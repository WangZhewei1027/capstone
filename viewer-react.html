<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTML Files Viewer - React Edition</title>

    <!-- React CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
    ></script>
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- D3.js for graph visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      h1 {
        text-align: center;
        color: white;
        margin-bottom: 30px;
        font-size: 2.5rem;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .workspace-selector {
        text-align: center;
        margin-bottom: 30px;
      }

      select {
        padding: 12px 20px;
        font-size: 16px;
        border: none;
        border-radius: 25px;
        background: white;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        cursor: pointer;
        transition: all 0.3s ease;
      }

      select:hover {
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        transform: translateY(-2px);
      }

      .grid-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        padding: 20px 0;
      }

      .html-card {
        background: white;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        cursor: pointer;
        position: relative;
      }

      .html-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
      }

      .card-preview {
        width: 100%;
        height: 200px;
        border: none;
        background: #f8f9fa;
      }

      .card-info {
        padding: 12px;
      }

      .card-buttons {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
      }

      .card-btn {
        flex: 1;
        padding: 6px 12px;
        font-size: 0.8rem;
        border: none;
        border-radius: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 500;
      }

      .card-btn.view {
        background: #4caf50;
        color: white;
      }

      .card-btn.fsm {
        background: #2196f3;
        color: white;
      }

      .card-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .card-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .card-title {
        font-size: 0.95rem;
        font-weight: 600;
        color: #333;
        margin-bottom: 8px;
        word-break: break-all;
      }

      .card-model {
        font-size: 0.9rem;
        color: #666;
        margin-bottom: 5px;
      }

      .card-timestamp {
        font-size: 0.8rem;
        color: #999;
      }

      .card-messages {
        margin-top: 10px;
        font-size: 0.85rem;
      }

      .message-item {
        margin-bottom: 6px;
        padding: 4px 8px;
        border-radius: 4px;
      }

      .message-system {
        background: #e3f2fd;
        border-left: 3px solid #2196f3;
      }

      .message-user {
        background: #f3e5f5;
        border-left: 3px solid #9c27b0;
      }

      .message-role {
        font-weight: 600;
        font-size: 0.75rem;
        text-transform: uppercase;
        margin-bottom: 2px;
      }

      .message-content {
        font-size: 0.8rem;
        line-height: 1.3;
        word-break: break-word;
      }

      .loading {
        text-align: center;
        color: white;
        font-size: 1.1rem;
        margin-top: 30px;
      }

      .error {
        text-align: center;
        color: #ff6b6b;
        font-size: 1.1rem;
        margin-top: 30px;
        background: white;
        padding: 20px;
        border-radius: 10px;
      }

      .no-files {
        text-align: center;
        color: white;
        font-size: 1.2rem;
        margin-top: 50px;
      }

      .filters-container {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 30px;
        backdrop-filter: blur(10px);
      }

      .filters-title {
        color: white;
        font-size: 1.2rem;
        margin-bottom: 15px;
        text-align: center;
      }

      .filters-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 15px;
      }

      .filter-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .filter-label {
        color: white;
        font-size: 0.9rem;
        font-weight: 500;
      }

      .filter-select,
      .filter-input {
        padding: 8px 12px;
        border: none;
        border-radius: 8px;
        background: white;
        font-size: 0.9rem;
        cursor: pointer;
      }

      .filter-input {
        cursor: text;
      }

      .filter-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 15px;
      }

      .filter-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 8px;
        background: white;
        color: #333;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .filter-btn:hover {
        background: #f0f0f0;
        transform: translateY(-1px);
      }

      .filter-btn.clear {
        background: #ff6b6b;
        color: white;
      }

      .filter-btn.clear:hover {
        background: #ff5252;
      }

      .results-count {
        color: white;
        text-align: center;
        margin-bottom: 10px;
        font-size: 0.9rem;
      }

      .filters-container {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 30px;
        backdrop-filter: blur(10px);
      }

      .filters-title {
        color: white;
        font-size: 1.2rem;
        margin-bottom: 15px;
        text-align: center;
      }

      .filters-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 15px;
      }

      .filter-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .filter-label {
        color: white;
        font-size: 0.9rem;
        font-weight: 500;
      }

      .filter-select,
      .filter-input {
        padding: 8px 12px;
        border: none;
        border-radius: 8px;
        background: white;
        font-size: 0.9rem;
        cursor: pointer;
      }

      .filter-input {
        cursor: text;
      }

      .filter-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 15px;
      }

      .filter-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 8px;
        background: white;
        color: #333;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .filter-btn:hover {
        background: #f0f0f0;
        transform: translateY(-1px);
      }

      .filter-btn.clear {
        background: #ff6b6b;
        color: white;
      }

      .filter-btn.clear:hover {
        background: #ff5252;
      }

      .results-count {
        color: white;
        text-align: center;
        margin-bottom: 10px;
        font-size: 0.9rem;
      }

      /* FSM Visualizer Modal Styles */
      .fsm-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 2000;
        display: none;
        overflow: auto;
      }

      .fsm-modal.show {
        display: block;
      }

      .fsm-modal-content {
        background: white;
        margin: 20px;
        border-radius: 15px;
        min-height: calc(100vh - 40px);
        position: relative;
      }

      .fsm-modal-header {
        padding: 20px;
        border-bottom: 2px solid #e0e0e0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 15px 15px 0 0;
      }

      .fsm-modal-title {
        font-size: 1.5rem;
        font-weight: 600;
      }

      .fsm-close-btn {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        font-size: 1.8rem;
        cursor: pointer;
        padding: 8px 12px;
        border-radius: 50%;
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
      }

      .fsm-close-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
      }

      .fsm-modal-body {
        padding: 20px;
      }

      .fsm-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }

      .info-panel {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 10px;
        border-left: 4px solid #4caf50;
      }

      .info-title {
        font-weight: 600;
        color: #333;
        margin-bottom: 10px;
        font-size: 1.1rem;
      }

      .info-content {
        color: #666;
        font-size: 0.9rem;
        line-height: 1.4;
      }

      .graph-container {
        width: 100%;
        height: 600px;
        border: 2px solid #e0e0e0;
        border-radius: 10px;
        background: #fafafa;
        position: relative;
        overflow: hidden;
        margin-bottom: 20px;
      }

      .state-node {
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .state-node:hover {
        filter: brightness(1.1);
      }

      .edge {
        fill: none;
        stroke: #666;
        stroke-width: 2;
        marker-end: url(#arrowhead);
        transition: all 0.3s ease;
      }

      .edge:hover {
        stroke: #4caf50;
        stroke-width: 3;
      }

      .legend {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 10px;
        padding: 15px;
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 100;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }

      .legend-title {
        font-weight: 600;
        margin-bottom: 10px;
        color: #333;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        font-size: 0.85rem;
      }

      .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        margin-right: 8px;
        border: 2px solid #333;
      }

      .screenshot-panel {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border-radius: 15px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        z-index: 3000;
        max-width: 80vw;
        max-height: 80vh;
        overflow: auto;
        display: none;
      }

      .screenshot-panel.show {
        display: block;
      }

      .screenshot-header {
        padding: 20px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .screenshot-title {
        font-size: 1.3rem;
        font-weight: 600;
        color: #333;
      }

      .screenshot-content {
        padding: 20px;
      }

      .screenshot-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
      }

      .screenshot-item {
        text-align: center;
      }

      .screenshot-img {
        width: 100%;
        max-width: 400px;
        border: 2px solid #ddd;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
      }

      .screenshot-img:hover {
        transform: scale(1.02);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
      }

      .screenshot-caption {
        margin-top: 10px;
        font-size: 0.9rem;
        color: #666;
        font-weight: 500;
      }

      .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 2999;
        display: none;
      }

      .overlay.show {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      // FSMçŠ¶æ€é…è‰²æ–¹æ¡ˆ - æŒ‰åŠŸèƒ½åˆ†ç±»
      const STATE_COLORS = {
        // å¼€å§‹çŠ¶æ€ - ç»¿è‰²ç³»
        idle: "#4caf50",

        // è¾“å…¥éªŒè¯ - æ©™è‰²ç³»
        validating_input: "#ff9800",
        validating_front_input: "#ff9800",
        validating_back_input: "#ffb74d",

        // æ‰§è¡ŒåŠ¨ä½œ - è“è‰²ç³»
        inserting_node: "#2196f3",
        adding_to_front: "#1976d2",
        adding_to_back: "#42a5f5",
        removing_from_front: "#ff5722",
        removing_from_back: "#ff7043",
        performing_front_removal: "#ff5722",
        performing_back_removal: "#ff7043",

        // æ˜¾ç¤ºæ›´æ–° - ç´«è‰²ç³»
        drawing_tree: "#9c27b0",
        updating_display: "#ab47bc",
        clearing_input: "#ba68c8",

        // é”™è¯¯å¤„ç† - çº¢è‰²ç³»
        error_alert: "#f44336",

        // ç»“æŸçŠ¶æ€ - ç°è‰²ç³»
        tree_resetting: "#607d8b",
      };

      // è·å–çŠ¶æ€ç±»å‹çš„å‡½æ•°
      const getStateCategory = (stateName) => {
        const name = stateName.toLowerCase();
        if (name.includes("idle") || name.includes("initial")) return "start";
        if (name.includes("validating") || name.includes("input"))
          return "input";
        if (
          name.includes("adding") ||
          name.includes("removing") ||
          name.includes("inserting") ||
          name.includes("performing")
        )
          return "action";
        if (
          name.includes("updating") ||
          name.includes("drawing") ||
          name.includes("display") ||
          name.includes("clearing")
        )
          return "display";
        if (name.includes("error") || name.includes("alert")) return "error";
        if (
          name.includes("resetting") ||
          name.includes("done") ||
          name.includes("complete")
        )
          return "end";
        return "action";
      };

      // æ™ºèƒ½æˆªå›¾-çŠ¶æ€åŒ¹é…å‡½æ•°
      const isScreenshotForState = (screenshot, stateName) => {
        // ç›´æ¥çŠ¶æ€åŒ¹é…
        if (screenshot.state === stateName) {
          return true;
        }

        const filename = screenshot.filename.toLowerCase();
        const state = stateName.toLowerCase();

        // ç›´æ¥æ–‡ä»¶ååŒ¹é…
        if (filename.includes(state)) {
          return true;
        }

        // ç‰¹æ®ŠçŠ¶æ€æ˜ å°„è§„åˆ™
        const stateMapping = {
          idle: ["initial", "empty", "idle"],
          validating_front_input: ["validating", "front", "input"],
          validating_back_input: ["validating", "back", "input"],
          adding_to_front: ["add_front", "front", "unshift"],
          adding_to_back: ["add_back", "back", "push"],
          removing_from_front: ["remove_front", "front", "shift"],
          removing_from_back: ["remove_back", "back", "pop"],
          performing_front_removal: ["remove_front", "front", "shift"],
          performing_back_removal: ["remove_back", "back", "pop"],
          updating_display: ["complete", "update", "display"],
          clearing_input: ["clear", "input"],
          // ä¼ ç»ŸBSTçŠ¶æ€
          validating_input: ["validating", "input"],
          error_alert: ["error", "alert"],
          inserting_node: ["inserting", "node", "tree_node"],
          drawing_tree: ["drawing", "tree", "tree_with"],
          tree_resetting: ["resetting", "reset"],
        };

        const keywords = stateMapping[state] || [state];
        return keywords.some((keyword) => filename.includes(keyword));
      };

      // ScreenshotPanel Component
      const ScreenshotPanel = ({
        show,
        onClose,
        selectedState,
        screenshots,
      }) => {
        if (!show) return null;

        // å¦‚æœæ²¡æœ‰é€‰æ‹©ç‰¹å®šçŠ¶æ€ï¼Œæ˜¾ç¤ºæ‰€æœ‰æˆªå›¾
        let stateScreenshots = screenshots;

        if (selectedState) {
          // ä½¿ç”¨åŒæ ·çš„æ™ºèƒ½åŒ¹é…å‡½æ•°
          stateScreenshots = screenshots.filter((imgItem) => {
            return isScreenshotForState(imgItem, selectedState);
          });
        }

        return (
          <>
            <div
              className={`overlay ${show ? "show" : ""}`}
              onClick={onClose}
            ></div>
            <div className={`screenshot-panel ${show ? "show" : ""}`}>
              <div className="screenshot-header">
                <div className="screenshot-title">
                  {selectedState ? `çŠ¶æ€æˆªå›¾: ${selectedState}` : "æ‰€æœ‰æˆªå›¾"}
                </div>
                <button className="fsm-close-btn" onClick={onClose}>
                  Ã—
                </button>
              </div>
              <div className="screenshot-content">
                {stateScreenshots.length > 0 ? (
                  <div className="screenshot-grid">
                    {stateScreenshots.map((screenshot, index) => (
                      <div key={index} className="screenshot-item">
                        <img
                          src={`http://localhost:3000${screenshot.url}`}
                          alt={`${selectedState || "State"} screenshot ${
                            index + 1
                          }`}
                          className="screenshot-img"
                          onError={(e) => {
                            e.target.style.display = "none";
                          }}
                        />
                        <div className="screenshot-caption">
                          {screenshot.filename.replace(".png", "")}
                        </div>
                      </div>
                    ))}
                  </div>
                ) : (
                  <div
                    style={{
                      textAlign: "center",
                      color: "#666",
                      padding: "40px",
                    }}
                  >
                    {selectedState
                      ? `æš‚æ—  ${selectedState} çŠ¶æ€çš„æˆªå›¾`
                      : "æš‚æ— æˆªå›¾"}
                  </div>
                )}
              </div>
            </div>
          </>
        );
      };

      // FSMGraph Component
      const FSMGraph = ({ fsmData, screenshots, onStateClick }) => {
        const svgRef = useRef();
        const [graphData, setGraphData] = useState({ nodes: [], links: [] });

        useEffect(() => {
          if (!fsmData) return;

          // æ„å»ºå›¾æ•°æ®
          const nodes = fsmData.states.map((state) => ({
            id: state.name,
            name: state.name,
            onEnter: state.onEnter,
            color: STATE_COLORS[state.name] || "#666",
            hasScreenshots: screenshots.some((img) => {
              // æ›´æ™ºèƒ½çš„æˆªå›¾-çŠ¶æ€åŒ¹é…
              return isScreenshotForState(img, state.name);
            }),
          }));

          const links = [];
          fsmData.states.forEach((state) => {
            if (state.on) {
              Object.entries(state.on).forEach(([event, target]) => {
                links.push({
                  source: state.name,
                  target: target,
                  event: event,
                });
              });
            }
          });

          setGraphData({ nodes, links });
        }, [fsmData, screenshots]);

        useEffect(() => {
          if (!graphData.nodes.length) return;

          const svg = d3.select(svgRef.current);
          svg.selectAll("*").remove();

          const width = 1000;
          const height = 550;

          // å®šä¹‰ç®­å¤´æ ‡è®°
          svg
            .append("defs")
            .append("marker")
            .attr("id", "arrowhead")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 25)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#666");

          const simulation = d3
            .forceSimulation(graphData.nodes)
            .force(
              "link",
              d3
                .forceLink(graphData.links)
                .id((d) => d.id)
                .distance(150)
            )
            .force("charge", d3.forceManyBody().strength(-800))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(60))
            .alpha(0.1) // é™ä½åˆå§‹èƒ½é‡ï¼Œå‡å°‘åŠ¨ç”»
            .alphaDecay(0.1) // å¿«é€Ÿè¡°å‡
            .velocityDecay(0.9); // å¢åŠ é˜»å°¼

          // æ™ºèƒ½å¸ƒå±€èŠ‚ç‚¹ä½ç½® - æ ¹æ®çŠ¶æ€ç±»å‹åˆ†ç»„
          const layoutNodesByType = (nodes, width, height) => {
            // æ ¹æ®çŠ¶æ€åç§°åˆ†ç±»
            const categories = {
              start: [], // å¼€å§‹çŠ¶æ€
              input: [], // è¾“å…¥å¤„ç†
              action: [], // æ‰§è¡ŒåŠ¨ä½œ
              display: [], // æ˜¾ç¤ºæ›´æ–°
              error: [], // é”™è¯¯å¤„ç†
              end: [], // ç»“æŸçŠ¶æ€
            };

            nodes.forEach((node) => {
              const name = node.name.toLowerCase();
              if (name.includes("idle") || name.includes("initial")) {
                categories.start.push(node);
              } else if (
                name.includes("validating") ||
                name.includes("input")
              ) {
                categories.input.push(node);
              } else if (
                name.includes("adding") ||
                name.includes("removing") ||
                name.includes("inserting") ||
                name.includes("performing")
              ) {
                categories.action.push(node);
              } else if (
                name.includes("updating") ||
                name.includes("drawing") ||
                name.includes("display") ||
                name.includes("clearing")
              ) {
                categories.display.push(node);
              } else if (name.includes("error") || name.includes("alert")) {
                categories.error.push(node);
              } else if (
                name.includes("resetting") ||
                name.includes("done") ||
                name.includes("complete")
              ) {
                categories.end.push(node);
              } else {
                // é»˜è®¤æ”¾å…¥actionåˆ†ç±»
                categories.action.push(node);
              }
            });

            // å®šä¹‰å„åˆ†ç±»çš„å¸ƒå±€åŒºåŸŸ
            const layouts = {
              start: { x: width * 0.15, y: height * 0.5, spread: 80 },
              input: { x: width * 0.35, y: height * 0.25, spread: 100 },
              action: { x: width * 0.5, y: height * 0.5, spread: 140 },
              display: { x: width * 0.75, y: height * 0.65, spread: 100 },
              error: { x: width * 0.25, y: height * 0.8, spread: 80 },
              end: { x: width * 0.85, y: height * 0.4, spread: 80 },
            };

            // ä¸ºæ¯ä¸ªåˆ†ç±»ä¸­çš„èŠ‚ç‚¹åˆ†é…ä½ç½®
            Object.keys(categories).forEach((category) => {
              const categoryNodes = categories[category];
              const layout = layouts[category];

              if (categoryNodes.length === 0) return;

              if (categoryNodes.length === 1) {
                // å•ä¸ªèŠ‚ç‚¹æ”¾åœ¨ä¸­å¿ƒï¼Œæ·»åŠ è½»å¾®éšæœºåç§»
                categoryNodes[0].x = layout.x + (Math.random() - 0.5) * 30;
                categoryNodes[0].y = layout.y + (Math.random() - 0.5) * 30;
              } else {
                // å¤šä¸ªèŠ‚ç‚¹æŒ‰ç…§ä¼˜åŒ–çš„åˆ†å¸ƒ
                categoryNodes.forEach((node, i) => {
                  if (categoryNodes.length === 2) {
                    // ä¸¤ä¸ªèŠ‚ç‚¹æ°´å¹³æˆ–å‚ç›´æ’åˆ—
                    const isVertical =
                      category === "input" || category === "display";
                    if (isVertical) {
                      node.x = layout.x + (Math.random() - 0.5) * 40;
                      node.y = layout.y + (i - 0.5) * 60;
                    } else {
                      node.x = layout.x + (i - 0.5) * 80;
                      node.y = layout.y + (Math.random() - 0.5) * 40;
                    }
                  } else if (categoryNodes.length === 3) {
                    // ä¸‰ä¸ªèŠ‚ç‚¹ä¸‰è§’å½¢æ’åˆ—
                    const angles = [0, (2 * Math.PI) / 3, (4 * Math.PI) / 3];
                    const radius = 50;
                    node.x = layout.x + Math.cos(angles[i]) * radius;
                    node.y = layout.y + Math.sin(angles[i]) * radius;
                  } else {
                    // å¤šä¸ªèŠ‚ç‚¹å°åœ†å½¢æ’åˆ—ï¼Œæ·»åŠ éšæœºåç§»
                    const angle = (i / categoryNodes.length) * 2 * Math.PI;
                    const radius =
                      layout.spread / 3 + (Math.random() - 0.5) * 20;
                    node.x = layout.x + Math.cos(angle) * radius;
                    node.y = layout.y + Math.sin(angle) * radius;
                  }
                });
              }
            });
          };

          // åº”ç”¨æ™ºèƒ½å¸ƒå±€
          layoutNodesByType(graphData.nodes, width, height);

          // æ·»åŠ åˆ†ç»„èƒŒæ™¯åŒºåŸŸ
          const addGroupBackgrounds = () => {
            const groupAreas = [
              {
                name: "å¼€å§‹",
                x: width * 0.05,
                y: height * 0.35,
                w: width * 0.2,
                h: height * 0.3,
                color: "#4caf50",
                opacity: 0.1,
              },
              {
                name: "è¾“å…¥éªŒè¯",
                x: width * 0.25,
                y: height * 0.1,
                w: width * 0.2,
                h: height * 0.3,
                color: "#ff9800",
                opacity: 0.1,
              },
              {
                name: "æ‰§è¡ŒåŠ¨ä½œ",
                x: width * 0.4,
                y: height * 0.3,
                w: width * 0.2,
                h: height * 0.4,
                color: "#2196f3",
                opacity: 0.1,
              },
              {
                name: "æ˜¾ç¤ºæ›´æ–°",
                x: width * 0.65,
                y: height * 0.45,
                w: width * 0.2,
                h: height * 0.3,
                color: "#9c27b0",
                opacity: 0.1,
              },
              {
                name: "é”™è¯¯å¤„ç†",
                x: width * 0.15,
                y: height * 0.65,
                w: width * 0.2,
                h: height * 0.25,
                color: "#f44336",
                opacity: 0.1,
              },
              {
                name: "ç»“æŸçŠ¶æ€",
                x: width * 0.75,
                y: height * 0.25,
                w: width * 0.2,
                h: height * 0.3,
                color: "#607d8b",
                opacity: 0.1,
              },
            ];

            // æ·»åŠ èƒŒæ™¯çŸ©å½¢
            svg
              .append("g")
              .attr("class", "group-backgrounds")
              .selectAll("rect")
              .data(groupAreas)
              .enter()
              .append("rect")
              .attr("x", (d) => d.x)
              .attr("y", (d) => d.y)
              .attr("width", (d) => d.w)
              .attr("height", (d) => d.h)
              .attr("fill", (d) => d.color)
              .attr("opacity", (d) => d.opacity)
              .attr("rx", 15)
              .attr("ry", 15)
              .attr("stroke", (d) => d.color)
              .attr("stroke-width", 1)
              .attr("stroke-opacity", 0.3);

            // æ·»åŠ åˆ†ç»„æ ‡ç­¾
            svg
              .append("g")
              .attr("class", "group-labels")
              .selectAll("text")
              .data(groupAreas)
              .enter()
              .append("text")
              .attr("x", (d) => d.x + 10)
              .attr("y", (d) => d.y + 20)
              .attr("font-size", "11px")
              .attr("font-weight", "bold")
              .attr("fill", (d) => d.color)
              .attr("opacity", 0.7)
              .text((d) => d.name);
          };

          addGroupBackgrounds();

          // ç«‹å³åœæ­¢æ¨¡æ‹Ÿä»¥å›ºå®šä½ç½®
          simulation.stop();

          // åˆ›å»ºè¿çº¿
          const link = svg
            .append("g")
            .selectAll("path")
            .data(graphData.links)
            .join("path")
            .attr("class", "edge")
            .attr("stroke", "#666")
            .attr("stroke-width", 2)
            .attr("fill", "none")
            .attr("marker-end", "url(#arrowhead)");

          // åˆ›å»ºè¿çº¿æ ‡ç­¾
          const linkLabel = svg
            .append("g")
            .selectAll("text")
            .data(graphData.links)
            .join("text")
            .attr("font-size", "10px")
            .attr("text-anchor", "middle")
            .attr("fill", "#333")
            .text((d) => d.event);

          // åˆ›å»ºèŠ‚ç‚¹
          const node = svg
            .append("g")
            .selectAll("g")
            .data(graphData.nodes)
            .join("g")
            .attr("class", "state-node")
            .style("cursor", "pointer");

          // èŠ‚ç‚¹åœ†åœˆ
          node
            .append("circle")
            .attr("r", (d) => (d.hasScreenshots ? 35 : 30))
            .attr("fill", (d) => d.color)
            .attr("stroke", (d) => (d.hasScreenshots ? "#fff" : "none"))
            .attr("stroke-width", (d) => (d.hasScreenshots ? 3 : 0))
            .attr("opacity", 0.9);

          // æˆªå›¾æŒ‡ç¤ºå™¨
          node
            .filter((d) => d.hasScreenshots)
            .append("circle")
            .attr("r", 8)
            .attr("cx", 25)
            .attr("cy", -25)
            .attr("fill", "#ff6b6b")
            .attr("stroke", "#fff")
            .attr("stroke-width", 2);

          node
            .filter((d) => d.hasScreenshots)
            .append("text")
            .attr("x", 25)
            .attr("y", -25)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "central")
            .attr("fill", "white")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .text("ğŸ“·");

          // èŠ‚ç‚¹æ ‡ç­¾
          node
            .append("text")
            .attr("font-size", "11px")
            .attr("font-weight", "600")
            .attr("fill", "white")
            .attr("text-anchor", "middle")
            .text((d) => d.name);

          // èŠ‚ç‚¹äº¤äº’
          node.on("click", (event, d) => {
            // é‡ç½®æ‰€æœ‰èŠ‚ç‚¹æ ·å¼
            node
              .select("circle")
              .attr("stroke-width", (d) => (d.hasScreenshots ? 3 : 0));

            // é«˜äº®å½“å‰èŠ‚ç‚¹
            d3.select(event.currentTarget)
              .select("circle")
              .attr("stroke", "#ff6b6b")
              .attr("stroke-width", 5);

            onStateClick(d.name);
          });

          // ç«‹å³æ›´æ–°ä½ç½®å‡½æ•°
          const updatePositions = () => {
            link.attr("d", (d) => {
              const dx = d.target.x - d.source.x;
              const dy = d.target.y - d.source.y;
              const dr = Math.sqrt(dx * dx + dy * dy);

              // è®¡ç®—åœ†åœˆè¾¹ç¼˜çš„ç‚¹
              const sourceX = d.source.x + (dx * 35) / dr;
              const sourceY = d.source.y + (dy * 35) / dr;
              const targetX = d.target.x - (dx * 35) / dr;
              const targetY = d.target.y - (dy * 35) / dr;

              return `M${sourceX},${sourceY}L${targetX},${targetY}`;
            });

            linkLabel
              .attr("x", (d) => (d.source.x + d.target.x) / 2)
              .attr("y", (d) => (d.source.y + d.target.y) / 2);

            node.attr("transform", (d) => `translate(${d.x},${d.y})`);
          };

          // æ‹–æ‹½åŠŸèƒ½ï¼ˆä¼˜åŒ–ä¸ºé™æ€æ¨¡å¼ï¼‰
          const drag = d3
            .drag()
            .on("start", (event, d) => {
              // ä»…åœ¨æ‹–æ‹½æ—¶å¯åŠ¨å¾®å¼±çš„æ¨¡æ‹Ÿ
              simulation.alpha(0.1).restart();
              d.fx = d.x;
              d.fy = d.y;
            })
            .on("drag", (event, d) => {
              d.fx = event.x;
              d.fy = event.y;
              // ç«‹å³æ›´æ–°ä½ç½®
              updatePositions();
            })
            .on("end", (event, d) => {
              // åœæ­¢æ¨¡æ‹Ÿå¹¶é‡Šæ”¾å›ºå®šä½ç½®
              simulation.alpha(0);
              d.fx = null;
              d.fy = null;
            });

          node.call(drag);

          // ç«‹å³æ›´æ–°ä½ç½®ï¼Œæ— åŠ¨ç”»
          updatePositions();

          // åªåœ¨æ‹–æ‹½æ—¶ä½¿ç”¨tickæ›´æ–°
          simulation.on("tick", updatePositions);
        }, [graphData, onStateClick]);

        return (
          <div className="graph-container">
            <svg ref={svgRef} width="100%" height="100%"></svg>
            <div className="legend">
              <div className="legend-title">çŠ¶æ€åˆ†ç±»å¸ƒå±€</div>
              <div className="legend-item">
                <div
                  className="legend-color"
                  style={{ backgroundColor: "#4caf50" }}
                ></div>
                <span>å¼€å§‹çŠ¶æ€ (å·¦ä¾§)</span>
              </div>
              <div className="legend-item">
                <div
                  className="legend-color"
                  style={{ backgroundColor: "#ff9800" }}
                ></div>
                <span>è¾“å…¥éªŒè¯ (å·¦ä¸Š)</span>
              </div>
              <div className="legend-item">
                <div
                  className="legend-color"
                  style={{ backgroundColor: "#2196f3" }}
                ></div>
                <span>æ‰§è¡ŒåŠ¨ä½œ (ä¸­å¿ƒ)</span>
              </div>
              <div className="legend-item">
                <div
                  className="legend-color"
                  style={{ backgroundColor: "#9c27b0" }}
                ></div>
                <span>æ˜¾ç¤ºæ›´æ–° (å³ä¸‹)</span>
              </div>
              <div className="legend-item">
                <div
                  className="legend-color"
                  style={{ backgroundColor: "#f44336" }}
                ></div>
                <span>é”™è¯¯å¤„ç† (å·¦ä¸‹)</span>
              </div>
              <div className="legend-item">
                <div
                  className="legend-color"
                  style={{ backgroundColor: "#607d8b" }}
                ></div>
                <span>ç»“æŸçŠ¶æ€ (å³ä¾§)</span>
              </div>
              <div
                className="legend-item"
                style={{ marginTop: "10px", fontSize: "11px" }}
              >
                <span>ğŸ“· = æœ‰æˆªå›¾å¯æŸ¥çœ‹</span>
              </div>
              <div
                className="legend-item"
                style={{ fontSize: "10px", color: "#666" }}
              >
                <span>æ‹–æ‹½èŠ‚ç‚¹å¯è°ƒæ•´ä½ç½®</span>
              </div>
            </div>
          </div>
        );
      };

      // FSMVisualizerModal Component
      const FSMVisualizerModal = ({ show, onClose, fileId, workspace }) => {
        const [fsmData, setFsmData] = useState(null);
        const [screenshots, setScreenshots] = useState([]);
        const [selectedState, setSelectedState] = useState("");
        const [showScreenshots, setShowScreenshots] = useState(false);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState("");

        useEffect(() => {
          if (show && fileId && workspace) {
            loadFSMData();
          }
        }, [show, fileId, workspace]);

        const loadFSMData = async () => {
          setLoading(true);
          setError("");

          try {
            // åŠ è½½FSMæ•°æ®
            const fsmResponse = await fetch(
              `http://localhost:3000/api/fsm-data/${workspace}/${fileId}.html`
            );
            if (fsmResponse.ok) {
              const fsm = await fsmResponse.json();
              setFsmData(fsm);
            } else {
              throw new Error("æ— æ³•åŠ è½½FSMæ•°æ®");
            }

            // åŠ è½½æˆªå›¾
            const screenshotResponse = await fetch(
              `http://localhost:3000/api/screenshots/${workspace}/${fileId}.html`
            );
            if (screenshotResponse.ok) {
              const screenshots = await screenshotResponse.json();
              setScreenshots(screenshots);
            }
          } catch (error) {
            setError(error.message);
            console.error("åŠ è½½FSMæ•°æ®å¤±è´¥:", error);
          } finally {
            setLoading(false);
          }
        };

        const handleStateClick = (stateName) => {
          setSelectedState(stateName);
          setShowScreenshots(true);
        };

        const closeScreenshots = () => {
          setShowScreenshots(false);
          setSelectedState("");
        };

        if (!show) return null;

        return (
          <div className="fsm-modal show">
            <div className="fsm-modal-content">
              <div className="fsm-modal-header">
                <div className="fsm-modal-title">
                  ğŸ”„ FSM State Machine: {fileId}
                </div>
                <button className="fsm-close-btn" onClick={onClose}>
                  Ã—
                </button>
              </div>

              <div className="fsm-modal-body">
                {error && (
                  <div className="error" style={{ marginBottom: "20px" }}>
                    {error}
                  </div>
                )}

                {loading && (
                  <div
                    className="loading"
                    style={{ textAlign: "center", padding: "40px" }}
                  >
                    åŠ è½½ä¸­...
                  </div>
                )}

                {fsmData && (
                  <>
                    <div className="fsm-info">
                      <div className="info-panel">
                        <div className="info-title">ğŸ“‹ FSM ä¿¡æ¯</div>
                        <div className="info-content">
                          <strong>ä¸»é¢˜:</strong> {fsmData.topic}
                          <br />
                          <strong>çŠ¶æ€æ•°:</strong> {fsmData.states?.length || 0}
                          <br />
                          <strong>äº‹ä»¶æ•°:</strong> {fsmData.events?.length || 0}
                          <br />
                          <strong>æˆªå›¾æ•°:</strong> {screenshots.length}
                        </div>
                      </div>
                      <div className="info-panel">
                        <div className="info-title">ğŸ’¡ æ“ä½œè¯´æ˜</div>
                        <div className="info-content">
                          â€¢ ç‚¹å‡»çŠ¶æ€èŠ‚ç‚¹æŸ¥çœ‹å¯¹åº”æˆªå›¾
                          <br />
                          â€¢ æ‹–æ‹½èŠ‚ç‚¹è°ƒæ•´å¸ƒå±€
                          <br />
                          â€¢ ç®­å¤´è¡¨ç¤ºçŠ¶æ€è½¬æ¢
                          <br />â€¢ ğŸ“· è¡¨ç¤ºè¯¥çŠ¶æ€æœ‰æˆªå›¾
                        </div>
                      </div>
                    </div>

                    <FSMGraph
                      fsmData={fsmData}
                      screenshots={screenshots}
                      onStateClick={handleStateClick}
                    />

                    {screenshots.length > 0 && (
                      <div style={{ textAlign: "center", marginTop: "20px" }}>
                        <button
                          className="card-btn view"
                          onClick={() => setShowScreenshots(true)}
                          style={{ padding: "10px 20px", fontSize: "1rem" }}
                        >
                          æŸ¥çœ‹æ‰€æœ‰æˆªå›¾ ({screenshots.length})
                        </button>
                      </div>
                    )}
                  </>
                )}
              </div>
            </div>

            <ScreenshotPanel
              show={showScreenshots}
              onClose={closeScreenshots}
              selectedState={selectedState}
              screenshots={screenshots}
            />
          </div>
        );
      };

      // FilterControls Component
      const FilterControls = ({
        filters,
        onFilterChange,
        onClearFilters,
        allData,
      }) => {
        // è·å–æ‰€æœ‰å¯ç”¨çš„æ¨¡å‹
        const availableModels = [
          ...new Set(Object.values(allData).map((item) => item.model)),
        ].sort();

        // è·å–æ‰€æœ‰å¯ç”¨çš„æ ‡ç­¾
        const availableTags = [
          ...new Set(Object.values(allData).flatMap((item) => item.tags || [])),
        ].sort();

        return (
          <div className="filters-container">
            <div className="filters-title">ğŸ” ç­›é€‰å™¨</div>

            <div className="filters-grid">
              <div className="filter-group">
                <div className="filter-label">æ¨¡å‹</div>
                <select
                  className="filter-select"
                  value={filters.model}
                  onChange={(e) => onFilterChange("model", e.target.value)}
                >
                  <option value="">æ‰€æœ‰æ¨¡å‹</option>
                  {availableModels.map((model) => (
                    <option key={model} value={model}>
                      {model}
                    </option>
                  ))}
                </select>
              </div>

              <div className="filter-group">
                <div className="filter-label">æ ‡ç­¾</div>
                <select
                  className="filter-select"
                  value={filters.tag}
                  onChange={(e) => onFilterChange("tag", e.target.value)}
                >
                  <option value="">æ‰€æœ‰æ ‡ç­¾</option>
                  {availableTags.map((tag) => (
                    <option key={tag} value={tag}>
                      {tag}
                    </option>
                  ))}
                </select>
              </div>

              <div className="filter-group">
                <div className="filter-label">é—®é¢˜å…³é”®è¯</div>
                <input
                  type="text"
                  className="filter-input"
                  placeholder="è¾“å…¥å…³é”®è¯..."
                  value={filters.question}
                  onChange={(e) => onFilterChange("question", e.target.value)}
                />
              </div>

              <div className="filter-group">
                <div className="filter-label">æ—¥æœŸèŒƒå›´</div>
                <select
                  className="filter-select"
                  value={filters.dateRange}
                  onChange={(e) => onFilterChange("dateRange", e.target.value)}
                >
                  <option value="">æ‰€æœ‰æ—¶é—´</option>
                  <option value="today">ä»Šå¤©</option>
                  <option value="week">è¿‘ä¸€å‘¨</option>
                  <option value="month">è¿‘ä¸€æœˆ</option>
                </select>
              </div>
            </div>

            <div className="filter-buttons">
              <button className="filter-btn clear" onClick={onClearFilters}>
                æ¸…é™¤ç­›é€‰
              </button>
            </div>
          </div>
        );
      };

      // WorkspaceSelector Component
      const WorkspaceSelector = ({
        onWorkspaceChange,
        workspaces,
        loading,
        error,
      }) => {
        return (
          <div className="workspace-selector">
            <select
              onChange={(e) => onWorkspaceChange(e.target.value)}
              disabled={loading}
            >
              <option value="">é€‰æ‹©å·¥ä½œç©ºé—´...</option>
              {workspaces.map((workspace) => (
                <option
                  key={workspace.name}
                  value={workspace.name}
                  disabled={!workspace.hasData}
                >
                  {workspace.name}
                  {workspace.hasData ? "" : " (æ•°æ®ä¸å®Œæ•´)"}
                </option>
              ))}
            </select>
            {error && (
              <div className="error" style={{ marginTop: "10px" }}>
                {error}
              </div>
            )}
          </div>
        );
      };

      // Message Component
      const Message = ({ message }) => {
        const roleClass = `message-${message.role}`;
        const roleText =
          message.role === "system"
            ? "ç³»ç»Ÿ"
            : message.role === "user"
            ? "ç”¨æˆ·"
            : message.role;

        return (
          <div className={`message-item ${roleClass}`}>
            <div className="message-role">{roleText}</div>
            <div className="message-content">{message.content}</div>
          </div>
        );
      };

      // HtmlCard Component
      const HtmlCard = ({ data, workspace, fileId, onFSMClick }) => {
        const handleViewClick = () => {
          window.open(`./workspace/${workspace}/html/${fileId}.html`, "_blank");
        };

        const handleFSMClick = (e) => {
          e.stopPropagation();
          onFSMClick(fileId);
        };

        return (
          <div className="html-card">
            <iframe
              className="card-preview"
              src={`./workspace/${workspace}/html/${fileId}.html`}
              scrolling="no"
              title={`Preview of ${fileId}`}
            />
            <div className="card-info">
              <div className="card-buttons">
                <button className="card-btn view" onClick={handleViewClick}>
                  æŸ¥çœ‹é¡µé¢
                </button>
                <button className="card-btn fsm" onClick={handleFSMClick}>
                  FSM å¯è§†åŒ–
                </button>
              </div>
              <div className="card-title">{fileId}</div>
              <div className="card-model">æ¨¡å‹: {data.model}</div>
              <div className="card-timestamp">
                {new Date(data.timestamp).toLocaleString("zh-CN")}
              </div>
              {data.messages && data.messages.length > 0 && (
                <div className="card-messages">
                  {data.messages.map((message, index) => (
                    <Message key={index} message={message} />
                  ))}
                </div>
              )}
            </div>
          </div>
        );
      };

      // GridContainer Component
      const GridContainer = ({
        htmlFiles,
        currentData,
        workspace,
        loading,
        totalCount,
        onFSMClick,
      }) => {
        if (loading) {
          return <div className="loading">åŠ è½½ä¸­...</div>;
        }

        if (htmlFiles.length === 0 && totalCount > 0) {
          return <div className="no-files">æ²¡æœ‰ç¬¦åˆç­›é€‰æ¡ä»¶çš„æ–‡ä»¶</div>;
        }

        if (htmlFiles.length === 0) {
          return <div className="no-files">å½“å‰å·¥ä½œç©ºé—´æ²¡æœ‰HTMLæ–‡ä»¶</div>;
        }

        const filteredCount = htmlFiles.filter(
          (fileId) => currentData[fileId]
        ).length;

        return (
          <>
            {totalCount > 0 && (
              <div className="results-count">
                æ˜¾ç¤º {filteredCount} / {totalCount} ä¸ªæ–‡ä»¶
              </div>
            )}
            <div className="grid-container">
              {htmlFiles.map((fileId) => {
                const data = currentData[fileId];
                if (!data) return null;

                return (
                  <HtmlCard
                    key={fileId}
                    data={data}
                    workspace={workspace}
                    fileId={fileId}
                    onFSMClick={onFSMClick}
                  />
                );
              })}
            </div>
          </>
        );
      };

      // Main App Component
      const App = () => {
        const [workspaces, setWorkspaces] = useState([]);
        const [currentWorkspace, setCurrentWorkspace] = useState("");
        const [currentData, setCurrentData] = useState({});
        const [htmlFiles, setHtmlFiles] = useState([]);
        const [allFiles, setAllFiles] = useState([]);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState("");
        const [filters, setFilters] = useState({
          model: "",
          tag: "",
          question: "",
          dateRange: "",
        });

        // FSMç›¸å…³çŠ¶æ€
        const [showFSMModal, setShowFSMModal] = useState(false);
        const [currentFSMFile, setCurrentFSMFile] = useState("");

        // Load workspaces on mount
        useEffect(() => {
          loadWorkspaces();
        }, []);

        const loadWorkspaces = async () => {
          try {
            // å°è¯•ä»APIè·å–å·¥ä½œç©ºé—´åˆ—è¡¨
            const response = await fetch(
              "http://localhost:3000/api/workspaces"
            );
            if (!response.ok) {
              throw new Error("APIæœåŠ¡å™¨æœªå¯åŠ¨æˆ–æ— æ³•è®¿é—®");
            }

            const workspaceData = await response.json();
            setWorkspaces(workspaceData);
            console.log(`âœ… æˆåŠŸåŠ è½½ ${workspaceData.length} ä¸ªå·¥ä½œç©ºé—´`);
          } catch (apiError) {
            console.warn("APIä¸å¯ç”¨ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ:", apiError.message);

            // å¤‡ç”¨æ–¹æ¡ˆï¼šæ‰‹åŠ¨æ·»åŠ å·²çŸ¥å·¥ä½œç©ºé—´
            const fallbackWorkspaces = [
              { name: "10-04", hasData: true },
              { name: "test", hasData: true },
            ];
            setWorkspaces(fallbackWorkspaces);

            setError(
              "APIæœåŠ¡å™¨æœªå¯åŠ¨ï¼Œä½¿ç”¨ç¦»çº¿æ¨¡å¼ã€‚è¯·è¿è¡Œ 'node api.mjs' å¯åŠ¨æœåŠ¡å™¨ä»¥è·å¾—å®Œæ•´åŠŸèƒ½ã€‚"
            );
          }
        };

        const loadWorkspaceData = async (workspace) => {
          if (!workspace) {
            setHtmlFiles([]);
            setCurrentData({});
            return;
          }

          setLoading(true);
          setError("");

          try {
            // é¦–å…ˆå°è¯•ä»APIè·å–æ•°æ®
            let data;
            try {
              const apiResponse = await fetch(
                `http://localhost:3000/api/workspaces/${workspace}/data`
              );
              if (apiResponse.ok) {
                data = await apiResponse.json();
                console.log(`âœ… ä»APIåŠ è½½å·¥ä½œç©ºé—´ ${workspace} çš„æ•°æ®`);
              } else {
                throw new Error("APIå“åº”å¤±è´¥");
              }
            } catch (apiError) {
              console.warn("APIä¸å¯ç”¨ï¼Œä½¿ç”¨ç›´æ¥è®¿é—®:", apiError.message);
              // å¤‡ç”¨æ–¹æ¡ˆï¼šç›´æ¥è®¿é—®æ–‡ä»¶
              const dataResponse = await fetch(
                `./workspace/${workspace}/data/data.json`
              );
              if (!dataResponse.ok) {
                throw new Error(`æ— æ³•åŠ è½½ ${workspace} çš„æ•°æ®æ–‡ä»¶`);
              }
              data = await dataResponse.json();
            }

            const newCurrentData = {};
            // å°†æ•°æ®æŒ‰IDç´¢å¼•
            data.forEach((item) => {
              newCurrentData[item.id] = item;
            });

            setCurrentData(newCurrentData);
            // è·å–HTMLæ–‡ä»¶åˆ—è¡¨ï¼ˆæ ¹æ®æ•°æ®æ¨æ–­ï¼‰
            const fileIds = data.map((item) => item.id);
            setAllFiles(fileIds);
            setHtmlFiles(fileIds);

            // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯ï¼ˆå¦‚æœAPIå¯ç”¨ï¼‰
            try {
              const statsResponse = await fetch(
                `http://localhost:3000/api/workspaces/${workspace}/stats`
              );
              if (statsResponse.ok) {
                const stats = await statsResponse.json();
                console.log(`ğŸ“Š å·¥ä½œç©ºé—´ç»Ÿè®¡:`, stats);
              }
            } catch (statsError) {
              // ç»Ÿè®¡ä¿¡æ¯è·å–å¤±è´¥ä¸å½±å“ä¸»è¦åŠŸèƒ½
            }
          } catch (error) {
            setError(error.message);
            console.error("åŠ è½½æ•°æ®å¤±è´¥:", error);
          } finally {
            setLoading(false);
          }
        };

        const handleWorkspaceChange = (workspace) => {
          setCurrentWorkspace(workspace);
          loadWorkspaceData(workspace);
          // é‡ç½®ç­›é€‰å™¨
          setFilters({
            model: "",
            tag: "",
            question: "",
            dateRange: "",
          });
        };

        // ç­›é€‰åŠŸèƒ½
        const applyFilters = (data, filterOptions) => {
          return data.filter((fileId) => {
            const item = currentData[fileId];
            if (!item) return false;

            // æ¨¡å‹ç­›é€‰
            if (filterOptions.model && item.model !== filterOptions.model) {
              return false;
            }

            // æ ‡ç­¾ç­›é€‰
            if (
              filterOptions.tag &&
              (!item.tags || !item.tags.includes(filterOptions.tag))
            ) {
              return false;
            }

            // é—®é¢˜å…³é”®è¯ç­›é€‰
            if (
              filterOptions.question &&
              !item.question
                .toLowerCase()
                .includes(filterOptions.question.toLowerCase())
            ) {
              return false;
            }

            // æ—¥æœŸèŒƒå›´ç­›é€‰
            if (filterOptions.dateRange) {
              const itemDate = new Date(item.timestamp);
              const now = new Date();
              const diffTime = Math.abs(now - itemDate);
              const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

              switch (filterOptions.dateRange) {
                case "today":
                  if (diffDays > 1) return false;
                  break;
                case "week":
                  if (diffDays > 7) return false;
                  break;
                case "month":
                  if (diffDays > 30) return false;
                  break;
              }
            }

            return true;
          });
        };

        // å¤„ç†ç­›é€‰å™¨å˜åŒ–
        const handleFilterChange = (key, value) => {
          const newFilters = { ...filters, [key]: value };
          setFilters(newFilters);

          // åº”ç”¨ç­›é€‰
          const filteredFiles = applyFilters(allFiles, newFilters);
          setHtmlFiles(filteredFiles);
        };

        // æ¸…é™¤ç­›é€‰
        const handleClearFilters = () => {
          const emptyFilters = {
            model: "",
            tag: "",
            question: "",
            dateRange: "",
          };
          setFilters(emptyFilters);
          setHtmlFiles(allFiles);
        };

        // FSMç›¸å…³å¤„ç†å‡½æ•°
        const handleFSMClick = (fileId) => {
          setCurrentFSMFile(fileId);
          setShowFSMModal(true);
        };

        const closeFSMModal = () => {
          setShowFSMModal(false);
          setCurrentFSMFile("");
        };

        return (
          <div className="container">
            <h1>HTML Files Viewer - React Edition</h1>

            <WorkspaceSelector
              onWorkspaceChange={handleWorkspaceChange}
              workspaces={workspaces}
              loading={loading}
              error={error}
            />

            {currentWorkspace && Object.keys(currentData).length > 0 && (
              <FilterControls
                filters={filters}
                onFilterChange={handleFilterChange}
                onClearFilters={handleClearFilters}
                allData={currentData}
              />
            )}

            <GridContainer
              htmlFiles={htmlFiles}
              currentData={currentData}
              workspace={currentWorkspace}
              loading={loading}
              totalCount={allFiles.length}
              onFSMClick={handleFSMClick}
            />

            <FSMVisualizerModal
              show={showFSMModal}
              onClose={closeFSMModal}
              fileId={currentFSMFile}
              workspace={currentWorkspace}
            />
          </div>
        );
      };

      // Render the app
      ReactDOM.render(<App />, document.getElementById("root"));
    </script>
  </body>
</html>
