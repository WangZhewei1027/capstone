
Here's an interactive Bubble Sort visualization in a single HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Sort Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        .container {
            background-color: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .visualization {
            display: flex;
            align-items: flex-end;
            height: 300px;
            margin: 30px 0;
            padding: 20px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            overflow: hidden;
        }
        .bar {
            flex: 1;
            background-color: #3498db;
            margin: 0 2px;
            border-radius: 4px 4px 0 0;
            transition: height 0.3s, background-color 0.3s;
        }
        .comparing {
            background-color: #e74c3c !important;
        }
        .sorted {
            background-color: #2ecc71 !important;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        button {
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }
        .explanation {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-top: 30px;
            line-height: 1.6;
        }
        .algorithm-steps {
            margin-top: 15px;
            padding-left: 20px;
        }
        .counter {
            margin-top: 15px;
            font-weight: bold;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bubble Sort Visualization</h1>
        
        <div class="visualization" id="visualization"></div>
        
        <div class="counter">
            Comparisons: <span id="comparison-count">0</span> | 
            Swaps: <span id="swap-count">0</span> | 
            Passes: <span id="pass-count">0</span>
        </div>
        
        <div class="controls">
            <button id="start-btn">Start Sorting</button>
            <button id="reset-btn">Reset Array</button>
            <button id="step-btn">Step Forward</button>
        </div>
        
        <div class="speed-control">
            <label for="speed-slider">Animation Speed:</label>
            <input type="range" id="speed-slider" min="1" max="200" value="50">
            <span id="speed-value">Medium</span>
        </div>
        
        <div class="explanation">
            <h3>How Bubble Sort Works</h3>
            <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, 
            compares adjacent elements and swaps them if they are in the wrong order.</p>
            
            <div class="algorithm-steps">
                <p>1. Start at the beginning of the array</p>
                <p>2. Compare each pair of adjacent elements</p>
                <p>3. If elements are in wrong order, swap them</p>
                <p>4. After each pass, the largest unsorted element "bubbles up" to its correct position</p>
                <p>5. Repeat until no more swaps are needed</p>
            </div>
            
            <p><strong>Time Complexity:</strong> O(nÂ²) in worst and average cases</p>
        </div>
    </div>

    <script>
        // Configuration constants
        const ARRAY_SIZE = 20;
        const MIN_VALUE = 20;
        const MAX_VALUE = 280;
        
        // State management
        let array = [];
        let isSorting = false;
        let comparisonCount = 0;
        let swapCount = 0;
        let passCount = 0;
        let i = 0;
        let j = 0;
        let speed = 100;
        let timeoutId = null;
        
        // DOM Elements
        const visualization = document.getElementById('visualization');
        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');
        const stepBtn = document.getElementById('step-btn');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        const comparisonCountEl = document.getElementById('comparison-count');
        const swapCountEl = document.getElementById('swap-count');
        const passCountEl = document.getElementById('pass-count');
        
        // Initialize visualization
        function init() {
            generateRandomArray();
            renderBars();
            addEventListeners();
            updateSpeedLabel();
        }
        
        // Generate random array
        function generateRandomArray() {
            array = [];
            for (let i = 0; i < ARRAY_SIZE; i++) {
                array.push(Math.floor(Math.random() * (MAX_VALUE - MIN_VALUE + 1) + MIN_VALUE));
            }
            resetState();
        }
        
        // Reset algorithm state
        function resetState() {
            i = 0;
            j = 0;
            comparisonCount = 0;
            swapCount = 0;
            passCount = 0;
            updateCounters();
            clearTimeout(timeoutId);
            isSorting = false;
            startBtn.textContent = "Start Sorting";
            stepBtn.disabled = false;
        }
        
        // Update counters display
        function updateCounters() {
            comparisonCountEl.textContent = comparisonCount;
            swapCountEl.textContent = swapCount;
            passCountEl.textContent = passCount;
        }
        
        // Render bars based on current array state
        function renderBars() {
            visualization.innerHTML = '';
            array.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = `${value}px`;
                
                // Highlight elements being compared
                if (index === j || index === j+1) {
                    bar.classList.add('comparing');
                }
                
                // Highlight sorted elements
                if (index > array.length - i - 1) {
                    bar.classList.add('sorted');
                }
                
                // Display value on top of bar
                const valueLabel = document.createElement('div');
                valueLabel.textContent = value;
                valueLabel.style.textAlign = 'center';
                valueLabel.style.marginTop = '5px';
                valueLabel.style.fontSize = '12px';
                bar.appendChild(valueLabel);
                
                visualization.appendChild(bar);
            });
        }
        
        // Perform one step of bubble sort
        function bubbleSortStep() {
            if (i < array.length - 1) {
                if (j < array.length - i - 1) {
                    comparisonCount++;
                    
                    // Compare adjacent elements
                    if (array[j] > array[j + 1]) {
                        // Swap elements
                        [array[j], array[j + 1]] = [array[j + 1], array[j]];
                        swapCount++;
                    }
                    j++;
                } else {
                    // Completed a pass
                    j = 0;
                    i++;
                    passCount++;
                }
                updateCounters();
                renderBars();
                return true;
            }
            return false;
        }
        
        // Animation controller
        function animateSort() {
            if (!isSorting) return;
            
            const hasMoreSteps = bubbleSortStep();
            
            if (hasMoreSteps) {
                timeoutId = setTimeout(animateSort, speed);
            } else {
                isSorting = false;
                startBtn.textContent = "Start Sorting";
                stepBtn.disabled = false;
            }
        }
        
        // Event handlers
        function addEventListeners() {
            startBtn.addEventListener('click', () => {
                if (isSorting) {
                    // Pause sorting
                    isSorting = false;
                    startBtn.textContent = "Resume Sorting";
                    clearTimeout(timeoutId);
                } else {
                    // Start/resume sorting
                    isSorting = true;
                    startBtn.textContent = "Pause Sorting";
                    stepBtn.disabled = true;
                    animateSort();
                }
            });
            
            resetBtn.addEventListener('click', () => {
                generateRandomArray();
                renderBars();
            });
            
            stepBtn.addEventListener('click', () => {
                if (!isSorting) {
                    const hasMoreSteps = bubbleSortStep();
                    if (!hasMoreSteps) {
                        stepBtn.disabled = true;
                    }
                }
            });
            
            speedSlider.addEventListener('input', () => {
                // Map slider value to delay (reverse scale: low slider = high speed)
                speed = 220 - speedSlider.value;
                updateSpeedLabel();
            });
        }
        
        // Update speed label based on slider value
        function updateSpeedLabel() {
            const sliderValue = speedSlider.value;
            if (sliderValue < 33) {
                speedValue.textContent = "Fast";
            } else if (sliderValue < 66) {
                speedValue.textContent = "Medium";
            } else {
                speedValue.textContent = "Slow";
            }
        }
        
        // Initialize when page loads
        window.onload = init;
    </script>
</body>
</html>
```

This visualization demonstrates the Bubble Sort algorithm with:

1. **Interactive Visual Representation**:
   - Color-coded bars showing comparison states (red) and sorted elements (green)
   - Real-time value labels on each bar
   - Dynamic height representation of numeric values

2. **Controls**:
   - Start/Pause sorting
   - Reset with new random array
   - Step-through mode for manual progression
   - Adjustable speed control

3. **Algorithm Information**:
   - Explanation of Bubble Sort
   - Step-by-step algorithm breakdown
   - Time complexity information

4. **Performance Tracking**:
   - Real-time counters for comparisons, swaps, and passes
   - Visual feedback during sorting process

The visualization clearly shows how bubble sort works by repeatedly comparing adjacent elements and "bubbling up" the largest values to the end of the array with each pass. The animation speed can be adjusted to observe the process at different rates or paused to examine each step in detail.