
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-means Clustering Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        button {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        canvas {
            border: 1px solid #ddd;
            background-color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .info {
            margin-top: 15px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>K-means Clustering Visualization</h1>
    <div class="controls">
        <div class="control-group">
            <label for="kValue">Number of Clusters (k):</label>
            <input type="number" id="kValue" min="1" max="10" value="3">
        </div>
        <div class="control-group">
            <label for="numPoints">Number of Points:</label>
            <input type="number" id="numPoints" min="10" max="500" value="100">
        </div>
        <div class="control-group">
            <button id="resetBtn">Reset</button>
        </div>
        <div class="control-group">
            <button id="stepBtn">Step</button>
        </div>
        <div class="control-group">
            <button id="runBtn">Run</button>
        </div>
    </div>
    <canvas id="canvas" width="600" height="400"></canvas>
    <div class="info">
        Iteration: <span id="iteration">0</span> | Status: <span id="status">Initialized</span>
    </div>

    <script>
        // Canvas and context
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Input elements
        const kInput = document.getElementById('kValue');
        const numPointsInput = document.getElementById('numPoints');
        const resetBtn = document.getElementById('resetBtn');
        const stepBtn = document.getElementById('stepBtn');
        const runBtn = document.getElementById('runBtn');
        const iterationDisplay = document.getElementById('iteration');
        const statusDisplay = document.getElementById('status');
        
        // Data storage
        let points = [];
        let centroids = [];
        let assignments = [];
        let currentIteration = 0;
        let maxIterations = 20;
        let state = 'need_assign'; // 'need_assign' or 'need_update'
        let animationId = null;
        const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', 
                        '#FF9F40', '#8AC926', '#1982C4', '#6A4C93', '#F15BB5'];
        
        // Initialize the visualization
        function init() {
            points = [];
            centroids = [];
            assignments = [];
            currentIteration = 0;
            state = 'need_assign';
            updateIterationDisplay();
            statusDisplay.textContent = 'Initialized';
            
            const k = parseInt(kInput.value);
            const numPoints = parseInt(numPointsInput.value);
            
            // Generate random data points
            for (let i = 0; i < numPoints; i++) {
                points.push({
                    x: Math.random() * (canvas.width - 30) + 15,
                    y: Math.random() * (canvas.height - 30) + 15
                });
            }
            
            // Initialize centroids randomly within the canvas
            for (let i = 0; i < k; i++) {
                centroids.push({
                    x: Math.random() * (canvas.width - 40) + 20,
                    y: Math.random() * (canvas.height - 40) + 20,
                    color: colors[i % colors.length]
                });
            }
            
            draw();
        }
        
        // Calculate Euclidean distance
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }
        
        // Assign points to nearest centroids
        function assignPoints() {
            assignments = [];
            for (let i = 0; i < points.length; i++) {
                let minDist = Infinity;
                let bestCentroid = 0;
                
                for (let j = 0; j < centroids.length; j++) {
                    const dist = distance(points[i], centroids[j]);
                    if (dist < minDist) {
                        minDist = dist;
                        bestCentroid = j;
                    }
                }
                assignments[i] = bestCentroid;
            }
            state = 'need_update';
            statusDisplay.textContent = 'Points assigned to centroids';
        }
        
        // Update centroids to be the mean of their assigned points
        function updateCentroids() {
            let moved = false;
            
            for (let j = 0; j < centroids.length; j++) {
                let sumX = 0;
                let sumY = 0;
                let count = 0;
                
                for (let i = 0; i < points.length; i++) {
                    if (assignments[i] === j) {
                        sumX += points[i].x;
                        sumY += points[i].y;
                        count++;
                    }
                }
                
                if (count > 0) {
                    const newX = sumX / count;
                    const newY = sumY / count;
                    
                    // Check if centroid moved significantly
                    if (distance(centroids[j], {x: newX, y: newY}) > 0.5) {
                        moved = true;
                    }
                    
                    centroids[j].x = newX;
                    centroids[j].y = newY;
                }
            }
            
            currentIteration++;
            updateIterationDisplay();
            
            if (!moved || currentIteration >= maxIterations) {
                statusDisplay.textContent = `Converged after ${currentIteration} iterations`;
                state = 'done';
            } else {
                state = 'need_assign';
                statusDisplay.textContent = 'Centroids updated';
            }
        }
        
        // Perform one step of the algorithm
        function step() {
            if (state === 'need_assign') {
                assignPoints();
            } else if (state === 'need_update') {
                updateCentroids();
            }
            draw();
        }
        
        // Animation function for run button
        function runAnimation() {
            if (state === 'done' || currentIteration >= maxIterations) {
                stopAnimation();
                return;
            }
            
            step();
            animationId = setTimeout(runAnimation, 800);
        }
        
        // Start animation
        function startAnimation() {
            if (!animationId) {
                runBtn.textContent = 'Stop';
                runAnimation();
            }
        }
        
        // Stop animation
        function stopAnimation() {
            if (animationId) {
                clearTimeout(animationId);
                animationId = null;
                runBtn.textContent = 'Run';
            }
        }
        
        // Draw points and centroids
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw points
            for (let i = 0; i < points.length; i++) {
                const centroidIdx = assignments[i];
                ctx.fillStyle = centroids[centroidIdx]?.color || '#999';
                ctx.beginPath();
                ctx.arc(points[i].x, points[i].y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw centroids
            for (let j = 0; j < centroids.length; j++) {
                ctx.fillStyle = centroids[j].color;
                ctx.beginPath();
                ctx.arc(centroids[j].x, centroids[j].y, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw centroid border
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centroids[j].x, centroids[j].y, 12, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw cluster number
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(j.toString(), centroids[j].x, centroids[j].y);
            }
        }
        
        // Update iteration display
        function updateIterationDisplay() {
            iterationDisplay.textContent = currentIteration;
        }
        
        // Event listeners
        resetBtn.addEventListener('click', () => {
            stopAnimation();
            init();
        });
        
        stepBtn.addEventListener('click', () => {
            if (state !== 'done') {
                step();
            }
        });
        
        runBtn.addEventListener('click', () => {
            if (animationId) {
                stopAnimation();
            } else if (state !== 'done') {
                startAnimation();
            }
        });
        
        // Initialize on load
        init();
    </script>
</body>
</html>
```