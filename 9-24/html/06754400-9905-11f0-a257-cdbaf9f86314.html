<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>K-means Clustering Demonstration</title>
    <style>
      body {
        font-family: sans-serif;
        text-align: center;
        margin: 20px;
      }
      canvas {
        border: 1px solid #ccc;
        background: #fafafa;
      }
      input, button {
        margin: 5px;
        padding: 5px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <h1>K-means Clustering Demonstration</h1>
    <p>
      This demo visualizes the K-means clustering algorithm. Click "Start" to generate random points and initialize cluster centers.
      Then use "Step" for a single iteration or "Auto Step" to run iterations automatically until convergence.
    </p>
    <div>
      <label for="numPoints">Number of Points:</label>
      <input type="number" id="numPoints" value="200" min="10" max="1000">
      &nbsp;
      <label for="numClusters">Number of Clusters (K):</label>
      <input type="number" id="numClusters" value="4" min="1" max="10">
    </div>
    <div>
      <button id="startButton">Start</button>
      <button id="stepButton" disabled>Step</button>
      <button id="autoButton" disabled>Auto Step</button>
      <button id="stopAutoButton" disabled>Stop Auto Step</button>
    </div>
    <br>
    <canvas id="canvas" width="600" height="600"></canvas>

    <script>
      // Global Variables
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      let points = [];
      let centroids = [];
      let colors = [];
      let k = 0;
      let iterationCount = 0;
      let autoInterval = null;

      // Initialize the simulation and data.
      function init() {
        // Clear any existing automatic stepping.
        if (autoInterval) {
          clearInterval(autoInterval);
          autoInterval = null;
        }
        iterationCount = 0;
        points = [];
        centroids = [];
        colors = [];
        
        // Get user inputs.
        const numPoints = parseInt(document.getElementById("numPoints").value);
        k = parseInt(document.getElementById("numClusters").value);

        // Generate random points.
        for (let i = 0; i < numPoints; i++) {
          points.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            cluster: -1 // Not assigned yet.
          });
        }

        // Initialize centroids: randomly pick positions from among points.
        for (let i = 0; i < k; i++) {
          const randomPoint = points[Math.floor(Math.random() * points.length)];
          centroids.push({
            x: randomPoint.x,
            y: randomPoint.y
          });
        }

        // Generate distinct colors for clusters.
        for (let i = 0; i < k; i++) {
          let hue = i * 360 / k;
          colors.push("hsl(" + hue + ", 100%, 50%)");
        }

        // Enable iteration buttons.
        document.getElementById("stepButton").disabled = false;
        document.getElementById("autoButton").disabled = false;
        document.getElementById("stopAutoButton").disabled = true;
        draw();
      }

      // Draw points and centroids onto the canvas.
      function draw() {
        // Clear canvas.
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw data points.
        for (let p of points) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
          // Points before assignment appear gray.
          ctx.fillStyle = (p.cluster === -1) ? "#999" : colors[p.cluster];
          ctx.fill();
        }

        // Draw centroids.
        for (let i = 0; i < centroids.length; i++) {
          const c = centroids[i];
          ctx.beginPath();
          ctx.arc(c.x, c.y, 8, 0, Math.PI * 2);
          ctx.fillStyle = colors[i];
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#000";
          ctx.stroke();
        }

        // Display the current iteration count.
        ctx.font = "16px Arial";
        ctx.fillStyle = "#000";
        ctx.fillText("Iteration: " + iterationCount, 10, 20);
      }

      // Perform one iteration (assignment and update) of k-means.
      function step() {
        iterationCount++;
        // Assignment step: assign each point to the nearest centroid.
        for (let p of points) {
          let minDist = Infinity;
          let assignedCluster = -1;
          for (let i = 0; i < centroids.length; i++) {
            let c = centroids[i];
            let dx = p.x - c.x;
            let dy = p.y - c.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDist) {
              minDist = dist;
              assignedCluster = i;
            }
          }
          p.cluster = assignedCluster;
        }

        // Update step: recalculate centroids based on assigned points.
        let newCentroids = [];
        for (let i = 0; i < k; i++) {
          let sumX = 0, sumY = 0, count = 0;
          for (let p of points) {
            if (p.cluster === i) {
              sumX += p.x;
              sumY += p.y;
              count++;
            }
          }
          if (count === 0) {
            // If a cluster loses all its points, reinitialize it randomly.
            newCentroids.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height
            });
          } else {
            newCentroids.push({
              x: sumX / count,
              y: sumY / count
            });
          }
        }

        // Check for convergence: if centroids hardly move, consider it converged.
        let converged = true;
        for (let i = 0; i < k; i++) {
          const dx = newCentroids[i].x - centroids[i].x;
          const dy = newCentroids[i].y - centroids[i].y;
          if (Math.sqrt(dx * dx + dy * dy) > 0.5) {  // tolerance threshold
            converged = false;
            break;
          }
        }

        // Update centroids to new positions.
        centroids = newCentroids;
        draw();
        
        // If converged, disable further iteration.
        if (converged) {
          alert("Converged after " + iterationCount + " iterations!");
          document.getElementById("stepButton").disabled = true;
          document.getElementById("autoButton").disabled = true;
          document.getElementById("stopAutoButton").disabled = true;
          if (autoInterval) {
            clearInterval(autoInterval);
            autoInterval = null;
          }
        }
      }

      // Automatically perform steps at intervals.
      function startAuto() {
        document.getElementById("autoButton").disabled = true;
        document.getElementById("stopAutoButton").disabled = false;
        autoInterval = setInterval(step, 1000);
      }

      function stopAuto() {
        if (autoInterval) {
          clearInterval(autoInterval);
          autoInterval = null;
        }
        document.getElementById("autoButton").disabled = false;
        document.getElementById("stopAutoButton").disabled = true;
      }

      // Assign event listeners to the buttons.
      document.getElementById("startButton").addEventListener("click", init);
      document.getElementById("stepButton").addEventListener("click", step);
      document.getElementById("autoButton").addEventListener("click", startAuto);
      document.getElementById("stopAutoButton").addEventListener("click", stopAuto);
    </script>
  </body>
</html>