```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Bubble Sort Visualization</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --primary-color: #e94560;
            --secondary-color: #16213e;
            --accent-color: #0f3460;
            --text-color: #dcdce6;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            
            --bar-default-color: #53a8b6;
            --bar-compare-color: #e94560;
            --bar-swap-color: #ffc947;
            --bar-sorted-color: #4caf50;
            
            --border-radius: 8px;
            --shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 1em;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        bubble-sort-visualizer {
            width: 100%;
            max-width: 1200px;
            display: block;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            gap: 1.5em;
            background-color: var(--secondary-color);
            padding: 2em;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-top: 0;
            font-size: 2.5em;
            text-shadow: 0 0 10px var(--primary-color);
        }

        .visualization-area {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 400px;
            padding: 1em;
            background: var(--accent-color);
            border-radius: var(--border-radius);
            gap: 2px;
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>

    <bubble-sort-visualizer></bubble-sort-visualizer>

    <script>
    // Utility function for delaying execution
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    // Web Component: <array-bar>
    class ArrayBar extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = `
                <style>
                    :host {
                        display: inline-block;
                        width: 100%;
                        transition: height 0.2s ease, background-color 0.2s ease;
                    }
                    .bar {
                        background-color: var(--bar-default-color);
                        height: 100%;
                        border-top-left-radius: 4px;
                        border-top-right-radius: 4px;
                    }
                    :host([state="comparing"]) .bar {
                        background-color: var(--bar-compare-color);
                    }
                    :host([state="swapping"]) .bar {
                        background-color: var(--bar-swap-color);
                    }
                    :host([state="sorted"]) .bar {
                        background-color: var(--bar-sorted-color);
                    }
                </style>
                <div class="bar"></div>
            `;
        }

        static get observedAttributes() {
            return ['value', 'state'];
        }

        attributeChangedCallback(name, oldValue, newValue) {
            if (name === 'value') {
                this.style.height = `${newValue}%`;
            } else if (name === 'state') {
                this.shadowRoot.querySelector('.bar').className = 'bar'; // Reset
            }
        }
    }
    customElements.define('array-bar', ArrayBar);


    // Web Component: <control-panel>
    class ControlPanel extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = `
                <style>
                    .controls {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 1.5em;
                        justify-content: center;
                        align-items: center;
                        padding: 1em;
                        background: var(--accent-color);
                        border-radius: var(--border-radius);
                    }
                    .control-group {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        gap: 0.5em;
                    }
                    label {
                        font-size: 0.9em;
                        font-weight: bold;
                    }
                    button {
                        background-color: var(--primary-color);
                        color: var(--text-color);
                        border: none;
                        padding: 10px 20px;
                        border-radius: var(--border-radius);
                        cursor: pointer;
                        font-weight: bold;
                        transition: all 0.2s ease;
                    }
                    button:hover:not(:disabled) {
                        transform: translateY(-2px);
                        box-shadow: 0 2px 8px rgba(233, 69, 96, 0.5);
                    }
                    button:disabled {
                        background-color: #555;
                        cursor: not-allowed;
                    }
                    .button-group {
                        display: flex;
                        gap: 1em;
                    }
                    input[type="range"] {
                        -webkit-appearance: none;
                        appearance: none;
                        width: 150px;
                        height: 8px;
                        background: #3f51b5;
                        outline: none;
                        opacity: 0.7;
                        transition: opacity .2s;
                        border-radius: 4px;
                    }
                    input[type="range"]:hover {
                        opacity: 1;
                    }
                    input[type="range"]::-webkit-slider-thumb {
                        -webkit-appearance: none;
                        appearance: none;
                        width: 20px;
                        height: 20px;
                        background: var(--primary-color);
                        cursor: pointer;
                        border-radius: 50%;
                    }
                    input[type="range"]::-moz-range-thumb {
                        width: 20px;
                        height: 20px;
                        background: var(--primary-color);
                        cursor: pointer;
                        border-radius: 50%;
                    }
                </style>
                <div class="controls">
                    <button id="new-array">New Array</button>
                    <div class="control-group">
                        <label for="size">Array Size: <span id="size-value">50</span></label>
                        <input type="range" id="size" min="10" max="100" value="50">
                    </div>
                    <div class="control-group">
                        <label for="speed">Animation Speed: <span id="speed-value">50</span></label>
                        <input type="range" id="speed" min="1" max="100" value="50">
                    </div>
                    <div class="button-group">
                        <button id="start">Start Sort</button>
                        <button id="pause" disabled>Pause</button>
                        <button id="reset" disabled>Reset</button>
                    </div>
                </div>
            `;

            this._bindEvents();
        }

        _bindEvents() {
            const dispatch = (eventName, detail) => {
                this.dispatchEvent(new CustomEvent(eventName, { bubbles: true, composed: true, detail }));
            };

            this.shadowRoot.getElementById('new-array').addEventListener('click', () => dispatch('newarray'));
            
            const sizeSlider = this.shadowRoot.getElementById('size');
            sizeSlider.addEventListener('input', (e) => {
                this.shadowRoot.getElementById('size-value').textContent = e.target.value;
            });
            sizeSlider.addEventListener('change', (e) => dispatch('sizechange', { value: e.target.value }));
            
            const speedSlider = this.shadowRoot.getElementById('speed');
            speedSlider.addEventListener('input', (e) => {
                this.shadowRoot.getElementById('speed-value').textContent = e.target.value;
                dispatch('speedchange', { value: e.target.value });
            });

            this.shadowRoot.getElementById('start').addEventListener('click', () => dispatch('start'));
            this.shadowRoot.getElementById('pause').addEventListener('click', () => dispatch('pause'));
            this.shadowRoot.getElementById('reset').addEventListener('click', () => dispatch('reset'));
        }

        setButtonState(state) {
            const startBtn = this.shadowRoot.getElementById('start');
            const pauseBtn = this.shadowRoot.getElementById('pause');
            const resetBtn = this.shadowRoot.getElementById('reset');
            const sizeSlider = this.shadowRoot.getElementById('size');
            const newArrayBtn = this.shadowRoot.getElementById('new-array');

            startBtn.disabled = true;
            pauseBtn.disabled = true;
            resetBtn.disabled = true;
            sizeSlider.disabled = false;
            newArrayBtn.disabled = false;
            pauseBtn.textContent = 'Pause';


            switch(state) {
                case 'initial':
                    startBtn.disabled = false;
                    break;
                case 'sorting':
                    pauseBtn.disabled = false;
                    resetBtn.disabled = false;
                    sizeSlider.disabled = true;
                    newArrayBtn.disabled = true;
                    break;
                case 'paused':
                    pauseBtn.disabled = false;
                    pauseBtn.textContent = 'Resume';
                    resetBtn.disabled = false;
                    break;
                case 'finished':
                    resetBtn.disabled = false;
                    break;
            }
        }
    }
    customElements.define('control-panel', ControlPanel);


    // Web Component: <info-panel>
    class InfoPanel extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = `
                <style>
                    .info-container {
                        display: grid;
                        grid-template-columns: 1fr 1fr;
                        gap: 1.5em;
                        padding: 1em;
                        background: var(--accent-color);
                        border-radius: var(--border-radius);
                    }
                    .explanation, .code-display {
                        padding: 1.5em;
                        background-color: var(--secondary-color);
                        border-radius: var(--border-radius);
                    }
                    h3 {
                        margin-top: 0;
                        color: var(--primary-color);
                    }
                    p {
                        line-height: 1.6;
                        margin: 0;
                    }
                    #status-message {
                        font-weight: bold;
                        min-height: 1.6em; /* Prevent layout shift */
                    }
                    pre {
                        background-color: #111;
                        padding: 1em;
                        border-radius: var(--border-radius);
                        overflow-x: auto;
                    }
                    code {
                        font-family: 'Courier New', Courier, monospace;
                        font-size: 0.95em;
                    }
                    .code-line {
                        display: block;
                        transition: background-color 0.3s;
                        padding: 2px 8px;
                        border-radius: 4px;
                    }
                    .highlight {
                        background-color: rgba(233, 69, 96, 0.4);
                    }
                </style>
                <div class="info-container">
                    <div class="explanation">
                        <h3>How Bubble Sort Works</h3>
                        <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.</p>
                        <br>
                        <p id="status-message">Ready to sort. Press 'Start'.</p>
                    </div>
                    <div class="code-display">
                        <h3>Algorithm Pseudocode</h3>
                        <pre><code>
<span class="code-line" data-line="1"><b>function</b> bubbleSort(array) {</span>
<span class="code-line" data-line="2">  <b>let</b> n = array.length;</span>
<span class="code-line" data-line="3">  <b>for</b> (i = 0; i < n - 1; i++) {</span>
<span class="code-line" data-line="4">    <b>for</b> (j = 0; j < n - i - 1; j++) {</span>
<span class="code-line" data-line="5">      <b>if</b> (array[j] > array[j + 1]) {</span>
<span class="code-line" data-line="6">        swap(array[j], array[j + 1]);</span>
<span class="code-line" data-line="7">      }</span>
<span class="code-line" data-line="8">    }</span>
<span class="code-line" data-line="9">  }</span>
<span class="code-line" data-line="10">}</span>
                        </code></pre>
                    </div>
                </div>
            `;
        }

        update({ message, line }) {
            this.shadowRoot.getElementById('status-message').textContent = message;
            
            this.shadowRoot.querySelectorAll('.code-line').forEach(el => el.classList.remove('highlight'));
            if (line) {
                const lineEl = this.shadowRoot.querySelector(`.code-line[data-line="${line}"]`);
                if(lineEl) lineEl.classList.add('highlight');
            }
        }
    }
    customElements.define('info-panel', InfoPanel);

    
    // Main Orchestrator Component: <bubble-sort-visualizer>
    class BubbleSortVisualizer extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });

            this.state = {
                array: [],
                originalArray: [],
                arraySize: 50,
                speed: 50, // 1-100 scale
                isSorting: false,
                isPaused: false,
                abortController: null,
            };

            this.shadowRoot.innerHTML = `
                <div class="main-container">
                    <h1>Bubble Sort Visualization</h1>
                    <control-panel></control-panel>
                    <div class="visualization-area"></div>
                    <info-panel></info-panel>
                </div>
            `;

            this.visualizationArea = this.shadowRoot.querySelector('.visualization-area');
            this.controlPanel = this.shadowRoot.querySelector('control-panel');
            this.infoPanel = this.shadowRoot.querySelector('info-panel');
        }

        connectedCallback() {
            this.generateNewArray();
            this.controlPanel.setButtonState('initial');

            this.addEventListener('newarray', this.handleNewArray);
            this.addEventListener('sizechange', this.handleSizeChange);
            this.addEventListener('speedchange', this.handleSpeedChange);
            this.addEventListener('start', this.handleStart);
            this.addEventListener('pause', this.handlePause);
            this.addEventListener('reset', this.handleReset);
        }

        // --- Event Handlers ---
        handleNewArray = () => {
            this.generateNewArray();
        }

        handleSizeChange = (e) => {
            this.state.arraySize = parseInt(e.detail.value, 10);
            this.generateNewArray();
        }

        handleSpeedChange = (e) => {
            // Invert and scale speed for a more intuitive feel (higher slider value = faster)
            this.state.speed = 101 - parseInt(e.detail.value, 10);
        }


        handleStart = () => {
            if (this.state.isSorting) return;
            this.state.isSorting = true;
            this.state.isPaused = false;
            this.state.abortController = new AbortController();
            this.controlPanel.setButtonState('sorting');
            this.runSort();
        };

        handlePause = () => {
            this.state.isPaused = !this.state.isPaused;
            this.controlPanel.setButtonState(this.state.isPaused ? 'paused' : 'sorting');
        };

        handleReset = () => {
            if (this.state.abortController) {
                this.state.abortController.abort();
            }
            this.state.isSorting = false;
            this.state.isPaused = false;
            this.state.array = [...this.state.originalArray];
            this.renderArray();
            this.controlPanel.setButtonState('initial');
            this.infoPanel.update({ message: "Sort reset. Ready to start again.", line: null });
        };

        // --- Core Logic & Rendering ---

        generateNewArray() {
            this.state.array = [];
            for (let i = 0; i < this.state.arraySize; i++) {
                this.state.array.push(Math.floor(Math.random() * 95) + 5); // Values from 5 to 100
            }
            this.state.originalArray = [...this.state.array];
            this.renderArray();
            this.controlPanel.setButtonState('initial');
            this.infoPanel.update({ message: "New array generated. Press 'Start' to sort.", line: null });
        }

        renderArray(states = {}) {
            this.visualizationArea.innerHTML = '';
            this.state.array.forEach((value, index) => {
                const bar = document.createElement('array-bar');
                bar.setAttribute('value', value);
                if (states[index]) {
                    bar.setAttribute('state', states[index]);
                }
                this.visualizationArea.appendChild(bar);
            });
        }
        
        async *bubbleSortGenerator() {
            let arr = this.state.array;
            let n = arr.length;
            let swapped;
            for (let i = 0; i < n - 1; i++) {
                swapped = false;
                yield { type: 'pass_start', pass: i + 1, line: 3 };
                for (let j = 0; j < n - i - 1; j++) {
                    yield { type: 'compare', indices: [j, j + 1], line: 5 };
                    if (arr[j] > arr[j + 1]) {
                        yield { type: 'swap_start', indices: [j, j + 1], line: 6 };
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        swapped = true;
                        yield { type: 'swap_end', indices: [j, j + 1], line: 6 };
                    }
                }
                yield { type: 'sorted', index: n - 1 - i, line: 8 };
                if (!swapped) {
                    // Optimization: if no swaps in a pass, array is sorted
                    break;
                }
            }
            // Mark all remaining as sorted if we broke early
            for(let k = 0; k < n; k++) {
                yield { type: 'sorted', index: k, line: 9 };
            }
        }
        
        async runSort() {
            const generator = this.bubbleSortGenerator();
            const sortedIndices = new Set();
            const { signal } = this.state.abortController;

            try {
                for await (const step of generator) {
                    if (signal.aborted) return;
                    
                    while(this.state.isPaused) {
                        if (signal.aborted) return;
                        await sleep(100);
                    }
                    
                    const states = {};
                    sortedIndices.forEach(i => states[i] = 'sorted');

                    switch(step.type) {
                        case 'pass_start':
                            this.infoPanel.update({ message: `Starting Pass ${step.pass}...`, line: step.line });
                            break;
                            
                        case 'compare':
                            const [i, j] = step.indices;
                            this.infoPanel.update({ message: `Comparing elements at index ${i} (${this.state.array[i]}) and ${j} (${this.state.array[j]})`, line: step.line });
                            states[i] = 'comparing';
                            states[j] = 'comparing';
                            this.renderArray(states);
                            break;

                        case 'swap_start':
                             const [i_swap, j_swap] = step.indices;
                             this.infoPanel.update({ message: `Swapping ${this.state.array[i_swap]} and ${this.state.array[j_swap]}`, line: step.line });
                             states[i_swap] = 'swapping';
                             states[j_swap] = 'swapping';
                             this.renderArray(states);
                             break;
                        
                        case 'swap_end':
                             this.renderArray(states); // Rerender with default colors after swap logic
                             break;

                        case 'sorted':
                            sortedIndices.add(step.index);
                            states[step.index] = 'sorted';
                            this.renderArray(states);
                            this.infoPanel.update({ message: `Element ${this.state.array[step.index]} is now in its final sorted position.`, line: step.line });
                            break;
                    }
                    await sleep(this.state.speed * 5);
                }

                this.infoPanel.update({ message: 'Array is sorted!', line: 10 });
                this.controlPanel.setButtonState('finished');
                this.state.isSorting = false;

            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error("Sorting error:", error);
                }
            }
        }
    }
    customElements.define('bubble-sort-visualizer', BubbleSortVisualizer);

    </script>
</body>
</html>
```