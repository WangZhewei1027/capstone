<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>K-Nearest Neighbor (KNN) Demo</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      .controls {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .canvas-container {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      canvas {
        border: 1px solid #ddd;
        background-color: #fafafa;
        cursor: crosshair;
      }
      .results {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      button {
        padding: 8px 16px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        background-color: #007bff;
        color: white;
        cursor: pointer;
      }
      button:hover {
        background-color: #0056b3;
      }
      button.clear {
        background-color: #dc3545;
      }
      button.clear:hover {
        background-color: #c82333;
      }
      input[type="number"] {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 60px;
      }
      .class-controls {
        display: flex;
        gap: 10px;
        align-items: center;
        margin: 10px 0;
      }
      .color-preview {
        width: 20px;
        height: 20px;
        border: 1px solid #ddd;
        display: inline-block;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>K-Nearest Neighbor (KNN) Demo</h1>

      <div class="controls">
        <h3>Controls</h3>
        <div>
          <label for="kValue">K Value: </label>
          <input type="number" id="kValue" min="1" max="20" value="3" />
          <button id="classifyBtn">Classify Points</button>
          <button id="clearBtn" class="clear">Clear All</button>
        </div>

        <div class="class-controls">
          <label>Class 1: </label>
          <input type="color" id="class1Color" value="#ff0000" />
          <span class="color-preview" style="background-color: #ff0000"></span>
          <button onclick="addTrainingPoint(0)">
            Add Training Point (Class 1)
          </button>
        </div>

        <div class="class-controls">
          <label>Class 2: </label>
          <input type="color" id="class2Color" value="#0000ff" />
          <span class="color-preview" style="background-color: #0000ff"></span>
          <button onclick="addTrainingPoint(1)">
            Add Training Point (Class 2)
          </button>
        </div>

        <div class="class-controls">
          <label>Test Point: </label>
          <input type="color" id="testColor" value="#00ff00" />
          <span class="color-preview" style="background-color: #00ff00"></span>
          <button onclick="addTestPoint()">Add Test Point</button>
        </div>

        <p>
          Click on the canvas to add points directly. Right-click to remove
          points.
        </p>
      </div>

      <div class="canvas-container">
        <canvas id="knnCanvas" width="800" height="400"></canvas>
      </div>

      <div class="results">
        <h3>Results</h3>
        <div id="resultsText">
          Add training points and test points to see KNN results.
        </div>
      </div>
    </div>

    <script>
      class KNN {
        constructor(k = 3) {
          this.k = k;
          this.trainingData = [];
          this.labels = [];
        }

        fit(data, labels) {
          this.trainingData = data;
          this.labels = labels;
        }

        predict(point) {
          // Calculate distances to all training points
          const distances = this.trainingData.map((trainPoint, index) => ({
            index: index,
            distance: this.euclideanDistance(point, trainPoint),
            label: this.labels[index],
          }));

          // Sort by distance and get k nearest neighbors
          distances.sort((a, b) => a.distance - b.distance);
          const kNearest = distances.slice(0, this.k);

          // Count votes for each class
          const voteCount = {};
          kNearest.forEach((neighbor) => {
            voteCount[neighbor.label] = (voteCount[neighbor.label] || 0) + 1;
          });

          // Find the class with most votes
          let maxVotes = 0;
          let predictedClass = null;

          for (const [className, votes] of Object.entries(voteCount)) {
            if (votes > maxVotes) {
              maxVotes = votes;
              predictedClass = parseInt(className);
            }
          }

          return {
            predictedClass: predictedClass,
            neighbors: kNearest,
            votes: voteCount,
          };
        }

        euclideanDistance(pointA, pointB) {
          return Math.sqrt(
            Math.pow(pointA[0] - pointB[0], 2) +
              Math.pow(pointA[1] - pointB[1], 2)
          );
        }
      }

      class KNNVisualizer {
        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.knn = new KNN();

          this.trainingPoints = [];
          this.testPoints = [];
          this.currentClass = 0; // 0 for class1, 1 for class2
          this.isAddingTestPoint = false;

          this.colors = {
            class1: "#ff0000",
            class2: "#0000ff",
            test: "#00ff00",
            neighborLine: "#888888",
          };

          this.setupEventListeners();
          this.updateColorPreviews();
          this.draw();
        }

        setupEventListeners() {
          this.canvas.addEventListener("click", (e) => {
            const point = this.getMousePos(e);

            if (this.isAddingTestPoint) {
              this.addTestPoint(point[0], point[1]);
              this.isAddingTestPoint = false;
            } else {
              this.addTrainingPoint(point[0], point[1], this.currentClass);
            }
          });

          this.canvas.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            const point = this.getMousePos(e);
            this.removeNearestPoint(point[0], point[1]);
          });

          // Update colors when color inputs change
          document
            .getElementById("class1Color")
            .addEventListener("input", (e) => {
              this.colors.class1 = e.target.value;
              this.updateColorPreviews();
              this.draw();
            });

          document
            .getElementById("class2Color")
            .addEventListener("input", (e) => {
              this.colors.class2 = e.target.value;
              this.updateColorPreviews();
              this.draw();
            });

          document
            .getElementById("testColor")
            .addEventListener("input", (e) => {
              this.colors.test = e.target.value;
              this.updateColorPreviews();
              this.draw();
            });

          // Control buttons
          document
            .getElementById("classifyBtn")
            .addEventListener("click", () => {
              this.classifyPoints();
            });

          document.getElementById("clearBtn").addEventListener("click", () => {
            this.clearAll();
          });
        }

        updateColorPreviews() {
          document.querySelectorAll(".color-preview")[0].style.backgroundColor =
            this.colors.class1;
          document.querySelectorAll(".color-preview")[1].style.backgroundColor =
            this.colors.class2;
          document.querySelectorAll(".color-preview")[2].style.backgroundColor =
            this.colors.test;
        }

        getMousePos(event) {
          const rect = this.canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          return [x, y];
        }

        addTrainingPoint(x, y, className = null) {
          if (className === null) className = this.currentClass;
          this.trainingPoints.push({ x, y, className, type: "training" });
          this.updateKNNModel();
          this.draw();
        }

        addTestPoint(x, y) {
          this.testPoints.push({ x, y, type: "test" });
          this.draw();
        }

        removeNearestPoint(x, y) {
          // Combine all points and find the nearest one to remove
          const allPoints = [...this.trainingPoints, ...this.testPoints];
          if (allPoints.length === 0) return;

          let minDist = Infinity;
          let pointToRemove = null;
          let pointType = null;
          let indexToRemove = -1;

          allPoints.forEach((point, index) => {
            const dist = Math.sqrt(
              Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2)
            );
            if (dist < minDist) {
              minDist = dist;
              pointToRemove = point;
              pointType = point.type;
              indexToRemove = index;
            }
          });

          if (minDist < 20) {
            // Only remove if click is close enough to a point
            if (pointType === "training") {
              this.trainingPoints.splice(indexToRemove, 1);
              this.updateKNNModel();
            } else {
              this.testPoints.splice(
                indexToRemove - this.trainingPoints.length,
                1
              );
            }
            this.draw();
          }
        }

        updateKNNModel() {
          const data = this.trainingPoints.map((p) => [p.x, p.y]);
          const labels = this.trainingPoints.map((p) => p.className);
          this.knn.fit(data, labels);
        }

        classifyPoints() {
          const k = parseInt(document.getElementById("kValue").value);
          this.knn.k = k;

          let resultsHTML = "";

          this.testPoints.forEach((testPoint, index) => {
            const result = this.knn.predict([testPoint.x, testPoint.y]);

            // Draw neighbor connections
            this.drawNeighborConnections(testPoint, result.neighbors);

            // Update results display
            resultsHTML += `
                        <div>
                            <strong>Test Point ${
                              index + 1
                            }</strong> at (${Math.round(
              testPoint.x
            )}, ${Math.round(testPoint.y)}) 
                            is classified as <span style="color: ${
                              result.predictedClass === 0
                                ? this.colors.class1
                                : this.colors.class2
                            }">
                            Class ${result.predictedClass + 1}</span><br>
                            Votes: Class 1: ${result.votes[0] || 0}, Class 2: ${
              result.votes[1] || 0
            }
                        </div>
                    `;
          });

          if (this.testPoints.length === 0) {
            resultsHTML = "No test points to classify. Add test points first.";
          }

          document.getElementById("resultsText").innerHTML = resultsHTML;
        }

        drawNeighborConnections(testPoint, neighbors) {
          this.ctx.save();
          this.ctx.strokeStyle = this.colors.neighborLine;
          this.ctx.setLineDash([5, 5]);
          this.ctx.lineWidth = 1;

          neighbors.forEach((neighbor) => {
            const trainPoint = this.trainingPoints[neighbor.index];
            this.ctx.beginPath();
            this.ctx.moveTo(testPoint.x, testPoint.y);
            this.ctx.lineTo(trainPoint.x, trainPoint.y);
            this.ctx.stroke();
          });

          this.ctx.restore();
        }

        draw() {
          // Clear canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw training points
          this.trainingPoints.forEach((point) => {
            this.drawPoint(
              point.x,
              point.y,
              point.className === 0 ? this.colors.class1 : this.colors.class2,
              `Class ${point.className + 1}`
            );
          });

          // Draw test points
          this.testPoints.forEach((point) => {
            this.drawPoint(point.x, point.y, this.colors.test, "Test");
          });
        }

        drawPoint(x, y, color, label) {
          this.ctx.save();

          // Draw point
          this.ctx.fillStyle = color;
          this.ctx.beginPath();
          this.ctx.arc(x, y, 6, 0, Math.PI * 2);
          this.ctx.fill();

          // Draw outline
          this.ctx.strokeStyle = "#000";
          this.ctx.lineWidth = 1;
          this.ctx.stroke();

          // Draw label
          this.ctx.fillStyle = "#000";
          this.ctx.font = "12px Arial";
          this.ctx.fillText(label, x + 8, y - 8);

          this.ctx.restore();
        }

        clearAll() {
          this.trainingPoints = [];
          this.testPoints = [];
          this.updateKNNModel();
          this.draw();
          document.getElementById("resultsText").innerHTML =
            "Add training points and test points to see KNN results.";
        }
      }

      // Global functions for button clicks
      function addTrainingPoint(className) {
        knnVisualizer.currentClass = className;
        knnVisualizer.isAddingTestPoint = false;
        document.getElementById("resultsText").innerHTML =
          "Click on the canvas to add a training point.";
      }

      function addTestPoint() {
        knnVisualizer.isAddingTestPoint = true;
        document.getElementById("resultsText").innerHTML =
          "Click on the canvas to add a test point.";
      }

      // Initialize the visualizer when the page loads
      let knnVisualizer;
      window.onload = function () {
        knnVisualizer = new KNNVisualizer("knnCanvas");
      };
    </script>
  </body>
</html>
