<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>K-Nearest Neighbors Visualization</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: #f5f5f5;
      }
      .container {
        max-width: 1000px;
        margin: 0 auto;
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      h1 {
        text-align: center;
        color: #333;
      }
      .controls {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 20px 0;
        flex-wrap: wrap;
        gap: 15px;
      }
      .control-group {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      label {
        margin-bottom: 5px;
        font-weight: bold;
        color: #555;
      }
      input,
      button {
        padding: 8px 12px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      button {
        background-color: #4caf50;
        color: white;
        cursor: pointer;
        border: none;
        font-weight: bold;
      }
      button:hover {
        background-color: #45a049;
      }
      canvas {
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #fafafa;
        display: block;
        margin: 20px auto;
      }
      .legend {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 10px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .color-box {
        width: 15px;
        height: 15px;
        border-radius: 2px;
      }
      .instructions {
        margin-top: 20px;
        padding: 10px;
        background-color: #e9f7ef;
        border-radius: 4px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>K-Nearest Neighbors Visualization</h1>

      <div class="controls">
        <div class="control-group">
          <label for="kValue">K Value:</label>
          <input type="number" id="kValue" min="1" max="20" value="3" />
        </div>

        <div class="control-group">
          <label for="pointType">Point Type:</label>
          <select id="pointType">
            <option value="0">Class 0 (Blue)</option>
            <option value="1">Class 1 (Red)</option>
            <option value="2">Class 2 (Green)</option>
          </select>
        </div>

        <button id="clearBtn">Clear Points</button>
        <button id="randomBtn">Add Random Points</button>
      </div>

      <canvas id="canvas" width="600" height="400"></canvas>

      <div class="legend">
        <div class="legend-item">
          <div class="color-box" style="background-color: #3498db"></div>
          <span>Class 0</span>
        </div>
        <div class="legend-item">
          <div class="color-box" style="background-color: #e74c3c"></div>
          <span>Class 1</span>
        </div>
        <div class="legend-item">
          <div class="color-box" style="background-color: #2ecc71"></div>
          <span>Class 2</span>
        </div>
        <div class="legend-item">
          <div class="color-box" style="background-color: #9b59b6"></div>
          <span>Query Point</span>
        </div>
        <div class="legend-item">
          <div class="color-box" style="background-color: #f1c40f"></div>
          <span>Nearest Neighbors</span>
        </div>
      </div>

      <div class="instructions">
        <p>
          <strong>Instructions:</strong> Click on the canvas to add data points.
          The current point type is selected above. After adding points, click
          anywhere on the canvas to classify a new point using K-NN. The K
          nearest neighbors will be highlighted in yellow.
        </p>
      </div>
    </div>

    <script>
      // Canvas setup
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const kInput = document.getElementById("kValue");
      const pointTypeSelect = document.getElementById("pointType");
      const clearBtn = document.getElementById("clearBtn");
      const randomBtn = document.getElementById("randomBtn");

      // Data points storage
      let points = [];
      let queryPoint = null;
      let nearestNeighbors = [];

      // Colors for classes
      const colors = ["#3498db", "#e74c3c", "#2ecc71"]; // Blue, Red, Green
      const queryColor = "#9b59b6"; // Purple
      const neighborColor = "#f1c40f"; // Yellow

      // Point class
      class Point {
        constructor(x, y, classType) {
          this.x = x;
          this.y = y;
          this.classType = classType;
        }
      }

      // Calculate Euclidean distance between two points
      function euclideanDistance(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      }

      // Find k nearest neighbors
      function findKNearestNeighbors(query, k) {
        if (points.length === 0) return [];

        // Calculate distances to all points
        const distances = points.map((point) => ({
          point: point,
          distance: euclideanDistance(query, point),
        }));

        // Sort by distance
        distances.sort((a, b) => a.distance - b.distance);

        // Return the k nearest points
        return distances
          .slice(0, Math.min(k, points.length))
          .map((d) => d.point);
      }

      // Determine the class of the query point based on neighbors
      function classifyPoint(neighbors) {
        if (neighbors.length === 0) return 0;

        // Count classes
        const classCount = {};
        neighbors.forEach((neighbor) => {
          classCount[neighbor.classType] =
            (classCount[neighbor.classType] || 0) + 1;
        });

        // Find the class with the highest count
        let maxCount = 0;
        let predictedClass = 0;
        for (let classType in classCount) {
          if (classCount[classType] > maxCount) {
            maxCount = classCount[classType];
            predictedClass = parseInt(classType);
          }
        }

        return predictedClass;
      }

      // Draw everything on canvas
      function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw grid
        ctx.strokeStyle = "#eee";
        ctx.lineWidth = 1;

        // Vertical lines
        for (let x = 0; x <= canvas.width; x += 20) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }

        // Horizontal lines
        for (let y = 0; y <= canvas.height; y += 20) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }

        // Draw existing points
        points.forEach((point) => {
          ctx.beginPath();
          ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
          ctx.fillStyle = colors[point.classType];
          ctx.fill();
          ctx.strokeStyle = "#333";
          ctx.lineWidth = 1;
          ctx.stroke();
        });

        // Draw nearest neighbors with highlight
        nearestNeighbors.forEach((point) => {
          ctx.beginPath();
          ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
          ctx.strokeStyle = neighborColor;
          ctx.lineWidth = 2;
          ctx.stroke();
        });

        // Draw query point if exists
        if (queryPoint) {
          ctx.beginPath();
          ctx.arc(queryPoint.x, queryPoint.y, 6, 0, Math.PI * 2);
          ctx.fillStyle = queryColor;
          ctx.fill();
          ctx.strokeStyle = "#333";
          ctx.lineWidth = 1;
          ctx.stroke();

          // Draw lines to nearest neighbors
          ctx.strokeStyle = neighborColor;
          ctx.lineWidth = 1;
          ctx.setLineDash([5, 3]);
          nearestNeighbors.forEach((neighbor) => {
            ctx.beginPath();
            ctx.moveTo(queryPoint.x, queryPoint.y);
            ctx.lineTo(neighbor.x, neighbor.y);
            ctx.stroke();
          });
          ctx.setLineDash([]);
        }
      }

      // Handle canvas click
      canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // If we have points, treat click as query point
        if (points.length > 0) {
          queryPoint = new Point(x, y, -1); // -1 indicates query point
          const k = parseInt(kInput.value) || 3;
          nearestNeighbors = findKNearestNeighbors(queryPoint, k);
          draw();
        } else {
          // Otherwise, add as a data point
          const classType = parseInt(pointTypeSelect.value);
          points.push(new Point(x, y, classType));
          draw();
        }
      });

      // Add random points
      randomBtn.addEventListener("click", () => {
        const numPoints = 30;
        for (let i = 0; i < numPoints; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const classType = Math.floor(Math.random() * 3);
          points.push(new Point(x, y, classType));
        }
        draw();
      });

      // Clear all points
      clearBtn.addEventListener("click", () => {
        points = [];
        queryPoint = null;
        nearestNeighbors = [];
        draw();
      });

      // Initialize
      draw();
    </script>
  </body>
</html>
