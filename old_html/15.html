<!doctype html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Singly Linked List Playground — Web Components</title>
<style>
:root{
  --bg: #f7f8fa;
  --fg: #1c1f23;
  --muted: #6b7280;
  --primary: #2563eb;
  --primary-weak: rgba(37,99,235,.12);
  --accent: #10b981;
  --warn: #ef4444;
  --card: #ffffff;
  --edge: #e5e7eb;
  --node: #eef2ff;
  --node-border:#c7d2fe;
  --highlight:#fde68a;
  --code-bg:#0b1020;
  --code-fg:#d1e7ff;
}
:root[data-theme="dark"]{
  --bg: #0b1020;
  --fg: #e6e7ea;
  --muted: #9aa1ad;
  --primary: #60a5fa;
  --primary-weak: rgba(96,165,250,.15);
  --accent: #34d399;
  --warn: #f87171;
  --card: #111628;
  --edge: #1f273a;
  --node: #0f1840;
  --node-border:#233066;
  --highlight:#3b2f0f;
  --code-bg:#0b0f1a;
  --code-fg:#e2f0ff;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  background:var(--bg);
  color:var(--fg);
  font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, Noto Sans, "Apple Color Emoji","Segoe UI Emoji";
}
main{
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
  display:grid;
  grid-template-columns: 320px 1fr 360px;
  grid-template-areas: "controls visual inspector";
  gap:12px;
}
@media (max-width: 1000px){
  main{grid-template-columns: 1fr; grid-template-areas: "controls" "visual" "inspector";}
}
.card{
  background:var(--card);
  border:1px solid var(--edge);
  border-radius:12px;
  padding:12px;
  box-shadow: 0 2px 0 rgba(0,0,0,.02);
}
h1{font-size:22px;margin:10px 0 0}
h2{font-size:16px;margin:0 0 8px}
small{color:var(--muted)}
kbd{
  background:var(--edge);
  border:1px solid rgba(0,0,0,.1);
  border-bottom-width:2px;
  padding:0 6px;
  border-radius:6px;
  font-size:12px;
}
button, input, select{
  font: inherit;
}
.hidden-visually{
  position:absolute!important;
  width:1px;height:1px;
  margin:-1px;border:0;padding:0;
  white-space:nowrap;clip-path:inset(100%);clip:rect(0 0 0 0);overflow:hidden;
}
/* simple toast */
#toast{
  position:fixed;inset:auto 16px 16px auto;
  background:var(--card);border:1px solid var(--edge);box-shadow:0 6px 20px rgba(0,0,0,.15);
  padding:10px 12px;border-radius:10px;opacity:0;transform:translateY(10px);pointer-events:none;transition:.25s;
}
#toast.show{opacity:1;transform:none}
footer{
  text-align:center;color:var(--muted);padding:16px 0 32px
}
</style>
</head>
<body>
  <main>
    <section class="card" style="grid-area:controls">
      <h1>Singly Linked List</h1>
      <small>Interactive, animated — Vanilla Web Components</small>
      <ll-controls></ll-controls>
    </section>
    <section class="card" style="grid-area:visual">
      <h2>Visualizer</h2>
      <ll-visualizer></ll-visualizer>
    </section>
    <section class="card" style="grid-area:inspector">
      <h2>Inspector</h2>
      <ll-inspector></ll-inspector>
    </section>
  </main>
  <footer>
    Keyboard: <kbd>P</kbd> Play/Pause • <kbd>.</kbd> Step • <kbd>R</kbd> Reset • <kbd>Z</kbd> Undo • <kbd>Y</kbd> Redo
  </footer>
  <div id="toast" role="status" aria-live="polite"></div>
<script type="module">
/** =============================
 *  Data Structures (Pure Logic)
 *  ============================= */
/** @template T */
class Node {
  /** @param {T} value */
  constructor(value){ this.value = value; /** @type {Node<T>|null} */ this.next = null; }
}
/** @template T */
class LinkedList {
  constructor(){ /** @type {Node<T>|null} */ this.head = null; /** @type {Node<T>|null} */ this.tail=null; this.size=0; }
  /** @param {T} value */ push(value){
    const n = new Node(value);
    if(!this.head){ this.head=this.tail=n; }
    else{ this.tail.next = n; this.tail = n; }
    this.size++; this._assertInvariants(); return true;
  }
  /** @param {T} value */ unshift(value){
    const n = new Node(value);
    if(!this.head){ this.head=this.tail=n; }
    else{ n.next=this.head; this.head=n; }
    this.size++; this._assertInvariants(); return true;
  }
  /** @param {number} index @param {T} value */
  insertAt(index, value){
    if(index<0||index>this.size) return false;
    if(index===0) return this.unshift(value);
    if(index===this.size) return this.push(value);
    let prev=this.head;
    for(let i=0;i<index-1;i++) prev=prev.next;
    const n = new Node(value); n.next = prev.next; prev.next=n;
    this.size++; this._assertInvariants(); return true;
  }
  /** @param {number} index */
  removeAt(index){
    if(index<0||index>=this.size) return null;
    if(index===0){
      const val=this.head.value; this.head=this.head.next; if(!this.head) this.tail=null; this.size--; this._assertInvariants(); return val;
    }
    let prev=this.head;
    for(let i=0;i<index-1;i++) prev=prev.next;
    const removed = prev.next; prev.next = removed.next;
    if(removed===this.tail) this.tail=prev;
    this.size--; this._assertInvariants(); return removed.value;
  }
  /** @param {T} value */ deleteValue(value){
    if(!this.head) return false;
    if(this.head.value==value){ this.removeAt(0); return true; }
    let prev=this.head, curr=this.head.next;
    while(curr){ if(curr.value==value){ prev.next=curr.next; if(curr===this.tail) this.tail=prev; this.size--; this._assertInvariants(); return true; } prev=curr; curr=curr.next; }
    return false;
  }
  /** @param {T} value */ search(value){
    let idx=0; let curr=this.head;
    while(curr){ if(curr.value==value) return idx; curr=curr.next; idx++; }
    return -1;
  }
  reverse(){
    let prev=null, curr=this.head; this.tail=this.head;
    while(curr){ const next=curr.next; curr.next=prev; prev=curr; curr=next; }
    this.head=prev; this._assertInvariants(); return true;
  }
  clear(){ this.head=this.tail=null; this.size=0; this._assertInvariants(); }
  /** @returns {T[]} */ toArray(){ const arr=[]; let n=this.head; while(n){ arr.push(n.value); n=n.next; } return arr; }
  /** @param {T[]} arr */ fromArray(arr){ this.clear(); for(const v of arr) this.push(v); }
  /** Basic invariants */
  _assertInvariants(){
    // size equals counted nodes; tail.next is null; head is null iff size=0; no cycles
    let count=0, slow=this.head, fast=this.head, cycle=false;
    while(fast&&fast.next){ slow=slow.next; fast=fast.next.next; if(slow===fast){ cycle=true; break; } }
    if(cycle) throw new Error("Invariant failed: cycle detected");
    let n=this.head, last=null;
    while(n){ count++; last=n; n=n.next; }
    if(count!==this.size) throw new Error("Invariant failed: size mismatch");
    if(this.size===0 && (this.head||this.tail)) throw new Error("Invariant failed: empty but head/tail set");
    if(this.size>0){
      if(!this.head||!this.tail) throw new Error("Invariant failed: missing head/tail");
      if(this.tail.next!==null) throw new Error("Invariant failed: tail.next not null");
    }
    return true;
  }
}

/** =============================
 *  Util
 *  ============================= */
const PSEUDOCODE = {
  push: [
    "node = new Node(value)",
    "if head == null: head = tail = node",
    "else: tail.next = node; tail = node",
    "size++"
  ],
  unshift: [
    "node = new Node(value)",
    "if head == null: head = tail = node",
    "else: node.next = head; head = node",
    "size++"
  ],
  insertAt: [
    "if index < 0 or index > size: return false",
    "if index == 0: unshift(value)",
    "if index == size: push(value)",
    "prev = nodeAt(index-1)",
    "node.next = prev.next",
    "prev.next = node",
    "size++"
  ],
  removeAt: [
    "if index < 0 or index >= size: return null",
    "if index == 0: head = head.next",
    "prev = nodeAt(index-1)",
    "removed = prev.next",
    "prev.next = removed.next",
    "if removed == tail: tail = prev",
    "size--"
  ],
  deleteValue: [
    "if head == null: return false",
    "if head.value == value: removeAt(0)",
    "prev = head; curr = head.next",
    "while curr and curr.value != value: prev = curr; curr = curr.next",
    "if curr == null: return false",
    "prev.next = curr.next",
    "if curr == tail: tail = prev",
    "size--; return true"
  ],
  search: [
    "idx = 0; curr = head",
    "while curr:",
    "    if curr.value == value: return idx",
    "    curr = curr.next; idx++",
    "return -1"
  ],
  reverse: [
    "prev = null; curr = head; tail = head",
    "while curr:",
    "    next = curr.next",
    "    curr.next = prev",
    "    prev = curr",
    "    curr = next",
    "head = prev"
  ],
  clear: [
    "head = null; tail = null; size = 0"
  ]
};
const COMPLEXITY = {
  push: "O(1)",
  unshift: "O(1)",
  insertAt: "O(n)",
  removeAt: "O(n)",
  deleteValue: "O(n)",
  search: "O(n)",
  reverse: "O(n)",
  clear: "O(1)"
};
const clamp = (n,min,max)=>Math.max(min,Math.min(max,n));
const toast = (msg)=>{ const t=document.getElementById('toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1200); };

/** =============================
 *  Web Components
 *  ============================= */
class LLControls extends HTMLElement{
  constructor(){ super(); this.attachShadow({mode:'open'}); }
  connectedCallback(){
    const s=this.shadowRoot;
    s.innerHTML=`
      <style>
        .row{display:flex; gap:8px; margin:8px 0; flex-wrap:wrap}
        .row > *{flex:1}
        input[type="number"]{width:110px}
        fieldset{border:1px dashed var(--edge); border-radius:10px; padding:8px}
        legend{font-size:12px; color:var(--muted)}
        .split{display:grid; grid-template-columns: 1fr 1fr; gap:6px}
        button{
          border:1px solid var(--edge); background:linear-gradient(var(--card), var(--primary-weak));
          padding:8px 10px; border-radius:10px; cursor:pointer;
        }
        button.primary{border-color:var(--primary); background:var(--primary); color:#fff}
        button.warn{border-color:var(--warn); color:#fff; background:var(--warn)}
        button:disabled{opacity:.5; cursor:not-allowed}
        .small{font-size:12px}
        .switch{display:flex; align-items:center; gap:8px}
        .test{position:relative}
        .test button{position:absolute; inset:0; opacity:.0001}
      </style>
  <div class="row" role="group" aria-label="Inputs">
    <label class="small">Value
      <input id="value" aria-label="Value" placeholder="e.g. 7">
    </label>
    <label class="small">Index
      <input id="index" type="number" aria-label="Index" value="0" step="1">
    </label>
  </div>
  <div class="split" role="group" aria-label="Mutating operations">
    <button id="unshift">Unshift (prepend)</button>
    <button id="push">Push (append)</button>
    <button id="insert">Insert At</button>
    <button id="remove">Remove At</button>
    <button id="delete">Delete Value</button>
    <button id="reverse">Reverse</button>
  </div>
  <div class="row">
    <button id="search" class="primary">Search</button>
    <button id="clear" class="warn">Clear</button>
  </div>
  <fieldset>
    <legend>Playback & Options</legend>
    <div class="row">
      <label class="small" style="flex:2">Speed <input id="speed" type="range" min="0.25" max="3" step="0.25" value="1" aria-label="Speed"></label>
      <label class="switch small"><input id="reduce" type="checkbox"> Reduce Motion</label>
      <label class="switch small"><input id="theme" type="checkbox"> Dark Theme</label>
    </div>
    <div class="row">
      <button id="undo" title="Undo (Z)">Undo</button>
      <button id="redo" title="Redo (Y)">Redo</button>
      <button id="random" title="Randomize list">Randomize</button>
      <span class="test" aria-hidden="true"><button id="test" title="Run hidden tests"></button></span>
    </div>
  </fieldset>
`;
const emit=(name,detail={})=>this.dispatchEvent(new CustomEvent(name,{detail,bubbles:true,composed:true}));
s.getElementById('push').onclick=()=>emit('controls:push',{value:s.getElementById('value').value});
s.getElementById('unshift').onclick=()=>emit('controls:unshift',{value:s.getElementById('value').value});
s.getElementById('insert').onclick=()=>emit('controls:insertAt',{index: Number(s.getElementById('index').value), value:s.getElementById('value').value});
s.getElementById('remove').onclick=()=>emit('controls:removeAt',{index: Number(s.getElementById('index').value)});
s.getElementById('delete').onclick=()=>emit('controls:deleteValue',{value:s.getElementById('value').value});
s.getElementById('search').onclick=()=>emit('controls:search',{value:s.getElementById('value').value});
s.getElementById('reverse').onclick=()=>emit('controls:reverse',{});
s.getElementById('clear').onclick=()=>emit('controls:clear',{});
s.getElementById('random').onclick=()=>emit('controls:randomize',{});
s.getElementById('undo').onclick=()=>emit('controls:undo',{});
s.getElementById('redo').onclick=()=>emit('controls:redo',{});
s.getElementById('speed').oninput=(e)=>emit('controls:speed',{speed:Number(e.target.value)});
s.getElementById('theme').onchange=(e)=>emit('controls:theme',{dark:e.target.checked});
s.getElementById('reduce').onchange=(e)=>emit('controls:reduce',{reduce:e.target.checked});
s.getElementById('test').onclick=()=>emit('controls:test',{});
this._undoBtn=s.getElementById('undo'); this._redoBtn=s.getElementById('redo');
}
setUndoRedoState({canUndo,canRedo}){ if(this._undoBtn){ this._undoBtn.disabled=!canUndo; } if(this._redoBtn){ this._redoBtn.disabled=!canRedo; } }
}
customElements.define(‘ll-controls’, LLControls);

class LLVisualizer extends HTMLElement{
constructor(){ super(); this.attachShadow({mode:‘open’}); this._arr=[]; this._highlight=-1; }
connectedCallback(){ this._render(); }
/** @param {any[]} arr @param {number} highlight /
setState(arr, highlight=-1){ this._arr=arr.slice(); this._highlight=highlight; this._render(); }
_render(){
const s=this.shadowRoot;
const arr=this._arr, hl=this._highlight;
const size=arr.length;
const nodeW=90, nodeH=44, gap=40, totalW=Math.max(320, size (nodeW+gap) + 80), totalH=120;
// Build SVG arrows
let nodesHTML=’’;
for(let i=0;i<size;i++){
const x=30 + i*(nodeW+gap), y=30;
const isHL=i===hl;
nodesHTML+=<g transform="translate(${x},${y})"> <rect rx="12" ry="12" width="${nodeW}" height="${nodeH}" fill="${isHL?'var(--highlight)':'var(--node)'}" stroke="var(--node-border)"></rect> <text x="${nodeW/2}" y="${nodeH/2+5}" text-anchor="middle" font-family="monospace" font-size="16" fill="currentColor">${String(arr[i])}</text> </g>;
// arrow to next
if(i<size-1){
const ax=x+nodeW, ay=y+nodeH/2, bx=x+nodeW+gap, by=y+nodeH/2;
nodesHTML+=<path d="M ${ax} ${ay} C ${ax+20} ${ay-10}, ${bx-20} ${by-10}, ${bx} ${by}" stroke="currentColor" stroke-opacity=".5" fill="none"></path> <polygon points="${bx} ${by} ${bx-8} ${by-4} ${bx-8} ${by+4}" fill="currentColor" fill-opacity=".5"></polygon>;
}
}
// head/tail/null labels
const headX= size? 30 : 30, headLabel = size? ‘head’ : ‘head (null)’;
const tailX= size? 30 + (size-1)(nodeW+gap) + nodeW/2 : 30;
const nullX= size? 30 + size(nodeW+gap) + 8 : 140;
s.innerHTML=<style> :host{display:block} .wrap{overflow:auto; border:1px dashed var(--edge); border-radius:10px; padding:6px; background:linear-gradient(0deg,transparent, var(--primary-weak))} svg{min-height:${totalH}px; min-width:${totalW}px} .meta{display:flex; justify-content:space-between; align-items:center; padding:6px 2px; color:var(--muted)} .tag{display:inline-flex; align-items:center; gap:6px; font-size:12px} .dot{width:10px;height:10px;border-radius:50%; background:var(--accent); display:inline-block} .legend{display:flex; gap:10px} </style> <div class="meta"> <div class="legend"> <span class="tag"><span class="dot"></span> node</span> <span class="tag"><span class="dot" style="background:var(--highlight)"></span> current</span> </div> <div>Size: <strong>${size}</strong></div> </div> <div class="wrap" role="img" aria-label="Linked list visualization"> <svg viewBox="0 0 ${totalW} ${totalH}" xmlns="http://www.w3.org/2000/svg"> ${nodesHTML} <text x="${headX}" y="16" font-size="12" fill="var(--muted)">${headLabel}</text> ${size?tail:''} <text x="${nullX}" y="${30+nodeH/2+5}" font-size="14" fill="var(--muted)">null</text> </svg> </div> ;
}
}
customElements.define(‘ll-visualizer’, LLVisualizer);

class LLInspector extends HTMLElement{
constructor(){ super(); this.attachShadow({mode:‘open’}); this._lines=[]; this._current=-1; this._op=’’; this._complexity=’’; this._step=0; this._total=0; }
connectedCallback(){ this._render(); }
setPseudo(lines){ this._lines=lines.slice(); this._render(); }
setOperation(name, totalSteps){ this._op=name; this._total=totalSteps??this._total; this._render(); }
setStep(idx){ this._step=idx; this._announce(Step ${idx+1} of ${this._total}); this._render(); }
highlightLine(i){ this._current=i; this._render(); }
setComplexity(text){ this._complexity=text; this._render(); }
log(msg,type=‘info’){ const ul=this.shadowRoot.getElementById(‘log’); const li=document.createElement(‘li’); li.textContent=msg; if(type===‘warn’) li.style.color=‘var(–warn)’; ul.appendChild(li); ul.scrollTop=ul.scrollHeight; }
clearLog(){ const ul=this.shadowRoot?.getElementById(‘log’); if(ul) ul.innerHTML=’’; }
_announce(msg){ const live=this.shadowRoot.getElementById(‘live’); live.textContent=msg; }
onControls({play, pause, step, reset}){ const s=this.shadowRoot; s.getElementById(‘play’).onclick=play; s.getElementById(‘pause’).onclick=pause; s.getElementById(‘step’).onclick=step; s.getElementById(‘reset’).onclick=reset; }
_render(){
const s=this.shadowRoot;
s.innerHTML=<style> :host{display:block} .meta{display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px} .controls{display:flex; gap:6px; flex-wrap:wrap} .controls button{border:1px solid var(--edge); border-radius:8px; padding:6px 8px; background:var(--card)} pre{ background:var(--code-bg); color:var(--code-fg); padding:8px 10px; border-radius:10px; overflow:auto; max-height:180px; margin:8px 0; } code{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:13px; line-height:1.5; display:block} .hl{background:rgba(255,255,255,.08)} .box{border:1px dashed var(--edge); border-radius:10px; padding:8px} ul{list-style:none; padding-left:14px; margin:6px 0; max-height:150px; overflow:auto} li{padding:2px 0} .muted{color:var(--muted)} </style> <div class="meta"> <div><strong>${this._op||'—'}</strong> <span class="muted">• Step ${this._step+1}/${this._total||'—'}</span></div> <div class="controls" role="group" aria-label="Playback controls"> <button id="play" title="Play (P)">Play</button> <button id="pause" title="Pause (P)">Pause</button> <button id="step" title="Step (.)">Step</button> <button id="reset" title="Reset (R)">Reset</button> </div> </div> <div class="box"> <div class="muted">Time Complexity: <strong>${this._complexity||'—'}</strong></div> <pre aria-label="Pseudo-code"><code>${this._lines.map((l,i)=> i===this._current?${l}: l).join('\n')}</code></pre> </div> <div class="box"> <div class="muted">Event Log</div> <ul id="log" aria-live="polite" aria-atomic="false"></ul> <span id="live" class="hidden-visually" aria-live="polite"></span> </div> ;
}
}
customElements.define(‘ll-inspector’, LLInspector);

/** =============================
	•	Animation Controller
	•	============================= /
/*
	•	A single animation step snapshot.
	•	{ array: any[], highlight: number, pseudoLine: number, desc: string }
*/
class Animator {
constructor(){ this.steps=[]; this.index=0; this.playing=false; this.speed=1; this.reduce=false; this._lastTs=0; this._raf=0; this.onStep=()=>{}; this.onEnd=()=>{}; }
load(steps){ this.steps=steps||[]; this.index=0; this._lastTs=0; this._tickCancel(); this.playing=false; this._emit(); }
setSpeed(s){ this.speed=s; }
setReduce(r){ this.reduce=r; }
play(){ if(this.reduce){ // jump to end, but emit each step quickly for a11y
for(let i=this.index;i<this.steps.length;i++){ this.index=i; this._emit(); }
this.index=this.steps.length-1; this._emit(); this.stop(); this.onEnd(); return;
}
if(this.playing) return; this.playing=true; this._lastTs=0; this._raf=requestAnimationFrame(this._tick.bind(this));
}
pause(){ this.playing=false; this._tickCancel(); }
stop(){ this.pause(); }
step(){ if(this.index < this.steps.length-1){ this.index++; this._emit(); if(this.index===this.steps.length-1) this.onEnd(); } }
reset(){ this.index=0; this._emit(); this.pause(); }
_tick(ts){
if(!this._lastTs) this._lastTs=ts;
const interval = 600 / this.speed; // ms per step
if(ts - this._lastTs >= interval){ this._lastTs=ts; if(this.index < this.steps.length-1){ this.index++; this._emit(); if(this.index===this.steps.length-1){ this.playing=false; this.onEnd(); return; } } }
if(this.playing) this._raf=requestAnimationFrame(this._tick.bind(this));
}
_tickCancel(){ if(this._raf) cancelAnimationFrame(this._raf); this._raf=0; }
_emit(){ if(!this.steps.length) return; this.onStep(this.steps[this.index], this.index, this.steps.length); }
}

/** =============================
	•	Application Wiring
	•	============================= /
class App {
constructor(){
this.list = new LinkedList();
/* history of arrays */
this.undoStack=[]; this.redoStack=[]; this.maxHist=10;
this.controls = document.querySelector(‘ll-controls’);
this.visual = document.querySelector(‘ll-visualizer’);
this.inspector = document.querySelector(‘ll-inspector’);
this.anim = new Animator();
this._bind();
this._refreshUI();
}
_bind(){
// controls events
this.controls.addEventListener(‘controls:push’, e=>this._op_push(e.detail.value));
this.controls.addEventListener(‘controls:unshift’, e=>this._op_unshift(e.detail.value));
this.controls.addEventListener(‘controls:insertAt’, e=>this._op_insertAt(e.detail.index, e.detail.value));
this.controls.addEventListener(‘controls:removeAt’, e=>this._op_removeAt(e.detail.index));
this.controls.addEventListener(‘controls:deleteValue’, e=>this._op_deleteValue(e.detail.value));
this.controls.addEventListener(‘controls:search’, e=>this._op_search(e.detail.value));
this.controls.addEventListener(‘controls:reverse’, ()=>this._op_reverse());
this.controls.addEventListener(‘controls:clear’, ()=>this._op_clear());
this.controls.addEventListener(‘controls:randomize’, ()=>this._randomize());
this.controls.addEventListener(‘controls:undo’, ()=>this._undo());
this.controls.addEventListener(‘controls:redo’, ()=>this._redo());
this.controls.addEventListener(‘controls:speed’, e=>{ this.anim.setSpeed(e.detail.speed); toast(Speed ${e.detail.speed}×); });
this.controls.addEventListener(‘controls:theme’, e=>{ document.documentElement.dataset.theme = e.detail.dark ? ‘dark’ : ‘’; });
this.controls.addEventListener(‘controls:reduce’, e=>{ this.anim.setReduce(e.detail.reduce); toast(e.detail.reduce?‘Reduce motion on’:‘Reduce motion off’); });
this.controls.addEventListener(‘controls:test’, ()=>this._runTests());
// animator to visual & inspector
this.anim.onStep = (step, idx, total)=>{
this.visual.setState(step.array, step.highlight);
this.inspector.setOperation(step.opName, total);
this.inspector.setStep(idx);
this.inspector.setPseudo(PSEUDOCODE[step.opKey] || []);
this.inspector.highlightLine(step.pseudoLine ?? -1);
this.inspector.setComplexity(COMPLEXITY[step.opKey] || ‘—’);
if(step.desc) this.inspector.log(step.desc);
};
this.anim.onEnd = ()=>{
// apply mutate if final desired array differs from current
const last = this.anim.steps[this.anim.steps.length-1];
if(last && last.commitArray){
this._commit(last.commitArray, last.commitOp || ‘update’);
}
};
// inspector buttons
this.inspector.onControls({
play: ()=>this.anim.play(),
pause: ()=>this.anim.pause(),
step: ()=>this.anim.step(),
reset: ()=>this.anim.reset()
});
// keyboard
window.addEventListener(‘keydown’, (e)=>{
if(e.key.toLowerCase()===‘p’){ e.preventDefault(); this.anim.playing? this.anim.pause(): this.anim.play(); }
else if(e.key===’.’){ e.preventDefault(); this.anim.step(); }
else if(e.key.toLowerCase()===‘r’){ e.preventDefault(); this.anim.reset(); }
else if(e.key.toLowerCase()===‘z’){ e.preventDefault(); this._undo(); }
else if(e.key.toLowerCase()===‘y’){ e.preventDefault(); this._redo(); }
});
}
_refreshUI(){
this.visual.setState(this.list.toArray(), -1);
this.controls.setUndoRedoState({canUndo:this.undoStack.length>0, canRedo:this.redoStack.length>0});
}
_pushHistory(arr){
this.undoStack.push(arr.slice());
if(this.undoStack.length>this.maxHist) this.undoStack.shift();
this.redoStack.length=0;
this.controls.setUndoRedoState({canUndo:this.undoStack.length>0, canRedo:this.redoStack.length>0});
}
_undo(){
if(!this.undoStack.length){ toast(‘Nothing to undo’); return; }
const current = this.list.toArray();
const prev = this.undoStack.pop();
this.redoStack.push(current);
this.list.fromArray(prev);
this._refreshUI();
this.inspector.log(‘Undo’, ‘info’);
}
_redo(){
if(!this.redoStack.length){ toast(‘Nothing to redo’); return; }
const current = this.list.toArray();
const next = this.redoStack.pop();
this.undoStack.push(current);
this.list.fromArray(next);
this._refreshUI();
this.inspector.log(‘Redo’, ‘info’);
}
_commit(arr, op){
const before = this.list.toArray();
if(JSON.stringify(arr)!==JSON.stringify(before)){
this._pushHistory(before);
this.list.fromArray(arr);
this._refreshUI();
this.inspector.log(${op} committed: [${arr.join(', ')}]);
try{ this.list._assertInvariants(); this.inspector.log(‘Invariants OK’); }
catch(err){ this.inspector.log(String(err), ‘warn’); }
}
}

/** –– Step builders (array-based visualization) –– */
_steps_traverse(opKey, opName, baseArr, targetIndex=-1, value=null){
const steps=[];
steps.push({opKey, opName, array: baseArr.slice(), highlight:-1, pseudoLine:0, desc:Start ${opName}});
if(baseArr.length===0){
steps.push({opKey, opName, array: baseArr.slice(), highlight:-1, pseudoLine:0, desc:List is empty});
return steps;
}
let lineLoop = opKey===‘search’?1: (opKey.includes(‘remove’)||opKey===‘deleteValue’||opKey===‘insertAt’?3:0);
for(let i=0;i<baseArr.length;i++){
steps.push({opKey, opName, array: baseArr.slice(), highlight:i, pseudoLine: lineLoop, desc:Visit index ${i} (value ${baseArr[i]})});
if(i===targetIndex && targetIndex>=0){
steps.push({opKey, opName, array: baseArr.slice(), highlight:i, pseudoLine: lineLoop+1, desc:Reached target index ${i}});
break;
}
if(value!=null && baseArr[i]==value){
steps.push({opKey, opName, array: baseArr.slice(), highlight:i, pseudoLine: opKey===‘search’?2:lineLoop+1, desc:Match found at index ${i}});
break;
}
}
return steps;
}
_op_push(value){
if(value===’’||value==null){ this.inspector.log(‘Enter a value to push’, ‘warn’); return; }
const arr=this.list.toArray();
const steps = this._steps_traverse(‘push’,‘push(value)’, arr);
const commit = arr.concat([value]);
steps.push({opKey:‘push’, opName:‘push(value)’, array: commit.slice(), highlight:arr.length, pseudoLine: arr.length?2:1, desc:‘Append new node’, commitArray: commit, commitOp:‘push’});
this.anim.load(steps); this.anim.play();
}
_op_unshift(value){
if(value===’’||value==null){ this.inspector.log(‘Enter a value to unshift’, ‘warn’); return; }
const arr=this.list.toArray();
const steps = [{opKey:‘unshift’, opName:‘unshift(value)’, array:arr.slice(), highlight:-1, pseudoLine:0, desc:‘Create node’}];
const commit = [value, …arr];
steps.push({opKey:‘unshift’, opName:‘unshift(value)’, array: commit.slice(), highlight:0, pseudoLine: arr.length?2:1, desc:‘Insert at head’, commitArray: commit, commitOp:‘unshift’});
this.anim.load(steps); this.anim.play();
}
_op_insertAt(index, value){
if(value===’’||value==null){ this.inspector.log(‘Enter a value to insert’, ‘warn’); return; }
index = Math.floor(Number(index));
const arr=this.list.toArray();
if(!(index>=0 && index<=arr.length)){ this.inspector.log(‘Index out of bounds’, ‘warn’); return; }
const steps = this._steps_traverse(‘insertAt’, ‘insertAt(index, value)’, arr, Math.min(index-1, arr.length-1));
const commit = arr.slice(); commit.splice(index, 0, value);
steps.push({opKey:‘insertAt’, opName:‘insertAt(index, value)’, array: commit.slice(), highlight:index, pseudoLine: 5, desc:Inserted at ${index}, commitArray: commit, commitOp:‘insertAt’});
this.anim.load(steps); this.anim.play();
}
_op_removeAt(index){
index = Math.floor(Number(index));
const arr=this.list.toArray();
if(!(index>=0 && index<arr.length)){ this.inspector.log(‘Index out of bounds’, ‘warn’); return; }
const steps = this._steps_traverse(‘removeAt’, ‘removeAt(index)’, arr, Math.min(index-1, arr.length-1));
const commit = arr.slice(); const removed = commit.splice(index,1)[0];
steps.push({opKey:‘removeAt’, opName:‘removeAt(index)’, array: commit.slice(), highlight: clamp(index,0,commit.length-1), pseudoLine: 4, desc:Removed value ${removed}, commitArray: commit, commitOp:‘removeAt’});
this.anim.load(steps); this.anim.play();
}
_op_deleteValue(value){
const arr=this.list.toArray();
if(arr.length===0){ this.inspector.log(‘List is empty’, ‘warn’); return; }
const idx = arr.indexOf(value);
const steps = this._steps_traverse(‘deleteValue’, ‘deleteValue(value)’, arr, -1, value);
if(idx===-1){
steps.push({opKey:‘deleteValue’, opName:‘deleteValue(value)’, array: arr.slice(), highlight:-1, pseudoLine:4, desc:Value not found});
}else{
const commit = arr.slice(); commit.splice(idx,1);
steps.push({opKey:‘deleteValue’, opName:‘deleteValue(value)’, array: commit.slice(), highlight: clamp(idx,0,commit.length-1), pseudoLine:6, desc:Deleted at index ${idx}, commitArray: commit, commitOp:‘deleteValue’});
}
this.anim.load(steps); this.anim.play();
}
_op_search(value){
const arr=this.list.toArray();
const steps = this._steps_traverse(‘search’, ‘search(value)’, arr, -1, value);
const idx = arr.indexOf(value);
if(idx===-1) steps.push({opKey:‘search’, opName:‘search(value)’, array: arr.slice(), highlight:-1, pseudoLine:4, desc:Not found});
this.anim.load(steps); this.anim.play();
}
_op_reverse(){
const arr=this.list.toArray();
const steps=[{opKey:‘reverse’, opName:‘reverse()’, array:arr.slice(), highlight:-1, pseudoLine:0, desc:‘Init’}];
// simulate pointer walking
for(let i=0;i<arr.length;i++){
steps.push({opKey:‘reverse’, opName:‘reverse()’, array: arr.slice().reverse().slice(arr.length-i-1).reverse(), highlight:i, pseudoLine:3, desc:Reverse link at index ${i}});
}
const commit = arr.slice().reverse();
steps.push({opKey:‘reverse’, opName:‘reverse()’, array: commit.slice(), highlight:0, pseudoLine:6, desc:‘Set head to prev’, commitArray: commit, commitOp:‘reverse’});
this.anim.load(steps); this.anim.play();
}
_op_clear(){
const arr=this.list.toArray();
const steps=[
{opKey:‘clear’, opName:‘clear()’, array:arr.slice(), highlight:-1, pseudoLine:0, desc:‘Clearing list’},
{opKey:‘clear’, opName:‘clear()’, array:[], highlight:-1, pseudoLine:0, desc:‘List cleared’, commitArray:[], commitOp:‘clear’}
];
this.anim.load(steps); this.anim.play();
}
_randomize(){
const n = 3 + Math.floor(Math.random()*5);
const arr = Array.from({length:n}, ()=> String( Math.floor(Math.random()*9) ));
this._commit(arr, ‘randomize’);
}

/** Tests */
_runTests(){
this.inspector.log(‘Running tests…’);
const L = new LinkedList();
const eq=(a,b)=>JSON.stringify(a)===JSON.stringify(b);
let ok=true;
L.unshift(3); L.push(5); L.insertAt(1,4); ok = ok && eq(L.toArray(), [3,4,5]);
L.deleteValue(4); ok = ok && eq(L.toArray(), [3,5]);
L.removeAt(1); ok = ok && eq(L.toArray(), [3]);
L.reverse(); ok = ok && eq(L.toArray(), [3]);
L.clear(); ok = ok && eq(L.toArray(), []);
this.inspector.log(ok?‘TEST PASS ✅’:‘TEST FAIL ❌’, ok?‘info’:‘warn’);
toast(ok?‘Tests passed’:‘Tests failed’);
}
}

const app = new App();
// Initialize theme based on prefers
if(window.matchMedia && window.matchMedia(’(prefers-color-scheme: dark)’).matches){
document.documentElement.dataset.theme=‘dark’;
}
</body>
</html>
