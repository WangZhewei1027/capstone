<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Interactive Gradient Descent Playground</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #0e1116;
        --panel: #161a22;
        --accent: #5dd0ff;
        --accent2: #ffb86b;
        --accent3: #a1e46d;
        --text: #e7e9ee;
        --muted: #99a2b2;
        --danger: #ff6b6b;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, "Apple Color Emoji", "Segoe UI Emoji";
        line-height: 1.4;
      }
      header {
        padding: 16px 20px;
        border-bottom: 1px solid #222838;
        background: linear-gradient(180deg, #111522 0%, #10131a 100%);
        position: sticky;
        top: 0;
        z-index: 10;
      }
      header h1 {
        margin: 0;
        font-size: 20px;
        letter-spacing: 0.3px;
      }
      header p {
        margin: 6px 0 0 0;
        color: var(--muted);
        font-size: 13px;
      }
      .container {
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 16px;
        padding: 16px;
      }
      @media (max-width: 1100px) {
        .container {
          grid-template-columns: 1fr;
        }
      }
      .panel {
        background: var(--panel);
        border: 1px solid #222838;
        border-radius: 12px;
        padding: 14px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
      }
      .panel h2 {
        font-size: 16px;
        margin: 4px 0 12px;
        color: #d9deea;
      }
      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      .control {
        margin-bottom: 10px;
        padding-bottom: 10px;
        border-bottom: 1px dashed #242b3a;
      }
      .control:last-child {
        border-bottom: none;
      }
      label {
        font-size: 13px;
        color: var(--muted);
      }
      select,
      input[type="number"],
      input[type="text"] {
        background: #0f1219;
        color: var(--text);
        border: 1px solid #2a3144;
        border-radius: 8px;
        padding: 6px 8px;
        font-size: 14px;
        outline: none;
      }
      input[type="range"] {
        width: 200px;
        accent-color: var(--accent);
      }
      .btn {
        background: #0f1219;
        color: var(--text);
        border: 1px solid #2a3144;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: 0.15s ease background, 0.15s ease border-color,
          0.15s ease transform;
        user-select: none;
      }
      .btn:hover {
        border-color: #3a4563;
      }
      .btn:active {
        transform: translateY(1px);
      }
      .btn.primary {
        background: linear-gradient(180deg, #1f5270, #1b2c3c);
        border-color: #296a8d;
      }
      .btn.warn {
        background: linear-gradient(180deg, #6e2a2a, #3c1b1b);
        border-color: #8d2929;
      }
      .badge {
        display: inline-block;
        padding: 2px 8px;
        font-size: 12px;
        border-radius: 999px;
        background: #0f1626;
        border: 1px solid #2a3144;
        color: #dbe7f7;
        margin-left: 8px;
      }
      .tiny {
        font-size: 12px;
        color: var(--muted);
      }
      .flex {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }
      .spacer {
        flex: 1;
      }
      .canvas-wrap {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }
      canvas {
        background: #0b0e14;
        border: 1px solid #222838;
        border-radius: 10px;
        display: block;
        width: 100%;
        height: 360px;
      }
      .small-canvas {
        height: 180px;
      }
      .info {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 13px;
        background: #0b0e14;
        border: 1px solid #222838;
        border-radius: 10px;
        padding: 10px;
        white-space: pre-line;
        color: #cfe2ff;
      }
      .legend {
        display: flex;
        gap: 14px;
        flex-wrap: wrap;
        font-size: 12px;
        color: var(--muted);
      }
      .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 6px;
        vertical-align: middle;
      }
      .dot.func {
        background: var(--accent);
      }
      .dot.point {
        background: var(--accent2);
      }
      .dot.path {
        background: var(--accent3);
      }
      .dot.grad {
        background: #c084fc;
      }
      .muted {
        color: var(--muted);
      }
      .divider {
        height: 1px;
        background: #222838;
        margin: 10px 0;
      }
      .kbd {
        border: 1px solid #3a4563;
        background: #111522;
        border-radius: 6px;
        padding: 2px 6px;
        font-size: 12px;
        color: #cfe2ff;
      }
      .checkbox {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
      }
      .footer-note {
        font-size: 12px;
        color: var(--muted);
        margin-top: 6px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Gradient Descent Interactive Playground</h1>
      <p>
        Click on the graph to set the starting point. Use Start, Step, and
        controls to watch gradient descent unfold.
      </p>
    </header>

    <div class="container">
      <div class="panel" id="controlsPanel">
        <h2>Controls</h2>

        <div class="control">
          <div class="row">
            <label for="funcSelect">Objective function</label>
            <select id="funcSelect"></select>
          </div>
          <div class="tiny">
            Domain shown adapts per function. You can click the plot to set x.
          </div>
        </div>

        <div class="control">
          <div class="row">
            <label
              >Learning rate η: <span class="badge" id="lrVal"></span
            ></label>
          </div>
          <div class="row">
            <input
              type="range"
              id="lrSlider"
              min="0.0001"
              max="1"
              step="0.0001"
              value="0.1"
            />
            <input
              type="number"
              id="lrInput"
              step="0.0001"
              min="0.000001"
              max="5"
              value="0.1"
              style="width: 100px"
            />
            <button class="btn" id="suggestLRBtn" title="Set to suggested η">
              Use suggested
            </button>
          </div>
        </div>

        <div class="control">
          <div class="row">
            <label class="checkbox"
              ><input type="checkbox" id="momentumChk" /> Use momentum</label
            >
            <span class="tiny">v = β v - η g, x ← x + v</span>
          </div>
          <div class="row">
            <label>β: <span class="badge" id="betaVal"></span></label>
          </div>
          <div class="row">
            <input
              type="range"
              id="betaSlider"
              min="0"
              max="0.99"
              step="0.01"
              value="0.90"
            />
            <input
              type="number"
              id="betaInput"
              step="0.01"
              min="0"
              max="0.999"
              value="0.90"
              style="width: 100px"
            />
          </div>
        </div>

        <div class="control">
          <div class="row">
            <label class="checkbox"
              ><input type="checkbox" id="noiseChk" /> Add gradient noise</label
            >
            <span class="tiny">ĝ = g + N(0, σ²)</span>
          </div>
          <div class="row">
            <label>σ: <span class="badge" id="sigmaVal"></span></label>
          </div>
          <div class="row">
            <input
              type="range"
              id="sigmaSlider"
              min="0"
              max="2"
              step="0.01"
              value="0.00"
            />
            <input
              type="number"
              id="sigmaInput"
              step="0.01"
              min="0"
              max="5"
              value="0.00"
              style="width: 100px"
            />
          </div>
        </div>

        <div class="control">
          <div class="row">
            <label>Initial x₀</label>
            <input
              type="number"
              id="x0Input"
              step="0.01"
              value="0"
              style="width: 120px"
            />
            <button
              class="btn"
              id="randomX0Btn"
              title="Pick random x within domain"
            >
              Random
            </button>
            <button class="btn" id="resetBtn">Reset</button>
          </div>
          <div class="tiny">
            Tip: Click anywhere on the curve to set x₀ directly.
          </div>
        </div>

        <div class="control">
          <div class="row">
            <button class="btn primary" id="startStopBtn">Start</button>
            <button class="btn" id="stepBtn" title="Single step (Space)">
              Step
            </button>
            <button class="btn warn" id="clearBtn">Clear path</button>
            <span class="spacer"></span>
            <label>Speed: <span class="badge" id="speedVal"></span></label>
          </div>
          <div class="row">
            <input
              type="range"
              id="speedSlider"
              min="10"
              max="1000"
              step="10"
              value="300"
            />
            <span class="tiny">ms per step</span>
          </div>
          <div class="row">
            <label class="checkbox"
              ><input type="checkbox" id="autoStopChk" checked /> Auto-stop when
              |g| < tol</label
            >
            <label
              >tol:
              <input
                type="number"
                id="tolInput"
                step="0.0001"
                value="0.001"
                style="width: 100px"
            /></label>
            <label
              >Max iters:
              <input
                type="number"
                id="maxIterInput"
                min="1"
                step="1"
                value="300"
                style="width: 90px"
            /></label>
          </div>
        </div>

        <div class="control">
          <div class="row">
            <label class="checkbox"
              ><input type="checkbox" id="showTangentChk" checked /> Show
              tangent line</label
            >
          </div>
          <div class="row">
            <label class="checkbox"
              ><input type="checkbox" id="showGradArrowChk" checked /> Show
              gradient & step arrows</label
            >
          </div>
          <div class="row">
            <label class="checkbox"
              ><input type="checkbox" id="showPathChk" checked /> Show visited
              points</label
            >
          </div>
        </div>

        <div class="footer-note">
          Keyboard: <span class="kbd">Space</span> = Step,
          <span class="kbd">Enter</span> = Start/Stop,
          <span class="kbd">R</span> = Reset
        </div>
      </div>

      <div class="panel">
        <div class="canvas-wrap">
          <div class="legend">
            <div><span class="dot func"></span>f(x)</div>
            <div><span class="dot point"></span>current x</div>
            <div><span class="dot path"></span>path</div>
            <div>
              <span class="dot grad" style="background: #c084fc"></span
              >gradient/step
            </div>
          </div>
          <canvas id="funcCanvas"></canvas>
          <div class="info" id="stepInfo"></div>
          <canvas id="lossCanvas" class="small-canvas"></canvas>
        </div>
      </div>
    </div>

    <script>
      // Utilities
      function clamp(n, a, b) {
        return Math.max(a, Math.min(b, n));
      }
      function fmt(n, digits = 6) {
        if (!Number.isFinite(n)) return String(n);
        const abs = Math.abs(n);
        if (abs !== 0 && (abs >= 1e6 || abs < 1e-3)) return n.toExponential(3);
        return n.toFixed(digits);
      }
      function randn() {
        // Box-Muller
        let u = 0,
          v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
      }

      // Function definitions
      const FUNCTIONS = [
        {
          id: "quadratic",
          name: "Convex: f(x) = (x - 2)^2 + 1",
          f: (x) => (x - 2) * (x - 2) + 1,
          df: (x) => 2 * (x - 2),
          domain: [-6, 10],
          x0: -4,
          suggestedLR: 0.2,
        },
        {
          id: "quartic",
          name: "Non-convex: f(x) = x^4 - 3x^3 + 2",
          f: (x) => x ** 4 - 3 * x ** 3 + 2,
          df: (x) => 4 * x ** 3 - 9 * x ** 2,
          domain: [-1, 4.5],
          x0: 4,
          suggestedLR: 0.005,
        },
        {
          id: "sinequad",
          name: "Non-convex: f(x) = sin(3x) + 0.3x^2",
          f: (x) => Math.sin(3 * x) + 0.3 * x * x,
          df: (x) => 3 * Math.cos(3 * x) + 0.6 * x,
          domain: [-8, 8],
          x0: 5,
          suggestedLR: 0.05,
        },
      ];

      // Graphing helpers (1D)
      class Graph1D {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");
          this.margin = { left: 48, right: 16, top: 16, bottom: 36 };
          this.xMin = -5;
          this.xMax = 5;
          this.yMin = -2;
          this.yMax = 10;
          this.dpr = 1;
          this.resizeObserver = new ResizeObserver(() => this.resize());
          this.resizeObserver.observe(this.canvas);
          this.resize();
        }
        setDomain(xMin, xMax) {
          this.xMin = xMin;
          this.xMax = xMax;
        }
        setYRange(yMin, yMax) {
          this.yMin = yMin;
          this.yMax = yMax;
        }
        resize() {
          const rect = this.canvas.getBoundingClientRect();
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          this.dpr = dpr;
          this.canvas.width = Math.floor(rect.width * dpr);
          this.canvas.height = Math.floor(rect.height * dpr);
          this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          this.draw(); // redraw on resize
        }
        get innerW() {
          return (
            this.canvas.getBoundingClientRect().width -
            this.margin.left -
            this.margin.right
          );
        }
        get innerH() {
          return (
            this.canvas.getBoundingClientRect().height -
            this.margin.top -
            this.margin.bottom
          );
        }
        xToPx(x) {
          const t = (x - this.xMin) / (this.xMax - this.xMin);
          return this.margin.left + t * this.innerW;
        }
        yToPx(y) {
          const t = (y - this.yMin) / (this.yMax - this.yMin);
          return this.margin.top + (1 - t) * this.innerH;
        }
        pxToX(px) {
          const t = (px - this.margin.left) / this.innerW;
          return this.xMin + t * (this.xMax - this.xMin);
        }
        drawAxes() {
          const ctx = this.ctx;
          ctx.save();
          ctx.lineWidth = 1;
          ctx.strokeStyle = "#273043";
          ctx.fillStyle = "#6f7a91";
          // X axis (y=0)
          if (this.yMin < 0 && this.yMax > 0) {
            const y0 = this.yToPx(0);
            ctx.beginPath();
            ctx.moveTo(this.margin.left, y0);
            ctx.lineTo(this.margin.left + this.innerW, y0);
            ctx.stroke();
          }
          // Y axis (x=0)
          if (this.xMin < 0 && this.xMax > 0) {
            const x0 = this.xToPx(0);
            ctx.beginPath();
            ctx.moveTo(x0, this.margin.top);
            ctx.lineTo(x0, this.margin.top + this.innerH);
            ctx.stroke();
          }
          // Ticks
          ctx.font =
            "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "top";
          const nTicksX = 8;
          for (let i = 0; i <= nTicksX; i++) {
            const t = i / nTicksX;
            const x = this.xMin + t * (this.xMax - this.xMin);
            const px = this.xToPx(x);
            const py = this.margin.top + this.innerH;
            ctx.strokeStyle = "#1e2331";
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(px, py + 4);
            ctx.stroke();
            ctx.fillStyle = "#6f7a91";
            ctx.fillText(fmt(x, 2), px, py + 6);
          }
          ctx.textAlign = "right";
          ctx.textBaseline = "middle";
          const nTicksY = 6;
          for (let i = 0; i <= nTicksY; i++) {
            const t = i / nTicksY;
            const y = this.yMin + t * (this.yMax - this.yMin);
            const py = this.yToPx(y);
            const px = this.margin.left;
            ctx.strokeStyle = "#1e2331";
            ctx.beginPath();
            ctx.moveTo(px - 4, py);
            ctx.lineTo(px, py);
            ctx.stroke();
            ctx.fillStyle = "#6f7a91";
            ctx.fillText(fmt(y, 2), px - 6, py);
          }
          ctx.restore();
        }
        drawArrow(x1, y1, x2, y2, color = "#c084fc") {
          const ctx = this.ctx;
          const angle = Math.atan2(y2 - y1, x2 - x1);
          const head = 8;
          ctx.save();
          ctx.strokeStyle = color;
          ctx.fillStyle = color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x2, y2);
          ctx.lineTo(
            x2 - head * Math.cos(angle - Math.PI / 6),
            y2 - head * Math.sin(angle - Math.PI / 6)
          );
          ctx.lineTo(
            x2 - head * Math.cos(angle + Math.PI / 6),
            y2 - head * Math.sin(angle + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        clear() {
          const ctx = this.ctx;
          const rect = this.canvas.getBoundingClientRect();
          ctx.save();
          ctx.clearRect(0, 0, rect.width, rect.height);
          ctx.restore();
        }
        draw() {
          // placeholder; actual drawing done by external controller
          const ctx = this.ctx;
          const rect = this.canvas.getBoundingClientRect();
          ctx.save();
          ctx.clearRect(0, 0, rect.width, rect.height);
          this.drawAxes();
          ctx.restore();
        }
      }

      // Loss graph
      class LossGraph {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");
          this.margin = { left: 48, right: 16, top: 16, bottom: 30 };
          this.xMin = 0;
          this.xMax = 100;
          this.yMin = 0;
          this.yMax = 1;
          this.resizeObserver = new ResizeObserver(() => this.resize());
          this.resizeObserver.observe(this.canvas);
          this.resize();
        }
        resize() {
          const rect = this.canvas.getBoundingClientRect();
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          this.canvas.width = Math.floor(rect.width * dpr);
          this.canvas.height = Math.floor(rect.height * dpr);
          this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          this.draw([]);
        }
        xToPx(x) {
          const innerW =
            this.canvas.getBoundingClientRect().width -
            this.margin.left -
            this.margin.right;
          return (
            this.margin.left +
            ((x - this.xMin) / (this.xMax - this.xMin)) * innerW
          );
        }
        yToPx(y) {
          const innerH =
            this.canvas.getBoundingClientRect().height -
            this.margin.top -
            this.margin.bottom;
          return (
            this.margin.top +
            (1 - (y - this.yMin) / (this.yMax - this.yMin)) * innerH
          );
        }
        drawAxes() {
          const ctx = this.ctx;
          const rect = this.canvas.getBoundingClientRect();
          const innerW = rect.width - this.margin.left - this.margin.right;
          const innerH = rect.height - this.margin.top - this.margin.bottom;
          ctx.save();
          ctx.lineWidth = 1;
          ctx.strokeStyle = "#273043";
          // Axes
          ctx.beginPath();
          ctx.moveTo(this.margin.left, this.margin.top + innerH);
          ctx.lineTo(this.margin.left + innerW, this.margin.top + innerH);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(this.margin.left, this.margin.top);
          ctx.lineTo(this.margin.left, this.margin.top + innerH);
          ctx.stroke();

          // Labels/ticks
          ctx.fillStyle = "#6f7a91";
          ctx.font =
            "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "top";
          const nX = 6;
          for (let i = 0; i <= nX; i++) {
            const x = this.xMin + (i * (this.xMax - this.xMin)) / nX;
            const px = this.xToPx(x);
            const py = this.margin.top + innerH;
            ctx.strokeStyle = "#1e2331";
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(px, py + 4);
            ctx.stroke();
            ctx.fillText(Math.round(x), px, py + 6);
          }
          ctx.textAlign = "right";
          ctx.textBaseline = "middle";
          const nY = 4;
          for (let i = 0; i <= nY; i++) {
            const y = this.yMin + (i * (this.yMax - this.yMin)) / nY;
            const py = this.yToPx(y);
            const px = this.margin.left;
            ctx.strokeStyle = "#1e2331";
            ctx.beginPath();
            ctx.moveTo(px - 4, py);
            ctx.lineTo(px, py);
            ctx.stroke();
            ctx.fillText(fmt(y, 2), px - 6, py);
          }
          ctx.restore();
        }
        draw(history) {
          const ctx = this.ctx;
          const rect = this.canvas.getBoundingClientRect();
          ctx.clearRect(0, 0, rect.width, rect.height);
          if (history.length === 0) {
            this.drawAxes();
            return;
          }
          // Update ranges
          const xs = history.map((_, i) => i);
          const ys = history.map((h) => h.fx);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          this.xMin = 0;
          this.xMax = Math.max(10, history.length - 1);
          if (Number.isFinite(minY) && Number.isFinite(maxY)) {
            const pad = 0.1 * Math.max(1e-6, maxY - minY);
            this.yMin = minY - pad;
            this.yMax = maxY + pad;
            if (this.yMin === this.yMax) {
              this.yMin -= 1;
              this.yMax += 1;
            }
          }
          this.drawAxes();
          // Draw line
          ctx.save();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#a1e46d";
          ctx.beginPath();
          for (let i = 0; i < history.length; i++) {
            const px = this.xToPx(i);
            const py = this.yToPx(history[i].fx);
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.stroke();
          // Draw points
          ctx.fillStyle = "#a1e46d";
          for (let i = 0; i < history.length; i++) {
            const px = this.xToPx(i);
            const py = this.yToPx(history[i].fx);
            ctx.beginPath();
            ctx.arc(px, py, 2.5, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }
      }

      // State
      const state = {
        func: FUNCTIONS[0],
        x: FUNCTIONS[0].x0,
        v: 0,
        iter: 0,
        history: [],
        running: false,
        timer: null,
        settings: {
          lr: 0.1,
          momentum: false,
          beta: 0.9,
          noise: false,
          sigma: 0,
          showTangent: true,
          showGradArrow: true,
          showPath: true,
          speedMs: 300,
          autoStop: true,
          tol: 1e-3,
          maxIter: 300,
        },
      };

      // UI elements
      const funcSelect = document.getElementById("funcSelect");
      const lrSlider = document.getElementById("lrSlider");
      const lrInput = document.getElementById("lrInput");
      const lrVal = document.getElementById("lrVal");
      const suggestLRBtn = document.getElementById("suggestLRBtn");
      const momentumChk = document.getElementById("momentumChk");
      const betaSlider = document.getElementById("betaSlider");
      const betaInput = document.getElementById("betaInput");
      const betaVal = document.getElementById("betaVal");
      const noiseChk = document.getElementById("noiseChk");
      const sigmaSlider = document.getElementById("sigmaSlider");
      const sigmaInput = document.getElementById("sigmaInput");
      const sigmaVal = document.getElementById("sigmaVal");
      const x0Input = document.getElementById("x0Input");
      const randomX0Btn = document.getElementById("randomX0Btn");
      const resetBtn = document.getElementById("resetBtn");
      const startStopBtn = document.getElementById("startStopBtn");
      const stepBtn = document.getElementById("stepBtn");
      const clearBtn = document.getElementById("clearBtn");
      const speedSlider = document.getElementById("speedSlider");
      const speedVal = document.getElementById("speedVal");
      const autoStopChk = document.getElementById("autoStopChk");
      const tolInput = document.getElementById("tolInput");
      const maxIterInput = document.getElementById("maxIterInput");
      const showTangentChk = document.getElementById("showTangentChk");
      const showGradArrowChk = document.getElementById("showGradArrowChk");
      const showPathChk = document.getElementById("showPathChk");

      const funcCanvas = document.getElementById("funcCanvas");
      const lossCanvas = document.getElementById("lossCanvas");
      const stepInfo = document.getElementById("stepInfo");

      const graph = new Graph1D(funcCanvas);
      const lossGraph = new LossGraph(lossCanvas);

      // Populate functions
      for (const f of FUNCTIONS) {
        const opt = document.createElement("option");
        opt.value = f.id;
        opt.textContent = f.name;
        funcSelect.appendChild(opt);
      }
      funcSelect.value = state.func.id;

      function numericGrad(f, x) {
        const h = 1e-6 * (1 + Math.abs(x));
        return (f(x + h) - f(x - h)) / (2 * h);
      }

      function pickFunction(id) {
        const f = FUNCTIONS.find((o) => o.id === id) || FUNCTIONS[0];
        state.func = f;
        // Reset y-range by sampling
        const samples = 400;
        const xs = [];
        const ys = [];
        for (let i = 0; i <= samples; i++) {
          const x = f.domain[0] + (i / samples) * (f.domain[1] - f.domain[0]);
          const y = f.f(x);
          xs.push(x);
          ys.push(y);
        }
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        const padY = 0.1 * Math.max(1e-6, maxY - minY);
        graph.setDomain(f.domain[0], f.domain[1]);
        graph.setYRange(minY - padY, maxY + padY);
        // Update x0 and learning rate UI
        x0Input.value = f.x0;
        if (!state.running) {
          state.x = f.x0;
          state.v = 0;
          state.iter = 0;
          state.history = [];
        }
        lrSlider.value = f.suggestedLR.toString();
        lrInput.value = f.suggestedLR.toString();
        state.settings.lr = f.suggestedLR;
        updateLrBadge();
        drawAll();
      }

      function updateLrBadge() {
        const lr = parseFloat(lrInput.value);
        lrVal.textContent = lr.toFixed(6);
      }
      function updateBetaBadge() {
        const beta = parseFloat(betaInput.value);
        betaVal.textContent = beta.toFixed(2);
      }
      function updateSigmaBadge() {
        const sigma = parseFloat(sigmaInput.value);
        sigmaVal.textContent = sigma.toFixed(2);
      }
      function updateSpeedBadge() {
        const ms = parseInt(speedSlider.value, 10);
        speedVal.textContent = ms + " ms";
      }

      function reset(runPreserve = false) {
        state.x = parseFloat(x0Input.value);
        if (!Number.isFinite(state.x)) state.x = state.func.x0;
        state.x = clamp(state.x, state.func.domain[0], state.func.domain[1]);
        state.v = 0;
        state.iter = 0;
        if (!runPreserve) state.history = [];
        drawAll();
      }

      function clearPath() {
        state.history = [];
        state.iter = 0;
        drawAll();
      }

      function step() {
        const { f, df } = state.func;
        const s = state.settings;
        const x = state.x;
        const fx = f(x);
        let grad = df(x);
        const gradNum = numericGrad(f, x);
        let noise = 0;
        if (s.noise && s.sigma > 0) noise = randn() * s.sigma;
        const gradHat = grad + noise;
        let vPrev = state.v;
        let vNew = vPrev;
        let xNew;
        if (s.momentum) {
          // Classical momentum: v = β v - η ĝ; x += v
          vNew = s.beta * vPrev - s.lr * gradHat;
          xNew = x + vNew;
        } else {
          xNew = x - s.lr * gradHat;
        }

        // Clamp within a slightly extended domain to avoid flying away
        const pad = 0.1 * (state.func.domain[1] - state.func.domain[0]);
        const hardMin = state.func.domain[0] - pad;
        const hardMax = state.func.domain[1] + pad;
        xNew = clamp(xNew, hardMin, hardMax);

        // Record history
        state.history.push({
          x,
          fx,
          grad,
          gradNum,
          gradHat,
          vPrev,
          vNew,
          lr: s.lr,
        });
        state.x = xNew;
        state.v = vNew;
        state.iter += 1;

        // Auto-stop
        const stopByTol = s.autoStop && Math.abs(grad) < s.tol;
        const stopByIter = state.iter >= s.maxIter;
        if (stopByTol || stopByIter) stop();
        drawAll();
      }

      function start() {
        if (state.running) return;
        state.running = true;
        startStopBtn.textContent = "Pause";
        const tick = () => {
          if (!state.running) return;
          step();
          state.timer = setTimeout(
            () => requestAnimationFrame(tick),
            state.settings.speedMs
          );
        };
        tick();
      }
      function stop() {
        state.running = false;
        startStopBtn.textContent = "Start";
        if (state.timer) {
          clearTimeout(state.timer);
          state.timer = null;
        }
        drawAll();
      }
      function toggleRun() {
        if (state.running) stop();
        else start();
      }

      function drawFunctionAndState() {
        const ctx = graph.ctx;
        const rect = graph.canvas.getBoundingClientRect();
        ctx.clearRect(0, 0, rect.width, rect.height);
        graph.drawAxes();

        const { f, df, domain } = state.func;

        // Draw function curve
        ctx.save();
        ctx.strokeStyle = "#5dd0ff";
        ctx.lineWidth = 2;
        const samples = Math.floor(graph.innerW);
        ctx.beginPath();
        for (let i = 0; i <= samples; i++) {
          const x = graph.xMin + (i / samples) * (graph.xMax - graph.xMin);
          const y = f(x);
          const px = graph.xToPx(x);
          const py = graph.yToPx(y);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
        ctx.restore();

        // Path history
        if (state.settings.showPath && state.history.length > 0) {
          ctx.save();
          ctx.strokeStyle = "#a1e46d";
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let i = 0; i < state.history.length; i++) {
            const hx = state.history[i].x;
            const hy = f(hx);
            const px = graph.xToPx(hx);
            const py = graph.yToPx(hy);
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.stroke();
          ctx.fillStyle = "#a1e46d";
          for (let i = 0; i < state.history.length; i++) {
            const hx = state.history[i].x;
            const hy = f(hx);
            const px = graph.xToPx(hx);
            const py = graph.yToPx(hy);
            ctx.beginPath();
            ctx.arc(px, py, 2.5, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        // Current point
        const x = state.x;
        const y = f(x);
        const grad = df(x);
        const px = graph.xToPx(x);
        const py = graph.yToPx(y);

        // Tangent line
        if (state.settings.showTangent) {
          ctx.save();
          ctx.strokeStyle = "#7aa2f7";
          ctx.setLineDash([6, 6]);
          ctx.lineWidth = 1.5;
          const tx1 = graph.xMin,
            tx2 = graph.xMax;
          const ty1 = y + grad * (tx1 - x);
          const ty2 = y + grad * (tx2 - x);
          ctx.beginPath();
          ctx.moveTo(graph.xToPx(tx1), graph.yToPx(ty1));
          ctx.lineTo(graph.xToPx(tx2), graph.yToPx(ty2));
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        }

        // Gradient and step arrows
        if (state.settings.showGradArrow) {
          // Arrow for -η g (horizontal displacement)
          const dx = state.settings.momentum
            ? state.v
            : -state.settings.lr * grad; // show current direction
          const scale = 1.0; // already in x-units
          const x2 = x + dx * scale;
          const px2 = graph.xToPx(x2);
          graph.drawArrow(px, py, px2, py, "#c084fc");

          // Also draw vertical gradient indication at the point (slope sign)
          const gNorm = grad;
          const gLen = Math.sign(gNorm) * 40; // just a visual at the point indicating slope direction
          graph.drawArrow(px, py, px, py - gLen, "#c084fc");
        }

        // Draw current point
        ctx.save();
        ctx.fillStyle = "#ffb86b";
        ctx.strokeStyle = "#ffb86b";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawLoss() {
        lossGraph.draw(state.history);
      }

      function updateInfo() {
        const { f, df } = state.func;
        const s = state.settings;
        const i = Math.max(0, state.history.length - 1);
        const currentX = state.history.length
          ? state.history[state.history.length - 1].x
          : state.x;
        const currentF = f(state.x);
        const grad = df(state.x);
        const gradNum = numericGrad(f, state.x);

        let last = null;
        if (state.history.length)
          last = state.history[state.history.length - 1];

        const lines = [];
        lines.push(`Iteration t = ${state.iter}`);
        lines.push(`x_t = ${fmt(state.x)}    f(x_t) = ${fmt(currentF)}`);
        lines.push(
          `Analytic grad g = f'(x_t) = ${fmt(grad)}    Numeric grad ≈ ${fmt(
            gradNum
          )}    |Δ| = ${fmt(Math.abs(grad - gradNum))}`
        );
        if (s.noise) {
          const ghat = last ? last.gradHat : grad;
          lines.push(
            `With noise: ĝ = g + N(0, σ²) = ${fmt(ghat)} (σ = ${fmt(
              s.sigma,
              2
            )})`
          );
        }
        if (s.momentum) {
          const vprev = last ? last.vPrev : 0;
          const vnew = last ? last.vNew : 0;
          const ghat = last ? last.gradHat : grad;
          lines.push(
            `Momentum: v_t = β v_{t-1} - η ĝ = ${fmt(s.beta)} * ${fmt(
              vprev
            )} - ${fmt(s.lr)} * ${fmt(ghat)} = ${fmt(vnew)}`
          );
          lines.push(
            `Update:   x_{t+1} = x_t + v_t = ${fmt(
              state.history.length ? last.x : state.x
            )} + ${fmt(vnew)} = ${fmt(state.x)}`
          );
        } else {
          const ghat = last ? last.gradHat : grad;
          const xprev = last ? last.x : state.x;
          const xnew = state.x;
          lines.push(
            `Update:   x_{t+1} = x_t - η ĝ = ${fmt(xprev)} - ${fmt(
              s.lr
            )} * ${fmt(ghat)} = ${fmt(xnew)}`
          );
        }
        if (s.autoStop) {
          lines.push(
            `Auto-stop: |g| < tol?  ${
              Math.abs(grad) < s.tol ? "Yes" : "No"
            }   (tol = ${fmt(s.tol, 4)})`
          );
        }
        lines.push("");
        lines.push("Instructions:");
        lines.push("- Click on the top graph to set x.");
        lines.push("- Press Step to take one update or Start to animate.");
        lines.push("- Toggle tangent/gradient/path visibility for clarity.");

        stepInfo.textContent = lines.join("\n");
      }

      function drawAll() {
        drawFunctionAndState();
        drawLoss();
        updateInfo();
      }

      // Event listeners
      funcSelect.addEventListener("change", () => {
        pickFunction(funcSelect.value);
      });

      lrSlider.addEventListener("input", () => {
        lrInput.value = lrSlider.value;
        state.settings.lr = parseFloat(lrSlider.value);
        updateLrBadge();
        drawAll();
      });
      lrInput.addEventListener("input", () => {
        const val = parseFloat(lrInput.value);
        if (Number.isFinite(val)) {
          lrSlider.value = val.toString();
          state.settings.lr = val;
          updateLrBadge();
          drawAll();
        }
      });
      suggestLRBtn.addEventListener("click", () => {
        const suggested = state.func.suggestedLR;
        lrSlider.value = suggested.toString();
        lrInput.value = suggested.toString();
        state.settings.lr = suggested;
        updateLrBadge();
        drawAll();
      });

      momentumChk.addEventListener("change", () => {
        state.settings.momentum = momentumChk.checked;
        drawAll();
      });
      betaSlider.addEventListener("input", () => {
        betaInput.value = betaSlider.value;
        state.settings.beta = parseFloat(betaSlider.value);
        updateBetaBadge();
        drawAll();
      });
      betaInput.addEventListener("input", () => {
        const val = parseFloat(betaInput.value);
        if (Number.isFinite(val)) {
          betaSlider.value = val.toString();
          state.settings.beta = val;
          updateBetaBadge();
          drawAll();
        }
      });

      noiseChk.addEventListener("change", () => {
        state.settings.noise = noiseChk.checked;
        drawAll();
      });
      sigmaSlider.addEventListener("input", () => {
        sigmaInput.value = sigmaSlider.value;
        state.settings.sigma = parseFloat(sigmaSlider.value);
        updateSigmaBadge();
        drawAll();
      });
      sigmaInput.addEventListener("input", () => {
        const val = parseFloat(sigmaInput.value);
        if (Number.isFinite(val)) {
          sigmaSlider.value = val.toString();
          state.settings.sigma = val;
          updateSigmaBadge();
          drawAll();
        }
      });

      x0Input.addEventListener("change", () => {
        state.x = parseFloat(x0Input.value);
        if (!Number.isFinite(state.x)) state.x = state.func.x0;
        state.x = clamp(state.x, state.func.domain[0], state.func.domain[1]);
        drawAll();
      });
      randomX0Btn.addEventListener("click", () => {
        const [a, b] = state.func.domain;
        const x = a + Math.random() * (b - a);
        x0Input.value = x.toFixed(3);
        reset();
      });
      resetBtn.addEventListener("click", () => {
        stop();
        reset(false);
      });
      clearBtn.addEventListener("click", () => {
        clearPath();
      });

      startStopBtn.addEventListener("click", () => toggleRun());
      stepBtn.addEventListener("click", () => {
        stop();
        step();
      });

      speedSlider.addEventListener("input", () => {
        state.settings.speedMs = parseInt(speedSlider.value, 10);
        updateSpeedBadge();
      });

      autoStopChk.addEventListener("change", () => {
        state.settings.autoStop = autoStopChk.checked;
        drawAll();
      });
      tolInput.addEventListener("input", () => {
        const v = parseFloat(tolInput.value);
        if (Number.isFinite(v) && v > 0) {
          state.settings.tol = v;
          drawAll();
        }
      });
      maxIterInput.addEventListener("input", () => {
        const v = parseInt(maxIterInput.value, 10);
        if (Number.isFinite(v) && v >= 1) state.settings.maxIter = v;
      });

      showTangentChk.addEventListener("change", () => {
        state.settings.showTangent = showTangentChk.checked;
        drawAll();
      });
      showGradArrowChk.addEventListener("change", () => {
        state.settings.showGradArrow = showGradArrowChk.checked;
        drawAll();
      });
      showPathChk.addEventListener("change", () => {
        state.settings.showPath = showPathChk.checked;
        drawAll();
      });

      // Canvas interactions: click to set x
      funcCanvas.addEventListener("mousedown", (e) => {
        const rect = funcCanvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const x = graph.pxToX(px);
        state.x = clamp(x, state.func.domain[0], state.func.domain[1]);
        if (!state.running) {
          x0Input.value = state.x.toFixed(3);
        }
        drawAll();
        // Enable drag
        let dragging = true;
        function onMove(ev) {
          if (!dragging) return;
          const px2 = ev.clientX - rect.left;
          const x2 = graph.pxToX(px2);
          state.x = clamp(x2, state.func.domain[0], state.func.domain[1]);
          if (!state.running) x0Input.value = state.x.toFixed(3);
          drawAll();
        }
        function onUp() {
          dragging = false;
          window.removeEventListener("mousemove", onMove);
          window.removeEventListener("mouseup", onUp);
        }
        window.addEventListener("mousemove", onMove);
        window.addEventListener("mouseup", onUp);
      });

      // Keyboard shortcuts
      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          stop();
          step();
        } else if (e.code === "Enter") {
          e.preventDefault();
          toggleRun();
        } else if (e.key.toLowerCase() === "r") {
          e.preventDefault();
          stop();
          reset();
        }
      });

      // Initialize UI with defaults
      function initUI() {
        lrSlider.value = state.settings.lr.toString();
        lrInput.value = state.settings.lr.toString();
        momentumChk.checked = state.settings.momentum;
        betaSlider.value = state.settings.beta.toString();
        betaInput.value = state.settings.beta.toString();
        noiseChk.checked = state.settings.noise;
        sigmaSlider.value = state.settings.sigma.toString();
        sigmaInput.value = state.settings.sigma.toString();
        showTangentChk.checked = state.settings.showTangent;
        showGradArrowChk.checked = state.settings.showGradArrow;
        showPathChk.checked = state.settings.showPath;
        speedSlider.value = state.settings.speedMs.toString();
        autoStopChk.checked = state.settings.autoStop;
        tolInput.value = state.settings.tol.toString();
        maxIterInput.value = state.settings.maxIter.toString();
        updateLrBadge();
        updateBetaBadge();
        updateSigmaBadge();
        updateSpeedBadge();
        pickFunction(state.func.id);
        x0Input.value = state.func.x0.toString();
        reset();
      }

      initUI();
      drawAll();
    </script>
  </body>
</html>
