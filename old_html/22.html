<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>k-Nearest Neighbor Demonstration</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      .controls {
        background-color: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .visualization {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
      }
      .chart-container {
        flex: 1;
        min-width: 300px;
        background-color: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      canvas {
        border: 1px solid #ddd;
        background-color: #fafafa;
      }
      input,
      button,
      select {
        padding: 8px;
        margin: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      button {
        background-color: #4caf50;
        color: white;
        cursor: pointer;
      }
      button:hover {
        background-color: #45a049;
      }
      .result {
        margin-top: 10px;
        padding: 10px;
        background-color: #e8f5e9;
        border-radius: 4px;
      }
      .point-info {
        font-size: 14px;
        margin-top: 5px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>k-Nearest Neighbor (k-NN) Algorithm Demonstration</h1>

      <div class="controls">
        <h3>Controls</h3>
        <div>
          <label for="kValue">k value:</label>
          <input type="number" id="kValue" min="1" max="10" value="3" />

          <label for="pointClass">Point Class:</label>
          <select id="pointClass">
            <option value="0">Class A (Blue)</option>
            <option value="1">Class B (Red)</option>
            <option value="2">Class C (Green)</option>
          </select>

          <button id="addPointBtn">Add Point to Training Data</button>
          <button id="classifyBtn">Classify Test Point</button>
          <button id="clearBtn">Clear All</button>
        </div>

        <div class="point-info">
          <p><strong>Instructions:</strong></p>
          <p>
            1. Select a class and click "Add Point" to add training data points
            to the chart
          </p>
          <p>
            2. Click anywhere on the chart to set a test point (shown as black)
          </p>
          <p>3. Adjust k value and click "Classify" to see k-NN in action</p>
          <p>4. The k nearest neighbors will be highlighted with a circle</p>
        </div>
      </div>

      <div class="visualization">
        <div class="chart-container">
          <h3>k-NN Visualization</h3>
          <canvas id="knnCanvas" width="500" height="400"></canvas>
          <div id="result" class="result"></div>
        </div>
      </div>
    </div>

    <script>
      // k-NN implementation
      class KNearestNeighbors {
        constructor(k) {
          this.k = k;
          this.trainingData = [];
        }

        // Euclidean distance calculation
        distance(point1, point2) {
          return Math.sqrt(
            Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2)
          );
        }

        // Add training point
        addPoint(x, y, label) {
          this.trainingData.push({ x, y, label });
        }

        // Classify a point using k-NN
        classify(point) {
          if (this.trainingData.length === 0) {
            return null;
          }

          // Calculate distances to all training points
          const distances = this.trainingData.map((trainPoint, index) => ({
            index,
            distance: this.distance(point, trainPoint),
            label: trainPoint.label,
          }));

          // Sort by distance (ascending)
          distances.sort((a, b) => a.distance - b.distance);

          // Get k nearest neighbors
          const neighbors = distances.slice(0, this.k);

          // Count votes for each class
          const votes = {};
          neighbors.forEach((neighbor) => {
            votes[neighbor.label] = (votes[neighbor.label] || 0) + 1;
          });

          // Find the class with most votes
          let maxVotes = 0;
          let predictedClass = null;

          for (const [label, count] of Object.entries(votes)) {
            if (count > maxVotes) {
              maxVotes = count;
              predictedClass = parseInt(label);
            }
          }

          return {
            predictedClass,
            neighbors,
            votes,
          };
        }

        clearData() {
          this.trainingData = [];
        }
      }

      // Visualization setup
      const canvas = document.getElementById("knnCanvas");
      const ctx = canvas.getContext("2d");
      const kValueInput = document.getElementById("kValue");
      const pointClassSelect = document.getElementById("pointClass");
      const addPointBtn = document.getElementById("addPointBtn");
      const classifyBtn = document.getElementById("classifyBtn");
      const clearBtn = document.getElementById("clearBtn");
      const resultDiv = document.getElementById("result");

      // Initialize k-NN
      let knn = new KNearestNeighbors(parseInt(kValueInput.value));
      let testPoint = null;
      let lastClassification = null;

      // Color mapping for classes
      const classColors = {
        0: "#2196F3", // Blue
        1: "#F44336", // Red
        2: "#4CAF50", // Green
      };

      // Class names
      const classNames = {
        0: "Class A",
        1: "Class B",
        2: "Class C",
      };

      // Draw everything on the canvas
      function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw training points
        knn.trainingData.forEach((point) => {
          drawPoint(point.x, point.y, point.label, false);
        });

        // Draw test point if exists
        if (testPoint) {
          drawPoint(testPoint.x, testPoint.y, null, true);

          // If we have a classification result, highlight neighbors
          if (lastClassification) {
            lastClassification.neighbors.forEach((neighbor) => {
              const point = knn.trainingData[neighbor.index];
              // Draw circle around neighbor
              ctx.beginPath();
              ctx.arc(point.x, point.y, 20, 0, 2 * Math.PI);
              ctx.strokeStyle = classColors[point.label];
              ctx.lineWidth = 2;
              ctx.stroke();
            });
          }
        }
      }

      // Draw a point on the canvas
      function drawPoint(x, y, label, isTestPoint) {
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);

        if (isTestPoint) {
          // Test point is black with a cross
          ctx.fillStyle = "black";
          ctx.fill();

          // Draw cross
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x - 4, y);
          ctx.lineTo(x + 4, y);
          ctx.moveTo(x, y - 4);
          ctx.lineTo(x, y + 4);
          ctx.stroke();
        } else {
          // Training point with class color
          ctx.fillStyle = classColors[label];
          ctx.fill();

          // White border
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      // Handle canvas click for test point
      canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        testPoint = { x, y };
        lastClassification = null;
        resultDiv.textContent = 'Click "Classify Test Point" to see the result';
        draw();
      });

      // Add training point
      addPointBtn.addEventListener("click", () => {
        // Add point at random location for demo
        const x = 50 + Math.random() * (canvas.width - 100);
        const y = 50 + Math.random() * (canvas.height - 100);
        const label = parseInt(pointClassSelect.value);

        knn.addPoint(x, y, label);
        draw();
      });

      // Classify test point
      classifyBtn.addEventListener("click", () => {
        if (!testPoint) {
          resultDiv.textContent =
            "Please click on the chart to set a test point first.";
          return;
        }

        if (knn.trainingData.length === 0) {
          resultDiv.textContent = "Please add some training data points first.";
          return;
        }

        // Update k value
        knn.k = parseInt(kValueInput.value);

        // Classify
        lastClassification = knn.classify(testPoint);

        if (lastClassification) {
          const votesText = Object.entries(lastClassification.votes)
            .map(([label, count]) => `${classNames[label]}: ${count} vote(s)`)
            .join(", ");

          resultDiv.innerHTML = `
                    <strong>Classification Result:</strong><br>
                    Test point belongs to: <strong>${
                      classNames[lastClassification.predictedClass]
                    }</strong><br>
                    Votes: ${votesText}<br>
                    Based on ${knn.k} nearest neighbors.
                `;
        }

        draw();
      });

      // Clear all data
      clearBtn.addEventListener("click", () => {
        knn.clearData();
        testPoint = null;
        lastClassification = null;
        resultDiv.textContent = "";
        draw();
      });

      // Update k value
      kValueInput.addEventListener("change", () => {
        knn.k = parseInt(kValueInput.value);
        if (testPoint && lastClassification) {
          // Reclassify if we have a test point
          classifyBtn.click();
        }
      });

      // Initial draw
      draw();

      // Add some initial training data for demonstration
      function addDemoData() {
        // Add some sample points for each class
        for (let i = 0; i < 5; i++) {
          knn.addPoint(100 + Math.random() * 100, 100 + Math.random() * 100, 0); // Class A
          knn.addPoint(300 + Math.random() * 100, 100 + Math.random() * 100, 1); // Class B
          knn.addPoint(200 + Math.random() * 100, 300 + Math.random() * 100, 2); // Class C
        }
        draw();
      }

      // Add demo data after a short delay
      setTimeout(addDemoData, 500);
    </script>
  </body>
</html>
