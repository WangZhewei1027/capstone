<!DOCTYPE html>
<html>
  <head>
    <title>K-Nearest Neighbors Explorer</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 10px;
      }
      #container {
        display: flex;
        flex-wrap: wrap;
      }
      #canvas-area {
        flex: 1;
        min-width: 300px;
      }
      #controls-area {
        flex: 1;
        min-width: 200px;
      }
      canvas {
        border: 1px solid #ccc;
      }
      .legend {
        margin-top: 10px;
      }
      .legend span {
        display: inline-block;
        margin-right: 10px;
      }
      .legend .color-box {
        width: 15px;
        height: 15px;
        display: inline-block;
        margin-right: 5px;
        border: 1px solid #000;
      }
      #explanation {
        margin-top: 10px;
        border: 1px solid #eee;
        padding: 10px;
      }
      #explanation h2 {
        margin-top: 0;
      }
      #try-this {
        margin-top: 10px;
      }
      #try-this ul {
        list-style-type: disc;
        padding-left: 20px;
      }
      #prediction-area {
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <!-- K-Nearest Neighbors Explorer - Interactive visualization for learning KNN -->

    <div id="container">
      <div id="canvas-area">
        <canvas id="knnCanvas" width="600" height="400"></canvas>
      </div>

      <div id="controls-area">
        <h2>Controls</h2>

        <label for="modeSelect">Mode:</label>
        <select id="modeSelect">
          <option value="add">Add Points</option>
          <option value="drag">Drag Test Point</option>
          <option value="generate">Generate Data</option>
          <option value="clear">Clear</option></select
        ><br /><br />

        <label for="kSlider">K (Neighbors):</label>
        <input type="range" id="kSlider" min="1" max="50" value="5" /><span
          id="kValue"
          >5</span
        ><br /><br />

        <label for="metricSelect">Metric:</label>
        <select id="metricSelect">
          <option value="euclidean">Euclidean</option>
          <option value="manhattan">Manhattan</option></select
        ><br /><br />

        <label for="weightedToggle">Weighted Voting:</label>
        <input type="checkbox" id="weightedToggle" /><br /><br />

        <label for="sampleSize">Sample Size:</label>
        <input
          type="number"
          id="sampleSize"
          value="100"
          min="10"
          max="1000"
        /><br /><br />

        <button id="shuffleButton">Shuffle Labels</button><br /><br />

        <button id="clearTrainingButton">Clear Training Data</button>
        <button id="clearTestButton">Clear Test Point</button><br /><br />

        <div class="legend">
          <span class="color-box" style="background-color: #ff0000"
            >Class A</span
          >
          <span class="color-box" style="background-color: #0000ff"
            >Class B</span
          >
          <span class="color-box" style="background-color: #00ff00"
            >Test Point</span
          >
          <span class="color-box" style="background-color: #ffff00"
            >Nearest Neighbors</span
          >
        </div>
      </div>

      <div id="explanation">
        <h2>K-Nearest Neighbors (KNN)</h2>
        <p>
          KNN is a simple algorithm for classification. It classifies a new data
          point based on the majority class of its k nearest neighbors.
        </p>
        <h3>How it Works:</h3>
        <ol>
          <li>
            Calculate the distance between the test point and all training
            points.
          </li>
          <li>Identify the k nearest neighbors.</li>
          <li>
            Assign the test point to the class that is most frequent among its k
            nearest neighbors.
          </li>
        </ol>

        <div id="try-this">
          <h2>Try This!</h2>
          <ul>
            <li>Increase K and observe how the prediction changes.</li>
            <li>Move the test point between clusters.</li>
            <li>Toggle weighted voting and see its effect.</li>
            <li>Generate a new dataset with a different sample size.</li>
          </ul>
        </div>
      </div>
    </div>

    <div id="prediction-area">
      <h2>Prediction: <span id="prediction"></span></h2>
      <p id="vote-counts"></p>
      <div id="aria-live" aria-live="polite"></div>
    </div>

    <script>
      const canvas = document.getElementById("knnCanvas");
      const ctx = canvas.getContext("2d");
      const modeSelect = document.getElementById("modeSelect");
      const kSlider = document.getElementById("kSlider");
      const kValueSpan = document.getElementById("kValue");
      const metricSelect = document.getElementById("metricSelect");
      const weightedToggle = document.getElementById("weightedToggle");
      const sampleSizeInput = document.getElementById("sampleSize");
      const shuffleButton = document.getElementById("shuffleButton");
      const clearTrainingButton = document.getElementById(
        "clearTrainingButton"
      );
      const clearTestButton = document.getElementById("clearTestButton");
      const predictionSpan = document.getElementById("prediction");
      const voteCountsParagraph = document.getElementById("vote-counts");
      const ariaLive = document.getElementById("aria-live");

      let dataPoints = [];
      let testPoint = null;
      let k = 5;
      let metric = "euclidean";
      let weighted = false;
      let mode = "add";
      let currentClass = "red"; // Default class for adding points

      const colors = {
        red: "#FF0000",
        blue: "#0000FF",
        green: "#00FF00",
        yellow: "#FFFF00",
      };

      // Function to calculate Euclidean distance
      function euclideanDistance(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      }

      // Function to calculate Manhattan distance
      function manhattanDistance(p1, p2) {
        return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
      }

      // Function to get distance based on selected metric
      function getDistance(p1, p2) {
        return metric === "euclidean"
          ? euclideanDistance(p1, p2)
          : manhattanDistance(p1, p2);
      }

      // Function to find k-nearest neighbors
      function findKNearestNeighbors(point, k) {
        const distances = dataPoints.map((dp) => ({
          point: dp,
          distance: getDistance(point, dp),
        }));
        distances.sort((a, b) => a.distance - b.distance);
        return distances.slice(0, k);
      }

      // Function to predict class
      function predictClass(neighbors) {
        const classCounts = {};
        neighbors.forEach((neighbor) => {
          const className = neighbor.point.class;
          classCounts[className] = (classCounts[className] || 0) + 1;
        });

        let predictedClass = null;
        let maxCount = 0;
        let totalDistance = 0;

        for (const className in classCounts) {
          if (classCounts[className] > maxCount) {
            maxCount = classCounts[className];
            predictedClass = className;
          }
        }

        if (weighted) {
          let weightedClassCounts = {};
          neighbors.forEach((neighbor) => {
            const className = neighbor.point.class;
            const weight = 1 / (neighbor.distance + 0.001); // Add a small epsilon to avoid division by zero
            weightedClassCounts[className] =
              (weightedClassCounts[className] || 0) + weight;
          });

          predictedClass = null;
          let maxWeight = 0;
          for (const className in weightedClassCounts) {
            if (weightedClassCounts[className] > maxWeight) {
              maxWeight = weightedClassCounts[className];
              predictedClass = className;
            }
          }
        }

        return predictedClass;
      }

      // Function to draw the canvas
      function drawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw data points
        dataPoints.forEach((point) => {
          ctx.fillStyle = colors[point.class];
          ctx.beginPath();
          ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
          ctx.fill();
        });

        // Draw test point
        if (testPoint) {
          ctx.fillStyle = colors["green"];
          ctx.beginPath();
          ctx.arc(testPoint.x, testPoint.y, 7, 0, 2 * Math.PI);
          ctx.fill();
        }

        // Highlight k-nearest neighbors
        if (testPoint) {
          const neighbors = findKNearestNeighbors(testPoint, k);
          neighbors.forEach((neighbor) => {
            ctx.fillStyle = colors["yellow"];
            ctx.beginPath();
            ctx.arc(neighbor.point.x, neighbor.point.y, 8, 0, 2 * Math.PI);
            ctx.fill();

            ctx.strokeStyle = colors["yellow"];
            ctx.beginPath();
            ctx.moveTo(testPoint.x, testPoint.y);
            ctx.lineTo(neighbor.point.x, neighbor.point.y);
            ctx.stroke();
          });
        }
      }

      // Function to generate random data
      function generateData(size) {
        dataPoints = [];
        for (let i = 0; i < size; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const randomClass = Math.random() < 0.5 ? "red" : "blue";
          dataPoints.push({ x, y, class: randomClass });
        }
      }

      // Function to shuffle labels
      function shuffleLabels() {
        dataPoints.forEach((point) => {
          point.class = Math.random() < 0.5 ? "red" : "blue";
        });
      }

      // Event listener for canvas clicks
      canvas.addEventListener("click", (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        if (mode === "add") {
          dataPoints.push({ x, y, class: currentClass });
          drawCanvas();
        } else if (mode === "drag") {
          testPoint = { x, y };
          drawCanvas();
          predictAndHighlight();
        }
      });

      // Event listener for canvas mousemove (dragging)
      let isDragging = false;
      canvas.addEventListener("mousedown", (event) => {
        if (mode === "drag") {
          isDragging = true;
        }
      });

      canvas.addEventListener("mouseup", () => {
        isDragging = false;
      });

      canvas.addEventListener("mousemove", (event) => {
        if (isDragging && mode === "drag") {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          testPoint = { x, y };
          drawCanvas();
          predictAndHighlight();
        }
      });

      // Function to predict and highlight
      function predictAndHighlight() {
        if (testPoint) {
          const neighbors = findKNearestNeighbors(testPoint, k);
          const predictedClass = predictClass(neighbors);

          const classCounts = {};
          neighbors.forEach((neighbor) => {
            const className = neighbor.point.class;
            classCounts[className] = (classCounts[className] || 0) + 1;
          });

          let voteCountsString = "";
          for (const className in classCounts) {
            voteCountsString += `${className}: ${classCounts[className]} `;
          }

          predictionSpan.textContent = predictedClass;
          voteCountsParagraph.textContent = "Vote Counts: " + voteCountsString;
          ariaLive.textContent = `Prediction updated to ${predictedClass}. Vote counts: ${voteCountsString}`;

          drawCanvas();
        }
      }

      // Event listeners for controls
      modeSelect.addEventListener("change", () => {
        mode = modeSelect.value;
        if (mode === "add") {
          currentClass = "red"; // Reset to red when adding
        }
      });

      kSlider.addEventListener("input", () => {
        k = parseInt(kSlider.value);
        kValueSpan.textContent = k;
        predictAndHighlight();
      });

      metricSelect.addEventListener("change", () => {
        metric = metricSelect.value;
        predictAndHighlight();
      });

      weightedToggle.addEventListener("change", () => {
        weighted = weightedToggle.checked;
        predictAndHighlight();
      });

      sampleSizeInput.addEventListener("change", () => {
        const size = parseInt(sampleSizeInput.value);
        generateData(size);
        drawCanvas();
      });

      shuffleButton.addEventListener("click", () => {
        shuffleLabels();
        drawCanvas();
        predictAndHighlight();
      });

      clearTrainingButton.addEventListener("click", () => {
        dataPoints = [];
        drawCanvas();
        predictAndHighlight();
      });

      clearTestButton.addEventListener("click", () => {
        testPoint = null;
        drawCanvas();
        predictionSpan.textContent = "";
        voteCountsParagraph.textContent = "";
        ariaLive.textContent = "";
      });

      // Initial setup
      generateData(100);
      drawCanvas();

      // Self-test routine
      function selfTest() {
        const testPoint1 = { x: 10, y: 10 };
        const testPoint2 = { x: 90, y: 90 };
        const testData = [
          { x: 5, y: 5, class: "red" },
          { x: 15, y: 15, class: "red" },
          { x: 85, y: 85, class: "blue" },
          { x: 95, y: 95, class: "blue" },
        ];
        dataPoints = testData;

        const dist1 = getDistance(testPoint1, testData[0]);
        const dist2 = getDistance(testPoint2, testData[2]);

        if (dist1 > 0 && dist2 > 0) {
          console.log("SELFTEST OK");
        } else {
          console.error("SELFTEST FAILED: Distance calculation error");
        }
      }

      selfTest();
    </script>
  </body>
</html>
