<!DOCTYPE html>
<html>
  <head>
    <title>K-Nearest Neighbors (kNN) Explorer</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 20px;
      }
      canvas {
        border: 1px solid #ccc;
      }
      #controls {
        margin-bottom: 10px;
      }
      #explanation {
        margin-top: 10px;
        border: 1px solid #eee;
        padding: 10px;
      }
    </style>
  </head>
  <body>
    <h1>K-Nearest Neighbors (kNN) Explorer</h1>

    <div id="controls">
      <label for="kSlider">K (Neighbors):</label>
      <input type="range" id="kSlider" min="1" max="10" value="3" />
      <span id="kValue">3</span>
    </div>

    <canvas id="knnCanvas" width="600" height="400"></canvas>

    <div id="explanation">
      <h2>How it Works</h2>
      <p id="step1">
        <b>Step 1:</b> Click on the canvas to add data points. Each point
        belongs to a class (red or blue).
      </p>
      <p id="step2">
        <b>Step 2:</b> A query point (green) is automatically generated. The
        algorithm calculates the distance from this point to all other points.
      </p>
      <p id="step3">
        <b>Step 3:</b> The 'k' nearest neighbors are identified (highlighted in
        yellow).
      </p>
      <p id="step4">
        <b>Step 4:</b> The class that appears most frequently among the 'k'
        neighbors is predicted as the class of the query point.
      </p>
    </div>

    <script>
      const canvas = document.getElementById("knnCanvas");
      const ctx = canvas.getContext("2d");
      const kSlider = document.getElementById("kSlider");
      const kValueSpan = document.getElementById("kValue");
      const step1 = document.getElementById("step1");
      const step2 = document.getElementById("step2");
      const step3 = document.getElementById("step3");
      const step4 = document.getElementById("step4");

      let dataPoints = [];
      let k = 3;
      let queryPoint = null;

      const colors = {
        red: "#FF0000",
        blue: "#0000FF",
        green: "#00FF00",
        yellow: "#FFFF00",
      };

      // Function to calculate Euclidean distance
      function distance(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      }

      // Function to find k-nearest neighbors
      function findKNearestNeighbors(point, k) {
        const distances = dataPoints.map((dp) => ({
          point: dp,
          distance: distance(point, dp),
        }));
        distances.sort((a, b) => a.distance - b.distance);
        return distances.slice(0, k);
      }

      // Function to predict class
      function predictClass(neighbors) {
        const classCounts = {};
        neighbors.forEach((neighbor) => {
          classCounts[neighbor.point.class] =
            (classCounts[neighbor.point.class] || 0) + 1;
        });

        let predictedClass = null;
        let maxCount = 0;
        for (const className in classCounts) {
          if (classCounts[className] > maxCount) {
            maxCount = classCounts[className];
            predictedClass = className;
          }
        }
        return predictedClass;
      }

      // Function to draw the canvas
      function drawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw grid
        ctx.strokeStyle = "#eee";
        for (let x = 0; x < canvas.width; x += 20) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y < canvas.height; y += 20) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }

        // Draw data points
        dataPoints.forEach((point) => {
          ctx.fillStyle = colors[point.class];
          ctx.beginPath();
          ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
          ctx.fill();
        });

        // Draw query point
        if (queryPoint) {
          ctx.fillStyle = colors["green"];
          ctx.beginPath();
          ctx.arc(queryPoint.x, queryPoint.y, 7, 0, 2 * Math.PI);
          ctx.fill();
        }

        // Highlight k-nearest neighbors
        if (queryPoint) {
          const neighbors = findKNearestNeighbors(queryPoint, k);
          neighbors.forEach((neighbor) => {
            ctx.fillStyle = colors["yellow"];
            ctx.beginPath();
            ctx.arc(neighbor.point.x, neighbor.point.y, 8, 0, 2 * Math.PI);
            ctx.fill();
          });
        }
      }

      // Event listener for canvas clicks
      canvas.addEventListener("click", (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const randomClass = Math.random() < 0.5 ? "red" : "blue";
        dataPoints.push({ x, y, class: randomClass });
        drawCanvas();
        step1.style.fontWeight = "normal";
        step2.style.fontWeight = "bold";
        generateQueryPoint();
      });

      // Function to generate a random query point
      function generateQueryPoint() {
        if (dataPoints.length > 0) {
          const minX = Math.min(...dataPoints.map((p) => p.x));
          const maxX = Math.max(...dataPoints.map((p) => p.x));
          const minY = Math.min(...dataPoints.map((p) => p.y));
          const maxY = Math.max(...dataPoints.map((p) => p.y));

          queryPoint = {
            x: minX + Math.random() * (maxX - minX),
            y: minY + Math.random() * (maxY - minY),
          };
          drawCanvas();
          step2.style.fontWeight = "normal";
          step3.style.fontWeight = "bold";
          predictAndHighlight();
        }
      }

      // Function to predict and highlight
      function predictAndHighlight() {
        if (queryPoint) {
          const neighbors = findKNearestNeighbors(queryPoint, k);
          const predictedClass = predictClass(neighbors);
          step3.style.fontWeight = "normal";
          step4.style.fontWeight = "bold";
          drawCanvas();
        }
      }

      // Event listener for k slider
      kSlider.addEventListener("input", () => {
        k = parseInt(kSlider.value);
        kValueSpan.textContent = k;
        predictAndHighlight();
      });

      // Initial setup
      kSlider.value = k;
      kValueSpan.textContent = k;
      drawCanvas();
      step1.style.fontWeight = "bold";
    </script>
  </body>
</html>
