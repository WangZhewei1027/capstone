<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Interactive Gradient Descent — Step-by-Step</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #0f1220;
        --panel: #171a2b;
        --ink: #e6e7ef;
        --muted: #aab0d0;
        --accent: #7aa2ff;
        --accent2: #22d3ee;
        --good: #34d399;
        --warn: #f59e0b;
        --bad: #ef4444;
        --grid: #22263b;
        --axis: #2f3554;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.35),
          inset 0 1px 0 rgba(255, 255, 255, 0.03);
        --radius: 16px;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: linear-gradient(180deg, #0c1020, #0b1022 40%, #0f1220);
        color: var(--ink);
        font: 15px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI,
          Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji",
          "Segoe UI Emoji";
        letter-spacing: 0.2px;
      }
      h1 {
        font-size: 22px;
        margin: 0 0 10px;
        letter-spacing: 0.4px;
      }
      h2 {
        font-size: 14px;
        color: var(--muted);
        font-weight: 600;
        margin: 14px 0 8px;
      }
      .app {
        max-width: 1200px;
        margin: 18px auto;
        padding: 0 16px 24px;
      }
      .topbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 14px;
        margin-bottom: 12px;
      }
      .pill {
        background: linear-gradient(180deg, #151a2c, #0f1426);
        border: 1px solid #252c47;
        border-radius: 999px;
        padding: 10px 14px;
        box-shadow: var(--shadow);
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      .pill label {
        color: var(--muted);
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
      }
      .sel,
      .btn,
      .chk {
        appearance: none;
        outline: none;
        border: none;
        color: var(--ink);
      }
      .sel {
        background: #0c1122;
        border: 1px solid #273055;
        border-radius: 10px;
        padding: 8px 10px;
        min-width: 220px;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
      }
      .btn {
        background: linear-gradient(180deg, #1d2440, #1a2040);
        border: 1px solid #2b3560;
        border-radius: 12px;
        padding: 9px 12px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: var(--shadow);
        transition: transform 0.05s ease, box-shadow 0.2s ease,
          background 0.2s ease;
      }
      .btn:hover {
        box-shadow: 0 10px 30px rgba(34, 211, 238, 0.25),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
      }
      .btn:active {
        transform: translateY(1px);
      }
      .btn.secondary {
        background: #12162b;
        border-color: #2a2f4d;
      }
      .btn.good {
        border-color: #1f7f5b;
        background: linear-gradient(180deg, #1a2e29, #142722);
      }
      .btn.warn {
        border-color: #7a550f;
        background: linear-gradient(180deg, #2b2312, #221d10);
      }
      .grid {
        display: grid;
        grid-template-columns: 340px 1fr;
        gap: 16px;
        align-items: start;
      }
      .panel {
        background: linear-gradient(180deg, #14182b, #101427);
        border: 1px solid #232a48;
        border-radius: var(--radius);
        padding: 14px;
        box-shadow: var(--shadow);
      }
      .panel .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin: 8px 0;
      }
      .panel .row.wrap {
        flex-wrap: wrap;
      }
      .panel small {
        color: var(--muted);
      }
      .slider {
        width: 100%;
        accent-color: var(--accent2);
      }
      .kv {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 6px;
        margin-top: 6px;
      }
      .kv div {
        padding: 6px 8px;
        background: #0c1023;
        border: 1px solid #1d2443;
        border-radius: 10px;
      }
      .kv .value {
        font-variant-numeric: tabular-nums;
        font-weight: 700;
      }
      .legend {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin: 6px 0 2px;
      }
      .tag {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid #25305a;
        background: #0f142a;
        font-size: 12px;
        color: var(--muted);
      }
      .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
      }
      .dot.func {
        background: var(--accent);
      }
      .dot.point {
        background: var(--good);
      }
      .dot.next {
        background: #e879f9;
      }
      .dot.tangent {
        background: #f97316;
      }
      .canvasWrap {
        background: radial-gradient(
          1200px 400px at 50% -200px,
          rgba(122, 162, 255, 0.15),
          transparent 60%
        );
        border: 1px solid #242c4c;
        border-radius: var(--radius);
        padding: 10px;
        box-shadow: var(--shadow);
      }
      canvas {
        display: block;
        width: 100%;
        height: auto;
        border-radius: 12px;
        background: linear-gradient(180deg, #0c1124, #0b0f1f);
      }
      .help {
        margin-top: 10px;
        color: var(--muted);
        font-size: 13px;
      }
      code {
        background: #0c1022;
        border: 1px solid #252c47;
        padding: 2px 6px;
        border-radius: 8px;
      }
      .steps {
        display: grid;
        gap: 8px;
        margin-top: 6px;
      }
      .step {
        background: #0d1226;
        border: 1px solid #1f2644;
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 13px;
        color: var(--muted);
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .step .num {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        display: grid;
        place-items: center;
        font-size: 12px;
        font-weight: 700;
        background: #121734;
        border: 1px solid #2a3155;
        color: #93c5fd;
      }
      .step.active {
        border-color: #3556ff66;
        background: #0e1230;
      }
      .bad {
        color: var(--bad);
      }
      .good {
        color: var(--good);
      }
      .warn {
        color: var(--warn);
      }
      .muted {
        color: var(--muted);
      }
      .mini {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-top: 12px;
      }
      .footerNote {
        margin-top: 10px;
        color: #8aa0ff;
        font-size: 12px;
      }
      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="topbar">
        <h1>Interactive Gradient Descent Playground</h1>
        <div class="pill">
          <label for="fnSelect">Function</label>
          <select id="fnSelect" class="sel" aria-label="Function to optimize">
            <option value="quadratic">
              Quadratic Bowl — f(x) = (x−3)² + 2
            </option>
            <option value="cubic">Cubic — f(x) = x³ − 3x</option>
            <option value="quartic">
              Non-Convex Quartic — f(x) = ¼x⁴ − x² + 0.5x + 3
            </option>
          </select>
          <button
            class="btn secondary"
            id="randomizeBtn"
            title="Randomize starting point"
          >
            Random Start
          </button>
          <button class="btn" id="resetBtn" title="Reset">Reset</button>
          <button class="btn good" id="runBtn" title="Run / Pause [Space]">
            Run
          </button>
          <button class="btn" id="stepBtn" title="Single Step [S]">Step</button>
        </div>
      </div>

      <div class="grid">
        <!-- Control Panel -->
        <div class="panel" id="controls">
          <h2>Parameters</h2>
          <div class="row">
            <div style="flex: 1">
              <div class="row wrap">
                <small>Learning rate (α)</small>
                <small id="lrVal">0.100</small>
              </div>
              <input
                class="slider"
                type="range"
                id="lr"
                min="0.001"
                max="1.0"
                step="0.001"
                value="0.1"
              />
            </div>
          </div>
          <div class="row">
            <div style="flex: 1">
              <div class="row wrap">
                <small>Momentum (β)</small>
                <small id="momVal">0.00</small>
              </div>
              <input
                class="slider"
                type="range"
                id="momentum"
                min="0"
                max="0.95"
                step="0.01"
                value="0.00"
              />
            </div>
          </div>
          <div class="row">
            <div style="flex: 1">
              <div class="row wrap">
                <small>Noise on gradient (σ)</small>
                <small id="noiseVal">0.00</small>
              </div>
              <input
                class="slider"
                type="range"
                id="noise"
                min="0"
                max="0.5"
                step="0.01"
                value="0.00"
              />
            </div>
          </div>
          <div class="row">
            <div style="flex: 1">
              <div class="row wrap">
                <small>Speed (steps/sec)</small>
                <small id="speedVal">10</small>
              </div>
              <input
                class="slider"
                type="range"
                id="speed"
                min="1"
                max="60"
                step="1"
                value="10"
              />
            </div>
          </div>

          <div class="row wrap" style="margin-top: 8px; gap: 10px">
            <label class="tag"
              ><input type="checkbox" id="showTangent" checked />&nbsp; Show
              tangent</label
            >
            <label class="tag"
              ><input type="checkbox" id="showArrows" checked />&nbsp; Show step
              arrows</label
            >
            <label class="tag"
              ><input type="checkbox" id="showPath" checked />&nbsp; Show
              path</label
            >
            <label class="tag"
              ><input type="checkbox" id="snapToRange" checked />&nbsp; Keep x
              in range</label
            >
          </div>

          <div class="legend">
            <div class="tag"><span class="dot func"></span> Function curve</div>
            <div class="tag"><span class="dot point"></span> Current point</div>
            <div class="tag"><span class="dot tangent"></span> Tangent</div>
            <div class="tag"><span class="dot next"></span> Next point</div>
          </div>

          <h2>Live Values</h2>
          <div class="kv">
            <div>Iteration</div>
            <div class="value" id="itVal">0</div>
            <div>x</div>
            <div class="value" id="xVal">0.0000</div>
            <div>f(x)</div>
            <div class="value" id="fxVal">0.0000</div>
            <div>f′(x)</div>
            <div class="value" id="dfVal">0.0000</div>
            <div>Δx = −α·g</div>
            <div class="value" id="dxVal">0.0000</div>
            <div>Status</div>
            <div class="value" id="statusVal">ready</div>
          </div>

          <h2>Step-by-Step</h2>
          <div class="steps" id="stepsBox">
            <div class="step" data-step="1">
              <span class="num">1</span> Pick a function <code>f(x)</code>.
            </div>
            <div class="step" data-step="2">
              <span class="num">2</span> Choose a learning rate
              <code>α</code> (and optional momentum <code>β</code>).
            </div>
            <div class="step" data-step="3">
              <span class="num">3</span> Start at some <code>x₀</code> (drag the
              point or randomize).
            </div>
            <div class="step" data-step="4">
              <span class="num">4</span> Compute gradient:
              <code>g = f′(x)</code>.
            </div>
            <div class="step" data-step="5">
              <span class="num">5</span> Update: <code>x ← x − α·g</code> (or
              with momentum).
            </div>
            <div class="step" data-step="6">
              <span class="num">6</span> Repeat until
              <code>|g| &lt; ε</code> (converged).
            </div>
          </div>

          <div class="help">
            Drag the green point on the big chart to set the starting position.
            Press <code>Space</code> to run/pause, <code>S</code> to
            single-step. Try a huge α to see overshoot (<span class="warn"
              >be careful!</span
            >).
          </div>

          <div class="footerNote">
            Tip: Add a little noise to simulate stochastic gradients.
          </div>
        </div>

        <!-- Charts -->
        <div>
          <div class="panel canvasWrap">
            <canvas
              id="plot"
              width="1000"
              height="520"
              aria-label="Function plot with gradient descent path"
            ></canvas>
          </div>
          <div class="mini">
            <div class="panel">
              <h2>Loss vs. Iteration (f(xₖ))</h2>
              <canvas id="loss" width="480" height="200"></canvas>
            </div>
            <div class="panel">
              <h2>Update Equation</h2>
              <div
                style="font-size: 14px; color: var(--muted); line-height: 1.6"
              >
                <div><b>Plain GD:</b> <code>xₖ₊₁ = xₖ − α·f′(xₖ)</code></div>
                <div>
                  <b>With momentum:</b> <code>vₖ = β·vₖ₋₁ + f′(xₖ)</code>,
                  &nbsp; <code>xₖ₊₁ = xₖ − α·vₖ</code>
                </div>
                <div class="help" id="stabilityNote"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function () {
        "use strict";

        // ---------- Math helpers ----------
        const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
        function fmt(n, d = 4) {
          return (Number.isFinite(n) ? n : 0).toFixed(d);
        }
        function rand(min, max) {
          return Math.random() * (max - min) + min;
        }
        // Gaussian noise (Box-Muller)
        function randn() {
          let u = 0,
            v = 0;
          while (u === 0) u = Math.random();
          while (v === 0) v = Math.random();
          return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        // ---------- Functions to optimize ----------
        const FUNCTIONS = {
          quadratic: {
            name: "Quadratic Bowl",
            expr: "f(x) = (x-3)² + 2",
            f: (x) => (x - 3) * (x - 3) + 2,
            df: (x) => 2 * (x - 3),
            range: [-5, 9],
            defaultX: -3.0,
          },
          cubic: {
            name: "Cubic",
            expr: "f(x) = x³ − 3x",
            f: (x) => x * x * x - 3 * x,
            df: (x) => 3 * x * x - 3,
            range: [-3.5, 3.5],
            defaultX: 2.8,
          },
          quartic: {
            name: "Non-Convex Quartic",
            expr: "f(x) = ¼x⁴ − x² + 0.5x + 3",
            f: (x) => 0.25 * x ** 4 - x ** 2 + 0.5 * x + 3,
            df: (x) => x ** 3 - 2 * x + 0.5,
            range: [-3.0, 3.0],
            defaultX: -2.4,
          },
        };

        // ---------- DOM ----------
        const el = (id) => document.getElementById(id);
        const plot = el("plot");
        const loss = el("loss");
        const ctx = plot.getContext("2d");
        const ltx = loss.getContext("2d");
        const fnSelect = el("fnSelect");
        const randomizeBtn = el("randomizeBtn");
        const resetBtn = el("resetBtn");
        const runBtn = el("runBtn");
        const stepBtn = el("stepBtn");

        const lr = el("lr"),
          lrVal = el("lrVal");
        const momentum = el("momentum"),
          momVal = el("momVal");
        const noise = el("noise"),
          noiseVal = el("noiseVal");
        const speed = el("speed"),
          speedVal = el("speedVal");

        const showTangent = el("showTangent");
        const showArrows = el("showArrows");
        const showPath = el("showPath");
        const snapToRange = el("snapToRange");

        const itVal = el("itVal"),
          xVal = el("xVal"),
          fxVal = el("fxVal"),
          dfVal = el("dfVal"),
          dxVal = el("dxVal"),
          statusVal = el("statusVal");
        const stepsBox = el("stepsBox");
        const stabilityNote = el("stabilityNote");

        // ---------- HiDPI setup ----------
        function setupHiDPI(c) {
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          const rect = c.getBoundingClientRect();
          c.width = Math.round(rect.width * dpr);
          c.height = Math.round(rect.height * dpr);
          const g = c.getContext("2d");
          g.setTransform(dpr, 0, 0, dpr, 0, 0);
          return g;
        }
        function resizeAll() {
          setupHiDPI(plot);
          setupHiDPI(loss);
          drawAll();
        }
        window.addEventListener("resize", resizeAll);

        // ---------- State ----------
        let currentKey = "quadratic";
        let f = FUNCTIONS[currentKey].f;
        let df = FUNCTIONS[currentKey].df;
        let XR = FUNCTIONS[currentKey].range.slice(); // [min, max]
        let x = FUNCTIONS[currentKey].defaultX;
        let v = 0; // momentum buffer
        let iter = 0;
        let running = false;
        let path = []; // [{x,y}]
        let yRange = [0, 1];
        let dragging = false;
        let dragOffsetX = 0;
        let lastFrameTime = 0;
        let lossHistory = [];

        // ---------- Coordinate transforms ----------
        function computeYRange() {
          const [xmin, xmax] = XR;
          let ymin = Infinity,
            ymax = -Infinity;
          const steps = 600;
          for (let i = 0; i <= steps; i++) {
            const xx = xmin + ((xmax - xmin) * i) / steps;
            const yy = f(xx);
            if (!Number.isFinite(yy)) continue;
            if (yy < ymin) ymin = yy;
            if (yy > ymax) ymax = yy;
          }
          if (!Number.isFinite(ymin) || !Number.isFinite(ymax)) {
            ymin = -1;
            ymax = 1;
          }
          const pad = 0.15 * (ymax - ymin || 1);
          yRange = [ymin - pad, ymax + pad];
        }
        function xToPx(xx) {
          const padding = 40;
          const w = plot.width / (window.devicePixelRatio || 1);
          return padding + (w - 2 * padding) * ((xx - XR[0]) / (XR[1] - XR[0]));
        }
        function yToPx(yy) {
          const padding = 30;
          const h = plot.height / (window.devicePixelRatio || 1);
          return (
            h -
            padding -
            (h - 2 * padding) * ((yy - yRange[0]) / (yRange[1] - yRange[0]))
          );
        }
        function pxToX(px) {
          const padding = 40;
          const w = plot.width / (window.devicePixelRatio || 1);
          const t = clamp((px - padding) / (w - 2 * padding), 0, 1);
          return XR[0] + t * (XR[1] - XR[0]);
        }

        // ---------- Drawing ----------
        function clear(g, c) {
          g.save();
          g.setTransform(1, 0, 0, 1, 0, 0); // Avoid transforming the clear rect
          g.clearRect(0, 0, c.width, c.height);
          g.restore();
        }

        function drawAxes() {
          const w = plot.width / (window.devicePixelRatio || 1);
          const h = plot.height / (window.devicePixelRatio || 1);
          const g = ctx;
          g.save();
          g.lineWidth = 1;
          // grid
          g.strokeStyle = "#1a2040";
          g.fillStyle = "#2f3554";
          for (let i = 0; i <= 10; i++) {
            const t = i / 10;
            const xx = XR[0] + t * (XR[1] - XR[0]);
            const xpx = xToPx(xx);
            g.beginPath();
            g.moveTo(xpx, 10);
            g.lineTo(xpx, h - 10);
            g.stroke();
            if (i > 0 && i < 10) {
              g.fillText(xx.toFixed(1), xpx - 8, h - 8);
            }
          }
          for (let j = 0; j <= 8; j++) {
            const t = j / 8;
            const yy = yRange[0] + t * (yRange[1] - yRange[0]);
            const ypx = yToPx(yy);
            g.beginPath();
            g.moveTo(10, ypx);
            g.lineTo(w - 10, ypx);
            g.stroke();
            if (j > 0 && j < 8) {
              g.fillText(yy.toFixed(1), 12, ypx - 4);
            }
          }
          // axis lines
          g.strokeStyle = "#2f3554";
          g.lineWidth = 1.5;
          // x-axis at y=0
          if (yRange[0] < 0 && yRange[1] > 0) {
            g.beginPath();
            g.moveTo(10, yToPx(0));
            g.lineTo(w - 10, yToPx(0));
            g.stroke();
          }
          // y-axis at x=0
          if (XR[0] < 0 && XR[1] > 0) {
            g.beginPath();
            g.moveTo(xToPx(0), 10);
            g.lineTo(xToPx(0), h - 10);
            g.stroke();
          }
          g.restore();
        }

        function drawFunction() {
          const g = ctx;
          g.save();
          g.strokeStyle = "#7aa2ff";
          g.lineWidth = 2;
          const steps = 800;
          let first = true;
          g.beginPath();
          for (let i = 0; i <= steps; i++) {
            const xx = XR[0] + (XR[1] - XR[0]) * (i / steps);
            const yy = f(xx);
            const xp = xToPx(xx),
              yp = yToPx(yy);
            if (first) {
              g.moveTo(xp, yp);
              first = false;
            } else g.lineTo(xp, yp);
          }
          g.stroke();
          g.restore();
        }

        function drawArrow(g, x1, y1, x2, y2) {
          g.save();
          g.beginPath();
          g.moveTo(x1, y1);
          g.lineTo(x2, y2);
          g.stroke();
          // arrow head
          const ang = Math.atan2(y2 - y1, x2 - x1);
          const len = 8;
          g.beginPath();
          g.moveTo(x2, y2);
          g.lineTo(
            x2 - len * Math.cos(ang - Math.PI / 6),
            y2 - len * Math.sin(ang - Math.PI / 6)
          );
          g.lineTo(
            x2 - len * Math.cos(ang + Math.PI / 6),
            y2 - len * Math.sin(ang + Math.PI / 6)
          );
          g.closePath();
          g.fill();
          g.restore();
        }

        function drawTangent(xx) {
          const g = ctx;
          const slope = df(xx);
          const yy = f(xx);
          const x1 = XR[0],
            x2 = XR[1];
          const y1 = yy + slope * (x1 - xx);
          const y2 = yy + slope * (x2 - xx);
          g.save();
          g.strokeStyle = "#f97316";
          g.lineWidth = 1.5;
          g.setLineDash([6, 4]);
          g.beginPath();
          g.moveTo(xToPx(x1), yToPx(y1));
          g.lineTo(xToPx(x2), yToPx(y2));
          g.stroke();
          g.setLineDash([]);
          // little slope label
          const p = xToPx(xx) + 8,
            q = yToPx(yy) - 8;
          g.fillStyle = "#fbbf24";
          g.font = "12px ui-sans-serif";
          g.fillText("slope = f′(x) = " + fmt(slope, 3), p, q);
          g.restore();
        }

        function drawPoint(xx, color = "#34d399", radius = 5) {
          const yy = f(xx);
          const g = ctx;
          g.save();
          g.fillStyle = color;
          g.strokeStyle = "rgba(255,255,255,.2)";
          g.lineWidth = 2;
          g.beginPath();
          g.arc(xToPx(xx), yToPx(yy), radius, 0, Math.PI * 2);
          g.fill();
          g.stroke();
          g.restore();
        }

        function drawStepArrow(xFrom, xTo) {
          const g = ctx;
          const yFrom = f(xFrom);
          const yTo = f(xTo);
          g.save();
          g.strokeStyle = "#e879f9";
          g.fillStyle = "#e879f9";
          g.lineWidth = 2;
          // L-shaped arrow to emphasize "move in x, then evaluate"
          const yMid = Math.min(yFrom, yTo) - 0.05 * (yRange[1] - yRange[0]);
          const a1x = xToPx(xFrom),
            a1y = yToPx(yFrom);
          const a2x = xToPx(xTo),
            a2y = yToPx(yTo);
          const midx1 = xToPx(xTo),
            midy1 = yToPx(yMid);
          const midx2 = xToPx(xFrom),
            midy2 = yToPx(yMid);

          g.setLineDash([4, 4]);
          g.beginPath();
          g.moveTo(a1x, a1y);
          g.lineTo(midx2, midy2);
          g.lineTo(midx1, midy1);
          g.lineTo(a2x, a2y);
          g.stroke();
          g.setLineDash([]);
          // arrow head at end
          drawArrow(g, midx1, midy1, a2x, a2y);
          g.restore();
        }

        function drawPath() {
          if (!path.length) return;
          const g = ctx;
          g.save();
          g.strokeStyle = "rgba(52,211,153,.35)";
          g.lineWidth = 2;
          g.beginPath();
          for (let i = 0; i < path.length; i++) {
            const p = path[i];
            const xp = xToPx(p.x),
              yp = yToPx(p.y);
            if (i === 0) g.moveTo(xp, yp);
            else g.lineTo(xp, yp);
          }
          g.stroke();
          g.restore();
        }

        function drawAll() {
          computeYRange();
          clear(ctx, plot);
          drawAxes();
          drawFunction();
          if (showPath.checked) drawPath();
          if (showTangent.checked) drawTangent(x);
          drawPoint(x, "#34d399", 6);
          // predicted next
          const g = effectiveGrad();
          const xNext = nextXPreview();
          if (showArrows.checked) {
            drawPoint(xNext, "#e879f9", 5);
            drawStepArrow(x, xNext);
          }
          updateHUD();
          drawLoss();
        }

        // ---------- Loss chart ----------
        function drawLoss() {
          // autoscale
          const w = loss.width / (window.devicePixelRatio || 1);
          const h = loss.height / (window.devicePixelRatio || 1);
          clear(ltx, loss);
          ltx.save();
          ltx.fillStyle = "#7aa2ff";
          ltx.strokeStyle = "#2a325b";
          ltx.lineWidth = 1;

          // axes
          ltx.strokeStyle = "#2f3554";
          ltx.beginPath();
          ltx.moveTo(40, 10);
          ltx.lineTo(40, h - 24);
          ltx.lineTo(w - 10, h - 24);
          ltx.stroke();

          if (lossHistory.length === 0) {
            ltx.restore();
            return;
          }

          const ys = lossHistory.map((d) => d.f);
          const ymin = Math.min(...ys),
            ymax = Math.max(...ys);
          const ypad = 0.1 * (ymax - ymin || 1);
          const lo = ymin - ypad,
            hi = ymax + ypad;
          const xpad = 40,
            right = w - 10,
            bottom = h - 24,
            top = 10;

          const X = (i) =>
            xpad + (right - xpad) * (i / Math.max(1, lossHistory.length - 1));
          const Y = (val) => bottom - (bottom - top) * ((val - lo) / (hi - lo));

          // grid labels
          ltx.fillStyle = "#8ea2ff";
          ltx.font = "12px ui-sans-serif";
          ltx.fillText("iter", right - 28, bottom + 14);
          ltx.fillText("f(x)", 8, top + 10);

          // curve
          ltx.strokeStyle = "#7aa2ff";
          ltx.lineWidth = 2;
          ltx.beginPath();
          lossHistory.forEach((d, i) => {
            const xp = X(i),
              yp = Y(d.f);
            if (i === 0) ltx.moveTo(xp, yp);
            else ltx.lineTo(xp, yp);
          });
          ltx.stroke();

          // last point
          const last = lossHistory[lossHistory.length - 1];
          ltx.fillStyle = "#34d399";
          ltx.beginPath();
          ltx.arc(X(lossHistory.length - 1), Y(last.f), 3.5, 0, Math.PI * 2);
          ltx.fill();

          // annotate
          ltx.fillStyle = "#aab0d0";
          ltx.fillText(
            "f(x) min ≈ " + fmt(Math.min(...ys), 4),
            xpad + 6,
            top + 16
          );

          ltx.restore();
        }

        // ---------- HUD / Steps ----------
        function setStepActive(n) {
          const nodes = stepsBox.querySelectorAll(".step");
          nodes.forEach((nd) => {
            const k = nd.getAttribute("data-step");
            if (Number(k) === n) nd.classList.add("active");
            else nd.classList.remove("active");
          });
        }
        function updateHUD() {
          const g = effectiveGrad(); // includes noise + momentum blend (preview)
          const alpha = Number(lr.value);
          const dx = -alpha * g.previewGrad; // preview shows plain grad (before momentum apply)
          itVal.textContent = String(iter);
          xVal.textContent = fmt(x, 4);
          fxVal.textContent = fmt(f(x), 4);
          dfVal.textContent =
            fmt(df(x), 4) +
            (Number(noise.value) > 0
              ? `  (~ ${fmt(g.previewGrad, 3)} with noise)`
              : "");
          dxVal.textContent = fmt(dx, 4);

          // stability hint (very rough)
          const beta = Number(momentum.value);
          let note = "";
          // For a simple quadratic approx with curvature c ~ |f''(x)|~estimate, we estimate with finite diff
          const c = estimateCurvature(x);
          const stableAlpha = c > 0 ? 2 / ((1 + beta) * c + 1e-9) : 0.5; // crude, illustrative
          if (c > 0) {
            if (alpha < 0.5 * stableAlpha)
              note = `Stable for this region (curvature≈${fmt(c, 2)}).`;
            else if (alpha <= stableAlpha)
              note = `Near the stability edge (curvature≈${fmt(c, 2)}).`;
            else
              note = `Likely to overshoot/diverge here (curvature≈${fmt(
                c,
                2
              )}).`;
          } else {
            note = `Non-convex region; step behavior may be unpredictable.`;
          }
          stabilityNote.innerHTML = note;

          // status & steps highlight
          const gabs = Math.abs(df(x));
          if (gabs < 1e-4) {
            statusVal.textContent = "converged ✓";
            setStepActive(6);
          } else if (running) {
            statusVal.textContent = "running…";
            setStepActive(5);
          } else {
            statusVal.textContent = "paused";
            setStepActive(4);
          }
        }

        function estimateCurvature(xx) {
          const h = 1e-3;
          const d1 = df(xx + h);
          const d0 = df(xx - h);
          return (d1 - d0) / (2 * h);
        }

        // ---------- Interaction ----------
        function pickFunction(key) {
          currentKey = key;
          const F = FUNCTIONS[currentKey];
          f = F.f;
          df = F.df;
          XR = F.range.slice();
          v = 0;
          iter = 0;
          lossHistory = [];
          x = F.defaultX;
          path = [{ x, y: f(x) }];
          computeYRange();
          drawAll();
          // Step box highlight reset
          setStepActive(1);
        }

        function randomizeStart() {
          const pad = 0.1 * (XR[1] - XR[0]);
          x = rand(XR[0] + pad, XR[1] - pad);
          v = 0;
          iter = 0;
          path = [{ x, y: f(x) }];
          lossHistory = [];
          drawAll();
          setStepActive(3);
        }

        function resetAll() {
          pickFunction(currentKey);
          setStepActive(2);
        }

        function nextXPreview() {
          // Preview next x using plain gradient (with noise only), not yet momentum applied to avoid confusion
          const alpha = Number(lr.value);
          const n = Number(noise.value);
          const g = df(x) + (n > 0 ? n * randn() : 0);
          const xn = x - alpha * g;
          if (snapToRange.checked) {
            return clamp(xn, XR[0], XR[1]);
          }
          return xn;
        }

        function effectiveGrad() {
          // For HUD display: show raw grad and previewGrad (with noise)
          const n = Number(noise.value);
          const raw = df(x);
          const withNoise = raw + (n > 0 ? n * randn() : 0);
          return { raw, previewGrad: withNoise };
        }

        function stepOnce() {
          const alpha = Number(lr.value);
          const beta = Number(momentum.value);
          const n = Number(noise.value);
          // compute noisy gradient
          const g = df(x) + (n > 0 ? n * randn() : 0);
          // momentum update
          v = beta * v + g;
          const dx = -alpha * (beta > 0 ? v : g);
          let xn = x + dx;
          if (snapToRange.checked) {
            xn = clamp(xn, XR[0], XR[1]);
          }
          x = xn;
          iter++;
          path.push({ x, y: f(x) });
          lossHistory.push({ k: iter, f: f(x) });
          // limit history size
          if (lossHistory.length > 400) lossHistory.shift();
          drawAll();
        }

        function toggleRun(force) {
          const to = typeof force === "boolean" ? force : !running;
          running = to;
          runBtn.textContent = running ? "Pause" : "Run";
          if (running) {
            requestAnimationFrame(tick);
          }
          updateHUD();
        }

        function tick(t) {
          if (!running) return;
          const spd = Number(speed.value);
          const now = performance.now();
          if (!lastFrameTime) lastFrameTime = now;
          const dt = now - lastFrameTime;
          const stepInterval = 1000 / spd;
          if (dt >= stepInterval - 1) {
            lastFrameTime = now;
            stepOnce();
          }
          requestAnimationFrame(tick);
        }

        // Dragging on plot
        plot.addEventListener("mousedown", (e) => {
          const rect = plot.getBoundingClientRect();
          const px = e.clientX - rect.left;
          const py = e.clientY - rect.top;
          const xp = pxToX(px);
          const yp = f(xp);
          const dist = Math.hypot(xToPx(xp) - px, yToPx(yp) - py);
          // begin drag if near the curve point
          const near = Math.hypot(xToPx(x) - px, yToPx(f(x)) - py) < 14;
          if (near) {
            dragging = true;
            dragOffsetX = x - xp;
          }
        });
        window.addEventListener("mousemove", (e) => {
          if (!dragging) return;
          const rect = plot.getBoundingClientRect();
          const px = e.clientX - rect.left;
          let xp = pxToX(px);
          xp = xp + dragOffsetX;
          if (snapToRange.checked) xp = clamp(xp, XR[0], XR[1]);
          x = xp;
          iter = 0;
          v = 0;
          path = [{ x, y: f(x) }];
          lossHistory = [];
          drawAll();
          setStepActive(3);
        });
        window.addEventListener("mouseup", () => (dragging = false));
        plot.addEventListener("mouseleave", () => (dragging = false));

        // ---------- Events ----------
        fnSelect.addEventListener("change", () => pickFunction(fnSelect.value));
        randomizeBtn.addEventListener("click", randomizeStart);
        resetBtn.addEventListener("click", resetAll);
        runBtn.addEventListener("click", () => toggleRun());
        stepBtn.addEventListener("click", () => {
          toggleRun(false);
          stepOnce();
          setStepActive(5);
        });

        lr.addEventListener("input", () => {
          lrVal.textContent = Number(lr.value).toFixed(3);
          updateHUD();
          drawAll();
        });
        momentum.addEventListener("input", () => {
          momVal.textContent = Number(momentum.value).toFixed(2);
          updateHUD();
        });
        noise.addEventListener("input", () => {
          noiseVal.textContent = Number(noise.value).toFixed(2);
          updateHUD();
        });
        speed.addEventListener("input", () => {
          speedVal.textContent = String(Number(speed.value));
        });

        showTangent.addEventListener("change", drawAll);
        showArrows.addEventListener("change", drawAll);
        showPath.addEventListener("change", drawAll);
        snapToRange.addEventListener("change", drawAll);

        // Hotkeys
        window.addEventListener("keydown", (e) => {
          if (e.code === "Space") {
            e.preventDefault();
            toggleRun();
          }
          if (e.key.toLowerCase() === "s") {
            e.preventDefault();
            toggleRun(false);
            stepOnce();
          }
          if (e.key.toLowerCase() === "r") {
            e.preventDefault();
            resetAll();
          }
        });

        // ---------- Init ----------
        function init() {
          resizeAll();
          pickFunction(currentKey);
          lrVal.textContent = Number(lr.value).toFixed(3);
          momVal.textContent = Number(momentum.value).toFixed(2);
          noiseVal.textContent = Number(noise.value).toFixed(2);
          speedVal.textContent = String(Number(speed.value));
          setStepActive(2);
          drawAll();
        }
        init();
      })();
    </script>
  </body>
</html>
