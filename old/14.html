<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Interactive Linked List Lab — Web Components</title>
    <style>
      :root {
        --bg: #0f1221;
        --panel: #151936;
        --ink: #e9ecff;
        --muted: #a7b0d7;
        --accent: #7c9cff;
        --accent-2: #5be9b9;
        --danger: #ff6b7a;
        --warn: #ffd166;
        --ok: #2ee07a;
        --node: #1b2148;
        --node-border: #6e7cff;
        --chip-bg: #232a5e;
        --chip-ink: #cfd6ff;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        --radius: 14px;
        --radius-sm: 10px;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto,
          "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif,
          "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--ink);
        background: radial-gradient(
            1200px 600px at 20% -10%,
            #1a1f42 0%,
            #0b0e1b 75%
          ),
          var(--bg);
        background-attachment: fixed;
      }
      /* Layout */
      linked-list-lab {
        display: block;
        max-width: 1200px;
        margin: 24px auto 48px;
        padding: 0 16px;
      }
      .shell {
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 20px;
      }
      @media (max-width: 980px) {
        .shell {
          grid-template-columns: 1fr;
        }
      }

      /* Card / panels */
      .card {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.06),
          rgba(255, 255, 255, 0.02)
        );
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow: clip;
      }
      .card h2 {
        margin: 0;
        font-size: 18px;
        font-weight: 700;
        padding: 14px 16px 12px;
        color: var(--ink);
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        background: radial-gradient(
            600px 200px at 0 -100px,
            rgba(124, 156, 255, 0.25),
            transparent 70%
          ),
          linear-gradient(
            0deg,
            rgba(255, 255, 255, 0.03),
            rgba(255, 255, 255, 0.07)
          );
      }
      .controls {
        padding: 14px;
        display: grid;
        gap: 10px;
      }
      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      .row > * {
        flex: 1 1 auto;
      }

      /* Inputs & buttons */
      input[type="text"],
      input[type="number"],
      select {
        background: #0e1330;
        color: var(--ink);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: var(--radius-sm);
        padding: 10px 12px;
        outline: none;
      }
      input[type="number"]::-webkit-outer-spin-button,
      input[type="number"]::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      label {
        font-size: 12px;
        color: var(--muted);
        display: block;
        margin: 0 0 6px;
      }

      button {
        appearance: none;
        background: linear-gradient(
          180deg,
          rgba(124, 156, 255, 0.18),
          rgba(124, 156, 255, 0.14)
        );
        color: var(--ink);
        border: 1px solid rgba(124, 156, 255, 0.45);
        border-radius: 12px;
        padding: 10px 12px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.04s ease, filter 0.15s ease,
          border-color 0.2s ease;
      }
      button:hover {
        filter: brightness(1.05);
      }
      button:active {
        transform: translateY(1px);
      }
      .ghost {
        background: #0e1330;
        border-color: rgba(255, 255, 255, 0.15);
      }
      .danger {
        background: linear-gradient(
          180deg,
          rgba(255, 107, 122, 0.16),
          rgba(255, 107, 122, 0.12)
        );
        border-color: rgba(255, 107, 122, 0.6);
      }
      .ok {
        background: linear-gradient(
          180deg,
          rgba(46, 224, 122, 0.18),
          rgba(46, 224, 122, 0.14)
        );
        border-color: rgba(46, 224, 122, 0.55);
      }
      .tiny {
        padding: 6px 9px;
        border-radius: 10px;
        font-size: 12px;
      }
      .wide {
        flex: 1 1 100%;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 999px;
        background: var(--chip-bg);
        color: var(--chip-ink);
        font-size: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
      }

      /* Visualization card */
      ll-visual {
        display: block;
        position: relative;
        min-height: 380px;
        background: radial-gradient(
            800px 400px at 100% -50%,
            rgba(91, 233, 185, 0.1),
            transparent 60%
          ),
          radial-gradient(
            900px 520px at -20% -160px,
            rgba(124, 156, 255, 0.12),
            transparent 50%
          ),
          linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.05),
            rgba(255, 255, 255, 0.03)
          );
      }
      .viz-wrap {
        position: relative;
        padding: 10px 10px 16px;
      }
      .legend {
        display: flex;
        gap: 10px;
        align-items: center;
        padding: 8px 12px 6px;
        flex-wrap: wrap;
      }

      .list-row,
      .extra-row {
        position: relative;
        display: flex;
        align-items: center;
        gap: 30px;
        padding: 22px 20px;
        min-height: 120px;
      }
      .extra-row {
        min-height: 100px;
        border-top: 1px dashed rgba(255, 255, 255, 0.12);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          transparent
        );
      }
      .extra-tag {
        position: absolute;
        left: 16px;
        top: 6px;
        font-size: 11px;
        color: var(--muted);
      }

      /* Node */
      ll-node {
        display: inline-block;
        position: relative;
      }
      ll-node .node {
        display: grid;
        grid-template-columns: 100px 70px;
        border: 2px solid var(--node-border);
        border-radius: 12px;
        overflow: hidden;
        background: var(--node);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
      }
      .cell {
        padding: 10px 12px;
        display: grid;
        place-items: center;
        min-height: 60px;
      }
      .cell.data {
        border-right: 2px solid var(--node-border);
        font-weight: 700;
        font-size: 18px;
      }
      .cell.next {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas,
          "Liberation Mono", monospace;
        font-size: 13px;
        color: var(--muted);
      }
      .addr {
        position: absolute;
        top: -22px;
        left: 8px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas,
          "Liberation Mono", monospace;
        font-size: 11px;
        color: #b8beff;
        opacity: 0.9;
        background: rgba(20, 26, 60, 0.9);
        padding: 3px 6px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.12);
      }
      .label {
        position: absolute;
        bottom: -22px;
        left: 10px;
        font-size: 11px;
        color: var(--muted);
      }
      .hl-visit .node {
        box-shadow: 0 0 0 3px rgba(124, 156, 255, 0.35),
          0 6px 18px rgba(124, 156, 255, 0.2);
      }
      .hl-match .node {
        box-shadow: 0 0 0 3px rgba(91, 233, 185, 0.35),
          0 6px 18px rgba(91, 233, 185, 0.2);
      }
      .hl-remove .node {
        box-shadow: 0 0 0 3px rgba(255, 107, 122, 0.35),
          0 6px 18px rgba(255, 107, 122, 0.18);
      }
      .pulse {
        animation: pulse 1.5s ease-in-out infinite;
      }
      @keyframes pulse {
        0%,
        100% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.25);
        }
      }

      /* Pointers & arrows overlay */
      svg.overlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      .msgbar {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          rgba(255, 255, 255, 0.03)
        );
        font-size: 14px;
        color: var(--ink);
      }

      /* Stepper */
      .stepper {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
        padding: 10px 12px;
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          rgba(255, 255, 255, 0.03)
        );
      }
      .spacer {
        flex: 1 1 auto;
      }
      .range {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: var(--muted);
      }
      input[type="range"] {
        width: 180px;
      }

      .kbd {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: #0f1330;
        color: #cbd1ff;
      }

      /* Tiny helper */
      .small {
        font-size: 12px;
        color: var(--muted);
      }
      .hint {
        color: var(--muted);
        font-size: 12px;
        margin-left: auto;
      }
    </style>
  </head>
  <body>
    <linked-list-lab></linked-list-lab>

    <template id="tpl-controls">
      <div class="card">
        <h2>Controls</h2>
        <div class="controls">
          <div class="row">
            <div style="flex: 1 1 120px">
              <label>Value</label>
              <input name="value" type="text" placeholder="e.g. 42 or 'A'" />
            </div>
            <div style="width: 110px">
              <label>Index</label>
              <input name="index" type="number" min="0" value="0" />
            </div>
          </div>

          <div class="row">
            <button data-action="push-head" title="Insert new node at the head">
              + Head
            </button>
            <button data-action="push-tail" title="Insert new node at the tail">
              + Tail
            </button>
            <button
              data-action="insert-at"
              class="ok"
              title="Insert at specific index"
            >
              Insert @ Index
            </button>
          </div>

          <div class="row">
            <button
              data-action="pop-head"
              class="danger"
              title="Remove head node"
            >
              − Head
            </button>
            <button
              data-action="pop-tail"
              class="danger"
              title="Remove tail node"
            >
              − Tail
            </button>
            <button
              data-action="remove-at"
              class="danger"
              title="Remove at index"
            >
              Remove @ Index
            </button>
          </div>

          <div class="row">
            <button
              data-action="search"
              class="ghost"
              title="Find value (linear search)"
            >
              Search
            </button>
            <button
              data-action="reverse"
              class="ghost"
              title="Reverse the list in-place"
            >
              Reverse
            </button>
          </div>

          <div class="row">
            <button data-action="random" title="Fill with random values">
              Randomize
            </button>
            <button data-action="clear" class="ghost" title="Clear the list">
              Clear
            </button>
            <div class="chip" title="Length of current linked list">
              <strong>len</strong>&nbsp;<span id="len">0</span>
            </div>
          </div>

          <div class="row">
            <div class="wide small">
              Tips: Use <span class="kbd">Space</span> to Step,
              <span class="kbd">⟵</span>/<span class="kbd">⟶</span> to navigate,
              and <span class="kbd">P</span> to Play/Pause.
            </div>
          </div>
        </div>

        <div class="stepper">
          <button class="tiny" data-step="first" title="First">⏮</button>
          <button class="tiny" data-step="prev" title="Prev">◀</button>
          <button class="tiny ok" data-step="step" title="Step (Space)">
            Step
          </button>
          <button class="tiny" data-step="next" title="Next">▶</button>
          <button class="tiny" data-step="last" title="Last">⏭</button>
          <button class="tiny ghost" data-step="play" title="Play/Pause (P)">
            ► Play
          </button>
          <div class="spacer"></div>
          <div class="range">
            Speed
            <input name="speed" type="range" min="0" max="100" value="70" />
            <span class="hint">slower ← → faster</span>
          </div>
        </div>
      </div>
    </template>

    <template id="tpl-visual">
      <div class="card">
        <h2>Linked List Visualization</h2>

        <div class="legend">
          <span class="chip"
            ><svg width="12" height="12" style="margin-right: 4px">
              <rect width="12" height="12" rx="2" fill="#7c9cff" /></svg
            >head</span
          >
          <span class="chip"
            ><svg width="12" height="12" style="margin-right: 4px">
              <rect width="12" height="12" rx="2" fill="#ffd166" /></svg
            >tail</span
          >
          <span class="chip"
            ><svg width="12" height="12" style="margin-right: 4px">
              <rect width="12" height="12" rx="2" fill="#5be9b9" /></svg
            >curr</span
          >
          <span class="chip"
            ><svg width="12" height="12" style="margin-right: 4px">
              <rect width="12" height="12" rx="2" fill="#ff6b7a" /></svg
            >prev</span
          >
          <span class="chip"
            ><svg width="12" height="12" style="margin-right: 4px">
              <rect width="12" height="12" rx="2" fill="#e9ecff" /></svg
            >next</span
          >
          <span class="hint">Each node shows [data | next address].</span>
        </div>

        <div class="viz-wrap">
          <div class="list-row" part="list-row"></div>
          <div class="extra-row" part="extra-row">
            <div class="extra-tag">Detached / newly allocated</div>
          </div>
          <svg
            class="overlay"
            part="overlay"
            xmlns="http://www.w3.org/2000/svg"
          ></svg>
        </div>

        <div class="msgbar">
          <div class="chip" id="stepChip">
            Step <span id="stepIndex">0</span>/<span id="stepTotal">0</span>
          </div>
          <div style="opacity: 0.65">•</div>
          <div id="message">Welcome! Create nodes to begin.</div>
          <div class="spacer"></div>
          <div class="small" id="meta"></div>
        </div>
      </div>
    </template>

    <template id="tpl-node">
      <div class="addr"></div>
      <div class="node">
        <div class="cell data" part="data"></div>
        <div class="cell next" part="next"></div>
      </div>
      <div class="label"></div>
    </template>

    <script>
      /* =========================
   Data Model: Linked List
   ========================= */
      class Node {
        constructor(value) {
          this.id = crypto.randomUUID();
          this.value = value;
          this.next = null; // pointer to next Node
          this.addr = Node.fakeAddr();
        }
        static fakeAddr() {
          // pretty little fake heap addresses (0xAB12:CD34 style)
          const r = () => Math.floor(Math.random() * 256);
          return `0x${r().toString(16).padStart(2, "0")}${r()
            .toString(16)
            .padStart(2, "0")}:${r().toString(16).padStart(2, "0")}${r()
            .toString(16)
            .padStart(2, "0")}`;
        }
      }

      class LinkedList {
        constructor() {
          this.head = null;
        }
        get length() {
          let n = 0,
            cur = this.head;
          while (cur) {
            n++;
            cur = cur.next;
          }
          return n;
        }
        toArray() {
          const arr = [];
          let cur = this.head;
          while (cur) {
            arr.push(cur);
            cur = cur.next;
          }
          return arr;
        }
      }

      /* ===================================
   Step Builder: snapshots per action
   =================================== */
      function buildSnapshot(
        ll,
        message,
        { highlight = {}, pointers = {}, extras = [] } = {}
      ) {
        // Build a render-friendly snapshot from the current list + extras
        const nodes = ll.toArray().map((n) => ({
          id: n.id,
          value: n.value,
          addr: n.addr,
          nextId: n.next ? n.next.id : null,
          highlight: highlight[n.id] || null,
        }));
        const extraNodes = extras.map((n) => ({
          id: n.id,
          value: n.value,
          addr: n.addr,
          nextId: n.next ? n.next.id : null,
          highlight: highlight[n.id] || null,
        }));
        const ptrs = {
          head: ll.head ? ll.head.id : null,
          tail: nodes.length ? nodes[nodes.length - 1].id : null,
          ...pointers,
        };
        return { message, nodes, extraNodes, pointers: ptrs };
      }

      function* steps_push_head(ll, value) {
        const newNode = new Node(value);
        yield buildSnapshot(
          ll,
          `Allocate new node with value ${repr(value)}.`,
          {
            extras: [newNode],
            pointers: { new: newNode.id },
            highlight: { [newNode.id]: "hl-visit" },
          }
        );
        newNode.next = ll.head;
        yield buildSnapshot(ll, `Set new.next → head.`, {
          extras: [newNode],
          pointers: { new: newNode.id, head: ll.head ? ll.head.id : null },
        });
        ll.head = newNode;
        yield buildSnapshot(ll, `Move head to new node.`, {
          pointers: { head: newNode.id },
        });
      }

      function* steps_push_tail(ll, value) {
        const newNode = new Node(value);
        if (!ll.head) {
          yield* steps_push_head(ll, value);
          return;
        }
        yield buildSnapshot(ll, `Allocate new tail node ${repr(value)}.`, {
          extras: [newNode],
          pointers: { new: newNode.id, tail: lastId(ll) },
          highlight: { [newNode.id]: "hl-visit" },
        });
        // Traverse to tail
        let prev = null,
          cur = ll.head;
        while (cur.next) {
          yield buildSnapshot(ll, `Traverse: curr at ${repr(cur.value)}.`, {
            extras: [newNode],
            pointers: { curr: cur.id, tail: lastId(ll) },
            highlight: { [cur.id]: "hl-visit" },
          });
          prev = cur;
          cur = cur.next;
        }
        yield buildSnapshot(ll, `Link last node's next → new.`, {
          extras: [newNode],
          pointers: { curr: cur.id, new: newNode.id },
        });
        cur.next = newNode;
        yield buildSnapshot(ll, `Tail is now the new node.`, {
          pointers: { tail: newNode.id },
        });
      }

      function* steps_insert_at(ll, index, value) {
        index = Math.max(0, Math.min(index, ll.length));
        if (index === 0) {
          yield* steps_push_head(ll, value);
          return;
        }
        const newNode = new Node(value);
        yield buildSnapshot(
          ll,
          `Allocate new node ${repr(value)} to insert at index ${index}.`,
          {
            extras: [newNode],
            pointers: { new: newNode.id },
            highlight: { [newNode.id]: "hl-visit" },
          }
        );
        let prev = null,
          cur = ll.head,
          i = 0;
        while (i < index - 1 && cur) {
          yield buildSnapshot(
            ll,
            `Traverse: i=${i}, curr=${repr(cur.value)}.`,
            {
              extras: [newNode],
              pointers: { curr: cur.id },
              highlight: { [cur.id]: "hl-visit" },
            }
          );
          prev = cur;
          cur = cur.next;
          i++;
        }
        yield buildSnapshot(
          ll,
          `Splice: new.next → prev.next (index ${index}).`,
          {
            extras: [newNode],
            pointers: {
              new: newNode.id,
              prev: prev.id,
              next: cur ? cur.id : null,
            },
          }
        );
        newNode.next = prev.next;
        prev.next = newNode;
        yield buildSnapshot(ll, `Connect prev.next → new.`, {
          pointers: { prev: prev.id, curr: newNode.id },
        });
      }

      function* steps_pop_head(ll) {
        if (!ll.head) {
          yield buildSnapshot(ll, `List is already empty.`, {});
          return;
        }
        yield buildSnapshot(
          ll,
          `Remove head: mark ${repr(ll.head.value)} for deletion.`,
          { highlight: { [ll.head.id]: "hl-remove" } }
        );
        ll.head = ll.head.next;
        yield buildSnapshot(ll, `Move head to next node.`, {});
      }

      function* steps_pop_tail(ll) {
        if (!ll.head) {
          yield* steps_pop_head(ll);
          return;
        }
        if (!ll.head.next) {
          yield* steps_pop_head(ll);
          return;
        }
        let prev = null,
          cur = ll.head;
        while (cur.next) {
          yield buildSnapshot(
            ll,
            `Traverse to tail: curr=${repr(cur.value)}.`,
            { pointers: { curr: cur.id }, highlight: { [cur.id]: "hl-visit" } }
          );
          prev = cur;
          cur = cur.next;
        }
        yield buildSnapshot(
          ll,
          `Unlink last node ${repr(cur.value)} by setting prev.next → null.`,
          {
            pointers: { prev: prev.id, curr: cur.id },
            highlight: { [cur.id]: "hl-remove" },
          }
        );
        prev.next = null;
        yield buildSnapshot(ll, `Tail is now ${repr(prev.value)}.`, {
          pointers: { tail: prev.id },
        });
      }

      function* steps_remove_at(ll, index) {
        if (index <= 0) {
          yield* steps_pop_head(ll);
          return;
        }
        if (index >= ll.length - 1) {
          yield* steps_pop_tail(ll);
          return;
        }
        let prev = null,
          cur = ll.head,
          i = 0;
        while (i < index && cur) {
          yield buildSnapshot(
            ll,
            `Traverse: i=${i}, curr=${repr(cur.value)}.`,
            { pointers: { curr: cur.id }, highlight: { [cur.id]: "hl-visit" } }
          );
          prev = cur;
          cur = cur.next;
          i++;
        }
        if (!cur) {
          yield buildSnapshot(ll, `Index out of range.`, {});
          return;
        }
        yield buildSnapshot(
          ll,
          `Remove at index ${index}: prev.next → curr.next.`,
          {
            pointers: {
              prev: prev.id,
              curr: cur.id,
              next: cur.next ? cur.next.id : null,
            },
            highlight: { [cur.id]: "hl-remove" },
          }
        );
        prev.next = cur.next;
        yield buildSnapshot(ll, `Splice complete.`, {});
      }

      function* steps_search(ll, value) {
        if (!ll.head) {
          yield buildSnapshot(
            ll,
            `List is empty; value ${repr(value)} not found.`,
            {}
          );
          return;
        }
        let cur = ll.head;
        let i = 0;
        while (cur) {
          yield buildSnapshot(ll, `Visit index ${i}: ${repr(cur.value)}.`, {
            pointers: { curr: cur.id },
            highlight: { [cur.id]: "hl-visit" },
          });
          if (equals(cur.value, value)) {
            yield buildSnapshot(ll, `Match at index ${i}!`, {
              pointers: { curr: cur.id },
              highlight: { [cur.id]: "hl-match" },
            });
            return;
          }
          cur = cur.next;
          i++;
        }
        yield buildSnapshot(ll, `Value ${repr(value)} not found.`, {});
      }

      function* steps_reverse(ll) {
        let prev = null,
          curr = ll.head,
          step = 0;
        yield buildSnapshot(ll, `Start reverse: prev = null, curr = head.`, {
          pointers: { prev: null, curr: curr ? curr.id : null },
        });
        while (curr) {
          const next = curr.next;
          yield buildSnapshot(
            ll,
            `Step ${step}: Save next, break curr.next link.`,
            {
              pointers: {
                prev: prev ? prev.id : null,
                curr: curr.id,
                next: next ? next.id : null,
              },
            }
          );
          curr.next = prev;
          yield buildSnapshot(
            ll,
            `Step ${step}: Reverse pointer: curr.next → prev.`,
            {
              pointers: { prev: prev ? prev.id : null, curr: curr.id },
              highlight: { [curr.id]: "hl-visit" },
            }
          );
          prev = curr;
          curr = next;
          yield buildSnapshot(ll, `Advance: prev = curr, curr = next.`, {
            pointers: {
              prev: prev ? prev.id : null,
              curr: curr ? curr.id : null,
            },
          });
          step++;
        }
        ll.head = prev;
        yield buildSnapshot(ll, `Done: head → prev; list reversed.`, {
          pointers: { head: ll.head ? ll.head.id : null },
        });
      }

      /* ==============
   Visual helpers
   ============== */
      const COLORS = {
        head: "#7c9cff",
        tail: "#ffd166",
        curr: "#5be9b9",
        prev: "#ff6b7a",
        next: "#e9ecff",
        new: "#a78bfa",
      };
      const ptrOrder = ["head", "tail", "curr", "prev", "next", "new"];

      function repr(v) {
        return typeof v === "string" && !/^\s*['"]/.test(v) ? `'${v}'` : `${v}`;
      }
      function equals(a, b) {
        try {
          // Try to coerce numeric strings to numbers if both look numeric
          const an = Number(a),
            bn = Number(b);
          if (!Number.isNaN(an) && !Number.isNaN(bn)) return an === bn;
        } catch {}
        return `${a}` === `${b}`;
      }
      function lastId(ll) {
        let cur = ll.head,
          last = null;
        while (cur) {
          last = cur;
          cur = cur.next;
        }
        return last ? last.id : null;
      }

      /* ==========================
   Web Component: <ll-node>
   ========================== */
      class LLNode extends HTMLElement {
        static get observedAttributes() {
          return ["value", "addr", "nextaddr", "label", "highlight"];
        }
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
          const tpl = document.getElementById("tpl-node");
          this.shadowRoot.append(tpl.content.cloneNode(true));
        }
        attributeChangedCallback() {
          this.render();
        }
        render() {
          const root = this.shadowRoot;
          root.querySelector(".addr").textContent =
            this.getAttribute("addr") || "";
          const data = root.querySelector(".cell.data");
          const next = root.querySelector(".cell.next");
          data.textContent = this.getAttribute("value") ?? "";
          next.textContent = this.getAttribute("nextaddr") ?? "NULL";
          root.querySelector(".label").textContent =
            this.getAttribute("label") ?? "";
          const cls = this.getAttribute("highlight") || "";
          const nodeEl = root.querySelector(".node");
          nodeEl.classList.remove("hl-visit", "hl-match", "hl-remove", "pulse");
          if (cls) nodeEl.classList.add(cls, "pulse");
        }
      }
      customElements.define("ll-node", LLNode);

      /* ============================
   Web Component: <ll-controls>
   ============================ */
      class LLControls extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
          const tpl = document.getElementById("tpl-controls");
          this.shadowRoot.append(tpl.content.cloneNode(true));
        }
        connectedCallback() {
          const $ = (sel) => this.shadowRoot.querySelector(sel);
          this.shadowRoot.addEventListener("click", (e) => {
            const btn = e.target.closest("button[data-action]");
            if (btn) {
              const valueRaw = $("input[name=value]").value.trim();
              const value = parseValue(valueRaw);
              const index = Number($("input[name=index]").value || 0);
              this.dispatchEvent(
                new CustomEvent("action", {
                  detail: {
                    action: btn.dataset.action,
                    value,
                    valueRaw,
                    index,
                  },
                  bubbles: true,
                  composed: true,
                })
              );
            }
            const stepBtn = e.target.closest("button[data-step]");
            if (stepBtn) {
              this.dispatchEvent(
                new CustomEvent("step", {
                  detail: { kind: stepBtn.dataset.step },
                  bubbles: true,
                  composed: true,
                })
              );
            }
          });
          this.shadowRoot
            .querySelector("input[name=speed]")
            .addEventListener("input", (e) => {
              this.dispatchEvent(
                new CustomEvent("speed", {
                  detail: { speed: Number(e.target.value) },
                  bubbles: true,
                  composed: true,
                })
              );
            });
        }
        set length(n) {
          const len = this.shadowRoot.getElementById("len");
          if (len) len.textContent = n;
        }
        set playing(on) {
          const btn = this.shadowRoot.querySelector('button[data-step="play"]');
          if (btn) btn.textContent = on ? "❚❚ Pause" : "► Play";
        }
      }
      customElements.define("ll-controls", LLControls);

      function parseValue(raw) {
        if (raw === "") return "";
        // try JSON first so "true", "null", numbers, and quoted strings work
        try {
          return JSON.parse(raw);
        } catch (_) {}
        // fallback: treat as plain string
        return raw;
      }

      /* ==========================
   Web Component: <ll-visual>
   ========================== */
      class LLVisual extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
          const tpl = document.getElementById("tpl-visual");
          this.shadowRoot.append(tpl.content.cloneNode(true));
          this._resizeObs = new ResizeObserver(() => this.drawOverlay());
        }
        connectedCallback() {
          const wrap = this.shadowRoot.querySelector(".viz-wrap");
          this._resizeObs.observe(wrap);
          window.addEventListener(
            "resize",
            (this._onResize = () => this.drawOverlay())
          );
        }
        disconnectedCallback() {
          this._resizeObs.disconnect();
          window.removeEventListener("resize", this._onResize);
        }

        setSnapshot(snap) {
          this.snapshot = snap;
          this.render();
        }

        render() {
          const {
            nodes = [],
            extraNodes = [],
            message = "",
            pointers = {},
          } = this.snapshot ?? {};
          const listRow = this.shadowRoot.querySelector(".list-row");
          const extraRow = this.shadowRoot.querySelector(".extra-row");
          listRow.innerHTML = "";
          extraRow.querySelectorAll("ll-node").forEach((n) => n.remove());

          // Render main nodes
          nodes.forEach((n) => {
            const el = document.createElement("ll-node");
            el.dataset.nodeId = n.id;
            el.setAttribute("value", `${n.value}`);
            el.setAttribute("addr", n.addr);
            el.setAttribute("nextaddr", nextAddrLabel(n, nodes));
            if (n.highlight) el.setAttribute("highlight", n.highlight);
            listRow.appendChild(el);
          });

          // Render extras (detached)
          extraNodes.forEach((n) => {
            const el = document.createElement("ll-node");
            el.dataset.nodeId = n.id;
            el.setAttribute("label", "(new)");
            el.setAttribute("value", `${n.value}`);
            el.setAttribute("addr", n.addr);
            el.setAttribute("nextaddr", n.nextId ? "..." : "NULL");
            if (n.highlight) el.setAttribute("highlight", n.highlight);
            extraRow.appendChild(el);
          });

          // message + meta
          this.shadowRoot.getElementById("message").textContent = message || "";
          this.shadowRoot.getElementById("meta").textContent = nodes.length
            ? `head → ${addrOf(nodes[0])} • tail → ${addrOf(
                nodes[nodes.length - 1]
              )}`
            : "head → NULL";
          this.drawOverlay();
        }

        drawOverlay() {
          const svg = this.shadowRoot.querySelector("svg.overlay");
          const listRow = this.shadowRoot.querySelector(".list-row");
          const wrap = this.shadowRoot.querySelector(".viz-wrap");
          const {
            nodes = [],
            extraNodes = [],
            pointers = {},
          } = this.snapshot ?? {};
          const allNodes = [...nodes, ...extraNodes];

          // reset svg
          svg.innerHTML = `
      <defs>
        <marker id="arrow" markerWidth="12" markerHeight="8" refX="10" refY="4" orient="auto">
          <path d="M 0 0 L 10 4 L 0 8 z" fill="currentColor"></path>
        </marker>
      </defs>
    `;

          const makeLine = (
            x1,
            y1,
            x2,
            y2,
            color,
            dash = false,
            width = 2.2
          ) => {
            const ln = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            const dx = x2 - x1,
              dy = y2 - y1;
            const ctrl = `C ${x1 + dx * 0.4} ${y1} ${
              x1 + dx * 0.6
            } ${y2} ${x2} ${y2}`;
            ln.setAttribute("d", `M ${x1} ${y1} ${ctrl}`);
            ln.setAttribute("stroke", color);
            ln.setAttribute("fill", "none");
            ln.setAttribute("stroke-width", width);
            ln.setAttribute("marker-end", "url(#arrow)");
            if (dash) ln.setAttribute("stroke-dasharray", "6 6");
            svg.appendChild(ln);
            return ln;
          };

          const relRect = (el) => {
            const r = el.getBoundingClientRect();
            const base = wrap.getBoundingClientRect();
            return {
              x: r.x - base.x,
              y: r.y - base.y,
              w: r.width,
              h: r.height,
            };
          };

          // Map id -> element
          const idToEl = {};
          this.shadowRoot.querySelectorAll("ll-node").forEach((el) => {
            idToEl[el.dataset.nodeId] = el;
          });

          // Draw "next" arrows between sequential nodes in main list
          nodes.forEach((n, i) => {
            if (!n.nextId) return;
            const from = idToEl[n.id];
            const to = idToEl[n.nextId];
            if (!from || !to) return;
            const rf = relRect(from.shadowRoot.querySelector(".cell.next"));
            const rt = relRect(to);
            const x1 = rf.x + rf.w / 2,
              y1 = rf.y + rf.h / 2;
            const x2 = rt.x - 8,
              y2 = rt.y + rt.h / 2;
            makeLine(x1, y1, x2, y2, "#aab4ff");
          });

          // Draw arrows from detached node to its 'next' if any
          extraNodes.forEach((n) => {
            if (!n.nextId) return;
            const from = idToEl[n.id];
            const to = idToEl[n.nextId];
            if (!from || !to) return;
            const rf = relRect(from.shadowRoot.querySelector(".cell.next"));
            const rt = relRect(to);
            makeLine(
              rf.x + rf.w / 2,
              rf.y + rf.h / 2,
              rt.x - 8,
              rt.y + rt.h / 2,
              "#cfd6ff",
              true
            );
          });

          // Draw pointer badges (head, tail, curr, prev, next, new)
          for (const key of ptrOrder) {
            const id = pointers[key];
            if (!id) continue;
            const target = idToEl[id];
            if (!target) continue;
            const r = relRect(target);
            const x = r.x + r.w / 2,
              y = r.y - 12; // above node
            const badge = drawBadge(svg, x, y, key);
            makeLine(
              badge.x,
              badge.y + 16,
              r.x + r.w / 2,
              r.y,
              COLORS[key],
              false,
              2
            );
          }

          // step counters
          const sIdx = this.getAttribute("step-index") || 0;
          const sTot = this.getAttribute("step-total") || 0;
          this.shadowRoot.getElementById("stepIndex").textContent = sIdx;
          this.shadowRoot.getElementById("stepTotal").textContent = sTot;
        }
      }

      function nextAddrLabel(node, nodes) {
        const nxt = node.nextId
          ? nodes.find((n) => n.id === node.nextId)
          : null;
        return nxt ? nxt.addr : "NULL";
      }

      function addrOf(n) {
        return n ? n.addr : "NULL";
      }

      function drawBadge(svg, x, y, key) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        const text = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "text"
        );
        const rect = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "rect"
        );
        const label = key;
        const color = COLORS[key] || "#fff";
        text.setAttribute("x", x + 8);
        text.setAttribute("y", y + 16);
        text.setAttribute("font-size", "12");
        text.setAttribute(
          "font-family",
          "system-ui, -apple-system, Segoe UI, Roboto, Arial"
        );
        text.setAttribute("fill", "#101225");
        text.textContent = label;
        const width = Math.max(26, 8 + label.length * 7 + 8);
        rect.setAttribute("x", x);
        rect.setAttribute("y", y);
        rect.setAttribute("width", width);
        rect.setAttribute("height", 20);
        rect.setAttribute("rx", 6);
        rect.setAttribute("fill", color);
        rect.setAttribute("stroke", "rgba(0,0,0,.25)");
        g.append(rect, text);
        svg.appendChild(g);
        return { x: x + width / 2, y };
      }
      customElements.define("ll-visual", LLVisual);

      /* ==================================
   Web Component: <linked-list-lab>
   ================================== */
      class LinkedListLab extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
          const wrapper = document.createElement("div");
          wrapper.className = "shell";
          // Controls
          this.controls = document.createElement("ll-controls");
          // Visual
          this.visual = document.createElement("ll-visual");
          // Intro card on the right
          wrapper.append(this.controls, this.visual);
          this.shadowRoot.append(wrapper);

          // internal state
          this.ll = new LinkedList();
          this.steps = [
            buildSnapshot(
              this.ll,
              "Empty list. Use the controls to add nodes."
            ),
          ];
          this.stepIndex = 0;
          this.autoplayTimer = null;
        }

        connectedCallback() {
          this.update();
          this.controls.addEventListener("action", (e) =>
            this.onAction(e.detail)
          );
          this.controls.addEventListener("step", (e) =>
            this.onStepCommand(e.detail.kind)
          );
          this.controls.addEventListener("speed", (e) =>
            this.onSpeed(e.detail.speed)
          );
          this.addEventListener("keydown", (e) => this.onKey(e));
          this.setAttribute("tabindex", "0"); // focusable for keyboard shortcuts
        }

        onSpeed(v) {
          // map 0..100 to 1200..200 ms (ease-out)
          const t = 200 + (100 - v) * 10;
          this.playDelay = t;
        }

        onKey(e) {
          if (e.code === "Space") {
            e.preventDefault();
            this.onStepCommand("step");
          } else if (e.key === "ArrowLeft") {
            this.onStepCommand("prev");
          } else if (e.key === "ArrowRight") {
            this.onStepCommand("next");
          } else if (e.key.toLowerCase() === "p") {
            this.onStepCommand("play");
          }
        }

        onStepCommand(kind) {
          const n = this.steps.length;
          const go = (i) => {
            this.stepIndex = Math.max(0, Math.min(i, n - 1));
            this.update();
          };
          if (kind === "first") go(0);
          else if (kind === "last") go(n - 1);
          else if (kind === "prev") go(this.stepIndex - 1);
          else if (kind === "next") go(this.stepIndex + 1);
          else if (kind === "step") go(this.stepIndex + 1);
          else if (kind === "play") {
            if (this.autoplayTimer) {
              this.stopPlay();
            } else this.startPlay();
          }
        }

        startPlay() {
          if (this.autoplayTimer) return;
          this.controls.playing = true;
          const tick = () => {
            if (this.stepIndex < this.steps.length - 1) {
              this.stepIndex++;
              this.update();
              this.autoplayTimer = setTimeout(tick, this.playDelay ?? 700);
            } else {
              this.stopPlay();
            }
          };
          this.autoplayTimer = setTimeout(tick, this.playDelay ?? 700);
        }
        stopPlay() {
          this.controls.playing = false;
          clearTimeout(this.autoplayTimer);
          this.autoplayTimer = null;
        }

        *genFrom(action) {
          switch (action.action) {
            case "push-head":
              yield* steps_push_head(this.ll, action.value);
              break;
            case "push-tail":
              yield* steps_push_tail(this.ll, action.value);
              break;
            case "insert-at":
              yield* steps_insert_at(this.ll, action.index, action.value);
              break;
            case "pop-head":
              yield* steps_pop_head(this.ll);
              break;
            case "pop-tail":
              yield* steps_pop_tail(this.ll);
              break;
            case "remove-at":
              yield* steps_remove_at(this.ll, action.index);
              break;
            case "search":
              yield* steps_search(this.ll, action.value);
              break;
            case "reverse":
              yield* steps_reverse(this.ll);
              break;
            case "random":
              yield* this.steps_random();
              break;
            case "clear":
              yield* this.steps_clear();
              break;
            default:
              yield buildSnapshot(this.ll, "No-op.");
          }
        }

        *steps_random() {
          // clear, then add 4-7 random nodes via head/tail mix to demo traversals
          yield* this.steps_clear();
          const n = 4 + Math.floor(Math.random() * 4);
          for (let i = 0; i < n; i++) {
            const v = Math.floor(Math.random() * 90) + 10;
            if (Math.random() < 0.5) yield* steps_push_head(this.ll, v);
            else yield* steps_push_tail(this.ll, v);
          }
          yield buildSnapshot(this.ll, `Randomized ${n} nodes.`);
        }
        *steps_clear() {
          while (this.ll.head) {
            yield* steps_pop_head(this.ll);
          }
          yield buildSnapshot(this.ll, "Cleared list.");
        }

        onAction(action) {
          this.stopPlay();
          // Build new steps: start with current final state snapshot so user can "step into"
          const snaps = [];
          for (const s of this.genFrom(action)) snaps.push(s);
          if (snaps.length === 0) return;

          // Prepend a snapshot capturing the current static state, for smoother stepping:
          const pre = buildSnapshot(this.ll, "Before operation.");
          const all = [pre, ...snaps];
          this.steps = all;
          this.stepIndex = 0;
          this.update();
        }

        update() {
          const snap = this.steps[this.stepIndex] || buildSnapshot(this.ll, "");
          this.visual.setAttribute("step-index", this.stepIndex);
          this.visual.setAttribute("step-total", this.steps.length - 1);
          this.visual.setSnapshot(snap);
          this.controls.length = this.ll.length;
        }
      }
      customElements.define("linked-list-lab", LinkedListLab);
    </script>
  </body>
</html>
