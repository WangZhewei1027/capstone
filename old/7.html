<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>K-Nearest Neighbors â€” Single-File JS Demo</title>
    <style>
      :root {
        --bg: #0b1020;
        --panel: #121a33;
        --ink: #e7ecff;
        --muted: #a9b2d3;
        --acc: #7dd3fc;
        --acc2: #c084fc;
        --acc3: #fca5a5;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: linear-gradient(160deg, #0b1020, #0a142a 60%, #081029);
        color: var(--ink);
        font: 14px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      }
      header {
        padding: 18px 20px;
        border-bottom: 1px solid #1e2a55;
        background: rgba(0, 0, 0, 0.25);
        backdrop-filter: blur(4px);
        position: sticky;
        top: 0;
        z-index: 5;
      }
      h1 {
        margin: 0;
        font-size: 18px;
        letter-spacing: 0.3px;
      }
      main {
        display: grid;
        grid-template-columns: 340px 1fr;
        gap: 14px;
        min-height: calc(100dvh - 64px);
        padding: 14px;
      }
      .panel {
        background: linear-gradient(180deg, #121a33, #0f1630);
        border: 1px solid #1c2750;
        border-radius: 14px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        padding: 14px;
      }
      .controls .row {
        display: flex;
        gap: 8px;
        align-items: center;
        margin: 8px 0;
      }
      label {
        font-size: 12px;
        color: var(--muted);
      }
      input[type="range"] {
        width: 100%;
      }
      button {
        cursor: pointer;
        background: #18234a;
        border: 1px solid #24336b;
        color: var(--ink);
        padding: 8px 10px;
        border-radius: 10px;
      }
      button:hover {
        filter: brightness(1.1);
      }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 8px;
        border-radius: 999px;
        border: 1px solid #26326a;
        background: #131a35;
        color: #cdd6ff;
        font-size: 12px;
      }
      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
      }
      .legend .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
      }
      .hint {
        color: var(--muted);
        font-size: 12px;
        margin: 8px 0 0;
      }
      #vizWrap {
        position: relative;
      }
      #canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: radial-gradient(
            1200px 600px at 60% -20%,
            rgba(125, 211, 252, 0.12),
            transparent 60%
          ),
          linear-gradient(180deg, #0a132b, #0b132a);
        border-radius: 14px;
        border: 1px solid #1a2554;
      }
      #readout {
        position: absolute;
        left: 12px;
        bottom: 12px;
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid #1c2750;
        border-radius: 10px;
        padding: 6px 10px;
        color: #dbe4ff;
        font-size: 12px;
      }
      .pill {
        padding: 0.1rem 0.5rem;
        border-radius: 999px;
        border: 1px solid #2b386f;
        background: #121a33;
        color: #cbd5ff;
        font-weight: 600;
      }
      .ghost {
        opacity: 0.65;
      }
      code.small {
        font-size: 12px;
        color: #bcd0ff;
      }
      footer {
        padding: 10px 16px;
        color: #9fb1ff;
        border-top: 1px solid #1a2554;
        font-size: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .kbd {
        border: 1px solid #33407b;
        border-bottom-width: 3px;
        padding: 2px 6px;
        border-radius: 6px;
        background: #0e1733;
        color: #cfe1ff;
        font-weight: 700;
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      }
      .gridBtns {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>
        k-Nearest Neighbors (k-NN) â€¢ Interactive JavaScript Demo (single HTML
        file)
      </h1>
    </header>

    <main>
      <section class="panel controls">
        <div class="row">
          <span class="badge"
            >Algorithm <code class="small">k-NN (Euclidean)</code></span
          >
        </div>

        <div class="row">
          <label style="min-width: 56px">k</label>
          <input id="kRange" type="range" min="1" max="15" step="1" value="5" />
          <output id="kOut" class="pill">5</output>
        </div>

        <div class="row">
          <label style="min-width: 56px">Classes</label>
          <div class="legend">
            <div class="badge">
              <span class="dot" style="background: var(--acc)"></span>Class A
            </div>
            <div class="badge">
              <span class="dot" style="background: var(--acc2)"></span>Class B
            </div>
            <div class="badge">
              <span class="dot" style="background: var(--acc3)"></span>Class C
            </div>
          </div>
        </div>

        <div class="row">
          <label style="min-width: 56px">Add</label>
          <div class="gridBtns">
            <button data-add="A">Add A</button>
            <button data-add="B">Add B</button>
            <button data-add="C">Add C</button>
            <button id="addNoise">Add 30 Random</button>
          </div>
        </div>

        <div class="row">
          <label style="min-width: 56px">Mode</label>
          <div class="gridBtns">
            <button id="modeAdd" class="pill">ðŸ“Œ Add Training</button>
            <button id="modeQuery" class="pill">
              ðŸ§­ Classify (Click canvas)
            </button>
          </div>
        </div>

        <div class="row">
          <label style="min-width: 56px">Data</label>
          <div class="gridBtns">
            <button id="resetBtn">Reset</button>
            <button id="lineToggle">Toggle neighbor lines</button>
            <button id="boundaryBtn">Show decision grid</button>
          </div>
        </div>

        <p class="hint">
          â€¢ Click the canvas to <b>add a query point</b> (purple ring) and
          classify it with k-NN.<br />
          â€¢ Use <span class="kbd">A</span>/<span class="kbd">B</span>/<span
            class="kbd"
            >C</span
          >
          keys to switch class when adding points; <span class="kbd">Q</span> to
          switch to query mode; <span class="kbd">R</span> to reset;
          <span class="kbd">L</span> lines; <span class="kbd">G</span> grid.
        </p>

        <hr style="border-color: #1c2750" />
        <details open>
          <summary style="cursor: pointer; color: #cfe1ff">
            How it works
          </summary>
          <p class="hint">
            Given a query point <em>q</em>, compute Euclidean distances to all
            training points, take the <em>k</em> smallest, and assign the class
            with the highest vote (ties break by smallest summed distance, then
            by smallest k). Complexity per query:
            <code class="small">O(n log n)</code> (sort) or
            <code class="small">O(n)</code> with a selection algorithm.
          </p>
        </details>
      </section>

      <section class="panel" id="vizWrap">
        <canvas id="canvas" width="1024" height="640"></canvas>
        <div id="readout">k=5 â€¢ Train: 0 â€¢ Click to classify</div>
      </section>
    </main>

    <footer>
      <div>
        Tip: drag to pan, wheel/trackpad to zoom. Double-click to center.
      </div>
      <div>Â© k-NN Demo â€” vanilla JS, no libraries</div>
    </footer>

    <script>
      (() => {
        // ---------- State ----------
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        const W0 = canvas.width,
          H0 = canvas.height;
        canvas.width = W0 * DPR;
        canvas.height = H0 * DPR;
        canvas.style.width = W0 + "px";
        canvas.style.height = H0 + "px";
        ctx.scale(DPR, DPR);

        const colors = {
          A: getCSS("--acc") || "#7dd3fc",
          B: getCSS("--acc2") || "#c084fc",
          C: getCSS("--acc3") || "#fca5a5",
          txt: getCSS("--ink") || "#e7ecff",
          grid: "#1a2554",
        };
        const points = []; // {x,y,cls}
        let k = 5;
        let currentClass = "A";
        let mode = "query"; // 'add' | 'query'
        let neighborLines = true;
        let showBoundary = false;
        let lastQuery = null; // {x,y,pred,neighbors:[indices]}
        const readout = document.getElementById("readout");

        // View transform (pan & zoom)
        const view = { x: W0 / 2, y: H0 / 2, scale: 1 }; // world units coincide with px
        let isPanning = false,
          panStart = null;

        // ---------- UI Elements ----------
        const kRange = document.getElementById("kRange");
        const kOut = document.getElementById("kOut");
        const addButtons = [...document.querySelectorAll("[data-add]")];
        const addNoiseBtn = document.getElementById("addNoise");
        const resetBtn = document.getElementById("resetBtn");
        const lineToggleBtn = document.getElementById("lineToggle");
        const boundaryBtn = document.getElementById("boundaryBtn");
        const modeAddBtn = document.getElementById("modeAdd");
        const modeQueryBtn = document.getElementById("modeQuery");

        // ---------- Helpers ----------
        function getCSS(varName) {
          return getComputedStyle(document.documentElement)
            .getPropertyValue(varName)
            .trim();
        }
        function dist2(a, b) {
          const dx = a.x - b.x,
            dy = a.y - b.y;
          return dx * dx + dy * dy;
        }
        function screenToWorld(sx, sy) {
          return {
            x: (sx - W0 / 2) / view.scale + view.x,
            y: (sy - H0 / 2) / view.scale + view.y,
          };
        }
        function worldToScreen(wx, wy) {
          return {
            x: (wx - view.x) * view.scale + W0 / 2,
            y: (wy - view.y) * view.scale + H0 / 2,
          };
        }

        function vote(neighbors) {
          const tally = new Map();
          const sumDist = new Map();
          neighbors.forEach((n) => {
            tally.set(n.cls, (tally.get(n.cls) || 0) + 1);
            sumDist.set(n.cls, (sumDist.get(n.cls) || 0) + Math.sqrt(n.d2));
          });
          let best = null;
          for (const [cls, count] of tally) {
            const entry = { cls, count, sum: sumDist.get(cls) };
            if (
              !best ||
              count > best.count ||
              (count === best.count && entry.sum < best.sum)
            )
              best = entry;
          }
          return best?.cls ?? null;
        }

        function classify(q, kVal) {
          if (points.length === 0) return { pred: null, neighbors: [] };
          const kUse = Math.min(kVal, points.length);
          const ds = points.map((p, i) => ({
            i,
            cls: p.cls,
            d2: dist2(q, p),
            pt: p,
          }));
          ds.sort((a, b) => a.d2 - b.d2);
          const kn = ds.slice(0, kUse);
          return { pred: vote(kn), neighbors: kn };
        }

        function addRandom(n = 30) {
          for (let i = 0; i < n; i++) {
            const cls = ["A", "B", "C"][Math.floor(Math.random() * 3)];
            const x =
              (Math.random() - 0.5) * W0 * 0.8 +
              W0 / 2 +
              (cls === "A" ? -80 : cls === "B" ? 80 : 0);
            const y =
              (Math.random() - 0.5) * H0 * 0.8 +
              H0 / 2 +
              (cls === "C" ? 80 : cls === "B" ? -40 : 0);
            points.push({ x, y, cls });
          }
          render();
        }

        function reset() {
          points.length = 0;
          lastQuery = null;
          render();
        }

        // ---------- Rendering ----------
        function drawGrid() {
          ctx.save();
          ctx.lineWidth = 1;
          ctx.strokeStyle = "rgba(26,37,84,0.9)";
          const step = niceStep(60 / view.scale);
          const topLeft = screenToWorld(0, 0);
          const bottomRight = screenToWorld(W0, H0);
          const startX = Math.floor(topLeft.x / step) * step;
          const startY = Math.floor(topLeft.y / step) * step;

          for (let x = startX; x < bottomRight.x; x += step) {
            const s = worldToScreen(x, 0);
            ctx.beginPath();
            ctx.moveTo(s.x, 0);
            ctx.lineTo(s.x, H0);
            ctx.stroke();
          }
          for (let y = startY; y < bottomRight.y; y += step) {
            const s = worldToScreen(0, y);
            ctx.beginPath();
            ctx.moveTo(0, s.y);
            ctx.lineTo(W0, s.y);
            ctx.stroke();
          }
          ctx.restore();
        }

        function niceStep(raw) {
          const pow = Math.pow(10, Math.floor(Math.log10(raw)));
          const frac = raw / pow;
          if (frac < 1.5) return 1 * pow;
          if (frac < 3.5) return 2 * pow;
          if (frac < 7.5) return 5 * pow;
          return 10 * pow;
        }

        function drawPoints() {
          for (const p of points) {
            const s = worldToScreen(p.x, p.y);
            ctx.beginPath();
            ctx.arc(s.x, s.y, 5, 0, Math.PI * 2);
            ctx.fillStyle =
              p.cls === "A" ? colors.A : p.cls === "B" ? colors.B : colors.C;
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = 6;
            ctx.fill();
            ctx.shadowBlur = 0;
          }
        }

        function drawNeighbors(qres, qpt) {
          if (!qres || !neighborLines) return;
          ctx.save();
          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 1.25;
          qres.neighbors.forEach((n) => {
            const a = worldToScreen(qpt.x, qpt.y);
            const b = worldToScreen(n.pt.x, n.pt.y);
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          });
          ctx.restore();
        }

        function drawQuery(qpt, pred) {
          if (!qpt) return;
          const s = worldToScreen(qpt.x, qpt.y);
          const c =
            pred === "A"
              ? colors.A
              : pred === "B"
              ? colors.B
              : pred === "C"
              ? colors.C
              : "#cbd5e1";
          ctx.beginPath();
          ctx.arc(s.x, s.y, 8, 0, Math.PI * 2);
          ctx.fillStyle = "#ffffff22";
          ctx.fill();
          ctx.beginPath();
          ctx.arc(s.x, s.y, 10, 0, Math.PI * 2);
          ctx.strokeStyle = c;
          ctx.lineWidth = 3;
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(s.x, s.y, 2.2, 0, Math.PI * 2);
          ctx.fillStyle = "#e2e8f0";
          ctx.fill();
        }

        function drawDecisionGrid() {
          if (!showBoundary || points.length === 0) return;
          // Coarse grid to keep it fast:
          const step = 12; // px in screen space
          for (let sy = 0; sy < H0; sy += step) {
            for (let sx = 0; sx < W0; sx += step) {
              const w = screenToWorld(sx + step / 2, sy + step / 2);
              const res = classify(w, k);
              const c =
                res.pred === "A"
                  ? hexWithAlpha(colors.A, 40)
                  : res.pred === "B"
                  ? hexWithAlpha(colors.B, 40)
                  : res.pred === "C"
                  ? hexWithAlpha(colors.C, 40)
                  : "rgba(255,255,255,0.06)";
              ctx.fillStyle = c;
              ctx.fillRect(sx, sy, step, step);
            }
          }
        }

        function hexWithAlpha(hex, alpha /*0-100*/) {
          // Accept rgb(a) or hex
          if (/^#/.test(hex)) {
            const v = hex.slice(1);
            const bigint = parseInt(
              v.length === 3
                ? v
                    .split("")
                    .map((ch) => ch + ch)
                    .join("")
                : v,
              16
            );
            const r = (bigint >> 16) & 255,
              g = (bigint >> 8) & 255,
              b = bigint & 255;
            return `rgba(${r},${g},${b},${(alpha / 100).toFixed(2)})`;
          }
          return hex; // assume rgba already
        }

        function render() {
          ctx.clearRect(0, 0, W0, H0);
          drawDecisionGrid();
          drawGrid();
          drawPoints();
          if (lastQuery) {
            drawNeighbors(lastQuery.res, lastQuery.q);
            drawQuery(lastQuery.q, lastQuery.res.pred);
          }
          readout.textContent =
            `k=${k} â€¢ Train: ${points.length}` +
            (lastQuery
              ? ` â€¢ Pred: ${lastQuery.res.pred ?? "â€”"}`
              : " â€¢ Click to classify");
        }

        // ---------- Events ----------
        kRange.addEventListener("input", () => {
          k = +kRange.value;
          kOut.textContent = k;
          if (lastQuery) {
            lastQuery.res = classify(lastQuery.q, k);
          }
          render();
        });

        addButtons.forEach((btn) => {
          btn.addEventListener("click", () => {
            currentClass = btn.dataset.add;
            mode = "add";
            updateModePills();
          });
        });

        addNoiseBtn.addEventListener("click", () => {
          addRandom(30);
        });
        resetBtn.addEventListener("click", reset);
        lineToggleBtn.addEventListener("click", () => {
          neighborLines = !neighborLines;
          render();
        });
        boundaryBtn.addEventListener("click", () => {
          showBoundary = !showBoundary;
          render();
        });
        modeAddBtn.addEventListener("click", () => {
          mode = "add";
          updateModePills();
        });
        modeQueryBtn.addEventListener("click", () => {
          mode = "query";
          updateModePills();
        });

        function updateModePills() {
          [modeAddBtn, modeQueryBtn].forEach((b) =>
            b.classList.remove("ghost")
          );
          if (mode === "add") modeQueryBtn.classList.add("ghost");
          if (mode === "query") modeAddBtn.classList.add("ghost");
        }
        updateModePills();

        // Canvas interactions: click to add/query, pan/zoom
        canvas.addEventListener("mousedown", (e) => {
          if (e.button === 1 || e.button === 2 || e.shiftKey) {
            isPanning = true;
            panStart = { x: e.clientX, y: e.clientY, vx: view.x, vy: view.y };
            return;
          }
        });
        window.addEventListener("mousemove", (e) => {
          if (!isPanning) return;
          const dx = (e.clientX - panStart.x) / view.scale;
          const dy = (e.clientY - panStart.y) / view.scale;
          view.x = panStart.vx - dx;
          view.y = panStart.vy - dy;
          render();
        });
        window.addEventListener("mouseup", () => {
          isPanning = false;
        });

        canvas.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const scaleFactor = Math.exp(-e.deltaY * 0.0015);
            const mouse = screenToWorld(e.offsetX, e.offsetY);
            const oldScale = view.scale;
            view.scale = Math.min(6, Math.max(0.25, view.scale * scaleFactor));
            // keep mouse anchored
            const after = worldToScreen(mouse.x, mouse.y);
            const dx = e.offsetX - after.x;
            const dy = e.offsetY - after.y;
            view.x -= dx / view.scale;
            view.y -= dy / view.scale;
            render();
          },
          { passive: false }
        );

        canvas.addEventListener("dblclick", (e) => {
          const w = screenToWorld(e.offsetX, e.offsetY);
          view.x = w.x;
          view.y = w.y;
          render();
        });

        canvas.addEventListener("click", (e) => {
          if (isPanning) return;
          const w = screenToWorld(e.offsetX, e.offsetY);
          if (mode === "add") {
            points.push({ x: w.x, y: w.y, cls: currentClass });
            render();
          } else {
            const res = classify(w, k);
            lastQuery = { q: w, res };
            render();
          }
        });

        window.addEventListener("keydown", (e) => {
          if (e.key === "a" || e.key === "A") {
            currentClass = "A";
            mode = "add";
            updateModePills();
          }
          if (e.key === "b" || e.key === "B") {
            currentClass = "B";
            mode = "add";
            updateModePills();
          }
          if (e.key === "c" || e.key === "C") {
            currentClass = "C";
            mode = "add";
            updateModePills();
          }
          if (e.key === "q" || e.key === "Q") {
            mode = "query";
            updateModePills();
          }
          if (e.key === "r" || e.key === "R") {
            reset();
          }
          if (e.key === "l" || e.key === "L") {
            neighborLines = !neighborLines;
            render();
          }
          if (e.key === "g" || e.key === "G") {
            showBoundary = !showBoundary;
            render();
          }
          if (e.key === "[") {
            k = Math.max(1, k - 1);
            kRange.value = k;
            kOut.textContent = k;
            if (lastQuery) {
              lastQuery.res = classify(lastQuery.q, k);
            }
            render();
          }
          if (e.key === "]") {
            k = Math.min(99, k + 1);
            kRange.value = k;
            kOut.textContent = k;
            if (lastQuery) {
              lastQuery.res = classify(lastQuery.q, k);
            }
            render();
          }
        });

        // ---------- Seed some points for a nice start ----------
        function seed() {
          const clusters = [
            { x: W0 * 0.35, y: H0 * 0.45, r: 90, n: 24, cls: "A" },
            { x: W0 * 0.62, y: H0 * 0.4, r: 90, n: 24, cls: "B" },
            { x: W0 * 0.5, y: H0 * 0.68, r: 90, n: 22, cls: "C" },
          ];
          clusters.forEach((c) => {
            for (let i = 0; i < c.n; i++) {
              const ang = Math.random() * Math.PI * 2;
              const rad = Math.random() ** 0.5 * c.r;
              points.push({
                x: c.x + Math.cos(ang) * rad,
                y: c.y + Math.sin(ang) * rad,
                cls: c.cls,
              });
            }
          });
        }
        seed();
        render();
      })();
    </script>
  </body>
</html>
