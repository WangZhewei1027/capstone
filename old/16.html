<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Singly Linked List — Interactive Visualizer (Web Components)</title>
<style>
  :root{
    --bg: #0f1220;
    --panel:#161a2f;
    --muted:#8b93b3;
    --text:#e9edff;
    --accent:#7aa2ff;
    --accent-2:#ffd166;
    --danger:#ff5d73;
    --ok:#2ecc71;
    --node:#22284a;
    --node-active:#2f3769;
    --border:#2a315b;
    --shadow: 0 8px 24px rgba(0,0,0,.25);
    --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    --radius: 12px;
    --gap: 12px;
  }
  body.theme-light{
    --bg: #f7f8ff;
    --panel:#ffffff;
    --muted:#5b6487;
    --text:#101226;
    --accent:#3758ff;
    --accent-2:#b46d00;
    --danger:#c62828;
    --ok:#1b7a38;
    --node:#f0f3ff;
    --node-active:#e3e8ff;
    --border:#d7defa;
    --shadow: 0 8px 24px rgba(32, 48, 120, .15);
  }
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--text); font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    display:grid; place-items:stretch;
  }
  main{
    display:grid; gap:var(--gap);
    grid-template-columns: 1.2fr .8fr;
    grid-template-rows: auto 1fr;
    padding: clamp(12px, 2vw, 24px);
    max-width: 1200px; margin-inline:auto; width:100%;
  }
  ll-controls{ grid-column: 1 / -1;}
  ll-visualizer{ min-height: 320px;}
  ll-inspector{ min-height: 320px;}
  @media (max-width: 900px){
    main{ grid-template-columns: 1fr; grid-template-rows: auto auto auto; }
  }
  /* Generic utility */
  .panel{ background:var(--panel); border:1px solid var(--border); border-radius:var(--radius); box-shadow:var(--shadow);}
  button, input, select{
    font: inherit; color:var(--text); background:transparent; border:1px solid var(--border);
    border-radius:10px; padding:.55rem .75rem; transition: transform .05s ease;
  }
  button{ background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.04)); cursor:pointer}
  button:hover{ transform: translateY(-1px) }
  button:active{ transform: translateY(0) scale(.98) }
  button.primary{ background: var(--accent); color:white; border-color: transparent; }
  button.ghost{ border-style:dashed; }
  button.danger{ background: var(--danger); color:#fff; border-color:transparent;}
  .toolbar{ display:flex; flex-wrap:wrap; gap:var(--gap); align-items:center}
  .toolbar .group{ display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap}
  .sep{ width:1px; align-self:stretch; background:var(--border) }
  .kbd{ font-family:var(--mono); font-size:.85em; border:1px solid var(--border); padding:.1em .4em; border-radius:6px; background:var(--panel); }
  .hint{ color:var(--muted); font-size:.9em}
  .sr-only{ position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;}
  .pill{ font: 12px/1 var(--mono); color:var(--text); background:var(--node-active); padding:6px 8px; border-radius:999px; border:1px solid var(--border)}
</style>
</head>
<body>
<main>
  <ll-controls class="panel" aria-label="Linked List Controls"></ll-controls>
  <ll-visualizer class="panel" aria-label="Linked List Visualizer"></ll-visualizer>
  <ll-inspector class="panel" aria-label="Inspector and Pseudocode"></ll-inspector>
</main>
<script>
/* ============================
   Data Model: Pure LinkedList
   ============================ */
class ListNode{
  constructor(value, next=null){
    this.value = value;
    this.next = next;
  }
}
class LinkedList{
  constructor(){ this.head=null; this._size=0; }
  get size(){ return this._size; }
  get tail(){
    let n=this.head; if(!n) return null;
    while(n.next) n=n.next; return n;
  }
  toArray(){
    const arr = []; let n=this.head; let guard=0;
    while(n){ arr.push(n.value); n=n.next; guard++; if(guard>10000) throw new Error("Cycle detected while toArray"); }
    return arr;
  }
  static fromArray(arr){
    const ll = new LinkedList(); for(const v of arr) ll.push(v); return ll;
  }
  clone(){ return LinkedList.fromArray(this.toArray()); }
  hasCycle(){
    let slow=this.head, fast=this.head;
    while(fast && fast.next){ slow=slow.next; fast=fast.next.next; if(slow===fast) return true; }
    return false;
  }
  _bounds(i){ if(i<0||i>=this._size) throw new Error("Index out of bounds"); }
  push(value){
    const node = new ListNode(value);
    if(!this.head){ this.head=node; }
    else{ this.tail.next = node; }
    this._size++;
  }
  unshift(value){
    this.head = new ListNode(value, this.head);
    this._size++;
  }
  insertAt(index, value){
    if(index<0||index>this._size) throw new Error("Index out of bounds");
    if(index===0){ this.unshift(value); return; }
    let prev = this.head;
    for(let i=0;i<index-1;i++) prev=prev.next;
    prev.next = new ListNode(value, prev.next);
    this._size++;
  }
  removeAt(index){
    this._bounds(index);
    if(index===0){ const v=this.head.value; this.head=this.head.next; this._size--; return v; }
    let prev=this.head; for(let i=0;i<index-1;i++) prev=prev.next;
    const v = prev.next.value; prev.next = prev.next.next; this._size--; return v;
  }
  deleteValue(value){
    let prev=null, cur=this.head, idx=0;
    while(cur){
      if(cur.value==value){
        if(prev) prev.next = cur.next; else this.head = cur.next; this._size--;
        return idx;
      }
      prev=cur; cur=cur.next; idx++;
    }
    return -1;
  }
  search(value){
    let i=0; let n=this.head;
    while(n){ if(n.value==value) return i; n=n.next; i++; }
    return -1;
  }
  reverse(){
    let prev=null, cur=this.head;
    while(cur){ const nxt=cur.next; cur.next=prev; prev=cur; cur=nxt; }
    this.head=prev;
  }
  clear(){ this.head=null; this._size=0; }
  /* Invariants: size, tail null, no cycles */
  validate(){
    // size
    let count=0; let n=this.head; let guard=0;
    while(n){ count++; if(n.next===undefined) throw new Error("Broken pointer"); n=n.next; guard++; if(guard>10000) throw new Error("Cycle suspected"); }
    if(count!==this._size) throw new Error(`Size mismatch: ${count} vs ${this._size}`);
    // tail null
    if(this._size>0 && this.tail && this.tail.next!==null) throw new Error("Tail.next must be null");
    // no cycles
    if(this.hasCycle()) throw new Error("Cycle detected");
    return true;
  }
}

/* ============================
   Tiny Event Bus for components
   ============================ */
const Bus = new EventTarget();
const preferReduced = window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches ?? false;

/* ============================
   State History (Undo/Redo)
   ============================ */
const History = {
  states: [ [] ], // array snapshots
  ptr: 0,
  current(){ return this.states[this.ptr]; },
  push(state){
    // truncate redo trail
    this.states = this.states.slice(0, this.ptr+1);
    this.states.push(structuredClone(state));
    this.ptr++;
    Bus.dispatchEvent(new CustomEvent('history-changed', {detail:{ptr:this.ptr, len:this.states.length}}))
  },
  canUndo(){ return this.ptr>0; },
  canRedo(){ return this.ptr < this.states.length-1; },
  undo(){ if(!this.canUndo()) return this.current(); this.ptr--; Bus.dispatchEvent(new CustomEvent('history-changed', {detail:{ptr:this.ptr, len:this.states.length}})); return this.current(); },
  redo(){ if(!this.canRedo()) return this.current(); this.ptr++; Bus.dispatchEvent(new CustomEvent('history-changed', {detail:{ptr:this.ptr, len:this.states.length}})); return this.current(); },
  replace(state){ this.states[this.ptr]=structuredClone(state); Bus.dispatchEvent(new CustomEvent('history-changed', {detail:{ptr:this.ptr, len:this.states.length}})); }
};

/* ============================
   Algorithm Step Engine
   ============================ */
class StepRunner extends EventTarget{
  constructor(steps=[], speed=400){ super(); this.steps=steps; this.i=0; this.timer=null; this.speed=speed; this.playing=false; }
  setSteps(steps){ this.stop(); this.steps=steps||[]; this.i=0; this.emit(); }
  setSpeed(ms){ this.speed=ms; if(this.playing){ this.stop(); this.play(); } }
  play(){ if(this.playing) return; this.playing=true; const loop=()=>{ if(this.i>=this.steps.length){ this.stop(); this.dispatchEvent(new Event('finished')); return; } this.tick(); this.timer=setTimeout(loop, this.speed); }; loop(); }
  pause(){ this.playing=false; if(this.timer) clearTimeout(this.timer); this.timer=null; }
  stop(){ this.pause(); this.i=0; this.emit(); }
  step(){ if(this.i>=this.steps.length){ this.dispatchEvent(new Event('finished')); return; } this.tick(); }
  reset(){ this.stop(); this.emit(); }
  tick(){ const step = this.steps[this.i]; this.emit(); if(step?.apply) step.apply(); this.i++; this.emit(); this.dispatchEvent(new CustomEvent('step', {detail:{index:this.i, step}})); if(this.i>=this.steps.length) this.dispatchEvent(new Event('finished')); }
  emit(){ this.dispatchEvent(new CustomEvent('progress', {detail:{i:this.i, total:this.steps.length, step:this.steps[this.i]||null}})); }
}

/* ============================
   ll-visualizer
   ============================ */
customElements.define('ll-visualizer', class extends HTMLElement{
  constructor(){
    super(); this.attachShadow({mode:'open'});
    this.state = { arr: History.current(), highlight: -1, message:'', foundIndex:-1 };
    this.speed = preferReduced ? 0 : 400;
    this.runner = new StepRunner([], this.speed);
    this.runner.addEventListener('progress', e=> this.updateProgress(e.detail));
    this.runner.addEventListener('step', e=> this.announce(e.detail.step?.desc||''));
    this.runner.addEventListener('finished', ()=> { this.announce('Animation finished'); Bus.dispatchEvent(new CustomEvent('viz-finished')); });
    Bus.addEventListener('request-animate', e=> this.animateOperation(e.detail));
    Bus.addEventListener('history-changed', ()=> this.setArray(History.current()));
    Bus.addEventListener('set-speed', e=> this.setSpeed(e.detail.ms));
    Bus.addEventListener('controls', e=>{
      const {action}=e.detail;
      if(action==='play') this.play();
      if(action==='pause') this.pause();
      if(action==='step') this.step();
      if(action==='reset') this.reset();
    });
  }
  connectedCallback(){ this.render(); }
  setArray(arr){ this.state.arr = [...arr]; this.render(); }
  setSpeed(ms){ this.speed = preferReduced ? 0 : ms; this.runner.setSpeed(this.speed||0); }
  announce(msg){ const live = this.shadowRoot.getElementById('live'); if(live){ live.textContent = msg; } Bus.dispatchEvent(new CustomEvent('log', {detail: msg})); }
  play(){ this.runner.play(); }
  pause(){ this.runner.pause(); }
  step(){ this.runner.step(); }
  reset(){ this.runner.reset(); this.render(); }

  /* Core: build steps for each operation on a copy of array state */
  buildSteps(op){
    const arr0 = [...this.state.arr];
    const steps = [];
    const pushStep = (desc, pseudo, hi=-1, apply=()=>{}) => steps.push({desc, pseudo, hi, apply});
    const markTrav = (i)=> pushStep(`Visit node ${i}`, 3, i);

    const addTrailingNull = (arr)=>{}; // purely cosmetic

    const ops = {
      push: ({value})=>{
        if(arr0.length===0){
          pushStep('List empty: new node becomes head/tail', 1, -1, ()=>{});
          pushStep(`Attach value ${value}`, 4, -1, ()=>{});
        }else{
          for(let i=0;i<arr0.length;i++) markTrav(i);
          pushStep(`Append ${value} after tail`, 5, arr0.length-1, ()=>{});
        }
        pushStep('Commit: update data model', 6, -1, ()=>{
          const ll = LinkedList.fromArray(History.current());
          ll.push(value);
          ll.validate();
          History.push(ll.toArray());
        });
      },
      unshift: ({value})=>{
        pushStep('Create new head node', 1, -1);
        if(arr0.length>0) pushStep('Point new head.next to old head', 2, 0);
        pushStep('Commit', 6, -1, ()=>{
          const ll=LinkedList.fromArray(History.current()); ll.unshift(value); ll.validate(); History.push(ll.toArray());
        });
      },
      insertAt: ({index, value})=>{
        if(index<0||index>arr0.length) { pushStep('Error: index out of bounds', 0,-1); return; }
        if(index===0){ ops.unshift({value}); return; }
        for(let i=0;i<index-1;i++) markTrav(i);
        pushStep(`At index ${index-1}, rewire next`, 4, index-1);
        pushStep('Commit', 6, -1, ()=>{
          const ll=LinkedList.fromArray(History.current()); ll.insertAt(index,value); ll.validate(); History.push(ll.toArray());
        });
      },
      removeAt: ({index})=>{
        if(index<0||index>=arr0.length){ pushStep('Error: index out of bounds', 0); return; }
        if(index===0){
          pushStep('Remove head: head = head.next', 2, 0);
        }else{
          for(let i=0;i<index-1;i++) markTrav(i);
          pushStep(`Bypass node ${index}`, 4, index);
        }
        pushStep('Commit', 6, -1, ()=>{
          const ll=LinkedList.fromArray(History.current()); ll.removeAt(index); ll.validate(); History.push(ll.toArray());
        });
      },
      deleteValue: ({value})=>{
        if(arr0.length===0){ pushStep('Empty list, nothing to delete', 0); return; }
        let found=-1;
        for(let i=0;i<arr0.length;i++){
          markTrav(i);
          if(arr0[i]==value){ found=i; pushStep(`Match at index ${i}`, 3, i); break; }
        }
        if(found===-1){ pushStep('Value not found', 7); }
        else{
          if(found===0) pushStep('Delete head', 2, 0);
          else pushStep(`Bypass node ${found}`, 4, found);
          pushStep('Commit', 6, -1, ()=>{
            const ll=LinkedList.fromArray(History.current()); ll.deleteValue(value); ll.validate(); History.push(ll.toArray());
          });
        }
      },
      search: ({value})=>{
        let found=-1;
        for(let i=0;i<arr0.length;i++){ markTrav(i); if(arr0[i]==value){ found=i; pushStep(`Found at index ${i}`, 3, i); break; } }
        if(found===-1) pushStep('Not found (return -1)', 7, -1);
        pushStep('Commit (no data change)', 6, -1, ()=>{
          // no change; still validate
          const ll=LinkedList.fromArray(History.current()); ll.validate(); History.replace(ll.toArray());
          Bus.dispatchEvent(new CustomEvent('search-result', {detail:{index: found}}));
        });
      },
      reverse: ()=>{
        for(let i=0;i<arr0.length;i++) pushStep(`Reverse link at node ${i}`, 4, i);
        pushStep('Commit', 6, -1, ()=>{
          const ll=LinkedList.fromArray(History.current()); ll.reverse(); ll.validate(); History.push(ll.toArray());
        });
      },
      clear: ()=>{
        pushStep('Set head = null', 2);
        pushStep('Set size = 0', 6);
        pushStep('Commit', 6, -1, ()=>{
          const ll=LinkedList.fromArray(History.current()); ll.clear(); ll.validate(); History.push(ll.toArray());
        });
      }
    };
    return ops;
  }

  animateOperation(detail){
    const {op, args} = detail;
    const ops = this.buildSteps(op);
    // Special case: reuse unshift in insertAt if index===0
    if(op==='insertAt' && args.index===0){ return this.animateOperation({op:'unshift', args:{value: args.value}}); }
    const builder = ops[op];
    if(!builder){ console.warn('Unknown op', op); return; }
    const steps = []; // collect via builder
    const pushStep = (s)=> steps.push(s);
    // Proxy pushStep by temporarily overriding in closure
    const built = builder(args);
    // builder already emitted using internal pushStep in buildSteps
    this.runner.setSteps(this._pendingSteps = this.runner.steps.length ? this.runner.steps : ops[op].steps || steps);
    // But our buildSteps pushes inside local function; to simplify, rebuild quickly by calling ops again capturing steps:
    const arr0=[...this.state.arr]; const localSteps=[];
    const hook = (desc, pseudo, hi=-1, apply=()=>{})=> localSteps.push({desc, pseudo, hi, apply});
    // Rebuild exact:
    const b2 = this._createBuilder(arr0, hook);
    b2[op](args||{});
    this.runner.setSteps(localSteps);
    Bus.dispatchEvent(new CustomEvent('pseudo', {detail:{op, total: localSteps.length}}));
    this.play(); // auto play on request
  }

  _createBuilder(arr0, pushStep){
    const markTrav = (i)=> pushStep(`Visit node ${i}`, 3, i);
    return {
      push: ({value})=>{
        if(arr0.length===0){
          pushStep('List empty: new node becomes head/tail', 1);
          pushStep(`Attach value ${value}`, 4);
        }else{
          for(let i=0;i<arr0.length;i++) markTrav(i);
          pushStep(`Append ${value} after tail`, 5, arr0.length-1);
        }
        pushStep('Commit: update data model', 6, -1, ()=>{
          const ll = LinkedList.fromArray(History.current()); ll.push(value); ll.validate(); History.push(ll.toArray());
        });
      },
      unshift: ({value})=>{
        pushStep('Create new head node', 1);
        if(arr0.length>0) pushStep('Point new head.next to old head', 2, 0);
        pushStep('Commit', 6, -1, ()=>{
          const ll=LinkedList.fromArray(History.current()); ll.unshift(value); ll.validate(); History.push(ll.toArray());
        });
      },
      insertAt: ({index, value})=>{
        if(index<0||index>arr0.length){ pushStep('Error: index out of bounds', 0); return; }
        if(index===0){ return this.unshift({value}); }
        for(let i=0;i<index-1;i++) markTrav(i);
        pushStep(`At index ${index-1}, rewire next`, 4, index-1);
        pushStep('Commit', 6, -1, ()=>{
          const ll=LinkedList.fromArray(History.current()); ll.insertAt(index,value); ll.validate(); History.push(ll.toArray());
        });
      },
      removeAt: ({index})=>{
        if(index<0||index>=arr0.length){ pushStep('Error: index out of bounds', 0); return; }
        if(index===0){ pushStep('Remove head: head = head.next', 2, 0); }
        else{ for(let i=0;i<index-1;i++) markTrav(i); pushStep(`Bypass node ${index}`, 4, index); }
        pushStep('Commit', 6, -1, ()=>{
          const ll=LinkedList.fromArray(History.current()); ll.removeAt(index); ll.validate(); History.push(ll.toArray());
        });
      },
      deleteValue: ({value})=>{
        if(arr0.length===0){ pushStep('Empty list, nothing to delete', 0); return; }
        let found=-1;
        for(let i=0;i<arr0.length;i++){ markTrav(i); if(arr0[i]==value){ found=i; pushStep(`Match at index ${i}`, 3, i); break; } }
        if(found===-1){ pushStep('Value not found', 7); }
        else{
          if(found===0) pushStep('Delete head', 2, 0); else pushStep(`Bypass node ${found}`, 4, found);
          pushStep('Commit', 6, -1, ()=>{
            const ll=LinkedList.fromArray(History.current()); ll.deleteValue(value); ll.validate(); History.push(ll.toArray());
          });
        }
      },
      search: ({value})=>{
        let found=-1;
        for(let i=0;i<arr0.length;i++){ markTrav(i); if(arr0[i]==value){ found=i; pushStep(`Found at index ${i}`, 3, i); break; } }
        if(found===-1) pushStep('Not found (return -1)', 7);
        pushStep('Commit (no data change)', 6, -1, ()=>{
          const ll=LinkedList.fromArray(History.current()); ll.validate(); History.replace(ll.toArray());
          Bus.dispatchEvent(new CustomEvent('search-result', {detail:{index: found}}));
        });
      },
      reverse: ()=>{
        for(let i=0;i<arr0.length;i++) pushStep(`Reverse link at node ${i}`, 4, i);
        pushStep('Commit', 6, -1, ()=>{
          const ll=LinkedList.fromArray(History.current()); ll.reverse(); ll.validate(); History.push(ll.toArray());
        });
      },
      clear: ()=>{
        pushStep('Set head = null', 2);
        pushStep('Set size = 0', 6);
        pushStep('Commit', 6, -1, ()=>{
          const ll=LinkedList.fromArray(History.current()); ll.clear(); ll.validate(); History.push(ll.toArray());
        });
      }
    }
  }

  updateProgress({i,total,step}){
    this.state.highlight = step?.hi ?? -1;
    this.render(i, total, step);
    Bus.dispatchEvent(new CustomEvent('pseudo-step', {detail:{i,total,step}}));
  }

  render(i=0, total=0, step=null){
    const arr = History.current();
    const headIdx = 0;
    const tailIdx = arr.length ? arr.length-1 : -1;
    const size = arr.length;
    this.shadowRoot.innerHTML = `
      <style>
        .wrap{ padding:16px; display:grid; gap:12px;}
        .top{ display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;}
        .bad{ color:var(--danger); } .ok{ color:var(--ok) }
        svg{ width:100%; height:220px; display:block; background:linear-gradient(180deg, transparent, rgba(0,0,0,.03)); border:1px dashed var(--border); border-radius:12px;}
        .meta{ display:flex; gap:12px; flex-wrap:wrap; align-items:center}
        .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
        .legend{ display:flex; gap:8px; align-items:center; color:var(--muted); font-size:.9em}
        .legend span{ display:inline-flex; align-items:center; gap:6px}
        .dot{ width:12px; height:12px; border-radius:50%; background:var(--accent);}
        .hl{ background:var(--node-active); padding:4px 6px; border-radius:8px; border:1px solid var(--border); }
      </style>
        <div class="wrap">
    <div class="top">
      <div class="meta">
        <span class="pill">head: ${arr.length?0:'null'}</span>
        <span class="pill">tail: ${arr.length?tailIdx:'null'}</span>
        <span class="pill">size: ${size}</span>
        <span class="pill">step: ${Math.min(i,total)} / ${total}</span>
      </div>
      <div class="controls" role="group" aria-label="Animation transport">
        <button id="play" class="primary" title="Play (P)"><span aria-hidden="true">▶</span> Play</button>
        <button id="pause" title="Pause"><span aria-hidden="true">⏸</span> Pause</button>
        <button id="step" title="Step (.)"><span aria-hidden="true">⏭</span> Step</button>
        <button id="reset" class="ghost" title="Reset (R)"><span aria-hidden="true">⟲</span> Reset</button>
      </div>
    </div>
    <svg viewBox="0 0 900 220" role="img" aria-label="Linked list diagram">
      <defs>
        <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L10,3 L0,6 z" fill="currentColor"></path>
        </marker>
      </defs>
      ${this.drawNodes(arr, this.state.highlight)}
    </svg>
    <div class="legend">
      <span><span class="dot"></span> traversal highlight</span>
      <span class="hl">${step?.desc || 'Ready'}</span>
    </div>
    <div id="live" class="sr-only" aria-live="polite"></div>
  </div>
`;
this.shadowRoot.getElementById('play').onclick = ()=> this.play();
this.shadowRoot.getElementById('pause').onclick = ()=> this.pause();
this.shadowRoot.getElementById('step').onclick = ()=> this.step();
this.shadowRoot.getElementById('reset').onclick = ()=> this.reset();
}

drawNodes(arr, hi){
const spacing = 120;
const startX = 40;
const y = 80;
const items = arr.map((v,i)=>{
const x = startX + i*spacing;
const active = i===hi ? ‘stroke=“var(–accent)” stroke-width=“2”’ : ‘stroke=“var(–border)”’;
return <g transform="translate(${x},${y})"> <rect width="86" height="46" rx="10" fill="var(--node)" ${active}></rect> <text x="43" y="28" text-anchor="middle" font-family="var(--mono)" font-size="14" fill="var(--text)">${String(v)}</text> </g> ${ i < arr.length-1 ?:null};
}).join(’’);
if(arr.length===0){
return <text x="40" y="${y+5}" font-family="var(--mono)" font-size="14" fill="var(--muted)">head → null</text>;
}
return items;
}
});

/* ============================
ll-inspector
============================ */
customElements.define(‘ll-inspector’, class extends HTMLElement{
constructor(){
super(); this.attachShadow({mode:‘open’});
this.lines = [
“function op(…){”,
“  // create / prepare node”,
“  // adjust head or pointers”,
“  // traverse: move current = current.next”,
“  // rewire pointers”,
“  // finalize tail / pointers”,
“  // commit updates”,
“  // return if not found”,
“}”
];
this.currentLine = -1;
this.complexity = {
push: “O(n) time, O(1) space”,
unshift: “O(1) time, O(1) space”,
insertAt: “O(n) time, O(1) space”,
removeAt: “O(n) time, O(1) space”,
deleteValue: “O(n) time, O(1) space”,
search: “O(n) time, O(1) space”,
reverse: “O(n) time, O(1) space”,
clear: “O(1) time, O(1) space”
};
Bus.addEventListener(‘pseudo’, e=> this.setOp(e.detail.op));
Bus.addEventListener(‘pseudo-step’, e=> this.highlight(e.detail.step?.pseudo ?? -1));
Bus.addEventListener(‘log’, e=> this.addLog(e.detail));
}
connectedCallback(){ this.render(); }
setOp(op){ this.op = op; this.render(); }
highlight(i){ this.currentLine = i; const ul=this.shadowRoot.querySelector(‘ol’); if(!ul) return; […ul.children].forEach((li,idx)=> li.classList.toggle(‘hl’, idx===i)); this.updateComplexity(); }
updateComplexity(){
const c = this.complexity[this.op] || “—”;
const el = this.shadowRoot.getElementById(‘complex’);
if(el) el.textContent = Complexity: ${c};
}
addLog(msg){
const log = this.shadowRoot.getElementById(‘loglist’);
const li = document.createElement(‘li’); li.textContent = msg; log.appendChild(li); log.scrollTop = log.scrollHeight;
}
render(){
this.shadowRoot.innerHTML = <style> .wrap{ padding:16px; display:grid; gap:12px; grid-template-rows:auto 1fr auto } h3{ margin:0 0 8px 0; font-weight:700 } ol{ margin:0; padding:0 0 0 24px; list-style: decimal; display:grid; gap:4px; } li{ padding:6px 8px; border-radius:8px; border:1px solid transparent; } li.hl{ background:var(--node-active); border-color:var(--border); } .foot{ display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; } .log{ border:1px solid var(--border); border-radius:10px; padding:8px; height:140px; overflow:auto; background:var(--node); } .log ul{ margin:0; padding-left:18px; } .sr{ font:12px/1 var(--mono); color:var(--muted) } </style> <div class="wrap"> <div> <h3>Pseudo-code</h3> <div class="sr" id="complex">Complexity: —</div> <ol aria-label="Pseudo-code lines"> ${this.lines.map((ln,i)=><li aria-live=“off” ${i===this.currentLine?‘class=“hl”’:’’}>${ln}).join('')} </ol> </div> <div> <h3 class="sr-only">Live Log</h3> <div class="log" role="log" aria-live="polite" aria-atomic="false"><ul id="loglist"></ul></div> </div> <div class="foot"> <div class="hint">Keyboard: <span class="kbd">P</span> Play · <span class="kbd">.</span> Step · <span class="kbd">R</span> Reset · <span class="kbd">Z</span> Undo · <span class="kbd">Y</span> Redo</div> <button id="runtests" class="ghost">Run tests</button> </div> </div> ;
this.shadowRoot.getElementById(‘runtests’).onclick = ()=> runTests();
}
});

/* ============================
ll-controls
============================ */
customElements.define(‘ll-controls’, class extends HTMLElement{
constructor(){
super(); this.attachShadow({mode:‘open’});
this.speed = preferReduced ? 0 : 400;
this.theme = localStorage.getItem(‘ll-theme’) || ‘dark’;
document.body.classList.toggle(‘theme-light’, this.theme===‘light’);
Bus.addEventListener(‘history-changed’, e=> this.updateUndoRedo());
}
connectedCallback(){ this.render(); this.updateUndoRedo(); this.bindKeys(); }
updateUndoRedo(){
const root = this.shadowRoot;
root?.getElementById(‘undo’)?.toggleAttribute(‘disabled’, !History.canUndo());
root?.getElementById(‘redo’)?.toggleAttribute(‘disabled’, !History.canRedo());
}
bindKeys(){
window.addEventListener(‘keydown’, (e)=>{
if(e.target && [‘INPUT’,‘TEXTAREA’].includes(e.target.tagName)) return;
if(e.key.toLowerCase()===‘p’){ Bus.dispatchEvent(new CustomEvent(‘controls’,{detail:{action:‘play’}})); }
if(e.key===’.’ ){ Bus.dispatchEvent(new CustomEvent(‘controls’,{detail:{action:‘step’}})); }
if(e.key.toLowerCase()===‘r’){ Bus.dispatchEvent(new CustomEvent(‘controls’,{detail:{action:‘reset’}})); }
if(e.key.toLowerCase()===‘z’){ this.undo(); }
if(e.key.toLowerCase()===‘y’){ this.redo(); }
});
}
themeToggle(){
this.theme = this.theme===‘dark’ ? ‘light’ : ‘dark’;
document.body.classList.toggle(‘theme-light’, this.theme===‘light’);
localStorage.setItem(‘ll-theme’, this.theme);
}
randomize(){
const n = 3 + Math.floor(Math.random()*5);
const arr = Array.from({length:n}, ()=> Math.floor(Math.random()*90)+10);
const ll = LinkedList.fromArray(arr); ll.validate();
History.push(ll.toArray());
}
undo(){ const arr = History.undo(); Bus.dispatchEvent(new CustomEvent(‘history-changed’)); }
redo(){ const arr = History.redo(); Bus.dispatchEvent(new CustomEvent(‘history-changed’)); }
request(op, args){
Bus.dispatchEvent(new CustomEvent(‘request-animate’, {detail:{op, args}}));
}
setSpeed(ms){
this.speed = preferReduced ? 0 : ms;
Bus.dispatchEvent(new CustomEvent(‘set-speed’, {detail:{ms:this.speed}}));
}
render(){
this.shadowRoot.innerHTML = <style> .wrap{ padding:16px; display:grid; gap:12px; } .grid{ display:grid; gap:12px; grid-template-columns: 1fr 1fr 1fr; } @media (max-width: 900px){ .grid{ grid-template-columns: 1fr; } } .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:end; } label{ display:grid; gap:6px; font-weight:600; color:var(--muted) } input[type="number"], input[type="text"]{ min-width: 120px; background:var(--node); } input[type="range"]{ width: 180px; } .right{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:flex-end } </style> <div class="wrap"> <div class="toolbar"> <div class="group"> <label>Value <input id="val" type="text" aria-label="Value"></label> <label>Index <input id="idx" type="number" aria-label="Index" step="1"></label> </div> <span class="sep"></span> <div class="group" role="group" aria-label="Operations"> <button id="push">push</button> <button id="unshift">unshift</button> <button id="insertAt">insertAt</button> <button id="removeAt">removeAt</button> <button id="deleteValue">deleteValue</button> <button id="search">search</button> <button id="reverse">reverse</button> <button id="clear" class="danger">clear</button> </div> <span class="sep"></span> <div class="group"> <label>Speed <input id="speed" type="range" min="0" max="1000" step="50" value="${this.speed}"></label> <button id="undo" title="Undo (Z)">Undo</button> <button id="redo" title="Redo (Y)">Redo</button> <button id="random">Randomize</button> <button id="theme">Theme</button> </div> </div> <div class="hint">All operations are animated. Use keyboard shortcuts for transport and history. Reduce Motion setting respected.</div> </div>;
const $ = (id)=> this.shadowRoot.getElementById(id);
$(‘push’).onclick = ()=> this.request(‘push’, {value: $(‘val’).value||’·’});
$(‘unshift’).onclick = ()=> this.request(‘unshift’, {value: $(‘val’).value||’·’});
$(‘insertAt’).onclick = ()=> this.request(‘insertAt’, {index: +$(‘idx’).value||0, value: $(‘val’).value||’·’});
$(‘removeAt’).onclick = ()=> this.request(‘removeAt’, {index: +$(‘idx’).value||0});
$(‘deleteValue’).onclick = ()=> this.request(‘deleteValue’, {value: $(‘val’).value});
$(‘search’).onclick = ()=> this.request(‘search’, {value: $(‘val’).value});
$(‘reverse’).onclick = ()=> this.request(‘reverse’, {});
$(‘clear’).onclick = ()=> this.request(‘clear’, {});
$(‘speed’).oninput = (e)=> this.setSpeed(+e.target.value);
$(‘undo’).onclick = ()=> this.undo();
$(‘redo’).onclick = ()=> this.redo();
$(‘random’).onclick = ()=> this.randomize();
$(‘theme’).onclick = ()=> this.themeToggle();
}
});

/* ============================
Tests
============================ */
function runTests(){
const log = (msg)=> Bus.dispatchEvent(new CustomEvent(‘log’, {detail: msg}));
const assert = (name, cond)=> log(${cond?'PASS':'FAIL'}: ${name});
try{
const ll = new LinkedList();
assert(‘Empty size=0’, ll.size===0);
ll.push(1); ll.push(2); ll.push(3);
assert(‘Push 3 items’, ll.size===3 && ll.tail.value===3);
ll.unshift(0);
assert(‘Unshift at head’, ll.head.value===0 && ll.size===4);
ll.insertAt(2, 9); // 0,1,9,2,3
assert(‘InsertAt index 2’, ll.toArray().join(’,’)===‘0,1,9,2,3’);
const removed = ll.removeAt(3); // remove 2
assert(‘RemoveAt index 3 returns 2’, removed===2 && ll.toArray().join(’,’)===‘0,1,9,3’);
const idx = ll.deleteValue(9);
assert(‘DeleteValue finds 9 at idx 2’, idx===2 && ll.toArray().join(’,’)===‘0,1,3’);
assert(‘Search 1 -> index 1’, ll.search(1)===1);
ll.reverse(); // 3,1,0
assert(‘Reverse’, ll.toArray().join(’,’)===‘3,1,0’);
ll.clear(); assert(‘Clear’, ll.size===0 && ll.head===null);
ll.validate(); assert(‘Validate OK’, true);
}catch(e){ log(’FAIL (exception): ’+e.message); }
}

/* ============================
Boot: initial state + wiring
============================ */
(function boot(){
// Respect Reduced Motion by setting speed to 0 and informing bus
if(preferReduced){
Bus.dispatchEvent(new CustomEvent(‘set-speed’, {detail:{ms:0}}));
}
// Initialize empty history state
History.states = [ [] ]; History.ptr=0;
Bus.dispatchEvent(new CustomEvent(‘history-changed’, {detail:{ptr:0, len:1}}));

// Global announce on finish to validate invariants again (safety net)
Bus.addEventListener(‘viz-finished’, ()=>{
try{
const ll = LinkedList.fromArray(History.current());
ll.validate();
}catch(e){
Bus.dispatchEvent(new CustomEvent(‘log’, {detail:’Invariant error: ’+e.message}));
alert(’Invariant error: ’+e.message);
}
});

// Provide helpful default content
const seed = [10, 20, 30];
const ll = LinkedList.fromArray(seed);
History.replace(ll.toArray());

// Keyboard transport already handled inside controls
})();
</body>
</html>
