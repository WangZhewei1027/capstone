<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Interactive Gradient Descent — Step-by-Step with Web Components
    </title>
    <style>
      :root {
        --bg: #0f1220;
        --panel: #171a2b;
        --ink: #e9ecff;
        --muted: #a9b0d3;
        --accent: #7aa2ff;
        --accent2: #5ee6b8;
        --hot: #ff7a99;
        --warn: #ffde7a;
        --ok: #a0ff7a;
        --grid: #22263e;
        --chip: #1f2340;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: var(--bg);
        color: var(--ink);
        font: 16px/1.45 system-ui, Segoe UI, Roboto, Ubuntu, Helvetica, Arial;
      }
      h1,
      h2,
      h3 {
        margin: 0.2rem 0 0.6rem;
      }
      h1 {
        font-size: clamp(1.2rem, 2.5vw, 1.8rem);
        font-weight: 800;
        letter-spacing: 0.2px;
      }
      h2 {
        font-size: 1.05rem;
        color: var(--muted);
        font-weight: 700;
      }
      p {
        color: #cbd0f5;
        margin: 0.25rem 0 0.6rem;
      }
      small {
        color: var(--muted);
      }
      .layout {
        display: grid;
        gap: 12px;
        padding: 14px;
        height: 100%;
        grid-template-columns: 320px 1fr 340px;
        grid-template-rows: auto 1fr 230px;
        grid-template-areas:
          "title title title"
          "left  main  right"
          "footer footer footer";
      }
      header {
        grid-area: title;
        background: linear-gradient(90deg, var(--panel), #1a1e34);
        border: 1px solid #283055;
        border-radius: 14px;
        padding: 12px 14px;
        display: flex;
        align-items: center;
        gap: 14px;
      }
      header .pill {
        background: var(--chip);
        padding: 0.25rem 0.5rem;
        border-radius: 999px;
        color: var(--muted);
        font-size: 0.8rem;
        border: 1px solid #2a2f51;
      }
      .left {
        grid-area: left;
        display: grid;
        gap: 12px;
        grid-auto-rows: max-content;
      }
      .main {
        grid-area: main;
        display: grid;
        grid-template-rows: 320px 1fr;
        gap: 12px;
      }
      .right {
        grid-area: right;
        display: grid;
        gap: 12px;
        grid-template-rows: min-content minmax(120px, 1fr);
      }
      .footer {
        grid-area: footer;
        display: grid;
        grid-template-columns: 1fr 450px;
        gap: 12px;
      }
      .card {
        background: linear-gradient(180deg, var(--panel), #13162a);
        border: 1px solid #1e2441;
        border-radius: 14px;
        padding: 12px;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.25), inset 0 1px 0 #2a2e52;
      }
      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .kpi {
        display: grid;
        grid-template-columns: auto auto;
        gap: 4px 8px;
        align-items: baseline;
      }
      .kpi .v {
        font-weight: 800;
      }
      .sep {
        height: 1px;
        background: #242a4a;
        margin: 8px 0;
      }
      button,
      input[type="range"],
      select {
        accent-color: var(--accent);
      }
      .btn {
        border: 1px solid #273055;
        background: linear-gradient(180deg, #1b2142, #141832);
        color: var(--ink);
        padding: 0.45rem 0.7rem;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.2px;
      }
      .btn:active {
        transform: translateY(1px);
      }
      .btn.primary {
        background: linear-gradient(180deg, #2a3a83, #1a2460);
        border-color: #3548a3;
      }
      .btn.warn {
        background: linear-gradient(180deg, #5a2230, #3a1520);
        border-color: #7a2b3c;
      }
      .btn.ghost {
        background: transparent;
        border-color: #2a3156;
      }
      label {
        font-size: 0.85rem;
        color: var(--muted);
      }
      .slider {
        display: grid;
        grid-template-columns: 1fr 70px;
        gap: 6px;
        align-items: center;
      }
      .chip {
        display: inline-flex;
        gap: 6px;
        align-items: center;
        background: var(--chip);
        color: #d9defa;
        border: 1px solid #2c325a;
        padding: 0.2rem 0.45rem;
        border-radius: 999px;
        font-size: 0.78rem;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
        border-radius: 12px;
        background: linear-gradient(180deg, #0d1020, #0b0f1f);
        border: 1px solid #242a4a;
      }
      .kbd {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas,
          "Liberation Mono", monospace;
        font-size: 0.82rem;
        background: #101327;
        border: 1px solid #2b3260;
        color: #d7dbff;
        padding: 0.05rem 0.35rem;
        border-radius: 6px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9rem;
      }
      td,
      th {
        border-bottom: 1px dashed #2a3156;
        padding: 0.35rem 0.3rem;
        text-align: right;
      }
      th {
        text-align: right;
        color: var(--muted);
        font-weight: 600;
      }
      td:first-child,
      th:first-child {
        text-align: left;
      }
      .eq {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas,
          "Liberation Mono";
        background: #0e1230;
        border: 1px dashed #2a2f57;
        border-radius: 12px;
        padding: 0.6rem;
      }
      .pop {
        position: absolute;
        background: #0e1230;
        border: 1px solid #2a3156;
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 0.88rem;
        color: #dfe3ff;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.4);
        transform: translate(-50%, -115%);
        pointer-events: none;
        white-space: nowrap;
      }
      .legend {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .legend .chip {
        border-radius: 8px;
      }
      .muted {
        color: var(--muted);
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas,
          "Liberation Mono";
      }
      @media (max-width: 1080px) {
        .layout {
          grid-template-columns: 1fr;
          grid-template-rows: auto auto auto auto;
          grid-template-areas: "title" "left" "main" "right" "footer";
        }
        .main {
          grid-template-rows: 280px 1fr;
        }
        .footer {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <header class="card">
        <div
          style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap"
        >
          <h1>Gradient Descent — Learn by Tweaking, Stepping, and Watching</h1>
          <span class="pill"
            >Keyboard: <span class="kbd">Space</span> Play/Pause ·
            <span class="kbd">→</span> Step ·
            <span class="kbd">R</span> Reset</span
          >
          <span class="pill"
            >Modes: 1D Function · 2D Contours · Linear Regression</span
          >
        </div>
      </header>

      ```
      <section class="left">
        <gd-controls class="card"></gd-controls>
        <math-stepper class="card"></math-stepper>
      </section>

      <section class="main">
        <loss-landscape class="card"></loss-landscape>
        <dataset-view class="card"></dataset-view>
      </section>

      <aside class="right">
        <param-tracker class="card"></param-tracker>
        <history-table class="card"></history-table>
      </aside>

      <section class="footer">
        <code-view class="card"></code-view>
        <how-it-works class="card"></how-it-works>
      </section>
      ```
    </div>

    <script type="module">
      /* ============================================================
         Tiny event bus so all components stay in sync
         ============================================================ */
      class Bus extends EventTarget {
        emit(type, detail){ this.dispatchEvent(new CustomEvent(type,{detail})); }
        on(type, fn){ this.addEventListener(type, fn); }
      }
      const bus = new Bus();

      /* ============================================================
         Core GD Engine
         - Supports three modes:
           1) "1d": f(x) = x^4 - 3x^3 + 2 (non-convex)
           2) "2d": f(w) = (w1-1)^2 + 4(w2+2)^2 (elliptical bowl)
           3) "linreg": y ≈ m x + b (synthetic data), MSE loss
         - Momentum, step, autoplay
         ============================================================ */
      const state = {
        mode: '1d',                 // '1d' | '2d' | 'linreg'
        lr: 0.05,                   // learning rate
        momentum: 0.0,
        noise: 0.0,                 // gradient noise
        playing: false,
        stepIntervalMs: 350,
        stepCount: 0,
        // parameters by mode
        x: 2.5,                     // for 1d
        w: [2.5, -3.5],             // for 2d
        m: -1.0, b: 4.0,            // for linreg
        // velocities (for momentum)
        v1: 0, v2: 0, vm: 0, vb: 0,
        // data for linreg
        data: [],
        lastGrad: null,
        lastLoss: null,
        history: []
      };

      // Utility random and clamp
      const rnd = (a=0,b=1)=>a + Math.random()*(b-a);
      const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
      function seedData(n=40){
        // y = 2.2 x - 1.3 + noise
        const trueM = 2.2, trueB = -1.3;
        const out = [];
        for(let i=0;i<n;i++){
          const x = rnd(-3,3);
          const y = trueM*x + trueB + rnd(-0.8,0.8);
          out.push([x,y]);
        }
        return out;
      }
      state.data = seedData();

      // 1D function: f(x) = x^4 - 3x^3 + 2
      function f1d(x){ return x*x*x*x - 3*x*x*x + 2; }
      function df1d(x){ return 4*x*x*x - 9*x*x; }

      // 2D function: f(w1,w2) = (w1-1)^2 + 4(w2+2)^2
      function f2d(w1,w2){ return (w1-1)**2 + 4*(w2+2)**2; }
      function df2d(w1,w2){ return [2*(w1-1), 8*(w2+2)]; }

      // Linear regression loss & grads (MSE)
      function fLinReg(m,b,data){
        let loss=0;
        for(const [x,y] of data){
          const yhat = m*x + b;
          const e = yhat - y;
          loss += e*e;
        }
        return loss / data.length;
      }
      function dfLinReg(m,b,data){
        let dm=0, db=0;
        for(const [x,y] of data){
          const yhat = m*x + b;
          const e = yhat - y;
          dm += 2*e*x;
          db += 2*e;
        }
        return [dm/data.length, db/data.length];
      }

      function currentLoss(){
        if(state.mode==='1d') return f1d(state.x);
        if(state.mode==='2d') return f2d(state.w[0], state.w[1]);
        return fLinReg(state.m, state.b, state.data);
      }
      function currentGrad(){
        let g;
        if(state.mode==='1d'){ g = [df1d(state.x)]; }
        else if(state.mode==='2d'){ g = df2d(state.w[0],state.w[1]); }
        else { g = dfLinReg(state.m,state.b,state.data); }
        // add optional noise
        if(state.noise>0){
          g = g.map(v=> v + rnd(-state.noise, state.noise));
        }
        return g;
      }
      function snapshot(){
        return {
          t: state.stepCount,
          mode: state.mode,
          lr: state.lr,
          momentum: state.momentum,
          loss: state.lastLoss ?? currentLoss(),
          grad: state.lastGrad ?? currentGrad(),
          params: state.mode==='1d' ? [state.x]
                : state.mode==='2d' ? [...state.w]
                : [state.m, state.b]
        };
      }
      function recordHistory(){
        const s = snapshot();
        state.history.unshift(s);
        if(state.history.length>200) state.history.pop();
      }

      let timer=null;
      function play(){ if(timer) return; state.playing=true; timer=setInterval(step, state.stepIntervalMs); bus.emit('play'); }
      function pause(){ state.playing=false; if(timer){clearInterval(timer); timer=null;} bus.emit('pause'); }
      function toggle(){ state.playing? pause() : play(); }

      function reset(hard=false){
        pause();
        state.stepCount=0;
        state.v1=state.v2=state.vm=state.vb=0;
        if(state.mode==='1d') state.x = rnd(-2.5,3.5);
        if(state.mode==='2d') state.w = [rnd(-3,3), rnd(-4,2)];
        if(state.mode==='linreg'){
          state.m = rnd(-2.5,2.5);
          state.b = rnd(-2.5,2.5);
          if(hard) state.data = seedData(40);
        }
        state.history=[];
        state.lastGrad=null; state.lastLoss=null;
        bus.emit('state', {state});
      }

      function step(){
        const lr = state.lr, mu = state.momentum;
        const g = currentGrad();
        state.lastGrad = g;
        if(state.mode==='1d'){
          const grad = g[0];
          state.v1 = mu*state.v1 + (1-mu)*grad;
          state.x  = state.x - lr * state.v1;
        }else if(state.mode==='2d'){
          const [g1,g2]=g;
          state.v1 = mu*state.v1 + (1-mu)*g1;
          state.v2 = mu*state.v2 + (1-mu)*g2;
          state.w[0] -= lr*state.v1;
          state.w[1] -= lr*state.v2;
        }else{ // linreg
          const [gm,gb]=g;
          state.vm = mu*state.vm + (1-mu)*gm;
          state.vb = mu*state.vb + (1-mu)*gb;
          state.m -= lr*state.vm;
          state.b -= lr*state.vb;
        }
        state.stepCount++;
        state.lastLoss = currentLoss();
        recordHistory();
        bus.emit('state', {state});
      }

      /* ============================================================
         Component: Controls
         ============================================================ */
      class GDControls extends HTMLElement{
        connectedCallback(){
          this.attachShadow({mode:'open'}).innerHTML = `
            <style>
              .g{display:grid;gap:8px}
              .row{display:grid;gap:8px;grid-template-columns:1fr auto}
              .slider input{width:100%}
              select{border:1px solid #2b325a;background:#141836;color:#e9ecff;padding:.35rem .4rem;border-radius:8px}
              .stack{display:grid;gap:10px}
            </style>

      ```
        <div class="g">
          <h2>Controls</h2>
          <div class="stack">
            <div class="row">
              <label>Mode</label>
              <select id="mode">
                <option value="1d">1D Non-Convex Function</option>
                <option value="2d">2D Elliptic Bowl</option>
                <option value="linreg">Linear Regression (MSE)</option>
              </select>
            </div>
            <div class="slider">
              <label>Learning rate (α): <b id="lrV">${state.lr.toFixed(3)}</b></label>
              <input id="lr" type="range" min="0.001" max="0.5" step="0.001" value="${state.lr}">
            </div>
            <div class="slider">
              <label>Momentum (β): <b id="moV">${state.momentum.toFixed(2)}</b></label>
              <input id="mo" type="range" min="0" max="0.95" step="0.01" value="${state.momentum}">
            </div>
            <div class="slider">
              <label>Gradient noise: <b id="nzV">${state.noise.toFixed(2)}</b></label>
              <input id="nz" type="range" min="0" max="1" step="0.01" value="${state.noise}">
            </div>
            <div class="row">
              <div class="row" style="gap:8px">
                <button id="play" class="btn primary">▶ Play</button>
                <button id="step" class="btn">Step (→)</button>
                <button id="reset" class="btn ghost">Reset (R)</button>
                <button id="reshuf" class="btn warn">Re-seed Data</button>
              </div>
              <label style="justify-self:end">Speed
                <input id="spd" type="range" min="60" max="1200" step="10" value="${state.stepIntervalMs}">
              </label>
            </div>
            <div class="legend">
              <span class="chip">• Path</span>
              <span class="chip">× Current Params</span>
              <span class="chip">↘ −α∇</span>
              <span class="chip">— Tangent</span>
            </div>
            <small>Tips: Press <span class="kbd">Space</span> to play/pause. Drag the sliders and watch the math and plots update live.</small>
          </div>
        </div>
      `;
      const $ = sel => this.shadowRoot.querySelector(sel);
      $('#mode').value = state.mode;
      $('#mode').addEventListener('change', e=>{ state.mode = e.target.value; reset(true); });
      $('#lr').addEventListener('input', e=>{ state.lr = +e.target.value; $('#lrV').textContent = state.lr.toFixed(3); bus.emit('state',{state}); });
      $('#mo').addEventListener('input', e=>{ state.momentum = +e.target.value; $('#moV').textContent = state.momentum.toFixed(2); bus.emit('state',{state}); });
      $('#nz').addEventListener('input', e=>{ state.noise = +e.target.value; $('#nzV').textContent = state.noise.toFixed(2); });
      $('#spd').addEventListener('input', e=>{ state.stepIntervalMs = +e.target.value; if(state.playing){ pause(); play(); }});
      $('#play').addEventListener('click', ()=> toggle());
      $('#step').addEventListener('click', ()=> step());
      $('#reset').addEventListener('click', ()=> reset());
      $('#reshuf').addEventListener('click', ()=> { state.data = seedData(40); reset(); });
      bus.on('play', ()=> $('#play').textContent='⏸ Pause');
      bus.on('pause', ()=> $('#play').textContent='▶ Play');

      // keyboard shortcuts in the light DOM
      window.addEventListener('keydown', (e)=>{
        if(e.repeat) return;
        if(e.code==='Space'){ e.preventDefault(); toggle(); }
        if(e.key==='ArrowRight'){ step(); }
        if(e.key.toLowerCase()==='r'){ reset(); }
      });
      ```

      }
      }
      customElements.define('gd-controls', GDControls);

      /\* ============================================================
      Component: Loss Landscape (1D + 2D visualizations)
      \============================================================ */
      class LossLandscape extends HTMLElement{
      connectedCallback(){
      this.attachShadow({mode:'open'});
      this.shadowRoot.innerHTML = `       <style>
              .wrap{position:relative;height:100%}
              .hud{position:absolute;top:8px;left:8px;display:flex;gap:8px;flex-wrap:wrap}
              .hud .chip{background:#0c1126}
              .pop{display:none}       </style>       <div class="wrap">         <canvas id="cv"></canvas>         <div class="hud">           <span class="chip">Loss Landscape</span>           <span class="chip">Click to set start</span>         </div>         <div id="pop" class="pop"></div>       </div>
          `;
      this.cv = this.shadowRoot.querySelector('#cv');
      this.ctx = this.cv.getContext('2d');
      this.pop = this.shadowRoot.querySelector('#pop');
      const resize=()=>{
      const r = this.getBoundingClientRect();
      this.cv.width = Math.floor(r.width*2); this.cv.height=Math.floor(r.height*2);
      this.draw();
      };
      new ResizeObserver(resize).observe(this);
      this.cv.addEventListener('mousemove', e=>{
      const pt = this.toWorld(e.offsetX, e.offsetY);
      const loss = this.sampleLoss(pt);
      this.pop.style.display='block';
      this.pop.textContent = `${state.mode==='2d'?'w1':'x'}=${pt[0].toFixed(2)}${state.mode==='2d'?`, w2=\${pt\[1].toFixed(2)}`:''} · L=${loss.toFixed(3)}`;
      this.pop.style.left = e.offsetX+'px';
      this.pop.style.top = e.offsetY+'px';
      });
      this.cv.addEventListener('mouseleave', ()=> this.pop.style.display='none');
      this.cv.addEventListener('click', e=>{
      const pt = this.toWorld(e.offsetX, e.offsetY);
      if(state.mode==='1d'){ state.x = pt\[0]; state.v1=0; }
      else if(state.mode==='2d'){ state.w=\[pt\[0],pt\[1]]; state.v1=state.v2=0; }
      else{ /* linear reg doesn't use canvas position */ }
      state.history=\[]; state.stepCount=0; bus.emit('state',{state});
      });
      bus.on('state', ()=> this.draw());
      this.draw();
      }
      worldBounds(){
      if(state.mode==='1d') return {x:\[-2.5,3.5], y:\[-6,12]};
      if(state.mode==='2d') return {x:\[-4,4], y:\[-4,4]};
      return {x:\[-3.5,3.5], y:\[-3.5,3.5]}; // not used heavily
      }
      toScreen(wx, wy){
      const {x,y}=this.worldBounds();
      const w=this.cv.width, h=this.cv.height;
      const sx = (wx - x\[0])/(x\[1]-x\[0]) \* (w-60) + 30;
      const sy = (1 - (wy - y\[0])/(y\[1]-y\[0])) \* (h-60) + 30;
      return \[sx, sy];
      }
      toWorld(sx, sy){
      const {x,y}=this.worldBounds();
      const w=this.cv.width, h=this.cv.height;
      const wx = (sx-30)/(w-60) \* (x\[1]-x\[0]) + x\[0];
      const wy = (1 - (sy-30)/(h-60)) \* (y\[1]-y\[0]) + y\[0];
      if(state.mode==='2d') return \[wx, wy];
      return \[wx, f1d(wx)];
      }
      sampleLoss(pt){
      if(state.mode==='1d') return f1d(pt\[0]);
      if(state.mode==='2d') return f2d(pt\[0], pt\[1]);
      return 0;
      }
      grid(){
      const ctx=this.ctx, w=this.cv.width, h=this.cv.height;
      ctx.save();
      ctx.strokeStyle = '#1b2040';
      ctx.lineWidth=1;
      for(let i=30;i\<w;i+=40){ ctx.beginPath(); ctx.moveTo(i,20); ctx.lineTo(i,h-20); ctx.stroke(); }
      for(let j=30;j\<h;j+=40){ ctx.beginPath(); ctx.moveTo(20,j); ctx.lineTo(w-20,j); ctx.stroke(); }
      ctx.restore();
      }
      draw1D(){
      const ctx=this.ctx, w=this.cv.width, h=this.cv.height;
      // curve
      ctx.beginPath();
      for(let i=0;i<=400;i++){
      const x = -2.5 + (i/400)*(3.5+2.5);
      const y = f1d(x);
      const \[sx,sy]=this.toScreen(x,y);
      if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
      }
      ctx.strokeStyle = '#5ee6b8'; ctx.lineWidth=3; ctx.stroke();

      ```
      // current point
      const x = state.x, y=f1d(x), g=df1d(x);
      const [sx,sy]=this.toScreen(x,y);
      ctx.fillStyle='#ff7a99'; ctx.beginPath(); ctx.arc(sx,sy,8,0,Math.PI*2); ctx.fill();

      // tangent line
      const dx=0.6;
      const y1 = y + g*(-dx), y2 = y + g*(dx);
      const [s1x,s1y]=this.toScreen(x-dx,y1), [s2x,s2y]=this.toScreen(x+dx,y2);
      ctx.strokeStyle='#ffd27a'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(s1x,s1y); ctx.lineTo(s2x,s2y); ctx.stroke();

      // gradient arrow
      const stepVec = -state.lr * (state.momentum? (state.v1 || g) : g);
      const [ax,ay]=this.toScreen(x, y);
      const [bx,by]=this.toScreen(x+stepVec, f1d(x)); // horizontal depiction
      ctx.strokeStyle='#7aa2ff'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,ay); ctx.stroke();

      // path
      ctx.strokeStyle='#9fb5ff'; ctx.lineWidth=2; ctx.setLineDash([6,5]); ctx.beginPath();
      const hist = [...state.history].slice(0,120).reverse();
      hist.forEach((h,i)=>{
        const xh = h.params[0], yh = f1d(xh);
        const [px,py]=this.toScreen(xh,yh);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      });
      ctx.stroke(); ctx.setLineDash([]);
      ```

      }
      draw2D(){
      const ctx=this.ctx, w=this.cv.width, h=this.cv.height;
      // contours
      for(let c=1;c<=12;c++){
      const L = c*c*0.6;
      ctx.beginPath();
      for(let i=0;i<=200;i++){
      const t = (i/200)*Math.PI*2;
      // ellipse paramization for (w1-1)^2 + 4(w2+2)^2 = L
      const a = Math.sqrt(L);
      const b = Math.sqrt(L/4);
      const wx = 1 + a*Math.cos(t);
      const wy = -2 + b*Math.sin(t);
      const \[sx,sy]=this.toScreen(wx,wy);
      if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
      }
      ctx.strokeStyle = 'rgba(126,162,255,0.15)'; ctx.lineWidth=2; ctx.stroke();
      }

      ```
      // current
      const [w1,w2]=state.w;
      const [sx,sy]=this.toScreen(w1,w2);
      ctx.fillStyle='#ff7a99'; ctx.beginPath(); ctx.arc(sx,sy,8,0,Math.PI*2); ctx.fill();

      // gradient arrow
      const [g1,g2]=df2d(w1,w2);
      const step = [-state.lr*(state.momentum? (state.v1 || g1) : g1),
                    -state.lr*(state.momentum? (state.v2 || g2) : g2)];
      const [ax,ay]=this.toScreen(w1,w2);
      const [bx,by]=this.toScreen(w1+step[0], w2+step[1]);
      ctx.strokeStyle='#7aa2ff'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();

      // path
      ctx.strokeStyle='#9fb5ff'; ctx.lineWidth=2; ctx.setLineDash([6,5]); ctx.beginPath();
      const hist = [...state.history].slice(0,150).reverse();
      hist.forEach((h,i)=>{
        const [pw1,pw2]=h.params;
        const [px,py]=this.toScreen(pw1,pw2);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      });
      ctx.stroke(); ctx.setLineDash([]);
      ```

      }
      draw(){
      const ctx=this.ctx, w=this.cv.width, h=this.cv.height;
      ctx.clearRect(0,0,w,h);
      this.grid();
      if(state.mode==='1d') this.draw1D();
      else if(state.mode==='2d') this.draw2D();
      else {
      // For linear regression, show nothing here; dataset-view will handle visuals.
      ctx.fillStyle='#a9b0d3';
      ctx.font = '24px ui-monospace';
      ctx.fillText('Linear Regression: See the plot below →', 40, 60);
      }
      }
      }
      customElements.define('loss-landscape', LossLandscape);

      /\* ============================================================
      Component: Dataset View (for Linear Regression)
      \============================================================ */
      class DatasetView extends HTMLElement{
      connectedCallback(){
      this.attachShadow({mode:'open'});
      this.shadowRoot.innerHTML = `       <style>
              .wrap{position:relative;height:100%}
              .hud{position:absolute;top:8px;left:8px;display:flex;gap:8px;flex-wrap:wrap}       </style>       <div class="wrap">         <canvas id="cv"></canvas>         <div class="hud">           <span class="chip">Linear Regression Fit</span>           <span class="chip">Drag: none · Click: none</span>         </div>       </div>
          `;
      this.cv = this.shadowRoot.querySelector('#cv');
      this.ctx = this.cv.getContext('2d');
      const resize=()=>{
      const r = this.getBoundingClientRect();
      this.cv.width = Math.floor(r.width*2); this.cv.height=Math.floor(r.height*2);
      this.draw();
      };
      new ResizeObserver(resize).observe(this);
      bus.on('state', ()=> this.draw());
      this.draw();
      }
      bounds(){
      // determine from data + margins
      const xs = state.data.map(d=>d\[0]), ys = state.data.map(d=>d\[1]);
      const x0 = Math.min(-3.5, Math.min(...xs)-0.5), x1 = Math.max(3.5, Math.max(...xs)+0.5);
      const y0 = Math.min(-5, Math.min(...ys)-0.5), y1 = Math.max(5, Math.max(...ys)+0.5);
      return {x:\[x0,x1], y:\[y0,y1]};
      }
      toScreen(wx, wy){
      const {x,y}=this.bounds();
      const w=this.cv.width, h=this.cv.height;
      const sx = (wx - x\[0])/(x\[1]-x\[0]) \* (w-60) + 30;
      const sy = (1 - (wy - y\[0])/(y\[1]-y\[0])) \* (h-60) + 30;
      return \[sx, sy];
      }
      grid(){
      const ctx=this.ctx, w=this.cv.width, h=this.cv.height;
      ctx.save();
      ctx.strokeStyle = '#1b2040';
      ctx.lineWidth=1;
      for(let i=30;i\<w;i+=40){ ctx.beginPath(); ctx.moveTo(i,20); ctx.lineTo(i,h-20); ctx.stroke(); }
      for(let j=30;j\<h;j+=40){ ctx.beginPath(); ctx.moveTo(20,j); ctx.lineTo(w-20,j); ctx.stroke(); }
      ctx.restore();
      }
      draw(){
      const ctx=this.ctx, w=this.cv.width, h=this.cv.height;
      ctx.clearRect(0,0,w,h);
      this.grid();
      if(state.mode!=='linreg'){
      ctx.fillStyle='#a9b0d3';
      ctx.font = '24px ui-monospace';
      ctx.fillText('Switch to Linear Regression mode ↑', 40, 60);
      return;
      }
      // scatter
      for(const \[x,y] of state.data){
      const \[sx,sy]=this.toScreen(x,y);
      ctx.fillStyle='#5ee6b8';
      ctx.beginPath(); ctx.arc(sx,sy,6,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(126,162,255,0.25)'; ctx.beginPath(); ctx.arc(sx,sy,10,0,Math.PI*2); ctx.stroke();
      }
      // line
      const {x:\[x0,x1], y:\[y0,y1]}=this.bounds();
      const p1 = this.toScreen(x0, state.m*x0 + state.b);
      const p2 = this.toScreen(x1, state.m*x1 + state.b);
      const gradDir = dfLinReg(state.m,state.b,state.data);
      // show line
      ctx.strokeStyle='#7aa2ff'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(...p1); ctx.lineTo(...p2); ctx.stroke();
      // show update arrow in parameter space legend-ish
      ctx.fillStyle='#ffd27a';
      ctx.font='18px ui-monospace';
      ctx.fillText(`m=${state.m.toFixed(3)} · b=${state.b.toFixed(3)} · L=${fLinReg(state.m,state.b,state.data).toFixed(3)}`, 40, 60);
      ctx.fillStyle='#a9b0d3';
      ctx.fillText(`∂L/∂m=${gradDir[0].toFixed(3)} · ∂L/∂b=${gradDir[1].toFixed(3)}`, 40, 84);
      // trajectory as fading lines to suggest improvement (using history)
      const hist = \[...state.history].filter(h=>h.mode==='linreg').slice(0,80).reverse();
      ctx.lineWidth = 2; ctx.setLineDash(\[6,5]);
      ctx.strokeStyle='#9fb5ff';
      for(let i=1;i\<hist.length;i++){
      const m1=hist\[i-1].params\[0], b1=hist\[i-1].params\[1];
      const m2=hist\[i].params\[0], b2=hist\[i].params\[1];
      const q1 = this.toScreen(x0, m1*x0 + b1);
      const q2 = this.toScreen(x0, m2\*x0 + b2);
      ctx.beginPath(); ctx.moveTo(...q1); ctx.lineTo(...q2); ctx.stroke();
      }
      ctx.setLineDash(\[]);
      }
      }
      customElements.define('dataset-view', DatasetView);

      /\* ============================================================
      Component: Parameter Tracker
      \============================================================ */
      class ParamTracker extends HTMLElement{
      connectedCallback(){
      this.attachShadow({mode:'open'});
      this.shadowRoot.innerHTML = `       <style>.grid{display:grid;gap:8px}.row{display:flex;gap:12px;align-items:baseline;flex-wrap:wrap}</style>       <div class="grid">         <h2>Live Parameters</h2>         <div class="kpi">           <div>Step</div><div class="v" id="step">0</div>           <div>Loss L(θ)</div><div class="v" id="loss">—</div>           <div>‖∇L‖</div><div class="v" id="grad">—</div>         </div>         <div class="sep"></div>         <div id="params" class="row"></div>         <small class="muted">Momentum uses an exponential moving average of gradients: <span class="mono">v ← βv + (1−β)∇L</span>.</small>         <canvas id="spark" height="90"></canvas>       </div>
          `;
      this.losses=\[];
      this.cv=this.shadowRoot.querySelector('#spark');
      bus.on('state', ({detail:{state\:s}})=> this.update(s));
      this.update(state);
      }
      update(s){
      const \$=sel=>this.shadowRoot.querySelector(sel);
      \$('#step').textContent = s.stepCount;
      const L = currentLoss();
      const g = currentGrad();
      \$('#loss').textContent = L.toFixed(5);
      const gn = Math.sqrt(g.map(v=>v*v).reduce((a,b)=>a+b,0));
      \$('#grad').textContent = gn.toFixed(5);
      const params = s.mode==='1d' ? \[`x=${s.x.toFixed(4)}`]
      : s.mode==='2d' ? \[`w1=${s.w[0].toFixed(4)}`, `w2=${s.w[1].toFixed(4)}`]
      : \[`m=${s.m.toFixed(4)}`, `b=${s.b.toFixed(4)}`];
      \$('#params').innerHTML = params.map(p=>`<span class="chip">${p}</span>`).join(' ');
      // sparkline of loss
      this.losses.push(L); if(this.losses.length>160) this.losses.shift();
      const ctx=this.cv.getContext('2d');
      const w=this.cv.width=this.cv.clientWidth*2, h=this.cv.height=this.cv.clientHeight*2;
      ctx.clearRect(0,0,w,h);
      ctx.strokeStyle='#2a3156'; for(let i=10;i\<w;i+=20){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,h); ctx.stroke(); }
      const min=Math.min(...this.losses), max=Math.max(...this.losses);
      ctx.beginPath();
      this.losses.forEach((L,i)=>{
      const x = i/(this.losses.length-1)*(w-20)+10;
      const y = (1-(L-min)/(max-min+1e-9))*(h-20)+10;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.strokeStyle='#7aa2ff'; ctx.lineWidth=3; ctx.stroke();
      }
      }
      customElements.define('param-tracker', ParamTracker);

      /\* ============================================================
      Component: Math Stepper (shows equations with numbers)
      \============================================================ \*/
      class MathStepper extends HTMLElement{
      connectedCallback(){
      this.attachShadow({mode:'open'});
      this.shadowRoot.innerHTML = `       <div>         <h2>Step-by-Step Math</h2>         <div class="eq" id="eq"></div>         <small class="muted">Update rule with momentum: <span class="mono">θ ← θ − α · v</span>, <span class="mono">v ← βv + (1−β)∇L(θ)</span>. Without momentum: <span class="mono">θ ← θ − α∇L(θ)</span>.</small>       </div>
          `;
      bus.on('state', ()=> this.render());
      this.render();
      }
      render(){
      const el = this.shadowRoot.querySelector('#eq');
      const α = state.lr, β = state.momentum;
      if(state.mode==='1d'){
      const x=state.x, g=df1d(x), L=f1d(x);
      el.innerHTML = `        <div><b>f(x)=x⁴−3x³+2</b></div>         <div>At <span class="mono">x=${x.toFixed(4)}</span>, <span class="mono">∇L=4x³−9x²=${g.toFixed(4)}</span>, <span class="mono">L=${L.toFixed(6)}</span></div>         <div>Update: <span class="mono">x ← x − α·g</span> ${β>0?`with momentum <span class="mono">v ← \${β.toFixed(2)}·v + (1−\${β.toFixed(2)})·g</span>`:''}</div>         <div>Next x (approx): <span class="mono">${(x - α*(state.v1||g)).toFixed(4)}</span></div>
            `;
      }else if(state.mode==='2d'){
      const \[w1,w2]=state.w; const \[g1,g2]=df2d(w1,w2); const L=f2d(w1,w2);
      el.innerHTML = `        <div><b>f(w)= (w₁−1)² + 4(w₂+2)²</b></div>         <div>At <span class="mono">w=[${w1.toFixed(4)}, ${w2.toFixed(4)}]</span>, <span class="mono">∇L=[${g1.toFixed(4)}, ${g2.toFixed(4)}]</span>, <span class="mono">L=${L.toFixed(6)}</span></div>         <div>Update: <span class="mono">w ← w − α·∇L</span> ${β>0?`, using momentum <span class="mono">v ← βv + (1−β)∇L</span>`:''}</div>         <div>Next w (approx): <span class="mono">[${(w1 - state.lr*(state.v1||g1)).toFixed(4)}, ${(w2 - state.lr*(state.v2||g2)).toFixed(4)}]</span></div>
            `;
      }else{
      const m=state.m, b=state.b; const \[gm,gb]=dfLinReg(m,b,state.data); const L=fLinReg(m,b,state.data);
      el.innerHTML = `         <div><b>L(m,b)= (1/N) Σ (mxᵢ+b−yᵢ)²</b></div>         <div>At <span class="mono">m=${m.toFixed(4)}, b=${b.toFixed(4)}</span>, <span class="mono">∂L/∂m=${gm.toFixed(4)}, ∂L/∂b=${gb.toFixed(4)}</span>, <span class="mono">L=${L.toFixed(6)}</span></div>         <div>Update: <span class="mono">m ← m − α·(βvₘ+(1−β)∂L/∂m)</span>, <span class="mono">b ← b − α·(βv_b+(1−β)∂L/∂b)</span></div>         <div>Next (approx): <span class="mono">m=${(m - state.lr*(state.vm||gm)).toFixed(4)}, b=${(b - state.lr*(state.vb||gb)).toFixed(4)}</span></div>
            `;
      }
      }
      }
      customElements.define('math-stepper', MathStepper);

      /\* ============================================================
      Component: History Table (latest steps)
      \============================================================ */
      class HistoryTable extends HTMLElement{
      connectedCallback(){
      this.attachShadow({mode:'open'});
      this.shadowRoot.innerHTML = `       <div>         <h2>Recent Steps</h2>         <table>           <thead><tr><th>#</th><th>Params</th><th>‖∇‖</th><th>Loss</th></tr></thead>           <tbody id="tb"></tbody>         </table>       </div>
          `;
      bus.on('state', ()=> this.render());
      this.render();
      }
      render(){
      const tb=this.shadowRoot.querySelector('#tb');
      const rows = state.history.slice(0,10).map(h=>{
      const gnorm = Math.sqrt(h.grad.map(v=>v*v).reduce((a,b)=>a+b,0));
      const p = h.params.map(v=>v.toFixed(3)).join(', ');
      return `<tr><td>${h.t}</td><td class="mono">${p}</td><td>${gnorm.toFixed(4)}</td><td>${h.loss.toFixed(5)}</td></tr>`;
      }).join('');
      tb.innerHTML = rows || `<tr><td colspan="4" class="muted">No steps yet.</td></tr>`;
      }
      }
      customElements.define('history-table', HistoryTable);

      /\* ============================================================
      Component: Code View (shows pseudo-code + live α, β)
      \============================================================ \*/
      class CodeView extends HTMLElement{
      connectedCallback(){
      this.attachShadow({mode:'open'});
      this.shadowRoot.innerHTML = \` <div> <h2>Algorithm Pseudo-Code</h2>

      <pre class="eq"><code>
      // Gradient Descent with Momentum
      given α = <span id="alpha"></span>, β = <span id="beta"></span>
      initialize θ randomly; v ← 0
      repeat:
        g ← ∇L(θ)
        v ← β·v + (1−β)·g
        θ ← θ − α·v
      until converged
      </code></pre>

      ```
          <small class="muted">This demo uses synthetic functions/data and exact gradients.</small>
        </div>
      `;
      const upd=()=>{
        this.shadowRoot.querySelector('#alpha').textContent = state.lr.toFixed(3);
        this.shadowRoot.querySelector('#beta').textContent = state.momentum.toFixed(2);
      };
      upd();
      bus.on('state', upd);
      ```

      }
      }
      customElements.define('code-view', CodeView);

      /\* ============================================================
      Component: How It Works (mini guide)
      \============================================================ \*/
      class HowItWorks extends HTMLElement{
      connectedCallback(){
      this.attachShadow({mode:'open'});
      this.shadowRoot.innerHTML = `       <div>         <h2>How to Explore</h2>         <ul style="margin:.2rem 0 .6rem 1.1rem; color:#cbd0f5">           <li>Pick a <b>mode</b> to change the loss landscape.</li>           <li>Use <b>α</b> (learning rate) and <b>β</b> (momentum) to tune convergence.</li>           <li>Click the 1D/2D canvas to set a new starting point.</li>           <li>Press <span class="kbd">Space</span> to animate, or <span class="kbd">→</span> to step once.</li>           <li>Add <b>noise</b> to gradients to see the stabilizing effect of momentum.</li>         </ul>         <p class="muted">Try this: set <span class="mono">α≈0.25</span> in 1D mode to see overshooting; then add <span class="mono">β≈0.9</span> to damp oscillations.</p>       </div>
          `;
      }
      }
      customElements.define('how-it-works', HowItWorks);

      // Initialize
      reset(true);
    </script>
  </body>
</html>
