<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Singly Linked List Visualizer</title>
    <style>
      :root {
        --bg: #f6f8fa;
        --fg: #0b1220;
        --muted: #556;
        --accent: #0b84ff;
        --danger: #e03e2d;
        --card: #fff;
        --glass: rgba(255, 255, 255, 0.6);
        --success: #16a34a;
        --shadow: 0 6px 18px rgba(11, 18, 32, 0.08);
      }
      [data-theme="dark"] {
        --bg: #0b1220;
        --fg: #e6eef8;
        --muted: #9ab;
        --accent: #46a8ff;
        --danger: #ff8575;
        --card: #071226;
        --glass: rgba(255, 255, 255, 0.03);
        --shadow: none;
        --success: #4ade80;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI",
          Roboto, "Helvetica Neue", Arial;
        background: linear-gradient(
          180deg,
          var(--bg) 0%,
          color-mix(in srgb, var(--bg) 90%, #0000) 100%
        );
        color: var(--fg);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        padding: 18px;
      }
      header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 12px;
        flex-wrap: wrap;
      }
      h1 {
        font-size: 18px;
        margin: 0;
      }
      .app {
        display: grid;
        grid-template-columns: 360px 1fr 360px;
        gap: 16px;
      }
      @media (max-width: 1000px) {
        .app {
          grid-template-columns: 1fr;
          padding-bottom: 120px;
        }
      }
      .panel {
        background: var(--card);
        padding: 12px;
        border-radius: 10px;
        box-shadow: var(--shadow);
      }
      ll-controls {
        display: block;
      }
      ll-visualizer {
        display: block;
      }
      ll-inspector {
        display: block;
      }
      /* small controls layout */
      .controls {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      input[type="text"],
      input[type="number"],
      select {
        padding: 8px;
        border-radius: 8px;
        border: 1px solid rgba(11, 18, 32, 0.08);
        background: var(--glass);
        color: var(--fg);
        min-width: 0;
        flex: 1;
      }
      button {
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid rgba(11, 18, 32, 0.06);
        background: linear-gradient(180deg, #fff, #f3f6fb);
        cursor: pointer;
      }
      button:hover {
        transform: translateY(-1px);
      }
      .btn-danger {
        background: linear-gradient(180deg, #ffdada, #ffecec);
        border-color: var(--danger);
        color: var(--danger);
      }
      .controls .small {
        padding: 6px 8px;
        font-size: 13px;
      }
      .playcontrols {
        display: flex;
        gap: 6px;
        align-items: center;
      }
      .meta {
        font-size: 13px;
        color: var(--muted);
      }
      .status {
        padding: 6px 8px;
        border-radius: 8px;
        background: linear-gradient(180deg, #eef6ff, #fff);
        font-weight: 600;
      }
      /* visualizer */
      .viz-wrap {
        min-height: 220px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .lane {
        position: relative;
        min-height: 120px;
        padding: 10px;
        border-radius: 8px;
        background: var(--glass);
        display: flex;
        align-items: center;
        overflow: auto;
      }
      .nodes {
        display: flex;
        gap: 18px;
        padding: 12px;
        align-items: center;
      }
      .node {
        min-width: 72px;
        height: 48px;
        border-radius: 10px;
        border: 1px solid rgba(11, 18, 32, 0.08);
        background: linear-gradient(180deg, #fff, #f9fbff);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px 10px;
        gap: 8px;
        position: relative;
        box-shadow: 0 4px 10px rgba(11, 18, 32, 0.04);
      }
      .node .value {
        font-weight: 700;
      }
      .node .ptr {
        font-size: 12px;
        color: var(--muted);
        opacity: 0.9;
      }
      .node.visited {
        outline: 3px solid rgba(11, 132, 255, 0.12);
      }
      .node.found {
        outline: 3px solid rgba(22, 163, 74, 0.15);
      }
      .node.removed {
        opacity: 0.3;
        transform: scale(0.98);
      }
      svg.arrows {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: visible;
      }
      .labels {
        display: flex;
        gap: 8px;
        align-items: center;
        font-size: 13px;
      }
      .labels b {
        background: var(--card);
        padding: 6px 8px;
        border-radius: 8px;
        box-shadow: var(--shadow);
      }
      /* inspector */
      pre.pseudocode {
        background: linear-gradient(180deg, #07122610, #ffffff00);
        padding: 12px;
        border-radius: 8px;
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        white-space: pre-wrap;
      }
      .code-line {
        padding: 2px 6px;
        border-radius: 6px;
      }
      .code-line.current {
        background: linear-gradient(
          90deg,
          rgba(11, 132, 255, 0.08),
          rgba(11, 132, 255, 0.02)
        );
        font-weight: 600;
      }
      .complexity {
        display: flex;
        gap: 8px;
        flex-direction: column;
        font-size: 13px;
        color: var(--muted);
      }
      .log {
        border-radius: 8px;
        padding: 8px;
        background: var(--glass);
        min-height: 60px;
        font-size: 13px;
        overflow: auto;
      }
      footer {
        margin-top: 12px;
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .kbd {
        background: #111827;
        color: #fff;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 12px;
      }
      .tiny {
        font-size: 12px;
        color: var(--muted);
      }
    </style>
  </head>
  <body data-theme="light">
    <header>
      <h1>Singly Linked List — Interactive Visualizer</h1>
      <div class="meta">
        Keyboard: P Play/Pause · . Step · R Reset · Z Undo · Y Redo
      </div>
    </header>
    <main class="app" role="main" aria-label="Singly linked list application">
      <section class="panel" aria-label="Controls panel">
        <ll-controls></ll-controls>
      </section>

      <section class="panel" aria-label="Visualizer panel">
        <ll-visualizer></ll-visualizer>
      </section>

      <aside class="panel" aria-label="Inspector panel">
        <ll-inspector></ll-inspector>
      </aside>
    </main>

    <script>
      /*
  Pure LinkedList class (no DOM)
  Methods return an array of frames that describe animation steps.
  Snapshot format: {nodes:[{id,value,next}], headIndex, tailIndex, size}
  Each frame: {snapshot, highlight:{indices:[],type,label}, codeLine, log}
*/
      class LinkedList {
        constructor() {
          this.head = null;
          this.tail = null;
          this.size = 0;
          this._idCounter = 1;
        }
        _makeNode(value) {
          return { id: this._idCounter++, value, next: null };
        }
        toSnapshot() {
          const map = new Map();
          let idx = 0;
          let node = this.head;
          const nodes = [];
          while (node) {
            map.set(node, idx);
            nodes.push({ id: node.id, value: node.value, next: null });
            node = node.next;
            idx++;
          }
          // set next indices
          node = this.head;
          let i = 0;
          while (node) {
            nodes[i].next = node.next ? map.get(node.next) : null;
            node = node.next;
            i++;
          }
          return {
            nodes,
            headIndex: this.head ? 0 : null,
            tailIndex: this._getTailIndex(nodes),
            size: this.size,
          };
        }
        _getTailIndex(nodes) {
          if (nodes.length === 0) return null;
          for (let i = 0; i < nodes.length; i++) {
            if (nodes[i].next === null) return i;
          }
          return null;
        }
        // invariant checks
        _invariants() {
          // size correctness
          let count = 0,
            node = this.head;
          while (node) {
            count++;
            node = node.next;
            if (count > 10000) break;
          }
          if (count !== this.size)
            throw new Error("Invariant failed: size mismatch");
          if (this.tail && this.tail.next !== null)
            throw new Error("Invariant failed: tail.next is not null");
          // cycle check (Floyd)
          let a = this.head,
            b = this.head;
          while (a && b && b.next) {
            a = a.next;
            b = b.next.next;
            if (a === b) throw new Error("Invariant failed: cycle detected");
          }
          return true;
        }

        _record(frameList, highlight, codeLine, log) {
          frameList.push({
            snapshot: this.toSnapshot(),
            highlight,
            codeLine,
            log,
          });
        }

        push(value) {
          const frames = [];
          const newNode = this._makeNode(value);
          this._record(
            frames,
            { indices: [], type: "start", label: "push start" },
            1,
            `Start push(${value})`
          );
          if (!this.head) {
            this.head = newNode;
            this.tail = newNode;
            this.size = 1;
            this._record(
              frames,
              { indices: [0], type: "create", label: "node created" },
              3,
              `Inserted as head`
            );
          } else {
            // traverse to tail
            let i = 0,
              node = this.head;
            while (node.next) {
              this._record(
                frames,
                { indices: [i], type: "visit", label: "traverse" },
                5,
                `Visiting index ${i}`
              );
              node = node.next;
              i++;
            }
            this._record(
              frames,
              { indices: [i], type: "visit", label: "tail" },
              6,
              `At tail index ${i}`
            );
            node.next = newNode;
            this.tail = newNode;
            this.size++;
            this._record(
              frames,
              { indices: [i + 1], type: "create", label: "appended" },
              8,
              `Appended at index ${i + 1}`
            );
          }
          this._invariants();
          this._record(
            frames,
            { indices: [], type: "done", label: "done" },
            9,
            `Push complete`
          );
          return frames;
        }

        unshift(value) {
          const frames = [];
          const newNode = this._makeNode(value);
          this._record(
            frames,
            { indices: [], type: "start", label: "unshift start" },
            1,
            `Start unshift(${value})`
          );
          if (!this.head) {
            this.head = newNode;
            this.tail = newNode;
            this.size = 1;
            this._record(
              frames,
              { indices: [0], type: "create", label: "node created" },
              3,
              `Inserted as head`
            );
          } else {
            this._record(
              frames,
              { indices: [0], type: "visit", label: "old head" },
              4,
              `Old head will be shifted`
            );
            newNode.next = this.head;
            this.head = newNode;
            this.size++;
            this._record(
              frames,
              { indices: [0], type: "create", label: "inserted" },
              6,
              `Inserted at head`
            );
          }
          this._invariants();
          this._record(
            frames,
            { indices: [], type: "done", label: "done" },
            7,
            `Unshift complete`
          );
          return frames;
        }

        insertAt(index, value) {
          const frames = [];
          this._record(
            frames,
            { indices: [], type: "start", label: "insertAt start" },
            1,
            `Start insertAt(${index}, ${value})`
          );
          if (index < 0 || index > this.size) {
            this._record(frames, {}, 2, `Index out of bounds`);
            throw new Error("Index out of bounds");
          }
          if (index === 0) return this.unshift(value);
          if (index === this.size) return this.push(value);
          const newNode = this._makeNode(value);
          let i = 0,
            node = this.head;
          while (i < index - 1 && node) {
            this._record(
              frames,
              { indices: [i], type: "visit", label: "traverse" },
              4,
              `Visiting index ${i}`
            );
            node = node.next;
            i++;
          }
          this._record(
            frames,
            { indices: [i], type: "visit", label: "insert point" },
            6,
            `At index ${i}`
          );
          newNode.next = node.next;
          node.next = newNode;
          this.size++;
          this._record(
            frames,
            { indices: [i + 1], type: "create", label: "inserted" },
            8,
            `Inserted at index ${index}`
          );
          this._invariants();
          this._record(
            frames,
            { indices: [], type: "done", label: "done" },
            9,
            `Insert complete`
          );
          return frames;
        }

        removeAt(index) {
          const frames = [];
          this._record(
            frames,
            { indices: [], type: "start", label: "removeAt start" },
            1,
            `Start removeAt(${index})`
          );
          if (index < 0 || index >= this.size) {
            this._record(frames, {}, 2, `Index out of bounds`);
            throw new Error("Index out of bounds");
          }
          if (index === 0) {
            this._record(
              frames,
              { indices: [0], type: "visit", label: "head" },
              3,
              `Removing head`
            );
            const removed = this.head;
            this.head = this.head.next;
            if (!this.head) this.tail = null;
            this.size--;
            this._record(
              frames,
              { indices: [0], type: "remove", label: "removed" },
              5,
              `Removed head (value=${removed.value})`
            );
            this._invariants();
            this._record(
              frames,
              { indices: [], type: "done", label: "done" },
              6,
              `Remove complete`
            );
            return frames;
          }
          let i = 0,
            node = this.head;
          while (i < index - 1 && node) {
            this._record(
              frames,
              { indices: [i], type: "visit", label: "traverse" },
              4,
              `Visiting index ${i}`
            );
            node = node.next;
            i++;
          }
          this._record(
            frames,
            { indices: [i + 1], type: "visit", label: "to remove" },
            6,
            `Will remove index ${index}`
          );
          const removed = node.next;
          node.next = removed.next;
          if (node.next === null) this.tail = node;
          this.size--;
          this._record(
            frames,
            { indices: [i + 1], type: "remove", label: "removed" },
            8,
            `Removed index ${index}`
          );
          this._invariants();
          this._record(
            frames,
            { indices: [], type: "done", label: "done" },
            9,
            `Remove complete`
          );
          return frames;
        }

        deleteValue(value) {
          const frames = [];
          this._record(
            frames,
            { indices: [], type: "start", label: "deleteValue start" },
            1,
            `Start deleteValue(${value})`
          );
          if (!this.head) {
            this._record(frames, {}, 2, `List empty`);
            return frames;
          }
          let idx = 0,
            node = this.head,
            prev = null;
          while (node) {
            this._record(
              frames,
              { indices: [idx], type: "visit", label: "compare" },
              4,
              `Comparing index ${idx}`
            );
            if (node.value === value) {
              this._record(
                frames,
                { indices: [idx], type: "found", label: "found" },
                5,
                `Found at ${idx}`
              );
              if (prev == null) {
                // head
                this.head = node.next;
                if (this.head == null) this.tail = null;
              } else {
                prev.next = node.next;
                if (prev.next == null) this.tail = prev;
              }
              this.size--;
              this._record(
                frames,
                { indices: [idx], type: "remove", label: "removed" },
                7,
                `Removed node with value ${value}`
              );
              this._invariants();
              this._record(
                frames,
                { indices: [], type: "done", label: "done" },
                8,
                `Delete complete`
              );
              return frames;
            }
            prev = node;
            node = node.next;
            idx++;
          }
          this._record(
            frames,
            { indices: [], type: "done", label: "not found" },
            9,
            `Value not found`
          );
          return frames;
        }

        search(value) {
          const frames = [];
          this._record(
            frames,
            { indices: [], type: "start", label: "search start" },
            1,
            `Start search(${value})`
          );
          let idx = 0,
            node = this.head;
          while (node) {
            this._record(
              frames,
              { indices: [idx], type: "visit", label: "compare" },
              3,
              `Comparing index ${idx}`
            );
            if (node.value === value) {
              this._record(
                frames,
                { indices: [idx], type: "found", label: "found" },
                5,
                `Found at index ${idx}`
              );
              this._record(
                frames,
                { indices: [], type: "done", label: "done" },
                6,
                `Search complete`
              );
              return frames;
            }
            node = node.next;
            idx++;
          }
          this._record(
            frames,
            { indices: [], type: "done", label: "not found" },
            7,
            `Not found`
          );
          return frames;
        }

        reverse() {
          const frames = [];
          this._record(
            frames,
            { indices: [], type: "start", label: "reverse start" },
            1,
            `Start reverse`
          );
          let prev = null,
            node = this.head;
          let idx = 0;
          // We'll simulate by visiting nodes and building reversed links
          while (node) {
            this._record(
              frames,
              { indices: [idx], type: "visit", label: "reversing" },
              4,
              `Reversing index ${idx}`
            );
            const next = node.next;
            node.next = prev;
            prev = node;
            node = next;
            idx++;
            // Record partial snapshot by reconstructing head to prev (we need to set head temporarily)
            const savedHead = this.head,
              savedTail = this.tail;
            this.head = prev; // set a temporary head to capture current reversed prefix
            // compute tail: it will be the last node in the reversed prefix or savedTail if none
            // restore later
            frames.push({
              snapshot: this.toSnapshot(),
              highlight: { indices: [], type: "partial", label: "partial" },
              codeLine: 5,
              log: `Reversed ${idx} nodes`,
            });
            this.head = savedHead;
            this.tail = savedTail;
          }
          // swap head/tail
          const oldHead = this.head;
          const oldTail = this.tail;
          this.head = prev;
          // recompute tail
          this.tail = this.head
            ? (() => {
                let n = this.head;
                while (n.next) n = n.next;
                return n;
              })()
            : null;
          this._record(
            frames,
            { indices: [], type: "done", label: "done" },
            8,
            `Reverse complete`
          );
          this._invariants();
          return frames;
        }

        clear() {
          const frames = [];
          this._record(
            frames,
            { indices: [], type: "start", label: "clear start" },
            1,
            `Start clear`
          );
          // record removal progressively
          let node = this.head,
            idx = 0;
          while (node) {
            this._record(
              frames,
              { indices: [idx], type: "remove", label: "removing" },
              3,
              `Removing index ${idx}`
            );
            node = node.next;
            idx++;
          }
          this.head = null;
          this.tail = null;
          this.size = 0;
          this._record(
            frames,
            { indices: [], type: "done", label: "done" },
            5,
            `Cleared`
          );
          this._invariants();
          return frames;
        }

        randomize(n, maxValue = 99) {
          // destructive: set list to new random values
          const frames = [];
          this._record(
            frames,
            { indices: [], type: "start", label: "randomize start" },
            1,
            `Randomize to ${n} nodes`
          );
          this.head = null;
          this.tail = null;
          this.size = 0;
          for (let i = 0; i < n; i++) {
            const v = Math.floor(Math.random() * maxValue);
            const f = this.push(v);
            // append frames but avoid double-recording invariants error (push already recorded)
            frames.push(...f);
          }
          this._record(
            frames,
            { indices: [], type: "done", label: "done" },
            3,
            `Randomize complete`
          );
          return frames;
        }

        cloneState() {
          // deep clone state: list of values
          const arr = [];
          let node = this.head;
          while (node) {
            arr.push(node.value);
            node = node.next;
          }
          return { values: arr, idCounter: this._idCounter };
        }
        restoreState(snapshot) {
          // snapshot is {values, idCounter}
          this.head = null;
          this.tail = null;
          this.size = 0;
          this._idCounter =
            snapshot && snapshot.idCounter
              ? snapshot.idCounter
              : this._idCounter;
          if (snapshot && snapshot.values) {
            for (const v of snapshot.values) this.push(v);
          }
        }
        equalsSnapshot(expected) {
          const cur = [];
          let node = this.head;
          while (node) {
            cur.push(node.value);
            node = node.next;
          }
          if (cur.length !== expected.length) return false;
          for (let i = 0; i < cur.length; i++)
            if (cur[i] !== expected[i]) return false;
          return true;
        }
      }

      /* Simple EventEmitter for components */
      const E = new (class {
        constructor() {
          this.map = new Map();
        }
        on(k, cb) {
          if (!this.map.has(k)) this.map.set(k, []);
          this.map.get(k).push(cb);
        }
        off(k, cb) {
          if (!this.map.has(k)) return;
          const arr = this.map.get(k);
          const i = arr.indexOf(cb);
          if (i >= 0) arr.splice(i, 1);
        }
        emit(k, d) {
          if (!this.map.has(k)) return;
          for (const cb of this.map.get(k)) cb(d);
        }
      })();

      /* Animator coordinates frames, playback, undo/redo */
      class Animator {
        constructor(visualizer, inspector) {
          this.visualizer = visualizer;
          this.inspector = inspector;
          this.queue = []; // frames
          this.playing = false;
          this.speed = 3; // 1..5
          this.timer = null;
          this.frameIndex = 0;
          this.currentFrames = [];
          this.onEnd = null;
          this.history = []; // states for undo
          this.future = []; // redo
          this.reduced = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          ).matches;
          document.addEventListener("visibilitychange", () => this.pause());
        }
        setSpeed(v) {
          this.speed = v;
        }
        pushFrames(frames, options = {}) {
          // frames is array of frame objects. Reset current frames and start playback
          this.currentFrames = frames;
          this.frameIndex = 0;
          this.playing = options.autoplay ?? true;
          this.onEnd = options.onEnd ?? null;
          this.visualizer.setSnapshot(
            frames.length ? frames[0].snapshot : null
          );
          this.step(); // show first frame immediately
          if (this.playing) this.play();
        }
        play() {
          if (this.playing) return;
          this.playing = true;
          this._schedule();
        }
        pause() {
          this.playing = false;
          if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
          }
        }
        reset() {
          this.pause();
          this.frameIndex = 0;
          if (this.currentFrames.length) {
            this._applyFrame(this.currentFrames[0]);
          } else {
            this.visualizer.setSnapshot(null);
            this.inspector.showFrame(null);
          }
        }
        step() {
          if (this.frameIndex >= this.currentFrames.length) {
            this._done();
            return;
          }
          const frame = this.currentFrames[this.frameIndex];
          this._applyFrame(frame);
          this.frameIndex++;
          if (this.frameIndex >= this.currentFrames.length) this._done();
        }
        _schedule() {
          if (!this.playing) return;
          const delay = this.reduced
            ? 20
            : Math.max(40, 700 - this.speed * 120);
          this.timer = setTimeout(() => {
            this.step();
            if (this.playing && this.frameIndex < this.currentFrames.length)
              this._schedule();
          }, delay);
        }
        _applyFrame(frame) {
          if (frame && frame.snapshot)
            this.visualizer.setSnapshot(frame.snapshot);
          this.visualizer.highlight(frame ? frame.highlight : null);
          this.inspector.showFrame(frame);
          if (frame && frame.log) this.inspector.log(frame.log);
        }
        _done() {
          this.pause();
          if (this.onEnd) this.onEnd();
        }
        // history management
        pushHistory(state) {
          this.history.push(JSON.parse(JSON.stringify(state)));
          this.future = [];
          E.emit("history", {
            canUndo: this.history.length > 0,
            canRedo: this.future.length > 0,
          });
        }
        undo(linkedList) {
          if (this.history.length <= 1) return null;
          const cur = this.history.pop();
          this.future.push(cur);
          const prev = JSON.parse(
            JSON.stringify(this.history[this.history.length - 1])
          );
          linkedList.restoreState(prev);
          E.emit("history", {
            canUndo: this.history.length > 1,
            canRedo: this.future.length > 0,
          });
          return prev;
        }
        redo(linkedList) {
          if (this.future.length === 0) return null;
          const s = this.future.pop();
          linkedList.restoreState(s);
          this.history.push(JSON.parse(JSON.stringify(s)));
          E.emit("history", {
            canUndo: this.history.length > 1,
            canRedo: this.future.length > 0,
          });
          return s;
        }
      }

      const LL = new LinkedList();
      const VISUAL = document.createElement("div"); // placeholder
      let animator;

      /* <ll-visualizer> component */
      class LLVisualizer extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
          this.shadowRoot.innerHTML = `
      <style>
        :host{display:block}
        .viz-wrap{min-height:240px;display:flex;flex-direction:column;gap:8px}
        .lane{position:relative;min-height:160px;padding:10px;border-radius:8px;background:var(--glass);display:flex;align-items:center;overflow:auto}
        .nodes{display:flex;gap:18px;padding:12px;align-items:center}
        .node{min-width:72px;height:48px;border-radius:10px;border:1px solid rgba(11,18,32,0.08);background:linear-gradient(180deg,#fff,#f9fbff);display:flex;align-items:center;justify-content:space-between;padding:6px 10px;gap:8px;position:relative;box-shadow:0 4px 10px rgba(11,18,32,0.04)}
        .node .value{font-weight:700}
        .node .ptr{font-size:12px;color:var(--muted);opacity:0.9}
        .node.visited{outline:3px solid rgba(11,132,255,0.12)}
        .node.found{outline:3px solid rgba(22,163,74,0.15)}
        .node.removed{opacity:0.3;transform:scale(0.98)}
        svg.arrows{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;overflow:visible}
        .labels{display:flex;gap:8px;align-items:center;font-size:13px}
        .labels b{background:var(--card);padding:6px 8px;border-radius:8px;box-shadow:var(--shadow)}
      </style>
      <div class="viz-wrap">
        <div class="labels" aria-hidden="true"><b class="status" id="size">Size: 0</b><div class="meta" id="headtail">Head: null · Tail: null</div></div>
        <div class="lane" part="lane">
          <div class="nodes" id="nodes" role="list" aria-label="Linked list nodes"></div>
          <svg class="arrows" id="svg"></svg>
        </div>
        <div class="meta tiny" id="null">Null → (end)</div>
      </div>`;
          this.nodesEl = this.shadowRoot.getElementById("nodes");
          this.svg = this.shadowRoot.getElementById("svg");
          this.sizeEl = this.shadowRoot.getElementById("size");
          this.headTailEl = this.shadowRoot.getElementById("headtail");
          this.currentSnapshot = null;
          window.addEventListener("resize", () => this._drawArrows());
        }

        connectedCallback() {
          E.on("visual:update", (s) => {
            this.setSnapshot(s);
          });
        }
        disconnectedCallback() {}

        setSnapshot(snapshot) {
          this.currentSnapshot = snapshot;
          this._render();
        }

        _render() {
          const snap = this.currentSnapshot;
          this.nodesEl.innerHTML = "";
          if (!snap || snap.nodes.length === 0) {
            this.sizeEl.textContent = "Size: 0";
            this.headTailEl.textContent = "Head: null · Tail: null";
            this._drawArrows();
            return;
          }
          this.sizeEl.textContent = `Size: ${snap.size}`;
          this.headTailEl.textContent = `Head: ${
            snap.headIndex === null ? "null" : snap.headIndex
          } · Tail: ${snap.tailIndex === null ? "null" : snap.tailIndex}`;
          // create node elements
          for (let i = 0; i < snap.nodes.length; i++) {
            const n = snap.nodes[i];
            const div = document.createElement("div");
            div.className = "node";
            div.dataset.index = i;
            div.setAttribute("role", "listitem");
            div.innerHTML = `<div class="value" aria-hidden="true">${
              n.value
            }</div><div class="ptr" aria-hidden="true">→ ${
              n.next === null ? "null" : n.next
            }</div>`;
            this.nodesEl.appendChild(div);
          }
          this._drawArrows();
        }

        highlight(spec) {
          // clear classes
          const nodes = [...this.nodesEl.children];
          nodes.forEach((n) =>
            n.classList.remove("visited", "found", "removed")
          );
          if (!spec || !spec.indices) return;
          for (const idx of spec.indices) {
            const el = this.nodesEl.querySelector(`.node[data-index="${idx}"]`);
            if (!el) continue;
            if (spec.type === "visit") el.classList.add("visited");
            if (spec.type === "found") el.classList.add("found");
            if (spec.type === "remove") el.classList.add("removed");
            if (spec.type === "create") el.classList.add("visited");
          }
          // aria live small announcement
          const announcer = this.shadowRoot.getElementById("announcer");
          if (!announcer) {
            const a = document.createElement("div");
            a.id = "announcer";
            a.setAttribute("aria-live", "polite");
            a.setAttribute("hidden", "");
            this.shadowRoot.appendChild(a);
          }
          if (spec && spec.label) {
            this.shadowRoot.getElementById("announcer").textContent =
              spec.label;
          }
        }

        _drawArrows() {
          // draw arrows connecting node centers to next node centers
          const svg = this.svg;
          svg.innerHTML = "";
          const nodes = [...this.nodesEl.children];
          if (nodes.length === 0) return;
          const laneRect = this.shadowRoot
            .querySelector(".lane")
            .getBoundingClientRect();
          for (let i = 0; i < nodes.length; i++) {
            const cur = nodes[i];
            const nextIndex = this.currentSnapshot.nodes[i].next;
            if (nextIndex === null) continue;
            const next = nodes[nextIndex];
            if (!cur || !next) continue;
            const a = cur.getBoundingClientRect(),
              b = next.getBoundingClientRect();
            const startX = a.right - laneRect.left - 6;
            const startY = a.top + a.height / 2 - laneRect.top;
            const endX = b.left - laneRect.left + 6;
            const endY = b.top + b.height / 2 - laneRect.top;
            const path = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            const dx = Math.max(18, (endX - startX) / 2);
            const d = `M ${startX} ${startY} C ${startX + dx} ${startY} ${
              endX - dx
            } ${endY} ${endX} ${endY}`;
            path.setAttribute("d", d);
            path.setAttribute("stroke", "rgba(11,132,255,0.4)");
            path.setAttribute("fill", "none");
            path.setAttribute("stroke-width", "2");
            path.setAttribute("marker-end", "url(#arrow)");
            svg.appendChild(path);
          }
          // defs
          const defs = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "defs"
          );
          const marker = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "marker"
          );
          marker.setAttribute("id", "arrow");
          marker.setAttribute("markerWidth", "6");
          marker.setAttribute("markerHeight", "6");
          marker.setAttribute("refX", "4");
          marker.setAttribute("refY", "3");
          marker.setAttribute("orient", "auto");
          const poly = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          poly.setAttribute("d", "M0,0 L6,3 L0,6 z");
          poly.setAttribute("fill", "rgba(11,132,255,0.6)");
          marker.appendChild(poly);
          defs.appendChild(marker);
          svg.appendChild(defs);
        }
      }
      customElements.define("ll-visualizer", LLVisualizer);

      /* <ll-inspector> shows pseudocode, complexity, and aria-live log */
      class LLInspector extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
          this.shadowRoot.innerHTML = `
      <style>
        :host{display:block}
        h3{margin:0 0 8px 0;font-size:15px}
        pre{background:var(--glass);padding:10px;border-radius:8px;font-family:ui-monospace,monospace;font-size:13px}
        .complex{display:flex;gap:8px;flex-direction:column;margin-top:8px}
        .log{margin-top:8px;padding:8px;border-radius:8px;background:var(--glass);min-height:70px;font-size:13px;overflow:auto}
      </style>
      <div>
        <h3>Pseudo-code (insertAt)</h3>
        <pre id="pseudo" class="pseudocode" aria-hidden="false"></pre>
        <div class="complex">
          <div><strong>Time Complexity:</strong> <span id="time">O(n)</span></div>
          <div><strong>Space Complexity:</strong> <span id="space">O(1)</span></div>
        </div>
        <div style="margin-top:10px"><strong>Console</strong></div>
        <div id="log" class="log" role="log" aria-live="polite"></div>
      </div>
    `;
          this.pseudo = this.shadowRoot.getElementById("pseudo");
          this.logEl = this.shadowRoot.getElementById("log");
          this.pseudocodeLines = [
            "function insertAt(index, value):",
            "  if index < 0 or index > size: error",
            "  if index == 0:",
            "    newNode.next = head",
            "    head = newNode",
            "    if tail == null: tail = head",
            "    return",
            "  prev = head",
            "  for i in 0 .. index-2:",
            "    prev = prev.next",
            "  newNode.next = prev.next",
            "  prev.next = newNode",
            "  if newNode.next == null: tail = newNode",
          ];
          this._renderPseudo();
        }
        _renderPseudo(curLine = null) {
          this.pseudo.innerHTML = "";
          for (let i = 0; i < this.pseudocodeLines.length; i++) {
            const div = document.createElement("div");
            div.textContent = this.pseudocodeLines[i];
            div.className = "code-line" + (curLine === i + 1 ? " current" : "");
            this.pseudo.appendChild(div);
          }
        }
        showFrame(frame) {
          if (!frame) {
            this._renderPseudo(null);
            return;
          }
          this._renderPseudo(frame.codeLine || null);
        }
        log(msg) {
          const d = document.createElement("div");
          d.textContent = `${new Date().toLocaleTimeString()}: ${msg}`;
          this.logEl.appendChild(d);
          this.logEl.scrollTop = this.logEl.scrollHeight;
        }
      }
      customElements.define("ll-inspector", LLInspector);

      /* <ll-controls> component */
      class LLControls extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
          this.shadowRoot.innerHTML = `
      <style>
        :host{display:block}
        .controls{display:flex;flex-direction:column;gap:8px}
        .row{display:flex;gap:8px;align-items:center}
        input[type="text"], input[type="number"], select{
          padding:8px;border-radius:8px;border:1px solid rgba(11,18,32,0.08);background:var(--glass);color:var(--fg);min-width:0;flex:1;
        }
        button{padding:8px;border-radius:8px;border:1px solid rgba(11,18,32,0.06);background:linear-gradient(180deg,#fff,#f3f6fb);cursor:pointer}
        .btn-danger{background:linear-gradient(180deg,#ffdada,#ffecec);border-color:var(--danger);color:var(--danger)}
        .group{display:flex;gap:6px;flex-wrap:wrap}
        .small{padding:6px 8px;font-size:13px}
      </style>
      <div class="controls" aria-label="List controls">
        <div class="row">
          <input id="value" type="text" placeholder="Value (string/number)" aria-label="Value input" />
          <input id="index" type="number" placeholder="Index" aria-label="Index input" />
        </div>
        <div class="group" role="group" aria-label="Operations">
          <button id="push">Push</button>
          <button id="unshift">Unshift</button>
          <button id="insert">InsertAt</button>
          <button id="remove">RemoveAt</button>
          <button id="del">DeleteValue</button>
          <button id="search">Search</button>
          <button id="reverse">Reverse</button>
          <button id="clear" class="btn-danger">Clear</button>
        </div>
        <div class="row">
          <div class="playcontrols" role="group" aria-label="Playback controls">
            <button id="play" class="small">Play</button>
            <button id="pause" class="small">Pause</button>
            <button id="step" class="small">Step</button>
            <button id="reset" class="small">Reset</button>
          </div>
          <div style="flex:1;text-align:right">
            <label class="tiny">Speed
              <select id="speed" aria-label="Animation speed">
                <option value="1">1 (slow)</option>
                <option value="2">2</option>
                <option value="3" selected>3</option>
                <option value="4">4</option>
                <option value="5">5 (fast)</option>
              </select>
            </label>
          </div>
        </div>
        <div class="row">
          <button id="undo" class="small">Undo</button>
          <button id="redo" class="small">Redo</button>
          <button id="random" class="small">Randomize</button>
          <button id="test" class="small">Run Tests</button>
          <button id="theme" class="small">Toggle Theme</button>
        </div>
        <div class="meta tiny" id="invariant" role="status" aria-live="polite"></div>
      </div>
    `;
          this.valueEl = this.shadowRoot.getElementById("value");
          this.indexEl = this.shadowRoot.getElementById("index");
          this.playBtn = this.shadowRoot.getElementById("play");
          this.pauseBtn = this.shadowRoot.getElementById("pause");
          this.stepBtn = this.shadowRoot.getElementById("step");
          this.resetBtn = this.shadowRoot.getElementById("reset");
          this.pushBtn = this.shadowRoot.getElementById("push");
          this.unshiftBtn = this.shadowRoot.getElementById("unshift");
          this.insertBtn = this.shadowRoot.getElementById("insert");
          this.removeBtn = this.shadowRoot.getElementById("remove");
          this.deleteBtn = this.shadowRoot.getElementById("del");
          this.searchBtn = this.shadowRoot.getElementById("search");
          this.reverseBtn = this.shadowRoot.getElementById("reverse");
          this.clearBtn = this.shadowRoot.getElementById("clear");
          this.speedEl = this.shadowRoot.getElementById("speed");
          this.undoBtn = this.shadowRoot.getElementById("undo");
          this.redoBtn = this.shadowRoot.getElementById("redo");
          this.randomBtn = this.shadowRoot.getElementById("random");
          this.themeBtn = this.shadowRoot.getElementById("theme");
          this.testBtn = this.shadowRoot.getElementById("test");
          this.invariantEl = this.shadowRoot.getElementById("invariant");
        }

        connectedCallback() {
          // hook up events
          this.pushBtn.onclick = () => this._op("push");
          this.unshiftBtn.onclick = () => this._op("unshift");
          this.insertBtn.onclick = () => this._op("insertAt");
          this.removeBtn.onclick = () => this._op("removeAt");
          this.deleteBtn.onclick = () => this._op("deleteValue");
          this.searchBtn.onclick = () => this._op("search");
          this.reverseBtn.onclick = () => this._op("reverse");
          this.clearBtn.onclick = () => this._op("clear");
          this.playBtn.onclick = () => animator.play();
          this.pauseBtn.onclick = () => animator.pause();
          this.stepBtn.onclick = () => animator.step();
          this.resetBtn.onclick = () => {
            animator.reset();
            this._announce("Reset animation");
          };
          this.speedEl.onchange = () =>
            animator.setSpeed(parseInt(this.speedEl.value));
          this.undoBtn.onclick = () => {
            animator.pause();
            const prev = animator.undo(LL);
            if (prev) {
              E.emit("visual:update", LL.toSnapshot());
              this._announce("Undo");
            }
          };
          this.redoBtn.onclick = () => {
            animator.pause();
            const s = animator.redo(LL);
            if (s) {
              E.emit("visual:update", LL.toSnapshot());
              this._announce("Redo");
            }
          };
          this.randomBtn.onclick = () => {
            animator.pause();
            const n = Math.max(
              1,
              Math.min(10, Math.round(Math.random() * 7) + 1)
            );
            const frames = LL.randomize(n, 50);
            animator.pushFrames(frames, {
              autoplay: true,
              onEnd: () => {
                animator.pushHistory(LL.cloneState());
                this._checkInvariant();
              },
            });
          };
          this.themeBtn.onclick = () => {
            const root = document.body;
            const t =
              root.getAttribute("data-theme") === "dark" ? "light" : "dark";
            root.setAttribute("data-theme", t);
            this._announce(`Theme ${t}`);
          };
          this.testBtn.onclick = () => this._runTests();
          // keyboard shortcuts
          document.addEventListener("keydown", (e) => {
            if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA")
              return;
            if (e.key.toLowerCase() === "p") {
              animator.play();
              e.preventDefault();
            }
            if (e.key === ".") {
              animator.step();
              e.preventDefault();
            }
            if (e.key.toLowerCase() === "r") {
              animator.reset();
              e.preventDefault();
            }
            if (e.key.toLowerCase() === "z") {
              this.undoBtn.click();
              e.preventDefault();
            }
            if (e.key.toLowerCase() === "y") {
              this.redoBtn.click();
              e.preventDefault();
            }
          });
          E.on("history", (s) => {
            this.undoBtn.disabled = !s.canUndo;
            this.redoBtn.disabled = !s.canRedo;
          });
          // initialize history
          animator.pushHistory(LL.cloneState());
          E.emit("visual:update", LL.toSnapshot());
          this._checkInvariant();
        }

        _getValue() {
          const v = this.valueEl.value.trim();
          if (v === "") return null;
          const num = Number(v);
          return isNaN(num) ? v : num;
        }
        _getIndex() {
          const val = this.indexEl.value;
          if (val === "") return null;
          return Number(val);
        }
        _op(name) {
          try {
            animator.pause();
            const val = this._getValue();
            const idx = this._getIndex();
            let frames = null;
            switch (name) {
              case "push":
                if (val === null) return this._announce("Please enter a value");
                frames = LL.push(val);
                break;
              case "unshift":
                if (val === null) return this._announce("Please enter a value");
                frames = LL.unshift(val);
                break;
              case "insertAt":
                if (val === null || idx === null)
                  return this._announce("Enter value and index");
                frames = LL.insertAt(idx, val);
                break;
              case "removeAt":
                if (idx === null) return this._announce("Enter index");
                frames = LL.removeAt(idx);
                break;
              case "deleteValue":
                if (val === null) return this._announce("Enter value");
                frames = LL.deleteValue(val);
                break;
              case "search":
                if (val === null) return this._announce("Enter value");
                frames = LL.search(val);
                break;
              case "reverse":
                frames = LL.reverse();
                break;
              case "clear":
                frames = LL.clear();
                break;
            }
            if (frames && frames.length > 0) {
              animator.pushFrames(frames, {
                autoplay: true,
                onEnd: () => {
                  animator.pushHistory(LL.cloneState());
                  this._checkInvariant();
                },
              });
            } else {
              // might be empty frames but state changed (e.g., clear on empty)
              animator.pushHistory(LL.cloneState());
              E.emit("visual:update", LL.toSnapshot());
              this._checkInvariant();
            }
          } catch (err) {
            this._announce("Error: " + err.message);
            console.error(err);
          }
        }

        _announce(text) {
          this.invariantEl.textContent = text;
        }

        _checkInvariant() {
          try {
            LL._invariants();
            this.invariantEl.textContent = "Invariants OK";
            this.invariantEl.style.color = "var(--success)";
          } catch (e) {
            this.invariantEl.textContent = "Invariant failed: " + e.message;
            this.invariantEl.style.color = "var(--danger)";
          }
        }

        _runTests() {
          const passAll = [];
          try {
            // save initial state
            const saved = LL.cloneState();
            // Test 1: push/unshift/insert/remove/clear equality
            LL.clear();
            LL.push(1);
            LL.push(2);
            LL.unshift(0); // list = 0,1,2
            if (!LL.equalsSnapshot([0, 1, 2])) passAll.push("Test1 failed");
            LL.insertAt(1, 5); // 0,5,1,2
            if (!LL.equalsSnapshot([0, 5, 1, 2])) passAll.push("Test2 failed");
            LL.removeAt(2); // 0,5,2
            if (!LL.equalsSnapshot([0, 5, 2])) passAll.push("Test3 failed");
            LL.deleteValue(5);
            if (!LL.equalsSnapshot([0, 2])) passAll.push("Test4 failed");
            LL.reverse();
            if (!LL.equalsSnapshot([2, 0])) passAll.push("Test5 failed");
            LL.clear();
            if (!LL.equalsSnapshot([])) passAll.push("Test6 failed");
            // restore
            LL.restoreState(saved);
          } catch (e) {
            passAll.push("Exception: " + e.message);
          }
          const res =
            passAll.length === 0 ? "PASS" : "FAIL: " + passAll.join("; ");
          this._announce("Tests: " + res);
          const inspector = document.querySelector("ll-inspector");
          inspector.log("Tests completed: " + res);
        }
      }
      customElements.define("ll-controls", LLControls);

      /* Initialize Animator and connect components */
      window.addEventListener("DOMContentLoaded", () => {
        const visual = document.querySelector("ll-visualizer");
        const inspector = document.querySelector("ll-inspector");
        animator = new Animator(visual, inspector);
        // connect visualizer to global events
        E.on("visual:update", (snap) => visual.setSnapshot(snap));
        // ensure initial snapshot
        visual.setSnapshot(LL.toSnapshot());
      });

      /* Expose for debugging (optional) */
      window._LL = LL;
      window._animator = () => animator;

      /* Accessibility: announce keyboard shortcuts */
      const help = document.createElement("div");
      help.style.position = "fixed";
      help.style.right = "12px";
      help.style.bottom = "12px";
      help.style.padding = "8px 10px";
      help.style.borderRadius = "8px";
      help.style.background = "var(--card)";
      help.style.boxShadow = "var(--shadow)";
      help.style.fontSize = "13px";
      help.setAttribute("aria-hidden", "true");
      help.innerHTML =
        '<strong>Shortcuts</strong><div style="margin-top:6px">P Play · . Step · R Reset · Z Undo · Y Redo</div>';
      document.body.appendChild(help);
    </script>
  </body>
</html>
