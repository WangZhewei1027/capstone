<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>K-means Clustering Interactive Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 12px; color: #111; }
  h1 { font-size: 20px; margin: 0 0 8px 0; }
  .container { display: flex; gap: 12px; align-items: flex-start; }
  #canvasWrap { border: 1px solid #ddd; position: relative; background: linear-gradient(180deg,#fff,#f8fbff); }
  canvas { display: block; }
  .controls { width: 320px; }
  .controls section { background: #fff; padding: 10px; border: 1px solid #eee; margin-bottom: 10px; border-radius: 6px; }
  label { display: block; font-size: 13px; margin: 6px 0 4px; }
  input[type="range"] { width: 100%; }
  input[type="number"] { width: 80px; }
  button { margin: 6px 6px 6px 0; padding: 6px 10px; }
  .small { font-size: 13px; color: #444; }
  #ssePlot { width: 100%; height: 80px; border: 1px solid #eee; background: #fafafa; }
  .footer { font-size: 12px; color: #666; margin-top: 6px; }
  .inline { display: inline-block; vertical-align: middle; }
</style>
</head>
<body>
<h1>K-means Clustering — Interactive Demo</h1>
<div class="container">
  <div id="canvasWrap">
    <canvas id="plot" width="700" height="500"></canvas>
  </div>

  <div class="controls">
    <section>
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <strong>Controls</strong>
        <div class="small" id="status">Points: 0 • K: 3 • Iter: 0 • SSE: 0.00</div>
      </div>

      <label>Choose K (<span id="kLabel">3</span>)</label>
      <input type="range" id="kRange" min="1" max="12" value="3" />
      <div style="margin-top:6px;">
        <label class="inline"><input type="radio" name="init" value="random" checked> Random init</label>
        <label style="margin-left:10px;" class="inline"><input type="radio" name="init" value="kpp"> K-means++</label>
      </div>

      <div style="margin-top:8px;">
        <button id="initBtn">Initialize Centroids</button>
        <button id="stepBtn">Step</button>
        <button id="runBtn">Run</button>
        <button id="pauseBtn" disabled>Pause</button>
        <button id="resetBtn">Clear</button>
      </div>

      <label style="margin-top:8px;">Algorithm settings</label>
      <div class="small">
        Max iterations: <input id="maxIter" type="number" min="1" value="100" style="width:60px"> &nbsp;
        Tolerance: <input id="tol" type="number" step="0.001" value="0.001" style="width:70px">
      </div>
    </section>

    <section>
      <strong>Dataset</strong>
      <div style="margin-top:6px;">
        Click on the canvas to add points. Hold Shift and drag to create many.
      </div>

      <label style="margin-top:8px;">Generate random points</label>
      <div>
        N: <input id="randN" type="number" value="100" min="1" style="width:70px"> &nbsp;
        <button id="genBtn">Generate</button>
        <button id="clusterGenBtn">Generate + Init</button>
      </div>

      <div style="margin-top:8px;">
        <button id="nextBatchBtn">Add 50 random</button>
        <button id="removeBtn">Remove last</button>
      </div>
    </section>

    <section>
      <strong>Visualization</strong>
      <div style="margin-top:6px;">
        <label><input type="checkbox" id="showLabels" checked> Show point labels/colors</label>
        <label style="margin-left:8px;"><input type="checkbox" id="drawLines"> Draw point->centroid lines</label>
        <label style="margin-left:8px;"><input type="checkbox" id="showCentroidLabels" checked> Centroid IDs</label>
      </div>
      <div class="small" style="margin-top:6px;">
        You can drag centroids (click near a centroid) to reposition them manually.
      </div>
    </section>

    <section>
      <strong>Metrics</strong>
      <div style="margin-top:6px;">
        <div>SSE (sum squared error): <span id="sseVal">0.00</span></div>
        <div>Iteration history (SSE):</div>
        <canvas id="ssePlot"></canvas>
      </div>
    </section>

    <div class="footer">Simple in-browser K-means demo. Try different K and initialization to see different results.</div>
  </div>
</div>

<script>
// K-means interactive demo
const canvas = document.getElementById('plot');
const ctx = canvas.getContext('2d');
const sseCanvas = document.getElementById('ssePlot');
sseCanvas.width = 300;
sseCanvas.height = 80;
const sseCtx = sseCanvas.getContext('2d');

let points = []; // {x,y}
let labels = []; // cluster index per point or -1
let centroids = []; // {x,y}
let K = parseInt(document.getElementById('kRange').value);
let iteration = 0;
let sseHistory = [];
let running = false;
let animationTimer = null;
let dragging = null; // {type:'centroid'|'point', idx}
let shiftDrag = false;
let lastMouse = null;

// Colors: generate via HSL for good separation
function colorFor(i) {
  const hue = (i * 89) % 360; // varied step
  return `hsl(${hue} 70% 50%)`;
}

function updateStatus() {
  document.getElementById('status').innerText =
    `Points: ${points.length} • K: ${K} • Iter: ${iteration} • SSE: ${sseHistory.length? sseHistory[sseHistory.length-1].toFixed(2): '0.00'}`;
  document.getElementById('kLabel').innerText = K;
  document.getElementById('sseVal').innerText = sseHistory.length? sseHistory[sseHistory.length-1].toFixed(2) : '0.00';
}

// Euclidean distance squared
function dist2(a,b) { const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

// Random helpers
function randRange(min,max) { return min + Math.random()*(max-min); }

function clear() {
  points = [];
  labels = [];
  centroids = [];
  iteration = 0;
  sseHistory = [];
  running = false;
  stopAnimation();
  updateStatus();
  draw();
}

function draw() {
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background grid
  ctx.save();
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.restore();

  // draw assignment lines (optional)
  const drawLines = document.getElementById('drawLines').checked;

  // draw points
  for (let i=0;i<points.length;i++) {
    const p = points[i];
    const label = labels[i];
    if (label >= 0) {
      ctx.fillStyle = colorFor(label);
      ctx.strokeStyle = colorFor(label);
    } else {
      ctx.fillStyle = '#999';
      ctx.strokeStyle = '#999';
    }
    ctx.beginPath();
    ctx.arc(p.x,p.y,4,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.stroke();
    // lines
    if (drawLines && label>=0 && centroids[label]) {
      ctx.strokeStyle = hexToRgba(colorFor(label),0.25);
      ctx.beginPath();
      ctx.moveTo(p.x,p.y);
      ctx.lineTo(centroids[label].x, centroids[label].y);
      ctx.stroke();
    }
    if (document.getElementById('showLabels').checked && label>=0) {
      ctx.font = '12px system-ui, Arial';
      ctx.fillStyle = '#222';
      ctx.fillText(String(label), p.x+6, p.y-6);
    }
  }

  // draw centroids
  for (let k=0;k<centroids.length;k++) {
    const c = centroids[k];
    ctx.beginPath();
    ctx.fillStyle = colorFor(k);
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.arc(c.x,c.y,9,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();
    // inner mark
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.arc(c.x,c.y,3,0,Math.PI*2);
    ctx.fill();
    if (document.getElementById('showCentroidLabels').checked) {
      ctx.font = '13px system-ui, Arial';
      ctx.fillStyle = '#111';
      ctx.fillText('C'+k, c.x+12, c.y+5);
    }
  }

  // optional bounding
  ctx.strokeStyle = "#eee";
  ctx.strokeRect(0,0,canvas.width,canvas.height);
}

// convert CSS hsl to rgba with alpha for lines
function hexToRgba(hsl, a) {
  // hsl in form "hsl(H S% L%)"
  const m = hsl.match(/hsl\((\d+)\s+([\d.]+)%\s+([\d.]+)%\)/);
  if (!m) return `rgba(100,100,100,${a})`;
  const H = +m[1], S = +m[2]/100, L = +m[3]/100;
  // convert HSL to RGB
  const C = (1 - Math.abs(2*L-1)) * S;
  const X = C * (1 - Math.abs((H/60)%2 - 1));
  const m2 = L - C/2;
  let r=0,g=0,b=0;
  if (0<=H && H<60) { r=C; g=X; b=0; }
  else if (60<=H && H<120) { r=X; g=C; b=0; }
  else if (120<=H && H<180) { r=0; g=C; b=X; }
  else if (180<=H && H<240) { r=0; g=X; b=C; }
  else if (240<=H && H<300) { r=X; g=0; b=C; }
  else { r=C; g=0; b=X; }
  r = Math.round((r+m2)*255);
  g = Math.round((g+m2)*255);
  b = Math.round((b+m2)*255);
  return `rgba(${r},${g},${b},${a})`;
}

// Assign points to nearest centroid
function assign() {
  if (centroids.length===0) {
    labels = new Array(points.length).fill(-1);
    return;
  }
  for (let i=0;i<points.length;i++) {
    let best = -1, bestd = Infinity;
    for (let k=0;k<centroids.length;k++) {
      const d = dist2(points[i], centroids[k]);
      if (d < bestd) { bestd = d; best = k; }
    }
    labels[i] = best;
  }
}

// Update centroids to means; return max movement (L2)
function updateCentroids() {
  const sums = new Array(K).fill(0).map(()=>({x:0,y:0,count:0}));
  for (let i=0;i<points.length;i++) {
    const l = labels[i];
    if (l>=0) {
      sums[l].x += points[i].x;
      sums[l].y += points[i].y;
      sums[l].count += 1;
    }
  }
  let maxMove = 0;
  for (let k=0;k<K;k++) {
    if (sums[k].count > 0) {
      const nx = sums[k].x / sums[k].count;
      const ny = sums[k].y / sums[k].count;
      const move = Math.hypot(nx - centroids[k].x, ny - centroids[k].y);
      centroids[k].x = nx;
      centroids[k].y = ny;
      if (move > maxMove) maxMove = move;
    } else {
      // empty cluster: reinitialize to a random point or random position
      if (points.length>0) {
        const idx = Math.floor(Math.random()*points.length);
        centroids[k].x = points[idx].x + randRange(-5,5);
        centroids[k].y = points[idx].y + randRange(-5,5);
      } else {
        centroids[k].x = randRange(10, canvas.width-10);
        centroids[k].y = randRange(10, canvas.height-10);
      }
      // this is a possibly large move
      maxMove = Math.max(maxMove, 999);
    }
  }
  return maxMove;
}

function computeSSE() {
  let sse = 0;
  for (let i=0;i<points.length;i++) {
    const l = labels[i];
    if (l>=0) sse += dist2(points[i], centroids[l]);
  }
  return sse;
}

// one k-means iteration: assign + update
function kmeansStep() {
  if (centroids.length === 0 || points.length === 0) return false;
  assign();
  const prevCentroids = centroids.map(c=>({x:c.x,y:c.y}));
  const maxMove = updateCentroids();
  iteration += 1;
  const sse = computeSSE();
  sseHistory.push(sse);
  updateStatus();
  drawSSE();
  draw();
  const tol = parseFloat(document.getElementById('tol').value) || 0.001;
  if (maxMove <= tol) {
    // converged
    running = false;
    stopAnimation();
    return true;
  }
  const maxIter = parseInt(document.getElementById('maxIter').value) || 100;
  if (iteration >= maxIter) { running=false; stopAnimation(); return true; }
  return false;
}

// init centroids randomly or kmeans++
function initializeCentroids(method='random') {
  K = Math.max(1, parseInt(document.getElementById('kRange').value));
  centroids = [];
  labels = new Array(points.length).fill(-1);
  if (method === 'kpp' && points.length>0) {
    // k-means++ initialization
    // pick first centroid uniformly
    const idx0 = Math.floor(Math.random()*points.length);
    centroids.push({x: points[idx0].x, y: points[idx0].y});
    while (centroids.length < K) {
      // compute distances to nearest centroid
      const d2 = points.map(p => {
        let best = Infinity;
        for (let c of centroids) {
          const dx = p.x-c.x, dy = p.y-c.y;
          const dd = dx*dx + dy*dy;
          if (dd < best) best = dd;
        }
        return best;
      });
      // weighted pick
      const sum = d2.reduce((a,b)=>a+b,0);
      if (sum === 0) {
        // all points equal, just add random
        centroids.push({x: randRange(10,canvas.width-10), y: randRange(10,canvas.height-10)});
        continue;
      }
      let r = Math.random()*sum;
      let chosen = 0;
      for (let i=0;i<d2.length;i++) {
        r -= d2[i];
        if (r <= 0) { chosen = i; break; }
      }
      centroids.push({x: points[chosen].x, y: points[chosen].y});
    }
  } else {
    // random positions (or choose random points if dataset exists)
    if (points.length >= K) {
      // choose K random distinct points as centroids (good default)
      const idxs = [];
      while (idxs.length < K) {
        const r = Math.floor(Math.random()*points.length);
        if (!idxs.includes(r)) idxs.push(r);
      }
      for (let i=0;i<idxs.length;i++) {
        const p = points[idxs[i]];
        centroids.push({x: p.x + randRange(-2,2), y: p.y + randRange(-2,2)});
      }
    } else {
      for (let i=0;i<K;i++) centroids.push({x: randRange(10,canvas.width-10), y: randRange(10,canvas.height-10)});
    }
  }
  iteration = 0;
  sseHistory = [];
  updateStatus();
  draw();
}

// Run animation loop of steps
function run() {
  if (running) return;
  running = true;
  document.getElementById('runBtn').disabled = true;
  document.getElementById('pauseBtn').disabled = false;
  const fps = 8; // steps per second
  animationTimer = setInterval(()=>{
    const finished = kmeansStep();
    if (finished) { running = false; stopAnimation(); }
  }, 1000/fps);
}
function stopAnimation() {
  if (animationTimer) { clearInterval(animationTimer); animationTimer = null; }
  document.getElementById('runBtn').disabled = false;
  document.getElementById('pauseBtn').disabled = true;
  running = false;
}

// draw SSE history small plot
function drawSSE() {
  const w = sseCanvas.width, h = sseCanvas.height;
  sseCtx.clearRect(0,0,w,h);
  sseCtx.fillStyle = '#fff';
  sseCtx.fillRect(0,0,w,h);
  sseCtx.strokeStyle = '#ddd';
  sseCtx.strokeRect(0,0,w,h);
  if (sseHistory.length===0) return;
  const max = Math.max(...sseHistory);
  const min = Math.min(...sseHistory);
  sseCtx.beginPath();
  sseCtx.lineWidth = 2;
  sseCtx.strokeStyle = '#2b6df6';
  for (let i=0;i<sseHistory.length;i++) {
    const x = (i/(sseHistory.length-1 || 1))*(w-6)+3;
    const t = (sseHistory[i] - min) / (max - min || 1);
    const y = h - 4 - t*(h-8);
    if (i===0) sseCtx.moveTo(x,y); else sseCtx.lineTo(x,y);
  }
  sseCtx.stroke();
}

// mouse interactions: add points, shift-drag to add many, drag centroids
canvas.addEventListener('mousedown',(e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  lastMouse = {x,y};
  shiftDrag = e.shiftKey;
  // check if near any centroid
  for (let k=0;k<centroids.length;k++) {
    const c = centroids[k];
    if (Math.hypot(c.x-x,c.y-y) <= 12) {
      dragging = {type:'centroid', idx:k, offsetX: c.x-x, offsetY: c.y-y};
      return;
    }
  }
  // not dragging centroid: add a point
  if (e.button === 0) {
    points.push({x,y});
    labels.push(-1);
    updateStatus();
    draw();
    // if shift, enable continuous draw
    if (shiftDrag) dragging = {type:'brush'}; 
  }
});

canvas.addEventListener('mousemove',(e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if (!dragging) return;
  if (dragging.type === 'centroid') {
    const k = dragging.idx;
    centroids[k].x = x + dragging.offsetX;
    centroids[k].y = y + dragging.offsetY;
    // update assignment and metrics in real-time
    assign();
    const sse = centroids.length? computeSSE() : 0;
    if (sseHistory.length===0) sseHistory.push(sse); else sseHistory[sseHistory.length-1] = sse;
    updateStatus();
    drawSSE();
    draw();
  } else if (dragging.type === 'brush') {
    // add points along the mouse move
    const last = lastMouse || {x,y};
    const dx = x - last.x, dy = y - last.y;
    const dist = Math.hypot(dx,dy);
    const steps = Math.max(1, Math.ceil(dist / 6));
    for (let i=0;i<steps;i++) {
      const px = last.x + dx*(i/steps);
      const py = last.y + dy*(i/steps);
      points.push({x:px,y:py});
      labels.push(-1);
    }
    lastMouse = {x,y};
    updateStatus();
    draw();
  }
});

canvas.addEventListener('mouseup',(e)=>{
  dragging = null;
  lastMouse = null;
});

canvas.addEventListener('mouseleave',(e)=>{
  // stop brush when leaving
  dragging = null;
  lastMouse = null;
});

// UI element bindings
document.getElementById('kRange').addEventListener('input',(e)=>{
  document.getElementById('kLabel').innerText = e.target.value;
});
document.getElementById('kRange').addEventListener('change',(e)=>{
  K = Math.max(1, parseInt(e.target.value));
  // update centroids array size if needed
  if (centroids.length > K) centroids = centroids.slice(0,K);
  iteration = 0;
  sseHistory = [];
  updateStatus();
  draw();
});

document.getElementsByName('init').forEach(r=>{
  r.addEventListener('change', ()=>{/* nothing */});
});

document.getElementById('initBtn').addEventListener('click',()=>{
  const method = document.querySelector('input[name="init"]:checked').value;
  initializeCentroids(method === 'kpp' ? 'kpp' : 'random');
});

document.getElementById('stepBtn').addEventListener('click',()=>{
  if (centroids.length === 0) initializeCentroids(document.querySelector('input[name="init"]:checked').value === 'kpp' ? 'kpp':'random');
  kmeansStep();
});

document.getElementById('runBtn').addEventListener('click', ()=>{
  if (centroids.length === 0) initializeCentroids(document.querySelector('input[name="init"]:checked').value === 'kpp' ? 'kpp':'random');
  run();
});
document.getElementById('pauseBtn').addEventListener('click', ()=>{
  stopAnimation();
});

document.getElementById('resetBtn').addEventListener('click', clear);

document.getElementById('genBtn').addEventListener('click', ()=>{
  const n = Math.max(1, parseInt(document.getElementById('randN').value));
  for (let i=0;i<n;i++) {
    const x = randRange(10, canvas.width-10);
    const y = randRange(10, canvas.height-10);
    points.push({x,y});
    labels.push(-1);
  }
  updateStatus();
  draw();
});

document.getElementById('clusterGenBtn').addEventListener('click', ()=>{
  const n = Math.max(1, parseInt(document.getElementById('randN').value));
  for (let i=0;i<n;i++) {
    const x = randRange(10, canvas.width-10);
    const y = randRange(10, canvas.height-10);
    points.push({x,y});
    labels.push(-1);
  }
  updateStatus();
  // initialize right away
  const method = document.querySelector('input[name="init"]:checked').value;
  initializeCentroids(method === 'kpp' ? 'kpp' : 'random');
  draw();
});

document.getElementById('nextBatchBtn').addEventListener('click', ()=>{
  for (let i=0;i<50;i++) {
    points.push({x: randRange(10, canvas.width-10), y: randRange(10, canvas.height-10)});
    labels.push(-1);
  }
  updateStatus(); draw();
});

document.getElementById('removeBtn').addEventListener('click', ()=>{
  if (points.length) {
    points.pop();
    labels.pop();
    updateStatus();
    draw();
  }
});

// keyboard: space to step, r to run/pause, c to clear
document.addEventListener('keydown',(e)=>{
  if (e.key === ' ') { e.preventDefault(); document.getElementById('stepBtn').click(); }
  if (e.key.toLowerCase() === 'r') { if (running) document.getElementById('pauseBtn').click(); else document.getElementById('runBtn').click(); }
  if (e.key.toLowerCase() === 'c') { document.getElementById('resetBtn').click(); }
});

// initialize small demo data
function seedDemo() {
  // generate a few Gaussian clusters
  function gauss(cx,cy, n) {
    for (let i=0;i<n;i++) {
      const angle = Math.random()*Math.PI*2;
      const r = Math.sqrt(Math.random()) * 40;
      const x = cx + Math.cos(angle)*r + randRange(-6,6);
      const y = cy + Math.sin(angle)*r + randRange(-6,6);
      points.push({x,y});
      labels.push(-1);
    }
  }
  gauss(150,150,60);
  gauss(420,130,50);
  gauss(320,350,70);
  updateStatus();
  draw();
}
seedDemo();

// On load, center update
updateStatus();
draw();

</script>
</body>
</html>