<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Interactive Linked List Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#0f1724; --panel:#0b1320; --accent:#06b6d4;
    --muted:#9aa7b2; --card:#071021;
  }
  body{ margin:0; font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial; background:linear-gradient(180deg,#071022 0%, #021224 100%); color:#e6eef3; }
  header{ padding:18px 24px; display:flex; gap:16px; align-items:center; background:linear-gradient(90deg, rgba(6,182,212,0.06), rgba(0,0,0,0.02)); box-shadow:0 2px 10px rgba(2,6,23,0.6); }
  h1{ font-size:18px; margin:0; color:var(--accent); }
  p.desc{ margin:0; color:var(--muted); font-size:13px; opacity:0.95; }
  main{ display:flex; gap:18px; padding:18px; height:calc(100vh - 72px); box-sizing:border-box; }
  .left{ width:360px; min-width:260px; background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent); border-radius:12px; padding:14px; box-shadow:0 8px 30px rgba(2,6,23,0.6); overflow:auto; }
  .right{ flex:1; background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent); border-radius:12px; padding:14px; position:relative; overflow:auto; }
  label{ display:block; font-size:13px; color:var(--muted); margin:10px 0 6px; }
  input[type="text"], input[type="number"], select{ width:100%; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:var(--muted); box-sizing:border-box; }
  .row{ display:flex; gap:8px; align-items:center; }
  button{ background:linear-gradient(90deg,var(--accent),#0ea5a1); color:#042022; border:none; padding:8px 10px; border-radius:8px; font-weight:600; cursor:pointer; box-shadow:0 6px 18px rgba(2,6,23,0.35); }
  button.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted); box-shadow:none; }
  .controls{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  .small{ padding:6px 8px; font-size:13px; border-radius:8px; }
  .card{ background:rgba(255,255,255,0.02); border-radius:10px; padding:10px; margin-top:12px; }
  pre{ margin:0; background:transparent; color:#cde; font-size:13px; overflow:auto; max-height:200px; }
  .footer{ font-size:12px; color:var(--muted); margin-top:10px; }
  /* SVG canvas */
  #canvas{ width:100%; height:100%; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); }
  .info{ font-size:13px; color:var(--muted); margin-top:8px; }
  .muted{ color:var(--muted); font-size:13px; }
  .badge{ display:inline-block; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.02); color:var(--muted); font-size:12px; }
  .clearfix{ clear:both; }
  /* Legend */
  .legend{ display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
  .legend .item{ display:flex; gap:8px; align-items:center; font-size:13px; color:var(--muted); }
  .swatch{ width:18px; height:18px; border-radius:6px; box-shadow:inset 0 -2px 6px rgba(0,0,0,0.5); }
  /* responsive */
  @media (max-width:860px){
    main{ flex-direction:column; height:auto; padding-bottom:80px; }
    .left{ width:100%; }
    .right{ width:100%; min-height:360px; }
  }
</style>
</head>
<body>
<header>
  <div style="flex:1">
    <h1>Linked List — Interactive Demo</h1>
    <p class="desc">Visualize and experiment with a singly linked list: insertion, deletion, search, reverse and traversal.</p>
  </div>
  <div style="text-align:right">
    <div class="badge">Singly Linked List</div>
  </div>
</header>

<main>
  <section class="left">
    <div style="display:flex; gap:8px; align-items:center;">
      <input id="valInput" type="text" placeholder="Node value (e.g., 42)" />
      <button id="pushBtn" class="small">Append</button>
      <button id="unshiftBtn" class="small">Prepend</button>
    </div>

    <label>Insert at index</label>
    <div style="display:flex; gap:8px;">
      <input id="idxInput" type="number" placeholder="index" min="0" />
      <button id="insertAtBtn" class="small">Insert</button>
      <button id="removeAtBtn" class="small ghost">Remove at</button>
    </div>

    <label>Remove/search by value</label>
    <div style="display:flex; gap:8px;">
      <input id="val2Input" type="text" placeholder="value" />
      <button id="removeValBtn" class="small ghost">Remove value</button>
      <button id="findBtn" class="small ghost">Find</button>
    </div>

    <div class="controls">
      <button id="traverseBtn" class="small">Traverse (animate)</button>
      <button id="reverseBtn" class="small">Reverse</button>
      <button id="clearBtn" class="small ghost">Clear</button>
      <button id="randomBtn" class="small">Random</button>
      <button id="fillBtn" class="small ghost">Fill Example</button>
    </div>

    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <div class="muted">List state</div>
          <div id="stats" style="font-weight:700; margin-top:6px;">Length: 0 — Head: null — Tail: null</div>
        </div>
        <div style="text-align:right">
          <div class="muted">Speed</div>
          <input id="speed" type="range" min="200" max="1500" value="700" style="width:120px"/>
        </div>
      </div>
      <div class="info">
        Use the controls to modify the linked list. Animations highlight nodes as operations traverse pointers.
      </div>
      <div style="margin-top:10px;">
        <div class="legend">
          <div class="item"><div class="swatch" style="background:#0ea5a1"></div> Active / new node</div>
          <div class="item"><div class="swatch" style="background:#1e293b"></div> Normal node</div>
          <div class="item"><div class="swatch" style="background:#bfdbfe"></div> Highlighted pointer</div>
        </div>
      </div>
    </div>

    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div class="muted">Pseudo-code (insert at end)</div>
        <div class="muted">O(n)</div>
      </div>
      <pre id="pseudocode">
// Append (push)
newNode = Node(value)
if head == null:
  head = newNode
else:
  tail.next = newNode
tail = newNode
length++
      </pre>
    </div>

    <div class="card">
      <div class="muted">Complexities (Singly Linked List)</div>
      <pre>
Access:  O(n)
Search:  O(n)
Insert (head): O(1)
Insert (tail): O(1) if tail ref known, else O(n)
Delete:  O(n)
      </pre>
    </div>

    <div class="footer">Tip: Try inserting at index 0 (prepend), or reversing the list to see pointers flip.</div>
  </section>

  <section class="right">
    <svg id="canvas" viewBox="0 0 1200 500" preserveAspectRatio="xMidYMid meet"></svg>
    <div style="position:absolute; right:20px; top:20px; text-align:right;">
      <div class="muted">Visualization</div>
      <div style="font-weight:700; margin-top:6px;" id="operationLabel">Ready</div>
    </div>
  </section>
</main>

<script>
/*
  Interactive singly linked list visualizer
  - Maintains a JS linked list (head, tail, length)
  - Draws nodes as boxes with arrows in an SVG canvas
  - Animates traversal, insertions, deletions, and reversal
*/

// Basic linked list implementation
class Node {
  constructor(value){
    this.value = value;
    this.next = null;
    this.id = Node._id++;
  }
}
Node._id = 1;

class LinkedList {
  constructor(){
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  push(value){
    const node = new Node(value);
    if(!this.head){ this.head = this.tail = node; }
    else{ this.tail.next = node; this.tail = node; }
    this.length++;
    return node;
  }
  unshift(value){
    const node = new Node(value);
    if(!this.head){ this.head = this.tail = node; }
    else { node.next = this.head; this.head = node; }
    this.length++;
    return node;
  }
  insertAt(index, value){
    if(index < 0) index = 0;
    if(index === 0) return this.unshift(value);
    if(index >= this.length) return this.push(value);
    let prev = this.head;
    for(let i=0;i<index-1;i++) prev = prev.next;
    const node = new Node(value);
    node.next = prev.next;
    prev.next = node;
    this.length++;
    return node;
  }
  removeAt(index){
    if(this.length === 0) return null;
    if(index <= 0){
      const rem = this.head;
      this.head = this.head.next;
      if(!this.head) this.tail = null;
      this.length--;
      return rem;
    }
    if(index >= this.length-1){
      // remove tail
      let prev = this.head;
      while(prev.next && prev.next !== this.tail) prev = prev.next;
      const rem = this.tail;
      if(prev) prev.next = null;
      this.tail = prev ? prev : null;
      if(!this.tail) this.head = null;
      this.length--;
      return rem;
    }
    let prev = this.head;
    for(let i=0;i<index-1;i++) prev = prev.next;
    const rem = prev.next;
    prev.next = rem.next;
    this.length--;
    return rem;
  }
  removeValue(value){
    if(!this.head) return null;
    if(this.head.value == value){
      const rem = this.head;
      this.head = this.head.next;
      if(!this.head) this.tail = null;
      this.length--;
      return rem;
    }
    let prev = this.head;
    while(prev.next && prev.next.value != value) prev = prev.next;
    if(!prev.next) return null;
    const rem = prev.next;
    prev.next = rem.next;
    if(rem === this.tail) this.tail = prev;
    this.length--;
    return rem;
  }
  indexOf(value){
    let idx = 0;
    let cur = this.head;
    while(cur){
      if(cur.value == value) return idx;
      cur = cur.next;
      idx++;
    }
    return -1;
  }
  toArray(){
    const out = [];
    let cur = this.head;
    while(cur){ out.push(cur); cur = cur.next; }
    return out;
  }
  reverse(){
    let prev = null, cur = this.head;
    this.tail = this.head;
    while(cur){
      const nxt = cur.next;
      cur.next = prev;
      prev = cur;
      cur = nxt;
    }
    this.head = prev;
  }
  clear(){
    this.head = this.tail = null;
    this.length = 0;
  }
}

// Visualization helpers
const svg = document.getElementById('canvas');
const NS = "http://www.w3.org/2000/svg";
let list = new LinkedList();
let animating = false;

const config = {
  nodeW: 120, nodeH: 48, gap: 26, startX: 30, startY: 40, speed: 700
};

function setOperation(text){
  document.getElementById('operationLabel').textContent = text;
}

function updateStats(){
  document.getElementById('stats').textContent = `Length: ${list.length} — Head: ${list.head ? list.head.value : 'null'} — Tail: ${list.tail ? list.tail.value : 'null'}`;
}

function clearSvg(){
  while(svg.firstChild) svg.removeChild(svg.firstChild);
}

// draw nodes and arrows
function draw(){
  clearSvg();
  const nodes = list.toArray();
  const totalWidth = nodes.length * (config.nodeW + config.gap);
  let x = config.startX;
  const y = config.startY;
  // defs for arrow marker
  let defs = document.createElementNS(NS,'defs');
  defs.innerHTML = `<marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L10,5 L0,10 z" fill="#9fbad6"/></marker>`;
  svg.appendChild(defs);

  nodes.forEach((node, idx) => {
    // group per node
    const g = document.createElementNS(NS,'g');
    g.setAttribute('data-id', node.id);
    g.setAttribute('transform', `translate(${x},${y})`);
    // rect for value
    const rect = document.createElementNS(NS,'rect');
    rect.setAttribute('x',0); rect.setAttribute('y',0);
    rect.setAttribute('rx',10); rect.setAttribute('ry',10);
    rect.setAttribute('width',config.nodeW); rect.setAttribute('height',config.nodeH);
    rect.setAttribute('fill','#0f1728');
    rect.setAttribute('stroke','#16324a');
    rect.setAttribute('stroke-width','1');
    rect.setAttribute('id','rect-'+node.id);
    // value text
    const txt = document.createElementNS(NS,'text');
    txt.setAttribute('x',10); txt.setAttribute('y',config.nodeH/2 + 6);
    txt.setAttribute('fill','#cfeff6');
    txt.setAttribute('font-size',18);
    txt.textContent = String(node.value);
    // pointer box (small) on right
    const pBoxX = config.nodeW - 36;
    const pBox = document.createElementNS(NS,'rect');
    pBox.setAttribute('x',pBoxX); pBox.setAttribute('y',8);
    pBox.setAttribute('width',28); pBox.setAttribute('height',config.nodeH - 16);
    pBox.setAttribute('rx',6); pBox.setAttribute('ry',6);
    pBox.setAttribute('fill','#082033');
    pBox.setAttribute('stroke','#12323f');
    // append
    g.appendChild(rect); g.appendChild(txt); g.appendChild(pBox);
    svg.appendChild(g);

    // arrow to next (if exists)
    if(node.next){
      const x1 = x + config.nodeW - 8;
      const y1 = y + config.nodeH/2;
      const x2 = x + config.nodeW + config.gap - 12;
      const y2 = y + config.nodeH/2;
      const line = document.createElementNS(NS,'path');
      line.setAttribute('d', `M ${x1} ${y1} C ${x1+18} ${y1} ${x2-18} ${y2} ${x2} ${y2}`);
      line.setAttribute('fill','none');
      line.setAttribute('stroke','#6aa7c6');
      line.setAttribute('stroke-width','2');
      line.setAttribute('marker-end','url(#arrow)');
      line.setAttribute('opacity','0.9');
      line.setAttribute('id','link-'+node.id);
      svg.appendChild(line);
    } else {
      // null label after pointer
      const nx = x + config.nodeW + 10;
      const t = document.createElementNS(NS,'text');
      t.setAttribute('x', nx); t.setAttribute('y', y + config.nodeH/2 + 6);
      t.setAttribute('fill','#9fbad6');
      t.setAttribute('font-size',13);
      t.textContent = 'null';
      svg.appendChild(t);
    }

    // head / tail labels
    if(idx === 0){
      const lab = document.createElementNS(NS,'text');
      lab.setAttribute('x', x + config.nodeW/2); lab.setAttribute('y', y - 10);
      lab.setAttribute('fill','#7ee7e9'); lab.setAttribute('font-size',12);
      lab.setAttribute('text-anchor','middle'); lab.textContent = 'HEAD';
      svg.appendChild(lab);
    }
    if(idx === nodes.length-1){
      const lab2 = document.createElementNS(NS,'text');
      lab2.setAttribute('x', x + config.nodeW/2); lab2.setAttribute('y', y + config.nodeH + 24);
      lab2.setAttribute('fill','#7ee7e9'); lab2.setAttribute('font-size',12);
      lab2.setAttribute('text-anchor','middle'); lab2.textContent = 'TAIL';
      svg.appendChild(lab2);
    }

    x += config.nodeW + config.gap;
  });
}

// helpers to highlight node by index or id
function highlightNode(nodeId, color="#0ea5a1"){
  const rect = document.getElementById('rect-'+nodeId);
  if(rect) rect.setAttribute('fill',color);
}
function unhighlightAll(){
  const rects = svg.querySelectorAll('rect[id^="rect-"]');
  rects.forEach(r => r.setAttribute('fill','#0f1728'));
}

// animate traversal: highlight each node in sequence
async function animateTraverse(callbackPerNode){
  if(animating) return;
  animating = true;
  setOperation('Traversing...');
  const arr = list.toArray();
  for(let i=0;i<arr.length;i++){
    unhighlightAll();
    highlightNode(arr[i].id, '#0ea5a1');
    if(typeof callbackPerNode === 'function') callbackPerNode(arr[i], i);
    await wait(config.speed);
  }
  unhighlightAll();
  animating = false;
  setOperation('Done');
}

// utility wait
function wait(ms){ return new Promise(r => setTimeout(r, ms)); }

// animate insertion at index (visual)
async function animateInsertAt(index, value){
  if(animating) return;
  animating = true;
  setOperation('Inserting...');
  const nodes = list.toArray();
  // create temporary floating node visual
  const tempId = 'temp';
  const tempGroup = document.createElementNS(NS,'g');
  tempGroup.setAttribute('id',tempId);
  tempGroup.setAttribute('transform',`translate(${config.startX},${config.startY - 70})`);
  const trect = document.createElementNS(NS,'rect');
  trect.setAttribute('x',0); trect.setAttribute('y',0);
  trect.setAttribute('rx',10); trect.setAttribute('width',config.nodeW); trect.setAttribute('height',config.nodeH);
  trect.setAttribute('fill','#0ea5a1');
  const ttxt = document.createElementNS(NS,'text');
  ttxt.setAttribute('x',10); ttxt.setAttribute('y',config.nodeH/2 + 6);
  ttxt.setAttribute('fill','#042022'); ttxt.setAttribute('font-size',18);
  ttxt.textContent = String(value);
  tempGroup.appendChild(trect); tempGroup.appendChild(ttxt);
  svg.appendChild(tempGroup);

  // If inserting at head or empty: animate drop into first spot
  if(index <= 0 || nodes.length === 0){
    await animateMove(tempGroup, config.startX, config.startY, config.speed/2);
    // finalize underlying data
    list.insertAt(index, value);
    svg.removeChild(tempGroup);
    draw();
    updateStats();
    animating = false;
    setOperation('Inserted at head');
    return;
  }

  // traverse nodes until (index-1) and highlight
  let targetIdx = Math.min(index-1, nodes.length-1);
  for(let i=0;i<=targetIdx;i++){
    unhighlightAll();
    highlightNode(nodes[i].id, '#0ea5a1');
    // move temp over the node to show traversal
    const targetX = config.startX + i*(config.nodeW + config.gap);
    await animateMove(tempGroup, targetX, config.startY - 70, config.speed/3);
    await wait(80);
  }
  // move to insertion spot (after prev)
  const insertX = config.startX + (targetIdx+1)*(config.nodeW + config.gap);
  await animateMove(tempGroup, insertX, config.startY - 20, config.speed/3);
  await wait(150);
  // commit to data structure
  list.insertAt(index, value);
  svg.removeChild(tempGroup);
  draw();
  updateStats();
  animating = false;
  setOperation(`Inserted at index ${index}`);
}

// animate removal at index
async function animateRemoveAt(index){
  if(animating || list.length===0) return;
  animating = true;
  setOperation('Removing...');
  const nodes = list.toArray();
  if(index <= 0){
    // highlight head and remove
    highlightNode(nodes[0].id, '#f97316');
    await wait(config.speed/2);
    list.removeAt(0);
    draw();
    updateStats();
    animating = false;
    setOperation('Removed head');
    return;
  }
  const targetIdx = Math.min(index, nodes.length-1);
  // traverse to target
  for(let i=0;i<=targetIdx;i++){
    unhighlightAll();
    highlightNode(nodes[i].id, '#f97316');
    await wait(config.speed/3);
  }
  // remove
  list.removeAt(index);
  draw();
  updateStats();
  animating = false;
  setOperation(`Removed at index ${index}`);
}

// animate find by value
async function animateFind(value){
  if(animating) return;
  animating = true;
  setOperation('Searching...');
  const nodes = list.toArray();
  let foundIndex = -1;
  for(let i=0;i<nodes.length;i++){
    unhighlightAll();
    highlightNode(nodes[i].id, '#ffea00');
    await wait(config.speed/2);
    if(String(nodes[i].value) === String(value)){
      foundIndex = i;
      break;
    }
  }
  if(foundIndex >= 0){
    setOperation(`Found at index ${foundIndex}`);
    // keep highlight green
    unhighlightAll();
    highlightNode(nodes[foundIndex].id, '#0ea5a1');
  } else {
    setOperation('Not found');
  }
  animating = false;
}

// animate reversing pointers (visual step-by-step)
async function animateReverse(){
  if(animating || list.length<=1) return;
  animating = true;
  setOperation('Reversing...');
  const nodes = list.toArray();
  // Stepwise: for visualization, we'll show pointer flips by highlighting nodes
  let prev = null;
  let cur = list.head;
  const steps = [];
  // record steps (pairs: node.id, becomes-> prev.id or null)
  while(cur){
    steps.push({id:cur.id, from: cur.next ? cur.next.id : null, to: prev ? prev.id : null});
    prev = cur;
    cur = cur.next;
  }
  // show each step
  for(let i=0;i<steps.length;i++){
    const s = steps[i];
    unhighlightAll();
    highlightNode(s.id, '#0ea5a1');
    // highlight link visually: fade out next arrow and show new arrow (approx)
    const link = svg.querySelector('#link-'+s.id);
    if(link) link.setAttribute('stroke','#bfdbfe');
    await wait(config.speed/2);
  }
  // actually reverse the data
  list.reverse();
  draw();
  updateStats();
  animating = false;
  setOperation('Reversed');
}

// simple move animation for a group element
function animateMove(elem, x, y, duration=400){
  return new Promise(resolve => {
    const start = performance.now();
    const transform = elem.getAttribute('transform') || 'translate(0,0)';
    const match = /translate\(([-\d.]+),\s*([-\d.]+)\)/.exec(transform);
    let sx = match ? parseFloat(match[1]) : 0;
    let sy = match ? parseFloat(match[2]) : 0;
    const dx = x - sx, dy = y - sy;
    function frame(now){
      const t = Math.min(1, (now - start) / duration);
      const nx = sx + dx * easeOutCubic(t);
      const ny = sy + dy * easeOutCubic(t);
      elem.setAttribute('transform', `translate(${nx},${ny})`);
      if(t < 1) requestAnimationFrame(frame); else resolve();
    }
    requestAnimationFrame(frame);
  });
}
function easeOutCubic(t){ return (--t)*t*t+1; }

// wire up controls
document.getElementById('pushBtn').addEventListener('click', async ()=>{
  const v = document.getElementById('valInput').value.trim();
  if(!v) return alert('Enter a value');
  if(animating) return;
  list.push(v);
  draw();
  updateStats();
  setOperation(`Appended ${v}`);
});
document.getElementById('unshiftBtn').addEventListener('click', async ()=>{
  const v = document.getElementById('valInput').value.trim();
  if(!v) return alert('Enter a value');
  if(animating) return;
  list.unshift(v);
  draw();
  updateStats();
  setOperation(`Prepended ${v}`);
});
document.getElementById('insertAtBtn').addEventListener('click', async ()=>{
  const v = document.getElementById('valInput').value.trim();
  let idx = parseInt(document.getElementById('idxInput').value,10);
  if(isNaN(idx)) idx = list.length;
  if(!v) return alert('Enter a value');
  await animateInsertAt(idx, v);
  updateStats();
});
document.getElementById('removeAtBtn').addEventListener('click', async ()=>{
  let idx = parseInt(document.getElementById('idxInput').value,10);
  if(isNaN(idx)) return alert('Enter index to remove');
  await animateRemoveAt(idx);
  updateStats();
});
document.getElementById('removeValBtn').addEventListener('click', async ()=>{
  const v = document.getElementById('val2Input').value.trim();
  if(!v) return alert('Enter a value to remove');
  if(animating) return;
  // find index
  const idx = list.indexOf(v);
  if(idx === -1){ setOperation('Value not found'); return; }
  await animateRemoveAt(idx);
});
document.getElementById('findBtn').addEventListener('click', async ()=>{
  const v = document.getElementById('val2Input').value.trim();
  if(!v) return alert('Enter a value to find');
  await animateFind(v);
});
document.getElementById('traverseBtn').addEventListener('click', async ()=>{
  await animateTraverse();
});
document.getElementById('reverseBtn').addEventListener('click', async ()=>{
  await animateReverse();
});
document.getElementById('clearBtn').addEventListener('click', ()=>{
  if(animating) return;
  list.clear();
  draw();
  updateStats();
  setOperation('Cleared');
});
document.getElementById('randomBtn').addEventListener('click', ()=>{
  if(animating) return;
  list.clear();
  const n = 3 + Math.floor(Math.random()*5);
  for(let i=0;i<n;i++) list.push(Math.floor(Math.random()*99));
  draw();
  updateStats();
  setOperation('Randomized');
});
document.getElementById('fillBtn').addEventListener('click', ()=>{
  if(animating) return;
  list.clear();
  ['A','B','C','D','E'].forEach(x => list.push(x));
  draw();
  updateStats();
  setOperation('Filled example');
});
document.getElementById('speed').addEventListener('input',(e)=>{
  config.speed = parseInt(e.target.value,10);
});

// initial draw
draw();
updateStats();
setOperation('Ready');

/* Keyboard hints: Enter to append */
document.getElementById('valInput').addEventListener('keypress', (e)=>{
  if(e.key === 'Enter') document.getElementById('pushBtn').click();
});

</script>
</body>
</html>