<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>K-Means Clustering — Interactive Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; margin: 0; display:flex; height:100vh; }
  #left { width: 360px; padding:16px; box-sizing:border-box; border-right:1px solid #e6e6e6; background:#fafafa; overflow:auto; }
  #canvas-wrap { flex:1; display:flex; align-items:stretch; justify-content:stretch; position:relative; }
  canvas { width:100%; height:100%; display:block; background: linear-gradient(180deg,#ffffff,#f3f7ff); cursor: crosshair; }
  h1 { margin:0 0 12px 0; font-size:18px; }
  label { display:block; margin:8px 0 4px; font-size:13px; color:#333; }
  input[type=number], select { width:100%; padding:6px 8px; font-size:14px; box-sizing:border-box; }
  .row { display:flex; gap:8px; margin-top:8px; }
  button { padding:8px 10px; font-size:14px; border:1px solid #cfcfcf; background:white; cursor:pointer; border-radius:6px; }
  button.primary { background:#2b78f6; color:white; border-color:#2466d6; }
  button.ghost { background:transparent; border-color:#dcdcdc; }
  .small { padding:6px 8px; font-size:13px; }
  .muted { color:#555; font-size:13px; margin-top:12px; }
  .info { margin-top:12px; font-size:13px; }
  .stat { margin-top:8px; font-size:13px; }
  .palette { display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; }
  .color-sample { width:18px; height:18px; border-radius:3px; border:1px solid rgba(0,0,0,0.08); }
  footer { position:absolute; left:14px; bottom:14px; font-size:12px; color:#666; }
  .hint { font-size:12px; color:#666; margin-top:8px; }
</style>
</head>
<body>
  <div id="left">
    <h1>K-Means Clustering — Interactive Demo</h1>
    <div class="muted">
      Click to add points. Drag points to move. Shift+click to remove nearest point.
    </div>

    <label>Number of clusters (K)</label>
    <input id="k-input" type="number" min="1" value="3">

    <label>Initialization</label>
    <select id="init-select">
      <option value="random">Random (pick K random points)</option>
      <option value="kmeans++" selected>K-means++</option>
    </select>

    <label>Points</label>
    <div class="row">
      <button id="random-points" class="small">Randomize</button>
      <input id="num-points" type="number" min="1" value="100" style="width:80px;">
    </div>

    <label>Controls</label>
    <div class="row">
      <button id="init-btn" class="small">Initialize</button>
      <button id="step-btn" class="small">Step</button>
      <button id="run-btn" class="small primary">Run</button>
      <button id="stop-btn" class="small">Stop</button>
    </div>

    <div class="row" style="margin-top:8px;">
      <button id="clear-btn" class="small ghost">Clear Points</button>
      <button id="reset-btn" class="small ghost">Reset Centroids</button>
    </div>

    <label>Max iterations</label>
    <input id="max-iter" type="number" min="1" value="100">

    <label>Animation speed (ms per iteration)</label>
    <input id="speed" type="number" min="10" value="300">

    <div class="info">
      <div class="stat">Iteration: <span id="iter">0</span></div>
      <div class="stat">SSE (sum squared errors): <span id="sse">0</span></div>
      <div class="stat">Points: <span id="count">0</span></div>
      <div class="stat">Cluster sizes: <span id="sizes">-</span></div>
    </div>

    <div class="hint">Tips: Use K-means++ for better initialization. If a cluster is empty it will be reinitialized randomly.</div>

    <div style="margin-top:12px;">
      Color palette:
      <div class="palette" id="palette"></div>
    </div>

    <div style="margin-top:12px; font-size:13px;">
      Algorithm: assign each point to nearest centroid (Euclidean), then update centroids to mean of assigned points. Repeat until convergence or max iterations.
    </div>

    <footer>Interactive K-means — Click canvas to add, drag to move</footer>
  </div>

  <div id="canvas-wrap">
    <canvas id="canvas"></canvas>
  </div>

<script>
/* Interactive K-means clustering demo (single-file).
   - Click canvas to add points
   - Drag to move points
   - Shift+click to remove nearest
   - Controls to initialize, step, run, stop, randomize
*/

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = canvas.clientWidth * devicePixelRatio;
  canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', resize);
resize();

// UI elements
const kInput = document.getElementById('k-input');
const initSelect = document.getElementById('init-select');
const randomPointsBtn = document.getElementById('random-points');
const numPointsInput = document.getElementById('num-points');
const initBtn = document.getElementById('init-btn');
const stepBtn = document.getElementById('step-btn');
const runBtn = document.getElementById('run-btn');
const stopBtn = document.getElementById('stop-btn');
const clearBtn = document.getElementById('clear-btn');
const resetBtn = document.getElementById('reset-btn');
const maxIterInput = document.getElementById('max-iter');
const speedInput = document.getElementById('speed');

const iterLabel = document.getElementById('iter');
const sseLabel = document.getElementById('sse');
const countLabel = document.getElementById('count');
const sizesLabel = document.getElementById('sizes');
const paletteDiv = document.getElementById('palette');

const width = () => canvas.clientWidth;
const height = () => canvas.clientHeight;

// Colors
const COLORS = [
  "#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"
];
paletteDiv.innerHTML = COLORS.map(c=>`<div class="color-sample" style="background:${c}"></div>`).join('');

// Data structures
let points = []; // {x,y,cluster?}
let centroids = []; // {x,y, oldX?, oldY?}
let assignments = []; // index->cluster
let iteration = 0;
let running = false;
let timer = null;

// Utilities
function rand(min, max){ return Math.random()*(max-min)+min; }
function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

function updateStats(){
  iterLabel.textContent = iteration;
  countLabel.textContent = points.length;
  // SSE
  let sse = 0;
  let sizes = new Array(centroids.length).fill(0);
  for(let i=0;i<points.length;i++){
    const c = assignments[i];
    if(c!=null && centroids[c]) {
      sse += dist2(points[i], centroids[c]);
      sizes[c]++;
    }
  }
  sseLabel.textContent = sse.toFixed(2);
  sizesLabel.textContent = sizes.join(', ');
}

// Drawing
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background grid
  const step = 40;
  ctx.save();
  ctx.globalAlpha = 0.08;
  ctx.strokeStyle = "#ccc";
  for(let x=0;x<width();x+=step){
    ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,height()); ctx.stroke();
  }
  for(let y=0;y<height();y+=step){
    ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(width(),y+0.5); ctx.stroke();
  }
  ctx.restore();

  // draw movement lines (centroid old->new)
  for(let k=0;k<centroids.length;k++){
    const c = centroids[k];
    if(c && c.oldX!=null){
      ctx.beginPath();
      ctx.moveTo(c.oldX, c.oldY);
      ctx.lineTo(c.x, c.y);
      ctx.strokeStyle = hexToRgba(COLORS[k%COLORS.length], 0.6);
      ctx.setLineDash([6,6]);
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  // points (colored by assignment)
  for(let i=0;i<points.length;i++){
    const p = points[i];
    const cidx = assignments[i];
    ctx.beginPath();
    ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
    ctx.fillStyle = cidx==null ? '#999' : COLORS[cidx % COLORS.length];
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.stroke();
  }

  // centroids
  for(let k=0;k<centroids.length;k++){
    const c = centroids[k];
    if(!c) continue;
    const color = COLORS[k % COLORS.length];
    // outer halo
    ctx.beginPath();
    ctx.arc(c.x, c.y, 12, 0, Math.PI*2);
    ctx.fillStyle = hexToRgba(color, 0.12);
    ctx.fill();
    // center square
    ctx.beginPath();
    ctx.rect(c.x-6, c.y-6, 12, 12);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#222';
    ctx.stroke();
    // label
    ctx.font = '12px system-ui, Arial';
    ctx.fillStyle = '#111';
    ctx.fillText('C'+k, c.x+10, c.y-10);
  }
  updateStats();
}

// helper to convert hex to rgba
function hexToRgba(hex, a){
  const h = hex.replace('#','');
  const bigint = parseInt(h,16);
  const r=(bigint>>16)&255, g=(bigint>>8)&255, b=bigint&255;
  return `rgba(${r},${g},${b},${a})`;
}

// Interaction: add, drag, remove
let dragging = null;
let dragOffset = {x:0,y:0};
canvas.addEventListener('mousedown', e=>{
  const pos = getMousePos(e);
  // check if clicking on a point
  const idx = findNearestPoint(pos, 8);
  if(idx!=null && idx!=-1){
    // start dragging
    dragging = idx;
    dragOffset.x = points[idx].x - pos.x;
    dragOffset.y = points[idx].y - pos.y;
    return;
  }
  // otherwise add or remove depending on shift
  if(e.shiftKey){
    // remove nearest
    const near = findNearestPoint(pos, 20);
    if(near!=null && near!=-1){
      points.splice(near,1);
      assignments.splice(near,1);
      draw();
    }
  } else {
    // add point
    points.push({x:pos.x, y:pos.y});
    assignments.push(null);
    draw();
  }
});
window.addEventListener('mousemove', e=>{
  if(dragging!=null){
    const pos = getMousePos(e);
    points[dragging].x = Math.max(0, Math.min(width(), pos.x + dragOffset.x));
    points[dragging].y = Math.max(0, Math.min(height(), pos.y + dragOffset.y));
    draw();
  }
});
window.addEventListener('mouseup', e=>{ dragging = null; });

function getMousePos(e){
  const rect = canvas.getBoundingClientRect();
  return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };
}

function findNearestPoint(pos, maxDist=Infinity){
  if(points.length===0) return -1;
  let best = -1; let bestd = maxDist*maxDist;
  for(let i=0;i<points.length;i++){
    const d = (points[i].x-pos.x)*(points[i].x-pos.x) + (points[i].y-pos.y)*(points[i].y-pos.y);
    if(d < bestd){ best = i; bestd = d; }
  }
  return best;
}

// K-means functions
function initializeCentroids(k, method='kmeans++'){
  centroids = [];
  if(points.length===0){
    // place random centroids in canvas
    for(let i=0;i<k;i++){
      centroids.push({x: rand(30,width()-30), y: rand(30,height()-30)});
    }
    assignments = new Array(points.length).fill(null);
    iteration = 0;
    return;
  }
  if(method==='random'){
    // pick k random points (or randomly in screen if k>points)
    const idxs = [];
    for(let i=0;i<Math.min(k, points.length); i++){
      let r; do { r = Math.floor(Math.random()*points.length); } while(idxs.includes(r));
      idxs.push(r);
      centroids.push({x: points[r].x, y: points[r].y});
    }
    while(centroids.length<k){
      centroids.push({x: rand(30,width()-30), y: rand(30,height()-30)});
    }
  } else {
    // kmeans++ initialization
    // choose first centroid uniformly from points
    const choose = [];
    const n = points.length;
    let idx = Math.floor(Math.random()*n);
    centroids.push({x: points[idx].x, y: points[idx].y});
    while(centroids.length<k){
      // compute D(x)^2 = min distance squared to existing centroids
      const ds = points.map(p => {
        let d = Infinity;
        for(const c of centroids){ const dx=p.x-c.x, dy=p.y-c.y; d = Math.min(d, dx*dx+dy*dy); }
        return d;
      });
      const sum = ds.reduce((a,b)=>a+b,0);
      if(sum===0){
        // all points coincide or centroids cover them; add random points
        centroids.push({x: rand(30,width()-30), y: rand(30,height()-30)});
        continue;
      }
      // choose weighted by ds
      let r = Math.random()*sum;
      let chosen = 0;
      for(let i=0;i<ds.length;i++){
        r -= ds[i];
        if(r <= 0){ chosen = i; break; }
      }
      centroids.push({x: points[chosen].x, y: points[chosen].y});
    }
  }
  assignments = new Array(points.length).fill(null);
  iteration = 0;
}

function assignPoints(){
  let changed = false;
  for(let i=0;i<points.length;i++){
    let best = -1; let bd = Infinity;
    for(let j=0;j<centroids.length;j++){
      const d2 = (points[i].x-centroids[j].x)**2 + (points[i].y-centroids[j].y)**2;
      if(d2 < bd){ bd = d2; best = j; }
    }
    if(assignments[i] !== best){ changed = true; assignments[i] = best; }
  }
  return changed;
}

function updateCentroids(){
  // store old positions for drawing movement
  for(let j=0;j<centroids.length;j++){
    if(!centroids[j]) centroids[j] = {x:rand(10,width()-10), y:rand(10,height()-10)};
    centroids[j].oldX = centroids[j].x;
    centroids[j].oldY = centroids[j].y;
  }
  const sums = centroids.map(()=>({x:0,y:0,count:0}));
  for(let i=0;i<points.length;i++){
    const c = assignments[i];
    if(c==null) continue;
    sums[c].x += points[i].x;
    sums[c].y += points[i].y;
    sums[c].count++;
  }
  for(let j=0;j<centroids.length;j++){
    if(sums[j].count===0){
      // empty cluster: reinitialize to random point
      centroids[j].x = rand(30,width()-30);
      centroids[j].y = rand(30,height()-30);
    } else {
      centroids[j].x = sums[j].x / sums[j].count;
      centroids[j].y = sums[j].y / sums[j].count;
    }
  }
}

// One K-means iteration (assign + update)
function kmeansStep(){
  if(centroids.length===0) return;
  const changed = assignPoints();
  updateCentroids();
  iteration++;
  draw();
  return changed;
}

// Run until convergence or max iterations
function runKmeans(){
  const maxIter = Math.max(1, parseInt(maxIterInput.value)||100);
  const speed = Math.max(5, parseInt(speedInput.value)||200);
  stopKmeans();
  running = true;
  runBtn.disabled = true;
  initBtn.disabled = true;
  stepBtn.disabled = true;
  clearBtn.disabled = true;

  function loop(){
    if(!running) return;
    if(iteration >= maxIter){ stopKmeans(); return; }
    const changed = kmeansStep();
    // if no assignments changed and centroids didn't move much, stop
    // Here we detect change by changed boolean and small centroid movements
    let moved = false;
    for(let c of centroids){
      if(c.oldX==null) { moved = true; break; }
      if(Math.hypot(c.x-c.oldX, c.y-c.oldY) > 1e-3) { moved = true; break; }
    }
    if(!changed && !moved){ stopKmeans(); return; }
    timer = setTimeout(loop, speed);
  }
  loop();
}

function stopKmeans(){
  running = false;
  clearTimeout(timer);
  runBtn.disabled = false;
  initBtn.disabled = false;
  stepBtn.disabled = false;
  clearBtn.disabled = false;
}

// Buttons
initBtn.addEventListener('click', ()=>{
  const k = Math.max(1, parseInt(kInput.value)||1);
  initializeCentroids(k, initSelect.value);
  draw();
});
stepBtn.addEventListener('click', ()=>{
  stopKmeans();
  if(centroids.length===0){
    initializeCentroids(Math.max(1,parseInt(kInput.value)||1), initSelect.value);
  }
  kmeansStep();
});
runBtn.addEventListener('click', ()=>{ runKmeans(); });
stopBtn.addEventListener('click', ()=>{ stopKmeans(); });

randomPointsBtn.addEventListener('click', ()=>{
  points = [];
  assignments = [];
  const n = Math.max(1, parseInt(numPointsInput.value) || 100);
  // generate Gaussian-ish blobs for nicer demonstration
  const clusters = Math.max(2, Math.min(6, Math.floor(Math.random()*5)+2));
  const centers = [];
  for(let i=0;i<clusters;i++){
    centers.push({x: rand(60,width()-60), y: rand(60,height()-60)});
  }
  for(let i=0;i<n;i++){
    const c = centers[Math.floor(Math.random()*centers.length)];
    const r = Math.random()*60;
    const angle = Math.random()*Math.PI*2;
    const x = c.x + Math.cos(angle)*r*0.6 + rand(-8,8);
    const y = c.y + Math.sin(angle)*r*0.6 + rand(-8,8);
    points.push({x: Math.max(6,Math.min(width()-6,x)), y: Math.max(6,Math.min(height()-6,y))});
    assignments.push(null);
  }
  centroids = [];
  iteration = 0;
  draw();
});

clearBtn.addEventListener('click', ()=>{ points=[]; assignments=[]; centroids=[]; iteration=0; draw(); });
resetBtn.addEventListener('click', ()=>{ centroids=[]; assignments = new Array(points.length).fill(null); iteration=0; draw(); });

/* initial example */
(function initDemo(){
  // create a few blobs
  const n = 120;
  const centers = [{x:100,y:120},{x:400,y:80},{x:300,y:320}];
  for(let i=0;i<n;i++){
    const c = centers[i%centers.length];
    const r = Math.random()*50;
    const angle = Math.random()*Math.PI*2;
    points.push({x:c.x + Math.cos(angle)*r + rand(-6,6), y:c.y + Math.sin(angle)*r + rand(-6,6)});
    assignments.push(null);
  }
  updateStats();
  draw();
})();

</script>
</body>
</html>