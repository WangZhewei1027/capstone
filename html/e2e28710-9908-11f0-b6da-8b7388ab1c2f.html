```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means Clustering Demo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #f0f2f5;
            margin: 0;
            padding: 1rem;
        }
        h1 {
            color: #333;
            margin-top: 0;
        }
        .controls {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }
        .controls > div {
            display: flex;
            flex-direction: column;
        }
        label {
            font-size: 0.9em;
            color: #555;
            margin-bottom: 5px;
        }
        input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            color: white;
            background-color: #007bff;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }
        #generateBtn { background-color: #28a745; }
        #generateBtn:hover { background-color: #218838; }
        #resetBtn { background-color: #dc3545; }
        #resetBtn:hover { background-color: #c82333; }
        
        #main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #info {
            margin-top: 10px;
            font-size: 1.1em;
            color: #333;
            min-height: 25px;
        }

        canvas {
            border: 1px solid #ddd;
            background-color: #fff;
            border-radius: 8px;
        }
    </style>
</head>
<body>

    <h1>K-Means Clustering Demo</h1>

    <div class="controls">
        <div>
            <label for="k-input">Clusters (K)</label>
            <input type="number" id="k-input" value="4" min="2" max="20">
        </div>
        <div>
            <label for="points-input">Data Points</label>
            <input type="number" id="points-input" value="300" min="10" max="2000">
        </div>
        <button id="generateBtn">Generate New Data</button>
        <button id="stepBtn">Step</button>
        <button id="runBtn">Run</button>
        <button id="resetBtn">Reset</button>
    </div>

    <div id="main-container">
        <canvas id="canvas" width="800" height="600"></canvas>
        <div id="info">Ready. Generate data to begin.</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // --- DOM Elements ---
        const kInput = document.getElementById('k-input');
        const pointsInput = document.getElementById('points-input');
        const generateBtn = document.getElementById('generateBtn');
        const stepBtn = document.getElementById('stepBtn');
        const runBtn = document.getElementById('runBtn');
        const resetBtn = document.getElementById('resetBtn');
        const infoDiv = document.getElementById('info');

        // --- State Variables ---
        let points = [];
        let centroids = [];
        let k = 4;
        let numPoints = 300;
        let animationFrameId = null;
        let iteration = 0;
        let hasConverged = false;
        let isRunning = false;
        let isInitialized = false;

        const CLUSTER_COLORS = [
            '#FF6347', '#4682B4', '#32CD32', '#FFD700', '#6A5ACD',
            '#FF4500', '#20B2AA', '#DA70D6', '#00FA9A', '#8B4513',
            '#B22222', '#4169E1', '#8FBC8F', '#F0E68C', '#9932CC',
            '#CD5C5C', '#1E90FF', '#98FB98', '#FFDEAD', '#BA55D3'
        ];

        // --- Core Algorithm Functions ---

        function euclideanDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function generateRandomPoints() {
            points = [];
            numPoints = parseInt(pointsInput.value);
            for (let i = 0; i < numPoints; i++) {
                points.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    cluster: -1
                });
            }
        }

        function initializeCentroids() {
            centroids = [];
            k = parseInt(kInput.value);
            const usedIndexes = new Set();
            for (let i = 0; i < k; i++) {
                let randomIndex;
                do {
                    randomIndex = Math.floor(Math.random() * points.length);
                } while (usedIndexes.has(randomIndex));
                usedIndexes.add(randomIndex);
                centroids.push({
                    x: points[randomIndex].x,
                    y: points[randomIndex].y
                });
            }
            isInitialized = true;
        }

        function assignPointsToClusters() {
            let changed = false;
            points.forEach(point => {
                let minDistance = Infinity;
                let closestCentroidIndex = -1;
                centroids.forEach((centroid, index) => {
                    const dist = euclideanDistance(point, centroid);
                    if (dist < minDistance) {
                        minDistance = dist;
                        closestCentroidIndex = index;
                    }
                });
                if (point.cluster !== closestCentroidIndex) {
                    point.cluster = closestCentroidIndex;
                    changed = true;
                }
            });
            return changed;
        }

        function updateCentroids() {
            const clusterSums = Array(k).fill(0).map(() => ({ x: 0, y: 0, count: 0 }));
            
            points.forEach(point => {
                if (point.cluster !== -1) {
                    clusterSums[point.cluster].x += point.x;
                    clusterSums[point.cluster].y += point.y;
                    clusterSums[point.cluster].count++;
                }
            });

            centroids.forEach((centroid, index) => {
                const sum = clusterSums[index];
                if (sum.count > 0) {
                    centroid.x = sum.x / sum.count;
                    centroid.y = sum.y / sum.count;
                }
            });
        }

        function step() {
            if (hasConverged) {
                infoDiv.textContent = `Converged after ${iteration} iterations.`;
                stop();
                return;
            }
            if (!isInitialized) {
                initializeCentroids();
            }

            iteration++;
            infoDiv.textContent = `Iteration: ${iteration}`;
            const changed = assignPointsToClusters();
            if (!changed) {
                hasConverged = true;
                infoDiv.textContent = `Converged after ${iteration} iterations.`;
                stop();
            } else {
                updateCentroids();
            }
            draw();
        }

        function run() {
            if (isRunning) return;
            if (points.length === 0) {
                alert("Please generate data first.");
                return;
            }
            if(hasConverged) {
                infoDiv.textContent = `Already converged after ${iteration} iterations. Reset to run again.`;
                return;
            }
            isRunning = true;
            updateUIState();
            
            function loop() {
                if (!isRunning || hasConverged) {
                    stop();
                    return;
                }
                step();
                animationFrameId = setTimeout(() => requestAnimationFrame(loop), 50); // Delay for visualization
            }
            loop();
        }

        function stop() {
            isRunning = false;
            if (animationFrameId) {
                clearTimeout(animationFrameId);
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            updateUIState();
        }

        // --- Drawing Functions ---

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw points
            points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = point.cluster === -1 ? '#333' : CLUSTER_COLORS[point.cluster % CLUSTER_COLORS.length];
                ctx.fill();
            });

            // Draw centroids
            centroids.forEach((centroid, index) => {
                ctx.beginPath();
                ctx.rect(centroid.x - 7, centroid.y - 7, 14, 14);
                ctx.fillStyle = CLUSTER_COLORS[index % CLUSTER_COLORS.length];
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        // --- UI and Control ---

        function resetState() {
            stop();
            isInitialized = false;
            hasConverged = false;
            iteration = 0;
            points = [];
            centroids = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            infoDiv.textContent = 'Ready. Generate data to begin.';
            updateUIState();
        }

        function setup() {
            resetState();
            generateRandomPoints();
            draw();
            infoDiv.textContent = 'Data generated. Press Step or Run to start clustering.';
        }

        function updateUIState() {
            generateBtn.disabled = isRunning;
            resetBtn.disabled = isRunning;
            stepBtn.disabled = isRunning || hasConverged || points.length === 0;
            runBtn.disabled = isRunning || hasConverged || points.length === 0;
            runBtn.textContent = isRunning ? "Running..." : "Run";
        }

        // --- Event Listeners ---
        generateBtn.addEventListener('click', setup);
        resetBtn.addEventListener('click', setup);
        stepBtn.addEventListener('click', () => {
             if (points.length === 0) {
                alert("Please generate data first.");
                return;
            }
            step();
            updateUIState();
        });
        runBtn.addEventListener('click', run);

        // Initial setup
        window.onload = () => {
            setup();
        };

    </script>
</body>
</html>
```