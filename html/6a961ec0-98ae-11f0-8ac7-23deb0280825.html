<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interactive Bubble Sort Visualizer</title>
<style>
  :root{
    --bg: #0f1724;
    --panel: #0b1220;
    --accent: #00d4ff;
    --muted: #94a3b8;
    --success: #22c55e;
    --danger: #fb7185;
    --glass: rgba(255,255,255,0.03);
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{
    height:100%;
    margin:0;
    background:linear-gradient(180deg,#071024 0%, #061026 60%);
    color: #e6eef8;
  }
  header{
    display:flex;
    gap:16px;
    align-items:center;
    padding:18px 28px;
    background:transparent;
  }
  h1{
    font-size:18px;
    margin:0;
    color:var(--accent);
    letter-spacing:0.6px;
  }
  .app{
    padding:18px 28px;
    display:grid;
    grid-template-columns: 520px 1fr;
    gap:18px;
    align-items:start;
  }
  .left, .right{
    background:var(--panel);
    border-radius:12px;
    padding:14px;
    box-shadow: 0 6px 30px rgba(2,6,23,0.6);
    min-height:320px;
  }
  .left{
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  controls-panel {
    display:block;
    padding:8px;
    background:var(--glass);
    border-radius:10px;
  }
  array-visualizer {
    display:block;
    height:300px;
  }

  .toolbar{
    display:flex;
    gap:8px;
    align-items:center;
  }
  button, .btn {
    background:linear-gradient(180deg,#071827,#04202b);
    color:#e7f4ff;
    border-radius:8px;
    padding:8px 10px;
    border:1px solid rgba(255,255,255,0.04);
    cursor:pointer;
    font-size:13px;
  }
  button.secondary{
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    color:var(--muted);
  }
  .small{
    padding:6px 8px;
    font-size:12px;
  }

  .panel-row{
    display:flex;
    gap:10px;
    align-items:center;
  }
  .range {
    width:100%;
  }
  .code-panel{
    background:#071732;
    padding:12px;
    border-radius:10px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
    font-size:13px;
    line-height:1.5;
    color:#cfefff;
    white-space:pre;
    overflow:auto;
    max-height:420px;
  }

  .line {
    padding:2px 8px;
    border-radius:6px;
    display:block;
  }
  .line.highlight{
    background:linear-gradient(90deg, rgba(0,212,255,0.08), rgba(0,212,255,0.02));
    color:var(--accent);
  }
  .muted {
    color:var(--muted);
    font-size:13px;
  }

  .stats {
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }
  .stat {
    background:linear-gradient(90deg, rgba(255,255,255,0.02), transparent);
    padding:8px;
    border-radius:8px;
    min-width:88px;
    text-align:center;
  }
  .stat .v {
    font-weight:700;
    font-size:16px;
    color:var(--accent);
  }

  footer{
    margin-top:16px;
    color:var(--muted);
    font-size:13px;
  }

  /* Visualizer styles */
  .vis {
    position:relative;
    height:300px;
    display:flex;
    align-items:end;
    gap:8px;
    padding:18px 12px;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    border-radius:10px;
    overflow:hidden;
  }
  .bar {
    --w: 28px;
    width:var(--w);
    background:linear-gradient(180deg,#06b6d4,#0284c7);
    border-radius:6px 6px 4px 4px;
    display:flex;
    align-items:flex-end;
    justify-content:center;
    color:rgba(255,255,255,0.92);
    font-weight:700;
    transform:translateY(0);
    transition: transform 400ms ease, height 400ms ease;
    position:relative;
    box-shadow: 0 8px 20px rgba(0,0,0,0.45);
  }
  .bar .label {
    padding:6px 4px;
    font-size:12px;
    color:rgba(255,255,255,0.95);
    transform:translateY(4px);
  }
  .bar.compare {
    outline:3px solid rgba(255,196,27,0.14);
    box-shadow: 0 10px 28px rgba(255,196,27,0.06);
  }
  .bar.swap {
    outline:4px solid rgba(99,102,241,0.16);
    box-shadow: 0 10px 30px rgba(99,102,241,0.08);
  }
  .bar.sorted {
    background:linear-gradient(180deg,#16a34a,#059669);
  }
  .legend {
    display:flex;
    gap:12px;
    align-items:center;
    font-size:13px;
    color:var(--muted);
  }
  .legend .dot {
    width:12px;height:12px;border-radius:3px;display:inline-block;margin-right:6px;
  }
  .dot.compare { background: rgba(255,196,27,0.85); }
  .dot.swap { background: rgba(99,102,241,0.9); }
  .dot.sorted { background: linear-gradient(180deg,#16a34a,#059669); }

  .explain {
    font-size:13px;
    color:var(--muted);
  }

  /* responsive */
  @media (max-width:980px){
    .app { grid-template-columns: 1fr; padding:14px; }
  }

</style>
</head>
<body>
<header>
  <h1>Bubble Sort â€” Interactive Step-by-Step Visualizer</h1>
</header>

<div class="app">
  <div class="left">
    <controls-panel></controls-panel>
    <array-visualizer></array-visualizer>
    <div class="legend" style="justify-content:space-between">
      <div style="display:flex;gap:12px;align-items:center">
        <div><span class="dot compare"></span> Comparing</div>
        <div><span class="dot swap"></span> Swapping</div>
        <div><span class="dot sorted"></span> Final/Sorted</div>
      </div>
      <div class="explain">Tip: Use Step to advance one operation. Play to animate full sort. Toggle "Optimized" for early exit.</div>
    </div>
  </div>

  <div class="right">
    <div style="display:flex;gap:12px;align-items:flex-start">
      <div style="flex:1">
        <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px">
          <div class="panel-row" style="gap:8px;">
            <label class="muted">Order:</label>
            <select id="orderSelect" style="padding:6px;border-radius:8px;background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04)">
              <option value="asc">Ascending</option>
              <option value="desc">Descending</option>
            </select>
            <label class="muted">Optimized:</label>
            <input type="checkbox" id="optCheckbox" />
          </div>
        </div>

        <div class="stats" style="margin-bottom:10px">
          <div class="stat">
            <div class="muted">Comparisons</div>
            <div id="compCount" class="v">0</div>
          </div>
          <div class="stat">
            <div class="muted">Swaps</div>
            <div id="swapCount" class="v">0</div>
          </div>
          <div class="stat">
            <div class="muted">Pass</div>
            <div id="passCount" class="v">0</div>
          </div>
          <div class="stat">
            <div class="muted">Elements</div>
            <div id="lenCount" class="v">8</div>
          </div>
          <div class="stat">
            <div class="muted">Status</div>
            <div id="status" class="v">idle</div>
          </div>
        </div>

        <div class="panel-row" style="gap:8px;margin-bottom:8px">
          <button id="stepBtn" class="small">Step</button>
          <button id="backBtn" class="small secondary">Back</button>
          <button id="playBtn" class="small">Play</button>
          <button id="pauseBtn" class="small secondary" disabled>Pause</button>
          <button id="resetBtn" class="small secondary">Reset</button>
          <div style="flex:1"></div>
        </div>

        <div style="margin-bottom:10px; display:flex; gap:8px; align-items:center;">
          <label class="muted">Speed</label>
          <input id="speed" class="range" type="range" min="0" max="1000" value="400" />
        </div>
      </div>
    </div>

    <div style="display:flex;gap:12px; margin-top:6px;">
      <div style="flex:1">
        <div class="code-panel" id="codePanel" aria-hidden="false"></div>
      </div>
    </div>

    <footer style="margin-top:10px">This interactive demo illustrates the inner workings of Bubble Sort. You can customize the array, watch comparisons and swaps, and step through the algorithm to understand why it's O(n^2) in the average and worst case.</footer>
  </div>
</div>

<!-- Templates for web components -->
<template id="controls-template">
  <style>
    :host{display:block}
    .wrap{display:flex;flex-direction:column;gap:10px}
    .row{display:flex;gap:8px;align-items:center}
    input[type="text"]{padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);flex:1}
    .mini{font-size:13px;padding:6px 8px}
  </style>
  <div class="wrap">
    <div class="row">
      <label class="muted" style="min-width:72px">Array:</label>
      <input id="arrayInput" type="text" placeholder="e.g. 5,3,8,1,2 or leave blank for random" />
      <button id="apply" class="mini">Apply</button>
    </div>
    <div class="row">
      <label class="muted" style="min-width:72px">Size:</label>
      <input id="size" type="range" min="3" max="20" value="8" />
      <div id="sizeVal" class="muted">8</div>
      <button id="rand" class="mini">Randomize</button>
    </div>
    <div class="row">
      <label class="muted" style="min-width:72px">Values:</label>
      <button id="seed1" class="mini">Easy</button>
      <button id="seed2" class="mini">Reverse</button>
      <button id="seed3" class="mini">Duplicate</button>
    </div>
  </div>
</template>

<template id="visualizer-template">
  <style>
    :host{display:block}
    .visWrap{display:flex;flex-direction:column;gap:8px}
    .vis{height:300px;position:relative}
  </style>
  <div class="visWrap">
    <div class="vis" id="visArea" role="img" aria-label="Array visualization"></div>
  </div>
</template>

<script>
/*
  Bubble Sort Visualizer
  - Uses custom elements: controls-panel, array-visualizer
  - Core logic in the main script: generator for step actions, history snapshots
  - Supports play/pause, step/back, speed control, optimized early exit, ascending/descending
*/

// Utility
const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
const sleep = ms => new Promise(r=>setTimeout(r,ms));

// Controls Panel Component
class ControlsPanel extends HTMLElement {
  constructor(){
    super();
    this.attachShadow({mode:'open'});
    this.shadowRoot.appendChild(document.getElementById('controls-template').content.cloneNode(true));
  }
  connectedCallback(){
    this.arrayInput = this.shadowRoot.querySelector('#arrayInput');
    this.applyBtn = this.shadowRoot.querySelector('#apply');
    this.size = this.shadowRoot.querySelector('#size');
    this.sizeVal = this.shadowRoot.querySelector('#sizeVal');
    this.randBtn = this.shadowRoot.querySelector('#rand');
    this.seed1 = this.shadowRoot.querySelector('#seed1');
    this.seed2 = this.shadowRoot.querySelector('#seed2');
    this.seed3 = this.shadowRoot.querySelector('#seed3');

    this.size.addEventListener('input', ()=> {
      this.sizeVal.textContent = this.size.value;
      this.emit('size-change', {size: Number(this.size.value)});
    });
    this.applyBtn.addEventListener('click', ()=> {
      this.emit('apply-array', {text:this.arrayInput.value});
    });
    this.randBtn.addEventListener('click', ()=> {
      this.emit('randomize', {size: Number(this.size.value)});
    });
    this.seed1.addEventListener('click', ()=> {
      this.emit('preset', {type: 'easy', size: Number(this.size.value)});
    });
    this.seed2.addEventListener('click', ()=> {
      this.emit('preset', {type: 'reverse', size: Number(this.size.value)});
    });
    this.seed3.addEventListener('click', ()=> {
      this.emit('preset', {type: 'duplicates', size: Number(this.size.value)});
    });
  }
  emit(name, detail){
    this.dispatchEvent(new CustomEvent(name, {detail, bubbles:true, composed:true}));
  }
}
customElements.define('controls-panel', ControlsPanel);

// Array Visualizer Component
class ArrayVisualizer extends HTMLElement {
  constructor(){
    super();
    this.attachShadow({mode:'open'});
    this.shadowRoot.appendChild(document.getElementById('visualizer-template').content.cloneNode(true));
    this.container = this.shadowRoot.getElementById('visArea');
    this.bars = [];
    this.positions = []; // maps index -> x position
  }

  setArray(arr){
    this.array = arr.slice();
    this.render();
  }

  // Create bars
  render(){
    const n = this.array.length;
    this.container.innerHTML = '';
    this.bars = [];
    const gap = 8;
    const totalGap = gap*(n-1);
    const width = this.container.clientWidth || 480;
    // width per bar: try to fit
    let barWidth = Math.floor((width - totalGap - 40) / n);
    barWidth = Math.max(18, Math.min(60, barWidth));
    const maxVal = Math.max(...this.array.map(v=>Math.abs(v)), 1);
    for(let i=0;i<n;i++){
      const val = this.array[i];
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.setProperty('--w', barWidth+'px');
      const heightPct = Math.max(6, Math.round((Math.abs(val)/maxVal) * 88)); // percent of area
      bar.style.height = heightPct + '%';
      bar.dataset.index = i;
      bar.dataset.value = val;
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = val;
      bar.appendChild(label);
      this.container.appendChild(bar);
      this.bars.push(bar);
    }
    // create simple horizontal layout using flex; we will animate by swapping heights/labels and classes
  }

  markCompare(i,j){
    this.clearStates();
    if(this.bars[i]) this.bars[i].classList.add('compare');
    if(this.bars[j]) this.bars[j].classList.add('compare');
  }
  markSwap(i,j){
    this.clearStates();
    if(this.bars[i]) this.bars[i].classList.add('swap');
    if(this.bars[j]) this.bars[j].classList.add('swap');
  }
  markSorted(idxStart){
    // mark elements from idxStart..end as sorted (for ascending bubble final pass)
    this.bars.forEach((b,idx)=> {
      b.classList.remove('compare','swap');
      if(idx >= idxStart) b.classList.add('sorted');
    });
  }
  clearStates(){
    this.bars.forEach(b=>{
      b.classList.remove('compare','swap');
      // keep 'sorted' until reset
    });
  }
  // Apply swap visually by swapping heights and labels
  async swap(i,j, duration=400){
    if(i===j) return;
    // swap values in DOM
    const bi = this.bars[i];
    const bj = this.bars[j];
    if(!bi || !bj) return;

    // animate: use transform swap (simple)
    bi.style.transition = `transform ${duration}ms ease`;
    bj.style.transition = `transform ${duration}ms ease`;

    bi.style.transform = `translateX(${(j-i)*(bi.offsetWidth + 8)}px)`;
    bj.style.transform = `translateX(${(i-j)*(bj.offsetWidth + 8)}px)`;

    await sleep(duration);

    // reset transforms
    bi.style.transition = '';
    bj.style.transition = '';
    bi.style.transform = '';
    bj.style.transform = '';

    // swap heights and labels and dataset
    const tempHeight = bi.style.height;
    const tempLabel = bi.querySelector('.label').textContent;
    const tempVal = bi.dataset.value;

    bi.style.height = bj.style.height;
    bi.querySelector('.label').textContent = bj.querySelector('.label').textContent;
    bi.dataset.value = bj.dataset.value;

    bj.style.height = tempHeight;
    bj.querySelector('.label').textContent = tempLabel;
    bj.dataset.value = tempVal;
  }

  updateArray(arr){
    // update labels/heights to match arr (no animation)
    this.array = arr.slice();
    const maxVal = Math.max(...arr.map(v=>Math.abs(v)), 1);
    for(let i=0;i<this.bars.length;i++){
      const val = arr[i];
      const heightPct = Math.max(6, Math.round((Math.abs(val)/maxVal) * 88));
      const bar = this.bars[i];
      bar.style.height = heightPct + '%';
      bar.dataset.value = val;
      bar.querySelector('.label').textContent = val;
      bar.classList.remove('compare','swap','sorted');
    }
  }

  markFinalSorted(){
    this.bars.forEach(b=> {
      b.classList.remove('compare','swap');
      b.classList.add('sorted');
    });
  }
}
customElements.define('array-visualizer', ArrayVisualizer);


// Main App Logic - tie components together
document.addEventListener('DOMContentLoaded', ()=> {
  const control = document.querySelector('controls-panel');
  const vis = document.querySelector('array-visualizer');

  // controls in right panel
  const stepBtn = document.getElementById('stepBtn');
  const backBtn = document.getElementById('backBtn');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const speedInput = document.getElementById('speed');
  const compCount = document.getElementById('compCount');
  const swapCount = document.getElementById('swapCount');
  const passCount = document.getElementById('passCount');
  const lenCount = document.getElementById('lenCount');
  const status = document.getElementById('status');
  const orderSelect = document.getElementById('orderSelect');
  const optCheckbox = document.getElementById('optCheckbox');
  const codePanel = document.getElementById('codePanel');

  // Pseudocode lines
  const codeLines = [
    'function bubbleSort(arr, ascending=true, optimized=false) {',
    '  let n = arr.length;',
    '  for (let i = 0; i < n - 1; i++) {',
    '    let swapped = false;                       // start of pass',
    '    for (let j = 0; j < n - 1 - i; j++) {',
    '      if ((ascending && arr[j] > arr[j+1]) || (!ascending && arr[j] < arr[j+1])) {',
    '        swap(arr, j, j+1);                     // swap elements',
    '        swapped = true;',
    '      }',
    '    }',
    '    if (optimized && !swapped) break;          // early exit',
    '  }',
    '}',
  ];

  function renderCode(highlightIdx=null){
    codePanel.innerHTML = '';
    for(let i=0;i<codeLines.length;i++){
      const ln = document.createElement('div');
      ln.className = 'line' + (i===highlightIdx ? ' highlight' : '');
      ln.textContent = codeLines[i];
      codePanel.appendChild(ln);
    }
  }

  renderCode(null);

  // state
  let array = [5,3,8,1,2,7,4,6];
  let history = []; // snapshots
  let actions = []; // generated actions for current run
  let actionIndex = 0;
  let playing = false;
  let runner = null;
  let comparisonCount = 0, swapCounter = 0, passCounter = 0;
  let ascending = true;
  let optimized = false;

  function setStatus(s){ status.textContent = s; }

  // helpers to generate arrays
  function randomArray(size){
    const arr = [];
    for(let i=0;i<size;i++){
      arr.push(Math.floor(Math.random()*100)+1);
    }
    return arr;
  }
  function reverseArray(size){
    const arr = [];
    for(let i=0;i<size;i++) arr.push(size-i);
    return arr;
  }
  function duplicatesArray(size){
    const base = [5,3,8,1,2,7,4,6];
    const arr = [];
    for(let i=0;i<size;i++){
      arr.push(base[i % base.length]);
    }
    return arr;
  }

  // Apply initial array to visualizer
  function applyArray(arr){
    array = arr.slice();
    history = [];
    actions = [];
    actionIndex = 0;
    comparisonCount = 0; swapCounter=0; passCounter=0;
    lenCount.textContent = array.length;
    compCount.textContent = '0';
    swapCount.textContent = '0';
    passCount.textContent = '0';
    vis.setArray(array);
    setStatus('idle');
    renderCode(null);
    backBtn.disabled = true;
    pauseBtn.disabled = true;
    playBtn.disabled = false;
  }

  // Event listeners from controls-panel
  control.addEventListener('apply-array', (e)=> {
    const text = e.detail.text.trim();
    if(text.length===0){
      applyArray(randomArray(Number(control.shadowRoot.querySelector('#size').value)));
      return;
    }
    const parts = text.split(',').map(s=>s.trim()).filter(s=>s!=='');
    const nums = parts.map(p=>Number(p));
    if(nums.some(isNaN)){
      alert('Invalid input. Use comma-separated numbers like: 5,3,8,1');
      return;
    }
    applyArray(nums);
  });
  control.addEventListener('size-change', (e)=> {
    const newSize = e.detail.size;
    lenCount.textContent = newSize;
  });
  control.addEventListener('randomize', (e)=> {
    const arr = randomArray(e.detail.size);
    applyArray(arr);
  });
  control.addEventListener('preset', (e)=> {
    let arr;
    if(e.detail.type==='easy') arr = [3,1,4,6,2,8,7,5].slice(0,e.detail.size);
    if(e.detail.type==='reverse') arr = reverseArray(e.detail.size);
    if(e.detail.type==='duplicates') arr = duplicatesArray(e.detail.size);
    applyArray(arr);
  });

  // Bubble sort action generator: returns a list of actions to animate
  function generateActions(arr, ascending=true, optimized=false){
    const a = arr.slice();
    const actions = [];
    const n = a.length;
    // snapshot initial
    actions.push({type:'snapshot', array:a.slice(), i:null, j:null, note:'start'});
    for(let i=0;i<n-1;i++){
      actions.push({type:'pass-start', i:i, note:`pass ${i+1}`});
      let swapped = false;
      for(let j=0;j<n-1-i;j++){
        actions.push({type:'compare', i:i, j:j});
        // comparison
        const cond = ascending ? (a[j] > a[j+1]) : (a[j] < a[j+1]);
        if(cond){
          actions.push({type:'swap', i:j, j:j+1});
          // swap in simulation
          const tmp = a[j]; a[j]=a[j+1]; a[j+1]=tmp;
          swapped = true;
          actions.push({type:'snapshot', array:a.slice(), i:i, j:j+1, note:'after-swap'});
        }
      }
      actions.push({type:'pass-end', i:i, swapped:swapped});
      if(optimized && !swapped){
        actions.push({type:'finished-early', i:i});
        break;
      }
    }
    actions.push({type:'done'});
    return actions;
  }

  // We will keep a history of snapshots for back stepping. Each snapshot captures array and stats.
  function pushSnapshot(arrSnapshot, meta={}){
    history.push({
      array: arrSnapshot.slice(),
      comp: comparisonCount,
      swaps: swapCounter,
      pass: passCounter,
      meta: meta
    });
  }

  // Prepare actions before running
  function prepareRun(){
    ascending = (orderSelect.value === 'asc');
    optimized = optCheckbox.checked;
    actions = generateActions(array, ascending, optimized);
    actionIndex = 0;
    history = [];
    // initial snapshot
    pushSnapshot(array.slice(), {note:'initial'});
    compCount.textContent = '0';
    swapCount.textContent = '0';
    passCount.textContent = '0';
    comparisonCount = 0; swapCounter = 0; passCounter = 0;
    renderCode(null);
    setStatus('ready');
    backBtn.disabled = true;
  }

  // Apply a single action (synchronous or with animation)
  async function applyAction(idx){
    if(idx < 0 || idx >= actions.length) return;
    const act = actions[idx];
    switch(act.type){
      case 'snapshot':
        // update whole array view (no highlight)
        vis.updateArray(act.array);
        renderCode(null);
        break;
      case 'pass-start':
        passCounter++;
        passCount.textContent = String(passCounter);
        setStatus(`Pass ${act.i+1} start`);
        renderCode(3); // highlight swapped flag line in pseudo-code area (approx)
        // push history
        pushSnapshot(currentArrayState(), {type:'pass-start', i:act.i});
        break;
      case 'compare':
        comparisonCount++;
        compCount.textContent = String(comparisonCount);
        setStatus(`Comparing indices ${act.j} and ${act.j+1}`);
        vis.markCompare(act.j, act.j+1);
        renderCode(4); // highlight inner loop and conditional
        pushSnapshot(currentArrayState(), {type:'compare', i:act.i, j:act.j});
        break;
      case 'swap':
        swapCounter++;
        swapCount.textContent = String(swapCounter);
        setStatus(`Swapping indices ${act.i} and ${act.j}`);
        vis.markSwap(act.i, act.j);
        renderCode(5); // highlight swap line
        // animate swap
        await vis.swap(act.i, act.j, clamp(1000 - Number(speedInput.value), 80, 1000));
        // After swap, we need to update internal array representation to reflect swapped values at positions
        // We'll swap the logical 'array' as well
        const tmp = array[act.i]; array[act.i]=array[act.j]; array[act.j]=tmp;
        // push snapshot after swap
        pushSnapshot(currentArrayState(), {type:'after-swap', i:act.i, j:act.j});
        break;
      case 'pass-end':
        setStatus(`Completed pass ${act.i+1}`);
        // mark suffix as sorted: elements from (array.length - (act.i+1))..end are in final position
        const sortedStart = array.length - (act.i+1);
        vis.markSorted(sortedStart);
        renderCode(10);
        pushSnapshot(currentArrayState(), {type:'pass-end', i:act.i});
        break;
      case 'finished-early':
        setStatus(`Finished early on pass ${act.i+1}`);
        vis.markFinalSorted();
        renderCode(11);
        pushSnapshot(currentArrayState(), {type:'finished-early', i:act.i});
        break;
      case 'done':
        setStatus('Done');
        vis.markFinalSorted();
        renderCode(11);
        pushSnapshot(currentArrayState(), {type:'done'});
        break;
      default:
        console.warn('unknown action', act);
    }
  }

  function currentArrayState(){
    // derive current array from visualizer bars
    // bars' dataset.value
    const bars = vis.shadowRoot ? vis.shadowRoot.querySelectorAll('.bar') : vis.container.querySelectorAll('.bar');
    if(bars && bars.length){
      return Array.from(bars).map(b=>Number(b.dataset.value));
    }
    return array.slice();
  }

  // Step forward one action
  async function stepForward(){
    if(actions.length === 0) {
      prepareRun();
    }
    if(actionIndex >= actions.length) {
      setStatus('already finished');
      return;
    }
    const curIdx = actionIndex;
    actionIndex++;
    backBtn.disabled = false;
    await applyAction(curIdx);
  }

  // Step backward: peek last snapshot and restore
  function stepBack(){
    if(history.length <= 1){
      // nothing to go back to
      return;
    }
    // pop last snapshot and set visualizer to previous
    const last = history.pop(); // current
    const prev = history[history.length-1];
    // restore counters and array
    comparisonCount = prev.comp;
    swapCounter = prev.swaps;
    passCounter = prev.pass;
    compCount.textContent = String(comparisonCount);
    swapCount.textContent = String(swapCounter);
    passCount.textContent = String(passCounter);
    // update array and visualizer
    array = prev.array.slice();
    vis.updateArray(array);
    setStatus('stepped back');
    actionIndex = Math.max(0, actionIndex-1);
    if(history.length <= 1) backBtn.disabled = true;
  }

  // Play sequence: animate remaining actions with timing
  async function playAll(){
    if(actions.length === 0) prepareRun();
    playing = true;
    playBtn.disabled = true;
    pauseBtn.disabled = false;
    setStatus('playing');
    while(playing && actionIndex < actions.length){
      await stepForward();
      // pacing: speedInput reversed (higher value = faster)
      const delay = clamp(1000 - Number(speedInput.value), 60, 1000);
      // If current action was a swap, we've already waited for the swap animation in applyAction.
      // Add a small pause between operations
      await sleep( Math.round(delay * 0.28) );
    }
    playing = false;
    playBtn.disabled = false;
    pauseBtn.disabled = true;
    if(actionIndex >= actions.length) setStatus('finished');
  }

  // Reset to initial state
  function resetAll(){
    // restore to initial array (first snapshot) if exists, otherwise current array
    if(history.length>0){
      const first = history[0];
      array = first.array.slice();
      vis.updateArray(array);
      compCount.textContent = '0';
      swapCount.textContent = '0';
      passCount.textContent = '0';
      comparisonCount = 0; swapCounter = 0; passCounter = 0;
      actions = [];
      actionIndex = 0;
      history = [];
      setStatus('reset');
      renderCode(null);
      backBtn.disabled = true;
      pauseBtn.disabled = true;
      playBtn.disabled = false;
    } else {
      // nothing recorded; just update widget
      vis.updateArray(array);
      compCount.textContent = '0';
      swapCount.textContent = '0';
      passCount.textContent = '0';
      comparisonCount = 0; swapCounter = 0; passCounter = 0;
      setStatus('idle');
      renderCode(null);
      backBtn.disabled = true;
      pauseBtn.disabled = true;
      playBtn.disabled = false;
    }
  }

  // wire up controls
  stepBtn.addEventListener('click', async ()=>{
    await stepForward();
  });
  backBtn.addEventListener('click', ()=>{
    stepBack();
  });
  playBtn.addEventListener('click', async ()=>{
    await playAll();
  });
  pauseBtn.addEventListener('click', ()=>{
    playing = false;
    pauseBtn.disabled = true;
    playBtn.disabled = false;
    setStatus('paused');
  });
  resetBtn.addEventListener('click', ()=>{
    playing = false;
    resetAll();
  });

  // When user toggles order or optimized, we prepare new run
  orderSelect.addEventListener('change', ()=>{
    prepareRun();
  });
  optCheckbox.addEventListener('change', ()=>{
    prepareRun();
  });

  speedInput.addEventListener('input', ()=>{
    // adjust nothing immediate; used in delays
  });

  // Initialize
  applyArray(array);
  prepareRun();

  // Small keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key === ' '){
      e.preventDefault();
      if(playing) { playing = false; pauseBtn.disabled = true; playBtn.disabled = false; setStatus('paused'); }
      else playAll();
    } else if (e.key === 'ArrowRight'){
      stepForward();
    } else if (e.key === 'ArrowLeft'){
      stepBack();
    }
  });

  // Accessibility: respond to container resize to re-render bars
  new ResizeObserver(()=>{ vis.render(); }).observe(vis);

  // Show initial code highlight mapping by default
  renderCode(null);
});
</script>
</body>
</html>