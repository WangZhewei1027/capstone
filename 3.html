<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bubble Sort Visualizer (Single File)</title>
    <style>
      :root {
        --bg: #0f1224;
        --panel: #171a2f;
        --accent: #7c9cff;
        --accent-2: #22c55e;
        --warn: #ffb020;
        --danger: #ff5d5d;
        --text: #e6e8ff;
        --muted: #a5a9d6;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji",
          "Segoe UI Emoji";
        color: var(--text);
        background: radial-gradient(
          1200px 600px at 70% -10%,
          #1e2142 0%,
          var(--bg) 45%
        );
        min-height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr auto;
        gap: 16px;
      }
      header {
        padding: 20px clamp(16px, 4vw, 32px) 0;
      }
      h1 {
        margin: 0 0 8px;
        font-size: clamp(22px, 3vw, 34px);
        letter-spacing: 0.2px;
      }
      p.sub {
        margin: 0;
        color: var(--muted);
      }

      .controls {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        padding: 12px clamp(16px, 4vw, 32px);
      }
      .panel {
        background: color-mix(in srgb, var(--panel), #ffffff 2%);
        border: 1px solid color-mix(in srgb, var(--panel), #ffffff 10%);
        border-radius: 12px;
        padding: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25),
          inset 0 1px 0 rgba(255, 255, 255, 0.04);
      }

      .row {
        display: grid;
        grid-template-columns: repeat(12, 1fr);
        gap: 8px;
        align-items: center;
      }
      .row > *:not(.spacer) {
        min-width: 0;
      }

      label {
        font-size: 13px;
        color: var(--muted);
      }
      input[type="range"] {
        width: 100%;
      }
      input[type="number"] {
        width: 100%;
        padding: 8px;
        background: #0d1022;
        border: 1px solid #2a2f57;
        border-radius: 8px;
        color: var(--text);
      }
      .btn {
        user-select: none;
        border: none;
        padding: 10px 14px;
        border-radius: 10px;
        color: #0b1020;
        background: var(--accent);
        font-weight: 700;
        cursor: pointer;
        transition: transform 0.06s ease, filter 0.2s ease, opacity 0.2s ease;
        white-space: nowrap;
      }
      .btn.secondary {
        background: #2f356b;
        color: var(--text);
      }
      .btn.ghost {
        background: transparent;
        color: var(--text);
        border: 1px dashed #39407a;
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .btn:active {
        transform: translateY(1px);
      }

      .stage-wrap {
        padding: 0 clamp(16px, 4vw, 32px);
      }
      .stage {
        position: relative;
        height: min(60vh, 520px);
        min-height: 280px;
        background: linear-gradient(
            transparent 0 96%,
            rgba(255, 255, 255, 0.05) 96% 100%
          ),
          linear-gradient(
              to right,
              rgba(255, 255, 255, 0.04) 1px,
              transparent 1px
            )
            0 100% / 40px 100%;
        border: 1px solid #262b55;
        border-radius: 14px;
        overflow: hidden;
        padding: 16px;
      }
      .bars {
        position: absolute;
        inset: 16px;
        display: grid;
        align-items: end;
        gap: 4px;
      }
      .bar {
        background: linear-gradient(180deg, #a9b6ff, var(--accent));
        border-radius: 6px 6px 0 0;
        outline: 1px solid rgba(255, 255, 255, 0.15);
        position: relative;
        transition: height 0.2s ease, transform 0.2s ease, background 0.15s ease,
          filter 0.15s ease;
      }
      .bar.compare {
        background: linear-gradient(180deg, #ffe29a, var(--warn));
        filter: saturate(1.1);
      }
      .bar.swap {
        background: linear-gradient(180deg, #ff9fa0, var(--danger));
      }
      .bar.sorted {
        background: linear-gradient(180deg, #b2f5c5, var(--accent-2));
      }

      .legend {
        display: flex;
        gap: 16px;
        align-items: center;
        flex-wrap: wrap;
        font-size: 13px;
        color: var(--muted);
        padding: 8px 12px 0;
      }
      .dot {
        width: 12px;
        height: 12px;
        border-radius: 4px;
        display: inline-block;
        vertical-align: middle;
        margin-right: 6px;
      }
      .dot.c {
        background: var(--warn);
      }
      .dot.s {
        background: var(--danger);
      }
      .dot.so {
        background: var(--accent-2);
      }

      footer {
        padding: 12px clamp(16px, 4vw, 32px) 28px;
        color: var(--muted);
        font-size: 13px;
      }
      code.inline {
        background: #0b0e20;
        border: 1px solid #2a2f57;
        padding: 1px 6px;
        border-radius: 6px;
      }

      @media (max-width: 720px) {
        .row {
          grid-template-columns: repeat(6, 1fr);
        }
        .hide-sm {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Bubble Sort — Visual & Interactive</h1>
      <p class="sub">
        Classic O(<span id="bigO">n²</span>) comparison sort. Watch adjacent
        elements bubble the largest to the end each pass.
      </p>
    </header>

    <section class="controls">
      <div class="panel">
        <div class="row" style="row-gap: 10px">
          <div style="grid-column: span 2">
            <label for="size">Size</label>
            <input id="size" type="number" min="5" max="200" value="30" />
          </div>
          <div style="grid-column: span 4">
            <label for="speed"
              >Speed (delay ms): <span id="speedVal">40</span></label
            >
            <input
              id="speed"
              type="range"
              min="0"
              max="300"
              step="5"
              value="40"
            />
          </div>
          <div style="grid-column: span 2">
            <label for="minVal">Min</label>
            <input id="minVal" type="number" value="5" />
          </div>
          <div style="grid-column: span 2">
            <label for="maxVal">Max</label>
            <input id="maxVal" type="number" value="100" />
          </div>
          <div class="hide-sm"></div>
          <div
            style="
              grid-column: span 12;
              display: flex;
              gap: 8px;
              flex-wrap: wrap;
            "
          >
            <button
              id="randomize"
              class="btn secondary"
              title="Generate a fresh random array"
            >
              Randomize
            </button>
            <button id="nearly" class="btn ghost" title="Nearly sorted array">
              Nearly Sorted
            </button>
            <button id="reversed" class="btn ghost" title="Reversed array">
              Reversed
            </button>
            <div class="spacer" style="flex: 1"></div>
            <button id="step" class="btn ghost" title="Do one comparison/swap">
              Step
            </button>
            <button id="play" class="btn" title="Animate bubble sort">
              Play
            </button>
            <button
              id="pause"
              class="btn secondary"
              title="Pause animation"
              disabled
            >
              Pause
            </button>
            <button id="reset" class="btn ghost" title="Reset to start">
              Reset
            </button>
          </div>
        </div>
        <div class="legend">
          <span><span class="dot c"></span>Comparing</span>
          <span><span class="dot s"></span>Swapping</span>
          <span><span class="dot so"></span>Sorted tail</span>
          <span>Pass: <code class="inline" id="pass">0</code></span>
          <span>Comparisons: <code class="inline" id="comps">0</code></span>
          <span>Swaps: <code class="inline" id="swaps">0</code></span>
        </div>
      </div>
    </section>

    <section class="stage-wrap">
      <div class="stage panel">
        <div id="bars" class="bars"></div>
      </div>
    </section>

    <footer>
      Bubble sort repeatedly steps through the list, compares adjacent pairs,
      and swaps them if they are in the wrong order. After each pass, the
      largest remaining element is placed at the end. Best:
      <code class="inline">O(n)</code> (already sorted with early exit),
      average/worst: <code class="inline">O(n²)</code>. Stable & in-place.
    </footer>

    <script>
      (function () {
        // ---- Utilities ----
        const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
        const byId = (id) => document.getElementById(id);
        const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

        // ---- State ----
        const els = {
          bars: byId("bars"),
          pass: byId("pass"),
          comps: byId("comps"),
          swaps: byId("swaps"),
          speed: byId("speed"),
          speedVal: byId("speedVal"),
          size: byId("size"),
          minVal: byId("minVal"),
          maxVal: byId("maxVal"),
          play: byId("play"),
          pause: byId("pause"),
          step: byId("step"),
          reset: byId("reset"),
          randomize: byId("randomize"),
          reversed: byId("reversed"),
          nearly: byId("nearly"),
        };

        let ARR = [];
        let halted = true;
        let running = false; // prevents concurrent runs
        let iPass = 0,
          comps = 0,
          swaps = 0;
        let jIndex = 0; // pointer for stepping
        let lastSortedTail = -1; // how many elements at the end are known sorted
        const MAX_HEIGHT = 100; // percentage scale

        // ---- Array generation ----
        function randInt(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        function makeRandom(n, lo, hi) {
          const out = Array.from({ length: n }, () => randInt(lo, hi));
          return out;
        }
        function makeNearlySorted(n, lo, hi, noise = 0.1) {
          const step = (hi - lo) / n;
          const base = Array.from({ length: n }, (_, i) =>
            Math.round(lo + i * step)
          );
          const k = Math.max(1, Math.floor(n * noise));
          for (let t = 0; t < k; t++) {
            const a = randInt(0, n - 1),
              b = clamp(a + (Math.random() < 0.5 ? -1 : 1), 0, n - 1);
            [base[a], base[b]] = [base[b], base[a]];
          }
          return base;
        }
        function makeReversed(n, lo, hi) {
          const arr = makeRandom(n, lo, hi)
            .sort((a, b) => a - b)
            .reverse();
          return arr;
        }

        // ---- Rendering ----
        function renderBars(arr) {
          const n = arr.length;
          const cols = Math.max(n, 1);
          els.bars.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
          els.bars.innerHTML = "";
          const maxVal = Math.max(...arr, 1);
          arr.forEach((v, idx) => {
            const bar = document.createElement("div");
            bar.className = "bar";
            bar.style.height = (v / maxVal) * MAX_HEIGHT + "%";
            bar.dataset.value = v;
            bar.dataset.index = idx;
            els.bars.appendChild(bar);
          });
          paintSortedTail();
        }

        function updateBar(idx, value) {
          const bar = els.bars.children[idx];
          bar.dataset.value = value;
          const maxVal = Math.max(...ARR, 1);
          bar.style.height = (value / maxVal) * MAX_HEIGHT + "%";
        }

        function markCompare(a, b) {
          clearMarks();
          if (els.bars.children[a])
            els.bars.children[a].classList.add("compare");
          if (els.bars.children[b])
            els.bars.children[b].classList.add("compare");
        }
        function markSwap(a, b) {
          clearMarks();
          if (els.bars.children[a]) els.bars.children[a].classList.add("swap");
          if (els.bars.children[b]) els.bars.children[b].classList.add("swap");
        }
        function clearMarks() {
          [...els.bars.children].forEach((el) => {
            el.classList.remove("compare", "swap", "sorted");
          });
          paintSortedTail();
        }
        function paintSortedTail() {
          const n = ARR.length;
          for (let k = n - 1; k >= n - 1 - lastSortedTail && k >= 0; k--) {
            els.bars.children[k]?.classList.add("sorted");
          }
        }

        function setStats() {
          els.pass.textContent = iPass;
          els.comps.textContent = comps;
          els.swaps.textContent = swaps;
        }

        // ---- Controls ----
        function setRunningUI(isRunning) {
          els.play.disabled = isRunning;
          els.pause.disabled = !isRunning;
          els.step.disabled = isRunning;
          els.reset.disabled = isRunning;
          els.randomize.disabled = isRunning;
          els.reversed.disabled = isRunning;
          els.nearly.disabled = isRunning;
          els.size.disabled = isRunning;
          els.minVal.disabled = isRunning;
          els.maxVal.disabled = isRunning;
        }

        function resetPointers() {
          iPass = 0;
          comps = 0;
          swaps = 0;
          jIndex = 0;
          lastSortedTail = -1;
          setStats();
          clearMarks();
        }

        function regenerate(kind = "random") {
          const n = clamp(parseInt(els.size.value || 30), 5, 200);
          const lo = parseInt(els.minVal.value || 1);
          const hi = parseInt(els.maxVal.value || 100);
          let next = [];
          if (kind === "nearly") next = makeNearlySorted(n, lo, hi, 0.12);
          else if (kind === "reversed") next = makeReversed(n, lo, hi);
          else next = makeRandom(n, lo, hi);
          ARR = next;
          renderBars(ARR);
          resetPointers();
        }

        // ---- Bubble Sort Engine (step-able & animatable) ----
        async function bubbleSortStep(animated = true) {
          // Returns: {done:boolean}
          const n = ARR.length;
          if (n <= 1) return { done: true };

          // If inner loop finished, finalize the tail element & reset j
          if (jIndex >= n - 1 - iPass) {
            lastSortedTail = Math.max(lastSortedTail, iPass);
            iPass++;
            jIndex = 0;
            paintSortedTail();
            // Early exit if no swaps happened in this pass
            if (_passSwaps === 0) {
              // Mark all as sorted
              lastSortedTail = n - 1;
              paintSortedTail();
              setStats();
              return { done: true };
            }
            _passSwaps = 0;
            if (iPass >= n - 1) {
              lastSortedTail = n - 1;
              paintSortedTail();
              setStats();
              return { done: true };
            }
          }

          // Compare pair (j, j+1)
          const a = jIndex,
            b = jIndex + 1;
          comps++;
          markCompare(a, b);
          setStats();

          if (animated) await sleep(currentDelay());

          if (ARR[a] > ARR[b]) {
            swaps++;
            _passSwaps++;
            markSwap(a, b);
            if (animated) await sleep(Math.max(30, currentDelay() * 0.8));
            // Swap values in data
            [ARR[a], ARR[b]] = [ARR[b], ARR[a]];
            // Visual swap: swap heights without reflowing the DOM order
            updateBar(a, ARR[a]);
            updateBar(b, ARR[b]);
          }

          jIndex++;
          setStats();
          return { done: false };
        }

        let _passSwaps = 0;

        function currentDelay() {
          return parseInt(els.speed.value, 10) || 0;
        }

        async function runAnimation() {
          if (running) return;
          halted = false;
          running = true;
          setRunningUI(true);
          clearMarks();

          while (!halted) {
            const { done } = await bubbleSortStep(true);
            if (done) break;
            // Tight loop yields naturally via awaits in step
          }

          halted = true;
          running = false;
          setRunningUI(false);
          clearMarks();
        }

        // ---- Event wiring ----
        els.speed.addEventListener("input", () => {
          els.speedVal.textContent = currentDelay();
        });

        els.play.addEventListener("click", () => {
          runAnimation();
        });
        els.pause.addEventListener("click", () => {
          halted = true;
        });
        els.step.addEventListener("click", async () => {
          // single step (no continuous run)
          await bubbleSortStep(false);
        });
        els.reset.addEventListener("click", () => {
          jIndex = 0;
          iPass = 0;
          comps = 0;
          swaps = 0;
          lastSortedTail = -1;
          _passSwaps = 0;
          renderBars(ARR);
          setStats();
        });

        els.randomize.addEventListener("click", () => regenerate("random"));
        els.reversed.addEventListener("click", () => regenerate("reversed"));
        els.nearly.addEventListener("click", () => regenerate("nearly"));

        // Keyboard shortcuts
        window.addEventListener("keydown", (e) => {
          if (e.key === " ") {
            e.preventDefault();
            if (running) {
              halted = true;
            } else {
              runAnimation();
            }
          }
          if (e.key === "ArrowRight") {
            e.preventDefault();
            els.step.click();
          }
          if ((e.key === "r" || e.key === "R") && !running) {
            e.preventDefault();
            els.reset.click();
          }
        });

        // ---- Initialize ----
        regenerate("random");
        els.speedVal.textContent = currentDelay();
      })();
    </script>
  </body>
</html>
