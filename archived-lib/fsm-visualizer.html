<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FSM State Machine Visualizer</title>

    <!-- React CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
    ></script>
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- D3.js for graph visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      h1 {
        text-align: center;
        color: white;
        margin-bottom: 30px;
        font-size: 2.5rem;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .controls {
        text-align: center;
        margin-bottom: 30px;
      }

      .controls select,
      .controls button {
        padding: 12px 20px;
        font-size: 16px;
        border: none;
        border-radius: 25px;
        background: white;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 0 10px;
      }

      .controls button:hover,
      .controls select:hover {
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        transform: translateY(-2px);
      }

      .controls button.active {
        background: #4caf50;
        color: white;
      }

      .fsm-container {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
      }

      .fsm-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }

      .info-panel {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 10px;
        border-left: 4px solid #4caf50;
      }

      .info-title {
        font-weight: 600;
        color: #333;
        margin-bottom: 10px;
        font-size: 1.1rem;
      }

      .info-content {
        color: #666;
        font-size: 0.9rem;
        line-height: 1.4;
      }

      .graph-container {
        width: 100%;
        height: 700px;
        border: 2px solid #e0e0e0;
        border-radius: 10px;
        background: #fafafa;
        position: relative;
        overflow: hidden;
      }

      .state-node {
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .state-node:hover {
        filter: brightness(1.1);
      }

      .state-node.active {
        stroke: #ff6b6b;
        stroke-width: 4px;
      }

      .state-label {
        font-family: "Segoe UI", sans-serif;
        font-size: 12px;
        font-weight: 600;
        text-anchor: middle;
        dominant-baseline: central;
        pointer-events: none;
      }

      .edge {
        fill: none;
        stroke: #666;
        stroke-width: 2;
        marker-end: url(#arrowhead);
        transition: all 0.3s ease;
      }

      .edge:hover {
        stroke: #4caf50;
        stroke-width: 3;
      }

      .edge-label {
        font-family: "Segoe UI", sans-serif;
        font-size: 10px;
        font-weight: 500;
        text-anchor: middle;
        dominant-baseline: central;
        fill: #333;
        background: white;
        padding: 2px 4px;
        border-radius: 3px;
      }

      .screenshot-panel {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border-radius: 15px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        max-width: 80vw;
        max-height: 80vh;
        overflow: auto;
        display: none;
      }

      .screenshot-panel.show {
        display: block;
      }

      .screenshot-header {
        padding: 20px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .screenshot-title {
        font-size: 1.3rem;
        font-weight: 600;
        color: #333;
      }

      .close-btn {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #666;
        padding: 5px;
        border-radius: 50%;
        width: 35px;
        height: 35px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .close-btn:hover {
        background: #f0f0f0;
      }

      .screenshot-content {
        padding: 20px;
      }

      .screenshot-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
      }

      .screenshot-item {
        text-align: center;
      }

      .screenshot-img {
        width: 100%;
        max-width: 400px;
        border: 2px solid #ddd;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
      }

      .screenshot-img:hover {
        transform: scale(1.02);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
      }

      .screenshot-caption {
        margin-top: 10px;
        font-size: 0.9rem;
        color: #666;
        font-weight: 500;
      }

      .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
        display: none;
      }

      .overlay.show {
        display: block;
      }

      .legend {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 10px;
        padding: 15px;
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 100;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }

      .legend-title {
        font-weight: 600;
        margin-bottom: 10px;
        color: #333;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
        font-size: 0.85rem;
      }

      .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        margin-right: 8px;
        border: 2px solid #333;
      }

      .error {
        text-align: center;
        color: #ff6b6b;
        font-size: 1.1rem;
        margin-top: 30px;
        background: white;
        padding: 20px;
        border-radius: 10px;
      }

      .loading {
        text-align: center;
        color: white;
        font-size: 1.1rem;
        margin-top: 30px;
      }

      @media (max-width: 768px) {
        .fsm-info {
          grid-template-columns: 1fr;
        }

        .graph-container {
          height: 500px;
        }

        .screenshot-panel {
          max-width: 95vw;
          max-height: 95vh;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      // FSMçŠ¶æ€é…è‰²æ–¹æ¡ˆ
      const STATE_COLORS = {
        idle: "#4caf50",
        validating_input: "#ff9800",
        error_alert: "#f44336",
        inserting_node: "#2196f3",
        drawing_tree: "#9c27b0",
        tree_resetting: "#607d8b",
      };

      // ScreenshotPanel Component
      const ScreenshotPanel = ({
        show,
        onClose,
        selectedState,
        screenshots,
      }) => {
        if (!show) return null;

        // å¦‚æœæ²¡æœ‰é€‰æ‹©ç‰¹å®šçŠ¶æ€ï¼Œæ˜¾ç¤ºæ‰€æœ‰æˆªå›¾
        let stateScreenshots = screenshots;

        if (selectedState) {
          // æ›´æ™ºèƒ½çš„çŠ¶æ€åŒ¹é…ç®—æ³•
          stateScreenshots = screenshots.filter((imgUrl) => {
            const filename = imgUrl.split("/").pop().toLowerCase();
            const stateLower = selectedState.toLowerCase();

            // ç›´æ¥åŒ¹é…çŠ¶æ€å
            if (filename.includes(stateLower)) {
              return true;
            }

            // ç‰¹æ®ŠçŠ¶æ€æ˜ å°„
            const stateMapping = {
              idle: ["idle", "input_ready"],
              validating_input: ["validating", "input"],
              error_alert: ["error", "alert"],
              inserting_node: ["inserting", "node", "tree_node"],
              drawing_tree: ["drawing", "tree", "tree_with"],
              tree_resetting: ["resetting", "reset"],
            };

            const keywords = stateMapping[stateLower] || [stateLower];
            return keywords.some((keyword) => filename.includes(keyword));
          });
        }

        return (
          <>
            <div
              className={`overlay ${show ? "show" : ""}`}
              onClick={onClose}
            ></div>
            <div className={`screenshot-panel ${show ? "show" : ""}`}>
              <div className="screenshot-header">
                <div className="screenshot-title">
                  {selectedState ? `çŠ¶æ€æˆªå›¾: ${selectedState}` : "æ‰€æœ‰æˆªå›¾"}
                </div>
                <button className="close-btn" onClick={onClose}>
                  Ã—
                </button>
              </div>
              <div className="screenshot-content">
                {stateScreenshots.length > 0 ? (
                  <div className="screenshot-grid">
                    {stateScreenshots.map((screenshot, index) => (
                      <div key={index} className="screenshot-item">
                        <img
                          src={screenshot}
                          alt={`${selectedState || "State"} screenshot ${
                            index + 1
                          }`}
                          className="screenshot-img"
                          onError={(e) => {
                            e.target.style.display = "none";
                          }}
                        />
                        <div className="screenshot-caption">
                          {screenshot.split("/").pop().replace(".png", "")}
                        </div>
                      </div>
                    ))}
                  </div>
                ) : (
                  <div
                    style={{
                      textAlign: "center",
                      color: "#666",
                      padding: "40px",
                    }}
                  >
                    {selectedState
                      ? `æš‚æ—  ${selectedState} çŠ¶æ€çš„æˆªå›¾`
                      : "æš‚æ— æˆªå›¾"}
                  </div>
                )}
              </div>
            </div>
          </>
        );
      };

      // FSMGraph Component
      const FSMGraph = ({ fsmData, screenshots, onStateClick }) => {
        const svgRef = useRef();
        const [graphData, setGraphData] = useState({ nodes: [], links: [] });

        useEffect(() => {
          if (!fsmData) return;

          // æ„å»ºå›¾æ•°æ®
          const nodes = fsmData.states.map((state) => ({
            id: state.name,
            name: state.name,
            onEnter: state.onEnter,
            color: STATE_COLORS[state.name] || "#666",
            hasScreenshots: screenshots.some((img) =>
              img.toLowerCase().includes(state.name.toLowerCase())
            ),
          }));

          const links = [];
          fsmData.states.forEach((state) => {
            if (state.on) {
              Object.entries(state.on).forEach(([event, target]) => {
                links.push({
                  source: state.name,
                  target: target,
                  event: event,
                });
              });
            }
          });

          setGraphData({ nodes, links });
        }, [fsmData, screenshots]);

        useEffect(() => {
          if (!graphData.nodes.length) return;

          const svg = d3.select(svgRef.current);
          svg.selectAll("*").remove();

          const width = 1200;
          const height = 650;

          // å®šä¹‰ç®­å¤´æ ‡è®°
          svg
            .append("defs")
            .append("marker")
            .attr("id", "arrowhead")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 25)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#666");

          const simulation = d3
            .forceSimulation(graphData.nodes)
            .force(
              "link",
              d3
                .forceLink(graphData.links)
                .id((d) => d.id)
                .distance(150)
            )
            .force("charge", d3.forceManyBody().strength(-800))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(60));

          // åˆ›å»ºè¿çº¿
          const link = svg
            .append("g")
            .selectAll("path")
            .data(graphData.links)
            .join("path")
            .attr("class", "edge")
            .attr("stroke", "#666")
            .attr("stroke-width", 2)
            .attr("fill", "none")
            .attr("marker-end", "url(#arrowhead)");

          // åˆ›å»ºè¿çº¿æ ‡ç­¾
          const linkLabel = svg
            .append("g")
            .selectAll("text")
            .data(graphData.links)
            .join("text")
            .attr("class", "edge-label")
            .attr("font-size", "10px")
            .attr("text-anchor", "middle")
            .text((d) => d.event);

          // åˆ›å»ºèŠ‚ç‚¹
          const node = svg
            .append("g")
            .selectAll("g")
            .data(graphData.nodes)
            .join("g")
            .attr("class", "state-node")
            .style("cursor", "pointer");

          // èŠ‚ç‚¹åœ†åœˆ
          node
            .append("circle")
            .attr("r", (d) => (d.hasScreenshots ? 35 : 30))
            .attr("fill", (d) => d.color)
            .attr("stroke", (d) => (d.hasScreenshots ? "#fff" : "none"))
            .attr("stroke-width", (d) => (d.hasScreenshots ? 3 : 0))
            .attr("opacity", 0.9);

          // æˆªå›¾æŒ‡ç¤ºå™¨
          node
            .filter((d) => d.hasScreenshots)
            .append("circle")
            .attr("r", 8)
            .attr("cx", 25)
            .attr("cy", -25)
            .attr("fill", "#ff6b6b")
            .attr("stroke", "#fff")
            .attr("stroke-width", 2);

          node
            .filter((d) => d.hasScreenshots)
            .append("text")
            .attr("x", 25)
            .attr("y", -25)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "central")
            .attr("fill", "white")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .text("ğŸ“·");

          // èŠ‚ç‚¹æ ‡ç­¾
          node
            .append("text")
            .attr("class", "state-label")
            .attr("font-size", "11px")
            .attr("font-weight", "600")
            .attr("fill", "white")
            .attr("text-anchor", "middle")
            .text((d) => d.name.split("_").join("\n"));

          // èŠ‚ç‚¹äº¤äº’
          node.on("click", (event, d) => {
            // é‡ç½®æ‰€æœ‰èŠ‚ç‚¹æ ·å¼
            node
              .select("circle")
              .attr("stroke-width", (d) => (d.hasScreenshots ? 3 : 0));

            // é«˜äº®å½“å‰èŠ‚ç‚¹
            d3.select(event.currentTarget)
              .select("circle")
              .attr("stroke", "#ff6b6b")
              .attr("stroke-width", 5);

            onStateClick(d.name);
          });

          // æ‹–æ‹½åŠŸèƒ½
          const drag = d3
            .drag()
            .on("start", (event, d) => {
              if (!event.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x;
              d.fy = d.y;
            })
            .on("drag", (event, d) => {
              d.fx = event.x;
              d.fy = event.y;
            })
            .on("end", (event, d) => {
              if (!event.active) simulation.alphaTarget(0);
              d.fx = null;
              d.fy = null;
            });

          node.call(drag);

          // æ›´æ–°ä½ç½®
          simulation.on("tick", () => {
            link.attr("d", (d) => {
              const dx = d.target.x - d.source.x;
              const dy = d.target.y - d.source.y;
              const dr = Math.sqrt(dx * dx + dy * dy);

              // è®¡ç®—åœ†åœˆè¾¹ç¼˜çš„ç‚¹
              const sourceX = d.source.x + (dx * 35) / dr;
              const sourceY = d.source.y + (dy * 35) / dr;
              const targetX = d.target.x - (dx * 35) / dr;
              const targetY = d.target.y - (dy * 35) / dr;

              return `M${sourceX},${sourceY}L${targetX},${targetY}`;
            });

            linkLabel
              .attr("x", (d) => (d.source.x + d.target.x) / 2)
              .attr("y", (d) => (d.source.y + d.target.y) / 2);

            node.attr("transform", (d) => `translate(${d.x},${d.y})`);
          });
        }, [graphData, onStateClick]);

        return (
          <div className="graph-container">
            <svg ref={svgRef} width="100%" height="100%"></svg>
            <div className="legend">
              <div className="legend-title">å›¾ä¾‹</div>
              {Object.entries(STATE_COLORS).map(([state, color]) => (
                <div key={state} className="legend-item">
                  <div
                    className="legend-color"
                    style={{ backgroundColor: color }}
                  ></div>
                  <span>{state}</span>
                </div>
              ))}
              <div className="legend-item" style={{ marginTop: "10px" }}>
                <span style={{ fontSize: "12px" }}>ğŸ“· = æœ‰æˆªå›¾</span>
              </div>
            </div>
          </div>
        );
      };

      // Main App Component
      const App = () => {
        const [htmlFiles, setHtmlFiles] = useState([]);
        const [selectedFile, setSelectedFile] = useState("");
        const [fsmData, setFsmData] = useState(null);
        const [screenshots, setScreenshots] = useState([]);
        const [selectedState, setSelectedState] = useState("");
        const [showScreenshots, setShowScreenshots] = useState(false);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState("");

        // åŠ è½½HTMLæ–‡ä»¶åˆ—è¡¨
        useEffect(() => {
          loadHtmlFiles();
        }, []);

        const loadHtmlFiles = async () => {
          try {
            // å°è¯•ä»APIè·å–HTMLæ–‡ä»¶åˆ—è¡¨
            const response = await fetch(
              "http://localhost:3001/api/html-files"
            );
            if (response.ok) {
              const files = await response.json();
              setHtmlFiles(files);
              console.log(`âœ… ä»APIåŠ è½½ ${files.length} ä¸ªHTMLæ–‡ä»¶`);
            } else {
              throw new Error("APIå“åº”å¤±è´¥");
            }
          } catch (error) {
            console.warn("APIä¸å¯ç”¨ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ:", error.message);
            // å¤‡ç”¨æ–¹æ¡ˆï¼šæ‰‹åŠ¨æ·»åŠ å·²çŸ¥æ–‡ä»¶
            const fallbackFiles = [
              "4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
              "46878530-b408-11f0-ab52-fbe7249bf639.html",
              "5736e9c0-b408-11f0-ab52-fbe7249bf639.html",
            ];
            setHtmlFiles(fallbackFiles);
            setError(
              'APIæœåŠ¡å™¨æœªå¯åŠ¨ï¼Œä½¿ç”¨ç¦»çº¿æ¨¡å¼ã€‚è¯·è¿è¡Œ "node fsm-api.mjs" å¯åŠ¨æœåŠ¡å™¨ä»¥è·å¾—å®Œæ•´åŠŸèƒ½ã€‚'
            );
          }
        };

        const loadFSMData = async (fileName) => {
          if (!fileName) return;

          setLoading(true);
          setError("");

          try {
            // å°è¯•ä»APIè·å–FSMæ•°æ®
            const fsmResponse = await fetch(
              `http://localhost:3001/api/fsm-data/${fileName}`
            );
            if (fsmResponse.ok) {
              const fsm = await fsmResponse.json();
              setFsmData(fsm);
              console.log("âœ… ä»APIåŠ è½½FSMæ•°æ®");
            } else {
              // å¤‡ç”¨æ–¹æ¡ˆï¼šç›´æ¥ä»HTMLæ–‡ä»¶è§£æ
              const htmlResponse = await fetch(
                `./workspace/vlm-test/html/${fileName}`
              );
              if (!htmlResponse.ok) {
                throw new Error("æ— æ³•åŠ è½½HTMLæ–‡ä»¶");
              }

              const htmlContent = await htmlResponse.text();
              const parser = new DOMParser();
              const doc = parser.parseFromString(htmlContent, "text/html");
              const fsmScript = doc.querySelector(
                'script[type="application/json"]'
              );

              if (!fsmScript) {
                throw new Error("HTMLæ–‡ä»¶ä¸­æœªæ‰¾åˆ°FSMé…ç½®");
              }

              const fsm = JSON.parse(fsmScript.textContent);
              setFsmData(fsm);
              console.log("âœ… ä»HTMLæ–‡ä»¶è§£æFSMæ•°æ®");
            }

            // åŠ è½½å¯¹åº”çš„æˆªå›¾
            await loadScreenshots(fileName);
          } catch (error) {
            setError(error.message);
            console.error("åŠ è½½FSMæ•°æ®å¤±è´¥:", error);
          } finally {
            setLoading(false);
          }
        };

        const loadScreenshots = async (fileName) => {
          try {
            // å°è¯•ä»APIè·å–æˆªå›¾åˆ—è¡¨
            const response = await fetch(
              `http://localhost:3001/api/screenshots/${fileName}`
            );
            if (response.ok) {
              const screenshotData = await response.json();
              const screenshotUrls = screenshotData.map(
                (item) => `http://localhost:3001${item.url}`
              );
              setScreenshots(screenshotUrls);
              console.log(`âœ… ä»APIåŠ è½½ ${screenshotUrls.length} ä¸ªæˆªå›¾`);
              return;
            }
          } catch (error) {
            console.warn("APIä¸å¯ç”¨ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆåŠ è½½æˆªå›¾");
          }

          // å¤‡ç”¨æ–¹æ¡ˆï¼šç›´æ¥æ„å»ºæˆªå›¾URL
          const baseName = fileName.replace(".html", "");
          const screenshotFolder = `./workspace/vlm-test/visuals/${baseName}/`;

          // åŸºäºå·²çŸ¥çš„æ–‡ä»¶å‘½åæ¨¡å¼
          const possibleScreenshots = [
            "01_idle_initial.png",
            "02_validating_input_valid.png",
            "03_drawing_tree_node_10.png",
            "04_input_ready_node_5.png",
            "05_drawing_tree_with_node_5.png",
            "06_input_ready_node_15.png",
            "07_drawing_tree_with_node_15.png",
            "08_input_ready_node_3.png",
            "09_drawing_tree_with_node_3.png",
            "10_input_ready_node_7.png",
            "11_drawing_tree_with_node_7.png",
            "12_input_ready_node_12.png",
            "13_drawing_tree_with_node_12.png",
            "14_input_ready_node_18.png",
            "15_drawing_tree_with_node_18.png",
            "16_drawing_tree_complete.png",
            "17_validating_input_invalid.png",
            "18_error_alert_active.png",
          ];

          const availableScreenshots = [];

          // æ£€æŸ¥å“ªäº›æˆªå›¾æ–‡ä»¶å­˜åœ¨
          for (const screenshot of possibleScreenshots) {
            try {
              const response = await fetch(screenshotFolder + screenshot, {
                method: "HEAD",
              });
              if (response.ok) {
                availableScreenshots.push(screenshotFolder + screenshot);
              }
            } catch (error) {
              // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡
            }
          }

          setScreenshots(availableScreenshots);
          console.log(`æ‰¾åˆ° ${availableScreenshots.length} ä¸ªæˆªå›¾æ–‡ä»¶`);
        };

        const handleFileChange = (fileName) => {
          setSelectedFile(fileName);
          loadFSMData(fileName);
        };

        const handleStateClick = (stateName) => {
          setSelectedState(stateName);
          setShowScreenshots(true);
        };

        const closeScreenshots = () => {
          setShowScreenshots(false);
          setSelectedState("");
        };

        return (
          <div className="container">
            <h1>ğŸ”„ FSM State Machine Visualizer</h1>

            <div className="controls">
              <select
                value={selectedFile}
                onChange={(e) => handleFileChange(e.target.value)}
                disabled={loading}
              >
                <option value="">é€‰æ‹©HTMLæ–‡ä»¶...</option>
                {htmlFiles.map((file) => (
                  <option key={file} value={file}>
                    {file}
                  </option>
                ))}
              </select>

              {screenshots.length > 0 && (
                <button onClick={() => setShowScreenshots(true)}>
                  æŸ¥çœ‹æ‰€æœ‰æˆªå›¾ ({screenshots.length})
                </button>
              )}
            </div>

            {error && <div className="error">{error}</div>}

            {loading && <div className="loading">åŠ è½½ä¸­...</div>}

            {fsmData && (
              <div className="fsm-container">
                <div className="fsm-info">
                  <div className="info-panel">
                    <div className="info-title">ğŸ“‹ FSM ä¿¡æ¯</div>
                    <div className="info-content">
                      <strong>ä¸»é¢˜:</strong> {fsmData.topic}
                      <br />
                      <strong>çŠ¶æ€æ•°:</strong> {fsmData.states?.length || 0}
                      <br />
                      <strong>äº‹ä»¶æ•°:</strong> {fsmData.events?.length || 0}
                      <br />
                      <strong>æˆªå›¾æ•°:</strong> {screenshots.length}
                    </div>
                  </div>
                  <div className="info-panel">
                    <div className="info-title">ğŸ’¡ æ“ä½œè¯´æ˜</div>
                    <div className="info-content">
                      â€¢ ç‚¹å‡»çŠ¶æ€èŠ‚ç‚¹æŸ¥çœ‹å¯¹åº”æˆªå›¾
                      <br />
                      â€¢ æ‹–æ‹½èŠ‚ç‚¹è°ƒæ•´å¸ƒå±€
                      <br />
                      â€¢ ç®­å¤´è¡¨ç¤ºçŠ¶æ€è½¬æ¢
                      <br />â€¢ ğŸ“· è¡¨ç¤ºè¯¥çŠ¶æ€æœ‰æˆªå›¾
                    </div>
                  </div>
                </div>

                <FSMGraph
                  fsmData={fsmData}
                  screenshots={screenshots}
                  onStateClick={handleStateClick}
                />
              </div>
            )}

            <ScreenshotPanel
              show={showScreenshots}
              onClose={closeScreenshots}
              selectedState={selectedState}
              screenshots={screenshots}
            />
          </div>
        );
      };

      // Render the app
      ReactDOM.render(<App />, document.getElementById("root"));
    </script>
  </body>
</html>
