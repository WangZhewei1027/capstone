[
  {
    "id": "571dc870-98a9-11f0-80eb-5318bf930f60",
    "model": "gpt-4o-mini",
    "timestamp": "2025-09-23T18:15:52.696Z",
    "question": "bubble sort",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Bubble Sort Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            margin: 0;\n            padding: 20px;\n        }\n        #arrayContainer {\n            display: flex;\n            margin: 20px;\n        }\n        .bar {\n            width: 30px;\n            margin: 2px;\n            background-color: teal;\n            display: inline-block;\n            transition: height 0.3s ease;\n        }\n        button {\n            margin: 10px;\n            padding: 10px 15px;\n            font-size: 16px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n\n<h1>Bubble Sort Visualization</h1>\n<div id=\"arrayContainer\"></div>\n<button onclick=\"startBubbleSort()\">Start Bubble Sort</button>\n\n<script>\n    const arrayContainer = document.getElementById('arrayContainer');\n    const array = [64, 34, 25, 12, 22, 11, 90];\n\n    function createBars(arr) {\n        arrayContainer.innerHTML = '';\n        arr.forEach(value => {\n            const bar = document.createElement('div');\n            bar.className = 'bar';\n            bar.style.height = value * 4 + 'px'; // Scale the height for visibility\n            arrayContainer.appendChild(bar);\n        });\n    }\n    \n    function startBubbleSort() {\n        bubbleSort(array.slice());\n    }\n\n    async function bubbleSort(arr) {\n        const bars = document.querySelectorAll('.bar');\n        let n = arr.length;\n\n        for (let i = 0; i < n - 1; i++) {\n            for (let j = 0; j < n - i - 1; j++) {\n                // Change color of the bars being compared\n                bars[j].style.backgroundColor = 'red';\n                bars[j + 1].style.backgroundColor = 'red';\n\n                // Wait for a moment to visualize the comparison\n                await new Promise(resolve => setTimeout(resolve, 300));\n\n                // Compare and swap if needed\n                if (arr[j] > arr[j + 1]) {\n                    let temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n\n                    // Update the visual representation\n                    bars[j].style.height = arr[j] * 4 + 'px';\n                    bars[j + 1].style.height = arr[j + 1] * 4 + 'px';\n                }\n\n                // Reset color after comparison\n                bars[j].style.backgroundColor = 'teal';\n                bars[j + 1].style.backgroundColor = 'teal';\n            }\n        }\n    }\n\n    // Initial bar creation\n    createBars(array);\n</script>\n\n</body>\n</html>\n```",
      "refusal": null,
      "annotations": []
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "bubble sort"
      }
    ],
    "evaluation": {
      "score": 2,
      "notes": "看着有点接近，但是交互性和视觉效果都很差"
    }
  },
  {
    "id": "7cd93f80-98aa-11f0-ab4c-f184c581df32",
    "model": "gpt-5-mini",
    "timestamp": "2025-09-23T18:24:05.496Z",
    "question": "bubble sort",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Bubble Sort Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1320;\n      --accent:#06b6d4;\n      --muted:#94a3b8;\n      --good:#16a34a;\n      --bad:#ef4444;\n      --compare:#f59e0b;\n      --bar-bg:#0b1220;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;}\n    body{background:linear-gradient(180deg,var(--bg),#07101a);color:#e6eef8;display:flex;flex-direction:column;align-items:stretch;padding:18px;box-sizing:border-box;}\n    h1{margin:0 0 8px 0;font-size:20px;}\n    .app{max-width:1100px;margin:0 auto;display:grid;grid-template-columns:1fr 360px;gap:18px;align-items:start;}\n    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.0));border:1px solid rgba(255,255,255,0.04);padding:14px;border-radius:12px;box-shadow: 0 6px 18px rgba(2,6,23,0.6);}\n    .controls{display:flex;flex-direction:column;gap:10px;}\n    .row{display:flex;gap:8px;align-items:center;}\n    label{color:var(--muted);font-size:13px;}\n    button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;}\n    button.primary{background:linear-gradient(90deg,var(--accent),#62d6d9);color:#042028;border:none;box-shadow:0 6px 18px rgba(6,182,212,0.12);}\n    button:disabled{opacity:0.45;cursor:default;}\n    .controls .row > *{flex:1;}\n    .vis{height:420px;display:flex;flex-direction:column;gap:12px;}\n    .bars{background:var(--bar-bg);flex:1;border-radius:8px;padding:12px;display:flex;align-items:flex-end;gap:6px;overflow:hidden;}\n    .bar{flex:1 1 auto;display:flex;align-items:flex-end;justify-content:center;border-radius:6px 6px 2px 2px;transition:height 150ms linear, background 150ms linear, transform 150ms;position:relative;}\n    .bar .val{font-size:11px;color:rgba(255,255,255,0.9);padding-bottom:6px;text-shadow:0 1px 0 rgba(0,0,0,0.6);}\n    .stats{display:flex;gap:10px;flex-wrap:wrap;color:var(--muted);font-size:13px;margin-top:6px;}\n    .badge{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);min-width:88px;text-align:center;}\n    .pseudocode{font-family:monospace;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;color:var(--muted);font-size:13px;line-height:1.5;white-space:pre;}\n    .highlight{background:rgba(255,255,255,0.04);color:#fff;padding:2px 4px;border-radius:4px;}\n    .footer{font-size:13px;color:var(--muted);margin-top:8px;}\n    .small{font-size:12px;color:var(--muted);}\n    .top-controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}\n    input[type=\"range\"]{width:100%;}\n    .center{display:flex;justify-content:center;align-items:center;gap:8px;}\n    .legend{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}\n    .legend .item{display:flex;gap:6px;align-items:center;color:var(--muted);font-size:13px;}\n    .color-swatch{width:14px;height:14px;border-radius:4px;}\n    /* Colors for states */\n    .bar.normal{background:linear-gradient(180deg,#0f2540,#0b1730);}\n    .bar.compare{background:linear-gradient(180deg,var(--compare), #fab95d); transform:translateY(-4px);}\n    .bar.swap{background:linear-gradient(180deg,var(--bad), #ff7b7b); transform:translateY(-6px);}\n    .bar.sorted{background:linear-gradient(180deg,var(--good), #7ee7a8);}\n    @media (max-width:980px){\n      .app{grid-template-columns:1fr; padding-bottom:40px;}\n      .panel{padding:12px;}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Bubble sort visualizer\">\n    <div class=\"panel\">\n      <h1>Bubble Sort Visualizer</h1>\n      <div class=\"vis\" aria-live=\"polite\">\n        <div class=\"bars\" id=\"bars\" role=\"list\" aria-label=\"Array bars\"></div>\n        <div class=\"stats\" id=\"stats\">\n          <div class=\"badge\">Comparisons: <span id=\"comp\">0</span></div>\n          <div class=\"badge\">Swaps: <span id=\"swaps\">0</span></div>\n          <div class=\"badge\">Pass: <span id=\"pass\">0</span></div>\n          <div class=\"badge\">i / n: <span id=\"indices\">-</span></div>\n          <div class=\"badge\">Status: <span id=\"status\">Idle</span></div>\n        </div>\n      </div>\n      <div class=\"footer small\" style=\"margin-top:12px;\">\n        Complexity: Average/Worst O(n²), Best O(n) with early-exit optimization. Bubble sort repeatedly steps through the list, compares adjacent items and swaps them if out of order, \"bubbling\" largest/smallest to the end.\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"controls\">\n        <div class=\"top-controls\">\n          <button id=\"randomBtn\" class=\"\">Randomize</button>\n          <button id=\"startBtn\" class=\"primary\">Start</button>\n          <button id=\"stepBtn\">Step</button>\n          <button id=\"pauseBtn\" disabled>Pause</button>\n          <button id=\"resetBtn\">Reset</button>\n        </div>\n\n        <div class=\"row\">\n          <label for=\"size\">Array size: <span id=\"sizeVal\">20</span></label>\n          <input id=\"size\" type=\"range\" min=\"5\" max=\"80\" value=\"20\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"speed\">Speed (ms delay): <span id=\"speedVal\">150</span></label>\n          <input id=\"speed\" type=\"range\" min=\"10\" max=\"600\" value=\"150\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"order\">Order</label>\n          <select id=\"order\" aria-label=\"Sort order\">\n            <option value=\"asc\">Ascending (small → left)</option>\n            <option value=\"desc\">Descending (large → left)</option>\n          </select>\n        </div>\n\n        <div class=\"row legend\">\n          <div class=\"item\"><span class=\"color-swatch\" style=\"background:linear-gradient(180deg,#0f2540,#0b1730)\"></span> Normal</div>\n          <div class=\"item\"><span class=\"color-swatch\" style=\"background:linear-gradient(180deg,var(--compare), #fab95d)\"></span> Comparing</div>\n          <div class=\"item\"><span class=\"color-swatch\" style=\"background:linear-gradient(180deg,var(--bad), #ff7b7b)\"></span> Swapping</div>\n          <div class=\"item\"><span class=\"color-swatch\" style=\"background:linear-gradient(180deg,var(--good), #7ee7a8)\"></span> Sorted</div>\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <div class=\"pseudocode\" id=\"pseudocode\" aria-hidden=\"true\">\ni = 0\nwhile i < n-1:\n  swapped = false\n  for j from 0 to n-2-i:\n    compare A[j] and A[j+1]\n    if out of order:\n      swap A[j] and A[j+1]\n      swapped = true\n  if not swapped:\n    break\n  i = i + 1\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Bubble Sort Visualizer\n    (function(){\n      const barsEl = document.getElementById('bars');\n      const compEl = document.getElementById('comp');\n      const swapsEl = document.getElementById('swaps');\n      const passEl = document.getElementById('pass');\n      const indicesEl = document.getElementById('indices');\n      const statusEl = document.getElementById('status');\n\n      const randomBtn = document.getElementById('randomBtn');\n      const startBtn = document.getElementById('startBtn');\n      const stepBtn = document.getElementById('stepBtn');\n      const pauseBtn = document.getElementById('pauseBtn');\n      const resetBtn = document.getElementById('resetBtn');\n\n      const sizeRange = document.getElementById('size');\n      const sizeVal = document.getElementById('sizeVal');\n      const speedRange = document.getElementById('speed');\n      const speedVal = document.getElementById('speedVal');\n      const orderSelect = document.getElementById('order');\n\n      let array = [];\n      let initialArray = [];\n      let bars = [];\n      let comparisons = 0;\n      let swaps = 0;\n      let pass = 0;\n\n      let gen = null;\n      let playing = false;\n      let autoTimer = null;\n\n      function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }\n\n      function createArray(n){\n        const arr = [];\n        // spread values so bar heights vary\n        for(let i=0;i<n;i++) arr.push(randInt(10, 100));\n        return arr;\n      }\n\n      function renderArray(arr){\n        barsEl.innerHTML = '';\n        bars = [];\n        const max = Math.max(...arr, 1);\n        for(let i=0;i<arr.length;i++){\n          const el = document.createElement('div');\n          el.className = 'bar normal';\n          el.style.height = (arr[i] / max * 100) + '%';\n          el.setAttribute('role','listitem');\n          el.setAttribute('aria-label','Value '+arr[i]);\n          const label = document.createElement('div');\n          label.className = 'val';\n          label.textContent = arr[i];\n          el.appendChild(label);\n          barsEl.appendChild(el);\n          bars.push(el);\n        }\n      }\n\n      function updateStats(){\n        compEl.textContent = comparisons;\n        swapsEl.textContent = swaps;\n        passEl.textContent = pass;\n      }\n\n      function resetHighlights(){\n        bars.forEach(b=>{ b.className='bar normal'; });\n      }\n\n      function markCompare(i,j){\n        resetHighlights();\n        if(bars[i]) bars[i].className='bar compare';\n        if(bars[j]) bars[j].className='bar compare';\n        indicesEl.textContent = i + ' / ' + j;\n      }\n      function markSwap(i,j){\n        if(bars[i]) bars[i].className='bar swap';\n        if(bars[j]) bars[j].className='bar swap';\n        indicesEl.textContent = i + ' / ' + j;\n      }\n      function markSorted(index){\n        if(bars[index]) bars[index].className='bar sorted';\n      }\n\n      // Bubble sort generator that yields actions for visualization\n      function* bubbleGen(arr, ascending=true){\n        const n = arr.length;\n        let i = 0;\n        while(i < n-1){\n          let swapped = false;\n          yield {type:'pass', pass:i+1};\n          for(let j=0;j<n-1-i;j++){\n            yield {type:'compare', i:j, j:j+1};\n            if( (ascending && arr[j] > arr[j+1]) || (!ascending && arr[j] < arr[j+1]) ){\n              // swap\n              [arr[j], arr[j+1]] = [arr[j+1], arr[j]];\n              yield {type:'swap', i:j, j:j+1};\n              swapped = true;\n            }\n          }\n          // after each pass, the last element in the unsorted portion is sorted\n          yield {type:'sortedIndex', index: n-1-i};\n          if(!swapped){\n            // early exit\n            yield {type:'done', early:true};\n            return;\n          }\n          i++;\n        }\n        // mark remaining as sorted\n        for(let k=0;k<n;k++){\n          yield {type:'sortedIndex', index:k};\n        }\n        yield {type:'done', early:false};\n      }\n\n      function applyAction(action){\n        switch(action.type){\n          case 'pass':\n            pass = action.pass;\n            statusEl.textContent = 'Running pass ' + pass;\n            break;\n          case 'compare':\n            comparisons++;\n            markCompare(action.i, action.j);\n            break;\n          case 'swap':\n            swaps++;\n            // swap heights and labels in DOM to reflect array change\n            const i = action.i, j = action.j;\n            // swap style height and textContent\n            const hi = bars[i].style.height;\n            const hj = bars[j].style.height;\n            const vi = bars[i].firstChild.textContent;\n            const vj = bars[j].firstChild.textContent;\n            bars[i].style.height = hj;\n            bars[j].style.height = hi;\n            bars[i].firstChild.textContent = vj;\n            bars[j].firstChild.textContent = vi;\n            markSwap(i,j);\n            break;\n          case 'sortedIndex':\n            markSorted(action.index);\n            break;\n          case 'done':\n            statusEl.textContent = action.early ? 'Done (early exit)' : 'Done';\n            resetControlsAfterFinish();\n            break;\n        }\n        updateStats();\n      }\n\n      function startAutoPlay(){\n        if(!gen) return;\n        playing = true;\n        startBtn.disabled = true;\n        pauseBtn.disabled = false;\n        stepBtn.disabled = true;\n        randomBtn.disabled = true;\n        sizeRange.disabled = true;\n        orderSelect.disabled = true;\n        statusEl.textContent = 'Playing';\n        const runStep = ()=>{\n          const res = gen.next();\n          if(res.done){\n            playing = false;\n            clearInterval(autoTimer);\n            resetControlsAfterFinish();\n            return;\n          }\n          applyAction(res.value);\n        };\n        // run first step immediately to be responsive\n        runStep();\n        autoTimer = setInterval(()=>{\n          // if paused externally, skip\n          if(!playing){ clearInterval(autoTimer); return; }\n          const res = gen.next();\n          if(res.done){\n            playing = false;\n            clearInterval(autoTimer);\n            resetControlsAfterFinish();\n            return;\n          }\n          applyAction(res.value);\n        }, Number(speedRange.value));\n      }\n\n      function resetControlsAfterFinish(){\n        startBtn.disabled = false;\n        pauseBtn.disabled = true;\n        stepBtn.disabled = false;\n        randomBtn.disabled = false;\n        sizeRange.disabled = false;\n        orderSelect.disabled = false;\n      }\n\n      // Event handlers\n      sizeRange.addEventListener('input', ()=>{\n        sizeVal.textContent = sizeRange.value;\n      });\n\n      speedRange.addEventListener('input', ()=>{\n        speedVal.textContent = speedRange.value;\n        // if playing, restart interval with new speed\n        if(playing){\n          if(autoTimer) clearInterval(autoTimer);\n          startAutoPlay();\n        }\n      });\n\n      randomBtn.addEventListener('click', ()=>{\n        const n = Number(sizeRange.value);\n        array = createArray(n);\n        initialArray = array.slice();\n        comparisons = swaps = pass = 0;\n        gen = null;\n        playing = false;\n        if(autoTimer) clearInterval(autoTimer);\n        resetHighlights();\n        renderArray(array);\n        updateStats();\n        statusEl.textContent = 'Ready';\n        resetBtn.disabled = false;\n      });\n\n      startBtn.addEventListener('click', ()=>{\n        if(!gen){\n          // create a new generator on a copy of the current DOM state\n          // ensure array matches what's currently displayed\n          array = bars.map(b => Number(b.firstChild.textContent));\n          gen = bubbleGen(array, orderSelect.value === 'asc');\n        }\n        if(playing) return;\n        startAutoPlay();\n      });\n\n      pauseBtn.addEventListener('click', ()=>{\n        playing = false;\n        if(autoTimer) clearInterval(autoTimer);\n        startBtn.disabled = false;\n        pauseBtn.disabled = true;\n        stepBtn.disabled = false;\n        statusEl.textContent = 'Paused';\n      });\n\n      stepBtn.addEventListener('click', ()=>{\n        if(!gen){\n          array = bars.map(b => Number(b.firstChild.textContent));\n          gen = bubbleGen(array, orderSelect.value === 'asc');\n        }\n        const res = gen.next();\n        if(res.done){\n          resetControlsAfterFinish();\n          return;\n        }\n        applyAction(res.value);\n      });\n\n      resetBtn.addEventListener('click', ()=>{\n        // reset to initial array before sorting\n        if(initialArray.length){\n          array = initialArray.slice();\n          renderArray(array);\n          comparisons = swaps = pass = 0;\n          updateStats();\n          gen = null;\n          playing = false;\n          if(autoTimer) clearInterval(autoTimer);\n          statusEl.textContent = 'Reset';\n        } else {\n          // otherwise randomize\n          randomBtn.click();\n        }\n      });\n\n      // Initialize\n      (function init(){\n        sizeVal.textContent = sizeRange.value;\n        speedVal.textContent = speedRange.value;\n        array = createArray(Number(sizeRange.value));\n        initialArray = array.slice();\n        renderArray(array);\n        updateStats();\n        statusEl.textContent = 'Ready';\n      })();\n\n      // Keyboard shortcuts (optional)\n      window.addEventListener('keydown', (e)=>{\n        if(e.key === ' ') { e.preventDefault(); if(!playing) startBtn.click(); else pauseBtn.click(); }\n        if(e.key === 's') stepBtn.click();\n        if(e.key === 'r') randomBtn.click();\n      });\n    })();\n  </script>\n</body>\n</html>",
      "refusal": null,
      "annotations": []
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "bubble sort"
      }
    ],
    "evaluation": {
      "score": 5,
      "notes": "完美"
    }
  },
  {
    "id": "9a3a1fb0-98ad-11f0-9549-2f493c823853",
    "model": "gemini-2.5-pro",
    "timestamp": "2025-09-23T18:46:23.276Z",
    "question": "bubble sort",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interactive Bubble Sort Visualization</title>\n    <style>\n        :root {\n            --bg-color: #1a1a2e;\n            --primary-color: #e94560;\n            --secondary-color: #16213e;\n            --accent-color: #0f3460;\n            --text-color: #dcdce6;\n            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            \n            --bar-default-color: #53a8b6;\n            --bar-compare-color: #e94560;\n            --bar-swap-color: #ffc947;\n            --bar-sorted-color: #4caf50;\n            \n            --border-radius: 8px;\n            --shadow: 0 4px 12px rgba(0,0,0,0.3);\n        }\n\n        body {\n            font-family: var(--font-family);\n            background-color: var(--bg-color);\n            color: var(--text-color);\n            margin: 0;\n            padding: 1em;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            min-height: 100vh;\n        }\n\n        bubble-sort-visualizer {\n            width: 100%;\n            max-width: 1200px;\n            display: block;\n        }\n\n        .main-container {\n            display: flex;\n            flex-direction: column;\n            gap: 1.5em;\n            background-color: var(--secondary-color);\n            padding: 2em;\n            border-radius: var(--border-radius);\n            box-shadow: var(--shadow);\n        }\n\n        h1 {\n            text-align: center;\n            color: var(--primary-color);\n            margin-top: 0;\n            font-size: 2.5em;\n            text-shadow: 0 0 10px var(--primary-color);\n        }\n\n        .visualization-area {\n            display: flex;\n            justify-content: center;\n            align-items: flex-end;\n            height: 400px;\n            padding: 1em;\n            background: var(--accent-color);\n            border-radius: var(--border-radius);\n            gap: 2px;\n            transition: all 0.3s ease;\n        }\n    </style>\n</head>\n<body>\n\n    <bubble-sort-visualizer></bubble-sort-visualizer>\n\n    <script>\n    // Utility function for delaying execution\n    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n    // Web Component: <array-bar>\n    class ArrayBar extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n            this.shadowRoot.innerHTML = `\n                <style>\n                    :host {\n                        display: inline-block;\n                        width: 100%;\n                        transition: height 0.2s ease, background-color 0.2s ease;\n                    }\n                    .bar {\n                        background-color: var(--bar-default-color);\n                        height: 100%;\n                        border-top-left-radius: 4px;\n                        border-top-right-radius: 4px;\n                    }\n                    :host([state=\"comparing\"]) .bar {\n                        background-color: var(--bar-compare-color);\n                    }\n                    :host([state=\"swapping\"]) .bar {\n                        background-color: var(--bar-swap-color);\n                    }\n                    :host([state=\"sorted\"]) .bar {\n                        background-color: var(--bar-sorted-color);\n                    }\n                </style>\n                <div class=\"bar\"></div>\n            `;\n        }\n\n        static get observedAttributes() {\n            return ['value', 'state'];\n        }\n\n        attributeChangedCallback(name, oldValue, newValue) {\n            if (name === 'value') {\n                this.style.height = `${newValue}%`;\n            } else if (name === 'state') {\n                this.shadowRoot.querySelector('.bar').className = 'bar'; // Reset\n            }\n        }\n    }\n    customElements.define('array-bar', ArrayBar);\n\n\n    // Web Component: <control-panel>\n    class ControlPanel extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n            this.shadowRoot.innerHTML = `\n                <style>\n                    .controls {\n                        display: flex;\n                        flex-wrap: wrap;\n                        gap: 1.5em;\n                        justify-content: center;\n                        align-items: center;\n                        padding: 1em;\n                        background: var(--accent-color);\n                        border-radius: var(--border-radius);\n                    }\n                    .control-group {\n                        display: flex;\n                        flex-direction: column;\n                        align-items: center;\n                        gap: 0.5em;\n                    }\n                    label {\n                        font-size: 0.9em;\n                        font-weight: bold;\n                    }\n                    button {\n                        background-color: var(--primary-color);\n                        color: var(--text-color);\n                        border: none;\n                        padding: 10px 20px;\n                        border-radius: var(--border-radius);\n                        cursor: pointer;\n                        font-weight: bold;\n                        transition: all 0.2s ease;\n                    }\n                    button:hover:not(:disabled) {\n                        transform: translateY(-2px);\n                        box-shadow: 0 2px 8px rgba(233, 69, 96, 0.5);\n                    }\n                    button:disabled {\n                        background-color: #555;\n                        cursor: not-allowed;\n                    }\n                    .button-group {\n                        display: flex;\n                        gap: 1em;\n                    }\n                    input[type=\"range\"] {\n                        -webkit-appearance: none;\n                        appearance: none;\n                        width: 150px;\n                        height: 8px;\n                        background: #3f51b5;\n                        outline: none;\n                        opacity: 0.7;\n                        transition: opacity .2s;\n                        border-radius: 4px;\n                    }\n                    input[type=\"range\"]:hover {\n                        opacity: 1;\n                    }\n                    input[type=\"range\"]::-webkit-slider-thumb {\n                        -webkit-appearance: none;\n                        appearance: none;\n                        width: 20px;\n                        height: 20px;\n                        background: var(--primary-color);\n                        cursor: pointer;\n                        border-radius: 50%;\n                    }\n                    input[type=\"range\"]::-moz-range-thumb {\n                        width: 20px;\n                        height: 20px;\n                        background: var(--primary-color);\n                        cursor: pointer;\n                        border-radius: 50%;\n                    }\n                </style>\n                <div class=\"controls\">\n                    <button id=\"new-array\">New Array</button>\n                    <div class=\"control-group\">\n                        <label for=\"size\">Array Size: <span id=\"size-value\">50</span></label>\n                        <input type=\"range\" id=\"size\" min=\"10\" max=\"100\" value=\"50\">\n                    </div>\n                    <div class=\"control-group\">\n                        <label for=\"speed\">Animation Speed: <span id=\"speed-value\">50</span></label>\n                        <input type=\"range\" id=\"speed\" min=\"1\" max=\"100\" value=\"50\">\n                    </div>\n                    <div class=\"button-group\">\n                        <button id=\"start\">Start Sort</button>\n                        <button id=\"pause\" disabled>Pause</button>\n                        <button id=\"reset\" disabled>Reset</button>\n                    </div>\n                </div>\n            `;\n\n            this._bindEvents();\n        }\n\n        _bindEvents() {\n            const dispatch = (eventName, detail) => {\n                this.dispatchEvent(new CustomEvent(eventName, { bubbles: true, composed: true, detail }));\n            };\n\n            this.shadowRoot.getElementById('new-array').addEventListener('click', () => dispatch('newarray'));\n            \n            const sizeSlider = this.shadowRoot.getElementById('size');\n            sizeSlider.addEventListener('input', (e) => {\n                this.shadowRoot.getElementById('size-value').textContent = e.target.value;\n            });\n            sizeSlider.addEventListener('change', (e) => dispatch('sizechange', { value: e.target.value }));\n            \n            const speedSlider = this.shadowRoot.getElementById('speed');\n            speedSlider.addEventListener('input', (e) => {\n                this.shadowRoot.getElementById('speed-value').textContent = e.target.value;\n                dispatch('speedchange', { value: e.target.value });\n            });\n\n            this.shadowRoot.getElementById('start').addEventListener('click', () => dispatch('start'));\n            this.shadowRoot.getElementById('pause').addEventListener('click', () => dispatch('pause'));\n            this.shadowRoot.getElementById('reset').addEventListener('click', () => dispatch('reset'));\n        }\n\n        setButtonState(state) {\n            const startBtn = this.shadowRoot.getElementById('start');\n            const pauseBtn = this.shadowRoot.getElementById('pause');\n            const resetBtn = this.shadowRoot.getElementById('reset');\n            const sizeSlider = this.shadowRoot.getElementById('size');\n            const newArrayBtn = this.shadowRoot.getElementById('new-array');\n\n            startBtn.disabled = true;\n            pauseBtn.disabled = true;\n            resetBtn.disabled = true;\n            sizeSlider.disabled = false;\n            newArrayBtn.disabled = false;\n            pauseBtn.textContent = 'Pause';\n\n\n            switch(state) {\n                case 'initial':\n                    startBtn.disabled = false;\n                    break;\n                case 'sorting':\n                    pauseBtn.disabled = false;\n                    resetBtn.disabled = false;\n                    sizeSlider.disabled = true;\n                    newArrayBtn.disabled = true;\n                    break;\n                case 'paused':\n                    pauseBtn.disabled = false;\n                    pauseBtn.textContent = 'Resume';\n                    resetBtn.disabled = false;\n                    break;\n                case 'finished':\n                    resetBtn.disabled = false;\n                    break;\n            }\n        }\n    }\n    customElements.define('control-panel', ControlPanel);\n\n\n    // Web Component: <info-panel>\n    class InfoPanel extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n            this.shadowRoot.innerHTML = `\n                <style>\n                    .info-container {\n                        display: grid;\n                        grid-template-columns: 1fr 1fr;\n                        gap: 1.5em;\n                        padding: 1em;\n                        background: var(--accent-color);\n                        border-radius: var(--border-radius);\n                    }\n                    .explanation, .code-display {\n                        padding: 1.5em;\n                        background-color: var(--secondary-color);\n                        border-radius: var(--border-radius);\n                    }\n                    h3 {\n                        margin-top: 0;\n                        color: var(--primary-color);\n                    }\n                    p {\n                        line-height: 1.6;\n                        margin: 0;\n                    }\n                    #status-message {\n                        font-weight: bold;\n                        min-height: 1.6em; /* Prevent layout shift */\n                    }\n                    pre {\n                        background-color: #111;\n                        padding: 1em;\n                        border-radius: var(--border-radius);\n                        overflow-x: auto;\n                    }\n                    code {\n                        font-family: 'Courier New', Courier, monospace;\n                        font-size: 0.95em;\n                    }\n                    .code-line {\n                        display: block;\n                        transition: background-color 0.3s;\n                        padding: 2px 8px;\n                        border-radius: 4px;\n                    }\n                    .highlight {\n                        background-color: rgba(233, 69, 96, 0.4);\n                    }\n                </style>\n                <div class=\"info-container\">\n                    <div class=\"explanation\">\n                        <h3>How Bubble Sort Works</h3>\n                        <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.</p>\n                        <br>\n                        <p id=\"status-message\">Ready to sort. Press 'Start'.</p>\n                    </div>\n                    <div class=\"code-display\">\n                        <h3>Algorithm Pseudocode</h3>\n                        <pre><code>\n<span class=\"code-line\" data-line=\"1\"><b>function</b> bubbleSort(array) {</span>\n<span class=\"code-line\" data-line=\"2\">  <b>let</b> n = array.length;</span>\n<span class=\"code-line\" data-line=\"3\">  <b>for</b> (i = 0; i < n - 1; i++) {</span>\n<span class=\"code-line\" data-line=\"4\">    <b>for</b> (j = 0; j < n - i - 1; j++) {</span>\n<span class=\"code-line\" data-line=\"5\">      <b>if</b> (array[j] > array[j + 1]) {</span>\n<span class=\"code-line\" data-line=\"6\">        swap(array[j], array[j + 1]);</span>\n<span class=\"code-line\" data-line=\"7\">      }</span>\n<span class=\"code-line\" data-line=\"8\">    }</span>\n<span class=\"code-line\" data-line=\"9\">  }</span>\n<span class=\"code-line\" data-line=\"10\">}</span>\n                        </code></pre>\n                    </div>\n                </div>\n            `;\n        }\n\n        update({ message, line }) {\n            this.shadowRoot.getElementById('status-message').textContent = message;\n            \n            this.shadowRoot.querySelectorAll('.code-line').forEach(el => el.classList.remove('highlight'));\n            if (line) {\n                const lineEl = this.shadowRoot.querySelector(`.code-line[data-line=\"${line}\"]`);\n                if(lineEl) lineEl.classList.add('highlight');\n            }\n        }\n    }\n    customElements.define('info-panel', InfoPanel);\n\n    \n    // Main Orchestrator Component: <bubble-sort-visualizer>\n    class BubbleSortVisualizer extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n\n            this.state = {\n                array: [],\n                originalArray: [],\n                arraySize: 50,\n                speed: 50, // 1-100 scale\n                isSorting: false,\n                isPaused: false,\n                abortController: null,\n            };\n\n            this.shadowRoot.innerHTML = `\n                <div class=\"main-container\">\n                    <h1>Bubble Sort Visualization</h1>\n                    <control-panel></control-panel>\n                    <div class=\"visualization-area\"></div>\n                    <info-panel></info-panel>\n                </div>\n            `;\n\n            this.visualizationArea = this.shadowRoot.querySelector('.visualization-area');\n            this.controlPanel = this.shadowRoot.querySelector('control-panel');\n            this.infoPanel = this.shadowRoot.querySelector('info-panel');\n        }\n\n        connectedCallback() {\n            this.generateNewArray();\n            this.controlPanel.setButtonState('initial');\n\n            this.addEventListener('newarray', this.handleNewArray);\n            this.addEventListener('sizechange', this.handleSizeChange);\n            this.addEventListener('speedchange', this.handleSpeedChange);\n            this.addEventListener('start', this.handleStart);\n            this.addEventListener('pause', this.handlePause);\n            this.addEventListener('reset', this.handleReset);\n        }\n\n        // --- Event Handlers ---\n        handleNewArray = () => {\n            this.generateNewArray();\n        }\n\n        handleSizeChange = (e) => {\n            this.state.arraySize = parseInt(e.detail.value, 10);\n            this.generateNewArray();\n        }\n\n        handleSpeedChange = (e) => {\n            // Invert and scale speed for a more intuitive feel (higher slider value = faster)\n            this.state.speed = 101 - parseInt(e.detail.value, 10);\n        }\n\n\n        handleStart = () => {\n            if (this.state.isSorting) return;\n            this.state.isSorting = true;\n            this.state.isPaused = false;\n            this.state.abortController = new AbortController();\n            this.controlPanel.setButtonState('sorting');\n            this.runSort();\n        };\n\n        handlePause = () => {\n            this.state.isPaused = !this.state.isPaused;\n            this.controlPanel.setButtonState(this.state.isPaused ? 'paused' : 'sorting');\n        };\n\n        handleReset = () => {\n            if (this.state.abortController) {\n                this.state.abortController.abort();\n            }\n            this.state.isSorting = false;\n            this.state.isPaused = false;\n            this.state.array = [...this.state.originalArray];\n            this.renderArray();\n            this.controlPanel.setButtonState('initial');\n            this.infoPanel.update({ message: \"Sort reset. Ready to start again.\", line: null });\n        };\n\n        // --- Core Logic & Rendering ---\n\n        generateNewArray() {\n            this.state.array = [];\n            for (let i = 0; i < this.state.arraySize; i++) {\n                this.state.array.push(Math.floor(Math.random() * 95) + 5); // Values from 5 to 100\n            }\n            this.state.originalArray = [...this.state.array];\n            this.renderArray();\n            this.controlPanel.setButtonState('initial');\n            this.infoPanel.update({ message: \"New array generated. Press 'Start' to sort.\", line: null });\n        }\n\n        renderArray(states = {}) {\n            this.visualizationArea.innerHTML = '';\n            this.state.array.forEach((value, index) => {\n                const bar = document.createElement('array-bar');\n                bar.setAttribute('value', value);\n                if (states[index]) {\n                    bar.setAttribute('state', states[index]);\n                }\n                this.visualizationArea.appendChild(bar);\n            });\n        }\n        \n        async *bubbleSortGenerator() {\n            let arr = this.state.array;\n            let n = arr.length;\n            let swapped;\n            for (let i = 0; i < n - 1; i++) {\n                swapped = false;\n                yield { type: 'pass_start', pass: i + 1, line: 3 };\n                for (let j = 0; j < n - i - 1; j++) {\n                    yield { type: 'compare', indices: [j, j + 1], line: 5 };\n                    if (arr[j] > arr[j + 1]) {\n                        yield { type: 'swap_start', indices: [j, j + 1], line: 6 };\n                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n                        swapped = true;\n                        yield { type: 'swap_end', indices: [j, j + 1], line: 6 };\n                    }\n                }\n                yield { type: 'sorted', index: n - 1 - i, line: 8 };\n                if (!swapped) {\n                    // Optimization: if no swaps in a pass, array is sorted\n                    break;\n                }\n            }\n            // Mark all remaining as sorted if we broke early\n            for(let k = 0; k < n; k++) {\n                yield { type: 'sorted', index: k, line: 9 };\n            }\n        }\n        \n        async runSort() {\n            const generator = this.bubbleSortGenerator();\n            const sortedIndices = new Set();\n            const { signal } = this.state.abortController;\n\n            try {\n                for await (const step of generator) {\n                    if (signal.aborted) return;\n                    \n                    while(this.state.isPaused) {\n                        if (signal.aborted) return;\n                        await sleep(100);\n                    }\n                    \n                    const states = {};\n                    sortedIndices.forEach(i => states[i] = 'sorted');\n\n                    switch(step.type) {\n                        case 'pass_start':\n                            this.infoPanel.update({ message: `Starting Pass ${step.pass}...`, line: step.line });\n                            break;\n                            \n                        case 'compare':\n                            const [i, j] = step.indices;\n                            this.infoPanel.update({ message: `Comparing elements at index ${i} (${this.state.array[i]}) and ${j} (${this.state.array[j]})`, line: step.line });\n                            states[i] = 'comparing';\n                            states[j] = 'comparing';\n                            this.renderArray(states);\n                            break;\n\n                        case 'swap_start':\n                             const [i_swap, j_swap] = step.indices;\n                             this.infoPanel.update({ message: `Swapping ${this.state.array[i_swap]} and ${this.state.array[j_swap]}`, line: step.line });\n                             states[i_swap] = 'swapping';\n                             states[j_swap] = 'swapping';\n                             this.renderArray(states);\n                             break;\n                        \n                        case 'swap_end':\n                             this.renderArray(states); // Rerender with default colors after swap logic\n                             break;\n\n                        case 'sorted':\n                            sortedIndices.add(step.index);\n                            states[step.index] = 'sorted';\n                            this.renderArray(states);\n                            this.infoPanel.update({ message: `Element ${this.state.array[step.index]} is now in its final sorted position.`, line: step.line });\n                            break;\n                    }\n                    await sleep(this.state.speed * 5);\n                }\n\n                this.infoPanel.update({ message: 'Array is sorted!', line: 10 });\n                this.controlPanel.setButtonState('finished');\n                this.state.isSorting = false;\n\n            } catch (error) {\n                if (error.name !== 'AbortError') {\n                    console.error(\"Sorting error:\", error);\n                }\n            }\n        }\n    }\n    customElements.define('bubble-sort-visualizer', BubbleSortVisualizer);\n\n    </script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user given concept. It should be highly interactive and utilize multiple web components to show the concept step by step. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "bubble sort"
      }
    ],
    "evaluation": {
      "score": 1,
      "notes": "ui错位严重，不能运行"
    }
  },
  {
    "id": "6a961ec0-98ae-11f0-8ac7-23deb0280825",
    "model": "gpt-5-mini",
    "timestamp": "2025-09-23T18:52:12.845Z",
    "question": "bubble sort",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<title>Interactive Bubble Sort Visualizer</title>\n<style>\n  :root{\n    --bg: #0f1724;\n    --panel: #0b1220;\n    --accent: #00d4ff;\n    --muted: #94a3b8;\n    --success: #22c55e;\n    --danger: #fb7185;\n    --glass: rgba(255,255,255,0.03);\n    font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n  }\n  html,body{\n    height:100%;\n    margin:0;\n    background:linear-gradient(180deg,#071024 0%, #061026 60%);\n    color: #e6eef8;\n  }\n  header{\n    display:flex;\n    gap:16px;\n    align-items:center;\n    padding:18px 28px;\n    background:transparent;\n  }\n  h1{\n    font-size:18px;\n    margin:0;\n    color:var(--accent);\n    letter-spacing:0.6px;\n  }\n  .app{\n    padding:18px 28px;\n    display:grid;\n    grid-template-columns: 520px 1fr;\n    gap:18px;\n    align-items:start;\n  }\n  .left, .right{\n    background:var(--panel);\n    border-radius:12px;\n    padding:14px;\n    box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n    min-height:320px;\n  }\n  .left{\n    display:flex;\n    flex-direction:column;\n    gap:12px;\n  }\n\n  controls-panel {\n    display:block;\n    padding:8px;\n    background:var(--glass);\n    border-radius:10px;\n  }\n  array-visualizer {\n    display:block;\n    height:300px;\n  }\n\n  .toolbar{\n    display:flex;\n    gap:8px;\n    align-items:center;\n  }\n  button, .btn {\n    background:linear-gradient(180deg,#071827,#04202b);\n    color:#e7f4ff;\n    border-radius:8px;\n    padding:8px 10px;\n    border:1px solid rgba(255,255,255,0.04);\n    cursor:pointer;\n    font-size:13px;\n  }\n  button.secondary{\n    background:transparent;\n    border:1px solid rgba(255,255,255,0.06);\n    color:var(--muted);\n  }\n  .small{\n    padding:6px 8px;\n    font-size:12px;\n  }\n\n  .panel-row{\n    display:flex;\n    gap:10px;\n    align-items:center;\n  }\n  .range {\n    width:100%;\n  }\n  .code-panel{\n    background:#071732;\n    padding:12px;\n    border-radius:10px;\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", \"Courier New\", monospace;\n    font-size:13px;\n    line-height:1.5;\n    color:#cfefff;\n    white-space:pre;\n    overflow:auto;\n    max-height:420px;\n  }\n\n  .line {\n    padding:2px 8px;\n    border-radius:6px;\n    display:block;\n  }\n  .line.highlight{\n    background:linear-gradient(90deg, rgba(0,212,255,0.08), rgba(0,212,255,0.02));\n    color:var(--accent);\n  }\n  .muted {\n    color:var(--muted);\n    font-size:13px;\n  }\n\n  .stats {\n    display:flex;\n    gap:10px;\n    flex-wrap:wrap;\n  }\n  .stat {\n    background:linear-gradient(90deg, rgba(255,255,255,0.02), transparent);\n    padding:8px;\n    border-radius:8px;\n    min-width:88px;\n    text-align:center;\n  }\n  .stat .v {\n    font-weight:700;\n    font-size:16px;\n    color:var(--accent);\n  }\n\n  footer{\n    margin-top:16px;\n    color:var(--muted);\n    font-size:13px;\n  }\n\n  /* Visualizer styles */\n  .vis {\n    position:relative;\n    height:300px;\n    display:flex;\n    align-items:end;\n    gap:8px;\n    padding:18px 12px;\n    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);\n    border-radius:10px;\n    overflow:hidden;\n  }\n  .bar {\n    --w: 28px;\n    width:var(--w);\n    background:linear-gradient(180deg,#06b6d4,#0284c7);\n    border-radius:6px 6px 4px 4px;\n    display:flex;\n    align-items:flex-end;\n    justify-content:center;\n    color:rgba(255,255,255,0.92);\n    font-weight:700;\n    transform:translateY(0);\n    transition: transform 400ms ease, height 400ms ease;\n    position:relative;\n    box-shadow: 0 8px 20px rgba(0,0,0,0.45);\n  }\n  .bar .label {\n    padding:6px 4px;\n    font-size:12px;\n    color:rgba(255,255,255,0.95);\n    transform:translateY(4px);\n  }\n  .bar.compare {\n    outline:3px solid rgba(255,196,27,0.14);\n    box-shadow: 0 10px 28px rgba(255,196,27,0.06);\n  }\n  .bar.swap {\n    outline:4px solid rgba(99,102,241,0.16);\n    box-shadow: 0 10px 30px rgba(99,102,241,0.08);\n  }\n  .bar.sorted {\n    background:linear-gradient(180deg,#16a34a,#059669);\n  }\n  .legend {\n    display:flex;\n    gap:12px;\n    align-items:center;\n    font-size:13px;\n    color:var(--muted);\n  }\n  .legend .dot {\n    width:12px;height:12px;border-radius:3px;display:inline-block;margin-right:6px;\n  }\n  .dot.compare { background: rgba(255,196,27,0.85); }\n  .dot.swap { background: rgba(99,102,241,0.9); }\n  .dot.sorted { background: linear-gradient(180deg,#16a34a,#059669); }\n\n  .explain {\n    font-size:13px;\n    color:var(--muted);\n  }\n\n  /* responsive */\n  @media (max-width:980px){\n    .app { grid-template-columns: 1fr; padding:14px; }\n  }\n\n</style>\n</head>\n<body>\n<header>\n  <h1>Bubble Sort — Interactive Step-by-Step Visualizer</h1>\n</header>\n\n<div class=\"app\">\n  <div class=\"left\">\n    <controls-panel></controls-panel>\n    <array-visualizer></array-visualizer>\n    <div class=\"legend\" style=\"justify-content:space-between\">\n      <div style=\"display:flex;gap:12px;align-items:center\">\n        <div><span class=\"dot compare\"></span> Comparing</div>\n        <div><span class=\"dot swap\"></span> Swapping</div>\n        <div><span class=\"dot sorted\"></span> Final/Sorted</div>\n      </div>\n      <div class=\"explain\">Tip: Use Step to advance one operation. Play to animate full sort. Toggle \"Optimized\" for early exit.</div>\n    </div>\n  </div>\n\n  <div class=\"right\">\n    <div style=\"display:flex;gap:12px;align-items:flex-start\">\n      <div style=\"flex:1\">\n        <div style=\"display:flex;gap:10px;align-items:center;margin-bottom:8px\">\n          <div class=\"panel-row\" style=\"gap:8px;\">\n            <label class=\"muted\">Order:</label>\n            <select id=\"orderSelect\" style=\"padding:6px;border-radius:8px;background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04)\">\n              <option value=\"asc\">Ascending</option>\n              <option value=\"desc\">Descending</option>\n            </select>\n            <label class=\"muted\">Optimized:</label>\n            <input type=\"checkbox\" id=\"optCheckbox\" />\n          </div>\n        </div>\n\n        <div class=\"stats\" style=\"margin-bottom:10px\">\n          <div class=\"stat\">\n            <div class=\"muted\">Comparisons</div>\n            <div id=\"compCount\" class=\"v\">0</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"muted\">Swaps</div>\n            <div id=\"swapCount\" class=\"v\">0</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"muted\">Pass</div>\n            <div id=\"passCount\" class=\"v\">0</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"muted\">Elements</div>\n            <div id=\"lenCount\" class=\"v\">8</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"muted\">Status</div>\n            <div id=\"status\" class=\"v\">idle</div>\n          </div>\n        </div>\n\n        <div class=\"panel-row\" style=\"gap:8px;margin-bottom:8px\">\n          <button id=\"stepBtn\" class=\"small\">Step</button>\n          <button id=\"backBtn\" class=\"small secondary\">Back</button>\n          <button id=\"playBtn\" class=\"small\">Play</button>\n          <button id=\"pauseBtn\" class=\"small secondary\" disabled>Pause</button>\n          <button id=\"resetBtn\" class=\"small secondary\">Reset</button>\n          <div style=\"flex:1\"></div>\n        </div>\n\n        <div style=\"margin-bottom:10px; display:flex; gap:8px; align-items:center;\">\n          <label class=\"muted\">Speed</label>\n          <input id=\"speed\" class=\"range\" type=\"range\" min=\"0\" max=\"1000\" value=\"400\" />\n        </div>\n      </div>\n    </div>\n\n    <div style=\"display:flex;gap:12px; margin-top:6px;\">\n      <div style=\"flex:1\">\n        <div class=\"code-panel\" id=\"codePanel\" aria-hidden=\"false\"></div>\n      </div>\n    </div>\n\n    <footer style=\"margin-top:10px\">This interactive demo illustrates the inner workings of Bubble Sort. You can customize the array, watch comparisons and swaps, and step through the algorithm to understand why it's O(n^2) in the average and worst case.</footer>\n  </div>\n</div>\n\n<!-- Templates for web components -->\n<template id=\"controls-template\">\n  <style>\n    :host{display:block}\n    .wrap{display:flex;flex-direction:column;gap:10px}\n    .row{display:flex;gap:8px;align-items:center}\n    input[type=\"text\"]{padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);flex:1}\n    .mini{font-size:13px;padding:6px 8px}\n  </style>\n  <div class=\"wrap\">\n    <div class=\"row\">\n      <label class=\"muted\" style=\"min-width:72px\">Array:</label>\n      <input id=\"arrayInput\" type=\"text\" placeholder=\"e.g. 5,3,8,1,2 or leave blank for random\" />\n      <button id=\"apply\" class=\"mini\">Apply</button>\n    </div>\n    <div class=\"row\">\n      <label class=\"muted\" style=\"min-width:72px\">Size:</label>\n      <input id=\"size\" type=\"range\" min=\"3\" max=\"20\" value=\"8\" />\n      <div id=\"sizeVal\" class=\"muted\">8</div>\n      <button id=\"rand\" class=\"mini\">Randomize</button>\n    </div>\n    <div class=\"row\">\n      <label class=\"muted\" style=\"min-width:72px\">Values:</label>\n      <button id=\"seed1\" class=\"mini\">Easy</button>\n      <button id=\"seed2\" class=\"mini\">Reverse</button>\n      <button id=\"seed3\" class=\"mini\">Duplicate</button>\n    </div>\n  </div>\n</template>\n\n<template id=\"visualizer-template\">\n  <style>\n    :host{display:block}\n    .visWrap{display:flex;flex-direction:column;gap:8px}\n    .vis{height:300px;position:relative}\n  </style>\n  <div class=\"visWrap\">\n    <div class=\"vis\" id=\"visArea\" role=\"img\" aria-label=\"Array visualization\"></div>\n  </div>\n</template>\n\n<script>\n/*\n  Bubble Sort Visualizer\n  - Uses custom elements: controls-panel, array-visualizer\n  - Core logic in the main script: generator for step actions, history snapshots\n  - Supports play/pause, step/back, speed control, optimized early exit, ascending/descending\n*/\n\n// Utility\nconst clamp = (v,a,b) => Math.max(a, Math.min(b, v));\nconst sleep = ms => new Promise(r=>setTimeout(r,ms));\n\n// Controls Panel Component\nclass ControlsPanel extends HTMLElement {\n  constructor(){\n    super();\n    this.attachShadow({mode:'open'});\n    this.shadowRoot.appendChild(document.getElementById('controls-template').content.cloneNode(true));\n  }\n  connectedCallback(){\n    this.arrayInput = this.shadowRoot.querySelector('#arrayInput');\n    this.applyBtn = this.shadowRoot.querySelector('#apply');\n    this.size = this.shadowRoot.querySelector('#size');\n    this.sizeVal = this.shadowRoot.querySelector('#sizeVal');\n    this.randBtn = this.shadowRoot.querySelector('#rand');\n    this.seed1 = this.shadowRoot.querySelector('#seed1');\n    this.seed2 = this.shadowRoot.querySelector('#seed2');\n    this.seed3 = this.shadowRoot.querySelector('#seed3');\n\n    this.size.addEventListener('input', ()=> {\n      this.sizeVal.textContent = this.size.value;\n      this.emit('size-change', {size: Number(this.size.value)});\n    });\n    this.applyBtn.addEventListener('click', ()=> {\n      this.emit('apply-array', {text:this.arrayInput.value});\n    });\n    this.randBtn.addEventListener('click', ()=> {\n      this.emit('randomize', {size: Number(this.size.value)});\n    });\n    this.seed1.addEventListener('click', ()=> {\n      this.emit('preset', {type: 'easy', size: Number(this.size.value)});\n    });\n    this.seed2.addEventListener('click', ()=> {\n      this.emit('preset', {type: 'reverse', size: Number(this.size.value)});\n    });\n    this.seed3.addEventListener('click', ()=> {\n      this.emit('preset', {type: 'duplicates', size: Number(this.size.value)});\n    });\n  }\n  emit(name, detail){\n    this.dispatchEvent(new CustomEvent(name, {detail, bubbles:true, composed:true}));\n  }\n}\ncustomElements.define('controls-panel', ControlsPanel);\n\n// Array Visualizer Component\nclass ArrayVisualizer extends HTMLElement {\n  constructor(){\n    super();\n    this.attachShadow({mode:'open'});\n    this.shadowRoot.appendChild(document.getElementById('visualizer-template').content.cloneNode(true));\n    this.container = this.shadowRoot.getElementById('visArea');\n    this.bars = [];\n    this.positions = []; // maps index -> x position\n  }\n\n  setArray(arr){\n    this.array = arr.slice();\n    this.render();\n  }\n\n  // Create bars\n  render(){\n    const n = this.array.length;\n    this.container.innerHTML = '';\n    this.bars = [];\n    const gap = 8;\n    const totalGap = gap*(n-1);\n    const width = this.container.clientWidth || 480;\n    // width per bar: try to fit\n    let barWidth = Math.floor((width - totalGap - 40) / n);\n    barWidth = Math.max(18, Math.min(60, barWidth));\n    const maxVal = Math.max(...this.array.map(v=>Math.abs(v)), 1);\n    for(let i=0;i<n;i++){\n      const val = this.array[i];\n      const bar = document.createElement('div');\n      bar.className = 'bar';\n      bar.style.setProperty('--w', barWidth+'px');\n      const heightPct = Math.max(6, Math.round((Math.abs(val)/maxVal) * 88)); // percent of area\n      bar.style.height = heightPct + '%';\n      bar.dataset.index = i;\n      bar.dataset.value = val;\n      const label = document.createElement('div');\n      label.className = 'label';\n      label.textContent = val;\n      bar.appendChild(label);\n      this.container.appendChild(bar);\n      this.bars.push(bar);\n    }\n    // create simple horizontal layout using flex; we will animate by swapping heights/labels and classes\n  }\n\n  markCompare(i,j){\n    this.clearStates();\n    if(this.bars[i]) this.bars[i].classList.add('compare');\n    if(this.bars[j]) this.bars[j].classList.add('compare');\n  }\n  markSwap(i,j){\n    this.clearStates();\n    if(this.bars[i]) this.bars[i].classList.add('swap');\n    if(this.bars[j]) this.bars[j].classList.add('swap');\n  }\n  markSorted(idxStart){\n    // mark elements from idxStart..end as sorted (for ascending bubble final pass)\n    this.bars.forEach((b,idx)=> {\n      b.classList.remove('compare','swap');\n      if(idx >= idxStart) b.classList.add('sorted');\n    });\n  }\n  clearStates(){\n    this.bars.forEach(b=>{\n      b.classList.remove('compare','swap');\n      // keep 'sorted' until reset\n    });\n  }\n  // Apply swap visually by swapping heights and labels\n  async swap(i,j, duration=400){\n    if(i===j) return;\n    // swap values in DOM\n    const bi = this.bars[i];\n    const bj = this.bars[j];\n    if(!bi || !bj) return;\n\n    // animate: use transform swap (simple)\n    bi.style.transition = `transform ${duration}ms ease`;\n    bj.style.transition = `transform ${duration}ms ease`;\n\n    bi.style.transform = `translateX(${(j-i)*(bi.offsetWidth + 8)}px)`;\n    bj.style.transform = `translateX(${(i-j)*(bj.offsetWidth + 8)}px)`;\n\n    await sleep(duration);\n\n    // reset transforms\n    bi.style.transition = '';\n    bj.style.transition = '';\n    bi.style.transform = '';\n    bj.style.transform = '';\n\n    // swap heights and labels and dataset\n    const tempHeight = bi.style.height;\n    const tempLabel = bi.querySelector('.label').textContent;\n    const tempVal = bi.dataset.value;\n\n    bi.style.height = bj.style.height;\n    bi.querySelector('.label').textContent = bj.querySelector('.label').textContent;\n    bi.dataset.value = bj.dataset.value;\n\n    bj.style.height = tempHeight;\n    bj.querySelector('.label').textContent = tempLabel;\n    bj.dataset.value = tempVal;\n  }\n\n  updateArray(arr){\n    // update labels/heights to match arr (no animation)\n    this.array = arr.slice();\n    const maxVal = Math.max(...arr.map(v=>Math.abs(v)), 1);\n    for(let i=0;i<this.bars.length;i++){\n      const val = arr[i];\n      const heightPct = Math.max(6, Math.round((Math.abs(val)/maxVal) * 88));\n      const bar = this.bars[i];\n      bar.style.height = heightPct + '%';\n      bar.dataset.value = val;\n      bar.querySelector('.label').textContent = val;\n      bar.classList.remove('compare','swap','sorted');\n    }\n  }\n\n  markFinalSorted(){\n    this.bars.forEach(b=> {\n      b.classList.remove('compare','swap');\n      b.classList.add('sorted');\n    });\n  }\n}\ncustomElements.define('array-visualizer', ArrayVisualizer);\n\n\n// Main App Logic - tie components together\ndocument.addEventListener('DOMContentLoaded', ()=> {\n  const control = document.querySelector('controls-panel');\n  const vis = document.querySelector('array-visualizer');\n\n  // controls in right panel\n  const stepBtn = document.getElementById('stepBtn');\n  const backBtn = document.getElementById('backBtn');\n  const playBtn = document.getElementById('playBtn');\n  const pauseBtn = document.getElementById('pauseBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const speedInput = document.getElementById('speed');\n  const compCount = document.getElementById('compCount');\n  const swapCount = document.getElementById('swapCount');\n  const passCount = document.getElementById('passCount');\n  const lenCount = document.getElementById('lenCount');\n  const status = document.getElementById('status');\n  const orderSelect = document.getElementById('orderSelect');\n  const optCheckbox = document.getElementById('optCheckbox');\n  const codePanel = document.getElementById('codePanel');\n\n  // Pseudocode lines\n  const codeLines = [\n    'function bubbleSort(arr, ascending=true, optimized=false) {',\n    '  let n = arr.length;',\n    '  for (let i = 0; i < n - 1; i++) {',\n    '    let swapped = false;                       // start of pass',\n    '    for (let j = 0; j < n - 1 - i; j++) {',\n    '      if ((ascending && arr[j] > arr[j+1]) || (!ascending && arr[j] < arr[j+1])) {',\n    '        swap(arr, j, j+1);                     // swap elements',\n    '        swapped = true;',\n    '      }',\n    '    }',\n    '    if (optimized && !swapped) break;          // early exit',\n    '  }',\n    '}',\n  ];\n\n  function renderCode(highlightIdx=null){\n    codePanel.innerHTML = '';\n    for(let i=0;i<codeLines.length;i++){\n      const ln = document.createElement('div');\n      ln.className = 'line' + (i===highlightIdx ? ' highlight' : '');\n      ln.textContent = codeLines[i];\n      codePanel.appendChild(ln);\n    }\n  }\n\n  renderCode(null);\n\n  // state\n  let array = [5,3,8,1,2,7,4,6];\n  let history = []; // snapshots\n  let actions = []; // generated actions for current run\n  let actionIndex = 0;\n  let playing = false;\n  let runner = null;\n  let comparisonCount = 0, swapCounter = 0, passCounter = 0;\n  let ascending = true;\n  let optimized = false;\n\n  function setStatus(s){ status.textContent = s; }\n\n  // helpers to generate arrays\n  function randomArray(size){\n    const arr = [];\n    for(let i=0;i<size;i++){\n      arr.push(Math.floor(Math.random()*100)+1);\n    }\n    return arr;\n  }\n  function reverseArray(size){\n    const arr = [];\n    for(let i=0;i<size;i++) arr.push(size-i);\n    return arr;\n  }\n  function duplicatesArray(size){\n    const base = [5,3,8,1,2,7,4,6];\n    const arr = [];\n    for(let i=0;i<size;i++){\n      arr.push(base[i % base.length]);\n    }\n    return arr;\n  }\n\n  // Apply initial array to visualizer\n  function applyArray(arr){\n    array = arr.slice();\n    history = [];\n    actions = [];\n    actionIndex = 0;\n    comparisonCount = 0; swapCounter=0; passCounter=0;\n    lenCount.textContent = array.length;\n    compCount.textContent = '0';\n    swapCount.textContent = '0';\n    passCount.textContent = '0';\n    vis.setArray(array);\n    setStatus('idle');\n    renderCode(null);\n    backBtn.disabled = true;\n    pauseBtn.disabled = true;\n    playBtn.disabled = false;\n  }\n\n  // Event listeners from controls-panel\n  control.addEventListener('apply-array', (e)=> {\n    const text = e.detail.text.trim();\n    if(text.length===0){\n      applyArray(randomArray(Number(control.shadowRoot.querySelector('#size').value)));\n      return;\n    }\n    const parts = text.split(',').map(s=>s.trim()).filter(s=>s!=='');\n    const nums = parts.map(p=>Number(p));\n    if(nums.some(isNaN)){\n      alert('Invalid input. Use comma-separated numbers like: 5,3,8,1');\n      return;\n    }\n    applyArray(nums);\n  });\n  control.addEventListener('size-change', (e)=> {\n    const newSize = e.detail.size;\n    lenCount.textContent = newSize;\n  });\n  control.addEventListener('randomize', (e)=> {\n    const arr = randomArray(e.detail.size);\n    applyArray(arr);\n  });\n  control.addEventListener('preset', (e)=> {\n    let arr;\n    if(e.detail.type==='easy') arr = [3,1,4,6,2,8,7,5].slice(0,e.detail.size);\n    if(e.detail.type==='reverse') arr = reverseArray(e.detail.size);\n    if(e.detail.type==='duplicates') arr = duplicatesArray(e.detail.size);\n    applyArray(arr);\n  });\n\n  // Bubble sort action generator: returns a list of actions to animate\n  function generateActions(arr, ascending=true, optimized=false){\n    const a = arr.slice();\n    const actions = [];\n    const n = a.length;\n    // snapshot initial\n    actions.push({type:'snapshot', array:a.slice(), i:null, j:null, note:'start'});\n    for(let i=0;i<n-1;i++){\n      actions.push({type:'pass-start', i:i, note:`pass ${i+1}`});\n      let swapped = false;\n      for(let j=0;j<n-1-i;j++){\n        actions.push({type:'compare', i:i, j:j});\n        // comparison\n        const cond = ascending ? (a[j] > a[j+1]) : (a[j] < a[j+1]);\n        if(cond){\n          actions.push({type:'swap', i:j, j:j+1});\n          // swap in simulation\n          const tmp = a[j]; a[j]=a[j+1]; a[j+1]=tmp;\n          swapped = true;\n          actions.push({type:'snapshot', array:a.slice(), i:i, j:j+1, note:'after-swap'});\n        }\n      }\n      actions.push({type:'pass-end', i:i, swapped:swapped});\n      if(optimized && !swapped){\n        actions.push({type:'finished-early', i:i});\n        break;\n      }\n    }\n    actions.push({type:'done'});\n    return actions;\n  }\n\n  // We will keep a history of snapshots for back stepping. Each snapshot captures array and stats.\n  function pushSnapshot(arrSnapshot, meta={}){\n    history.push({\n      array: arrSnapshot.slice(),\n      comp: comparisonCount,\n      swaps: swapCounter,\n      pass: passCounter,\n      meta: meta\n    });\n  }\n\n  // Prepare actions before running\n  function prepareRun(){\n    ascending = (orderSelect.value === 'asc');\n    optimized = optCheckbox.checked;\n    actions = generateActions(array, ascending, optimized);\n    actionIndex = 0;\n    history = [];\n    // initial snapshot\n    pushSnapshot(array.slice(), {note:'initial'});\n    compCount.textContent = '0';\n    swapCount.textContent = '0';\n    passCount.textContent = '0';\n    comparisonCount = 0; swapCounter = 0; passCounter = 0;\n    renderCode(null);\n    setStatus('ready');\n    backBtn.disabled = true;\n  }\n\n  // Apply a single action (synchronous or with animation)\n  async function applyAction(idx){\n    if(idx < 0 || idx >= actions.length) return;\n    const act = actions[idx];\n    switch(act.type){\n      case 'snapshot':\n        // update whole array view (no highlight)\n        vis.updateArray(act.array);\n        renderCode(null);\n        break;\n      case 'pass-start':\n        passCounter++;\n        passCount.textContent = String(passCounter);\n        setStatus(`Pass ${act.i+1} start`);\n        renderCode(3); // highlight swapped flag line in pseudo-code area (approx)\n        // push history\n        pushSnapshot(currentArrayState(), {type:'pass-start', i:act.i});\n        break;\n      case 'compare':\n        comparisonCount++;\n        compCount.textContent = String(comparisonCount);\n        setStatus(`Comparing indices ${act.j} and ${act.j+1}`);\n        vis.markCompare(act.j, act.j+1);\n        renderCode(4); // highlight inner loop and conditional\n        pushSnapshot(currentArrayState(), {type:'compare', i:act.i, j:act.j});\n        break;\n      case 'swap':\n        swapCounter++;\n        swapCount.textContent = String(swapCounter);\n        setStatus(`Swapping indices ${act.i} and ${act.j}`);\n        vis.markSwap(act.i, act.j);\n        renderCode(5); // highlight swap line\n        // animate swap\n        await vis.swap(act.i, act.j, clamp(1000 - Number(speedInput.value), 80, 1000));\n        // After swap, we need to update internal array representation to reflect swapped values at positions\n        // We'll swap the logical 'array' as well\n        const tmp = array[act.i]; array[act.i]=array[act.j]; array[act.j]=tmp;\n        // push snapshot after swap\n        pushSnapshot(currentArrayState(), {type:'after-swap', i:act.i, j:act.j});\n        break;\n      case 'pass-end':\n        setStatus(`Completed pass ${act.i+1}`);\n        // mark suffix as sorted: elements from (array.length - (act.i+1))..end are in final position\n        const sortedStart = array.length - (act.i+1);\n        vis.markSorted(sortedStart);\n        renderCode(10);\n        pushSnapshot(currentArrayState(), {type:'pass-end', i:act.i});\n        break;\n      case 'finished-early':\n        setStatus(`Finished early on pass ${act.i+1}`);\n        vis.markFinalSorted();\n        renderCode(11);\n        pushSnapshot(currentArrayState(), {type:'finished-early', i:act.i});\n        break;\n      case 'done':\n        setStatus('Done');\n        vis.markFinalSorted();\n        renderCode(11);\n        pushSnapshot(currentArrayState(), {type:'done'});\n        break;\n      default:\n        console.warn('unknown action', act);\n    }\n  }\n\n  function currentArrayState(){\n    // derive current array from visualizer bars\n    // bars' dataset.value\n    const bars = vis.shadowRoot ? vis.shadowRoot.querySelectorAll('.bar') : vis.container.querySelectorAll('.bar');\n    if(bars && bars.length){\n      return Array.from(bars).map(b=>Number(b.dataset.value));\n    }\n    return array.slice();\n  }\n\n  // Step forward one action\n  async function stepForward(){\n    if(actions.length === 0) {\n      prepareRun();\n    }\n    if(actionIndex >= actions.length) {\n      setStatus('already finished');\n      return;\n    }\n    const curIdx = actionIndex;\n    actionIndex++;\n    backBtn.disabled = false;\n    await applyAction(curIdx);\n  }\n\n  // Step backward: peek last snapshot and restore\n  function stepBack(){\n    if(history.length <= 1){\n      // nothing to go back to\n      return;\n    }\n    // pop last snapshot and set visualizer to previous\n    const last = history.pop(); // current\n    const prev = history[history.length-1];\n    // restore counters and array\n    comparisonCount = prev.comp;\n    swapCounter = prev.swaps;\n    passCounter = prev.pass;\n    compCount.textContent = String(comparisonCount);\n    swapCount.textContent = String(swapCounter);\n    passCount.textContent = String(passCounter);\n    // update array and visualizer\n    array = prev.array.slice();\n    vis.updateArray(array);\n    setStatus('stepped back');\n    actionIndex = Math.max(0, actionIndex-1);\n    if(history.length <= 1) backBtn.disabled = true;\n  }\n\n  // Play sequence: animate remaining actions with timing\n  async function playAll(){\n    if(actions.length === 0) prepareRun();\n    playing = true;\n    playBtn.disabled = true;\n    pauseBtn.disabled = false;\n    setStatus('playing');\n    while(playing && actionIndex < actions.length){\n      await stepForward();\n      // pacing: speedInput reversed (higher value = faster)\n      const delay = clamp(1000 - Number(speedInput.value), 60, 1000);\n      // If current action was a swap, we've already waited for the swap animation in applyAction.\n      // Add a small pause between operations\n      await sleep( Math.round(delay * 0.28) );\n    }\n    playing = false;\n    playBtn.disabled = false;\n    pauseBtn.disabled = true;\n    if(actionIndex >= actions.length) setStatus('finished');\n  }\n\n  // Reset to initial state\n  function resetAll(){\n    // restore to initial array (first snapshot) if exists, otherwise current array\n    if(history.length>0){\n      const first = history[0];\n      array = first.array.slice();\n      vis.updateArray(array);\n      compCount.textContent = '0';\n      swapCount.textContent = '0';\n      passCount.textContent = '0';\n      comparisonCount = 0; swapCounter = 0; passCounter = 0;\n      actions = [];\n      actionIndex = 0;\n      history = [];\n      setStatus('reset');\n      renderCode(null);\n      backBtn.disabled = true;\n      pauseBtn.disabled = true;\n      playBtn.disabled = false;\n    } else {\n      // nothing recorded; just update widget\n      vis.updateArray(array);\n      compCount.textContent = '0';\n      swapCount.textContent = '0';\n      passCount.textContent = '0';\n      comparisonCount = 0; swapCounter = 0; passCounter = 0;\n      setStatus('idle');\n      renderCode(null);\n      backBtn.disabled = true;\n      pauseBtn.disabled = true;\n      playBtn.disabled = false;\n    }\n  }\n\n  // wire up controls\n  stepBtn.addEventListener('click', async ()=>{\n    await stepForward();\n  });\n  backBtn.addEventListener('click', ()=>{\n    stepBack();\n  });\n  playBtn.addEventListener('click', async ()=>{\n    await playAll();\n  });\n  pauseBtn.addEventListener('click', ()=>{\n    playing = false;\n    pauseBtn.disabled = true;\n    playBtn.disabled = false;\n    setStatus('paused');\n  });\n  resetBtn.addEventListener('click', ()=>{\n    playing = false;\n    resetAll();\n  });\n\n  // When user toggles order or optimized, we prepare new run\n  orderSelect.addEventListener('change', ()=>{\n    prepareRun();\n  });\n  optCheckbox.addEventListener('change', ()=>{\n    prepareRun();\n  });\n\n  speedInput.addEventListener('input', ()=>{\n    // adjust nothing immediate; used in delays\n  });\n\n  // Initialize\n  applyArray(array);\n  prepareRun();\n\n  // Small keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === ' '){\n      e.preventDefault();\n      if(playing) { playing = false; pauseBtn.disabled = true; playBtn.disabled = false; setStatus('paused'); }\n      else playAll();\n    } else if (e.key === 'ArrowRight'){\n      stepForward();\n    } else if (e.key === 'ArrowLeft'){\n      stepBack();\n    }\n  });\n\n  // Accessibility: respond to container resize to re-render bars\n  new ResizeObserver(()=>{ vis.render(); }).observe(vis);\n\n  // Show initial code highlight mapping by default\n  renderCode(null);\n});\n</script>\n</body>\n</html>",
      "refusal": null,
      "annotations": []
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user given concept. It should be highly interactive and utilize multiple web components to show the concept step by step. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "bubble sort"
      }
    ],
    "evaluation": {
      "score": 1,
      "notes": "ui错位严重，不能运行"
    }
  },
  {
    "id": "c0959290-98f6-11f0-b679-735244a266fb",
    "model": "claude-opus-4-20250514",
    "timestamp": "2025-09-24T03:30:00.890Z",
    "question": "bubble sort",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Bubble Sort Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 800px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f0f0f0;\n        }\n        h1 {\n            color: #333;\n            text-align: center;\n        }\n        .controls {\n            text-align: center;\n            margin: 20px 0;\n        }\n        button {\n            padding: 10px 20px;\n            margin: 0 5px;\n            font-size: 16px;\n            cursor: pointer;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 5px;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        button:disabled {\n            background-color: #cccccc;\n            cursor: not-allowed;\n        }\n        input {\n            padding: 8px;\n            font-size: 16px;\n            width: 300px;\n            margin-right: 10px;\n        }\n        .visualization {\n            display: flex;\n            justify-content: center;\n            align-items: flex-end;\n            height: 300px;\n            margin: 30px 0;\n            background-color: white;\n            border-radius: 10px;\n            padding: 20px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        .bar {\n            width: 40px;\n            margin: 0 2px;\n            background-color: #3498db;\n            color: white;\n            text-align: center;\n            line-height: 30px;\n            font-weight: bold;\n            transition: all 0.3s ease;\n            position: relative;\n        }\n        .bar.comparing {\n            background-color: #e74c3c;\n        }\n        .bar.sorted {\n            background-color: #2ecc71;\n        }\n        .info {\n            text-align: center;\n            margin: 20px 0;\n            font-size: 18px;\n        }\n        .code {\n            background-color: #2c3e50;\n            color: #ecf0f1;\n            padding: 20px;\n            border-radius: 10px;\n            font-family: 'Courier New', monospace;\n            overflow-x: auto;\n            white-space: pre;\n            line-height: 1.5;\n        }\n    </style>\n</head>\n<body>\n    <h1>Bubble Sort Visualization</h1>\n    \n    <div class=\"controls\">\n        <input type=\"text\" id=\"arrayInput\" placeholder=\"Enter numbers separated by commas\" value=\"64, 34, 25, 12, 22, 11, 90\">\n        <button onclick=\"setArray()\">Set Array</button>\n        <button onclick=\"randomArray()\">Random Array</button>\n        <button id=\"sortBtn\" onclick=\"startSort()\">Start Sort</button>\n        <button id=\"resetBtn\" onclick=\"resetArray()\">Reset</button>\n    </div>\n    \n    <div class=\"info\">\n        <div id=\"status\">Ready to sort</div>\n        <div id=\"comparisons\">Comparisons: 0</div>\n        <div id=\"swaps\">Swaps: 0</div>\n    </div>\n    \n    <div class=\"visualization\" id=\"visualization\"></div>\n    \n    <div class=\"code\">\nfunction bubbleSort(arr) {\n    let n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // Swap elements\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n    return arr;\n}\n\nTime Complexity: O(n²)\nSpace Complexity: O(1)\n    </div>\n\n    <script>\n        let array = [];\n        let originalArray = [];\n        let sorting = false;\n        let comparisons = 0;\n        let swaps = 0;\n\n        function setArray() {\n            const input = document.getElementById('arrayInput').value;\n            const numbers = input.split(',').map(num => parseInt(num.trim())).filter(num => !isNaN(num));\n            if (numbers.length > 0 && numbers.length <= 15) {\n                array = [...numbers];\n                originalArray = [...numbers];\n                visualize();\n                resetStats();\n            } else {\n                alert('Please enter 1-15 valid numbers separated by commas');\n            }\n        }\n\n        function randomArray() {\n            const size = Math.floor(Math.random() * 8) + 8; // 8-15 elements\n            array = [];\n            for (let i = 0; i < size; i++) {\n                array.push(Math.floor(Math.random() * 90) + 10); // 10-99\n            }\n            originalArray = [...array];\n            document.getElementById('arrayInput').value = array.join(', ');\n            visualize();\n            resetStats();\n        }\n\n        function visualize() {\n            const container = document.getElementById('visualization');\n            container.innerHTML = '';\n            \n            const maxValue = Math.max(...array);\n            \n            array.forEach((value, index) => {\n                const bar = document.createElement('div');\n                bar.className = 'bar';\n                bar.style.height = `${(value / maxValue) * 250}px`;\n                bar.textContent = value;\n                bar.id = `bar-${index}`;\n                container.appendChild(bar);\n            });\n        }\n\n        function updateBar(index, comparing = false, sorted = false) {\n            const bar = document.getElementById(`bar-${index}`);\n            if (bar) {\n                bar.className = 'bar';\n                if (comparing) bar.classList.add('comparing');\n                if (sorted) bar.classList.add('sorted');\n            }\n        }\n\n        function resetStats() {\n            comparisons = 0;\n            swaps = 0;\n            updateStats();\n            document.getElementById('status').textContent = 'Ready to sort';\n        }\n\n        function updateStats() {\n            document.getElementById('comparisons').textContent = `Comparisons: ${comparisons}`;\n            document.getElementById('swaps').textContent = `Swaps: ${swaps}`;\n        }\n\n        async function bubbleSort() {\n            const n = array.length;\n            \n            for (let i = 0; i < n - 1; i++) {\n                for (let j = 0; j < n - i - 1; j++) {\n                    if (!sorting) return;\n                    \n                    // Highlight bars being compared\n                    updateBar(j, true);\n                    updateBar(j + 1, true);\n                    comparisons++;\n                    updateStats();\n                    \n                    await sleep(500);\n                    \n                    if (array[j] > array[j + 1]) {\n                        // Swap elements\n                        let temp = array[j];\n                        array[j] = array[j + 1];\n                        array[j + 1] = temp;\n                        swaps++;\n                        updateStats();\n                        visualize();\n                        \n                        // Re-highlight after visualization\n                        updateBar(j, true);\n                        updateBar(j + 1, true);\n                        await sleep(500);\n                    }\n                    \n                    // Remove highlight\n                    updateBar(j);\n                    updateBar(j + 1);\n                }\n                \n                // Mark the last element of this pass as sorted\n                updateBar(n - i - 1, false, true);\n            }\n            \n            // Mark the first element as sorted\n            updateBar(0, false, true);\n        }\n\n        function sleep(ms) {\n            return new Promise(resolve => setTimeout(resolve, ms));\n        }\n\n        async function startSort() {\n            if (sorting) return;\n            \n            sorting = true;\n            document.getElementById('sortBtn').disabled = true;\n            document.getElementById('status').textContent = 'Sorting...';\n            \n            await bubbleSort();\n            \n            if (sorting) {\n                document.getElementById('status').textContent = 'Sorted!';\n                // Mark all as sorted\n                for (let i = 0; i < array.length; i++) {\n                    updateBar(i, false, true);\n                }\n            }\n            \n            sorting = false;\n            document.getElementById('sortBtn').disabled = false;\n        }\n\n        function resetArray() {\n            sorting = false;\n            array = [...originalArray];\n            visualize();\n            resetStats();\n            document.getElementById('sortBtn').disabled = false;\n        }\n\n        // Initialize with default array\n        setArray();\n    </script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "bubble sort"
      }
    ],
    "evaluation": {
      "score": 4,
      "notes": "整体正确，ui略有错位"
    }
  },
  {
    "id": "66081c70-9901-11f0-92f7-4fe3e16f322c",
    "model": "gpt-5-mini",
    "timestamp": "2025-09-24T04:46:13.432Z",
    "question": "Bubble Sort",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Bubble Sort Visualization</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#6ee7b7;\n      --muted:#94a3b8;\n      --bar:#60a5fa;\n      --compare:#fb7185;\n      --swap:#fbbf24;\n      --sorted:#34d399;\n      --text:#e6eef7;\n    }\n    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial}\n    body{\n      margin:0;\n      padding:20px;\n      background:linear-gradient(180deg,var(--bg),#071019);\n      color:var(--text);\n      min-height:100vh;\n    }\n    .wrap{\n      max-width:1100px;\n      margin:0 auto;\n      display:grid;\n      grid-template-columns: 1fr 360px;\n      gap:18px;\n    }\n    header{\n      grid-column:1/-1;\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:12px;\n      margin-bottom:6px;\n    }\n    h1{font-size:20px;margin:0}\n    .controls{\n      background:linear-gradient(180deg,var(--panel),#071927);\n      padding:14px;\n      border-radius:12px;\n      box-shadow:0 6px 18px rgba(2,6,23,0.6);\n    }\n    .controls .row{display:flex;gap:8px;align-items:center;margin-bottom:8px}\n    label{font-size:13px;color:var(--muted);min-width:75px}\n    input[type=range]{flex:1}\n    button{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--text);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      transition:all .15s;\n    }\n    button:hover{transform:translateY(-2px)}\n    button.primary{\n      background:linear-gradient(90deg,var(--accent),#34d399);\n      color:#06323b;\n      border:none;\n      font-weight:600;\n      box-shadow:0 6px 12px rgba(52,211,153,0.12);\n    }\n    .left-controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n    .right-panel{\n      background:linear-gradient(180deg,var(--panel),#071927);\n      padding:12px;\n      border-radius:12px;\n      box-shadow:0 6px 18px rgba(2,6,23,0.6);\n      height:fit-content;\n    }\n    .stats{display:flex;gap:10px;flex-wrap:wrap;font-size:13px;margin-top:8px}\n    .stat{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;min-width:88px;text-align:center}\n    .visual{\n      background:linear-gradient(180deg,#051228,#071925);\n      border-radius:12px;\n      padding:12px;\n      height:460px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      box-shadow:0 6px 18px rgba(2,6,23,0.6);\n    }\n    #bars{\n      flex:1;\n      display:flex;\n      align-items:end;\n      gap:4px;\n      padding:6px;\n      border-radius:8px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n    }\n    .bar{\n      background:var(--bar);\n      width:100%;\n      border-radius:6px 6px 4px 4px;\n      display:flex;\n      align-items:flex-end;\n      justify-content:center;\n      color:rgba(0,0,0,0.6);\n      font-size:11px;\n      user-select:none;\n      transition:height 180ms ease, transform 120ms ease, background-color 120ms ease;\n    }\n    .bar.compare{background:var(--compare); transform:translateY(-6px)}\n    .bar.swap{background:var(--swap); transform:translateY(-6px)}\n    .bar.sorted{background:var(--sorted)}\n    .pseudocode{\n      background:linear-gradient(180deg,#061023,#071522);\n      color:var(--muted);\n      padding:10px;\n      border-radius:8px;\n      font-family:ui-monospace,SFMono-Regular,Menlo,monospace;\n      font-size:13px;\n      line-height:1.55;\n      margin-top:8px;\n    }\n    .codeLine{display:block;padding:3px 6px;border-radius:6px}\n    .codeLine.active{background:rgba(110,231,183,0.06);color:var(--accent)}\n    .footerNote{font-size:12px;color:var(--muted);margin-top:8px}\n    .toggles{display:flex;align-items:center;gap:8px}\n    small{color:var(--muted)}\n    .legend{display:flex;gap:8px;align-items:center;margin-top:6px}\n    .chip{display:inline-flex;gap:6px;align-items:center;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.03);font-size:13px}\n    .chip .dot{width:12px;height:12px;border-radius:3px}\n    footer{grid-column:1/-1;color:var(--muted);font-size:12px;margin-top:12px;text-align:center}\n    @media (max-width:980px){\n      .wrap{grid-template-columns:1fr; padding:12px}\n      .right-panel{order:3}\n      header{flex-direction:column;align-items:flex-start;gap:12px}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <header>\n      <div>\n        <h1>Bubble Sort — Interactive Visualization</h1>\n        <small>Compare and swap until the array is sorted. Try step-by-step or run automatically.</small>\n      </div>\n      <div class=\"left-controls\">\n        <div class=\"controls\" style=\"display:flex;flex-direction:column;gap:8px;\">\n          <div class=\"row\">\n            <label for=\"size\">Size</label>\n            <input id=\"size\" type=\"range\" min=\"5\" max=\"80\" value=\"24\">\n            <span id=\"sizeVal\" style=\"min-width:34px;text-align:right;color:var(--muted)\">24</span>\n          </div>\n          <div class=\"row\">\n            <label for=\"speed\">Speed</label>\n            <input id=\"speed\" type=\"range\" min=\"1\" max=\"1000\" value=\"220\">\n            <span id=\"speedVal\" style=\"min-width:34px;text-align:right;color:var(--muted)\">220ms</span>\n          </div>\n          <div class=\"row\" style=\"justify-content:space-between;\">\n            <div class=\"toggles\" title=\"Optimize with early exit when no swaps occur in a pass.\">\n              <input id=\"opt\" type=\"checkbox\" checked>\n              <label for=\"opt\" style=\"margin:0;color:var(--muted)\">Optimized</label>\n            </div>\n            <div style=\"display:flex;gap:6px\">\n              <button id=\"random\">Randomize</button>\n              <button id=\"start\" class=\"primary\">Start</button>\n              <button id=\"pause\">Pause</button>\n              <button id=\"step\">Step</button>\n              <button id=\"reset\">Reset</button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </header>\n\n    <section class=\"visual\">\n      <div id=\"bars\" aria-hidden=\"true\"></div>\n      <div class=\"legend\">\n        <div class=\"chip\"><span class=\"dot\" style=\"background:var(--bar)\"></span> Unsorted</div>\n        <div class=\"chip\"><span class=\"dot\" style=\"background:var(--compare)\"></span> Comparing</div>\n        <div class=\"chip\"><span class=\"dot\" style=\"background:var(--swap)\"></span> Swapping</div>\n        <div class=\"chip\"><span class=\"dot\" style=\"background:var(--sorted)\"></span> Sorted</div>\n      </div>\n      <div style=\"display:flex;gap:12px;align-items:center;justify-content:space-between\">\n        <div style=\"display:flex;gap:8px;\">\n          <div class=\"stat\"><div style=\"font-size:12px;color:var(--muted)\">Pass</div><div id=\"pass\">0</div></div>\n          <div class=\"stat\"><div style=\"font-size:12px;color:var(--muted)\">Comparisons</div><div id=\"comp\">0</div></div>\n          <div class=\"stat\"><div style=\"font-size:12px;color:var(--muted)\">Swaps</div><div id=\"swaps\">0</div></div>\n        </div>\n        <div style=\"display:flex;gap:8px;align-items:center;\">\n          <small id=\"status\">Idle</small>\n        </div>\n      </div>\n    </section>\n\n    <aside class=\"right-panel\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center\">\n        <strong>Pseudocode</strong>\n        <small style=\"color:var(--muted)\">Optimized flag toggles early exit</small>\n      </div>\n      <div class=\"pseudocode\" id=\"pcode\" aria-hidden=\"false\">\n        <div class=\"codeLine\" data-line=\"0\">function bubbleSort(arr)</div>\n        <div class=\"codeLine\" data-line=\"1\">  n = arr.length</div>\n        <div class=\"codeLine\" data-line=\"2\">  for i from 0 to n-1</div>\n        <div class=\"codeLine\" data-line=\"3\">    swapped = false</div>\n        <div class=\"codeLine\" data-line=\"4\">    for j from 0 to n-i-2</div>\n        <div class=\"codeLine\" data-line=\"5\">      if arr[j] > arr[j+1]</div>\n        <div class=\"codeLine\" data-line=\"6\">        swap arr[j] and arr[j+1]</div>\n        <div class=\"codeLine\" data-line=\"7\">        swapped = true</div>\n        <div class=\"codeLine\" data-line=\"8\">    if optimized and not swapped then break</div>\n        <div class=\"codeLine\" data-line=\"9\">  return arr</div>\n      </div>\n\n      <div style=\"margin-top:12px\">\n        <strong>Time Complexity</strong>\n        <div style=\"font-size:13px; color:var(--muted); margin-top:6px\">\n          Worst-case: O(n^2) | Average: O(n^2) | Best (optimized): O(n)\n        </div>\n      </div>\n\n      <div style=\"margin-top:12px\">\n        <strong>Notes</strong>\n        <div class=\"footerNote\">Bubble sort repeatedly compares adjacent elements and swaps them if they are in the wrong order. It's simple but inefficient for large datasets.</div>\n      </div>\n    </aside>\n\n    <footer>\n      Try the \"Step\" button to advance one comparison at a time. \"Optimized\" stops early if a pass needs no swaps.\n    </footer>\n  </div>\n\n  <script>\n    // Elements\n    const barsEl = document.getElementById('bars');\n    const sizeInput = document.getElementById('size');\n    const speedInput = document.getElementById('speed');\n    const sizeVal = document.getElementById('sizeVal');\n    const speedVal = document.getElementById('speedVal');\n    const randomBtn = document.getElementById('random');\n    const startBtn = document.getElementById('start');\n    const pauseBtn = document.getElementById('pause');\n    const stepBtn = document.getElementById('step');\n    const resetBtn = document.getElementById('reset');\n    const optCheckbox = document.getElementById('opt');\n    const passEl = document.getElementById('pass');\n    const compEl = document.getElementById('comp');\n    const swapsEl = document.getElementById('swaps');\n    const statusEl = document.getElementById('status');\n    const codeLines = document.querySelectorAll('.codeLine');\n\n    let arr = [];\n    let running = false;\n    let controllerState = 'idle'; // 'running','paused','step','stopped','idle'\n    let speed = parseInt(speedInput.value,10);\n    let pass = 0, comparisons = 0, swaps = 0;\n    let currentHighlights = [];\n\n    function randArray(n){\n      const a = [];\n      for(let i=0;i<n;i++){\n        a.push(Math.floor(Math.random()*100)+5); // keep min height >0\n      }\n      return a;\n    }\n\n    function render(){\n      barsEl.innerHTML = '';\n      const n = arr.length;\n      for(let i=0;i<n;i++){\n        const b = document.createElement('div');\n        b.className='bar';\n        b.style.height = (arr[i]* ( (barsEl.clientHeight-20) / 110 )) + 'px';\n        b.style.flex = `1 1 ${Math.max(4, 100/n)}%`;\n        b.title = String(arr[i]);\n        b.dataset.index = i;\n        // show small label for few elements\n        if(n<=32) b.textContent = arr[i];\n        barsEl.appendChild(b);\n      }\n      updateCounts();\n    }\n\n    function updateCounts(){\n      passEl.textContent = pass;\n      compEl.textContent = comparisons;\n      swapsEl.textContent = swaps;\n    }\n\n    // util highlight functions\n    function clearBarClasses(){\n      barsEl.querySelectorAll('.bar').forEach(b=>{\n        b.classList.remove('compare','swap','sorted');\n        b.style.transform = '';\n      });\n    }\n    function markCompare(i,j){\n      clearBarClasses();\n      const a = barsEl.children[i];\n      const b = barsEl.children[j];\n      if(a) a.classList.add('compare');\n      if(b) b.classList.add('compare');\n    }\n    function markSwap(i,j){\n      clearBarClasses();\n      const a = barsEl.children[i];\n      const b = barsEl.children[j];\n      if(a) a.classList.add('swap');\n      if(b) b.classList.add('swap');\n    }\n    function markSorted(upto){\n      for(let k=barsEl.children.length-1;k>=upto;k--){\n        const el = barsEl.children[k];\n        if(el) el.classList.add('sorted');\n      }\n    }\n\n    // pseudocode highlight\n    function highlightLine(num){\n      codeLines.forEach(line=>{\n        line.classList.toggle('active', Number(line.dataset.line) === num);\n      });\n    }\n\n    // sleep/wait that respects pause/step/reset\n    function waiter(ms){\n      const start = performance.now();\n      return new Promise(resolve=>{\n        function tick(){\n          if(controllerState === 'stopped' || controllerState==='idle'){ resolve({aborted:true}); return; }\n          if(controllerState === 'step'){\n            controllerState = 'paused';\n            resolve({aborted:false, stepped:true});\n            return;\n          }\n          if(controllerState === 'running'){\n            const now = performance.now();\n            if(now - start >= ms){\n              resolve({aborted:false});\n              return;\n            }\n          }\n          // else paused: keep waiting\n          requestAnimationFrame(tick);\n        }\n        tick();\n      });\n    }\n\n    async function bubbleSortVisual(){\n      running = true;\n      controllerState = 'running';\n      pass = 0; comparisons = 0; swaps = 0;\n      updateCounts();\n      statusEl.textContent = 'Running';\n      const n = arr.length;\n      highlightLine(0);\n      await sleepFrame();\n\n      for(let i=0;i<n;i++){\n        pass = i+1;\n        updateCounts();\n        highlightLine(2); // for i from 0 to n-1\n        await sleepFrame();\n\n        let swapped = false;\n        highlightLine(3);\n        await sleepFrame();\n\n        for(let j=0;j<n-i-1;j++){\n          // if aborted\n          if(controllerState === 'stopped') { running=false; statusEl.textContent='Stopped'; highlightLine(-1); return; }\n\n          // comparing arr[j] and arr[j+1]\n          comparisons++;\n          updateCounts();\n          markCompare(j,j+1);\n          highlightLine(5);\n          const r = await waiter(speed);\n          if(r.aborted){ running=false; statusEl.textContent='Stopped'; highlightLine(-1); return; }\n\n          if(arr[j] > arr[j+1]){\n            // swap\n            swaps++;\n            swapped = true;\n            updateCounts();\n            markSwap(j,j+1);\n            highlightLine(6);\n            await animateSwap(j,j+1);\n            // actual swap in array\n            const tmp = arr[j];\n            arr[j] = arr[j+1];\n            arr[j+1] = tmp;\n            render();\n            await sleepFrame();\n            highlightLine(7);\n            const r2 = await waiter(Math.max(60, speed/2));\n            if(r2.aborted){ running=false; statusEl.textContent='Stopped'; highlightLine(-1); return; }\n          }\n        }\n\n        // mark elements from end that are known to be sorted\n        markSorted(n - i - 1);\n        await sleepFrame();\n\n        if(optCheckbox.checked){\n          highlightLine(8);\n          await sleepFrame();\n          if(!swapped){\n            statusEl.textContent = 'Sorted (early exit)';\n            // entire array sorted\n            for(let k=0;k<n;k++){\n              const el = barsEl.children[k];\n              if(el) el.classList.add('sorted');\n            }\n            running=false;\n            highlightLine(-1);\n            return;\n          }\n        }\n      }\n      statusEl.textContent = 'Sorted';\n      running = false;\n      highlightLine(-1);\n      // mark all sorted\n      for(let k=0;k<arr.length;k++){\n        const el = barsEl.children[k];\n        if(el) el.classList.add('sorted');\n      }\n    }\n\n    // small helper to allow UI to update\n    function sleepFrame(){ return new Promise(resolve => requestAnimationFrame(resolve)); }\n\n    // Animate swap by exchanging heights visually\n    async function animateSwap(i,j){\n      const a = barsEl.children[i];\n      const b = barsEl.children[j];\n      if(!a || !b) return;\n      // simple visual: move them up briefly (class swap already applied)\n      a.style.transform = 'translateY(-8px)';\n      b.style.transform = 'translateY(-8px)';\n      await new Promise(r => setTimeout(r, Math.max(80, speed/3)));\n    }\n\n    // Event bindings\n    sizeInput.addEventListener('input', e=>{\n      sizeVal.textContent = e.target.value;\n      resetArray(Number(e.target.value));\n    });\n    speedInput.addEventListener('input', e=>{\n      speed = Number(e.target.value);\n      speedVal.textContent = speed + 'ms';\n    });\n    randomBtn.addEventListener('click', ()=> resetArray(Number(sizeInput.value)));\n    startBtn.addEventListener('click', async ()=>{\n      if(running){\n        // if paused, resume\n        controllerState = 'running';\n        statusEl.textContent = 'Running';\n        return;\n      }\n      // start fresh visualization\n      clearBarClasses();\n      comparisons=0; swaps=0; pass=0;\n      updateCounts();\n      await sleepFrame();\n      bubbleSortVisual();\n    });\n    pauseBtn.addEventListener('click', ()=>{\n      if(!running) return;\n      controllerState = 'paused';\n      statusEl.textContent = 'Paused';\n    });\n    stepBtn.addEventListener('click', ()=>{\n      if(!running){\n        // start algorithm in paused mode and then step once\n        comparisons=0; swaps=0; pass=0;\n        updateCounts();\n        controllerState='paused';\n        bubbleSortVisual();\n        // give it a tick then step\n        setTimeout(()=>{ controllerState='step'; statusEl.textContent='Stepping'; }, 40);\n      } else {\n        controllerState='step';\n        statusEl.textContent='Stepping';\n      }\n    });\n    resetBtn.addEventListener('click', ()=>{\n      controllerState='stopped';\n      running=false;\n      statusEl.textContent='Idle';\n      clearBarClasses();\n      highlightLine(-1);\n      resetArray(Number(sizeInput.value));\n    });\n\n    function resetArray(n){\n      arr = randArray(n);\n      pass = 0; comparisons = 0; swaps = 0;\n      updateCounts();\n      statusEl.textContent = 'Idle';\n      controllerState = 'idle';\n      running = false;\n      render();\n      clearBarClasses();\n      highlightLine(-1);\n    }\n\n    // init\n    sizeVal.textContent = sizeInput.value;\n    speedVal.textContent = speedInput.value + 'ms';\n    resetArray(Number(sizeInput.value));\n\n    // allow clicking bars to shuffle small subset (fun)\n    barsEl.addEventListener('click', (e)=>{\n      const b = e.target.closest('.bar');\n      if(!b) return;\n      const idx = Number(b.dataset.index);\n      // swap with random neighbor\n      const j = Math.min(arr.length-1, Math.max(0, idx + (Math.random()>0.5?1:-1)));\n      const tmp = arr[idx]; arr[idx] = arr[j]; arr[j] = tmp;\n      render();\n    });\n\n    // remove highlight when mouse leaves\n    document.addEventListener('visibilitychange', ()=>{\n      if(document.hidden && running){\n        controllerState='paused';\n        statusEl.textContent='Paused (tab hidden)';\n      }\n    });\n\n  </script>\n</body>\n</html>",
      "refusal": null,
      "annotations": []
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Bubble Sort"
      }
    ],
    "evaluation": {
      "score": 5,
      "notes": "顶级好！！！！甚至代码有实时的高亮；而且UI的响应也是目前最棒的：过多的数据不会出现问题，整体也是reponsive的！！！"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "d919f760-9901-11f0-852f-5d58d0cdae99",
    "model": "gpt-5-mini",
    "timestamp": "2025-09-24T04:49:26.486Z",
    "question": "Linked List",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>Interactive Linked List Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  :root{\n    --bg:#0f1724; --panel:#0b1320; --accent:#06b6d4;\n    --muted:#9aa7b2; --card:#071021;\n  }\n  body{ margin:0; font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,\"Helvetica Neue\",Arial; background:linear-gradient(180deg,#071022 0%, #021224 100%); color:#e6eef3; }\n  header{ padding:18px 24px; display:flex; gap:16px; align-items:center; background:linear-gradient(90deg, rgba(6,182,212,0.06), rgba(0,0,0,0.02)); box-shadow:0 2px 10px rgba(2,6,23,0.6); }\n  h1{ font-size:18px; margin:0; color:var(--accent); }\n  p.desc{ margin:0; color:var(--muted); font-size:13px; opacity:0.95; }\n  main{ display:flex; gap:18px; padding:18px; height:calc(100vh - 72px); box-sizing:border-box; }\n  .left{ width:360px; min-width:260px; background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent); border-radius:12px; padding:14px; box-shadow:0 8px 30px rgba(2,6,23,0.6); overflow:auto; }\n  .right{ flex:1; background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent); border-radius:12px; padding:14px; position:relative; overflow:auto; }\n  label{ display:block; font-size:13px; color:var(--muted); margin:10px 0 6px; }\n  input[type=\"text\"], input[type=\"number\"], select{ width:100%; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:var(--muted); box-sizing:border-box; }\n  .row{ display:flex; gap:8px; align-items:center; }\n  button{ background:linear-gradient(90deg,var(--accent),#0ea5a1); color:#042022; border:none; padding:8px 10px; border-radius:8px; font-weight:600; cursor:pointer; box-shadow:0 6px 18px rgba(2,6,23,0.35); }\n  button.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted); box-shadow:none; }\n  .controls{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }\n  .small{ padding:6px 8px; font-size:13px; border-radius:8px; }\n  .card{ background:rgba(255,255,255,0.02); border-radius:10px; padding:10px; margin-top:12px; }\n  pre{ margin:0; background:transparent; color:#cde; font-size:13px; overflow:auto; max-height:200px; }\n  .footer{ font-size:12px; color:var(--muted); margin-top:10px; }\n  /* SVG canvas */\n  #canvas{ width:100%; height:100%; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); }\n  .info{ font-size:13px; color:var(--muted); margin-top:8px; }\n  .muted{ color:var(--muted); font-size:13px; }\n  .badge{ display:inline-block; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.02); color:var(--muted); font-size:12px; }\n  .clearfix{ clear:both; }\n  /* Legend */\n  .legend{ display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }\n  .legend .item{ display:flex; gap:8px; align-items:center; font-size:13px; color:var(--muted); }\n  .swatch{ width:18px; height:18px; border-radius:6px; box-shadow:inset 0 -2px 6px rgba(0,0,0,0.5); }\n  /* responsive */\n  @media (max-width:860px){\n    main{ flex-direction:column; height:auto; padding-bottom:80px; }\n    .left{ width:100%; }\n    .right{ width:100%; min-height:360px; }\n  }\n</style>\n</head>\n<body>\n<header>\n  <div style=\"flex:1\">\n    <h1>Linked List — Interactive Demo</h1>\n    <p class=\"desc\">Visualize and experiment with a singly linked list: insertion, deletion, search, reverse and traversal.</p>\n  </div>\n  <div style=\"text-align:right\">\n    <div class=\"badge\">Singly Linked List</div>\n  </div>\n</header>\n\n<main>\n  <section class=\"left\">\n    <div style=\"display:flex; gap:8px; align-items:center;\">\n      <input id=\"valInput\" type=\"text\" placeholder=\"Node value (e.g., 42)\" />\n      <button id=\"pushBtn\" class=\"small\">Append</button>\n      <button id=\"unshiftBtn\" class=\"small\">Prepend</button>\n    </div>\n\n    <label>Insert at index</label>\n    <div style=\"display:flex; gap:8px;\">\n      <input id=\"idxInput\" type=\"number\" placeholder=\"index\" min=\"0\" />\n      <button id=\"insertAtBtn\" class=\"small\">Insert</button>\n      <button id=\"removeAtBtn\" class=\"small ghost\">Remove at</button>\n    </div>\n\n    <label>Remove/search by value</label>\n    <div style=\"display:flex; gap:8px;\">\n      <input id=\"val2Input\" type=\"text\" placeholder=\"value\" />\n      <button id=\"removeValBtn\" class=\"small ghost\">Remove value</button>\n      <button id=\"findBtn\" class=\"small ghost\">Find</button>\n    </div>\n\n    <div class=\"controls\">\n      <button id=\"traverseBtn\" class=\"small\">Traverse (animate)</button>\n      <button id=\"reverseBtn\" class=\"small\">Reverse</button>\n      <button id=\"clearBtn\" class=\"small ghost\">Clear</button>\n      <button id=\"randomBtn\" class=\"small\">Random</button>\n      <button id=\"fillBtn\" class=\"small ghost\">Fill Example</button>\n    </div>\n\n    <div class=\"card\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n        <div>\n          <div class=\"muted\">List state</div>\n          <div id=\"stats\" style=\"font-weight:700; margin-top:6px;\">Length: 0 — Head: null — Tail: null</div>\n        </div>\n        <div style=\"text-align:right\">\n          <div class=\"muted\">Speed</div>\n          <input id=\"speed\" type=\"range\" min=\"200\" max=\"1500\" value=\"700\" style=\"width:120px\"/>\n        </div>\n      </div>\n      <div class=\"info\">\n        Use the controls to modify the linked list. Animations highlight nodes as operations traverse pointers.\n      </div>\n      <div style=\"margin-top:10px;\">\n        <div class=\"legend\">\n          <div class=\"item\"><div class=\"swatch\" style=\"background:#0ea5a1\"></div> Active / new node</div>\n          <div class=\"item\"><div class=\"swatch\" style=\"background:#1e293b\"></div> Normal node</div>\n          <div class=\"item\"><div class=\"swatch\" style=\"background:#bfdbfe\"></div> Highlighted pointer</div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"card\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n        <div class=\"muted\">Pseudo-code (insert at end)</div>\n        <div class=\"muted\">O(n)</div>\n      </div>\n      <pre id=\"pseudocode\">\n// Append (push)\nnewNode = Node(value)\nif head == null:\n  head = newNode\nelse:\n  tail.next = newNode\ntail = newNode\nlength++\n      </pre>\n    </div>\n\n    <div class=\"card\">\n      <div class=\"muted\">Complexities (Singly Linked List)</div>\n      <pre>\nAccess:  O(n)\nSearch:  O(n)\nInsert (head): O(1)\nInsert (tail): O(1) if tail ref known, else O(n)\nDelete:  O(n)\n      </pre>\n    </div>\n\n    <div class=\"footer\">Tip: Try inserting at index 0 (prepend), or reversing the list to see pointers flip.</div>\n  </section>\n\n  <section class=\"right\">\n    <svg id=\"canvas\" viewBox=\"0 0 1200 500\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n    <div style=\"position:absolute; right:20px; top:20px; text-align:right;\">\n      <div class=\"muted\">Visualization</div>\n      <div style=\"font-weight:700; margin-top:6px;\" id=\"operationLabel\">Ready</div>\n    </div>\n  </section>\n</main>\n\n<script>\n/*\n  Interactive singly linked list visualizer\n  - Maintains a JS linked list (head, tail, length)\n  - Draws nodes as boxes with arrows in an SVG canvas\n  - Animates traversal, insertions, deletions, and reversal\n*/\n\n// Basic linked list implementation\nclass Node {\n  constructor(value){\n    this.value = value;\n    this.next = null;\n    this.id = Node._id++;\n  }\n}\nNode._id = 1;\n\nclass LinkedList {\n  constructor(){\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  push(value){\n    const node = new Node(value);\n    if(!this.head){ this.head = this.tail = node; }\n    else{ this.tail.next = node; this.tail = node; }\n    this.length++;\n    return node;\n  }\n  unshift(value){\n    const node = new Node(value);\n    if(!this.head){ this.head = this.tail = node; }\n    else { node.next = this.head; this.head = node; }\n    this.length++;\n    return node;\n  }\n  insertAt(index, value){\n    if(index < 0) index = 0;\n    if(index === 0) return this.unshift(value);\n    if(index >= this.length) return this.push(value);\n    let prev = this.head;\n    for(let i=0;i<index-1;i++) prev = prev.next;\n    const node = new Node(value);\n    node.next = prev.next;\n    prev.next = node;\n    this.length++;\n    return node;\n  }\n  removeAt(index){\n    if(this.length === 0) return null;\n    if(index <= 0){\n      const rem = this.head;\n      this.head = this.head.next;\n      if(!this.head) this.tail = null;\n      this.length--;\n      return rem;\n    }\n    if(index >= this.length-1){\n      // remove tail\n      let prev = this.head;\n      while(prev.next && prev.next !== this.tail) prev = prev.next;\n      const rem = this.tail;\n      if(prev) prev.next = null;\n      this.tail = prev ? prev : null;\n      if(!this.tail) this.head = null;\n      this.length--;\n      return rem;\n    }\n    let prev = this.head;\n    for(let i=0;i<index-1;i++) prev = prev.next;\n    const rem = prev.next;\n    prev.next = rem.next;\n    this.length--;\n    return rem;\n  }\n  removeValue(value){\n    if(!this.head) return null;\n    if(this.head.value == value){\n      const rem = this.head;\n      this.head = this.head.next;\n      if(!this.head) this.tail = null;\n      this.length--;\n      return rem;\n    }\n    let prev = this.head;\n    while(prev.next && prev.next.value != value) prev = prev.next;\n    if(!prev.next) return null;\n    const rem = prev.next;\n    prev.next = rem.next;\n    if(rem === this.tail) this.tail = prev;\n    this.length--;\n    return rem;\n  }\n  indexOf(value){\n    let idx = 0;\n    let cur = this.head;\n    while(cur){\n      if(cur.value == value) return idx;\n      cur = cur.next;\n      idx++;\n    }\n    return -1;\n  }\n  toArray(){\n    const out = [];\n    let cur = this.head;\n    while(cur){ out.push(cur); cur = cur.next; }\n    return out;\n  }\n  reverse(){\n    let prev = null, cur = this.head;\n    this.tail = this.head;\n    while(cur){\n      const nxt = cur.next;\n      cur.next = prev;\n      prev = cur;\n      cur = nxt;\n    }\n    this.head = prev;\n  }\n  clear(){\n    this.head = this.tail = null;\n    this.length = 0;\n  }\n}\n\n// Visualization helpers\nconst svg = document.getElementById('canvas');\nconst NS = \"http://www.w3.org/2000/svg\";\nlet list = new LinkedList();\nlet animating = false;\n\nconst config = {\n  nodeW: 120, nodeH: 48, gap: 26, startX: 30, startY: 40, speed: 700\n};\n\nfunction setOperation(text){\n  document.getElementById('operationLabel').textContent = text;\n}\n\nfunction updateStats(){\n  document.getElementById('stats').textContent = `Length: ${list.length} — Head: ${list.head ? list.head.value : 'null'} — Tail: ${list.tail ? list.tail.value : 'null'}`;\n}\n\nfunction clearSvg(){\n  while(svg.firstChild) svg.removeChild(svg.firstChild);\n}\n\n// draw nodes and arrows\nfunction draw(){\n  clearSvg();\n  const nodes = list.toArray();\n  const totalWidth = nodes.length * (config.nodeW + config.gap);\n  let x = config.startX;\n  const y = config.startY;\n  // defs for arrow marker\n  let defs = document.createElementNS(NS,'defs');\n  defs.innerHTML = `<marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"8\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\"><path d=\"M0,0 L10,5 L0,10 z\" fill=\"#9fbad6\"/></marker>`;\n  svg.appendChild(defs);\n\n  nodes.forEach((node, idx) => {\n    // group per node\n    const g = document.createElementNS(NS,'g');\n    g.setAttribute('data-id', node.id);\n    g.setAttribute('transform', `translate(${x},${y})`);\n    // rect for value\n    const rect = document.createElementNS(NS,'rect');\n    rect.setAttribute('x',0); rect.setAttribute('y',0);\n    rect.setAttribute('rx',10); rect.setAttribute('ry',10);\n    rect.setAttribute('width',config.nodeW); rect.setAttribute('height',config.nodeH);\n    rect.setAttribute('fill','#0f1728');\n    rect.setAttribute('stroke','#16324a');\n    rect.setAttribute('stroke-width','1');\n    rect.setAttribute('id','rect-'+node.id);\n    // value text\n    const txt = document.createElementNS(NS,'text');\n    txt.setAttribute('x',10); txt.setAttribute('y',config.nodeH/2 + 6);\n    txt.setAttribute('fill','#cfeff6');\n    txt.setAttribute('font-size',18);\n    txt.textContent = String(node.value);\n    // pointer box (small) on right\n    const pBoxX = config.nodeW - 36;\n    const pBox = document.createElementNS(NS,'rect');\n    pBox.setAttribute('x',pBoxX); pBox.setAttribute('y',8);\n    pBox.setAttribute('width',28); pBox.setAttribute('height',config.nodeH - 16);\n    pBox.setAttribute('rx',6); pBox.setAttribute('ry',6);\n    pBox.setAttribute('fill','#082033');\n    pBox.setAttribute('stroke','#12323f');\n    // append\n    g.appendChild(rect); g.appendChild(txt); g.appendChild(pBox);\n    svg.appendChild(g);\n\n    // arrow to next (if exists)\n    if(node.next){\n      const x1 = x + config.nodeW - 8;\n      const y1 = y + config.nodeH/2;\n      const x2 = x + config.nodeW + config.gap - 12;\n      const y2 = y + config.nodeH/2;\n      const line = document.createElementNS(NS,'path');\n      line.setAttribute('d', `M ${x1} ${y1} C ${x1+18} ${y1} ${x2-18} ${y2} ${x2} ${y2}`);\n      line.setAttribute('fill','none');\n      line.setAttribute('stroke','#6aa7c6');\n      line.setAttribute('stroke-width','2');\n      line.setAttribute('marker-end','url(#arrow)');\n      line.setAttribute('opacity','0.9');\n      line.setAttribute('id','link-'+node.id);\n      svg.appendChild(line);\n    } else {\n      // null label after pointer\n      const nx = x + config.nodeW + 10;\n      const t = document.createElementNS(NS,'text');\n      t.setAttribute('x', nx); t.setAttribute('y', y + config.nodeH/2 + 6);\n      t.setAttribute('fill','#9fbad6');\n      t.setAttribute('font-size',13);\n      t.textContent = 'null';\n      svg.appendChild(t);\n    }\n\n    // head / tail labels\n    if(idx === 0){\n      const lab = document.createElementNS(NS,'text');\n      lab.setAttribute('x', x + config.nodeW/2); lab.setAttribute('y', y - 10);\n      lab.setAttribute('fill','#7ee7e9'); lab.setAttribute('font-size',12);\n      lab.setAttribute('text-anchor','middle'); lab.textContent = 'HEAD';\n      svg.appendChild(lab);\n    }\n    if(idx === nodes.length-1){\n      const lab2 = document.createElementNS(NS,'text');\n      lab2.setAttribute('x', x + config.nodeW/2); lab2.setAttribute('y', y + config.nodeH + 24);\n      lab2.setAttribute('fill','#7ee7e9'); lab2.setAttribute('font-size',12);\n      lab2.setAttribute('text-anchor','middle'); lab2.textContent = 'TAIL';\n      svg.appendChild(lab2);\n    }\n\n    x += config.nodeW + config.gap;\n  });\n}\n\n// helpers to highlight node by index or id\nfunction highlightNode(nodeId, color=\"#0ea5a1\"){\n  const rect = document.getElementById('rect-'+nodeId);\n  if(rect) rect.setAttribute('fill',color);\n}\nfunction unhighlightAll(){\n  const rects = svg.querySelectorAll('rect[id^=\"rect-\"]');\n  rects.forEach(r => r.setAttribute('fill','#0f1728'));\n}\n\n// animate traversal: highlight each node in sequence\nasync function animateTraverse(callbackPerNode){\n  if(animating) return;\n  animating = true;\n  setOperation('Traversing...');\n  const arr = list.toArray();\n  for(let i=0;i<arr.length;i++){\n    unhighlightAll();\n    highlightNode(arr[i].id, '#0ea5a1');\n    if(typeof callbackPerNode === 'function') callbackPerNode(arr[i], i);\n    await wait(config.speed);\n  }\n  unhighlightAll();\n  animating = false;\n  setOperation('Done');\n}\n\n// utility wait\nfunction wait(ms){ return new Promise(r => setTimeout(r, ms)); }\n\n// animate insertion at index (visual)\nasync function animateInsertAt(index, value){\n  if(animating) return;\n  animating = true;\n  setOperation('Inserting...');\n  const nodes = list.toArray();\n  // create temporary floating node visual\n  const tempId = 'temp';\n  const tempGroup = document.createElementNS(NS,'g');\n  tempGroup.setAttribute('id',tempId);\n  tempGroup.setAttribute('transform',`translate(${config.startX},${config.startY - 70})`);\n  const trect = document.createElementNS(NS,'rect');\n  trect.setAttribute('x',0); trect.setAttribute('y',0);\n  trect.setAttribute('rx',10); trect.setAttribute('width',config.nodeW); trect.setAttribute('height',config.nodeH);\n  trect.setAttribute('fill','#0ea5a1');\n  const ttxt = document.createElementNS(NS,'text');\n  ttxt.setAttribute('x',10); ttxt.setAttribute('y',config.nodeH/2 + 6);\n  ttxt.setAttribute('fill','#042022'); ttxt.setAttribute('font-size',18);\n  ttxt.textContent = String(value);\n  tempGroup.appendChild(trect); tempGroup.appendChild(ttxt);\n  svg.appendChild(tempGroup);\n\n  // If inserting at head or empty: animate drop into first spot\n  if(index <= 0 || nodes.length === 0){\n    await animateMove(tempGroup, config.startX, config.startY, config.speed/2);\n    // finalize underlying data\n    list.insertAt(index, value);\n    svg.removeChild(tempGroup);\n    draw();\n    updateStats();\n    animating = false;\n    setOperation('Inserted at head');\n    return;\n  }\n\n  // traverse nodes until (index-1) and highlight\n  let targetIdx = Math.min(index-1, nodes.length-1);\n  for(let i=0;i<=targetIdx;i++){\n    unhighlightAll();\n    highlightNode(nodes[i].id, '#0ea5a1');\n    // move temp over the node to show traversal\n    const targetX = config.startX + i*(config.nodeW + config.gap);\n    await animateMove(tempGroup, targetX, config.startY - 70, config.speed/3);\n    await wait(80);\n  }\n  // move to insertion spot (after prev)\n  const insertX = config.startX + (targetIdx+1)*(config.nodeW + config.gap);\n  await animateMove(tempGroup, insertX, config.startY - 20, config.speed/3);\n  await wait(150);\n  // commit to data structure\n  list.insertAt(index, value);\n  svg.removeChild(tempGroup);\n  draw();\n  updateStats();\n  animating = false;\n  setOperation(`Inserted at index ${index}`);\n}\n\n// animate removal at index\nasync function animateRemoveAt(index){\n  if(animating || list.length===0) return;\n  animating = true;\n  setOperation('Removing...');\n  const nodes = list.toArray();\n  if(index <= 0){\n    // highlight head and remove\n    highlightNode(nodes[0].id, '#f97316');\n    await wait(config.speed/2);\n    list.removeAt(0);\n    draw();\n    updateStats();\n    animating = false;\n    setOperation('Removed head');\n    return;\n  }\n  const targetIdx = Math.min(index, nodes.length-1);\n  // traverse to target\n  for(let i=0;i<=targetIdx;i++){\n    unhighlightAll();\n    highlightNode(nodes[i].id, '#f97316');\n    await wait(config.speed/3);\n  }\n  // remove\n  list.removeAt(index);\n  draw();\n  updateStats();\n  animating = false;\n  setOperation(`Removed at index ${index}`);\n}\n\n// animate find by value\nasync function animateFind(value){\n  if(animating) return;\n  animating = true;\n  setOperation('Searching...');\n  const nodes = list.toArray();\n  let foundIndex = -1;\n  for(let i=0;i<nodes.length;i++){\n    unhighlightAll();\n    highlightNode(nodes[i].id, '#ffea00');\n    await wait(config.speed/2);\n    if(String(nodes[i].value) === String(value)){\n      foundIndex = i;\n      break;\n    }\n  }\n  if(foundIndex >= 0){\n    setOperation(`Found at index ${foundIndex}`);\n    // keep highlight green\n    unhighlightAll();\n    highlightNode(nodes[foundIndex].id, '#0ea5a1');\n  } else {\n    setOperation('Not found');\n  }\n  animating = false;\n}\n\n// animate reversing pointers (visual step-by-step)\nasync function animateReverse(){\n  if(animating || list.length<=1) return;\n  animating = true;\n  setOperation('Reversing...');\n  const nodes = list.toArray();\n  // Stepwise: for visualization, we'll show pointer flips by highlighting nodes\n  let prev = null;\n  let cur = list.head;\n  const steps = [];\n  // record steps (pairs: node.id, becomes-> prev.id or null)\n  while(cur){\n    steps.push({id:cur.id, from: cur.next ? cur.next.id : null, to: prev ? prev.id : null});\n    prev = cur;\n    cur = cur.next;\n  }\n  // show each step\n  for(let i=0;i<steps.length;i++){\n    const s = steps[i];\n    unhighlightAll();\n    highlightNode(s.id, '#0ea5a1');\n    // highlight link visually: fade out next arrow and show new arrow (approx)\n    const link = svg.querySelector('#link-'+s.id);\n    if(link) link.setAttribute('stroke','#bfdbfe');\n    await wait(config.speed/2);\n  }\n  // actually reverse the data\n  list.reverse();\n  draw();\n  updateStats();\n  animating = false;\n  setOperation('Reversed');\n}\n\n// simple move animation for a group element\nfunction animateMove(elem, x, y, duration=400){\n  return new Promise(resolve => {\n    const start = performance.now();\n    const transform = elem.getAttribute('transform') || 'translate(0,0)';\n    const match = /translate\\(([-\\d.]+),\\s*([-\\d.]+)\\)/.exec(transform);\n    let sx = match ? parseFloat(match[1]) : 0;\n    let sy = match ? parseFloat(match[2]) : 0;\n    const dx = x - sx, dy = y - sy;\n    function frame(now){\n      const t = Math.min(1, (now - start) / duration);\n      const nx = sx + dx * easeOutCubic(t);\n      const ny = sy + dy * easeOutCubic(t);\n      elem.setAttribute('transform', `translate(${nx},${ny})`);\n      if(t < 1) requestAnimationFrame(frame); else resolve();\n    }\n    requestAnimationFrame(frame);\n  });\n}\nfunction easeOutCubic(t){ return (--t)*t*t+1; }\n\n// wire up controls\ndocument.getElementById('pushBtn').addEventListener('click', async ()=>{\n  const v = document.getElementById('valInput').value.trim();\n  if(!v) return alert('Enter a value');\n  if(animating) return;\n  list.push(v);\n  draw();\n  updateStats();\n  setOperation(`Appended ${v}`);\n});\ndocument.getElementById('unshiftBtn').addEventListener('click', async ()=>{\n  const v = document.getElementById('valInput').value.trim();\n  if(!v) return alert('Enter a value');\n  if(animating) return;\n  list.unshift(v);\n  draw();\n  updateStats();\n  setOperation(`Prepended ${v}`);\n});\ndocument.getElementById('insertAtBtn').addEventListener('click', async ()=>{\n  const v = document.getElementById('valInput').value.trim();\n  let idx = parseInt(document.getElementById('idxInput').value,10);\n  if(isNaN(idx)) idx = list.length;\n  if(!v) return alert('Enter a value');\n  await animateInsertAt(idx, v);\n  updateStats();\n});\ndocument.getElementById('removeAtBtn').addEventListener('click', async ()=>{\n  let idx = parseInt(document.getElementById('idxInput').value,10);\n  if(isNaN(idx)) return alert('Enter index to remove');\n  await animateRemoveAt(idx);\n  updateStats();\n});\ndocument.getElementById('removeValBtn').addEventListener('click', async ()=>{\n  const v = document.getElementById('val2Input').value.trim();\n  if(!v) return alert('Enter a value to remove');\n  if(animating) return;\n  // find index\n  const idx = list.indexOf(v);\n  if(idx === -1){ setOperation('Value not found'); return; }\n  await animateRemoveAt(idx);\n});\ndocument.getElementById('findBtn').addEventListener('click', async ()=>{\n  const v = document.getElementById('val2Input').value.trim();\n  if(!v) return alert('Enter a value to find');\n  await animateFind(v);\n});\ndocument.getElementById('traverseBtn').addEventListener('click', async ()=>{\n  await animateTraverse();\n});\ndocument.getElementById('reverseBtn').addEventListener('click', async ()=>{\n  await animateReverse();\n});\ndocument.getElementById('clearBtn').addEventListener('click', ()=>{\n  if(animating) return;\n  list.clear();\n  draw();\n  updateStats();\n  setOperation('Cleared');\n});\ndocument.getElementById('randomBtn').addEventListener('click', ()=>{\n  if(animating) return;\n  list.clear();\n  const n = 3 + Math.floor(Math.random()*5);\n  for(let i=0;i<n;i++) list.push(Math.floor(Math.random()*99));\n  draw();\n  updateStats();\n  setOperation('Randomized');\n});\ndocument.getElementById('fillBtn').addEventListener('click', ()=>{\n  if(animating) return;\n  list.clear();\n  ['A','B','C','D','E'].forEach(x => list.push(x));\n  draw();\n  updateStats();\n  setOperation('Filled example');\n});\ndocument.getElementById('speed').addEventListener('input',(e)=>{\n  config.speed = parseInt(e.target.value,10);\n});\n\n// initial draw\ndraw();\nupdateStats();\nsetOperation('Ready');\n\n/* Keyboard hints: Enter to append */\ndocument.getElementById('valInput').addEventListener('keypress', (e)=>{\n  if(e.key === 'Enter') document.getElementById('pushBtn').click();\n});\n\n</script>\n</body>\n</html>",
      "refusal": null,
      "annotations": []
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Linked List"
      }
    ],
    "evaluation": {
      "score": 5,
      "notes": "碉堡了，无需多言。除了在link list过长时会有遮挡问题。插入的动画顶级！！"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "84bb7f30-9902-11f0-9b51-7b35692af53e",
    "model": "gpt-5-mini",
    "timestamp": "2025-09-24T04:54:14.435Z",
    "question": "K-means clustering",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>K-means Clustering Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 12px; color: #111; }\n  h1 { font-size: 20px; margin: 0 0 8px 0; }\n  .container { display: flex; gap: 12px; align-items: flex-start; }\n  #canvasWrap { border: 1px solid #ddd; position: relative; background: linear-gradient(180deg,#fff,#f8fbff); }\n  canvas { display: block; }\n  .controls { width: 320px; }\n  .controls section { background: #fff; padding: 10px; border: 1px solid #eee; margin-bottom: 10px; border-radius: 6px; }\n  label { display: block; font-size: 13px; margin: 6px 0 4px; }\n  input[type=\"range\"] { width: 100%; }\n  input[type=\"number\"] { width: 80px; }\n  button { margin: 6px 6px 6px 0; padding: 6px 10px; }\n  .small { font-size: 13px; color: #444; }\n  #ssePlot { width: 100%; height: 80px; border: 1px solid #eee; background: #fafafa; }\n  .footer { font-size: 12px; color: #666; margin-top: 6px; }\n  .inline { display: inline-block; vertical-align: middle; }\n</style>\n</head>\n<body>\n<h1>K-means Clustering — Interactive Demo</h1>\n<div class=\"container\">\n  <div id=\"canvasWrap\">\n    <canvas id=\"plot\" width=\"700\" height=\"500\"></canvas>\n  </div>\n\n  <div class=\"controls\">\n    <section>\n      <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n        <strong>Controls</strong>\n        <div class=\"small\" id=\"status\">Points: 0 • K: 3 • Iter: 0 • SSE: 0.00</div>\n      </div>\n\n      <label>Choose K (<span id=\"kLabel\">3</span>)</label>\n      <input type=\"range\" id=\"kRange\" min=\"1\" max=\"12\" value=\"3\" />\n      <div style=\"margin-top:6px;\">\n        <label class=\"inline\"><input type=\"radio\" name=\"init\" value=\"random\" checked> Random init</label>\n        <label style=\"margin-left:10px;\" class=\"inline\"><input type=\"radio\" name=\"init\" value=\"kpp\"> K-means++</label>\n      </div>\n\n      <div style=\"margin-top:8px;\">\n        <button id=\"initBtn\">Initialize Centroids</button>\n        <button id=\"stepBtn\">Step</button>\n        <button id=\"runBtn\">Run</button>\n        <button id=\"pauseBtn\" disabled>Pause</button>\n        <button id=\"resetBtn\">Clear</button>\n      </div>\n\n      <label style=\"margin-top:8px;\">Algorithm settings</label>\n      <div class=\"small\">\n        Max iterations: <input id=\"maxIter\" type=\"number\" min=\"1\" value=\"100\" style=\"width:60px\"> &nbsp;\n        Tolerance: <input id=\"tol\" type=\"number\" step=\"0.001\" value=\"0.001\" style=\"width:70px\">\n      </div>\n    </section>\n\n    <section>\n      <strong>Dataset</strong>\n      <div style=\"margin-top:6px;\">\n        Click on the canvas to add points. Hold Shift and drag to create many.\n      </div>\n\n      <label style=\"margin-top:8px;\">Generate random points</label>\n      <div>\n        N: <input id=\"randN\" type=\"number\" value=\"100\" min=\"1\" style=\"width:70px\"> &nbsp;\n        <button id=\"genBtn\">Generate</button>\n        <button id=\"clusterGenBtn\">Generate + Init</button>\n      </div>\n\n      <div style=\"margin-top:8px;\">\n        <button id=\"nextBatchBtn\">Add 50 random</button>\n        <button id=\"removeBtn\">Remove last</button>\n      </div>\n    </section>\n\n    <section>\n      <strong>Visualization</strong>\n      <div style=\"margin-top:6px;\">\n        <label><input type=\"checkbox\" id=\"showLabels\" checked> Show point labels/colors</label>\n        <label style=\"margin-left:8px;\"><input type=\"checkbox\" id=\"drawLines\"> Draw point->centroid lines</label>\n        <label style=\"margin-left:8px;\"><input type=\"checkbox\" id=\"showCentroidLabels\" checked> Centroid IDs</label>\n      </div>\n      <div class=\"small\" style=\"margin-top:6px;\">\n        You can drag centroids (click near a centroid) to reposition them manually.\n      </div>\n    </section>\n\n    <section>\n      <strong>Metrics</strong>\n      <div style=\"margin-top:6px;\">\n        <div>SSE (sum squared error): <span id=\"sseVal\">0.00</span></div>\n        <div>Iteration history (SSE):</div>\n        <canvas id=\"ssePlot\"></canvas>\n      </div>\n    </section>\n\n    <div class=\"footer\">Simple in-browser K-means demo. Try different K and initialization to see different results.</div>\n  </div>\n</div>\n\n<script>\n// K-means interactive demo\nconst canvas = document.getElementById('plot');\nconst ctx = canvas.getContext('2d');\nconst sseCanvas = document.getElementById('ssePlot');\nsseCanvas.width = 300;\nsseCanvas.height = 80;\nconst sseCtx = sseCanvas.getContext('2d');\n\nlet points = []; // {x,y}\nlet labels = []; // cluster index per point or -1\nlet centroids = []; // {x,y}\nlet K = parseInt(document.getElementById('kRange').value);\nlet iteration = 0;\nlet sseHistory = [];\nlet running = false;\nlet animationTimer = null;\nlet dragging = null; // {type:'centroid'|'point', idx}\nlet shiftDrag = false;\nlet lastMouse = null;\n\n// Colors: generate via HSL for good separation\nfunction colorFor(i) {\n  const hue = (i * 89) % 360; // varied step\n  return `hsl(${hue} 70% 50%)`;\n}\n\nfunction updateStatus() {\n  document.getElementById('status').innerText =\n    `Points: ${points.length} • K: ${K} • Iter: ${iteration} • SSE: ${sseHistory.length? sseHistory[sseHistory.length-1].toFixed(2): '0.00'}`;\n  document.getElementById('kLabel').innerText = K;\n  document.getElementById('sseVal').innerText = sseHistory.length? sseHistory[sseHistory.length-1].toFixed(2) : '0.00';\n}\n\n// Euclidean distance squared\nfunction dist2(a,b) { const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }\n\n// Random helpers\nfunction randRange(min,max) { return min + Math.random()*(max-min); }\n\nfunction clear() {\n  points = [];\n  labels = [];\n  centroids = [];\n  iteration = 0;\n  sseHistory = [];\n  running = false;\n  stopAnimation();\n  updateStatus();\n  draw();\n}\n\nfunction draw() {\n  // clear\n  ctx.clearRect(0,0,canvas.width,canvas.height);\n  // background grid\n  ctx.save();\n  ctx.fillStyle = '#fff';\n  ctx.fillRect(0,0,canvas.width,canvas.height);\n  ctx.restore();\n\n  // draw assignment lines (optional)\n  const drawLines = document.getElementById('drawLines').checked;\n\n  // draw points\n  for (let i=0;i<points.length;i++) {\n    const p = points[i];\n    const label = labels[i];\n    if (label >= 0) {\n      ctx.fillStyle = colorFor(label);\n      ctx.strokeStyle = colorFor(label);\n    } else {\n      ctx.fillStyle = '#999';\n      ctx.strokeStyle = '#999';\n    }\n    ctx.beginPath();\n    ctx.arc(p.x,p.y,4,0,Math.PI*2);\n    ctx.fill();\n    ctx.strokeStyle = '#fff';\n    ctx.lineWidth = 1;\n    ctx.stroke();\n    // lines\n    if (drawLines && label>=0 && centroids[label]) {\n      ctx.strokeStyle = hexToRgba(colorFor(label),0.25);\n      ctx.beginPath();\n      ctx.moveTo(p.x,p.y);\n      ctx.lineTo(centroids[label].x, centroids[label].y);\n      ctx.stroke();\n    }\n    if (document.getElementById('showLabels').checked && label>=0) {\n      ctx.font = '12px system-ui, Arial';\n      ctx.fillStyle = '#222';\n      ctx.fillText(String(label), p.x+6, p.y-6);\n    }\n  }\n\n  // draw centroids\n  for (let k=0;k<centroids.length;k++) {\n    const c = centroids[k];\n    ctx.beginPath();\n    ctx.fillStyle = colorFor(k);\n    ctx.strokeStyle = '#222';\n    ctx.lineWidth = 2;\n    ctx.arc(c.x,c.y,9,0,Math.PI*2);\n    ctx.fill();\n    ctx.stroke();\n    // inner mark\n    ctx.beginPath();\n    ctx.fillStyle = '#fff';\n    ctx.arc(c.x,c.y,3,0,Math.PI*2);\n    ctx.fill();\n    if (document.getElementById('showCentroidLabels').checked) {\n      ctx.font = '13px system-ui, Arial';\n      ctx.fillStyle = '#111';\n      ctx.fillText('C'+k, c.x+12, c.y+5);\n    }\n  }\n\n  // optional bounding\n  ctx.strokeStyle = \"#eee\";\n  ctx.strokeRect(0,0,canvas.width,canvas.height);\n}\n\n// convert CSS hsl to rgba with alpha for lines\nfunction hexToRgba(hsl, a) {\n  // hsl in form \"hsl(H S% L%)\"\n  const m = hsl.match(/hsl\\((\\d+)\\s+([\\d.]+)%\\s+([\\d.]+)%\\)/);\n  if (!m) return `rgba(100,100,100,${a})`;\n  const H = +m[1], S = +m[2]/100, L = +m[3]/100;\n  // convert HSL to RGB\n  const C = (1 - Math.abs(2*L-1)) * S;\n  const X = C * (1 - Math.abs((H/60)%2 - 1));\n  const m2 = L - C/2;\n  let r=0,g=0,b=0;\n  if (0<=H && H<60) { r=C; g=X; b=0; }\n  else if (60<=H && H<120) { r=X; g=C; b=0; }\n  else if (120<=H && H<180) { r=0; g=C; b=X; }\n  else if (180<=H && H<240) { r=0; g=X; b=C; }\n  else if (240<=H && H<300) { r=X; g=0; b=C; }\n  else { r=C; g=0; b=X; }\n  r = Math.round((r+m2)*255);\n  g = Math.round((g+m2)*255);\n  b = Math.round((b+m2)*255);\n  return `rgba(${r},${g},${b},${a})`;\n}\n\n// Assign points to nearest centroid\nfunction assign() {\n  if (centroids.length===0) {\n    labels = new Array(points.length).fill(-1);\n    return;\n  }\n  for (let i=0;i<points.length;i++) {\n    let best = -1, bestd = Infinity;\n    for (let k=0;k<centroids.length;k++) {\n      const d = dist2(points[i], centroids[k]);\n      if (d < bestd) { bestd = d; best = k; }\n    }\n    labels[i] = best;\n  }\n}\n\n// Update centroids to means; return max movement (L2)\nfunction updateCentroids() {\n  const sums = new Array(K).fill(0).map(()=>({x:0,y:0,count:0}));\n  for (let i=0;i<points.length;i++) {\n    const l = labels[i];\n    if (l>=0) {\n      sums[l].x += points[i].x;\n      sums[l].y += points[i].y;\n      sums[l].count += 1;\n    }\n  }\n  let maxMove = 0;\n  for (let k=0;k<K;k++) {\n    if (sums[k].count > 0) {\n      const nx = sums[k].x / sums[k].count;\n      const ny = sums[k].y / sums[k].count;\n      const move = Math.hypot(nx - centroids[k].x, ny - centroids[k].y);\n      centroids[k].x = nx;\n      centroids[k].y = ny;\n      if (move > maxMove) maxMove = move;\n    } else {\n      // empty cluster: reinitialize to a random point or random position\n      if (points.length>0) {\n        const idx = Math.floor(Math.random()*points.length);\n        centroids[k].x = points[idx].x + randRange(-5,5);\n        centroids[k].y = points[idx].y + randRange(-5,5);\n      } else {\n        centroids[k].x = randRange(10, canvas.width-10);\n        centroids[k].y = randRange(10, canvas.height-10);\n      }\n      // this is a possibly large move\n      maxMove = Math.max(maxMove, 999);\n    }\n  }\n  return maxMove;\n}\n\nfunction computeSSE() {\n  let sse = 0;\n  for (let i=0;i<points.length;i++) {\n    const l = labels[i];\n    if (l>=0) sse += dist2(points[i], centroids[l]);\n  }\n  return sse;\n}\n\n// one k-means iteration: assign + update\nfunction kmeansStep() {\n  if (centroids.length === 0 || points.length === 0) return false;\n  assign();\n  const prevCentroids = centroids.map(c=>({x:c.x,y:c.y}));\n  const maxMove = updateCentroids();\n  iteration += 1;\n  const sse = computeSSE();\n  sseHistory.push(sse);\n  updateStatus();\n  drawSSE();\n  draw();\n  const tol = parseFloat(document.getElementById('tol').value) || 0.001;\n  if (maxMove <= tol) {\n    // converged\n    running = false;\n    stopAnimation();\n    return true;\n  }\n  const maxIter = parseInt(document.getElementById('maxIter').value) || 100;\n  if (iteration >= maxIter) { running=false; stopAnimation(); return true; }\n  return false;\n}\n\n// init centroids randomly or kmeans++\nfunction initializeCentroids(method='random') {\n  K = Math.max(1, parseInt(document.getElementById('kRange').value));\n  centroids = [];\n  labels = new Array(points.length).fill(-1);\n  if (method === 'kpp' && points.length>0) {\n    // k-means++ initialization\n    // pick first centroid uniformly\n    const idx0 = Math.floor(Math.random()*points.length);\n    centroids.push({x: points[idx0].x, y: points[idx0].y});\n    while (centroids.length < K) {\n      // compute distances to nearest centroid\n      const d2 = points.map(p => {\n        let best = Infinity;\n        for (let c of centroids) {\n          const dx = p.x-c.x, dy = p.y-c.y;\n          const dd = dx*dx + dy*dy;\n          if (dd < best) best = dd;\n        }\n        return best;\n      });\n      // weighted pick\n      const sum = d2.reduce((a,b)=>a+b,0);\n      if (sum === 0) {\n        // all points equal, just add random\n        centroids.push({x: randRange(10,canvas.width-10), y: randRange(10,canvas.height-10)});\n        continue;\n      }\n      let r = Math.random()*sum;\n      let chosen = 0;\n      for (let i=0;i<d2.length;i++) {\n        r -= d2[i];\n        if (r <= 0) { chosen = i; break; }\n      }\n      centroids.push({x: points[chosen].x, y: points[chosen].y});\n    }\n  } else {\n    // random positions (or choose random points if dataset exists)\n    if (points.length >= K) {\n      // choose K random distinct points as centroids (good default)\n      const idxs = [];\n      while (idxs.length < K) {\n        const r = Math.floor(Math.random()*points.length);\n        if (!idxs.includes(r)) idxs.push(r);\n      }\n      for (let i=0;i<idxs.length;i++) {\n        const p = points[idxs[i]];\n        centroids.push({x: p.x + randRange(-2,2), y: p.y + randRange(-2,2)});\n      }\n    } else {\n      for (let i=0;i<K;i++) centroids.push({x: randRange(10,canvas.width-10), y: randRange(10,canvas.height-10)});\n    }\n  }\n  iteration = 0;\n  sseHistory = [];\n  updateStatus();\n  draw();\n}\n\n// Run animation loop of steps\nfunction run() {\n  if (running) return;\n  running = true;\n  document.getElementById('runBtn').disabled = true;\n  document.getElementById('pauseBtn').disabled = false;\n  const fps = 8; // steps per second\n  animationTimer = setInterval(()=>{\n    const finished = kmeansStep();\n    if (finished) { running = false; stopAnimation(); }\n  }, 1000/fps);\n}\nfunction stopAnimation() {\n  if (animationTimer) { clearInterval(animationTimer); animationTimer = null; }\n  document.getElementById('runBtn').disabled = false;\n  document.getElementById('pauseBtn').disabled = true;\n  running = false;\n}\n\n// draw SSE history small plot\nfunction drawSSE() {\n  const w = sseCanvas.width, h = sseCanvas.height;\n  sseCtx.clearRect(0,0,w,h);\n  sseCtx.fillStyle = '#fff';\n  sseCtx.fillRect(0,0,w,h);\n  sseCtx.strokeStyle = '#ddd';\n  sseCtx.strokeRect(0,0,w,h);\n  if (sseHistory.length===0) return;\n  const max = Math.max(...sseHistory);\n  const min = Math.min(...sseHistory);\n  sseCtx.beginPath();\n  sseCtx.lineWidth = 2;\n  sseCtx.strokeStyle = '#2b6df6';\n  for (let i=0;i<sseHistory.length;i++) {\n    const x = (i/(sseHistory.length-1 || 1))*(w-6)+3;\n    const t = (sseHistory[i] - min) / (max - min || 1);\n    const y = h - 4 - t*(h-8);\n    if (i===0) sseCtx.moveTo(x,y); else sseCtx.lineTo(x,y);\n  }\n  sseCtx.stroke();\n}\n\n// mouse interactions: add points, shift-drag to add many, drag centroids\ncanvas.addEventListener('mousedown',(e)=>{\n  const rect = canvas.getBoundingClientRect();\n  const x = e.clientX - rect.left;\n  const y = e.clientY - rect.top;\n  lastMouse = {x,y};\n  shiftDrag = e.shiftKey;\n  // check if near any centroid\n  for (let k=0;k<centroids.length;k++) {\n    const c = centroids[k];\n    if (Math.hypot(c.x-x,c.y-y) <= 12) {\n      dragging = {type:'centroid', idx:k, offsetX: c.x-x, offsetY: c.y-y};\n      return;\n    }\n  }\n  // not dragging centroid: add a point\n  if (e.button === 0) {\n    points.push({x,y});\n    labels.push(-1);\n    updateStatus();\n    draw();\n    // if shift, enable continuous draw\n    if (shiftDrag) dragging = {type:'brush'}; \n  }\n});\n\ncanvas.addEventListener('mousemove',(e)=>{\n  const rect = canvas.getBoundingClientRect();\n  const x = e.clientX - rect.left;\n  const y = e.clientY - rect.top;\n  if (!dragging) return;\n  if (dragging.type === 'centroid') {\n    const k = dragging.idx;\n    centroids[k].x = x + dragging.offsetX;\n    centroids[k].y = y + dragging.offsetY;\n    // update assignment and metrics in real-time\n    assign();\n    const sse = centroids.length? computeSSE() : 0;\n    if (sseHistory.length===0) sseHistory.push(sse); else sseHistory[sseHistory.length-1] = sse;\n    updateStatus();\n    drawSSE();\n    draw();\n  } else if (dragging.type === 'brush') {\n    // add points along the mouse move\n    const last = lastMouse || {x,y};\n    const dx = x - last.x, dy = y - last.y;\n    const dist = Math.hypot(dx,dy);\n    const steps = Math.max(1, Math.ceil(dist / 6));\n    for (let i=0;i<steps;i++) {\n      const px = last.x + dx*(i/steps);\n      const py = last.y + dy*(i/steps);\n      points.push({x:px,y:py});\n      labels.push(-1);\n    }\n    lastMouse = {x,y};\n    updateStatus();\n    draw();\n  }\n});\n\ncanvas.addEventListener('mouseup',(e)=>{\n  dragging = null;\n  lastMouse = null;\n});\n\ncanvas.addEventListener('mouseleave',(e)=>{\n  // stop brush when leaving\n  dragging = null;\n  lastMouse = null;\n});\n\n// UI element bindings\ndocument.getElementById('kRange').addEventListener('input',(e)=>{\n  document.getElementById('kLabel').innerText = e.target.value;\n});\ndocument.getElementById('kRange').addEventListener('change',(e)=>{\n  K = Math.max(1, parseInt(e.target.value));\n  // update centroids array size if needed\n  if (centroids.length > K) centroids = centroids.slice(0,K);\n  iteration = 0;\n  sseHistory = [];\n  updateStatus();\n  draw();\n});\n\ndocument.getElementsByName('init').forEach(r=>{\n  r.addEventListener('change', ()=>{/* nothing */});\n});\n\ndocument.getElementById('initBtn').addEventListener('click',()=>{\n  const method = document.querySelector('input[name=\"init\"]:checked').value;\n  initializeCentroids(method === 'kpp' ? 'kpp' : 'random');\n});\n\ndocument.getElementById('stepBtn').addEventListener('click',()=>{\n  if (centroids.length === 0) initializeCentroids(document.querySelector('input[name=\"init\"]:checked').value === 'kpp' ? 'kpp':'random');\n  kmeansStep();\n});\n\ndocument.getElementById('runBtn').addEventListener('click', ()=>{\n  if (centroids.length === 0) initializeCentroids(document.querySelector('input[name=\"init\"]:checked').value === 'kpp' ? 'kpp':'random');\n  run();\n});\ndocument.getElementById('pauseBtn').addEventListener('click', ()=>{\n  stopAnimation();\n});\n\ndocument.getElementById('resetBtn').addEventListener('click', clear);\n\ndocument.getElementById('genBtn').addEventListener('click', ()=>{\n  const n = Math.max(1, parseInt(document.getElementById('randN').value));\n  for (let i=0;i<n;i++) {\n    const x = randRange(10, canvas.width-10);\n    const y = randRange(10, canvas.height-10);\n    points.push({x,y});\n    labels.push(-1);\n  }\n  updateStatus();\n  draw();\n});\n\ndocument.getElementById('clusterGenBtn').addEventListener('click', ()=>{\n  const n = Math.max(1, parseInt(document.getElementById('randN').value));\n  for (let i=0;i<n;i++) {\n    const x = randRange(10, canvas.width-10);\n    const y = randRange(10, canvas.height-10);\n    points.push({x,y});\n    labels.push(-1);\n  }\n  updateStatus();\n  // initialize right away\n  const method = document.querySelector('input[name=\"init\"]:checked').value;\n  initializeCentroids(method === 'kpp' ? 'kpp' : 'random');\n  draw();\n});\n\ndocument.getElementById('nextBatchBtn').addEventListener('click', ()=>{\n  for (let i=0;i<50;i++) {\n    points.push({x: randRange(10, canvas.width-10), y: randRange(10, canvas.height-10)});\n    labels.push(-1);\n  }\n  updateStatus(); draw();\n});\n\ndocument.getElementById('removeBtn').addEventListener('click', ()=>{\n  if (points.length) {\n    points.pop();\n    labels.pop();\n    updateStatus();\n    draw();\n  }\n});\n\n// keyboard: space to step, r to run/pause, c to clear\ndocument.addEventListener('keydown',(e)=>{\n  if (e.key === ' ') { e.preventDefault(); document.getElementById('stepBtn').click(); }\n  if (e.key.toLowerCase() === 'r') { if (running) document.getElementById('pauseBtn').click(); else document.getElementById('runBtn').click(); }\n  if (e.key.toLowerCase() === 'c') { document.getElementById('resetBtn').click(); }\n});\n\n// initialize small demo data\nfunction seedDemo() {\n  // generate a few Gaussian clusters\n  function gauss(cx,cy, n) {\n    for (let i=0;i<n;i++) {\n      const angle = Math.random()*Math.PI*2;\n      const r = Math.sqrt(Math.random()) * 40;\n      const x = cx + Math.cos(angle)*r + randRange(-6,6);\n      const y = cy + Math.sin(angle)*r + randRange(-6,6);\n      points.push({x,y});\n      labels.push(-1);\n    }\n  }\n  gauss(150,150,60);\n  gauss(420,130,50);\n  gauss(320,350,70);\n  updateStatus();\n  draw();\n}\nseedDemo();\n\n// On load, center update\nupdateStatus();\ndraw();\n\n</script>\n</body>\n</html>",
      "refusal": null,
      "annotations": []
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "K-means clustering"
      }
    ],
    "evaluation": {
      "score": 3,
      "notes": "很丑，感觉不太对"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "7af87420-9903-11f0-94f8-f9ad827596cb",
    "model": "gpt-5-mini",
    "timestamp": "2025-09-24T05:01:07.555Z",
    "question": "K-means clustering",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>K-Means Clustering — Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, \"Helvetica Neue\", Arial; margin: 0; display:flex; height:100vh; }\n  #left { width: 360px; padding:16px; box-sizing:border-box; border-right:1px solid #e6e6e6; background:#fafafa; overflow:auto; }\n  #canvas-wrap { flex:1; display:flex; align-items:stretch; justify-content:stretch; position:relative; }\n  canvas { width:100%; height:100%; display:block; background: linear-gradient(180deg,#ffffff,#f3f7ff); cursor: crosshair; }\n  h1 { margin:0 0 12px 0; font-size:18px; }\n  label { display:block; margin:8px 0 4px; font-size:13px; color:#333; }\n  input[type=number], select { width:100%; padding:6px 8px; font-size:14px; box-sizing:border-box; }\n  .row { display:flex; gap:8px; margin-top:8px; }\n  button { padding:8px 10px; font-size:14px; border:1px solid #cfcfcf; background:white; cursor:pointer; border-radius:6px; }\n  button.primary { background:#2b78f6; color:white; border-color:#2466d6; }\n  button.ghost { background:transparent; border-color:#dcdcdc; }\n  .small { padding:6px 8px; font-size:13px; }\n  .muted { color:#555; font-size:13px; margin-top:12px; }\n  .info { margin-top:12px; font-size:13px; }\n  .stat { margin-top:8px; font-size:13px; }\n  .palette { display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; }\n  .color-sample { width:18px; height:18px; border-radius:3px; border:1px solid rgba(0,0,0,0.08); }\n  footer { position:absolute; left:14px; bottom:14px; font-size:12px; color:#666; }\n  .hint { font-size:12px; color:#666; margin-top:8px; }\n</style>\n</head>\n<body>\n  <div id=\"left\">\n    <h1>K-Means Clustering — Interactive Demo</h1>\n    <div class=\"muted\">\n      Click to add points. Drag points to move. Shift+click to remove nearest point.\n    </div>\n\n    <label>Number of clusters (K)</label>\n    <input id=\"k-input\" type=\"number\" min=\"1\" value=\"3\">\n\n    <label>Initialization</label>\n    <select id=\"init-select\">\n      <option value=\"random\">Random (pick K random points)</option>\n      <option value=\"kmeans++\" selected>K-means++</option>\n    </select>\n\n    <label>Points</label>\n    <div class=\"row\">\n      <button id=\"random-points\" class=\"small\">Randomize</button>\n      <input id=\"num-points\" type=\"number\" min=\"1\" value=\"100\" style=\"width:80px;\">\n    </div>\n\n    <label>Controls</label>\n    <div class=\"row\">\n      <button id=\"init-btn\" class=\"small\">Initialize</button>\n      <button id=\"step-btn\" class=\"small\">Step</button>\n      <button id=\"run-btn\" class=\"small primary\">Run</button>\n      <button id=\"stop-btn\" class=\"small\">Stop</button>\n    </div>\n\n    <div class=\"row\" style=\"margin-top:8px;\">\n      <button id=\"clear-btn\" class=\"small ghost\">Clear Points</button>\n      <button id=\"reset-btn\" class=\"small ghost\">Reset Centroids</button>\n    </div>\n\n    <label>Max iterations</label>\n    <input id=\"max-iter\" type=\"number\" min=\"1\" value=\"100\">\n\n    <label>Animation speed (ms per iteration)</label>\n    <input id=\"speed\" type=\"number\" min=\"10\" value=\"300\">\n\n    <div class=\"info\">\n      <div class=\"stat\">Iteration: <span id=\"iter\">0</span></div>\n      <div class=\"stat\">SSE (sum squared errors): <span id=\"sse\">0</span></div>\n      <div class=\"stat\">Points: <span id=\"count\">0</span></div>\n      <div class=\"stat\">Cluster sizes: <span id=\"sizes\">-</span></div>\n    </div>\n\n    <div class=\"hint\">Tips: Use K-means++ for better initialization. If a cluster is empty it will be reinitialized randomly.</div>\n\n    <div style=\"margin-top:12px;\">\n      Color palette:\n      <div class=\"palette\" id=\"palette\"></div>\n    </div>\n\n    <div style=\"margin-top:12px; font-size:13px;\">\n      Algorithm: assign each point to nearest centroid (Euclidean), then update centroids to mean of assigned points. Repeat until convergence or max iterations.\n    </div>\n\n    <footer>Interactive K-means — Click canvas to add, drag to move</footer>\n  </div>\n\n  <div id=\"canvas-wrap\">\n    <canvas id=\"canvas\"></canvas>\n  </div>\n\n<script>\n/* Interactive K-means clustering demo (single-file).\n   - Click canvas to add points\n   - Drag to move points\n   - Shift+click to remove nearest\n   - Controls to initialize, step, run, stop, randomize\n*/\n\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\nfunction resize() {\n  canvas.width = canvas.clientWidth * devicePixelRatio;\n  canvas.height = canvas.clientHeight * devicePixelRatio;\n  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);\n}\nwindow.addEventListener('resize', resize);\nresize();\n\n// UI elements\nconst kInput = document.getElementById('k-input');\nconst initSelect = document.getElementById('init-select');\nconst randomPointsBtn = document.getElementById('random-points');\nconst numPointsInput = document.getElementById('num-points');\nconst initBtn = document.getElementById('init-btn');\nconst stepBtn = document.getElementById('step-btn');\nconst runBtn = document.getElementById('run-btn');\nconst stopBtn = document.getElementById('stop-btn');\nconst clearBtn = document.getElementById('clear-btn');\nconst resetBtn = document.getElementById('reset-btn');\nconst maxIterInput = document.getElementById('max-iter');\nconst speedInput = document.getElementById('speed');\n\nconst iterLabel = document.getElementById('iter');\nconst sseLabel = document.getElementById('sse');\nconst countLabel = document.getElementById('count');\nconst sizesLabel = document.getElementById('sizes');\nconst paletteDiv = document.getElementById('palette');\n\nconst width = () => canvas.clientWidth;\nconst height = () => canvas.clientHeight;\n\n// Colors\nconst COLORS = [\n  \"#1f77b4\",\"#ff7f0e\",\"#2ca02c\",\"#d62728\",\"#9467bd\",\"#8c564b\",\"#e377c2\",\"#7f7f7f\",\"#bcbd22\",\"#17becf\"\n];\npaletteDiv.innerHTML = COLORS.map(c=>`<div class=\"color-sample\" style=\"background:${c}\"></div>`).join('');\n\n// Data structures\nlet points = []; // {x,y,cluster?}\nlet centroids = []; // {x,y, oldX?, oldY?}\nlet assignments = []; // index->cluster\nlet iteration = 0;\nlet running = false;\nlet timer = null;\n\n// Utilities\nfunction rand(min, max){ return Math.random()*(max-min)+min; }\nfunction dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }\n\nfunction updateStats(){\n  iterLabel.textContent = iteration;\n  countLabel.textContent = points.length;\n  // SSE\n  let sse = 0;\n  let sizes = new Array(centroids.length).fill(0);\n  for(let i=0;i<points.length;i++){\n    const c = assignments[i];\n    if(c!=null && centroids[c]) {\n      sse += dist2(points[i], centroids[c]);\n      sizes[c]++;\n    }\n  }\n  sseLabel.textContent = sse.toFixed(2);\n  sizesLabel.textContent = sizes.join(', ');\n}\n\n// Drawing\nfunction draw(){\n  ctx.clearRect(0,0,canvas.width,canvas.height);\n  // background grid\n  const step = 40;\n  ctx.save();\n  ctx.globalAlpha = 0.08;\n  ctx.strokeStyle = \"#ccc\";\n  for(let x=0;x<width();x+=step){\n    ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,height()); ctx.stroke();\n  }\n  for(let y=0;y<height();y+=step){\n    ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(width(),y+0.5); ctx.stroke();\n  }\n  ctx.restore();\n\n  // draw movement lines (centroid old->new)\n  for(let k=0;k<centroids.length;k++){\n    const c = centroids[k];\n    if(c && c.oldX!=null){\n      ctx.beginPath();\n      ctx.moveTo(c.oldX, c.oldY);\n      ctx.lineTo(c.x, c.y);\n      ctx.strokeStyle = hexToRgba(COLORS[k%COLORS.length], 0.6);\n      ctx.setLineDash([6,6]);\n      ctx.lineWidth = 2;\n      ctx.stroke();\n      ctx.setLineDash([]);\n    }\n  }\n\n  // points (colored by assignment)\n  for(let i=0;i<points.length;i++){\n    const p = points[i];\n    const cidx = assignments[i];\n    ctx.beginPath();\n    ctx.arc(p.x, p.y, 5, 0, Math.PI*2);\n    ctx.fillStyle = cidx==null ? '#999' : COLORS[cidx % COLORS.length];\n    ctx.fill();\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = 'rgba(0,0,0,0.08)';\n    ctx.stroke();\n  }\n\n  // centroids\n  for(let k=0;k<centroids.length;k++){\n    const c = centroids[k];\n    if(!c) continue;\n    const color = COLORS[k % COLORS.length];\n    // outer halo\n    ctx.beginPath();\n    ctx.arc(c.x, c.y, 12, 0, Math.PI*2);\n    ctx.fillStyle = hexToRgba(color, 0.12);\n    ctx.fill();\n    // center square\n    ctx.beginPath();\n    ctx.rect(c.x-6, c.y-6, 12, 12);\n    ctx.fillStyle = color;\n    ctx.fill();\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = '#222';\n    ctx.stroke();\n    // label\n    ctx.font = '12px system-ui, Arial';\n    ctx.fillStyle = '#111';\n    ctx.fillText('C'+k, c.x+10, c.y-10);\n  }\n  updateStats();\n}\n\n// helper to convert hex to rgba\nfunction hexToRgba(hex, a){\n  const h = hex.replace('#','');\n  const bigint = parseInt(h,16);\n  const r=(bigint>>16)&255, g=(bigint>>8)&255, b=bigint&255;\n  return `rgba(${r},${g},${b},${a})`;\n}\n\n// Interaction: add, drag, remove\nlet dragging = null;\nlet dragOffset = {x:0,y:0};\ncanvas.addEventListener('mousedown', e=>{\n  const pos = getMousePos(e);\n  // check if clicking on a point\n  const idx = findNearestPoint(pos, 8);\n  if(idx!=null && idx!=-1){\n    // start dragging\n    dragging = idx;\n    dragOffset.x = points[idx].x - pos.x;\n    dragOffset.y = points[idx].y - pos.y;\n    return;\n  }\n  // otherwise add or remove depending on shift\n  if(e.shiftKey){\n    // remove nearest\n    const near = findNearestPoint(pos, 20);\n    if(near!=null && near!=-1){\n      points.splice(near,1);\n      assignments.splice(near,1);\n      draw();\n    }\n  } else {\n    // add point\n    points.push({x:pos.x, y:pos.y});\n    assignments.push(null);\n    draw();\n  }\n});\nwindow.addEventListener('mousemove', e=>{\n  if(dragging!=null){\n    const pos = getMousePos(e);\n    points[dragging].x = Math.max(0, Math.min(width(), pos.x + dragOffset.x));\n    points[dragging].y = Math.max(0, Math.min(height(), pos.y + dragOffset.y));\n    draw();\n  }\n});\nwindow.addEventListener('mouseup', e=>{ dragging = null; });\n\nfunction getMousePos(e){\n  const rect = canvas.getBoundingClientRect();\n  return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n}\n\nfunction findNearestPoint(pos, maxDist=Infinity){\n  if(points.length===0) return -1;\n  let best = -1; let bestd = maxDist*maxDist;\n  for(let i=0;i<points.length;i++){\n    const d = (points[i].x-pos.x)*(points[i].x-pos.x) + (points[i].y-pos.y)*(points[i].y-pos.y);\n    if(d < bestd){ best = i; bestd = d; }\n  }\n  return best;\n}\n\n// K-means functions\nfunction initializeCentroids(k, method='kmeans++'){\n  centroids = [];\n  if(points.length===0){\n    // place random centroids in canvas\n    for(let i=0;i<k;i++){\n      centroids.push({x: rand(30,width()-30), y: rand(30,height()-30)});\n    }\n    assignments = new Array(points.length).fill(null);\n    iteration = 0;\n    return;\n  }\n  if(method==='random'){\n    // pick k random points (or randomly in screen if k>points)\n    const idxs = [];\n    for(let i=0;i<Math.min(k, points.length); i++){\n      let r; do { r = Math.floor(Math.random()*points.length); } while(idxs.includes(r));\n      idxs.push(r);\n      centroids.push({x: points[r].x, y: points[r].y});\n    }\n    while(centroids.length<k){\n      centroids.push({x: rand(30,width()-30), y: rand(30,height()-30)});\n    }\n  } else {\n    // kmeans++ initialization\n    // choose first centroid uniformly from points\n    const choose = [];\n    const n = points.length;\n    let idx = Math.floor(Math.random()*n);\n    centroids.push({x: points[idx].x, y: points[idx].y});\n    while(centroids.length<k){\n      // compute D(x)^2 = min distance squared to existing centroids\n      const ds = points.map(p => {\n        let d = Infinity;\n        for(const c of centroids){ const dx=p.x-c.x, dy=p.y-c.y; d = Math.min(d, dx*dx+dy*dy); }\n        return d;\n      });\n      const sum = ds.reduce((a,b)=>a+b,0);\n      if(sum===0){\n        // all points coincide or centroids cover them; add random points\n        centroids.push({x: rand(30,width()-30), y: rand(30,height()-30)});\n        continue;\n      }\n      // choose weighted by ds\n      let r = Math.random()*sum;\n      let chosen = 0;\n      for(let i=0;i<ds.length;i++){\n        r -= ds[i];\n        if(r <= 0){ chosen = i; break; }\n      }\n      centroids.push({x: points[chosen].x, y: points[chosen].y});\n    }\n  }\n  assignments = new Array(points.length).fill(null);\n  iteration = 0;\n}\n\nfunction assignPoints(){\n  let changed = false;\n  for(let i=0;i<points.length;i++){\n    let best = -1; let bd = Infinity;\n    for(let j=0;j<centroids.length;j++){\n      const d2 = (points[i].x-centroids[j].x)**2 + (points[i].y-centroids[j].y)**2;\n      if(d2 < bd){ bd = d2; best = j; }\n    }\n    if(assignments[i] !== best){ changed = true; assignments[i] = best; }\n  }\n  return changed;\n}\n\nfunction updateCentroids(){\n  // store old positions for drawing movement\n  for(let j=0;j<centroids.length;j++){\n    if(!centroids[j]) centroids[j] = {x:rand(10,width()-10), y:rand(10,height()-10)};\n    centroids[j].oldX = centroids[j].x;\n    centroids[j].oldY = centroids[j].y;\n  }\n  const sums = centroids.map(()=>({x:0,y:0,count:0}));\n  for(let i=0;i<points.length;i++){\n    const c = assignments[i];\n    if(c==null) continue;\n    sums[c].x += points[i].x;\n    sums[c].y += points[i].y;\n    sums[c].count++;\n  }\n  for(let j=0;j<centroids.length;j++){\n    if(sums[j].count===0){\n      // empty cluster: reinitialize to random point\n      centroids[j].x = rand(30,width()-30);\n      centroids[j].y = rand(30,height()-30);\n    } else {\n      centroids[j].x = sums[j].x / sums[j].count;\n      centroids[j].y = sums[j].y / sums[j].count;\n    }\n  }\n}\n\n// One K-means iteration (assign + update)\nfunction kmeansStep(){\n  if(centroids.length===0) return;\n  const changed = assignPoints();\n  updateCentroids();\n  iteration++;\n  draw();\n  return changed;\n}\n\n// Run until convergence or max iterations\nfunction runKmeans(){\n  const maxIter = Math.max(1, parseInt(maxIterInput.value)||100);\n  const speed = Math.max(5, parseInt(speedInput.value)||200);\n  stopKmeans();\n  running = true;\n  runBtn.disabled = true;\n  initBtn.disabled = true;\n  stepBtn.disabled = true;\n  clearBtn.disabled = true;\n\n  function loop(){\n    if(!running) return;\n    if(iteration >= maxIter){ stopKmeans(); return; }\n    const changed = kmeansStep();\n    // if no assignments changed and centroids didn't move much, stop\n    // Here we detect change by changed boolean and small centroid movements\n    let moved = false;\n    for(let c of centroids){\n      if(c.oldX==null) { moved = true; break; }\n      if(Math.hypot(c.x-c.oldX, c.y-c.oldY) > 1e-3) { moved = true; break; }\n    }\n    if(!changed && !moved){ stopKmeans(); return; }\n    timer = setTimeout(loop, speed);\n  }\n  loop();\n}\n\nfunction stopKmeans(){\n  running = false;\n  clearTimeout(timer);\n  runBtn.disabled = false;\n  initBtn.disabled = false;\n  stepBtn.disabled = false;\n  clearBtn.disabled = false;\n}\n\n// Buttons\ninitBtn.addEventListener('click', ()=>{\n  const k = Math.max(1, parseInt(kInput.value)||1);\n  initializeCentroids(k, initSelect.value);\n  draw();\n});\nstepBtn.addEventListener('click', ()=>{\n  stopKmeans();\n  if(centroids.length===0){\n    initializeCentroids(Math.max(1,parseInt(kInput.value)||1), initSelect.value);\n  }\n  kmeansStep();\n});\nrunBtn.addEventListener('click', ()=>{ runKmeans(); });\nstopBtn.addEventListener('click', ()=>{ stopKmeans(); });\n\nrandomPointsBtn.addEventListener('click', ()=>{\n  points = [];\n  assignments = [];\n  const n = Math.max(1, parseInt(numPointsInput.value) || 100);\n  // generate Gaussian-ish blobs for nicer demonstration\n  const clusters = Math.max(2, Math.min(6, Math.floor(Math.random()*5)+2));\n  const centers = [];\n  for(let i=0;i<clusters;i++){\n    centers.push({x: rand(60,width()-60), y: rand(60,height()-60)});\n  }\n  for(let i=0;i<n;i++){\n    const c = centers[Math.floor(Math.random()*centers.length)];\n    const r = Math.random()*60;\n    const angle = Math.random()*Math.PI*2;\n    const x = c.x + Math.cos(angle)*r*0.6 + rand(-8,8);\n    const y = c.y + Math.sin(angle)*r*0.6 + rand(-8,8);\n    points.push({x: Math.max(6,Math.min(width()-6,x)), y: Math.max(6,Math.min(height()-6,y))});\n    assignments.push(null);\n  }\n  centroids = [];\n  iteration = 0;\n  draw();\n});\n\nclearBtn.addEventListener('click', ()=>{ points=[]; assignments=[]; centroids=[]; iteration=0; draw(); });\nresetBtn.addEventListener('click', ()=>{ centroids=[]; assignments = new Array(points.length).fill(null); iteration=0; draw(); });\n\n/* initial example */\n(function initDemo(){\n  // create a few blobs\n  const n = 120;\n  const centers = [{x:100,y:120},{x:400,y:80},{x:300,y:320}];\n  for(let i=0;i<n;i++){\n    const c = centers[i%centers.length];\n    const r = Math.random()*50;\n    const angle = Math.random()*Math.PI*2;\n    points.push({x:c.x + Math.cos(angle)*r + rand(-6,6), y:c.y + Math.sin(angle)*r + rand(-6,6)});\n    assignments.push(null);\n  }\n  updateStats();\n  draw();\n})();\n\n</script>\n</body>\n</html>",
      "refusal": null,
      "annotations": []
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "K-means clustering"
      }
    ],
    "evaluation": {
      "score": 4,
      "notes": "看着还比较对"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "f731c0f0-9903-11f0-903f-db19604321bc",
    "model": "o3-mini-high",
    "timestamp": "2025-09-24T05:04:35.968Z",
    "question": "Bubble Sort",
    "answer": {
      "role": "assistant",
      "content": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>Bubble Sort Visualization</title>\n    <style>\n      body {\n        font-family: Arial, sans-serif;\n        text-align: center;\n        background-color: #f0f0f0;\n        margin: 0;\n        padding: 20px;\n      }\n      canvas {\n        background-color: #fff;\n        border: 1px solid #333;\n        display: block;\n        margin: 20px auto;\n      }\n      button {\n        padding: 10px 20px;\n        margin: 10px;\n        font-size: 16px;\n      }\n    </style>\n  </head>\n  <body>\n    <h1>Bubble Sort Visualization</h1>\n    <canvas id=\"canvas\" width=\"600\" height=\"400\"></canvas>\n    <div>\n      <button id=\"start\">Start Bubble Sort</button>\n      <button id=\"reset\">Reset Array</button>\n    </div>\n    \n    <script>\n      // Get canvas and context\n      const canvas = document.getElementById(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n\n      // Global variables for the array and our bubble sort pointers\n      let arr = [];\n      let i = 0, j = 0;\n      let intervalId = null;\n\n      // Initialize the random array and reset indices\n      function init() {\n        arr = [];\n        const numberOfBars = 50;\n        for (let k = 0; k < numberOfBars; k++) {\n          // Generate a random height between 20 and canvas height (to avoid too short bars)\n          arr.push(Math.floor(Math.random() * (canvas.height - 20)) + 20);\n        }\n        i = 0;\n        j = 0;\n        draw();\n      }\n\n      // Draw the array bars on the canvas.\n      // If sorting is complete (i >= arr.length), display all bars in green.\n      // Otherwise, highlight the two bars being compared in red.\n      function draw() {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        const barWidth = canvas.width / arr.length;\n        for (let k = 0; k < arr.length; k++) {\n          if (i >= arr.length) {\n            // Sorting complete\n            ctx.fillStyle = \"green\";\n          } else if (k === j || k === j + 1) {\n            // Current pair being compared\n            ctx.fillStyle = \"red\";\n          } else {\n            ctx.fillStyle = \"blue\";\n          }\n          ctx.fillRect(k * barWidth, canvas.height - arr[k], barWidth - 1, arr[k]);\n        }\n      }\n\n      // Execute one \"step\" of bubble sort.\n      // This function compares and swaps a single pair of adjacent elements,\n      // then updates the indices. When done, it stops the interval.\n      function bubbleSortStep() {\n        if (i < arr.length) {\n          if (j < arr.length - i - 1) {\n            if (arr[j] > arr[j + 1]) {\n              // Swap the elements\n              const temp = arr[j];\n              arr[j] = arr[j + 1];\n              arr[j + 1] = temp;\n            }\n            j++;\n          } else {\n            // End of one full pass, reset inner index and move the outer pointer\n            j = 0;\n            i++;\n          }\n        } else {\n          // Sorting is complete\n          clearInterval(intervalId);\n          intervalId = null;\n        }\n        draw();\n      }\n\n      // Start button event: Reset indices and start the interval to animate sorting\n      document.getElementById(\"start\").addEventListener(\"click\", function () {\n        if (intervalId) {\n          clearInterval(intervalId);\n        }\n        // Reset counters to re-run the sort\n        i = 0;\n        j = 0;\n        intervalId = setInterval(bubbleSortStep, 50);\n      });\n\n      // Reset button: Stop any ongoing sort and generate a new random array.\n      document.getElementById(\"reset\").addEventListener(\"click\", function () {\n        if (intervalId) {\n          clearInterval(intervalId);\n          intervalId = null;\n        }\n        init();\n      });\n\n      // Initialize the array and draw it on page load.\n      init();\n    </script>\n  </body>\n</html>",
      "refusal": null,
      "annotations": []
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Bubble Sort"
      }
    ],
    "evaluation": {
      "score": 3,
      "notes": "美观度不行，交互性可调参数不行"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "488c2b70-9904-11f0-81e8-17b92652cd45",
    "model": "o3-mini-high",
    "timestamp": "2025-09-24T05:06:52.456Z",
    "question": "Bubble Sort",
    "answer": {
      "role": "assistant",
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Bubble Sort Visualization</title>\n    <style>\n      body {\n        font-family: Arial, sans-serif;\n        text-align: center;\n      }\n      canvas {\n        border: 1px solid #333;\n        margin: 20px;\n      }\n      button {\n        margin: 10px;\n        padding: 10px 20px;\n        font-size: 16px;\n        cursor: pointer;\n      }\n    </style>\n  </head>\n  <body>\n    <h1>Bubble Sort Visualization</h1>\n    <canvas id=\"sortCanvas\" width=\"800\" height=\"400\"></canvas>\n    <br />\n    <button id=\"startBtn\">Start Sorting</button>\n    <button id=\"resetBtn\">Reset Array</button>\n\n    <script>\n      // Global variables\n      const canvas = document.getElementById(\"sortCanvas\");\n      const ctx = canvas.getContext(\"2d\");\n      const arraySize = 50; // Number of elements in the array\n      let array = [];\n      let sortingInterval;\n      let i = 0, j = 0; // Bubble sort indices\n\n      // Initialize the array with random values\n      function initArray() {\n        array = [];\n        for (let k = 0; k < arraySize; k++) {\n          // Random values between 5 and canvas.height for visible bars\n          array.push(Math.floor(Math.random() * (canvas.height - 5)) + 5);\n        }\n      }\n\n      // Draw the array as bars on the canvas.\n      // Optionally, highlight two indices (e.g., currently compared elements).\n      function drawArray(highlight1, highlight2) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        const barWidth = canvas.width / arraySize;\n        for (let k = 0; k < arraySize; k++) {\n          const barHeight = array[k];\n          // Highlight bars being compared in red\n          if (k === highlight1 || k === highlight2) {\n            ctx.fillStyle = \"red\";\n          } else {\n            ctx.fillStyle = \"blue\";\n          }\n          // Draw the bar. Subtract 2 from barWidth for spacing.\n          ctx.fillRect(k * barWidth, canvas.height - barHeight, barWidth - 2, barHeight);\n        }\n      }\n\n      // Performs one step of the bubble sort algorithm.\n      function bubbleSortStep() {\n        if (i < array.length) {\n          if (j < array.length - i - 1) {\n            // Visualize the comparison: highlight indices j and j+1.\n            drawArray(j, j + 1);\n            if (array[j] > array[j + 1]) {\n              // Swap elements if they are in the wrong order.\n              const temp = array[j];\n              array[j] = array[j + 1];\n              array[j + 1] = temp;\n            }\n            j++;\n          } else {\n            // End of one full pass; reset inner loop index and increment outer loop.\n            j = 0;\n            i++;\n          }\n        } else {\n          // Sorting complete: clear the interval and display the final sorted array.\n          drawArray();\n          clearInterval(sortingInterval);\n          sortingInterval = null;\n          document.getElementById(\"startBtn\").disabled = false;\n        }\n      }\n\n      // Start the sorting process.\n      function startSorting() {\n        if (sortingInterval) return; // Prevent multiple intervals\n        document.getElementById(\"startBtn\").disabled = true;\n        i = 0;\n        j = 0;\n        sortingInterval = setInterval(bubbleSortStep, 50); // Adjust delay (ms) as needed\n      }\n\n      // Reset the array and redraw unsorted bars.\n      function resetArray() {\n        if (sortingInterval) {\n          clearInterval(sortingInterval);\n          sortingInterval = null;\n        }\n        initArray();\n        drawArray();\n        document.getElementById(\"startBtn\").disabled = false;\n        i = 0;\n        j = 0;\n      }\n\n      // Initialize array and draw it when the page loads.\n      window.onload = function () {\n        initArray();\n        drawArray();\n      };\n\n      // Attach event listeners to buttons.\n      document.getElementById(\"startBtn\").addEventListener(\"click\", startSorting);\n      document.getElementById(\"resetBtn\").addEventListener(\"click\", resetArray);\n    </script>\n  </body>\n</html>",
      "refusal": null,
      "annotations": []
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Bubble Sort"
      }
    ],
    "evaluation": {
      "score": 3,
      "notes": "维持原判。美观度不行，交互性可调参数不行"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "ca4f9f20-9904-11f0-8a8d-ff78404f1f3b",
    "model": "o3-mini-high",
    "timestamp": "2025-09-24T05:10:30.162Z",
    "question": "Linked List",
    "answer": {
      "role": "assistant",
      "content": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Linked List Demo</title>\n    <style>\n      body {\n        font-family: Arial, sans-serif;\n        margin: 20px;\n      }\n      input,\n      button {\n        margin: 5px;\n        padding: 5px 10px;\n        font-size: 16px;\n      }\n      .node {\n        display: inline-block;\n        border: 1px solid #333;\n        border-radius: 4px;\n        padding: 8px 12px;\n        margin: 5px;\n        background-color: #cce5ff;\n      }\n      .arrow {\n        display: inline-block;\n        margin: 0 5px;\n        font-size: 22px;\n        vertical-align: middle;\n      }\n      #listContainer {\n        margin-top: 20px;\n      }\n    </style>\n  </head>\n  <body>\n    <h1>Linked List Demo (JavaScript)</h1>\n    <p>\n      This demo demonstrates a simple Linked List implementation in JavaScript.\n      You can append nodes, remove the head node, or clear the entire list.\n    </p>\n\n    <div>\n      <input type=\"text\" id=\"nodeValue\" placeholder=\"Enter node value\" />\n      <button onclick=\"appendNode()\">Append Node</button>\n      <button onclick=\"removeHead()\">Remove Head</button>\n      <button onclick=\"clearList()\">Clear List</button>\n    </div>\n\n    <div id=\"listContainer\">\n      <!-- Linked List will be rendered here -->\n    </div>\n\n    <script>\n      // Node class - represents a single element in the linked list\n      class Node {\n        constructor(value) {\n          this.value = value;\n          this.next = null;\n        }\n      }\n\n      // LinkedList class - manages nodes\n      class LinkedList {\n        constructor() {\n          this.head = null;\n        }\n\n        // Append a node with the given value to the end of the list\n        append(value) {\n          const newNode = new Node(value);\n          if (this.head === null) {\n            this.head = newNode;\n          } else {\n            let current = this.head;\n            while (current.next !== null) {\n              current = current.next;\n            }\n            current.next = newNode;\n          }\n        }\n\n        // Remove the head node of the linked list\n        removeHead() {\n          if (this.head !== null) {\n            this.head = this.head.next;\n          }\n        }\n\n        // Clear the linked list\n        clear() {\n          this.head = null;\n        }\n\n        // Convert the linked list to an array for easy display\n        toArray() {\n          const arr = [];\n          let current = this.head;\n          while (current) {\n            arr.push(current.value);\n            current = current.next;\n          }\n          return arr;\n        }\n      }\n\n      // Instance of the LinkedList\n      const linkedList = new LinkedList();\n\n      // Update the display of the linked list in the HTML\n      function updateDisplay() {\n        const container = document.getElementById(\"listContainer\");\n        container.innerHTML = \"\"; // Clear previous content\n\n        if (linkedList.head === null) {\n          container.textContent = \"The list is empty.\";\n          return;\n        }\n\n        let current = linkedList.head;\n        while (current) {\n          // Create a visual representation for a node\n          const nodeElement = document.createElement(\"span\");\n          nodeElement.className = \"node\";\n          nodeElement.textContent = current.value;\n          container.appendChild(nodeElement);\n\n          // If there is a next node, add an arrow\n          if (current.next) {\n            const arrowElement = document.createElement(\"span\");\n            arrowElement.className = \"arrow\";\n            arrowElement.textContent = \"→\";\n            container.appendChild(arrowElement);\n          }\n\n          current = current.next;\n        }\n      }\n\n      // Append a new node to the linked list\n      function appendNode() {\n        const input = document.getElementById(\"nodeValue\");\n        const value = input.value.trim();\n        if (value !== \"\") {\n          linkedList.append(value);\n          input.value = \"\";\n          updateDisplay();\n        } else {\n          alert(\"Please enter a value to append.\");\n        }\n      }\n\n      // Remove the head node of the linked list\n      function removeHead() {\n        if (linkedList.head === null) {\n          alert(\"The list is already empty.\");\n          return;\n        }\n        linkedList.removeHead();\n        updateDisplay();\n      }\n\n      // Clear the entire linked list\n      function clearList() {\n        linkedList.clear();\n        updateDisplay();\n      }\n\n      // Initial display update\n      updateDisplay();\n    </script>\n  </body>\n</html>",
      "refusal": null,
      "annotations": []
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Linked List"
      }
    ],
    "evaluation": {
      "score": 3,
      "notes": "o3好像就这样。生成东西很短但是绝对正确。美观度和可交互性都不行。"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "06754400-9905-11f0-a257-cdbaf9f86314",
    "model": "o3-mini-high",
    "timestamp": "2025-09-24T05:12:11.073Z",
    "question": "K-means clustering",
    "answer": {
      "role": "assistant",
      "content": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>K-means Clustering Demonstration</title>\n    <style>\n      body {\n        font-family: sans-serif;\n        text-align: center;\n        margin: 20px;\n      }\n      canvas {\n        border: 1px solid #ccc;\n        background: #fafafa;\n      }\n      input, button {\n        margin: 5px;\n        padding: 5px;\n        font-size: 14px;\n      }\n    </style>\n  </head>\n  <body>\n    <h1>K-means Clustering Demonstration</h1>\n    <p>\n      This demo visualizes the K-means clustering algorithm. Click \"Start\" to generate random points and initialize cluster centers.\n      Then use \"Step\" for a single iteration or \"Auto Step\" to run iterations automatically until convergence.\n    </p>\n    <div>\n      <label for=\"numPoints\">Number of Points:</label>\n      <input type=\"number\" id=\"numPoints\" value=\"200\" min=\"10\" max=\"1000\">\n      &nbsp;\n      <label for=\"numClusters\">Number of Clusters (K):</label>\n      <input type=\"number\" id=\"numClusters\" value=\"4\" min=\"1\" max=\"10\">\n    </div>\n    <div>\n      <button id=\"startButton\">Start</button>\n      <button id=\"stepButton\" disabled>Step</button>\n      <button id=\"autoButton\" disabled>Auto Step</button>\n      <button id=\"stopAutoButton\" disabled>Stop Auto Step</button>\n    </div>\n    <br>\n    <canvas id=\"canvas\" width=\"600\" height=\"600\"></canvas>\n\n    <script>\n      // Global Variables\n      const canvas = document.getElementById(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      let points = [];\n      let centroids = [];\n      let colors = [];\n      let k = 0;\n      let iterationCount = 0;\n      let autoInterval = null;\n\n      // Initialize the simulation and data.\n      function init() {\n        // Clear any existing automatic stepping.\n        if (autoInterval) {\n          clearInterval(autoInterval);\n          autoInterval = null;\n        }\n        iterationCount = 0;\n        points = [];\n        centroids = [];\n        colors = [];\n        \n        // Get user inputs.\n        const numPoints = parseInt(document.getElementById(\"numPoints\").value);\n        k = parseInt(document.getElementById(\"numClusters\").value);\n\n        // Generate random points.\n        for (let i = 0; i < numPoints; i++) {\n          points.push({\n            x: Math.random() * canvas.width,\n            y: Math.random() * canvas.height,\n            cluster: -1 // Not assigned yet.\n          });\n        }\n\n        // Initialize centroids: randomly pick positions from among points.\n        for (let i = 0; i < k; i++) {\n          const randomPoint = points[Math.floor(Math.random() * points.length)];\n          centroids.push({\n            x: randomPoint.x,\n            y: randomPoint.y\n          });\n        }\n\n        // Generate distinct colors for clusters.\n        for (let i = 0; i < k; i++) {\n          let hue = i * 360 / k;\n          colors.push(\"hsl(\" + hue + \", 100%, 50%)\");\n        }\n\n        // Enable iteration buttons.\n        document.getElementById(\"stepButton\").disabled = false;\n        document.getElementById(\"autoButton\").disabled = false;\n        document.getElementById(\"stopAutoButton\").disabled = true;\n        draw();\n      }\n\n      // Draw points and centroids onto the canvas.\n      function draw() {\n        // Clear canvas.\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        // Draw data points.\n        for (let p of points) {\n          ctx.beginPath();\n          ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);\n          // Points before assignment appear gray.\n          ctx.fillStyle = (p.cluster === -1) ? \"#999\" : colors[p.cluster];\n          ctx.fill();\n        }\n\n        // Draw centroids.\n        for (let i = 0; i < centroids.length; i++) {\n          const c = centroids[i];\n          ctx.beginPath();\n          ctx.arc(c.x, c.y, 8, 0, Math.PI * 2);\n          ctx.fillStyle = colors[i];\n          ctx.fill();\n          ctx.lineWidth = 2;\n          ctx.strokeStyle = \"#000\";\n          ctx.stroke();\n        }\n\n        // Display the current iteration count.\n        ctx.font = \"16px Arial\";\n        ctx.fillStyle = \"#000\";\n        ctx.fillText(\"Iteration: \" + iterationCount, 10, 20);\n      }\n\n      // Perform one iteration (assignment and update) of k-means.\n      function step() {\n        iterationCount++;\n        // Assignment step: assign each point to the nearest centroid.\n        for (let p of points) {\n          let minDist = Infinity;\n          let assignedCluster = -1;\n          for (let i = 0; i < centroids.length; i++) {\n            let c = centroids[i];\n            let dx = p.x - c.x;\n            let dy = p.y - c.y;\n            let dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < minDist) {\n              minDist = dist;\n              assignedCluster = i;\n            }\n          }\n          p.cluster = assignedCluster;\n        }\n\n        // Update step: recalculate centroids based on assigned points.\n        let newCentroids = [];\n        for (let i = 0; i < k; i++) {\n          let sumX = 0, sumY = 0, count = 0;\n          for (let p of points) {\n            if (p.cluster === i) {\n              sumX += p.x;\n              sumY += p.y;\n              count++;\n            }\n          }\n          if (count === 0) {\n            // If a cluster loses all its points, reinitialize it randomly.\n            newCentroids.push({\n              x: Math.random() * canvas.width,\n              y: Math.random() * canvas.height\n            });\n          } else {\n            newCentroids.push({\n              x: sumX / count,\n              y: sumY / count\n            });\n          }\n        }\n\n        // Check for convergence: if centroids hardly move, consider it converged.\n        let converged = true;\n        for (let i = 0; i < k; i++) {\n          const dx = newCentroids[i].x - centroids[i].x;\n          const dy = newCentroids[i].y - centroids[i].y;\n          if (Math.sqrt(dx * dx + dy * dy) > 0.5) {  // tolerance threshold\n            converged = false;\n            break;\n          }\n        }\n\n        // Update centroids to new positions.\n        centroids = newCentroids;\n        draw();\n        \n        // If converged, disable further iteration.\n        if (converged) {\n          alert(\"Converged after \" + iterationCount + \" iterations!\");\n          document.getElementById(\"stepButton\").disabled = true;\n          document.getElementById(\"autoButton\").disabled = true;\n          document.getElementById(\"stopAutoButton\").disabled = true;\n          if (autoInterval) {\n            clearInterval(autoInterval);\n            autoInterval = null;\n          }\n        }\n      }\n\n      // Automatically perform steps at intervals.\n      function startAuto() {\n        document.getElementById(\"autoButton\").disabled = true;\n        document.getElementById(\"stopAutoButton\").disabled = false;\n        autoInterval = setInterval(step, 1000);\n      }\n\n      function stopAuto() {\n        if (autoInterval) {\n          clearInterval(autoInterval);\n          autoInterval = null;\n        }\n        document.getElementById(\"autoButton\").disabled = false;\n        document.getElementById(\"stopAutoButton\").disabled = true;\n      }\n\n      // Assign event listeners to the buttons.\n      document.getElementById(\"startButton\").addEventListener(\"click\", init);\n      document.getElementById(\"stepButton\").addEventListener(\"click\", step);\n      document.getElementById(\"autoButton\").addEventListener(\"click\", startAuto);\n      document.getElementById(\"stopAutoButton\").addEventListener(\"click\", stopAuto);\n    </script>\n  </body>\n</html>",
      "refusal": null,
      "annotations": []
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "K-means clustering"
      }
    ],
    "evaluation": {
      "score": 3,
      "notes": "维持原判"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "60b3fce0-9905-11f0-a79a-b3247c3c0412",
    "model": "deepseek-r1",
    "timestamp": "2025-09-24T05:14:42.479Z",
    "question": "Bubble Sort",
    "answer": {
      "role": "assistant",
      "content": "\nHere's an interactive Bubble Sort visualization in a single HTML file:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Bubble Sort Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            max-width: 900px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f7fa;\n            color: #333;\n        }\n        h1 {\n            color: #2c3e50;\n            text-align: center;\n        }\n        .container {\n            background-color: white;\n            border-radius: 10px;\n            padding: 25px;\n            box-shadow: 0 4px 12px rgba(0,0,0,0.1);\n        }\n        .visualization {\n            display: flex;\n            align-items: flex-end;\n            height: 300px;\n            margin: 30px 0;\n            padding: 20px;\n            border: 2px solid #e0e6ed;\n            border-radius: 8px;\n            overflow: hidden;\n        }\n        .bar {\n            flex: 1;\n            background-color: #3498db;\n            margin: 0 2px;\n            border-radius: 4px 4px 0 0;\n            transition: height 0.3s, background-color 0.3s;\n        }\n        .comparing {\n            background-color: #e74c3c !important;\n        }\n        .sorted {\n            background-color: #2ecc71 !important;\n        }\n        .controls {\n            display: flex;\n            justify-content: center;\n            gap: 15px;\n            margin: 20px 0;\n        }\n        button {\n            padding: 12px 25px;\n            font-size: 16px;\n            cursor: pointer;\n            background-color: #3498db;\n            color: white;\n            border: none;\n            border-radius: 5px;\n            transition: background-color 0.2s;\n        }\n        button:hover {\n            background-color: #2980b9;\n        }\n        button:disabled {\n            background-color: #bdc3c7;\n            cursor: not-allowed;\n        }\n        .speed-control {\n            display: flex;\n            align-items: center;\n            gap: 10px;\n            margin-top: 15px;\n        }\n        .explanation {\n            background-color: #f8f9fa;\n            padding: 20px;\n            border-radius: 8px;\n            margin-top: 30px;\n            line-height: 1.6;\n        }\n        .algorithm-steps {\n            margin-top: 15px;\n            padding-left: 20px;\n        }\n        .counter {\n            margin-top: 15px;\n            font-weight: bold;\n            text-align: center;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Bubble Sort Visualization</h1>\n        \n        <div class=\"visualization\" id=\"visualization\"></div>\n        \n        <div class=\"counter\">\n            Comparisons: <span id=\"comparison-count\">0</span> | \n            Swaps: <span id=\"swap-count\">0</span> | \n            Passes: <span id=\"pass-count\">0</span>\n        </div>\n        \n        <div class=\"controls\">\n            <button id=\"start-btn\">Start Sorting</button>\n            <button id=\"reset-btn\">Reset Array</button>\n            <button id=\"step-btn\">Step Forward</button>\n        </div>\n        \n        <div class=\"speed-control\">\n            <label for=\"speed-slider\">Animation Speed:</label>\n            <input type=\"range\" id=\"speed-slider\" min=\"1\" max=\"200\" value=\"50\">\n            <span id=\"speed-value\">Medium</span>\n        </div>\n        \n        <div class=\"explanation\">\n            <h3>How Bubble Sort Works</h3>\n            <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, \n            compares adjacent elements and swaps them if they are in the wrong order.</p>\n            \n            <div class=\"algorithm-steps\">\n                <p>1. Start at the beginning of the array</p>\n                <p>2. Compare each pair of adjacent elements</p>\n                <p>3. If elements are in wrong order, swap them</p>\n                <p>4. After each pass, the largest unsorted element \"bubbles up\" to its correct position</p>\n                <p>5. Repeat until no more swaps are needed</p>\n            </div>\n            \n            <p><strong>Time Complexity:</strong> O(n²) in worst and average cases</p>\n        </div>\n    </div>\n\n    <script>\n        // Configuration constants\n        const ARRAY_SIZE = 20;\n        const MIN_VALUE = 20;\n        const MAX_VALUE = 280;\n        \n        // State management\n        let array = [];\n        let isSorting = false;\n        let comparisonCount = 0;\n        let swapCount = 0;\n        let passCount = 0;\n        let i = 0;\n        let j = 0;\n        let speed = 100;\n        let timeoutId = null;\n        \n        // DOM Elements\n        const visualization = document.getElementById('visualization');\n        const startBtn = document.getElementById('start-btn');\n        const resetBtn = document.getElementById('reset-btn');\n        const stepBtn = document.getElementById('step-btn');\n        const speedSlider = document.getElementById('speed-slider');\n        const speedValue = document.getElementById('speed-value');\n        const comparisonCountEl = document.getElementById('comparison-count');\n        const swapCountEl = document.getElementById('swap-count');\n        const passCountEl = document.getElementById('pass-count');\n        \n        // Initialize visualization\n        function init() {\n            generateRandomArray();\n            renderBars();\n            addEventListeners();\n            updateSpeedLabel();\n        }\n        \n        // Generate random array\n        function generateRandomArray() {\n            array = [];\n            for (let i = 0; i < ARRAY_SIZE; i++) {\n                array.push(Math.floor(Math.random() * (MAX_VALUE - MIN_VALUE + 1) + MIN_VALUE));\n            }\n            resetState();\n        }\n        \n        // Reset algorithm state\n        function resetState() {\n            i = 0;\n            j = 0;\n            comparisonCount = 0;\n            swapCount = 0;\n            passCount = 0;\n            updateCounters();\n            clearTimeout(timeoutId);\n            isSorting = false;\n            startBtn.textContent = \"Start Sorting\";\n            stepBtn.disabled = false;\n        }\n        \n        // Update counters display\n        function updateCounters() {\n            comparisonCountEl.textContent = comparisonCount;\n            swapCountEl.textContent = swapCount;\n            passCountEl.textContent = passCount;\n        }\n        \n        // Render bars based on current array state\n        function renderBars() {\n            visualization.innerHTML = '';\n            array.forEach((value, index) => {\n                const bar = document.createElement('div');\n                bar.className = 'bar';\n                bar.style.height = `${value}px`;\n                \n                // Highlight elements being compared\n                if (index === j || index === j+1) {\n                    bar.classList.add('comparing');\n                }\n                \n                // Highlight sorted elements\n                if (index > array.length - i - 1) {\n                    bar.classList.add('sorted');\n                }\n                \n                // Display value on top of bar\n                const valueLabel = document.createElement('div');\n                valueLabel.textContent = value;\n                valueLabel.style.textAlign = 'center';\n                valueLabel.style.marginTop = '5px';\n                valueLabel.style.fontSize = '12px';\n                bar.appendChild(valueLabel);\n                \n                visualization.appendChild(bar);\n            });\n        }\n        \n        // Perform one step of bubble sort\n        function bubbleSortStep() {\n            if (i < array.length - 1) {\n                if (j < array.length - i - 1) {\n                    comparisonCount++;\n                    \n                    // Compare adjacent elements\n                    if (array[j] > array[j + 1]) {\n                        // Swap elements\n                        [array[j], array[j + 1]] = [array[j + 1], array[j]];\n                        swapCount++;\n                    }\n                    j++;\n                } else {\n                    // Completed a pass\n                    j = 0;\n                    i++;\n                    passCount++;\n                }\n                updateCounters();\n                renderBars();\n                return true;\n            }\n            return false;\n        }\n        \n        // Animation controller\n        function animateSort() {\n            if (!isSorting) return;\n            \n            const hasMoreSteps = bubbleSortStep();\n            \n            if (hasMoreSteps) {\n                timeoutId = setTimeout(animateSort, speed);\n            } else {\n                isSorting = false;\n                startBtn.textContent = \"Start Sorting\";\n                stepBtn.disabled = false;\n            }\n        }\n        \n        // Event handlers\n        function addEventListeners() {\n            startBtn.addEventListener('click', () => {\n                if (isSorting) {\n                    // Pause sorting\n                    isSorting = false;\n                    startBtn.textContent = \"Resume Sorting\";\n                    clearTimeout(timeoutId);\n                } else {\n                    // Start/resume sorting\n                    isSorting = true;\n                    startBtn.textContent = \"Pause Sorting\";\n                    stepBtn.disabled = true;\n                    animateSort();\n                }\n            });\n            \n            resetBtn.addEventListener('click', () => {\n                generateRandomArray();\n                renderBars();\n            });\n            \n            stepBtn.addEventListener('click', () => {\n                if (!isSorting) {\n                    const hasMoreSteps = bubbleSortStep();\n                    if (!hasMoreSteps) {\n                        stepBtn.disabled = true;\n                    }\n                }\n            });\n            \n            speedSlider.addEventListener('input', () => {\n                // Map slider value to delay (reverse scale: low slider = high speed)\n                speed = 220 - speedSlider.value;\n                updateSpeedLabel();\n            });\n        }\n        \n        // Update speed label based on slider value\n        function updateSpeedLabel() {\n            const sliderValue = speedSlider.value;\n            if (sliderValue < 33) {\n                speedValue.textContent = \"Fast\";\n            } else if (sliderValue < 66) {\n                speedValue.textContent = \"Medium\";\n            } else {\n                speedValue.textContent = \"Slow\";\n            }\n        }\n        \n        // Initialize when page loads\n        window.onload = init;\n    </script>\n</body>\n</html>\n```\n\nThis visualization demonstrates the Bubble Sort algorithm with:\n\n1. **Interactive Visual Representation**:\n   - Color-coded bars showing comparison states (red) and sorted elements (green)\n   - Real-time value labels on each bar\n   - Dynamic height representation of numeric values\n\n2. **Controls**:\n   - Start/Pause sorting\n   - Reset with new random array\n   - Step-through mode for manual progression\n   - Adjustable speed control\n\n3. **Algorithm Information**:\n   - Explanation of Bubble Sort\n   - Step-by-step algorithm breakdown\n   - Time complexity information\n\n4. **Performance Tracking**:\n   - Real-time counters for comparisons, swaps, and passes\n   - Visual feedback during sorting process\n\nThe visualization clearly shows how bubble sort works by repeatedly comparing adjacent elements and \"bubbling up\" the largest values to the end of the array with each pass. The animation speed can be adjusted to observe the process at different rates or paused to examine each step in detail.",
      "reasoning_content": "\nWe are going to create an interactive demonstration of the Bubble Sort algorithm.\n The HTML file will include:\n   - A title and description of Bubble Sort.\n   - A canvas to visualize the sorting process.\n   - Buttons to start sorting, reset the array, and adjust the speed.\n\n Steps for the visualization:\n   1. Generate an array of random numbers.\n   2. Draw the array as bars on the canvas.\n   3. Implement Bubble Sort with step-by-step visualization:\n        We'll use a function that does one step of the bubble sort and then schedules the next step with a delay.\n   4. We'll use colors to indicate the elements being compared and the sorted state.\n\n The Bubble Sort algorithm:\n   It repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.\n   The pass through the list is repeated until the list is sorted.\n\n Implementation details for visualization:\n   We'll have:\n     - `i` and `j` as indices for the current comparison.\n     - We'll traverse the array, and for each pair (j, j+1) we compare and swap if needed.\n     - After each pass, the largest element will be at the end.\n\n We'll use:\n   - `arr`: the array of numbers to sort.\n   - `i`: the outer loop index (from arr.length-1 down to 0)\n   - `j`: the inner loop index (from 0 to i-1)\n\n We break the algorithm into steps so that we can draw after each comparison.\n\n Steps in the algorithm function (using setTimeout to allow visualization):\n\n   function step() {\n      if (i < 0) {\n          // Sorting complete\n          return;\n      }\n      if (j <= i-1) {\n          // Compare arr[j] and arr[j+1]\n          if (arr[j] > arr[j+1]) {\n              swap(arr, j, j+1);\n          }\n          j++;\n      } else {\n          i--;\n          j = 0;\n      }\n\n      draw the array, highlighting the current j and j+1, and also the already sorted part (from i+1 to end).\n\n      Then schedule the next step with a delay.\n   }\n\n Buttons:\n   - \"Start Sorting\": Starts the sorting process.\n   - \"Reset Array\": Generates a new random array and resets the sorting state.\n   - Speed control: A slider to adjust the delay between steps.\n\n We'll also include a brief explanation of Bubble Sort.\n\n Let's code accordingly.\n"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Bubble Sort"
      }
    ],
    "evaluation": {
      "score": 4,
      "notes": "还算美观，但是对于只返回html这个要求没有完全做到。交互性还行，能调速"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "fdbc55f0-9905-11f0-a5fb-31bccccea7a6",
    "model": "deepseek-r1",
    "timestamp": "2025-09-24T05:19:05.935Z",
    "question": "Linked List",
    "answer": {
      "role": "assistant",
      "content": "\n# Linked List Visualization\n\nI'll create an interactive visualization of a linked list with both a graphical representation and code explanation.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Linked List Visualization</title>\n    <style>\n        * {\n            box-sizing: border-box;\n            margin: 0;\n            padding: 0;\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n        }\n        \n        body {\n            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);\n            color: white;\n            min-height: 100vh;\n            padding: 20px;\n        }\n        \n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n        }\n        \n        header {\n            text-align: center;\n            margin-bottom: 30px;\n            animation: fadeIn 1s;\n        }\n        \n        h1 {\n            font-size: 3.5rem;\n            margin-bottom: 10px;\n            text-shadow: 0 2px 10px rgba(0,0,0,0.3);\n        }\n        \n        .subtitle {\n            font-size: 1.3rem;\n            opacity: 0.9;\n            max-width: 800px;\n            margin: 0 auto;\n            line-height: 1.6;\n        }\n        \n        .content {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 30px;\n            margin-bottom: 40px;\n        }\n        \n        .visualization-section {\n            flex: 1;\n            min-width: 300px;\n            background: rgba(255, 255, 255, 0.1);\n            backdrop-filter: blur(10px);\n            border-radius: 20px;\n            padding: 25px;\n            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);\n            border: 1px solid rgba(255, 255, 255, 0.18);\n        }\n        \n        .section-title {\n            font-size: 1.8rem;\n            margin-bottom: 20px;\n            color: #ffcc00;\n            text-align: center;\n            padding-bottom: 10px;\n            border-bottom: 2px solid rgba(255, 255, 255, 0.2);\n        }\n        \n        #linked-list-container {\n            height: 300px;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            position: relative;\n            overflow: hidden;\n            margin: 30px 0;\n        }\n        \n        .node {\n            width: 70px;\n            height: 70px;\n            border-radius: 50%;\n            background: linear-gradient(135deg, #3494E6, #EC6EAD);\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            font-weight: bold;\n            font-size: 1.4rem;\n            position: relative;\n            margin: 0 40px;\n            box-shadow: 0 4px 15px rgba(0,0,0,0.3);\n            transition: all 0.3s ease;\n        }\n        \n        .node-value {\n            color: white;\n            text-shadow: 0 1px 2px rgba(0,0,0,0.5);\n        }\n        \n        .pointer {\n            position: absolute;\n            width: 50px;\n            height: 4px;\n            background: #ffcc00;\n            top: 50%;\n            transform: translateY(-50%);\n            right: -45px;\n            animation: pulse 1.5s infinite;\n        }\n        \n        .pointer::after {\n            content: '';\n            position: absolute;\n            width: 12px;\n            height: 12px;\n            border-top: 4px solid #ffcc00;\n            border-right: 4px solid #ffcc00;\n            transform: rotate(45deg);\n            right: 0;\n            top: -4px;\n        }\n        \n        .null-node {\n            width: 60px;\n            height: 60px;\n            border-radius: 50%;\n            background: rgba(255, 255, 255, 0.15);\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            font-weight: bold;\n            color: #bbb;\n            font-style: italic;\n            margin-left: 40px;\n        }\n        \n        .controls {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 15px;\n            justify-content: center;\n            margin-top: 20px;\n        }\n        \n        input, button {\n            padding: 12px 20px;\n            border-radius: 50px;\n            border: none;\n            font-size: 1rem;\n            transition: all 0.3s ease;\n        }\n        \n        input {\n            background: rgba(255, 255, 255, 0.12);\n            color: white;\n            width: 180px;\n            border: 1px solid rgba(255, 255, 255, 0.2);\n        }\n        \n        input::placeholder {\n            color: rgba(255, 255, 255, 0.6);\n        }\n        \n        button {\n            background: linear-gradient(to right, #ff8c00, #ffcc00);\n            color: #1a1a2e;\n            font-weight: bold;\n            cursor: pointer;\n            box-shadow: 0 4px 10px rgba(0,0,0,0.2);\n        }\n        \n        button:hover {\n            transform: translateY(-3px);\n            box-shadow: 0 6px 15px rgba(0,0,0,0.3);\n        }\n        \n        .explanation {\n            flex: 1;\n            min-width: 300px;\n            background: rgba(0, 0, 0, 0.3);\n            border-radius: 20px;\n            padding: 25px;\n        }\n        \n        .concept {\n            margin-bottom: 25px;\n            padding-bottom: 15px;\n            border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n        }\n        \n        .concept h3 {\n            color: #ffcc00;\n            margin-bottom: 12px;\n            font-size: 1.4rem;\n        }\n        \n        .concept p {\n            line-height: 1.7;\n            font-size: 1.1rem;\n            opacity: 0.9;\n        }\n        \n        .code-section {\n            background: rgba(0, 0, 0, 0.5);\n            padding: 25px;\n            border-radius: 15px;\n            margin-top: 20px;\n            overflow-x: auto;\n        }\n        \n        .code-section h3 {\n            color: #ffcc00;\n            margin-bottom: 15px;\n            text-align: center;\n        }\n        \n        pre {\n            background: #1e1e2e;\n            padding: 20px;\n            border-radius: 10px;\n            overflow-x: auto;\n            font-size: 0.95rem;\n            line-height: 1.5;\n            tab-size: 4;\n        }\n        \n        .comment { color: #6A9955; }\n        .keyword { color: #569CD6; }\n        .function { color: #DCDCAA; }\n        .operator { color: #D4D4D4; }\n        .string { color: #CE9178; }\n        .number { color: #B5CEA8; }\n        \n        .operations {\n            display: flex;\n            gap: 20px;\n            flex-wrap: wrap;\n            justify-content: center;\n            margin-top: 25px;\n        }\n        \n        .op-card {\n            background: rgba(255, 255, 255, 0.1);\n            border-radius: 15px;\n            padding: 20px;\n            flex: 1;\n            min-width: 200px;\n            text-align: center;\n            transition: transform 0.3s ease;\n        }\n        \n        .op-card:hover {\n            transform: translateY(-5px);\n            background: rgba(255, 255, 255, 0.15);\n        }\n        \n        .op-card h4 {\n            color: #ffcc00;\n            margin-bottom: 10px;\n            font-size: 1.3rem;\n        }\n        \n        .op-card p {\n            font-size: 0.95rem;\n            opacity: 0.85;\n        }\n        \n        footer {\n            text-align: center;\n            margin-top: 40px;\n            padding-top: 20px;\n            border-top: 1px solid rgba(255, 255, 255, 0.1);\n            font-size: 1rem;\n            opacity: 0.8;\n        }\n        \n        @keyframes fadeIn {\n            from { opacity: 0; transform: translateY(-20px); }\n            to { opacity: 1; transform: translateY(0); }\n        }\n        \n        @keyframes pulse {\n            0% { opacity: 0.6; }\n            50% { opacity: 1; }\n            100% { opacity: 0.6; }\n        }\n        \n        @keyframes highlight {\n            0% { background: linear-gradient(135deg, #3494E6, #EC6EAD); }\n            50% { background: linear-gradient(135deg, #ffcc00, #ff6600); }\n            100% { background: linear-gradient(135deg, #3494E6, #EC6EAD); }\n        }\n        \n        .node.highlight {\n            animation: highlight 1.5s ease;\n        }\n        \n        @media (max-width: 768px) {\n            .content {\n                flex-direction: column;\n            }\n            \n            h1 {\n                font-size: 2.5rem;\n            }\n            \n            .subtitle {\n                font-size: 1.1rem;\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>Linked List Visualization</h1>\n            <p class=\"subtitle\">A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node in the sequence. Unlike arrays, linked lists allow efficient insertion and removal of elements without reorganization of the entire structure.</p>\n        </header>\n        \n        <div class=\"content\">\n            <div class=\"visualization-section\">\n                <h2 class=\"section-title\">Interactive Linked List</h2>\n                <div id=\"linked-list-container\">\n                    <!-- Nodes will be dynamically added here -->\n                </div>\n                \n                <div class=\"controls\">\n                    <input type=\"number\" id=\"nodeValue\" placeholder=\"Enter node value\" min=\"1\" max=\"99\">\n                    <button id=\"addHeadBtn\">Add to Head</button>\n                    <button id=\"addTailBtn\">Add to Tail</button>\n                    <button id=\"removeHeadBtn\">Remove Head</button>\n                    <button id=\"removeTailBtn\">Remove Tail</button>\n                </div>\n            </div>\n            \n            <div class=\"explanation\">\n                <h2 class=\"section-title\">Linked List Concepts</h2>\n                \n                <div class=\"concept\">\n                    <h3>What is a Linked List?</h3>\n                    <p>A linked list is a linear data structure consisting of a sequence of elements called nodes. Each node contains two fields: data and a reference (link) to the next node in the sequence. The last node has a reference to null, indicating the end of the list.</p>\n                </div>\n                \n                <div class=\"concept\">\n                    <h3>Key Characteristics</h3>\n                    <p>• Dynamic Size: Unlike arrays, linked lists can grow and shrink during runtime.<br>\n                       • Efficient Insertions/Deletions: Adding or removing elements at the head or tail is O(1).<br>\n                       • Memory Efficiency: Memory is allocated as needed rather than in advance.<br>\n                       • Sequential Access: Elements are accessed sequentially, starting from the head node.</p>\n                </div>\n                \n                <div class=\"concept\">\n                    <h3>Types of Linked Lists</h3>\n                    <p>• Singly Linked List: Each node points only to the next node.<br>\n                       • Doubly Linked List: Each node points to both the next and previous nodes.<br>\n                       • Circular Linked List: The last node points back to the first node.</p>\n                </div>\n                \n                <div class=\"code-section\">\n                    <h3>Linked List Implementation (JavaScript)</h3>\n                    <pre><code><span class=\"comment\">// Node class represents each element in the list</span>\n<span class=\"keyword\">class</span> Node {\n    <span class=\"keyword\">constructor</span>(<span class=\"function\">value</span>) {\n        <span class=\"keyword\">this</span>.<span class=\"function\">value</span> = value;\n        <span class=\"keyword\">this</span>.<span class=\"function\">next</span> = null;\n    }\n}\n\n<span class=\"comment\">// LinkedList class manages the nodes</span>\n<span class=\"keyword\">class</span> LinkedList {\n    <span class=\"keyword\">constructor</span>() {\n        <span class=\"keyword\">this</span>.<span class=\"function\">head</span> = null;\n        <span class=\"keyword\">this</span>.<span class=\"function\">tail</span> = null;\n        <span class=\"keyword\">this</span>.<span class=\"function\">size</span> = 0;\n    }\n    \n    <span class=\"comment\">// Add node to the beginning of the list</span>\n    <span class=\"function\">addToHead</span>(<span class=\"function\">value</span>) {\n        <span class=\"keyword\">const</span> newNode = <span class=\"keyword\">new</span> Node(value);\n        <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.<span class=\"function\">head</span>) {\n            <span class=\"keyword\">this</span>.<span class=\"function\">head</span> = newNode;\n            <span class=\"keyword\">this</span>.<span class=\"function\">tail</span> = newNode;\n        } <span class=\"keyword\">else</span> {\n            newNode.<span class=\"function\">next</span> = <span class=\"keyword\">this</span>.<span class=\"function\">head</span>;\n            <span class=\"keyword\">this</span>.<span class=\"function\">head</span> = newNode;\n        }\n        <span class=\"keyword\">this</span>.<span class=\"function\">size</span>++;\n    }\n    \n    <span class=\"comment\">// Add node to the end of the list</span>\n    <span class=\"function\">addToTail</span>(<span class=\"function\">value</span>) {\n        <span class=\"keyword\">const</span> newNode = <span class=\"keyword\">new</span> Node(value);\n        <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.<span class=\"function\">head</span>) {\n            <span class=\"keyword\">this</span>.<span class=\"function\">head</span> = newNode;\n            <span class=\"keyword\">this</span>.<span class=\"function\">tail</span> = newNode;\n        } <span class=\"keyword\">else</span> {\n            <span class=\"keyword\">this</span>.<span class=\"function\">tail</span>.<span class=\"function\">next</span> = newNode;\n            <span class=\"keyword\">this</span>.<span class=\"function\">tail</span> = newNode;\n        }\n        <span class=\"keyword\">this</span>.<span class=\"function\">size</span>++;\n    }\n    \n    <span class=\"comment\">// Remove the first node from the list</span>\n    <span class=\"function\">removeHead</span>() {\n        <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.<span class=\"function\">head</span>) <span class=\"keyword\">return</span> null;\n        <span class=\"keyword\">const</span> removedNode = <span class=\"keyword\">this</span>.<span class=\"function\">head</span>;\n        <span class=\"keyword\">this</span>.<span class=\"function\">head</span> = <span class=\"keyword\">this</span>.<span class=\"function\">head</span>.<span class=\"function\">next</span>;\n        <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.<span class=\"function\">head</span>) {\n            <span class=\"keyword\">this</span>.<span class=\"function\">tail</span> = null;\n        }\n        <span class=\"keyword\">this</span>.<span class=\"function\">size</span>--;\n        <span class=\"keyword\">return</span> removedNode.<span class=\"function\">value</span>;\n    }\n    \n    <span class=\"comment\">// Remove the last node from the list</span>\n    <span class=\"function\">removeTail</span>() {\n        <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.<span class=\"function\">head</span>) <span class=\"keyword\">return</span> null;\n        \n        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.<span class=\"function\">head</span> === <span class=\"keyword\">this</span>.<span class=\"function\">tail</span>) {\n            <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.<span class=\"function\">head</span>.<span class=\"function\">value</span>;\n            <span class=\"keyword\">this</span>.<span class=\"function\">head</span> = null;\n            <span class=\"keyword\">this</span>.<span class=\"function\">tail</span> = null;\n            <span class=\"keyword\">this</span>.<span class=\"function\">size</span> = 0;\n            <span class=\"keyword\">return</span> value;\n        }\n        \n        <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.<span class=\"function\">head</span>;\n        <span class=\"keyword\">while</span> (current",
      "reasoning_content": "\nWe are going to create a simple visualization of a linked list.\n The HTML file will include:\n   - A canvas to draw the linked list.\n   - Buttons to add nodes and remove nodes.\n   - Input for the value of the node to be added.\n   - JavaScript to handle the linked list operations and drawing.\n\n We'll create a LinkedList class with methods to append and remove nodes.\n Each node will have a value and a next pointer.\n\n The drawing will be done on a canvas. We'll draw nodes as circles with the value inside and an arrow to the next node.\n\n Steps:\n   1. Set up the HTML structure with a canvas, an input for node value, and buttons to add and remove.\n   2. Write CSS to style the elements (if necessary, minimal for this example).\n   3. Write JavaScript:\n        a. Define Node and LinkedList classes.\n        b. Implement methods: append, remove (by value), and a method to draw the linked list.\n        c. Handle button click events to add/remove nodes and update the drawing.\n\n Note: We are going to remove by value. If multiple nodes have the same value, we remove the first occurrence.\n\n Since the requirement is a single HTML file, we'll embed everything.\n"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Linked List"
      }
    ],
    "evaluation": {
      "score": 2,
      "notes": "虽然很炫，但是功能不work，不及格"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "62c42d50-9907-11f0-a3ca-03103b96a9b8",
    "model": "deepseek-r1",
    "timestamp": "2025-09-24T05:29:04.933Z",
    "question": "K-means clustering",
    "answer": {
      "role": "assistant",
      "content": "\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>K-means Clustering Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .controls {\n            margin-bottom: 20px;\n            display: flex;\n            gap: 15px;\n            flex-wrap: wrap;\n            justify-content: center;\n        }\n        .control-group {\n            display: flex;\n            flex-direction: column;\n            gap: 5px;\n        }\n        button {\n            padding: 8px 15px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        canvas {\n            border: 1px solid #ddd;\n            background-color: white;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        .info {\n            margin-top: 15px;\n            font-size: 14px;\n            color: #666;\n        }\n    </style>\n</head>\n<body>\n    <h1>K-means Clustering Visualization</h1>\n    <div class=\"controls\">\n        <div class=\"control-group\">\n            <label for=\"kValue\">Number of Clusters (k):</label>\n            <input type=\"number\" id=\"kValue\" min=\"1\" max=\"10\" value=\"3\">\n        </div>\n        <div class=\"control-group\">\n            <label for=\"numPoints\">Number of Points:</label>\n            <input type=\"number\" id=\"numPoints\" min=\"10\" max=\"500\" value=\"100\">\n        </div>\n        <div class=\"control-group\">\n            <button id=\"resetBtn\">Reset</button>\n        </div>\n        <div class=\"control-group\">\n            <button id=\"stepBtn\">Step</button>\n        </div>\n        <div class=\"control-group\">\n            <button id=\"runBtn\">Run</button>\n        </div>\n    </div>\n    <canvas id=\"canvas\" width=\"600\" height=\"400\"></canvas>\n    <div class=\"info\">\n        Iteration: <span id=\"iteration\">0</span> | Status: <span id=\"status\">Initialized</span>\n    </div>\n\n    <script>\n        // Canvas and context\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        \n        // Input elements\n        const kInput = document.getElementById('kValue');\n        const numPointsInput = document.getElementById('numPoints');\n        const resetBtn = document.getElementById('resetBtn');\n        const stepBtn = document.getElementById('stepBtn');\n        const runBtn = document.getElementById('runBtn');\n        const iterationDisplay = document.getElementById('iteration');\n        const statusDisplay = document.getElementById('status');\n        \n        // Data storage\n        let points = [];\n        let centroids = [];\n        let assignments = [];\n        let currentIteration = 0;\n        let maxIterations = 20;\n        let state = 'need_assign'; // 'need_assign' or 'need_update'\n        let animationId = null;\n        const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', \n                        '#FF9F40', '#8AC926', '#1982C4', '#6A4C93', '#F15BB5'];\n        \n        // Initialize the visualization\n        function init() {\n            points = [];\n            centroids = [];\n            assignments = [];\n            currentIteration = 0;\n            state = 'need_assign';\n            updateIterationDisplay();\n            statusDisplay.textContent = 'Initialized';\n            \n            const k = parseInt(kInput.value);\n            const numPoints = parseInt(numPointsInput.value);\n            \n            // Generate random data points\n            for (let i = 0; i < numPoints; i++) {\n                points.push({\n                    x: Math.random() * (canvas.width - 30) + 15,\n                    y: Math.random() * (canvas.height - 30) + 15\n                });\n            }\n            \n            // Initialize centroids randomly within the canvas\n            for (let i = 0; i < k; i++) {\n                centroids.push({\n                    x: Math.random() * (canvas.width - 40) + 20,\n                    y: Math.random() * (canvas.height - 40) + 20,\n                    color: colors[i % colors.length]\n                });\n            }\n            \n            draw();\n        }\n        \n        // Calculate Euclidean distance\n        function distance(p1, p2) {\n            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n        }\n        \n        // Assign points to nearest centroids\n        function assignPoints() {\n            assignments = [];\n            for (let i = 0; i < points.length; i++) {\n                let minDist = Infinity;\n                let bestCentroid = 0;\n                \n                for (let j = 0; j < centroids.length; j++) {\n                    const dist = distance(points[i], centroids[j]);\n                    if (dist < minDist) {\n                        minDist = dist;\n                        bestCentroid = j;\n                    }\n                }\n                assignments[i] = bestCentroid;\n            }\n            state = 'need_update';\n            statusDisplay.textContent = 'Points assigned to centroids';\n        }\n        \n        // Update centroids to be the mean of their assigned points\n        function updateCentroids() {\n            let moved = false;\n            \n            for (let j = 0; j < centroids.length; j++) {\n                let sumX = 0;\n                let sumY = 0;\n                let count = 0;\n                \n                for (let i = 0; i < points.length; i++) {\n                    if (assignments[i] === j) {\n                        sumX += points[i].x;\n                        sumY += points[i].y;\n                        count++;\n                    }\n                }\n                \n                if (count > 0) {\n                    const newX = sumX / count;\n                    const newY = sumY / count;\n                    \n                    // Check if centroid moved significantly\n                    if (distance(centroids[j], {x: newX, y: newY}) > 0.5) {\n                        moved = true;\n                    }\n                    \n                    centroids[j].x = newX;\n                    centroids[j].y = newY;\n                }\n            }\n            \n            currentIteration++;\n            updateIterationDisplay();\n            \n            if (!moved || currentIteration >= maxIterations) {\n                statusDisplay.textContent = `Converged after ${currentIteration} iterations`;\n                state = 'done';\n            } else {\n                state = 'need_assign';\n                statusDisplay.textContent = 'Centroids updated';\n            }\n        }\n        \n        // Perform one step of the algorithm\n        function step() {\n            if (state === 'need_assign') {\n                assignPoints();\n            } else if (state === 'need_update') {\n                updateCentroids();\n            }\n            draw();\n        }\n        \n        // Animation function for run button\n        function runAnimation() {\n            if (state === 'done' || currentIteration >= maxIterations) {\n                stopAnimation();\n                return;\n            }\n            \n            step();\n            animationId = setTimeout(runAnimation, 800);\n        }\n        \n        // Start animation\n        function startAnimation() {\n            if (!animationId) {\n                runBtn.textContent = 'Stop';\n                runAnimation();\n            }\n        }\n        \n        // Stop animation\n        function stopAnimation() {\n            if (animationId) {\n                clearTimeout(animationId);\n                animationId = null;\n                runBtn.textContent = 'Run';\n            }\n        }\n        \n        // Draw points and centroids\n        function draw() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw points\n            for (let i = 0; i < points.length; i++) {\n                const centroidIdx = assignments[i];\n                ctx.fillStyle = centroids[centroidIdx]?.color || '#999';\n                ctx.beginPath();\n                ctx.arc(points[i].x, points[i].y, 4, 0, Math.PI * 2);\n                ctx.fill();\n            }\n            \n            // Draw centroids\n            for (let j = 0; j < centroids.length; j++) {\n                ctx.fillStyle = centroids[j].color;\n                ctx.beginPath();\n                ctx.arc(centroids[j].x, centroids[j].y, 12, 0, Math.PI * 2);\n                ctx.fill();\n                \n                // Draw centroid border\n                ctx.strokeStyle = 'black';\n                ctx.lineWidth = 2;\n                ctx.beginPath();\n                ctx.arc(centroids[j].x, centroids[j].y, 12, 0, Math.PI * 2);\n                ctx.stroke();\n                \n                // Draw cluster number\n                ctx.fillStyle = 'white';\n                ctx.font = 'bold 12px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText(j.toString(), centroids[j].x, centroids[j].y);\n            }\n        }\n        \n        // Update iteration display\n        function updateIterationDisplay() {\n            iterationDisplay.textContent = currentIteration;\n        }\n        \n        // Event listeners\n        resetBtn.addEventListener('click', () => {\n            stopAnimation();\n            init();\n        });\n        \n        stepBtn.addEventListener('click', () => {\n            if (state !== 'done') {\n                step();\n            }\n        });\n        \n        runBtn.addEventListener('click', () => {\n            if (animationId) {\n                stopAnimation();\n            } else if (state !== 'done') {\n                startAnimation();\n            }\n        });\n        \n        // Initialize on load\n        init();\n    </script>\n</body>\n</html>\n```",
      "reasoning_content": "\nWe are going to create an interactive visualization of K-means clustering.\n The user will be able to:\n   - See randomly generated data points on a canvas.\n   - Adjust the number of clusters (k) and the number of data points.\n   - Step through the algorithm or run it automatically.\n\n The visualization will show:\n   - Data points (with colors representing their current cluster assignment).\n   - Cluster centroids (as larger circles).\n   - The movement of centroids between iterations.\n\n Steps of the algorithm:\n   1. Choose initial centroids (randomly from data points or random positions).\n   2. Assign each data point to the nearest centroid.\n   3. Recompute centroids as the mean of the points assigned to it.\n   4. Repeat steps 2 and 3 until convergence (or max iterations).\n\n Implementation plan:\n   - We'll use an HTML canvas for drawing.\n   - Inputs for k, number of points, and buttons to control the algorithm.\n   - We'll use random data points in the canvas area.\n\n Note: We'll use Euclidean distance.\n\n Let's structure the HTML with:\n   - A canvas element for drawing.\n   - Inputs: \n        <input type=\"number\" id=\"kValue\" min=\"1\" value=\"3\"> for k\n        <input type=\"number\" id=\"numPoints\" min=\"10\" value=\"100\"> for number of points\n   - Buttons: \n        <button id=\"reset\">Reset</button> to generate new points\n        <button id=\"step\">Step</button> to perform one step (either assign or update, we break into two steps for clarity in visualization)\n        <button id=\"run\">Run</button> to run until convergence (or max iterations)\n\n However, note that the standard k-means iteration is two steps: assignment and update. We can break it into two steps for step-by-step, but for the run button we do full iterations.\n\n Alternatively, we can have two modes: \n   - One step that does both assignment and update (one iteration) -> simpler for stepping.\n\n We'll do:\n\n   let maxIterations = 100;\n   let currentIteration = 0;\n\n   Steps:\n\n   reset():\n      - Generate random points (with x, y in canvas dimensions).\n      - Initialize centroids: choose k distinct random points from the data (or random positions? Let's use random positions in the canvas to avoid degenerate cases).\n      - Set currentIteration = 0.\n\n   step():\n      - If currentIteration==0: we haven't assigned? Then do initial assignment to centroids.\n      - Otherwise: \n          Step 1: Update centroids (using the current assignments) -> then reassign points? \n          Actually, standard iteration: assign then update. But we start with centroids and then assign.\n\n      We break the iteration into two phases for visualization? Or we show the assignment and then update in one step? \n\n   For simplicity in stepping, one step will be one full iteration: assignment and then update.\n\n   However, we want to show the assignment before updating the centroids? Then maybe we break into two steps.\n\n   Let's change: we'll have two steps per iteration.\n\n   But we want to show the state after assignment (with old centroids and new assignments) and then after updating centroids.\n\n   Alternatively, we can do:\n\n     State 0: initial centroids placed (randomly). Then we assign points -> state 1: assigned to centroids (with old centroids). Then we update centroids -> state 2: updated centroids (and then we reassign? but that is the next iteration).\n\n   We can let one step be:\n\n     If we are at state after update (or initial state), then we assign (and then stop). Then the next step we update.\n\n   But that complicates the stepping.\n\n   Alternatively, we can do one iteration (assign and then update) as one step, and after the update we redraw. The assignments during the iteration are based on the centroids at the beginning of the iteration.\n\n   We'll do:\n\n     Step function:\n\n        Assign each point to closest centroid (using current centroids).\n        Then update centroids to the mean of the points assigned.\n\n        Then redraw.\n\n   We can also show intermediate state (assignment only) by having two steps? We'll skip that for simplicity.\n\n   How about we let the user see the assignment and then the update? We'll break the step into two: first assignment (and then wait for next step to update) and then update and then reassign? \n\n   Actually, we can have a state machine:\n\n     states: \n        - Not started: we have centroids but no assignments? Or we assign at the beginning? \n        - After assignment (so we have clusters but centroids haven't moved)\n        - After update (new centroids, then we can assign again)\n\n   For simplicity, we'll do:\n\n     Step 1: Assign all points to the nearest centroid (if we haven't done initial assignment, or after centroids update).\n        -> Then we are in \"assigned\" state.\n     Step 2: Update centroids to the mean of their points.\n        -> Then we are in \"updated\" state.\n\n   Then we can do:\n\n        reset: \n          generate points and centroids (random centroids in the canvas).\n          state: 'unassigned'\n\n        step:\n          if state is 'unassigned' or 'updated':\n             assignPoints(); -> state becomes 'assigned'\n          else if state is 'assigned':\n             updateCentroids(); -> state becomes 'updated'\n             currentIteration++\n\n        But then the run button would run until convergence? \n\n   However, note that convergence is when the centroids don't change (or assignments don't change). \n\n   We can also do one iteration (assign and update) as one step? Then state alternates between updated for the next iteration and then we do the next assign and update.\n\n   Let me think: we start:\n\n        Initialization: choose random centroids -> state: centroids set, no assignment? Or we do initial assignment? \n\n        We can do initial assignment as part of reset? Then after reset we show the initial assignment? \n\n        Then step would be: update centroids and then reassign? \n\n        Actually, standard:\n\n          Step 0: initialize centroids (randomly) -> then assign points (this is iteration 0 assignment).\n          Step 1: update centroids (using the assignment from step0) -> iteration 0 update.\n          Step 2: assign points again (iteration1 assignment) -> then update centroids again (iteration1 update) ...\n\n        So we can have after reset: we have centroids and we have an initial assignment (which is the first assignment). Then step does update and then assign? \n\n        But note: after update, we break the current assignment? So we should reassign? \n\n        Alternatively, we can structure:\n\n          reset():\n             generate points\n             initialize centroids (random positions in canvas)\n             assignPoints();   // initial assignment\n             state = 'assigned'\n\n          step():\n             if state == 'assigned':\n                 updateCentroids();   // now we have new centroids\n                 state = 'updated'\n                 currentIteration++\n                 // and then we can auto-assign? or wait for next step? \n                 // But the algorithm requires reassigning after update.\n                 // So we do: after update, we immediately assign? Then it becomes one iteration.\n\n          But then we lose the intermediate state.\n\n        We want to show the updated centroids without reassignment? Then we break.\n\n        Let me change: we let step do:\n\n          if state is 'assigned':\n             updateCentroids()\n             state = 'updated'\n             currentIteration++\n\n          else if state is 'updated':\n             assignPoints()\n             state = 'assigned'\n\n        Then the first step after reset (state='assigned') does update -> state='updated'. Then next step (state='updated') does assign -> state='assigned'. \n\n        That way, one iteration (update and then assign) is done in two steps? \n\n        But note: the initial reset does an assignment? So we start with assignments. The first update uses that assignment. Then the next step updates centroids (we see the centroids move) and then the step after that reassigns points? \n\n        Actually, the initial assignment is done at reset. Then:\n\n          Step 1: update centroids (based on initial assignment) -> state updated (centroids moved, but points still assigned to old centroids? or should we reassign immediately? we don't because we break for visualization)\n\n        Then we show: the centroids have moved but the points are still colored by the old assignment? That might be confusing.\n\n        Alternatively, we do:\n\n          reset:\n            generate points\n            centroids = initialize randomly (but not assigned to any point? so we don't have assignments yet)\n            state = 'unassigned'\n\n          Then step:\n\n            if state is 'unassigned' or 'updated':\n               assignPoints()   // using current centroids -> state='assigned'\n            else if state is 'assigned':\n               updateCentroids()   // state='updated'\n\n          Then the first step after reset (state='unassigned') does assign -> state='assigned'. Then step does update -> state='updated'. Then step does assign (again) -> state='assigned'. Then step does update -> state='updated'. \n\n          This way, we see:\n\n            Step0: assign -> we see the initial assignment (with initial centroids)\n            Step1: update -> we see the centroids move to the mean (and points are still colored by old assignment? but that's the previous assignment). Then we do step2: assign again (which uses the new centroids) and we see the points reassigned.\n\n          That matches: iteration0: assign and then update. Then iteration1: assign and then update.\n\n        But note: the update step uses the assignments from the previous assign step.\n\n        So we are storing the assignments until we assign again.\n\n        This is acceptable.\n\n   We'll design:\n\n     Data:\n        points: array of { x, y }\n        centroids: array of { x, y }\n        assignments: array of integers (index of centroid for each point) or null if unassigned.\n\n        state: string, one of ['unassigned', 'assigned', 'updated']\n\n     reset():\n        generate points (random in canvas)\n        centroids = generate k random points in canvas (or we can pick k distinct points? random positions in canvas is fine).\n        assignments = null (or empty array) -> state='unassigned'\n\n     step():\n        if state is 'unassigned' or 'updated':\n           assignPoints();\n           state = 'assigned'\n        else if state is 'assigned':\n           updateCentroids();\n           state = 'updated'\n           currentIteration++\n\n     We also have a run button that will keep stepping until convergence (or max iterations) but we break the steps into assign and update? We can run until state is back to 'assigned' after a full iteration? \n\n     Actually, convergence: we stop when the centroids stop moving (or assignments don't change). We can check in the assign step if the assignments changed? But note: we break the iteration into two steps.\n\n     Alternatively, we can run until a maximum number of iterations (say 10) and then stop.\n\n   Let's keep it simple for this demo: we'll set maxIterations to 10 and stop when currentIteration reaches maxIterations.\n\n   However, we don't want to run indefinitely. We can check for convergence by storing the old centroids and see if they moved? But we are breaking into steps.\n\n   How about we run until the centroids don't change (or change less than a threshold) in the update step? \n\n   We can do in updateCentroids():\n\n        for each centroid, we compute the new position (mean of points assigned to it).\n        if the movement is less than a threshold (e.g., 0.5) for all centroids, then we stop? \n\n   But we break the steps: update step is separate.\n\n   We'll add a flag `converged` that is set in updateCentroids if the centroids didn't move much.\n\n   Then run button would run until converged or maxIterations.\n\n   However, stepping manually we don't check convergence? We can check at update step and then stop? Then the step button would not step further?\n\n   Alternatively, we can let the step button work regardless and the user sees when it stops changing.\n\n   For simplicity, we'll just run maxIterations steps (for the run button) and then stop.\n\n   We'll set maxIterations to 20.\n\n   Steps:\n\n        reset: currentIteration = 0, state = 'unassigned'\n\n        step: \n          if state is 'unassigned' or 'updated': assignPoints -> state='assigned'\n          else if state is 'assigned': \n               updateCentroids -> state='updated'\n               currentIteration++\n\n        run: \n          while (currentIteration < maxIterations) and (state is not converged? we skip convergence check for now) we do step? \n          But step alternates? We can run until state becomes 'assigned' again? Actually, we want to run one full iteration at a time? \n\n        How about we run until we complete an iteration? meaning we start at state 'assigned' and then we do update and then assign? That is one iteration.\n\n        But our run button should run until we complete a full iteration? \n\n        Alternatively, we can change the step to complete one full iteration? \n\n        Let me restructure to one step per iteration? \n\n        We'll change to:\n\n          reset: \n            generate points\n            initialize centroids (random in canvas)\n            assignPoints()   // initial assignment\n            state = 'assigned'   // and currentIteration = 0\n\n          step:\n            if currentIteration >= maxIterations: return\n            updateCentroids()   // using current assignments\n            assignPoints()      // reassign points to new centroids\n            currentIteration++\n\n          Then we don't break the steps. The state is always after assignment? \n\n          Then we draw:\n\n            points with color of the centroid they are assigned to.\n            centroids as large circles.\n\n          And between steps, we update the centroids and then reassign? \n\n          So we lose the intermediate state of updated centroids without reassignment? \n\n          But the algorithm is usually presented as: update centroids and then reassign. And we want to show the new centroids and then the reassignment? \n\n          We can split the step into two:\n\n            stepPart = 0   // 0: update, 1: assign\n\n          But then stepping becomes two clicks per iteration.\n\n        Given the complexity and for simplicity of the demo, we'll do one step per iteration (both update and assign) and then we draw the state after the reassignment.\n\n        Then we don't show the updated centroids without reassignment? But note: after update, we reassign immediately so the user doesn't see the state where centroids have moved but points are still with old assignments.\n\n        However, we can do:\n\n          After update (before assign) we can show the centroids in their new positions and the points with old assignments? Then we reassign and redraw? Then we need two draws per iteration.\n\n        We decide to do one step per iteration (update and assign) and redraw after the assignment? Then we show:\n\n          At the beginning of iteration i: \n            centroids are at positions from the end of iteration i-1 (or initial for i=0)\n            points are assigned to these centroids (so that's the state we see at the start).\n\n          Then we step:\n\n            update centroids: compute new centroids as the mean of the current clusters.\n            assign points to the new centroids.\n\n          Then we draw: the new centroids and the points assigned to them.\n\n        So we don't see the intermediate state? \n\n        But we can remember the previous centroids and draw them as well? We don't want to overcomplicate.\n\n        Alternatively, we can do the following:\n\n          We break the iteration into two steps for visualization? We'll try:\n\n            reset: \n               generate points and centroids (initial centroids)\n               state = 'after_update'   // meaning centroids are set, but no assignment? \n               then we do assignment? \n\n            Let's define:\n\n               state: \n                 'need_assign' -> we need to assign points to centroids (which are the current centroids)\n                 'need_update' -> we need to update centroids based on the current assignments\n\n            reset:\n               points, centroids (random)\n               state = 'need_assign'\n\n            step():\n               if state == 'need_assign':\n                  assignPoints()\n                  state = 'need_update'\n               else if state == 'need_update':\n                  updateCentroids()\n                  state = 'need_assign'\n                  currentIteration++\n\n            Then the first step after reset: assign points -> state becomes 'need_update'. Then step: update centroids -> state becomes 'need_assign' and iteration++.\n\n            Then step: assign points (using the updated centroids) -> state becomes 'need_update'. Then step: update centroids -> state becomes 'need_assign', iteration++.\n\n            So two steps per iteration.\n\n        We'll implement with two steps per iteration so that we can show the intermediate state.\n\n        The visualization:\n\n          In state 'need_assign': we have centroids (from previous update) and we show the assignments from the last assignment? But if we just updated the centroids, then we haven't reassigned? So we show the assignments from before the update? That might be confusing.\n\n        Actually, when we update the centroids, we haven't reassigned the points. So the points are still assigned to the old centroids? But we updated the centroids positions? Then the points are assigned to the centroid index, but the centroid has moved? \n\n        We store the centroid positions at the time of assignment? No, we store the current centroid positions.\n\n        How we draw:\n\n          We draw the points with color based on the centroid index they are assigned to. We draw the centroid at its current position.\n\n        So if we update the centroid position, then we move the centroid on the canvas, but the points are still assigned to that centroid index (so same color), but the centroid has moved.\n\n        That means after updateCentroids, the points are still assigned to the same centroid index, but the centroid has moved to the center of the cluster? \n\n        That is exactly what we want to show: after update, the centroids move to the center, but the points are still assigned to the old centroids (by index) so same color. Then we reassign and the points might change color if the closest centroid changed.\n\n        That is a good visualization.\n\n        So:\n\n          reset -> state: need_assign\n          step1 (assign): assigns points to centroids (initial) -> we see points colored and centroids at initial positions. Then state becomes need_update.\n          step2 (update): we compute new centroids (mean of assigned points) -> centroids move to the center of the clusters. The points remain assigned to the same index (so same color) but now the centroid has moved. Then state becomes need_assign and iteration++.\n          step3 (assign): we reassign points to the new centroid positions -> some points may change color if they are now closer to a different centroid. Then state becomes need_update.\n\n        This is perfect.\n\n   Implementation:\n\n        Let:\n\n          points: Array<{x, y}>\n          centroids: Array<{x, y}>   // current positions of centroids\n          assignments: Array<number>  // for each point, the index of the centroid it is assigned to\n\n        reset():\n          points = generate random points (numPoints)\n          centroids = generate k random points (we can do within the canvas)\n          assignments = [];   // empty array\n          state = 'need_assign'\n          currentIteration = 0\n\n        assignPoints():\n          for each point:\n             compute distance to each centroid, find the closest centroid index.\n             assignments[index] = that centroid index.\n\n          Then we set state = 'need_update'\n\n        updateCentroids():\n          // First, we need to compute new centroid positions: for each cluster, the mean of the points assigned to it.\n          // But note: a centroid might have no points? then we leave it as is? or we move it to a random point? \n          // We'll leave it as is? or we can skip updating? \n\n          // We'll create an array for each centroid: { sumX, sumY, count }\n          let sums = new Array(centroids.length);\n          for (let i = 0; i < centroids.length; i++) {\n            sums[i] = { sumX: 0, sumY: 0, count: 0 };\n          }\n\n          points.forEach((point, idx) => {\n            let centIdx = assignments[idx];\n            if (centIdx !== undefined) { // should always be defined?\n              sums[centIdx].sumX += point.x;\n              sums[centIdx].sumY += point.y;\n              sums[centIdx].count++;\n            }\n          });\n\n          let moved = false;\n          for (let i = 0; i < centroids.length; i++) {\n            if (sums[i].count > 0) {\n              let newX = sums[i].sumX / sums[i].count;\n              let newY = sums[i].sumY / sums[i].count;\n              // Check if centroid has moved significantly? \n              if (Math.abs(centroids[i].x - newX) > 0.1 || Math.abs(centroids[i].y - newY) > 0.1) {\n                moved = true;\n              }\n              centroids[i].x = newX;\n              centroids[i].y = newY;\n            }\n            // else: leave centroid unchanged (no points assigned)\n          }\n\n          state = 'need_assign';\n          currentIteration++;\n\n          // Also, if we want to check convergence, we can set a flag if not moved? but we'll just use maxIterations.\n\n        We draw the scene at every step.\n\n   Now for the run button: we want to run until currentIteration >= maxIterations. But note: we break into two steps. We want to run until we complete a full cycle? \n\n        We can set:\n\n          run() {\n            while (currentIteration < maxIterations) {\n              if (state=='need_assign') {\n                 assignPoints();\n              }\n              else if (state=='need_update') {\n                 updateCentroids();\n              }\n            }\n          }\n\n        But that would block the UI. We should use setInterval or requestAnimationFrame to animate.\n\n   We'll do:\n\n        let runInterval = null;\n\n        run button click:\n\n          if (runInterval) {\n             clearInterval(runInterval);\n             runInterval = null;\n             this.textContent = 'Run';\n          } else {\n             runInterval = setInterval(() => {\n                 if (currentIteration >= maxIterations) {\n                    clearInterval(runInterval);\n                    runInterval = null;\n                    runButton.textContent = 'Run';\n                    return;\n                 }\n                 step();   // which does one part (assign or update) and then redraws\n                 // However, step() does one step (either assign or update) and increments iteration only in update.\n                 // So we call step until we hit maxIterations? But note: maxIterations is set to the number of update steps.\n\n                 // Actually, we have currentIteration updated only in updateCentroids.\n\n                 // But we want to run until we've done maxIterations updates.\n\n                 if (currentIteration >= maxIterations) {\n                    clearInterval(runInterval);\n                    runInterval = null;\n                    runButton.textContent = 'Run';\n                 }\n             }, 1000); // one step per second?\n          }\n\n        Alternatively, we can have a runStep() that does a full iteration? \n\n        Given we have two steps per iteration, we might want to do:\n\n          runStep() {\n            if (state == 'need_assign') {\n               assignPoints();\n               // then if we are still in need_update, we don't do more? we break.\n            } else {\n               updateCentroids();   // then we are in need_assign\n            }\n          }\n\n        But then one runStep does one part? \n\n        We decide to keep stepping in the interval by calling step() which does one part.\n\n        Then the interval will do one part per interval.\n\n        The stepping will be at a fixed rate.\n\n   We'll create:\n\n        step() function: \n           if (currentIteration >= maxIterations) return;\n           if (state == 'need_assign') {\n              assignPoints();\n           } else if (state == 'need_update') {\n              updateCentroids();\n           }\n           redraw();\n\n        And then the run button toggles an interval that calls step() every 500ms.\n\n   Also, we'll have a reset button:\n\n        reset() function: \n          clearInterval(runInterval);\n          runButton.textContent = 'Run';\n          ... reset data and state ...\n          redraw();\n\n   Now for the drawing:\n\n        We'll have colors for each centroid. We assign a fixed color per centroid index.\n\n        We'll create an array of colors (e.g., ['red', 'green', 'blue', ...] for k up to 10).\n\n        Drawing:\n\n          clear canvas.\n\n          Draw points: for each point, if assigned, use the color of the centroid it is assigned to. Otherwise, if unassigned (should only be at reset before first assign) we draw black?\n\n          Draw centroids: as a circle of a fixed radius (larger than points) with the color of the centroid index? and maybe a black outline? Also, we can draw a cross or something? \n\n        We'll draw points as small circles and centroids as big circles.\n\n   Let's set:\n\n        pointRadius = 3\n        centroidRadius = 10\n\n   We'll create a function redraw().\n\n   We also need to handle the inputs:\n\n        kValue: when changed, we reset? or we wait for reset button? We can reset when reset button is pressed.\n\n        Similarly, numPoints: when changed, reset on reset button.\n\n        We won't change during run.\n\n   We'll structure:\n\n        <div>\n          <label>Number of clusters (k):</label>\n          <input type=\"number\" id=\"kValue\" min=\"1\" max=\"10\" value=\"3\">\n          <label>Number of points:</label>\n          <input type=\"number\" id=\"numPoints\" min=\"10\" max=\"1000\" value=\"100\">\n          <button id=\"resetBtn\">Reset</button>\n          <button id=\"stepBtn\">Step</button>\n          <button id=\"runBtn\">Run</button>\n        </div>\n        <canvas id=\"canvas\" width=\"600\" height=\"400\"></canvas>\n        <div>Iteration: <span id=\"iteration\">0</span></div>\n\n   We'll generate the points and centroids within the canvas boundaries.\n\n   Colors: we'll predefine an array of 10 colors.\n\n   Let's code accordingly.\n\n   Note: we'll set maxIterations = 20.\n\n   We'll also show the current iteration.\n\n   Steps:\n\n        resetBtn: \n          let k = parseInt(document.getElementById('kValue').value);\n          let numPoints = parseInt(document.getElementById('numPoints').value);\n          resetData(k, numPoints);\n          redraw();\n\n        stepBtn: calls step(), then redraw() (but step() already calls redraw? we can have step() call redraw, but also reset calls redraw? and run uses step which calls redraw?).\n\n        We'll have step() and reset() call redraw.\n\n   Implementation:\n\n        We wrap in an IIFE to avoid global variables.\n\n   Let's write the code.\n"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "K-means clustering"
      }
    ],
    "evaluation": {
      "score": 3,
      "notes": "看着挺对"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "d77427e0-9907-11f0-aaba-d955ef06694f",
    "model": "gemini-2.5-pro",
    "timestamp": "2025-09-24T05:32:20.702Z",
    "question": "Bubble Sort",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Bubble Sort Visualization</title>\n    <style>\n        :root {\n            --bar-color: #3498db;\n            --compare-color: #f1c40f;\n            --swap-color: #e67e22;\n            --sorted-color: #2ecc71;\n            --primary-bg: #f0f2f5;\n            --secondary-bg: #ffffff;\n            --text-color: #333;\n            --header-color: #2c3e50;\n            --shadow-color: rgba(0, 0, 0, 0.1);\n        }\n\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;\n            background-color: var(--primary-bg);\n            color: var(--text-color);\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            margin: 0;\n            padding: 20px;\n        }\n\n        h1 {\n            color: var(--header-color);\n            margin-bottom: 20px;\n        }\n\n        .controls {\n            background-color: var(--secondary-bg);\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 4px 8px var(--shadow-color);\n            margin-bottom: 20px;\n            display: flex;\n            gap: 15px;\n            align-items: center;\n            flex-wrap: wrap;\n            justify-content: center;\n        }\n        \n        .controls label {\n            font-weight: bold;\n        }\n\n        input[type=\"text\"] {\n            padding: 8px 12px;\n            border: 1px solid #ccc;\n            border-radius: 4px;\n            min-width: 250px;\n            font-size: 1rem;\n        }\n\n        button {\n            padding: 10px 15px;\n            border: none;\n            border-radius: 4px;\n            color: white;\n            background-color: var(--bar-color);\n            cursor: pointer;\n            font-size: 1rem;\n            font-weight: bold;\n            transition: background-color 0.3s, transform 0.1s;\n        }\n\n        button:hover {\n            background-color: #2980b9;\n        }\n        \n        button:active {\n            transform: scale(0.98);\n        }\n        \n        button#resetBtn {\n            background-color: #e74c3c;\n        }\n        \n        button#resetBtn:hover {\n            background-color: #c0392b;\n        }\n        \n        button:disabled {\n            background-color: #bdc3c7;\n            cursor: not-allowed;\n        }\n\n        #visualization-container {\n            display: flex;\n            align-items: flex-end;\n            justify-content: center;\n            height: 400px;\n            width: 90%;\n            max-width: 1000px;\n            background-color: var(--secondary-bg);\n            border: 1px solid #ddd;\n            border-radius: 8px;\n            padding: 10px;\n            box-shadow: 0 4px 8px var(--shadow-color);\n            min-height: 100px;\n            overflow: hidden;\n        }\n\n        .bar {\n            flex-grow: 1;\n            margin: 0 2px;\n            background-color: var(--bar-color);\n            color: white;\n            text-align: center;\n            font-size: 12px;\n            font-weight: bold;\n            display: flex;\n            justify-content: center;\n            align-items: flex-end;\n            padding-bottom: 5px;\n            box-sizing: border-box;\n            border-radius: 4px 4px 0 0;\n            transition: height 0.3s ease-in-out, background-color 0.3s ease-in-out;\n        }\n        \n        .bar.comparing {\n            background-color: var(--compare-color);\n        }\n        \n        .bar.swapping {\n            background-color: var(--swap-color);\n        }\n\n        .bar.sorted {\n            background-color: var(--sorted-color);\n        }\n        \n        .status {\n            margin-top: 20px;\n            padding: 15px;\n            background: var(--secondary-bg);\n            border-radius: 8px;\n            width: 90%;\n            max-width: 1000px;\n            box-shadow: 0 4px 8px var(--shadow-color);\n            text-align: center;\n        }\n        \n        .status p {\n            margin: 5px 0;\n            font-family: 'Courier New', Courier, monospace;\n            font-size: 1.1rem;\n        }\n    </style>\n</head>\n<body>\n\n    <h1>Bubble Sort Visualization</h1>\n\n    <div class=\"controls\">\n        <label for=\"array-input\">Array (comma-separated):</label>\n        <input type=\"text\" id=\"array-input\" value=\"8, 2, 6, 4, 9, 7, 1, 3, 5\">\n        <button id=\"sortBtn\">Sort</button>\n        <button id=\"resetBtn\">Reset</button>\n        <label for=\"speed-slider\">Speed:</label>\n        <input type=\"range\" id=\"speed-slider\" min=\"50\" max=\"1000\" value=\"300\" step=\"10\">\n    </div>\n\n    <div id=\"visualization-container\"></div>\n    \n    <div class=\"status\">\n        <h3>Algorithm Steps</h3>\n        <p id=\"status-text\">Enter an array and click 'Sort' to begin.</p>\n    </div>\n\n    <script>\n        const arrayInput = document.getElementById('array-input');\n        const sortBtn = document.getElementById('sortBtn');\n        const resetBtn = document.getElementById('resetBtn');\n        const speedSlider = document.getElementById('speed-slider');\n        const container = document.getElementById('visualization-container');\n        const statusText = document.getElementById('status-text');\n\n        let dataArray = [];\n        let animationDelay = 300;\n\n        // --- Event Listeners ---\n        document.addEventListener('DOMContentLoaded', initialize);\n        sortBtn.addEventListener('click', startSort);\n        resetBtn.addEventListener('click', initialize);\n        speedSlider.addEventListener('input', (e) => {\n            // Invert the slider value so that moving it to the right increases speed (decreases delay)\n            animationDelay = 1050 - parseInt(e.target.value, 10);\n        });\n\n        // --- Core Functions ---\n\n        /**\n         * Initializes or resets the visualization based on the input field.\n         */\n        function initialize() {\n            const inputText = arrayInput.value.trim();\n            if (inputText === '') {\n                dataArray = [];\n            } else {\n                dataArray = inputText.split(',')\n                                 .map(item => parseInt(item.trim(), 10))\n                                 .filter(item => !isNaN(item) && item > 0);\n            }\n            renderBars();\n            updateStatus('Ready to sort.');\n            toggleControls(true);\n        }\n\n        /**\n         * Renders the bars in the visualization container based on the current array.\n         */\n        function renderBars() {\n            container.innerHTML = '';\n            if (dataArray.length === 0) return;\n\n            const maxValue = Math.max(...dataArray);\n            const containerHeight = container.clientHeight - 20; // Account for padding\n\n            dataArray.forEach(value => {\n                const bar = document.createElement('div');\n                bar.classList.add('bar');\n                // Calculate height relative to the max value, with a minimum for visibility\n                const barHeight = Math.max((value / maxValue) * containerHeight, 25);\n                bar.style.height = `${barHeight}px`;\n                bar.textContent = value;\n                container.appendChild(bar);\n            });\n        }\n        \n        /**\n         * Updates the status text panel.\n         * @param {string} text - The message to display.\n         */\n        function updateStatus(text) {\n            statusText.textContent = text;\n        }\n        \n        /**\n         * Enables or disables UI controls to prevent interference during sorting.\n         * @param {boolean} enabled - True to enable, false to disable.\n         */\n        function toggleControls(enabled) {\n            sortBtn.disabled = !enabled;\n            resetBtn.disabled = !enabled;\n            arrayInput.disabled = !enabled;\n            speedSlider.disabled = !enabled;\n        }\n\n        /**\n         * Kicks off the sorting process.\n         */\n        async function startSort() {\n            toggleControls(false);\n            await bubbleSort();\n            toggleControls(true);\n        }\n\n        // --- Bubble Sort Algorithm and Visualization ---\n\n        /**\n         * Performs the Bubble Sort algorithm with visual feedback.\n         */\n        async function bubbleSort() {\n            const bars = Array.from(container.children);\n            let n = dataArray.length;\n            let swapped;\n\n            updateStatus('Starting Bubble Sort...');\n            await sleep(animationDelay * 2);\n            \n            for (let i = 0; i < n - 1; i++) {\n                swapped = false;\n                for (let j = 0; j < n - i - 1; j++) {\n                    // 1. Highlight bars being compared\n                    bars[j].classList.add('comparing');\n                    bars[j + 1].classList.add('comparing');\n                    updateStatus(`Comparing ${dataArray[j]} and ${dataArray[j + 1]}...`);\n                    await sleep(animationDelay);\n\n                    if (dataArray[j] > dataArray[j + 1]) {\n                        // 2. Elements need to be swapped\n                        swapped = true;\n                        updateStatus(`${dataArray[j]} > ${dataArray[j + 1]}. Swapping.`);\n                        \n                        bars[j].classList.add('swapping');\n                        bars[j+1].classList.add('swapping');\n                        await sleep(animationDelay);\n\n                        await swap(bars, j, j + 1);\n\n                        bars[j].classList.remove('swapping');\n                        bars[j+1].classList.remove('swapping');\n                    } else {\n                        updateStatus(`${dataArray[j]} <= ${dataArray[j + 1]}. No swap needed.`);\n                        await sleep(animationDelay / 2);\n                    }\n\n                    // 3. Remove comparison highlight\n                    bars[j].classList.remove('comparing');\n                    bars[j + 1].classList.remove('comparing');\n                }\n                \n                // 4. Mark the last element of the unsorted part as sorted\n                bars[n - 1 - i].classList.add('sorted');\n                updateStatus(`Element ${dataArray[n - 1 - i]} is in its correct position.`);\n                await sleep(animationDelay);\n\n                // Optimization: if no swaps in a pass, the array is already sorted\n                if (!swapped) {\n                    updateStatus('No swaps in the last pass. Array is sorted.');\n                    // Mark all remaining unsorted elements as sorted\n                    for(let k = 0; k < n - 1 - i; k++) {\n                        bars[k].classList.add('sorted');\n                    }\n                    break;\n                }\n            }\n            \n            // Ensure the first element is marked if the loop completes\n            if(bars.length > 0 && !bars[0].classList.contains('sorted')) {\n                bars[0].classList.add('sorted');\n            }\n\n            updateStatus('Bubble Sort Complete!');\n        }\n\n        /**\n         * Swaps two elements in the data array and their visual representations.\n         * @param {HTMLElement[]} bars - The array of bar elements.\n         * @param {number} index1 - The first index to swap.\n         * @param {number} index2 - The second index to swap.\n         */\n        async function swap(bars, index1, index2) {\n            // Swap in the data array\n            [dataArray[index1], dataArray[index2]] = [dataArray[index2], dataArray[index1]];\n\n            // Visually swap the bars' properties (height and text content)\n            const tempHeight = bars[index1].style.height;\n            const tempText = bars[index1].textContent;\n\n            bars[index1].style.height = bars[index2].style.height;\n            bars[index1].textContent = bars[index2].textContent;\n            \n            bars[index2].style.height = tempHeight;\n            bars[index2].textContent = tempText;\n            \n            await sleep(animationDelay);\n        }\n\n        /**\n         * Pauses execution for a specified duration.\n         * @param {number} ms - The number of milliseconds to sleep.\n         * @returns {Promise<void>}\n         */\n        function sleep(ms) {\n            return new Promise(resolve => setTimeout(resolve, ms));\n        }\n\n    </script>\n\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Bubble Sort"
      }
    ],
    "evaluation": {
      "score": 3,
      "notes": "尚可，比较基础"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "6ef34470-9908-11f0-a0e2-1554db8eb063",
    "model": "gemini-2.5-pro",
    "timestamp": "2025-09-24T05:36:34.872Z",
    "question": "Linked List",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interactive Linked List Demonstration</title>\n    <style>\n        :root {\n            --primary-bg: #f0f4f8;\n            --secondary-bg: #ffffff;\n            --text-color: #333;\n            --accent-color: #007bff;\n            --accent-hover: #0056b3;\n            --node-color: #e0e7ff;\n            --node-border: #a3bffa;\n            --arrow-color: #555;\n            --head-color: #28a745;\n            --null-color: #dc3545;\n            --highlight-color: #ffc107;\n            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            --border-radius: 8px;\n            --box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n        }\n\n        body {\n            font-family: var(--font-family);\n            background-color: var(--primary-bg);\n            color: var(--text-color);\n            margin: 0;\n            padding: 20px;\n            display: flex;\n            justify-content: center;\n            align-items: flex-start;\n            min-height: 100vh;\n        }\n\n        .container {\n            width: 95%;\n            max-width: 1200px;\n            background: var(--secondary-bg);\n            padding: 25px;\n            border-radius: var(--border-radius);\n            box-shadow: var(--box-shadow);\n        }\n\n        h1 {\n            text-align: center;\n            color: var(--accent-color);\n            margin-top: 0;\n        }\n\n        p.description {\n            text-align: center;\n            margin-bottom: 25px;\n            color: #555;\n        }\n\n        .controls {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));\n            gap: 15px;\n            align-items: end;\n            padding: 20px;\n            background-color: var(--primary-bg);\n            border-radius: var(--border-radius);\n            margin-bottom: 30px;\n        }\n\n        .control-group {\n            display: flex;\n            flex-direction: column;\n        }\n        \n        .control-group label {\n            margin-bottom: 5px;\n            font-size: 0.9em;\n            font-weight: bold;\n        }\n\n        input[type=\"text\"], input[type=\"number\"] {\n            padding: 10px;\n            border: 1px solid #ccc;\n            border-radius: 4px;\n            font-size: 1em;\n        }\n\n        button {\n            padding: 10px 15px;\n            border: none;\n            background-color: var(--accent-color);\n            color: white;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 1em;\n            transition: background-color 0.2s ease-in-out;\n            font-weight: bold;\n        }\n        \n        button.danger {\n            background-color: var(--null-color);\n        }\n        button.danger:hover {\n            background-color: #c82333;\n        }\n\n        button:hover {\n            background-color: var(--accent-hover);\n        }\n\n        #visualization-container {\n            margin-top: 20px;\n            min-height: 100px;\n            padding: 20px;\n            background: #fdfdfd;\n            border: 1px dashed #ddd;\n            border-radius: var(--border-radius);\n            overflow-x: auto;\n        }\n\n        #visualization {\n            display: flex;\n            align-items: center;\n            padding: 20px 0;\n            position: relative;\n        }\n\n        .head-label {\n            position: absolute;\n            top: -15px;\n            left: 10px;\n            font-weight: bold;\n            color: var(--head-color);\n            font-size: 1.2em;\n        }\n\n        .node {\n            flex-shrink: 0;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            width: 70px;\n            height: 40px;\n            background-color: var(--node-color);\n            border: 2px solid var(--node-border);\n            border-radius: 4px;\n            font-weight: bold;\n            font-size: 1.1em;\n            position: relative;\n            transition: transform 0.3s ease, background-color 0.3s ease;\n        }\n\n        .node.highlight {\n            background-color: var(--highlight-color);\n            transform: scale(1.1);\n        }\n        .node.highlight-success {\n            background-color: #28a745;\n            color: white;\n            transform: scale(1.1);\n        }\n        .node.highlight-fail {\n            background-color: #dc3545;\n            color: white;\n            transform: scale(1.1);\n        }\n\n        .arrow {\n            flex-shrink: 0;\n            width: 50px;\n            height: 2px;\n            background-color: var(--arrow-color);\n            position: relative;\n            margin: 0 5px;\n        }\n\n        .arrow::after {\n            content: '';\n            position: absolute;\n            right: -1px;\n            top: -4px;\n            width: 0;\n            height: 0;\n            border-top: 5px solid transparent;\n            border-bottom: 5px solid transparent;\n            border-left: 8px solid var(--arrow-color);\n        }\n\n        .null-node {\n            flex-shrink: 0;\n            width: 50px;\n            height: 40px;\n            line-height: 40px;\n            text-align: center;\n            background-color: #f8d7da;\n            border: 2px solid var(--null-color);\n            color: var(--null-color);\n            font-weight: bold;\n            border-radius: 4px;\n        }\n        \n        #output {\n            margin-top: 20px;\n            padding: 15px;\n            background-color: #333;\n            color: #f8f8f8;\n            border-radius: var(--border-radius);\n            font-family: 'Courier New', Courier, monospace;\n            white-space: pre-wrap;\n            min-height: 50px;\n        }\n    </style>\n</head>\n<body>\n\n    <div class=\"container\">\n        <h1>Interactive Linked List</h1>\n        <p class=\"description\">\n            A linked list is a linear data structure where elements are not stored at contiguous memory locations.\n            Each element (a 'node') contains its data and a reference (a 'link') to the next node in the sequence.\n        </p>\n\n        <div class=\"controls\">\n            <div class=\"control-group\">\n                <label for=\"valueInput\">Value</label>\n                <input type=\"text\" id=\"valueInput\" placeholder=\"Enter a value\">\n            </div>\n            <div class=\"control-group\">\n                <label for=\"indexInput\">Index (for Insert)</label>\n                <input type=\"number\" id=\"indexInput\" placeholder=\"Enter index\" min=\"0\">\n            </div>\n            <div class=\"control-group\">\n                <label>&nbsp;</label>\n                <button id=\"appendBtn\">Append</button>\n            </div>\n            <div class=\"control-group\">\n                <label>&nbsp;</label>\n                <button id=\"prependBtn\">Prepend</button>\n            </div>\n            <div class=\"control-group\">\n                <label>&nbsp;</label>\n                <button id=\"insertAtBtn\">Insert At Index</button>\n            </div>\n            <div class=\"control-group\">\n                <label>&nbsp;</label>\n                <button id=\"removeBtn\">Remove Value</button>\n            </div>\n            <div class=\"control-group\">\n                <label>&nbsp;</label>\n                <button id=\"findBtn\">Find Value</button>\n            </div>\n            <div class=\"control-group\">\n                <label>&nbsp;</label>\n                <button id=\"clearBtn\" class=\"danger\">Clear List</button>\n            </div>\n        </div>\n\n        <div id=\"visualization-container\">\n            <div id=\"visualization\"></div>\n        </div>\n\n        <div id=\"output\">\n            Welcome! Add a node to get started.\n        </div>\n    </div>\n\n    <script>\n        // --- 1. DATA STRUCTURE DEFINITION ---\n\n        // Node class represents each element in the list\n        class Node {\n            constructor(value) {\n                this.value = value;\n                this.next = null;\n            }\n        }\n\n        // LinkedList class to manage the nodes\n        class LinkedList {\n            constructor() {\n                this.head = null;\n                this.size = 0;\n            }\n\n            // Add a node to the end of the list\n            append(value) {\n                const newNode = new Node(value);\n                if (!this.head) {\n                    this.head = newNode;\n                } else {\n                    let current = this.head;\n                    while (current.next) {\n                        current = current.next;\n                    }\n                    current.next = newNode;\n                }\n                this.size++;\n            }\n\n            // Add a node to the beginning of the list\n            prepend(value) {\n                const newNode = new Node(value);\n                newNode.next = this.head;\n                this.head = newNode;\n                this.size++;\n            }\n\n            // Insert a node at a specific index\n            insertAt(value, index) {\n                if (index < 0 || index > this.size) {\n                    return null; // Out of bounds\n                }\n                if (index === 0) {\n                    this.prepend(value);\n                    return true;\n                }\n                const newNode = new Node(value);\n                let current = this.head;\n                let previous;\n                let count = 0;\n                while (count < index) {\n                    previous = current;\n                    current = current.next;\n                    count++;\n                }\n                newNode.next = current;\n                previous.next = newNode;\n                this.size++;\n                return true;\n            }\n\n            // Remove the first node with a given value\n            remove(value) {\n                if (!this.head) return false;\n\n                if (this.head.value === value) {\n                    this.head = this.head.next;\n                    this.size--;\n                    return true;\n                }\n\n                let current = this.head;\n                let previous = null;\n                while (current && current.value !== value) {\n                    previous = current;\n                    current = current.next;\n                }\n\n                if (!current) return false; // Not found\n\n                previous.next = current.next;\n                this.size--;\n                return true;\n            }\n\n            // Find the index of a node with a given value\n            find(value) {\n                let current = this.head;\n                let index = 0;\n                while (current) {\n                    if (current.value === value) {\n                        return index;\n                    }\n                    current = current.next;\n                    index++;\n                }\n                return -1; // Not found\n            }\n\n            // Clear the entire list\n            clear() {\n                this.head = null;\n                this.size = 0;\n            }\n\n            // Get an array representation of the list\n            toArray() {\n                const elements = [];\n                let current = this.head;\n                while (current) {\n                    elements.push(current.value);\n                    current = current.next;\n                }\n                return elements;\n            }\n        }\n\n\n        // --- 2. DOM AND UI LOGIC ---\n\n        // Get DOM elements\n        const valueInput = document.getElementById('valueInput');\n        const indexInput = document.getElementById('indexInput');\n        const appendBtn = document.getElementById('appendBtn');\n        const prependBtn = document.getElementById('prependBtn');\n        const insertAtBtn = document.getElementById('insertAtBtn');\n        const removeBtn = document.getElementById('removeBtn');\n        const findBtn = document.getElementById('findBtn');\n        const clearBtn = document.getElementById('clearBtn');\n        const visualizationDiv = document.getElementById('visualization');\n        const outputDiv = document.getElementById('output');\n\n        // Create a new Linked List instance\n        const list = new LinkedList();\n\n        // Highlight a node with a specific class and duration\n        function highlightNode(index, className = 'highlight', duration = 1500) {\n            const nodeElements = visualizationDiv.querySelectorAll('.node');\n            if (nodeElements[index]) {\n                nodeElements[index].classList.add(className);\n                setTimeout(() => {\n                    nodeElements[index].classList.remove(className);\n                }, duration);\n            }\n        }\n\n        // Update the visual representation of the linked list\n        function updateUI(message = '') {\n            visualizationDiv.innerHTML = '';\n            \n            if (list.head) {\n                 const headLabel = document.createElement('div');\n                 headLabel.className = 'head-label';\n                 headLabel.textContent = 'HEAD';\n                 visualizationDiv.appendChild(headLabel);\n            }\n\n            let current = list.head;\n            let index = 0;\n            while (current) {\n                // Create node element\n                const nodeEl = document.createElement('div');\n                nodeEl.className = 'node';\n                nodeEl.textContent = current.value;\n                nodeEl.dataset.index = index;\n                visualizationDiv.appendChild(nodeEl);\n\n                // Create arrow if not the last node\n                if (current.next) {\n                    const arrowEl = document.createElement('div');\n                    arrowEl.className = 'arrow';\n                    visualizationDiv.appendChild(arrowEl);\n                }\n                current = current.next;\n                index++;\n            }\n            \n            // Add the final NULL element\n            const nullEl = document.createElement('div');\n            nullEl.className = 'null-node';\n            nullEl.textContent = 'NULL';\n\n            if (list.head) {\n                 const arrowEl = document.createElement('div');\n                 arrowEl.className = 'arrow';\n                 visualizationDiv.appendChild(arrowEl);\n            }\n            visualizationDiv.appendChild(nullEl);\n            \n            // Update the output text\n            let outputText = `// Current List State:\\n`;\n            outputText += `Size: ${list.size}\\n`;\n            outputText += `List: ${list.toArray().join(' -> ')} -> null\\n\\n`;\n            if (message) {\n                outputText += `// Last Operation:\\n${message}`;\n            }\n            outputDiv.textContent = outputText;\n        }\n\n        // --- 3. EVENT LISTENERS ---\n\n        appendBtn.addEventListener('click', () => {\n            const value = valueInput.value.trim();\n            if (!value) {\n                alert('Please enter a value.');\n                return;\n            }\n            list.append(value);\n            updateUI(`Appended node with value \"${value}\".`);\n            highlightNode(list.size - 1, 'highlight-success');\n            valueInput.value = '';\n            valueInput.focus();\n        });\n\n        prependBtn.addEventListener('click', () => {\n            const value = valueInput.value.trim();\n            if (!value) {\n                alert('Please enter a value.');\n                return;\n            }\n            list.prepend(value);\n            updateUI(`Prepended node with value \"${value}\".`);\n            highlightNode(0, 'highlight-success');\n            valueInput.value = '';\n            valueInput.focus();\n        });\n\n        insertAtBtn.addEventListener('click', () => {\n            const value = valueInput.value.trim();\n            const index = parseInt(indexInput.value, 10);\n            if (!value) {\n                alert('Please enter a value.');\n                return;\n            }\n            if (isNaN(index)) {\n                alert('Please enter a valid index.');\n                return;\n            }\n            if (index < 0 || index > list.size) {\n                 updateUI(`Error: Index ${index} is out of bounds. Valid range is 0 to ${list.size}.`);\n                 return;\n            }\n            list.insertAt(value, index);\n            updateUI(`Inserted \"${value}\" at index ${index}.`);\n            highlightNode(index, 'highlight-success');\n            valueInput.value = '';\n            indexInput.value = '';\n            valueInput.focus();\n        });\n\n        removeBtn.addEventListener('click', () => {\n            const value = valueInput.value.trim();\n            if (!value) {\n                alert('Please enter a value to remove.');\n                return;\n            }\n            const removed = list.remove(value);\n            if (removed) {\n                updateUI(`Removed the first node with value \"${value}\".`);\n            } else {\n                updateUI(`Value \"${value}\" not found in the list.`);\n            }\n            valueInput.value = '';\n        });\n\n        findBtn.addEventListener('click', async () => {\n            const value = valueInput.value.trim();\n            if (!value) {\n                alert('Please enter a value to find.');\n                return;\n            }\n\n            let current = list.head;\n            let index = 0;\n            let found = false;\n\n            while (current) {\n                highlightNode(index, 'highlight', 400);\n                await new Promise(resolve => setTimeout(resolve, 500)); // Pause for animation\n\n                if (current.value === value) {\n                    highlightNode(index, 'highlight-success');\n                    updateUI(`Found value \"${value}\" at index ${index}.`);\n                    found = true;\n                    break;\n                }\n                current = current.next;\n                index++;\n            }\n\n            if (!found) {\n                updateUI(`Value \"${value}\" not found in the list.`);\n            }\n        });\n\n        clearBtn.addEventListener('click', () => {\n            list.clear();\n            updateUI('List has been cleared.');\n        });\n        \n        // Initial UI render\n        updateUI();\n\n    </script>\n\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Linked List"
      }
    ],
    "evaluation": {
      "score": 5,
      "notes": "冲这功能性我给5分。UI简洁布局合理。而且是目前唯一一个list很长可以滚动的。实用主义满分！！！"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "e2e28710-9908-11f0-b6da-8b7388ab1c2f",
    "model": "gemini-2.5-pro",
    "timestamp": "2025-09-24T05:39:49.378Z",
    "question": "K-means clustering",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>K-Means Clustering Demo</title>\n    <style>\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            background-color: #f0f2f5;\n            margin: 0;\n            padding: 1rem;\n        }\n        h1 {\n            color: #333;\n            margin-top: 0;\n        }\n        .controls {\n            background-color: #ffffff;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n            margin-bottom: 20px;\n            display: flex;\n            flex-wrap: wrap;\n            gap: 15px;\n            align-items: center;\n            justify-content: center;\n        }\n        .controls > div {\n            display: flex;\n            flex-direction: column;\n        }\n        label {\n            font-size: 0.9em;\n            color: #555;\n            margin-bottom: 5px;\n        }\n        input[type=\"number\"] {\n            width: 80px;\n            padding: 8px;\n            border: 1px solid #ccc;\n            border-radius: 4px;\n            font-size: 1em;\n        }\n        button {\n            padding: 10px 15px;\n            border: none;\n            border-radius: 4px;\n            color: white;\n            background-color: #007bff;\n            cursor: pointer;\n            font-size: 1em;\n            transition: background-color 0.2s;\n        }\n        button:hover {\n            background-color: #0056b3;\n        }\n        button:disabled {\n            background-color: #aaa;\n            cursor: not-allowed;\n        }\n        #generateBtn { background-color: #28a745; }\n        #generateBtn:hover { background-color: #218838; }\n        #resetBtn { background-color: #dc3545; }\n        #resetBtn:hover { background-color: #c82333; }\n        \n        #main-container {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n\n        #info {\n            margin-top: 10px;\n            font-size: 1.1em;\n            color: #333;\n            min-height: 25px;\n        }\n\n        canvas {\n            border: 1px solid #ddd;\n            background-color: #fff;\n            border-radius: 8px;\n        }\n    </style>\n</head>\n<body>\n\n    <h1>K-Means Clustering Demo</h1>\n\n    <div class=\"controls\">\n        <div>\n            <label for=\"k-input\">Clusters (K)</label>\n            <input type=\"number\" id=\"k-input\" value=\"4\" min=\"2\" max=\"20\">\n        </div>\n        <div>\n            <label for=\"points-input\">Data Points</label>\n            <input type=\"number\" id=\"points-input\" value=\"300\" min=\"10\" max=\"2000\">\n        </div>\n        <button id=\"generateBtn\">Generate New Data</button>\n        <button id=\"stepBtn\">Step</button>\n        <button id=\"runBtn\">Run</button>\n        <button id=\"resetBtn\">Reset</button>\n    </div>\n\n    <div id=\"main-container\">\n        <canvas id=\"canvas\" width=\"800\" height=\"600\"></canvas>\n        <div id=\"info\">Ready. Generate data to begin.</div>\n    </div>\n\n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n\n        // --- DOM Elements ---\n        const kInput = document.getElementById('k-input');\n        const pointsInput = document.getElementById('points-input');\n        const generateBtn = document.getElementById('generateBtn');\n        const stepBtn = document.getElementById('stepBtn');\n        const runBtn = document.getElementById('runBtn');\n        const resetBtn = document.getElementById('resetBtn');\n        const infoDiv = document.getElementById('info');\n\n        // --- State Variables ---\n        let points = [];\n        let centroids = [];\n        let k = 4;\n        let numPoints = 300;\n        let animationFrameId = null;\n        let iteration = 0;\n        let hasConverged = false;\n        let isRunning = false;\n        let isInitialized = false;\n\n        const CLUSTER_COLORS = [\n            '#FF6347', '#4682B4', '#32CD32', '#FFD700', '#6A5ACD',\n            '#FF4500', '#20B2AA', '#DA70D6', '#00FA9A', '#8B4513',\n            '#B22222', '#4169E1', '#8FBC8F', '#F0E68C', '#9932CC',\n            '#CD5C5C', '#1E90FF', '#98FB98', '#FFDEAD', '#BA55D3'\n        ];\n\n        // --- Core Algorithm Functions ---\n\n        function euclideanDistance(p1, p2) {\n            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n        }\n\n        function generateRandomPoints() {\n            points = [];\n            numPoints = parseInt(pointsInput.value);\n            for (let i = 0; i < numPoints; i++) {\n                points.push({\n                    x: Math.random() * canvas.width,\n                    y: Math.random() * canvas.height,\n                    cluster: -1\n                });\n            }\n        }\n\n        function initializeCentroids() {\n            centroids = [];\n            k = parseInt(kInput.value);\n            const usedIndexes = new Set();\n            for (let i = 0; i < k; i++) {\n                let randomIndex;\n                do {\n                    randomIndex = Math.floor(Math.random() * points.length);\n                } while (usedIndexes.has(randomIndex));\n                usedIndexes.add(randomIndex);\n                centroids.push({\n                    x: points[randomIndex].x,\n                    y: points[randomIndex].y\n                });\n            }\n            isInitialized = true;\n        }\n\n        function assignPointsToClusters() {\n            let changed = false;\n            points.forEach(point => {\n                let minDistance = Infinity;\n                let closestCentroidIndex = -1;\n                centroids.forEach((centroid, index) => {\n                    const dist = euclideanDistance(point, centroid);\n                    if (dist < minDistance) {\n                        minDistance = dist;\n                        closestCentroidIndex = index;\n                    }\n                });\n                if (point.cluster !== closestCentroidIndex) {\n                    point.cluster = closestCentroidIndex;\n                    changed = true;\n                }\n            });\n            return changed;\n        }\n\n        function updateCentroids() {\n            const clusterSums = Array(k).fill(0).map(() => ({ x: 0, y: 0, count: 0 }));\n            \n            points.forEach(point => {\n                if (point.cluster !== -1) {\n                    clusterSums[point.cluster].x += point.x;\n                    clusterSums[point.cluster].y += point.y;\n                    clusterSums[point.cluster].count++;\n                }\n            });\n\n            centroids.forEach((centroid, index) => {\n                const sum = clusterSums[index];\n                if (sum.count > 0) {\n                    centroid.x = sum.x / sum.count;\n                    centroid.y = sum.y / sum.count;\n                }\n            });\n        }\n\n        function step() {\n            if (hasConverged) {\n                infoDiv.textContent = `Converged after ${iteration} iterations.`;\n                stop();\n                return;\n            }\n            if (!isInitialized) {\n                initializeCentroids();\n            }\n\n            iteration++;\n            infoDiv.textContent = `Iteration: ${iteration}`;\n            const changed = assignPointsToClusters();\n            if (!changed) {\n                hasConverged = true;\n                infoDiv.textContent = `Converged after ${iteration} iterations.`;\n                stop();\n            } else {\n                updateCentroids();\n            }\n            draw();\n        }\n\n        function run() {\n            if (isRunning) return;\n            if (points.length === 0) {\n                alert(\"Please generate data first.\");\n                return;\n            }\n            if(hasConverged) {\n                infoDiv.textContent = `Already converged after ${iteration} iterations. Reset to run again.`;\n                return;\n            }\n            isRunning = true;\n            updateUIState();\n            \n            function loop() {\n                if (!isRunning || hasConverged) {\n                    stop();\n                    return;\n                }\n                step();\n                animationFrameId = setTimeout(() => requestAnimationFrame(loop), 50); // Delay for visualization\n            }\n            loop();\n        }\n\n        function stop() {\n            isRunning = false;\n            if (animationFrameId) {\n                clearTimeout(animationFrameId);\n                cancelAnimationFrame(animationFrameId);\n                animationFrameId = null;\n            }\n            updateUIState();\n        }\n\n        // --- Drawing Functions ---\n\n        function draw() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n            // Draw points\n            points.forEach(point => {\n                ctx.beginPath();\n                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);\n                ctx.fillStyle = point.cluster === -1 ? '#333' : CLUSTER_COLORS[point.cluster % CLUSTER_COLORS.length];\n                ctx.fill();\n            });\n\n            // Draw centroids\n            centroids.forEach((centroid, index) => {\n                ctx.beginPath();\n                ctx.rect(centroid.x - 7, centroid.y - 7, 14, 14);\n                ctx.fillStyle = CLUSTER_COLORS[index % CLUSTER_COLORS.length];\n                ctx.fill();\n                ctx.strokeStyle = '#000';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n            });\n        }\n\n        // --- UI and Control ---\n\n        function resetState() {\n            stop();\n            isInitialized = false;\n            hasConverged = false;\n            iteration = 0;\n            points = [];\n            centroids = [];\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            infoDiv.textContent = 'Ready. Generate data to begin.';\n            updateUIState();\n        }\n\n        function setup() {\n            resetState();\n            generateRandomPoints();\n            draw();\n            infoDiv.textContent = 'Data generated. Press Step or Run to start clustering.';\n        }\n\n        function updateUIState() {\n            generateBtn.disabled = isRunning;\n            resetBtn.disabled = isRunning;\n            stepBtn.disabled = isRunning || hasConverged || points.length === 0;\n            runBtn.disabled = isRunning || hasConverged || points.length === 0;\n            runBtn.textContent = isRunning ? \"Running...\" : \"Run\";\n        }\n\n        // --- Event Listeners ---\n        generateBtn.addEventListener('click', setup);\n        resetBtn.addEventListener('click', setup);\n        stepBtn.addEventListener('click', () => {\n             if (points.length === 0) {\n                alert(\"Please generate data first.\");\n                return;\n            }\n            step();\n            updateUIState();\n        });\n        runBtn.addEventListener('click', run);\n\n        // Initial setup\n        window.onload = () => {\n            setup();\n        };\n\n    </script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "K-means clustering"
      }
    ],
    "evaluation": {
      "score": 2,
      "notes": "失败 不work"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "1d7752c0-9909-11f0-b94d-4935f02b5cd0",
    "model": "gemini-2.5-pro",
    "timestamp": "2025-09-24T05:41:27.661Z",
    "question": "K-means clustering",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>K-Means Clustering Demonstration</title>\n    <style>\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;\n            background-color: #f0f2f5;\n            color: #333;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            margin: 0;\n            padding: 20px;\n            min-height: 100vh;\n            box-sizing: border-box;\n        }\n\n        h1 {\n            color: #1a2a4d;\n            margin-bottom: 20px;\n        }\n\n        #controls {\n            display: flex;\n            flex-wrap: wrap;\n            justify-content: center;\n            align-items: center;\n            gap: 15px;\n            background-color: #ffffff;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n            margin-bottom: 20px;\n            width: 90%;\n            max-width: 960px;\n        }\n\n        .control-group {\n            display: flex;\n            align-items: center;\n            gap: 8px;\n        }\n\n        label {\n            font-weight: 500;\n        }\n\n        input[type=\"number\"] {\n            width: 60px;\n            padding: 8px;\n            border: 1px solid #ccc;\n            border-radius: 4px;\n            font-size: 1em;\n            text-align: center;\n        }\n\n        button {\n            background-color: #007bff;\n            color: white;\n            border: none;\n            padding: 10px 15px;\n            border-radius: 5px;\n            cursor: pointer;\n            font-size: 1em;\n            font-weight: 500;\n            transition: background-color 0.2s ease, transform 0.1s ease;\n        }\n\n        button:hover {\n            background-color: #0056b3;\n        }\n\n        button:active {\n            transform: scale(0.98);\n        }\n\n        button:disabled {\n            background-color: #a0a0a0;\n            cursor: not-allowed;\n        }\n\n        #reset-btn {\n            background-color: #dc3545;\n        }\n        #reset-btn:hover {\n            background-color: #c82333;\n        }\n\n        #canvas-container {\n            width: 90%;\n            max-width: 960px;\n            aspect-ratio: 4 / 3;\n            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n            border-radius: 8px;\n            overflow: hidden; /* Ensures canvas corners are rounded */\n        }\n        \n        canvas {\n            width: 100%;\n            height: 100%;\n            display: block;\n            background-color: #fff;\n        }\n\n        #status {\n            margin-top: 15px;\n            font-size: 1.1em;\n            color: #555;\n            min-height: 1.5em;\n        }\n    </style>\n</head>\n<body>\n\n    <h1>K-Means Clustering Visualizer</h1>\n\n    <div id=\"controls\">\n        <div class=\"control-group\">\n            <label for=\"k-input\">Clusters (K):</label>\n            <input type=\"number\" id=\"k-input\" value=\"4\" min=\"2\" max=\"20\">\n        </div>\n        <div class=\"control-group\">\n            <label for=\"points-input\">Data Points:</label>\n            <input type=\"number\" id=\"points-input\" value=\"300\" min=\"10\" max=\"2000\">\n        </div>\n        <button id=\"generate-btn\">1. Generate Data</button>\n        <button id=\"init-centroids-btn\" disabled>2. Initialize Centroids</button>\n        <button id=\"step-btn\" disabled>3. Run One Step</button>\n        <button id=\"run-btn\" disabled>4. Run to Completion</button>\n        <button id=\"reset-btn\">Reset</button>\n    </div>\n\n    <div id=\"canvas-container\">\n        <canvas id=\"kmeans-canvas\"></canvas>\n    </div>\n\n    <div id=\"status\">Ready. Generate data to begin.</div>\n\n    <script>\n        const canvas = document.getElementById('kmeans-canvas');\n        const ctx = canvas.getContext('2d');\n\n        // --- UI Elements ---\n        const kInput = document.getElementById('k-input');\n        const pointsInput = document.getElementById('points-input');\n        const generateBtn = document.getElementById('generate-btn');\n        const initCentroidsBtn = document.getElementById('init-centroids-btn');\n        const stepBtn = document.getElementById('step-btn');\n        const runBtn = document.getElementById('run-btn');\n        const resetBtn = document.getElementById('reset-btn');\n        const statusEl = document.getElementById('status');\n        \n        // --- State Variables ---\n        let points = [];\n        let centroids = [];\n        let k = 4;\n        let numPoints = 300;\n        let animationFrameId = null;\n        let iterationCount = 0;\n        \n        // Predefined colors for clusters for better visualization\n        const COLORS = [\n            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', \n            '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', \n            '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', '#f7b6d2', '#c7c7c7', \n            '#dbdb8d', '#9edae5'\n        ];\n\n        // --- Initialization ---\n        function init() {\n            // Set canvas dimensions based on its container\n            const dpr = window.devicePixelRatio || 1;\n            const rect = canvas.getBoundingClientRect();\n            canvas.width = rect.width * dpr;\n            canvas.height = rect.height * dpr;\n            ctx.scale(dpr, dpr);\n            \n            attachEventListeners();\n            updateFromInputs();\n            reset();\n        }\n\n        function updateFromInputs() {\n            k = parseInt(kInput.value, 10);\n            numPoints = parseInt(pointsInput.value, 10);\n        }\n\n        function attachEventListeners() {\n            generateBtn.addEventListener('click', generateRandomPoints);\n            initCentroidsBtn.addEventListener('click', initializeCentroids);\n            stepBtn.addEventListener('click', runSingleStep);\n            runBtn.addEventListener('click', runFullAlgorithm);\n            resetBtn.addEventListener('click', reset);\n            kInput.addEventListener('change', updateFromInputs);\n            pointsInput.addEventListener('change', updateFromInputs);\n        }\n\n        // --- Core K-Means Logic ---\n\n        function generateRandomPoints() {\n            reset(true); // Soft reset: keep inputs\n            updateFromInputs();\n            points = [];\n            for (let i = 0; i < numPoints; i++) {\n                points.push({\n                    x: Math.random() * canvas.clientWidth,\n                    y: Math.random() * canvas.clientHeight,\n                    cluster: null\n                });\n            }\n            statusEl.textContent = 'Data generated. Now initialize centroids.';\n            updateButtonStates('pointsGenerated');\n            draw();\n        }\n\n        function initializeCentroids() {\n            stopAnimation();\n            updateFromInputs();\n            centroids = [];\n            iterationCount = 0;\n            // Reset cluster assignment for all points\n            points.forEach(p => p.cluster = null);\n\n            // Pick K random points as initial centroids\n            const usedIndices = new Set();\n            while (centroids.length < k && centroids.length < points.length) {\n                const idx = Math.floor(Math.random() * points.length);\n                if (!usedIndices.has(idx)) {\n                    usedIndices.add(idx);\n                    centroids.push({\n                        x: points[idx].x,\n                        y: points[idx].y,\n                        color: COLORS[centroids.length % COLORS.length],\n                        points: []\n                    });\n                }\n            }\n            statusEl.textContent = 'Centroids initialized. Ready to run steps.';\n            updateButtonStates('centroidsInitialized');\n            draw();\n        }\n\n        /**\n         * Assignment Step: Assign each point to the nearest centroid.\n         * @returns {boolean} - True if any point changed its cluster, false otherwise.\n         */\n        function assignPointsToClusters() {\n            let changed = false;\n            // Clear centroid point lists\n            centroids.forEach(c => c.points = []);\n\n            points.forEach(point => {\n                let minDistance = Infinity;\n                let nearestCentroidIndex = -1;\n\n                centroids.forEach((centroid, index) => {\n                    const dist = distance(point, centroid);\n                    if (dist < minDistance) {\n                        minDistance = dist;\n                        nearestCentroidIndex = index;\n                    }\n                });\n\n                if (point.cluster !== nearestCentroidIndex) {\n                    changed = true;\n                }\n                point.cluster = nearestCentroidIndex;\n                if (nearestCentroidIndex !== -1) {\n                    centroids[nearestCentroidIndex].points.push(point);\n                }\n            });\n            return changed;\n        }\n\n        /**\n         * Update Step: Recalculate the position of each centroid based on the mean of its assigned points.\n         */\n        function updateCentroids() {\n            centroids.forEach(centroid => {\n                if (centroid.points.length === 0) {\n                    // Optional: re-initialize runaway centroids. For now, we leave them.\n                    return;\n                }\n                let sumX = 0;\n                let sumY = 0;\n                centroid.points.forEach(point => {\n                    sumX += point.x;\n                    sumY += point.y;\n                });\n                centroid.x = sumX / centroid.points.length;\n                centroid.y = sumY / centroid.points.length;\n            });\n        }\n        \n        function runSingleStep() {\n            stopAnimation();\n            iterationCount++;\n            const changed = assignPointsToClusters();\n            if (changed) {\n                updateCentroids();\n                statusEl.textContent = `Iteration: ${iterationCount}. Points reassigned.`;\n            } else {\n                statusEl.textContent = `Converged after ${iterationCount} iterations.`;\n                updateButtonStates('converged');\n            }\n            draw();\n        }\n\n        function runFullAlgorithm() {\n            stopAnimation();\n            updateButtonStates('running');\n            statusEl.textContent = 'Running...';\n            \n            function animationLoop() {\n                iterationCount++;\n                const changed = assignPointsToClusters();\n                if (changed) {\n                    updateCentroids();\n                    statusEl.textContent = `Running... Iteration: ${iterationCount}`;\n                    draw();\n                    animationFrameId = requestAnimationFrame(animationLoop);\n                } else {\n                    statusEl.textContent = `Converged after ${iterationCount} iterations.`;\n                    updateButtonStates('converged');\n                    draw();\n                }\n            }\n            animationFrameId = requestAnimationFrame(animationLoop);\n        }\n\n\n        // --- Drawing and Helper Functions ---\n        \n        function draw() {\n            const width = canvas.clientWidth;\n            const height = canvas.clientHeight;\n            ctx.clearRect(0, 0, width, height);\n\n            // Draw points\n            points.forEach(point => {\n                ctx.beginPath();\n                ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI);\n                ctx.fillStyle = point.cluster !== null ? centroids[point.cluster].color : '#cccccc';\n                ctx.fill();\n            });\n\n            // Draw centroids\n            centroids.forEach(centroid => {\n                ctx.beginPath();\n                // Draw a cross shape for the centroid\n                const size = 10;\n                ctx.moveTo(centroid.x - size, centroid.y);\n                ctx.lineTo(centroid.x + size, centroid.y);\n                ctx.moveTo(centroid.x, centroid.y - size);\n                ctx.lineTo(centroid.x, centroid.y + size);\n                \n                ctx.strokeStyle = '#000000';\n                ctx.lineWidth = 4;\n                ctx.stroke();\n\n                ctx.strokeStyle = centroid.color;\n                ctx.lineWidth = 2.5;\n                ctx.stroke();\n            });\n        }\n\n        function distance(p1, p2) {\n            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n        }\n\n        function stopAnimation() {\n            if (animationFrameId) {\n                cancelAnimationFrame(animationFrameId);\n                animationFrameId = null;\n            }\n        }\n\n        function reset(soft = false) {\n            stopAnimation();\n            points = [];\n            centroids = [];\n            iterationCount = 0;\n            if (!soft) {\n                kInput.value = 4;\n                pointsInput.value = 300;\n                updateFromInputs();\n            }\n            statusEl.textContent = 'Ready. Generate data to begin.';\n            updateButtonStates('initial');\n            ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);\n        }\n        \n        function updateButtonStates(state) {\n            generateBtn.disabled = state === 'running';\n            initCentroidsBtn.disabled = !(state === 'pointsGenerated' || state === 'centroidsInitialized' || state === 'converged');\n            stepBtn.disabled = !(state === 'centroidsInitialized' || state === 'converged'); // Allow step even after convergence to see nothing happens\n            runBtn.disabled = !(state === 'centroidsInitialized');\n            \n            // Only enable reset when there's something to reset\n            resetBtn.disabled = state === 'initial';\n        }\n\n        // --- Start the application ---\n        window.addEventListener('load', init);\n        window.addEventListener('resize', init);\n    </script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "K-means clustering"
      }
    ],
    "evaluation": {
      "score": 3,
      "notes": "尚可 教育意义不行"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "718173f0-9909-11f0-a36a-4d4b7e8db71e",
    "model": "claude-sonnet-4-20250514",
    "timestamp": "2025-09-24T05:43:48.655Z",
    "question": "Bubble Sort",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Bubble Sort Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 800px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        .container {\n            background: white;\n            padding: 30px;\n            border-radius: 10px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        h1 {\n            text-align: center;\n            color: #333;\n            margin-bottom: 30px;\n        }\n        .controls {\n            text-align: center;\n            margin-bottom: 30px;\n        }\n        button {\n            background: #007bff;\n            color: white;\n            border: none;\n            padding: 10px 20px;\n            margin: 5px;\n            border-radius: 5px;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        button:hover {\n            background: #0056b3;\n        }\n        button:disabled {\n            background: #ccc;\n            cursor: not-allowed;\n        }\n        .array-container {\n            display: flex;\n            justify-content: center;\n            align-items: flex-end;\n            height: 300px;\n            margin: 30px 0;\n            padding: 20px;\n            border: 2px solid #ddd;\n            border-radius: 5px;\n        }\n        .bar {\n            width: 40px;\n            margin: 2px;\n            background: #007bff;\n            display: flex;\n            align-items: flex-end;\n            justify-content: center;\n            color: white;\n            font-weight: bold;\n            transition: all 0.3s ease;\n            border-radius: 5px 5px 0 0;\n        }\n        .bar.comparing {\n            background: #ffc107;\n            color: #000;\n        }\n        .bar.swapping {\n            background: #dc3545;\n            transform: scale(1.1);\n        }\n        .bar.sorted {\n            background: #28a745;\n        }\n        .info {\n            text-align: center;\n            margin: 20px 0;\n        }\n        .stats {\n            display: grid;\n            grid-template-columns: repeat(3, 1fr);\n            gap: 20px;\n            margin: 20px 0;\n            text-align: center;\n        }\n        .stat {\n            background: #e9ecef;\n            padding: 15px;\n            border-radius: 5px;\n        }\n        .stat-value {\n            font-size: 24px;\n            font-weight: bold;\n            color: #007bff;\n        }\n        .code-section {\n            margin-top: 30px;\n            padding: 20px;\n            background: #f8f9fa;\n            border-radius: 5px;\n        }\n        .code {\n            background: #2d3748;\n            color: #e2e8f0;\n            padding: 15px;\n            border-radius: 5px;\n            font-family: 'Courier New', monospace;\n            white-space: pre-wrap;\n            overflow-x: auto;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>🫧 Bubble Sort Visualization</h1>\n        \n        <div class=\"controls\">\n            <button onclick=\"generateArray()\">Generate New Array</button>\n            <button onclick=\"startSort()\" id=\"sortBtn\">Start Bubble Sort</button>\n            <button onclick=\"resetArray()\" id=\"resetBtn\">Reset</button>\n            <label for=\"speed\">Speed: </label>\n            <input type=\"range\" id=\"speed\" min=\"1\" max=\"10\" value=\"5\" style=\"width: 100px;\">\n        </div>\n\n        <div class=\"info\" id=\"info\">Click \"Generate New Array\" to begin</div>\n\n        <div class=\"stats\">\n            <div class=\"stat\">\n                <div class=\"stat-value\" id=\"comparisons\">0</div>\n                <div>Comparisons</div>\n            </div>\n            <div class=\"stat\">\n                <div class=\"stat-value\" id=\"swaps\">0</div>\n                <div>Swaps</div>\n            </div>\n            <div class=\"stat\">\n                <div class=\"stat-value\" id=\"passes\">0</div>\n                <div>Passes</div>\n            </div>\n        </div>\n\n        <div class=\"array-container\" id=\"arrayContainer\"></div>\n\n        <div class=\"code-section\">\n            <h3>Bubble Sort Algorithm:</h3>\n            <div class=\"code\">function bubbleSort(arr) {\n    let n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n        let swapped = false;\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // Swap elements\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n                swapped = true;\n            }\n        }\n        // If no swapping occurred, array is sorted\n        if (!swapped) break;\n    }\n    return arr;\n}</div>\n        </div>\n    </div>\n\n    <script>\n        let array = [];\n        let isRunning = false;\n        let comparisons = 0;\n        let swaps = 0;\n        let passes = 0;\n\n        function generateArray() {\n            array = [];\n            const size = 12;\n            for (let i = 0; i < size; i++) {\n                array.push(Math.floor(Math.random() * 250) + 10);\n            }\n            resetStats();\n            renderArray();\n            document.getElementById('info').textContent = `Generated array with ${size} elements`;\n        }\n\n        function resetStats() {\n            comparisons = 0;\n            swaps = 0;\n            passes = 0;\n            updateStats();\n        }\n\n        function updateStats() {\n            document.getElementById('comparisons').textContent = comparisons;\n            document.getElementById('swaps').textContent = swaps;\n            document.getElementById('passes').textContent = passes;\n        }\n\n        function renderArray() {\n            const container = document.getElementById('arrayContainer');\n            container.innerHTML = '';\n            \n            array.forEach((value, index) => {\n                const bar = document.createElement('div');\n                bar.className = 'bar';\n                bar.style.height = `${value}px`;\n                bar.textContent = value;\n                bar.id = `bar-${index}`;\n                container.appendChild(bar);\n            });\n        }\n\n        function resetArray() {\n            if (isRunning) return;\n            \n            const bars = document.querySelectorAll('.bar');\n            bars.forEach(bar => {\n                bar.className = 'bar';\n            });\n            resetStats();\n            document.getElementById('info').textContent = 'Array reset to original state';\n        }\n\n        async function startSort() {\n            if (isRunning || array.length === 0) return;\n            \n            isRunning = true;\n            document.getElementById('sortBtn').disabled = true;\n            document.getElementById('resetBtn').disabled = true;\n            \n            const speed = 1100 - (document.getElementById('speed').value * 100);\n            \n            const n = array.length;\n            \n            for (let i = 0; i < n - 1; i++) {\n                passes++;\n                updateStats();\n                document.getElementById('info').textContent = `Pass ${passes}: Bubbling largest element to position ${n - i}`;\n                \n                let swapped = false;\n                \n                for (let j = 0; j < n - i - 1; j++) {\n                    // Highlight comparing elements\n                    document.getElementById(`bar-${j}`).classList.add('comparing');\n                    document.getElementById(`bar-${j + 1}`).classList.add('comparing');\n                    \n                    comparisons++;\n                    updateStats();\n                    \n                    await sleep(speed);\n                    \n                    if (array[j] > array[j + 1]) {\n                        // Highlight swapping elements\n                        document.getElementById(`bar-${j}`).classList.add('swapping');\n                        document.getElementById(`bar-${j + 1}`).classList.add('swapping');\n                        \n                        // Swap in array\n                        let temp = array[j];\n                        array[j] = array[j + 1];\n                        array[j + 1] = temp;\n                        swapped = true;\n                        swaps++;\n                        updateStats();\n                        \n                        await sleep(speed);\n                        \n                        // Re-render to show swap\n                        renderArray();\n                        \n                        // Re-apply classes after re-render\n                        document.getElementById(`bar-${j}`).classList.add('swapping');\n                        document.getElementById(`bar-${j + 1}`).classList.add('swapping');\n                        \n                        await sleep(speed);\n                        \n                        // Remove swapping class\n                        document.getElementById(`bar-${j}`).classList.remove('swapping');\n                        document.getElementById(`bar-${j + 1}`).classList.remove('swapping');\n                    }\n                    \n                    // Remove comparing class\n                    document.getElementById(`bar-${j}`).classList.remove('comparing');\n                    document.getElementById(`bar-${j + 1}`).classList.remove('comparing');\n                }\n                \n                // Mark the last element as sorted\n                document.getElementById(`bar-${n - i - 1}`).classList.add('sorted');\n                \n                // If no swapping occurred, array is sorted\n                if (!swapped) {\n                    // Mark remaining elements as sorted\n                    for (let k = 0; k < n - i - 1; k++) {\n                        document.getElementById(`bar-${k}`).classList.add('sorted');\n                    }\n                    break;\n                }\n                \n                await sleep(speed);\n            }\n            \n            // Mark first element as sorted if not already\n            if (array.length > 0) {\n                document.getElementById('bar-0').classList.add('sorted');\n            }\n            \n            document.getElementById('info').textContent = `✅ Sorting complete! Array is now sorted in ${passes} passes with ${comparisons} comparisons and ${swaps} swaps.`;\n            \n            isRunning = false;\n            document.getElementById('sortBtn').disabled = false;\n            document.getElementById('resetBtn').disabled = false;\n        }\n\n        function sleep(ms) {\n            return new Promise(resolve => setTimeout(resolve, ms));\n        }\n\n        // Initialize\n        generateArray();\n    </script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Bubble Sort"
      }
    ],
    "evaluation": {
      "score": 4,
      "notes": "功能性上小bug"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "b100cb20-9909-11f0-b669-13a2fc77cf62",
    "model": "claude-sonnet-4-20250514",
    "timestamp": "2025-09-24T05:45:35.187Z",
    "question": "Linked List",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Linked List Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        \n        .container {\n            background: white;\n            border-radius: 10px;\n            padding: 20px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        \n        h1 {\n            text-align: center;\n            color: #333;\n            margin-bottom: 30px;\n        }\n        \n        .controls {\n            display: flex;\n            gap: 10px;\n            margin-bottom: 20px;\n            flex-wrap: wrap;\n        }\n        \n        input[type=\"text\"] {\n            padding: 8px 12px;\n            border: 2px solid #ddd;\n            border-radius: 5px;\n            font-size: 14px;\n        }\n        \n        button {\n            padding: 8px 16px;\n            background: #007bff;\n            color: white;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n            font-size: 14px;\n            transition: background 0.3s;\n        }\n        \n        button:hover {\n            background: #0056b3;\n        }\n        \n        button:disabled {\n            background: #ccc;\n            cursor: not-allowed;\n        }\n        \n        .visualization {\n            min-height: 150px;\n            border: 2px dashed #ddd;\n            border-radius: 10px;\n            padding: 20px;\n            margin: 20px 0;\n            display: flex;\n            align-items: center;\n            justify-content: flex-start;\n            overflow-x: auto;\n            background: #fafafa;\n        }\n        \n        .node {\n            display: flex;\n            background: white;\n            border: 2px solid #007bff;\n            border-radius: 8px;\n            margin-right: 20px;\n            box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n            animation: nodeAppear 0.3s ease-out;\n        }\n        \n        @keyframes nodeAppear {\n            from { transform: scale(0); opacity: 0; }\n            to { transform: scale(1); opacity: 1; }\n        }\n        \n        .node-data {\n            padding: 15px 20px;\n            font-weight: bold;\n            font-size: 16px;\n            background: #007bff;\n            color: white;\n            min-width: 40px;\n            text-align: center;\n        }\n        \n        .node-pointer {\n            padding: 15px 20px;\n            background: #f8f9fa;\n            border-left: 2px solid #007bff;\n            font-family: monospace;\n            color: #666;\n        }\n        \n        .arrow {\n            display: flex;\n            align-items: center;\n            color: #007bff;\n            font-size: 20px;\n            font-weight: bold;\n            margin-right: 20px;\n        }\n        \n        .stats {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n            gap: 15px;\n            margin-top: 20px;\n        }\n        \n        .stat-item {\n            background: #e9ecef;\n            padding: 15px;\n            border-radius: 8px;\n            text-align: center;\n        }\n        \n        .stat-label {\n            font-size: 14px;\n            color: #666;\n            margin-bottom: 5px;\n        }\n        \n        .stat-value {\n            font-size: 24px;\n            font-weight: bold;\n            color: #007bff;\n        }\n        \n        .operations-log {\n            background: #f8f9fa;\n            border: 1px solid #dee2e6;\n            border-radius: 8px;\n            padding: 15px;\n            margin-top: 20px;\n            max-height: 200px;\n            overflow-y: auto;\n        }\n        \n        .log-item {\n            padding: 5px 0;\n            border-bottom: 1px solid #eee;\n            font-family: monospace;\n            font-size: 14px;\n        }\n        \n        .empty-message {\n            text-align: center;\n            color: #666;\n            font-style: italic;\n            padding: 40px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Linked List Data Structure</h1>\n        \n        <div class=\"controls\">\n            <input type=\"text\" id=\"valueInput\" placeholder=\"Enter value\" maxlength=\"10\">\n            <button onclick=\"addToHead()\">Add to Head</button>\n            <button onclick=\"addToTail()\">Add to Tail</button>\n            <button onclick=\"removeHead()\">Remove Head</button>\n            <button onclick=\"removeTail()\">Remove Tail</button>\n            <button onclick=\"clearList()\">Clear All</button>\n            <button onclick=\"findValue()\">Find Value</button>\n        </div>\n        \n        <div class=\"visualization\" id=\"visualization\">\n            <div class=\"empty-message\">Linked list is empty. Add some nodes to get started!</div>\n        </div>\n        \n        <div class=\"stats\">\n            <div class=\"stat-item\">\n                <div class=\"stat-label\">Length</div>\n                <div class=\"stat-value\" id=\"lengthStat\">0</div>\n            </div>\n            <div class=\"stat-item\">\n                <div class=\"stat-label\">Head Value</div>\n                <div class=\"stat-value\" id=\"headStat\">null</div>\n            </div>\n            <div class=\"stat-item\">\n                <div class=\"stat-label\">Tail Value</div>\n                <div class=\"stat-value\" id=\"tailStat\">null</div>\n            </div>\n            <div class=\"stat-item\">\n                <div class=\"stat-label\">Operations</div>\n                <div class=\"stat-value\" id=\"operationsStat\">0</div>\n            </div>\n        </div>\n        \n        <div class=\"operations-log\">\n            <h3>Operations Log</h3>\n            <div id=\"logContainer\"></div>\n        </div>\n    </div>\n\n    <script>\n        class Node {\n            constructor(data) {\n                this.data = data;\n                this.next = null;\n            }\n        }\n\n        class LinkedList {\n            constructor() {\n                this.head = null;\n                this.length = 0;\n            }\n\n            addToHead(data) {\n                const newNode = new Node(data);\n                newNode.next = this.head;\n                this.head = newNode;\n                this.length++;\n            }\n\n            addToTail(data) {\n                const newNode = new Node(data);\n                if (!this.head) {\n                    this.head = newNode;\n                } else {\n                    let current = this.head;\n                    while (current.next) {\n                        current = current.next;\n                    }\n                    current.next = newNode;\n                }\n                this.length++;\n            }\n\n            removeHead() {\n                if (!this.head) return null;\n                const removedData = this.head.data;\n                this.head = this.head.next;\n                this.length--;\n                return removedData;\n            }\n\n            removeTail() {\n                if (!this.head) return null;\n                \n                if (!this.head.next) {\n                    const removedData = this.head.data;\n                    this.head = null;\n                    this.length--;\n                    return removedData;\n                }\n\n                let current = this.head;\n                while (current.next && current.next.next) {\n                    current = current.next;\n                }\n                const removedData = current.next.data;\n                current.next = null;\n                this.length--;\n                return removedData;\n            }\n\n            find(data) {\n                let current = this.head;\n                let index = 0;\n                while (current) {\n                    if (current.data === data) {\n                        return index;\n                    }\n                    current = current.next;\n                    index++;\n                }\n                return -1;\n            }\n\n            clear() {\n                this.head = null;\n                this.length = 0;\n            }\n\n            getTail() {\n                if (!this.head) return null;\n                let current = this.head;\n                while (current.next) {\n                    current = current.next;\n                }\n                return current.data;\n            }\n        }\n\n        const linkedList = new LinkedList();\n        let operationsCount = 0;\n\n        function addToHead() {\n            const value = document.getElementById('valueInput').value.trim();\n            if (!value) {\n                alert('Please enter a value');\n                return;\n            }\n            \n            linkedList.addToHead(value);\n            operationsCount++;\n            logOperation(`Added \"${value}\" to head`);\n            document.getElementById('valueInput').value = '';\n            updateVisualization();\n        }\n\n        function addToTail() {\n            const value = document.getElementById('valueInput').value.trim();\n            if (!value) {\n                alert('Please enter a value');\n                return;\n            }\n            \n            linkedList.addToTail(value);\n            operationsCount++;\n            logOperation(`Added \"${value}\" to tail`);\n            document.getElementById('valueInput').value = '';\n            updateVisualization();\n        }\n\n        function removeHead() {\n            const removedValue = linkedList.removeHead();\n            if (removedValue !== null) {\n                operationsCount++;\n                logOperation(`Removed \"${removedValue}\" from head`);\n                updateVisualization();\n            } else {\n                alert('List is empty');\n            }\n        }\n\n        function removeTail() {\n            const removedValue = linkedList.removeTail();\n            if (removedValue !== null) {\n                operationsCount++;\n                logOperation(`Removed \"${removedValue}\" from tail`);\n                updateVisualization();\n            } else {\n                alert('List is empty');\n            }\n        }\n\n        function findValue() {\n            const value = document.getElementById('valueInput').value.trim();\n            if (!value) {\n                alert('Please enter a value to find');\n                return;\n            }\n            \n            const index = linkedList.find(value);\n            operationsCount++;\n            if (index !== -1) {\n                logOperation(`Found \"${value}\" at index ${index}`);\n                highlightNode(index);\n            } else {\n                logOperation(`\"${value}\" not found in list`);\n            }\n        }\n\n        function clearList() {\n            linkedList.clear();\n            operationsCount++;\n            logOperation('Cleared entire list');\n            updateVisualization();\n        }\n\n        function updateVisualization() {\n            const visualization = document.getElementById('visualization');\n            \n            if (linkedList.length === 0) {\n                visualization.innerHTML = '<div class=\"empty-message\">Linked list is empty. Add some nodes to get started!</div>';\n            } else {\n                let html = '';\n                let current = linkedList.head;\n                let index = 0;\n                \n                while (current) {\n                    html += `\n                        <div class=\"node\" id=\"node-${index}\">\n                            <div class=\"node-data\">${current.data}</div>\n                            <div class=\"node-pointer\">${current.next ? 'next' : 'null'}</div>\n                        </div>\n                    `;\n                    \n                    if (current.next) {\n                        html += '<div class=\"arrow\">→</div>';\n                    }\n                    \n                    current = current.next;\n                    index++;\n                }\n                \n                visualization.innerHTML = html;\n            }\n            \n            updateStats();\n        }\n\n        function updateStats() {\n            document.getElementById('lengthStat').textContent = linkedList.length;\n            document.getElementById('headStat').textContent = linkedList.head ? linkedList.head.data : 'null';\n            document.getElementById('tailStat').textContent = linkedList.getTail() || 'null';\n            document.getElementById('operationsStat').textContent = operationsCount;\n        }\n\n        function logOperation(operation) {\n            const logContainer = document.getElementById('logContainer');\n            const timestamp = new Date().toLocaleTimeString();\n            const logItem = document.createElement('div');\n            logItem.className = 'log-item';\n            logItem.textContent = `[${timestamp}] ${operation}`;\n            logContainer.insertBefore(logItem, logContainer.firstChild);\n            \n            // Keep only last 20 operations\n            while (logContainer.children.length > 20) {\n                logContainer.removeChild(logContainer.lastChild);\n            }\n        }\n\n        function highlightNode(index) {\n            // Remove previous highlights\n            document.querySelectorAll('.node').forEach(node => {\n                node.style.background = 'white';\n                node.style.borderColor = '#007bff';\n            });\n            \n            // Highlight found node\n            const nodeElement = document.getElementById(`node-${index}`);\n            if (nodeElement) {\n                nodeElement.style.background = '#fff3cd';\n                nodeElement.style.borderColor = '#ffc107';\n                \n                // Remove highlight after 2 seconds\n                setTimeout(() => {\n                    nodeElement.style.background = 'white';\n                    nodeElement.style.borderColor = '#007bff';\n                }, 2000);\n            }\n        }\n\n        // Allow Enter key to add to tail\n        document.getElementById('valueInput').addEventListener('keypress', function(e) {\n            if (e.key === 'Enter') {\n                addToTail();\n            }\n        });\n\n        // Initialize with some sample data\n        linkedList.addToTail('A');\n        linkedList.addToTail('B');\n        linkedList.addToTail('C');\n        operationsCount = 3;\n        logOperation('Initialized with sample data: A → B → C');\n        updateVisualization();\n    </script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "Linked List"
      }
    ],
    "evaluation": {
      "score": 5,
      "notes": "很棒了"
    },
    "tags": [
      "9/24"
    ]
  },
  {
    "id": "e738cc60-9909-11f0-86f7-4da6279a7fa0",
    "model": "claude-sonnet-4-20250514",
    "timestamp": "2025-09-24T05:47:06.150Z",
    "question": "K-means clustering",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>K-Means Clustering Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 20px;\n            background-color: #f0f0f0;\n        }\n        .container {\n            max-width: 1000px;\n            margin: 0 auto;\n            background: white;\n            padding: 20px;\n            border-radius: 10px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        .controls {\n            margin-bottom: 20px;\n            display: flex;\n            gap: 15px;\n            align-items: center;\n            flex-wrap: wrap;\n        }\n        button {\n            padding: 10px 15px;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n            font-size: 14px;\n            transition: background-color 0.3s;\n        }\n        .primary-btn {\n            background-color: #4CAF50;\n            color: white;\n        }\n        .primary-btn:hover {\n            background-color: #45a049;\n        }\n        .secondary-btn {\n            background-color: #2196F3;\n            color: white;\n        }\n        .secondary-btn:hover {\n            background-color: #1976D2;\n        }\n        .danger-btn {\n            background-color: #f44336;\n            color: white;\n        }\n        .danger-btn:hover {\n            background-color: #d32f2f;\n        }\n        input[type=\"number\"] {\n            width: 60px;\n            padding: 5px;\n            border: 1px solid #ccc;\n            border-radius: 3px;\n        }\n        canvas {\n            border: 2px solid #333;\n            cursor: crosshair;\n            display: block;\n            margin: 0 auto;\n        }\n        .info {\n            margin-top: 15px;\n            padding: 10px;\n            background-color: #e3f2fd;\n            border-radius: 5px;\n            font-size: 14px;\n        }\n        .iteration-counter {\n            font-weight: bold;\n            color: #1976D2;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>K-Means Clustering Visualization</h1>\n        \n        <div class=\"controls\">\n            <label>K (clusters): <input type=\"number\" id=\"kValue\" value=\"3\" min=\"1\" max=\"8\"></label>\n            <button class=\"secondary-btn\" onclick=\"generateRandomPoints()\">Generate Random Points</button>\n            <button class=\"primary-btn\" onclick=\"startKMeans()\">Start K-Means</button>\n            <button class=\"secondary-btn\" onclick=\"stepKMeans()\">Step Through</button>\n            <button class=\"danger-btn\" onclick=\"clearCanvas()\">Clear All</button>\n        </div>\n        \n        <canvas id=\"canvas\" width=\"800\" height=\"600\"></canvas>\n        \n        <div class=\"info\">\n            <div class=\"iteration-counter\" id=\"iterationCounter\">Iteration: 0</div>\n            <p><strong>Instructions:</strong></p>\n            <ul>\n                <li>Click on the canvas to add data points</li>\n                <li>Set the number of clusters (K) and click \"Start K-Means\"</li>\n                <li>Use \"Step Through\" to see the algorithm progress step by step</li>\n                <li>Watch as centroids (large circles) move and points get assigned to clusters</li>\n            </ul>\n            <p><strong>Colors:</strong> Each cluster is represented by a different color. Centroids are large circles, data points are small circles.</p>\n        </div>\n    </div>\n\n    <script>\n        class KMeansVisualizer {\n            constructor() {\n                this.canvas = document.getElementById('canvas');\n                this.ctx = this.canvas.getContext('2d');\n                this.points = [];\n                this.centroids = [];\n                this.clusters = [];\n                this.k = 3;\n                this.iteration = 0;\n                this.isRunning = false;\n                this.colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'];\n                \n                this.canvas.addEventListener('click', (e) => this.addPoint(e));\n                this.setupCanvas();\n            }\n            \n            setupCanvas() {\n                this.ctx.fillStyle = '#ffffff';\n                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n            }\n            \n            addPoint(e) {\n                if (this.isRunning) return;\n                \n                const rect = this.canvas.getBoundingClientRect();\n                const x = e.clientX - rect.left;\n                const y = e.clientY - rect.top;\n                \n                this.points.push({x, y, cluster: -1});\n                this.drawPoints();\n            }\n            \n            generateRandomPoints(count = 30) {\n                if (this.isRunning) return;\n                \n                this.points = [];\n                for (let i = 0; i < count; i++) {\n                    this.points.push({\n                        x: Math.random() * (this.canvas.width - 40) + 20,\n                        y: Math.random() * (this.canvas.height - 40) + 20,\n                        cluster: -1\n                    });\n                }\n                this.drawPoints();\n            }\n            \n            initializeCentroids() {\n                this.centroids = [];\n                for (let i = 0; i < this.k; i++) {\n                    this.centroids.push({\n                        x: Math.random() * (this.canvas.width - 40) + 20,\n                        y: Math.random() * (this.canvas.height - 40) + 20\n                    });\n                }\n            }\n            \n            distance(p1, p2) {\n                return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n            }\n            \n            assignPointsToClusters() {\n                let changed = false;\n                \n                for (let point of this.points) {\n                    let minDistance = Infinity;\n                    let closestCluster = 0;\n                    \n                    for (let i = 0; i < this.centroids.length; i++) {\n                        const dist = this.distance(point, this.centroids[i]);\n                        if (dist < minDistance) {\n                            minDistance = dist;\n                            closestCluster = i;\n                        }\n                    }\n                    \n                    if (point.cluster !== closestCluster) {\n                        changed = true;\n                        point.cluster = closestCluster;\n                    }\n                }\n                \n                return changed;\n            }\n            \n            updateCentroids() {\n                const newCentroids = [];\n                \n                for (let i = 0; i < this.k; i++) {\n                    const clusterPoints = this.points.filter(p => p.cluster === i);\n                    \n                    if (clusterPoints.length > 0) {\n                        const sumX = clusterPoints.reduce((sum, p) => sum + p.x, 0);\n                        const sumY = clusterPoints.reduce((sum, p) => sum + p.y, 0);\n                        \n                        newCentroids.push({\n                            x: sumX / clusterPoints.length,\n                            y: sumY / clusterPoints.length\n                        });\n                    } else {\n                        // Keep the old centroid if no points assigned\n                        newCentroids.push({...this.centroids[i]});\n                    }\n                }\n                \n                this.centroids = newCentroids;\n            }\n            \n            drawPoints() {\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                this.setupCanvas();\n                \n                // Draw points\n                for (let point of this.points) {\n                    this.ctx.fillStyle = point.cluster >= 0 ? this.colors[point.cluster % this.colors.length] : '#666666';\n                    this.ctx.beginPath();\n                    this.ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);\n                    this.ctx.fill();\n                    this.ctx.strokeStyle = '#333333';\n                    this.ctx.lineWidth = 1;\n                    this.ctx.stroke();\n                }\n                \n                // Draw centroids\n                for (let i = 0; i < this.centroids.length; i++) {\n                    const centroid = this.centroids[i];\n                    this.ctx.fillStyle = this.colors[i % this.colors.length];\n                    this.ctx.beginPath();\n                    this.ctx.arc(centroid.x, centroid.y, 15, 0, 2 * Math.PI);\n                    this.ctx.fill();\n                    this.ctx.strokeStyle = '#000000';\n                    this.ctx.lineWidth = 3;\n                    this.ctx.stroke();\n                    \n                    // Draw cross in centroid\n                    this.ctx.strokeStyle = '#000000';\n                    this.ctx.lineWidth = 2;\n                    this.ctx.beginPath();\n                    this.ctx.moveTo(centroid.x - 6, centroid.y);\n                    this.ctx.lineTo(centroid.x + 6, centroid.y);\n                    this.ctx.moveTo(centroid.x, centroid.y - 6);\n                    this.ctx.lineTo(centroid.x, centroid.y + 6);\n                    this.ctx.stroke();\n                }\n            }\n            \n            async startKMeans() {\n                if (this.points.length === 0) {\n                    alert('Please add some points first!');\n                    return;\n                }\n                \n                this.k = parseInt(document.getElementById('kValue').value);\n                this.isRunning = true;\n                this.iteration = 0;\n                \n                this.initializeCentroids();\n                this.drawPoints();\n                \n                let maxIterations = 100;\n                let converged = false;\n                \n                while (!converged && this.iteration < maxIterations) {\n                    await this.sleep(500); // Pause for visualization\n                    \n                    const changed = this.assignPointsToClusters();\n                    this.updateCentroids();\n                    this.iteration++;\n                    \n                    document.getElementById('iterationCounter').textContent = `Iteration: ${this.iteration}`;\n                    this.drawPoints();\n                    \n                    if (!changed) {\n                        converged = true;\n                        alert(`K-Means converged after ${this.iteration} iterations!`);\n                    }\n                }\n                \n                if (this.iteration >= maxIterations) {\n                    alert(`K-Means stopped after ${maxIterations} iterations (max limit reached)`);\n                }\n                \n                this.isRunning = false;\n            }\n            \n            stepKMeans() {\n                if (this.points.length === 0) {\n                    alert('Please add some points first!');\n                    return;\n                }\n                \n                if (this.iteration === 0) {\n                    this.k = parseInt(document.getElementById('kValue').value);\n                    this.initializeCentroids();\n                }\n                \n                const changed = this.assignPointsToClusters();\n                this.updateCentroids();\n                this.iteration++;\n                \n                document.getElementById('iterationCounter').textContent = `Iteration: ${this.iteration}`;\n                this.drawPoints();\n                \n                if (!changed) {\n                    alert(`K-Means converged after ${this.iteration} iterations!`);\n                }\n            }\n            \n            clearCanvas() {\n                this.points = [];\n                this.centroids = [];\n                this.clusters = [];\n                this.iteration = 0;\n                this.isRunning = false;\n                document.getElementById('iterationCounter').textContent = 'Iteration: 0';\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                this.setupCanvas();\n            }\n            \n            sleep(ms) {\n                return new Promise(resolve => setTimeout(resolve, ms));\n            }\n        }\n        \n        // Initialize the visualizer\n        const kmeans = new KMeansVisualizer();\n        \n        // Bind functions to global scope for HTML onclick handlers\n        window.generateRandomPoints = () => kmeans.generateRandomPoints();\n        window.startKMeans = () => kmeans.startKMeans();\n        window.stepKMeans = () => kmeans.stepKMeans();\n        window.clearCanvas = () => kmeans.clearCanvas();\n        \n        // Generate some initial random points\n        kmeans.generateRandomPoints(25);\n    </script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
      },
      {
        "role": "user",
        "content": "K-means clustering"
      }
    ],
    "evaluation": {
      "score": 4,
      "notes": "看着应该没问题"
    },
    "tags": [
      "9/24"
    ]
  }
]