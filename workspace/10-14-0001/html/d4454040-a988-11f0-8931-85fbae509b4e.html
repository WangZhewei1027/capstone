<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Bubble Sort Lab — Interactive Visualization and Practice</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg: #0e1116;
      --panel: #171b21;
      --accent: #4cc9f0;
      --accent-2: #bde0fe;
      --green: #59d48e;
      --red: #ff6b6b;
      --yellow: #ffd166;
      --text: #eaeef3;
      --muted: #c6ced9;
      --border: #242c36;
      --highlight: #2e3440;
      --bar: #6fa8dc;
      --bar2: #80ed99;
      --barDup: #cdb4db;
      --sortedShade: rgba(89, 212, 142, 0.18);
    }

    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px;
      display: grid;
      gap: 16px;
      grid-template-columns: 1fr;
    }

    header h1 {
      margin: 0 0 6px 0;
      font-weight: 700;
      letter-spacing: 0.3px;
    }
    header p {
      margin: 0;
      color: var(--muted);
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 16px;
    }
    @media (max-width: 980px) {
      .layout { grid-template-columns: 1fr; }
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
    }
    .panel h2 {
      margin: 0 0 8px 0;
      font-size: 1rem;
      color: var(--accent-2);
    }

    .controls {
      display: grid;
      gap: 10px;
    }

    .control-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 640px) {
      .control-row { grid-template-columns: 1fr; }
    }

    .group {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: #12161c;
    }
    .group h3 {
      margin: 0 0 8px 0;
      font-size: 0.95rem;
      color: var(--muted);
      font-weight: 600;
    }

    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .row label { font-size: 0.9rem; color: var(--muted); }
    .row input[type="number"], .row input[type="text"], .row select {
      background: #0b0f14;
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      padding: 6px 8px;
      min-width: 0;
    }
    .row input[type="range"] {
      width: 160px;
    }

    .btn {
      background: #18202a;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      cursor: pointer;
      font-weight: 600;
    }
    .btn:hover { background: #202836; }
    .btn.primary { background: var(--accent); color: #001018; border: none; }
    .btn.primary:hover { filter: brightness(1.1); }
    .btn.danger { background: #2a1616; color: #ffb3b3; border: 1px solid #522; }
    .btn.success { background: #122218; color: #9ff0c1; border: 1px solid #1f3e2c; }
    .btn.ghost { background: transparent; border: 1px dashed var(--border); }
    .btn.small { padding: 6px 10px; font-size: 0.9rem; }
    .btn:disabled { opacity: 0.5; cursor: default; }

    .viz-panel {
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      gap: 8px;
      min-height: 420px;
    }

    .legend {
      display: flex;
      align-items: center;
      gap: 14px;
      flex-wrap: wrap;
      font-size: 0.9rem;
    }
    .badge { display: inline-flex; align-items: center; gap: 6px; }
    .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; }
    .dot.compare { background: var(--yellow); }
    .dot.swap { background: var(--red); }
    .dot.sorted { background: var(--green); }
    .dot.boundary { background: var(--accent); }

    .array-container {
      position: relative;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: linear-gradient(180deg, #0d1217 0, #0a0f14 100%);
      padding: 16px 16px 24px 16px;
      overflow: hidden;
      min-height: 280px;
    }

    .bars {
      position: relative;
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: minmax(24px, 1fr);
      gap: 8px;
      align-items: end;
      height: 100%;
    }

    .bar {
      position: relative;
      border-radius: 6px 6px 0 0;
      background: linear-gradient(160deg, var(--bar) 0, #4d7eb3 100%);
      transition: background 0.2s ease;
      outline: 1px solid rgba(255,255,255,0.04);
      will-change: transform, background;
    }
    .bar.dup {
      background: linear-gradient(160deg, var(--barDup) 0, #a98fb6 100%);
    }
    .bar.compare {
      box-shadow: 0 0 0 2px var(--yellow) inset, 0 0 12px rgba(255, 209, 102, 0.4);
    }
    .bar.swapping {
      box-shadow: 0 0 0 2px var(--red) inset, 0 0 12px rgba(255, 107, 107, 0.5);
    }
    .bar.sorted-tail {
      background: linear-gradient(160deg, var(--bar2) 0, #52b788 100%);
      box-shadow: 0 0 0 2px var(--green) inset;
      opacity: 0.9;
    }

    .bar .value {
      position: absolute;
      top: -18px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.9rem;
      color: var(--muted);
      user-select: none;
    }
    .bar .label {
      position: absolute;
      bottom: 6px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      font-weight: 700;
      color: rgba(0, 0, 0, 0.7);
      background: rgba(255,255,255,0.8);
      padding: 2px 6px;
      border-radius: 999px;
      user-select: none;
    }

    .unsorted-boundary {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      pointer-events: none;
      height: 100%;
    }
    .unsorted-boundary::after {
      content: "";
      position: absolute;
      bottom: 0;
      right: 0;
      width: var(--boundary-width, 0%);
      height: 100%;
      background: linear-gradient(90deg, transparent 0, transparent 60%, var(--sortedShade) 90%);
    }

    .timeline {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .timeline input[type="range"] { width: 240px; }
    .key {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .side {
      display: grid;
      gap: 12px;
    }

    .stats {
      display: grid;
      gap: 6px;
      font-size: 0.95rem;
    }
    .stats .kv {
      display: flex; justify-content: space-between; align-items: baseline;
      border-bottom: 1px dotted var(--border);
      padding-bottom: 6px;
    }
    .stats .kv .k { color: var(--muted); }
    .stats .kv .v { font-weight: 700; }

    .code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: #0b0f14;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      line-height: 1.4;
      font-size: 0.9rem;
      position: relative;
    }
    .line { padding: 2px 6px; border-left: 4px solid transparent; }
    .line.active { background: #141a21; border-left-color: var(--accent); }
    .line.comment { color: #9aa7b4; }

    .explain {
      background: #10151b;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .explain ul {
      margin: 6px 0 0 18px;
    }

    .footer {
      color: var(--muted);
      font-size: 0.9rem;
    }
    .kbd {
      display: inline-block;
      background: #0b0f14;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 2px 6px;
      font-family: monospace;
      margin: 0 2px;
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <h1>Bubble Sort Lab</h1>
      <p>Hands-on exploration of Bubble Sort with step-by-step visualization, controls, and guided practice.</p>
    </header>

    <div class="layout">
      <div class="panel viz-panel">
        <div class="legend">
          <span class="badge"><span class="dot compare"></span> comparing</span>
          <span class="badge"><span class="dot swap"></span> swapping</span>
          <span class="badge"><span class="dot sorted"></span> sorted tail</span>
          <span class="badge"><span class="dot boundary"></span> unsorted boundary</span>
        </div>

        <div class="array-container" id="arrayContainer" aria-label="Array visualization">
          <div class="unsorted-boundary" id="boundary"></div>
          <div class="bars" id="bars"></div>
        </div>

        <div class="timeline">
          <button class="btn small" id="prevBtn" title="Previous step (Left arrow)">⟵ Prev</button>
          <button class="btn small primary" id="playBtn" title="Play/Pause (Space)">▶ Play</button>
          <button class="btn small" id="nextBtn" title="Next step (Right arrow)">Next ⟶</button>
          <button class="btn small ghost" id="resetBtn" title="Reset to step 0 (R)">⟲ Reset</button>
          <label class="key">Speed</label>
          <input type="range" min="0.2" max="3" step="0.1" value="1" id="speedRange" />
          <label class="key">Step</label>
          <input type="range" min="0" max="0" value="0" id="stepRange" />
        </div>

        <div class="controls panel">
          <div class="control-row">
            <div class="group">
              <h3>Data</h3>
              <div class="row">
                <label>Length</label>
                <input type="number" id="lenInput" min="3" max="40" value="12" />
                <label>Min</label>
                <input type="number" id="minInput" min="-99" max="99" value="1" />
                <label>Max</label>
                <input type="number" id="maxInput" min="-99" max="99" value="99" />
                <label><input type="checkbox" id="dupsInput" checked /> allow duplicates</label>
              </div>
              <div class="row">
                <button class="btn small" id="randBtn">Random</button>
                <button class="btn small" id="nearlyBtn">Nearly sorted</button>
                <button class="btn small" id="sortedBtn">Sorted</button>
                <button class="btn small" id="reversedBtn">Reversed</button>
              </div>
              <div class="row">
                <label>Values (CSV)</label>
                <input type="text" id="csvInput" placeholder="e.g., 5,1,4,2,8" style="flex: 1;" />
                <button class="btn small" id="applyCsvBtn">Apply</button>
              </div>
            </div>

            <div class="group">
              <h3>Algorithm</h3>
              <div class="row">
                <label>Order</label>
                <select id="orderSelect">
                  <option value="asc">Ascending</option>
                  <option value="desc">Descending</option>
                </select>
                <label>Variant</label>
                <select id="variantSelect">
                  <option value="classic">Classic</option>
                  <option value="optimized">Optimized (last swap boundary)</option>
                </select>
              </div>
              <div class="row">
                <label><input type="checkbox" id="stableToggle" checked /> stable (no swap on equals)</label>
                <label><input type="checkbox" id="predictToggle" /> practice: predict next step</label>
              </div>
              <div class="row" id="predictRow" style="display:none;">
                <button class="btn small success" id="predictSwapBtn">I think it swaps</button>
                <button class="btn small danger" id="predictNoSwapBtn">No swap</button>
                <span id="predictFeedback" style="margin-left:8px;"></span>
              </div>
            </div>
          </div>
        </div>

        <div class="explain">
          Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are out of order. After each pass, the largest remaining element "bubbles" to its correct position at the end.
          Try:
          <ul>
            <li>Generate a nearly-sorted array and enable the optimized variant. Observe the shrinking boundary.</li>
            <li>Add duplicates and keep "stable" checked. Watch labels to confirm equal items preserve order.</li>
            <li>Switch to descending order. Bubble sort works the same with a reversed comparison.</li>
          </ul>
        </div>
      </div>

      <div class="side">
        <div class="panel">
          <h2>Stats</h2>
          <div class="stats">
            <div class="kv"><span class="k">Pass</span><span class="v" id="passStat">0</span></div>
            <div class="kv"><span class="k">Inner index j</span><span class="v" id="jStat">–</span></div>
            <div class="kv"><span class="k">Comparisons</span><span class="v" id="cmpStat">0</span></div>
            <div class="kv"><span class="k">Swaps</span><span class="v" id="swapStat">0</span></div>
            <div class="kv"><span class="k">Early exit</span><span class="v" id="exitStat">no</span></div>
            <div class="kv"><span class="k">Boundary</span><span class="v" id="boundaryStat">–</span></div>
            <div class="kv"><span class="k">Stable check</span><span class="v" id="stableStat">ok</span></div>
          </div>
        </div>

        <div class="panel">
          <h2>Pseudocode</h2>
          <div class="code" id="codeBlock">
            <div class="line comment">// Classic bubble sort with early exit</div>
            <div class="line" data-line="c1">repeat</div>
            <div class="line" data-line="c2">  swapped ← false</div>
            <div class="line" data-line="c3">  for j ← 0 to n - 2</div>
            <div class="line" data-line="c4">    if needsSwap(a[j], a[j+1])</div>
            <div class="line" data-line="c5">      swap(a[j], a[j+1])</div>
            <div class="line" data-line="c6">      swapped ← true</div>
            <div class="line" data-line="c7">until swapped = false</div>
            <div style="height:8px"></div>
            <div class="line comment">// Optimized: shrink inner loop to last swap index</div>
            <div class="line" data-line="o1">end ← n - 1</div>
            <div class="line" data-line="o2">repeat</div>
            <div class="line" data-line="o3">  swapped ← false</div>
            <div class="line" data-line="o4">  lastSwap ← 0</div>
            <div class="line" data-line="o5">  for j ← 0 to end - 1</div>
            <div class="line" data-line="o6">    if needsSwap(a[j], a[j+1])</div>
            <div class="line" data-line="o7">      swap; swapped ← true</div>
            <div class="line" data-line="o8">      lastSwap ← j + 1</div>
            <div class="line" data-line="o9">  end ← lastSwap</div>
            <div class="line" data-line="o10">until swapped = false</div>
          </div>
        </div>

        <div class="panel explain">
          Complexity:
          <ul>
            <li>Worst case: O(n²) comparisons, O(n²) swaps</li>
            <li>Best case (already sorted, early exit): O(n) comparisons, 0 swaps</li>
            <li>Stable when equal elements are not swapped</li>
          </ul>
          Keyboard:
          <ul>
            <li>Space: Play/Pause</li>
            <li>Left/Right: Prev/Next step</li>
            <li>R: Reset timeline</li>
            <li>S: Random data</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="footer">
      Built for learning: experiment, predict, and observe the bubble effect, boundary shrinking, and stability with duplicates.
    </div>
  </div>

  <script>
    // Bubble Sort Lab: interactive, step-by-step visualization
    // Data model: each item { id, value, label }
    // Steps: sequence of { pass, j, willSwap, boundaryAfterPass, variantContext, arraySnapshot }

    const barsEl = document.getElementById('bars');
    const boundaryEl = document.getElementById('boundary');
    const passStat = document.getElementById('passStat');
    const jStat = document.getElementById('jStat');
    const cmpStat = document.getElementById('cmpStat');
    const swapStat = document.getElementById('swapStat');
    const exitStat = document.getElementById('exitStat');
    const boundaryStat = document.getElementById('boundaryStat');
    const stableStat = document.getElementById('stableStat');

    const lenInput = document.getElementById('lenInput');
    const minInput = document.getElementById('minInput');
    const maxInput = document.getElementById('maxInput');
    const dupsInput = document.getElementById('dupsInput');
    const csvInput = document.getElementById('csvInput');

    const randBtn = document.getElementById('randBtn');
    const nearlyBtn = document.getElementById('nearlyBtn');
    const sortedBtn = document.getElementById('sortedBtn');
    const reversedBtn = document.getElementById('reversedBtn');
    const applyCsvBtn = document.getElementById('applyCsvBtn');

    const orderSelect = document.getElementById('orderSelect');
    const variantSelect = document.getElementById('variantSelect');
    const stableToggle = document.getElementById('stableToggle');
    const predictToggle = document.getElementById('predictToggle');
    const predictRow = document.getElementById('predictRow');
    const predictSwapBtn = document.getElementById('predictSwapBtn');
    const predictNoSwapBtn = document.getElementById('predictNoSwapBtn');
    const predictFeedback = document.getElementById('predictFeedback');

    const prevBtn = document.getElementById('prevBtn');
    const playBtn = document.getElementById('playBtn');
    const nextBtn = document.getElementById('nextBtn');
    const resetBtn = document.getElementById('resetBtn');
    const stepRange = document.getElementById('stepRange');
    const speedRange = document.getElementById('speedRange');
    const codeBlock = document.getElementById('codeBlock');

    let data = []; // array of items
    let baseOrderLabels = []; // track base labels order by value to check stability
    let steps = []; // array of step objects
    let stepIndex = 0;
    let playing = false;
    let speed = 1.0;
    let order = 'asc';
    let variant = 'classic';
    let stableEquals = true;

    let comparisonsSoFar = 0;
    let swapsSoFar = 0;

    const sleep = ms => new Promise(r => setTimeout(r, ms));

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateRandomData(len, min, max, allowDups) {
      const arr = [];
      const used = new Set();
      let id = 1;
      while (arr.length < len) {
        const v = randInt(min, max);
        if (allowDups || !used.has(v)) {
          used.add(v);
          arr.push({ id: id++, value: v, label: idToLabel(id-1) });
        }
      }
      return arr;
    }

    function generateNearlySorted(len, min, max) {
      // create sorted and perform a few random small swaps
      const values = [];
      for (let i=0;i<len;i++) values.push(randInt(min, max));
      values.sort((a,b)=>a-b);
      const arr = values.map((v, idx)=>({ id: idx+1, value: v, label: idToLabel(idx+1) }));
      for (let k=0;k<Math.min(5, Math.floor(len/2));k++) {
        const i = randInt(0, len-2);
        const j = i+1;
        const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
      }
      return arr;
    }

    function generateSorted(len, min, max, descending=false) {
      const values = [];
      for (let i=0;i<len;i++) values.push(randInt(min, max));
      values.sort((a,b)=>descending ? b-a : a-b);
      return values.map((v, idx)=>({ id: idx+1, value: v, label: idToLabel(idx+1) }));
    }

    function generateReversed(len, min, max) {
      const arr = generateSorted(len, min, max, true);
      return arr; // already reversed
    }

    function idToLabel(id) {
      // A, B, C ... Z, AA, AB ...
      const letters = [];
      id--;
      do {
        letters.push(String.fromCharCode(65 + (id % 26)));
        id = Math.floor(id / 26) - 1;
      } while (id >= 0);
      return letters.reverse().join('');
    }

    function drawArray(items) {
      barsEl.innerHTML = '';
      const maxVal = Math.max(...items.map(x=>x.value));
      const countPerValue = {};
      items.forEach(it => { countPerValue[it.value] = (countPerValue[it.value]||0)+1; });

      items.forEach((item, idx) => {
        const bar = document.createElement('div');
        bar.className = 'bar' + (countPerValue[item.value] > 1 ? ' dup' : '');
        bar.dataset.id = String(item.id);
        const heightPct = maxVal === 0 ? 5 : Math.max(5, Math.round((item.value / maxVal) * 100));
        bar.style.height = heightPct + '%';

        const v = document.createElement('div');
        v.className = 'value';
        v.textContent = item.value;

        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = item.label;

        bar.appendChild(v);
        bar.appendChild(label);
        barsEl.appendChild(bar);
      });
    }

    function compareValues(a, b) {
      if (order === 'asc') {
        if (stableEquals) return a.value > b.value;
        return a.value >= b.value; // intentionally unstable if equals
      } else {
        if (stableEquals) return a.value < b.value;
        return a.value <= b.value;
      }
    }

    function computeSteps(items) {
      // Build steps for the chosen variant; we copy the input to a working array
      const arr = items.map(x => ({...x}));
      const N = arr.length;
      const outSteps = [];
      let comparisons = 0;
      let swaps = 0;
      let earlyExit = false;
      let pass = 0;

      if (variant === 'classic') {
        while (true) {
          let swapped = false;
          for (let j = 0; j <= N - 2; j++) {
            const willSwap = compareValues(arr[j], arr[j+1]);
            comparisons++;
            outSteps.push({
              pass,
              j,
              willSwap,
              variant: 'classic',
              boundary: N - pass - 1, // after this pass, last element fixed
              snapshotBefore: arr.map(x => ({...x})),
            });
            if (willSwap) {
              swaps++;
              const tmp = arr[j];
              arr[j] = arr[j+1];
              arr[j+1] = tmp;
              outSteps[outSteps.length-1].snapshotAfter = arr.map(x => ({...x}));
            }
          }
          if (!swapped) {
            // check the pass last step to see if any willSwap happened
            const stepsThisPass = outSteps.filter(s => s.pass === pass);
            swapped = stepsThisPass.some(s => s.willSwap);
          }
          if (!swapped) { earlyExit = true; break; }
          pass++;
          if (pass >= N-1) break;
        }
      } else {
        let end = N - 1;
        while (true) {
          let swapped = false;
          let lastSwap = 0;
          for (let j = 0; j < end; j++) {
            const willSwap = compareValues(arr[j], arr[j+1]);
            comparisons++;
            outSteps.push({
              pass,
              j,
              willSwap,
              variant: 'optimized',
              boundary: end, // unsorted boundary at 'end'
              snapshotBefore: arr.map(x => ({...x})),
            });
            if (willSwap) {
              swaps++;
              const tmp = arr[j];
              arr[j] = arr[j+1];
              arr[j+1] = tmp;
              swapped = true;
              lastSwap = j + 1;
              outSteps[outSteps.length-1].snapshotAfter = arr.map(x => ({...x}));
            }
          }
          end = lastSwap;
          pass++;
          if (!swapped) { earlyExit = true; break; }
          if (end <= 0) break;
        }
      }

      // Append summary to the last step
      if (outSteps.length > 0) {
        const last = outSteps[outSteps.length-1];
        last.summary = { comparisons, swaps, earlyExit };
      }
      return outSteps;
    }

    function setBoundaryUI(step) {
      // For classic: boundary is N - pass - 1 (sorted tail size = pass+1)
      // For optimized: boundary = 'end' (unsorted boundary)
      const N = data.length;
      let sortedCount = 0;
      let boundaryIndex = null;

      if (!step) {
        boundaryEl.style.setProperty('--boundary-width', '0%');
        boundaryStat.textContent = '–';
        return;
      }

      if (step.variant === 'classic') {
        sortedCount = Math.max(0, step.pass);
        boundaryIndex = N - step.pass - 1;
        boundaryStat.textContent = `tail size: ${sortedCount}`;
      } else {
        boundaryIndex = step.boundary;
        sortedCount = N - boundaryIndex - 1;
        boundaryStat.textContent = `end: ${step.boundary}`;
      }
      const pct = Math.max(0, Math.min(100, ((sortedCount) / N) * 100));
      boundaryEl.style.setProperty('--boundary-width', pct + '%');
    }

    function clearHighlights() {
      Array.from(barsEl.children).forEach(bar => {
        bar.classList.remove('compare', 'swapping', 'sorted-tail');
        bar.style.transform = '';
      });
    }

    function applySnapshot(snapshot) {
      // Reorder DOM to match snapshot order; animate with FLIP
      const currentMap = {};
      Array.from(barsEl.children).forEach(el => {
        currentMap[el.dataset.id] = el;
      });

      const firstRects = {};
      Array.from(barsEl.children).forEach(el => {
        firstRects[el.dataset.id] = el.getBoundingClientRect();
      });

      // Rebuild DOM in new order
      const frag = document.createDocumentFragment();
      snapshot.forEach(item => {
        const el = currentMap[String(item.id)];
        frag.appendChild(el);
      });
      barsEl.appendChild(frag);

      const duration = 400 / speed; // ms
      Array.from(barsEl.children).forEach(el => {
        const lastRect = el.getBoundingClientRect();
        const firstRect = firstRects[el.dataset.id];
        const deltaX = firstRect.left - lastRect.left;
        el.style.transform = `translateX(${deltaX}px)`;
        el.style.transition = `transform ${duration}ms ease`;
        requestAnimationFrame(() => {
          el.style.transform = 'translateX(0)';
        });
      });

      setTimeout(() => {
        Array.from(barsEl.children).forEach(el => {
          el.style.transform = '';
          el.style.transition = '';
        });
      }, duration + 20);
    }

    async function renderStep(idx, runAnimation=true) {
      if (steps.length === 0) return;
      const step = steps[idx];
      const N = data.length;

      // Update stats
      const cmpCount = idx + 1; // each step is a comparison
      const swapCount = steps.slice(0, idx+1).filter(s => s.willSwap).length;
      comparisonsSoFar = cmpCount;
      swapsSoFar = swapCount;

      passStat.textContent = step.pass;
      jStat.textContent = step.j;
      cmpStat.textContent = comparisonsSoFar;
      swapStat.textContent = swapsSoFar;
      exitStat.textContent = (step.summary && step.summary.earlyExit && idx === steps.length-1) ? 'yes' : 'no';

      setBoundaryUI(step);
      clearHighlights();

      // Compare highlight
      const aEl = barsEl.children[step.j];
      const bEl = barsEl.children[step.j + 1];
      if (aEl && bEl) {
        aEl.classList.add('compare');
        bEl.classList.add('compare');
      }

      highlightPseudocode(step, 'compare');

      const comparePause = runAnimation ? (250 / speed) : 0;
      if (comparePause > 0) await sleep(comparePause);

      // Swap if needed
      if (step.willSwap) {
        if (aEl && bEl) {
          aEl.classList.add('swapping');
          bEl.classList.add('swapping');
        }
        highlightPseudocode(step, 'swap');

        if (runAnimation) {
          applySnapshot(step.snapshotAfter || step.snapshotBefore);
          await sleep(420 / speed);
        } else {
          // immediate reorder
          applySnapshot(step.snapshotAfter || step.snapshotBefore);
        }
      }

      // Mark sorted tail for classic after pass; for optimized, mark tail by boundary
      Array.from(barsEl.children).forEach((el, i) => {
        el.classList.remove('sorted-tail');
      });
      if (step.variant === 'classic') {
        const tailStart = N - step.pass - 1; // index that is last compared, tail is beyond it
        for (let i = tailStart+1; i < N; i++) {
          barsEl.children[i]?.classList.add('sorted-tail');
        }
      } else {
        const end = step.boundary;
        for (let i = end+1; i < N; i++) {
          barsEl.children[i]?.classList.add('sorted-tail');
        }
      }

      stepRange.value = idx;
      stepIndex = idx;

      // Stability check if finished
      if (idx === steps.length - 1) {
        const final = steps[idx].snapshotAfter || steps[idx].snapshotBefore;
        const stableOK = checkStability(final);
        stableStat.textContent = stableOK ? 'ok' : 'violated';
        stableStat.style.color = stableOK ? '#9ff0c1' : '#ffb3b3';
      } else {
        stableStat.textContent = 'ok';
        stableStat.style.color = '';
      }
    }

    function highlightPseudocode(step, phase) {
      Array.from(codeBlock.querySelectorAll('.line')).forEach(l => l.classList.remove('active'));
      if (step.variant === 'classic') {
        codeBlock.querySelector('[data-line="c1"]').classList.add('active');
        codeBlock.querySelector('[data-line="c2"]').classList.add('active');
        codeBlock.querySelector('[data-line="c3"]').classList.add('active');
        if (phase === 'compare') {
          codeBlock.querySelector('[data-line="c4"]').classList.add('active');
        } else {
          codeBlock.querySelector('[data-line="c5"]').classList.add('active');
          codeBlock.querySelector('[data-line="c6"]').classList.add('active');
        }
      } else {
        codeBlock.querySelector('[data-line="o1"]').classList.add('active');
        codeBlock.querySelector('[data-line="o2"]').classList.add('active');
        codeBlock.querySelector('[data-line="o3"]').classList.add('active');
        codeBlock.querySelector('[data-line="o4"]').classList.add('active');
        codeBlock.querySelector('[data-line="o5"]').classList.add('active');
        if (phase === 'compare') {
          codeBlock.querySelector('[data-line="o6"]').classList.add('active');
        } else {
          codeBlock.querySelector('[data-line="o7"]').classList.add('active');
          codeBlock.querySelector('[data-line="o8"]').classList.add('active');
          codeBlock.querySelector('[data-line="o9"]').classList.add('active');
        }
      }
    }

    function computeBaseOrderLabels(items) {
      // For each value, record labels in original order to verify stability later
      const map = new Map();
      items.forEach(it => {
        const list = map.get(it.value) || [];
        list.push(it.label);
        map.set(it.value, list);
      });
      return map;
    }

    function checkStability(sortedItems) {
      if (!stableEquals) return false; // if unstable mode, we expect violation
      // For each value, collect labels in final order and compare to base
      const now = new Map();
      sortedItems.forEach(it => {
        const list = now.get(it.value) || [];
        list.push(it.label);
        now.set(it.value, list);
      });
      for (const [value, labels] of now.entries()) {
        const orig = baseOrderLabels.get(value) || [];
        // Only check values with duplicates
        if (orig.length > 1) {
          const same = labels.join('|') === orig.join('|');
          if (!same) return false;
        }
      }
      return true;
    }

    function updateStepRange() {
      stepRange.min = 0;
      stepRange.max = Math.max(0, steps.length - 1);
      stepRange.value = 0;
    }

    function stopPlaying() {
      playing = false;
      playBtn.textContent = '▶ Play';
    }

    async function playFromCurrent() {
      if (steps.length === 0) return;
      playing = true;
      playBtn.textContent = '⏸ Pause';
      while (playing && stepIndex < steps.length) {
        await renderStep(stepIndex, true);
        stepIndex++;
        if (predictToggle.checked) {
          // pause before next comparison to allow prediction
          await sleep(120 / speed);
          stopPlaying();
          break;
        }
        await sleep(100 / speed);
      }
      if (stepIndex >= steps.length) {
        stopPlaying();
      }
    }

    function rebuild() {
      // Recompute steps from current data and controls
      order = orderSelect.value;
      variant = variantSelect.value;
      stableEquals = stableToggle.checked;

      drawArray(data);
      baseOrderLabels = computeBaseOrderLabels(data);
      steps = computeSteps(data);
      comparisonsSoFar = 0; swapsSoFar = 0;
      updateStepRange();
      stepIndex = 0;
      renderStep(0, false);
    }

    function parseCsv(str) {
      const vals = str.split(/[\s,]+/).map(s => s.trim()).filter(s => s.length);
      const numbers = vals.map(v => Number(v)).filter(v => Number.isFinite(v));
      return numbers;
    }

    function loadCsvValues() {
      const nums = parseCsv(csvInput.value);
      if (!nums.length) return;
      data = nums.map((v, idx)=>({ id: idx+1, value: v, label: idToLabel(idx+1) }));
      lenInput.value = data.length;
      rebuild();
    }

    function init() {
      data = generateRandomData(Number(lenInput.value), Number(minInput.value), Number(maxInput.value), dupsInput.checked);
      rebuild();
    }

    // Controls wiring
    randBtn.addEventListener('click', () => {
      data = generateRandomData(Number(lenInput.value), Number(minInput.value), Number(maxInput.value), dupsInput.checked);
      rebuild();
    });
    nearlyBtn.addEventListener('click', () => {
      data = generateNearlySorted(Number(lenInput.value), Number(minInput.value), Number(maxInput.value));
      rebuild();
    });
    sortedBtn.addEventListener('click', () => {
      data = generateSorted(Number(lenInput.value), Number(minInput.value), Number(maxInput.value), false);
      rebuild();
    });
    reversedBtn.addEventListener('click', () => {
      data = generateSorted(Number(lenInput.value), Number(minInput.value), Number(maxInput.value), true);
      rebuild();
    });
    applyCsvBtn.addEventListener('click', loadCsvValues);
    csvInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') loadCsvValues();
    });

    lenInput.addEventListener('change', () => {
      const len = Math.max(3, Math.min(40, Number(lenInput.value)));
      lenInput.value = len;
      data = generateRandomData(len, Number(minInput.value), Number(maxInput.value), dupsInput.checked);
      rebuild();
    });
    minInput.addEventListener('change', () => { rebuildDataIfRangeValid(); });
    maxInput.addEventListener('change', () => { rebuildDataIfRangeValid(); });
    dupsInput.addEventListener('change', () => { data = generateRandomData(Number(lenInput.value), Number(minInput.value), Number(maxInput.value), dupsInput.checked); rebuild(); });

    function rebuildDataIfRangeValid() {
      const min = Number(minInput.value);
      const max = Number(maxInput.value);
      if (min > max) { const tmp = min; minInput.value = max; maxInput.value = tmp; }
      data = generateRandomData(Number(lenInput.value), Number(minInput.value), Number(maxInput.value), dupsInput.checked);
      rebuild();
    }

    orderSelect.addEventListener('change', () => { stopPlaying(); rebuild(); });
    variantSelect.addEventListener('change', () => { stopPlaying(); rebuild(); });
    stableToggle.addEventListener('change', () => { stopPlaying(); rebuild(); });

    predictToggle.addEventListener('change', () => {
      predictRow.style.display = predictToggle.checked ? 'flex' : 'none';
      predictFeedback.textContent = '';
    });
    predictSwapBtn.addEventListener('click', () => handlePrediction(true));
    predictNoSwapBtn.addEventListener('click', () => handlePrediction(false));
    function handlePrediction(userThinksSwap) {
      if (steps.length === 0) return;
      const idx = stepIndex;
      if (idx >= steps.length) return;
      const step = steps[idx];
      const correct = step.willSwap === userThinksSwap;
      predictFeedback.textContent = correct ? 'Correct!' : 'Not this time.';
      predictFeedback.style.color = correct ? '#9ff0c1' : '#ffb3b3';
      // Execute the step after prediction
      renderStep(idx, true).then(()=>{
        stepIndex = Math.min(steps.length, stepIndex+1);
        if (stepIndex >= steps.length) stopPlaying();
      });
    }

    prevBtn.addEventListener('click', async () => {
      stopPlaying();
      stepIndex = Math.max(0, stepIndex - 1);
      await renderStep(stepIndex, false);
    });
    nextBtn.addEventListener('click', async () => {
      stopPlaying();
      if (stepIndex >= steps.length) return;
      await renderStep(stepIndex, true);
      stepIndex = Math.min(steps.length, stepIndex + 1);
    });
    resetBtn.addEventListener('click', async () => {
      stopPlaying();
      stepIndex = 0;
      await renderStep(stepIndex, false);
    });
    playBtn.addEventListener('click', async () => {
      if (playing) {
        stopPlaying();
      } else {
        await playFromCurrent();
      }
    });

    stepRange.addEventListener('input', async (e) => {
      stopPlaying();
      stepIndex = Number(e.target.value);
      await renderStep(stepIndex, false);
    });

    speedRange.addEventListener('input', () => {
      speed = Number(speedRange.value);
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', async (e) => {
      const tag = (e.target.tagName || '').toLowerCase();
      if (tag === 'input' || tag === 'select' || tag === 'textarea') return;

      if (e.key === ' ') {
        e.preventDefault();
        if (playing) stopPlaying(); else await playFromCurrent();
      }
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        prevBtn.click();
      }
      if (e.key === 'ArrowRight') {
        e.preventDefault();
        nextBtn.click();
      }
      if (e.key.toLowerCase() === 'r') {
        e.preventDefault();
        resetBtn.click();
      }
      if (e.key.toLowerCase() === 's') {
        e.preventDefault();
        randBtn.click();
      }
    });

    // Initialize
    init();
  </script>
</body>
</html>