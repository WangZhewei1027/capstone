<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bubble Sort Interactive Lab</title>
<style>
  :root {
    --safe-margin: 24px;
    --gap: 16px;
    --bar-gap: 8px;
    --bg: #0f172a;
    --panel: #111827;
    --muted: #9ca3af;
    --text: #e5e7eb;
    --accent: #60a5fa;
    --accent-2: #34d399;
    --danger: #f87171;
    --warning: #fbbf24;
    --focus: #f97316;
    --border: #1f2937;
    --code-bg: #0b1327;
    --code-border: #17223a;
    --bar: #3b82f6;
    --bar-compare: #f59e0b;
    --bar-swap: #ef4444;
    --bar-sorted: #10b981;
    --shadow: rgba(0,0,0,0.35);
  }

  * { box-sizing: border-box; }
  html, body {
    height: 100%;
    background: linear-gradient(180deg, #0b1020 0%, #0e152d 100%);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    line-height: 1.5;
  }
  body { margin: 0; }

  main.container {
    padding: var(--safe-margin);
    max-width: 1200px;
    margin: 0 auto;
  }

  h1, h2 {
    margin: 0 0 8px 0;
    line-height: 1.25;
  }
  h1 {
    font-size: 28px;
    letter-spacing: 0.2px;
  }
  h2 {
    font-size: 20px;
    color: #dbeafe;
  }
  p, li {
    color: var(--text);
  }

  .grid {
    display: grid;
    grid-template-columns: minmax(280px, 1.15fr) 2fr;
    gap: 24px;
  }
  @media (max-width: 880px) {
    .grid { grid-template-columns: 1fr; }
  }

  .panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    box-shadow: 0 8px 24px var(--shadow);
  }
  .panel .section {
    padding: 16px 16px 0 16px;
  }
  .panel .section:last-child { padding-bottom: 16px; }

  .meta {
    display: grid;
    gap: 16px;
  }
  .meta .card {
    background: #0f1a33;
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 16px;
  }
  .meta ul {
    margin: 8px 0 0 18px;
  }
  .meta code, pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  .meta .layout-note {
    color: var(--muted);
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: var(--gap);
    align-items: center;
  }

  .control-group {
    display: flex;
    flex-wrap: wrap;
    gap: var(--gap);
    align-items: center;
  }

  .field {
    display: flex;
    flex-direction: column;
    gap: 8px;
    min-width: 240px;
  }
  .field label {
    font-size: 13px;
    color: var(--muted);
  }
  .field input[type="text"] {
    width: 100%;
    height: 40px;
    padding: 10px 12px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: #0c142a;
    color: var(--text);
    outline: none;
  }
  .field input[type="text"]::placeholder {
    color: #64748b;
  }
  .field input[type="range"] {
    width: 220px;
  }

  .btn {
    height: 40px;
    padding: 0 14px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: #132041;
    color: var(--text);
    cursor: pointer;
    transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
  }
  .btn:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(0,0,0,0.2); }
  .btn:active { transform: translateY(0); }
  .btn.primary { background: #1d4ed8; border-color: #1d4ed8; }
  .btn.green { background: #059669; border-color: #059669; }
  .btn.red { background: #b91c1c; border-color: #b91c1c; }
  .btn.secondary { background: #0c1833; }
  .btn[disabled] { opacity: 0.55; cursor: not-allowed; }

  .toggle {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    user-select: none;
  }
  .toggle input { width: 20px; height: 20px; }

  .bar-area-wrap {
    padding: 16px;
  }
  .bar-area {
    position: relative;
    height: 280px;
    background: #0b1327;
    border: 1px solid var(--code-border);
    border-radius: 12px;
    overflow: hidden;
  }

  .bar {
    position: absolute;
    bottom: 0;
    width: 48px; /* will be resized dynamically */
    border-radius: 8px 8px 0 0;
    background: var(--bar);
    color: #0b1020;
    text-align: center;
    transform: translateX(0);
    transition: transform var(--anim-ms, 350ms) ease, background-color 180ms ease, box-shadow 180ms ease, outline-color 180ms ease;
    outline: 3px solid transparent;
  }
  .bar .label {
    position: absolute;
    top: -26px;
    left: 50%;
    transform: translateX(-50%);
    width: max-content;
    padding: 2px 6px;
    border-radius: 6px;
    font-size: 13px;
    color: #dbeafe;
    background: rgba(37, 99, 235, 0.15);
    border: 1px solid rgba(59, 130, 246, 0.35);
    backdrop-filter: blur(3px);
  }
  .bar.compare { background: var(--bar-compare); outline-color: rgba(251, 191, 36, 0.6); }
  .bar.swap { background: var(--bar-swap); outline-color: rgba(239, 68, 68, 0.6); }
  .bar.sorted { background: var(--bar-sorted); outline-color: rgba(16, 185, 129, 0.5); }

  .legend {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    margin-top: 12px;
  }
  .legend .chip {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    border-radius: 999px;
    padding: 6px 12px;
    background: #0c1b36;
    border: 1px solid var(--border);
    font-size: 13px;
    color: var(--muted);
  }
  .legend .dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    display: inline-block;
  }
  .dot.compare { background: var(--bar-compare); }
  .dot.swap { background: var(--bar-swap); }
  .dot.sorted { background: var(--bar-sorted); }

  .status-row {
    display: grid;
    grid-template-columns: repeat(3, minmax(140px, 1fr));
    gap: 16px;
    margin-top: 16px;
  }
  .stat {
    background: #0c1a34;
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px;
  }
  .stat .label { color: var(--muted); font-size: 12px; }
  .stat .value { font-weight: 700; font-size: 18px; margin-top: 6px; }

  .code {
    background: var(--code-bg);
    border: 1px solid var(--code-border);
    border-radius: 12px;
    padding: 12px;
    margin-top: 16px;
    overflow: auto;
    max-height: 180px;
  }
  .code pre {
    margin: 0;
    color: #c7d2fe;
    font-size: 14px;
  }
  .code .line { padding: 3px 8px; border-radius: 6px; }
  .code .active { background: rgba(96, 165, 250, 0.15); border: 1px solid rgba(96, 165, 250, 0.35); }

  .prompt {
    margin-top: 12px;
    padding: 12px;
    background: #081128;
    border: 1px solid var(--code-border);
    border-radius: 10px;
  }
  .prompt .question { color: #fde68a; }
  .prompt .feedback { margin-top: 8px; font-size: 14px; }

  .kbd {
    display: inline-block;
    border: 1px solid var(--border);
    background: #0a1328;
    padding: 2px 6px;
    border-radius: 6px;
    font-size: 12px;
    color: #c7d2fe;
  }

  /* Focus styles for accessibility */
  .btn:focus, input:focus, .toggle input:focus {
    outline: 3px solid rgba(249, 115, 22, 0.5);
    outline-offset: 2px;
  }

  /* Responsive tweaks */
  @media (max-width: 640px) {
    .status-row { grid-template-columns: 1fr; }
    .field { min-width: 100%; }
  }
</style>
</head>
<body>
<main class="container">
  <div class="grid">
    <!-- Left column: Pedagogical description -->
    <section class="panel" aria-labelledby="title">
      <div class="section">
        <h1 id="title">Bubble Sort — Visual, Step-by-Step Interactive Module</h1>
        <p class="layout-note">Safe area margins: 24 px on all sides. Minimum spacing: 16 px between interactive controls. The interface is responsive and keyboard-accessible.</p>
      </div>
      <div class="section meta">
        <div class="card" aria-labelledby="learning-objective">
          <h2 id="learning-objective">Learning Objective</h2>
          <ul>
            <li>Understand how bubble sort compares adjacent elements and moves the largest unsorted value to the end on each pass.</li>
            <li>Recognize the shrinking inner loop and the “sorted tail” region after each pass.</li>
            <li>Relate algorithm steps to real-time visual feedback: comparisons, condition checks, and swaps.</li>
          </ul>
        </div>
        <div class="card" aria-labelledby="interaction-design">
          <h2 id="interaction-design">Interaction Design</h2>
          <ul>
            <li>Input data: Type a comma-separated list or generate random values. Load to visualize bars.</li>
            <li>Play/Pause: Automatically run the bubble sort with animated comparisons and swaps. Speed slider adjusts animation duration in real time.</li>
            <li>Step: Advance one algorithm step (one adjacent comparison and possible swap) to observe the process carefully.</li>
            <li>Challenge mode: For each comparison, choose “Swap” or “Keep.” You receive immediate feedback and the animation shows the result. This reinforces the comparison rule A[j] &gt; A[j+1] → swap.</li>
            <li>Pseudocode mapping: Lines highlight dynamically to match the current phase (new pass, comparison, swap) and create a strong mental model.</li>
            <li>Keyboard: Space toggles Play/Pause, Right Arrow performs Step, R resets to the initial dataset.</li>
          </ul>
        </div>
        <div class="card" aria-labelledby="layout-description">
          <h2 id="layout-description">Layout Description</h2>
          <p>
            Spatial organization maintains clarity, focus, and balance:
          </p>
          <ul>
            <li>Left pane: The concept title and explanatory sections (Learning Objective, Interaction Design, Layout Description).</li>
            <li>Right pane: The interactive lab containing data controls at the top, the animated bar visualization centrally, and status, legend, and pseudocode below.</li>
            <li>Safe area: 24 px padding on the main container. Interactive controls are arranged with at least 16 px gap to prevent accidental clicks and to improve scanability.</li>
            <li>Accessibility: Clear labels, visible focus outlines, ARIA live status region, keyboard shortcuts, and high-contrast colors ensure inclusive interaction.</li>
            <li>Responsiveness: The grid collapses into a single column on small screens; bars and controls scale to maintain readability and usability.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Right column: Interactive module -->
    <section class="panel" aria-labelledby="module-title">
      <div class="section">
        <h2 id="module-title">Interactive Lab</h2>
        <div class="controls" role="group" aria-label="Dataset controls">
          <div class="field">
            <label for="dataset">Dataset (comma-separated integers)</label>
            <input id="dataset" type="text" placeholder="e.g., 7, 3, 2, 9, 1" aria-describedby="dataset-help" />
            <small id="dataset-help" class="layout-note">Example: 10,4,7,2,5 — values from 0–999 supported.</small>
          </div>
          <div class="control-group" aria-label="Dataset actions">
            <button id="loadBtn" class="btn primary" aria-label="Load dataset">Load</button>
            <button id="randomBtn" class="btn secondary" aria-label="Generate random dataset">Randomize</button>
            <button id="resetBtn" class="btn red" aria-label="Reset to initial dataset" disabled>Reset</button>
          </div>
        </div>

        <div class="controls" role="group" aria-label="Run controls" style="margin-top:16px;">
          <label class="toggle" for="challengeToggle">
            <input id="challengeToggle" type="checkbox" aria-label="Toggle challenge mode" />
            Challenge mode (you decide swap/keep)
          </label>

          <div class="control-group" aria-label="Playback controls">
            <button id="playPauseBtn" class="btn green" aria-label="Play or pause" disabled>Play</button>
            <button id="stepBtn" class="btn" aria-label="Step one comparison" disabled>Step</button>
          </div>

          <div class="field" style="min-width:200px;">
            <label for="speed">Speed</label>
            <input id="speed" type="range" min="0.2" max="2.5" value="1" step="0.1" aria-label="Animation speed" />
            <small class="layout-note">Slower ← → Faster</small>
          </div>
        </div>
      </div>

      <div class="bar-area-wrap">
        <div id="barArea" class="bar-area" aria-label="Bubble sort visualization"></div>
        <div class="legend" aria-label="Legend">
          <span class="chip"><span class="dot compare" aria-hidden="true"></span> comparing pair</span>
          <span class="chip"><span class="dot swap" aria-hidden="true"></span> swapped</span>
          <span class="chip"><span class="dot sorted" aria-hidden="true"></span> sorted tail</span>
        </div>

        <div class="status-row" aria-label="Status">
          <div class="stat" aria-live="polite">
            <div class="label">Comparisons</div>
            <div id="comparisons" class="value">0</div>
          </div>
          <div class="stat" aria-live="polite">
            <div class="label">Swaps</div>
            <div id="swaps" class="value">0</div>
          </div>
          <div class="stat" aria-live="polite">
            <div class="label">Pass</div>
            <div id="pass" class="value">0</div>
          </div>
        </div>

        <div class="prompt" id="prompt" style="display:none;" aria-live="polite">
          <div class="question" id="promptQuestion">Should we swap the highlighted pair?</div>
          <div class="control-group" style="margin-top:8px;">
            <button id="chooseSwap" class="btn primary" aria-label="Choose swap">Swap</button>
            <button id="chooseKeep" class="btn secondary" aria-label="Choose keep">Keep</button>
          </div>
          <div class="feedback" id="promptFeedback"></div>
        </div>

        <div class="code" aria-label="Pseudocode">
          <pre id="pseudo">
<span class="line" data-line="1">1  for i from 0 to n-1:              // outer pass: largest bubble goes right</span>
<span class="line" data-line="2">2    for j from 0 to n-2-i:          // inner loop shrinks as tail becomes sorted</span>
<span class="line" data-line="3">3      compare A[j] and A[j+1]</span>
<span class="line" data-line="4">4      if A[j] > A[j+1]: swap(A[j], A[j+1])</span>
          </pre>
        </div>

        <div class="section">
          <p id="ariaStatus" aria-live="polite" class="layout-note">Status: Ready. Load a dataset to begin.</p>
          <p class="layout-note">
            Tips: Press <span class="kbd">Space</span> to Play/Pause, <span class="kbd">→</span> to Step, <span class="kbd">R</span> to Reset. Challenge mode requires you to decide whether the current pair should swap.
          </p>
        </div>
      </div>
    </section>
  </div>
</main>

<script>
(function() {
  // State
  const state = {
    items: [],          // { id, value, index }
    original: [],
    n: 0,
    i: 0,               // pass index
    j: 0,               // inner index
    comparisons: 0,
    swaps: 0,
    running: false,
    challenge: false,
    waitingDecision: false,
    speed: 1,           // multiplier
    animMs: 350,        // base ms
    justLoaded: false
  };

  // Elements
  const barArea = document.getElementById('barArea');
  const datasetInput = document.getElementById('dataset');
  const loadBtn = document.getElementById('loadBtn');
  const randomBtn = document.getElementById('randomBtn');
  const resetBtn = document.getElementById('resetBtn');
  const playPauseBtn = document.getElementById('playPauseBtn');
  const stepBtn = document.getElementById('stepBtn');
  const speedInput = document.getElementById('speed');
  const comparisonsEl = document.getElementById('comparisons');
  const swapsEl = document.getElementById('swaps');
  const passEl = document.getElementById('pass');
  const pseudo = document.getElementById('pseudo');
  const ariaStatus = document.getElementById('ariaStatus');
  const challengeToggle = document.getElementById('challengeToggle');
  const prompt = document.getElementById('prompt');
  const promptQuestion = document.getElementById('promptQuestion');
  const promptFeedback = document.getElementById('promptFeedback');
  const chooseSwap = document.getElementById('chooseSwap');
  const chooseKeep = document.getElementById('chooseKeep');

  // Utility
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));
  function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

  function updateStatusText(txt) {
    ariaStatus.textContent = "Status: " + txt;
  }

  function highlightLine(n) {
    [...pseudo.querySelectorAll('.line')].forEach(line => {
      line.classList.toggle('active', Number(line.dataset.line) === n);
    });
  }

  // Data helpers
  function parseDataset(text) {
    const nums = text.split(',')
      .map(s => s.trim())
      .filter(s => s.length)
      .map(s => {
        const v = Number(s);
        if (!Number.isFinite(v)) throw new Error("All values must be numbers.");
        return clamp(Math.round(v), -999, 999);
      });
    if (nums.length < 2) throw new Error("Please provide at least two numbers.");
    return nums;
  }

  function generateRandom(len = 8) {
    const n = clamp(len, 5, 14);
    const arr = [];
    for (let k = 0; k < n; k++) {
      arr.push(Math.floor(Math.random() * 90) + 10);
    }
    return arr;
  }

  // Layout / render
  function computeBarLayout() {
    const gap = 8;
    const padding = 12;
    const width = barArea.clientWidth;
    const n = state.n;
    const maxBarWidth = 64;
    const minBarWidth = 32;
    let w = Math.floor((width - padding * 2 - gap * (n - 1)) / n);
    w = clamp(w, minBarWidth, maxBarWidth);
    const totalW = w * n + gap * (n - 1);
    const leftOffset = Math.floor((width - totalW) / 2);
    return { barWidth: w, gap, leftOffset };
  }

  function maxAbsValue() {
    if (!state.items.length) return 1;
    const max = Math.max(...state.items.map(i => Math.abs(i.value)));
    return Math.max(1, max);
  }

  function itemX(index, layout) {
    return layout.leftOffset + index * (layout.barWidth + layout.gap);
  }

  function itemHeight(value) {
    // Map value magnitude to height with minimum; negative values supported
    const max = maxAbsValue();
    const minH = 28;
    const maxH = 220;
    const norm = Math.abs(value) / max;
    return Math.floor(minH + norm * (maxH - minH));
  }

  function clearBars() {
    barArea.innerHTML = '';
  }

  function renderBars(initial = false) {
    clearBars();
    const layout = computeBarLayout();
    state.items.forEach(item => {
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.setAttribute('role', 'img');
      bar.setAttribute('aria-label', `Value ${item.value}`);
      bar.style.setProperty('--anim-ms', `${Math.round(state.animMs / state.speed)}ms`);
      bar.style.width = `${layout.barWidth}px`;
      bar.style.height = `${itemHeight(item.value)}px`;
      bar.style.transform = `translateX(${itemX(item.index, layout)}px)`;
      bar.dataset.id = String(item.id);

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = String(item.value);
      bar.appendChild(label);
      barArea.appendChild(bar);
    });
    highlightSortedTail();
  }

  function updateBarPositions() {
    const layout = computeBarLayout();
    document.querySelectorAll('.bar').forEach(bar => {
      const id = Number(bar.dataset.id);
      const item = state.items.find(i => i.id === id);
      bar.style.setProperty('--anim-ms', `${Math.round(state.animMs / state.speed)}ms`);
      bar.style.width = `${layout.barWidth}px`;
      bar.style.transform = `translateX(${itemX(item.index, layout)}px)`;
      bar.style.height = `${itemHeight(item.value)}px`;
    });
  }

  function markCompare(leftIndex, rightIndex, on = true) {
    document.querySelectorAll('.bar').forEach(bar => {
      const id = Number(bar.dataset.id);
      const item = state.items.find(i => i.id === id);
      if (item.index === leftIndex || item.index === rightIndex) {
        bar.classList.toggle('compare', on);
      } else {
        bar.classList.remove('compare');
      }
      bar.classList.remove('swap'); // cleanup
    });
  }

  function markSwap(leftIndex, rightIndex) {
    document.querySelectorAll('.bar').forEach(bar => {
      const id = Number(bar.dataset.id);
      const item = state.items.find(i => i.id === id);
      const isPair = item.index === leftIndex || item.index === rightIndex;
      bar.classList.toggle('swap', isPair);
    });
  }

  function highlightSortedTail() {
    const sortedStart = state.n - state.i;
    document.querySelectorAll('.bar').forEach(bar => {
      const id = Number(bar.dataset.id);
      const item = state.items.find(i => i.id === id);
      const isSortedTail = item.index >= sortedStart;
      bar.classList.toggle('sorted', isSortedTail);
    });
  }

  function setControlsEnabled(enabled) {
    playPauseBtn.disabled = !enabled || state.challenge;
    stepBtn.disabled = !enabled;
    resetBtn.disabled = !enabled;
  }

  // Algorithm control
  function resetStats() {
    state.i = 0;
    state.j = 0;
    state.comparisons = 0;
    state.swaps = 0;
    comparisonsEl.textContent = '0';
    swapsEl.textContent = '0';
    passEl.textContent = '0';
    updateStatusText('Ready. Press Play or Step to begin.');
    highlightLine(0);
  }

  function loadArray(arr) {
    state.original = arr.slice();
    state.items = arr.map((v, idx) => ({ id: idx + 1, value: v, index: idx }));
    state.n = state.items.length;
    state.running = false;
    resetStats();
    renderBars(true);
    setControlsEnabled(true);
    playPauseBtn.textContent = 'Play';
    state.justLoaded = true;
  }

  function shuffleToOriginal() {
    // Reset to original order
    const arr = state.original.slice();
    state.items.forEach((item, idx) => {
      item.value = arr[idx];
      item.index = idx;
    });
    resetStats();
    renderBars(true);
  }

  function swapIndices(aIdx, bIdx) {
    // Swap positions of items with index aIdx and bIdx
    const itemA = state.items.find(i => i.index === aIdx);
    const itemB = state.items.find(i => i.index === bIdx);
    if (!itemA || !itemB) return;
    const tmp = itemA.index;
    itemA.index = itemB.index;
    itemB.index = tmp;

    // Also swap values in logical order array perspective: maintain a virtual array by index mapping
    // For bubble sort correctness, we rely on visual indices only; values remain attached to bars.
  }

  function sorted() {
    return state.i >= state.n - 1;
  }

  async function prepareNextComparison() {
    if (sorted()) return false;

    // If inner loop finished, advance pass
    const limit = state.n - 1 - state.i;
    if (state.j >= limit) {
      state.i += 1;
      state.j = 0;
      passEl.textContent = String(state.i);
      highlightSortedTail();
      updateStatusText(`New pass: i = ${state.i}`);
      highlightLine(1);
      await sleep(Math.round(220 / state.speed));
    }

    if (sorted()) return false;

    const left = state.j;
    const right = state.j + 1;
    markCompare(left, right, true);
    highlightLine(3);
    updateStatusText(`Comparing A[${left}] and A[${right}]`);
    return true;
  }

  async function applyDecision(doSwap) {
    const left = state.j;
    const right = state.j + 1;

    state.comparisons += 1;
    comparisonsEl.textContent = String(state.comparisons);

    if (doSwap) {
      state.swaps += 1;
      swapsEl.textContent = String(state.swaps);
      highlightLine(4);
      markSwap(left, right);
      // Animate swap by updating indices and positions
      swapIndices(left, right);
      updateBarPositions();
      await sleep(Math.round(state.animMs / state.speed));
    }

    // Cleanup pair highlights
    markCompare(left, right, false);
    document.querySelectorAll('.bar').forEach(b => b.classList.remove('swap'));

    state.j += 1;
    highlightSortedTail();
    return true;
  }

  async function stepGuided() {
    const ok = await prepareNextComparison();
    if (!ok) {
      finishRun();
      return false;
    }
    const left = state.j;
    const right = state.j + 1;
    const a = valueAtIndex(left);
    const b = valueAtIndex(right);
    const doSwap = a > b;
    await sleep(Math.round(260 / state.speed)); // short pause so learner can see the comparison
    await applyDecision(doSwap);
    return true;
  }

  function finishRun() {
    state.running = false;
    playPauseBtn.textContent = 'Play';
    setControlsEnabled(true);
    highlightLine(0);
    updateStatusText('All passes complete. Array sorted.');
  }

  function valueAtIndex(idx) {
    const item = state.items.find(i => i.index === idx);
    return item ? item.value : undefined;
  }

  // Challenge mode handlers
  async function stepChallenge() {
    promptFeedback.textContent = '';
    const ok = await prepareNextComparison();
    if (!ok) { finishRun(); prompt.style.display = 'none'; return; }
    state.waitingDecision = true;
    prompt.style.display = 'block';

    const left = state.j;
    const right = state.j + 1;
    const a = valueAtIndex(left);
    const b = valueAtIndex(right);
    promptQuestion.textContent = `Should we swap? Left = ${a}, Right = ${b}`;

    // Disable Play while in challenge mode
    playPauseBtn.disabled = true;
  }

  async function handleDecision(choiceSwap) {
    if (!state.waitingDecision) return;
    const left = state.j;
    const right = state.j + 1;
    const a = valueAtIndex(left);
    const b = valueAtIndex(right);
    const shouldSwap = a > b;
    const correct = (choiceSwap === shouldSwap);

    promptFeedback.textContent = correct
      ? `Correct: ${a} ${shouldSwap ? '>' : '<='} ${b}${shouldSwap ? ' → swap.' : ' → keep.'}`
      : `Not quite: ${a} ${shouldSwap ? '>' : '<='} ${b}${shouldSwap ? ' so we should swap.' : ' so we should keep.'}`;

    await applyDecision(shouldSwap); // Perform the algorithmically correct action
    state.waitingDecision = false;
    prompt.style.display = 'none';

    if (sorted()) {
      finishRun();
    }
  }

  async function runLoop() {
    state.running = true;
    playPauseBtn.textContent = 'Pause';
    setControlsEnabled(false);
    updateStatusText('Running...');
    while (state.running && !sorted()) {
      const progressed = await stepGuided();
      if (!progressed) break;
      // Gentle pacing between steps
      await sleep(Math.round(140 / state.speed));
    }
    if (sorted()) finishRun();
  }

  function togglePlay() {
    if (state.challenge) {
      updateStatusText('Challenge mode on: use Step and your decisions.');
      return;
    }
    if (!state.running) runLoop();
    else {
      state.running = false;
      playPauseBtn.textContent = 'Play';
      setControlsEnabled(true);
      updateStatusText('Paused.');
    }
  }

  function setSpeed(mult) {
    state.speed = mult;
    updateBarPositions();
  }

  // Event bindings
  loadBtn.addEventListener('click', () => {
    try {
      const arr = parseDataset(datasetInput.value);
      loadArray(arr);
      updateStatusText('Dataset loaded. Ready to sort.');
    } catch (e) {
      updateStatusText((e && e.message) ? e.message : 'Invalid input.');
    }
  });

  randomBtn.addEventListener('click', () => {
    const arr = generateRandom(Math.floor(Math.random() * 6) + 8);
    datasetInput.value = arr.join(', ');
    loadArray(arr);
    updateStatusText('Random dataset loaded.');
  });

  resetBtn.addEventListener('click', () => {
    state.running = false;
    shuffleToOriginal();
    playPauseBtn.textContent = 'Play';
    prompt.style.display = 'none';
  });

  playPauseBtn.addEventListener('click', togglePlay);
  stepBtn.addEventListener('click', async () => {
    if (state.challenge) {
      await stepChallenge();
    } else {
      await stepGuided();
      if (sorted()) finishRun();
    }
  });

  speedInput.addEventListener('input', (e) => {
    const mult = Number(e.target.value);
    setSpeed(mult);
  });

  challengeToggle.addEventListener('change', (e) => {
    state.challenge = e.target.checked;
    if (state.challenge) {
      updateStatusText('Challenge mode enabled. Decide swap/keep for each comparison.');
      prompt.style.display = 'none';
      playPauseBtn.disabled = true;
      playPauseBtn.textContent = 'Play';
      state.running = false;
    } else {
      updateStatusText('Challenge mode disabled. You can Play or Step.');
      prompt.style.display = 'none';
      playPauseBtn.disabled = false;
    }
  });

  chooseSwap.addEventListener('click', () => handleDecision(true));
  chooseKeep.addEventListener('click', () => handleDecision(false));

  // Keyboard shortcuts
  window.addEventListener('keydown', async (e) => {
    const tag = (e.target && e.target.tagName) || '';
    const editingInput = tag === 'INPUT' || tag === 'TEXTAREA';
    if (editingInput) return;

    if (e.code === 'Space') {
      e.preventDefault();
      if (!playPauseBtn.disabled) togglePlay();
    } else if (e.code === 'ArrowRight') {
      e.preventDefault();
      if (!stepBtn.disabled) {
        if (state.challenge) await stepChallenge();
        else await stepGuided();
      }
    } else if (e.key.toLowerCase() === 'r') {
      e.preventDefault();
      if (!resetBtn.disabled) resetBtn.click();
    }
  });

  // Resize listener to keep bars centered/responsive
  window.addEventListener('resize', () => {
    updateBarPositions();
  });

  // Initial demo dataset
  const defaultArr = [7, 3, 2, 9, 1, 5, 4];
  datasetInput.value = defaultArr.join(', ');
  loadArray(defaultArr);
})();
</script>
</body>
</html>