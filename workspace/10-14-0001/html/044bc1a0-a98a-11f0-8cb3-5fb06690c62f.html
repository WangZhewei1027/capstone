<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Bubble Sort — Interactive Visual Exploration</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root{
      --safe:24px;
      --gap:16px;
      --control-radius:10px;
      --bar-gap:16px;
      --bar-focus:3px;
      --bg:#f7f9fc;
      --text:#0f172a;
      --muted:#475569;
      --accent:#2563eb;
      --accent-2:#ef4444;
      --accent-3:#22c55e;
      --accent-4:#f59e0b;
      --border:#e2e8f0;
      --bar:#64748b;
      --bar-compare:#f59e0b;
      --bar-swap:#ef4444;
      --bar-sorted:#22c55e;
      --bar-drag:#7c3aed;
      --focus:#7c3aed;
      --control-bg:#ffffff;
      --shadow:0 8px 30px rgba(2, 6, 23, 0.08);
      --speed-ms:600;
      --easing:cubic-bezier(.25,.8,.25,1);
    }
    /* Safe area and global layout */
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      line-height:1.35;
    }
    .safe{
      padding:var(--safe);
      box-sizing:border-box;
      max-width:1100px;
      margin:0 auto;
    }

    /* Headings */
    h1,h2{margin:0 0 8px 0; line-height:1.2;}
    h1{font-size:1.6rem;}
    h2{font-size:1.25rem;}
    p{margin:0 0 12px 0; color:var(--muted);}

    /* Sections container */
    .section{
      background:var(--control-bg);
      border:1px solid var(--border);
      border-radius:16px;
      padding:20px;
      box-shadow:var(--shadow);
      margin-bottom:24px;
    }

    /* Controls */
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:var(--gap);
      align-items:center;
      margin-top:8px;
    }
    .control{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width:180px;
      flex:1 1 220px;
    }
    .control label{
      font-size:.9rem;
      color:var(--muted);
    }
    input[type="text"]{
      height:44px;
      padding:0 12px;
      border:1px solid var(--border);
      border-radius:var(--control-radius);
      background:var(--control-bg);
      color:var(--text);
      font-size:1rem;
      outline:none;
    }
    input[type="text"]:focus, input[type="range"]:focus{
      box-shadow:0 0 0 3px color-mix(in oklab, var(--focus) 25%, transparent);
      border-color:color-mix(in oklab, var(--focus) 35%, var(--border));
    }
    .btns{
      display:flex;
      flex-wrap:wrap;
      gap:var(--gap);
    }
    button{
      height:44px;
      padding:0 14px;
      border-radius:var(--control-radius);
      border:1px solid var(--border);
      background:var(--control-bg);
      color:var(--text);
      cursor:pointer;
      font-weight:600;
    }
    button.primary{
      background:var(--accent);
      color:white;
      border-color:color-mix(in oklab, var(--accent) 40%, var(--border));
    }
    button.danger{
      background:var(--accent-2);
      color:white;
      border-color:color-mix(in oklab, var(--accent-2) 40%, var(--border));
    }
    button:disabled{
      opacity:.6;
      cursor:not-allowed;
    }
    button:focus-visible{
      outline:none;
      box-shadow:0 0 0 3px color-mix(in oklab, var(--focus) 30%, transparent);
    }

    .inline{
      display:flex;
      align-items:center;
      gap:12px;
    }
    .range-wrap{
      display:flex;
      align-items:center;
      gap:12px;
    }
    input[type="range"]{width:180px;}
    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border:1px solid var(--border);
      border-radius:var(--control-radius);
      height:44px;
      background:var(--control-bg);
    }

    /* Visualization area */
    .viz{
      display:grid;
      grid-template-columns: 2fr 1fr;
      gap:24px;
    }
    @media (max-width: 900px){
      .viz{grid-template-columns: 1fr;}
    }

    .canvas-wrap{
      background:var(--control-bg);
      border:1px solid var(--border);
      border-radius:16px;
      padding:16px;
      box-shadow:var(--shadow);
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    .status{
      display:flex;
      flex-wrap:wrap;
      gap:var(--gap);
      align-items:center;
      font-size:.95rem;
      color:var(--muted);
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border:1px solid var(--border);
      border-radius:999px;
      background:#fafbff;
    }
    .legend{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      font-size:.9rem;
    }
    .k{
      display:inline-flex; align-items:center; gap:6px;
    }
    .swatch{
      width:14px; height:14px; border-radius:3px; border:1px solid var(--border);
    }
    .swatch.c{background:var(--bar-compare);}
    .swatch.s{background:var(--bar-swap);}
    .swatch.d{background:var(--bar-sorted);}

    .canvas{
      position:relative;
      height:320px;
      border:1px dashed var(--border);
      border-radius:12px;
      background:linear-gradient(to top, #ffffff, #f9fbff);
      overflow:hidden;
    }

    .bar{
      position:absolute;
      bottom:0;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      transform:translateX(0);
      transition: transform calc(var(--speed-ms) * 1ms) var(--easing),
                  background-color 250ms ease,
                  box-shadow 250ms ease;
      width:40px; /* placeholder; JS computes actual width */
      background:var(--bar);
      border-radius:8px 8px 0 0;
      color:white;
      font-weight:700;
      box-shadow:0 2px 12px rgba(2,6,23,.06);
      outline:none;
    }
    .bar .label{
      margin-bottom:8px;
      padding:4px 6px;
      border-radius:6px;
      background:rgba(255,255,255,0.18);
      font-size:.9rem;
    }
    .bar.compare{ background:var(--bar-compare); }
    .bar.swap{ background:var(--bar-swap); }
    .bar.sorted{ background:var(--bar-sorted); }
    .bar.dragging{
      background:var(--bar-drag);
      box-shadow:0 14px 30px rgba(124,58,237,.25);
      z-index:3;
    }
    .bar:focus-visible{
      box-shadow:0 0 0 var(--bar-focus) color-mix(in oklab, var(--focus) 40%, transparent);
    }
    .drop-indicator{
      position:absolute;
      bottom:0;
      width:2px;
      height:85%;
      background:var(--focus);
      box-shadow:0 0 0 3px color-mix(in oklab, var(--focus) 30%, transparent);
      display:none;
    }

    /* Pseudocode panel */
    .code{
      background:var(--control-bg);
      border:1px solid var(--border);
      border-radius:16px;
      padding:16px;
      box-shadow:var(--shadow);
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:.95rem;
      line-height:1.5;
    }
    .code .line{
      padding:6px 8px;
      border-radius:8px;
      margin:2px 0;
    }
    .code .hl{
      background:color-mix(in oklab, var(--accent) 18%, transparent);
      color:var(--text);
      border-left:3px solid var(--accent);
    }
    .code .comment{ color:#64748b; font-style:italic; }

    /* Helper / accessibility */
    .sr-only{
      position:absolute !important;
      height:1px; width:1px; overflow:hidden;
      clip:rect(1px,1px,1px,1px);
      white-space:nowrap;
      border:0; padding:0; margin:-1px;
    }
    .help{
      font-size:.9rem;
      color:var(--muted);
    }
  </style>
</head>
<body>
  <main class="safe" role="main" aria-labelledby="title">
    <header class="section">
      <h1 id="title">Concept Title: Bubble Sort — Visual Comparison and Swapping</h1>
      <p>Explore how bubble sort repeatedly compares adjacent elements, swapping them when out of order, so larger values “bubble” to the end. Interact by typing or dragging values, then watch the algorithm unfold step-by-step or in real time.</p>
    </header>

    <section class="section" aria-labelledby="objective">
      <h2 id="objective">Learning Objective</h2>
      <ul>
        <li>Understand the bubble sort mechanism: adjacent comparison, conditional swap, and pass-by-pass progression.</li>
        <li>Observe why the largest element settles at the end of each pass and how a sorted suffix grows.</li>
        <li>Relate visual actions to algorithm steps via pseudocode highlighting and live counters.</li>
        <li>Practice configuring inputs and pacing to cement the concept with hands-on control.</li>
      </ul>
    </section>

    <section class="section" aria-labelledby="interaction">
      <h2 id="interaction">Interaction Design</h2>
      <ul>
        <li>Typing: Enter a list of integers (comma or space separated). Press Apply to render bars whose heights match values.</li>
        <li>Dragging: Grab a bar and drag it horizontally to a new position; a drop indicator appears. Release to reorder and update the array.</li>
        <li>Clicking:
          <ul>
            <li>Play/Pause to run or pause the algorithm with animated comparisons and swaps.</li>
            <li>Step to perform a single comparison (and swap if needed).</li>
            <li>Randomize to generate new values for quick experimentation; Reset to restore the initial state.</li>
            <li>Toggle “Early Exit” to enable the common optimization that stops once a pass makes no swaps.</li>
            <li>Adjust Speed to control animation duration and pacing.</li>
          </ul>
        </li>
        <li>Keyboard: Tab to focus bars or buttons. While a bar is focused, press Alt+← or Alt+→ to move it left or right by one position. Space toggles Play/Pause; Enter triggers the focused control; Right Arrow triggers Step.</li>
        <li>Visual Feedback: Comparing bars highlight amber; a swap highlights red with smooth motion; sorted suffix turns green. Pseudocode lines highlight in sync with the current step. Counters update live (passes, comparisons, swaps).</li>
      </ul>
    </section>

    <section class="section" aria-labelledby="layout">
      <h2 id="layout">Layout Description</h2>
      <ul>
        <li>Spatial organization:
          <ul>
            <li>Top: Title and overview.</li>
            <li>Middle: Controls in a responsive wrap (Apply, Randomize, Play/Pause, Step, Reset, Early Exit, Speed) with at least 16 px spacing.</li>
            <li>Main: Visualization canvas on the left with bars; synchronized pseudocode on the right. On small screens, pseudocode stacks below the canvas.</li>
          </ul>
        </li>
        <li>Safe area: 24 px padding on all sides ensures content doesn’t touch viewport edges.</li>
        <li>Accessibility:
          <ul>
            <li>High-contrast color cues; focus outlines; buttons sized to at least 44 px height.</li>
            <li>ARIA labels and a live region announce algorithm progress and reorders.</li>
            <li>Keyboard shortcuts and focusable bars for non-pointer interaction.</li>
          </ul>
        </li>
        <li>Responsiveness: Flexible layout adapts to narrow screens, keeping controls accessible and readable. Bars resize and reposition on window resize while maintaining minimum 16 px spacing.</li>
      </ul>
    </section>

    <section class="section" aria-labelledby="module">
      <h2 id="module">Interactive Bubble Sort Module</h2>

      <div class="controls" aria-label="Bubble sort controls">
        <div class="control">
          <label for="numbers">Numbers (comma or space separated)</label>
          <input id="numbers" type="text" inputmode="numeric" placeholder="e.g., 12, 7, 5, 9, 3" aria-describedby="numbers-help">
          <div id="numbers-help" class="help">Range 1–99. Invalid entries are ignored with feedback.</div>
        </div>
        <div class="btns" role="group" aria-label="Array actions">
          <button id="apply" class="primary" aria-label="Apply typed numbers">Apply</button>
          <button id="randomize" aria-label="Randomize values">Randomize</button>
          <button id="reset" class="danger" aria-label="Reset to initial values">Reset</button>
        </div>
        <div class="btns" role="group" aria-label="Run controls">
          <button id="play" class="primary" aria-label="Play or pause">Play</button>
          <button id="step" aria-label="Step once">Step</button>
        </div>
        <div class="toggle" role="group" aria-label="Options">
          <input id="earlyExit" type="checkbox" checked aria-label="Enable early exit optimization">
          <label for="earlyExit">Early Exit</label>
        </div>
        <div class="range-wrap" role="group" aria-label="Speed control">
          <label for="speed">Speed</label>
          <input id="speed" type="range" min="0.25" max="2" step="0.05" value="1" aria-valuemin="0.25" aria-valuemax="2" aria-valuenow="1">
          <span id="speedLabel" aria-live="polite">1.0×</span>
        </div>
      </div>

      <div class="viz" aria-label="Visualization and pseudocode">
        <div class="canvas-wrap" role="region" aria-label="Bubble sort visualization">
          <div class="status" aria-live="polite">
            <div class="badge" id="passBadge">Pass: 0</div>
            <div class="badge" id="indexBadge">Comparing: —</div>
            <div class="badge" id="compBadge">Comparisons: 0</div>
            <div class="badge" id="swapBadge">Swaps: 0</div>
            <div class="badge" id="stateBadge">State: Idle</div>
          </div>
          <div class="legend" aria-hidden="true">
            <div class="k"><span class="swatch c"></span> Comparing</div>
            <div class="k"><span class="swatch s"></span> Swapping</div>
            <div class="k"><span class="swatch d"></span> Sorted suffix</div>
          </div>
          <div class="canvas" id="canvas" aria-label="Draggable bars representing values">
            <div id="dropIndicator" class="drop-indicator" aria-hidden="true"></div>
          </div>
          <div class="help">Tip: Drag bars to reorder. Keyboard: Alt+←/Alt+→ moves the focused bar; Space toggles Play/Pause; → steps.</div>
        </div>

        <aside class="code" role="region" aria-label="Pseudocode">
          <div class="comment">// Bubble sort with early-exit optimization</div>
          <pre id="codeBlock" aria-label="Bubble sort pseudocode">
<span class="line" data-line="1">for i = 0 to n - 1:</span>
<span class="line" data-line="2">    swapped = false</span>
<span class="line" data-line="3">    for j = 0 to n - i - 2:</span>
<span class="line" data-line="4">        if A[j] > A[j + 1]:</span>
<span class="line" data-line="5">            swap(A[j], A[j + 1])</span>
<span class="line" data-line="6">            swapped = true</span>
<span class="line" data-line="7">    if (not swapped): break</span>
          </pre>
        </aside>
      </div>
    </section>

    <div id="live" class="sr-only" aria-live="polite"></div>
  </main>

  <script>
    (function(){
      // State and configuration
      const state = {
        array: [12, 7, 5, 9, 3, 16, 4, 10],
        initial: null,
        i: 0,            // current pass
        j: 0,            // current index
        comparisons: 0,
        swaps: 0,
        playing: false,
        earlyExit: true,
        swappedThisPass: false,
        sortedStop: null, // index where sorted suffix starts
        speed: 1.0,
        inTransition: false
      };

      // DOM references
      const canvas = document.getElementById('canvas');
      const dropIndicator = document.getElementById('dropIndicator');
      const numbersInput = document.getElementById('numbers');
      const applyBtn = document.getElementById('apply');
      const randomizeBtn = document.getElementById('randomize');
      const resetBtn = document.getElementById('reset');
      const playBtn = document.getElementById('play');
      const stepBtn = document.getElementById('step');
      const earlyExitCheckbox = document.getElementById('earlyExit');
      const speedRange = document.getElementById('speed');
      const speedLabel = document.getElementById('speedLabel');

      const passBadge = document.getElementById('passBadge');
      const indexBadge = document.getElementById('indexBadge');
      const compBadge = document.getElementById('compBadge');
      const swapBadge = document.getElementById('swapBadge');
      const stateBadge = document.getElementById('stateBadge');
      const live = document.getElementById('live');

      const codeBlock = document.getElementById('codeBlock');

      // Layout metrics
      const metrics = {
        width: 0,
        height: 0,
        barWidth: 0,
        gap: parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-gap')) || 16,
        maxValue: 99,
      };

      let bars = [];

      function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
      function setSpeed(multiplier){
        state.speed = multiplier;
        speedLabel.textContent = multiplier.toFixed(2) + '×';
        document.documentElement.style.setProperty('--speed-ms', String(Math.round(600 / multiplier)));
      }
      setSpeed(1);

      function announce(msg){
        live.textContent = msg;
      }

      function parseNumbers(text){
        const parts = text.split(/[\s,]+/).filter(Boolean);
        const result = [];
        for(const p of parts){
          const n = parseInt(p, 10);
          if(Number.isFinite(n)){
            result.push(clamp(n, 1, metrics.maxValue));
          }
        }
        return result;
      }

      function randomArray(len){
        const arr = [];
        for(let i=0;i<len;i++){
          arr.push(Math.floor(5 + Math.random()*94)); // range 5–99
        }
        return arr;
      }

      function measure(){
        const rect = canvas.getBoundingClientRect();
        metrics.width = rect.width;
        metrics.height = rect.height;
        metrics.barWidth = Math.floor((metrics.width - (state.array.length - 1) * metrics.gap) / state.array.length);
        // min width for touch targets
        metrics.barWidth = Math.max(metrics.barWidth, 32);
      }

      function buildBars(){
        canvas.innerHTML = '';
        canvas.appendChild(dropIndicator);
        bars = state.array.map((val, idx) => {
          const el = document.createElement('button');
          el.className = 'bar';
          el.setAttribute('role','button');
          el.setAttribute('aria-label', `Value ${val}, position ${idx+1} of ${state.array.length}`);
          el.tabIndex = 0;
          el.dataset.index = String(idx);
          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = String(val);
          el.appendChild(label);
          canvas.appendChild(el);
          attachBarEvents(el);
          return el;
        });
        measure();
        layoutBars();
        updateStatus();
        updateSortedClasses();
      }

      function layoutBars(){
        const maxVal = Math.max(...state.array, 1);
        bars.forEach((bar, i) => {
          const v = state.array[i];
          const x = i * (metrics.barWidth + metrics.gap);
          const h = Math.max(24, Math.round((v / maxVal) * (metrics.height - 24)));
          bar.style.width = metrics.barWidth + 'px';
          bar.style.height = h + 'px';
          bar.style.transform = `translateX(${x}px)`;
          const label = bar.querySelector('.label');
          label.textContent = String(v);
          bar.setAttribute('aria-label', `Value ${v}, position ${i+1} of ${state.array.length}`);
        });
        // position drop indicator off
        dropIndicator.style.display = 'none';
      }

      function highlightBars(indices, cls){
        indices.forEach(i => {
          if(bars[i]) bars[i].classList.add(cls);
        });
      }
      function clearHighlights(){
        bars.forEach(b => {
          b.classList.remove('compare','swap');
        });
      }

      function updateStatus(){
        passBadge.textContent = `Pass: ${state.i}`;
        if(state.j < state.array.length - state.i - 1){
          indexBadge.textContent = `Comparing: j=${state.j} & j+1=${state.j+1}`;
        } else {
          indexBadge.textContent = `Comparing: —`;
        }
        compBadge.textContent = `Comparisons: ${state.comparisons}`;
        swapBadge.textContent = `Swaps: ${state.swaps}`;
        stateBadge.textContent = `State: ${state.playing ? 'Playing' : 'Idle'}`;
      }

      function resetAlgo(resetToInitial = true){
        state.i = 0;
        state.j = 0;
        state.comparisons = 0;
        state.swaps = 0;
        state.playing = false;
        state.swappedThisPass = false;
        state.sortedStop = null;
        playBtn.textContent = 'Play';
        stateBadge.textContent = 'State: Idle';
        clearHighlights();
        updateSortedClasses(true);
        if(resetToInitial && state.initial){
          state.array = state.initial.slice();
        }
        measure();
        layoutBars();
        updateStatus();
        unhighlightCode();
      }

      function setArray(arr){
        state.array = arr.slice();
        state.initial = arr.slice();
        resetAlgo(false);
        buildBars();
        announce(`Array set to ${arr.join(', ')}`);
      }

      function randomize(){
        const len = clamp(state.array.length, 4, 16);
        setArray(randomArray(len));
      }

      function updateSortedClasses(clear=false){
        bars.forEach(b => b.classList.remove('sorted'));
        if(clear) return;
        // sorted suffix size equals state.i elements at the end
        const sortedFrom = state.array.length - state.i;
        for(let k=sortedFrom; k<state.array.length; k++){
          if(bars[k]) bars[k].classList.add('sorted');
        }
      }

      // Pseudocode highlighting
      function unhighlightCode(){
        codeBlock.querySelectorAll('.line').forEach(l => l.classList.remove('hl'));
      }
      function hl(line){
        unhighlightCode();
        const el = codeBlock.querySelector(`.line[data-line="${line}"]`);
        if(el) el.classList.add('hl');
      }
      function hlCompare(){ hl(4); }
      function hlSwap(){ hl(5); }
      function hlOuter(){ hl(1); }
      function hlInner(){ hl(3); }
      function hlSwappedSet(){ hl(2); }
      function hlBreak(){ hl(7); }

      // Algorithm stepping
      function done(){
        state.playing = false;
        playBtn.textContent = 'Play';
        stateBadge.textContent = 'State: Done';
        unhighlightCode();
        announce('Sorting complete.');
      }

      function lockUI(locked){
        const disabled = locked;
        numbersInput.disabled = disabled;
        applyBtn.disabled = disabled;
        randomizeBtn.disabled = disabled;
        resetBtn.disabled = disabled;
        earlyExitCheckbox.disabled = disabled;
        bars.forEach(b => b.disabled = disabled);
      }

      function wait(ms){
        return new Promise(res => setTimeout(res, ms));
      }

      async function stepOnce(){
        if(state.inTransition) return;
        // if complete
        if(state.i >= state.array.length - 1){
          done();
          return;
        }
        hlOuter();
        hlSwappedSet();

        // if inner loop done, finalize pass
        const innerLimit = state.array.length - state.i - 1;
        if(state.j >= innerLimit){
          // early exit check
          updateSortedClasses();
          if(state.earlyExit && !state.swappedThisPass){
            hlBreak();
            // mark all remaining unsorted as sorted (since already sorted)
            state.i = state.array.length - 1;
            updateSortedClasses();
            await wait(300 / state.speed);
            done();
            return;
          }
          state.j = 0;
          state.i++;
          state.swappedThisPass = false;
          updateSortedClasses();
          updateStatus();
          return;
        }

        // Compare j and j+1
        hlInner();
        hlCompare();
        clearHighlights();
        highlightBars([state.j, state.j+1], 'compare');
        state.comparisons++;
        updateStatus();
        announce(`Comparing positions ${state.j+1} and ${state.j+2}`);

        await wait(300 / state.speed);

        if(state.array[state.j] > state.array[state.j+1]){
          // swap needed
          hlSwap();
          clearHighlights();
          highlightBars([state.j, state.j+1], 'swap');
          state.inTransition = true;

          // Perform swap in data
          const a = state.array[state.j];
          state.array[state.j] = state.array[state.j+1];
          state.array[state.j+1] = a;

          state.swaps++;
          state.swappedThisPass = true;

          // Animate positions by re-layout
          layoutBars();

          await wait(Math.max(300, 600 / state.speed));
          state.inTransition = false;
        } else {
          // keep compare highlight briefly
          await wait(200 / state.speed);
        }

        clearHighlights();
        state.j++;
        updateStatus();
      }

      async function playLoop(){
        lockUI(true);
        stateBadge.textContent = 'State: Playing';
        while(state.playing){
          await stepOnce();
          // break if done
          if(state.i >= state.array.length - 1 || !state.playing){
            break;
          }
          // pacing gap
          await wait(200 / state.speed);
        }
        lockUI(false);
      }

      // Drag & drop and keyboard reordering
      function attachBarEvents(bar){
        let startX = 0;
        let dragging = false;
        let startIndex = 0;

        function pointerDown(e){
          if(state.playing) return; // disable while playing
          dragging = true;
          bar.classList.add('dragging');
          startX = (e.touches ? e.touches[0].clientX : e.clientX);
          startIndex = parseInt(bar.dataset.index, 10);
          dropIndicator.style.display = 'block';
          bar.setPointerCapture && bar.setPointerCapture(e.pointerId || 0);
          e.preventDefault();
        }

        function pointerMove(e){
          if(!dragging) return;
          const x = (e.touches ? e.touches[0].clientX : e.clientX);
          const dx = x - startX;
          const baseX = startIndex * (metrics.barWidth + metrics.gap);
          const newX = baseX + dx;
          bar.style.transform = `translateX(${newX}px)`;
          // compute nearest index
          const idx = clamp(Math.round(newX / (metrics.barWidth + metrics.gap)), 0, state.array.length - 1);
          const indicatorX = idx * (metrics.barWidth + metrics.gap);
          dropIndicator.style.left = (indicatorX - 1) + 'px';
        }

        function pointerUp(e){
          if(!dragging) return;
          dragging = false;
          bar.classList.remove('dragging');
          dropIndicator.style.display = 'none';
          const currentX = parseFloat(bar.style.transform.replace('translateX(','').replace('px)','')) || 0;
          let targetIndex = clamp(Math.round(currentX / (metrics.barWidth + metrics.gap)), 0, state.array.length - 1);

          const from = startIndex;
          const to = targetIndex;
          if(from !== to){
            // reorder array
            const val = state.array.splice(from, 1)[0];
            state.array.splice(to, 0, val);
            announce(`Moved value ${val} from position ${from+1} to ${to+1}`);
          }
          // relayout bars with new order
          buildBars();
        }

        // Pointer events
        bar.addEventListener('mousedown', pointerDown);
        bar.addEventListener('touchstart', pointerDown, {passive:false});
        window.addEventListener('mousemove', pointerMove);
        window.addEventListener('touchmove', pointerMove, {passive:false});
        window.addEventListener('mouseup', pointerUp);
        window.addEventListener('touchend', pointerUp);

        // Keyboard: Alt+Left/Right to move
        bar.addEventListener('keydown', (e) => {
          if(state.playing) return;
          const idx = parseInt(bar.dataset.index, 10);
          if(e.altKey && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')){
            e.preventDefault();
            const dir = e.key === 'ArrowLeft' ? -1 : 1;
            const to = clamp(idx + dir, 0, state.array.length - 1);
            if(to !== idx){
              const val = state.array.splice(idx, 1)[0];
              state.array.splice(to, 0, val);
              announce(`Moved value ${val} from position ${idx+1} to ${to+1}`);
              buildBars();
              // focus the moved bar at new index
              bars[to].focus();
            }
          }
        });
      }

      // Controls event wiring
      applyBtn.addEventListener('click', () => {
        const vals = parseNumbers(numbersInput.value);
        if(vals.length >= 2){
          setArray(vals);
        } else {
          announce('Please enter at least two valid integers.');
          numbersInput.focus();
        }
      });

      numbersInput.addEventListener('input', () => {
        const vals = parseNumbers(numbersInput.value);
        if(vals.length){
          numbersInput.setAttribute('aria-invalid','false');
        } else {
          numbersInput.setAttribute('aria-invalid','true');
        }
      });

      randomizeBtn.addEventListener('click', () => {
        randomize();
      });

      resetBtn.addEventListener('click', () => {
        resetAlgo(true);
      });

      earlyExitCheckbox.addEventListener('change', () => {
        state.earlyExit = earlyExitCheckbox.checked;
        announce(`Early exit ${state.earlyExit ? 'enabled' : 'disabled'}.`);
      });

      playBtn.addEventListener('click', async () => {
        state.playing = !state.playing;
        playBtn.textContent = state.playing ? 'Pause' : 'Play';
        updateStatus();
        if(state.playing){
          playLoop();
        }
      });

      stepBtn.addEventListener('click', async () => {
        await stepOnce();
      });

      speedRange.addEventListener('input', () => {
        const mult = parseFloat(speedRange.value);
        setSpeed(mult);
      });

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if(e.key === ' '){
          e.preventDefault();
          playBtn.click();
        } else if(e.key === 'ArrowRight' && !state.playing){
          e.preventDefault();
          stepBtn.click();
        }
      });

      window.addEventListener('resize', () => {
        measure();
        layoutBars();
      });

      // Initialize
      (function init(){
        numbersInput.value = state.array.join(', ');
        setArray(state.array);
      })();
    })();
  </script>
</body>
</html>