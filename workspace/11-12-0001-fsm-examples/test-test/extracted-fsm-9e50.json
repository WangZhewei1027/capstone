{
  "states": [
    {
      "id": "initial",
      "type": "initial",
      "description": "Page loaded"
    },
    {
      "id": "state_after_insertButton",
      "type": "interaction",
      "description": "After clicking Insert",
      "semantic": "insert"
    }
  ],
  "transitions": [
    {
      "from": "initial",
      "to": "state_after_insertButton",
      "event": "click_insertButton",
      "element": "Insert",
      "semantic": "insert",
      "changes": [
        {
          "type": "node_count_change",
          "before": 0,
          "after": 1
        },
        {
          "type": "element_count_change",
          "before": 15,
          "after": 16
        },
        {
          "type": "text_content_change",
          "newText": [
            "50",
            "Inserted: 50"
          ]
        }
      ]
    }
  ],
  "components": {
    "inputs": 1,
    "buttons": 2,
    "inputDetails": [
      {
        "id": "inputValue",
        "type": "number"
      }
    ],
    "buttonDetails": [
      {
        "id": "insertButton",
        "text": "Insert"
      },
      {
        "id": "deleteButton",
        "text": "Delete"
      }
    ]
  },
  "issues": [
    "Button \"Delete\" failed: elementHandle.fill: Element is not attached to the DOM\nCall log:\n\u001b[2m    - fill(\"50\")\u001b[22m\n\u001b[2m  - attempting fill action\u001b[22m\n\u001b[2m    - waiting for element to be visible, enabled and editable\u001b[22m\n"
  ],
  "debug": {
    "initialState": {
      "timestamp": 1762917061091,
      "elementCounts": {
        "buttons": 2,
        "inputs": 1,
        "totalElements": 15
      },
      "treeNodes": [],
      "visibleText": [
        "Interactive Binary Search Tree (BST)",
        "Insert",
        "Delete",
        "class TreeNode {\n        constructor(value) {\n          this.value = value;\n          this.left = null;\n          this.right = null;\n        }\n      }\n\n      class BST {\n        constructor() {\n          this.root = null;\n        }\n\n        insert(value) {\n          const newNode = new TreeNode(value);\n          if (!this.root) {\n            this.root = newNode;\n          } else {\n            this.insertNode(this.root, newNode);\n          }\n        }\n\n        insertNode(node, newNode) {\n          if (newNode.value < node.value) {\n            if (!node.left) {\n              node.left = newNode;\n            } else {\n              this.insertNode(node.left, newNode);\n            }\n          } else {\n            if (!node.right) {\n              node.right = newNode;\n            } else {\n              this.insertNode(node.right, newNode);\n            }\n          }\n        }\n\n        delete(value) {\n          this.root = this.deleteNode(this.root, value);\n        }\n\n        deleteNode(node, value) {\n          if (!node) return null;\n          if (value < node.value) {\n            node.left = this.deleteNode(node.left, value);\n            return node;\n          } else if (value > node.value) {\n            node.right = this.deleteNode(node.right, value);\n            return node;\n          } else {\n            // Node to be deleted found\n            if (!node.left && !node.right) return null; // No children\n            if (!node.left) return node.right; // One child (right)\n            if (!node.right) return node.left; // One child (left)\n\n            // Two children: Get the inorder successor (smallest in the right subtree)\n            node.value = this.minValue(node.right);\n            node.right = this.deleteNode(node.right, node.value);\n          }\n          return node;\n        }\n\n        minValue(node) {\n          let min = node.value;\n          while (node.left) {\n            min = node.left.value;\n            node = node.left;\n          }\n          return min;\n        }\n      }\n\n      const bst = new BST();\n\n      function drawBST(node, x, y, gap) {\n        if (!node) return;\n\n        const nodeElement = document.createElement(\"div\");\n        nodeElement.className = \"node\";\n        nodeElement.innerText = node.value;\n        nodeElement.style.left = `${x}px`;\n        nodeElement.style.top = `${y}px`;\n        document.getElementById(\"bstVisualization\").appendChild(nodeElement);\n\n        drawBST(node.left, x - gap, y + 60, gap / 2);\n        drawBST(node.right, x + gap, y + 60, gap / 2);\n      }\n\n      document.getElementById(\"insertButton\").addEventListener(\"click\", () => {\n        const value = parseInt(document.getElementById(\"inputValue\").value);\n        if (isNaN(value)) {\n          alert(\"Please enter a valid number.\");\n          return;\n        }\n        bst.insert(value);\n        document.getElementById(\"result\").innerText = `Inserted: ${value}`;\n        document.getElementById(\"bstVisualization\").innerHTML = \"\";\n        drawBST(bst.root, 300, 20, 100);\n      });\n\n      document.getElementById(\"deleteButton\").addEventListener(\"click\", () => {\n        const value = parseInt(document.getElementById(\"inputValue\").value);\n        if (isNaN(value)) {\n          alert(\"Please enter a valid number.\");\n          return;\n        }\n        bst.delete(value);\n        document.getElementById(\"result\").innerText = `Deleted: ${value}`;\n        document.getElementById(\"bstVisualization\").innerHTML = \"\";\n        drawBST(bst.root, 300, 20, 100);\n      });"
      ]
    },
    "detectedButtons": [
      "Insert",
      "Delete"
    ]
  }
}