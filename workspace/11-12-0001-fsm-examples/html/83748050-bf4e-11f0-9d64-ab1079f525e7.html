<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bubble Sort — Interactive Module</title>
  <style>
    :root{
      --safe-pad: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --muted: #94a3b8;
      --accent: #38bdf8;
      --accent-2: #60a5fa;
      --success: #34d399;
      --danger: #fb7185;
      --tile-bg: linear-gradient(180deg,#0ea5a6 0%, #0891b2 100%);
      --max-width: 1100px;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071025 0%, #061226 100%);
      color:#e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    /* Safe area margins: 24px on all sides */
    .page{
      padding:var(--safe-pad);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }
    .wrap{
      width:100%;
      max-width:var(--max-width);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    /* Header / info cards */
    .header{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .title-card{
      background:linear-gradient(180deg,#06102a 0%, #081827 100%);
      padding:20px;
      border-radius:12px;
      flex:1 1 420px;
      min-width:280px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      border:1px solid rgba(255,255,255,0.03);
    }
    .title-card h1{
      margin:0 0 8px 0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    .title-card p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    /* Side descriptions */
    .meta{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      min-width:320px;
      flex:0 0 320px;
    }
    .card{
      background:var(--card);
      border-radius:12px;
      padding:16px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      border:1px solid rgba(255,255,255,0.03);
    }
    .card h3{
      margin:0 0 8px 0;
      font-size:13px;
    }
    .card p, .card li{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.5;
    }
    .card ul{ padding-left:18px; margin:6px 0 0 0; }

    /* Main interactive area */
    .interactive{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .controls{
      width:320px;
      min-width:280px;
      max-width:360px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .panel{
      background:var(--card);
      border-radius:12px;
      padding:14px;
      border:1px solid rgba(255,255,255,0.03);
      box-shadow: 0 6px 18px rgba(2,6,23,0.45);
    }
    .controls .panel .row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    label{ font-size:13px; color:var(--muted); }
    input[type="range"]{
      width:100%;
    }
    .btn{
      background:linear-gradient(180deg,#0b1830 0%, #071428 100%);
      color:var(--accent);
      border:1px solid rgba(56,189,248,0.12);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
      transition:transform .08s ease, box-shadow .08s ease;
    }
    .btn:active{ transform:translateY(1px) }
    .btn.primary{
      background:linear-gradient(90deg,var(--accent),var(--accent-2));
      color:#04202b;
      border:none;
      box-shadow:0 6px 20px rgba(3,105,161,0.18);
    }
    .btn.ghost{
      background:transparent;
      border:1px dashed rgba(255,255,255,0.04);
      color:var(--muted);
    }
    .controls .small{
      font-size:13px;
      color:var(--muted);
    }
    input[type="text"], textarea{
      width:100%;
      background:rgba(255,255,255,0.02);
      color:inherit;
      border:1px solid rgba(255,255,255,0.03);
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      box-sizing:border-box;
    }

    /* Visualization pane */
    .viz{
      flex:1 1 640px;
      min-width:320px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .viz-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:var(--gap);
    }
    .status{
      color:var(--muted);
      font-size:13px;
    }
    .board{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:12px;
      border:1px solid rgba(255,255,255,0.03);
      min-height:220px;
    }
    .slots{
      position:relative;
      height:160px;
      background:linear-gradient(180deg, rgba(2,6,23,0.4), rgba(2,6,23,0.2));
      border-radius:10px;
      display:block;
      overflow:visible;
      padding:12px;
      box-sizing:border-box;
    }
    .slot{
      position:absolute;
      bottom:12px;
      width:48px;
      height:100%;
      transform-origin:bottom left;
      transition:transform 400ms cubic-bezier(.2,.9,.2,1), box-shadow 220ms;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      gap:8px;
      pointer-events:auto;
    }
    .tile{
      width:48px;
      border-radius:8px;
      background:var(--tile-bg);
      display:flex;
      align-items:center;
      justify-content:center;
      color:#04202b;
      font-weight:700;
      box-shadow: 0 8px 20px rgba(2,10,20,0.5);
      transition:transform 260ms ease, background 260ms ease, box-shadow 260ms ease;
      user-select:none;
      cursor:pointer;
      height:100%;
      overflow:hidden;
      padding-bottom:6px;
      box-sizing:border-box;
    }
    .tile.small{ width:40px; border-radius:6px; }
    .tile .val{
      transform:translateY(6px);
      font-size:13px;
      color:#ecfeff;
      text-shadow: 0 1px 0 rgba(0,0,0,0.2);
    }
    .tile.compare{
      box-shadow: 0 10px 28px rgba(250,230,30,0.08);
      outline: 2px solid rgba(250,230,30,0.12);
    }
    .tile.swap{
      box-shadow: 0 10px 36px rgba(250,80,80,0.12);
      outline:2px solid rgba(250,80,80,0.12);
    }
    .tile.sorted{
      background: linear-gradient(180deg,var(--success), #10b981);
      color:#043029;
    }
    .info-row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    .badge{
      background:rgba(255,255,255,0.03);
      padding:8px 10px;
      border-radius:10px;
      font-size:13px;
      color:var(--muted);
    }

    /* Pseudocode pane */
    .code{
      background:linear-gradient(180deg,#051226 0%, #06162b 100%);
      border-radius:10px;
      padding:12px;
      color:var(--muted);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace;
      font-size:13px;
      line-height:1.6;
      border:1px solid rgba(255,255,255,0.03);
      max-height:260px;
      overflow:auto;
    }
    .code pre{ margin:0; white-space:pre-wrap; }
    .code .line{ display:block; padding:2px 6px; border-radius:6px; }
    .code .line.now{ background:linear-gradient(90deg, rgba(56,189,248,0.08), rgba(96,165,250,0.04)); color:var(--accent); }
    .code .muted{ color:var(--muted); font-size:12px; }

    /* footer small */
    .hint{ color:var(--muted); font-size:13px; }

    /* Responsive */
    @media (max-width:980px){
      .header{ flex-direction:column; }
      .meta{ flex-direction:row; flex-wrap:wrap; }
      .controls{ width:100%; max-width:none; order:2; }
      .viz{ order:1; }
    }
  </style>
</head>
<body>
  <div class="page" role="main">
    <div class="wrap" aria-live="polite">
      <!-- Header / Title and objective -->
      <div class="header">
        <div class="title-card">
          <h1>Bubble Sort — Pairwise swapping visualized</h1>
          <p>Interactive exploration of the Bubble Sort algorithm. Use the controls to step through comparisons and swaps, change the array, and observe how the algorithm progressively sorts the list.</p>
        </div>

        <div class="meta">
          <div class="card" aria-labelledby="objective">
            <h3 id="objective">Learning Objective</h3>
            <p>After interacting with this module you will be able to:</p>
            <ul>
              <li>Explain how Bubble Sort repeatedly compares adjacent items and swaps them when out of order.</li>
              <li>Observe the inner and outer loops and the effect of each pass in moving the largest unsorted item to its correct place.</li>
              <li>Relate counts of comparisons and swaps to algorithm behavior and stability.</li>
            </ul>
          </div>

          <div class="card" aria-labelledby="interaction">
            <h3 id="interaction">Interaction Design</h3>
            <p>This module supports multiple forms of interaction:</p>
            <ul>
              <li>Typing: Enter a custom array (comma-separated) and press "Apply".</li>
              <li>Clicking: Select a tile to swap manually (click one tile, then another). Clicking controls: Step, Play/Pause, Reset, Randomize.</li>
              <li>Sliders & Buttons: Adjust speed and size, then step through or autoplay.</li>
            </ul>
            <p>Visual & animated feedback:</p>
            <ul>
              <li>Comparisons are highlighted in yellow, swaps animate smoothly, and fully sorted tiles turn green.</li>
              <li>Pseudo-code lines are highlighted to show algorithm flow (inner/outer loops).</li>
              <li>Live counters show comparisons, swaps, current pass and index.</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Interaction design explanation -->
      <div class="card">
        <h3>Layout Description</h3>
        <p>
          The page arranges content into a left control column and a right visualization column on wide screens (responsive to stack vertically on smaller screens).
          The safe area uses 24px padding on all sides, and interactive elements are separated by a minimum 16px gap to avoid visual clutter.
        </p>
        <p>
          Controls (left): inputs and buttons grouped in panels with clear labels. Visualization (right): status row, a board showing tiles (each tile is a bar whose height is proportional to its numeric value), and a pseudocode pane that highlights the current line.
          Everything is keyboard- and screen-reader-friendly: buttons are focusable and aria-live updates provide real-time feedback.
        </p>
      </div>

      <!-- Main interactive modules -->
      <div class="interactive">
        <!-- Controls -->
        <div class="controls" role="region" aria-label="Controls">
          <div class="panel">
            <div class="row" style="justify-content:space-between;align-items:center;">
              <div>
                <label class="small">Array size</label>
                <div style="display:flex;gap:8px;align-items:center;margin-top:6px;">
                  <input id="sizeRange" type="range" min="3" max="12" value="8" aria-label="Array size slider">
                  <div class="badge" id="sizeLabel">8</div>
                </div>
              </div>
              <div style="min-width:110px;">
                <label class="small">Speed</label>
                <input id="speedRange" type="range" min="0.25" max="2" step="0.25" value="1" aria-label="Speed slider">
                <div class="badge" id="speedLabel">1x</div>
              </div>
            </div>

            <div style="height:var(--gap)"></div>

            <div class="row" style="justify-content:flex-start;">
              <button class="btn primary" id="playBtn" aria-pressed="false">Play</button>
              <button class="btn" id="stepBtn">Step</button>
              <button class="btn ghost" id="pauseBtn">Pause</button>
              <button class="btn" id="resetBtn">Reset</button>
            </div>

            <div style="height:var(--gap)"></div>

            <div class="row" style="flex-direction:column;align-items:stretch;">
              <label class="small">Custom array (comma separated)</label>
              <input id="customInput" type="text" placeholder="e.g. 5,2,9,1,4" aria-label="Custom array input">
              <div style="display:flex;gap:var(--gap);margin-top:10px;">
                <button class="btn" id="applyBtn">Apply</button>
                <button class="btn" id="randomBtn">Randomize</button>
                <button class="btn ghost" id="shuffleBtn">Shuffle</button>
              </div>
            </div>
          </div>

          <div class="panel" aria-live="polite">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div>
                <div class="small">Statistics</div>
                <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap;">
                  <div class="badge">Comparisons: <span id="compCount">0</span></div>
                  <div class="badge">Swaps: <span id="swapCount">0</span></div>
                  <div class="badge">Pass: <span id="passCount">0</span></div>
                </div>
              </div>
              <div style="text-align:right;">
                <div class="small">Mode</div>
                <div style="margin-top:6px;"><span class="badge" id="modeLabel">Manual</span></div>
              </div>
            </div>

            <div style="height:var(--gap)"></div>

            <div>
              <div class="small" style="margin-bottom:6px;">Interaction tips</div>
              <ul style="margin:0;padding-left:18px;color:var(--muted);font-size:13px;">
                <li>Click a tile to select, then click another to swap manually.</li>
                <li>Use Step to advance one action (compare or swap). Play auto-steps.</li>
                <li>Press Space to step, R to randomize, Enter to apply custom array.</li>
              </ul>
            </div>
          </div>
        </div>

        <!-- Visualization -->
        <div class="viz" role="region" aria-label="Visualization">
          <div class="viz-top">
            <div class="status">
              <div style="font-weight:600;">Array visualization</div>
              <div class="hint">Adjacent comparisons highlighted; swapped tiles animate into new positions.</div>
            </div>
            <div style="display:flex;gap:12px;align-items:center;">
              <div class="badge">n = <span id="nVal">8</span></div>
              <div class="badge" id="statusBadge">Idle</div>
            </div>
          </div>

          <div class="board" id="board">
            <div class="info-row" style="justify-content:space-between;">
              <div>
                <div class="badge">i (inner index): <span id="iIndex">—</span></div>
                <div class="badge">j (comp index): <span id="jIndex">—</span></div>
              </div>
              <div style="display:flex;gap:8px;align-items:center;">
                <div class="hint">Click tiles to swap manually</div>
              </div>
            </div>

            <div class="slots" id="slots" aria-live="polite" aria-label="Array slots (tiles)"></div>

            <div style="display:flex;gap:var(--gap);align-items:center;justify-content:space-between;">
              <div style="display:flex;gap:8px;align-items:center;">
                <div class="badge">Selected: <span id="selectedIdx">—</span></div>
                <div class="badge">Comparisons: <strong id="cCount">0</strong></div>
              </div>
              <div style="display:flex;gap:8px;align-items:center;">
                <div class="badge">Swaps: <strong id="sCount">0</strong></div>
                <div class="badge">State: <strong id="curState">Idle</strong></div>
              </div>
            </div>
          </div>

          <div style="display:flex;gap:var(--gap);flex-wrap:wrap;">
            <div class="code" id="pseudocode" aria-hidden="false">
              <pre>
<span class="line" data-line="1">for (i = 0; i &lt; n-1; i++) {</span>
<span class="line" data-line="2">  for (j = 0; j &lt; n-1-i; j++) {</span>
<span class="line" data-line="3">    if (A[j] &gt; A[j+1]) {</span>
<span class="line" data-line="4">      swap(A[j], A[j+1]);</span>
<span class="line" data-line="5">    }</span>
<span class="line" data-line="6">  }</span>
<span class="line" data-line="7">}</span>
              </pre>
            </div>

            <div style="min-width:220px;flex:0 0 220px;">
              <div class="panel" style="padding:12px;">
                <div style="font-weight:600;margin-bottom:6px;">Explanation</div>
                <div class="muted" style="font-size:13px;">Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them when they are in the wrong order.
                After each full pass, the next largest element is placed in its final position at the end.</div>
              </div>
            </div>
          </div>

        </div>
      </div>

      <div style="height:8px"></div>
    </div>
  </div>

  <script>
    // Bubble Sort Interactive Module — Vanilla JS
    (function(){
      // DOM elements
      const sizeRange = document.getElementById('sizeRange');
      const sizeLabel = document.getElementById('sizeLabel');
      const nVal = document.getElementById('nVal');

      const speedRange = document.getElementById('speedRange');
      const speedLabel = document.getElementById('speedLabel');

      const playBtn = document.getElementById('playBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');

      const customInput = document.getElementById('customInput');
      const applyBtn = document.getElementById('applyBtn');
      const randomBtn = document.getElementById('randomBtn');
      const shuffleBtn = document.getElementById('shuffleBtn');

      const slots = document.getElementById('slots');
      const compCount = document.getElementById('compCount');
      const swapCount = document.getElementById('swapCount');
      const cCount = document.getElementById('cCount');
      const sCount = document.getElementById('sCount');
      const passCount = document.getElementById('passCount');
      const modeLabel = document.getElementById('modeLabel');
      const statusBadge = document.getElementById('statusBadge');

      const iIndex = document.getElementById('iIndex');
      const jIndex = document.getElementById('jIndex');
      const selectedIdx = document.getElementById('selectedIdx');
      const curState = document.getElementById('curState');

      const pseudocode = document.getElementById('pseudocode');

      // state
      let arr = [];
      let initialArr = [];
      let tileEls = [];
      let running = false;
      let autoplay = false;
      let intervalId = null;
      let speed = parseFloat(speedRange.value);
      let comp = 0, swaps = 0, passes = 0;
      let generator = null;
      let selected = -1;
      let lineHighlight = null;

      // layout params
      const slotHeight = 140; // visual mapping
      const tileWidth = 48;
      const gap = 12;

      // initialize
      function init(size=8){
        sizeRange.value = size;
        sizeLabel.textContent = size;
        nVal.textContent = size;
        arr = randomArray(size, 1, 20);
        initialArr = arr.slice();
        resetStats();
        render();
        stopAuto();
        updateMode('Manual');
        updateStatus('Idle');
      }

      function resetStats(){
        comp = 0; swaps = 0; passes = 0;
        updateStats();
      }

      function updateStats(){
        compCount.textContent = comp;
        swapCount.textContent = swaps;
        cCount.textContent = comp;
        sCount.textContent = swaps;
        passCount.textContent = passes;
      }

      // render tiles in absolute positions and set heights
      function render(){
        slots.innerHTML = '';
        tileEls = [];
        const n = arr.length;
        const containerWidth = Math.max(320, n * (tileWidth + 8) + 40);
        slots.style.width = '100%';
        // compute positions based on index
        const positions = [];
        const slotRect = slots.getBoundingClientRect();
        // compute horizontal start to center tiles
        const totalWidth = n * tileWidth + (n-1)*8;
        const containerInnerWidth = Math.max(slotRect.width, totalWidth);
        const startX = Math.max(12, (slotRect.width - totalWidth) / 2);

        arr.forEach((val, idx) => {
          const slot = document.createElement('div');
          slot.className = 'slot';
          slot.setAttribute('data-index', idx);
          slot.style.left = (startX + idx*(tileWidth + 8)) + 'px';
          slot.style.width = tileWidth + 'px';
          // tile height proportional (min 20, max slotHeight)
          const minV = Math.min(...arr);
          const maxV = Math.max(...arr);
          const range = Math.max(1, maxV - minV);
          const relative = (val - minV) / range;
          const height = 36 + Math.round(relative * (slotHeight - 36));
          const tile = document.createElement('div');
          tile.className = 'tile';
          tile.style.height = height + 'px';
          tile.setAttribute('role','button');
          tile.setAttribute('aria-label', 'value ' + val + ' at index ' + idx);
          tile.dataset.idx = idx;
          const span = document.createElement('div');
          span.className = 'val';
          span.textContent = val;
          tile.appendChild(span);

          // click selection for manual swap
          tile.addEventListener('click', (e)=>{
            if(running) return;
            const idx = Number(tile.dataset.idx);
            handleTileClick(idx, tile);
          });

          slot.appendChild(tile);
          slots.appendChild(slot);
          tileEls.push({slot, tile, idx});
        });

        // update selected index display
        selectedIdx.textContent = selected >=0 ? selected : '—';
      }

      function updateTileVisual(idx, opts = {}){
        const el = tileEls[idx];
        if(!el) return;
        const tile = el.tile;
        tile.classList.remove('compare','swap','sorted');
        if(opts.compare) tile.classList.add('compare');
        if(opts.swap) tile.classList.add('swap');
        if(opts.sorted) tile.classList.add('sorted');
        // update value
        tile.querySelector('.val').textContent = arr[idx];
        tile.setAttribute('aria-label', 'value ' + arr[idx] + ' at index ' + idx);
      }

      // highlight pseudo code line
      function highlightLine(num){
        pseudocode.querySelectorAll('.line').forEach(l => {
          if(Number(l.dataset.line) === num) l.classList.add('now');
          else l.classList.remove('now');
        });
      }

      // generator for bubble sort actions
      function* bubbleGen(array){
        const n = array.length;
        for(let i=0;i<n-1;i++){
          passes = i+1;
          yield {type:'pass', i};
          for(let j=0;j<n-1-i;j++){
            yield {type:'compare', i, j};
            if(array[j] > array[j+1]){
              // swap
              [array[j], array[j+1]] = [array[j+1], array[j]];
              yield {type:'swap', i, j};
            }
          }
        }
        yield {type:'done'};
      }

      // step by step executor
      async function step(){
        if(!generator){
          // initialize generator with a copied array
          generator = bubbleGen(arr.slice());
          updateMode('Auto (stepping)');
        }
        const res = generator.next();
        if(res.done){
          updateStatus('Finished');
          updateMode('Finished');
          markAllSorted();
          generator = null;
          running = false;
          stopAuto();
          return;
        }
        const action = res.value;
        await handleAction(action);
      }

      async function handleAction(action){
        if(!action) return;
        if(action.type === 'pass'){
          // update pass count visually
          passes = action.i + 1;
          updateStats();
          passCount.textContent = passes;
          iIndex.textContent = action.i;
          jIndex.textContent = '—';
          highlightLine(1);
          updateStatus('Starting pass ' + passes);
          await sleep(120);
        } else if(action.type === 'compare'){
          comp++;
          updateStats();
          iIndex.textContent = action.i;
          jIndex.textContent = action.j;
          highlightLine(2);
          updateStatus('Comparing indices ' + action.j + ' and ' + (action.j+1));
          // temporarily highlight tiles
          markCompare(action.j, action.j+1);
          await sleep(300 / speed);
          // remove highlight unless swapped next
          clearCompare(action.j, action.j+1);
        } else if(action.type === 'swap'){
          swaps++;
          updateStats();
          highlightLine(3);
          updateStatus('Swapping ' + action.j + ' and ' + (action.j+1));
          // perform visual swap and animate positions
          await animateSwap(action.j, action.j+1);
        } else if(action.type === 'done'){
          highlightLine(7);
          updateStatus('Sorting complete');
          markAllSorted();
          generator = null;
        }
      }

      // animate swapping elements in the actual arr and visual tiles
      function animateSwap(j, k){
        return new Promise((resolve) => {
          // since our generator used a copy, we need to perform swap on actual arr now
          // swap in arr
          [arr[j], arr[k]] = [arr[k], arr[j]];
          // re-render to update heights and labels
          // We'll animate by fading/out-in effect for simplicity
          // Mark swap visual
          render(); // re-create tiles
          // Add swap class briefly
          const elJ = slots.querySelectorAll('.tile')[j];
          const elK = slots.querySelectorAll('.tile')[k];
          if(elJ) elJ.classList.add('swap');
          if(elK) elK.classList.add('swap');
          setTimeout(()=>{
            if(elJ) elJ.classList.remove('swap');
            if(elK) elK.classList.remove('swap');
            resolve();
          }, Math.max(220, 420 / speed));
        });
      }

      function markCompare(a,b){
        const tiles = slots.querySelectorAll('.tile');
        if(tiles[a]) tiles[a].classList.add('compare');
        if(tiles[b]) tiles[b].classList.add('compare');
      }
      function clearCompare(a,b){
        const tiles = slots.querySelectorAll('.tile');
        if(tiles[a]) tiles[a].classList.remove('compare');
        if(tiles[b]) tiles[b].classList.remove('compare');
      }

      function markAllSorted(){
        const tiles = slots.querySelectorAll('.tile');
        tiles.forEach(t => t.classList.add('sorted'));
        updateStatus('Sorted');
      }

      // autoplay management
      function startAuto(){
        if(autoplay) return;
        autoplay = true;
        updateMode('Autoplay');
        playBtn.setAttribute('aria-pressed','true');
        statusBadge.textContent = 'Running';
        runAuto();
      }
      function stopAuto(){
        autoplay = false;
        playBtn.setAttribute('aria-pressed','false');
        statusBadge.textContent = 'Idle';
        if(intervalId) { clearInterval(intervalId); intervalId = null; }
      }

      function runAuto(){
        if(intervalId) clearInterval(intervalId);
        const interval = Math.max(60, 600 / speed);
        intervalId = setInterval(async ()=>{
          if(!autoplay){
            clearInterval(intervalId);
            intervalId = null;
            return;
          }
          await step();
        }, interval);
      }

      function stopAll(){
        running = false;
        autoplay = false;
        if(intervalId) { clearInterval(intervalId); intervalId = null; }
      }

      function updateMode(text){
        modeLabel.textContent = text;
      }

      function updateStatus(text){
        statusBadge.textContent = text;
        curState.textContent = text;
      }

      // Utilities
      function randomArray(n, min=1, max=20){
        const a = [];
        for(let i=0;i<n;i++){
          a.push(Math.floor(Math.random()*(max-min+1))+min);
        }
        return a;
      }

      function shuffleArray(a){
        for(let i=a.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [a[i],a[j]] = [a[j],a[i]];
        }
        return a;
      }

      function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }

      // tile click selection for manual swapping
      function handleTileClick(idx, tile){
        if(selected === -1){
          selected = idx;
          selectedIdx.textContent = idx;
          tile.classList.add('compare');
          updateStatus('Selected index ' + idx + '. Click another to swap.');
        } else if(selected === idx){
          // deselect
          selected = -1;
          selectedIdx.textContent = '—';
          tile.classList.remove('compare');
          updateStatus('Selection cleared');
        } else {
          // swap selected and idx
          updateStatus('Manual swap: ' + selected + ' ↔ ' + idx);
          [arr[selected], arr[idx]] = [arr[idx], arr[selected]];
          swaps++;
          swapCount.textContent = swaps;
          sCount.textContent = swaps;
          render();
          // clear selected markers
          selected = -1;
          selectedIdx.textContent = '—';
        }
      }

      // event listeners
      sizeRange.addEventListener('input', (e)=>{
        const val = Number(e.target.value);
        sizeLabel.textContent = val;
        nVal.textContent = val;
      });

      speedRange.addEventListener('input', (e)=>{
        speed = parseFloat(e.target.value);
        speedLabel.textContent = speed + 'x';
        if(autoplay) runAuto();
      });

      playBtn.addEventListener('click', ()=>{
        running = true;
        updateMode('Autoplay');
        startAuto();
      });
      pauseBtn.addEventListener('click', ()=>{
        updateMode('Paused');
        stopAuto();
      });
      stepBtn.addEventListener('click', async ()=>{
        running = true;
        stopAuto();
        await step();
      });
      resetBtn.addEventListener('click', ()=>{
        // reset to initial array
        stopAll();
        arr = initialArr.slice();
        generator = null;
        resetStats();
        render();
        updateMode('Manual');
        updateStatus('Reset to initial');
      });

      applyBtn.addEventListener('click', ()=>{
        const txt = customInput.value.trim();
        if(!txt) return;
        const parts = txt.split(',').map(s=>Number(s.trim())).filter(x=>!isNaN(x));
        if(parts.length < 2){ alert('Please enter at least 2 numbers.'); return; }
        arr = parts.slice(0, 20);
        initialArr = arr.slice();
        sizeRange.value = arr.length;
        sizeLabel.textContent = arr.length;
        nVal.textContent = arr.length;
        resetStats();
        generator = null;
        render();
        updateMode('Manual');
        updateStatus('Applied custom array');
      });

      randomBtn.addEventListener('click', ()=>{
        const n = Number(sizeRange.value);
        arr = randomArray(n, 1, Math.max(10, n*3));
        initialArr = arr.slice();
        resetStats();
        render();
        generator = null;
        updateMode('Manual');
        updateStatus('Randomized');
      });

      shuffleBtn.addEventListener('click', ()=>{
        arr = shuffleArray(arr.slice());
        initialArr = arr.slice();
        resetStats();
        render();
        generator = null;
        updateMode('Manual');
        updateStatus('Shuffled');
      });

      // keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if(e.code === 'Space'){
          e.preventDefault();
          stepBtn.click();
        } else if(e.key === 'r' || e.key === 'R'){
          randomBtn.click();
        } else if(e.key === 'Enter'){
          applyBtn.click();
        }
      });

      // initial call
      init(8);

      // Accessibility: announce status updates
      const live = document.createElement('div');
      live.setAttribute('aria-live','polite');
      live.style.position='absolute';
      live.style.width='1px';
      live.style.height='1px';
      live.style.margin='-1px';
      live.style.border='0';
      live.style.padding='0';
      live.style.clip='rect(0 0 0 0)';
      live.style.overflow='hidden';
      document.body.appendChild(live);

      // watch status text and announce
      let lastStatus = '';
      setInterval(()=>{
        const s = statusBadge.textContent;
        if(s !== lastStatus){
          live.textContent = s;
          lastStatus = s;
        }
      }, 250);

    })();
  </script>
</body>
</html>