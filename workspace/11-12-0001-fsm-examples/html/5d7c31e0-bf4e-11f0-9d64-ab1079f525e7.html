<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive BST Explorer</title>
  <style>
    :root{
      --safe-margin:24px;
      --gap:16px;
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#3b82f6;
      --muted:#94a3b8;
      --success:#16a34a;
      --danger:#ef4444;
      --node:#1e293b;
      --node-text:#e6eef8;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      padding:var(--safe-margin);
      background:linear-gradient(180deg,#071025 0%, #07182a 100%);
      color:var(--node-text);
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      line-height:1.35;
    }
    /* Layout */
    .wrap{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:var(--gap);
      align-items:start;
      min-height: calc(100vh - (2 * var(--safe-margin)));
    }
    @media (max-width:920px){
      .wrap{grid-template-columns:1fr; padding-bottom:40px}
    }
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      padding:20px;
      border-radius:12px;
      box-shadow: 0 6px 24px rgba(2,6,23,0.6);
    }

    /* Left column */
    .meta{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
    }
    .section{
      background:rgba(255,255,255,0.01);
      border-radius:10px;
      padding:12px;
      font-size:14px;
    }
    .controls{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
      margin-top:8px;
    }
    input[type="number"]{
      -moz-appearance: textfield;
    }
    .row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      margin-top:8px;
    }
    input[type="text"], input[type="number"]{
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:rgba(255,255,255,0.02);
      color:var(--node-text);
      min-width:120px;
      outline:none;
    }
    button{
      padding:9px 12px;
      border-radius:8px;
      border: none;
      background:var(--accent);
      color:white;
      cursor:pointer;
      font-weight:600;
      transition:transform .12s ease, box-shadow .12s ease;
      min-width:72px;
    }
    button:active{transform:translateY(1px)}
    button.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--node-text);
    }
    button.warn{ background:var(--danger) }
    button.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.02); color:var(--muted) }
    .small{
      padding:7px 10px;
      font-size:13px;
    }
    .toggle{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }

    /* Right column: visualization */
    .vis{
      position:relative;
      min-height:520px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .canvas-wrap{
      background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.006));
      border-radius:12px;
      padding:16px;
      position:relative;
      height:520px;
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow:hidden;
    }
    .svg-area{
      flex:1;
      width:100%;
      border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.008), transparent);
      display:flex;
      align-items:flex-start;
      justify-content:center;
      overflow:auto;
    }
    svg{ width:100%; height:100%; overflow:visible; }

    /* Node styles */
    .node-group{ cursor:pointer; transition:transform 400ms cubic-bezier(.22,.9,.36,1), opacity 300ms ease; }
    .node-circle{
      fill:var(--node);
      stroke:rgba(255,255,255,0.03);
      stroke-width:1;
      filter: drop-shadow(0 6px 24px rgba(2,6,23,0.6));
    }
    .node-text{
      font-size:12px;
      fill:var(--node-text);
      text-anchor:middle;
      dominant-baseline:middle;
      font-weight:700;
      pointer-events:none;
    }
    /* highlights */
    .visited .node-circle{ stroke: var(--accent); stroke-width:2.6; animation: pulse 1s infinite alternate; }
    @keyframes pulse{
      from{ box-shadow:0 0 0px rgba(59,130,246,0.0) }
      to{ box-shadow:0 0 14px rgba(59,130,246,0.12) }
    }
    .found .node-circle{ fill:var(--success) }
    .removing{ opacity:0.12; transform:scale(.8) }

    /* links */
    .link{
      stroke:rgba(255,255,255,0.06);
      stroke-width:2;
      stroke-linecap:round;
      transition:stroke 240ms ease, opacity 240ms ease;
    }
    .link.visited{ stroke:var(--accent); stroke-width:3.4; opacity:1; }

    /* logs */
    .log{
      background:rgba(0,0,0,0.12);
      padding:10px;
      border-radius:8px;
      font-family:monospace;
      font-size:13px;
      color:var(--muted);
      height:86px;
      overflow:auto;
    }

    /* layout description area */
    .desc{
      font-size:13px;
      color:var(--muted);
      background:rgba(255,255,255,0.01);
      padding:10px;
      border-radius:8px;
    }

    /* accessibility focus */
    button:focus, input:focus{ outline: 3px solid rgba(59,130,246,0.15) }

    /* spacing enforcement */
    .controls > * { margin-bottom: var(--gap); }
  </style>
</head>
<body>
  <div class="wrap" role="main">
    <aside class="panel" aria-labelledby="title">
      <div class="meta">
        <div>
          <h1 id="title">Binary Search Tree (BST) — Interactive Explorer</h1>
          <div class="muted">One focused concept: dynamic insertion, search, and deletion in a BST with visualized traversal and animations.</div>
        </div>

        <div class="section" aria-labelledby="objective-title">
          <strong id="objective-title">Learning objective</strong>
          <p class="muted" style="margin:8px 0 0;">
            After interacting you'll be able to visualize how values are inserted, located, and removed in a BST;
            observe the exact nodes visited (path), understand parent-child reassignment during delete, and feel the
            cost (number of comparisons) through animated highlights and step-by-step controls.
          </p>
        </div>

        <div class="section" aria-labelledby="interaction-title">
          <strong id="interaction-title">Interaction design (how to use)</strong>
          <div class="desc" style="margin-top:8px;">
            - Type a number and press Insert to add. The algorithm highlights each visited node, animating the path.
            <br>- Use Step Mode to advance one comparison at a time (Next / Prev).
            <br>- Click Search to highlight the path; found node turns green.
            <br>- Delete removes a value; animations show node replacement (in-order successor) when needed.
            <br>- Click nodes directly in the visualization to remove them (confirmation).
            <br>- Use Randomize to add several nodes quickly and Clear to reset.
          </div>
        </div>

        <div class="section" aria-labelledby="layout-title">
          <strong id="layout-title">Layout description</strong>
          <div class="desc" style="margin-top:8px;">
            - Safe margins: 24px around viewport. Controls spaced with at least 16px.
            <br>- Left column: concise controls, objectives, and instructions.
            <br>- Right column: large SVG visualization (center) with controls below and a console log.
            <br>- Responsive: columns collapse to single column on narrow screens, SVG scales fluidly.
          </div>
        </div>

        <div class="section" aria-labelledby="controls-title">
          <strong id="controls-title">Controls</strong>

          <div class="row" style="margin-top:10px;">
            <label for="valueInput" class="muted" style="width:80px">Value</label>
            <input id="valueInput" type="number" inputmode="numeric" aria-label="Value to insert or delete" placeholder="e.g. 42" />
            <button id="insertBtn">Insert</button>
            <button id="searchBtn" class="secondary">Search</button>
          </div>

          <div class="row">
            <button id="deleteBtn" class="warn">Delete</button>
            <button id="clearBtn" class="ghost small">Clear</button>
            <button id="randomBtn" class="secondary small">Randomize</button>
          </div>

          <div class="row" style="justify-content:space-between; margin-top:12px;">
            <div class="toggle">
              <input id="stepToggle" type="checkbox" aria-label="Enable step mode" />
              <label for="stepToggle" class="muted">Step Mode</label>
            </div>
            <div style="display:flex; gap:10px;">
              <button id="prevStep" class="secondary small" title="Previous step">Prev</button>
              <button id="nextStep" class="secondary small" title="Next step">Next</button>
            </div>
          </div>

          <div style="margin-top:12px;">
            <div class="muted" style="margin-bottom:6px">Current tree (in-order):</div>
            <div id="inorder" class="desc" aria-live="polite">— empty —</div>
          </div>

        </div>

      </div>
    </aside>

    <main class="panel vis" aria-label="Visualization panel">
      <div class="canvas-wrap" role="region" aria-label="Binary Search Tree visualization">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="display:flex; gap:12px; align-items:center;">
            <strong style="font-size:15px">BST Visualizer</strong>
            <div class="muted" style="font-size:13px">Click nodes to remove. Hover to see value.</div>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <div class="muted" style="font-size:13px">Comparisons:</div>
            <div id="compCount" class="desc" style="min-width:36px; text-align:center;">0</div>
          </div>
        </div>

        <div class="svg-area" id="svgArea" tabindex="0">
          <svg id="svg" viewBox="0 0 1200 520" preserveAspectRatio="xMidYMin meet" aria-hidden="false"></svg>
        </div>

        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="flex:1">
            <div class="muted" style="margin-bottom:6px">Action log</div>
            <div id="log" class="log" aria-live="polite"></div>
          </div>
          <div style="width:220px">
            <div class="muted" style="margin-bottom:6px">Legend</div>
            <div class="desc" style="display:flex;flex-direction:column; gap:8px">
              <div style="display:flex; gap:8px; align-items:center;">
                <svg width="18" height="18"><circle cx="9" cy="9" r="7" fill="#1e293b" stroke="rgba(255,255,255,0.03)"/></svg>
                <span class="muted">Node</span>
              </div>
              <div style="display:flex; gap:8px; align-items:center;">
                <svg width="18" height="18"><rect width="18" height="4" rx="2" fill="rgba(255,255,255,0.06)"/></svg>
                <span class="muted">Edge</span>
              </div>
              <div style="display:flex; gap:8px; align-items:center;">
                <svg width="18" height="18"><circle cx="9" cy="9" r="7" fill="#16a34a"/></svg>
                <span class="muted">Found</span>
              </div>
              <div style="display:flex; gap:8px; align-items:center;">
                <svg width="18" height="18"><circle cx="9" cy="9" r="7" fill="#3b82f6"/></svg>
                <span class="muted">Visited</span>
              </div>
            </div>
          </div>
        </div>

      </div>
    </main>
  </div>

  <script>
    // BST Data structure + Visualization
    (function(){
      // DOM elements
      const svg = document.getElementById('svg');
      const insertBtn = document.getElementById('insertBtn');
      const searchBtn = document.getElementById('searchBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const clearBtn = document.getElementById('clearBtn');
      const randomBtn = document.getElementById('randomBtn');
      const valueInput = document.getElementById('valueInput');
      const inorderEl = document.getElementById('inorder');
      const logEl = document.getElementById('log');
      const compCountEl = document.getElementById('compCount');
      const stepToggle = document.getElementById('stepToggle');
      const nextStep = document.getElementById('nextStep');
      const prevStep = document.getElementById('prevStep');

      // Visualization params
      const viewW = 1200, viewH = 520;
      const levelGap = 92;
      const nodeRadius = 22;
      const transitionMs = 400;

      // State
      let root = null;
      let nodeIdCounter = 1;
      let comparisons = 0;
      let currentPath = []; // nodes visited in current operation
      let stepIndex = -1;
      let isStepping = false;
      let pendingAnim = null;
      const nodesMap = new Map(); // id => node obj

      // Utility log
      function log(...args){
        const t = new Date().toLocaleTimeString();
        logEl.innerText = `${t} - ${args.join(' ')}\n` + logEl.innerText;
      }

      // Node representation
      function createNode(val){
        const n = { id: nodeIdCounter++, val: Number(val), left: null, right: null, x:0, y:0 };
        nodesMap.set(n.id, n);
        return n;
      }

      // BST operations with path tracking
      function bstInsert(val){
        if (root === null) { root = createNode(val); return { inserted: root, path:[root] }; }
        let cur = root;
        const path = [];
        while(cur){
          path.push(cur);
          if (val === cur.val) { return { inserted:null, path, duplicate:true }; }
          if (val < cur.val){
            if (!cur.left){ cur.left = createNode(val); path.push(cur.left); return { inserted:cur.left, path }; }
            cur = cur.left;
          } else {
            if (!cur.right){ cur.right = createNode(val); path.push(cur.right); return { inserted:cur.right, path }; }
            cur = cur.right;
          }
        }
        return { inserted:null, path };
      }

      function bstSearch(val){
        let cur = root;
        const path = [];
        while(cur){
          path.push(cur);
          if (val === cur.val) return { found:cur, path };
          if (val < cur.val) cur = cur.left; else cur = cur.right;
        }
        return { found:null, path };
      }

      function bstDelete(val){
        let parent = null;
        let cur = root;
        const path = [];
        while(cur && cur.val !== val){
          path.push(cur);
          parent = cur;
          if (val < cur.val) cur = cur.left; else cur = cur.right;
        }
        if (!cur) return { deleted:null, path };
        path.push(cur);
        // Node with two children
        if (cur.left && cur.right){
          // find in-order successor
          let succParent = cur;
          let succ = cur.right;
          while(succ.left){
            succParent = succ;
            succ = succ.left;
          }
          // swap values
          const oldVal = cur.val;
          cur.val = succ.val;
          succ.val = oldVal;
          // now delete successor (which has at most right child)
          // adjust references to delete succ
          if (succParent.left === succ) succParent.left = succ.right;
          else succParent.right = succ.right;
          path.push(succ); // include the replaced node in path
          nodesMap.delete(succ.id);
          return { deleted:cur, replaced:succ, path, swapped:true };
        } else {
          // node has 0 or 1 child
          const child = cur.left ? cur.left : cur.right;
          if (!parent){
            // deleting root
            root = child;
          } else {
            if (parent.left === cur) parent.left = child; else parent.right = child;
          }
          nodesMap.delete(cur.id);
          return { deleted:cur, replaced:child, path, swapped:false };
        }
      }

      // Layout computation: compute inorder positions for x, y by depth
      function layoutTree(){
        const positions = {};
        let index = 0;
        function inorder(n, depth){
          if (!n) return;
          inorder(n.left, depth+1);
          const x = (index + 1) * (viewW / (Math.max(1, totalCount())));
          const y = 30 + depth * levelGap;
          positions[n.id] = { x, y, depth };
          index++;
          inorder(n.right, depth+1);
        }
        inorder(root, 0);
        return positions;
      }

      function totalCount(){
        let c = 0;
        (function traverse(n){ if(!n) return; c++; traverse(n.left); traverse(n.right); })(root);
        return Math.max(1, c);
      }

      // Render tree to SVG
      function renderTree(highlights = { visited:[], found:null, removing:null }, animate=true){
        // compute positions
        const positions = layoutTree();

        // Build a flat array of nodes
        const nodeArr = [];
        (function collect(n){
          if(!n) return;
          nodeArr.push(n);
          collect(n.left); collect(n.right);
        })(root);

        // Clear svg
        while(svg.firstChild) svg.removeChild(svg.firstChild);

        // Draw links first
        nodeArr.forEach(n=>{
          if (n.left){
            const p = positions[n.id];
            const c = positions[n.left.id];
            if (p && c){
              const line = document.createElementNS('http://www.w3.org/2000/svg','line');
              line.setAttribute('x1', p.x);
              line.setAttribute('y1', p.y + nodeRadius);
              line.setAttribute('x2', c.x);
              line.setAttribute('y2', c.y - nodeRadius);
              line.setAttribute('class','link');
              if (highlights.visited.some(v=>v && v.id === n.id && v.next && v.next.id === n.left.id)) {
                line.classList.add('visited');
              }
              svg.appendChild(line);
            }
          }
          if (n.right){
            const p = positions[n.id];
            const c = positions[n.right.id];
            if (p && c){
              const line = document.createElementNS('http://www.w3.org/2000/svg','line');
              line.setAttribute('x1', p.x);
              line.setAttribute('y1', p.y + nodeRadius);
              line.setAttribute('x2', c.x);
              line.setAttribute('y2', c.y - nodeRadius);
              line.setAttribute('class','link');
              if (highlights.visited.some(v=>v && v.id === n.id && v.next && v.next.id === n.right.id)) {
                line.classList.add('visited');
              }
              svg.appendChild(line);
            }
          }
        });

        // Draw nodes
        nodeArr.forEach(n=>{
          const pos = positions[n.id] || {x: viewW/2, y:30};
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('class','node-group');
          g.setAttribute('data-id', n.id);
          g.setAttribute('transform', `translate(${pos.x},${pos.y})`);
          g.setAttribute('tabindex','0');
          g.setAttribute('role','button');
          g.setAttribute('aria-label', `Node ${n.val}`);
          // circle
          const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circ.setAttribute('r', nodeRadius);
          circ.setAttribute('class','node-circle');
          g.appendChild(circ);
          // text
          const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
          txt.setAttribute('class','node-text');
          txt.textContent = n.val;
          g.appendChild(txt);

          // highlight classes
          if (highlights.visited.some(v=>v && v.id === n.id)) g.classList.add('visited');
          if (highlights.found && highlights.found.id === n.id) g.classList.add('found');
          if (highlights.removing && highlights.removing.id === n.id) g.classList.add('removing');

          // click to delete
          g.addEventListener('click', (evt)=>{
            evt.stopPropagation();
            if (confirm(`Delete node ${n.val}?`)){
              performDelete(n.val);
            }
          });
          // keyboard delete on Enter or Space
          g.addEventListener('keydown', (evt)=>{
            if (evt.key === 'Enter' || evt.key === ' ') {
              evt.preventDefault();
              if (confirm(`Delete node ${n.val}?`)){
                performDelete(n.val);
              }
            }
          });

          svg.appendChild(g);
        });

        // update inorder text
        const inorderVals = [];
        (function inorder(n){
          if(!n) return;
          inorder(n.left); inorderVals.push(n.val); inorder(n.right);
        })(root);
        inorderEl.textContent = inorderVals.length ? inorderVals.join(', ') : '— empty —';
      }

      // Animated insertion: highlight path nodes sequentially then place node
      function animatePath(path, targetNode=null, cb){
        comparisons = 0;
        compCountEl.textContent = 0;
        if (!isStepping){
          // play automatically
          let i = 0;
          function step(){
            if (i < path.length){
              comparisons++;
              compCountEl.textContent = comparisons;
              renderTree({ visited: path.slice(0, i+1).map((n,idx)=>{
                const obj = { id: n.id, next: path[idx+1] || null };
                return obj;
              }) });
              i++;
              pendingAnim = setTimeout(step, 520);
            } else {
              // final render: show found/inserted node
              if (targetNode) {
                renderTree({ visited: path.map((n,idx)=>({id:n.id, next:path[idx+1]||null})), found: targetNode });
              } else {
                renderTree({ visited: path.map((n,idx)=>({id:n.id, next:path[idx+1]||null})) });
              }
              pendingAnim = null;
              if (cb) cb();
            }
          }
          step();
        } else {
          // Step mode: initialize stepIndex and store currentPath
          currentPath = path.slice();
          stepIndex = -1;
          renderTree({ visited: [], found: null });
          if (cb) cb();
        }
      }

      function stepNext(){
        if (!isStepping || currentPath.length === 0) return;
        if (stepIndex < currentPath.length - 1) stepIndex++;
        comparisons = stepIndex + 1;
        compCountEl.textContent = comparisons;
        const visited = currentPath.slice(0, stepIndex+1).map((n, idx)=>({ id:n.id, next: currentPath[idx+1] || null }));
        renderTree({ visited });
      }
      function stepPrev(){
        if (!isStepping || currentPath.length === 0) return;
        if (stepIndex > -1) stepIndex--;
        comparisons = Math.max(0, stepIndex + 1);
        compCountEl.textContent = comparisons;
        const visited = currentPath.slice(0, stepIndex+1).map((n, idx)=>({ id:n.id, next: currentPath[idx+1] || null }));
        renderTree({ visited });
      }

      // Public operations triggered by UI

      function performInsert(){
        const v = Number(valueInput.value);
        if (!Number.isFinite(v)){ alert('Please enter a valid number.'); return; }
        const result = bstInsert(v);
        if (result.duplicate){
          log(`Insert ${v} skipped (duplicate).`);
          renderTree({ visited: result.path.map((n,idx)=>({id:n.id, next: result.path[idx+1] || null})) });
          return;
        }
        log(`Insert ${v} — visiting ${result.path.length} node(s).`);
        animatePath(result.path, result.inserted, ()=>{
          // finalize: re-render to place nodes in their computed positions
          setTimeout(()=> renderTree({ visited: [], found: result.inserted }), transitionMs+40);
        });
      }

      function performSearch(){
        const v = Number(valueInput.value);
        if (!Number.isFinite(v)){ alert('Please enter a valid number.'); return; }
        const res = bstSearch(v);
        log(`Search ${v} — visited ${res.path.length} node(s). ${res.found ? 'Found.' : 'Not found.'}`);
        animatePath(res.path, res.found, ()=> {
          setTimeout(()=> renderTree({ visited: [], found: res.found }), transitionMs+40);
        });
      }

      function performDelete(valInput){
        const val = arguments.length ? valInput : Number(valueInput.value);
        if (!Number.isFinite(val)){ alert('Please enter a valid number.'); return; }
        const res = bstDelete(val);
        if (!res.deleted){
          log(`Delete ${val} — not found.`);
          renderTree({ visited: res.path.map((n,idx)=>({id:n.id, next: res.path[idx+1] || null})) });
          return;
        }
        log(`Delete ${val} — visited ${res.path.length} node(s). ${res.swapped? 'Replaced by successor.' : 'Removed.'}`);
        // animate path highlight then structural update
        animatePath(res.path, res.deleted, ()=>{
          // mark removing node briefly
          renderTree({ visited: res.path.map((n,idx)=>({id:n.id, next: res.path[idx+1] || null})), removing: res.deleted });
          setTimeout(()=>{ renderTree({ visited: [], found: null }); }, transitionMs + 120);
        });
      }

      // helpers
      function randomize(n=7){
        const set = new Set();
        while(set.size < n){
          const r = Math.floor(Math.random()*99) + 1;
          set.add(r);
        }
        const vals = Array.from(set);
        let i = 0;
        function insNext(){
          if (i >= vals.length) return;
          valueInput.value = vals[i++];
          performInsert();
          setTimeout(insNext, 300);
        }
        insNext();
      }

      // Event wire-up
      insertBtn.addEventListener('click', ()=>{ if (pendingAnim) clearTimeout(pendingAnim); performInsert(); });
      searchBtn.addEventListener('click', ()=>{ if (pendingAnim) clearTimeout(pendingAnim); performSearch(); });
      deleteBtn.addEventListener('click', ()=>{ if (pendingAnim) clearTimeout(pendingAnim); performDelete(); });
      clearBtn.addEventListener('click', ()=>{
        if (!confirm('Clear entire tree?')) return;
        root = null; nodesMap.clear(); nodeIdCounter = 1;
        log('Cleared tree.');
        renderTree();
        compCountEl.textContent = '0';
      });
      randomBtn.addEventListener('click', ()=> randomize(6));

      stepToggle.addEventListener('change', (e)=>{
        isStepping = e.target.checked;
        if (!isStepping){
          // reset step mode
          currentPath = [];
          stepIndex = -1;
          renderTree();
        } else {
          log('Step mode enabled. Use Next/Prev to advance comparisons.');
        }
      });
      nextStep.addEventListener('click', ()=>{ stepNext(); });
      prevStep.addEventListener('click', ()=>{ stepPrev(); });

      // keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter' && document.activeElement === valueInput){
          insertBtn.click();
        }
        if (e.key === 'f' && (e.ctrlKey || e.metaKey)){
          e.preventDefault();
          searchBtn.click();
        }
      });

      // initial render
      renderTree();
      log('BST Explorer ready. Insert some values to begin.');

      // Accessibility: resize handling - recompute viewBox maybe not necessary, but keep responsive
      window.addEventListener('resize', ()=> setTimeout(()=> renderTree(), 120));

    })();
  </script>
</body>
</html>