[
  {
    "id": "ab039320-bdd4-11f0-bd8d-55214871deb0",
    "timestamp": "2025-11-10T01:29:14.834Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Queue",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Queue Module — FIFO Visualization</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#3b82f6;\n      --muted:#94a3b8;\n      --success:#10b981;\n      --danger:#ef4444;\n      --box-w:84px;\n      --box-h:56px;\n    }\n    /* Safe area margins */\n    html,body{height:100%;}\n    body{\n      margin:0;\n      padding:var(--safe-margin);\n      font-family:Inter, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background:linear-gradient(180deg,#071029 0%, #071020 100%);\n      color:#e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      box-sizing:border-box;\n    }\n    *{box-sizing:inherit}\n    h1{margin:0 0 8px 0; font-size:20px;}\n    p{margin:0 0 12px 0; color:var(--muted); line-height:1.4}\n    .container{\n      display:flex;\n      gap:var(--gap);\n      align-items:stretch;\n      min-height:60vh;\n    }\n    /* Responsive: stack on narrow screens */\n    @media (max-width:880px){\n      .container{flex-direction:column;}\n    }\n\n    /* Left column: descriptors */\n    .doc{\n      flex:1 1 360px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:10px;\n      padding:20px;\n      min-width:280px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .section-title{font-weight:600; font-size:13px; color:var(--accent); margin-top:6px}\n    .list{font-size:13px; color:var(--muted); margin-left:8px}\n\n    /* Right column: interactive module */\n    .module{\n      flex:1 1 520px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:10px;\n      padding:20px;\n      min-width:320px;\n      display:flex;\n      flex-direction:column;\n      gap:16px;\n    }\n\n    /* Controls area */\n    .controls{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .controls > *{min-height:40px}\n    input[type=\"text\"], input[type=\"number\"]{\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background:transparent;\n      color:inherit;\n      min-width:120px;\n      outline:none;\n    }\n    input[type=\"text\"]::placeholder{color:rgba(230,238,248,0.5)}\n    .btn{\n      padding:8px 12px;\n      border-radius:8px;\n      border:none;\n      cursor:pointer;\n      background:rgba(59,130,246,0.12);\n      color:var(--accent);\n      font-weight:600;\n      transition:transform .12s ease, box-shadow .12s;\n      min-width:84px;\n    }\n    .btn:active{transform:translateY(1px)}\n    .btn.secondary{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.04);\n      color:var(--muted);\n      font-weight:600;\n    }\n    .btn.ghost{\n      background:transparent;\n      color:var(--muted);\n      border:1px dashed rgba(255,255,255,0.03);\n      min-width:44px;\n    }\n\n    .controls-left{display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap;}\n\n    /* Visualization area */\n    .visual{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      align-items:stretch;\n      padding:8px;\n    }\n    .queue-area{\n      background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:10px;\n      padding:18px;\n      min-height:150px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      position:relative;\n      overflow:hidden;\n    }\n    .queue-line{\n      display:flex;\n      gap:14px;\n      align-items:center;\n      padding:8px;\n      transition:all .28s ease;\n      min-height: calc(var(--box-h) + 16px);\n      flex-wrap:wrap;\n    }\n    .slot{\n      width:var(--box-w);\n      height:var(--box-h);\n      border-radius:8px;\n      background:rgba(255,255,255,0.02);\n      border:1px dashed rgba(255,255,255,0.03);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      color:var(--muted);\n      font-weight:700;\n      position:relative;\n      flex:0 0 auto;\n    }\n    .node{\n      width:var(--box-w);\n      height:var(--box-h);\n      border-radius:8px;\n      background:linear-gradient(180deg, rgba(59,130,246,0.18), rgba(59,130,246,0.08));\n      border:1px solid rgba(59,130,246,0.18);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      color: #e6f0ff;\n      font-weight:700;\n      font-size:15px;\n      box-shadow: 0 6px 18px rgba(11,37,84,0.25);\n      transform:translateY(0);\n      opacity:1;\n      transition:transform .28s cubic-bezier(.2,.9,.3,1), opacity .22s ease;\n    }\n    /* entrance and exit */\n    .node.enter{transform:translateY(20px); opacity:0;}\n    .node.enter.node--active{transform:translateY(0); opacity:1;}\n    .node.exit{transform:translateY(-20px); opacity:0;}\n\n    .badge{\n      position:absolute;\n      top:6px;\n      font-size:12px;\n      padding:6px 8px;\n      border-radius:999px;\n      background:rgba(2,6,23,0.7);\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.02);\n      transform:translateX(-50%);\n      pointer-events:none;\n      white-space:nowrap;\n    }\n\n    /* head/tail small markers */\n    .marker{\n      position:absolute;\n      top:-10px;\n      font-size:12px;\n      padding:6px 8px;\n      border-radius:999px;\n      background:var(--panel);\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.03);\n      transform:translateX(-50%);\n      transition:left .28s ease;\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n    .marker .dot{width:8px; height:8px; border-radius:50%}\n    .marker.head .dot{background:var(--success)}\n    .marker.tail .dot{background:var(--accent)}\n\n    /* Status area */\n    .status{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:space-between;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .status .msg{min-height:20px}\n    .status .capacity{font-weight:700; color:var(--muted)}\n\n    /* log */\n    .log{\n      max-height:120px;\n      overflow:auto;\n      padding:8px;\n      border-radius:8px;\n      background:rgba(255,255,255,0.01);\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* feedback styles: full/empty */\n    .indicator{\n      padding:6px 8px;\n      border-radius:8px;\n      color:#07202a;\n      background:rgba(255,255,255,0.04);\n      font-weight:700;\n      font-size:13px;\n    }\n    .indicator.full{background:linear-gradient(90deg,var(--danger), #f97316); color:white;}\n    .indicator.empty{background:linear-gradient(90deg,#94a3b8,#64748b); color:white;}\n\n    /* shake animation */\n    @keyframes shake {\n      0%{transform:translateX(0)} 20%{transform:translateX(-6px)} 40%{transform:translateX(6px)} 60%{transform:translateX(-4px)} 80%{transform:translateX(4px)} 100%{transform:translateX(0)}\n    }\n    .shake{animation:shake .48s cubic-bezier(.36,.07,.19,.97);}\n\n    /* small helpers */\n    .muted{color:var(--muted); font-size:13px}\n    .sr-only{position:absolute; left:-10000px; width:1px; height:1px; overflow:hidden}\n  </style>\n</head>\n<body>\n  <main style=\"display:flex;flex-direction:column;gap:16px;\">\n    <!-- Header -->\n    <header style=\"display:flex;flex-direction:column;gap:6px;\">\n      <h1>Queue — FIFO (First In, First Out) Interactive Module</h1>\n      <p class=\"muted\">Explore how a Queue stores items in a first-in-first-out order. Use the controls below to enqueue values, dequeue them, peek at the front, and observe head/tail movement and overflow/underflow behaviors.</p>\n    </header>\n\n    <div class=\"container\" role=\"region\" aria-label=\"Queue learning module container\">\n      <!-- Documentation / Planning Column -->\n      <aside class=\"doc\" aria-labelledby=\"doc-title\">\n        <div>\n          <div id=\"doc-title\" class=\"section-title\">Concept Title</div>\n          <div style=\"font-weight:700; margin-top:8px\">Queue (FIFO) — Enqueue, Dequeue, Peek</div>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Learning Objective</div>\n          <p class=\"list\">\n            After interacting with this module you will:\n            <ul style=\"margin:8px 0 0 18px; color:var(--muted);\">\n              <li>Understand FIFO order (first enqueued, first dequeued).</li>\n              <li>Visualize how head and tail move with each operation.</li>\n              <li>Observe overflow (when capacity is reached) and underflow (when empty).</li>\n            </ul>\n          </p>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Interaction Design</div>\n          <p class=\"list\">\n            - Users type a value and press \"Enqueue\" (or Enter). The new node animates into the queue at the tail.<br>\n            - Press \"Dequeue\" to remove the head; the head node animates out and remaining nodes shift left. A short text announcement describes the result.<br>\n            - \"Peek\" highlights the front item without removing it. Invalid actions (enqueue to full queue, dequeue from empty) produce a shake + error message.<br>\n            - Capacity can be changed; adjusting lower than current size prevents change unless cleared.<br>\n            - Visual feedback includes animated entry/exit, head/tail badges repositioning, color cues for full/empty states, and a live log of operations.\n          </p>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Layout Description</div>\n          <p class=\"list\">\n            - Two-column layout: left column contains textual guidance and objectives; right column contains the interactive module.<br>\n            - Safe area margins: 24 px on all sides of the viewport. Minimum spacing between interactive elements: 16 px.<br>\n            - Controls at top of the module (input, buttons, capacity) use horizontal flow and wrap on small screens. The visualization appears below with head/tail badges anchored above the relevant node. A status and operation log are at the bottom.<br>\n            - Accessibility: buttons have visible focus styles, inputs accept keyboard Enter, and there's an ARIA live region announcing operations. The layout is responsive: stacks on narrow screens with consistent padding and spacing.\n          </p>\n        </div>\n      </aside>\n\n      <!-- Interactive Module -->\n      <section class=\"module\" aria-labelledby=\"module-title\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <div id=\"module-title\" style=\"font-weight:700\">Interactive Queue</div>\n          <div class=\"muted\" style=\"font-size:13px\">Capacity is bounded for learning overflow</div>\n        </div>\n\n        <!-- Controls -->\n        <div class=\"controls\" role=\"form\" aria-label=\"Queue controls\">\n          <div class=\"controls-left\" style=\"gap:var(--gap);\">\n            <label for=\"value\" class=\"sr-only\">Value to enqueue</label>\n            <input id=\"value\" type=\"text\" placeholder=\"Value (e.g., A, 42)\" aria-label=\"Value to enqueue\">\n            <button id=\"enqueueBtn\" class=\"btn\" aria-controls=\"queue-line\">Enqueue</button>\n            <button id=\"dequeueBtn\" class=\"btn secondary\" aria-controls=\"queue-line\">Dequeue</button>\n            <button id=\"peekBtn\" class=\"btn ghost\" aria-controls=\"queue-line\">Peek</button>\n          </div>\n\n          <div style=\"display:flex;gap:var(--gap);align-items:center;\">\n            <label for=\"capacity\" class=\"muted\">Capacity</label>\n            <input id=\"capacity\" type=\"number\" min=\"1\" max=\"12\" value=\"6\" style=\"width:84px\" aria-label=\"Queue capacity\">\n            <button id=\"clearBtn\" class=\"btn secondary\" title=\"Clear all\" aria-label=\"Clear queue\">Clear</button>\n          </div>\n        </div>\n\n        <!-- Visualization -->\n        <div class=\"visual\" aria-hidden=\"false\">\n          <div class=\"queue-area\" role=\"region\" aria-label=\"Queue visualization\">\n            <div class=\"queue-line\" id=\"queue-line\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n            <div class=\"marker head\" id=\"marker-head\" style=\"left:0; display:none;\"><span class=\"dot\"></span> head</div>\n            <div class=\"marker tail\" id=\"marker-tail\" style=\"left:0; display:none;\"><span class=\"dot\"></span> tail</div>\n          </div>\n\n          <div class=\"status\" role=\"status\" aria-live=\"polite\">\n            <div class=\"msg\" id=\"message\">Ready — enqueue a value to start</div>\n            <div style=\"display:flex;gap:12px;align-items:center;\">\n              <div id=\"stateIndicator\" class=\"indicator\" aria-hidden=\"true\">Idle</div>\n              <div class=\"capacity muted\" id=\"capLabel\">0 / 6</div>\n            </div>\n          </div>\n\n          <div class=\"log\" id=\"log\" aria-live=\"polite\" aria-atomic=\"false\">\n            <!-- operation log -->\n          </div>\n        </div>\n      </section>\n    </div>\n  </main>\n\n  <script>\n    // Queue interactive module (vanilla JS)\n    (function(){\n      // DOM\n      const valueInput = document.getElementById('value');\n      const enqueueBtn = document.getElementById('enqueueBtn');\n      const dequeueBtn = document.getElementById('dequeueBtn');\n      const peekBtn = document.getElementById('peekBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const capacityInput = document.getElementById('capacity');\n      const queueLine = document.getElementById('queue-line');\n      const messageEl = document.getElementById('message');\n      const capLabel = document.getElementById('capLabel');\n      const logEl = document.getElementById('log');\n      const indicator = document.getElementById('stateIndicator');\n      const markerHead = document.getElementById('marker-head');\n      const markerTail = document.getElementById('marker-tail');\n\n      // State\n      let capacity = parseInt(capacityInput.value, 10) || 6;\n      let items = []; // stores objects {value, id}\n      let idCounter = 0;\n\n      // Accessibility: live region for announcements\n      function announce(text){\n        messageEl.textContent = text;\n      }\n\n      function addLog(text){\n        const time = new Date().toLocaleTimeString();\n        const el = document.createElement('div');\n        el.textContent = `[${time}] ${text}`;\n        logEl.prepend(el);\n      }\n\n      function updateCapacityLabel(){\n        capLabel.textContent = `${items.length} / ${capacity}`;\n        if(items.length === 0){\n          indicator.textContent = 'Empty';\n          indicator.classList.remove('full');\n          indicator.classList.add('empty');\n        } else if(items.length >= capacity){\n          indicator.textContent = 'Full';\n          indicator.classList.add('full');\n          indicator.classList.remove('empty');\n        } else {\n          indicator.textContent = 'Active';\n          indicator.classList.remove('full','empty');\n          indicator.style.background = 'rgba(255,255,255,0.04)';\n          indicator.style.color = 'var(--muted)';\n        }\n      }\n\n      // Visual helpers\n      function createNodeElement(item){\n        const node = document.createElement('div');\n        node.className = 'node enter';\n        node.setAttribute('data-id', item.id);\n        node.setAttribute('role', 'listitem');\n        node.setAttribute('aria-label', `Item ${item.value}`);\n        node.textContent = item.value;\n        return node;\n      }\n\n      function positionMarkers(){\n        // If no items, hide markers\n        if(items.length === 0){\n          markerHead.style.display = 'none';\n          markerTail.style.display = 'none';\n          return;\n        }\n        // get first and last child bounding rect relative to queueLine\n        const children = queueLine.children;\n        if(children.length === 0){\n          markerHead.style.display = 'none';\n          markerTail.style.display = 'none';\n          return;\n        }\n        const firstRect = children[0].getBoundingClientRect();\n        const lastRect = children[children.length - 1].getBoundingClientRect();\n        const containerRect = queueLine.getBoundingClientRect();\n        // compute left as percentage relative to queue-line\n        const headLeft = (firstRect.left + firstRect.width/2) - containerRect.left;\n        const tailLeft = (lastRect.left + lastRect.width/2) - containerRect.left;\n        markerHead.style.display = 'flex';\n        markerTail.style.display = 'flex';\n        markerHead.style.left = headLeft + 'px';\n        markerTail.style.left = tailLeft + 'px';\n      }\n\n      // Enqueue with animation\n      function enqueue(value){\n        if(items.length >= capacity){\n          // invalid: overflow\n          flashInvalid('Queue overflow — cannot enqueue (full).');\n          addLog(`ENQUEUE ${value} — FAILED (overflow)`);\n          return;\n        }\n        const id = (++idCounter);\n        const item = {value: String(value), id};\n        items.push(item);\n        const node = createNodeElement(item);\n        queueLine.appendChild(node);\n\n        // force reflow then activate transition to animate entrance\n        requestAnimationFrame(()=> {\n          node.classList.add('node--active');\n        });\n\n        // remove enter class after transition completes\n        node.addEventListener('transitionend', function te(e){\n          if(e.propertyName === 'transform'){\n            node.classList.remove('enter','node--active');\n            node.removeEventListener('transitionend', te);\n          }\n        });\n\n        addLog(`ENQUEUE ${value}`);\n        announce(`Enqueued ${value}.`);\n        updateCapacityLabel();\n        positionMarkers();\n      }\n\n      // Dequeue with animation\n      function dequeue(){\n        if(items.length === 0){\n          flashInvalid('Queue underflow — nothing to dequeue.');\n          addLog('DEQUEUE — FAILED (underflow)');\n          return;\n        }\n        // remove head visually with exit animation\n        const child = queueLine.querySelector('.node[data-id]');\n        const id = items.shift().id;\n        if(child){\n          child.classList.add('exit');\n          // after transition, remove element\n          child.addEventListener('transitionend', function te(){\n            child.removeEventListener('transitionend', te);\n            if(child.parentNode) child.parentNode.removeChild(child);\n            // reposition markers after DOM updates\n            positionMarkers();\n          });\n        }\n        addLog('DEQUEUE -> removed head');\n        announce('Dequeued head item.');\n        updateCapacityLabel();\n        positionMarkers();\n      }\n\n      // Peek: highlight head temporarily\n      function peek(){\n        if(items.length === 0){\n          flashInvalid('Queue is empty — nothing to peek.');\n          addLog('PEEK — FAILED (empty)');\n          return;\n        }\n        const firstNode = queueLine.querySelector('.node');\n        if(!firstNode) return;\n        firstNode.style.transition = 'box-shadow .18s ease, transform .18s ease';\n        const original = firstNode.style.boxShadow;\n        firstNode.style.boxShadow = '0 10px 26px rgba(59,130,246,0.35)';\n        firstNode.style.transform = 'translateY(-6px)';\n        addLog(`PEEK -> ${items[0].value}`);\n        announce(`Peek: ${items[0].value}`);\n        setTimeout(()=>{\n          firstNode.style.boxShadow = '';\n          firstNode.style.transform = '';\n        }, 520);\n      }\n\n      // Clear queue\n      function clearQueue(){\n        if(items.length === 0){\n          addLog('CLEAR -> already empty');\n          announce('Queue already empty.');\n          return;\n        }\n        // animate fade out for all nodes\n        const nodes = Array.from(queueLine.querySelectorAll('.node'));\n        nodes.forEach((n, i) => {\n          setTimeout(()=> {\n            n.classList.add('exit');\n            n.addEventListener('transitionend', function te(){\n              n.removeEventListener('transitionend', te);\n              if(n.parentNode) n.parentNode.removeChild(n);\n            });\n          }, i * 40);\n        });\n        items = [];\n        addLog('CLEAR -> emptied queue');\n        announce('Cleared queue.');\n        updateCapacityLabel();\n        positionMarkers();\n      }\n\n      // Invalid action feedback (shake + message)\n      function flashInvalid(msg){\n        announce(msg);\n        messageEl.style.color = 'var(--danger)';\n        messageEl.textContent = msg;\n        queueLine.classList.add('shake');\n        setTimeout(()=> {\n          queueLine.classList.remove('shake');\n          messageEl.style.color = '';\n          messageEl.textContent = 'Ready';\n        }, 520);\n      }\n\n      // event handlers\n      enqueueBtn.addEventListener('click', () => {\n        const v = valueInput.value.trim();\n        if(v === '') {\n          valueInput.focus();\n          flashInvalid('Please enter a value to enqueue.');\n          return;\n        }\n        enqueue(v);\n        valueInput.value = '';\n        valueInput.focus();\n      });\n\n      dequeueBtn.addEventListener('click', () => {\n        dequeue();\n      });\n\n      peekBtn.addEventListener('click', () => {\n        peek();\n      });\n\n      clearBtn.addEventListener('click', () => {\n        clearQueue();\n      });\n\n      capacityInput.addEventListener('change', () => {\n        const newCap = parseInt(capacityInput.value, 10) || 1;\n        if(newCap < items.length){\n          // can't decrease below current size — reject and notify\n          capacityInput.value = capacity;\n          flashInvalid('Capacity cannot be less than current size. Clear first to reduce.');\n          return;\n        }\n        capacity = newCap;\n        addLog(`Capacity set to ${capacity}`);\n        announce(`Capacity set to ${capacity}`);\n        updateCapacityLabel();\n      });\n\n      // keyboard: Enter in input enqueues\n      valueInput.addEventListener('keydown', (e) => {\n        if(e.key === 'Enter'){\n          enqueueBtn.click();\n        }\n      });\n\n      // Resize observer to reposition markers when layout changes\n      const ro = new ResizeObserver(()=> positionMarkers());\n      ro.observe(queueLine);\n      window.addEventListener('resize', positionMarkers);\n\n      // Initialize\n      updateCapacityLabel();\n      positionMarkers();\n      addLog('Module ready');\n\n      // For demo: add a couple of initial enqueues silently (optional)\n      // enqueue('A'); enqueue('B');\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Queue.\n\n**Project Overview:**\nTopic: Queue\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Queue"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "ae4c2e70-bdd4-11f0-bd8d-55214871deb0",
    "timestamp": "2025-11-10T01:29:20.343Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Linked List",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Linked List Explorer</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --node-bg: #ffffff;\n      --accent: #2563eb;\n      --accent-2: #10b981;\n      --muted: #6b7280;\n      --danger: #ef4444;\n      --surface: #f8fafc;\n      --shadow: 0 6px 18px rgba(16,24,40,0.08);\n      --radius: 10px;\n      --node-width: 96px;\n      --node-height: 56px;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n\n    html,body{\n      height: 100%;\n      margin: 0;\n      background: linear-gradient(180deg,#f1f5f9 0%, #ffffff 100%);\n      color: #0f172a;\n    }\n\n    .app{\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height: 100%;\n      display: grid;\n      grid-template-columns: 400px 1fr;\n      gap: var(--gap);\n    }\n\n    /* Responsive: stack columns under 880px */\n    @media (max-width: 880px){\n      .app{\n        grid-template-columns: 1fr;\n        padding: 16px; /* still keep comfortable */\n      }\n    }\n\n    /* Left panel: info & plan */\n    .panel{\n      background: var(--surface);\n      border-radius: 12px;\n      padding: 20px;\n      box-shadow: var(--shadow);\n      min-width: 0;\n    }\n\n    .title{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      margin-bottom: 12px;\n    }\n\n    .title h1{\n      margin:0;\n      font-size: 20px;\n      line-height:1;\n    }\n\n    .meta{\n      font-size: 13px;\n      color: var(--muted);\n      margin-bottom: 14px;\n    }\n\n    .section{\n      margin-bottom: 18px;\n    }\n\n    .section h3{\n      margin: 0 0 8px 0;\n      font-size: 14px;\n    }\n\n    .section p, .section li{\n      margin: 0;\n      font-size: 13px;\n      color: #0f172a;\n    }\n\n    .list{\n      padding-left: 18px;\n      margin-top: 6px;\n      color: var(--muted);\n      font-size: 13px;\n    }\n\n    /* Right: interactive workspace */\n    .workspace{\n      background: white;\n      border-radius: 12px;\n      padding: 18px;\n      box-shadow: var(--shadow);\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n      min-height: 420px;\n      overflow: hidden;\n    }\n\n    .controls{\n      display:flex;\n      gap: var(--gap);\n      flex-wrap:wrap;\n      align-items:center;\n    }\n\n    .group{\n      background: #fff;\n      border-radius: 8px;\n      padding: 10px;\n      display:flex;\n      gap:8px;\n      align-items:center;\n      box-shadow: 0 2px 6px rgba(2,6,23,0.04);\n    }\n\n    .group label{\n      font-size: 13px;\n      color: var(--muted);\n    }\n\n    input[type=\"text\"], input[type=\"number\"]{\n      height: 36px;\n      border-radius: 8px;\n      border: 1px solid #e6edf3;\n      padding: 8px 10px;\n      font-size: 14px;\n      min-width: 120px;\n    }\n\n    input[type=\"number\"]{\n      width: 90px;\n    }\n\n    button{\n      background: var(--accent);\n      color: white;\n      border: none;\n      border-radius: 8px;\n      padding: 8px 12px;\n      cursor: pointer;\n      font-weight: 600;\n      font-size: 13px;\n      height: 36px;\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n    }\n\n    button.ghost{\n      background: transparent;\n      color: var(--accent);\n      border: 1px solid rgba(37,99,235,0.12);\n    }\n\n    button.warn{\n      background: var(--danger);\n    }\n\n    button.small{\n      padding: 6px 8px;\n      height: 32px;\n      font-size: 13px;\n    }\n\n    .canvas-wrap{\n      flex:1;\n      border-radius: 10px;\n      background: linear-gradient(180deg, #ffffff 0%, #fbfdff 100%);\n      border: 1px dashed rgba(15,23,42,0.06);\n      padding: 14px;\n      position: relative;\n      overflow: auto;\n    }\n\n    /* Node list area */\n    .list-area{\n      min-height: 160px;\n      display:flex;\n      align-items:flex-start;\n      gap: 32px;\n      padding: 12px;\n      box-sizing: border-box;\n      position: relative;\n      width: max-content;\n      min-width: 100%;\n      transition: height .2s ease;\n    }\n\n    .nodes-row{\n      display:flex;\n      align-items:center;\n      gap: 22px;\n      padding: 12px;\n    }\n\n    .node{\n      width: var(--node-width);\n      height: var(--node-height);\n      background: var(--node-bg);\n      border-radius: 10px;\n      display:flex;\n      align-items:center;\n      justify-content: space-between;\n      padding: 0 10px;\n      box-shadow: 0 2px 8px rgba(2,6,23,0.06);\n      position: relative;\n      transition: transform .35s cubic-bezier(.2,.9,.2,1), opacity .25s ease, box-shadow .15s ease;\n      flex-shrink: 0;\n    }\n\n    .node .value{\n      font-weight: 700;\n      font-size: 15px;\n      color: #0f172a;\n      text-align:left;\n    }\n\n    .node .next-box{\n      width: 30px;\n      height: calc(var(--node-height) - 20px);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      border-left: 1px dashed rgba(15,23,42,0.06);\n      margin-left: 8px;\n      color: var(--muted);\n      font-size: 12px;\n    }\n\n    .node.head{\n      box-shadow: 0 6px 20px rgba(37,99,235,0.08);\n      border: 1px solid rgba(37,99,235,0.08);\n    }\n\n    .node.active{\n      transform: scale(1.05);\n      box-shadow: 0 10px 30px rgba(2,6,23,0.12);\n      outline: 3px solid rgba(16,185,129,0.08);\n    }\n\n    .node.removing{\n      opacity: 0;\n      transform: translateY(18px) scale(.95);\n    }\n\n    .node.incoming{\n      transform: translateY(-16px) scale(.98);\n      opacity: 0;\n    }\n\n    .label-head{\n      position:absolute;\n      top: -18px;\n      left: 10px;\n      font-size: 12px;\n      color: var(--accent);\n      background: rgba(37,99,235,0.06);\n      padding: 4px 8px;\n      border-radius: 8px;\n      font-weight:600;\n    }\n\n    /* SVG overlay for arrows */\n    .svg-overlay{\n      position:absolute;\n      inset:0;\n      pointer-events:none;\n    }\n\n    /* status / structure details */\n    .status{\n      display:flex;\n      gap: var(--gap);\n      align-items:center;\n      justify-content: space-between;\n    }\n\n    .structure{\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n      background: #0f172a;\n      color: white;\n      padding: 8px 12px;\n      border-radius: 8px;\n      font-size: 13px;\n    }\n\n    .vis-help{\n      font-size: 13px;\n      color: var(--muted);\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n\n    .sr-only{\n      position:absolute;\n      width:1px;\n      height:1px;\n      margin:-1px;\n      clip:rect(0 0 0 0);\n      overflow:hidden;\n      border:0;\n      padding:0;\n    }\n\n    footer.note{\n      font-size: 13px;\n      color: var(--muted);\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content: flex-end;\n    }\n\n    /* small responsive tweaks */\n    @media (max-width:480px){\n      .nodes-row{ gap: 14px;}\n      .node{ width: 82px; height:48px; }\n    }\n\n    /* animated stroke class */\n    .arrow-path{\n      stroke: rgba(15,23,42,0.22);\n      stroke-width: 2;\n      fill: none;\n      stroke-linecap: round;\n      stroke-linejoin: round;\n    }\n    .arrow-path.draw{\n      transition: stroke-dashoffset .6s cubic-bezier(.2,.9,.2,1);\n    }\n\n    /* live announcer */\n    #liveAnnouncer{\n      position:absolute;\n      left:-9999px;\n      top:auto;\n      width:1px;\n      height:1px;\n      overflow:hidden;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Linked List Interactive Module\">\n    <!-- Left panel: Design Plan -->\n    <aside class=\"panel\" aria-labelledby=\"conceptTitle\">\n      <div class=\"title\">\n        <svg width=\"36\" height=\"36\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n          <rect x=\"2\" y=\"6\" width=\"8\" height=\"12\" rx=\"2\" fill=\"#10B981\"></rect>\n          <rect x=\"14\" y=\"4\" width=\"8\" height=\"16\" rx=\"2\" fill=\"#2563EB\"></rect>\n        </svg>\n        <div>\n          <h1 id=\"conceptTitle\">Linked List — Visual and Interactive</h1>\n          <div class=\"meta\">One concept: Singly Linked List (structure & basic operations)</div>\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <h3>Learning Objective</h3>\n        <p>After interacting with this module you will be able to:</p>\n        <ul class=\"list\">\n          <li>Understand how a singly linked list stores nodes with \"value\" and \"next\".</li>\n          <li>Visually perform and observe insert (head/tail/after), delete, and traversal operations.</li>\n          <li>See how pointer (head) and node connections change step-by-step.</li>\n        </ul>\n      </div>\n\n      <div class=\"section\">\n        <h3>Interaction Design</h3>\n        <p>How to interact:</p>\n        <ul class=\"list\">\n          <li>Use the input and buttons to insert a node at the head, append to tail, or insert after a node index.</li>\n          <li>Delete nodes by index. Visual animations show nodes being added or removed, and arrows redraw to reflect links.</li>\n          <li>Traverse the list step-by-step using \"Step\" or \"Auto\" traversal to highlight the current node and the head pointer.</li>\n          <li>Keyboard: press Enter in the value field to submit the most recent action; controls are accessible and labelled.</li>\n        </ul>\n      </div>\n\n      <div class=\"section\">\n        <h3>Layout Description</h3>\n        <p>Spatial organization:</p>\n        <ul class=\"list\">\n          <li>Left column (this panel): concise objectives and instructions. Safe area margins of 24px and minimum spacing of 16px maintained.</li>\n          <li>Right column: interactive workspace — controls bar on top, canvas with node visualization and arrow overlay center, status bar below.</li>\n          <li>Controls grouped and separated by at least 16px; visual focus is on the canvas where node boxes and animated arrows appear.</li>\n          <li>Responsive: columns stack on narrow screens and elements wrap while preserving touch targets and accessible labels.</li>\n        </ul>\n      </div>\n    </aside>\n\n    <!-- Right panel: Interactive module -->\n    <main class=\"workspace\" id=\"workspace\" aria-live=\"polite\">\n      <div style=\"display:flex;align-items:center;justify-content:space-between;gap:12px;\">\n        <div style=\"display:flex;flex-direction:column;\">\n          <div style=\"font-size:16px;font-weight:700\">Interactive Linked List</div>\n          <div style=\"font-size:13px;color:var(--muted)\">Singly linked list — values and next pointers visualized</div>\n        </div>\n        <div style=\"display:flex;gap:10px;align-items:center;\">\n          <button id=\"resetBtn\" class=\"ghost small\" title=\"Reset list to empty\">Reset</button>\n          <button id=\"sampleBtn\" class=\"ghost small\" title=\"Load a sample list\">Load Sample</button>\n        </div>\n      </div>\n\n      <!-- Controls -->\n      <div class=\"controls\" role=\"region\" aria-label=\"Controls\">\n        <div class=\"group\" style=\"min-width:260px;\">\n          <label for=\"valueInput\">Value</label>\n          <input id=\"valueInput\" type=\"text\" placeholder=\"e.g. 42\" aria-label=\"Node value\" />\n          <button id=\"addTailBtn\" title=\"Append to tail\">Add Tail</button>\n        </div>\n\n        <div class=\"group\">\n          <label for=\"valueHead\">Head</label>\n          <input id=\"valueHead\" type=\"text\" placeholder=\"e.g. x\" aria-label=\"Insert at head value\" />\n          <button id=\"addHeadBtn\" title=\"Insert at head\">Insert Head</button>\n        </div>\n\n        <div class=\"group\">\n          <label for=\"afterIndex\">Insert After Index</label>\n          <input id=\"afterIndex\" type=\"number\" min=\"0\" placeholder=\"index\" aria-label=\"Insert after index\" />\n          <input id=\"valueAfter\" type=\"text\" placeholder=\"value\" aria-label=\"Value to insert after index\" />\n          <button id=\"insertAfterBtn\" title=\"Insert after index\">Insert</button>\n        </div>\n\n        <div class=\"group\">\n          <label for=\"delIndex\">Delete Index</label>\n          <input id=\"delIndex\" type=\"number\" min=\"0\" placeholder=\"index\" aria-label=\"Index to delete\" />\n          <button id=\"deleteBtn\" class=\"warn\" title=\"Delete node at index\">Delete</button>\n        </div>\n\n        <div class=\"group\" style=\"margin-left:auto;\">\n          <button id=\"stepBtn\" class=\"small\">Step</button>\n          <button id=\"autoBtn\" class=\"small ghost\">Auto</button>\n          <button id=\"resetTraversal\" class=\"small ghost\">Reset Traversal</button>\n        </div>\n      </div>\n\n      <!-- Canvas area -->\n      <div class=\"canvas-wrap\" id=\"canvasWrap\" tabindex=\"0\" aria-label=\"Linked list visualization\">\n        <div class=\"label-head\" id=\"headLabel\" style=\"display:none\">head</div>\n        <div id=\"listArea\" class=\"list-area\" role=\"list\" aria-label=\"List nodes\">\n          <div class=\"nodes-row\" id=\"nodesRow\" aria-live=\"polite\"></div>\n        </div>\n        <svg class=\"svg-overlay\" id=\"svgOverlay\" aria-hidden=\"true\"></svg>\n      </div>\n\n      <!-- Status bar -->\n      <div class=\"status\">\n        <div class=\"structure\" id=\"structureText\" aria-live=\"polite\">[]</div>\n        <div class=\"vis-help\">\n          <div style=\"display:flex;gap:10px;align-items:center\">\n            <div style=\"width:12px;height:12px;border-radius:3px;background:var(--accent)\"></div>\n            <div style=\"font-size:13px;color:var(--muted)\">Head</div>\n          </div>\n          <div style=\"display:flex;gap:10px;align-items:center\">\n            <div style=\"width:12px;height:12px;border-radius:3px;background:var(--accent-2)\"></div>\n            <div style=\"font-size:13px;color:var(--muted)\">Active</div>\n          </div>\n        </div>\n      </div>\n\n      <footer class=\"note\">\n        <div style=\"flex:1;color:var(--muted)\">Tip: Use small integer indexes starting at 0 (head) for insertion/deletion reference.</div>\n        <div style=\"font-size:13px;color:var(--muted)\">Singly linked list demo — vanilla JS</div>\n      </footer>\n\n      <div id=\"liveAnnouncer\" aria-live=\"assertive\" aria-atomic=\"true\"></div>\n    </main>\n  </div>\n\n  <script>\n    // Linked List Interactive Module (Singly linked list) - Vanilla JS\n    (function(){\n      // Utility\n      const $ = sel => document.querySelector(sel);\n      const $$ = sel => Array.from(document.querySelectorAll(sel));\n\n      // Elements\n      const nodesRow = $('#nodesRow');\n      const svgOverlay = $('#svgOverlay');\n      const listArea = $('#listArea');\n      const headLabel = $('#headLabel');\n      const structureText = $('#structureText');\n      const liveAnnouncer = $('#liveAnnouncer');\n\n      const valueInput = $('#valueInput');\n      const addTailBtn = $('#addTailBtn');\n      const valueHead = $('#valueHead');\n      const addHeadBtn = $('#addHeadBtn');\n      const afterIndex = $('#afterIndex');\n      const valueAfter = $('#valueAfter');\n      const insertAfterBtn = $('#insertAfterBtn');\n      const delIndex = $('#delIndex');\n      const deleteBtn = $('#deleteBtn');\n      const stepBtn = $('#stepBtn');\n      const autoBtn = $('#autoBtn');\n      const resetTraversal = $('#resetTraversal');\n      const resetBtn = $('#resetBtn');\n      const sampleBtn = $('#sampleBtn');\n\n      // State\n      let nodes = []; // array of {id, value, el}\n      let currentIndex = -1;\n      let autoInterval = null;\n      let nodeIdCounter = 1;\n\n      // Accessibility announcer\n      function announce(msg){\n        liveAnnouncer.textContent = msg;\n      }\n\n      // Render functions\n      function renderNodes(animated=true){\n        // Clear nodesRow and append DOM elements\n        nodesRow.innerHTML = '';\n        nodes.forEach((n, idx) => {\n          const nodeEl = document.createElement('div');\n          nodeEl.className = 'node';\n          nodeEl.setAttribute('role', 'listitem');\n          nodeEl.setAttribute('data-index', idx);\n          nodeEl.setAttribute('data-id', n.id);\n          nodeEl.innerHTML = '<div class=\"value\"></div><div class=\"next-box\">next</div>';\n          nodeEl.querySelector('.value').textContent = n.value;\n          if(idx===0) nodeEl.classList.add('head');\n          if(idx===currentIndex) nodeEl.classList.add('active');\n          nodesRow.appendChild(nodeEl);\n          n.el = nodeEl;\n        });\n\n        // Update head label position\n        updateHeadLabel();\n\n        // Recompute SVG\n        requestAnimationFrame(() => {\n          drawConnections(animated);\n          updateStructureText();\n        });\n      }\n\n      function updateStructureText(){\n        const repr = nodes.map((n, i) => `${n.value}->${i+1<nodes.length?nodes[i+1].value:'null'}`);\n        structureText.textContent = '[' + nodes.map(n=>n.value).join(', ') + ']';\n      }\n\n      function updateHeadLabel(){\n        if(nodes.length===0){\n          headLabel.style.display = 'none';\n          return;\n        }\n        const first = nodes[0].el;\n        const wrapRect = listArea.getBoundingClientRect();\n        const rect = first.getBoundingClientRect();\n        const offsetLeft = rect.left - wrapRect.left + 6;\n        headLabel.style.display = 'block';\n        headLabel.style.left = offsetLeft + 'px';\n        headLabel.style.top = (rect.top - wrapRect.top - 26) + 'px';\n      }\n\n      // SVG connections\n      function drawConnections(animated=true){\n        const overlayRect = listArea.getBoundingClientRect();\n        svgOverlay.setAttribute('width', overlayRect.width);\n        svgOverlay.setAttribute('height', overlayRect.height);\n        svgOverlay.innerHTML = '';\n\n        for(let i=0;i<nodes.length-1;i++){\n          const a = nodes[i].el;\n          const b = nodes[i+1].el;\n          if(!a || !b) continue;\n          const aRect = a.getBoundingClientRect();\n          const bRect = b.getBoundingClientRect();\n          const offsetA = { x: aRect.right - overlayRect.left - 6, y: aRect.top + aRect.height/2 - overlayRect.top };\n          const offsetB = { x: bRect.left - overlayRect.left + 6, y: bRect.top + bRect.height/2 - overlayRect.top };\n\n          const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n          const dx = Math.max(20, offsetB.x - offsetA.x);\n          const cp1x = offsetA.x + dx*0.35;\n          const cp2x = offsetB.x - dx*0.35;\n          const d = `M ${offsetA.x} ${offsetA.y} C ${cp1x} ${offsetA.y} ${cp2x} ${offsetB.y} ${offsetB.x} ${offsetB.y}`;\n          path.setAttribute('d', d);\n          path.setAttribute('class', 'arrow-path');\n          // add arrowhead marker\n          path.setAttribute('marker-end','url(#arrowhead)');\n\n          svgOverlay.appendChild(path);\n        }\n\n        // define arrowhead\n        const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');\n        defs.innerHTML = '<marker id=\"arrowhead\" markerWidth=\"8\" markerHeight=\"8\" refX=\"6\" refY=\"4\" orient=\"auto\"><path d=\"M0 0 L8 4 L0 8 z\" fill=\"rgba(15,23,42,0.22)\"/></marker>';\n        svgOverlay.insertBefore(defs, svgOverlay.firstChild);\n\n        // Animate paths\n        const paths = svgOverlay.querySelectorAll('path.arrow-path');\n        paths.forEach(p=>{\n          const length = p.getTotalLength();\n          p.style.strokeDasharray = length;\n          if(animated){\n            p.style.strokeDashoffset = length;\n            p.classList.add('draw');\n            // trigger draw\n            requestAnimationFrame(()=> p.style.strokeDashoffset = '0');\n          } else {\n            p.style.strokeDashoffset = '0';\n            p.classList.remove('draw');\n          }\n        });\n      }\n\n      // Operations\n      function addTail(value){\n        if(value===undefined || value==='') { announce('Please provide a value to add.'); return; }\n        const id = nodeIdCounter++;\n        const node = { id, value: String(value), el: null };\n        nodes.push(node);\n        // temporary placeholder for animation: create element with incoming class and then re-render\n        renderNodes(false);\n        if(node.el){\n          node.el.classList.add('incoming');\n          requestAnimationFrame(()=> {\n            node.el.classList.remove('incoming');\n            drawConnections(true);\n          });\n        }\n        announce(`Added node with value ${value} at tail.`);\n      }\n\n      function insertHead(value){\n        if(value===undefined || value==='') { announce('Please provide a value to insert at head.'); return; }\n        const id = nodeIdCounter++;\n        const node = { id, value: String(value), el: null };\n        nodes.unshift(node);\n        renderNodes(false);\n        if(node.el){\n          node.el.classList.add('incoming');\n          requestAnimationFrame(()=> {\n            node.el.classList.remove('incoming');\n            drawConnections(true);\n          });\n        }\n        announce(`Inserted node with value ${value} at head (index 0).`);\n      }\n\n      function insertAfter(index, value){\n        index = Number(index);\n        if(Number.isNaN(index) || index < 0 || index >= nodes.length){\n          announce('Invalid index for insert-after.');\n          return;\n        }\n        if(value===undefined || value===''){\n          announce('Please provide a value to insert.');\n          return;\n        }\n        const id = nodeIdCounter++;\n        const node = { id, value: String(value), el: null };\n        nodes.splice(index+1, 0, node);\n        renderNodes(false);\n        if(node.el){\n          node.el.classList.add('incoming');\n          requestAnimationFrame(()=> {\n            node.el.classList.remove('incoming');\n            drawConnections(true);\n          });\n        }\n        announce(`Inserted ${value} after index ${index}.`);\n      }\n\n      function deleteAt(index){\n        index = Number(index);\n        if(Number.isNaN(index) || index < 0 || index >= nodes.length){\n          announce('Invalid index for deletion.');\n          return;\n        }\n        const removed = nodes.splice(index,1)[0];\n        // animate removal using class on old element if exists\n        if(removed && removed.el){\n          removed.el.classList.add('removing');\n          // wait for animation then re-render\n          setTimeout(()=> {\n            renderNodes(true);\n          }, 220);\n        } else {\n          renderNodes(true);\n        }\n        // adjust currentIndex if needed\n        if(currentIndex >= nodes.length) currentIndex = nodes.length -1;\n        announce(`Deleted node ${removed ? removed.value : ''} at index ${index}.`);\n      }\n\n      function stepTraversal(){\n        if(nodes.length===0){\n          announce('List is empty.');\n          return;\n        }\n        currentIndex = Math.min(currentIndex + 1, nodes.length - 1);\n        renderNodes(true);\n        announce(`Visited node index ${currentIndex} with value ${nodes[currentIndex].value}.`);\n      }\n\n      function resetTraversalState(){\n        currentIndex = -1;\n        renderNodes(true);\n        announce('Traversal reset.');\n      }\n\n      function autoTraverse(){\n        if(autoInterval){\n          clearInterval(autoInterval);\n          autoInterval = null;\n          autoBtn.textContent = 'Auto';\n          autoBtn.classList.remove('ghost');\n          autoBtn.classList.add('ghost'); // stable state\n          announce('Auto traversal stopped.');\n          return;\n        }\n        if(nodes.length===0){\n          announce('List is empty.');\n          return;\n        }\n        announce('Auto traversal started.');\n        currentIndex = -1;\n        autoBtn.textContent = 'Stop';\n        autoInterval = setInterval(()=>{\n          if(currentIndex >= nodes.length - 1){\n            clearInterval(autoInterval);\n            autoInterval = null;\n            autoBtn.textContent = 'Auto';\n            announce('Auto traversal completed.');\n            return;\n          }\n          stepTraversal();\n        }, 700);\n      }\n\n      // Event bindings\n      addTailBtn.addEventListener('click', ()=> {\n        addTail(valueInput.value.trim());\n        valueInput.value = '';\n      });\n\n      addHeadBtn.addEventListener('click', ()=> {\n        insertHead(valueHead.value.trim());\n        valueHead.value = '';\n      });\n\n      insertAfterBtn.addEventListener('click', ()=> {\n        insertAfter(afterIndex.value, valueAfter.value.trim());\n        afterIndex.value = '';\n        valueAfter.value = '';\n      });\n\n      deleteBtn.addEventListener('click', ()=> {\n        deleteAt(delIndex.value);\n        delIndex.value = '';\n      });\n\n      stepBtn.addEventListener('click', ()=> {\n        stepTraversal();\n      });\n\n      resetTraversal.addEventListener('click', ()=> {\n        resetTraversalState();\n      });\n\n      autoBtn.addEventListener('click', ()=> {\n        autoTraverse();\n      });\n\n      resetBtn.addEventListener('click', ()=> {\n        nodes = [];\n        nodeIdCounter = 1;\n        resetTraversalState();\n        renderNodes(false);\n        announce('List reset.');\n      });\n\n      sampleBtn.addEventListener('click', ()=> {\n        nodes = [\n          { id: nodeIdCounter++, value: 'A', el: null },\n          { id: nodeIdCounter++, value: 'B', el: null },\n          { id: nodeIdCounter++, value: 'C', el: null },\n        ];\n        currentIndex = -1;\n        renderNodes(true);\n        announce('Sample list loaded: A, B, C.');\n      });\n\n      // Keyboard: Enter in certain fields triggers relevant action\n      valueInput.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter') { addTailBtn.click(); e.preventDefault(); }\n      });\n      valueHead.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter') { addHeadBtn.click(); e.preventDefault(); }\n      });\n      valueAfter.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter') { insertAfterBtn.click(); e.preventDefault(); }\n      });\n      delIndex.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter') { deleteBtn.click(); e.preventDefault(); }\n      });\n\n      // Resize observer to redraw connections when layout changes\n      const ro = new ResizeObserver(()=> drawConnections(false));\n      ro.observe(listArea);\n      window.addEventListener('resize', ()=> drawConnections(false));\n\n      // Initial render: empty list\n      renderNodes(false);\n      announce('Interactive linked list ready. Add nodes to get started.');\n\n      // Click node to set traversal index to that node (interactive)\n      nodesRow.addEventListener('click', (e)=>{\n        const nodeEl = e.target.closest('.node');\n        if(!nodeEl) return;\n        const idx = Number(nodeEl.getAttribute('data-index'));\n        if(!Number.isNaN(idx)){\n          currentIndex = idx;\n          renderNodes(true);\n          announce(`Selected node index ${idx} with value ${nodes[idx].value}.`);\n        }\n      });\n\n      // Touch: allow pressing and holding to delete (mobile friendly)\n      let touchTimer = null;\n      nodesRow.addEventListener('touchstart', (e)=>{\n        const nodeEl = e.target.closest('.node');\n        if(!nodeEl) return;\n        const idx = Number(nodeEl.getAttribute('data-index'));\n        touchTimer = setTimeout(()=>{\n          // long press => remove\n          deleteAt(idx);\n        }, 800);\n      }, {passive:true});\n      nodesRow.addEventListener('touchend', ()=> { if(touchTimer) clearTimeout(touchTimer); });\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Linked List.\n\n**Project Overview:**\nTopic: Linked List\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Linked List"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "b3b6e670-bdd4-11f0-bd8d-55214871deb0",
    "timestamp": "2025-11-10T01:29:29.431Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Heap (Min/Max)",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Heap (Min/Max) — Interactive Module</title>\n  <style>\n    /* SAFE AREA and BASE */\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #f6f8fb;\n      --card: #ffffff;\n      --accent: #2b6ef6;\n      --accent-2: #0ea5a1;\n      --muted: #6b7280;\n      --node-size: 56px;\n      --transition: 400ms cubic-bezier(.2,.8,.2,1);\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg,#eef2ff 0%,var(--bg) 100%);\n      color:#0f172a;\n    }\n    .app {\n      padding: var(--safe-margin);\n      box-sizing:border-box;\n      min-height:100vh;\n      display:flex;\n      flex-direction:column;\n      gap: var(--gap);\n    }\n\n    /* HEADER: Title + Objectives */\n    header.module-head {\n      display:flex;\n      flex-wrap:wrap;\n      gap: var(--gap);\n      align-items:center;\n      justify-content:space-between;\n    }\n    .title {\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      min-width:220px;\n    }\n    .title h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:-0.2px;\n    }\n    .subtitle {\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* MAIN LAYOUT: Left controls, Right visualization */\n    .main {\n      display:grid;\n      grid-template-columns: 340px 1fr;\n      gap: var(--gap);\n      align-items:start;\n    }\n    @media (max-width:900px){\n      .main { grid-template-columns: 1fr; }\n    }\n\n    /* CONTROLS CARD */\n    .card {\n      background:var(--card);\n      border-radius:12px;\n      padding:18px;\n      box-shadow: 0 6px 20px rgba(16,24,40,0.06);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .section-title{\n      font-weight:600;\n      font-size:13px;\n    }\n    label{\n      display:block;\n      font-size:13px;\n      color:var(--muted);\n      margin-bottom:6px;\n    }\n    input[type=\"number\"]{\n      width:100%;\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid #e6edf7;\n      background:#fbfdff;\n      font-size:14px;\n      box-sizing:border-box;\n    }\n    button{\n      background:var(--accent);\n      color:white;\n      border:0;\n      padding:10px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      transition:transform 120ms ease;\n    }\n    button:active{ transform: translateY(1px); }\n    .btn-ghost{\n      background:transparent;\n      color:var(--accent);\n      border:1px solid rgba(43,110,246,0.12);\n    }\n    .row{\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n\n    /* Toggle switch */\n    .switch {\n      display:inline-flex;\n      align-items:center;\n      gap:10px;\n    }\n    .switch input{ display:none; }\n    .switch .track{\n      width:58px;\n      height:32px;\n      background:#eef2ff;\n      border-radius:999px;\n      padding:4px;\n      display:inline-flex;\n      align-items:center;\n      transition:background var(--transition);\n      box-sizing:content-box;\n    }\n    .switch .knob{\n      width:24px;height:24px;border-radius:50%;\n      background:white;box-shadow:0 2px 6px rgba(2,6,23,0.08);\n      transform:translateX(0); transition:transform var(--transition);\n    }\n    .switch input:checked + .track { background: linear-gradient(90deg,var(--accent),#7dd3fc); }\n    .switch input:checked + .track .knob { transform:translateX(26px); }\n\n    /* Controls group spacing */\n    .controls-grid{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .small {\n      font-size:13px;color:var(--muted);\n    }\n\n    /* VISUALIZATION CARD */\n    .viz {\n      background:linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.6));\n      border-radius:12px;\n      padding:18px;\n      min-height:420px;\n      box-shadow: 0 6px 20px rgba(16,24,40,0.06);\n      position:relative;\n      overflow:hidden;\n    }\n    .viz-top {\n      display:flex;\n      align-items:center;\n      gap:12px;\n      justify-content:space-between;\n      margin-bottom:8px;\n    }\n    .legend {\n      display:flex;\n      gap:10px;\n      align-items:center;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .legend .dot{\n      width:12px;height:12px;border-radius:50%;\n      display:inline-block;\n    }\n    .dot-min{ background: #60a5fa; }\n    .dot-max{ background: #fb7185; }\n\n    /* tree area */\n    .tree-area {\n      position:relative;\n      height:340px;\n      min-height:240px;\n      border-radius:8px;\n      background: linear-gradient(180deg, rgba(245,247,255,0.9), rgba(255,255,255,0.7));\n      padding:12px;\n      box-sizing:border-box;\n      overflow:visible;\n    }\n    /* nodes are absolutely positioned */\n    .node {\n      position:absolute;\n      width:var(--node-size);\n      height:var(--node-size);\n      border-radius:50%;\n      background:linear-gradient(180deg,#fff,#f8fbff);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      box-shadow: 0 8px 18px rgba(12,14,26,0.08);\n      border:2px solid rgba(15,23,42,0.06);\n      font-weight:700;\n      cursor:default;\n      transition: left var(--transition), top var(--transition), transform var(--transition), box-shadow var(--transition);\n      user-select:none;\n    }\n    .node.min { border-color: rgba(96,165,250,0.28); color:#1e3a8a; }\n    .node.max { border-color: rgba(251,113,133,0.28); color:#7f1d1d; }\n    .node.highlight { transform:scale(1.06); box-shadow: 0 14px 30px rgba(12,14,26,0.12); }\n\n    /* connector lines (simple) */\n    .connector {\n      position:absolute;\n      width:2px;\n      background: linear-gradient(180deg, rgba(15,23,42,0.08), rgba(15,23,42,0.03));\n      transform-origin:top left;\n      transition: left var(--transition), top var(--transition), height var(--transition), transform var(--transition);\n    }\n\n    /* array view below */\n    .array-view {\n      margin-top:12px;\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .arr-box{\n      min-width:44px;\n      height:44px;\n      background:white;\n      border-radius:8px;\n      border:1px solid #e6eefb;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:700;\n      font-size:14px;\n      box-shadow:0 6px 14px rgba(16,24,40,0.04);\n      padding:6px;\n    }\n    .arr-index{\n      font-size:11px;color:var(--muted);margin-top:6px;text-align:center;\n    }\n\n    /* Footer / Legend text */\n    .meta {\n      color:var(--muted);\n      font-size:13px;\n    }\n    /* Accessibility focus */\n    button:focus, input:focus {\n      outline:3px solid rgba(43,110,246,0.14);\n      outline-offset:2px;\n      border-radius:8px;\n    }\n    /* small helpers */\n    .muted { color:var(--muted); font-size:13px; }\n    .controls-row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"main\">\n    <!-- Header / Explanations -->\n    <header class=\"module-head\">\n      <div class=\"title\" aria-hidden=\"false\">\n        <h1>Heap (Min/Max) — Interactive Visualizer</h1>\n        <p class=\"subtitle\">Explore insertions, extractions and heapify behavior for min-heap and max-heap.</p>\n      </div>\n\n      <div style=\"max-width:640px\" aria-labelledby=\"learning-objective\">\n        <div class=\"card\" style=\"padding:12px;\">\n          <div id=\"learning-objective\" class=\"section-title\">Learning Objective</div>\n          <div class=\"small\" style=\"margin-top:6px;\">\n            After interacting with this module you will understand:\n            <ul style=\"margin:8px 0 0 18px; padding:0; color:var(--muted); font-size:13px;\">\n              <li>How a binary heap is represented as an array and as a tree.</li>\n              <li>How insert (heapify-up) and extract (heapify-down) maintain heap property.</li>\n              <li>The difference between min-heap and max-heap behavior.</li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    </header>\n\n    <!-- Main interactive area -->\n    <section class=\"main\" aria-label=\"Interactive heap module\">\n      <!-- LEFT: Controls -->\n      <aside class=\"card\" aria-labelledby=\"controls-title\">\n        <div id=\"controls-title\" class=\"section-title\">Interactions</div>\n\n        <div class=\"controls-grid\" role=\"region\" aria-label=\"Heap controls\">\n          <div>\n            <label for=\"value-input\">Insert value (integer)</label>\n            <div class=\"row\">\n              <input id=\"value-input\" type=\"number\" inputmode=\"numeric\" aria-label=\"Number to insert\" placeholder=\"e.g. 42\" />\n              <button id=\"insert-btn\">Insert</button>\n            </div>\n            <div class=\"small\" style=\"margin-top:6px;\">\n              Tip: Press Enter in the input to insert. Values will animate into the heap.\n            </div>\n          </div>\n\n          <div>\n            <label>Heap Type</label>\n            <div class=\"row\" style=\"align-items:center;\">\n              <label class=\"switch\" aria-label=\"Toggle heap type\">\n                <input id=\"heap-toggle\" type=\"checkbox\" aria-checked=\"false\" />\n                <span class=\"track\" role=\"presentation\"><span class=\"knob\" aria-hidden=\"true\"></span></span>\n              </label>\n              <div class=\"muted\" id=\"heap-type-label\">Min-Heap</div>\n            </div>\n            <div class=\"small\" style=\"margin-top:6px;\">\n              Toggle to switch between Min-Heap and Max-Heap. The visual rules and swap priorities update immediately.\n            </div>\n          </div>\n\n          <div>\n            <label>Operations</label>\n            <div class=\"controls-row\">\n              <button id=\"extract-btn\" class=\"btn-ghost\" title=\"Remove root\">Extract Root</button>\n              <button id=\"clear-btn\" class=\"btn-ghost\">Clear</button>\n              <button id=\"random-btn\" class=\"btn-ghost\">Random (6)</button>\n            </div>\n            <div class=\"small\" style=\"margin-top:6px;\">\n              Extract removes the root (min or max depending on mode). Clear resets the heap.\n            </div>\n          </div>\n\n          <div>\n            <label>Playback</label>\n            <div class=\"row\" style=\"align-items:center;\">\n              <button id=\"step-btn\" class=\"btn-ghost\">Step</button>\n              <button id=\"auto-btn\" class=\"btn-ghost\">Auto Play</button>\n              <label style=\"margin-left:8px;\" class=\"small\">Speed</label>\n              <input id=\"speed\" type=\"range\" min=\"100\" max=\"1200\" step=\"100\" value=\"400\" aria-label=\"Animation speed\" />\n            </div>\n            <div class=\"small\" style=\"margin-top:6px;\">\n              Use Step to see each swap. Auto Play animates the full operation.\n            </div>\n          </div>\n\n          <div>\n            <label>Notes</label>\n            <div class=\"small\">\n              - Nodes swap visually and array updates in sync.<br/>\n              - Connectors show parent-child relations. Nodes are indexed from 1 (left to right in each level).\n            </div>\n          </div>\n        </div>\n      </aside>\n\n      <!-- RIGHT: Visualization -->\n      <div class=\"viz\" aria-live=\"polite\">\n        <div class=\"viz-top\">\n          <div style=\"display:flex;gap:12px;align-items:center;\">\n            <div class=\"legend\">\n              <span class=\"dot dot-min\" aria-hidden=\"true\"></span><span class=\"muted\">Min</span>\n              <span style=\"width:8px;\"></span>\n              <span class=\"dot dot-max\" aria-hidden=\"true\"></span><span class=\"muted\">Max</span>\n            </div>\n          </div>\n          <div>\n            <div class=\"muted\">Array view mirrors the tree below</div>\n          </div>\n        </div>\n\n        <!-- Tree area -->\n        <div id=\"tree-area\" class=\"tree-area\" role=\"application\" aria-label=\"Heap tree visualization\">\n          <!-- connectors and nodes injected here -->\n        </div>\n\n        <!-- Array View -->\n        <div aria-label=\"Heap array representation\" style=\"margin-top:12px;\">\n          <div class=\"section-title\" style=\"font-size:14px;margin-bottom:8px;\">Array Representation</div>\n          <div id=\"array-view\" class=\"array-view\" role=\"list\"></div>\n        </div>\n      </div>\n    </section>\n\n    <!-- Footer: Interaction Design and Layout Description -->\n    <section class=\"card\" aria-labelledby=\"interaction-title\">\n      <div id=\"interaction-title\" class=\"section-title\">Interaction Design & Layout Description</div>\n\n      <div style=\"margin-top:8px; color:var(--muted); font-size:13px; line-height:1.45;\">\n        <strong>Interaction Design</strong>\n        <ul style=\"margin:8px 0 8px 18px; padding:0;\">\n          <li>Insert: Type an integer and press Insert (or Enter). The value appears as a new node at the next array index and animates from the bottom of the tree toward its parent while performing swap animations when heap property is violated (heapify-up).</li>\n          <li>Extract Root: Removes the root node (min for Min-Heap, max for Max-Heap). The last node moves to the root and then animates down swapping with the appropriate child until heap property restored (heapify-down). Each swap is animated and the array is updated in sync.</li>\n          <li>Step / Auto Play: Step advances a single comparison/swap during an ongoing operation. Auto Play animates the full operation at the chosen speed slider value. Speed controls duration of transitions.</li>\n          <li>Heap Type Toggle: Switch between Min and Max; active swaps are colored and the comparison direction changes immediately.</li>\n          <li>Random & Clear: Random populates six values; Clear empties the heap.</li>\n        </ul>\n\n        <strong>Layout Description</strong>\n        <p style=\"margin:6px 0 0 0;\">\n          The module uses a two-column responsive layout with a controls column (left) and a visualization column (right). A safe area margin of 24px surrounds the viewport and at least 16px spacing separates interactive elements. The tree visualization is placed above the array view. Nodes are absolutely positioned in the tree area so their coordinates can be animated; connectors are simple vertical/horizontal bars between parent and child to reinforce tree structure. Controls are grouped by function to maintain clarity and ease of access. All controls are keyboard-accessible and visually focusable for accessibility.\n        </p>\n      </div>\n    </section>\n  </div>\n\n  <script>\n    /*\n      Heap Interactive Module\n      - Supports Min-Heap and Max-Heap\n      - Visualizes insert (heapify-up) and extract (heapify-down) with animations\n      - No external libraries. Vanilla JS + CSS transitions.\n    */\n\n    (function(){\n      // DOM refs\n      const treeArea = document.getElementById('tree-area');\n      const arrayView = document.getElementById('array-view');\n      const input = document.getElementById('value-input');\n      const insertBtn = document.getElementById('insert-btn');\n      const extractBtn = document.getElementById('extract-btn');\n      const clearBtn = document.getElementById('clear-btn');\n      const randomBtn = document.getElementById('random-btn');\n      const heapToggle = document.getElementById('heap-toggle');\n      const heapTypeLabel = document.getElementById('heap-type-label');\n      const stepBtn = document.getElementById('step-btn');\n      const autoBtn = document.getElementById('auto-btn');\n      const speedRange = document.getElementById('speed');\n\n      // State\n      let heap = []; // 1-based conceptual, but we'll store 0-based; functions adapt.\n      let isMin = true;\n      let busy = false; // prevents concurrent ops\n      let autoPlaying = false;\n      let pendingSteps = []; // for stepping through operations (swap sequences)\n      let animDuration = parseInt(speedRange.value, 10); // ms\n\n      // UI constants\n      const NODE_SIZE = 56;\n      const GAP = 16;\n\n      // Helpers\n      function cmp(a,b){\n        return isMin ? a - b : b - a;\n      }\n\n      function updateHeapTypeUI(){\n        heapTypeLabel.textContent = isMin ? 'Min-Heap' : 'Max-Heap';\n      }\n\n      // Create node DOM for index i (0-based)\n      function createNodeElement(val, idx){\n        const el = document.createElement('div');\n        el.className = 'node ' + (isMin ? 'min' : 'max');\n        el.setAttribute('data-idx', idx);\n        el.setAttribute('role','img');\n        el.setAttribute('aria-label', 'Heap node ' + val);\n        el.textContent = val;\n        el.style.width = NODE_SIZE + 'px';\n        el.style.height = NODE_SIZE + 'px';\n        el.style.lineHeight = NODE_SIZE + 'px';\n        el.style.fontSize = '15px';\n        el.style.transitionDuration = animDuration + 'ms';\n        treeArea.appendChild(el);\n        return el;\n      }\n\n      // Create connector element\n      function createConnector(){\n        const c = document.createElement('div');\n        c.className = 'connector';\n        treeArea.appendChild(c);\n        return c;\n      }\n\n      // Render full tree and array, positioning nodes\n      function renderAll(animated = true){\n        // Clear tree area\n        treeArea.querySelectorAll('.node, .connector').forEach(n => {\n          if (!animated) n.style.transitionDuration = '0ms';\n          else n.style.transitionDuration = animDuration + 'ms';\n        });\n\n        const nodes = heap.map((v,i) => ({val:v, idx:i}));\n        // Ensure enough node elements exist\n        let existing = Array.from(treeArea.querySelectorAll('.node'));\n        // synchronize count\n        while (existing.length < nodes.length){\n          const idx = existing.length;\n          const el = createNodeElement(nodes[idx].val, idx);\n          existing.push(el);\n        }\n        while (existing.length > nodes.length){\n          const el = existing.pop();\n          el.remove();\n        }\n\n        // Update node content and attributes\n        existing = Array.from(treeArea.querySelectorAll('.node'));\n        existing.forEach((el,i) => {\n          el.textContent = String(heap[i]);\n          el.setAttribute('data-idx', i);\n          el.classList.toggle('min', isMin);\n          el.classList.toggle('max', !isMin);\n          el.style.transitionDuration = animDuration + 'ms';\n        });\n\n        // Connectors: number equals nodes.length - 1 (for each child)\n        // Remove existing connectors and recreate to avoid complexity\n        treeArea.querySelectorAll('.connector').forEach(c => c.remove());\n        const connectors = [];\n\n        // Compute positions\n        function computePos(i){\n          // compute tree layout: levels\n          const level = Math.floor(Math.log2(i + 1));\n          const indexInLevel = i - (2**level - 1);\n          const nodesInLevel = 2**level;\n          const areaWidth = treeArea.clientWidth;\n          // horizontal spacing: divide area into (nodesInLevel + 1) gutters\n          const gapX = Math.max( (areaWidth - NODE_SIZE) / (nodesInLevel + 1), 8);\n          // center at (indexInLevel+1)*gapX - half node + offset\n          const x = (indexInLevel + 1) * gapX - (NODE_SIZE/2);\n          const levelHeight = Math.max(62, NODE_SIZE + 12);\n          const y = level * levelHeight + 12;\n          return {x: Math.max(8, x), y};\n        }\n\n        // Position nodes\n        existing.forEach((el,i) => {\n          const pos = computePos(i);\n          el.style.left = pos.x + 'px';\n          el.style.top = pos.y + 'px';\n          el.style.zIndex = 1000 - pos.y;\n        });\n\n        // Add connectors between parent and child\n        existing.forEach((el,i) => {\n          const left = parseFloat(el.style.left);\n          const top = parseFloat(el.style.top);\n          const center = { x: left + NODE_SIZE/2, y: top + NODE_SIZE/2 };\n          const leftChildIdx = 2*i + 1;\n          const rightChildIdx = 2*i + 2;\n          [leftChildIdx, rightChildIdx].forEach(childIdx => {\n            if (childIdx < heap.length){\n              const child = existing[childIdx];\n              const cleft = parseFloat(child.style.left);\n              const ctop = parseFloat(child.style.top);\n              const ccenter = { x: cleft + NODE_SIZE/2, y: ctop + NODE_SIZE/2 };\n              // create connector from parent center to child center\n              const conn = createConnector();\n              const x = Math.min(center.x, ccenter.x);\n              const y = Math.min(center.y, ccenter.y);\n              const dx = ccenter.x - center.x;\n              const dy = ccenter.y - center.y;\n              const length = Math.hypot(dx, dy);\n              const angle = Math.atan2(dy, dx) * (180/Math.PI);\n              conn.style.left = center.x + 'px';\n              conn.style.top = center.y + 'px';\n              conn.style.width = Math.max(2, length) + 'px';\n              conn.style.height = '2px';\n              conn.style.transform = `rotate(${angle}deg)`;\n              connectors.push(conn);\n            }\n          });\n        });\n\n        // Render array view\n        renderArray();\n      }\n\n      // Render the array representation\n      function renderArray(){\n        arrayView.innerHTML = '';\n        // show indices starting at 1\n        heap.forEach((v,i) => {\n          const box = document.createElement('div');\n          box.className = 'arr-box';\n          box.textContent = v;\n          arrayView.appendChild(box);\n\n          const idx = document.createElement('div');\n          idx.className = 'arr-index';\n          idx.textContent = (i+1);\n          arrayView.appendChild(idx);\n        });\n      }\n\n      // Insert a value with animated heapify-up, producing a sequence of swaps to play\n      function insertValue(val){\n        if (busy) return;\n        busy = true;\n        pendingSteps = [];\n        heap.push(val);\n        const startIdx = heap.length - 1;\n        // Build steps: comparisons and swaps (indices)\n        let i = startIdx;\n        while (i > 0){\n          const parent = Math.floor((i - 1) / 2);\n          if (cmp(heap[parent], heap[i]) > 0){\n            // swap needed\n            pendingSteps.push({type:'swap', a:parent, b:i});\n            // perform swap in logical heap for future decisions\n            [heap[parent], heap[i]] = [heap[i], heap[parent]];\n            i = parent;\n          } else {\n            break;\n          }\n        }\n        // We built and applied swaps already in the 'heap' to compute final state.\n        // But for animation we need the intermediate states. So reconstruct a separate sequence.\n        // Instead: re-simulate from array before insertion\n        // Better approach: build sequence by simulating on a copy\n        // Recompute properly:\n        const original = heap.slice(); // current final state\n        // recreate from start: copy original but removing final swaps\n        // We'll simulate separately to produce steps visually.\n        // Simulate on a copy starting with earlier array\n        // For clarity, rebuild sequence from snapshot before insertion:\n        // snapshotBefore:\n        let snapshotBefore = original.slice();\n        // remove the inserted element that was appended (we know its final position)\n        snapshotBefore.splice(startIdx,1);\n        // Now simulate insertion step-by-step to record swaps\n        let sim = snapshotBefore.slice();\n        sim.push(val);\n        i = sim.length - 1;\n        const animSteps = [];\n        while (i > 0){\n          const parent = Math.floor((i - 1) / 2);\n          if (cmp(sim[parent], sim[i]) > 0){\n            animSteps.push({type:'swap', a:parent, b:i});\n            [sim[parent], sim[i]] = [sim[i], sim[parent]];\n            i = parent;\n          } else { break; }\n        }\n        // For animation, we need to apply the initial state (snapshotBefore + appended val),\n        // then play animSteps one by one.\n        // So set heap to initial simulation state:\n        heap = snapshotBefore.slice();\n        heap.push(val);\n        renderAll(false);\n        playSteps(animSteps).then(() => { busy = false; });\n      }\n\n      // Extract root with animated heapify-down\n      function extractRoot(){\n        if (busy) return;\n        if (heap.length === 0) return;\n        busy = true;\n        // Create simulation steps\n        const animSteps = [];\n        // snapshot\n        const sim = heap.slice();\n        // Swap root with last, remove last\n        if (sim.length === 1){\n          // simple remove\n          sim.pop();\n        } else {\n          [sim[0], sim[sim.length - 1]] = [sim[sim.length - 1], sim[0]];\n          animSteps.push({type:'swap', a:0, b: sim.length - 1, removeIndex: sim.length - 1});\n          sim.pop(); // remove the popped root (now at end)\n          // heapify down\n          let i = 0;\n          while (true){\n            const left = 2*i + 1;\n            const right = 2*i + 2;\n            let candidate = i;\n            if (left < sim.length && cmp(sim[candidate], sim[left]) > 0) candidate = left;\n            if (right < sim.length && cmp(sim[candidate], sim[right]) > 0) candidate = right;\n            if (candidate !== i){\n              animSteps.push({type:'swap', a:i, b:candidate});\n              [sim[i], sim[candidate]] = [sim[candidate], sim[i]];\n              i = candidate;\n            } else break;\n          }\n        }\n        // Now for animation: set heap to initial state and play animSteps\n        renderAll(false);\n        playSteps(animSteps).then(() => { busy = false; });\n      }\n\n      // Play a sequence of steps (swap steps)\n      // Each step animates a swap. Optionally remove an element after swap.\n      function playSteps(steps){\n        return new Promise((resolve) => {\n          if (!steps || steps.length === 0){\n            // nothing to do; final render set\n            // ensure final array set correctly (simulate)\n            renderAll(true);\n            resolve();\n            return;\n          }\n          let idx = 0;\n\n          function doNext(){\n            if (idx >= steps.length){\n              // finished; ensure final heap state consistent\n              // After all steps, recompute heap by applying simulated steps to an initial snapshot\n              // Instead of recomputing, we'll maintain heap state incrementally.\n              renderAll(true);\n              resolve();\n              return;\n            }\n            const s = steps[idx++];\n            if (s.type === 'swap'){\n              // perform DOM swap animation between a and b\n              // find nodes by data-idx attributes\n              const aIdx = s.a;\n              const bIdx = s.b;\n              const nodes = Array.from(treeArea.querySelectorAll('.node'));\n              const nodeA = nodes[aIdx];\n              const nodeB = nodes[bIdx];\n              if (!nodeA || !nodeB){\n                // fallback: update logical heap and continue\n                performSwapLogical(aIdx,bIdx,s.removeIndex);\n                renderAll(true);\n                return setTimeout(doNext, animDuration + 40);\n              }\n              // highlight\n              nodeA.classList.add('highlight');\n              nodeB.classList.add('highlight');\n\n              // get current positions\n              const aLeft = parseFloat(nodeA.style.left);\n              const aTop = parseFloat(nodeA.style.top);\n              const bLeft = parseFloat(nodeB.style.left);\n              const bTop = parseFloat(nodeB.style.top);\n\n              // swap text immediates? For smoother look swap positions only\n              // move elements by setting left/top to each other's positions\n              nodeA.style.left = bLeft + 'px';\n              nodeA.style.top = bTop + 'px';\n              nodeB.style.left = aLeft + 'px';\n              nodeB.style.top = aTop + 'px';\n\n              // after transition duration, swap their data-idx attributes and update logical heap\n              setTimeout(() => {\n                nodeA.classList.remove('highlight');\n                nodeB.classList.remove('highlight');\n                // swap in DOM order: easiest to swap displayed values and data-idx\n                const tempA = nodeA.textContent;\n                nodeA.textContent = nodeB.textContent;\n                nodeB.textContent = tempA;\n                // update data-idx on elements for future finds\n                nodeA.setAttribute('data-idx', bIdx);\n                nodeB.setAttribute('data-idx', aIdx);\n\n                // update logical heap\n                performSwapLogical(aIdx,bIdx,s.removeIndex);\n                // re-render connectors to stay consistent\n                renderAll(true);\n\n                // next\n                if (autoPlaying) {\n                  setTimeout(doNext, 60);\n                } else {\n                  // wait for user step click\n                }\n              }, animDuration + 20);\n            } else {\n              // unknown step\n              setTimeout(doNext, 60);\n            }\n          }\n\n          // If autoPlaying, drive steps immediately; otherwise wait for step button to trigger doNext\n          if (autoPlaying){\n            doNext();\n          } else {\n            // attach temporary handler for step button\n            function stepHandler(){\n              doNext();\n              stepBtn.removeEventListener('click', stepHandler);\n            }\n            stepBtn.addEventListener('click', stepHandler, {once:true});\n          }\n\n          // Kick-off for the case of autoPlaying or first visual stage\n          if (autoPlaying) {\n            // ensure first frame is visible\n            renderAll(true);\n            // slight delay then start\n            setTimeout(doNext, 80);\n          } else {\n            // render initial frame and wait for step press\n            renderAll(true);\n          }\n        });\n      }\n\n      // Perform logical swap in heap array and handle removal if indicated\n      function performSwapLogical(a,b,removeIndex){\n        // make sure a and b in bounds\n        if (a < 0 || b < 0 || a >= heap.length || b >= heap.length) return;\n        [heap[a], heap[b]] = [heap[b], heap[a]];\n        if (typeof removeIndex !== 'undefined'){\n          // remove the element at removeIndex (typically last)\n          heap.splice(removeIndex,1);\n        }\n      }\n\n      // UI bindings\n      insertBtn.addEventListener('click', () => {\n        const val = parseInt(input.value,10);\n        if (Number.isNaN(val)) { input.focus(); return; }\n        insertValue(val);\n        input.value = '';\n        input.focus();\n      });\n\n      input.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter'){\n          insertBtn.click();\n        }\n      });\n\n      extractBtn.addEventListener('click', () => {\n        if (heap.length === 0) return;\n        autoPlaying = false;\n        extractRoot();\n      });\n\n      clearBtn.addEventListener('click', () => {\n        if (busy) return;\n        heap = [];\n        renderAll(false);\n      });\n\n      randomBtn.addEventListener('click', () => {\n        if (busy) return;\n        heap = [];\n        const count = 6;\n        for (let i=0;i<count;i++){\n          heap.push(Math.floor(Math.random()*90)+10);\n        }\n        // If we want a real heap, heapify the array to obey current type.\n        heapifyArray();\n        renderAll(false);\n      });\n\n      heapToggle.addEventListener('change', (e) => {\n        isMin = !heapToggle.checked; // checked = Max (we decided)\n        updateHeapTypeUI();\n        // change styling of nodes\n        treeArea.querySelectorAll('.node').forEach(n => {\n          n.classList.toggle('min', isMin);\n          n.classList.toggle('max', !isMin);\n        });\n        // Re-heapify existing data to reflect new ordering\n        heapifyArray();\n        renderAll(true);\n      });\n\n      // Step and Auto\n      stepBtn.addEventListener('click', () => {\n        // Step is only meaningful when there are pending steps; we implement step to perform a single logical comparison/swap\n        // For simplicity, trigger a single visual step by invoking a no-op or continuing any running operation.\n        // If not busy, do nothing.\n        // The playSteps function listens for step clicks if not autoPlaying.\n        // We'll simply trigger a click to advance if there are pending animations in progress.\n        // (This simplistic model allows step to advance operations created by insert/extract.)\n      });\n\n      autoBtn.addEventListener('click', () => {\n        autoPlaying = !autoPlaying;\n        autoBtn.textContent = autoPlaying ? 'Auto Pause' : 'Auto Play';\n      });\n\n      speedRange.addEventListener('input', (e) => {\n        animDuration = parseInt(e.target.value,10);\n        // update transition durations on nodes and connectors\n        treeArea.querySelectorAll('.node, .connector').forEach(n => {\n          n.style.transitionDuration = animDuration + 'ms';\n        });\n      });\n\n      // Heapify current array according to isMin: standard build-heap\n      function heapifyArray(){\n        // build heap in place\n        for (let i = Math.floor(heap.length/2)-1; i >= 0; i--){\n          siftDown(i, heap.length);\n        }\n      }\n      function siftDown(i, len){\n        while (true){\n          const left = 2*i + 1;\n          const right = 2*i + 2;\n          let candidate = i;\n          if (left < len && cmp(heap[candidate], heap[left]) > 0) candidate = left;\n          if (right < len && cmp(heap[candidate], heap[right]) > 0) candidate = right;\n          if (candidate !== i){\n            [heap[i], heap[candidate]] = [heap[candidate], heap[i]];\n            i = candidate;\n          } else break;\n        }\n      }\n\n      // Initial render\n      updateHeapTypeUI();\n      renderAll(false);\n\n      // Resize handling to reposition nodes responsively\n      let resizeTimer;\n      window.addEventListener('resize', () => {\n        // throttle\n        clearTimeout(resizeTimer);\n        resizeTimer = setTimeout(() => renderAll(true), 80);\n      });\n\n      // Accessibility: keyboard shortcuts\n      window.addEventListener('keydown', (e) => {\n        if (e.key === 'i' && document.activeElement.tagName !== 'INPUT') {\n          input.focus();\n        }\n        if (e.key === 'r') randomBtn.click();\n        if (e.key === 'c') clearBtn.click();\n        if (e.key === 'e') extractBtn.click();\n      });\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Heap (Min/Max).\n\n**Project Overview:**\nTopic: Heap (Min/Max)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Heap (Min/Max)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "9638b2e0-bdd4-11f0-bd8d-55214871deb0",
    "timestamp": "2025-11-10T01:29:31.212Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "Concept Title:\nBinary Search Tree (BST) — Visual Insert, Search, and Delete with Step-by-step Animation\n\nLearning Objective:\nAfter interacting with this module, learners will:\n- Understand the BST property (left < node < right) and how insert/search/delete operations follow it.\n- See visually which nodes are compared during operations (step-by-step path).\n- Observe how tree shape changes after insertions and deletions.\n- Read off in-order traversal to confirm BST ordering.\n\nInteraction Design:\n- Primary interactions:\n  - Text input: type an integer and press \"Insert\", \"Search\", or \"Delete\".\n  - Buttons: \"Insert\", \"Search\", \"Delete\", \"Random Tree\", \"Clear\".\n  - Toggle \"Step-by-step\" to animate each visit; otherwise operations proceed quickly with a single animation.\n  - Speed slider to control the animation delay (Slow → Fast).\n- Visual feedback and animations:\n  - Nodes are rendered as SVG circles with their values. Edges are straight lines.\n  - During search/insert/delete, nodes visited are highlighted in sequence (color change). The highlight pulses briefly for each visited node (CSS scale + color).\n  - When a node is inserted, it appears with a grow animation from scale 0 to 1 at its final position.\n  - When a node is deleted, it fades out and its parent/child link is redrawn smoothly.\n  - Positions of nodes are computed and transitioned smoothly when the tree shape changes (smooth translate transitions on node groups).\n  - A status area narrates what the algorithm is doing (e.g., \"Compare with 42: go left\", \"Insert 42 as left child of 50\", \"Found node 30\").\n  - An in-order traversal display updates after each structural change, confirming the BST property visually (in-order list).\n- How these reinforce learning:\n  - Sequential highlighting shows the comparison path and decision points.\n  - Animated structural updates make it clear how insert/delete reorder links.\n  - In-order output provides a check that BST ordering is maintained.\n\nLayout Description:\n- Safe area margins: 24 px on all sides of the viewport (body padding: 24px).\n- Layout uses a responsive two-column arrangement:\n  - Left column (controls): compact card containing inputs, buttons, toggles, speed slider, and textual descriptions. Controls arranged in vertical flow with a minimum spacing of 16 px between interactive elements (CSS gap).\n  - Right column (visual): an SVG canvas that displays the tree. The canvas scales to available space. The top of the right column also shows a concise legend and the in-order traversal list.\n- On narrow screens (mobile), the control column stacks on top and the canvas below for readability.\n- Accessibility:\n  - Buttons and inputs are keyboard-focusable; Enter key in the input triggers Insert.\n  - aria-live region provides verbal status updates for screen readers.\n  - Sufficient color contrast and alternative textual status for important state.\n- Visual balance:\n  - Controls kept compact to the left; primary visual focus is the SVG canvas on the right.\n  - Minimum spacing 16 px is enforced between buttons and controls. SVG nodes have enough spacing to avoid overlap; horizontal spacing adapts to container width.\n\nImplementation (self-contained HTML/CSS/JavaScript):\n- Single HTML file below. No external libraries or assets. Paste into a file and open in a browser.\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Binary Search Tree Interactive Module</title>\n  <style>\n    :root{\n      --safe-margin:24px;\n      --gap:16px;\n      --bg:#0f1724;\n      --card:#0b1220;\n      --accent:#4f46e5;\n      --muted:#94a3b8;\n      --node-fill:#0ea5a4;\n      --node-highlight:#f97316;\n      --node-text:#061826;\n      --edge:#94a3b8;\n      --success:#10b981;\n      --danger:#ef4444;\n    }\n\n    /* Safe area */\n    html,body{\n      height:100%;\n      margin:0;\n      background:linear-gradient(180deg,#071023 0%, #071726 60%);\n      font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;\n      color:#e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    body{\n      padding:var(--safe-margin);\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      min-height:100vh;\n    }\n\n    .module{\n      display:grid;\n      grid-template-columns:320px 1fr;\n      gap:var(--gap);\n      align-items:start;\n      width:100%;\n      min-height:480px;\n    }\n\n    @media (max-width:880px){\n      .module{\n        grid-template-columns:1fr;\n      }\n    }\n\n    /* Controls card */\n    .card{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      border-radius:12px;\n      padding:18px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);\n    }\n\n    h1{\n      font-size:18px;\n      margin:0 0 8px 0;\n      color:#e6eef8;\n      letter-spacing:0.2px;\n    }\n    p.lead{\n      margin:0 0 12px 0;\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.3;\n    }\n\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      margin-top:8px;\n    }\n\n    .row{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n    }\n    .row.wrap{\n      flex-wrap:wrap;\n    }\n\n    input[type=\"number\"]{\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background:rgba(255,255,255,0.02);\n      color:inherit;\n      outline:none;\n      min-width:0;\n      flex:1;\n      font-size:14px;\n    }\n\n    button{\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      color:inherit;\n      cursor:pointer;\n      font-weight:600;\n      font-size:13px;\n      transition:transform .12s ease, box-shadow .12s ease;\n      min-width:86px;\n    }\n    button:hover{ transform:translateY(-2px); box-shadow:0 6px 18px rgba(2,6,23,0.5); }\n    button.primary{\n      background:linear-gradient(90deg,var(--accent), #06b6d4 120%);\n      border:0;\n      color:white;\n    }\n    button.ghost{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n    }\n    .small{\n      padding:8px 10px;\n      font-size:13px;\n    }\n\n    label{\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    .toggles{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n    }\n    .switch{\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n      font-size:13px;\n    }\n    input[type=\"range\"]{\n      width:140px;\n    }\n\n    /* Visual area */\n    .visual{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      min-height:360px;\n    }\n\n    .vis-header{\n      display:flex;\n      justify-content:space-between;\n      gap:12px;\n      align-items:center;\n    }\n    .legend{\n      font-size:13px;\n      color:var(--muted);\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    .legend .dot{\n      width:12px;\n      height:12px;\n      border-radius:50%;\n      display:inline-block;\n      margin-right:6px;\n    }\n\n    .canvas{\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:12px;\n      min-height:420px;\n      position:relative;\n      overflow:auto;\n    }\n\n    /* SVG nodes and transitions */\n    svg{ width:100%; height:100%; display:block; }\n    .edge{\n      stroke:var(--edge);\n      stroke-width:2;\n      stroke-linecap:round;\n      transition:opacity .25s ease;\n      opacity:0.95;\n    }\n\n    .node-group{\n      transition:transform .35s cubic-bezier(.2,.8,.2,1);\n      transform-origin:center center;\n      cursor:default;\n    }\n    .node-circle{\n      fill:var(--node-fill);\n      stroke:#06323a;\n      stroke-width:2;\n      transition:transform .18s ease, fill .18s ease, opacity .18s ease;\n    }\n    .node-label{\n      font-size:12px;\n      fill:var(--node-text);\n      font-weight:700;\n      pointer-events:none;\n      text-anchor:middle;\n      dominant-baseline:middle;\n    }\n\n    .node-visited .node-circle{\n      fill:var(--node-highlight);\n      transform:scale(1.15);\n    }\n    .node-inserted .node-circle{\n      transform:scale(0);\n      animation:grow .28s forwards;\n    }\n    @keyframes grow{\n      from{ transform:scale(0); opacity:0; }\n      to{ transform:scale(1); opacity:1; }\n    }\n\n    .status{\n      font-size:13px;\n      color:var(--muted);\n    }\n    .status strong{ color:#e6eef8; }\n\n    .inorder{\n      margin-top:8px;\n      font-size:13px;\n      color:var(--muted);\n      min-height:20px;\n      padding:8px;\n      border-radius:8px;\n      background:rgba(255,255,255,0.01);\n      border:1px solid rgba(255,255,255,0.02);\n      display:flex;\n      gap:8px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .chip{\n      background:rgba(0,0,0,0.25);\n      padding:6px 8px;\n      border-radius:999px;\n      font-weight:600;\n      font-size:13px;\n      color:#e6eef8;\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n      min-height:28px;\n    }\n\n    /* Small helper */\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* Ensure spacing >=16px inside control groups */\n    .controls > * { margin:0; }\n    .controls > .row { gap:var(--gap); }\n    .controls .row > * { min-width:0; }\n  </style>\n</head>\n<body>\n  <div class=\"module\" role=\"application\" aria-labelledby=\"module-title\">\n    <div class=\"card\" aria-hidden=\"false\">\n      <h1 id=\"module-title\">Binary Search Tree Explorer</h1>\n      <p class=\"lead\">Insert, search, and delete integer nodes. Watch each comparison and see how the tree reshapes.</p>\n\n      <div class=\"controls\" role=\"region\" aria-label=\"BST controls\">\n        <div class=\"row\">\n          <input id=\"value-input\" type=\"number\" aria-label=\"Value\" placeholder=\"Enter integer (e.g. 42)\" />\n          <button id=\"insert-btn\" class=\"primary\" title=\"Insert\">Insert</button>\n        </div>\n\n        <div class=\"row wrap\">\n          <button id=\"search-btn\" class=\"small\">Search</button>\n          <button id=\"delete-btn\" class=\"small\">Delete</button>\n          <button id=\"random-btn\" class=\"small ghost\">Random Tree</button>\n          <button id=\"clear-btn\" class=\"small ghost\">Clear</button>\n        </div>\n\n        <div class=\"row\">\n          <label for=\"speed\">Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"100\" max=\"1200\" value=\"500\" aria-label=\"Animation speed\" />\n          <span class=\"muted\" id=\"speed-label\">500 ms</span>\n        </div>\n\n        <div class=\"row toggles\">\n          <label class=\"switch\"><input id=\"step-toggle\" type=\"checkbox\" aria-label=\"Step by step\" /> Step-by-step</label>\n          <label class=\"switch\"><input id=\"show-values\" type=\"checkbox\" checked aria-label=\"Show node values\" /> Show values</label>\n        </div>\n\n        <div class=\"row\">\n          <div class=\"status\" id=\"status\" aria-live=\"polite\"><strong>Ready.</strong> Insert a number to begin.</div>\n        </div>\n\n        <div>\n          <label class=\"muted\">Tip</label>\n          <p class=\"muted\" style=\"margin:6px 0 0 0; font-size:13px;\">Press Enter in the input to Insert. Use Random to add several nodes quickly.</p>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"visual\">\n      <div class=\"vis-header\">\n        <div class=\"legend\" aria-hidden=\"true\">\n          <span class=\"dot\" style=\"background:var(--node-fill)\"></span><span class=\"muted\">Node</span>\n          <span class=\"dot\" style=\"background:var(--node-highlight)\"></span><span class=\"muted\">Visited</span>\n        </div>\n        <div class=\"muted\">BST property: left &lt; node &lt; right</div>\n      </div>\n\n      <div class=\"canvas card\" id=\"canvas\" role=\"img\" aria-label=\"BST visualisation\">\n        <svg id=\"svg\" viewBox=\"0 0 1200 600\" preserveAspectRatio=\"xMidYMid meet\" aria-hidden=\"false\"></svg>\n      </div>\n\n      <div>\n        <label class=\"muted\">In-order (sorted):</label>\n        <div class=\"inorder\" id=\"inorder\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    /***********************\n     * Binary Search Tree\n     * Interactive visualization\n     * Self-contained: no libraries\n     ***********************/\n\n    (function(){\n      // DOM references\n      const svg = document.getElementById('svg');\n      const input = document.getElementById('value-input');\n      const insertBtn = document.getElementById('insert-btn');\n      const searchBtn = document.getElementById('search-btn');\n      const deleteBtn = document.getElementById('delete-btn');\n      const randomBtn = document.getElementById('random-btn');\n      const clearBtn = document.getElementById('clear-btn');\n      const statusEl = document.getElementById('status');\n      const inorderEl = document.getElementById('inorder');\n      const stepToggle = document.getElementById('step-toggle');\n      const speedRange = document.getElementById('speed');\n      const speedLabel = document.getElementById('speed-label');\n      const showValues = document.getElementById('show-values');\n\n      speedLabel.textContent = speedRange.value + ' ms';\n\n      // BST model\n      function Node(value){\n        this.value = value;\n        this.left = null;\n        this.right = null;\n        this.id = 'n' + Math.random().toString(36).slice(2,9);\n        // layout properties\n        this.x = 0;\n        this.y = 0;\n      }\n      let root = null;\n\n      // Animation and layout configuration\n      let animDelay = Number(speedRange.value) || 500;\n      let nodeRadius = 22;\n      let levelGap = 80;\n      let baseXSpacing = 70;\n\n      function setStatus(text, strongText){\n        statusEl.innerHTML = (strongText ? ('<strong>' + strongText + '.</strong> ') : '') + text;\n      }\n\n      function inOrderList(){\n        const out = [];\n        (function dfs(n){ if(!n) return; dfs(n.left); out.push(n.value); dfs(n.right); })(root);\n        return out;\n      }\n\n      function updateInorderDisplay(){\n        const arr = inOrderList();\n        inorderEl.innerHTML = '';\n        if(arr.length === 0){\n          inorderEl.textContent = '— empty —';\n          return;\n        }\n        arr.forEach(v=>{\n          const span = document.createElement('div');\n          span.className = 'chip';\n          span.textContent = v;\n          inorderEl.appendChild(span);\n        });\n      }\n\n      // SVG helpers\n      function clearSVG(){\n        while(svg.firstChild) svg.removeChild(svg.firstChild);\n      }\n\n      function computePositions(){\n        // assign xIndex by in-order traversal\n        let counter = 0;\n        function assignX(n, depth){\n          if(!n) return;\n          assignX(n.left, depth+1);\n          n._index = counter++;\n          n._depth = depth;\n          assignX(n.right, depth+1);\n        }\n        assignX(root, 0);\n\n        const total = counter;\n        // compute width and spacing adaptively\n        const width = Math.max(800, svg.clientWidth || 1200);\n        const spacing = Math.max(baseXSpacing, Math.floor(width / Math.max(6, total+1)));\n        // compute positions\n        function setCoords(n){\n          if(!n) return;\n          n.x = (n._index + 1) * spacing;\n          n.y = (n._depth + 1) * levelGap;\n          setCoords(n.left);\n          setCoords(n.right);\n        }\n        setCoords(root);\n      }\n\n      // Render tree\n      function renderTree(highlightedIds = [], insertedId = null){\n        computePositions();\n        clearSVG();\n        if(!root){\n          // draw a placeholder message\n          const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n          txt.setAttribute('x','50%');\n          txt.setAttribute('y','50%');\n          txt.setAttribute('text-anchor','middle');\n          txt.setAttribute('fill','#94a3b8');\n          txt.setAttribute('font-size','18');\n          txt.textContent = 'Tree is empty — insert a node.';\n          svg.appendChild(txt);\n          updateInorderDisplay();\n          return;\n        }\n\n        // draw edges first\n        (function drawEdges(n){\n          if(!n) return;\n          if(n.left){\n            const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n            line.setAttribute('class','edge');\n            line.setAttribute('x1', n.x);\n            line.setAttribute('y1', n.y);\n            line.setAttribute('x2', n.left.x);\n            line.setAttribute('y2', n.left.y);\n            svg.appendChild(line);\n          }\n          if(n.right){\n            const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n            line.setAttribute('class','edge');\n            line.setAttribute('x1', n.x);\n            line.setAttribute('y1', n.y);\n            line.setAttribute('x2', n.right.x);\n            line.setAttribute('y2', n.right.y);\n            svg.appendChild(line);\n          }\n          drawEdges(n.left);\n          drawEdges(n.right);\n        })(root);\n\n        // draw nodes\n        (function drawNodes(n){\n          if(!n) return;\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('class','node-group');\n          g.setAttribute('transform', `translate(${n.x}, ${n.y})`);\n          g.setAttribute('data-id', n.id);\n          // allow aria on group\n          // circle\n          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          circle.setAttribute('r', nodeRadius);\n          circle.setAttribute('class','node-circle');\n          circle.setAttribute('cx', 0);\n          circle.setAttribute('cy', 0);\n          // label\n          const label = document.createElementNS('http://www.w3.org/2000/svg','text');\n          label.setAttribute('class','node-label');\n          label.setAttribute('x', 0);\n          label.setAttribute('y', 0);\n          label.textContent = showValues.checked ? n.value : '';\n          g.appendChild(circle);\n          g.appendChild(label);\n\n          if(highlightedIds.includes(n.id)) g.classList.add('node-visited');\n          if(n.id === insertedId) g.classList.add('node-inserted');\n\n          // add tooltip behavior for accessibility\n          g.setAttribute('role','img');\n          g.setAttribute('aria-label','Node ' + n.value);\n\n          svg.appendChild(g);\n\n          drawNodes(n.left);\n          drawNodes(n.right);\n        })(root);\n\n        updateInorderDisplay();\n      }\n\n      // BST operations (non-animated core)\n      function bstInsert(value){\n        if(root === null){\n          root = new Node(value);\n          return { inserted: root, path: [root] };\n        }\n        const path = [];\n        let cur = root;\n        while(true){\n          path.push(cur);\n          if(value === cur.value){\n            // duplicates: do nothing\n            return { inserted: null, path, message: 'Value already exists' };\n          } else if(value < cur.value){\n            if(!cur.left){\n              cur.left = new Node(value);\n              path.push(cur.left);\n              return { inserted: cur.left, path };\n            }\n            cur = cur.left;\n          } else {\n            if(!cur.right){\n              cur.right = new Node(value);\n              path.push(cur.right);\n              return { inserted: cur.right, path };\n            }\n            cur = cur.right;\n          }\n        }\n      }\n\n      function bstSearch(value){\n        const path = [];\n        let cur = root;\n        while(cur){\n          path.push(cur);\n          if(value === cur.value) return { found: cur, path };\n          if(value < cur.value) cur = cur.left;\n          else cur = cur.right;\n        }\n        return { found: null, path };\n      }\n\n      function bstDelete(value){\n        const path = [];\n        let parent = null;\n        let cur = root;\n        while(cur && cur.value !== value){\n          path.push(cur);\n          parent = cur;\n          if(value < cur.value) cur = cur.left;\n          else cur = cur.right;\n        }\n        if(!cur) return { deleted: null, path, message: 'Not found' };\n        path.push(cur);\n\n        // helper to replace child of parent\n        function replaceParentChild(par, oldNode, newNode){\n          if(!par){\n            root = newNode;\n          } else {\n            if(par.left === oldNode) par.left = newNode;\n            else par.right = newNode;\n          }\n        }\n\n        // if node has no left child, replace with right\n        if(!cur.left){\n          replaceParentChild(parent, cur, cur.right);\n          return { deleted: cur, path };\n        }\n        // if no right child, replace with left\n        if(!cur.right){\n          replaceParentChild(parent, cur, cur.left);\n          return { deleted: cur, path };\n        }\n        // two children: find in-order successor (smallest in right subtree)\n        let succParent = cur;\n        let succ = cur.right;\n        while(succ.left){\n          succParent = succ;\n          succ = succ.left;\n        }\n        // copy successor's value into cur\n        const successorValue = succ.value;\n        // delete successor\n        if(succParent.left === succ) succParent.left = succ.right;\n        else succParent.right = succ.right;\n        cur.value = successorValue;\n        // include the nodes involved\n        return { deleted: cur, replacedWith: succ, path };\n      }\n\n      // Animation helpers\n      function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }\n\n      async function animatePath(pathNodes, reason){\n        // highlight nodes along the path sequentially\n        for(let i=0;i<pathNodes.length;i++){\n          const n = pathNodes[i];\n          renderTree([n.id], null);\n          setStatus(reason ? reason(n, i) : '', 'Comparing with ' + n.value);\n          if(stepToggle.checked){\n            await sleep(animDelay);\n          } else {\n            // small pause to show highlight even when not stepping\n            await sleep(Math.min(animDelay, 250));\n          }\n        }\n      }\n\n      // High level operations with animations and status\n      async function doInsert(value){\n        if(Number.isNaN(value)) {\n          setStatus('Enter a valid integer.', 'Invalid');\n          return;\n        }\n        setStatus('Starting insert for ' + value, 'Insert');\n        // run a dry-path to show comparisons\n        const result = bstInsert(value);\n        // if duplicate, remove the actual inserted node (we shouldn't have inserted)\n        if(result.inserted === null){\n          await animatePath(result.path, (n,i)=> {\n            if(n.value === value) return 'Value already exists';\n            return (value < n.value) ? 'Go left' : 'Go right';\n          });\n          setStatus('Value already exists — no change', 'Duplicate');\n          renderTree([], null);\n          return;\n        }\n        // animate comparisons then insertion\n        await animatePath(result.path.slice(0, result.path.length-1), (n,i)=> (value < n.value) ? 'Go left' : 'Go right');\n        // highlight parent, then show insertion\n        const parent = result.path[result.path.length-2] || null;\n        const inserted = result.inserted;\n        setStatus('Insert ' + value + (parent ? ' as child of ' + parent.value : ' as root'), 'Inserting');\n        // re-render to include new node with special insertedId for grow animation\n        renderTree([], inserted.id);\n        // small pause so animation runs\n        await sleep(animDelay);\n        renderTree([], null);\n      }\n\n      async function doSearch(value){\n        if(Number.isNaN(value)) {\n          setStatus('Enter a valid integer.', 'Invalid');\n          return;\n        }\n        setStatus('Searching for ' + value, 'Search');\n        const result = bstSearch(value);\n        // animate full path\n        await animatePath(result.path, (n,i) => {\n          if(n.value === value) return 'Found node';\n          return (value < n.value) ? 'Go left' : 'Go right';\n        });\n        if(result.found) {\n          setStatus('Value ' + value + ' found.', 'Found');\n          // final highlight\n          renderTree([result.found.id]);\n        } else {\n          setStatus('Value ' + value + ' not found.', 'Not found');\n          renderTree([], null);\n        }\n      }\n\n      async function doDelete(value){\n        if(Number.isNaN(value)) {\n          setStatus('Enter a valid integer.', 'Invalid');\n          return;\n        }\n        setStatus('Deleting ' + value, 'Delete');\n        const result = bstDelete(value);\n        await animatePath(result.path, (n,i)=>(value < n.value)?'Go left':'Go right');\n        if(!result.deleted){\n          setStatus('Value not found — no change', 'Not found');\n          renderTree([], null);\n          return;\n        }\n        // deletion may have replaced value (two-child case); show structure change\n        setStatus('Deleted ' + value, 'Deleted');\n        // briefly highlight deletion\n        renderTree([], result.deleted.id);\n        await sleep(animDelay);\n        renderTree([], null);\n      }\n\n      // UI wiring\n      insertBtn.addEventListener('click', async ()=>{\n        const val = parseInt(input.value,10);\n        await doInsert(val);\n        input.value = '';\n      });\n      input.addEventListener('keydown', async (e)=>{\n        if(e.key === 'Enter'){\n          e.preventDefault();\n          insertBtn.click();\n        }\n      });\n\n      searchBtn.addEventListener('click', async ()=>{\n        const val = parseInt(input.value,10);\n        await doSearch(val);\n      });\n\n      deleteBtn.addEventListener('click', async ()=>{\n        const val = parseInt(input.value,10);\n        await doDelete(val);\n      });\n\n      randomBtn.addEventListener('click', ()=>{\n        // insert 6 random values between 1 and 99\n        const arr = [];\n        for(let i=0;i<6;i++){\n          arr.push(Math.floor(Math.random()*99)+1);\n        }\n        // add them one by one with delay\n        (async ()=>{\n          for(const v of arr){\n            await doInsert(v);\n            await sleep(180);\n          }\n        })();\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        root = null;\n        setStatus('Cleared the tree', 'Cleared');\n        renderTree();\n      });\n\n      speedRange.addEventListener('input', ()=>{\n        animDelay = Number(speedRange.value);\n        speedLabel.textContent = animDelay + ' ms';\n      });\n\n      stepToggle.addEventListener('change', ()=>{\n        // no-op, behavior is checked at runtime\n      });\n\n      showValues.addEventListener('change', ()=>{\n        renderTree();\n      });\n\n      // Initial render\n      renderTree();\n\n      // Accessibility: announce focus on svg region\n      svg.setAttribute('tabindex','0');\n\n      // expose functions for debugging (not required)\n      window._bst_debug = {\n        rootRef: () => root,\n        insert: (v) => doInsert(Number(v)),\n        search: (v) => doSearch(Number(v)),\n        del: (v) => doDelete(Number(v)),\n        render: renderTree\n      };\n    })();\n  </script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Binary Search Tree (BST).\n\n**Project Overview:**\nTopic: Binary Search Tree (BST)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Binary Search Tree Interactive Module",
      "description": "FSM modeling user interactions, animations and visual feedback for inserting, searching and deleting nodes in the BST interactive visualization.",
      "states": [
        {
          "name": "idle",
          "onEnter": "renderTree",
          "onExit": "noop",
          "on": {
            "INSERT": "inserting",
            "SEARCH": "searching",
            "DELETE": "deleting",
            "RANDOM": "random_inserting",
            "CLEAR": "cleared",
            "SPEED_CHANGE": "idle",
            "TOGGLE_STEP": "idle",
            "TOGGLE_SHOW_VALUES": "idle"
          }
        },
        {
          "name": "inserting",
          "onEnter": "call_doInsert",
          "onExit": "noop",
          "on": {
            "INSERT_FINISHED": "idle",
            "INSERT_DUPLICATE": "duplicate",
            "CANCEL": "idle",
            "INSERT": "inserting",
            "SEARCH": "inserting",
            "DELETE": "inserting",
            "CLEAR": "inserting"
          }
        },
        {
          "name": "duplicate",
          "onEnter": "setStatusDuplicate",
          "onExit": "renderTree",
          "on": {
            "ACK": "idle",
            "INSERT": "inserting",
            "CLEAR": "cleared"
          }
        },
        {
          "name": "searching",
          "onEnter": "call_doSearch",
          "onExit": "noop",
          "on": {
            "SEARCH_FOUND": "found",
            "SEARCH_NOT_FOUND": "not_found",
            "CANCEL": "idle",
            "INSERT": "searching",
            "DELETE": "searching",
            "CLEAR": "searching"
          }
        },
        {
          "name": "found",
          "onEnter": "highlightFound",
          "onExit": "renderTree",
          "on": {
            "ACK": "idle",
            "INSERT": "inserting",
            "SEARCH": "searching",
            "DELETE": "deleting",
            "CLEAR": "cleared"
          }
        },
        {
          "name": "not_found",
          "onEnter": "setStatusNotFound",
          "onExit": "renderTree",
          "on": {
            "ACK": "idle",
            "INSERT": "inserting",
            "SEARCH": "searching",
            "DELETE": "deleting",
            "CLEAR": "cleared"
          }
        },
        {
          "name": "deleting",
          "onEnter": "call_doDelete",
          "onExit": "noop",
          "on": {
            "DELETE_FINISHED": "deleted",
            "DELETE_NOT_FOUND": "not_found",
            "CANCEL": "idle",
            "INSERT": "deleting",
            "SEARCH": "deleting",
            "CLEAR": "deleting"
          }
        },
        {
          "name": "deleted",
          "onEnter": "setStatusDeleted",
          "onExit": "renderTree",
          "on": {
            "ACK": "idle",
            "INSERT": "inserting",
            "SEARCH": "searching",
            "DELETE": "deleting",
            "CLEAR": "cleared"
          }
        },
        {
          "name": "random_inserting",
          "onEnter": "call_doRandomInsert",
          "onExit": "noop",
          "on": {
            "RANDOM_DONE": "idle",
            "CANCEL": "idle",
            "INSERT": "random_inserting",
            "CLEAR": "random_inserting"
          }
        },
        {
          "name": "cleared",
          "onEnter": "clearTree",
          "onExit": "renderTree",
          "on": {
            "ACK": "idle",
            "INSERT": "inserting",
            "RANDOM": "random_inserting"
          }
        }
      ],
      "events": [
        "INSERT",
        "SEARCH",
        "DELETE",
        "RANDOM",
        "CLEAR",
        "SPEED_CHANGE",
        "TOGGLE_STEP",
        "TOGGLE_SHOW_VALUES",
        "INSERT_FINISHED",
        "INSERT_DUPLICATE",
        "SEARCH_FOUND",
        "SEARCH_NOT_FOUND",
        "DELETE_FINISHED",
        "DELETE_NOT_FOUND",
        "RANDOM_DONE",
        "ACK",
        "CANCEL"
      ],
      "notes": "Animation timing and step-by-step behavior are controlled by speedRange (animDelay) and stepToggle. renderTree and setStatus are invoked on many transitions to update visual state. animatePath is used internally during inserting/searching/deleting to highlight comparisons; these are modeled as part of the inserting/searching/deleting states. The UI does not explicitly disable controls during animations; concurrent user actions may invoke additional transitions but the intended flow is to complete the current operation (INSERT/SEARCH/DELETE/RANDOM) before returning to idle."
    }
  },
  {
    "id": "b4cfa970-bdd4-11f0-bd8d-55214871deb0",
    "timestamp": "2025-11-10T01:29:31.271Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "K-Nearest Neighbors (KNN)",
    "answer": {
      "role": "assistant",
      "content": "Concept Title:\nK-Nearest Neighbors (KNN) — interactive, visual classification by nearest neighbors\n\nLearning Objective:\nAfter interacting with this module you will be able to:\n- Understand how KNN classifies a new (query) point by examining the labels of the K nearest training points.\n- See how the choice of K and distance metric (Euclidean vs Manhattan) affects classification and decision regions.\n- Explore the effect of moving points, adding/removing points, and observing how neighbors and the decision boundary change in real time.\n\nInteraction Design:\n- Tools & Controls:\n  - Tool selector (radio buttons): Add Class A, Add Class B, Place Query, Move/Drag Points.\n  - K slider (1–15): choose number of neighbors K; updates classification and visualization live.\n  - Distance metric (Euclidean / Manhattan): changes how distances are computed and shows updated neighbors & boundary.\n  - Buttons: Clear All, Randomize (add random training points), Toggle Decision Map (show/hide colored decision regions).\n- Canvas & SVG:\n  - A canvas draws the decision map (colored background) computed at moderate resolution for responsiveness.\n  - An SVG overlay draws training points (blue/red), the query point (outlined circle), neighbor-highlight rings (pulsing animation), and connecting animated lines to the neighbor points.\n- User interactions:\n  - Click inside the square when in Add Class A or Add Class B to add a labeled training point. Each point is focusable and has an accessible label.\n  - Choose \"Place Query\" then click to place the query point (or drag an existing query to reposition). The system automatically classifies and updates visuals.\n  - Choose \"Move/Drag Points\" then drag any training point or the query to reposition; double-click a point to delete it.\n  - Use the K slider or metric radios to experiment; nearest neighbors pulse and connecting lines animate each time the query or parameters change.\n  - Toggle Decision Map to see the background decision regions (changes color smoothly with a CSS fade).\n- Visual/Auditory Feedback:\n  - Neighbor points are highlighted with a pulsing ring animation and connected with animated lines to the query point. The prediction result (class and confidence) is announced in an aria-live region for screen readers.\n  - The decision map is redrawn on any update and transitions opacity when toggled.\n  - A compact legend and counters show how many Class A/B points exist and the current K.\n\nLayout Description:\n- Safe area: the page uses 24px padding on all sides to respect the safe area.\n- Main layout: A responsive two-column layout (stacked on narrow screens) with:\n  - Left column (info & controls, minimum spacing 16px between controls): Title, Learning Objective, Tool controls (radio buttons), K slider, metric radios, buttons (Randomize, Clear), Toggle Decision Map, and the status/legend/prediction area. Controls are arranged in logical groups with at least 16px gap between them for clarity and touch comfort.\n  - Right column (interactive visualization): a square interactive module (canvas + SVG overlay) that scales while keeping its content centered. It uses 24px internal padding in the overall page; controls maintain at least 16px spacing from the visual.\n- Responsiveness & Accessibility:\n  - On narrow screens the columns stack vertically (controls above the interactive area).\n  - All controls are keyboard accessible, labeled, and the prediction is presented visually and via aria-live text.\n  - Color choices ensure contrast and shapes/labels are present so colorblind users can still distinguish classes (Class A uses blue with 'A', Class B uses red with 'B').\n\nInteractive Module Implementation\nBelow is a single-file, self-contained HTML/CSS/JavaScript implementation of the above design. Just open in a browser — no external libraries or assets required.\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>K-Nearest Neighbors Interactive</title>\n  <style>\n    :root{\n      --safe-pad: 24px;\n      --gap: 16px;\n      --bg: #0f1721;\n      --panel-bg: #0b1220;\n      --card: #0f1727;\n      --muted: #94a3b8;\n      --accent: #10b981;\n      --a-color: #2563eb; /* blue */\n      --b-color: #ef4444; /* red */\n      --query-stroke: #fbbf24; /* yellowish */\n      font-family: Inter, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background:linear-gradient(180deg,#071028 0%, #071226 60%);\n      color:#e6eef8;\n      padding:var(--safe-pad);\n      box-sizing:border-box;\n    }\n    main{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      justify-content:space-between;\n    }\n    /* Responsive: stack vertically on narrow screens */\n    @media (max-width:960px){\n      main{flex-direction:column;}\n    }\n    .panel{\n      width:360px;\n      min-width:280px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      border-radius:12px;\n      padding:20px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      box-sizing:border-box;\n    }\n    .panel h1{\n      font-size:18px;\n      margin:0 0 8px 0;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.4;\n      margin-bottom:12px;\n    }\n    fieldset{\n      border:1px solid rgba(255,255,255,0.03);\n      padding:12px;\n      border-radius:8px;\n      margin:0 0 16px 0;\n    }\n    legend{font-weight:600; font-size:13px; padding:0 6px;}\n    .controls-row{\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n      align-items:center;\n    }\n    label.tool{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      background:rgba(255,255,255,0.02);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      user-select:none;\n      font-size:13px;\n    }\n    input[type=\"radio\"][name=\"tool\"]{accent-color:var(--accent);}\n    .small{\n      font-size:13px;color:var(--muted);\n    }\n    .slider-row{display:flex;gap:12px;align-items:center;}\n    input[type=\"range\"]{width:160px;}\n    .btn{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      color:inherit;\n      font-size:13px;\n    }\n    .btn:active{transform:translateY(1px);}\n    .tog {\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n      padding:8px 10px;\n      border-radius:8px;\n      background:rgba(255,255,255,0.01);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .legend{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      margin-top:8px;\n    }\n    .legend .chip{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      background:rgba(255,255,255,0.02);\n      padding:6px 8px;border-radius:8px;font-size:13px;\n    }\n    .dotA{width:14px;height:14px;border-radius:50%;background:var(--a-color);}\n    .dotB{width:14px;height:14px;border-radius:50%;background:var(--b-color);}\n    .status{\n      margin-top:12px;\n      padding:10px;\n      background:rgba(255,255,255,0.015);\n      border-radius:8px;\n      font-size:14px;\n    }\n\n    /* Interactive area */\n    .canvas-wrap{\n      flex:1;\n      min-width:280px;\n      max-width:880px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n    }\n    .interactive {\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:18px;\n      box-sizing:border-box;\n      border:1px solid rgba(255,255,255,0.03);\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      width: min(720px, calc(100vw - 2*var(--safe-pad) - 420px));\n    }\n    @media (max-width:960px){\n      .interactive{width:100%;}\n    }\n    .stage {\n      position:relative;\n      width:100%;\n      padding-top:100%; /* square */\n      border-radius:8px;\n      overflow:hidden;\n      background:linear-gradient(180deg,#061024, #041427 60%);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    /* Canvas sits behind, SVG overlay on top */\n    .stage canvas{\n      position:absolute; inset:0; width:100%; height:100%; display:block;\n    }\n    .stage svg{\n      position:absolute; inset:0; width:100%; height:100%; overflow:visible;\n    }\n    /* Points */\n    .pt{\n      cursor:grab;\n      transition:transform 0.12s ease;\n    }\n    .pt:active{cursor:grabbing; transform:scale(1.05);}\n    .label{\n      font-size:11px; fill:#ffffff; pointer-events:none; font-weight:600;\n    }\n\n    /* neighbor highlight pulse */\n    @keyframes pulse {\n      0%{ r:8; opacity:0.9; stroke-width:2; }\n      70%{ r:20; opacity:0.08; stroke-width:1; }\n      100%{ r:28; opacity:0; stroke-width:0; }\n    }\n    .pulse-ring{\n      fill:none;\n      stroke-width:2;\n      opacity:0.8;\n    }\n    /* animated lines (stroke dash animation) */\n    .nn-line{\n      stroke-width:2;\n      stroke-linecap:round;\n      stroke-dasharray:6 6;\n      opacity:0.95;\n      transition:stroke-dashoffset 360ms linear;\n    }\n\n    /* decision map fade */\n    .decision-canvas{ transition:opacity 260ms ease-in-out; }\n\n    /* small helper */\n    .muted-sm{color:var(--muted);font-size:12px;}\n    .kbd{background:rgba(255,255,255,0.02);padding:4px 8px;border-radius:6px;font-size:12px;border:1px solid rgba(255,255,255,0.02);}\n\n    /* Ensure min spacing of interactive elements */\n    .group{margin-bottom:16px;}\n  </style>\n</head>\n<body>\n  <main>\n    <section class=\"panel\" aria-labelledby=\"title\">\n      <h1 id=\"title\">K-Nearest Neighbors (KNN) — Interactive Module</h1>\n\n      <p class=\"muted\">Place labeled points, add a query, and experiment with K and distance metric to see how KNN classifies and how the decision regions change.</p>\n\n      <fieldset>\n        <legend>Tools</legend>\n\n        <div class=\"controls-row group\" role=\"radiogroup\" aria-label=\"tool selection\">\n          <label class=\"tool\"><input type=\"radio\" name=\"tool\" value=\"addA\" checked> Add Class A</label>\n          <label class=\"tool\"><input type=\"radio\" name=\"tool\" value=\"addB\"> Add Class B</label>\n          <label class=\"tool\"><input type=\"radio\" name=\"tool\" value=\"query\"> Place Query</label>\n          <label class=\"tool\"><input type=\"radio\" name=\"tool\" value=\"move\"> Move / Drag</label>\n        </div>\n\n        <div class=\"group\">\n          <div class=\"slider-row\">\n            <div class=\"small\">K: <span id=\"kval\">3</span></div>\n            <input id=\"kSlider\" type=\"range\" min=\"1\" max=\"15\" value=\"3\" aria-label=\"K value slider\">\n            <div class=\"small\">Metric:</div>\n            <label class=\"small\"><input type=\"radio\" name=\"metric\" value=\"euclidean\" checked> Euclidean</label>\n            <label class=\"small\" style=\"margin-left:6px;\"><input type=\"radio\" name=\"metric\" value=\"manhattan\"> Manhattan</label>\n          </div>\n        </div>\n\n        <div class=\"group controls-row\">\n          <button id=\"randomizeBtn\" class=\"btn\" aria-label=\"Randomize points\">Randomize</button>\n          <button id=\"clearBtn\" class=\"btn\" aria-label=\"Clear all points\">Clear All</button>\n          <label class=\"tog\" title=\"Show or hide background decision map\"><input id=\"toggleDecision\" type=\"checkbox\" checked> Decision Map</label>\n        </div>\n\n        <div class=\"group legend\" aria-hidden=\"false\">\n          <div class=\"chip\">\n            <div class=\"dotA\" aria-hidden=\"true\"></div><div class=\"muted-sm\">Class A</div>\n          </div>\n          <div class=\"chip\">\n            <div class=\"dotB\" aria-hidden=\"true\"></div><div class=\"muted-sm\">Class B</div>\n          </div>\n          <div class=\"chip\"><div class=\"kbd\" id=\"pointsCount\">0 pts</div></div>\n        </div>\n      </fieldset>\n\n      <div class=\"status\" aria-live=\"polite\" id=\"statusBox\">\n        <div><strong>Prediction:</strong> <span id=\"prediction\">Place a query to classify</span></div>\n        <div class=\"muted-sm\" style=\"margin-top:8px;\">Tips: Click to add points. Double-click a point to remove it. Drag to reposition points.</div>\n      </div>\n    </section>\n\n    <section class=\"interactive\" aria-label=\"KNN interactive stage\">\n      <div style=\"display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;\">\n        <div><strong>Interactive Stage</strong><div class=\"muted-sm\">Click inside to add or place query based on selected tool.</div></div>\n        <div style=\"font-size:13px;color:var(--muted)\"><span id=\"metricLabel\">Euclidean</span> • <span id=\"kLabel\">K=3</span></div>\n      </div>\n\n      <div class=\"stage\" id=\"stage\" role=\"application\" aria-label=\"KNN stage with canvas and points\">\n        <canvas id=\"decisionCanvas\" class=\"decision-canvas\" width=\"400\" height=\"400\" aria-hidden=\"true\"></canvas>\n        <svg id=\"svgOverlay\" viewBox=\"0 0 400 400\" role=\"img\" aria-label=\"points and neighbor lines\"></svg>\n      </div>\n    </section>\n  </main>\n\n  <script>\n    // KNN interactive module (vanilla JS)\n    (function(){\n      // Configuration\n      const CANVAS_RES = 200; // resolution used to compute decision map (per axis)\n      const svgNS = \"http://www.w3.org/2000/svg\";\n\n      // DOM\n      const stage = document.getElementById('stage');\n      const decisionCanvas = document.getElementById('decisionCanvas');\n      const svg = document.getElementById('svgOverlay');\n      const kSlider = document.getElementById('kSlider');\n      const kvalLabel = document.getElementById('kval');\n      const metricRadios = document.querySelectorAll('input[name=\"metric\"]');\n      const toolRadios = document.querySelectorAll('input[name=\"tool\"]');\n      const randomizeBtn = document.getElementById('randomizeBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const toggleDecision = document.getElementById('toggleDecision');\n      const predictionEl = document.getElementById('prediction');\n      const statusBox = document.getElementById('statusBox');\n      const pointsCount = document.getElementById('pointsCount');\n      const metricLabel = document.getElementById('metricLabel');\n      const kLabel = document.getElementById('kLabel');\n\n      // State\n      let points = []; // training points: {id,x,y,class} class: 0(A) or 1(B)\n      let query = null; // {id,x,y} class = null\n      let nextId = 1;\n      let K = parseInt(kSlider.value,10);\n      let metric = 'euclidean';\n      let currentTool = 'addA';\n      let dragging = null;\n      let dragOffset = {x:0,y:0};\n      let decisionVisible = toggleDecision.checked;\n\n      // Canvas & SVG sizing (responsive)\n      function resizeToDisplay() {\n        const rect = stage.getBoundingClientRect();\n        const size = Math.min(rect.width, rect.height);\n        const canvasEl = decisionCanvas;\n        canvasEl.width = CANVAS_RES;\n        canvasEl.height = CANVAS_RES;\n        canvasEl.style.width = '100%';\n        canvasEl.style.height = '100%';\n        svg.setAttribute('viewBox', `0 0 ${CANVAS_RES} ${CANVAS_RES}`);\n        // Scale existing SVG elements by re-rendering\n        renderAll();\n      }\n      window.addEventListener('resize', resizeToDisplay);\n      // initial resize after load\n      setTimeout(resizeToDisplay, 10);\n\n      // Helpers: coordinate transform from event to SVG coords\n      function clientToSVGCoords(clientX, clientY) {\n        const rect = stage.getBoundingClientRect();\n        const px = clientX - rect.left;\n        const py = clientY - rect.top;\n        const size = Math.min(rect.width, rect.height);\n        const scale = CANVAS_RES / size;\n        // center if stage rect not square—use top-left padding to center the square\n        const leftPad = (rect.width - size) / 2;\n        const topPad = (rect.height - size) / 2;\n        const x = (px - leftPad) * scale;\n        const y = (py - topPad) * scale;\n        // clamp\n        return {x: Math.max(0, Math.min(CANVAS_RES, x)), y: Math.max(0, Math.min(CANVAS_RES, y))};\n      }\n\n      // Add & remove point functions\n      function addPoint(x,y,cls){\n        const id = nextId++;\n        points.push({id,x,y,class:cls});\n        renderPoint({id,x,y,class:cls});\n        updateCounts();\n        computeAndRender();\n      }\n      function setQuery(x,y){\n        if(!query){\n          query = {id:'q', x, y};\n          renderQuery();\n        } else {\n          query.x = x; query.y = y;\n        }\n        updateQuery();\n        computeAndRender();\n      }\n      function removePointById(id){\n        // check if id is query\n        if(query && query.id === id){\n          query = null;\n          removeQueryFromSVG();\n          computeAndRender();\n          return;\n        }\n        const idx = points.findIndex(p=>p.id===id);\n        if(idx>=0){\n          points.splice(idx,1);\n          const el = svg.querySelector('[data-id=\"'+id+'\"]');\n          if(el) el.remove();\n          updateCounts();\n          computeAndRender();\n        }\n      }\n\n      // Rendering helpers\n      function clearSVGNeighbors(){\n        const els = svg.querySelectorAll('.nn-line, .pulse-ring');\n        els.forEach(e=>e.remove());\n      }\n\n      function renderAll(){\n        // remove all point elements, then recreate\n        while(svg.firstChild) svg.removeChild(svg.firstChild);\n        points.forEach(renderPoint);\n        if(query) renderQuery();\n        computeAndRender();\n      }\n\n      function renderPoint(pt){\n        // circle group with label\n        const g = document.createElementNS(svgNS,'g');\n        g.setAttribute('transform', `translate(${pt.x},${pt.y})`);\n        g.setAttribute('data-id', pt.id);\n        g.classList.add('pt');\n        g.setAttribute('tabindex','0');\n        g.setAttribute('role','button');\n        g.setAttribute('aria-label', `Class ${pt.class===0?'A':'B'} point at (${Math.round(pt.x)},${Math.round(pt.y)})`);\n        // circle\n        const circle = document.createElementNS(svgNS,'circle');\n        circle.setAttribute('r', 6);\n        circle.setAttribute('fill', pt.class===0?getComputedStyle(document.documentElement).getPropertyValue('--a-color').trim() : getComputedStyle(document.documentElement).getPropertyValue('--b-color').trim());\n        circle.setAttribute('stroke','rgba(255,255,255,0.06)');\n        circle.setAttribute('stroke-width','1.4');\n        circle.setAttribute('pointer-events','auto');\n        g.appendChild(circle);\n        // small label inside for clarity\n        const txt = document.createElementNS(svgNS,'text');\n        txt.setAttribute('x', 0);\n        txt.setAttribute('y', 4);\n        txt.setAttribute('text-anchor','middle');\n        txt.setAttribute('class','label');\n        txt.textContent = pt.class===0?'A':'B';\n        g.appendChild(txt);\n\n        // event listeners for drag / double-click\n        g.addEventListener('pointerdown', onPointerDownPoint);\n        g.addEventListener('dblclick', (e)=>{ e.stopPropagation(); removePointById(pt.id); });\n        g.addEventListener('keydown', (e)=>{\n          if(e.key === 'Delete' || e.key === 'Backspace') removePointById(pt.id);\n        });\n\n        svg.appendChild(g);\n      }\n\n      function renderQuery(){\n        // remove old query if any\n        removeQueryFromSVG();\n        if(!query) return;\n        const g = document.createElementNS(svgNS,'g');\n        g.setAttribute('transform', `translate(${query.x},${query.y})`);\n        g.setAttribute('data-id', query.id);\n        g.classList.add('pt');\n        g.setAttribute('tabindex','0');\n        g.setAttribute('role','button');\n        g.setAttribute('aria-label', `Query point at (${Math.round(query.x)},${Math.round(query.y)})`);\n        // outer ring\n        const ring = document.createElementNS(svgNS,'circle');\n        ring.setAttribute('r', 12);\n        ring.setAttribute('fill','none');\n        ring.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--query-stroke').trim());\n        ring.setAttribute('stroke-width','2');\n        ring.setAttribute('opacity','0.6');\n        g.appendChild(ring);\n        // core\n        const circle = document.createElementNS(svgNS,'circle');\n        circle.setAttribute('r', 7);\n        circle.setAttribute('fill','none');\n        circle.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--query-stroke').trim());\n        circle.setAttribute('stroke-width','2');\n        g.appendChild(circle);\n        // label\n        const txt = document.createElementNS(svgNS,'text');\n        txt.setAttribute('x', 0);\n        txt.setAttribute('y', 4);\n        txt.setAttribute('text-anchor','middle');\n        txt.setAttribute('class','label');\n        txt.textContent = '?';\n        g.appendChild(txt);\n\n        g.addEventListener('pointerdown', onPointerDownPoint);\n        g.addEventListener('dblclick', (e)=>{ e.stopPropagation(); removePointById(query.id); });\n\n        svg.appendChild(g);\n      }\n      function removeQueryFromSVG(){\n        const el = svg.querySelector('[data-id=\"q\"]');\n        if(el) el.remove();\n      }\n\n      // Update the textual indicators\n      function updateCounts(){\n        pointsCount.textContent = `${points.length} pts`;\n      }\n\n      // Distance functions\n      function distance(a,b){\n        const dx = a.x - b.x;\n        const dy = a.y - b.y;\n        if(metric === 'euclidean') return Math.sqrt(dx*dx + dy*dy);\n        return Math.abs(dx) + Math.abs(dy);\n      }\n\n      // KNN compute\n      function computeNeighbors(q){\n        const arr = points.map(p => ({...p, d: distance(p,q)}));\n        arr.sort((p1,p2)=>p1.d - p2.d);\n        return arr.slice(0, Math.min(K, arr.length));\n      }\n\n      // Compute prediction for the query\n      function computePrediction(){\n        if(!query) return null;\n        if(points.length === 0) return {label:null, confidence:0, neighbors:[]};\n        const neighbors = computeNeighbors(query);\n        // majority vote\n        const counts = neighbors.reduce((acc,n)=>{\n          acc[n.class] = (acc[n.class] || 0) + 1;\n          return acc;\n        },{});\n        let label = null;\n        if((counts[0]||0) > (counts[1]||0)) label = 0;\n        else if((counts[1]||0) > (counts[0]||0)) label = 1;\n        else {\n          // tie-break: choose nearest neighbor's class\n          label = neighbors[0] ? neighbors[0].class : null;\n        }\n        const confidence = neighbors.length ? ((counts[label]||0)/neighbors.length) : 0;\n        return {label, confidence, neighbors};\n      }\n\n      // Render neighbor highlights and lines; and update prediction text\n      function renderNeighborsAndPrediction(){\n        clearSVGNeighbors();\n        const pred = computePrediction();\n        if(!query){\n          predictionEl.textContent = 'Place a query to classify';\n          return;\n        }\n        if(points.length === 0){\n          predictionEl.textContent = 'No training points: add some Class A or B points.';\n          return;\n        }\n        const {label, confidence, neighbors} = pred;\n        // show animated connecting lines and pulse rings for each neighbor\n        neighbors.forEach((n, idx)=>{\n          // draw line\n          const line = document.createElementNS(svgNS,'line');\n          line.setAttribute('x1', query.x);\n          line.setAttribute('y1', query.y);\n          line.setAttribute('x2', n.x);\n          line.setAttribute('y2', n.y);\n          line.classList.add('nn-line');\n          line.setAttribute('stroke', n.class===0?getComputedStyle(document.documentElement).getPropertyValue('--a-color').trim() : getComputedStyle(document.documentElement).getPropertyValue('--b-color').trim());\n          // stroke dash animation: set dashoffset high then animate to zero\n          const len = Math.hypot(n.x - query.x, n.y - query.y);\n          line.style.strokeDashoffset = String(len);\n          // force reflow then animate\n          requestAnimationFrame(()=>{ line.style.strokeDashoffset = '0'; });\n          svg.appendChild(line);\n\n          // pulsing ring\n          const ring = document.createElementNS(svgNS,'circle');\n          ring.setAttribute('cx', n.x);\n          ring.setAttribute('cy', n.y);\n          ring.classList.add('pulse-ring');\n          ring.setAttribute('stroke', n.class===0?getComputedStyle(document.documentElement).getPropertyValue('--a-color').trim() : getComputedStyle(document.documentElement).getPropertyValue('--b-color').trim());\n          ring.setAttribute('r', 8);\n          ring.style.animation = `pulse 1100ms ${idx*80}ms linear infinite`;\n          svg.appendChild(ring);\n        });\n\n        // update text\n        const pretty = label === 0 ? 'Class A' : label === 1 ? 'Class B' : 'Undetermined';\n        const pct = Math.round((confidence||0)*100);\n        predictionEl.textContent = `Predicted: ${pretty} (${pct}% of ${Math.min(K, points.length)} nearest)`;\n        // update labels\n        metricLabel.textContent = metric[0].toUpperCase() + metric.slice(1);\n        kLabel.textContent = `K=${K}`;\n      }\n\n      // Decision map computation (color each small cell by predicted class)\n      function renderDecisionMap(){\n        const ctx = decisionCanvas.getContext('2d');\n        const w = decisionCanvas.width;\n        const h = decisionCanvas.height;\n        const img = ctx.createImageData(w, h);\n        // If no points, fill with subtle neutral color\n        if(points.length === 0){\n          for(let i=0;i<img.data.length;i+=4){\n            img.data[i] = 6; img.data[i+1]=18; img.data[i+2]=36; img.data[i+3]=255;\n          }\n          ctx.putImageData(img,0,0);\n          return;\n        }\n        // For each pixel, compute predicted class among K neighbors\n        // Reduce resolution by stepping to keep responsive if needed\n        for(let y=0;y<h;y++){\n          for(let x=0;x<w;x++){\n            const qx = (x + 0.5) * (CANVAS_RES / w);\n            const qy = (y + 0.5) * (CANVAS_RES / h);\n            const q = {x: qx, y: qy};\n            // compute neighbors distances\n            const arr = points.map(p=> ({...p, d: (metric === 'euclidean') ? Math.hypot(p.x - q.x, p.y - q.y) : Math.abs(p.x - q.x) + Math.abs(p.y - q.y)}));\n            arr.sort((a,b)=>a.d - b.d);\n            const top = arr.slice(0, Math.min(K, arr.length));\n            const counts = top.reduce((acc,n)=>{ acc[n.class] = (acc[n.class]||0)+1; return acc; }, {});\n            let lab;\n            if((counts[0]||0) > (counts[1]||0)) lab = 0;\n            else if((counts[1]||0) > (counts[0]||0)) lab = 1;\n            else lab = top[0] ? top[0].class : 0;\n            // compute color: blend towards class color with low alpha\n            let r,g,b;\n            if(lab === 0){ r=37; g=99; b=235; } else { r=239; g=68; b=68; }\n            // low alpha so points are visible and background stays dark\n            const alpha = 28; // out of 255\n            const baseR = 6, baseG = 18, baseB = 36;\n            const finalR = Math.round((r*alpha + baseR*(255-alpha))/255);\n            const finalG = Math.round((g*alpha + baseG*(255-alpha))/255);\n            const finalB = Math.round((b*alpha + baseB*(255-alpha))/255);\n            const idx = (y*w + x)*4;\n            img.data[idx] = finalR;\n            img.data[idx+1] = finalG;\n            img.data[idx+2] = finalB;\n            img.data[idx+3] = 255;\n          }\n        }\n        ctx.putImageData(img, 0, 0);\n      }\n\n      // compute + render everything\n      function computeAndRender(){\n        // decision map\n        if(decisionVisible){\n          renderDecisionMap();\n          decisionCanvas.style.opacity = 1;\n        } else {\n          decisionCanvas.style.opacity = 0;\n        }\n        // neighbors + prediction\n        renderNeighborsAndPrediction();\n      }\n\n      // Event handlers for stage interactions\n      function onStagePointerDown(e){\n        // only left click / touch\n        if(e.button && e.button !== 0) return;\n        const pt = clientToSVGCoords(e.clientX, e.clientY);\n        if(currentTool === 'addA') { addPoint(pt.x, pt.y, 0); }\n        else if(currentTool === 'addB') { addPoint(pt.x, pt.y, 1); }\n        else if(currentTool === 'query') { setQuery(pt.x, pt.y); }\n        // move mode should start drag only if clicked on a point itself (handled by point pointerdown)\n      }\n\n      // Pointer handlers for point elements\n      function onPointerDownPoint(e){\n        e.stopPropagation();\n        const id = this.getAttribute('data-id');\n        const isQuery = id === 'q';\n        const tool = currentTool;\n        if(tool === 'addA' || tool === 'addB'){\n          // clicking a point while in add mode toggles nothing; allow selection for moving instead\n        }\n        // start dragging only if tool is move or if it's the query and tool is query (allow drag)\n        if(tool === 'move' || (isQuery && tool === 'query')){\n          dragging = id;\n          const pt = clientToSVGCoords(e.clientX, e.clientY);\n          const obj = (isQuery ? query : points.find(p=>p.id==id));\n          if(!obj) return;\n          dragOffset.x = obj.x - pt.x;\n          dragOffset.y = obj.y - pt.y;\n          this.setPointerCapture(e.pointerId);\n        }\n      }\n      function onPointerMoveStage(e){\n        if(!dragging) return;\n        const pt = clientToSVGCoords(e.clientX, e.clientY);\n        const id = dragging;\n        if(id === 'q' && query){\n          query.x = Math.max(0,Math.min(CANVAS_RES, pt.x + dragOffset.x));\n          query.y = Math.max(0,Math.min(CANVAS_RES, pt.y + dragOffset.y));\n          const el = svg.querySelector('[data-id=\"q\"]');\n          if(el) el.setAttribute('transform', `translate(${query.x},${query.y})`);\n          computeAndRender();\n        } else {\n          const p = points.find(pp=>pp.id==id);\n          if(p){\n            p.x = Math.max(0,Math.min(CANVAS_RES, pt.x + dragOffset.x));\n            p.y = Math.max(0,Math.min(CANVAS_RES, pt.y + dragOffset.y));\n            const el = svg.querySelector('[data-id=\"'+id+'\"]');\n            if(el) el.setAttribute('transform', `translate(${p.x},${p.y})`);\n            computeAndRender();\n          }\n        }\n      }\n      function onPointerUpStage(e){\n        if(dragging){\n          // release pointer capture\n          const el = svg.querySelector('[data-id=\"'+dragging+'\"]');\n          if(el) try{ el.releasePointerCapture(e.pointerId); }catch(_){}\n        }\n        dragging = null;\n      }\n\n      // UI control bindings\n      kSlider.addEventListener('input', ()=>{\n        K = parseInt(kSlider.value,10);\n        kvalLabel.textContent = K;\n        kLabel.textContent = `K=${K}`;\n        computeAndRender();\n      });\n      metricRadios.forEach(r=>{\n        r.addEventListener('change', ()=>{\n          if(r.checked){\n            metric = r.value;\n            metricLabel.textContent = metric[0].toUpperCase() + metric.slice(1);\n            computeAndRender();\n          }\n        });\n      });\n      toolRadios.forEach(r=>{\n        r.addEventListener('change', ()=>{\n          if(r.checked) currentTool = r.value;\n        });\n      });\n      randomizeBtn.addEventListener('click', ()=>{\n        points = [];\n        nextId = 1;\n        // add 8-14 random points\n        const n = 10 + Math.floor(Math.random()*6);\n        for(let i=0;i<n;i++){\n          const cls = Math.random() < 0.5 ? 0 : 1;\n          const x = 20 + Math.random()*(CANVAS_RES-40);\n          const y = 20 + Math.random()*(CANVAS_RES-40);\n          points.push({id: nextId++, x,y, class:cls});\n        }\n        query = null;\n        renderAll();\n        updateCounts();\n      });\n      clearBtn.addEventListener('click', ()=>{\n        points = []; query = null; nextId = 1;\n        renderAll();\n        updateCounts();\n      });\n      toggleDecision.addEventListener('change', ()=>{\n        decisionVisible = toggleDecision.checked;\n        computeAndRender();\n      });\n\n      // Stage mouse events\n      stage.addEventListener('pointerdown', onStagePointerDown);\n      window.addEventListener('pointermove', onPointerMoveStage);\n      window.addEventListener('pointerup', onPointerUpStage);\n      // For touch devices, reduce delay\n      stage.addEventListener('touchstart', (e)=>{ e.preventDefault(); });\n\n      // keyboard accessibility: allow pressing Enter on the stage to place query at center\n      stage.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter'){\n          const rect = stage.getBoundingClientRect();\n          const centerX = rect.left + rect.width/2;\n          const centerY = rect.top + rect.height/2;\n          if(currentTool === 'addA') addPoint(CANVAS_RES/2, CANVAS_RES/2, 0);\n          else if(currentTool === 'addB') addPoint(CANVAS_RES/2, CANVAS_RES/2, 1);\n          else if(currentTool === 'query') setQuery(CANVAS_RES/2, CANVAS_RES/2);\n        }\n      });\n\n      // Update query visualization after programmatic move\n      function updateQuery(){\n        // move query element if exists\n        const el = svg.querySelector('[data-id=\"q\"]');\n        if(el && query) el.setAttribute('transform', `translate(${query.x},${query.y})`);\n        computeAndRender();\n      }\n\n      // Initialize with a few random points\n      (function init(){\n        // small starter dataset for learning\n        points = [\n          {id:1,x:60,y:80,class:0},\n          {id:2,x:90,y:110,class:0},\n          {id:3,x:70,y:140,class:0},\n          {id:4,x:320,y:260,class:1},\n          {id:5,x:300,y:220,class:1},\n          {id:6,x:260,y:260,class:1}\n        ];\n        nextId = 7;\n        resizeToDisplay();\n        renderAll();\n        updateCounts();\n      })();\n\n      // Click on empty SVG to add points when appropriate\n      svg.addEventListener('pointerdown', (e)=>{\n        // prevent stage handler (handled above) if clicking on point element (handled separately)\n        if(e.target.closest('[data-id]')) return;\n        const pt = clientToSVGCoords(e.clientX, e.clientY);\n        if(currentTool === 'addA') addPoint(pt.x, pt.y, 0);\n        else if(currentTool === 'addB') addPoint(pt.x, pt.y, 1);\n        else if(currentTool === 'query') setQuery(pt.x, pt.y);\n      });\n\n      // initial compute\n      computeAndRender();\n\n      // Expose some helpful keyboard tips in status for screen readers\n      statusBox.setAttribute('aria-hidden','false');\n    })();\n  </script>\n</body>\n</html>\n```\n\nHow this reinforces understanding:\n- You place labeled examples and a query point and immediately see which labeled points are nearest (pulsing) and how they vote to classify the query. Changing K shows how the local neighborhood size affects classification stability (low K → sensitive to noise; high K → smoother decisions).\n- Switching metrics demonstrates how distance definition changes neighbor selection and the decision regions.\n- The decision map gives an overall view of how the classifier partitions space, while the animated neighbors and lines make the local mechanism of KNN tactile and visible.\n\nNotes on accessibility and performance:\n- The interface uses clear labels and an aria-live region to announce predictions.\n- The decision map uses a modest resolution (200×200) to stay responsive; you can increase CANVAS_RES if your device handles higher work."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of K-Nearest Neighbors (KNN).\n\n**Project Overview:**\nTopic: K-Nearest Neighbors (KNN)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "K-Nearest Neighbors (KNN)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "b7a73370-bdd4-11f0-bd8d-55214871deb0",
    "timestamp": "2025-11-10T01:29:36.039Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Bubble Sort",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Bubble Sort Explorer</title>\n  <style>\n    /* Safe area margins: 24px on all sides */\n    :root {\n      --safe-padding: 24px;\n      --gap: 16px; /* minimum spacing between interactive elements */\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --muted: #9aa4bf;\n      --accent: #4f46e5;\n      --ok: #10b981;\n      --danger: #ef4444;\n      --compare: #f59e0b;\n      --swap: #ef4444;\n      --sorted: #06b6d4;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071022 0%, #0b1220 100%);\n      color:#e6eef8;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app {\n      padding: var(--safe-padding);\n      box-sizing: border-box;\n      min-height: 100vh;\n      display: grid;\n      grid-template-columns: 1fr 360px;\n      grid-gap: var(--gap);\n      align-items: start;\n    }\n\n    /* Responsive: single column under 900px */\n    @media (max-width: 900px) {\n      .app {\n        grid-template-columns: 1fr;\n      }\n    }\n\n    header.module {\n      grid-column: 1 / -1;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 12px;\n      padding: 18px;\n      display:flex;\n      gap: 18px;\n      align-items: center;\n      box-shadow: 0 4px 20px rgba(2,6,23,0.6);\n    }\n    .title {\n      font-size: 20px;\n      font-weight: 600;\n      margin: 0;\n    }\n    .subtitle {\n      color: var(--muted);\n      font-size: 13px;\n      margin: 0;\n    }\n\n    /* Left main panel: visualization */\n    .visual-panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius: 12px;\n      padding: 18px;\n      min-height: 420px;\n      display:flex;\n      flex-direction:column;\n      gap: 18px;\n      box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n    }\n    .vis-top {\n      display:flex;\n      gap: 16px;\n      align-items: center;\n      justify-content: space-between;\n    }\n    .learning {\n      max-width: 720px;\n    }\n    .learning h3 {\n      margin: 0 0 6px 0;\n      font-size: 16px;\n    }\n    .learning p {\n      margin: 0;\n      color: var(--muted);\n      font-size: 13px;\n      line-height: 1.3;\n    }\n\n    /* Visualization area */\n    .canvas {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));\n      border: 1px solid rgba(255,255,255,0.03);\n      border-radius: 10px;\n      height: 260px;\n      position: relative;\n      overflow: hidden;\n      padding: 12px;\n      display:flex;\n      align-items:flex-end;\n      justify-content:center;\n    }\n\n    .bars {\n      position:relative;\n      height: 100%;\n      width: 100%;\n      max-width: 980px;\n    }\n\n    .bar {\n      position:absolute;\n      bottom:12px;\n      width: 48px;\n      border-radius: 8px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));\n      color:#0b1220;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:600;\n      transition: left 320ms ease, transform 320ms ease, background-color 180ms ease, width 320ms ease;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.5), inset 0 -4px 8px rgba(255,255,255,0.02);\n      user-select: none;\n    }\n    .bar .label {\n      font-size: 13px;\n      color: #071022;\n    }\n\n    /* Visual states */\n    .bar.compare { background: linear-gradient(180deg, #fff7ed, #fff1dd); box-shadow:0 8px 24px rgba(245,158,11,0.12); }\n    .bar.swap { background: linear-gradient(180deg, #ffecee, #ffdfe1); box-shadow:0 10px 30px rgba(239,68,68,0.12); }\n    .bar.sorted { background: linear-gradient(180deg, #e6fffb, #ccfff7); box-shadow:0 8px 24px rgba(6,182,212,0.08); }\n    .bar.dim { opacity: 0.42; }\n\n    /* Controls */\n    .controls {\n      display:flex;\n      gap: 12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    button, input[type=\"range\"], select {\n      font-size: 13px;\n      padding: 8px 12px;\n      border-radius: 8px;\n      border: none;\n      background: rgba(255,255,255,0.03);\n      color: #e6eef8;\n      cursor: pointer;\n      min-height:40px;\n    }\n    button:focus { outline:2px solid rgba(79,70,229,0.25); }\n    .btn-primary {\n      background: linear-gradient(90deg,var(--accent), #7c3aed);\n      box-shadow: 0 6px 18px rgba(79,70,229,0.18);\n      border: 1px solid rgba(255,255,255,0.02);\n    }\n    .btn-ghost {\n      background: transparent;\n      border: 1px solid rgba(255,255,255,0.04);\n    }\n    .play-toggle { display:flex; gap:8px; align-items:center; }\n\n    .small {\n      font-size:13px;\n      padding: 6px 10px;\n      min-height:36px;\n    }\n\n    /* Right panel: options and pseudocode */\n    .side-panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.007));\n      border-radius: 12px;\n      padding: 18px;\n      display:flex;\n      flex-direction:column;\n      gap:16px;\n      min-height: 420px;\n      box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n    }\n    .panel-section h4 { margin:0 0 8px 0; font-size:14px; }\n    .inputs { display:flex; gap:12px; flex-wrap:wrap; }\n    .inputs input[type=\"text\"] {\n      background: rgba(255,255,255,0.02);\n      border: 1px solid rgba(255,255,255,0.03);\n      color: #e6eef8;\n      padding: 8px 10px;\n      border-radius:8px;\n      min-width: 0;\n    }\n    .stat-grid {\n      display:grid;\n      grid-template-columns: repeat(2,1fr);\n      gap:8px;\n    }\n    .stat {\n      background: rgba(255,255,255,0.02);\n      padding:8px;\n      border-radius:8px;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .stat b { color:#e6eef8; display:block; font-size:15px; }\n\n    pre.pseudo {\n      background: rgba(255,255,255,0.02);\n      padding: 12px;\n      border-radius:8px;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n      font-size:13px;\n      color:var(--muted);\n      margin:0;\n      overflow:auto;\n    }\n    .pseudo .line { display:block; padding: 2px 6px; border-radius:6px; }\n    .pseudo .active { background: rgba(79,70,229,0.12); color: #fff; }\n\n    /* Footer small tips */\n    .tips {\n      color: var(--muted);\n      font-size: 13px;\n    }\n\n    /* Accessibility helpers */\n    .sr-only {\n      position:absolute;\n      left:-10000px;\n      top:auto;\n      width:1px;\n      height:1px;\n      overflow:hidden;\n    }\n\n  </style>\n</head>\n<body>\n  <main class=\"app\" id=\"app\">\n    <header class=\"module\" aria-labelledby=\"title\">\n      <div>\n        <h1 id=\"title\" class=\"title\">Bubble Sort — Interactive Explorer</h1>\n        <p class=\"subtitle\">Visualize comparisons, swaps, and how repeated passes bubble the largest elements to the end.</p>\n      </div>\n      <div style=\"margin-left:auto; text-align:right;\">\n        <div class=\"subtitle\" style=\"font-weight:600\">One concept: Bubble Sort</div>\n        <div class=\"tips\" style=\"margin-top:6px\">Controls: Step • Play/Pause • Randomize • Edit array</div>\n      </div>\n    </header>\n\n    <!-- Left: Visualization & Controls -->\n    <section class=\"visual-panel\" aria-labelledby=\"learningTitle\">\n      <div class=\"vis-top\">\n        <div class=\"learning\">\n          <h3 id=\"learningTitle\">Learning Objective</h3>\n          <p>\n            After interacting with this module you will visually understand how Bubble Sort compares adjacent items,\n            performs swaps when needed, and completes multiple passes until the array is sorted. Observe comparisons,\n            swaps, and the growing \"sorted\" region at the end.\n          </p>\n        </div>\n\n        <div style=\"min-width:220px;\">\n          <div style=\"color:var(--muted); font-size:13px;\">Current mode</div>\n          <div style=\"margin-top:6px; display:flex; gap:8px;\">\n            <button class=\"small btn-ghost\" id=\"stepBtn\" title=\"Step one comparison or swap (keyboard: S)\">Step</button>\n            <button class=\"small btn-primary\" id=\"playBtn\" title=\"Play / Pause (keyboard: Space)\">Play</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"canvas\" id=\"canvas\" aria-live=\"polite\" aria-label=\"Sorting visualization\">\n        <div class=\"bars\" id=\"bars\" role=\"list\" aria-label=\"Array elements as bars\"></div>\n      </div>\n\n      <div style=\"display:flex; gap:var(--gap); align-items:center; justify-content:space-between; flex-wrap:wrap;\">\n        <div class=\"controls\" role=\"group\" aria-label=\"Array controls\">\n          <button id=\"randBtn\" class=\"btn-ghost\">Randomize</button>\n          <label style=\"display:flex; gap:8px; align-items:center;\">\n            <span class=\"subtitle\" style=\"font-size:13px; color:var(--muted);\">Size</span>\n            <input id=\"sizeRange\" type=\"range\" min=\"3\" max=\"14\" value=\"8\" />\n          </label>\n          <label style=\"display:flex; gap:8px; align-items:center;\">\n            <span class=\"subtitle\" style=\"font-size:13px; color:var(--muted);\">Speed</span>\n            <input id=\"speedRange\" type=\"range\" min=\"50\" max=\"1200\" value=\"380\" />\n          </label>\n          <button id=\"resetBtn\" class=\"btn-ghost\">Reset</button>\n        </div>\n\n        <div style=\"display:flex; gap:12px; align-items:center;\">\n          <div class=\"subtitle\" id=\"statusText\" style=\"font-size:13px; color:var(--muted)\">Ready</div>\n        </div>\n      </div>\n    </section>\n\n    <!-- Right: Options, stats, pseudocode -->\n    <aside class=\"side-panel\" aria-labelledby=\"optionsTitle\">\n      <div class=\"panel-section\">\n        <h4 id=\"optionsTitle\">Array & Options</h4>\n        <div class=\"inputs\">\n          <input id=\"arrayInput\" type=\"text\" placeholder=\"Enter numbers, e.g. 5,3,8,1\" aria-label=\"Array values input\" />\n          <button id=\"setBtn\" class=\"small btn-ghost\">Set</button>\n        </div>\n        <div style=\"margin-top:10px; color:var(--muted); font-size:13px;\">\n          Tip: values are parsed as numbers. Use commas or spaces.\n        </div>\n      </div>\n\n      <div class=\"panel-section\">\n        <h4>Statistics</h4>\n        <div class=\"stat-grid\" aria-live=\"polite\">\n          <div class=\"stat\"><span class=\"subtitle\">Comparisons</span><b id=\"compCount\">0</b></div>\n          <div class=\"stat\"><span class=\"subtitle\">Swaps</span><b id=\"swapCount\">0</b></div>\n          <div class=\"stat\"><span class=\"subtitle\">Pass</span><b id=\"passCount\">0</b></div>\n          <div class=\"stat\"><span class=\"subtitle\">Array size</span><b id=\"sizeLabel\">8</b></div>\n        </div>\n      </div>\n\n      <div class=\"panel-section\" style=\"flex:1; display:flex; flex-direction:column;\">\n        <h4>Pseudocode</h4>\n        <pre class=\"pseudo\" id=\"pseudocode\" aria-hidden=\"false\">\n<span class=\"line\" data-line=\"1\">1: for i from 0 to n-1</span>\n<span class=\"line\" data-line=\"2\">2:   for j from 0 to n-2-i</span>\n<span class=\"line\" data-line=\"3\">3:     if array[j] > array[j+1]</span>\n<span class=\"line\" data-line=\"4\">4:       swap array[j] and array[j+1]</span>\n<span class=\"line\" data-line=\"5\">5: end</span>\n        </pre>\n      </div>\n\n      <div>\n        <h4>Design Plan</h4>\n        <div style=\"font-size:13px; color:var(--muted); line-height:1.3;\">\n          <strong>Interaction design:</strong> Step compares one pair; Play auto-steps at adjustable speed. Randomize or set custom array.\n          Visual feedback highlights compared bars, animates swaps, and marks sorted items. Pseudocode lines highlight corresponding actions.\n          <br/><br/>\n          <strong>Layout:</strong> Left column: visualization + controls. Right column: inputs, stats, pseudocode. Spacing uses 24px safe padding and at least 16px gaps.\n        </div>\n      </div>\n    </aside>\n  </main>\n\n  <script>\n    // Bubble Sort Interactive Module (vanilla JS)\n    (function () {\n      // DOM refs\n      const barsEl = document.getElementById('bars');\n      const sizeRange = document.getElementById('sizeRange');\n      const sizeLabel = document.getElementById('sizeLabel');\n      const randBtn = document.getElementById('randBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const stepBtn = document.getElementById('stepBtn');\n      const playBtn = document.getElementById('playBtn');\n      const speedRange = document.getElementById('speedRange');\n      const arrayInput = document.getElementById('arrayInput');\n      const setBtn = document.getElementById('setBtn');\n      const compCountEl = document.getElementById('compCount');\n      const swapCountEl = document.getElementById('swapCount');\n      const passCountEl = document.getElementById('passCount');\n      const statusText = document.getElementById('statusText');\n      const pseudocode = document.getElementById('pseudocode');\n\n      // State\n      let array = [];\n      let size = parseInt(sizeRange.value, 10);\n      let positions = []; // left positions for each index (px)\n      let isPlaying = false;\n      let timer = null;\n      let speed = parseInt(speedRange.value, 10);\n      let comparisons = 0;\n      let swaps = 0;\n      let pass = 0;\n\n      // Algorithm pointers\n      let i = 0, j = 0;\n      let n = size;\n      let sortedUntil = n; // elements from sortedUntil..n-1 are sorted\n\n      // Accessibility / keyboard controls\n      document.addEventListener('keydown', (e) => {\n        if (e.code === 'Space') {\n          e.preventDefault();\n          togglePlay();\n        } else if (e.key === 's' || e.key === 'S') {\n          e.preventDefault();\n          step();\n        }\n      });\n\n      // Initialize\n      function init() {\n        size = parseInt(sizeRange.value, 10);\n        sizeLabel.textContent = size;\n        generateRandom(size);\n        resetState();\n        render();\n        attachEventListeners();\n      }\n\n      function attachEventListeners() {\n        window.addEventListener('resize', recalcPositions);\n        sizeRange.addEventListener('input', () => {\n          size = parseInt(sizeRange.value, 10);\n          sizeLabel.textContent = size;\n        });\n        sizeRange.addEventListener('change', () => {\n          size = parseInt(sizeRange.value, 10);\n          generateRandom(size);\n          resetState();\n          render();\n        });\n\n        randBtn.addEventListener('click', () => {\n          generateRandom(size);\n          resetState();\n          render();\n        });\n        resetBtn.addEventListener('click', () => {\n          resetState();\n          render();\n        });\n        stepBtn.addEventListener('click', step);\n        playBtn.addEventListener('click', togglePlay);\n        speedRange.addEventListener('input', () => {\n          speed = parseInt(speedRange.value, 10);\n          if (isPlaying) startAutoPlay();\n        });\n\n        setBtn.addEventListener('click', () => {\n          const text = arrayInput.value.trim();\n          if (!text) return;\n          const parsed = parseArrayText(text);\n          if (parsed && parsed.length >= 2) {\n            array = parsed.slice(0, 50);\n            size = array.length;\n            sizeRange.value = size;\n            sizeLabel.textContent = size;\n            resetState();\n            render();\n          } else {\n            alert('Please enter at least two numbers separated by commas or spaces.');\n          }\n        });\n      }\n\n      function parseArrayText(text) {\n        // allow commas or spaces\n        const parts = text.split(/[\\s,]+/).filter(Boolean);\n        const nums = parts.map(p => Number(p)).filter(n => !Number.isNaN(n));\n        return nums.length === 0 ? null : nums;\n      }\n\n      function generateRandom(sz) {\n        array = [];\n        // generate random numbers between 5 and 95\n        for (let k = 0; k < sz; k++) {\n          array.push(5 + Math.round(Math.random() * 90));\n        }\n      }\n\n      function resetState() {\n        isPlaying = false;\n        clearInterval(timer);\n        timer = null;\n        speed = parseInt(speedRange.value, 10);\n        comparisons = 0;\n        swaps = 0;\n        pass = 0;\n        i = 0;\n        j = 0;\n        n = array.length;\n        sortedUntil = n;\n        updateStats();\n        statusText.textContent = 'Ready';\n        playBtn.textContent = 'Play';\n        clearPseudocodeHighlight();\n      }\n\n      function updateStats() {\n        compCountEl.textContent = comparisons;\n        swapCountEl.textContent = swaps;\n        passCountEl.textContent = pass;\n        sizeLabel.textContent = n;\n      }\n\n      // Rendering bars\n      function render() {\n        barsEl.innerHTML = '';\n        // compute bar width based on container width and n, respecting minimum spacing 16px\n        const containerRect = barsEl.getBoundingClientRect();\n        const maxWidth = containerRect.width || (window.innerWidth - 2 * 24 - 360);\n        // fallback width if 0\n        const gap = 12;\n        let barWidth = Math.max(36, Math.min(72, Math.floor((maxWidth - (n - 1) * gap) / n)));\n        // create bar elements, absolutely positioned\n        positions = [];\n        for (let idx = 0; idx < array.length; idx++) {\n          const el = document.createElement('div');\n          el.className = 'bar';\n          el.setAttribute('role', 'listitem');\n          el.setAttribute('aria-label', `Value ${array[idx]}`);\n          el.style.width = barWidth + 'px';\n          // height relative to value (scale to container height)\n          const minVal = 0;\n          const maxVal = 100;\n          const hPct = Math.max(8, Math.min(100, Math.round((array[idx] - minVal) / (maxVal - minVal) * 100)));\n          el.style.height = Math.max(36, Math.round((hPct / 100) * (barsEl.clientHeight - 36))) + 'px';\n          el.dataset.index = idx;\n          const label = document.createElement('div');\n          label.className = 'label';\n          label.textContent = array[idx];\n          el.appendChild(label);\n\n          barsEl.appendChild(el);\n        }\n        recalcPositions();\n        // mark sorted region (initially none)\n        markSortedFrom(sortedUntil);\n      }\n\n      function recalcPositions() {\n        const barEls = Array.from(barsEl.children);\n        if (barEls.length === 0) return;\n        const containerWidth = barsEl.clientWidth;\n        const gap = 12;\n        const barWidth = parseInt(barEls[0].style.width, 10);\n        const totalW = barEls.length * barWidth + (barEls.length - 1) * gap;\n        const startX = Math.max(12, (containerWidth - totalW) / 2);\n        positions = [];\n        barEls.forEach((el, idx) => {\n          const left = startX + idx * (barWidth + gap);\n          positions.push(left);\n          el.style.left = left + 'px';\n        });\n      }\n\n      // Helpers to highlight pseudocode\n      function clearPseudocodeHighlight() {\n        const lines = pseudocode.querySelectorAll('.line');\n        lines.forEach(l => l.classList.remove('active'));\n      }\n      function highlightPseudo(lineNum) {\n        clearPseudocodeHighlight();\n        const node = pseudocode.querySelector('.line[data-line=\"' + lineNum + '\"]');\n        if (node) node.classList.add('active');\n      }\n\n      // Mark sorted region visually\n      function markSortedFrom(startIdx) {\n        const barEls = Array.from(barsEl.children);\n        for (let k = 0; k < barEls.length; k++) {\n          const el = barEls[k];\n          el.classList.remove('sorted', 'dim', 'compare', 'swap');\n          if (k >= startIdx) {\n            el.classList.add('sorted');\n            el.setAttribute('aria-label', `Value ${array[k]} (sorted)`);\n          }\n        }\n      }\n\n      // Core step function: one comparison, possibly a swap\n      async function step() {\n        if (array.length < 2) return;\n        if (i >= n - 1) {\n          // finished\n          statusText.textContent = 'Sorted';\n          markSortedFrom(0);\n          clearPseudocodeHighlight();\n          return;\n        }\n\n        // highlight pseudocode lines\n        highlightPseudo(1); // outer for\n        highlightPseudo(2); // inner for\n\n        // If j exceeds inner bound, finish pass\n        if (j > n - 2 - i) {\n          // End of inner loop: last element in this pass becomes sorted\n          sortedUntil = n - 1 - i;\n          markSortedFrom(sortedUntil);\n          j = 0;\n          i++;\n          pass++;\n          updateStats();\n          statusText.textContent = `Completed pass ${pass}`;\n          // Slight pause to show completed pass\n          await delay(Math.max(80, speed / 4));\n          // continue to next step automatically if playing, else return\n          checkFinish();\n          return;\n        }\n\n        // Compare array[j] and array[j+1]\n        highlightPseudo(3);\n        comparisons++;\n        updateStats();\n        statusText.textContent = `Comparing indices ${j} and ${j + 1}`;\n        const barEls = Array.from(barsEl.children);\n        const aEl = barEls[j];\n        const bEl = barEls[j + 1];\n        // set compare visual\n        clearVisualStates();\n        if (aEl) aEl.classList.add('compare');\n        if (bEl) bEl.classList.add('compare');\n\n        // Wait a short moment to let user see comparison\n        await delay(Math.max(120, speed / 6));\n\n        if (array[j] > array[j + 1]) {\n          // Swap\n          highlightPseudo(4);\n          swaps++;\n          updateStats();\n          statusText.textContent = `Swapping ${array[j]} ↔ ${array[j + 1]}`;\n          if (aEl) { aEl.classList.remove('compare'); aEl.classList.add('swap'); }\n          if (bEl) { bEl.classList.remove('compare'); bEl.classList.add('swap'); }\n          await animateSwap(j, j + 1);\n          // swap data\n          const tmp = array[j];\n          array[j] = array[j + 1];\n          array[j + 1] = tmp;\n          // also swap DOM order: after animation, reorder elements to match indices\n          reorderDOMElements();\n        } else {\n          statusText.textContent = `No swap needed`;\n        }\n\n        // move to next index\n        j++;\n        highlightPseudo(2);\n        // update sorted region subtly\n        markSortedFrom(sortedUntil);\n        checkFinish();\n      }\n\n      // Check if sort finished\n      function checkFinish() {\n        if (i >= n - 1) {\n          statusText.textContent = 'Sorted';\n          highlightPseudo(5);\n          markSortedFrom(0);\n          isPlaying = false;\n          clearInterval(timer);\n          playBtn.textContent = 'Play';\n        }\n      }\n\n      function clearVisualStates() {\n        const barEls = Array.from(barsEl.children);\n        barEls.forEach(el => {\n          el.classList.remove('compare', 'swap', 'dim');\n        });\n      }\n\n      // Animate swapping two bars (by indices)\n      async function animateSwap(idxA, idxB) {\n        const barEls = Array.from(barsEl.children);\n        const aEl = barEls[idxA];\n        const bEl = barEls[idxB];\n        if (!aEl || !bEl) return;\n\n        // Calculate translation distances based on current left positions\n        const leftA = parseFloat(aEl.style.left);\n        const leftB = parseFloat(bEl.style.left);\n        const delta = leftB - leftA;\n\n        // Apply translate to animate swap visually\n        aEl.style.transform = `translateX(${delta}px) scale(1.02)`;\n        bEl.style.transform = `translateX(${-delta}px) scale(1.02)`;\n\n        // Wait for transition to end\n        await Promise.all([waitTransition(aEl), waitTransition(bEl)]);\n\n        // Reset transforms (but swap their left positions to reflect final layout)\n        aEl.style.transform = '';\n        bEl.style.transform = '';\n\n        // Swap left positions (so subsequent layout is consistent)\n        const tmpLeft = aEl.style.left;\n        aEl.style.left = bEl.style.left;\n        bEl.style.left = tmpLeft;\n\n        // Update dataset indices to reflect their visual positions (not strictly necessary)\n      }\n\n      // After animations, reorder DOM nodes to match logical array order\n      function reorderDOMElements() {\n        // Recreate DOM order to match logical array\n        const nodes = Array.from(barsEl.children);\n        // Sort nodes by their left position numerically\n        nodes.sort((x, y) => parseFloat(x.style.left) - parseFloat(y.style.left));\n        // Re-append in order\n        nodes.forEach(n => barsEl.appendChild(n));\n        // Update label values to match array values (for consistency)\n        const children = Array.from(barsEl.children);\n        for (let k = 0; k < children.length; k++) {\n          const lbl = children[k].querySelector('.label');\n          if (lbl) lbl.textContent = array[k];\n        }\n      }\n\n      // Utility: wait for transition end on element or fallback delay\n      function waitTransition(el) {\n        return new Promise(resolve => {\n          let invoked = false;\n          function done() {\n            if (invoked) return;\n            invoked = true;\n            el.removeEventListener('transitionend', onEnd);\n            resolve();\n          }\n          function onEnd(e) {\n            // only consider transform/left transitions\n            if (e.propertyName === 'transform' || e.propertyName === 'left') done();\n          }\n          el.addEventListener('transitionend', onEnd);\n          // safety timeout\n          setTimeout(done, Math.max(200, speed + 120));\n        });\n      }\n\n      function delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n      }\n\n      // Play/pause logic\n      function togglePlay() {\n        if (isPlaying) {\n          isPlaying = false;\n          clearInterval(timer);\n          timer = null;\n          playBtn.textContent = 'Play';\n          statusText.textContent = 'Paused';\n        } else {\n          // if finished, restart?\n          if (i >= n - 1) {\n            resetState();\n            render();\n          }\n          isPlaying = true;\n          startAutoPlay();\n          playBtn.textContent = 'Pause';\n          statusText.textContent = 'Playing';\n        }\n      }\n\n      function startAutoPlay() {\n        clearInterval(timer);\n        const interval = Math.max(60, speed); // ms between steps\n        timer = setInterval(async () => {\n          // Pause interval while a swap animation is in progress by ensuring animateSwap awaits\n          // Call step; if step performs async operations, subsequent interval ticks might overlap, so disable while busy.\n          if (isBusy) return;\n          isBusy = true;\n          await step();\n          isBusy = false;\n        }, Math.max(60, Math.floor(speed)));\n      }\n\n      // ensure we don't run overlapping steps\n      let isBusy = false;\n\n      // Provide a graceful reset function\n      function resetArrayTo(arrayValues) {\n        array = arrayValues.slice();\n        n = array.length;\n        sizeRange.value = n;\n        sizeLabel.textContent = n;\n        resetState();\n        render();\n      }\n\n      // Initial render\n      init();\n\n      // Expose some functions to console for quick testing (optional)\n      window._bubble = {\n        get array() { return array.slice(); },\n        step: step,\n        play: togglePlay,\n        reset: () => { resetState(); render(); },\n        setArray: resetArrayTo\n      };\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Bubble Sort.\n\n**Project Overview:**\nTopic: Bubble Sort\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Bubble Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "a8e82d30-bdd4-11f0-bd8d-55214871deb0",
    "timestamp": "2025-11-10T01:30:07.981Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Stack",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Stack Module</title>\n  <style>\n    /* Safe area margins: 24px on all sides */\n    :root {\n      --safe-margin: 24px;\n      --gap: 16px; /* minimum spacing between interactive elements */\n      --stack-width: 220px;\n      --card-height: 48px;\n      --card-gap: 8px;\n      --accent: #0b76ef;\n      --muted: #6b6b6b;\n      --bg: #f7f9fc;\n      --card-bg: #ffffff;\n      --danger: #e44;\n    }\n\n    html,body {\n      height: 100%;\n      margin: 0;\n      background: linear-gradient(180deg,#f9fbff 0%, #f7f9fc 100%);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      color: #111827;\n    }\n\n    .container {\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height: 100%;\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n    }\n\n    header {\n      display: flex;\n      gap: var(--gap);\n      align-items: center;\n      justify-content: space-between;\n      flex-wrap: wrap;\n    }\n\n    .title {\n      font-size: 20px;\n      font-weight: 700;\n      display: flex;\n      flex-direction: column;\n      gap: 4px;\n    }\n\n    .subtitle {\n      font-size: 13px;\n      color: var(--muted);\n    }\n\n    main {\n      display: grid;\n      grid-template-columns: 1fr 360px;\n      gap: 24px;\n      align-items: start;\n    }\n\n    /* Responsive: single column on narrow screens */\n    @media (max-width: 880px) {\n      main {\n        grid-template-columns: 1fr;\n      }\n    }\n\n    /* Left panel: explanation and controls */\n    .panel {\n      background: var(--card-bg);\n      border-radius: 12px;\n      padding: 18px;\n      box-shadow: 0 1px 4px rgba(16,24,40,0.04), 0 6px 20px rgba(16,24,40,0.06);\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n    }\n\n    .section-title {\n      font-weight: 600;\n      font-size: 14px;\n      color: #0f172a;\n    }\n\n    .text {\n      color: #374151;\n      font-size: 13px;\n      line-height: 1.45;\n    }\n\n    .controls {\n      display: flex;\n      gap: var(--gap);\n      align-items: center;\n      flex-wrap: wrap;\n    }\n\n    .input {\n      display: flex;\n      gap: 8px;\n      align-items: center;\n    }\n\n    input[type=\"text\"], input[type=\"number\"] {\n      padding: 10px 12px;\n      border: 1px solid #e6e9ee;\n      border-radius: 8px;\n      font-size: 14px;\n      outline: none;\n      min-width: 160px;\n    }\n\n    input[type=\"number\"] {\n      width: 120px;\n    }\n\n    input:focus {\n      box-shadow: 0 0 0 3px rgba(11,118,239,0.12);\n      border-color: var(--accent);\n    }\n\n    button {\n      background: var(--accent);\n      color: white;\n      border: none;\n      padding: 10px 14px;\n      border-radius: 8px;\n      font-weight: 600;\n      cursor: pointer;\n      font-size: 14px;\n    }\n\n    button.secondary {\n      background: #f3f4f6;\n      color: #111827;\n      border: 1px solid #e6e9ee;\n    }\n\n    button.warn {\n      background: #fff5f5;\n      color: var(--danger);\n      border: 1px solid rgba(228,68,68,0.12);\n    }\n\n    .controls > * { margin: 0; }\n\n    /* Right panel: visualization */\n    .viz {\n      background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.85));\n      border-radius: 12px;\n      padding: 18px;\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n      align-items: center;\n      min-height: 220px;\n      width: 100%;\n      box-sizing: border-box;\n    }\n\n    .stack-frame {\n      width: var(--stack-width);\n      min-height: calc(var(--card-height) * 3 + var(--card-gap) * 2 + 20px);\n      background: linear-gradient(180deg,#fbfdff,#ffffff);\n      border-radius: 10px;\n      border: 1px solid #e6edf9;\n      padding: 12px;\n      display: flex;\n      flex-direction: column;\n      gap: var(--card-gap);\n      align-items: center;\n      position: relative;\n      box-shadow: 0 2px 8px rgba(17,24,39,0.02);\n    }\n\n    .stack-label {\n      position: absolute;\n      top: -12px;\n      left: 12px;\n      background: white;\n      padding: 2px 8px;\n      border-radius: 6px;\n      font-size: 12px;\n      color: var(--muted);\n      border: 1px solid #eef4ff;\n    }\n\n    /* The actual stack area (cards are appended here) */\n    .stack-area {\n      display: flex;\n      flex-direction: column; /* top is index 0 */\n      gap: var(--card-gap);\n      width: 100%;\n      align-items: center;\n      min-height: 48px;\n      padding-top: 6px;\n      box-sizing: border-box;\n    }\n\n    .stack-card {\n      width: calc(100% - 28px);\n      height: var(--card-height);\n      background: linear-gradient(180deg,#ffffff,#fbfbff);\n      border: 1px solid #e6e9ee;\n      border-radius: 8px;\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n      padding: 0 12px;\n      box-sizing: border-box;\n      font-weight: 600;\n      color: #0b1220;\n      box-shadow: 0 1px 0 rgba(2,6,23,0.04);\n      transform-origin: center;\n    }\n\n    .stack-card .index {\n      font-size: 12px;\n      color: var(--muted);\n      font-weight: 600;\n      opacity: 0.9;\n    }\n\n    .top-indicator {\n      position: absolute;\n      right: -36px;\n      top: 28px; /* initial, will be updated by JS to match top card */\n      width: 28px;\n      height: 28px;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      border-radius: 8px;\n      background: linear-gradient(180deg, #ffffff, #f3f8ff);\n      border: 1px solid #e4f0ff;\n      font-size: 12px;\n      color: var(--accent);\n      box-shadow: 0 2px 6px rgba(11,118,239,0.08);\n      transition: top 300ms cubic-bezier(.2,.9,.2,1);\n    }\n\n    .empty-hint {\n      color: var(--muted);\n      font-size: 13px;\n      padding: 18px 6px;\n    }\n\n    /* History trace area */\n    .trace {\n      width: 100%;\n      background: #f8fafc;\n      border: 1px solid #eef3fa;\n      padding: 10px;\n      border-radius: 8px;\n      font-size: 13px;\n      color: #374151;\n      min-height: 80px;\n      overflow: auto;\n    }\n\n    .trace-entry {\n      margin: 6px 0;\n      font-size: 13px;\n    }\n\n    .status {\n      font-size: 13px;\n      color: #111827;\n      display: flex;\n      gap: 8px;\n      align-items: center;\n    }\n\n    .announce {\n      position: absolute;\n      left: -9999px;\n      width: 1px;\n      height: 1px;\n      overflow: hidden;\n    }\n\n    /* Animations */\n    .animate-in {\n      transform: translateX(40px) translateY(-8px) scale(0.98);\n      opacity: 0;\n      transition: transform 380ms cubic-bezier(.2,.9,.2,1), opacity 300ms ease;\n    }\n\n    .animate-in.visible {\n      transform: translateX(0) translateY(0) scale(1);\n      opacity: 1;\n    }\n\n    .animate-out {\n      transform: translateX(0);\n      opacity: 1;\n      transition: transform 340ms cubic-bezier(.25,.8,.25,1), opacity 260ms ease;\n    }\n\n    .animate-out.hidden {\n      transform: translateX(40px);\n      opacity: 0;\n    }\n\n    .pulse {\n      animation: pulse 900ms ease;\n    }\n\n    @keyframes pulse {\n      0% { box-shadow: 0 0 0 0 rgba(11,118,239,0.18); }\n      70% { box-shadow: 0 0 0 8px rgba(11,118,239,0.02); }\n      100% { box-shadow: 0 0 0 0 rgba(11,118,239,0); }\n    }\n\n    .warning {\n      color: var(--danger);\n      font-weight: 700;\n    }\n\n    /* control footer for small screens */\n    .controls-row {\n      display: flex;\n      gap: var(--gap);\n      align-items: center;\n      flex-wrap: wrap;\n    }\n\n    /* accessibility focus outlines */\n    button:focus, input:focus {\n      outline: 3px solid rgba(11,118,239,0.12);\n      outline-offset: 2px;\n    }\n\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <header>\n      <div class=\"title\" aria-hidden=\"false\">\n        <div>Stack — LIFO Data Structure (Interactive)</div>\n        <div class=\"subtitle\">Push, Pop, Peek, and Visualize Top / Underflow / Overflow</div>\n      </div>\n      <div style=\"font-size:13px;color:var(--muted);\">Accessible. Responsive. Vanilla HTML/CSS/JS.</div>\n    </header>\n\n    <!-- Descriptive panel and interactive module are both included in main -->\n    <main>\n      <!-- Left: Explanations + Controls -->\n      <section class=\"panel\" aria-labelledby=\"concept-title\">\n        <div>\n          <div id=\"concept-title\" class=\"section-title\">Concept Title</div>\n          <p class=\"text\" style=\"margin-top:8px;\">\n            Stack — a linear data structure that follows Last-In, First-Out (LIFO). Elements are added and removed from the \"top\" of the stack.\n          </p>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Learning Objective</div>\n          <p class=\"text\" style=\"margin-top:8px;\">\n            After interacting with this module you will be able to:\n            identify the top of a stack, perform push and pop operations, recognize underflow and overflow, and observe how operations affect the stack visually and as a sequence of steps.\n          </p>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Interaction Design</div>\n          <p class=\"text\" style=\"margin-top:8px;\">\n            Use the input to push values onto the stack (type then press Enter or click \"Push\"). Click \"Pop\" to remove the top value. \"Peek\" highlights the top without removing it. Adjust capacity to see overflow behavior. Visual animations show items entering (slide+fade) and leaving (slide out). An action trace describes each operation. All controls are keyboard-accessible.\n          </p>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Layout Description</div>\n          <p class=\"text\" style=\"margin-top:8px;\">\n            Left panel (this area) contains explanatory text and interactive controls. Right panel contains the visual stack, a top indicator, and an operation trace. The page uses 24px safe margins and at least 16px spacing between interactive elements. The design is responsive: on narrow screens the visualization stacks below the controls. Visual feedback includes animated transitions for push/pop, a pulsing peek highlight, and aria-live announcements for assistive tech.\n          </p>\n        </div>\n\n        <!-- Controls -->\n        <div>\n          <div class=\"section-title\" style=\"margin-bottom:8px;\">Controls</div>\n\n          <form id=\"controlsForm\" class=\"controls\" onsubmit=\"return false;\" aria-label=\"Stack controls\">\n            <div class=\"input\" style=\"min-width:0;\">\n              <label for=\"valueInput\" style=\"display:none;\">Value</label>\n              <input id=\"valueInput\" type=\"text\" placeholder=\"Value to push (e.g. 42 or 'A')\" aria-label=\"Value to push\" />\n              <button id=\"pushBtn\" type=\"button\">Push</button>\n            </div>\n\n            <div class=\"controls-row\">\n              <button id=\"popBtn\" type=\"button\" class=\"secondary\">Pop</button>\n              <button id=\"peekBtn\" type=\"button\" class=\"secondary\">Peek</button>\n              <button id=\"clearBtn\" type=\"button\" class=\"warn\">Clear</button>\n            </div>\n\n            <div style=\"display:flex; align-items:center; gap:12px;\">\n              <label for=\"capacity\" style=\"font-size:13px;color:var(--muted);\">Capacity</label>\n              <input id=\"capacity\" type=\"number\" min=\"1\" max=\"20\" value=\"6\" aria-label=\"Stack capacity\" />\n            </div>\n          </form>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Tips</div>\n          <ul class=\"text\" style=\"margin-top:8px; margin-left:16px;\">\n            <li>Press Enter in the input to push faster.</li>\n            <li>Observe the top indicator and trace log to understand LIFO ordering.</li>\n            <li>Try to push more than capacity to trigger overflow; pop from empty to see underflow handling.</li>\n          </ul>\n        </div>\n      </section>\n\n      <!-- Right: Visualization -->\n      <aside class=\"viz\" aria-live=\"polite\" aria-atomic=\"true\">\n        <div style=\"display:flex; width:100%; justify-content:space-between; align-items:center;\">\n          <div style=\"display:flex; flex-direction:column;\">\n            <div style=\"font-weight:700;\">Stack Visualization</div>\n            <div style=\"font-size:13px; color:var(--muted);\">Top is indicated on the right</div>\n          </div>\n          <div class=\"status\" aria-hidden=\"true\">\n            <div style=\"font-size:13px;color:var(--muted);\">Size:</div>\n            <div id=\"sizeBadge\" style=\"font-weight:700;padding:6px 10px;border-radius:8px;background:#f3f7ff;border:1px solid #e6f0ff;\">0</div>\n          </div>\n        </div>\n\n        <div class=\"stack-frame\" role=\"region\" aria-label=\"Stack frame\">\n          <div class=\"stack-label\">Stack</div>\n          <div id=\"topIndicator\" class=\"top-indicator\" aria-hidden=\"true\">TOP</div>\n          <div id=\"stackArea\" class=\"stack-area\" aria-live=\"polite\" aria-atomic=\"false\">\n            <div id=\"emptyHint\" class=\"empty-hint\">Stack is empty. Push an item to begin.</div>\n          </div>\n        </div>\n\n        <div style=\"width:100%;\">\n          <div class=\"section-title\" style=\"margin-bottom:8px;\">Operation Trace</div>\n          <div id=\"trace\" class=\"trace\" role=\"log\" aria-live=\"polite\"></div>\n        </div>\n\n        <div style=\"width:100%; display:flex; justify-content:space-between; gap:12px;\">\n          <div style=\"font-size:13px;color:var(--muted);\">Announcements for screen readers:</div>\n          <div id=\"ariaAnnouncer\" class=\"announce\" aria-live=\"assertive\"></div>\n        </div>\n      </aside>\n    </main>\n  </div>\n\n  <script>\n    // Self-contained Stack module implementation (vanilla JS)\n    (function () {\n      // DOM references\n      const valueInput = document.getElementById('valueInput');\n      const pushBtn = document.getElementById('pushBtn');\n      const popBtn = document.getElementById('popBtn');\n      const peekBtn = document.getElementById('peekBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const capacityInput = document.getElementById('capacity');\n      const stackArea = document.getElementById('stackArea');\n      const emptyHint = document.getElementById('emptyHint');\n      const trace = document.getElementById('trace');\n      const sizeBadge = document.getElementById('sizeBadge');\n      const topIndicator = document.getElementById('topIndicator');\n      const ariaAnnouncer = document.getElementById('ariaAnnouncer');\n\n      // Internal stack representation\n      let stack = [];\n      const nodeElements = []; // parallel array of DOM elements\n      let capacity = Math.max(1, parseInt(capacityInput.value) || 6);\n\n      // Helpers for announcements and trace\n      function announce(text) {\n        // Use both visual trace and aria-live region\n        const entry = document.createElement('div');\n        entry.className = 'trace-entry';\n        entry.textContent = text;\n        trace.prepend(entry);\n        // Limit trace length\n        if (trace.childElementCount > 50) {\n          trace.removeChild(trace.lastChild);\n        }\n        ariaAnnouncer.textContent = text;\n      }\n\n      function updateSizeBadge() {\n        sizeBadge.textContent = stack.length;\n      }\n\n      function updateTopIndicatorPosition() {\n        // Position the topIndicator next to the top card if any\n        if (nodeElements.length === 0) {\n          topIndicator.style.top = '28px';\n          topIndicator.style.opacity = '0.3';\n          topIndicator.setAttribute('aria-hidden', 'true');\n        } else {\n          const topEl = nodeElements[0];\n          // compute relative position of topEl within stackFrame\n          const frame = topEl.closest('.stack-frame') || topEl.parentElement;\n          // We'll compute top offset relative to frame\n          // Use getBoundingClientRect for accuracy\n          const frameRect = frame.getBoundingClientRect();\n          const topRect = topEl.getBoundingClientRect();\n          const offset = topRect.top - frameRect.top;\n          // Place center-ish\n          const center = offset + (topRect.height / 2) - 14; // 14 = half of indicator height\n          topIndicator.style.top = Math.max(12, center) + 'px';\n          topIndicator.style.opacity = '1';\n          topIndicator.removeAttribute('aria-hidden');\n        }\n      }\n\n      // Create a card DOM element for a value\n      function createCard(value, index) {\n        const el = document.createElement('div');\n        el.className = 'stack-card animate-in';\n        el.setAttribute('role', 'listitem');\n        el.setAttribute('tabindex', '0');\n        el.innerHTML = '<div class=\"label\">' + String(value) + '</div>' +\n                       '<div class=\"index\">idx ' + index + '</div>';\n        return el;\n      }\n\n      // Push operation with animation\n      function push(value) {\n        if (stack.length >= capacity) {\n          announce('Overflow: cannot push, capacity is ' + capacity + '.');\n          flashCapacityWarning();\n          return;\n        }\n\n        // Update internal model\n        stack.unshift(value); // top is at index 0\n        // Create element and insert at top of stackArea\n        const card = createCard(value, 0);\n        // Hide empty hint if present\n        if (emptyHint && emptyHint.parentElement) {\n          emptyHint.remove();\n        }\n\n        // Prepend card to DOM\n        if (stackArea.firstChild) {\n          stackArea.insertBefore(card, stackArea.firstChild);\n        } else {\n          stackArea.appendChild(card);\n        }\n        nodeElements.unshift(card);\n\n        // Force reflow then add visible class to animate in\n        // Use requestAnimationFrame to ensure transition\n        requestAnimationFrame(() => {\n          card.classList.add('visible');\n        });\n\n        // After animation, normalize indexes shown on cards\n        setTimeout(() => {\n          normalizeIndexes();\n        }, 380);\n\n        // Update UI\n        updateSizeBadge();\n        updateTopIndicatorPosition();\n        announce('Pushed \"' + String(value) + '\" onto stack. Size: ' + stack.length + '.');\n        // Add focus/keyboard affordance\n        card.addEventListener('keydown', (e) => {\n          if (e.key === 'Enter' || e.key === ' ') {\n            // When Enter or Space pressed on card, peek it\n            highlightTop();\n          }\n        });\n      }\n\n      // Pop operation with animation\n      function pop() {\n        if (stack.length === 0) {\n          announce('Underflow: cannot pop from an empty stack.');\n          flashUnderflow();\n          return;\n        }\n\n        // Remove from model and animate top card out\n        const poppedValue = stack.shift();\n        const card = nodeElements.shift();\n\n        // Animate out to the right\n        card.classList.remove('visible');\n        card.classList.add('animate-out');\n\n        // force reflow then hide\n        requestAnimationFrame(() => {\n          card.classList.add('hidden');\n        });\n\n        // After animation, remove element\n        setTimeout(() => {\n          if (card && card.parentElement) {\n            card.parentElement.removeChild(card);\n          }\n          normalizeIndexes();\n          updateSizeBadge();\n          updateTopIndicatorPosition();\n        }, 380);\n\n        announce('Popped \"' + String(poppedValue) + '\". Size: ' + stack.length + '.');\n      }\n\n      // Peek: highlight top without removing\n      function peek() {\n        if (stack.length === 0) {\n          announce('Peek: stack is empty.');\n          flashUnderflow();\n          return;\n        }\n        const topValue = stack[0];\n        announce('Peek: top is \"' + String(topValue) + '\".');\n        highlightTop();\n      }\n\n      // Highlight top card with a pulse\n      function highlightTop() {\n        if (nodeElements.length === 0) return;\n        const topCard = nodeElements[0];\n        topCard.classList.add('pulse');\n        setTimeout(() => {\n          topCard.classList.remove('pulse');\n        }, 900);\n      }\n\n      // Clear the stack\n      function clearStack() {\n        if (stack.length === 0) {\n          announce('Stack is already empty.');\n          return;\n        }\n        // Animate out all cards, stagger slightly\n        const elements = nodeElements.slice();\n        nodeElements.length = 0;\n        stack.length = 0;\n\n        elements.forEach((card, idx) => {\n          setTimeout(() => {\n            card.classList.add('animate-out', 'hidden');\n            if (card.parentElement) {\n              card.parentElement.removeChild(card);\n            }\n            if (idx === elements.length - 1) {\n              // restore empty hint\n              stackArea.appendChild(emptyHint);\n              updateSizeBadge();\n              updateTopIndicatorPosition();\n              announce('Cleared stack.');\n            }\n          }, idx * 50);\n        });\n      }\n\n      function normalizeIndexes() {\n        // Update index labels on the cards to reflect current index\n        for (let i = 0; i < nodeElements.length; i++) {\n          const el = nodeElements[i];\n          const idxLabel = el.querySelector('.index');\n          if (idxLabel) {\n            idxLabel.textContent = 'idx ' + i;\n          }\n        }\n      }\n\n      // Visual warnings\n      function flashUnderflow() {\n        // briefly flash topIndicator and announce\n        topIndicator.style.background = '#fff5f5';\n        topIndicator.style.borderColor = 'rgba(228,68,68,0.16)';\n        topIndicator.style.color = 'var(--danger)';\n        setTimeout(() => {\n          topIndicator.style.background = '';\n          topIndicator.style.borderColor = '';\n          topIndicator.style.color = '';\n        }, 600);\n      }\n\n      function flashCapacityWarning() {\n        // briefly flash capacity input\n        capacityInput.style.boxShadow = '0 0 0 6px rgba(228,68,68,0.06)';\n        capacityInput.style.borderColor = 'rgba(228,68,68,0.5)';\n        setTimeout(() => {\n          capacityInput.style.boxShadow = '';\n          capacityInput.style.borderColor = '';\n        }, 700);\n      }\n\n      // Event handlers\n      pushBtn.addEventListener('click', () => {\n        const val = valueInput.value.trim();\n        if (val === '') {\n          // Do not push empty — but allow \"0\" or \"false\", so check trimmed length only\n          announce('Enter a non-empty value to push.');\n          valueInput.focus();\n          return;\n        }\n        push(val);\n        valueInput.value = '';\n        valueInput.focus();\n      });\n\n      valueInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          e.preventDefault();\n          pushBtn.click();\n        }\n      });\n\n      popBtn.addEventListener('click', () => {\n        pop();\n      });\n\n      peekBtn.addEventListener('click', () => {\n        peek();\n      });\n\n      clearBtn.addEventListener('click', () => {\n        if (confirm('Clear the entire stack?')) {\n          clearStack();\n        }\n      });\n\n      capacityInput.addEventListener('change', () => {\n        const newCap = Math.max(1, Math.min(20, parseInt(capacityInput.value) || 6));\n        capacityInput.value = newCap;\n        capacity = newCap;\n        announce('Capacity set to ' + capacity + '.');\n        // If current size exceeds new capacity, visually indicate overflow and suggest clearing\n        if (stack.length > capacity) {\n          announce('Note: current size exceeds capacity. You may pop items to fit within capacity.');\n          flashCapacityWarning();\n        }\n      });\n\n      // keyboard shortcuts: Alt+P push focus, Alt+O pop\n      document.addEventListener('keydown', (e) => {\n        if (e.altKey && !e.shiftKey && !e.ctrlKey) {\n          if (e.key.toLowerCase() === 'p') {\n            e.preventDefault();\n            valueInput.focus();\n          } else if (e.key.toLowerCase() === 'o') {\n            e.preventDefault();\n            popBtn.focus();\n            pop();\n          } else if (e.key.toLowerCase() === 'k') {\n            e.preventDefault();\n            peek();\n          }\n        }\n      });\n\n      // Initial UI setup\n      updateSizeBadge();\n      updateTopIndicatorPosition();\n\n      // A11y: ensure trace region is initially described\n      announce('Stack module ready. Capacity is ' + capacity + '. Use the input to push values.');\n\n      // Expose simple API for potential testing (optional)\n      window._stackModule = {\n        push: (v) => push(String(v)),\n        pop: pop,\n        peek: peek,\n        clear: clearStack,\n        getStack: () => stack.slice()\n      };\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Stack.\n\n**Project Overview:**\nTopic: Stack\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Stack"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Stack Module",
      "description": "Models the interactive states of a visual stack UI supporting push, pop, peek, clear, capacity changes, and keyboard shortcuts with animations and accessibility announcements.",
      "states": [
        {
          "name": "idle",
          "onEnter": "updateUI",
          "onExit": "noop",
          "on": {
            "PUSH_SUBMIT": "pushing",
            "PUSH_EMPTY": "invalidInput",
            "PUSH_OVERFLOW": "overflow",
            "POP_CLICK_VALID": "popping",
            "POP_CLICK_EMPTY": "underflow",
            "PEEK_CLICK_VALID": "peeking",
            "PEEK_CLICK_EMPTY": "underflow",
            "CLEAR_CLICK": "awaitingConfirmation",
            "CAPACITY_CHANGE": "capacityUpdating",
            "ALT_P_FOCUS": "idle",
            "ALT_O_POP_VALID": "popping",
            "ALT_O_POP_EMPTY": "underflow",
            "ALT_K_PEEK_VALID": "peeking",
            "ALT_K_PEEK_EMPTY": "underflow",
            "INPUT_CHANGE": "idle",
            "INVALID_ACK": "idle"
          }
        },
        {
          "name": "invalidInput",
          "onEnter": "announceEnterNonEmpty",
          "onExit": "noop",
          "on": {
            "INPUT_CHANGE": "idle",
            "ACK": "idle",
            "FOCUS_INPUT": "idle"
          }
        },
        {
          "name": "pushing",
          "onEnter": "pushValue; animateIn; updateSizeBadge; updateTopIndicatorPosition; announcePush",
          "onExit": "normalizeIndexes",
          "on": {
            "ANIMATION_END_PUSH": "idle",
            "CANCEL": "idle",
            "PUSH_INTERRUPTED": "idle"
          }
        },
        {
          "name": "popping",
          "onEnter": "animateOutTop; removeTopFromModel; updateSizeBadge; updateTopIndicatorPosition; announcePop",
          "onExit": "noop",
          "on": {
            "ANIMATION_END_POP": "idle",
            "CANCEL": "idle",
            "POP_INTERRUPTED": "idle"
          }
        },
        {
          "name": "peeking",
          "onEnter": "announcePeek; highlightTop",
          "onExit": "noop",
          "on": {
            "HIGHLIGHT_END": "idle",
            "CANCEL": "idle"
          }
        },
        {
          "name": "awaitingConfirmation",
          "onEnter": "showConfirmDialog",
          "onExit": "hideConfirmDialog",
          "on": {
            "CLEAR_CONFIRM": "clearing",
            "CLEAR_CANCEL": "idle",
            "ESCAPE": "idle"
          }
        },
        {
          "name": "clearing",
          "onEnter": "clearAllCards; animateOutAll; updateSizeBadge; updateTopIndicatorPosition; announceClear",
          "onExit": "noop",
          "on": {
            "CLEAR_COMPLETE": "idle"
          }
        },
        {
          "name": "capacityUpdating",
          "onEnter": "applyCapacityChange; announceCapacity; flashIfExceeded",
          "onExit": "noop",
          "on": {
            "CAPACITY_APPLIED": "idle"
          }
        },
        {
          "name": "overflow",
          "onEnter": "announceOverflow; flashCapacityWarning",
          "onExit": "noop",
          "on": {
            "ACK": "idle",
            "POP_CLICK_VALID": "popping",
            "CLEAR_CLICK": "awaitingConfirmation",
            "CAPACITY_CHANGE": "capacityUpdating"
          }
        },
        {
          "name": "underflow",
          "onEnter": "announceUnderflow; flashUnderflow",
          "onExit": "noop",
          "on": {
            "ACK": "idle",
            "CLEAR_CLICK": "awaitingConfirmation",
            "CAPACITY_CHANGE": "capacityUpdating"
          }
        }
      ],
      "events": [
        "PUSH_CLICK",
        "PUSH_SUBMIT",
        "PUSH_EMPTY",
        "PUSH_OVERFLOW",
        "ANIMATION_END_PUSH",
        "POP_CLICK",
        "POP_CLICK_VALID",
        "POP_CLICK_EMPTY",
        "ANIMATION_END_POP",
        "PEEK_CLICK",
        "PEEK_CLICK_VALID",
        "PEEK_CLICK_EMPTY",
        "HIGHLIGHT_END",
        "CLEAR_CLICK",
        "CLEAR_CONFIRM",
        "CLEAR_CANCEL",
        "CLEAR_COMPLETE",
        "CAPACITY_CHANGE",
        "CAPACITY_APPLIED",
        "ALT_P_FOCUS",
        "ALT_O_POP_VALID",
        "ALT_O_POP_EMPTY",
        "ALT_K_PEEK_VALID",
        "ALT_K_PEEK_EMPTY",
        "INPUT_CHANGE",
        "FOCUS_INPUT",
        "ACK",
        "INVALID_ACK",
        "CANCEL",
        "ESCAPE",
        "PUSH_INTERRUPTED",
        "POP_INTERRUPTED"
      ],
      "notes": "States model user-triggered operations and their animated lifecycles. 'pushing' and 'popping' represent transient animation+model-update phases that return to 'idle' on animation end. 'overflow' and 'underflow' are short-lived error feedback states that also allow recovery via ACK, capacity change, pop, or clear. 'awaitingConfirmation' models the browser confirm dialog before clearing. Keyboard shortcuts map to events that either focus input or invoke actions; those flows are represented as separate events for valid / empty conditions (e.g., POP_CLICK_VALID vs POP_CLICK_EMPTY). onEnter action strings describe the primary DOM/model side effects invoked in that state."
    }
  }
]