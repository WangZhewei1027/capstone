<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Heap (Min/Max) — Interactive Module</title>
  <style>
    /* SAFE AREA and BASE */
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #f6f8fb;
      --card: #ffffff;
      --accent: #2b6ef6;
      --accent-2: #0ea5a1;
      --muted: #6b7280;
      --node-size: 56px;
      --transition: 400ms cubic-bezier(.2,.8,.2,1);
    }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#eef2ff 0%,var(--bg) 100%);
      color:#0f172a;
    }
    .app {
      padding: var(--safe-margin);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    /* HEADER: Title + Objectives */
    header.module-head {
      display:flex;
      flex-wrap:wrap;
      gap: var(--gap);
      align-items:center;
      justify-content:space-between;
    }
    .title {
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width:220px;
    }
    .title h1{
      margin:0;
      font-size:20px;
      letter-spacing:-0.2px;
    }
    .subtitle {
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* MAIN LAYOUT: Left controls, Right visualization */
    .main {
      display:grid;
      grid-template-columns: 340px 1fr;
      gap: var(--gap);
      align-items:start;
    }
    @media (max-width:900px){
      .main { grid-template-columns: 1fr; }
    }

    /* CONTROLS CARD */
    .card {
      background:var(--card);
      border-radius:12px;
      padding:18px;
      box-shadow: 0 6px 20px rgba(16,24,40,0.06);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .section-title{
      font-weight:600;
      font-size:13px;
    }
    label{
      display:block;
      font-size:13px;
      color:var(--muted);
      margin-bottom:6px;
    }
    input[type="number"]{
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #e6edf7;
      background:#fbfdff;
      font-size:14px;
      box-sizing:border-box;
    }
    button{
      background:var(--accent);
      color:white;
      border:0;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      transition:transform 120ms ease;
    }
    button:active{ transform: translateY(1px); }
    .btn-ghost{
      background:transparent;
      color:var(--accent);
      border:1px solid rgba(43,110,246,0.12);
    }
    .row{
      display:flex;
      gap:12px;
      align-items:center;
    }

    /* Toggle switch */
    .switch {
      display:inline-flex;
      align-items:center;
      gap:10px;
    }
    .switch input{ display:none; }
    .switch .track{
      width:58px;
      height:32px;
      background:#eef2ff;
      border-radius:999px;
      padding:4px;
      display:inline-flex;
      align-items:center;
      transition:background var(--transition);
      box-sizing:content-box;
    }
    .switch .knob{
      width:24px;height:24px;border-radius:50%;
      background:white;box-shadow:0 2px 6px rgba(2,6,23,0.08);
      transform:translateX(0); transition:transform var(--transition);
    }
    .switch input:checked + .track { background: linear-gradient(90deg,var(--accent),#7dd3fc); }
    .switch input:checked + .track .knob { transform:translateX(26px); }

    /* Controls group spacing */
    .controls-grid{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .small {
      font-size:13px;color:var(--muted);
    }

    /* VISUALIZATION CARD */
    .viz {
      background:linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.6));
      border-radius:12px;
      padding:18px;
      min-height:420px;
      box-shadow: 0 6px 20px rgba(16,24,40,0.06);
      position:relative;
      overflow:hidden;
    }
    .viz-top {
      display:flex;
      align-items:center;
      gap:12px;
      justify-content:space-between;
      margin-bottom:8px;
    }
    .legend {
      display:flex;
      gap:10px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .legend .dot{
      width:12px;height:12px;border-radius:50%;
      display:inline-block;
    }
    .dot-min{ background: #60a5fa; }
    .dot-max{ background: #fb7185; }

    /* tree area */
    .tree-area {
      position:relative;
      height:340px;
      min-height:240px;
      border-radius:8px;
      background: linear-gradient(180deg, rgba(245,247,255,0.9), rgba(255,255,255,0.7));
      padding:12px;
      box-sizing:border-box;
      overflow:visible;
    }
    /* nodes are absolutely positioned */
    .node {
      position:absolute;
      width:var(--node-size);
      height:var(--node-size);
      border-radius:50%;
      background:linear-gradient(180deg,#fff,#f8fbff);
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: 0 8px 18px rgba(12,14,26,0.08);
      border:2px solid rgba(15,23,42,0.06);
      font-weight:700;
      cursor:default;
      transition: left var(--transition), top var(--transition), transform var(--transition), box-shadow var(--transition);
      user-select:none;
    }
    .node.min { border-color: rgba(96,165,250,0.28); color:#1e3a8a; }
    .node.max { border-color: rgba(251,113,133,0.28); color:#7f1d1d; }
    .node.highlight { transform:scale(1.06); box-shadow: 0 14px 30px rgba(12,14,26,0.12); }

    /* connector lines (simple) */
    .connector {
      position:absolute;
      width:2px;
      background: linear-gradient(180deg, rgba(15,23,42,0.08), rgba(15,23,42,0.03));
      transform-origin:top left;
      transition: left var(--transition), top var(--transition), height var(--transition), transform var(--transition);
    }

    /* array view below */
    .array-view {
      margin-top:12px;
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .arr-box{
      min-width:44px;
      height:44px;
      background:white;
      border-radius:8px;
      border:1px solid #e6eefb;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      font-size:14px;
      box-shadow:0 6px 14px rgba(16,24,40,0.04);
      padding:6px;
    }
    .arr-index{
      font-size:11px;color:var(--muted);margin-top:6px;text-align:center;
    }

    /* Footer / Legend text */
    .meta {
      color:var(--muted);
      font-size:13px;
    }
    /* Accessibility focus */
    button:focus, input:focus {
      outline:3px solid rgba(43,110,246,0.14);
      outline-offset:2px;
      border-radius:8px;
    }
    /* small helpers */
    .muted { color:var(--muted); font-size:13px; }
    .controls-row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

  </style>
</head>
<body>
  <div class="app" role="main">
    <!-- Header / Explanations -->
    <header class="module-head">
      <div class="title" aria-hidden="false">
        <h1>Heap (Min/Max) — Interactive Visualizer</h1>
        <p class="subtitle">Explore insertions, extractions and heapify behavior for min-heap and max-heap.</p>
      </div>

      <div style="max-width:640px" aria-labelledby="learning-objective">
        <div class="card" style="padding:12px;">
          <div id="learning-objective" class="section-title">Learning Objective</div>
          <div class="small" style="margin-top:6px;">
            After interacting with this module you will understand:
            <ul style="margin:8px 0 0 18px; padding:0; color:var(--muted); font-size:13px;">
              <li>How a binary heap is represented as an array and as a tree.</li>
              <li>How insert (heapify-up) and extract (heapify-down) maintain heap property.</li>
              <li>The difference between min-heap and max-heap behavior.</li>
            </ul>
          </div>
        </div>
      </div>
    </header>

    <!-- Main interactive area -->
    <section class="main" aria-label="Interactive heap module">
      <!-- LEFT: Controls -->
      <aside class="card" aria-labelledby="controls-title">
        <div id="controls-title" class="section-title">Interactions</div>

        <div class="controls-grid" role="region" aria-label="Heap controls">
          <div>
            <label for="value-input">Insert value (integer)</label>
            <div class="row">
              <input id="value-input" type="number" inputmode="numeric" aria-label="Number to insert" placeholder="e.g. 42" />
              <button id="insert-btn">Insert</button>
            </div>
            <div class="small" style="margin-top:6px;">
              Tip: Press Enter in the input to insert. Values will animate into the heap.
            </div>
          </div>

          <div>
            <label>Heap Type</label>
            <div class="row" style="align-items:center;">
              <label class="switch" aria-label="Toggle heap type">
                <input id="heap-toggle" type="checkbox" aria-checked="false" />
                <span class="track" role="presentation"><span class="knob" aria-hidden="true"></span></span>
              </label>
              <div class="muted" id="heap-type-label">Min-Heap</div>
            </div>
            <div class="small" style="margin-top:6px;">
              Toggle to switch between Min-Heap and Max-Heap. The visual rules and swap priorities update immediately.
            </div>
          </div>

          <div>
            <label>Operations</label>
            <div class="controls-row">
              <button id="extract-btn" class="btn-ghost" title="Remove root">Extract Root</button>
              <button id="clear-btn" class="btn-ghost">Clear</button>
              <button id="random-btn" class="btn-ghost">Random (6)</button>
            </div>
            <div class="small" style="margin-top:6px;">
              Extract removes the root (min or max depending on mode). Clear resets the heap.
            </div>
          </div>

          <div>
            <label>Playback</label>
            <div class="row" style="align-items:center;">
              <button id="step-btn" class="btn-ghost">Step</button>
              <button id="auto-btn" class="btn-ghost">Auto Play</button>
              <label style="margin-left:8px;" class="small">Speed</label>
              <input id="speed" type="range" min="100" max="1200" step="100" value="400" aria-label="Animation speed" />
            </div>
            <div class="small" style="margin-top:6px;">
              Use Step to see each swap. Auto Play animates the full operation.
            </div>
          </div>

          <div>
            <label>Notes</label>
            <div class="small">
              - Nodes swap visually and array updates in sync.<br/>
              - Connectors show parent-child relations. Nodes are indexed from 1 (left to right in each level).
            </div>
          </div>
        </div>
      </aside>

      <!-- RIGHT: Visualization -->
      <div class="viz" aria-live="polite">
        <div class="viz-top">
          <div style="display:flex;gap:12px;align-items:center;">
            <div class="legend">
              <span class="dot dot-min" aria-hidden="true"></span><span class="muted">Min</span>
              <span style="width:8px;"></span>
              <span class="dot dot-max" aria-hidden="true"></span><span class="muted">Max</span>
            </div>
          </div>
          <div>
            <div class="muted">Array view mirrors the tree below</div>
          </div>
        </div>

        <!-- Tree area -->
        <div id="tree-area" class="tree-area" role="application" aria-label="Heap tree visualization">
          <!-- connectors and nodes injected here -->
        </div>

        <!-- Array View -->
        <div aria-label="Heap array representation" style="margin-top:12px;">
          <div class="section-title" style="font-size:14px;margin-bottom:8px;">Array Representation</div>
          <div id="array-view" class="array-view" role="list"></div>
        </div>
      </div>
    </section>

    <!-- Footer: Interaction Design and Layout Description -->
    <section class="card" aria-labelledby="interaction-title">
      <div id="interaction-title" class="section-title">Interaction Design & Layout Description</div>

      <div style="margin-top:8px; color:var(--muted); font-size:13px; line-height:1.45;">
        <strong>Interaction Design</strong>
        <ul style="margin:8px 0 8px 18px; padding:0;">
          <li>Insert: Type an integer and press Insert (or Enter). The value appears as a new node at the next array index and animates from the bottom of the tree toward its parent while performing swap animations when heap property is violated (heapify-up).</li>
          <li>Extract Root: Removes the root node (min for Min-Heap, max for Max-Heap). The last node moves to the root and then animates down swapping with the appropriate child until heap property restored (heapify-down). Each swap is animated and the array is updated in sync.</li>
          <li>Step / Auto Play: Step advances a single comparison/swap during an ongoing operation. Auto Play animates the full operation at the chosen speed slider value. Speed controls duration of transitions.</li>
          <li>Heap Type Toggle: Switch between Min and Max; active swaps are colored and the comparison direction changes immediately.</li>
          <li>Random & Clear: Random populates six values; Clear empties the heap.</li>
        </ul>

        <strong>Layout Description</strong>
        <p style="margin:6px 0 0 0;">
          The module uses a two-column responsive layout with a controls column (left) and a visualization column (right). A safe area margin of 24px surrounds the viewport and at least 16px spacing separates interactive elements. The tree visualization is placed above the array view. Nodes are absolutely positioned in the tree area so their coordinates can be animated; connectors are simple vertical/horizontal bars between parent and child to reinforce tree structure. Controls are grouped by function to maintain clarity and ease of access. All controls are keyboard-accessible and visually focusable for accessibility.
        </p>
      </div>
    </section>
  </div>

  <script>
    /*
      Heap Interactive Module
      - Supports Min-Heap and Max-Heap
      - Visualizes insert (heapify-up) and extract (heapify-down) with animations
      - No external libraries. Vanilla JS + CSS transitions.
    */

    (function(){
      // DOM refs
      const treeArea = document.getElementById('tree-area');
      const arrayView = document.getElementById('array-view');
      const input = document.getElementById('value-input');
      const insertBtn = document.getElementById('insert-btn');
      const extractBtn = document.getElementById('extract-btn');
      const clearBtn = document.getElementById('clear-btn');
      const randomBtn = document.getElementById('random-btn');
      const heapToggle = document.getElementById('heap-toggle');
      const heapTypeLabel = document.getElementById('heap-type-label');
      const stepBtn = document.getElementById('step-btn');
      const autoBtn = document.getElementById('auto-btn');
      const speedRange = document.getElementById('speed');

      // State
      let heap = []; // 1-based conceptual, but we'll store 0-based; functions adapt.
      let isMin = true;
      let busy = false; // prevents concurrent ops
      let autoPlaying = false;
      let pendingSteps = []; // for stepping through operations (swap sequences)
      let animDuration = parseInt(speedRange.value, 10); // ms

      // UI constants
      const NODE_SIZE = 56;
      const GAP = 16;

      // Helpers
      function cmp(a,b){
        return isMin ? a - b : b - a;
      }

      function updateHeapTypeUI(){
        heapTypeLabel.textContent = isMin ? 'Min-Heap' : 'Max-Heap';
      }

      // Create node DOM for index i (0-based)
      function createNodeElement(val, idx){
        const el = document.createElement('div');
        el.className = 'node ' + (isMin ? 'min' : 'max');
        el.setAttribute('data-idx', idx);
        el.setAttribute('role','img');
        el.setAttribute('aria-label', 'Heap node ' + val);
        el.textContent = val;
        el.style.width = NODE_SIZE + 'px';
        el.style.height = NODE_SIZE + 'px';
        el.style.lineHeight = NODE_SIZE + 'px';
        el.style.fontSize = '15px';
        el.style.transitionDuration = animDuration + 'ms';
        treeArea.appendChild(el);
        return el;
      }

      // Create connector element
      function createConnector(){
        const c = document.createElement('div');
        c.className = 'connector';
        treeArea.appendChild(c);
        return c;
      }

      // Render full tree and array, positioning nodes
      function renderAll(animated = true){
        // Clear tree area
        treeArea.querySelectorAll('.node, .connector').forEach(n => {
          if (!animated) n.style.transitionDuration = '0ms';
          else n.style.transitionDuration = animDuration + 'ms';
        });

        const nodes = heap.map((v,i) => ({val:v, idx:i}));
        // Ensure enough node elements exist
        let existing = Array.from(treeArea.querySelectorAll('.node'));
        // synchronize count
        while (existing.length < nodes.length){
          const idx = existing.length;
          const el = createNodeElement(nodes[idx].val, idx);
          existing.push(el);
        }
        while (existing.length > nodes.length){
          const el = existing.pop();
          el.remove();
        }

        // Update node content and attributes
        existing = Array.from(treeArea.querySelectorAll('.node'));
        existing.forEach((el,i) => {
          el.textContent = String(heap[i]);
          el.setAttribute('data-idx', i);
          el.classList.toggle('min', isMin);
          el.classList.toggle('max', !isMin);
          el.style.transitionDuration = animDuration + 'ms';
        });

        // Connectors: number equals nodes.length - 1 (for each child)
        // Remove existing connectors and recreate to avoid complexity
        treeArea.querySelectorAll('.connector').forEach(c => c.remove());
        const connectors = [];

        // Compute positions
        function computePos(i){
          // compute tree layout: levels
          const level = Math.floor(Math.log2(i + 1));
          const indexInLevel = i - (2**level - 1);
          const nodesInLevel = 2**level;
          const areaWidth = treeArea.clientWidth;
          // horizontal spacing: divide area into (nodesInLevel + 1) gutters
          const gapX = Math.max( (areaWidth - NODE_SIZE) / (nodesInLevel + 1), 8);
          // center at (indexInLevel+1)*gapX - half node + offset
          const x = (indexInLevel + 1) * gapX - (NODE_SIZE/2);
          const levelHeight = Math.max(62, NODE_SIZE + 12);
          const y = level * levelHeight + 12;
          return {x: Math.max(8, x), y};
        }

        // Position nodes
        existing.forEach((el,i) => {
          const pos = computePos(i);
          el.style.left = pos.x + 'px';
          el.style.top = pos.y + 'px';
          el.style.zIndex = 1000 - pos.y;
        });

        // Add connectors between parent and child
        existing.forEach((el,i) => {
          const left = parseFloat(el.style.left);
          const top = parseFloat(el.style.top);
          const center = { x: left + NODE_SIZE/2, y: top + NODE_SIZE/2 };
          const leftChildIdx = 2*i + 1;
          const rightChildIdx = 2*i + 2;
          [leftChildIdx, rightChildIdx].forEach(childIdx => {
            if (childIdx < heap.length){
              const child = existing[childIdx];
              const cleft = parseFloat(child.style.left);
              const ctop = parseFloat(child.style.top);
              const ccenter = { x: cleft + NODE_SIZE/2, y: ctop + NODE_SIZE/2 };
              // create connector from parent center to child center
              const conn = createConnector();
              const x = Math.min(center.x, ccenter.x);
              const y = Math.min(center.y, ccenter.y);
              const dx = ccenter.x - center.x;
              const dy = ccenter.y - center.y;
              const length = Math.hypot(dx, dy);
              const angle = Math.atan2(dy, dx) * (180/Math.PI);
              conn.style.left = center.x + 'px';
              conn.style.top = center.y + 'px';
              conn.style.width = Math.max(2, length) + 'px';
              conn.style.height = '2px';
              conn.style.transform = `rotate(${angle}deg)`;
              connectors.push(conn);
            }
          });
        });

        // Render array view
        renderArray();
      }

      // Render the array representation
      function renderArray(){
        arrayView.innerHTML = '';
        // show indices starting at 1
        heap.forEach((v,i) => {
          const box = document.createElement('div');
          box.className = 'arr-box';
          box.textContent = v;
          arrayView.appendChild(box);

          const idx = document.createElement('div');
          idx.className = 'arr-index';
          idx.textContent = (i+1);
          arrayView.appendChild(idx);
        });
      }

      // Insert a value with animated heapify-up, producing a sequence of swaps to play
      function insertValue(val){
        if (busy) return;
        busy = true;
        pendingSteps = [];
        heap.push(val);
        const startIdx = heap.length - 1;
        // Build steps: comparisons and swaps (indices)
        let i = startIdx;
        while (i > 0){
          const parent = Math.floor((i - 1) / 2);
          if (cmp(heap[parent], heap[i]) > 0){
            // swap needed
            pendingSteps.push({type:'swap', a:parent, b:i});
            // perform swap in logical heap for future decisions
            [heap[parent], heap[i]] = [heap[i], heap[parent]];
            i = parent;
          } else {
            break;
          }
        }
        // We built and applied swaps already in the 'heap' to compute final state.
        // But for animation we need the intermediate states. So reconstruct a separate sequence.
        // Instead: re-simulate from array before insertion
        // Better approach: build sequence by simulating on a copy
        // Recompute properly:
        const original = heap.slice(); // current final state
        // recreate from start: copy original but removing final swaps
        // We'll simulate separately to produce steps visually.
        // Simulate on a copy starting with earlier array
        // For clarity, rebuild sequence from snapshot before insertion:
        // snapshotBefore:
        let snapshotBefore = original.slice();
        // remove the inserted element that was appended (we know its final position)
        snapshotBefore.splice(startIdx,1);
        // Now simulate insertion step-by-step to record swaps
        let sim = snapshotBefore.slice();
        sim.push(val);
        i = sim.length - 1;
        const animSteps = [];
        while (i > 0){
          const parent = Math.floor((i - 1) / 2);
          if (cmp(sim[parent], sim[i]) > 0){
            animSteps.push({type:'swap', a:parent, b:i});
            [sim[parent], sim[i]] = [sim[i], sim[parent]];
            i = parent;
          } else { break; }
        }
        // For animation, we need to apply the initial state (snapshotBefore + appended val),
        // then play animSteps one by one.
        // So set heap to initial simulation state:
        heap = snapshotBefore.slice();
        heap.push(val);
        renderAll(false);
        playSteps(animSteps).then(() => { busy = false; });
      }

      // Extract root with animated heapify-down
      function extractRoot(){
        if (busy) return;
        if (heap.length === 0) return;
        busy = true;
        // Create simulation steps
        const animSteps = [];
        // snapshot
        const sim = heap.slice();
        // Swap root with last, remove last
        if (sim.length === 1){
          // simple remove
          sim.pop();
        } else {
          [sim[0], sim[sim.length - 1]] = [sim[sim.length - 1], sim[0]];
          animSteps.push({type:'swap', a:0, b: sim.length - 1, removeIndex: sim.length - 1});
          sim.pop(); // remove the popped root (now at end)
          // heapify down
          let i = 0;
          while (true){
            const left = 2*i + 1;
            const right = 2*i + 2;
            let candidate = i;
            if (left < sim.length && cmp(sim[candidate], sim[left]) > 0) candidate = left;
            if (right < sim.length && cmp(sim[candidate], sim[right]) > 0) candidate = right;
            if (candidate !== i){
              animSteps.push({type:'swap', a:i, b:candidate});
              [sim[i], sim[candidate]] = [sim[candidate], sim[i]];
              i = candidate;
            } else break;
          }
        }
        // Now for animation: set heap to initial state and play animSteps
        renderAll(false);
        playSteps(animSteps).then(() => { busy = false; });
      }

      // Play a sequence of steps (swap steps)
      // Each step animates a swap. Optionally remove an element after swap.
      function playSteps(steps){
        return new Promise((resolve) => {
          if (!steps || steps.length === 0){
            // nothing to do; final render set
            // ensure final array set correctly (simulate)
            renderAll(true);
            resolve();
            return;
          }
          let idx = 0;

          function doNext(){
            if (idx >= steps.length){
              // finished; ensure final heap state consistent
              // After all steps, recompute heap by applying simulated steps to an initial snapshot
              // Instead of recomputing, we'll maintain heap state incrementally.
              renderAll(true);
              resolve();
              return;
            }
            const s = steps[idx++];
            if (s.type === 'swap'){
              // perform DOM swap animation between a and b
              // find nodes by data-idx attributes
              const aIdx = s.a;
              const bIdx = s.b;
              const nodes = Array.from(treeArea.querySelectorAll('.node'));
              const nodeA = nodes[aIdx];
              const nodeB = nodes[bIdx];
              if (!nodeA || !nodeB){
                // fallback: update logical heap and continue
                performSwapLogical(aIdx,bIdx,s.removeIndex);
                renderAll(true);
                return setTimeout(doNext, animDuration + 40);
              }
              // highlight
              nodeA.classList.add('highlight');
              nodeB.classList.add('highlight');

              // get current positions
              const aLeft = parseFloat(nodeA.style.left);
              const aTop = parseFloat(nodeA.style.top);
              const bLeft = parseFloat(nodeB.style.left);
              const bTop = parseFloat(nodeB.style.top);

              // swap text immediates? For smoother look swap positions only
              // move elements by setting left/top to each other's positions
              nodeA.style.left = bLeft + 'px';
              nodeA.style.top = bTop + 'px';
              nodeB.style.left = aLeft + 'px';
              nodeB.style.top = aTop + 'px';

              // after transition duration, swap their data-idx attributes and update logical heap
              setTimeout(() => {
                nodeA.classList.remove('highlight');
                nodeB.classList.remove('highlight');
                // swap in DOM order: easiest to swap displayed values and data-idx
                const tempA = nodeA.textContent;
                nodeA.textContent = nodeB.textContent;
                nodeB.textContent = tempA;
                // update data-idx on elements for future finds
                nodeA.setAttribute('data-idx', bIdx);
                nodeB.setAttribute('data-idx', aIdx);

                // update logical heap
                performSwapLogical(aIdx,bIdx,s.removeIndex);
                // re-render connectors to stay consistent
                renderAll(true);

                // next
                if (autoPlaying) {
                  setTimeout(doNext, 60);
                } else {
                  // wait for user step click
                }
              }, animDuration + 20);
            } else {
              // unknown step
              setTimeout(doNext, 60);
            }
          }

          // If autoPlaying, drive steps immediately; otherwise wait for step button to trigger doNext
          if (autoPlaying){
            doNext();
          } else {
            // attach temporary handler for step button
            function stepHandler(){
              doNext();
              stepBtn.removeEventListener('click', stepHandler);
            }
            stepBtn.addEventListener('click', stepHandler, {once:true});
          }

          // Kick-off for the case of autoPlaying or first visual stage
          if (autoPlaying) {
            // ensure first frame is visible
            renderAll(true);
            // slight delay then start
            setTimeout(doNext, 80);
          } else {
            // render initial frame and wait for step press
            renderAll(true);
          }
        });
      }

      // Perform logical swap in heap array and handle removal if indicated
      function performSwapLogical(a,b,removeIndex){
        // make sure a and b in bounds
        if (a < 0 || b < 0 || a >= heap.length || b >= heap.length) return;
        [heap[a], heap[b]] = [heap[b], heap[a]];
        if (typeof removeIndex !== 'undefined'){
          // remove the element at removeIndex (typically last)
          heap.splice(removeIndex,1);
        }
      }

      // UI bindings
      insertBtn.addEventListener('click', () => {
        const val = parseInt(input.value,10);
        if (Number.isNaN(val)) { input.focus(); return; }
        insertValue(val);
        input.value = '';
        input.focus();
      });

      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter'){
          insertBtn.click();
        }
      });

      extractBtn.addEventListener('click', () => {
        if (heap.length === 0) return;
        autoPlaying = false;
        extractRoot();
      });

      clearBtn.addEventListener('click', () => {
        if (busy) return;
        heap = [];
        renderAll(false);
      });

      randomBtn.addEventListener('click', () => {
        if (busy) return;
        heap = [];
        const count = 6;
        for (let i=0;i<count;i++){
          heap.push(Math.floor(Math.random()*90)+10);
        }
        // If we want a real heap, heapify the array to obey current type.
        heapifyArray();
        renderAll(false);
      });

      heapToggle.addEventListener('change', (e) => {
        isMin = !heapToggle.checked; // checked = Max (we decided)
        updateHeapTypeUI();
        // change styling of nodes
        treeArea.querySelectorAll('.node').forEach(n => {
          n.classList.toggle('min', isMin);
          n.classList.toggle('max', !isMin);
        });
        // Re-heapify existing data to reflect new ordering
        heapifyArray();
        renderAll(true);
      });

      // Step and Auto
      stepBtn.addEventListener('click', () => {
        // Step is only meaningful when there are pending steps; we implement step to perform a single logical comparison/swap
        // For simplicity, trigger a single visual step by invoking a no-op or continuing any running operation.
        // If not busy, do nothing.
        // The playSteps function listens for step clicks if not autoPlaying.
        // We'll simply trigger a click to advance if there are pending animations in progress.
        // (This simplistic model allows step to advance operations created by insert/extract.)
      });

      autoBtn.addEventListener('click', () => {
        autoPlaying = !autoPlaying;
        autoBtn.textContent = autoPlaying ? 'Auto Pause' : 'Auto Play';
      });

      speedRange.addEventListener('input', (e) => {
        animDuration = parseInt(e.target.value,10);
        // update transition durations on nodes and connectors
        treeArea.querySelectorAll('.node, .connector').forEach(n => {
          n.style.transitionDuration = animDuration + 'ms';
        });
      });

      // Heapify current array according to isMin: standard build-heap
      function heapifyArray(){
        // build heap in place
        for (let i = Math.floor(heap.length/2)-1; i >= 0; i--){
          siftDown(i, heap.length);
        }
      }
      function siftDown(i, len){
        while (true){
          const left = 2*i + 1;
          const right = 2*i + 2;
          let candidate = i;
          if (left < len && cmp(heap[candidate], heap[left]) > 0) candidate = left;
          if (right < len && cmp(heap[candidate], heap[right]) > 0) candidate = right;
          if (candidate !== i){
            [heap[i], heap[candidate]] = [heap[candidate], heap[i]];
            i = candidate;
          } else break;
        }
      }

      // Initial render
      updateHeapTypeUI();
      renderAll(false);

      // Resize handling to reposition nodes responsively
      let resizeTimer;
      window.addEventListener('resize', () => {
        // throttle
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => renderAll(true), 80);
      });

      // Accessibility: keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.key === 'i' && document.activeElement.tagName !== 'INPUT') {
          input.focus();
        }
        if (e.key === 'r') randomBtn.click();
        if (e.key === 'c') clearBtn.click();
        if (e.key === 'e') extractBtn.click();
      });

    })();
  </script>
</body>
</html>