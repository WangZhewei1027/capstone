<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Bubble Sort Explorer</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-padding: 24px;
      --gap: 16px; /* minimum spacing between interactive elements */
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa4bf;
      --accent: #4f46e5;
      --ok: #10b981;
      --danger: #ef4444;
      --compare: #f59e0b;
      --swap: #ef4444;
      --sorted: #06b6d4;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071022 0%, #0b1220 100%);
      color:#e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app {
      padding: var(--safe-padding);
      box-sizing: border-box;
      min-height: 100vh;
      display: grid;
      grid-template-columns: 1fr 360px;
      grid-gap: var(--gap);
      align-items: start;
    }

    /* Responsive: single column under 900px */
    @media (max-width: 900px) {
      .app {
        grid-template-columns: 1fr;
      }
    }

    header.module {
      grid-column: 1 / -1;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 18px;
      display:flex;
      gap: 18px;
      align-items: center;
      box-shadow: 0 4px 20px rgba(2,6,23,0.6);
    }
    .title {
      font-size: 20px;
      font-weight: 600;
      margin: 0;
    }
    .subtitle {
      color: var(--muted);
      font-size: 13px;
      margin: 0;
    }

    /* Left main panel: visualization */
    .visual-panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius: 12px;
      padding: 18px;
      min-height: 420px;
      display:flex;
      flex-direction:column;
      gap: 18px;
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
    }
    .vis-top {
      display:flex;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
    }
    .learning {
      max-width: 720px;
    }
    .learning h3 {
      margin: 0 0 6px 0;
      font-size: 16px;
    }
    .learning p {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.3;
    }

    /* Visualization area */
    .canvas {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));
      border: 1px solid rgba(255,255,255,0.03);
      border-radius: 10px;
      height: 260px;
      position: relative;
      overflow: hidden;
      padding: 12px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
    }

    .bars {
      position:relative;
      height: 100%;
      width: 100%;
      max-width: 980px;
    }

    .bar {
      position:absolute;
      bottom:12px;
      width: 48px;
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      color:#0b1220;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:600;
      transition: left 320ms ease, transform 320ms ease, background-color 180ms ease, width 320ms ease;
      box-shadow: 0 6px 18px rgba(2,6,23,0.5), inset 0 -4px 8px rgba(255,255,255,0.02);
      user-select: none;
    }
    .bar .label {
      font-size: 13px;
      color: #071022;
    }

    /* Visual states */
    .bar.compare { background: linear-gradient(180deg, #fff7ed, #fff1dd); box-shadow:0 8px 24px rgba(245,158,11,0.12); }
    .bar.swap { background: linear-gradient(180deg, #ffecee, #ffdfe1); box-shadow:0 10px 30px rgba(239,68,68,0.12); }
    .bar.sorted { background: linear-gradient(180deg, #e6fffb, #ccfff7); box-shadow:0 8px 24px rgba(6,182,212,0.08); }
    .bar.dim { opacity: 0.42; }

    /* Controls */
    .controls {
      display:flex;
      gap: 12px;
      align-items:center;
      flex-wrap:wrap;
    }
    button, input[type="range"], select {
      font-size: 13px;
      padding: 8px 12px;
      border-radius: 8px;
      border: none;
      background: rgba(255,255,255,0.03);
      color: #e6eef8;
      cursor: pointer;
      min-height:40px;
    }
    button:focus { outline:2px solid rgba(79,70,229,0.25); }
    .btn-primary {
      background: linear-gradient(90deg,var(--accent), #7c3aed);
      box-shadow: 0 6px 18px rgba(79,70,229,0.18);
      border: 1px solid rgba(255,255,255,0.02);
    }
    .btn-ghost {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.04);
    }
    .play-toggle { display:flex; gap:8px; align-items:center; }

    .small {
      font-size:13px;
      padding: 6px 10px;
      min-height:36px;
    }

    /* Right panel: options and pseudocode */
    .side-panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.007));
      border-radius: 12px;
      padding: 18px;
      display:flex;
      flex-direction:column;
      gap:16px;
      min-height: 420px;
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
    }
    .panel-section h4 { margin:0 0 8px 0; font-size:14px; }
    .inputs { display:flex; gap:12px; flex-wrap:wrap; }
    .inputs input[type="text"] {
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.03);
      color: #e6eef8;
      padding: 8px 10px;
      border-radius:8px;
      min-width: 0;
    }
    .stat-grid {
      display:grid;
      grid-template-columns: repeat(2,1fr);
      gap:8px;
    }
    .stat {
      background: rgba(255,255,255,0.02);
      padding:8px;
      border-radius:8px;
      font-size:13px;
      color:var(--muted);
    }
    .stat b { color:#e6eef8; display:block; font-size:15px; }

    pre.pseudo {
      background: rgba(255,255,255,0.02);
      padding: 12px;
      border-radius:8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
      color:var(--muted);
      margin:0;
      overflow:auto;
    }
    .pseudo .line { display:block; padding: 2px 6px; border-radius:6px; }
    .pseudo .active { background: rgba(79,70,229,0.12); color: #fff; }

    /* Footer small tips */
    .tips {
      color: var(--muted);
      font-size: 13px;
    }

    /* Accessibility helpers */
    .sr-only {
      position:absolute;
      left:-10000px;
      top:auto;
      width:1px;
      height:1px;
      overflow:hidden;
    }

  </style>
</head>
<body>
  <main class="app" id="app">
    <header class="module" aria-labelledby="title">
      <div>
        <h1 id="title" class="title">Bubble Sort — Interactive Explorer</h1>
        <p class="subtitle">Visualize comparisons, swaps, and how repeated passes bubble the largest elements to the end.</p>
      </div>
      <div style="margin-left:auto; text-align:right;">
        <div class="subtitle" style="font-weight:600">One concept: Bubble Sort</div>
        <div class="tips" style="margin-top:6px">Controls: Step • Play/Pause • Randomize • Edit array</div>
      </div>
    </header>

    <!-- Left: Visualization & Controls -->
    <section class="visual-panel" aria-labelledby="learningTitle">
      <div class="vis-top">
        <div class="learning">
          <h3 id="learningTitle">Learning Objective</h3>
          <p>
            After interacting with this module you will visually understand how Bubble Sort compares adjacent items,
            performs swaps when needed, and completes multiple passes until the array is sorted. Observe comparisons,
            swaps, and the growing "sorted" region at the end.
          </p>
        </div>

        <div style="min-width:220px;">
          <div style="color:var(--muted); font-size:13px;">Current mode</div>
          <div style="margin-top:6px; display:flex; gap:8px;">
            <button class="small btn-ghost" id="stepBtn" title="Step one comparison or swap (keyboard: S)">Step</button>
            <button class="small btn-primary" id="playBtn" title="Play / Pause (keyboard: Space)">Play</button>
          </div>
        </div>
      </div>

      <div class="canvas" id="canvas" aria-live="polite" aria-label="Sorting visualization">
        <div class="bars" id="bars" role="list" aria-label="Array elements as bars"></div>
      </div>

      <div style="display:flex; gap:var(--gap); align-items:center; justify-content:space-between; flex-wrap:wrap;">
        <div class="controls" role="group" aria-label="Array controls">
          <button id="randBtn" class="btn-ghost">Randomize</button>
          <label style="display:flex; gap:8px; align-items:center;">
            <span class="subtitle" style="font-size:13px; color:var(--muted);">Size</span>
            <input id="sizeRange" type="range" min="3" max="14" value="8" />
          </label>
          <label style="display:flex; gap:8px; align-items:center;">
            <span class="subtitle" style="font-size:13px; color:var(--muted);">Speed</span>
            <input id="speedRange" type="range" min="50" max="1200" value="380" />
          </label>
          <button id="resetBtn" class="btn-ghost">Reset</button>
        </div>

        <div style="display:flex; gap:12px; align-items:center;">
          <div class="subtitle" id="statusText" style="font-size:13px; color:var(--muted)">Ready</div>
        </div>
      </div>
    </section>

    <!-- Right: Options, stats, pseudocode -->
    <aside class="side-panel" aria-labelledby="optionsTitle">
      <div class="panel-section">
        <h4 id="optionsTitle">Array & Options</h4>
        <div class="inputs">
          <input id="arrayInput" type="text" placeholder="Enter numbers, e.g. 5,3,8,1" aria-label="Array values input" />
          <button id="setBtn" class="small btn-ghost">Set</button>
        </div>
        <div style="margin-top:10px; color:var(--muted); font-size:13px;">
          Tip: values are parsed as numbers. Use commas or spaces.
        </div>
      </div>

      <div class="panel-section">
        <h4>Statistics</h4>
        <div class="stat-grid" aria-live="polite">
          <div class="stat"><span class="subtitle">Comparisons</span><b id="compCount">0</b></div>
          <div class="stat"><span class="subtitle">Swaps</span><b id="swapCount">0</b></div>
          <div class="stat"><span class="subtitle">Pass</span><b id="passCount">0</b></div>
          <div class="stat"><span class="subtitle">Array size</span><b id="sizeLabel">8</b></div>
        </div>
      </div>

      <div class="panel-section" style="flex:1; display:flex; flex-direction:column;">
        <h4>Pseudocode</h4>
        <pre class="pseudo" id="pseudocode" aria-hidden="false">
<span class="line" data-line="1">1: for i from 0 to n-1</span>
<span class="line" data-line="2">2:   for j from 0 to n-2-i</span>
<span class="line" data-line="3">3:     if array[j] > array[j+1]</span>
<span class="line" data-line="4">4:       swap array[j] and array[j+1]</span>
<span class="line" data-line="5">5: end</span>
        </pre>
      </div>

      <div>
        <h4>Design Plan</h4>
        <div style="font-size:13px; color:var(--muted); line-height:1.3;">
          <strong>Interaction design:</strong> Step compares one pair; Play auto-steps at adjustable speed. Randomize or set custom array.
          Visual feedback highlights compared bars, animates swaps, and marks sorted items. Pseudocode lines highlight corresponding actions.
          <br/><br/>
          <strong>Layout:</strong> Left column: visualization + controls. Right column: inputs, stats, pseudocode. Spacing uses 24px safe padding and at least 16px gaps.
        </div>
      </div>
    </aside>
  </main>

  <script>
    // Bubble Sort Interactive Module (vanilla JS)
    (function () {
      // DOM refs
      const barsEl = document.getElementById('bars');
      const sizeRange = document.getElementById('sizeRange');
      const sizeLabel = document.getElementById('sizeLabel');
      const randBtn = document.getElementById('randBtn');
      const resetBtn = document.getElementById('resetBtn');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const speedRange = document.getElementById('speedRange');
      const arrayInput = document.getElementById('arrayInput');
      const setBtn = document.getElementById('setBtn');
      const compCountEl = document.getElementById('compCount');
      const swapCountEl = document.getElementById('swapCount');
      const passCountEl = document.getElementById('passCount');
      const statusText = document.getElementById('statusText');
      const pseudocode = document.getElementById('pseudocode');

      // State
      let array = [];
      let size = parseInt(sizeRange.value, 10);
      let positions = []; // left positions for each index (px)
      let isPlaying = false;
      let timer = null;
      let speed = parseInt(speedRange.value, 10);
      let comparisons = 0;
      let swaps = 0;
      let pass = 0;

      // Algorithm pointers
      let i = 0, j = 0;
      let n = size;
      let sortedUntil = n; // elements from sortedUntil..n-1 are sorted

      // Accessibility / keyboard controls
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          togglePlay();
        } else if (e.key === 's' || e.key === 'S') {
          e.preventDefault();
          step();
        }
      });

      // Initialize
      function init() {
        size = parseInt(sizeRange.value, 10);
        sizeLabel.textContent = size;
        generateRandom(size);
        resetState();
        render();
        attachEventListeners();
      }

      function attachEventListeners() {
        window.addEventListener('resize', recalcPositions);
        sizeRange.addEventListener('input', () => {
          size = parseInt(sizeRange.value, 10);
          sizeLabel.textContent = size;
        });
        sizeRange.addEventListener('change', () => {
          size = parseInt(sizeRange.value, 10);
          generateRandom(size);
          resetState();
          render();
        });

        randBtn.addEventListener('click', () => {
          generateRandom(size);
          resetState();
          render();
        });
        resetBtn.addEventListener('click', () => {
          resetState();
          render();
        });
        stepBtn.addEventListener('click', step);
        playBtn.addEventListener('click', togglePlay);
        speedRange.addEventListener('input', () => {
          speed = parseInt(speedRange.value, 10);
          if (isPlaying) startAutoPlay();
        });

        setBtn.addEventListener('click', () => {
          const text = arrayInput.value.trim();
          if (!text) return;
          const parsed = parseArrayText(text);
          if (parsed && parsed.length >= 2) {
            array = parsed.slice(0, 50);
            size = array.length;
            sizeRange.value = size;
            sizeLabel.textContent = size;
            resetState();
            render();
          } else {
            alert('Please enter at least two numbers separated by commas or spaces.');
          }
        });
      }

      function parseArrayText(text) {
        // allow commas or spaces
        const parts = text.split(/[\s,]+/).filter(Boolean);
        const nums = parts.map(p => Number(p)).filter(n => !Number.isNaN(n));
        return nums.length === 0 ? null : nums;
      }

      function generateRandom(sz) {
        array = [];
        // generate random numbers between 5 and 95
        for (let k = 0; k < sz; k++) {
          array.push(5 + Math.round(Math.random() * 90));
        }
      }

      function resetState() {
        isPlaying = false;
        clearInterval(timer);
        timer = null;
        speed = parseInt(speedRange.value, 10);
        comparisons = 0;
        swaps = 0;
        pass = 0;
        i = 0;
        j = 0;
        n = array.length;
        sortedUntil = n;
        updateStats();
        statusText.textContent = 'Ready';
        playBtn.textContent = 'Play';
        clearPseudocodeHighlight();
      }

      function updateStats() {
        compCountEl.textContent = comparisons;
        swapCountEl.textContent = swaps;
        passCountEl.textContent = pass;
        sizeLabel.textContent = n;
      }

      // Rendering bars
      function render() {
        barsEl.innerHTML = '';
        // compute bar width based on container width and n, respecting minimum spacing 16px
        const containerRect = barsEl.getBoundingClientRect();
        const maxWidth = containerRect.width || (window.innerWidth - 2 * 24 - 360);
        // fallback width if 0
        const gap = 12;
        let barWidth = Math.max(36, Math.min(72, Math.floor((maxWidth - (n - 1) * gap) / n)));
        // create bar elements, absolutely positioned
        positions = [];
        for (let idx = 0; idx < array.length; idx++) {
          const el = document.createElement('div');
          el.className = 'bar';
          el.setAttribute('role', 'listitem');
          el.setAttribute('aria-label', `Value ${array[idx]}`);
          el.style.width = barWidth + 'px';
          // height relative to value (scale to container height)
          const minVal = 0;
          const maxVal = 100;
          const hPct = Math.max(8, Math.min(100, Math.round((array[idx] - minVal) / (maxVal - minVal) * 100)));
          el.style.height = Math.max(36, Math.round((hPct / 100) * (barsEl.clientHeight - 36))) + 'px';
          el.dataset.index = idx;
          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = array[idx];
          el.appendChild(label);

          barsEl.appendChild(el);
        }
        recalcPositions();
        // mark sorted region (initially none)
        markSortedFrom(sortedUntil);
      }

      function recalcPositions() {
        const barEls = Array.from(barsEl.children);
        if (barEls.length === 0) return;
        const containerWidth = barsEl.clientWidth;
        const gap = 12;
        const barWidth = parseInt(barEls[0].style.width, 10);
        const totalW = barEls.length * barWidth + (barEls.length - 1) * gap;
        const startX = Math.max(12, (containerWidth - totalW) / 2);
        positions = [];
        barEls.forEach((el, idx) => {
          const left = startX + idx * (barWidth + gap);
          positions.push(left);
          el.style.left = left + 'px';
        });
      }

      // Helpers to highlight pseudocode
      function clearPseudocodeHighlight() {
        const lines = pseudocode.querySelectorAll('.line');
        lines.forEach(l => l.classList.remove('active'));
      }
      function highlightPseudo(lineNum) {
        clearPseudocodeHighlight();
        const node = pseudocode.querySelector('.line[data-line="' + lineNum + '"]');
        if (node) node.classList.add('active');
      }

      // Mark sorted region visually
      function markSortedFrom(startIdx) {
        const barEls = Array.from(barsEl.children);
        for (let k = 0; k < barEls.length; k++) {
          const el = barEls[k];
          el.classList.remove('sorted', 'dim', 'compare', 'swap');
          if (k >= startIdx) {
            el.classList.add('sorted');
            el.setAttribute('aria-label', `Value ${array[k]} (sorted)`);
          }
        }
      }

      // Core step function: one comparison, possibly a swap
      async function step() {
        if (array.length < 2) return;
        if (i >= n - 1) {
          // finished
          statusText.textContent = 'Sorted';
          markSortedFrom(0);
          clearPseudocodeHighlight();
          return;
        }

        // highlight pseudocode lines
        highlightPseudo(1); // outer for
        highlightPseudo(2); // inner for

        // If j exceeds inner bound, finish pass
        if (j > n - 2 - i) {
          // End of inner loop: last element in this pass becomes sorted
          sortedUntil = n - 1 - i;
          markSortedFrom(sortedUntil);
          j = 0;
          i++;
          pass++;
          updateStats();
          statusText.textContent = `Completed pass ${pass}`;
          // Slight pause to show completed pass
          await delay(Math.max(80, speed / 4));
          // continue to next step automatically if playing, else return
          checkFinish();
          return;
        }

        // Compare array[j] and array[j+1]
        highlightPseudo(3);
        comparisons++;
        updateStats();
        statusText.textContent = `Comparing indices ${j} and ${j + 1}`;
        const barEls = Array.from(barsEl.children);
        const aEl = barEls[j];
        const bEl = barEls[j + 1];
        // set compare visual
        clearVisualStates();
        if (aEl) aEl.classList.add('compare');
        if (bEl) bEl.classList.add('compare');

        // Wait a short moment to let user see comparison
        await delay(Math.max(120, speed / 6));

        if (array[j] > array[j + 1]) {
          // Swap
          highlightPseudo(4);
          swaps++;
          updateStats();
          statusText.textContent = `Swapping ${array[j]} ↔ ${array[j + 1]}`;
          if (aEl) { aEl.classList.remove('compare'); aEl.classList.add('swap'); }
          if (bEl) { bEl.classList.remove('compare'); bEl.classList.add('swap'); }
          await animateSwap(j, j + 1);
          // swap data
          const tmp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = tmp;
          // also swap DOM order: after animation, reorder elements to match indices
          reorderDOMElements();
        } else {
          statusText.textContent = `No swap needed`;
        }

        // move to next index
        j++;
        highlightPseudo(2);
        // update sorted region subtly
        markSortedFrom(sortedUntil);
        checkFinish();
      }

      // Check if sort finished
      function checkFinish() {
        if (i >= n - 1) {
          statusText.textContent = 'Sorted';
          highlightPseudo(5);
          markSortedFrom(0);
          isPlaying = false;
          clearInterval(timer);
          playBtn.textContent = 'Play';
        }
      }

      function clearVisualStates() {
        const barEls = Array.from(barsEl.children);
        barEls.forEach(el => {
          el.classList.remove('compare', 'swap', 'dim');
        });
      }

      // Animate swapping two bars (by indices)
      async function animateSwap(idxA, idxB) {
        const barEls = Array.from(barsEl.children);
        const aEl = barEls[idxA];
        const bEl = barEls[idxB];
        if (!aEl || !bEl) return;

        // Calculate translation distances based on current left positions
        const leftA = parseFloat(aEl.style.left);
        const leftB = parseFloat(bEl.style.left);
        const delta = leftB - leftA;

        // Apply translate to animate swap visually
        aEl.style.transform = `translateX(${delta}px) scale(1.02)`;
        bEl.style.transform = `translateX(${-delta}px) scale(1.02)`;

        // Wait for transition to end
        await Promise.all([waitTransition(aEl), waitTransition(bEl)]);

        // Reset transforms (but swap their left positions to reflect final layout)
        aEl.style.transform = '';
        bEl.style.transform = '';

        // Swap left positions (so subsequent layout is consistent)
        const tmpLeft = aEl.style.left;
        aEl.style.left = bEl.style.left;
        bEl.style.left = tmpLeft;

        // Update dataset indices to reflect their visual positions (not strictly necessary)
      }

      // After animations, reorder DOM nodes to match logical array order
      function reorderDOMElements() {
        // Recreate DOM order to match logical array
        const nodes = Array.from(barsEl.children);
        // Sort nodes by their left position numerically
        nodes.sort((x, y) => parseFloat(x.style.left) - parseFloat(y.style.left));
        // Re-append in order
        nodes.forEach(n => barsEl.appendChild(n));
        // Update label values to match array values (for consistency)
        const children = Array.from(barsEl.children);
        for (let k = 0; k < children.length; k++) {
          const lbl = children[k].querySelector('.label');
          if (lbl) lbl.textContent = array[k];
        }
      }

      // Utility: wait for transition end on element or fallback delay
      function waitTransition(el) {
        return new Promise(resolve => {
          let invoked = false;
          function done() {
            if (invoked) return;
            invoked = true;
            el.removeEventListener('transitionend', onEnd);
            resolve();
          }
          function onEnd(e) {
            // only consider transform/left transitions
            if (e.propertyName === 'transform' || e.propertyName === 'left') done();
          }
          el.addEventListener('transitionend', onEnd);
          // safety timeout
          setTimeout(done, Math.max(200, speed + 120));
        });
      }

      function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      // Play/pause logic
      function togglePlay() {
        if (isPlaying) {
          isPlaying = false;
          clearInterval(timer);
          timer = null;
          playBtn.textContent = 'Play';
          statusText.textContent = 'Paused';
        } else {
          // if finished, restart?
          if (i >= n - 1) {
            resetState();
            render();
          }
          isPlaying = true;
          startAutoPlay();
          playBtn.textContent = 'Pause';
          statusText.textContent = 'Playing';
        }
      }

      function startAutoPlay() {
        clearInterval(timer);
        const interval = Math.max(60, speed); // ms between steps
        timer = setInterval(async () => {
          // Pause interval while a swap animation is in progress by ensuring animateSwap awaits
          // Call step; if step performs async operations, subsequent interval ticks might overlap, so disable while busy.
          if (isBusy) return;
          isBusy = true;
          await step();
          isBusy = false;
        }, Math.max(60, Math.floor(speed)));
      }

      // ensure we don't run overlapping steps
      let isBusy = false;

      // Provide a graceful reset function
      function resetArrayTo(arrayValues) {
        array = arrayValues.slice();
        n = array.length;
        sizeRange.value = n;
        sizeLabel.textContent = n;
        resetState();
        render();
      }

      // Initial render
      init();

      // Expose some functions to console for quick testing (optional)
      window._bubble = {
        get array() { return array.slice(); },
        step: step,
        play: togglePlay,
        reset: () => { resetState(); render(); },
        setArray: resetArrayTo
      };

    })();
  </script>
</body>
</html>