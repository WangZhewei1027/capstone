<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Queue Module — FIFO Visualization</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#3b82f6;
      --muted:#94a3b8;
      --success:#10b981;
      --danger:#ef4444;
      --box-w:84px;
      --box-h:56px;
    }
    /* Safe area margins */
    html,body{height:100%;}
    body{
      margin:0;
      padding:var(--safe-margin);
      font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:linear-gradient(180deg,#071029 0%, #071020 100%);
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      box-sizing:border-box;
    }
    *{box-sizing:inherit}
    h1{margin:0 0 8px 0; font-size:20px;}
    p{margin:0 0 12px 0; color:var(--muted); line-height:1.4}
    .container{
      display:flex;
      gap:var(--gap);
      align-items:stretch;
      min-height:60vh;
    }
    /* Responsive: stack on narrow screens */
    @media (max-width:880px){
      .container{flex-direction:column;}
    }

    /* Left column: descriptors */
    .doc{
      flex:1 1 360px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:10px;
      padding:20px;
      min-width:280px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .section-title{font-weight:600; font-size:13px; color:var(--accent); margin-top:6px}
    .list{font-size:13px; color:var(--muted); margin-left:8px}

    /* Right column: interactive module */
    .module{
      flex:1 1 520px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:10px;
      padding:20px;
      min-width:320px;
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    /* Controls area */
    .controls{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    .controls > *{min-height:40px}
    input[type="text"], input[type="number"]{
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:transparent;
      color:inherit;
      min-width:120px;
      outline:none;
    }
    input[type="text"]::placeholder{color:rgba(230,238,248,0.5)}
    .btn{
      padding:8px 12px;
      border-radius:8px;
      border:none;
      cursor:pointer;
      background:rgba(59,130,246,0.12);
      color:var(--accent);
      font-weight:600;
      transition:transform .12s ease, box-shadow .12s;
      min-width:84px;
    }
    .btn:active{transform:translateY(1px)}
    .btn.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      font-weight:600;
    }
    .btn.ghost{
      background:transparent;
      color:var(--muted);
      border:1px dashed rgba(255,255,255,0.03);
      min-width:44px;
    }

    .controls-left{display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap;}

    /* Visualization area */
    .visual{
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:stretch;
      padding:8px;
    }
    .queue-area{
      background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:10px;
      padding:18px;
      min-height:150px;
      display:flex;
      flex-direction:column;
      gap:12px;
      position:relative;
      overflow:hidden;
    }
    .queue-line{
      display:flex;
      gap:14px;
      align-items:center;
      padding:8px;
      transition:all .28s ease;
      min-height: calc(var(--box-h) + 16px);
      flex-wrap:wrap;
    }
    .slot{
      width:var(--box-w);
      height:var(--box-h);
      border-radius:8px;
      background:rgba(255,255,255,0.02);
      border:1px dashed rgba(255,255,255,0.03);
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--muted);
      font-weight:700;
      position:relative;
      flex:0 0 auto;
    }
    .node{
      width:var(--box-w);
      height:var(--box-h);
      border-radius:8px;
      background:linear-gradient(180deg, rgba(59,130,246,0.18), rgba(59,130,246,0.08));
      border:1px solid rgba(59,130,246,0.18);
      display:flex;
      align-items:center;
      justify-content:center;
      color: #e6f0ff;
      font-weight:700;
      font-size:15px;
      box-shadow: 0 6px 18px rgba(11,37,84,0.25);
      transform:translateY(0);
      opacity:1;
      transition:transform .28s cubic-bezier(.2,.9,.3,1), opacity .22s ease;
    }
    /* entrance and exit */
    .node.enter{transform:translateY(20px); opacity:0;}
    .node.enter.node--active{transform:translateY(0); opacity:1;}
    .node.exit{transform:translateY(-20px); opacity:0;}

    .badge{
      position:absolute;
      top:6px;
      font-size:12px;
      padding:6px 8px;
      border-radius:999px;
      background:rgba(2,6,23,0.7);
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.02);
      transform:translateX(-50%);
      pointer-events:none;
      white-space:nowrap;
    }

    /* head/tail small markers */
    .marker{
      position:absolute;
      top:-10px;
      font-size:12px;
      padding:6px 8px;
      border-radius:999px;
      background:var(--panel);
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.03);
      transform:translateX(-50%);
      transition:left .28s ease;
      display:flex;
      gap:8px;
      align-items:center;
    }
    .marker .dot{width:8px; height:8px; border-radius:50%}
    .marker.head .dot{background:var(--success)}
    .marker.tail .dot{background:var(--accent)}

    /* Status area */
    .status{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      color:var(--muted);
      font-size:13px;
    }
    .status .msg{min-height:20px}
    .status .capacity{font-weight:700; color:var(--muted)}

    /* log */
    .log{
      max-height:120px;
      overflow:auto;
      padding:8px;
      border-radius:8px;
      background:rgba(255,255,255,0.01);
      color:var(--muted);
      font-size:13px;
    }

    /* feedback styles: full/empty */
    .indicator{
      padding:6px 8px;
      border-radius:8px;
      color:#07202a;
      background:rgba(255,255,255,0.04);
      font-weight:700;
      font-size:13px;
    }
    .indicator.full{background:linear-gradient(90deg,var(--danger), #f97316); color:white;}
    .indicator.empty{background:linear-gradient(90deg,#94a3b8,#64748b); color:white;}

    /* shake animation */
    @keyframes shake {
      0%{transform:translateX(0)} 20%{transform:translateX(-6px)} 40%{transform:translateX(6px)} 60%{transform:translateX(-4px)} 80%{transform:translateX(4px)} 100%{transform:translateX(0)}
    }
    .shake{animation:shake .48s cubic-bezier(.36,.07,.19,.97);}

    /* small helpers */
    .muted{color:var(--muted); font-size:13px}
    .sr-only{position:absolute; left:-10000px; width:1px; height:1px; overflow:hidden}
  </style>
</head>
<body>
  <main style="display:flex;flex-direction:column;gap:16px;">
    <!-- Header -->
    <header style="display:flex;flex-direction:column;gap:6px;">
      <h1>Queue — FIFO (First In, First Out) Interactive Module</h1>
      <p class="muted">Explore how a Queue stores items in a first-in-first-out order. Use the controls below to enqueue values, dequeue them, peek at the front, and observe head/tail movement and overflow/underflow behaviors.</p>
    </header>

    <div class="container" role="region" aria-label="Queue learning module container">
      <!-- Documentation / Planning Column -->
      <aside class="doc" aria-labelledby="doc-title">
        <div>
          <div id="doc-title" class="section-title">Concept Title</div>
          <div style="font-weight:700; margin-top:8px">Queue (FIFO) — Enqueue, Dequeue, Peek</div>
        </div>

        <div>
          <div class="section-title">Learning Objective</div>
          <p class="list">
            After interacting with this module you will:
            <ul style="margin:8px 0 0 18px; color:var(--muted);">
              <li>Understand FIFO order (first enqueued, first dequeued).</li>
              <li>Visualize how head and tail move with each operation.</li>
              <li>Observe overflow (when capacity is reached) and underflow (when empty).</li>
            </ul>
          </p>
        </div>

        <div>
          <div class="section-title">Interaction Design</div>
          <p class="list">
            - Users type a value and press "Enqueue" (or Enter). The new node animates into the queue at the tail.<br>
            - Press "Dequeue" to remove the head; the head node animates out and remaining nodes shift left. A short text announcement describes the result.<br>
            - "Peek" highlights the front item without removing it. Invalid actions (enqueue to full queue, dequeue from empty) produce a shake + error message.<br>
            - Capacity can be changed; adjusting lower than current size prevents change unless cleared.<br>
            - Visual feedback includes animated entry/exit, head/tail badges repositioning, color cues for full/empty states, and a live log of operations.
          </p>
        </div>

        <div>
          <div class="section-title">Layout Description</div>
          <p class="list">
            - Two-column layout: left column contains textual guidance and objectives; right column contains the interactive module.<br>
            - Safe area margins: 24 px on all sides of the viewport. Minimum spacing between interactive elements: 16 px.<br>
            - Controls at top of the module (input, buttons, capacity) use horizontal flow and wrap on small screens. The visualization appears below with head/tail badges anchored above the relevant node. A status and operation log are at the bottom.<br>
            - Accessibility: buttons have visible focus styles, inputs accept keyboard Enter, and there's an ARIA live region announcing operations. The layout is responsive: stacks on narrow screens with consistent padding and spacing.
          </p>
        </div>
      </aside>

      <!-- Interactive Module -->
      <section class="module" aria-labelledby="module-title">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div id="module-title" style="font-weight:700">Interactive Queue</div>
          <div class="muted" style="font-size:13px">Capacity is bounded for learning overflow</div>
        </div>

        <!-- Controls -->
        <div class="controls" role="form" aria-label="Queue controls">
          <div class="controls-left" style="gap:var(--gap);">
            <label for="value" class="sr-only">Value to enqueue</label>
            <input id="value" type="text" placeholder="Value (e.g., A, 42)" aria-label="Value to enqueue">
            <button id="enqueueBtn" class="btn" aria-controls="queue-line">Enqueue</button>
            <button id="dequeueBtn" class="btn secondary" aria-controls="queue-line">Dequeue</button>
            <button id="peekBtn" class="btn ghost" aria-controls="queue-line">Peek</button>
          </div>

          <div style="display:flex;gap:var(--gap);align-items:center;">
            <label for="capacity" class="muted">Capacity</label>
            <input id="capacity" type="number" min="1" max="12" value="6" style="width:84px" aria-label="Queue capacity">
            <button id="clearBtn" class="btn secondary" title="Clear all" aria-label="Clear queue">Clear</button>
          </div>
        </div>

        <!-- Visualization -->
        <div class="visual" aria-hidden="false">
          <div class="queue-area" role="region" aria-label="Queue visualization">
            <div class="queue-line" id="queue-line" aria-live="polite" aria-atomic="true"></div>
            <div class="marker head" id="marker-head" style="left:0; display:none;"><span class="dot"></span> head</div>
            <div class="marker tail" id="marker-tail" style="left:0; display:none;"><span class="dot"></span> tail</div>
          </div>

          <div class="status" role="status" aria-live="polite">
            <div class="msg" id="message">Ready — enqueue a value to start</div>
            <div style="display:flex;gap:12px;align-items:center;">
              <div id="stateIndicator" class="indicator" aria-hidden="true">Idle</div>
              <div class="capacity muted" id="capLabel">0 / 6</div>
            </div>
          </div>

          <div class="log" id="log" aria-live="polite" aria-atomic="false">
            <!-- operation log -->
          </div>
        </div>
      </section>
    </div>
  </main>

  <script>
    // Queue interactive module (vanilla JS)
    (function(){
      // DOM
      const valueInput = document.getElementById('value');
      const enqueueBtn = document.getElementById('enqueueBtn');
      const dequeueBtn = document.getElementById('dequeueBtn');
      const peekBtn = document.getElementById('peekBtn');
      const clearBtn = document.getElementById('clearBtn');
      const capacityInput = document.getElementById('capacity');
      const queueLine = document.getElementById('queue-line');
      const messageEl = document.getElementById('message');
      const capLabel = document.getElementById('capLabel');
      const logEl = document.getElementById('log');
      const indicator = document.getElementById('stateIndicator');
      const markerHead = document.getElementById('marker-head');
      const markerTail = document.getElementById('marker-tail');

      // State
      let capacity = parseInt(capacityInput.value, 10) || 6;
      let items = []; // stores objects {value, id}
      let idCounter = 0;

      // Accessibility: live region for announcements
      function announce(text){
        messageEl.textContent = text;
      }

      function addLog(text){
        const time = new Date().toLocaleTimeString();
        const el = document.createElement('div');
        el.textContent = `[${time}] ${text}`;
        logEl.prepend(el);
      }

      function updateCapacityLabel(){
        capLabel.textContent = `${items.length} / ${capacity}`;
        if(items.length === 0){
          indicator.textContent = 'Empty';
          indicator.classList.remove('full');
          indicator.classList.add('empty');
        } else if(items.length >= capacity){
          indicator.textContent = 'Full';
          indicator.classList.add('full');
          indicator.classList.remove('empty');
        } else {
          indicator.textContent = 'Active';
          indicator.classList.remove('full','empty');
          indicator.style.background = 'rgba(255,255,255,0.04)';
          indicator.style.color = 'var(--muted)';
        }
      }

      // Visual helpers
      function createNodeElement(item){
        const node = document.createElement('div');
        node.className = 'node enter';
        node.setAttribute('data-id', item.id);
        node.setAttribute('role', 'listitem');
        node.setAttribute('aria-label', `Item ${item.value}`);
        node.textContent = item.value;
        return node;
      }

      function positionMarkers(){
        // If no items, hide markers
        if(items.length === 0){
          markerHead.style.display = 'none';
          markerTail.style.display = 'none';
          return;
        }
        // get first and last child bounding rect relative to queueLine
        const children = queueLine.children;
        if(children.length === 0){
          markerHead.style.display = 'none';
          markerTail.style.display = 'none';
          return;
        }
        const firstRect = children[0].getBoundingClientRect();
        const lastRect = children[children.length - 1].getBoundingClientRect();
        const containerRect = queueLine.getBoundingClientRect();
        // compute left as percentage relative to queue-line
        const headLeft = (firstRect.left + firstRect.width/2) - containerRect.left;
        const tailLeft = (lastRect.left + lastRect.width/2) - containerRect.left;
        markerHead.style.display = 'flex';
        markerTail.style.display = 'flex';
        markerHead.style.left = headLeft + 'px';
        markerTail.style.left = tailLeft + 'px';
      }

      // Enqueue with animation
      function enqueue(value){
        if(items.length >= capacity){
          // invalid: overflow
          flashInvalid('Queue overflow — cannot enqueue (full).');
          addLog(`ENQUEUE ${value} — FAILED (overflow)`);
          return;
        }
        const id = (++idCounter);
        const item = {value: String(value), id};
        items.push(item);
        const node = createNodeElement(item);
        queueLine.appendChild(node);

        // force reflow then activate transition to animate entrance
        requestAnimationFrame(()=> {
          node.classList.add('node--active');
        });

        // remove enter class after transition completes
        node.addEventListener('transitionend', function te(e){
          if(e.propertyName === 'transform'){
            node.classList.remove('enter','node--active');
            node.removeEventListener('transitionend', te);
          }
        });

        addLog(`ENQUEUE ${value}`);
        announce(`Enqueued ${value}.`);
        updateCapacityLabel();
        positionMarkers();
      }

      // Dequeue with animation
      function dequeue(){
        if(items.length === 0){
          flashInvalid('Queue underflow — nothing to dequeue.');
          addLog('DEQUEUE — FAILED (underflow)');
          return;
        }
        // remove head visually with exit animation
        const child = queueLine.querySelector('.node[data-id]');
        const id = items.shift().id;
        if(child){
          child.classList.add('exit');
          // after transition, remove element
          child.addEventListener('transitionend', function te(){
            child.removeEventListener('transitionend', te);
            if(child.parentNode) child.parentNode.removeChild(child);
            // reposition markers after DOM updates
            positionMarkers();
          });
        }
        addLog('DEQUEUE -> removed head');
        announce('Dequeued head item.');
        updateCapacityLabel();
        positionMarkers();
      }

      // Peek: highlight head temporarily
      function peek(){
        if(items.length === 0){
          flashInvalid('Queue is empty — nothing to peek.');
          addLog('PEEK — FAILED (empty)');
          return;
        }
        const firstNode = queueLine.querySelector('.node');
        if(!firstNode) return;
        firstNode.style.transition = 'box-shadow .18s ease, transform .18s ease';
        const original = firstNode.style.boxShadow;
        firstNode.style.boxShadow = '0 10px 26px rgba(59,130,246,0.35)';
        firstNode.style.transform = 'translateY(-6px)';
        addLog(`PEEK -> ${items[0].value}`);
        announce(`Peek: ${items[0].value}`);
        setTimeout(()=>{
          firstNode.style.boxShadow = '';
          firstNode.style.transform = '';
        }, 520);
      }

      // Clear queue
      function clearQueue(){
        if(items.length === 0){
          addLog('CLEAR -> already empty');
          announce('Queue already empty.');
          return;
        }
        // animate fade out for all nodes
        const nodes = Array.from(queueLine.querySelectorAll('.node'));
        nodes.forEach((n, i) => {
          setTimeout(()=> {
            n.classList.add('exit');
            n.addEventListener('transitionend', function te(){
              n.removeEventListener('transitionend', te);
              if(n.parentNode) n.parentNode.removeChild(n);
            });
          }, i * 40);
        });
        items = [];
        addLog('CLEAR -> emptied queue');
        announce('Cleared queue.');
        updateCapacityLabel();
        positionMarkers();
      }

      // Invalid action feedback (shake + message)
      function flashInvalid(msg){
        announce(msg);
        messageEl.style.color = 'var(--danger)';
        messageEl.textContent = msg;
        queueLine.classList.add('shake');
        setTimeout(()=> {
          queueLine.classList.remove('shake');
          messageEl.style.color = '';
          messageEl.textContent = 'Ready';
        }, 520);
      }

      // event handlers
      enqueueBtn.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if(v === '') {
          valueInput.focus();
          flashInvalid('Please enter a value to enqueue.');
          return;
        }
        enqueue(v);
        valueInput.value = '';
        valueInput.focus();
      });

      dequeueBtn.addEventListener('click', () => {
        dequeue();
      });

      peekBtn.addEventListener('click', () => {
        peek();
      });

      clearBtn.addEventListener('click', () => {
        clearQueue();
      });

      capacityInput.addEventListener('change', () => {
        const newCap = parseInt(capacityInput.value, 10) || 1;
        if(newCap < items.length){
          // can't decrease below current size — reject and notify
          capacityInput.value = capacity;
          flashInvalid('Capacity cannot be less than current size. Clear first to reduce.');
          return;
        }
        capacity = newCap;
        addLog(`Capacity set to ${capacity}`);
        announce(`Capacity set to ${capacity}`);
        updateCapacityLabel();
      });

      // keyboard: Enter in input enqueues
      valueInput.addEventListener('keydown', (e) => {
        if(e.key === 'Enter'){
          enqueueBtn.click();
        }
      });

      // Resize observer to reposition markers when layout changes
      const ro = new ResizeObserver(()=> positionMarkers());
      ro.observe(queueLine);
      window.addEventListener('resize', positionMarkers);

      // Initialize
      updateCapacityLabel();
      positionMarkers();
      addLog('Module ready');

      // For demo: add a couple of initial enqueues silently (optional)
      // enqueue('A'); enqueue('B');
    })();
  </script>
</body>
</html>