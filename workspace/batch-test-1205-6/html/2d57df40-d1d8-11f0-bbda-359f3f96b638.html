<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huffman Coding Demonstration</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #inputText {
            width: 100%;
            height: 100px;
        }
        #result {
            margin-top: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>

<h1>Huffman Coding Demonstration</h1>
<p>Enter text to encode using Huffman coding:</p>
<textarea id="inputText"></textarea>
<button onclick="generateHuffmanCodes()">Generate Huffman Codes</button>

<div id="result"></div>

<script>
    class Node {
        constructor(char, freq) {
            this.char = char;
            this.freq = freq;
            this.left = null;
            this.right = null;
        }
    }

    class MinHeap {
        constructor() {
            this.nodes = [];
        }

        insert(node) {
            this.nodes.push(node);
            this.bubbleUp();
        }

        bubbleUp() {
            let idx = this.nodes.length - 1;
            while (idx > 0) {
                let parentIdx = Math.floor((idx - 1) / 2);
                if (this.nodes[parentIdx].freq <= this.nodes[idx].freq) break;
                [this.nodes[parentIdx], this.nodes[idx]] = [this.nodes[idx], this.nodes[parentIdx]];
                idx = parentIdx;
            }
        }

        remove() {
            const min = this.nodes[0];
            const end = this.nodes.pop();
            if (this.nodes.length > 0) {
                this.nodes[0] = end;
                this.bubbleDown();
            }
            return min;
        }

        bubbleDown() {
            let idx = 0;
            const length = this.nodes.length;
            const element = this.nodes[0];

            while (true) {
                let leftChildIdx = 2 * idx + 1;
                let rightChildIdx = 2 * idx + 2;
                let leftChild, rightChild;
                let swap = null;

                if (leftChildIdx < length) {
                    leftChild = this.nodes[leftChildIdx];
                    if (leftChild.freq < element.freq) {
                        swap = leftChildIdx;
                    }
                }
                if (rightChildIdx < length) {
                    rightChild = this.nodes[rightChildIdx];
                    if (
                        (swap === null && rightChild.freq < element.freq) ||
                        (swap !== null && rightChild.freq < leftChild.freq)
                    ) {
                        swap = rightChildIdx;
                    }
                }
                if (swap === null) break;
                this.nodes[idx] = this.nodes[swap];
                this.nodes[swap] = element;
                idx = swap;
            }
        }

        isEmpty() {
            return this.nodes.length === 0;
        }
    }

    function buildHuffmanTree(text) {
        const frequency = {};
        for (const char of text) {
            frequency[char] = (frequency[char] || 0) + 1;
        }

        const minHeap = new MinHeap();
        for (const [char, freq] of Object.entries(frequency)) {
            minHeap.insert(new Node(char, freq));
        }

        while (minHeap.nodes.length > 1) {
            const left = minHeap.remove();
            const right = minHeap.remove();
            const merged = new Node(null, left.freq + right.freq);
            merged.left = left;
            merged.right = right;
            minHeap.insert(merged);
        }

        return minHeap.remove();
    }

    function generateCodes(node, prefix = "", codes = {}) {
        if (node === null) return;

        if (node.char !== null) {
            codes[node.char] = prefix;
        }

        generateCodes(node.left, prefix + "0", codes);
        generateCodes(node.right, prefix + "1", codes);

        return codes;
    }

    function generateHuffmanCodes() {
        const inputText = document.getElementById("inputText").value;
        if (!inputText) {
            alert("Please enter some text to encode.");
            return;
        }

        const huffmanTree = buildHuffmanTree(inputText);
        const huffmanCodes = generateCodes(huffmanTree);

        let resultHTML = '<h2>Huffman Codes:</h2>';
        resultHTML += '<table><tr><th>Character</th><th>Code</th></tr>';
        for (const char in huffmanCodes) {
            resultHTML += `<tr><td>${char}</td><td>${huffmanCodes[char]}</td></tr>`;
        }
        resultHTML += '</table>';
        resultHTML += `<h3>Encoded Text: </h3><p>${inputText.split('').map(char => huffmanCodes[char]).join('')}</p>`;
        
        document.getElementById("result").innerHTML = resultHTML;
    }
</script>

</body>
</html>