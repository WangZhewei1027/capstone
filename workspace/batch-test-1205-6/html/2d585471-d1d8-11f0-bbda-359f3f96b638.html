<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Nearest Neighbors (KNN) Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <h1>K-Nearest Neighbors (KNN) Demo</h1>
    <p>Click anywhere in the canvas to add a point. The color will indicate the predicted class.</p>
    <p>Current K value: <span id="kValue">3</span></p>
    <input type="number" id="kInput" min="1" value="3" />
    <button id="setK">Set K</button>
    <canvas id="canvas" width="600" height="400"></canvas>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const points = [];
        let k = 3; // default K value
        const colors = ['red', 'blue']; // two classes

        // Draw existing points on the canvas
        function drawPoints() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            points.forEach(point => {
                ctx.fillStyle = point.color;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Function to classify a new point using KNN
        function classifyPoint(newPoint) {
            // Calculate distance from the new point to all existing points
            const distances = points.map(point => ({
                point,
                distance: Math.sqrt(Math.pow(point.x - newPoint.x, 2) + Math.pow(point.y - newPoint.y, 2))
            })).sort((a, b) => a.distance - b.distance);

            // Select K nearest neighbors
            const neighbors = distances.slice(0, k);
            const votes = {};

            // Count votes
            neighbors.forEach(neighbor => {
                const cls = neighbor.point.class;
                if (votes[cls]) {
                    votes[cls]++;
                } else {
                    votes[cls] = 1;
                }
            });

            // Determine the class of the new point based on majority voting
            let predictedClass = null;
            let maxVotes = 0;
            for (const cls in votes) {
                if (votes[cls] > maxVotes) {
                    maxVotes = votes[cls];
                    predictedClass = cls;
                }
            }

            return predictedClass;
        }

        // Add a new point to the canvas and classify it
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Create a new point with random class (0 or 1)
            const classIndex = Math.floor(Math.random() * 2);
            const color = colors[classIndex];
            const newPoint = { x, y, color, class: classIndex };

            // Classify the newly created point
            const predictedClass = classifyPoint(newPoint);
            newPoint.color = colors[predictedClass]; // Set color based on predicted class

            points.push(newPoint);
            drawPoints();
        });

        // Set K value from input
        document.getElementById('setK').onclick = () => {
            k = parseInt(document.getElementById('kInput').value);
            document.getElementById('kValue').innerText = k;
        };

    </script>
</body>
</html>