<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Sort Demonstration</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        input[type="text"] {
            width: 300px;
        }
        button {
            margin-left: 10px;
        }
        #result {
            margin-top: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Topological Sort Demonstration</h1>
    <p>Enter edges of a directed graph (e.g., A --> B, B --> C) as a comma-separated list:</p>
    <input type="text" id="inputEdges" placeholder="e.g., A,B; B,C; A,C">
    <button onclick="performTopologicalSort()">Sort</button>
    <div id="result"></div>

    <script>
        function performTopologicalSort() {
            const input = document.getElementById('inputEdges').value;
            const edges = input.split(';').map(edge => edge.trim());
            const graph = {};
            const inDegree = {};
            const result = [];
            
            // Build the graph and in-degree map
            edges.forEach(edge => {
                const [from, to] = edge.split(',').map(n => n.trim());
                if (!graph[from]) graph[from] = [];
                graph[from].push(to);
                inDegree[to] = (inDegree[to] || 0) + 1;
                if (!inDegree[from]) inDegree[from] = 0; // Ensure all nodes are in inDegree
            });

            const queue = [];
            // Enqueue nodes with no incoming edges (in-degree of 0)
            for (const node in inDegree) {
                if (inDegree[node] === 0) {
                    queue.push(node);
                }
            }

            while (queue.length > 0) {
                const current = queue.shift();
                result.push(current);
                // Reduce the in-degree for each neighbor
                if (graph[current]) {
                    graph[current].forEach(neighbor => {
                        inDegree[neighbor]--;
                        // If in-degree becomes 0, enqueue the neighbor
                        if (inDegree[neighbor] === 0) {
                            queue.push(neighbor);
                        }
                    });
                }
            }

            // Check for cycles: if the result doesn't contain all nodes, there is a cycle
            if (result.length === Object.keys(inDegree).length) {
                document.getElementById('result').innerText = 'Topological Sort: ' + result.join(' -> ');
            } else {
                document.getElementById('result').innerText = 'The graph has a cycle, topological sort is not possible.';
            }
        }
    </script>
</body>
</html>