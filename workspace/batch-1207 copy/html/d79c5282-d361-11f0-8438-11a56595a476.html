<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Adjacency List Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  h1 {
    text-align: center;
  }
  #graphInput, #adjListDisplay, #message {
    max-width: 600px;
    margin: 10px auto;
  }
  textarea {
    width: 100%;
    height: 120px;
    font-family: monospace;
    font-size: 14px;
  }
  button {
    margin-top: 10px;
    padding: 8px 16px;
    font-size: 16px;
  }
  pre {
    background: #f4f4f4;
    padding: 10px;
    border-radius: 5px;
  }
  #visualization {
    margin: 20px auto;
    max-width: 600px;
    text-align: center;
  }
  .node {
    display: inline-block;
    margin: 10px;
    padding: 10px 12px;
    border-radius: 50%;
    background-color: #3498db;
    color: white;
    font-weight: bold;
    position: relative;
  }
  .edge {
    font-size: 12px;
    color: #555;
    margin-top: 5px;
  }
  .adjlist-block {
    margin-bottom: 15px;
  }
</style>
</head>
<body>
<h1>Adjacency List Representation of a Graph</h1>

<div id="graphInput">
<label for="edgeInput">Enter edges (one per line) in the format: <code>node1 node2</code><br>
For undirected graph: edges are assumed bidirectional.<br>
Example:<br>
A B<br>
A C<br>
B D<br>
C D<br>
D E
</label>
<textarea id="edgeInput" placeholder="A B&#10;A C&#10;B D&#10;C D&#10;D E"></textarea>
<br/>
<button id="buildGraphBtn">Build Graph & Show Adjacency List</button>
</div>

<div id="message"></div>

<div id="adjListDisplay"></div>

<script>
  /*
   This script parses a list of edges entered by the user,
   builds an adjacency list for an undirected graph,
   and displays the adjacency list in a readable format.
  */

  const edgeInput = document.getElementById('edgeInput');
  const buildGraphBtn = document.getElementById('buildGraphBtn');
  const adjListDisplay = document.getElementById('adjListDisplay');
  const message = document.getElementById('message');

  function buildAdjacencyList(edges) {
    // edges: Array of [node1, node2]
    const adjList = {};
    edges.forEach(([u, v]) => {
      if (!(u in adjList)) adjList[u] = [];
      if (!(v in adjList)) adjList[v] = [];
      adjList[u].push(v);
      adjList[v].push(u); // for undirected graph
    });
    // Sort adjacency lists for consistent output
    for (const key in adjList) {
      adjList[key].sort();
    }
    return adjList;
  }

  function displayAdjacencyList(adjList) {
    adjListDisplay.innerHTML = '';
    const container = document.createElement('div');
    container.style.fontFamily = 'monospace';
    container.style.whiteSpace = 'pre';

    let output = '';
    for (const node of Object.keys(adjList).sort()) {
      output += node + ' -> ' + adjList[node].join(', ') + '\n';
    }
    const pre = document.createElement('pre');
    pre.textContent = output;
    adjListDisplay.appendChild(pre);
  }

  function parseEdges(inputText) {
    // Parses the input lines into edge pairs
    const lines = inputText.trim().split('\n');
    const edges = [];
    for (const line of lines) {
      if (!line.trim()) continue;
      const parts = line.trim().split(/\s+/);
      if (parts.length !== 2) {
        throw new Error('Invalid edge format on line: "' + line + '". Each line must have exactly two nodes.');
      }
      edges.push(parts);
    }
    return edges;
  }

  buildGraphBtn.addEventListener('click', () => {
    message.textContent = '';
    adjListDisplay.innerHTML = '';
    try {
      const edges = parseEdges(edgeInput.value);
      const adjList = buildAdjacencyList(edges);
      displayAdjacencyList(adjList);
    } catch (e) {
      message.textContent = e.message;
      message.style.color = 'red';
    }
  });
</script>

</body>
</html>