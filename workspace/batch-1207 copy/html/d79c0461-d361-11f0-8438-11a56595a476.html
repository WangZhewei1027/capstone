<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Red-Black Tree Visualization and Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    background-color: #f9fafb;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 {
    margin: 1rem 0 0.25rem 0;
  }
  #controls {
    margin: 0.5rem 0 1rem 0;
  }
  input[type=number] {
    width: 80px;
    padding: 0.3rem 0.5rem;
    font-size: 1.1rem;
  }
  button {
    font-size: 1.1rem;
    padding: 0.4rem 1rem;
    margin-left: 0.5rem;
    cursor: pointer;
  }
  #message {
    margin-top: 0.5rem;
    min-height: 1.2em;
    color: #aa0000;
  }
  svg {
    background-color: white;
    border: 1px solid #ddd;
    border-radius: 0.25rem;
  }
  .node {
    cursor: pointer;
    user-select: none;
    transition: filter 0.3s ease;
  }
  .node:hover {
    filter: drop-shadow(0 0 4px rgba(0,0,0,0.3));
  }
  .red {
    fill: #e53935;
    stroke: #b71c1c;
  }
  .black {
    fill: #212121;
    stroke: #000000;
  }
  .nil {
    fill: #b0bec5;
    stroke: #78909c;
    font-style: italic;
  }
  line.link {
    stroke: #555;
    stroke-width: 2px;
  }
  #explanation {
    max-width: 700px;
    margin: 1rem;
    font-size: 0.95rem;
    line-height: 1.4;
    background: #f0f4f8;
    padding: 1rem 1rem 1rem 1rem;
    border-radius: 5px;
  }
  a {
    color: #1565c0;
  }
</style>
</head>
<body>
<h1>Red-Black Tree Visualization</h1>

<div id="controls">
  <input id="valueInput" type="number" placeholder="Enter value" />
  <button id="insertBtn" title="Insert value">Insert</button>
  <button id="clearBtn" title="Clear tree">Clear Tree</button>
</div>
<div id="message"></div>
<svg id="treeSVG" width="900" height="500" aria-label="Red-Black Tree visualization" role="img"></svg>
<div id="explanation">
  <h2>About Red-Black Trees</h2>
  <p>
    A <strong>Red-Black Tree</strong> is a balanced binary search tree with extra color information for each node (red or black) that maintains the following properties to guarantee balanced height and thus fast operations:
  </p>
  <ul>
    <li>Every node is either red or black.</li>
    <li>The root is black.</li>
    <li>All leaves (<em>nil</em> nodes) are black.</li>
    <li>If a node is red, then both its children are black (no two reds in a row).</li>
    <li>For each node, all paths from the node to its descendant leaves contain the same number of black nodes.</li>
  </ul>
  <p>
    These properties ensure the height remains logarithmic with respect to the number of nodes, providing <code>O(log n)</code> complexity for insertion, deletion, and search.
  </p>
  <p>
    Try inserting values above and watch how the tree balances and colors update.
  </p>
  <p>
    Learn more: <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="noopener">Wikipedia: Red-Black Tree</a>
  </p>
</div>

<script>
// --- Red Black Tree Implementation with Visualization ---

// NIL node singleton to represent leaves
class NILNode {
  constructor() {
    this.color = "black";
    this.isNil = true;
    this.left = null;
    this.right = null;
    this.parent = null;
    this.value = null;
  }
}
const NIL = new NILNode();

class Node {
  constructor(value, color = "red", parent = NIL) {
    this.value = value;
    this.color = color; // 'red' or 'black'
    this.left = NIL;
    this.right = NIL;
    this.parent = parent;
    this.isNil = false;
  }
}

class RedBlackTree {
  constructor() {
    this.root = NIL;
  }

  leftRotate(x) {
    let y = x.right;
    x.right = y.left;
    if (y.left !== NIL) y.left.parent = x;
    y.parent = x.parent;
    if (x.parent === NIL) this.root = y;
    else if (x === x.parent.left) x.parent.left = y;
    else x.parent.right = y;
    y.left = x;
    x.parent = y;
  }

  rightRotate(y) {
    let x = y.left;
    y.left = x.right;
    if (x.right !== NIL) x.right.parent = y;
    x.parent = y.parent;
    if (y.parent === NIL) this.root = x;
    else if (y === y.parent.left) y.parent.left = x;
    else y.parent.right = x;
    x.right = y;
    y.parent = x;
  }

  insert(value) {
    let newNode = new Node(value);
    let y = NIL;
    let x = this.root;

    while (x !== NIL) {
      y = x;
      if (value === x.value) {
        // Duplicate, do not insert
        return false;
      }
      if (value < x.value) x = x.left;
      else x = x.right;
    }

    newNode.parent = y;
    if (y === NIL) this.root = newNode;
    else if (value < y.value) y.left = newNode;
    else y.right = newNode;

    newNode.left = NIL;
    newNode.right = NIL;
    newNode.color = "red";

    this.insertFixup(newNode);
    return true;
  }

  insertFixup(z) {
    while (z.parent.color === "red") {
      if (z.parent === z.parent.parent.left) {
        let y = z.parent.parent.right;
        if (y.color === "red") {
          // Case 1
          z.parent.color = "black";
          y.color = "black";
          z.parent.parent.color = "red";
          z = z.parent.parent;
        } else {
          if (z === z.parent.right) {
            // Case 2
            z = z.parent;
            this.leftRotate(z);
          }
          // Case 3
          z.parent.color = "black";
          z.parent.parent.color = "red";
          this.rightRotate(z.parent.parent);
        }
      } else {
        // Mirror cases
        let y = z.parent.parent.left;
        if (y.color === "red") {
          // Case 1
          z.parent.color = "black";
          y.color = "black";
          z.parent.parent.color = "red";
          z = z.parent.parent;
        } else {
          if (z === z.parent.left) {
            // Case 2
            z = z.parent;
            this.rightRotate(z);
          }
          // Case 3
          z.parent.color = "black";
          z.parent.parent.color = "red";
          this.leftRotate(z.parent.parent);
        }
      }
    }
    this.root.color = "black";
  }

  clear() {
    this.root = NIL;
  }
}

// --- Visualization ---

const svg = document.getElementById("treeSVG");
const width = svg.clientWidth;
const height = svg.clientHeight;
const radius = 18;

function clearSVG() {
  while (svg.firstChild) {
    svg.removeChild(svg.firstChild);
  }
}

// Calculate positions for nodes using in-order traversal and depth
function calcNodePositions(treeRoot) {
  const positions = new Map();
  let maxDepth = 0;

  // We need x positions spaced to avoid node overlap
  // Use an in-order traversal to assign x positions increasing order
  let xCounter = 0;

  function inorder(node, depth) {
    if (node === NIL) return;
    if (depth > maxDepth) maxDepth = depth;
    inorder(node.left, depth + 1);
    positions.set(node, { x: xCounter, depth });
    xCounter++;
    inorder(node.right, depth + 1);
  }

  if (treeRoot === NIL) return { positions, maxDepth: 0 };
  inorder(treeRoot, 0);
  return { positions, maxDepth };
}

function drawTree(tree) {
  clearSVG();
  if (tree.root === NIL) {
    // show empty message or nothing
    return;
  }
  const { positions, maxDepth } = calcNodePositions(tree.root);

  // Compute spacing
  // Horizontal spacing = width / (total nodes + 1)
  const totalNodes = positions.size;
  const hSpacing = width / (totalNodes + 1);
  const vSpacing = height / (maxDepth + 2);

  // Draw edges first (lines)
  positions.forEach((pos, node) => {
    if (node.left !== NIL) {
      drawLine(pos.x * hSpacing + hSpacing, pos.depth * vSpacing + vSpacing, positions.get(node.left).x * hSpacing + hSpacing, positions.get(node.left).depth * vSpacing + vSpacing);
    }
    if (node.right !== NIL) {
      drawLine(pos.x * hSpacing + hSpacing, pos.depth * vSpacing + vSpacing, positions.get(node.right).x * hSpacing + hSpacing, positions.get(node.right).depth * vSpacing + vSpacing);
    }
  });

  // Draw nodes
  positions.forEach((pos, node) => {
    drawNode(pos.x * hSpacing + hSpacing, pos.depth * vSpacing + vSpacing, node);
  });
}

function drawLine(x1, y1, x2, y2) {
  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
  line.setAttribute("x1", x1);
  line.setAttribute("y1", y1);
  line.setAttribute("x2", x2);
  line.setAttribute("y2", y2);
  line.setAttribute("class", "link");
  line.setAttribute("stroke-linecap", "round");
  svg.appendChild(line);
}

function drawNode(cx, cy, node) {
  const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
  group.setAttribute("class", "node");
  group.setAttribute("transform", `translate(${cx},${cy})`);
  group.setAttribute("aria-label", `Node value ${node.value}, color ${node.color}`);
  group.setAttribute("role", "img");

  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("r", radius);
  circle.setAttribute("class", node.color === "red" ? "red" : "black");
  circle.setAttribute("stroke-width", "3");
  group.appendChild(circle);

  const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
  text.setAttribute("text-anchor", "middle");
  text.setAttribute("dominant-baseline", "middle");
  text.setAttribute("fill", node.color === "red" ? "#fff5f5" : "#e0e0e0");
  text.style.fontWeight = "600";
  text.style.userSelect = "none";
  text.textContent = node.value;
  group.appendChild(text);

  svg.appendChild(group);
}

// --- UI Interaction ---

const tree = new RedBlackTree();

const insertBtn = document.getElementById("insertBtn");
const clearBtn = document.getElementById("clearBtn");
const valueInput = document.getElementById("valueInput");
const messageEl = document.getElementById("message");

function showMessage(msg, error = false) {
  messageEl.textContent = msg;
  messageEl.style.color = error ? "#aa0000" : "#007700";
}

insertBtn.addEventListener("click", () => {
  const valStr = valueInput.value.trim();
  if (valStr === "") {
    showMessage("Please enter a value to insert.", true);
    valueInput.focus();
    return;
  }
  const valNum = Number(valStr);
  if (!Number.isInteger(valNum)) {
    showMessage("Only integers are allowed.", true);
    valueInput.focus();
    return;
  }
  const inserted = tree.insert(valNum);
  if (!inserted) {
    showMessage(`Value ${valNum} already exists in the tree.`, true);
  } else {
    showMessage(`Inserted value ${valNum}.`);
  }
  valueInput.value = "";
  valueInput.focus();
  drawTree(tree);
});

clearBtn.addEventListener("click", () => {
  tree.clear();
  clearSVG();
  showMessage("Tree cleared.");
  valueInput.value = "";
  valueInput.focus();
});

// Press Enter in input triggers insert
valueInput.addEventListener("keydown", e => {
  if (e.key === "Enter") {
    insertBtn.click();
  }
});

// Initial message
showMessage("Enter integers and click Insert to add nodes.");

</script>
</body>
</html>