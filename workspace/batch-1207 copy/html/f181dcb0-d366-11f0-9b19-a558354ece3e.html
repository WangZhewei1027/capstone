<!DOCTYPE html>
# Floyd-Warshall Algorithm Demonstration

I've created an interactive visualization of the Floyd-Warshall algorithm that finds the shortest paths between all pairs of nodes in a weighted graph.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floyd-Warshall Algorithm Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .graph-section, .control-section, .matrix-section, .steps-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .canvas-container {
            text-align: center;
        }
        canvas {
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fafafa;
        }
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        button {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .matrix {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .matrix-row {
            display: flex;
            gap: 5px;
            justify-content: center;
        }
        .matrix-cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ddd;
            background-color: #f8f9fa;
            font-weight: bold;
        }
        .matrix-cell.current {
            background-color: #3498db;
            color: white;
        }
        .matrix-cell.updated {
            background-color: #2ecc71;
            color: white;
        }
        .steps {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #f8f9fa;
        }
        .instruction {
            margin-bottom: 10px;
            text-align: center;
            font-style: italic;
            color: #7f8c8d;
        }
        label {
            margin-right: 5px;
        }
        input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>Floyd-Warshall Algorithm Visualization</h1>
    
    <div class="container">
        <div class="graph-section">
            <div class="instruction">Click on the canvas to add nodes. Click and drag between nodes to add edges. Right-click on edges to set weights.</div>
            <div class="canvas-container">
                <canvas id="graphCanvas" width="800" height="400"></canvas>
            </div>
        </div>
        
        <div class="control-section">
            <div class="controls">
                <button id="resetBtn">Reset Graph</button>
                <button id="generateBtn">Generate Random Graph</button>
                <button id="runBtn">Run Algorithm</button>
                <button id="stepBtn" disabled>Step Forward</button>
                <button id="resetAlgoBtn" disabled>Reset Algorithm</button>
                <div>
                    <label for="speedControl">Speed:</label>
                    <input type="number" id="speedControl" min="1" max="10" value="5">
                </div>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #3498db;"></div>
                    <span>Current node being considered</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #2ecc71;"></div>
                    <span>Updated distance</span>
                </div>
            </div>
        </div>
        
        <div class="matrix-section">
            <h3>Distance Matrix</h3>
            <div id="matrixContainer" class="matrix">
                <!-- Matrix will be generated here -->
            </div>
        </div>
        
        <div class="steps-section">
            <h3>Algorithm Steps</h3>
            <div id="stepsContainer" class="steps">
                <!-- Steps will be added here -->
            </div>
        </div>
    </div>

    <script>
        // Graph and algorithm state
        let nodes = [];
        let edges = [];
        let isRunning = false;
        let stepInterval = null;
        let currentStep = 0;
        let distanceMatrix = [];
        let pathMatrix = [];
        let algorithmState = null;

        // DOM elements
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const resetBtn = document.getElementById('resetBtn');
        const generateBtn = document.getElementById('generateBtn');
        const runBtn = document.getElementById('runBtn');
        const stepBtn = document.getElementById('stepBtn');
        const resetAlgoBtn = document.getElementById('resetAlgoBtn');
        const speedControl = document.getElementById('speedControl');
        const matrixContainer = document.getElementById('matrixContainer');
        const stepsContainer = document.getElementById('stepsContainer');

        // Initialize with a simple graph
        initializeDefaultGraph();

        // Event listeners
        resetBtn.addEventListener('click', resetGraph);
        generateBtn.addEventListener('click', generateRandomGraph);
        runBtn.addEventListener('click', toggleAlgorithm);
        stepBtn.addEventListener('click', stepAlgorithm);
        resetAlgoBtn.addEventListener('click', resetAlgorithm);

        // Canvas event listeners for graph creation
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('contextmenu', handleCanvasRightClick);
        canvas.addEventListener('mousedown', startEdgeCreation);
        canvas.addEventListener('mousemove', updateEdgeCreation);
        canvas.addEventListener('mouseup', finishEdgeCreation);

        // Initialize the graph with some nodes and edges
        function initializeDefaultGraph() {
            resetGraph();
            
            // Add some default nodes
            addNode(200, 150);
            addNode(400, 150);
            addNode(300, 300);
            addNode(600, 200);
            
            // Add some default edges
            addEdge(0, 1, 4);
            addEdge(0, 2, 5);
            addEdge(1, 2, 1);
            addEdge(1, 3, 3);
            addEdge(2, 3, 2);
            
            drawGraph();
            initializeAlgorithm();
        }

        // Reset the graph to empty
        function resetGraph() {
            nodes = [];
            edges = [];
            resetAlgorithm();
            drawGraph();
        }

        // Generate a random graph
        function generateRandomGraph() {
            resetGraph();
            
            // Add 5-8 random nodes
            const nodeCount = Math.floor(Math.random() * 4) + 5;
            for (let i = 0; i < nodeCount; i++) {
                const x = 100 + Math.random() * 600;
                const y = 100 + Math.random() * 200;
                addNode(x, y);
            }
            
            // Add random edges (about 1.5 edges per node on average)
            for (let i = 0; i < nodeCount; i++) {
                for (let j = i + 1; j < nodeCount; j++) {
                    if (Math.random() < 0.4) { // 40% chance of having an edge
                        const weight = Math.floor(Math.random() * 10) + 1;
                        addEdge(i, j, weight);
                    }
                }
            }
            
            drawGraph();
            initializeAlgorithm();
        }

        // Add a node to the graph
        function addNode(x, y) {
            nodes.push({ x, y, id: nodes.length });
        }

        // Add an edge to the graph
        function addEdge(from, to, weight) {
            // Check if edge already exists
            if (!edges.some(edge => 
                (edge.from === from && edge.to === to) || 
                (edge.from === to && edge.to === from))) {
                edges.push({ from, to, weight });
            }
        }

        // Draw the graph on the canvas
        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            edges.forEach(edge => {
                const fromNode = nodes[edge.from];
                const toNode = nodes[edge.to];
                
                // Draw line
                ctx.beginPath();
                ctx.moveTo(fromNode.x, fromNode.y);
                ctx.lineTo(toNode.x, toNode.y);
                ctx.strokeStyle = '#34495e';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw weight
                const midX = (fromNode.x + toNode.x) / 2;
                const midY = (fromNode.y + toNode.y) / 2;
                ctx.fillStyle = '#34495e';
                ctx.font = '14px Arial';
                ctx.fillText(edge.weight, midX + 10, midY - 10);
            });
            
            // Draw nodes
            nodes.forEach((node, index) => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
                ctx.fillStyle = '#3498db';
                ctx.fill();
                ctx.strokeStyle = '#2980b9';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw node label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(String.fromCharCode(65 + index), node.x, node.y);
            });
        }

        // Handle canvas clicks for adding nodes
        function handleCanvasClick(e) {
            if (isRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if click is on an existing node
            const clickedNode = nodes.findIndex(node => 
                Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2) <= 20);
            
            if (clickedNode === -1) {
                // Add new node
                addNode(x, y);
                drawGraph();
                initializeAlgorithm();
            }
        }

        // Handle canvas right-clicks for setting edge weights
        function handleCanvasRightClick(e) {
            e.preventDefault();
            if (isRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Find if click is near an edge
            for (let i = 0; i < edges.length; i++) {
                const edge = edges[i];
                const fromNode = nodes[edge.from];
                const toNode = nodes[edge.to];
                
                // Calculate distance from point to line segment
                const A = { x: fromNode.x, y: fromNode.y };
                const B = { x: toNode.x, y: toNode.y };
                const P = { x, y };
                
                const distance = pointToLineDistance(A, B, P);
                
                if (distance < 15) {
                    const newWeight = prompt(`Enter new weight for edge ${String.fromCharCode(65 + edge.from)}-${String.fromCharCode(65 + edge.to)}:`, edge.weight);
                    if (newWeight !== null && !isNaN(newWeight) && newWeight !== '') {
                        edge.weight = parseInt(newWeight);
                        drawGraph();
                        initializeAlgorithm();
                    }
                    break;
                }
            }
        }

        // Calculate distance from point to line segment
        function pointToLineDistance(A, B, P) {
            const AB = { x: B.x - A.x, y: B.y - A.y };
            const AP = { x: P.x - A.x, y: P.y - A.y };
            
            const ab2 = AB.x * AB.x + AB.y * AB.y;
            const ap_ab = AP.x * AB.x + AP.y * AB.y;
            
            let t = ap_ab / ab2;
            t = Math.max(0, Math.min(1, t));
            
            const closest = {
                x: A.x + AB.x * t,
                y: A.y + AB.y * t
            };
            
            return Math.sqrt((P.x - closest.x) ** 2 + (P.y - closest.y) ** 2);
        }

        // Edge creation variables
        let isCreatingEdge = false;
        let edgeStartNode = null;
        let mouseX = 0;
        let mouseY = 0;

        // Start creating an edge
        function startEdgeCreation(e) {
            if (isRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if click is on a node
            const clickedNode = nodes.findIndex(node => 
                Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2) <= 20);
            
            if (clickedNode !== -1) {
                isCreatingEdge = true;
                edgeStartNode = clickedNode;
                mouseX = x;
                mouseY = y;
            }
        }

        // Update edge creation while mouse is moving
        function updateEdgeCreation(e) {
            if (!isCreatingEdge) return;
            
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            
            drawGraph();
            
            // Draw temporary edge
            const startNode = nodes[edgeStartNode];
            ctx.beginPath();
            ctx.moveTo(startNode.x, startNode.y);
            ctx.lineTo(mouseX, mouseY);
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Finish creating an edge
        function finishEdgeCreation(e) {
            if (!isCreatingEdge) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if release is on a node
            const clickedNode = nodes.findIndex(node => 
                Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2) <= 20);
            
            if (clickedNode !== -1 && clickedNode !== edgeStartNode) {
                const weight = prompt(`Enter weight for edge ${String.fromCharCode(65 + edgeStartNode)}-${String.fromCharCode(65 + clickedNode)}:`, "1");
                if (weight !== null && !isNaN(weight) && weight !== '') {
                    addEdge(edgeStartNode, clickedNode, parseInt(weight));
                }
            }
            
            isCreatingEdge = false;
            edgeStartNode = null;
            drawGraph();
            initializeAlgorithm();
        }

        // Initialize the Floyd-Warshall algorithm
        function initializeAlgorithm() {
            const n = nodes.length;
            
            // Initialize distance matrix with Infinity for unconnected nodes
            distanceMatrix = Array(n).fill().map(() => Array(n).fill(Infinity));
            pathMatrix = Array(n).fill().map(() => Array(n).fill(null));
            
            // Set diagonal to 0
            for (let i = 0; i < n; i++) {
                distanceMatrix[i][i] = 0;
                pathMatrix[i][i] = i;
            }
            
            // Set known edge weights
            edges.forEach(edge => {
                distanceMatrix[edge.from][edge.to] = edge.weight;
                distanceMatrix[edge.to][edge.from] = edge.weight;
                pathMatrix[edge.from][edge.to] = edge.to;
                pathMatrix[edge.to][edge.from] = edge.from;
            });
            
            // Reset algorithm state
            algorithmState = {
                k: 0,
                i: 0,
                j: 0,
                n: n
            };
            
            currentStep = 0;
            updateMatrixDisplay();
            updateStepsContainer("Algorithm initialized. Click 'Run Algorithm' to start.");
            enableAlgorithmControls(false);
        }

        // Run one step of the Floyd-Warshall algorithm
        function stepAlgorithm() {
            if (!algorithmState || algorithmState.k >= algorithmState.n) {
                isRunning = false;
                enableAlgorithmControls(false);
                updateStepsContainer("Algorithm completed! All shortest paths found.");
                return;
            }
            
            const { k, i, j, n } = algorithmState;
            currentStep++;
            
            // Update step description
            let stepDescription = `Step ${currentStep}: Checking path from ${String.fromCharCode(65 + i)} to ${String.fromCharCode(65 + j)} via ${String.fromCharCode(65 + k)}. `;
            
            // Check if we can get a shorter path via node k
            const viaK = distanceMatrix[i][k] + distanceMatrix[k][j];
            
            if (