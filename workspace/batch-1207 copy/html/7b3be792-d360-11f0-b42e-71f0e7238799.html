<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bellman-Ford Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            padding: 20px;
        }
        #graph {
            margin: 20px 0;
        }
        table {
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #000;
            padding: 5px 10px;
            text-align: center;
        }
    </style>
</head>
<body>

<h1>Bellman-Ford Algorithm Visualization</h1>
<p>Enter the number of edges and their weights:</p>
<form id="form">
    <label for="numEdges">Number of edges:</label>
    <input type="number" id="numEdges" value="4" min="1" required>
    <button type="submit">Create Edges</button>
</form>

<div id="graph"></div>
<div id="result"></div>
<script>
    document.getElementById('form').addEventListener('submit', function(event) {
        event.preventDefault();
        const numEdges = parseInt(document.getElementById('numEdges').value);
        createEdges(numEdges);
    });

    function createEdges(numEdges) {
        let edges = [];
        const graphDiv = document.getElementById('graph');
        graphDiv.innerHTML = '';

        for (let i = 0; i < numEdges; i++) {
            const edgeInput = document.createElement('div');
            edgeInput.innerHTML = `
                <label>Edge ${i + 1}: </label>
                <input type="text" placeholder="e.g. A B 4 (from to weight)" required>
            `;
            graphDiv.appendChild(edgeInput);
        }

        const calculateButton = document.createElement('button');
        calculateButton.textContent = 'Calculate Shortest Paths';
        calculateButton.addEventListener('click', () => {
            const edges = Array.from(graphDiv.children).map(child => {
                const input = child.querySelector('input').value;
                const parts = input.split(' ');
                return {
                    from: parts[0],
                    to: parts[1],
                    weight: parseInt(parts[2])
                };
            });
            const startVertex = prompt("Enter the starting vertex e.g. A:");
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = '';
            const distances = bellmanFord(edges, startVertex);
            for (const [vertex, distance] of Object.entries(distances)) {
                resultDiv.innerHTML += `Distance from ${startVertex} to ${vertex}: ${distance === Infinity ? 'Infinity' : distance}<br>`;
            }
        });

        graphDiv.appendChild(calculateButton);
    }

    function bellmanFord(edges, start) {
        const distances = {};
        const vertices = new Set();

        // Initialize distances
        edges.forEach(edge => {
            vertices.add(edge.from);
            vertices.add(edge.to);
            distances[edge.from] = Infinity;
            distances[edge.to] = Infinity;
        });
        distances[start] = 0;

        // Relax edges |V| - 1 times
        for (let i = 0; i < vertices.size - 1; i++) {
            edges.forEach(edge => {
                if (distances[edge.from] !== Infinity &&
                    distances[edge.from] + edge.weight < distances[edge.to]) {
                    distances[edge.to] = distances[edge.from] + edge.weight;
                }
            });
        }

        // Check for negative-weight cycles
        edges.forEach(edge => {
            if (distances[edge.from] !== Infinity &&
                distances[edge.from] + edge.weight < distances[edge.to]) {
                throw new Error("Graph contains a negative-weight cycle");
            }
        });

        return distances;
    }
</script>
</body>
</html>