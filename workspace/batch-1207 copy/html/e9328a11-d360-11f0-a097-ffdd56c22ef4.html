<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>HashMap Demo (JavaScript) — Interactive</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 18px; color: #111; }
  h1 { margin: 0 0 8px 0; font-size: 20px; }
  p.lead { margin: 6px 0 18px 0; color: #444; }
  .container { display: flex; gap: 18px; flex-wrap: wrap; }
  .panel { border: 1px solid #ddd; padding: 12px; border-radius: 8px; background: #fafafa; min-width: 320px; }
  label { display:block; margin-top: 8px; font-size: 13px; color: #333; }
  input[type="text"], input[type="number"], select { width: 100%; padding: 8px; margin-top:6px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 6px; }
  button { margin-top: 8px; padding: 8px 10px; border-radius: 6px; border: 1px solid #888; background: #f5f5f5; cursor: pointer; }
  button.primary { background: #007bff; color: white; border-color: #005ecb; }
  .row { display:flex; gap:8px; }
  .meta { font-size: 13px; color: #333; margin-top:8px; display:flex; gap:12px; flex-wrap:wrap; }
  .buckets { display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; }
  .bucket { width: 120px; min-height:36px; border-radius:6px; border:1px solid #ddd; padding:6px; background:#fff; box-sizing:border-box; }
  .bucketHeader { font-weight:600; font-size:12px; color:#333; margin-bottom:6px; display:flex; justify-content:space-between; }
  .entry { padding:6px; border-radius:6px; margin-bottom:6px; font-size:13px; display:flex; justify-content:space-between; gap:8px; background: linear-gradient(180deg,#f7f7ff,#eef1ff); border:1px solid #d0d6ff; }
  .entry.object { background: linear-gradient(180deg,#fff7e6,#fff1d6); border-color:#ffd6a6; }
  .entry .key { color:#044; font-weight:600; }
  .log { height:160px; overflow:auto; border:1px solid #e6e6e6; background:#fff; padding:8px; border-radius:6px; font-family: monospace; font-size:12px; }
  .small { font-size:12px; color:#555; }
  pre.code { max-height: 340px; overflow:auto; background:#0b0c0d; color:#cfe9ff; padding:12px; border-radius:6px; font-size:13px; }
  .controls { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
  .obj-list { margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; }
  .obj-pill { padding:6px 8px; border-radius:12px; background:#efefef; border:1px solid #ddd; font-size:13px; display:flex; gap:8px; align-items:center; }
  .muted { color:#666; font-size:13px; }
  .badge { display:inline-block; padding:2px 6px; border-radius:8px; background:#eee; font-size:12px; border:1px solid #ddd; }
  .footer { margin-top:14px; font-size:13px; color:#555; }
  .grow { flex:1; }
  .example-btns { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
</style>
</head>
<body>
  <h1>HashMap (JS) — Interactive Demo</h1>
  <p class="lead">This page implements a simple HashMap in JavaScript (separate chaining) with collision handling, object keys, automatic resize (rehash), and interactive visualization.</p>

  <div class="container">
    <div class="panel" style="flex:1 1 420px;">
      <strong>Controls</strong>
      <label>Key type
        <select id="keyType">
          <option value="string">String</option>
          <option value="number">Number</option>
          <option value="object">Object (use created object)</option>
        </select>
      </label>

      <label id="keyInputLabel">Key (string)
        <input id="keyInput" type="text" value="foo" />
      </label>

      <label>Value
        <input id="valueInput" type="text" value="bar" />
      </label>

      <div class="controls">
        <button id="putBtn" class="primary">put(key, value)</button>
        <button id="getBtn">get(key)</button>
        <button id="hasBtn">has(key)</button>
        <button id="deleteBtn">delete(key)</button>
        <button id="clearBtn">clear()</button>
      </div>

      <label style="margin-top:12px;">Objects you can use as keys (click to create new object)</label>
      <div class="row">
        <button id="createObjBtn">Create Object Key</button>
        <div class="muted grow" id="objCount">0 objects available</div>
      </div>
      <div class="obj-list" id="objList"></div>

      <div class="example-btns">
        <button id="demoCollide">Demo collisions</button>
        <button id="demoResize">Demo resize rehash</button>
        <button id="demoRandom">Random inserts</button>
      </div>

      <div class="meta">
        <div class="badge">size: <span id="size">0</span></div>
        <div class="badge">capacity: <span id="capacity">8</span></div>
        <div class="badge">loadFactor: <span id="load">0</span></div>
        <div class="badge">rehashes: <span id="rehashes">0</span></div>
      </div>

      <div style="margin-top:12px;">
        <strong>Operation Log</strong>
        <div class="log" id="log"></div>
      </div>
    </div>

    <div class="panel" style="flex:1 1 560px;">
      <strong>Buckets (visual)</strong>
      <div class="small muted">Each bucket is an array (separate chaining). Click an entry to remove it.</div>
      <div class="buckets" id="buckets"></div>

      <div style="margin-top:12px;">
        <strong>Quick Inspect</strong>
        <div class="small">Keys: <span id="keysSummary" class="muted"></span></div>
        <div class="small">Values: <span id="valuesSummary" class="muted"></span></div>
      </div>

      <div style="margin-top:12px;">
        <strong>HashMap Implementation (source)</strong>
        <pre class="code" id="codeBlock"></pre>
      </div>
    </div>
  </div>

<script>
/*
  HashMap implementation (separate chaining).
  - Supports string, number, boolean, undefined, null (treated as primitives)
  - Supports objects by assigning them a hidden unique id symbol (so object identity is preserved)
  - Automatic resize: grows when loadFactor > 0.75, shrinks when loadFactor < 0.20 (min capacity 4)
  - Buckets are arrays of { key, value, hash }
*/

// Unique symbol to tag objects with an id for hashing
const OBJECT_HASH_PROP = Symbol('[[HashMapID]]');

class HashMap {
  constructor(initialCapacity = 8) {
    this._capacity = Math.max(4, initialCapacity | 0);
    this._buckets = Array.from({length: this._capacity}, () => []);
    this._size = 0;
    this._idCounter = 1; // used only for object keys internal ids
    this._rehashCount = 0;
  }

  // Public API

  put(key, value) {
    const hash = this._rawHash(key);
    const idx = this._indexForHash(hash);
    const bucket = this._buckets[idx];

    // find existing entry
    for (let entry of bucket) {
      if (this._keyEquals(entry.key, key)) {
        entry.value = value;
        return; // updated, size unchanged
      }
    }

    // new entry
    bucket.push({key, value, hash});
    this._size++;
    this._ensureCapacityAfterInsert();
  }

  get(key) {
    const hash = this._rawHash(key);
    const bucket = this._buckets[this._indexForHash(hash)];
    for (let entry of bucket) {
      if (this._keyEquals(entry.key, key)) return entry.value;
    }
    return undefined;
  }

  has(key) {
    const hash = this._rawHash(key);
    const bucket = this._buckets[this._indexForHash(hash)];
    for (let entry of bucket) if (this._keyEquals(entry.key, key)) return true;
    return false;
  }

  delete(key) {
    const hash = this._rawHash(key);
    const idx = this._indexForHash(hash);
    const bucket = this._buckets[idx];
    for (let i=0;i<bucket.length;i++) {
      if (this._keyEquals(bucket[i].key, key)) {
        bucket.splice(i,1);
        this._size--;
        this._ensureCapacityAfterDelete();
        return true;
      }
    }
    return false;
  }

  clear() {
    this._buckets = Array.from({length: this._capacity}, () => []);
    this._size = 0;
  }

  keys() {
    const out = [];
    for (let b of this._buckets) for (let e of b) out.push(e.key);
    return out;
  }

  values() {
    const out = [];
    for (let b of this._buckets) for (let e of b) out.push(e.value);
    return out;
  }

  entries() {
    const out = [];
    for (let b of this._buckets) for (let e of b) out.push([e.key,e.value]);
    return out;
  }

  // Private helpers

  _rawHash(key) {
    // Normalizes a key to an integer hash (32-bit)
    const t = typeof key;
    if (t === 'number') {
      // handle NaN
      if (Number.isNaN(key)) return 0;
      // mix bits for floats/large numbers
      let x = key | 0;
      if (x !== key) { // not integer
        // simple float mixing
        x = Math.floor(key * 2654435761) | 0;
      }
      return this._mixBits(x);
    }
    if (t === 'string') {
      return this._stringHash(key);
    }
    if (t === 'boolean') {
      return key ? 1231 : 1237;
    }
    if (key === null || key === undefined) {
      return key === null ? 3 : 7;
    }
    // object (including arrays, functions)
    return this._objectHash(key);
  }

  _stringHash(str) {
    // djb2-ish hashing for strings -> 32-bit int
    let h = 5381;
    for (let i = 0; i < str.length; i++) {
      h = ((h << 5) + h) ^ str.charCodeAt(i); // h * 33 ^ c
    }
    return this._mixBits(h);
  }

  _objectHash(obj) {
    // If object already has assigned id, use it; otherwise assign one.
    if (!Object.prototype.hasOwnProperty.call(obj, OBJECT_HASH_PROP)) {
      // define non-enumerable property
      Object.defineProperty(obj, OBJECT_HASH_PROP, {
        value: this._idCounter++,
        configurable: false,
        enumerable: false,
        writable: false
      });
    }
    return this._mixBits(obj[OBJECT_HASH_PROP]);
  }

  _mixBits(x) {
    // Mix bits to reduce clustering; keep within 32-bit signed int range
    x = x | 0;
    x = ((x >>> 16) ^ x) * 0x45d9f3b;
    x = ((x >>> 16) ^ x) * 0x45d9f3b;
    x = (x >>> 16) ^ x;
    return x | 0;
  }

  _indexForHash(hash) {
    // positive modulo
    const idx = (hash >>> 0) % this._capacity;
    return idx;
  }

  _keyEquals(a, b) {
    // For primitives, === works. For objects we compare their assigned id symbol.
    if (a === b) return true;
    if (a && b && typeof a === 'object' && typeof b === 'object') {
      return a[OBJECT_HASH_PROP] === b[OBJECT_HASH_PROP];
    }
    return false;
  }

  _ensureCapacityAfterInsert() {
    const load = this._size / this._capacity;
    if (load > 0.75) {
      this._resize(this._capacity * 2);
    }
  }

  _ensureCapacityAfterDelete() {
    const load = this._size / this._capacity;
    if (this._capacity > 4 && load < 0.20) {
      this._resize(Math.max(4, Math.floor(this._capacity / 2)));
    }
  }

  _resize(newCapacity) {
    newCapacity = Math.max(4, newCapacity | 0);
    if (newCapacity === this._capacity) return;
    const oldBuckets = this._buckets;
    this._buckets = Array.from({length: newCapacity}, () => []);
    this._capacity = newCapacity;
    this._size = 0;
    for (let b of oldBuckets) {
      for (let e of b) {
        // re-insert preserving same key objects and values
        const idx = this._indexForHash(e.hash);
        this._buckets[idx].push({key: e.key, value: e.value, hash: e.hash});
        this._size++;
      }
    }
    this._rehashCount++;
  }

  // Introspection
  get size() { return this._size; }
  get capacity() { return this._capacity; }
  get loadFactor() { return +(this._size / this._capacity).toFixed(3); }
  get rehashes() { return this._rehashCount; }
  // for visualization
  _rawBuckets() { return this._buckets; }
}


// ---------- Demo UI logic ----------
const map = new HashMap(8);
const logEl = document.getElementById('log');
const bucketsEl = document.getElementById('buckets');
const sizeEl = document.getElementById('size');
const capEl = document.getElementById('capacity');
const loadEl = document.getElementById('load');
const rehashEl = document.getElementById('rehashes');
const keysSummary = document.getElementById('keysSummary');
const valuesSummary = document.getElementById('valuesSummary');
const keyType = document.getElementById('keyType');
const keyInput = document.getElementById('keyInput');
const keyInputLabel = document.getElementById('keyInputLabel');
const valueInput = document.getElementById('valueInput');
const objListEl = document.getElementById('objList');
const objCountEl = document.getElementById('objCount');
const codeBlock = document.getElementById('codeBlock');

let createdObjects = []; // hold references for object keys

function appendLog(text) {
  const now = new Date().toLocaleTimeString();
  logEl.textContent = `[${now}] ${text}\n` + logEl.textContent;
}

// update UI representation of buckets
function render() {
  // meta
  sizeEl.textContent = map.size;
  capEl.textContent = map.capacity;
  loadEl.textContent = map.loadFactor;
  rehashEl.textContent = map.rehashes;

  // buckets
  bucketsEl.innerHTML = '';
  const buckets = map._rawBuckets();
  for (let i = 0; i < buckets.length; i++) {
    const bucket = document.createElement('div');
    bucket.className = 'bucket';
    const header = document.createElement('div');
    header.className = 'bucketHeader';
    header.innerHTML = `#${i} <span class="small muted">(${buckets[i].length})</span>`;
    bucket.appendChild(header);

    if (buckets[i].length === 0) {
      const empty = document.createElement('div');
      empty.className = 'small muted';
      empty.textContent = 'empty';
      bucket.appendChild(empty);
    } else {
      for (let entry of buckets[i]) {
        const e = document.createElement('div');
        e.className = 'entry' + (typeof entry.key === 'object' ? ' object' : '');
        e.title = 'hash: ' + entry.hash;
        const k = document.createElement('div');
        k.className = 'key';
        k.textContent = prettyKey(entry.key);
        const v = document.createElement('div');
        v.className = 'val';
        v.textContent = String(entry.value);
        e.appendChild(k);
        e.appendChild(v);
        // clicking entry deletes it
        e.addEventListener('click', () => {
          const ok = confirm('Delete entry with key ' + prettyKey(entry.key) + '?');
          if (ok) {
            const removed = map.delete(entry.key);
            appendLog('delete(' + prettyKey(entry.key) + ') => ' + removed);
            render();
          }
        });
        bucket.appendChild(e);
      }
    }
    bucketsEl.appendChild(bucket);
  }

  // summaries
  keysSummary.textContent = map.keys().map(k => prettyKey(k)).slice(0,10).join(', ') || '—';
  valuesSummary.textContent = map.values().slice(0,10).map(v => String(v)).join(', ') || '—';

  // code view
  codeBlock.textContent = HashMap.toString(); // show source of class (approx)
}

// pretty key representation
function prettyKey(k) {
  if (typeof k === 'string') return '"' + k + '"';
  if (typeof k === 'number') return String(k);
  if (k === null) return 'null';
  if (k === undefined) return 'undefined';
  if (typeof k === 'object') {
    return 'Object#' + (k[OBJECT_HASH_PROP] || '?');
  }
  return String(k);
}

// UI wired actions
document.getElementById('putBtn').addEventListener('click', () => {
  const key = readKeyInput();
  const value = valueInput.value;
  map.put(key, value);
  appendLog('put(' + prettyKey(key) + ', "' + value + '")');
  render();
});

document.getElementById('getBtn').addEventListener('click', () => {
  const key = readKeyInput();
  const v = map.get(key);
  appendLog('get(' + prettyKey(key) + ') => ' + (v === undefined ? 'undefined' : JSON.stringify(v)));
  render();
});

document.getElementById('hasBtn').addEventListener('click', () => {
  const key = readKeyInput();
  const h = map.has(key);
  appendLog('has(' + prettyKey(key) + ') => ' + h);
  render();
});

document.getElementById('deleteBtn').addEventListener('click', () => {
  const key = readKeyInput();
  const d = map.delete(key);
  appendLog('delete(' + prettyKey(key) + ') => ' + d);
  render();
});

document.getElementById('clearBtn').addEventListener('click', () => {
  map.clear();
  appendLog('clear()');
  render();
});

keyType.addEventListener('change', () => {
  const t = keyType.value;
  if (t === 'string') {
    keyInputLabel.textContent = 'Key (string)';
    keyInput.type = 'text';
    keyInput.value = 'foo';
  } else if (t === 'number') {
    keyInputLabel.textContent = 'Key (number)';
    keyInput.type = 'number';
    keyInput.value = '42';
  } else {
    keyInputLabel.textContent = 'Choose an object key from list below';
    keyInput.type = 'text';
    keyInput.value = '';
  }
});

document.getElementById('createObjBtn').addEventListener('click', () => {
  // create a random object with a display property
  const obj = { createdAt: new Date().toLocaleTimeString(), seed: Math.floor(Math.random() * 10000) };
  // attach an accessor (this will assign the object's hidden id when we inspect it internally in map)
  createdObjects.push(obj);
  refreshObjList();
  appendLog('Created new object for use as key: ' + JSON.stringify(obj));
});

function refreshObjList() {
  objListEl.innerHTML = '';
  objCountEl.textContent = createdObjects.length + ' objects available';
  createdObjects.forEach((o, i) => {
    const pill = document.createElement('div');
    pill.className = 'obj-pill';
    pill.textContent = 'Object[' + i + ']';
    const btnSet = document.createElement('button'); btnSet.textContent = 'use'; btnSet.style.padding='4px 6px';
    const btnInfo = document.createElement('button'); btnInfo.textContent = 'inspect'; btnInfo.style.padding='4px 6px';
    pill.appendChild(btnSet); pill.appendChild(btnInfo);
    btnSet.addEventListener('click', () => {
      // set selection to this object
      keyType.value = 'object';
      keyType.dispatchEvent(new Event('change'));
      // store the index in input field so readKeyInput can find it
      keyInput.value = String(i);
      appendLog('Selected object['+i+'] as key');
    });
    btnInfo.addEventListener('click', () => {
      alert('Object['+i+'] = ' + JSON.stringify(o) + '\\n(internal id: ' + (o[OBJECT_HASH_PROP]||'(not set)') + ')');
    });
    objListEl.appendChild(pill);
  });
}

function readKeyInput() {
  const t = keyType.value;
  if (t === 'string') return String(keyInput.value);
  if (t === 'number') return Number(keyInput.value);
  if (t === 'object') {
    const idx = Number(keyInput.value);
    if (!Number.isFinite(idx) || idx < 0 || idx >= createdObjects.length) {
      alert('Invalid object index. Create objects and choose one.');
      throw new Error('invalid object index');
    }
    return createdObjects[idx];
  }
  return keyInput.value;
}

// Example demos
document.getElementById('demoCollide').addEventListener('click', () => {
  // Create several strings that intentionally collide for small table sizes by manipulating characters.
  // We will reset map to small capacity to force collisions.
  map._resize(4);
  map.clear();
  appendLog('Demo collisions: resized to capacity 4 and inserting keys that often collide.');
  const keys = ['a','b','c','d','e','f','g','h','aa','bb','cc','ab','ba'];
  keys.forEach((k,i) => {
    map.put(k, 'val'+i);
  });
  render();
});

document.getElementById('demoResize').addEventListener('click', () => {
  map._resize(4);
  map.clear();
  appendLog('Demo resize: start with capacity 4 and insert many entries to trigger grow.');
  for (let i=0;i<30;i++) map.put('k'+i, 'v'+i);
  appendLog('Inserted 30 entries; map should have resized multiple times.');
  render();
});

document.getElementById('demoRandom').addEventListener('click', () => {
  map._resize(8);
  map.clear();
  appendLog('Random demo: inserting 12 random entries (mix of numbers/strings/objects).');
  // create some objects too
  for (let i=0;i<4;i++) {
    const o = { seed: Math.random(), i };
    createdObjects.push(o);
  }
  refreshObjList();
  for (let i=0;i<12;i++) {
    const r = Math.random();
    if (r < 0.33) map.put('s' + (Math.floor(Math.random()*100)), 'str'+i);
    else if (r < 0.66) map.put(i, 'num' + i);
    else {
      const o = createdObjects[Math.floor(Math.random()*createdObjects.length)];
      map.put(o, 'obj'+i);
    }
  }
  render();
});

// Clicking entries removes them (wired in render)

// initialize
render();
appendLog('HashMap initialized.');

// Display HashMap code exemplar (trimmed, show essential methods)
(function showCodeText() {
  const code = `// HashMap (separate chaining) - essential methods
class HashMap {
  constructor(initialCapacity = 8) { ... }

  put(key, value) {
    const hash = this._rawHash(key);
    const idx = this._indexForHash(hash);
    const bucket = this._buckets[idx];
    for (let entry of bucket) {
      if (this._keyEquals(entry.key, key)) { entry.value = value; return; }
    }
    bucket.push({key, value, hash});
    this._size++;
    if (this._size / this._capacity > 0.75) this._resize(this._capacity * 2);
  }

  get(key) { ... } // find bucket by hash and compare keys
  delete(key) { ... } // remove from bucket, possibly shrink
  // hashing: numbers, strings (djb2-like), and objects (assign hidden id)
}`;
  codeBlock.textContent = code;
})();

</script>
</body>
</html>