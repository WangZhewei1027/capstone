<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Stack Visualization & Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#3b82f6;
      --accent-2:#06b6d4;
      --muted:#94a3b8;
      --success:#10b981;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{background:linear-gradient(180deg,#071025 0%, #07182a 60%); color:#e6eef8; display:flex; align-items:flex-start; justify-content:center; padding:28px;}
    .container{width:1100px;max-width:96%; display:grid; grid-template-columns:360px 1fr; gap:22px;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:18px; border-radius:12px; box-shadow: 0 6px 30px rgba(2,6,23,0.6);}
    h1{margin:0 0 8px;font-size:18px;}
    p.desc{margin:8px 0 12px;color:var(--muted);font-size:13px;line-height:1.3;}
    .controls{display:flex;flex-direction:column;gap:10px;}
    .row{display:flex;gap:8px;align-items:center;}
    input[type="text"], input[type="number"], select{
      background:var(--glass); border:1px solid rgba(255,255,255,0.04); color:inherit; padding:8px 10px; border-radius:8px; outline:none; width:100%;
    }
    button{
      background:linear-gradient(180deg,var(--accent), #2563eb);
      color:white; border:0; padding:9px 12px; border-radius:8px; cursor:pointer; font-weight:600;
      box-shadow: 0 6px 18px rgba(59,130,246,0.12);
    }
    button.alt{background:linear-gradient(180deg,#111827,#0b1220); border:1px solid rgba(255,255,255,0.03);}
    button.warn{background:linear-gradient(180deg,var(--danger), #dc2626);}
    .muted{color:var(--muted); font-size:13px;}
    .visual{
      padding:18px; display:flex; gap:18px; align-items:flex-start; min-height:420px;
    }
    .stack-viewport{
      width:180px; min-height:320px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015)); border-radius:10px; padding:12px; border:1px dashed rgba(255,255,255,0.03);
      display:flex; flex-direction:column; align-items:center; position:relative;
    }
    .stack-title{font-size:13px;color:var(--muted); margin-bottom:6px;}
    .stack-container{display:flex; flex-direction:column-reverse; gap:8px; width:100%; align-items:center; padding:6px;}
    .slot{
      width:100%; height:44px; border-radius:8px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03);
      display:flex; align-items:center; justify-content:center; color:#dbeafe; font-weight:700; letter-spacing:0.6px; position:relative; overflow:hidden;
      transition:transform .28s cubic-bezier(.2,.9,.3,1), opacity .25s ease;
    }
    .slot.empty{color:var(--muted); font-weight:600; background:transparent; border:1px dashed rgba(255,255,255,0.02);}
    .slot.top{box-shadow:inset 0 1px 0 rgba(255,255,255,0.03), 0 6px 18px rgba(59,130,246,0.08); border:1px solid rgba(59,130,246,0.18); background:linear-gradient(180deg, rgba(59,130,246,0.08), rgba(59,130,246,0.03));}
    .label-top{position:absolute; top:8px; left:12px; font-size:12px; color:var(--muted);}
    .array-view{
      flex:1; min-height:320px; padding:12px; background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02)); border-radius:8px; border:1px solid rgba(255,255,255,0.02);
      overflow:auto;
    }
    .array-row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .cell{
      width:72px; height:56px; border-radius:8px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03);
      display:flex; flex-direction:column; align-items:center; justify-content:center; color:#bfe0ff; font-weight:700; position:relative;
      transition:transform .25s ease, box-shadow .2s;
    }
    .cell.index{font-size:11px; color:var(--muted); position:absolute; top:6px; right:6px; font-weight:600;}
    .cell.empty{color:var(--muted); font-weight:600; background:transparent; border:1px dashed rgba(255,255,255,0.02);}
    .cell.top{box-shadow:0 10px 30px rgba(59,130,246,0.06); border:1px solid rgba(59,130,246,0.14);}
    .log{margin-top:12px; max-height:120px; overflow:auto; font-size:13px; color:var(--muted); background:rgba(255,255,255,0.01); padding:10px; border-radius:8px; border:1px dashed rgba(255,255,255,0.02);}
    .status{display:flex; gap:8px; align-items:center; margin-top:8px;}
    .pill{padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.02); color:var(--muted); border:1px solid rgba(255,255,255,0.02); font-weight:600;}
    .hint{font-size:12px;color:var(--muted); margin-top:10px;}
    .small{font-size:13px;color:var(--muted);}
    .controls .row > * {flex:1;}
    .sequence-input{height:44px;}
    footer{margin-top:12px;color:var(--muted);font-size:13px;}
    .danger-text{color:var(--danger); font-weight:700;}
    /* animation classes */
    .anim-push{transform: translateY(-10px) scale(1.02); opacity:0; animation:pushIn .32s forwards;}
    .anim-pop{transform:translateY(0) scale(1); animation:popOut .28s forwards;}
    @keyframes pushIn{
      0%{transform: translateY(-40px) scale(.95); opacity:0;}
      100%{transform: translateY(0) scale(1); opacity:1;}
    }
    @keyframes popOut{
      0%{transform: translateY(0) scale(1); opacity:1;}
      100%{transform: translateY(-30px) scale(.95); opacity:0;}
    }
    .controls .small-note{font-size:12px;color:var(--muted); margin-left:6px;}
    .grid-two{display:grid;grid-template-columns:1fr 1fr;gap:8px;}
  </style>
</head>
<body>
  <main class="container">
    <section class="card">
      <h1>Stack — push, pop, peek</h1>
      <p class="desc">This interactive demo shows a stack (LIFO — Last In First Out). Try pushing values, popping, peeking, and run sequences. The visualization shows the stack vertically and the underlying array with indices.</p>

      <div class="controls">
        <div class="row">
          <input id="valueInput" type="text" placeholder="Value to push (any text)" />
          <button id="pushBtn">Push</button>
        </div>

        <div class="row">
          <button id="popBtn" class="alt">Pop</button>
          <button id="peekBtn" class="alt">Peek</button>
        </div>

        <div class="row">
          <button id="clearBtn" class="alt">Clear</button>
          <button id="isEmptyBtn" class="alt">Is Empty?</button>
        </div>

        <div class="row">
          <input id="capacityInput" type="number" min="0" placeholder="Optional capacity (0 = unlimited)" />
          <button id="setCapBtn" class="alt">Set Capacity</button>
        </div>

        <div class="row">
          <input id="fillCount" type="number" min="1" placeholder="Random fill count" />
          <button id="fillBtn" class="alt">Fill Random</button>
        </div>

        <div style="display:flex; gap:8px;">
          <button id="exampleSeqBtn" class="alt">Load Example Sequence</button>
          <button id="runSeqBtn">Run Sequence</button>
        </div>

        <textarea id="sequenceInput" class="sequence-input" placeholder="Sequence (one command per line). Commands: push <value>, pop, peek, clear, wait <ms>. Example:&#10;push apple&#10;push banana&#10;pop&#10;peek" ></textarea>

        <div class="status">
          <div class="pill">Size: <span id="sizeLabel">0</span></div>
          <div class="pill">Top index: <span id="topLabel">-1</span></div>
          <div class="pill">Capacity: <span id="capLabel">∞</span></div>
        </div>

        <div class="hint">Tip: Use "wait <ms>" in a sequence to pause between operations (e.g., wait 500).</div>
      </div>

      <div class="log" id="logArea" aria-live="polite"></div>
      <footer>
        Time complexity: push/pop O(1) average. This demo uses an array internally and supports optional fixed capacity to model overflow.
      </footer>
    </section>

    <section class="card">
      <div class="visual">
        <div class="stack-viewport" aria-hidden="false">
          <div class="stack-title">Stack (Top at top)</div>
          <div class="label-top">Top</div>
          <div class="stack-container" id="stackContainer" role="list"></div>
        </div>

        <div class="array-view">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="font-weight:700;">Underlying array (index -> value)</div>
            <div class="small">Empty cells are dashed</div>
          </div>
          <div id="arrayRow" class="array-row" style="margin-top:12px;"></div>

          <div class="small" style="margin-top:12px;">Operation log (most recent at bottom):</div>
          <div id="opLog" class="log"></div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Stack implementation with visualization hooks.
    class Stack {
      constructor(capacity = 0) {
        this._arr = [];       // underlying array
        this._top = -1;       // top index
        this.capacity = capacity || 0; // 0 means unlimited
      }

      push(value) {
        if (this.capacity > 0 && this._arr.length >= this.capacity) {
          throw new Error('Stack overflow: capacity reached');
        }
        this._arr.push(value);
        this._top = this._arr.length - 1;
        return this._top;
      }

      pop() {
        if (this.isEmpty()) {
          throw new Error('Stack underflow: stack is empty');
        }
        const val = this._arr.pop();
        this._top = this._arr.length - 1;
        return val;
      }

      peek() {
        if (this.isEmpty()) {
          throw new Error('Stack is empty');
        }
        return this._arr[this._top];
      }

      size() {
        return this._arr.length;
      }

      isEmpty() {
        return this._arr.length === 0;
      }

      clear() {
        this._arr.length = 0;
        this._top = -1;
      }

      elements() {
        // return a shallow copy for safe rendering
        return this._arr.slice();
      }
    }

    // UI Elements
    const valueInput = document.getElementById('valueInput');
    const pushBtn = document.getElementById('pushBtn');
    const popBtn = document.getElementById('popBtn');
    const peekBtn = document.getElementById('peekBtn');
    const clearBtn = document.getElementById('clearBtn');
    const isEmptyBtn = document.getElementById('isEmptyBtn');
    const capacityInput = document.getElementById('capacityInput');
    const setCapBtn = document.getElementById('setCapBtn');
    const fillCount = document.getElementById('fillCount');
    const fillBtn = document.getElementById('fillBtn');
    const stackContainer = document.getElementById('stackContainer');
    const arrayRow = document.getElementById('arrayRow');
    const sizeLabel = document.getElementById('sizeLabel');
    const topLabel = document.getElementById('topLabel');
    const capLabel = document.getElementById('capLabel');
    const logArea = document.getElementById('logArea');
    const opLog = document.getElementById('opLog');
    const sequenceInput = document.getElementById('sequenceInput');
    const exampleSeqBtn = document.getElementById('exampleSeqBtn');
    const runSeqBtn = document.getElementById('runSeqBtn');

    // Initialize stack
    const stack = new Stack(0);
    updateUI();

    function log(message, isError = false) {
      const time = new Date().toLocaleTimeString();
      const el = document.createElement('div');
      el.textContent = `[${time}] ${message}`;
      if (isError) el.style.color = 'var(--danger)';
      logArea.appendChild(el);
      logArea.scrollTop = logArea.scrollHeight;

      const op = document.createElement('div');
      op.textContent = message;
      opLog.appendChild(op);
      opLog.scrollTop = opLog.scrollHeight;
    }

    function updateUI(animType) {
      // Update labels
      sizeLabel.textContent = stack.size();
      topLabel.textContent = stack.size() - 1;
      capLabel.textContent = stack.capacity > 0 ? stack.capacity : '∞';

      // Render stack vertical slots (show max of current size or a minimum number)
      const displayCount = Math.max(6, stack.size()); // always show at least 6 slots for context
      stackContainer.innerHTML = '';
      // Build slots bottom-up (we use column-reverse styling, so iterate low->high)
      for (let i = 0; i < displayCount; i++) {
        const slot = document.createElement('div');
        slot.className = 'slot empty';
        const realIndex = i; // 0 is bottom as we render reversed via CSS
        // compute corresponding stack index from bottom: bottom index is 0; top index is size-1
        const arrIndex = realIndex; // since container is column-reverse, the visual top corresponds to last element
        const fromTopIndex = displayCount - 1 - i; // not used directly
        // We want to show top at top — easier: render actual stack values into slots from top downward
        // Instead, rebuild using stack elements directly:
        stackContainer.innerHTML = ''; // we'll rebuild differently
        break;
      }

      // Rebuild slots properly: top at top
      const values = stack.elements();
      const minSlots = 6;
      const totalSlots = Math.max(minSlots, values.length);
      // We want top at top; CSS uses column-reverse, so append from bottom to top
      for (let i = 0; i < totalSlots; i++) {
        const slot = document.createElement('div');
        // index from bottom: 0..totalSlots-1
        const fromBottom = i;
        slot.className = 'slot';
        // map to value index: top is values.length-1 -> should be first visually. Since column-reverse,
        // we need to append from bottom to top: so bottom should be index 0 into values.
        const valueIndex = fromBottom; // bottom corresponds to values[0]
        if (valueIndex < values.length) {
          slot.textContent = values[valueIndex];
          if (valueIndex === values.length - 1) slot.classList.add('top');
          else slot.classList.remove('empty');
        } else {
          slot.textContent = '';
          slot.classList.add('empty');
        }
        // Add animation classes if provided
        stackContainer.appendChild(slot);
      }

      // Add a "Top" label at the visual topmost slot
      const topLabels = stackContainer.querySelectorAll('.label-top');
      // ensure top visual marking
      Array.from(stackContainer.children).forEach((el, idx) => {
        el.style.order = ''; // reset
      });

      // Highlight the top slot visually (top value is last element). Top in DOM is last child because column-reverse
      // Use CSS class .top already set.

      // Render array view horizontally: indices and values
      arrayRow.innerHTML = '';
      const arrValues = stack.elements();
      const arrDisplayCount = Math.max(8, arrValues.length); // show at least 8 cells for context
      for (let i = 0; i < arrDisplayCount; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        const idx = document.createElement('div');
        idx.className = 'index';
        idx.textContent = i;
        const val = document.createElement('div');
        if (i < arrValues.length) {
          val.textContent = arrValues[i];
          cell.classList.add('cell-filled');
          if (i === arrValues.length - 1) cell.classList.add('top');
        } else {
          val.textContent = '';
          cell.classList.add('empty');
        }
        cell.appendChild(idx);
        cell.appendChild(val);
        arrayRow.appendChild(cell);
      }

      // Brief visual feedback if animType set
      if (animType === 'push') {
        // animate the top slot with .anim-push
        const slots = stackContainer.querySelectorAll('.slot');
        // The top value is the last filled slot: find last non-empty
        for (let i = slots.length - 1; i >= 0; i--) {
          if (!slots[i].classList.contains('empty')) {
            slots[i].classList.add('anim-push');
            setTimeout(()=>slots[i].classList.remove('anim-push'), 700);
            break;
          }
        }
      } else if (animType === 'pop') {
        // animate the slot that was removed: we can mark the first empty from top
        const slots = stackContainer.querySelectorAll('.slot');
        // find the first empty from top (last element visually)
        for (let i = slots.length - 1; i >= 0; i--) {
          if (slots[i].classList.contains('empty')) {
            // animate the one below it (the one that was popped)
            if (i - 1 >= 0) {
              const popped = slots[i - 1];
              popped.classList.add('anim-pop');
              setTimeout(()=>popped.classList.remove('anim-pop'), 400);
            }
            break;
          }
        }
      }
    }

    // Hook up buttons
    pushBtn.addEventListener('click', () => {
      const v = valueInput.value.trim();
      if (v === '') {
        valueInput.focus();
        return;
      }
      try {
        stack.push(v);
        log(`push("${v}")`);
        updateUI('push');
        valueInput.value = '';
        valueInput.focus();
      } catch (e) {
        log(e.message, true);
        flashCapacity();
      }
    });

    popBtn.addEventListener('click', () => {
      try {
        const v = stack.pop();
        log(`pop() -> "${v}"`);
        updateUI('pop');
      } catch (e) {
        log(e.message, true);
      }
    });

    peekBtn.addEventListener('click', () => {
      try {
        const v = stack.peek();
        log(`peek() -> "${v}"`);
        // small visual highlight: briefly add class to top cell
        const slots = stackContainer.querySelectorAll('.slot');
        for (let i = slots.length - 1; i >= 0; i--) {
          if (!slots[i].classList.contains('empty')) {
            slots[i].style.boxShadow = '0 10px 30px rgba(8,145,178,0.12)';
            setTimeout(()=>slots[i].style.boxShadow = '', 500);
            break;
          }
        }
      } catch (e) {
        log(e.message, true);
      }
    });

    clearBtn.addEventListener('click', () => {
      stack.clear();
      log('clear() -> stack emptied');
      updateUI();
    });

    isEmptyBtn.addEventListener('click', () => {
      const res = stack.isEmpty();
      log(`isEmpty() -> ${res}`);
    });

    setCapBtn.addEventListener('click', () => {
      const n = parseInt(capacityInput.value, 10);
      if (isNaN(n) || n < 0) {
        log('Capacity must be a non-negative integer', true);
        return;
      }
      if (n > 0 && n < stack.size()) {
        log('New capacity is smaller than current size. Elements will remain but pushes will overflow.', true);
      }
      stack.capacity = n;
      log(`capacity set to ${n > 0 ? n : '∞'}`);
      updateUI();
    });

    fillBtn.addEventListener('click', () => {
      const n = parseInt(fillCount.value, 10);
      if (isNaN(n) || n <= 0) {
        log('Fill count must be a positive integer', true);
        return;
      }
      const items = generateRandomArray(n);
      try {
        for (const it of items) {
          stack.push(it);
        }
        log(`Filled ${n} random items`);
        updateUI('push');
      } catch (e) {
        log(e.message, true);
      }
    });

    exampleSeqBtn.addEventListener('click', () => {
      sequenceInput.value = [
        'push apple',
        'push banana',
        'push cherry',
        'peek',
        'pop',
        'push date',
        'push eggfruit',
        'wait 600',
        'pop',
        'pop',
        'peek'
      ].join('\n');
    });

    // Sequence runner: supports commands line by line
    runSeqBtn.addEventListener('click', async () => {
      const raw = sequenceInput.value.split('\n').map(l=>l.trim()).filter(l=>l);
      if (raw.length === 0) {
        log('Sequence is empty', true);
        return;
      }
      runSeqBtn.disabled = true;
      exampleSeqBtn.disabled = true;
      try {
        for (const line of raw) {
          const parts = line.split(/\s+/);
          const cmd = parts[0].toLowerCase();
          if (cmd === 'push') {
            const val = line.substring(5).trim();
            if (!val) {
              log('push requires a value', true);
            } else {
              try {
                stack.push(val);
                log(`push("${val}")`);
                updateUI('push');
              } catch (e) {
                log(e.message, true);
              }
            }
            await sleep(180);
          } else if (cmd === 'pop') {
            try {
              const v = stack.pop();
              log(`pop() -> "${v}"`);
              updateUI('pop');
            } catch (e) {
              log(e.message, true);
            }
            await sleep(300);
          } else if (cmd === 'peek') {
            try {
              const v = stack.peek();
              log(`peek() -> "${v}"`);
              // visual peek highlight
              const slots = stackContainer.querySelectorAll('.slot');
              for (let i = slots.length - 1; i >= 0; i--) {
                if (!slots[i].classList.contains('empty')) {
                  slots[i].style.boxShadow = '0 10px 30px rgba(8,145,178,0.12)';
                  setTimeout(()=>slots[i].style.boxShadow = '', 400);
                  break;
                }
              }
            } catch (e) {
              log(e.message, true);
            }
            await sleep(260);
          } else if (cmd === 'clear') {
            stack.clear();
            log('clear()');
            updateUI();
            await sleep(180);
          } else if (cmd === 'wait') {
            const ms = parseInt(parts[1]||'0',10) || 0;
            log(`wait ${ms}ms`);
            await sleep(ms);
          } else {
            log(`Unknown command: ${line}`, true);
          }
        }
      } finally {
        runSeqBtn.disabled = false;
        exampleSeqBtn.disabled = false;
      }
    });

    // Helpers
    function generateRandomArray(n) {
      const words = ['alpha','beta','gamma','delta','epsilon','one','two','three','four','apple','banana','cherry','date','kiwi','mango','zeta'];
      const out = [];
      for (let i=0;i<n;i++){
        out.push(words[Math.floor(Math.random()*words.length)] + (Math.random()*100|0));
      }
      return out;
    }

    function sleep(ms){ return new Promise(resolve=>setTimeout(resolve, ms)); }

    function flashCapacity() {
      // small visual flash on capacity label
      const orig = capLabel.style.color;
      capLabel.style.color = 'var(--danger)';
      setTimeout(()=>capLabel.style.color = orig, 800);
    }

    // Add keyboard shortcuts: Enter in input pushes
    valueInput.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter') {
        ev.preventDefault();
        pushBtn.click();
      }
    });

    // Initial helpful message
    log('Demo ready — push values to the stack. Try the example sequence.');

    // Accessibility: make stack container announce changes
    const obs = new MutationObserver(()=> {
      stackContainer.setAttribute('aria-label', `Stack with ${stack.size()} elements. Top index ${stack.size()-1}.`);
    });
    obs.observe(stackContainer, {childList:true, subtree:true});

    // Ensure UI sync on load
    updateUI();

    // Extra: support clicking on array cell to mimic popping until that index (exploratory)
    arrayRow.addEventListener('click', (e) => {
      const cell = e.target.closest('.cell');
      if (!cell) return;
      const idxLabel = cell.querySelector('.index');
      if (!idxLabel) return;
      const idx = parseInt(idxLabel.textContent, 10);
      // If clicked index is the top, pop once
      if (idx === stack.size() - 1) {
        popBtn.click();
      } else if (idx < stack.size()) {
        // pop repeatedly until that index becomes top (simulate multiple pops)
        const toPop = stack.size() - 1 - idx;
        if (toPop > 0 && confirm(`Pop ${toPop} item(s) to make index ${idx} the top?`)) {
          for (let i=0;i<toPop;i++) {
            try { stack.pop(); log('pop()'); } catch(e){ log(e.message,true); break; }
          }
          updateUI('pop');
        }
      }
    });
  </script>
</body>
</html>