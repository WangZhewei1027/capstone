<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Binary Search Tree (BST) Demonstration</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  #bstCanvas {
    border: 1px solid #444;
    background-color: #fafafa;
    display: block;
    margin-top: 20px;
  }
  input, button {
    font-size: 16px;
    padding: 6px 10px;
    margin: 5px 0;
  }
  #traversals {
    margin-top: 10px;
  }
  .output-label {
    font-weight: bold;
  }
</style>
</head>
<body>
<h1>Binary Search Tree (BST) Demonstration</h1>

<label for="nodeValue">Enter Node Value (number): </label>
<input type="number" id="nodeValue" />
<button id="insertBtn">Insert</button>
<button id="deleteBtn">Delete</button>
<button id="searchBtn">Search</button>
<button id="clearBtn">Clear Tree</button>

<div id="message" style="margin-top:10px; color: #b33;"></div>

<div id="traversals">
  <span class="output-label">In-Order: </span><span id="inorder"></span><br />
  <span class="output-label">Pre-Order: </span><span id="preorder"></span><br />
  <span class="output-label">Post-Order: </span><span id="postorder"></span><br />
  <span class="output-label">Level-Order: </span><span id="levelorder"></span>
</div>

<canvas id="bstCanvas" width="900" height="400"></canvas>

<script>
  /***** BST Node and Tree Classes *****/
  class Node {
    constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
    }
  }

  class BST {
    constructor() {
      this.root = null;
    }

    insert(value) {
      const newNode = new Node(value);
      if (this.root === null) {
        this.root = newNode;
        return true;
      }
      let current = this.root;
      while (true) {
        if (value === current.value) return false; // no duplicates
        if (value < current.value) {
          if (current.left === null) {
            current.left = newNode;
            return true;
          }
          current = current.left;
        } else {
          if (current.right === null) {
            current.right = newNode;
            return true;
          }
          current = current.right;
        }
      }
    }

    search(value) {
      let current = this.root;
      while (current) {
        if (value === current.value) return true;
        else if (value < current.value) current = current.left;
        else current = current.right;
      }
      return false;
    }

    delete(value) {
      this.root = this._deleteRec(this.root,value);
    }

    _deleteRec(root, value) {
      if (!root) return root;
      if (value < root.value) {
        root.left = this._deleteRec(root.left, value);
      } else if (value > root.value) {
        root.right = this._deleteRec(root.right, value);
      } else {
        // node to be deleted found
        if (!root.left) return root.right;
        else if (!root.right) return root.left;

        // node with two children: get inorder successor (smallest in right subtree)
        root.value = this._minValue(root.right);
        root.right = this._deleteRec(root.right, root.value);
      }
      return root;
    }

    _minValue(node) {
      let current = node;
      while (current.left != null) {
        current = current.left;
      }
      return current.value;
    }

    inorder() {
      const result = [];
      this._inorderRec(this.root, result);
      return result;
    }
    _inorderRec(node, arr) {
      if (node) {
        this._inorderRec(node.left, arr);
        arr.push(node.value);
        this._inorderRec(node.right, arr);
      }
    }
    preorder() {
      const result = [];
      this._preorderRec(this.root, result);
      return result;
    }
    _preorderRec(node, arr) {
      if (node) {
        arr.push(node.value);
        this._preorderRec(node.left, arr);
        this._preorderRec(node.right, arr);
      }
    }
    postorder() {
      const result = [];
      this._postorderRec(this.root, result);
      return result;
    }
    _postorderRec(node, arr) {
      if (node) {
        this._postorderRec(node.left, arr);
        this._postorderRec(node.right, arr);
        arr.push(node.value);
      }
    }
    levelOrder() {
      const result = [];
      if (!this.root) return result;
      const queue = [this.root];
      while (queue.length > 0) {
        const node = queue.shift();
        result.push(node.value);
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
      }
      return result;
    }
  }

  /***** Visualization on Canvas *****/
  const canvas = document.getElementById('bstCanvas');
  const ctx = canvas.getContext('2d');
  const radius = 20;
  const levelHeight = 70;

  function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  // Compute positions of nodes before drawing
  // We'll perform an inorder traversal assigning x positions to keep nodes spaced out
  function computeNodePositions(root) {
    const positions = new Map();
    let xPos = 40; // horizontal start offset

    function inorderAssign(node, depth) {
      if (!node) return;
      inorderAssign(node.left, depth + 1);
      positions.set(node, { x: xPos, y: 40 + depth * levelHeight });
      xPos += 70; // distance between nodes horizontally
      inorderAssign(node.right, depth + 1);
    }
    inorderAssign(root, 0);
    return positions;
  }

  // Draw line between two points with arrow-like end
  function drawLine(fromX, fromY, toX, toY) {
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();
  }

  // Draw a node circle with value text
  function drawNode(x, y, value, highlight=false) {
    ctx.beginPath();
    ctx.fillStyle = highlight ? '#ff6666' : '#4a90e2';
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.shadowColor = 'rgba(0,0,0,0.2)';
    ctx.shadowBlur = 3;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.stroke();

    ctx.fillStyle = 'white';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(value, x, y);
  }

  // Draw BST recursively using the precomputed positions
  function drawBST(tree, highlightValue=null) {
    clearCanvas();
    if (!tree.root) return;
    const positions = computeNodePositions(tree.root);

    // Draw edges
    positions.forEach((pos, node) => {
      if (node.left) {
        let leftPos = positions.get(node.left);
        drawLine(pos.x, pos.y + radius, leftPos.x, leftPos.y - radius);
      }
      if (node.right) {
        let rightPos = positions.get(node.right);
        drawLine(pos.x, pos.y + radius, rightPos.x, rightPos.y - radius);
      }
    });

    // Draw nodes on top of edges
    positions.forEach((pos, node) => {
      const highlight = (node.value === highlightValue);
      drawNode(pos.x, pos.y, node.value, highlight);
    });
  }

  /***** UI and Interaction *****/
  const bst = new BST();
  const nodeInput = document.getElementById('nodeValue');
  const insertBtn = document.getElementById('insertBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const searchBtn = document.getElementById('searchBtn');
  const clearBtn = document.getElementById('clearBtn');
  const messageDiv = document.getElementById('message');

  const inorderSpan = document.getElementById('inorder');
  const preorderSpan = document.getElementById('preorder');
  const postorderSpan = document.getElementById('postorder');
  const levelorderSpan = document.getElementById('levelorder');

  function updateTraversalDisplays() {
    inorderSpan.textContent = bst.inorder().join(', ');
    preorderSpan.textContent = bst.preorder().join(', ');
    postorderSpan.textContent = bst.postorder().join(', ');
    levelorderSpan.textContent = bst.levelOrder().join(', ');
  }

  function clearMessage() {
    messageDiv.textContent = '';
  }

  insertBtn.addEventListener('click', () => {
    clearMessage();
    const value = parseInt(nodeInput.value);
    if (Number.isNaN(value)) {
      messageDiv.textContent = 'Please enter a valid number to insert.';
      return;
    }
    const inserted = bst.insert(value);
    if (inserted) {
      messageDiv.style.color = 'green';
      messageDiv.textContent = `Inserted ${value} into the BST.`;
    } else {
      messageDiv.style.color = '#b33';
      messageDiv.textContent = `Value ${value} already exists in the BST.`;
    }
    updateTraversalDisplays();
    drawBST(bst);
  });

  deleteBtn.addEventListener('click', () => {
    clearMessage();
    const value = parseInt(nodeInput.value);
    if (Number.isNaN(value)) {
      messageDiv.textContent = 'Please enter a valid number to delete.';
      return;
    }
    if (!bst.search(value)) {
      messageDiv.style.color = '#b33';
      messageDiv.textContent = `Value ${value} not found in the BST.`;
      return;
    }
    bst.delete(value);
    messageDiv.style.color = 'green';
    messageDiv.textContent = `Deleted ${value} from the BST.`;
    updateTraversalDisplays();
    drawBST(bst);
  });

  searchBtn.addEventListener('click', () => {
    clearMessage();
    const value = parseInt(nodeInput.value);
    if (Number.isNaN(value)) {
      messageDiv.textContent = 'Please enter a valid number to search.';
      return;
    }
    const found = bst.search(value);
    if (found) {
      messageDiv.style.color = 'green';
      messageDiv.textContent = `Value ${value} found in the BST. Highlighting node...`;
      drawBST(bst, value);
    } else {
      messageDiv.style.color = '#b33';
      messageDiv.textContent = `Value ${value} not found in the BST.`;
      drawBST(bst);
    }
  });

  clearBtn.addEventListener('click', () => {
    clearMessage();
    bst.root = null;
    updateTraversalDisplays();
    drawBST(bst);
    messageDiv.style.color = 'black';
    messageDiv.textContent = 'BST cleared.';
  });

  // Draw initial empty tree
  updateTraversalDisplays();
  drawBST(bst);
</script>
</body>
</html>