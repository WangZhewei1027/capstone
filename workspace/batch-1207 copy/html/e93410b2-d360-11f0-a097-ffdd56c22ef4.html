<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Breadth-First Search (BFS) Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#111;
      --panel:#0f1720;
      --muted:#94a3b8;
      --accent:#38bdf8;
      --success:#4ade80;
      --danger:#fb7185;
      --wall:#111827;
      --cell-size:26px;
    }
    *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    html,body{height:100%; margin:0; background:linear-gradient(180deg,#071023 0%, #00121a 100%); color:#e6eef6;}
    .container{display:grid; grid-template-columns: 720px 1fr; gap:18px; padding:18px; max-width:1200px; margin:18px auto;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:12px; border-radius:8px;}
    .header{display:flex; gap:12px; align-items:center; margin-bottom:8px;}
    h1{font-size:18px; margin:0;}
    .controls{display:flex; gap:6px; flex-wrap:wrap; align-items:center;}
    button{background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--muted); padding:8px 10px; border-radius:6px; cursor:pointer;}
    button.primary{background:var(--accent); color:#022; border:0;}
    button.warn{background:var(--danger); color:#fff; border:0;}
    button.success{background:var(--success); color:#022; border:0;}
    button:active{transform:translateY(1px);}
    .small{font-size:13px; color:var(--muted);}
    .grid-wrap{display:flex; gap:12px;}
    .grid{display:grid; grid-template-rows: repeat(var(--rows), var(--cell-size)); grid-template-columns: repeat(var(--cols), var(--cell-size)); gap:2px; background:transparent; padding:8px; border-radius:8px;}
    .cell{width:var(--cell-size); height:var(--cell-size); border-radius:4px; background:rgba(255,255,255,0.02); display:flex; align-items:center; justify-content:center; font-size:11px; color:transparent; cursor:pointer; user-select:none;}
    .cell.wall{background:var(--wall); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);}
    .cell.start{background:linear-gradient(180deg,#16a34a,#059669); color:#032; font-weight:700;}
    .cell.target{background:linear-gradient(180deg,#ef4444,#dc2626); color:#420000; font-weight:700;}
    .cell.frontier{background:linear-gradient(180deg,#60a5fa,#3b82f6); color:#042; box-shadow:0 0 6px rgba(59,130,246,0.35);}
    .cell.visited{background:linear-gradient(180deg,#c7d2fe,#a78bfa); color:#042;}
    .cell.current{background:linear-gradient(180deg,#fb923c,#f97316); color:#2b0500; box-shadow:0 0 8px rgba(249,115,22,0.4);}
    .cell.path{background:linear-gradient(180deg,#fde68a,#f59e0b); color:#4b2300; border:1px solid rgba(0,0,0,0.2);}
    .legend{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:8px;}
    .legend .item{display:flex; gap:6px; align-items:center; color:var(--muted);}
    .swatch{width:18px; height:18px; border-radius:4px; border:1px solid rgba(255,255,255,0.03);}
    .right-col{display:flex; flex-direction:column; gap:12px;}
    textarea{width:100%; height:200px; background:transparent; color:var(--muted); border:1px dashed rgba(255,255,255,0.04); padding:8px; border-radius:6px; resize:vertical;}
    .status{font-size:13px; color:var(--muted);}
    .queue-view{display:flex; flex-wrap:wrap; gap:6px; padding:8px; background:rgba(255,255,255,0.02); border-radius:6px; min-height:36px;}
    .q-item{padding:6px 8px; border-radius:6px; background:rgba(255,255,255,0.03); font-size:12px;}
    .controls-row{display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap;}
    .settings{display:flex; gap:8px; align-items:center; color:var(--muted); flex-wrap:wrap;}
    label{font-size:13px; color:var(--muted);}
    input[type=range]{width:140px;}
    .footer{font-size:12px; color:var(--muted); margin-top:6px;}
    .hint{font-size:13px; color:var(--muted); margin-top:8px;}
    .muted-box{background:rgba(255,255,255,0.01); padding:8px; border-radius:6px; border:1px solid rgba(255,255,255,0.02); color:var(--muted);}
    @media (max-width:1000px){
      .container{grid-template-columns: 1fr; padding:12px;}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="header">
        <h1>Breadth-First Search (BFS) — Visualizer</h1>
        <div class="small">Unweighted shortest path on a grid (4-neighbors)</div>
      </div>

      <div class="controls-row">
        <div class="controls">
          <button id="runBtn" class="primary">Run</button>
          <button id="stepBtn">Step</button>
          <button id="pauseBtn">Pause</button>
          <button id="resetBtn">Reset</button>
          <button id="clearWallsBtn">Clear Walls</button>
          <button id="randomWallsBtn">Random Walls</button>
        </div>

        <div style="margin-left:auto;" class="settings">
          <label>Speed</label>
          <input id="speedRange" type="range" min="10" max="800" value="120" />
          <label id="speedLabel" class="small">120 ms</label>
          <label>Rows</label>
          <input id="rowsInput" type="number" min="6" max="40" value="20" style="width:56px;padding:6px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)"/>
          <label>Cols</label>
          <input id="colsInput" type="number" min="6" max="60" value="28" style="width:56px;padding:6px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)"/>
          <button id="resizeBtn">Resize Grid</button>
        </div>
      </div>

      <div class="grid-wrap">
        <div>
          <div id="grid" class="grid" style="--rows:20; --cols:28;"></div>

          <div class="legend">
            <div class="item"><div class="swatch start"></div> start</div>
            <div class="item"><div class="swatch target"></div> target</div>
            <div class="item"><div class="swatch frontier"></div> frontier (queue)</div>
            <div class="item"><div class="swatch visited"></div> visited</div>
            <div class="item"><div class="swatch path"></div> final path</div>
            <div class="item"><div class="swatch wall"></div> wall</div>
          </div>

          <div class="hint muted-box">
            Click a cell to toggle a wall. Shift+Click a cell to set the start. Ctrl/Command+Click to set the target.
            <div style="margin-top:6px">When running: BFS explores level-by-level. Once the target is found, BFS reconstructs the shortest path using parent pointers.</div>
          </div>
        </div>

        <div class="right-col">
          <div class="card" style="padding:10px;">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div style="font-weight:600">Status</div>
              <div id="counts" class="small">Visited: 0 • Queue: 0</div>
            </div>
            <div style="margin-top:8px;">
              <div class="status" id="statusText">Idle — set walls, start and target then Run.</div>
              <div style="margin-top:8px">
                <div style="font-weight:600;margin-bottom:6px">Queue (front at left)</div>
                <div id="queue" class="queue-view"></div>
              </div>
            </div>
            <div style="margin-top:8px;">
              <button id="reconstructBtn" class="success">Show Path (if found)</button>
            </div>
          </div>

          <div class="card">
            <div style="font-weight:700;margin-bottom:6px">Pseudocode</div>
            <textarea readonly rows="12">
BFS(start):
  queue ← empty queue
  enqueue start
  visited[start] ← true
  parent[start] ← null

  while queue not empty:
    node ← dequeue
    if node is target: break
    for each neighbor of node:
      if neighbor not visited and not a wall:
        visited[neighbor] ← true
        parent[neighbor] ← node
        enqueue neighbor

  reconstruct path by following parent pointers from target to start
            </textarea>
          </div>

          <div class="card">
            <div style="font-weight:700;margin-bottom:6px">Tips</div>
            <ul style="margin:0;color:var(--muted);padding-left:16px">
              <li>Use walls to create obstacles and see how BFS navigates.</li>
              <li>BFS guarantees the shortest path (fewest steps) on an unweighted grid.</li>
              <li>Try mazes or random walls and adjust speed.</li>
              <li>Step mode lets you advance one expansion at a time.</li>
            </ul>
          </div>

          <div class="card">
            <div style="font-weight:700;margin-bottom:6px">Controls Reference</div>
            <div class="small">Run/Pause/Step — control animation. Reset — clear visited/frontier/path but keep walls. Clear Walls — remove all walls. Random — add random obstacles. Resize grid to change dimensions.</div>
          </div>

        </div>
      </div>

    </div>
  </div>

  <script>
    // BFS Visualizer
    (function(){
      // DOM elements
      const gridEl = document.getElementById('grid');
      const runBtn = document.getElementById('runBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');
      const clearWallsBtn = document.getElementById('clearWallsBtn');
      const randomWallsBtn = document.getElementById('randomWallsBtn');
      const queueEl = document.getElementById('queue');
      const statusText = document.getElementById('statusText');
      const countsEl = document.getElementById('counts');
      const reconstructBtn = document.getElementById('reconstructBtn');
      const speedRange = document.getElementById('speedRange');
      const speedLabel = document.getElementById('speedLabel');
      const rowsInput = document.getElementById('rowsInput');
      const colsInput = document.getElementById('colsInput');
      const resizeBtn = document.getElementById('resizeBtn');

      // Settings
      let rows = parseInt(rowsInput.value,10) || 20;
      let cols = parseInt(colsInput.value,10) || 28;
      const defaultStart = {r: Math.floor(rows/2), c: Math.floor(cols/4)};
      const defaultTarget = {r: Math.floor(rows/2), c: Math.floor(cols*3/4)};

      // State
      let start = {...defaultStart};
      let target = {...defaultTarget};
      let cells = []; // array of elements
      let grid = []; // metadata objects {wall, visited, parent}
      let running = false;
      let paused = false;
      let timer = null;
      let delay = parseInt(speedRange.value,10);
      let queue = [];
      let visitedCount = 0;
      let found = false;

      // Initialize grid
      function initGrid() {
        // clamp rows/cols
        rows = Math.max(6, Math.min(40, parseInt(rowsInput.value,10) || 20));
        cols = Math.max(6, Math.min(60, parseInt(colsInput.value,10) || 28));
        rowsInput.value = rows; colsInput.value = cols;

        gridEl.style.setProperty('--rows', rows);
        gridEl.style.setProperty('--cols', cols);

        gridEl.innerHTML = '';
        cells = new Array(rows*cols);
        grid = new Array(rows);
        for (let r=0;r<rows;r++){
          grid[r] = new Array(cols);
          for (let c=0;c<cols;c++){
            const idx = r*cols + c;
            const div = document.createElement('div');
            div.className = 'cell';
            div.dataset.r = r;
            div.dataset.c = c;
            div.title = `(${r},${c})`;
            // events
            div.addEventListener('click', onCellClick);
            div.addEventListener('contextmenu', e => e.preventDefault());
            gridEl.appendChild(div);
            cells[idx] = div;
            grid[r][c] = {wall:false, visited:false, parent:null};
          }
        }
        // reset start/target to reasonable positions if out of bounds
        if (start.r >= rows || start.c >= cols) start = {...defaultStart, r: Math.floor(rows/2), c: Math.floor(cols/4)};
        if (target.r >= rows || target.c >= cols) target = {...defaultTarget, r: Math.floor(rows/2), c: Math.floor(cols*3/4)};
        markSpecials();
        resetSearch(true);
      }

      function cellIndex(r,c){ return r*cols + c; }

      function markSpecials(){
        // clear special classes first
        for (let i=0;i<cells.length;i++){
          cells[i].classList.remove('start','target');
        }
        cells[cellIndex(start.r,start.c)].classList.add('start');
        cells[cellIndex(target.r,target.c)].classList.add('target');
      }

      // click handler: toggle wall / set start / set target
      function onCellClick(e){
        const r = parseInt(this.dataset.r,10);
        const c = parseInt(this.dataset.c,10);
        if (e.shiftKey) {
          // set start
          if (!grid[r][c].wall && !(r===target.r && c===target.c)) {
            start = {r,c};
            markSpecials();
            resetSearch(true);
          }
          return;
        }
        if (e.ctrlKey || e.metaKey){
          // set target
          if (!grid[r][c].wall && !(r===start.r && c===start.c)) {
            target = {r,c};
            markSpecials();
            resetSearch(true);
          }
          return;
        }
        // toggle wall (do not allow placing wall on start/target)
        if ((r===start.r && c===start.c) || (r===target.r && c===target.c)) return;
        grid[r][c].wall = !grid[r][c].wall;
        updateCellVisual(r,c);
        resetSearch(true);
      }

      function updateCellVisual(r,c){
        const el = cells[cellIndex(r,c)];
        el.classList.toggle('wall', grid[r][c].wall);
        // remove search-related classes if wall
        if (grid[r][c].wall){
          el.classList.remove('frontier','visited','current','path');
        }
      }

      // BFS implementation as generator-like stepper
      function resetSearch(fullClear){
        stopRunning();
        // clear visited/parent/path/frontier but keep walls (unless fullClear also clears walls)
        if (fullClear === true){
          for (let r=0;r<rows;r++){
            for (let c=0;c<cols;c++){
              grid[r][c].visited = false;
              grid[r][c].parent = null;
              // if fullClear is true but we want to keep walls on Reset? Here reset preserves walls unless Clear Walls pressed.
              // We'll keep walls. So no action to change wall flag.
              const el = cells[cellIndex(r,c)];
              el.classList.remove('frontier','visited','current','path');
            }
          }
        }
        queue = [];
        visitedCount = 0;
        found = false;
        updateCounts();
        queueEl.innerHTML = '';
        statusText.textContent = 'Idle — ready';
      }

      function clearWalls(){
        for (let r=0;r<rows;r++){
          for (let c=0;c<cols;c++){
            grid[r][c].wall = false;
            updateCellVisual(r,c);
          }
        }
        resetSearch(true);
      }

      function randomWalls(prob=0.25){
        for (let r=0;r<rows;r++){
          for (let c=0;c<cols;c++){
            // avoid start and target
            if ((r===start.r && c===start.c) || (r===target.r && c===target.c)) { grid[r][c].wall = false; continue;}
            grid[r][c].wall = Math.random() < prob;
            updateCellVisual(r,c);
          }
        }
        resetSearch(true);
      }

      // BFS neighbor generator (4-neighbors)
      function neighbors(r,c){
        const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
        for (const [dr,dc] of dirs){
          const nr = r+dr, nc = c+dc;
          if (nr>=0 && nr<rows && nc>=0 && nc<cols) yieldNeighbor(nr,nc);
        }
      }
      function* neighborGen(r,c){
        const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
        for (const [dr,dc] of dirs){
          const nr = r+dr, nc = c+dc;
          if (nr>=0 && nr<rows && nc>=0 && nc<cols) yield {r:nr,c:nc};
        }
      }

      // Run BFS: we will implement it as a step function that does one "dequeue" per step
      function startBFS(){
        if (running) return;
        // prepare
        resetVisitedClasses();
        queue = [];
        visitedCount = 0;
        found = false;
        // mark start visited and enqueue
        grid[start.r][start.c].visited = true;
        grid[start.r][start.c].parent = null;
        queue.push({r:start.r,c:start.c});
        updateCellClass(start.r,start.c,'frontier');
        updateQueueView();
        updateCounts();
        running = true;
        paused = false;
        statusText.textContent = 'Running BFS...';
        scheduleStep();
      }

      // Step of BFS: process one queue pop
      function bfsStep(){
        if (!running) return;
        if (queue.length === 0){
          statusText.textContent = 'Finished — target not reachable';
          running = false;
          updateQueueView();
          return;
        }
        // dequeue
        const node = queue.shift();
        updateQueueView();
        const {r,c} = node;
        // mark as current for a moment
        updateCellClass(r,c,'current');
        // check if target
        if (r===target.r && c===target.c){
          found = true;
          statusText.textContent = `Target found! Distance: ${reconstructDistance()}`;
          running = false;
          // mark path
          reconstructPathVisual();
          updateCounts();
          return;
        }
        // expand neighbors
        for (const nb of neighborGen(r,c)){
          const nr = nb.r, nc = nb.c;
          if (grid[nr][nc].wall) continue;
          if (!grid[nr][nc].visited){
            grid[nr][nc].visited = true;
            grid[nr][nc].parent = {r,c};
            queue.push({r:nr,c:nc});
            updateCellClass(nr,nc,'frontier');
            visitedCount++;
          }
        }
        // mark node as visited (done)
        updateCellClass(r,c,'visited',true);
        updateCounts();
        // schedule next if still running and not paused
        if (running && !paused) scheduleStep();
      }

      function scheduleStep(){
        clearTimeout(timer);
        timer = setTimeout(() => {
          bfsStep();
        }, delay);
      }

      function stopRunning(){
        running = false;
        paused = false;
        clearTimeout(timer);
      }

      function resetVisitedClasses(){
        for (let r=0;r<rows;r++){
          for (let c=0;c<cols;c++){
            grid[r][c].visited = false;
            grid[r][c].parent = null;
            const el = cells[cellIndex(r,c)];
            el.classList.remove('frontier','visited','current','path');
            if (grid[r][c].wall) el.classList.add('wall'); else el.classList.remove('wall');
          }
        }
        markSpecials();
      }

      function updateCellClass(r,c,cls,removeFrontier=false){
        const el = cells[cellIndex(r,c)];
        // clear 'current' / 'frontier' if making visited or path
        if (cls === 'current'){
          el.classList.remove('frontier','visited','path');
          el.classList.add('current');
        } else if (cls === 'visited'){
          el.classList.remove('current','frontier');
          if (!el.classList.contains('start') && !el.classList.contains('target'))
            el.classList.add('visited');
        } else if (cls === 'frontier'){
          if (!el.classList.contains('start') && !el.classList.contains('target') && !el.classList.contains('wall'))
            el.classList.add('frontier');
        } else if (cls === 'path'){
          el.classList.remove('frontier','visited','current');
          el.classList.add('path');
        }
      }

      function updateQueueView(){
        queueEl.innerHTML = '';
        for (let i=0;i<queue.length;i++){
          const q = queue[i];
          const div = document.createElement('div');
          div.className = 'q-item';
          div.textContent = `(${q.r},${q.c})`;
          queueEl.appendChild(div);
        }
      }

      function updateCounts(){
        countsEl.textContent = `Visited: ${visitedCount} • Queue: ${queue.length}`;
      }

      // reconstruct path visual from target via parents
      function reconstructPathVisual(){
        if (!found && !grid[target.r][target.c].parent) {
          statusText.textContent = 'No path to reconstruct';
          return;
        }
        let cur = {r: target.r, c: target.c};
        const path = [];
        while (cur){
          path.push(cur);
          cur = grid[cur.r][cur.c].parent;
        }
        // path includes start...target
        for (const p of path){
          // skip start/target styling (but path style on intermediate)
          if ((p.r===start.r && p.c===start.c) || (p.r===target.r && p.c===target.c)) continue;
          updateCellClass(p.r,p.c,'path');
        }
      }

      function reconstructDistance(){
        let d = 0;
        let cur = {r: target.r, c: target.c};
        while (cur && !(cur.r===start.r && cur.c===start.c)){
          cur = grid[cur.r][cur.c].parent;
          d++;
          if (!cur) return 'unknown';
        }
        return d;
      }

      // Event handlers for control buttons
      runBtn.addEventListener('click', () => {
        if (!running){
          startBFS();
        } else {
          // if paused, unpause
          if (paused){ paused = false; statusText.textContent = 'Running BFS...'; scheduleStep(); }
        }
      });
      pauseBtn.addEventListener('click', () => {
        if (running){
          paused = true;
          clearTimeout(timer);
          statusText.textContent = 'Paused';
        }
      });
      stepBtn.addEventListener('click', () => {
        if (!running){
          // start BFS in single-step mode
          resetVisitedClasses();
          queue = [];
          visitedCount = 0;
          found = false;
          grid[start.r][start.c].visited = true;
          grid[start.r][start.c].parent = null;
          queue.push({r:start.r,c:start.c});
          updateCellClass(start.r,start.c,'frontier');
          updateQueueView();
          running = true;
          paused = true;
        }
        // do exactly one step
        bfsStep();
        // keep paused
        paused = true;
        running = running && !found; // if found, running false
      });

      resetBtn.addEventListener('click', () => {
        resetSearch(true);
        statusText.textContent = 'Reset — cleared search state';
      });

      clearWallsBtn.addEventListener('click', () => {
        clearWalls();
        statusText.textContent = 'All walls cleared';
      });

      randomWallsBtn.addEventListener('click', () => {
        randomWalls(0.25 + Math.random()*0.25);
        statusText.textContent = 'Random walls applied';
      });

      reconstructBtn.addEventListener('click', () => {
        reconstructPathVisual();
      });

      speedRange.addEventListener('input', () => {
        delay = parseInt(speedRange.value,10);
        speedLabel.textContent = `${delay} ms`;
      });

      resizeBtn.addEventListener('click', () => {
        // apply new size
        initGrid();
      });

      // keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.key === ' ') { e.preventDefault(); if (running && !paused) { paused=true; statusText.textContent='Paused'; } else runBtn.click(); }
        if (e.key === 'r') randomWallsBtn.click();
        if (e.key === 'c') clearWallsBtn.click();
      });

      // initial setup
      initGrid();

      // Expose small helpers for debugging in console (optional)
      window.bfsViz = {
        startBFS, bfsStep, resetSearch, randomWalls, clearWalls, reconstructPathVisual, getGrid: ()=>grid
      };

      // Make sure start/target cells are styled distinct in legend swatches (pure cosmetic)
      (function styleLegend(){
        const swatches = document.querySelectorAll('.swatch');
        if (swatches[0]) swatches[0].classList.add('start');
        if (swatches[1]) swatches[1].classList.add('target');
        if (swatches[2]) swatches[2].classList.add('frontier');
        if (swatches[3]) swatches[3].classList.add('visited');
        if (swatches[4]) swatches[4].classList.add('path');
        if (swatches[5]) swatches[5].classList.add('wall');
      })();

    })();
  </script>
</body>
</html>