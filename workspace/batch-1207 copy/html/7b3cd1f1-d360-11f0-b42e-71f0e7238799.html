<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means Clustering Visualization</title>
    <style>
        canvas {
            border: 1px solid black;
            margin: 20px;
        }
    </style>
</head>
<body>
    <h1>K-Means Clustering Demo</h1>
    <p>Click on the canvas to generate random points and run K-Means clustering.</p>
    <canvas id="canvas" width="800" height="600"></canvas>
    <button id="kmeansButton">Run K-Means (K=3)</button>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let points = [];
        const k = 3; // Number of clusters

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            points.push({ x, y });
            drawPoints();
        });

        function drawPoints() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'black';
            points.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        function getRandomCentroids() {
            let centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                });
            }
            return centroids;
        }

        function assignClusters(points, centroids) {
            points.forEach(point => {
                let closestIndex = 0;
                let closestDistance = Infinity;
                centroids.forEach((centroid, index) => {
                    const distance = Math.sqrt(Math.pow(point.x - centroid.x, 2) + Math.pow(point.y - centroid.y, 2));
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestIndex = index;
                    }
                });
                point.cluster = closestIndex;
            });
        }

        function updateCentroids(points) {
            const newCentroids = Array.from({ length: k }, () => ({ x: 0, y: 0, count: 0 }));
            points.forEach(point => {
                newCentroids[point.cluster].x += point.x;
                newCentroids[point.cluster].y += point.y;
                newCentroids[point.cluster].count++;
            });
            return newCentroids.map(centroid => {
                if (centroid.count > 0) {
                    return { x: centroid.x / centroid.count, y: centroid.y / centroid.count };
                } else {
                    return { x: Math.random() * canvas.width, y: Math.random() * canvas.height };
                }
            });
        }

        function drawCentroids(centroids) {
            ctx.fillStyle = 'red';
            centroids.forEach(centroid => {
                ctx.beginPath();
                ctx.arc(centroid.x, centroid.y, 8, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        function drawClusters(points) {
            const colors = ['blue', 'green', 'orange'];
            points.forEach(point => {
                ctx.fillStyle = colors[point.cluster];
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        function kMeans() {
            if (points.length === 0) return;
            let centroids = getRandomCentroids();

            for (let i = 0; i < 10; i++) { // Limit iterations to 10
                assignClusters(points, centroids);
                centroids = updateCentroids(points);
            }

            drawClusters(points);
            drawCentroids(centroids);
        }

        document.getElementById('kmeansButton').addEventListener('click', () => {
            kMeans();
        });
    </script>
</body>
</html>