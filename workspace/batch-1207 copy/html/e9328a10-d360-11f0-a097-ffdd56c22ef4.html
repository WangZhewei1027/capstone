<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hash Table Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --accent:#4fd1c5; --muted:#94a3b8; --danger:#ff6b6b;
      --ok:#7ee787; --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071025 0%, #071220 100%);color:#e6eef6}
    .wrap{max-width:1100px;margin:28px auto;padding:20px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 6px 30px rgba(2,6,23,0.6)}
    header{display:flex;align-items:center;gap:16px;padding-bottom:16px;border-bottom:1px solid rgba(255,255,255,0.03)}
    h1{font-size:20px;margin:0}
    .controls{display:flex;gap:12px;flex-wrap:wrap;padding:14px 0}
    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
    .col{display:flex;flex-direction:column}
    input[type="text"], select, input[type="number"]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.05);background:var(--glass);color:var(--muted);min-width:160px}
    button{background:var(--accent);border:0;padding:8px 12px;border-radius:10px;color:#022;cursor:pointer;font-weight:600}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .row{display:flex;gap:12px;align-items:flex-end}
    .vis{margin-top:18px;padding:16px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));min-height:220px}
    .buckets{display:flex;gap:8px;flex-wrap:wrap}
    .bucket{width:80px;border-radius:8px;padding:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);text-align:center;position:relative}
    .idx{position:absolute;left:6px;top:6px;font-size:11px;color:var(--muted)}
    .cells{margin-top:16px;display:flex;flex-direction:column;gap:6px;align-items:center}
    .node{padding:6px 8px;border-radius:8px;background:#071831;color:#cfeff0;border:1px solid rgba(255,255,255,0.03);min-width:40px}
    .empty{opacity:0.4;color:var(--muted);font-size:13px;padding:10px 0}
    .log{margin-top:14px;padding:10px;border-radius:8px;background:rgba(0,0,0,0.22);max-height:160px;overflow:auto;font-size:13px;color:var(--muted)}
    .meta{display:flex;gap:12px;align-items:center;margin-left:auto}
    .badge{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;font-size:13px;border:1px solid rgba(255,255,255,0.02)}
    .highlight{box-shadow:0 0 0 3px rgba(79,209,197,0.12) inset}
    .probe{outline:3px solid rgba(125, 250, 180, 0.12);transition:all .22s}
    .found{animation:found 900ms ease}
    @keyframes found{0%{transform:scale(1)}40%{transform:scale(1.05)}100%{transform:scale(1)}}
    .tomb{background:#2b2f36;color:#bbb}
    .controls small{display:block;color:var(--muted);margin-top:6px;font-size:12px}
    footer{margin-top:14px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}
    .legend{display:flex;gap:8px;align-items:center}
    .legend div{display:flex;gap:6px;align-items:center}
    .sw{width:16px;height:12px;border-radius:4px;background:var(--accent);box-shadow:0 0 0 3px rgba(79,209,197,0.08) inset}
    @media (max-width:880px){.buckets{justify-content:center}.meta{display:none}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Hash Table Visualizer</h1>
      <div class="meta">
        <div class="badge">Count: <span id="count">0</span></div>
        <div class="badge">Capacity: <span id="cap">8</span></div>
        <div class="badge">Load: <span id="load">0%</span></div>
      </div>
    </header>

    <section class="controls">
      <div class="col" style="flex:1;min-width:260px">
        <label>Key (string or number)</label>
        <input id="keyInput" type="text" placeholder="e.g. Alice or 42" />
      </div>

      <div class="col">
        <label>Choose collision handling</label>
        <select id="mode">
          <option value="chaining">Separate chaining (linked lists)</option>
          <option value="linear">Open addressing (linear probing)</option>
        </select>
      </div>

      <div class="col">
        <label>Hash function</label>
        <select id="hashFn">
          <option value="djb2">djb2 (strings), modulo for numbers</option>
          <option value="poly">Polynomial rolling</option>
          <option value="sum">Sum char codes</option>
        </select>
      </div>

      <div class="col">
        <label>Table capacity</label>
        <select id="capacitySelect">
          <option>8</option><option>16</option><option>32</option><option>64</option>
        </select>
        <small>Changing capacity resets the table</small>
      </div>

      <div class="col" style="min-width:200px">
        <div class="row">
          <button id="insertBtn">Insert</button>
          <button id="searchBtn" class="secondary">Search</button>
          <button id="deleteBtn" class="secondary">Delete</button>
        </div>
        <div style="margin-top:8px" class="row">
          <button id="randBtn" class="secondary">Insert Random</button>
          <button id="bulkBtn" class="secondary">Bulk Insert 6</button>
          <button id="clearBtn" class="secondary">Clear</button>
        </div>
      </div>

      <div class="col">
        <label>Auto-resize threshold (load factor %)</label>
        <input id="threshold" type="number" value="70" min="10" max="95" />
        <small>When exceeded, table will resize (double)</small>
      </div>
    </section>

    <section class="vis">
      <div class="buckets" id="buckets"></div>
      <div class="log" id="log"></div>
    </section>

    <footer>
      Tip: Try strings and numbers. Switch collision handling to see chaining vs linear probing behavior. Click Log entries to scroll.
      <div style="margin-top:8px" class="legend">
        <div><div class="sw"></div> Bucket highlight</div>
        <div><div style="width:16px;height:12px;background:#2b2f36;border-radius:4px;margin-left:2px"></div> Tombstone (deleted)</div>
      </div>
    </footer>
  </div>

<script>
/*
  Hash Table Visualizer
  - Supports separate chaining and linear probing (open addressing)
  - Several simple hash functions for strings
  - Animates probing and highlights buckets
  - Auto-resize when load factor exceeds threshold
*/

(function(){
  // Utilities
  const el = id => document.getElementById(id);
  const log = (msg, strong=false) => {
    const out = el('log');
    const div = document.createElement('div');
    div.style.padding = '6px 4px';
    div.style.borderBottom = '1px dashed rgba(255,255,255,0.02)';
    div.innerHTML = (strong?'<b style="color:var(--accent)">'+msg+'</b>':msg);
    out.prepend(div);
  };

  function isNumberString(s){
    return /^-?\d+(\.\d+)?$/.test(String(s).trim());
  }

  function toKey(raw){
    const s = String(raw);
    if(isNumberString(s)) {
      const n = Number(s);
      return {type:'number', value:n, raw:s};
    }
    return {type:'string', value:s, raw:s};
  }

  // Hash functions
  const hashFns = {
    djb2(key, cap){
      // djb2 for strings; for numbers use modulo
      if(key.type === 'number') return Math.abs(Math.floor(key.value)) % cap;
      let str = key.value;
      let h = 5381;
      for(let i=0;i<str.length;i++) h = ((h<<5) + h) + str.charCodeAt(i);
      return Math.abs(h) % cap;
    },
    poly(key, cap){
      if(key.type === 'number') return Math.abs(Math.floor(key.value)) % cap;
      const p = 31;
      let h = 0;
      for(let i=0;i<key.value.length;i++){
        h = (h * p + key.value.charCodeAt(i)) % 1_000_000_007;
      }
      return Math.abs(h) % cap;
    },
    sum(key, cap){
      if(key.type === 'number') return Math.abs(Math.floor(key.value)) % cap;
      let s = 0;
      for(let ch of key.value) s += ch.charCodeAt(0);
      return Math.abs(s) % cap;
    }
  };

  // Hash Table implementation (visual-friendly)
  class HashTable {
    constructor(capacity=8, mode='chaining', hashName='djb2', onUpdate = ()=>{}){
      this.capacity = capacity;
      this.count = 0;
      this.mode = mode;
      this.hashName = hashName;
      this.onUpdate = onUpdate;
      this.tombstone = {__tomb: true};
      this.clear();
    }

    clear(){
      if(this.mode === 'chaining'){
        this.table = new Array(this.capacity).fill(0).map(()=>[]);
      }else{
        this.table = new Array(this.capacity).fill(null);
      }
      this.count = 0;
      this.onUpdate();
    }

    _hash(key){ return hashFns[this.hashName](key, this.capacity); }

    contains(rawKey){
      const key = toKey(rawKey);
      if(this.mode === 'chaining'){
        const idx = this._hash(key);
        return this.table[idx].some(e => e.raw === key.raw);
      }else{
        let idx = this._hash(key);
        for(let i=0;i<this.capacity;i++){
          const j = (idx + i) % this.capacity;
          const cell = this.table[j];
          if(cell === null) return false;
          if(cell === this.tombstone) continue;
          if(cell.raw === key.raw) return true;
        }
        return false;
      }
    }

    // returns an animation plan (array of steps) for UI to play
    planInsert(rawKey){
      const key = toKey(rawKey);
      const ops = [];
      const idx = this._hash(key);
      ops.push({type:'compute', idx, key});
      if(this.mode === 'chaining'){
        // highlight bucket, then append node
        ops.push({type:'bucket', idx});
        const bucket = this.table[idx];
        const exists = bucket.some(e => e.raw === key.raw);
        if(exists){
          ops.push({type:'exists', idx});
        } else {
          ops.push({type:'insert_chain', idx, key});
        }
      } else {
        // linear probing plan
        let start = idx;
        for(let step=0; step<this.capacity; step++){
          const j = (start + step) % this.capacity;
          ops.push({type:'probe', idx:j, step});
          const cell = this.table[j];
          if(cell === null || cell === this.tombstone){
            ops.push({type:'place', idx:j, key});
            break;
          }
          if(cell.raw === key.raw){
            ops.push({type:'exists', idx:j});
            break;
          }
        }
      }
      return ops;
    }

    // similarly planSearch
    planSearch(rawKey){
      const key = toKey(rawKey);
      const ops = [];
      const idx = this._hash(key);
      ops.push({type:'compute', idx, key});
      if(this.mode === 'chaining'){
        ops.push({type:'bucket', idx});
        const bucket = this.table[idx];
        for(let i=0;i<bucket.length;i++){
          ops.push({type:'check_chain', idx, pos:i, entry:bucket[i]});
          if(bucket[i].raw === key.raw){
            ops.push({type:'found', idx, pos:i});
            return ops;
          }
        }
        ops.push({type:'notfound', idx});
      }else{
        let start = idx;
        for(let step=0; step<this.capacity; step++){
          const j = (start + step) % this.capacity;
          ops.push({type:'probe', idx:j, step});
          const cell = this.table[j];
          if(cell === null){
            ops.push({type:'notfound', idx:j});
            break;
          }
          if(cell === this.tombstone) continue;
          if(cell.raw === key.raw){
            ops.push({type:'found', idx:j});
            break;
          }
        }
      }
      return ops;
    }

    planDelete(rawKey){
      const key = toKey(rawKey);
      const ops = this.planSearch(rawKey);
      // append delete action if found
      ops.push({type:'delete_attempt', key});
      return ops;
    }

    // The actual operations (no animation). Return status and message.
    insert(rawKey){
      const key = toKey(rawKey);
      if(this.contains(key.raw)){
        return {ok:false, msg:'Key already present'};
      }
      if(this.mode === 'chaining'){
        const idx = this._hash(key);
        this.table[idx].push(key);
        this.count++;
      } else {
        let idx = this._hash(key);
        for(let i=0;i<this.capacity;i++){
          const j = (idx + i) % this.capacity;
          const cell = this.table[j];
          if(cell === null || cell === this.tombstone){
            this.table[j] = key;
            this.count++;
            break;
          }
        }
      }
      this._maybeResize();
      this.onUpdate();
      return {ok:true, msg:'Inserted'};
    }

    search(rawKey){
      return this.contains(rawKey);
    }

    delete(rawKey){
      const key = toKey(rawKey);
      if(this.mode === 'chaining'){
        const idx = this._hash(key);
        const bucket = this.table[idx];
        const i = bucket.findIndex(e => e.raw === key.raw);
        if(i >= 0){
          bucket.splice(i,1);
          this.count--;
          this.onUpdate();
          return {ok:true, msg:'Deleted'};
        } else {
          return {ok:false, msg:'Not found'};
        }
      } else {
        let idx = this._hash(key);
        for(let i=0;i<this.capacity;i++){
          const j = (idx + i) % this.capacity;
          const cell = this.table[j];
          if(cell === null) return {ok:false, msg:'Not found'};
          if(cell === this.tombstone) continue;
          if(cell.raw === key.raw){
            this.table[j] = this.tombstone;
            this.count--;
            this.onUpdate();
            return {ok:true, msg:'Deleted (marked tombstone)'};
          }
        }
        return {ok:false, msg:'Not found'};
      }
    }

    _maybeResize(){
      const load = Math.round(this.count / this.capacity * 100);
      const threshold = Number(el('threshold').value || 70);
      if(load > threshold){
        // double capacity
        const newCap = this.capacity * 2;
        log(`Auto-resize: capacity ${this.capacity} → ${newCap}`, true);
        const old = this.table;
        this.capacity = newCap;
        if(this.mode === 'chaining') this.table = new Array(this.capacity).fill(0).map(()=>[]);
        else this.table = new Array(this.capacity).fill(null);
        const all = [];
        if(this.mode === 'chaining'){
          for(const b of old) for(const e of b) all.push(e.raw);
        } else {
          for(const c of old) if(c && c !== this.tombstone) all.push(c.raw);
        }
        this.count = 0;
        for(const k of all) this.insert(k);
      }
    }
  }

  // UI wiring
  const bucketContainer = el('buckets');
  const keyInput = el('keyInput');
  const insertBtn = el('insertBtn');
  const searchBtn = el('searchBtn');
  const deleteBtn = el('deleteBtn');
  const clearBtn = el('clearBtn');
  const randBtn = el('randBtn');
  const bulkBtn = el('bulkBtn');
  const modeSelect = el('mode');
  const hashSelect = el('hashFn');
  const capSelect = el('capacitySelect');
  const countEl = el('count');
  const capEl = el('cap');
  const loadEl = el('load');

  let table = new HashTable(Number(capSelect.value), modeSelect.value, hashSelect.value, redraw);

  function redraw(){
    // update meta
    countEl.textContent = table.count;
    capEl.textContent = table.capacity;
    const load = Math.round(table.count / table.capacity * 100);
    loadEl.textContent = load + '%';

    // draw buckets
    bucketContainer.innerHTML = '';
    for(let i=0;i<table.capacity;i++){
      const b = document.createElement('div');
      b.className = 'bucket';
      b.dataset.idx = i;
      const idx = document.createElement('div');
      idx.className = 'idx';
      idx.textContent = i;
      b.appendChild(idx);

      const cells = document.createElement('div');
      cells.className = 'cells';
      if(table.mode === 'chaining'){
        const bucket = table.table[i];
        if(bucket.length === 0){
          const e = document.createElement('div');
          e.className = 'empty';
          e.textContent = 'empty';
          cells.appendChild(e);
        } else {
          for(const ent of bucket){
            const n = document.createElement('div');
            n.className = 'node';
            n.textContent = ent.raw;
            cells.appendChild(n);
          }
        }
      } else {
        const cell = table.table[i];
        if(cell === null){
          const e = document.createElement('div');
          e.className = 'empty';
          e.style.padding = '10px 0';
          e.textContent = 'empty';
          cells.appendChild(e);
        } else if(cell === table.tombstone){
          const t = document.createElement('div');
          t.className = 'node tomb';
          t.textContent = 'deleted';
          cells.appendChild(t);
        } else {
          const n = document.createElement('div');
          n.className = 'node';
          n.textContent = cell.raw;
          cells.appendChild(n);
        }
      }
      b.appendChild(cells);
      b.addEventListener('click', ()=> logBucket(i));
      bucketContainer.appendChild(b);
    }
  }

  function logBucket(i){
    if(table.mode === 'chaining'){
      const b = table.table[i];
      log(`Bucket ${i}: [ ${b.map(x=>x.raw).join(', ')} ]`);
    } else {
      const c = table.table[i];
      if(c === null) log(`Bucket ${i}: empty`);
      else if(c === table.tombstone) log(`Bucket ${i}: tombstone`);
      else log(`Bucket ${i}: ${c.raw}`);
    }
  }

  // Visual animator: takes plan and plays steps with highlights
  let animating = false;
  async function playPlan(plan){
    if(animating) return;
    animating = true;
    clearHighlights();

    for(const step of plan){
      clearHighlights();
      if(step.type === 'compute'){
        log(`Hash(${step.key.raw}) → index ${step.idx}`);
        highlightBucket(step.idx,'highlight');
        await sleep(450);
      } else if(step.type === 'bucket'){
        highlightBucket(step.idx, 'probe');
        await sleep(450);
      } else if(step.type === 'insert_chain'){
        highlightBucket(step.idx,'probe');
        await sleep(350);
        table.insert(step.key.raw);
        redraw();
        log(`Inserted ${step.key.raw} into bucket ${step.idx}`, true);
        const b = getBucketEl(step.idx);
        if(b) animNode(b, step.key.raw);
        await sleep(500);
      } else if(step.type === 'probe'){
        highlightBucket(step.idx,'probe');
        log(`Probing index ${step.idx}`);
        await sleep(350);
      } else if(step.type === 'place'){
        highlightBucket(step.idx,'probe');
        await sleep(250);
        table.insert(step.key.raw);
        redraw();
        log(`Placed ${step.key.raw} at index ${step.idx}`, true);
        const b = getBucketEl(step.idx);
        if(b) animNode(b, step.key.raw);
        await sleep(500);
      } else if(step.type === 'exists'){
        highlightBucket(step.idx,'found');
        log(`Key already exists at ${step.idx}`);
        await sleep(600);
      } else if(step.type === 'check_chain'){
        const b = getBucketEl(step.idx);
        const nodes = b ? b.querySelectorAll('.node') : [];
        if(nodes[step.pos]){
          nodes[step.pos].classList.add('probe');
        }
        await sleep(380);
      } else if(step.type === 'found'){
        highlightBucket(step.idx,'found');
        log(`Found key at ${step.idx}`, true);
        await sleep(600);
      } else if(step.type === 'notfound'){
        highlightBucket(step.idx,'highlight');
        log(`Not found (stopped at ${step.idx})`);
        await sleep(500);
      } else if(step.type === 'delete_attempt'){
        // perform deletion and log result
        const res = table.delete(step.key.raw);
        redraw();
        if(res.ok) log(res.msg, true);
        else log(res.msg);
        await sleep(300);
      }
    }

    clearHighlights();
    animating = false;
  }

  function animNode(bucketEl, label){
    // find last node containing label and add pulse
    const nodes = [...bucketEl.querySelectorAll('.node')].filter(n=>n.textContent===label);
    if(nodes.length) nodes[nodes.length-1].classList.add('found');
    setTimeout(()=>{ for(const n of nodes) n.classList.remove('found'); }, 800);
  }

  function getBucketEl(i){
    return bucketContainer.querySelector('.bucket[data-idx="'+i+'"]');
  }

  function highlightBucket(i, cls='highlight'){
    const elb = getBucketEl(i);
    if(elb) elb.classList.add(cls);
  }

  function clearHighlights(){
    const nodes = bucketContainer.querySelectorAll('.bucket');
    nodes.forEach(n => { n.classList.remove('highlight','probe','found'); const inner = n.querySelectorAll('.node'); inner.forEach(x=>x.classList.remove('probe')); });
  }

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // UI events
  insertBtn.addEventListener('click', async ()=>{
    const key = keyInput.value.trim();
    if(!key){ alert('Enter a key'); return; }
    table.hashName = hashSelect.value;
    table.mode = modeSelect.value;
    const plan = table.planInsert(key);
    await playPlan(plan);
  });

  searchBtn.addEventListener('click', async ()=>{
    const key = keyInput.value.trim();
    if(!key){ alert('Enter a key'); return; }
    table.hashName = hashSelect.value;
    table.mode = modeSelect.value;
    const plan = table.planSearch(key);
    await playPlan(plan);
  });

  deleteBtn.addEventListener('click', async ()=>{
    const key = keyInput.value.trim();
    if(!key){ alert('Enter a key'); return; }
    table.hashName = hashSelect.value;
    table.mode = modeSelect.value;
    const plan = table.planDelete(key);
    await playPlan(plan);
  });

  clearBtn.addEventListener('click', ()=>{
    table = new HashTable(Number(capSelect.value), modeSelect.value, hashSelect.value, redraw);
    redraw();
    log('Table cleared', true);
  });

  randBtn.addEventListener('click', async ()=>{
    const key = randomKey();
    keyInput.value = key;
    const plan = table.planInsert(key);
    await playPlan(plan);
  });

  bulkBtn.addEventListener('click', async ()=>{
    const arr = [];
    for(let i=0;i<6;i++) arr.push(randomKey());
    for(const k of arr){
      keyInput.value = k;
      const plan = table.planInsert(k);
      await playPlan(plan);
      await sleep(120);
    }
  });

  modeSelect.addEventListener('change', ()=>{
    // changing mode resets table
    table = new HashTable(Number(capSelect.value), modeSelect.value, hashSelect.value, redraw);
    redraw();
    log('Switched collision handling. Table reset', true);
  });

  hashSelect.addEventListener('change', ()=>{
    table.hashName = hashSelect.value;
    log(`Hash function set to ${hashSelect.value}`, true);
  });

  capSelect.addEventListener('change', ()=>{
    table = new HashTable(Number(capSelect.value), modeSelect.value, hashSelect.value, redraw);
    redraw();
    log('Capacity changed. Table reset', true);
  });

  // random key generator
  function randomKey(){
    if(Math.random() < 0.5) return (Math.floor(Math.random()*200)).toString();
    const names = ['Alice','Bob','Carol','Dave','Eve','Mallory','Trent','Peggy','Victor','Sybil'];
    return names[Math.floor(Math.random()*names.length)] + Math.floor(Math.random()*100);
  }

  // initial draw
  redraw();
  log('Ready. Insert keys to see hashing and collisions visualized.');

  // expose to window for debugging (optional)
  window.ht = table;

})();
</script>
</body>
</html>