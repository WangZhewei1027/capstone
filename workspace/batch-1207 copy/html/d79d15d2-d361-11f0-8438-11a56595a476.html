<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Depth-First Search (DFS) Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f0f0f0;
  }
  h1 {
    text-align: center;
  }
  #graph-container {
    display: flex;
    justify-content: center;
    margin: 20px 0;
  }
  svg {
    border: 1px solid #ccc;
    background: #fff;
    border-radius: 8px;
  }
  .node {
    fill: #3498db;
    stroke: #2980b9;
    stroke-width: 2px;
    cursor: pointer;
    transition: fill 0.3s ease;
  }
  .node.visited {
    fill: #2ecc71;
    stroke: #27ae60;
  }
  .node.current {
    fill: #e74c3c;
    stroke: #c0392b;
  }
  .edge {
    stroke: #999;
    stroke-width: 2px;
  }
  #controls {
    text-align: center;
    margin-top: 10px;
  }
  button {
    background: #2980b9;
    color: white;
    border: none;
    padding: 12px 18px;
    margin: 0 8px;
    font-size: 16px;
    cursor: pointer;
    border-radius: 5px;
  }
  button:disabled {
    background: #95a5a6;
    cursor: default;
  }
  #log {
    margin-top: 20px;
    background: white;
    border-radius: 8px;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
    height: 150px;
    overflow-y: auto;
    padding: 10px;
    border: 1px solid #ccc;
    font-family: monospace;
    font-size: 14px;
  }
  #info {
    text-align: center;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
    color: #555;
  }
  #startNode {
    font-size: 16px;
    padding: 8px 12px;
    border-radius: 5px;
    margin-left: 8px;
    width: 50px;
    text-align: center;
  }
  label {
    font-size: 16px;
  }
</style>
</head>
<body>
<h1>Depth-First Search (DFS) Visualization</h1>
<div id="info">
  <p>Select start node by clicking one of the blue nodes, then click "Start DFS" to run the algorithm step-by-step.</p>
  <p>Nodes will be highlighted as: <span style="color:#3498db;">Blue (Unvisited)</span>, <span style="color:#e74c3c;">Red (Current)</span>, <span style="color:#2ecc71;">Green (Visited)</span>.</p>
</div>
<div id="graph-container">
  <svg width="600" height="400" aria-label="Graph visualization">
    <!-- Edges will go here -->
    <!-- Nodes will go here -->
  </svg>
</div>
<div id="controls">
  <button id="startBtn" disabled>Start DFS</button>
  <button id="nextBtn" disabled>Next Step</button>
  <button id="resetBtn">Reset</button>
</div>
<div id="log" aria-live="polite" aria-atomic="true" role="log"></div>

<script>
(() => {
  /*
  This demo shows DFS on a fixed graph.
  The user can select the start node by clicking a node.
  Start DFS to see stepwise traversal.
  */

  const svgNS = "http://www.w3.org/2000/svg";

  // Graph data: adjacency list representation
  // We'll generate a simple undirected graph
  const graph = {
    nodes: [
      { id: "A", x: 100, y: 100 },
      { id: "B", x: 250, y: 70 },
      { id: "C", x: 400, y: 100 },
      { id: "D", x: 150, y: 250 },
      { id: "E", x: 350, y: 250 },
      { id: "F", x: 500, y: 200 },
      { id: "G", x: 300, y: 350 }
    ],
    edges: [
      ["A", "B"],
      ["A", "D"],
      ["B", "C"],
      ["B", "E"],
      ["C", "F"],
      ["D", "E"],
      ["E", "F"],
      ["D", "G"],
      ["E", "G"]
    ]
  };

  // Build adjacency map for quick lookups
  const adjacency = {};
  graph.nodes.forEach(n => (adjacency[n.id] = []));
  graph.edges.forEach(([u, v]) => {
    adjacency[u].push(v);
    adjacency[v].push(u);
  });

  // Elements
  const svg = document.querySelector("svg");
  const startBtn = document.getElementById("startBtn");
  const nextBtn = document.getElementById("nextBtn");
  const resetBtn = document.getElementById("resetBtn");
  const logEl = document.getElementById("log");

  // State
  let selectedStartNode = null;
  let dfsStack = [];
  let visitedSet = new Set();
  let currentNode = null;
  let running = false;

  // Create SVG elements for edges
  function createEdges() {
    graph.edges.forEach(([u, v]) => {
      const nodeU = graph.nodes.find(n => n.id === u);
      const nodeV = graph.nodes.find(n => n.id === v);
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", nodeU.x);
      line.setAttribute("y1", nodeU.y);
      line.setAttribute("x2", nodeV.x);
      line.setAttribute("y2", nodeV.y);
      line.classList.add("edge");
      svg.appendChild(line);
    });
  }

  // Create SVG elements for nodes
  function createNodes() {
    graph.nodes.forEach(n => {
      const circle = document.createElementNS(svgNS, "circle");
      circle.setAttribute("cx", n.x);
      circle.setAttribute("cy", n.y);
      circle.setAttribute("r", 20);
      circle.classList.add("node");
      circle.setAttribute("id", `node-${n.id}`);
      circle.setAttribute("tabindex", "0");
      circle.setAttribute("role", "button");
      circle.setAttribute("aria-label", `Node ${n.id}`);
      circle.setAttribute("aria-pressed", "false");

      const text = document.createElementNS(svgNS, "text");
      text.setAttribute("x", n.x);
      text.setAttribute("y", n.y + 6);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("font-size", "16");
      text.setAttribute("pointer-events", "none"); // So clicks go to circle
      text.textContent = n.id;

      svg.appendChild(circle);
      svg.appendChild(text);

      circle.addEventListener("click", () => {
        if (running) return;
        selectStartNode(n.id);
      });
      circle.addEventListener("keydown", (evt) => {
        if (running) return;
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          selectStartNode(n.id);
        }
      });
    });
  }

  // Select start node visually and stateful
  function selectStartNode(nodeId) {
    if (running) return;
    if (selectedStartNode === nodeId) return; // already selected

    // Reset old selection
    if (selectedStartNode) {
      const old = document.getElementById(`node-${selectedStartNode}`);
      if (old) {
        old.setAttribute("aria-pressed", "false");
        old.classList.remove("selectedStart");
        old.classList.remove("current");
      }
    }
    selectedStartNode = nodeId;
    startBtn.disabled = false;
    log(`Selected start node: ${nodeId}`, true);

    const newEl = document.getElementById(`node-${nodeId}`);
    if (newEl) {
      newEl.classList.add("selectedStart");
      newEl.setAttribute("aria-pressed", "true");
    }
  }

  // Update node colors (clear + set visited + current + start)
  function updateNodeStyles() {
    graph.nodes.forEach(n => {
      const el = document.getElementById(`node-${n.id}`);
      if (!el) return;
      el.classList.remove("visited", "current");
      el.style.pointerEvents = running ? "none" : "auto"; // Disable clicking while running
    });

    visitedSet.forEach(id => {
      const el = document.getElementById(`node-${id}`);
      if (el) el.classList.add("visited");
    });

    if (currentNode) {
      const el = document.getElementById(`node-${currentNode}`);
      if (el) el.classList.add("current");
    }
  }

  // Log messages with auto-scroll
  function log(message, clear = false) {
    if (clear) logEl.textContent = "";
    const time = new Date().toLocaleTimeString();
    logEl.textContent += `[${time}] ${message}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }

  // DFS algorithm step (explicit stack)
  function dfsStep() {
    if(dfsStack.length === 0) {
      // Done
      log("DFS complete! No more nodes to visit.");
      running = false;
      currentNode = null;
      updateNodeStyles();
      nextBtn.disabled = true;
      startBtn.disabled = true;
      return;
    }

    currentNode = dfsStack.pop();
    if (visitedSet.has(currentNode)) {
      // Already visited, skip step and run next step immediately
      return dfsStep();
    }

    // Visit this node
    visitedSet.add(currentNode);
    log(`Visiting node ${currentNode}`);

    // Add neighbors to stack (in reverse alphabetical order for consistent order)
    const neighbors = adjacency[currentNode]
      .filter(n => !visitedSet.has(n))
      .sort()
      .reverse();
    neighbors.forEach(n => {
      dfsStack.push(n);
      log(`  Pushed neighbor ${n} to stack`);
    });

    updateNodeStyles();
  }

  // Start DFS: initialize stack and visited set
  function startDFS() {
    if (!selectedStartNode) {
      alert("Please select a start node by clicking on a node.");
      return;
    }
    running = true;
    startBtn.disabled = true;
    nextBtn.disabled = false;
    resetBtn.disabled = false;

    dfsStack = [selectedStartNode];
    visitedSet = new Set();
    currentNode = null;

    log("Starting DFS from node " + selectedStartNode, true);
    updateNodeStyles();
  }

  // Reset everything
  function reset() {
    running = false;
    selectedStartNode = null;
    dfsStack = [];
    visitedSet = new Set();
    currentNode = null;

    startBtn.disabled = true;
    nextBtn.disabled = true;

    // Remove start selection highlight
    graph.nodes.forEach(n => {
      const el = document.getElementById(`node-${n.id}`);
      if (el) {
        el.classList.remove("visited", "current", "selectedStart");
        el.setAttribute("aria-pressed", "false");
        el.style.pointerEvents = "auto";
      }
    });
    log("Reset completed. Please select a start node by clicking on a node.", true);
  }

  // Initialize SVG graph
  function init() {
    createEdges();
    createNodes();
    reset();
  }

  // Button handlers
  startBtn.addEventListener("click", () => {
    if (running) return;
    startDFS();
  });

  nextBtn.addEventListener("click", () => {
    if (!running) return;
    dfsStep();
  });

  resetBtn.addEventListener("click", () => {
    reset();
  });

  window.addEventListener("load", () => {
    init();
  });
})();
</script>
</body>
</html>