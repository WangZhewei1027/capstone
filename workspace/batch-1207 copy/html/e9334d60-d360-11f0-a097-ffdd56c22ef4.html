<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Adjacency Matrix Interactive Demo</title>
<style>
  :root { --bg:#f7f8fb; --card:#ffffff; --accent:#1f6feb; --muted:#6b7280; --danger:#ef4444; }
  body { margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:#0f172a; }
  .app { display:flex; gap:16px; padding:16px; box-sizing:border-box; height:100vh; }
  .panel { background:var(--card); border-radius:8px; box-shadow:0 2px 8px rgba(2,6,23,0.08); padding:12px; display:flex; flex-direction:column; }
  .left { flex:1 1 60%; min-width:320px; overflow:hidden; }
  .right { width:420px; min-width:300px; max-width:520px; overflow:auto; }
  .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px; }
  .controls button, .controls label { background:#fff; border:1px solid #e6e9ef; padding:6px 8px; border-radius:6px; cursor:pointer; }
  .controls input[type="checkbox"] { margin-right:6px; }
  .controls .active { background:linear-gradient(90deg,var(--accent),#60a5fa); color:#fff; border-color:transparent; }
  .svgwrap { border-radius:8px; background:linear-gradient(180deg,#fbfdff,#f6f9ff); padding:8px; height:calc(100% - 120px); display:flex; flex-direction:column; }
  svg { width:100%; height:100%; touch-action:none; cursor:default; user-select:none; }
  .info { font-size:13px; color:var(--muted); margin-top:8px; }
  table { border-collapse:collapse; width:100%; }
  .matrix-wrap { overflow:auto; max-height:72vh; border-radius:6px; border:1px solid #e6e9ef; }
  table.matrix { border-collapse:collapse; width:100%; min-width:320px; }
  table.matrix th, table.matrix td { border:1px solid #eef2f7; padding:6px; text-align:center; min-width:36px; font-family:monospace; font-size:13px; }
  table.matrix th { background:#fbfdff; position:sticky; top:0; z-index:2; }
  table.matrix th.col-head { position:sticky; left:0; z-index:3; background:#fbfdff; }
  td.cell { cursor:pointer; }
  td.cell:hover { background:rgba(31,111,235,0.06); }
  td.cell.active, td.cell.highlight { background:rgba(31,111,235,0.14); }
  .node { stroke:#0f172a; stroke-width:1px; fill:#fff; cursor:pointer; }
  .node.highlight { stroke:var(--accent); stroke-width:2px; }
  .edge { stroke:#94a3b8; stroke-width:2px; fill:none; }
  .edge.highlight { stroke:var(--accent); stroke-width:3px; }
  .weight-label { font-family:monospace; font-size:12px; fill:#0f172a; background:#fff; }
  .toolbar { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
  .small { font-size:13px; padding:6px 8px; }
  .muted { color:var(--muted); font-size:13px; }
  .textarea { width:100%; height:90px; box-sizing:border-box; border:1px solid #e6e9ef; border-radius:6px; padding:8px; font-family:monospace; }
  .footer { margin-top:8px; font-size:13px; color:var(--muted); }
  .topbar { display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; }
  .kbd { background:#fff; border:1px solid #e6e9ef; padding:2px 6px; border-radius:4px; font-family:monospace; font-size:12px; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .btn-danger { background:var(--danger); color:#fff; border:none; }
  .btn-ghost { background:transparent; border:1px dashed #e6e9ef; }
</style>
</head>
<body>
<div class="app">
  <div class="panel left">
    <div class="topbar">
      <div class="row">
        <div class="controls">
          <button id="addNodeBtn" class="small">Add Node</button>
          <button id="addEdgeBtn" class="small">Add Edge</button>
          <button id="deleteModeBtn" class="small">Delete</button>
          <label class="small"><input type="checkbox" id="directedChk"> Directed</label>
          <label class="small"><input type="checkbox" id="weightedChk"> Weighted</label>
          <label class="small"><input type="checkbox" id="selfLoopChk"> Self-loops</label>
          <button id="randomBtn" class="small">Random</button>
          <button id="clearBtn" class="small btn-danger">Clear</button>
        </div>
      </div>
      <div class="row">
        <div class="muted">Click nodes to add edges. Drag to move. Click matrix cells to toggle edges.</div>
      </div>
    </div>

    <div class="svgwrap">
      <svg id="canvas" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid slice">
        <defs>
          <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L10,5 L0,10 z" fill="#94a3b8"></path>
          </marker>
          <marker id="arrow-highlight" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L10,5 L0,10 z" fill="var(--accent)"></path>
          </marker>
        </defs>
        <g id="edges"></g>
        <g id="nodes"></g>
        <g id="labels"></g>
      </svg>
    </div>

    <div class="info">
      Controls: Add Node (click on canvas), Add Edge (click source then target), Delete mode (click node or edge), Directed/Weighted toggles. Click matrix cells to toggle edges; double-click to edit weight.
    </div>
  </div>

  <div class="panel right">
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
      <button id="exportBtn" class="small">Copy Matrix</button>
      <button id="importBtn" class="small">Import Matrix</button>
      <button id="fromAdjListBtn" class="small btn-ghost">Example</button>
    </div>

    <div class="matrix-wrap" id="matrixWrap" tabindex="0">
      <!-- adjacency matrix table injected here -->
    </div>

    <div style="margin-top:8px;">
      <textarea id="matrixText" class="textarea" placeholder="Paste numeric adjacency matrix here (rows separated by newlines, numbers separated by spaces or commas)"></textarea>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <button id="loadMatrixBtn" class="small">Build Graph from Matrix</button>
        <button id="clearTextBtn" class="small">Clear</button>
      </div>
    </div>

    <div class="footer">
      This demo keeps a list of nodes and edges and synchronizes a visual graph with its adjacency matrix. It supports directed/undirected graphs and optional edge weights.
    </div>
  </div>
</div>

<script>
/*
  Adjacency Matrix Interactive Demo
  - Click "Add Node" then click on SVG to add a node (or click Add Node repeatedly to create at random positions).
  - Toggle "Add Edge" then click two nodes to add an edge from first to second (or undirected if not directed).
  - Drag nodes to reposition.
  - Click matrix cells to toggle edges; double-click to edit weight.
  - Import/paste a numeric matrix to build graph.
*/

(() => {
  const svg = document.getElementById('canvas');
  const edgesGroup = document.getElementById('edges');
  const nodesGroup = document.getElementById('nodes');
  const labelsGroup = document.getElementById('labels');
  const matrixWrap = document.getElementById('matrixWrap');
  const matrixText = document.getElementById('matrixText');

  // Controls
  const addNodeBtn = document.getElementById('addNodeBtn');
  const addEdgeBtn = document.getElementById('addEdgeBtn');
  const deleteModeBtn = document.getElementById('deleteModeBtn');
  const directedChk = document.getElementById('directedChk');
  const weightedChk = document.getElementById('weightedChk');
  const selfLoopChk = document.getElementById('selfLoopChk');
  const randomBtn = document.getElementById('randomBtn');
  const clearBtn = document.getElementById('clearBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const loadMatrixBtn = document.getElementById('loadMatrixBtn');
  const fromAdjListBtn = document.getElementById('fromAdjListBtn');
  const clearTextBtn = document.getElementById('clearTextBtn');

  let mode = null; // 'addNode', 'addEdge', 'delete'
  let nodes = []; // {id, x, y}
  let edges = new Map(); // key -> {from, to, weight}
  let nextId = 0;
  let edgeSource = null;
  let dragging = null;
  let dragOffset = {x:0,y:0};

  // Utility
  function nodeKey(id) { return String(id); }
  function edgeKey(u,v, directed) {
    if (!directed) {
      // canonical order for undirected
      return u <= v ? `${u}|${v}` : `${v}|${u}`;
    }
    return `${u}|${v}`;
  }

  // Initial sample graph
  function initSample() {
    clearAll();
    addNodeAt(150,120);
    addNodeAt(420,80);
    addNodeAt(300,280);
    addNodeAt(650,210);
    addEdgeInternal(0,1,1);
    addEdgeInternal(1,2,2);
    addEdgeInternal(2,0,0.5);
    addEdgeInternal(2,3,3);
    directedChk.checked = false;
    weightedChk.checked = true;
    render();
  }

  // Add / remove nodes & edges
  function addNodeAt(x,y) {
    const id = nextId++;
    nodes.push({id,x,y});
    render();
    return id;
  }

  function removeNode(id) {
    nodes = nodes.filter(n => n.id !== id);
    // remove edges touching node
    for (const k of Array.from(edges.keys())) {
      const e = edges.get(k);
      if (e.from === id || e.to === id) edges.delete(k);
    }
    render();
  }

  function addEdgeInternal(u,v,weight=1) {
    if (!selfLoopChk.checked && u===v) return;
    const key = edgeKey(u,v, directedChk.checked);
    if (!edges.has(key)) {
      edges.set(key, {from:u, to:v, weight: weight});
    } else {
      // update weight
      edges.get(key).weight = weight;
    }
    render();
  }

  function removeEdgeInternal(u,v) {
    const key = edgeKey(u,v, directedChk.checked);
    edges.delete(key);
    render();
  }

  function toggleEdge(u,v) {
    const key = edgeKey(u,v, directedChk.checked);
    if (edges.has(key)) edges.delete(key);
    else addEdgeInternal(u,v, weightedChk.checked ? 1 : 1);
    render();
  }

  // Rendering
  function clearSVGGroup(g) { while (g.firstChild) g.removeChild(g.firstChild); }

  function render() {
    // Clear
    clearSVGGroup(edgesGroup);
    clearSVGGroup(nodesGroup);
    clearSVGGroup(labelsGroup);

    // Draw edges
    const directed = directedChk.checked;
    const used = new Set(); // for undirected, draw each pair once
    for (const e of edges.values()) {
      const key = edgeKey(e.from,e.to, directed);
      if (!directed) {
        // determine canonical key to avoid duplicate lines
        const canon = edgeKey(e.from,e.to, false);
        if (used.has(canon)) continue;
        used.add(canon);
      }
      const a = nodes.find(n=>n.id===e.from);
      const b = nodes.find(n=>n.id===e.to);
      if (!a || !b) continue;
      drawEdge(a,b,e, directed);
    }

    // Draw nodes
    for (const n of nodes) drawNode(n);

    // Draw labels (node ids)
    for (const n of nodes) {
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x',n.x);
      text.setAttribute('y',n.y+4);
      text.setAttribute('text-anchor','middle');
      text.setAttribute('font-size','12');
      text.setAttribute('fill','#0f172a');
      text.setAttribute('pointer-events','none');
      text.textContent = String(n.id);
      labelsGroup.appendChild(text);
    }

    buildMatrix();
  }

  function drawNode(n) {
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('class','node-g');
    g.dataset.id = n.id;
    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('cx', n.x);
    circle.setAttribute('cy', n.y);
    circle.setAttribute('r', 20);
    circle.setAttribute('class','node');
    circle.style.fill = '#fff';
    circle.style.stroke = '#0f172a';
    g.appendChild(circle);
    nodesGroup.appendChild(g);

    // Events
    g.addEventListener('pointerdown', (ev) => {
      ev.preventDefault();
      if (mode === 'addEdge') {
        if (edgeSource === null) {
          edgeSource = n.id;
          highlightNode(n.id,true);
        } else {
          // add edge from edgeSource -> n.id
          addEdgeInternal(edgeSource, n.id, weightedChk.checked ? 1 : 1);
          highlightNode(edgeSource,false);
          edgeSource = null;
        }
        return;
      }
      if (mode === 'delete') {
        // remove node
        removeNode(n.id);
        return;
      }
      // start dragging
      dragging = n.id;
      const pt = svg.createSVGPoint();
      pt.x = ev.clientX; pt.y = ev.clientY;
      const ctm = svg.getScreenCTM();
      const svgP = pt.matrixTransform(ctm.inverse());
      dragOffset.x = n.x - svgP.x;
      dragOffset.y = n.y - svgP.y;
      g.setPointerCapture(ev.pointerId);
    });

    g.addEventListener('pointerenter', () => {
      highlightNode(n.id,true);
      highlightMatrixCellsForNode(n.id,true);
    });
    g.addEventListener('pointerleave', () => {
      highlightNode(n.id,false);
      highlightMatrixCellsForNode(n.id,false);
    });
  }

  function highlightNode(id, on) {
    const circles = nodesGroup.querySelectorAll('g.node-g');
    for (const g of circles) {
      if (Number(g.dataset.id) === id) {
        const c = g.querySelector('circle.node');
        if (c) {
          if (on) c.classList.add('highlight'); else c.classList.remove('highlight');
        }
      }
    }
    // highlight edges adjacent
    for (const el of edgesGroup.querySelectorAll('path.edge')) {
      const f = el.dataset.from|0, t = el.dataset.to|0;
      if (f===id || t===id) {
        if (on) el.classList.add('highlight'); else el.classList.remove('highlight');
      }
    }
  }

  function highlightMatrixCellsForNode(id, on) {
    const tbl = matrixWrap.querySelector('table.matrix');
    if (!tbl) return;
    for (let r=0;r<nodes.length;r++){
      for (let c=0;c<nodes.length;c++){
        const cell = tbl.rows[r+1].cells[c+1]; // header offset
        if (!cell) continue;
        if (Number(tbl.rows[r+1].dataset.row)===id || Number(tbl.rows[0].cells[c+1].dataset.col)===id) {
          if (on) cell.classList.add('highlight'); else cell.classList.remove('highlight');
        }
      }
    }
  }

  function drawEdge(a,b,e, directed) {
    // compute line endpoints with offsets from node circle radius
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dist = Math.hypot(dx,dy) || 1;
    const r = 22;
    const sx = a.x + (dx/dist)*r;
    const sy = a.y + (dy/dist)*r;
    const ex = b.x - (dx/dist)*r;
    const ey = b.y - (dy/dist)*r;

    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    const d = `M ${sx} ${sy} L ${ex} ${ey}`;
    path.setAttribute('d',d);
    path.setAttribute('class','edge');
    path.dataset.from = e.from;
    path.dataset.to = e.to;
    if (directed) {
      path.setAttribute('marker-end','url(#arrow)');
    }
    // For highlighting arrow marker color update manually via class and marker; but we'll swap marker on hover by switching attribute
    path.addEventListener('pointerenter', () => {
      path.classList.add('highlight');
      if (directed) path.setAttribute('marker-end','url(#arrow-highlight)');
      highlightMatrixCellsForEdge(e, true);
    });
    path.addEventListener('pointerleave', () => {
      path.classList.remove('highlight');
      if (directed) path.setAttribute('marker-end','url(#arrow)');
      highlightMatrixCellsForEdge(e, false);
    });
    path.addEventListener('click', (ev) => {
      ev.stopPropagation();
      if (mode === 'delete') {
        // delete this edge
        const key = edgeKey(e.from,e.to,directed);
        edges.delete(key);
        render();
      } else if (mode === 'addEdge') {
        // pick this edge as source?
        edgeSource = e.from;
      }
    });
    edgesGroup.appendChild(path);

    // weight label
    if (weightedChk.checked) {
      const tx = (sx+ex)/2;
      const ty = (sy+ey)/2;
      const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
      txt.setAttribute('x',tx);
      txt.setAttribute('y',ty-6);
      txt.setAttribute('class','weight-label');
      txt.setAttribute('text-anchor','middle');
      txt.textContent = String(e.weight);
      labelsGroup.appendChild(txt);
    }
  }

  function highlightMatrixCellsForEdge(e,on) {
    const tbl = matrixWrap.querySelector('table.matrix');
    if (!tbl) return;
    const rows = nodes.map(n=>n.id);
    for (let r=0;r<nodes.length;r++){
      for (let c=0;c<nodes.length;c++){
        if (nodes[r].id === e.from && nodes[c].id === e.to) {
          const cell = tbl.rows[r+1].cells[c+1];
          if (cell) {
            if (on) cell.classList.add('highlight'); else cell.classList.remove('highlight');
          }
        }
        if (!directedChk.checked) {
          if (nodes[r].id === e.to && nodes[c].id === e.from) {
            const cell = tbl.rows[r+1].cells[c+1];
            if (cell) {
              if (on) cell.classList.add('highlight'); else cell.classList.remove('highlight');
            }
          }
        }
      }
    }
  }

  // Matrix building & interactions
  function buildMatrix() {
    // Create matrix NxN table
    const n = nodes.length;
    const tbl = document.createElement('table');
    tbl.className = 'matrix';
    const thead = document.createElement('thead');
    const headRow = document.createElement('tr');
    const empty = document.createElement('th'); headRow.appendChild(empty);
    // columns header (node ids)
    for (const c of nodes) {
      const th = document.createElement('th');
      th.textContent = c.id;
      th.dataset.col = c.id;
      headRow.appendChild(th);
    }
    thead.appendChild(headRow);
    tbl.appendChild(thead);

    const tbody = document.createElement('tbody');
    // Fill rows
    for (let i=0;i<n;i++) {
      const row = document.createElement('tr');
      row.dataset.row = nodes[i].id;
      const th = document.createElement('th');
      th.className = 'col-head';
      th.textContent = nodes[i].id;
      row.appendChild(th);
      for (let j=0;j<n;j++) {
        const td = document.createElement('td');
        td.className = 'cell';
        const u = nodes[i].id;
        const v = nodes[j].id;
        let val = 0;
        if (directedChk.checked) {
          const key = edgeKey(u,v,true);
          if (edges.has(key)) val = edges.get(key).weight ?? 1;
        } else {
          const key = edgeKey(u,v,false);
          if (edges.has(key)) {
            const e = edges.get(key);
            // for undirected, present the same weight both places
            val = e.weight ?? 1;
          }
        }
        td.textContent = String(val);
        td.dataset.u = u; td.dataset.v = v;
        td.addEventListener('click', (ev) => {
          ev.stopPropagation();
          // toggle edge (use directed mode setting at the time)
          if (mode === 'delete') {
            // delete if present
            const key = edgeKey(u,v,directedChk.checked);
            if (edges.has(key)) edges.delete(key);
          } else {
            // toggle
            const key = edgeKey(u,v,directedChk.checked);
            if (edges.has(key)) edges.delete(key);
            else {
              // if weighted, default weight 1
              addEdgeInternal(u,v, weightedChk.checked ? 1 : 1);
            }
          }
          render();
        });
        td.addEventListener('dblclick', (ev) => {
          ev.stopPropagation();
          // edit weight if weighted
          const newW = prompt(`Enter weight for edge ${u} -> ${v} (empty to remove)`, td.textContent);
          if (newW === null) return;
          const trimmed = newW.trim();
          if (trimmed === '') {
            // remove edge
            const key = edgeKey(u,v,directedChk.checked);
            edges.delete(key);
          } else {
            const num = Number(trimmed);
            if (Number.isNaN(num)) { alert('Invalid number'); return; }
            addEdgeInternal(u,v,num);
          }
          render();
        });
        td.addEventListener('mouseenter', () => {
          // highlight corresponding nodes/edges
          highlightCell(u,v,true);
        });
        td.addEventListener('mouseleave', () => {
          highlightCell(u,v,false);
        });

        row.appendChild(td);
      }
      tbody.appendChild(row);
    }
    tbl.appendChild(tbody);

    // replace matrixWrap content
    matrixWrap.innerHTML = '';
    matrixWrap.appendChild(tbl);
  }

  function highlightCell(u,v,on) {
    // highlight nodes u and v and the edge (u->v)
    highlightNode(u,on);
    highlightNode(v,on);
    // edges
    for (const el of edgesGroup.querySelectorAll('path.edge')) {
      const f = Number(el.dataset.from), t = Number(el.dataset.to);
      if (directedChk.checked) {
        if (f===u && t===v) {
          if (on) { el.classList.add('highlight'); el.setAttribute('marker-end','url(#arrow-highlight)'); }
          else { el.classList.remove('highlight'); el.setAttribute('marker-end','url(#arrow)'); }
        }
      } else {
        // undirected: match either orientation
        if ((f===u && t===v) || (f===v && t===u) || (f===u && t===v)) {
          if (on) el.classList.add('highlight'); else el.classList.remove('highlight');
        }
      }
    }
  }

  // Events: svg click to add node
  svg.addEventListener('pointerdown', (ev) => {
    if (mode === 'addNode') {
      // add at mouse pos
      const pt = svg.createSVGPoint();
      pt.x = ev.clientX; pt.y = ev.clientY;
      const ctm = svg.getScreenCTM();
      const p = pt.matrixTransform(ctm.inverse());
      addNodeAt(p.x, p.y);
    }
  });

  // pointermove for dragging
  svg.addEventListener('pointermove', (ev) => {
    if (dragging !== null) {
      const pt = svg.createSVGPoint();
      pt.x = ev.clientX; pt.y = ev.clientY;
      const ctm = svg.getScreenCTM();
      const p = pt.matrixTransform(ctm.inverse());
      const n = nodes.find(x=>x.id===dragging);
      if (n) {
        n.x = p.x + dragOffset.x;
        n.y = p.y + dragOffset.y;
        render();
      }
    }
  });
  // pointerup stop dragging
  svg.addEventListener('pointerup', (ev) => {
    if (dragging !== null) {
      // release pointer capture on node if any
      const g = nodesGroup.querySelector(`g.node-g[data-id="${dragging}"]`);
      if (g) {
        try { g.releasePointerCapture(ev.pointerId); } catch(e){}
      }
      dragging = null;
    }
  });

  // Control actions
  addNodeBtn.addEventListener('click', () => {
    setMode('addNode');
    addNodeBtn.classList.toggle('active', mode==='addNode');
  });
  addEdgeBtn.addEventListener('click', () => {
    setMode('addEdge');
    addEdgeBtn.classList.toggle('active', mode==='addEdge');
    edgeSource = null;
  });
  deleteModeBtn.addEventListener('click', () => {
    setMode('delete');
    deleteModeBtn.classList.toggle('active', mode==='delete');
  });

  directedChk.addEventListener('change', () => {
    // When switching between directed and undirected, we need to possibly consolidate or separate edges.
    if (!directedChk.checked) {
      // undirected: convert any pair u->v and v->u into single canonical edge with weight of first found
      const newEdges = new Map();
      for (const e of edges.values()) {
        const k = edgeKey(e.from,e.to,false);
        if (!newEdges.has(k)) newEdges.set(k, {from: e.from, to: e.to, weight: e.weight});
      }
      edges = newEdges;
    } else {
      // directed: keep as is; undirected entries remain as single key; when viewing as directed, interpret each as inserted edge in canonical orientation
      // expand undirected edges into one directed edge (keep the stored from,to)
      const newEdges = new Map();
      for (const e of edges.values()) {
        const k = edgeKey(e.from,e.to,true);
        newEdges.set(k, {from:e.from, to:e.to, weight:e.weight});
      }
      edges = newEdges;
    }
    render();
  });

  weightedChk.addEventListener('change', () => {
    // If weights disabled, remove numeric weights display but keep numbers internally
    render();
  });

  randomBtn.addEventListener('click', () => {
    // generate random graph with current directed/weighted settings
    clearAll();
    const count = Math.floor(Math.random()*5)+4;
    for (let i=0;i<count;i++) addNodeAt(120 + Math.random()*760, 80 + Math.random()*520);
    const density = 0.25 + Math.random()*0.45;
    for (let i=0;i<nodes.length;i++){
      for (let j=0;j<nodes.length;j++){
        if (i===j && !selfLoopChk.checked) continue;
        if (Math.random() < density) {
          const w = weightedChk.checked ? (Math.round((Math.random()*9+0.1)*10)/10) : 1;
          addEdgeInternal(nodes[i].id, nodes[j].id, w);
        }
      }
    }
    render();
  });

  clearBtn.addEventListener('click', () => {
    if (!confirm('Clear all nodes and edges?')) return;
    clearAll();
    render();
  });

  exportBtn.addEventListener('click', () => {
    const text = adjacencyMatrixToText();
    navigator.clipboard?.writeText(text).then(()=> {
      alert('Matrix copied to clipboard');
    }).catch(()=>{
      // fallback: select textarea
      matrixText.value = text;
      matrixText.select();
    });
  });

  importBtn.addEventListener('click', () => {
    alert('Paste a numeric adjacency matrix into the textarea on the right, then click "Build Graph from Matrix".');
  });

  loadMatrixBtn.addEventListener('click', () => {
    const txt = matrixText.value.trim();
    if (!txt) { alert('Paste matrix first'); return; }
    const matrix = parseMatrixText(txt);
    if (!matrix) { alert('Could not parse matrix. Ensure rows of numbers separated by spaces, commas, or tabs.'); return; }
    buildFromMatrix(matrix);
  });

  fromAdjListBtn.addEventListener('click', ()=> {
    // Example adjacency matrix
    matrixText.value = "0 1 0 1\n1 0 1 0\n0 1 0 1\n1 0 1 0";
  });

  clearTextBtn.addEventListener('click', ()=> { matrixText.value=''; });

  // Helpers
  function setMode(m) {
    mode = (mode === m) ? null : m;
    // update button visuals
    addNodeBtn.classList.toggle('active', mode==='addNode');
    addEdgeBtn.classList.toggle('active', mode==='addEdge');
    deleteModeBtn.classList.toggle('active', mode==='delete');
    edgeSource = null;
  }

  function clearAll() {
    nodes = [];
    edges = new Map();
    nextId = 0;
    edgeSource = null;
    dragging = null;
  }

  function adjacencyMatrixToText() {
    // rows of numbers separated by spaces
    const ids = nodes.map(n=>n.id);
    const n = nodes.length;
    const lines = [];
    for (let i=0;i<n;i++){
      const row = [];
      for (let j=0;j<n;j++){
        const u = nodes[i].id;
        const v = nodes[j].id;
        let val = 0;
        if (directedChk.checked) {
          const key = edgeKey(u,v,true);
          if (edges.has(key)) val = edges.get(key).weight ?? 1;
        } else {
          const key = edgeKey(u,v,false);
          if (edges.has(key)) val = edges.get(key).weight ?? 1;
        }
        row.push(String(val));
      }
      lines.push(row.join(' '));
    }
    return lines.join('\n');
  }

  function parseMatrixText(txt) {
    const rows = txt.trim().split(/\r?\n/).map(r=>r.trim()).filter(Boolean);
    const matrix = [];
    for (const r of rows) {
      const parts = r.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean);
      const nums = parts.map(p=>Number(p));
      if (nums.some(x=>Number.isNaN(x))) return null;
      matrix.push(nums);
    }
    // ensure square: if not square, return null
    const m = matrix.length;
    if (matrix.some(row => row.length !== m)) return null;
    return matrix;
  }

  function buildFromMatrix(mat) {
    clearAll();
    const n = mat.length;
    for (let i=0;i<n;i++) {
      addNodeAt(100 + (i%5)*140 + Math.random()*20, 100 + Math.floor(i/5)*160 + Math.random()*20);
    }
    // By default treat as directed if any asymmetry found; else as undirected
    let directed = false;
    for (let i=0;i<n;i++){
      for (let j=0;j<n;j++){
        if (mat[i][j] !== mat[j][i]) directed = true;
      }
    }
    directedChk.checked = directed;
    // add edges
    for (let i=0;i<n;i++){
      for (let j=0;j<n;j++){
        const val = mat[i][j];
        if (!val) continue;
        const u = nodes[i].id, v = nodes[j].id;
        if (!directed) {
          if (i<=j) addEdgeInternal(u,v,val);
        } else {
          addEdgeInternal(u,v,val);
        }
      }
    }
    render();
  }

  // init
  initSample();
})();
</script>
</body>
</html>