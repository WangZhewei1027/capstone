<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Topological Sort Visualizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{--bg:#121212;--panel:#1e1e1e;--accent:#4fc3f7;--muted:#9aa3ad;--success:#7ed957;--danger:#ff6b6b;}
  body{margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;background:linear-gradient(180deg,#0f1720,#081016);color:#e6eef6;display:flex;height:100vh;overflow:hidden}
  .sidebar{width:360px;background:var(--panel);padding:16px;box-sizing:border-box;display:flex;flex-direction:column;gap:12px;overflow:auto}
  .title{font-size:20px;font-weight:700;display:flex;align-items:center;gap:10px}
  .controls{display:flex;flex-wrap:wrap;gap:8px}
  button,select,input[type=range]{background:#0b1220;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 10px;border-radius:6px;cursor:pointer}
  button.active{outline:2px solid rgba(79,195,247,0.2)}
  .small{padding:6px 8px;font-size:13px}
  .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  .info{font-size:13px;color:var(--muted);line-height:1.4}
  .canvas-wrap{flex:1;background:linear-gradient(180deg,#071426,#05111a);display:flex;align-items:stretch;justify-content:center;padding:12px;position:relative}
  svg{width:100%;height:100%;border-radius:8px}
  .status{position:absolute;left:24px;bottom:24px;padding:8px 12px;border-radius:8px;background:rgba(0,0,0,0.35);backdrop-filter:blur(6px);font-size:13px;border:1px solid rgba(255,255,255,0.03)}
  .legend{display:flex;gap:8px;flex-wrap:wrap}
  .chip{padding:6px 8px;border-radius:6px;font-size:13px;background:rgba(255,255,255,0.02)}
  .list{font-family:monospace;background:#0b1220;padding:8px;border-radius:6px;overflow:auto;max-height:140px}
  .footer{margin-top:auto;font-size:12px;color:var(--muted)}
  input[type=number]{width:70px;padding:6px 8px;border-radius:6px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .hint{font-size:13px;color:var(--muted);margin-top:6px}
  .error{color:var(--danger);font-weight:700}
  .ok{color:var(--success);font-weight:700}
  .node-label{pointer-events:none;fill:#fff;font-size:12px;font-weight:700;text-anchor:middle;dominant-baseline:central}
  .edge{stroke:#8fa8bd;stroke-width:2;fill:none;opacity:0.9}
  .edge.cycle{stroke:var(--danger);opacity:1}
  .node{cursor:pointer;stroke:#101418;stroke-width:2}
  .node.normal{fill:#0b6b8a}
  .node.selected{fill:#4fc3f7;stroke:#0b1220}
  .node.zero{fill:#7ed957}
  .node.gray{fill:#f6c85f}
  .node.black{fill:#7a7a7a}
  .controls-row{display:flex;gap:8px;align-items:center}
  .title small{font-size:12px;color:var(--muted);font-weight:500}
  .muted{color:var(--muted)}
  a{color:var(--accent);text-decoration:none}
  .topo-output{font-family:monospace;padding:8px;border-radius:6px;background:#071724}
</style>
</head>
<body>
  <div class="sidebar">
    <div class="title">Topological Sort Visualizer <small> (Kahn & DFS)</small></div>
    <div class="panel">
      <div class="controls-row" style="justify-content:space-between">
        <div style="display:flex;gap:8px">
          <button id="addNodeBtn" class="small">Add node</button>
          <button id="edgeModeBtn" class="small">Add edge</button>
          <button id="delModeBtn" class="small">Delete</button>
        </div>
        <div style="display:flex;gap:8px">
          <button id="clearBtn" class="small">Clear</button>
        </div>
      </div>
      <div class="hint">Click a node to select it. In "Add edge" mode click source then destination to create an edge. Drag nodes to reposition.</div>
    </div>

    <div class="panel">
      <label>Quick graph</label>
      <div style="display:flex;gap:8px;align-items:center">
        <input id="randN" type="number" min="1" max="26" value="6"/>
        <input id="randP" type="number" min="0" max="100" value="25"/>% prob
        <button id="randBtn" class="small">Generate</button>
      </div>
      <div class="hint">Generates a random directed graph (may contain cycles).</div>
    </div>

    <div class="panel">
      <label>Algorithms</label>
      <div class="controls">
        <button id="kahnBtn" class="small">Run Kahn's algorithm</button>
        <button id="kahnStepBtn" class="small">Step</button>
        <button id="kahnPlayBtn" class="small">Play</button>
        <button id="kahnStopBtn" class="small">Reset</button>
      </div>
      <div style="height:8px"></div>
      <div class="controls">
        <button id="dfsBtn" class="small">Run DFS topo</button>
        <button id="dfsStepBtn" class="small">Step</button>
        <button id="dfsPlayBtn" class="small">Play</button>
        <button id="dfsStopBtn" class="small">Reset</button>
      </div>
      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <label style="margin:0">Speed</label>
        <input id="speed" type="range" min="200" max="1500" value="700">
      </div>
    </div>

    <div class="panel">
      <label>Algorithm state</label>
      <div style="display:flex;gap:8px">
        <div style="flex:1">
          <div class="muted">Indegrees</div>
          <div id="indegrees" class="list"></div>
        </div>
        <div style="flex:1">
          <div class="muted">Queue / Stack</div>
          <div id="queue" class="list"></div>
        </div>
      </div>
      <div style="margin-top:8px">
        <div class="muted">Output (topological order so far)</div>
        <div id="output" class="topo-output"></div>
      </div>
    </div>

    <div class="panel">
      <label>Legend & status</label>
      <div class="legend" style="margin-bottom:8px">
        <div class="chip">Blue: normal node</div>
        <div class="chip">Cyan: selected</div>
        <div class="chip">Green: zero indegree (Kahn)</div>
        <div class="chip">Yellow: visiting (DFS)</div>
        <div class="chip">Gray: finished (DFS)</div>
      </div>
      <div id="status" class="info">Ready</div>
    </div>

    <div class="footer">Tip: Try creating a cycle to see detection. Implemented: Kahn's algorithm (BFS indegree) and DFS-based topological sort.</div>
  </div>

  <div class="canvas-wrap">
    <svg id="svg" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid meet">
      <defs>
        <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L10,5 L0,10 z" fill="#8fa8bd"/>
        </marker>
        <marker id="arrow-red" markerWidth="10" markerHeight="10" refX="10" refY="5" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L10,5 L0,10 z" fill="#ff6b6b"/>
        </marker>
      </defs>
      <g id="edges"></g>
      <g id="nodes"></g>
    </svg>
    <div class="status">
      <div><strong>Mode:</strong> <span id="modeLabel">Idle</span></div>
      <div style="margin-top:6px"><strong>Selected:</strong> <span id="selectedLabel">None</span></div>
    </div>
  </div>

<script>
(function(){
  // Simple topological sort visualizer with interactive graph building
  const svg = document.getElementById('svg');
  const edgesG = document.getElementById('edges');
  const nodesG = document.getElementById('nodes');
  const addNodeBtn = document.getElementById('addNodeBtn');
  const edgeModeBtn = document.getElementById('edgeModeBtn');
  const delModeBtn = document.getElementById('delModeBtn');
  const clearBtn = document.getElementById('clearBtn');
  const randBtn = document.getElementById('randBtn');
  const randN = document.getElementById('randN');
  const randP = document.getElementById('randP');
  const modeLabel = document.getElementById('modeLabel');
  const selectedLabel = document.getElementById('selectedLabel');
  const status = document.getElementById('status');

  const indegEl = document.getElementById('indegrees');
  const queueEl = document.getElementById('queue');
  const outputEl = document.getElementById('output');

  const kahnBtn = document.getElementById('kahnBtn');
  const kahnStepBtn = document.getElementById('kahnStepBtn');
  const kahnPlayBtn = document.getElementById('kahnPlayBtn');
  const kahnStopBtn = document.getElementById('kahnStopBtn');

  const dfsBtn = document.getElementById('dfsBtn');
  const dfsStepBtn = document.getElementById('dfsStepBtn');
  const dfsPlayBtn = document.getElementById('dfsPlayBtn');
  const dfsStopBtn = document.getElementById('dfsStopBtn');

  const speedInput = document.getElementById('speed');

  let nodes = []; // {id,label,x,y,el,circle,txt}
  let edges = []; // {from,to,el,path}
  let nextId = 0;

  let mode = 'idle'; // 'idle','edge','delete'
  let selectedNode = null;
  let edgeFrom = null;

  let drag = {node:null,offsetX:0,offsetY:0};

  // Algorithm state controllers
  let kahnRunner = null;
  let kahnTimer = null;
  let dfsRunner = null;
  let dfsTimer = null;

  function setMode(m){
    mode = m;
    modeLabel.textContent = m === 'idle' ? 'Idle' : m === 'edge' ? 'Add edge' : 'Delete';
    addNodeBtn.classList.toggle('active', m==='idle' && false);
    edgeModeBtn.classList.toggle('active', m==='edge');
    delModeBtn.classList.toggle('active', m==='delete');
    edgeFrom = null;
    updateSelectedLabel();
  }

  addNodeBtn.addEventListener('click', ()=>{ addNodeAt(Math.random()*1000+100, Math.random()*500+100); });

  edgeModeBtn.addEventListener('click', ()=> setMode(mode==='edge' ? 'idle' : 'edge'));
  delModeBtn.addEventListener('click', ()=> setMode(mode==='delete' ? 'idle' : 'delete'));
  clearBtn.addEventListener('click', ()=> { clearGraph(); setStatus('Cleared graph'); });

  randBtn.addEventListener('click', ()=> {
    const n = Math.max(1, Math.min(26, parseInt(randN.value)||6));
    const p = Math.max(0, Math.min(100, parseInt(randP.value)||20));
    generateRandom(n, p/100);
  });

  function addNodeAt(x,y,label){
    const id = nextId++;
    const lbl = label || idToLabel(id);
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform', `translate(${x},${y})`);
    g.style.cursor = 'pointer';
    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('r', 26);
    circle.setAttribute('class','node normal');
    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('class','node-label');
    text.textContent = lbl;
    g.appendChild(circle);
    g.appendChild(text);
    nodesG.appendChild(g);
    const node = {id, label:lbl, x, y, g, circle, text};
    nodes.push(node);

    g.addEventListener('mousedown', (ev)=>onNodeMouseDown(ev,node));
    g.addEventListener('click', (ev)=>onNodeClick(ev,node));
    render();
    setStatus(`Added node ${lbl}`);
    return node;
  }

  function idToLabel(i){
    // A, B, ... Z, A1, B1 ...
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    if(i < 26) return letters[i];
    return letters[i%26] + Math.floor(i/26);
  }

  function onNodeMouseDown(ev,node){
    ev.stopPropagation();
    if(mode === 'delete'){ deleteNode(node); return; }
    drag.node = node;
    const pt = svg.createSVGPoint();
    pt.x = ev.clientX; pt.y = ev.clientY;
    const ctm = svg.getScreenCTM().inverse();
    const loc = pt.matrixTransform(ctm);
    drag.offsetX = loc.x - node.x; drag.offsetY = loc.y - node.y;
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
  }

  function onMouseMove(ev){
    if(!drag.node) return;
    const pt = svg.createSVGPoint();
    pt.x = ev.clientX; pt.y = ev.clientY;
    const ctm = svg.getScreenCTM().inverse();
    const loc = pt.matrixTransform(ctm);
    drag.node.x = loc.x - drag.offsetX;
    drag.node.y = loc.y - drag.offsetY;
    drag.node.g.setAttribute('transform', `translate(${drag.node.x},${drag.node.y})`);
    updateEdgesForNode(drag.node);
  }

  function onMouseUp(){
    drag.node = null;
    window.removeEventListener('mousemove', onMouseMove);
    window.removeEventListener('mouseup', onMouseUp);
  }

  function onNodeClick(ev,node){
    ev.stopPropagation();
    if(mode === 'edge'){
      if(!edgeFrom){ edgeFrom = node; setStatus('Pick destination node'); updateSelectedLabel(); highlightNodeEdge(edgeFrom, true); return; }
      if(edgeFrom === node){ setStatus('Cannot create self-loop'); highlightNodeEdge(edgeFrom,false); edgeFrom=null; updateSelectedLabel(); return; }
      addEdge(edgeFrom, node);
      setStatus(`Edge ${edgeFrom.label} → ${node.label} added`);
      highlightNodeEdge(edgeFrom,false);
      edgeFrom = null; updateSelectedLabel();
      render();
      return;
    }
    if(mode === 'delete'){
      // delete edges incident to node then node
      deleteNode(node);
      return;
    }
    // select node (for highlighting)
    if(selectedNode === node){ selectedNode = null; } else selectedNode = node;
    updateSelectedLabel();
    render();
  }

  function updateSelectedLabel(){
    selectedLabel.textContent = selectedNode ? selectedNode.label : 'None';
  }

  function highlightNodeEdge(node, on){
    if(!node) return;
    node.circle.classList.toggle('selected', on);
  }

  function addEdge(u,v){
    // prevent duplicates
    if(edges.find(e=>e.from===u && e.to===v)) return;
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('class','edge');
    path.setAttribute('marker-end','url(#arrow)');
    edgesG.appendChild(path);
    const e = {from:u,to:v, path};
    edges.push(e);
    updateEdgesForNode(u);
    updateEdgesForNode(v);
  }

  function deleteEdge(edge){
    edges = edges.filter(e=>e!==edge);
    if(edge.path && edge.path.parentNode) edge.path.parentNode.removeChild(edge.path);
    render();
  }

  function deleteNode(node){
    // remove edges incident to node
    edges.filter(e=>e.from===node || e.to===node).forEach(e=>deleteEdge(e));
    nodes = nodes.filter(n=>n!==node);
    if(node.g && node.g.parentNode) node.g.parentNode.removeChild(node.g);
    setStatus(`Deleted node ${node.label}`);
    render();
  }

  function clearGraph(){
    nodes.forEach(n=>{ if(n.g && n.g.parentNode) n.g.parentNode.removeChild(n.g); });
    edges.forEach(e=>{ if(e.path && e.path.parentNode) e.path.parentNode.removeChild(e.path); });
    nodes = []; edges = []; nextId = 0;
    selectedNode = null; edgeFrom = null;
    setMode('idle');
    stopAll();
    render();
  }

  function updateEdgesForNode(node){
    edges.forEach(e=> {
      if(e.from===node || e.to===node) updateEdgePath(e);
    });
  }

  function updateEdgePath(e){
    const from = e.from, to = e.to;
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const dist = Math.sqrt(dx*dx+dy*dy);
    const r = 26;
    // start and end points offset by circle radius
    const ux = dx/dist, uy = dy/dist;
    const startX = from.x + ux*r;
    const startY = from.y + uy*r;
    const endX = to.x - ux*(r+6); // stop a bit before arrow marker
    const endY = to.y - uy*(r+6);
    // simple curved path for readability if nodes are nearby
    const midX = (startX + endX)/2 - uy*40;
    const midY = (startY + endY)/2 + ux*40;
    const d = `M ${startX} ${startY} Q ${midX} ${midY} ${endX} ${endY}`;
    e.path.setAttribute('d', d);
  }

  function render(){
    // update nodes positions and classes
    nodes.forEach(n=>{
      n.g.setAttribute('transform', `translate(${n.x},${n.y})`);
      n.text.textContent = n.label;
      // classes
      n.circle.classList.remove('selected','zero','gray','black','normal');
      if(edgeFrom === n) n.circle.classList.add('selected');
      else if(selectedNode === n) n.circle.classList.add('selected');
      else n.circle.classList.add('normal');
    });
    // update edges
    edges.forEach(e=> updateEdgePath(e));
    updateIndegreesDisplay();
    updateQueueDisplay([]);
    updateOutputDisplay([]);
  }

  // Build adjacency and indegree
  function buildGraph(){
    const adj = new Map();
    const indeg = new Map();
    nodes.forEach(n=>{ adj.set(n,[]); indeg.set(n,0); });
    edges.forEach(e=>{
      if(!adj.has(e.from) || !adj.has(e.to)) return;
      adj.get(e.from).push(e.to);
      indeg.set(e.to, indeg.get(e.to)+1);
    });
    return {adj, indeg};
  }

  function updateIndegreesDisplay(map){
    const g = map || buildGraph().indeg;
    let txt = '';
    nodes.forEach(n=>{
      const v = g.get(n)??0;
      txt += `${n.label}: ${v}\n`;
    });
    indegEl.textContent = txt;
  }
  function updateQueueDisplay(arr){ queueEl.textContent = (arr||[]).map(x=>x.label || x).join('  '); }
  function updateOutputDisplay(arr){ outputEl.textContent = (arr||[]).map(n=>n.label || n).join(' → '); }

  function setStatus(txt, cls){
    status.textContent = txt;
    if(cls==='error') status.classList.add('error'); else status.classList.remove('error');
  }

  // Kahn's algorithm as a generator of steps for animation
  function* kahnGenerator(){
    const {adj, indeg} = buildGraph();
    // create a working copy
    const indegW = new Map(indeg);
    const Q = [];
    for(const [node,d] of indegW.entries()) if(d===0) Q.push(node);
    // sort queue by label for deterministic output
    Q.sort((a,b)=>a.label.localeCompare(b.label));
    yield {phase:'init', indeg: new Map(indegW), queue:Q.slice(), output:[]};
    const out = [];
    while(Q.length){
      const u = Q.shift();
      yield {phase:'pop', node:u, indeg: new Map(indegW), queue:Q.slice(), output: out.slice()};
      out.push(u);
      // decrease neighbors one by one (yield per neighbor)
      for(const v of adj.get(u) || []){
        indegW.set(v, indegW.get(v)-1);
        yield {phase:'decr', from:u, to:v, indeg: new Map(indegW), queue: Q.slice(), output: out.slice()};
        if(indegW.get(v)===0){
          Q.push(v);
          Q.sort((a,b)=>a.label.localeCompare(b.label));
          yield {phase:'push', node:v, indeg:new Map(indegW), queue:Q.slice(), output:out.slice()};
        }
      }
    }
    yield {phase:'done', indeg:new Map(indegW), queue:Q.slice(), output:out.slice()};
    // if not all nodes processed, there is a cycle
  }

  function runKahnStep(){
    if(!kahnRunner) kahnRunner = kahnGenerator();
    const step = kahnRunner.next();
    if(step.done){ setStatus('Kahn finished'); kahnRunner=null; return; }
    applyKahnStep(step.value);
  }

  function applyKahnStep(s){
    // highlight according to phase
    clearNodeStyles();
    if(s.phase==='init'){
      setStatus('Kahn init');
    } else if(s.phase==='pop'){
      setStatus(`Pop ${s.node.label} from queue`);
      highlightNode(s.node,'zero');
    } else if(s.phase==='decr'){
      setStatus(`Decrement indegree: ${s.to.label} (from ${s.from.label})`);
      highlightNode(s.from,'selected'); highlightNode(s.to,'gray');
      // highlight edge
      highlightEdge(s.from,s.to);
    } else if(s.phase==='push'){
      setStatus(`Push ${s.node.label} to queue (now zero indegree)`);
      highlightNode(s.node,'zero');
    } else if(s.phase==='done'){
      setStatus('Kahn finished');
    }
    // update displays
    updateIndegreesDisplay(s.indeg);
    updateQueueDisplay(s.queue);
    updateOutputDisplay(s.output);
    // final check for cycle at done
    if(s.phase==='done'){
      if(s.output.length < nodes.length){
        setStatus('Cycle detected — no topological ordering (Kahn)', 'error');
        // mark cycle edges/nodes crudely: nodes not in output are part of cycle(s)
        const outSet = new Set(s.output);
        nodes.forEach(n=>{ if(!outSet.has(n)) n.circle.classList.add('cycle'); });
        edges.forEach(e=>{
          if(!outSet.has(e.from) && !outSet.has(e.to)) e.path.classList.add('cycle');
        });
      } else {
        setStatus('Topological order (Kahn) complete');
      }
      kahnRunner = null;
      stopKahnTimer();
    }
  }

  function highlightNode(node, cls){
    node.circle.classList.remove('normal','selected','zero','gray','black');
    node.circle.classList.add(cls);
  }

  function clearNodeStyles(){
    nodes.forEach(n=>{
      n.circle.classList.remove('selected','zero','gray','black','cycle');
      n.circle.classList.add('normal');
    });
    edges.forEach(e=> e.path.classList.remove('cycle'));
  }

  function highlightEdge(u,v){
    edges.forEach(e=>{
      if(e.from===u && e.to===v) e.path.classList.add('cycle');
      else e.path.classList.remove('cycle');
    });
  }

  function playKahn(){
    if(kahnTimer) return;
    if(!kahnRunner) kahnRunner = kahnGenerator();
    kahnTimer = setInterval(()=> {
      const nxt = kahnRunner.next();
      if(nxt.done){ applyKahnStep(nxt.value); stopKahnTimer(); return; }
      applyKahnStep(nxt.value);
    }, parseInt(speedInput.value) || 700);
  }

  function stopKahnTimer(){ if(kahnTimer) clearInterval(kahnTimer); kahnTimer=null; kahnRunner=null; }

  // DFS topological sort generator
  function* dfsGenerator(){
    const {adj} = buildGraph();
    const color = new Map(); // white undefined, gray 'gray', black 'black'
    const order = [];
    const nodesList = Array.from(adj.keys()).sort((a,b)=>a.label.localeCompare(b.label));
    // simulate recursion with explicit stack frames: {node, iter, returning}
    function* visit(u){
      color.set(u,'gray');
      yield {phase:'visit', node:u, color: new Map(color), order: order.slice()};
      const neighbors = adj.get(u) || [];
      for(const v of neighbors){
        if(!color.get(v)){
          // recurse
          yield* visit(v);
        } else if(color.get(v) === 'gray'){
          // back edge -> cycle
          yield {phase:'backedge', from:u, to:v, color:new Map(color), order:order.slice()};
        }
      }
      color.set(u,'black');
      order.push(u);
      yield {phase:'finish', node:u, color:new Map(color), order:order.slice()};
    }

    for(const u of nodesList){
      if(!color.get(u)){
        yield* visit(u);
      }
    }
    yield {phase:'done', color:new Map(color), order: order.slice().reverse()}; // return reversed
  }

  function runDfsStep(){
    if(!dfsRunner) dfsRunner = dfsGenerator();
    const step = dfsRunner.next();
    if(step.done){ setStatus('DFS finished'); dfsRunner=null; return; }
    applyDfsStep(step.value);
  }

  function applyDfsStep(s){
    clearNodeStyles();
    if(s.phase==='visit'){
      setStatus(`Visiting ${s.node.label}`);
      s.color.forEach((c,node)=> {
        node.circle.classList.remove('normal','selected','zero','gray','black');
        if(c==='gray') node.circle.classList.add('gray');
        else if(c==='black') node.circle.classList.add('black');
        else node.circle.classList.add('normal');
      });
    } else if(s.phase==='backedge'){
      setStatus(`Back edge detected ${s.from.label} → ${s.to.label} (cycle)`, 'error');
      highlightEdge(s.from,s.to);
      s.color.forEach((c,node)=> {
        node.circle.classList.remove('normal','selected','zero','gray','black');
        if(c==='gray') node.circle.classList.add('gray');
        else if(c==='black') node.circle.classList.add('black');
        else node.circle.classList.add('normal');
      });
    } else if(s.phase==='finish'){
      setStatus(`Finished ${s.node.label}`);
      s.color.forEach((c,node)=> {
        node.circle.classList.remove('normal','selected','zero','gray','black');
        if(c==='gray') node.circle.classList.add('gray');
        else if(c==='black') node.circle.classList.add('black');
        else node.circle.classList.add('normal');
      });
    } else if(s.phase==='done'){
      setStatus('DFS topological sort complete');
      // order is reversed of finishing times
      updateOutputDisplay(s.order);
      dfsRunner = null;
    }
    // update displays for color-based indegrees/queue placeholders
    updateIndegreesDisplay(); // not relevant for DFS
    updateQueueDisplay([]);
    updateOutputDisplay(s.order || []);
  }

  function playDfs(){
    if(dfsTimer) return;
    if(!dfsRunner) dfsRunner = dfsGenerator();
    dfsTimer = setInterval(()=> {
      const nxt = dfsRunner.next();
      if(nxt.done){ if(nxt.value) applyDfsStep(nxt.value); stopDfsTimer(); return; }
      applyDfsStep(nxt.value);
    }, parseInt(speedInput.value) || 700);
  }

  function stopDfsTimer(){ if(dfsTimer) clearInterval(dfsTimer); dfsTimer=null; dfsRunner=null; }

  function stopAll(){
    stopKahnTimer();
    stopDfsTimer();
  }

  // Buttons
  kahnStepBtn.addEventListener('click', ()=> { stopDfsTimer(); runKahnStep(); });
  kahnBtn.addEventListener('click', ()=> { stopAll(); kahnRunner = kahnGenerator(); let s = kahnRunner.next(); if(!s.done) applyKahnStep(s.value); });
  kahnPlayBtn.addEventListener('click', ()=> { stopDfsTimer(); playKahn(); });
  kahnStopBtn.addEventListener('click', ()=> { stopKahnTimer(); clearNodeStyles(); updateIndegreesDisplay(); updateQueueDisplay([]); updateOutputDisplay([]); setStatus('Kahn reset'); });

  dfsStepBtn.addEventListener('click', ()=> { stopKahnTimer(); runDfsStep(); });
  dfsBtn.addEventListener('click', ()=> { stopAll(); dfsRunner = dfsGenerator(); let s = dfsRunner.next(); if(!s.done) applyDfsStep(s.value); });
  dfsPlayBtn.addEventListener('click', ()=> { stopKahnTimer(); playDfs(); });
  dfsStopBtn.addEventListener('click', ()=> { stopDfsTimer(); clearNodeStyles(); updateIndegreesDisplay(); updateQueueDisplay([]); updateOutputDisplay([]); setStatus('DFS reset'); });

  // SVG background click to deselect / finalize edge
  svg.addEventListener('click', (ev)=> {
    if(mode === 'edge' && edgeFrom){
      setStatus('Edge creation canceled'); highlightNodeEdge(edgeFrom,false); edgeFrom=null; updateSelectedLabel();
    } else {
      selectedNode = null; updateSelectedLabel(); render();
    }
  });

  // generate random graph
  function generateRandom(n, p){
    clearGraph();
    // place nodes in a grid-ish layout
    const w = 1000, h = 600;
    for(let i=0;i<n;i++){
      const angle = Math.random()*Math.PI*2;
      const r = 200 + Math.random()*200;
      const x = w/2 + Math.cos(angle)*r;
      const y = h/2 + Math.sin(angle)*r;
      addNodeAt(x,y);
    }
    // add edges with probability p, but avoid too many cycles by biasing edges from lower index to higher index half the time
    for(let i=0;i<n;i++){
      for(let j=0;j<n;j++){
        if(i===j) continue;
        if(Math.random() < p){
          // 60% chance directed i->j if i<j to reduce cycles
          if(Math.random()<0.6 && i<j) addEdge(nodes[i], nodes[j]);
          else if(Math.random()<0.6 && j<i) addEdge(nodes[j], nodes[i]);
          else addEdge(nodes[i], nodes[j]);
        }
      }
    }
    setStatus(`Generated random graph (${n} nodes)`);
    render();
  }

  // initial example
  (function initExample(){
    clearGraph();
    const A = addNodeAt(220,160,'A');
    const B = addNodeAt(420,120,'B');
    const C = addNodeAt(620,160,'C');
    const D = addNodeAt(320,300,'D');
    const E = addNodeAt(520,320,'E');
    addEdge(A,B); addEdge(A,D); addEdge(B,C); addEdge(B,D); addEdge(D,E); addEdge(C,E);
    setStatus('Sample DAG loaded');
    render();
  })();

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key === 'e') setMode(mode==='edge' ? 'idle' : 'edge');
    if(e.key === 'd') setMode(mode==='delete' ? 'idle' : 'delete');
    if(e.key === 'a') addNodeAt(600+Math.random()*200-100, 350+Math.random()*200-100);
    if(e.key === 'Escape') { setMode('idle'); edgeFrom=null; updateSelectedLabel(); }
  });

  // small helpers
  function stopKahnTimer(){ if(kahnTimer) clearInterval(kahnTimer); kahnTimer=null; kahnRunner=null; }
  function stopDfsTimer(){ if(dfsTimer) clearInterval(dfsTimer); dfsTimer=null; dfsRunner=null; }

  // Prevent text selection while interacting
  document.addEventListener('selectstart', (e)=>{ if(drag.node) e.preventDefault(); });

})();
</script>
</body>
</html>