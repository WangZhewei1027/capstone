<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Longest Common Subsequence (LCS) Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1720;
      --card:#0b1220;
      --accent:#06b6d4;
      --muted:#94a3b8;
      --cell:#0b1228;
      --cell-border: #1e293b;
      --match:#134e4a;
      --path:#16a34a;
      --text:#e6eef6;
    }
    * { box-sizing: border-box; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    html,body{ height:100%; margin:0; background:linear-gradient(180deg,#071021 0%, #031324 100%); color:var(--text); }
    .wrap{ max-width:1100px; margin:28px auto; padding:20px; }
    header{ display:flex; align-items:center; gap:16px; margin-bottom:18px; }
    h1{ margin:0; font-size:20px; letter-spacing:0.2px; }
    .top-row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    .card{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); padding:12px; border-radius:10px; }
    textarea{ width:100%; min-height:56px; resize:vertical; background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.03); padding:8px; border-radius:6px; outline:none; }
    input[type="text"]{ padding:8px 10px; border-radius:6px; background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.03); min-width:160px; }
    button{ background:var(--accent); color:#002018; border:none; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
    button.ghost{ background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.06); }
    .layout{ display:grid; grid-template-columns: 360px 1fr; gap:16px; margin-top:12px; }
    .left{ display:flex; flex-direction:column; gap:12px; }
    .grid-wrap{ overflow:auto; border-radius:10px; padding:12px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); border:1px solid rgba(255,255,255,0.02); }
    .dp-table{ border-collapse:collapse; font-size:13px; background:transparent; }
    .dp-table td, .dp-table th{ border:1px solid var(--cell-border); min-width:42px; height:42px; text-align:center; vertical-align:middle; padding:4px; background:var(--cell); color:var(--text); position:relative; }
    .dp-table th{ background:transparent; color:var(--muted); min-width:38px; font-weight:600; }
    .dp-cell-value{ font-weight:700; color:var(--text); }
    .dp-cell-arrow{ position:absolute; right:3px; bottom:2px; font-size:11px; color:var(--muted); }
    .cell-active{ outline:3px solid rgba(6,182,212,0.12); }
    .cell-match{ background:linear-gradient(180deg,#052a29,#083b39); border:1px solid rgba(22,163,74,0.08); }
    .cell-path{ background:linear-gradient(180deg,#07391d,#0b2e17); border:1px solid rgba(16,185,129,0.14); }
    .strings{ display:flex; flex-direction:column; gap:8px; font-size:14px; }
    .str-line{ background:rgba(255,255,255,0.02); padding:8px; border-radius:6px; display:flex; gap:6px; align-items:center; flex-wrap:wrap; color:var(--muted); }
    .char{ padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.03); background:transparent; color:var(--text); }
    .char.match{ background:var(--match); color:#dffcf3; border-color:rgba(22,163,74,0.12); font-weight:700; }
    .char.used{ background:var(--path); color:#eaffef; border-color:rgba(16,185,129,0.14); font-weight:700; }
    .result{ margin-top:6px; font-size:15px; }
    .small{ font-size:13px; color:var(--muted); }
    .footer{ margin-top:12px; display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap; color:var(--muted); }
    .speed{ display:flex; gap:6px; align-items:center; }
    .legend{ display:flex; gap:8px; align-items:center; font-size:13px; }
    .legend .box{ width:12px; height:12px; border-radius:3px; display:inline-block; margin-right:6px; }
    .centered{ display:flex; align-items:center; justify-content:center; gap:8px; }
    .actions{ display:flex; gap:8px; }
    @media(max-width:880px){
      .layout{ grid-template-columns: 1fr; }
      .left{ order:2; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Longest Common Subsequence (LCS) Visualizer</h1>
        <div class="small">Interactive dynamic-programming demo: fill DP table, animate updates and backtrack one LCS.</div>
      </div>
    </header>

    <div class="controls card">
      <div class="top-row">
        <div style="flex:1; min-width:220px;">
          <div style="font-size:13px; color:var(--muted); margin-bottom:6px;">String A</div>
          <input id="strA" type="text" value="ABCBDAB" />
        </div>
        <div style="flex:1; min-width:220px;">
          <div style="font-size:13px; color:var(--muted); margin-bottom:6px;">String B</div>
          <input id="strB" type="text" value="BDCABA" />
        </div>

        <div style="display:flex; gap:8px; align-items:center;">
          <button id="computeBtn">Compute LCS</button>
          <button id="animateBtn" class="ghost">Animate Fill</button>
          <button id="stepBtn" class="ghost">Step</button>
          <button id="backtrackBtn" class="ghost">Backtrack</button>
        </div>
      </div>

      <div style="display:flex; gap:12px; align-items:center; margin-top:10px;">
        <label style="display:flex; gap:6px; align-items:center;"><input id="showVals" type="checkbox" checked /> Show values</label>
        <label style="display:flex; gap:6px; align-items:center;"><input id="showArrows" type="checkbox" /> Show arrows</label>
        <label style="display:flex; gap:6px; align-items:center;"><input id="autoHighlight" type="checkbox" checked /> Highlight subsequence in strings</label>
        <div style="flex:1"></div>
        <div class="speed">
          <div class="small">Speed</div>
          <input id="speedRange" type="range" min="50" max="1200" value="220" />
        </div>
      </div>
    </div>

    <div class="layout">
      <div class="left">
        <div class="card">
          <div style="font-weight:700; margin-bottom:8px;">Strings</div>
          <div class="strings">
            <div style="font-size:13px; color:var(--muted);">String A (rows):</div>
            <div id="displayA" class="str-line"></div>
            <div style="font-size:13px; color:var(--muted); margin-top:8px;">String B (cols):</div>
            <div id="displayB" class="str-line"></div>
            <div class="result" id="resultArea"></div>
          </div>
        </div>

        <div class="card">
          <div style="font-weight:700; margin-bottom:8px;">Info</div>
          <div class="small">
            LCS is the longest sequence that appears in the same relative order (not necessarily contiguous) in both strings.<br><br>
            Time complexity: O(m*n). Space: O(m*n) for table, can be optimized to O(min(m,n)) if only length is needed.
          </div>
          <div style="margin-top:10px;" class="legend">
            <div><span class="box" style="background:var(--match)"></span>matching diagonal</div>
            <div><span class="box" style="background:var(--path)"></span>backtrack / chosen path</div>
            <div><span class="box" style="background:rgba(6,182,212,0.12)"></span>current cell</div>
          </div>
        </div>
      </div>

      <div class="grid-wrap card">
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
          <div style="font-weight:700;">DP Table (rows = A, cols = B)</div>
          <div class="small">Includes a leading empty row/column for base-case zeros.</div>
          <div style="flex:1"></div>
          <div class="small">Click any cell to set as current step.</div>
        </div>
        <div id="tableContainer" style="overflow:auto;"></div>

        <div class="footer">
          <div class="centered actions">
            <button id="playPause" class="ghost">Play</button>
            <button id="prevStep" class="ghost">Prev</button>
            <button id="nextStep" class="ghost">Next</button>
            <button id="resetBtn" class="ghost">Reset</button>
          </div>
          <div class="small" id="statusText">Status: Idle</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Elements
    const strAInput = document.getElementById('strA');
    const strBInput = document.getElementById('strB');
    const computeBtn = document.getElementById('computeBtn');
    const animateBtn = document.getElementById('animateBtn');
    const stepBtn = document.getElementById('stepBtn');
    const backtrackBtn = document.getElementById('backtrackBtn');
    const tableContainer = document.getElementById('tableContainer');
    const displayA = document.getElementById('displayA');
    const displayB = document.getElementById('displayB');
    const resultArea = document.getElementById('resultArea');
    const showVals = document.getElementById('showVals');
    const showArrows = document.getElementById('showArrows');
    const autoHighlight = document.getElementById('autoHighlight');
    const speedRange = document.getElementById('speedRange');
    const statusText = document.getElementById('statusText');

    const playPause = document.getElementById('playPause');
    const prevStep = document.getElementById('prevStep');
    const nextStep = document.getElementById('nextStep');
    const resetBtn = document.getElementById('resetBtn');

    // State
    let s = '';
    let t = '';
    let m = 0;
    let n = 0;
    let dp = []; // (m+1)x(n+1)
    let arrows = []; // arrow directions info
    let steps = []; // sequence of cell updates for animation
    let curStep = 0;
    let playing = false;
    let playTimer = null;
    let backtrackPath = []; // coords used for chosen LCS
    let lcsStr = '';

    function initFromInputs(){
      s = String(strAInput.value || '');
      t = String(strBInput.value || '');
      m = s.length;
      n = t.length;
    }

    function resetState(){
      dp = Array.from({length:m+1}, ()=>Array(n+1).fill(0));
      arrows = Array.from({length:m+1}, ()=>Array(n+1).fill(''));
      steps = [];
      curStep = 0;
      backtrackPath = [];
      lcsStr = '';
      playing = false;
      clearInterval(playTimer);
      playTimer = null;
      playPause.textContent = 'Play';
    }

    function computeDP(full=true){
      // If full=true do regular full computation and generate steps
      resetState();
      // base zeros steps (optional) - we'll show computed cells for i>=1 j>=1
      for(let i=1;i<=m;i++){
        for(let j=1;j<=n;j++){
          let match = (s[i-1] === t[j-1]);
          if(match){
            dp[i][j] = dp[i-1][j-1] + 1;
            arrows[i][j] = 'diag';
          } else {
            if(dp[i-1][j] >= dp[i][j-1]){
              dp[i][j] = dp[i-1][j];
              arrows[i][j] = 'up';
            } else {
              dp[i][j] = dp[i][j-1];
              arrows[i][j] = 'left';
            }
          }
          steps.push({i,j,value:dp[i][j],match,from:arrows[i][j]});
        }
      }
      // After filling, do backtrack to extract one LCS
      let i=m,j=n;
      const path = [];
      let chars = [];
      while(i>0 && j>0){
        if(s[i-1]===t[j-1]){
          path.push({i,j});
          chars.push(s[i-1]);
          i--; j--;
        } else {
          if(dp[i-1][j] >= dp[i][j-1]) i--;
          else j--;
        }
      }
      backtrackPath = path; // reversed order (from end to start)
      lcsStr = chars.reverse().join('');
      return {dp,arrows,steps,backtrackPath,lcsStr};
    }

    function renderStrings(){
      // displayA and displayB characters with spans
      displayA.innerHTML = '';
      displayB.innerHTML = '';
      for(let i=0;i<m;i++){
        const span = document.createElement('div');
        span.className='char';
        span.textContent = s[i];
        displayA.appendChild(span);
      }
      for(let j=0;j<n;j++){
        const span = document.createElement('div');
        span.className='char';
        span.textContent = t[j];
        displayB.appendChild(span);
      }
    }

    function buildTable(){
      // Build table HTML with headers (empty+ t chars)
      const table = document.createElement('table');
      table.className = 'dp-table';
      const thead = document.createElement('thead');
      // First header row: top-left empty cell plus B chars
      const hr = document.createElement('tr');
      const th0 = document.createElement('th'); th0.textContent=''; hr.appendChild(th0);
      const th1 = document.createElement('th'); th1.textContent=''; hr.appendChild(th1); // the first column header for empty
      for(let j=0;j<n;j++){
        const th = document.createElement('th');
        th.textContent = t[j];
        hr.appendChild(th);
      }
      thead.appendChild(hr);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      // row 0 (empty A) header and zero values
      const r0 = document.createElement('tr');
      const r0head = document.createElement('th'); r0head.textContent=''; r0.appendChild(r0head);
      const r0col0 = document.createElement('td'); r0col0.className='dp-cell'; r0col0.dataset.i=0; r0col0.dataset.j=0;
      r0col0.innerHTML = showVals.checked ? `<div class="dp-cell-value">${dp[0][0]}</div>` : '';
      r0.appendChild(r0col0);
      for(let j=1;j<=n;j++){
        const td = document.createElement('td');
        td.className='dp-cell';
        td.dataset.i=0; td.dataset.j=j;
        td.innerHTML = showVals.checked ? `<div class="dp-cell-value">${dp[0][j]}</div>` : '';
        r0.appendChild(td);
      }
      tbody.appendChild(r0);

      for(let i=1;i<=m;i++){
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = s[i-1];
        tr.appendChild(th);
        for(let j=0;j<=n;j++){
          const td = document.createElement('td');
          td.className='dp-cell';
          td.dataset.i=i; td.dataset.j=j;
          if(showVals.checked && !(i===0 && j===0)){
            td.innerHTML = `<div class="dp-cell-value">${dp[i][j]}</div>`;
          }
          if(showArrows.checked && arrows[i] && arrows[i][j]) {
            const arrSpan = document.createElement('div');
            arrSpan.className='dp-cell-arrow';
            const a = arrows[i][j];
            arrSpan.textContent = a==='diag' ? '↖' : a==='up' ? '↑' : a==='left' ? '←' : '';
            td.appendChild(arrSpan);
          }
          td.addEventListener('click', ()=> {
            // set current step to this cell's step if exists
            const idx = steps.findIndex(st=>st.i==i && st.j==j);
            if(idx>=0){
              curStep = idx;
              renderStep(curStep);
              stopPlaying();
            } else {
              // if it's base cell (0 row/col)
              curStep = 0;
              renderStep(curStep);
              stopPlaying();
            }
          });
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      // replace container
      tableContainer.innerHTML = '';
      tableContainer.appendChild(table);
    }

    function renderFullTableHighlight(){
      // update all cells according to dp, arrows, and backtrackPath
      const table = tableContainer.querySelector('.dp-table');
      if(!table) return;
      // collect path set
      const pathSet = new Set(backtrackPath.map(p=>`${p.i},${p.j}`));
      for(const td of table.querySelectorAll('td.dp-cell')){
        const i = Number(td.dataset.i);
        const j = Number(td.dataset.j);
        td.classList.remove('cell-active','cell-match','cell-path');
        // values
        if(showVals.checked){
          let el = td.querySelector('.dp-cell-value');
          if(!el){
            el = document.createElement('div'); el.className='dp-cell-value'; td.appendChild(el);
          }
          el.textContent = dp[i][j];
        } else {
          const el = td.querySelector('.dp-cell-value');
          if(el) el.remove();
        }
        // arrows
        const arrSpan = td.querySelector('.dp-cell-arrow');
        if(showArrows.checked && arrows[i] && arrows[i][j]){
          if(!arrSpan){
            const ael = document.createElement('div'); ael.className='dp-cell-arrow'; td.appendChild(ael);
          }
          td.querySelector('.dp-cell-arrow').textContent = arrows[i][j]==='diag' ? '↖' : arrows[i][j]==='up' ? '↑' : '←';
        } else {
          if(arrSpan) arrSpan.remove();
        }
        // marks
        if(arrows[i] && arrows[i][j]==='diag' && i>0 && j>0 && s[i-1]===t[j-1]){
          td.classList.add('cell-match');
        } else {
          td.classList.remove('cell-match');
        }
        if(pathSet.has(`${i},${j}`)){
          td.classList.add('cell-path');
        } else {
          td.classList.remove('cell-path');
        }
      }
    }

    function renderStep(k){
      // highlight up to step k (inclusive). Steps indexed 0..steps.length-1.
      const table = tableContainer.querySelector('.dp-table');
      if(!table) return;
      // Clear classes
      for(const td of table.querySelectorAll('td.dp-cell')){
        td.classList.remove('cell-active','cell-match','cell-path');
        const el = td.querySelector('.dp-cell-value');
        if(el) el.textContent = '0';
      }
      // Show base zeros in row0 and col0
      for(const td of table.querySelectorAll('td.dp-cell')){
        const i = Number(td.dataset.i);
        const j = Number(td.dataset.j);
        if(i===0 || j===0){
          if(showVals.checked){
            const el = td.querySelector('.dp-cell-value') || (()=>{const d=document.createElement('div'); d.className='dp-cell-value'; td.appendChild(d); return d;})();
            el.textContent = '0';
          }
        }
      }

      // apply steps up to k
      for(let idx=0; idx<=k && idx<steps.length; idx++){
        const st = steps[idx];
        const selector = `td.dp-cell[data-i="${st.i}"][data-j="${st.j}"]`;
        const td = table.querySelector(selector);
        if(!td) continue;
        // set value
        if(showVals.checked){
          let el = td.querySelector('.dp-cell-value');
          if(!el){ el = document.createElement('div'); el.className='dp-cell-value'; td.appendChild(el); }
          el.textContent = st.value;
        }
        if(showArrows.checked){
          let arr = td.querySelector('.dp-cell-arrow');
          if(!arr){ arr = document.createElement('div'); arr.className='dp-cell-arrow'; td.appendChild(arr); }
          arr.textContent = st.from==='diag' ? '↖' : st.from==='up' ? '↑' : '←';
        } else {
          const arr = td.querySelector('.dp-cell-arrow'); if(arr) arr.remove();
        }

        // mark matches (diag cells that were match)
        if(st.match){
          td.classList.add('cell-match');
        }
      }
      // highlight current cell
      if(k>=0 && k<steps.length){
        const cur = steps[k];
        const tdcur = table.querySelector(`td.dp-cell[data-i="${cur.i}"][data-j="${cur.j}"]`);
        if(tdcur) tdcur.classList.add('cell-active');
        statusText.textContent = `Step ${k+1} / ${steps.length} — filling cell (${cur.i},${cur.j}) value=${cur.value} ${cur.match? '(match)':''}`;
      } else {
        statusText.textContent = `Step ${k} / ${steps.length}`;
      }

      // if reached end, update result and highlight full backtrack path if available
      if(k === steps.length - 1){
        // compute backtrack now (dp is fully computed)
        statusText.textContent = `Completed. LCS length = ${dp[m][n]}. Use Backtrack to highlight chosen subsequence.`;
        renderFullTableHighlight(); // ensure path style if previously computed
      }
    }

    function animateFill(){
      if(steps.length===0){ statusText.textContent='No computed steps. Click Compute LCS first.'; return; }
      stopPlaying();
      playing = true;
      playPause.textContent = 'Pause';
      const delay = Number(speedRange.value) || 220;
      playTimer = setInterval(()=>{
        if(curStep >= steps.length - 1){
          clearInterval(playTimer); playTimer = null; playing=false; playPause.textContent='Play';
          curStep = steps.length - 1;
          renderStep(curStep);
        } else {
          renderStep(curStep);
          curStep++;
        }
      }, delay);
      statusText.textContent = 'Animating...';
    }

    function stopPlaying(){
      if(playTimer) clearInterval(playTimer);
      playTimer = null;
      playing = false;
      playPause.textContent = 'Play';
    }

    // Backtrack animation / highlight
    async function doBacktrack(){
      // Use dp and arrows to collect chosen path
      if(steps.length===0){ statusText.textContent='No computed DP to backtrack.'; return; }
      // compute backtrack path (again)
      let i=m,j=n;
      const path = [];
      while(i>0 && j>0){
        if(s[i-1]===t[j-1]){
          path.push({i,j});
          i--; j--;
        } else {
          if(dp[i-1][j] >= dp[i][j-1]) i--;
          else j--;
        }
      }
      backtrackPath = path; // reversed: from end to start
      // animate marking the path from end to start
      const table = tableContainer.querySelector('.dp-table');
      // clear previous path markers
      for(const td of table.querySelectorAll('td.dp-cell')){
        td.classList.remove('cell-path');
      }
      // show from start to end (reverse of path)
      const rev = path.slice().reverse();
      for(let k=0;k<rev.length;k++){
        const p = rev[k];
        const td = table.querySelector(`td.dp-cell[data-i="${p.i}"][data-j="${p.j}"]`);
        if(td) td.classList.add('cell-path');
        // highlight corresponding characters in strings if desired
        if(autoHighlight.checked){
          markCharsForBacktrack(rev.slice(0,k+1));
        }
        await sleep(Math.max(60, Number(speedRange.value)/3));
      }
      // show result text
      resultArea.innerHTML = `<div style="font-weight:700">LCS (length ${dp[m][n]}): <span style="color:var(--accent)">${lcsStr || computeLCSStringFromDP()}</span></div>`;
      statusText.textContent = 'Backtrack complete.';
    }

    function markCharsForBacktrack(pathList){
      // pathList is list from start to current of {i,j}
      // mark characters in A and B that are used up to this point
      const usedA = new Set(pathList.map(p=>p.i-1));
      const usedB = new Set(pathList.map(p=>p.j-1));
      const childrenA = displayA.querySelectorAll('.char');
      childrenA.forEach((el,idx)=> {
        el.classList.toggle('used', usedA.has(idx));
      });
      const childrenB = displayB.querySelectorAll('.char');
      childrenB.forEach((el,idx)=> {
        el.classList.toggle('used', usedB.has(idx));
      });
    }

    function computeLCSStringFromDP(){
      // fallback constructing lcs from dp table
      let i=m,j=n; const arr=[];
      while(i>0 && j>0){
        if(s[i-1]===t[j-1]){
          arr.push(s[i-1]); i--; j--;
        } else if(dp[i-1][j] >= dp[i][j-1]) i--;
        else j--;
      }
      return arr.reverse().join('');
    }

    function sleep(ms){ return new Promise(res => setTimeout(res,ms)); }

    // Event bindings
    computeBtn.addEventListener('click', ()=>{
      initFromInputs();
      if(m===0 || n===0){
        statusText.textContent = 'One or both strings are empty.';
      }
      renderStrings();
      computeDP();
      buildTable();
      renderFullTableHighlight();
      resultArea.innerHTML = `<div style="font-weight:700">LCS length: <span style="color:var(--accent)">${dp[m][n]}</span></div>`;
      statusText.textContent = `DP computed. ${steps.length} steps generated.`;
      // if autoHighlight initial, highlight diagonal matches
      if(autoHighlight.checked){
        // clear used classes
        displayA.querySelectorAll('.char').forEach((el,i)=>{
          el.classList.toggle('match', false);
          el.classList.toggle('used', false);
        });
        displayB.querySelectorAll('.char').forEach((el,i)=>{
          el.classList.toggle('match', false);
          el.classList.toggle('used', false);
        });
      }
    });

    animateBtn.addEventListener('click', ()=>{
      initFromInputs();
      if(steps.length===0){ statusText.textContent = 'Compute DP first.'; return; }
      stopPlaying();
      // start animation of filling all cells
      animateFill();
    });

    stepBtn.addEventListener('click', ()=>{
      initFromInputs();
      if(steps.length===0){ statusText.textContent = 'Compute DP first.'; return; }
      // step once
      if(curStep >= steps.length - 1) curStep = 0;
      else curStep++;
      renderStep(curStep);
    });

    backtrackBtn.addEventListener('click', async ()=>{
      initFromInputs();
      if(steps.length===0){ statusText.textContent = 'Compute DP first.'; return; }
      // ensure lcsStr is available
      lcsStr = lcsStr || computeLCSStringFromDP();
      await doBacktrack();
    });

    playPause.addEventListener('click', ()=>{
      if(playing){
        stopPlaying();
        statusText.textContent = 'Paused.';
      } else {
        if(steps.length===0){
          statusText.textContent = 'Compute DP first.';
          return;
        }
        // if at end, reset to 0
        if(curStep >= steps.length) curStep = 0;
        playing = true;
        playPause.textContent = 'Pause';
        const delay = Number(speedRange.value) || 220;
        playTimer = setInterval(()=>{
          renderStep(curStep);
          curStep++;
          if(curStep > steps.length - 1){
            stopPlaying();
            statusText.textContent = 'Animation complete.';
          }
        }, delay);
      }
    });

    prevStep.addEventListener('click', ()=>{
      if(steps.length===0) return;
      stopPlaying();
      curStep = Math.max(0, curStep-1);
      renderStep(curStep);
    });
    nextStep.addEventListener('click', ()=>{
      if(steps.length===0) return;
      stopPlaying();
      curStep = Math.min(steps.length-1, curStep+1);
      renderStep(curStep);
    });

    resetBtn.addEventListener('click', ()=>{
      stopPlaying();
      initFromInputs();
      resetState();
      renderStrings();
      tableContainer.innerHTML = '';
      resultArea.innerHTML = '';
      statusText.textContent = 'Reset.';
      displayA.querySelectorAll('.char').forEach(el=>el.className='char');
      displayB.querySelectorAll('.char').forEach(el=>el.className='char');
    });

    showVals.addEventListener('change', ()=>{
      buildTable();
      renderFullTableHighlight();
    });
    showArrows.addEventListener('change', ()=>{
      buildTable();
      renderFullTableHighlight();
    });
    autoHighlight.addEventListener('change', ()=>{
      // clear used classes when toggled off
      if(!autoHighlight.checked){
        displayA.querySelectorAll('.char').forEach(el=>el.classList.remove('used'));
        displayB.querySelectorAll('.char').forEach(el=>el.classList.remove('used'));
      }
    });

    // initial render
    (function initDemo(){
      initFromInputs();
      renderStrings();
      resetState();
      buildTable();
      statusText.textContent = 'Ready. Click Compute LCS to start.';
    })();

    // Small convenience: recompute when inputs change and user presses Enter
    strAInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') computeBtn.click(); });
    strBInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') computeBtn.click(); });
  </script>
</body>
</html>