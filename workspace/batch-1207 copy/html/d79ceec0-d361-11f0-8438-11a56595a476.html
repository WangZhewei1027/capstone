<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Counting Sort Demonstration</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 2rem;
    background: #f9f9f9;
    color: #333;
  }
  h1 {
    text-align: center;
  }
  label, button {
    font-weight: bold;
  }
  input[type="text"] {
    width: 80%;
    font-size: 1.1rem;
    padding: 0.5rem;
    margin: 0.5rem 0 1rem 0;
  }
  button {
    padding: 0.6rem 1rem;
    margin-bottom: 1.5rem;
    cursor: pointer;
    background-color: #0078d7;
    color: white;
    border: none;
    border-radius: 4px;
  }
  button:hover {
    background-color: #005a9e;
  }
  .result-section {
    background: white;
    border-radius: 8px;
    padding: 1rem;
    box-shadow: 0 0 10px #ccc;
    max-width: 1000px;
    margin: 0 auto;
  }
  pre {
    background: #eee;
    padding: 0.5rem;
    border-radius: 4px;
    overflow-x: auto;
  }
  .array-display {
    font-family: 'Courier New', Courier, monospace;
    white-space: pre-wrap;
    word-wrap: break-word;
    margin-bottom: 1rem;
  }
  .step {
    margin-bottom: 1rem;
    border-left: 4px solid #0078d7;
    padding-left: 1rem;
    background: #f0f8ff;
    border-radius: 4px;
  }
  footer {
    margin-top: 3rem;
    text-align: center;
    font-size: 0.9rem;
    color: #666;
  }
  .error {
    color: red;
    margin-bottom: 1rem;
    font-weight: bold;
  }
</style>
</head>
<body>
<h1>Counting Sort Visualization</h1>
<div class="result-section">
  <label for="inputArray">Enter integers separated by commas or spaces:</label><br />
  <input type="text" id="inputArray" placeholder="e.g. 4, 2, 2, 8, 3, 3, 1" />
  <br />
  <button id="sortButton">Sort using Counting Sort</button>
  <div id="errorMsg" class="error" aria-live="assertive"></div>
  <div id="output"></div>
</div>

<script>
  function parseInput(input) {
    // Split by comma or whitespace, remove empty entries
    return input.split(/[\s,]+/)
      .map(s => s.trim())
      .filter(s => s.length > 0)
      .map(n => Number(n));
  }

  function validateArray(arr) {
    // Check all are finite integers
    for (let n of arr) {
      if (!Number.isInteger(n) || !isFinite(n)) {
        return false;
      }
    }
    return true;
  }

  function countingSort(arr, outputCallback) {
    if (arr.length === 0) return [];

    const min = Math.min(...arr);
    const max = Math.max(...arr);

    outputCallback(`Input array: [${arr.join(', ')}]`);
    outputCallback(`Range of values: min = ${min}, max = ${max}`);

    // Initialize count array
    const range = max - min + 1;
    let count = new Array(range).fill(0);
    outputCallback(`Initialized count array with size ${range} (all zeros):`);
    outputCallback(count);

    // Store the count of each element
    for (let i = 0; i < arr.length; i++) {
      count[arr[i] - min]++;
      outputCallback(`Increment count for value ${arr[i]}: count[${arr[i] - min}] = ${count[arr[i] - min]}`);
    }
    outputCallback(`Count array after counting elements:`);
    outputCallback(count);

    // Change count[i] so that count[i] now contains actual position of this element in output array
    for (let i = 1; i < count.length; i++) {
      count[i] += count[i - 1];
      outputCallback(`Prefix sum step ${i}: count[${i}] = count[${i}] + count[${i-1}] -> ${count[i]}`);
    }
    outputCallback(`Count array after prefix sums:`);
    outputCallback(count);

    // Build the output array
    let output = new Array(arr.length);
    // We go backwards to make the sort stable
    for (let i = arr.length - 1; i >= 0; i--) {
      let current = arr[i];
      count[current - min]--;
      let pos = count[current - min];
      output[pos] = current;
      outputCallback(`Place element ${current} at output[${pos}]`);
    }

    outputCallback(`Sorted array: [${output.join(', ')}]`);
    return output;
  }

  // To nicely print arrays and messages in output div
  function appendMessage(msg) {
    const outDiv = document.getElementById('output');
    let el = document.createElement('div');
    el.classList.add('step');
    if (Array.isArray(msg)) {
      el.textContent = `[${msg.join(', ')}]`;
    } else {
      el.textContent = msg;
    }
    outDiv.appendChild(el);
    // Scroll to bottom
    outDiv.scrollTop = outDiv.scrollHeight;
  }

  document.getElementById('sortButton').addEventListener('click', () => {
    const input = document.getElementById('inputArray').value;
    const errorMsg = document.getElementById('errorMsg');
    errorMsg.textContent = '';
    const outputDiv = document.getElementById('output');
    outputDiv.innerHTML = '';

    if (!input.trim()) {
      errorMsg.textContent = 'Please enter some integers.';
      return;
    }

    let arr = parseInput(input);

    if (!validateArray(arr)) {
      errorMsg.textContent = 'Input must be integers only.';
      return;
    }

    // If large range, warn user
    const min = Math.min(...arr);
    const max = Math.max(...arr);
    if (max - min > 100000) {
      if (!confirm(`Warning: Large range (${max - min}) may cause performance issues. Continue?`)) {
        return;
      }
    }

    countingSort(arr, appendMessage);
  });
</script>
<footer>
  &copy; 2024 Counting Sort Demo
</footer>
</body>
</html>