<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Floyd-Warshall Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f7fa;
        }
        h1 {
            text-align: center;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px #ccc;
        }
        label {
            font-weight: bold;
            display: block;
            margin-top: 15px;
        }
        textarea {
            width: 100%;
            height: 120px;
            font-family: monospace;
            font-size: 14px;
            margin-top: 5px;
            resize: vertical;
            border-radius: 5px;
            border: 1px solid #ccc;
            padding: 8px;
        }
        button {
            margin-top: 15px;
            font-size: 16px;
            padding: 10px 18px;
            background-color: #009578;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: 0.3s ease;
        }
        button:hover {
            background-color: #007a5e;
        }
        table {
            margin: 15px 0;
            border-collapse: collapse;
            width: 100%;
            max-width: 100%;
        }
        th, td {
            border: 1px solid #999;
            padding: 8px 12px;
            text-align: center;
            font-family: monospace;
            user-select: none;
        }
        th {
            background-color: #eeeeee;
        }
        .output-section {
            margin-top: 25px;
        }
        .step-title {
            font-weight: bold;
            margin-top: 20px;
            margin-bottom: 5px;
            font-size: 18px;
            color: #314a6d;
        }
        .note {
            background: #e3f2fd;
            border-left: 5px solid #1976d2;
            padding: 10px 15px;
            margin-top: 10px;
            font-style: italic;
            color: #0d47a1;
            border-radius: 4px;
        }
        .error {
            background: #ffebee;
            border-left: 5px solid #d32f2f;
            color: #b71c1c;
            padding: 10px 15px;
            margin-top: 10px;
            border-radius: 4px;
        }
        small.tip {
            display: block;
            margin-top: 5px;
            color: #555;
            font-style: italic;
        }
        #steps {
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid #ccc;
            background: #fafafa;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            user-select: none;
        }
        @media (max-width: 600px) {
            textarea {
                height: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Floyd-Warshall Algorithm Demo</h1>
        <label for="graphInput">Enter Weighted Directed Graph Adjacency Matrix (use Infinity or "INF" for no edge):</label>
        <textarea id="graphInput" aria-label="Input adjacency matrix">
0 3 INF 7
8 0 2 INF
5 INF 0 1
2 INF INF 0
        </textarea>
        <small class="tip">Example: A 4-node graph matrix.<br>Rows represent source nodes, columns destination nodes.</small>
        <button id="runBtn" aria-label="Run Floyd-Warshall Algorithm">Run Floyd-Warshall</button>
        <div id="errorMsg" class="error" style="display:none;"></div>

        <section class="output-section" id="outputSection" aria-live="polite" aria-relevant="additions">
            <div class="step-title">Initial Distance Matrix:</div>
            <div id="initialMatrix"></div>

            <div class="step-title">Algorithm Steps:</div>
            <div id="steps"></div>

            <div class="step-title">Final Shortest Distance Matrix:</div>
            <div id="finalMatrix"></div>

            <div class="note">Note: '∞' indicates no path between nodes.</div>
        </section>
    </div>

    <script>
        (() => {
            const INF = Infinity;
            const inputArea = document.getElementById('graphInput');
            const runBtn = document.getElementById('runBtn');
            const initialMatrixDiv = document.getElementById('initialMatrix');
            const finalMatrixDiv = document.getElementById('finalMatrix');
            const stepsDiv = document.getElementById('steps');
            const outputSection = document.getElementById('outputSection');
            const errorDiv = document.getElementById('errorMsg');

            function parseMatrix(text) {
                // Parses the input text into a 2D matrix of numbers or Infinity
                const lines = text.trim().split('\n').filter(line => line.trim() !== '');
                const matrix = [];

                for (let r=0; r<lines.length; r++) {
                    const values = lines[r].trim().split(/\s+/);
                    if (r>0 && values.length !== matrix[0].length) {
                        throw new Error(`Row ${r+1} length (${values.length}) does not match first row length (${matrix[0].length}).`);
                    }
                    matrix.push(values.map(v => {
                        const valStr = v.trim().toUpperCase();
                        if (valStr === 'INF' || valStr === 'INFINITY' || valStr === '∞') return INF;
                        const num = Number(valStr);
                        if (isNaN(num)) throw new Error(`Invalid number "${v}" detected.`);
                        if(num < 0) throw new Error('Negative weights not allowed in Floyd-Warshall in this demo.');
                        return num;
                    }));
                }
                // Check square matrix
                if (!matrix.every(row => row.length === matrix.length)) {
                    throw new Error(`Input matrix must be square. You have ${matrix.length} rows and varying column lengths.`);
                }
                return matrix;
            }

            function matrixToHTML(matrix) {
                const n = matrix.length;
                const tbl = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');

                // Header row
                const headerRow = document.createElement('tr');
                headerRow.appendChild(document.createElement('th')); // empty corner cell
                for(let i=0; i<n; i++) {
                    const th = document.createElement('th');
                    th.textContent = `V${i}`;
                    headerRow.appendChild(th);
                }
                thead.appendChild(headerRow);

                // Body rows
                for(let i=0; i<n; i++) {
                    const tr = document.createElement('tr');
                    const rowHeader = document.createElement('th');
                    rowHeader.textContent = `V${i}`;
                    tr.appendChild(rowHeader);
                    for(let j=0; j<n; j++) {
                        const td = document.createElement('td');
                        const val = matrix[i][j];
                        td.textContent = val === INF ? '∞' : val;
                        tr.appendChild(td);
                    }
                    tbody.appendChild(tr);
                }

                tbl.appendChild(thead);
                tbl.appendChild(tbody);
                return tbl;
            }

            function cloneMatrix(m) {
                return m.map(row => row.slice());
            }

            function floydWarshall(matrix, callbackStep) {
                const n = matrix.length;
                // dist initialized as copy of input matrix
                let dist = cloneMatrix(matrix);

                // Floyd-Warshall main loops
                for(let k=0; k<n; k++) {
                    callbackStep && callbackStep(`Considering intermediate vertex V${k}`);
                    for(let i=0; i<n; i++) {
                        for(let j=0; j<n; j++) {
                            if(dist[i][k] !== INF && dist[k][j] !== INF) {
                                const newDist = dist[i][k] + dist[k][j];
                                if(newDist < dist[i][j]) {
                                    const oldDist = dist[i][j];
                                    dist[i][j] = newDist;
                                    callbackStep && callbackStep(`Updated dist[V${i}][V${j}]: ${oldDist === INF ? '∞' : oldDist} → ${newDist} (via V${k})`);
                                }
                            }
                        }
                    }
                }
                return dist;
            }

            function runAlgorithm() {
                // Clear previous outputs & errors
                errorDiv.style.display = 'none';
                initialMatrixDiv.innerHTML = '';
                finalMatrixDiv.innerHTML = '';
                stepsDiv.textContent = '';
                outputSection.style.display = 'block';

                let matrix;
                try {
                    matrix = parseMatrix(inputArea.value);
                } catch(e) {
                    errorDiv.textContent = e.message;
                    errorDiv.style.display = 'block';
                    outputSection.style.display = 'none';
                    return;
                }
                // Display initial matrix
                initialMatrixDiv.appendChild(matrixToHTML(matrix));

                // Capture steps
                const steps = [];
                function stepCollector(msg) {
                    steps.push(msg);
                    // Scroll latest step into view
                    stepsDiv.textContent = steps.join('\n');
                    stepsDiv.scrollTop = stepsDiv.scrollHeight;
                }

                // Execute Floyd-Warshall
                const finalDist = floydWarshall(matrix, stepCollector);

                // Display final matrix
                finalMatrixDiv.appendChild(matrixToHTML(finalDist));
            }

            runBtn.addEventListener('click', runAlgorithm);

            // Run initially on page load
            window.onload = () => {
                runAlgorithm();
            }
        })();
    </script>
</body>
</html>