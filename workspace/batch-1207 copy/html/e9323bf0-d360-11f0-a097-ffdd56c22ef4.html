<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Queue Demonstration</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --muted:#9aa6b2;
      --accent:#4f46e5;
      --accent-2:#06b6d4;
      --good:#10b981;
      --bad:#ef4444;
      font-family: Inter, Roboto, system-ui, -apple-system, "Segoe UI", "Helvetica Neue", Arial;
      color-scheme: dark;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071025 0%, #051026 60%, #071029 100%);color:#e6eef6}
    .wrap{
      max-width:1100px;margin:28px auto;padding:22px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow: 0 6px 30px rgba(2,6,23,0.6);
      border: 1px solid rgba(255,255,255,0.03);
    }
    h1{margin:0 0 6px;font-size:22px}
    p.lead{margin:0 0 18px;color:var(--muted);font-size:13px}
    .controls{
      display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:18px;
    }
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.01));
      padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);display:flex;gap:12px;align-items:center;
    }
    input[type="number"], input[type="text"], select{
      padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit;width:160px;
    }
    button{
      background:linear-gradient(180deg,var(--accent),#3b34c8);color:white;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600;
      box-shadow:0 8px 18px rgba(79,70,229,0.12);
    }
    button.secondary{
      background:transparent;color:var(--accent);border:1px solid rgba(79,70,229,0.12);box-shadow:none;font-weight:600;
    }
    button.warn{background:linear-gradient(180deg,var(--bad),#d33);box-shadow:none}
    .main{
      display:flex;gap:18px;align-items:flex-start;
    }
    .left{
      flex:1;
      min-width:420px;
      padding:16px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008));
      border:1px solid rgba(255,255,255,0.02);
    }
    .right{
      width:360px;min-width:280px;padding:16px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008));
      border:1px solid rgba(255,255,255,0.02);
    }
    .visual{
      margin-top:8px;padding:14px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.008), rgba(255,255,255,0.005));
      min-height:160px;display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden;
    }
    .queue-row{
      display:flex;gap:10px;align-items:center;transition:all 360ms ease;
    }
    .slot{
      width:72px;height:56px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:15px;
      color:#eaf2ff;position:relative;box-shadow: 0 6px 12px rgba(2,6,23,0.45);
    }
    .slot.empty{color:var(--muted);font-weight:600;font-size:13px;opacity:0.7}
    .pointer{
      position:absolute;top:-18px;padding:6px 8px;border-radius:8px;background:rgba(7,15,30,0.9);font-size:12px;color:var(--accent-2);border:1px solid rgba(6,182,212,0.12);box-shadow:0 6px 16px rgba(6,182,212,0.03);
    }
    .annotations{display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap}
    .badge{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--muted);font-size:13px;border:1px solid rgba(255,255,255,0.02)}
    .log{height:200px;overflow:auto;padding:10px;border-radius:8px;background:rgba(255,255,255,0.015);border:1px dashed rgba(255,255,255,0.02);font-family:monospace;font-size:13px;color:#d8eef7}
    .stats{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
    .stat{padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.006), rgba(255,255,255,0.004));min-width:84px;text-align:center}
    .stat .n{font-weight:800;font-size:18px}
    .row-actions{display:flex;gap:8px;align-items:center}
    .small{padding:6px 8px;border-radius:8px;font-size:13px}
    .muted{color:var(--muted);font-size:13px}
    .codebox{background:rgba(0,0,0,0.16);padding:10px;border-radius:8px;font-family:monospace;font-size:13px;color:#dff3ff;border:1px solid rgba(255,255,255,0.02)}
    .flex-col{display:flex;flex-direction:column;gap:8px}
    .controls .panel .hint{font-size:12px;color:var(--muted)}
    .center{display:flex;align-items:center;justify-content:center}
    /* animations */
    .fade-in{animation:fadeIn 360ms ease both}
    @keyframes fadeIn{from{opacity:0;transform:translateY(-6px)}to{opacity:1;transform:none}}
    .slide-from-right{animation:slideRight 420ms cubic-bezier(.2,.9,.3,1) both}
    @keyframes slideRight{from{transform:translateX(18px) scale(.98);opacity:0}to{transform:none;opacity:1}}
    .pulse{animation:pulse 800ms ease}
    @keyframes pulse{0%{box-shadow:0 6px 18px rgba(79,70,229,0.0)}50%{box-shadow:0 12px 28px rgba(79,70,229,0.12)}100%{box-shadow:0 6px 18px rgba(79,70,229,0.0)}}
    .hint-small{font-size:12px;color:var(--muted)}
    footer{margin-top:18px;color:var(--muted);font-size:13px;text-align:center}
    /* responsive */
    @media (max-width:920px){
      .main{flex-direction:column}
      .right{width:100%}
      .left{min-width:auto}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Queue — Interactive demo</h1>
    <p class="lead">Explore the queue data structure. Enqueue, dequeue, peek and visualize both a dynamic (array-based) queue and a fixed-size circular queue with indices.</p>

    <div class="controls">
      <div class="panel">
        <div style="display:flex;flex-direction:column">
          <label class="hint-small">Implementation</label>
          <select id="implSelect" title="Choose queue implementation">
            <option value="dynamic">Dynamic array queue</option>
            <option value="circular">Fixed-size circular queue</option>
          </select>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;align-items:center;gap:8px">
          <input id="valueInput" type="text" placeholder="Value to enqueue (string/number)">
          <button id="enqueueBtn">Enqueue</button>
          <button id="dequeueBtn" class="secondary">Dequeue</button>
          <button id="peekBtn" class="secondary">Peek</button>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;align-items:center;gap:8px">
          <label class="hint-small">Capacity (for circular)</label>
          <input id="capInput" type="number" min="2" max="20" value="7" style="width:84px">
          <button id="resetBtn" class="secondary">Reset</button>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;align-items:center;gap:8px">
          <button id="fillBtn" class="secondary small">Fill random</button>
          <button id="clearBtn" class="warn small">Clear</button>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;align-items:center;gap:8px">
          <button id="autoplayBtn" class="small secondary">Auto-run</button>
          <label class="hint-small">Speed</label>
          <input id="speedRange" type="range" min="200" max="2000" value="900">
        </div>
      </div>
    </div>

    <div class="main">
      <div class="left">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="muted">Visual representation</div>
          <div class="muted">Animations highlight source of change</div>
        </div>

        <div class="visual" id="visualArea" aria-live="polite">
          <!-- dynamic content -->
        </div>

        <div class="annotations">
          <div class="badge">Front pointer: <span id="frontIdx">-</span></div>
          <div class="badge">Rear pointer: <span id="rearIdx">-</span></div>
          <div class="badge">Size: <span id="sizeVal">0</span></div>
          <div class="badge">Empty: <span id="emptyVal">true</span></div>
        </div>

        <div style="margin-top:12px;display:flex;gap:12px;align-items:center">
          <div class="stat"><div class="muted">Operations</div><div class="n" id="opCount">0</div></div>
          <div class="stat"><div class="muted">Last op</div><div id="lastOp" class="muted">-</div></div>
        </div>

        <div style="margin-top:12px">
          <div class="muted">Pseudo-code (highlights operation)</div>
          <div class="codebox" id="pseudo" style="min-height:84px">
            <!-- pseudo lines -->
          </div>
        </div>
      </div>

      <div class="right">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="muted">Log</div>
          <div class="muted hint-small">Recent events</div>
        </div>
        <div class="log" id="logArea"></div>

        <div style="margin-top:12px">
          <div class="muted">Underlying structure (array view)</div>
          <div class="visual" id="arrayView" style="min-height:120px;padding:10px"></div>
        </div>

        <div style="margin-top:12px">
          <div class="muted">Implementation details</div>
          <div class="codebox" id="implNote" style="margin-top:6px">
            Dynamic array: push/pop from end with shift on dequeue (simple).
            Circular queue: fixed array with front/rear indices and modulo arithmetic.
          </div>
        </div>
      </div>
    </div>

    <footer>
      Try enqueuing values, dequeuing, peek, toggling implementations, and toggling autoplay.
    </footer>
  </div>

  <script>
    // Queue demo script
    (function(){
      // DOM refs
      const implSelect = document.getElementById('implSelect');
      const valueInput = document.getElementById('valueInput');
      const enqueueBtn = document.getElementById('enqueueBtn');
      const dequeueBtn = document.getElementById('dequeueBtn');
      const peekBtn = document.getElementById('peekBtn');
      const resetBtn = document.getElementById('resetBtn');
      const fillBtn = document.getElementById('fillBtn');
      const clearBtn = document.getElementById('clearBtn');
      const autoplayBtn = document.getElementById('autoplayBtn');
      const speedRange = document.getElementById('speedRange');
      const capInput = document.getElementById('capInput');

      const visualArea = document.getElementById('visualArea');
      const arrayView = document.getElementById('arrayView');
      const frontIdx = document.getElementById('frontIdx');
      const rearIdx = document.getElementById('rearIdx');
      const sizeVal = document.getElementById('sizeVal');
      const emptyVal = document.getElementById('emptyVal');
      const opCount = document.getElementById('opCount');
      const lastOp = document.getElementById('lastOp');
      const logArea = document.getElementById('logArea');
      const pseudo = document.getElementById('pseudo');

      let operationCounter = 0;
      let autoplay = false;
      let autoplayTimer = null;
      let impl = 'dynamic';
      let speed = parseInt(speedRange.value,10);

      // Two implementations:
      class DynamicQueue {
        constructor(){
          this.arr = [];
        }
        enqueue(x){
          this.arr.push(x);
        }
        dequeue(){
          return this.arr.length? this.arr.shift() : undefined;
        }
        peek(){
          return this.arr.length? this.arr[0] : undefined;
        }
        size(){ return this.arr.length }
        isEmpty(){ return this.arr.length===0 }
        clear(){ this.arr = [] }
        toArray(){ return this.arr.slice() }
      }

      class CircularQueue {
        constructor(capacity){
          this.cap = Math.max(2, capacity|0);
          this.arr = new Array(this.cap).fill(null);
          this.front = 0;
          this.rear = 0;
          this.count = 0;
        }
        enqueue(x){
          if(this.count === this.cap) return false; // full
          this.arr[this.rear] = x;
          this.rear = (this.rear+1) % this.cap;
          this.count++;
          return true;
        }
        dequeue(){
          if(this.count===0) return undefined;
          const v = this.arr[this.front];
          this.arr[this.front] = null;
          this.front = (this.front+1) % this.cap;
          this.count--;
          return v;
        }
        peek(){ return this.count? this.arr[this.front] : undefined }
        size(){ return this.count }
        isEmpty(){ return this.count===0 }
        clear(){
          this.arr = new Array(this.cap).fill(null);
          this.front = this.rear = this.count = 0;
        }
        toArray(){
          // shows logical order from front to rear
          const out = [];
          for(let i=0;i<this.count;i++){
            out.push(this.arr[(this.front+i)%this.cap]);
          }
          return out;
        }
      }

      // Current queue instance
      let q = new DynamicQueue();
      function resetQueue(){
        impl = implSelect.value;
        if(impl==='dynamic'){
          q = new DynamicQueue();
        } else {
          const cap = Math.max(2, parseInt(capInput.value||7,10) || 7);
          q = new CircularQueue(cap);
        }
        operationCounter = 0;
        updateAll();
        log("Reset queue (" + (impl==='dynamic' ? "dynamic array" : "circular capacity="+q.cap) + ")");
      }

      // Logging
      function log(s){
        const time = new Date().toLocaleTimeString();
        const node = document.createElement('div');
        node.textContent = `[${time}] ${s}`;
        logArea.insertBefore(node, logArea.firstChild);
      }

      // Visual helpers
      function clearVisual(){
        visualArea.innerHTML = '';
        arrayView.innerHTML = '';
      }

      function updateAll(highlight){
        // highlight: {type:'enqueue'|'dequeue'|'peek', value, idx}
        clearVisual();
        // Visual row (logical left->right: front ... rear)
        const row = document.createElement('div');
        row.className = 'queue-row';
        const logical = q.toArray ? q.toArray() : [];
        // If using dynamic, q.toArray() exists. For completeness.
        // For circular, toArray returns logical order.
        const display = logical;
        if(display.length === 0){
          const emptySlot = document.createElement('div');
          emptySlot.className = 'slot empty fade-in';
          emptySlot.textContent = 'empty';
          row.appendChild(emptySlot);
        } else {
          display.forEach((v,i) => {
            const s = document.createElement('div');
            s.className = 'slot fade-in';
            s.textContent = String(v);
            // apply highlight
            if(highlight && highlight.type==='enqueue' && highlight.value!==undefined && highlight.value === v && highlight.once){
              s.classList.add('pulse');
              // ensure 'once' only pulses first match
              highlight.once = false;
            }
            if(highlight && highlight.type==='dequeue' && highlight.idx===i){
              s.style.boxShadow = '0 10px 30px rgba(239,68,68,0.12)';
              s.classList.add('slide-from-right');
            }
            row.appendChild(s);
          });
        }
        visualArea.appendChild(row);

        // pointers for circular show indices. For dynamic, show front=0, rear=size-1
        if(impl === 'dynamic'){
          frontIdx.textContent = q.size()? 0 : '-';
          rearIdx.textContent = q.size()? (q.size()-1) : '-';
          // arrayView: show raw array underlying (dynamic JS array)
          const arr = q.toArray();
          drawArrayView(arr, {logical: true});
        } else {
          // circular
          frontIdx.textContent = q.count? q.front : '-';
          rearIdx.textContent = q.count? ((q.rear - 1 + q.cap) % q.cap) : '-';
          drawArrayView(q.arr, {logical:false, cap:q.cap, front:q.front, rear:q.rear, count:q.count});
        }

        sizeVal.textContent = q.size? q.size() : '-';
        emptyVal.textContent = q.isEmpty? q.isEmpty() : '-';
        opCount.textContent = operationCounter;
      }

      function drawArrayView(arr, opts){
        // arr: array to display (either logical or fixed array)
        arrayView.innerHTML = '';
        const row = document.createElement('div');
        row.className = 'queue-row';
        arr.forEach((v,i)=>{
          const s = document.createElement('div');
          s.className = 'slot';
          if(v === null || v === undefined) { s.classList.add('empty'); s.textContent = 'empty'; }
          else s.textContent = String(v);
          s.style.minWidth = '56px';
          row.appendChild(s);
        });
        arrayView.appendChild(row);

        if(!opts.logical){
          // show indices bar
          const indexRow = document.createElement('div');
          indexRow.style.display='flex';
          indexRow.style.gap='10px';
          indexRow.style.marginTop='8px';
          arr.forEach((v,i)=>{
            const idx = document.createElement('div');
            idx.className='hint-small';
            idx.style.width='72px';
            idx.style.textAlign='center';
            idx.textContent = i;
            indexRow.appendChild(idx);
          });
          arrayView.appendChild(indexRow);

          // pointers markers
          // create pointer badges for front and rear positions
          const pointerFront = document.createElement('div');
          pointerFront.className='pointer';
          pointerFront.style.left = computePointerLeft(opts.front);
          pointerFront.textContent = 'front ('+opts.front+')';
          arrayView.appendChild(pointerFront);

          const r = (opts.rear - 1 + opts.cap) % opts.cap;
          const pointerRear = document.createElement('div');
          pointerRear.className='pointer';
          pointerRear.style.left = computePointerLeft(r);
          pointerRear.style.top = 'auto';
          pointerRear.style.bottom = '-18px';
          pointerRear.textContent = 'rear (' + r + ')';
          arrayView.appendChild(pointerRear);

          function computePointerLeft(idx){
            // approximate position inside arrayView:
            const slotW = 72;
            const gap = 10;
            const left = 10 + idx * (slotW + gap);
            return left + 'px';
          }
        } else {
          // logical dynamic: show simple label
          const msg = document.createElement('div');
          msg.className='hint-small';
          msg.style.marginTop='8px';
          msg.textContent = 'Logical order (front -> rear)';
          arrayView.appendChild(msg);
        }
      }

      // Pseudo-code display helper
      function setPseudoFor(op){
        const lines = {
          enqueue_dynamic: [
            'function enqueue(x):',
            '    arr.push(x)       // O(1) amortized',
            '    // rear moves to end'
          ],
          dequeue_dynamic: [
            'function dequeue():',
            '    if arr.length == 0: return undefined',
            '    return arr.shift()  // O(n) due to shift'
          ],
          enqueue_circular: [
            'function enqueue(x):',
            '    if count == capacity: return false   // full',
            '    arr[rear] = x',
            '    rear = (rear + 1) % capacity',
            '    count += 1'
          ],
          dequeue_circular: [
            'function dequeue():',
            '    if count == 0: return undefined',
            '    v = arr[front]',
            '    arr[front] = null',
            '    front = (front + 1) % capacity',
            '    count -= 1',
            '    return v'
          ],
          peek: [
            'function peek():',
            '    if size == 0: return undefined',
            '    return element at front'
          ]
        };
        pseudo.innerHTML = lines[op].map((l,i)=>'<div style="padding:2px 0">'+escapeHtml(l)+'</div>').join('');
      }

      function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

      // Operations
      function doEnqueue(val){
        if(val === '') { alert('Please enter a value to enqueue'); return; }
        if(impl === 'dynamic'){
          setPseudoFor('enqueue_dynamic');
          q.enqueue(val);
          operationCounter++;
          lastOp.textContent = 'enqueue ' + val;
          log('Enqueued "'+val+'" (dynamic)');
          updateAll({type:'enqueue', value:val, once:true});
        } else {
          setPseudoFor('enqueue_circular');
          const ok = q.enqueue(val);
          if(!ok){
            // show full
            log('Enqueue failed: queue is full (capacity='+q.cap+')');
            flashMessage('Queue is full — cannot enqueue', true);
          } else {
            operationCounter++;
            lastOp.textContent = 'enqueue ' + val;
            log('Enqueued "'+val+'" (circular)');
            updateAll({type:'enqueue', value:val, once:true});
          }
        }
      }

      function doDequeue(){
        setPseudoFor(impl==='dynamic' ? 'dequeue_dynamic' : 'dequeue_circular');
        const v = q.dequeue();
        operationCounter++;
        lastOp.textContent = 'dequeue';
        if(v === undefined){
          log('Dequeue: queue empty');
          flashMessage('Queue empty', true);
        } else {
          log('Dequeued "'+v+'"');
        }
        updateAll({type:'dequeue', idx:0});
      }

      function doPeek(){
        setPseudoFor('peek');
        const v = q.peek();
        operationCounter++;
        lastOp.textContent = 'peek';
        if(v === undefined){ log('Peek: empty'); flashMessage('Queue empty', true); }
        else { log('Peek -> "'+v+'"'); flashMessage('Peek -> ' + String(v)); }
        updateAll();
      }

      // UI extras
      function flashMessage(txt, isError){
        // show temporary log-like message top-right
        const node = document.createElement('div');
        node.textContent = txt;
        node.style.position = 'fixed';
        node.style.right = '20px';
        node.style.top = '20px';
        node.style.padding = '10px 12px';
        node.style.borderRadius = '8px';
        node.style.fontWeight = '700';
        node.style.background = isError ? 'rgba(239,68,68,0.12)' : 'rgba(6,182,212,0.06)';
        node.style.border = isError ? '1px solid rgba(239,68,68,0.18)' : '1px solid rgba(6,182,212,0.12)';
        node.style.color = isError ? '#ffdfe0' : '#cff7ff';
        document.body.appendChild(node);
        setTimeout(()=>{ node.style.transition='all 360ms'; node.style.opacity='0'; node.style.transform='translateY(-6px)'; setTimeout(()=>node.remove(),360); }, 900);
      }

      // Fill random
      function fillRandom(){
        const sample = ['A','B','C','1','2','3','X','Y','Z','α','β','7'];
        const n = impl==='dynamic' ? (Math.floor(Math.random()*6)+1) : Math.min(q.cap, Math.floor(Math.random()* (q.cap-1) ) + 1);
        for(let i=0;i<n;i++){
          const val = sample[Math.floor(Math.random()*sample.length)] + (Math.random()<0.4? Math.floor(Math.random()*90):'');
          if(impl==='dynamic') q.enqueue(val);
          else {
            if(!q.enqueue(val)) break;
          }
        }
        operationCounter += n;
        log('Filled with '+n+' random values');
        updateAll();
      }

      // Clear
      function clearQ(){
        if(q.clear) q.clear();
        else { // fallback
          while(!q.isEmpty()) q.dequeue();
        }
        operationCounter++;
        log('Cleared queue');
        updateAll();
      }

      // Reset handler
      resetBtn.addEventListener('click', ()=>{
        resetQueue();
      });

      // Implementation switch
      implSelect.addEventListener('change', ()=>{
        resetQueue();
      });

      // Buttons
      enqueueBtn.addEventListener('click', ()=>{ const v = valueInput.value.trim(); doEnqueue(v); valueInput.value=''; });
      dequeueBtn.addEventListener('click', doDequeue);
      peekBtn.addEventListener('click', doPeek);
      fillBtn.addEventListener('click', fillRandom);
      clearBtn.addEventListener('click', clearQ);

      // autoplay behavior: randomly enqueue/dequeue
      autoplayBtn.addEventListener('click', ()=>{
        autoplay = !autoplay;
        autoplayBtn.textContent = autoplay? 'Stop' : 'Auto-run';
        autoplayBtn.classList.toggle('secondary', !autoplay);
        autoplayBtn.classList.toggle('warn', autoplay);
        if(autoplay) startAutoplay(); else stopAutoplay();
      });

      speedRange.addEventListener('input', ()=>{
        speed = parseInt(speedRange.value,10);
        if(autoplay) {
          stopAutoplay();
          startAutoplay();
        }
      });

      capInput.addEventListener('change', ()=>{
        // change cap only affects when switching to circular or reset
        if(implSelect.value==='circular') resetQueue();
      });

      // keyboard convenience
      valueInput.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){ enqueueBtn.click(); }
      });

      function startAutoplay(){
        if(autoplayTimer) clearInterval(autoplayTimer);
        autoplayTimer = setInterval(()=>{
          // random action: enqueue or dequeue (biased)
          const choose = Math.random();
          if(choose < 0.55){
            // enqueue
            const sample = ['A','B','C','1','2','3','X','Y','Z','α','β','7'];
            const val = sample[Math.floor(Math.random()*sample.length)] + (Math.random()<0.5? Math.floor(Math.random()*50):'');
            doEnqueue(val);
          } else {
            doDequeue();
          }
        }, Math.max(120, speed));
      }
      function stopAutoplay(){ if(autoplayTimer) clearInterval(autoplayTimer); autoplayTimer = null; }

      // initial setup
      resetQueue();

      // expose to window for debugging (optional)
      window._queueDemo = {resetQueue, doEnqueue, doDequeue, doPeek, q};

      // Small accessibility: update aria-live label for visual area
      const observer = new MutationObserver(()=>{ visualArea.setAttribute('aria-label','Queue visual updated, size '+(q.size? q.size():0)); });
      observer.observe(visualArea, {childList:true, subtree:true});
    })();
  </script>
</body>
</html>