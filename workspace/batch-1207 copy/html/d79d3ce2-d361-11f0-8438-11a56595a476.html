<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bellman-Ford Algorithm Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    display: flex;
    height: 100vh;
    overflow: hidden;
  }
  #container {
    display: flex;
    flex-direction: row;
    flex-grow: 1;
  }
  #graph-container {
    flex: 1;
    background: #f5f5f5;
    position: relative;
  }
  svg {
    width: 100%;
    height: 100vh;
  }
  #controls {
    width: 350px;
    background: #222;
    color: #eee;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
  }
  #controls h2 {
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
  }
  label {
    font-weight: bold;
    margin-top: 10px;
  }
  textarea {
    width: 100%;
    height: 80px;
    resize: vertical;
    font-family: monospace;
    font-size: 14px;
    margin-top: 5px;
    box-sizing: border-box;
  }
  select, input[type=number] {
    width: 100%;
    margin-top: 5px;
    padding: 5px;
    box-sizing: border-box;
    font-size: 14px;
  }
  button {
    margin-top: 15px;
    padding: 10px;
    font-size: 16px;
    cursor: pointer;
    background: #0b79d0;
    color: white;
    border: none;
    border-radius: 3px;
  }
  button:disabled {
    background: #666;
    cursor: not-allowed;
  }
  #messages {
    margin-top: 15px;
    height: 130px;
    overflow-y: auto;
    background: #111;
    border: 1px solid #444;
    padding: 8px;
    font-family: monospace;
    font-size: 13px;
    white-space: pre-wrap;
  }
  #distances {
    margin-top: 15px;
    background: #111;
    border: 1px solid #444;
    padding: 8px;
    font-size: 14px;
    min-height: 80px;
    overflow-y: auto;
    font-family: monospace;
  }
  .node circle {
    fill: #3498db;
    stroke: #2980b9;
    stroke-width: 3px;
    cursor: pointer;
    transition: fill 0.3s;
  }
  .node text {
    fill: white;
    font-weight: bold;
    pointer-events: none;
    user-select: none;
  }
  .edge path {
    stroke: #444;
    stroke-width: 2px;
    fill: none;
    marker-end: url(#arrowhead);
    transition: stroke 0.3s, stroke-width 0.3s;
  }
  .edge text {
    fill: #222;
    font-weight: bold;
    font-size: 12px;
    user-select: none;
  }
  .edge.highlight path {
    stroke: #e74c3c;
    stroke-width: 4px;
  }
  .node.start circle {
    fill: #27ae60;
    stroke: #1f8c4a;
  }
  .node.relaxed circle {
    fill: #f39c12;
    stroke: #d67e00;
  }
  .negative-cycle {
    color: #e74c3c;
    font-weight: bold;
    font-size: 16px;
    text-align: center;
    margin-top: 15px;
  }
  #step-info {
    margin-top: 10px;
    font-family: monospace;
    background: #222;
    padding: 6px;
    border-radius: 3px;
    font-size: 13px;
    min-height: 60px;
    overflow-y: auto;
  }
  footer {
    position: absolute;
    bottom: 5px;
    left: 20px;
    color: #999;
    font-size: 12px;
  }
</style>
</head>
<body>
<div id="container">
  <div id="graph-container">
    <svg id="graph"></svg>
    <footer>Bellman-Ford Algorithm Visualization - Click nodes to select start vertex before running.</footer>
  </div>
  <div id="controls">
    <h2>Bellman-Ford Algorithm</h2>
    <label for="vertex-count">Number of Vertices (2-20):</label>
    <input type="number" id="vertex-count" min="2" max="20" value="5" />
    <label for="edge-list">Edges (one per line: from to weight):</label>
    <textarea id="edge-list" placeholder="Example:
0 1 6
0 2 7
1 2 8
1 3 5
1 4 -4
2 3 -3
2 4 9
3 1 -2
4 0 2
4 3 7"></textarea>
    <label for="start-vertex">Start Vertex:</label>
    <select id="start-vertex"></select>
    <button id="btn-generate">Generate Graph</button>
    <button id="btn-start" disabled>Run Bellman-Ford Step-by-Step</button>
    <button id="btn-next" disabled>Next Step</button>
    <button id="btn-reset" disabled>Reset</button>
    <div id="messages"></div>
    <div id="distances"></div>
    <div id="step-info"></div>
  </div>
</div>

<script>
(() => {
  // HTML Elements
  const svg = document.getElementById("graph");
  const vertexCountInput = document.getElementById("vertex-count");
  const edgeListInput = document.getElementById("edge-list");
  const startVertexSelect = document.getElementById("start-vertex");
  const btnGenerate = document.getElementById("btn-generate");
  const btnStart = document.getElementById("btn-start");
  const btnNext = document.getElementById("btn-next");
  const btnReset = document.getElementById("btn-reset");
  const messagesDiv = document.getElementById("messages");
  const distancesDiv = document.getElementById("distances");
  const stepInfoDiv = document.getElementById("step-info");

  let graph = { vertices: 0, edges: [] };
  let nodePositions = [];
  let nodeElements = [];
  let edgeElements = [];
  let distances = [];
  let predecessors = [];
  let startVertex = 0;
  let iteration = 0;
  let stepEdgeIndex = 0;
  let isRunning = false;
  let negativeCycleDetected = false;
  let relaxationLogs = [];
  // For animation step tracking:
  // We'll run V-1 iterations, each iteration tries all edges in order
  // Finally one extra iteration for negative cycle detection

  // Utility: Clear SVG
  function clearSVG() {
    while (svg.lastChild) svg.removeChild(svg.lastChild);
  }

  // Draw arrowhead marker for directed edges
  function drawArrowMarker() {
    const markerId = "arrowhead";
    // Check if marker already defined
    if (svg.querySelector("#" + markerId)) return;

    const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    marker.setAttribute("id", markerId);
    marker.setAttribute("markerWidth", "10");
    marker.setAttribute("markerHeight", "7");
    marker.setAttribute("refX", "10");
    marker.setAttribute("refY", "3.5");
    marker.setAttribute("orient", "auto");
    marker.setAttribute("fill", "#444");

    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", "M0,0 L10,3.5 L0,7 L2,3.5 z");
    marker.appendChild(path);

    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    defs.appendChild(marker);
    svg.appendChild(defs);
  }

  // Calculate positions for vertices on a circle
  function calculatePositions(vertexCount, width = svg.clientWidth, height = svg.clientHeight) {
    const radius = Math.min(width, height) / 2.5;
    const centerX = width / 2;
    const centerY = height / 2;
    const positions = [];
    for (let i = 0; i < vertexCount; i++) {
      const angle = (2 * Math.PI * i) / vertexCount - Math.PI / 2;
      positions.push({
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle)
      });
    }
    return positions;
  }

  // Draw the whole graph
  function drawGraph() {
    clearSVG();
    drawArrowMarker();

    // Draw edges first so they appear below nodes
    edgeElements = [];
    graph.edges.forEach((edge, idx) => {
      const fromPos = nodePositions[edge.from];
      const toPos = nodePositions[edge.to];
      const edgeGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
      edgeGroup.classList.add("edge");
      edgeGroup.setAttribute("data-edge-index", idx);

      // Create curved path if from == to (self loop) or if multiple edges between same nodes
      // For simplicity, we'll draw straight lines for all edges here
      // But to avoid overlap, we adjust edges if there are edges in both directions between two nodes

      let dx = toPos.x - fromPos.x;
      let dy = toPos.y - fromPos.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      if (dist === 0) dist = 1; // avoid div zero

      // Normalize direction vector
      const nx = dx / dist;
      const ny = dy / dist;

      // Arrow line start/end adjusted so it doesn't touch node circle centers but node edge:
      // nodes radius: 20
      const r = 20;

      // Adjusted points
      let startX = fromPos.x + nx * r;
      let startY = fromPos.y + ny * r;
      let endX = toPos.x - nx * r;
      let endY = toPos.y - ny * r;

      // To avoid arrow overlap for edges in opposite directions, shift slightly
      const isOpposite = graph.edges.some((e2, i2) => 
        i2 !== idx &&
        e2.from === edge.to &&
        e2.to === edge.from
      );
      if (isOpposite) {
        // Shift perpendicular by 8 pixels
        const perpX = -ny;
        const perpY = nx;
        startX += perpX * 8;
        startY += perpY * 8;
        endX += perpX * 8;
        endY += perpY * 8;
      }

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", `M${startX},${startY} L${endX},${endY}`);
      path.setAttribute("marker-end", "url(#arrowhead)");
      edgeGroup.appendChild(path);

      // Label the edge weight - position it at middle point plus slight orthogonal offset
      const labelX = (startX + endX) / 2;
      const labelY = (startY + endY) / 2;

      // Offset label orthogonal by 12px
      const labelOffset = 12;
      const labelPosX = labelX - ny * labelOffset;
      const labelPosY = labelY + nx * labelOffset;

      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", labelPosX);
      text.setAttribute("y", labelPosY);
      text.textContent = edge.weight;
      edgeGroup.appendChild(text);

      svg.appendChild(edgeGroup);
      edgeElements.push(edgeGroup);
    });

    // Draw nodes
    nodeElements = [];
    graph.vertices = parseInt(graph.vertices);
    for (let i = 0; i < graph.vertices; i++) {
      const pos = nodePositions[i];
      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      group.classList.add("node");
      group.setAttribute("data-node", i);
      group.style.cursor = "pointer";

      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", pos.x);
      circle.setAttribute("cy", pos.y);
      circle.setAttribute("r", 20);
      group.appendChild(circle);

      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", pos.x);
      text.setAttribute("y", pos.y + 6);
      text.setAttribute("text-anchor", "middle");
      text.textContent = i;
      group.appendChild(text);

      svg.appendChild(group);
      nodeElements.push(group);
    }

    // Add node click handlers to select start vertex
    nodeElements.forEach((nodeEl, i) => {
      nodeEl.onclick = () => {
        if (isRunning) return;
        selectStartVertex(i);
      };
    });
  }

  // Parse edges from text area
  function parseEdges(inputText, vertexCount) {
    const lines = inputText.trim().split("\n");
    const edges = [];
    for (let line of lines) {
      if (!line.trim()) continue;
      // from to weight
      const parts = line.trim().split(/\s+/);
      if (parts.length !== 3) throw new Error("Each edge line must contain exactly 3 values: from to weight.");
      let [fromS, toS, wS] = parts;
      let from = parseInt(fromS);
      let to = parseInt(toS);
      let weight = Number(wS);
      if (isNaN(from) || isNaN(to) || isNaN(weight)) throw new Error("Invalid edge line: " + line);
      if (from < 0 || from >= vertexCount || to < 0 || to >= vertexCount) {
        throw new Error(`Edge vertex indices out of range (0 to ${vertexCount-1}): ${line}`);
      }
      edges.push({from, to, weight});
    }
    return edges;
  }

  // Update start vertex dropdown options
  function updateStartVertexOptions(vertexCount) {
    startVertexSelect.innerHTML = "";
    for (let i = 0; i < vertexCount; i++) {
      const option = document.createElement("option");
      option.value = i;
      option.textContent = i;
      startVertexSelect.appendChild(option);
    }
    startVertexSelect.value = "0";
    startVertex = 0;
  }

  // Display messages in messagesDiv
  function appendMessage(msg, isError = false) {
    messagesDiv.textContent += msg + "\n";
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
    if (isError) {
      messagesDiv.style.color = "#e74c3c";
    } else {
      messagesDiv.style.color = "#eee";
    }
  }

  // Display distances in a formatted way
  function displayDistances() {
    let text = "Distances from start vertex " + startVertex + ":\n";
    for (let i = 0; i < graph.vertices; i++) {
      let distText = (distances[i] === Infinity) ? "∞" : distances[i].toString();
      text += `  ${i}: ${distText}\n`;
    }
    distancesDiv.textContent = text;
  }

  // Highlight start node and update node colors based on relaxation
  function updateNodeColors() {
    nodeElements.forEach((group, i) => {
      group.classList.remove("start", "relaxed");
      if (i === startVertex) group.classList.add("start");
    });
  }

  // Highlight a particular edge by index
  function highlightEdge(edgeIndex) {
    edgeElements.forEach((edgeGroup, i) => {
      edgeGroup.classList.toggle("highlight", i === edgeIndex);
    });
  }

  // Bellman-Ford state and steps
  // We'll implement stepwise relaxation for each edge.
  // For iteration i, we relax all edges in order.

  function resetState() {
    iteration = 0;
    stepEdgeIndex = 0;
    distances = new Array(graph.vertices).fill(Infinity);
    predecessors = new Array(graph.vertices).fill(null);
    distances[startVertex] = 0;
    negativeCycleDetected = false;
    relaxationLogs = [];
    isRunning = false;
    btnNext.disabled = true;
    btnStart.disabled = false;
    btnReset.disabled = false;
    stepInfoDiv.textContent = "";
    updateNodeColors();
    displayDistances();
    highlightEdge(-1);
    appendMessage("Ready to start Bellman-Ford algorithm.");
  }

  // One relaxation step for the current edge during the current iteration
  function stepRelaxEdge() {
    if (negativeCycleDetected) return;

    const edge = graph.edges[stepEdgeIndex];
    const u = edge.from;
    const v = edge.to;
    const w = edge.weight;

    let didRelax = false;
    const distU = distances[u];
    const distV = distances[v];
    let logMsg = `Iter ${iteration + 1}, edge ${u} -> ${v} (w=${w}): `;

    if (distU !== Infinity && distU + w < distV) {
      distances[v] = distU + w;
      predecessors[v] = u;
      didRelax = true;
      logMsg += `Relaxed - distance updated from ${distV === Infinity ? "∞" : distV} to ${distances[v]}`;
      // Highlight relaxed node
      nodeElements[v].classList.add("relaxed");
    } else {
      logMsg += "No relaxation";
      nodeElements[v].classList.remove("relaxed");
    }

    relaxationLogs.push(logMsg);
    displayDistances();
    stepInfoDiv.textContent = logMsg;
    highlightEdge(stepEdgeIndex);

    stepEdgeIndex++;

    // If finished relaxing all edges in iteration
    if (stepEdgeIndex >= graph.edges.length) {
      iteration++;
      stepEdgeIndex = 0;

      // After V-1 iterations, run one more iteration to check negative cycles
      if (iteration === graph.vertices) {
        // Detect negative cycle step
        let negativeFound = false;
        for (let i = 0; i < graph.edges.length; i++) {
          const e = graph.edges[i];
          const u = e.from;
          const v = e.to;
          const w = e.weight;
          if (distances[u] !== Infinity && distances[u] + w < distances[v]) {
            negativeFound = true;
            highlightEdge(i);
            stepInfoDiv.textContent = `Negative weight cycle detected! Edge ${u} -> ${v} can still relax distance.`;
            appendMessage("Negative weight cycle detected! Algorithm terminated.");
            negativeCycleDetected = true;
            break;
          }
        }
        if (!negativeFound) {
          appendMessage("No negative weight cycles detected. Algorithm complete.");
          stepInfoDiv.textContent = "Algorithm complete: Shortest distances finalized.";
        }
        btnNext.disabled = true;
      }
    }
  }

  // Step through the algorithm
  function nextStep() {
    if (!isRunning) return;
    if (negativeCycleDetected) return;
    if (iteration >= graph.vertices) return;
    stepRelaxEdge();
  }

  // Handle start button click: initialize and start algo
  function startAlgorithm() {
    if (isRunning) return;
    isRunning = true;
    btnNext.disabled = false;
    btnStart.disabled = true;
    btnGenerate.disabled = true;
    vertexCountInput.disabled = true;
    edgeListInput.disabled = true;
    startVertexSelect.disabled = true;
    btnReset.disabled = false;
    appendMessage(`Starting Bellman-Ford from vertex ${startVertex}...`);
  }

  // Handle reset button click
  function resetAlgorithm() {
    isRunning = false;
    btnNext.disabled = true;
    btnStart.disabled = false;
    btnGenerate.disabled = false;
    vertexCountInput.disabled = false;
    edgeListInput.disabled = false;
    startVertexSelect.disabled = false;
    btnReset.disabled = true;
    iteration = 0;
    stepEdgeIndex = 0;
    negativeCycleDetected = false;
    distances = [];
    predecessors = [];
    relaxationLogs = [];
    stepInfoDiv.textContent = "";
    messagesDiv.textContent = "";
    distancesDiv.textContent = "";
    updateNodeColors();
    highlightEdge(-1);
  }

  // Select start vertex from dropdown or graph node clicks
  function selectStartVertex(newStart) {
    if (isRunning) return;
    startVertex = newStart;
    startVertexSelect.value = newStart;
    updateNodeColors();
    appendMessage(`Start vertex set to ${startVertex}.`);
    distancesDiv.textContent = "";
    stepInfoDiv.textContent = "";
  }

  // Generate graph from inputs
  function generateGraph() {
    try {
      const vertexCount = parseInt(vertexCountInput.value);
      if (isNaN(vertexCount) || vertexCount < 2 || vertexCount > 20)
        throw new Error("Vertex count must be an integer between 2 and 20.");

      // Parse edges
      const edges = parseEdges(edgeListInput.value, vertexCount);

      graph = {
        vertices: vertexCount,
        edges: edges
      };

      nodePositions = calculatePositions(vertexCount);
      drawGraph();
      updateStartVertexOptions(vertexCount);
      selectStartVertex(0);

      btnStart.disabled = false;
      btnReset.disabled = true;
      btnNext.disabled = true;
      messagesDiv.textContent = "";
      distancesDiv.textContent = "";
      stepInfoDiv.textContent = "";
      appendMessage("Graph generated successfully.");
    } catch (e) {
      messagesDiv.textContent = "";
      appendMessage("Error: " + e.message, true);
      btnStart.disabled = true;
    }
  }

  // Event bindings
  btnGenerate.addEventListener("click", () => {
    resetAlgorithm();
    generateGraph();
  });
  btnStart.addEventListener("click", () => {
    distances = new Array(graph.vertices).fill(Infinity);
    predecessors = new Array(graph.vertices).fill(null);
    distances[startVertex] = 0;
    iteration = 0;
    stepEdgeIndex = 0;
    negativeCycleDetected = false;
    relaxationLogs = [];
    isRunning = true;
    btnNext.disabled = false;
    btnStart.disabled = true;
    btnGenerate.disabled = true;
    vertexCountInput.disabled = true;
    edgeListInput.disabled = true;
    startVertexSelect.disabled = true;
    messagesDiv.textContent = "";
    distancesDiv.textContent = "";
    stepInfoDiv.textContent = "";
    appendMessage(`Started Bellman-Ford from vertex ${startVertex}.`);
    displayDistances();
    updateNodeColors();
    highlightEdge(-1);
  });
  btnNext.addEventListener("click", () => {
    nextStep();
  });
  btnReset.addEventListener("click", () => {
    resetAlgorithm();
  });
  startVertexSelect.addEventListener("change", e => {
    selectStartVertex(parseInt(e.target.value));
  });

  // On load: fill example edges
  function fillExample() {
    vertexCountInput.value = 5;
    edgeListInput.value = `0 1 6
0 2 7
1 2 8
1 3 5
1 4 -4
2 3 -3
2 4 9
3 1 -2
4 0 2
4 3 7`;
  }

  fillExample();
  generateGraph();

})();
</script>
</body>
</html>