<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Bellman-Ford Algorithm Visualizer</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
  :root {
    --bg: #0f1724;
    --panel: #0b1220;
    --accent: #3b82f6;
    --muted: #94a3b8;
    --good: #16a34a;
    --bad: #ef4444;
    --yellow: #f59e0b;
    --node-fill: #0ea5a4;
    --node-stroke: #065f5c;
    --edge: #cbd5e1;
    --font: 14px/1.2 "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }
  html,body { height:100%; margin:0; background:linear-gradient(180deg,#071027 0%, #071a2b 100%); font:var(--font); color:#e6eef8; }
  .app { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }
  .left {
    flex:1;
    min-width:380px;
    background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
    border-radius:8px;
    padding:12px;
    box-shadow: 0 6px 24px rgba(2,6,23,0.6);
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .canvas-wrap {
    flex:1;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
    border-radius:6px;
    position:relative;
    overflow:hidden;
  }
  svg { width:100%; height:100%; touch-action: none; }
  .controls {
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    align-items:center;
  }
  .controls button, .controls select {
    background:transparent;
    color:var(--accent);
    border:1px solid rgba(59,130,246,0.18);
    padding:6px 8px;
    border-radius:6px;
    cursor:pointer;
  }
  .controls button.active { background:rgba(59,130,246,0.12); }
  .controls label { color:var(--muted); font-size:13px; display:flex; gap:6px; align-items:center; }
  .side {
    width:360px;
    min-width:280px;
    max-width:420px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:8px;
    padding:12px;
    box-shadow: 0 6px 24px rgba(2,6,23,0.6);
    overflow:auto;
  }
  h2 { margin:8px 0; font-size:16px; color:#fff; }
  .legend { display:flex; gap:8px; flex-wrap:wrap; font-size:13px; color:var(--muted); }
  .legend .item { display:flex; gap:6px; align-items:center; }
  .badge { width:16px; height:12px; border-radius:3px; display:inline-block; }
  .panel { background:rgba(255,255,255,0.02); padding:8px; border-radius:6px; margin-bottom:8px; }
  .list { display:grid; gap:6px; max-height:220px; overflow:auto; padding-right:6px; }
  .row { display:flex; justify-content:space-between; gap:8px; align-items:center; padding:6px; background:transparent; border-radius:6px; }
  .row:hover { background:rgba(255,255,255,0.01); }
  .node-label { display:flex; gap:8px; align-items:center; }
  .small { font-size:13px; color:var(--muted); }
  .log { font-family:monospace; font-size:12px; color:#dbeafe; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); padding:8px; border-radius:6px; max-height:220px; overflow:auto; }
  .footer { display:flex; justify-content:space-between; gap:8px; align-items:center; margin-top:8px; color:var(--muted); font-size:13px; }
  .btn-danger { border-color:rgba(239,68,68,0.18); color:var(--bad); }
  input[type="number"] { width:72px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:var(--muted); }
  .info { font-size:13px; color:var(--muted); margin-bottom:6px; }
  .distance { font-weight:700; font-size:12px; color:#fff; }
  .small-muted { font-size:12px; color:var(--muted); }
  .mode-instructions { color:var(--muted); font-size:13px; }
  .preset { display:flex; gap:6px; }
  a.link { color:var(--accent); text-decoration:none; }
  @media (max-width:900px) { .app{flex-direction:column;} .side{width:100%;} }
</style>
</head>
<body>
<div class="app">
  <div class="left">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
      <div>
        <h2>Bellman-Ford Visualizer</h2>
        <div class="small-muted">Build a directed graph (weights can be negative). Step through relaxations and detect negative cycles.</div>
      </div>
      <div class="legend">
        <div class="item"><span class="badge" style="background:var(--accent)"></span><span class="small-muted">UI Controls</span></div>
        <div class="item"><span class="badge" style="background:var(--good)"></span><span class="small-muted">Improved</span></div>
        <div class="item"><span class="badge" style="background:var(--yellow)"></span><span class="small-muted">Currently checking</span></div>
        <div class="item"><span class="badge" style="background:var(--bad)"></span><span class="small-muted">Negative cycle</span></div>
      </div>
    </div>

    <div class="controls" style="margin-top:8px;">
      <button id="addNodeBtn">Add Node</button>
      <button id="addEdgeBtn">Add Edge</button>
      <button id="selectBtn" class="active">Select/Move</button>
      <button id="delBtn" class="">Delete</button>
      <label title="Treat edges as undirected (adds opposite directed edge)">
        <input type="checkbox" id="undirected"> Undirected
      </label>

      <select id="sourceSelect" title="Choose source vertex">
      </select>

      <button id="stepBtn">Step</button>
      <button id="iterBtn">Next Iteration</button>
      <button id="runBtn">Run</button>
      <button id="autoBtn">Auto</button>
      <button id="resetBtn" class="btn-danger">Reset</button>
    </div>

    <div class="canvas-wrap panel" id="canvasWrap">
      <svg id="svgCanvas" width="100%" height="520" viewBox="0 0 1200 520" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <marker id="arrow" markerWidth="10" markerHeight="10" refX="18" refY="5" orient="auto">
            <path d="M0,0 L10,5 L0,10 z" fill="#cbd5e1" />
          </marker>
          <marker id="arrow-green" markerWidth="10" markerHeight="10" refX="18" refY="5" orient="auto">
            <path d="M0,0 L10,5 L0,10 z" fill="#16a34a" />
          </marker>
          <marker id="arrow-red" markerWidth="10" markerHeight="10" refX="18" refY="5" orient="auto">
            <path d="M0,0 L10,5 L0,10 z" fill="#ef4444" />
          </marker>
          <marker id="arrow-yellow" markerWidth="10" markerHeight="10" refX="18" refY="5" orient="auto">
            <path d="M0,0 L10,5 L0,10 z" fill="#f59e0b" />
          </marker>
        </defs>
        <g id="edgesLayer"></g>
        <g id="nodesLayer"></g>
      </svg>
      <div style="position:absolute;left:10px;bottom:10px;background:rgba(0,0,0,0.2);padding:6px;border-radius:6px;color:var(--muted);font-size:13px;">
        Mode: <span id="modeLabel">Select/Move</span>
      </div>
    </div>

    <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
      <div class="small-muted">Presets:</div>
      <div class="preset">
        <button id="preset1">Example 1</button>
        <button id="preset2">Negative Cycle</button>
        <button id="clearBtn">Clear</button>
      </div>
    </div>
  </div>

  <div class="side">
    <h2>Algorithm State</h2>
    <div class="panel">
      <div class="info">Source vertex:
        <select id="sourceSelectSide"></select>
      </div>
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
        <div class="small-muted">Iteration:</div>
        <div id="iterationDisplay" class="distance">0</div>
        <div class="small-muted">Edge index:</div>
        <div id="edgeIndexDisplay" class="distance">0</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="markPathBtn">Highlight Shortest Tree</button>
        <button id="clearHighlights">Clear Highlights</button>
      </div>
    </div>

    <div class="panel">
      <div class="small-muted">Vertices</div>
      <div class="list" id="nodesList"></div>
    </div>

    <div class="panel">
      <div class="small-muted">Edges</div>
      <div class="list" id="edgesList"></div>
    </div>

    <div class="panel">
      <div class="small-muted">Log</div>
      <div class="log" id="log"></div>
    </div>

    <div class="footer">
      <div class="small-muted">Tip: Add nodes on canvas. Click "Add Edge" then pick source & target to create an edge.</div>
      <div style="font-size:12px;color:var(--muted)">Bellman-Ford: O(VE)</div>
    </div>
  </div>
</div>

<script>
/*
Bellman-Ford Visualizer
Author: Generated by AI assistant
Features:
- Add/move/delete nodes and edges
- Directed edges (optional undirected mode)
- Step through each edge relaxation, iterate, run to completion, and auto-animation
- Detect and highlight negative cycles
- Show distances and predecessors
*/

const svg = document.getElementById('svgCanvas');
const nodesLayer = document.getElementById('nodesLayer');
const edgesLayer = document.getElementById('edgesLayer');

let nodes = []; // {id, x, y}
let edges = []; // {id, from, to, w}
let nextNodeId = 0;
let nextEdgeId = 0;

let mode = 'select'; // 'select', 'addNode', 'addEdge', 'delete'
let addEdgeFrom = null;
let dragging = null;
let dragOffset = {x:0,y:0};
let undirectedCheckbox = document.getElementById('undirected');

const addNodeBtn = document.getElementById('addNodeBtn');
const addEdgeBtn = document.getElementById('addEdgeBtn');
const selectBtn = document.getElementById('selectBtn');
const delBtn = document.getElementById('delBtn');
const sourceSelect = document.getElementById('sourceSelect');
const sourceSelectSide = document.getElementById('sourceSelectSide');

const stepBtn = document.getElementById('stepBtn');
const iterBtn = document.getElementById('iterBtn');
const runBtn = document.getElementById('runBtn');
const autoBtn = document.getElementById('autoBtn');
const resetBtn = document.getElementById('resetBtn');
const clearBtn = document.getElementById('clearBtn');

const nodesList = document.getElementById('nodesList');
const edgesList = document.getElementById('edgesList');
const logDiv = document.getElementById('log');
const iterationDisplay = document.getElementById('iterationDisplay');
const edgeIndexDisplay = document.getElementById('edgeIndexDisplay');
const modeLabel = document.getElementById('modeLabel');
const markPathBtn = document.getElementById('markPathBtn');
const clearHighlightsBtn = document.getElementById('clearHighlights');

const preset1 = document.getElementById('preset1');
const preset2 = document.getElementById('preset2');

let state = {
  distances: {}, // id -> number (Infinity)
  pred: {}, // id -> predecessor id or null
  V: 0,
  E: 0,
  iter: 0,
  edgeIndex: 0,
  finished: true,
  negativeCycle: false,
  autoTimer: null,
  running: false,
};

function log(msg) {
  const d = new Date().toLocaleTimeString();
  logDiv.innerHTML = `<div>[${d}] ${escapeHtml(msg)}</div>` + logDiv.innerHTML;
}
function escapeHtml(s){ return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function setMode(m) {
  mode = m;
  addNodeBtn.classList.toggle('active', m==='addNode');
  addEdgeBtn.classList.toggle('active', m==='addEdge');
  selectBtn.classList.toggle('active', m==='select');
  delBtn.classList.toggle('active', m==='delete');
  modeLabel.textContent = m==='select' ? 'Select/Move' : m==='addNode' ? 'Add Node' : m==='addEdge' ? 'Add Edge' : 'Delete';
}

addNodeBtn.addEventListener('click', ()=>setMode('addNode'));
addEdgeBtn.addEventListener('click', ()=>setMode('addEdge'));
selectBtn.addEventListener('click', ()=>setMode('select'));
delBtn.addEventListener('click', ()=>setMode('delete'));

svg.addEventListener('mousedown', svgPointerDown);
svg.addEventListener('mousemove', svgPointerMove);
svg.addEventListener('mouseup', svgPointerUp);
svg.addEventListener('mouseleave', svgPointerUp);

function svgPoint(evt){
  const rect = svg.getBoundingClientRect();
  const x = evt.clientX - rect.left;
  const y = evt.clientY - rect.top;
  return {x, y};
}

function svgPointerDown(evt){
  const pt = svgPoint(evt);
  if (mode === 'addNode') {
    const id = addNode(pt.x, pt.y);
    render();
    updateLists();
    setMode('select');
    log(`Added node ${id}`);
  } else if (mode === 'select') {
    // check node hit
    const node = nodeAt(pt);
    if (node) {
      dragging = node.id;
      dragOffset.x = pt.x - node.x;
      dragOffset.y = pt.y - node.y;
    }
  } else if (mode === 'addEdge') {
    const node = nodeAt(pt);
    if (node) {
      if (!addEdgeFrom) {
        addEdgeFrom = node.id;
        modeLabel.textContent = 'Select target node for edge';
      } else {
        const to = node.id;
        const from = addEdgeFrom;
        const w = parseFloat(prompt(`Weight for edge ${from} → ${to} (can be negative):`, "0"));
        if (!Number.isFinite(w)) {
          alert('Invalid weight. Edge aborted.');
        } else {
          addEdge(from, to, w);
          if (undirectedCheckbox.checked) addEdge(to, from, w);
          log(`Added edge ${from} → ${to} (${w})`);
        }
        addEdgeFrom = null;
        setMode('select');
        render();
        updateLists();
      }
    }
  } else if (mode === 'delete') {
    const node = nodeAt(pt);
    if (node) {
      if (confirm(`Delete node ${node.id} and its edges?`)) {
        removeNode(node.id);
        render();
        updateLists();
        log(`Deleted node ${node.id}`);
      }
    } else {
      const e = edgeAt(pt);
      if (e) {
        if (confirm(`Delete edge ${e.from} → ${e.to} (w=${e.w})?`)) {
          removeEdge(e.id);
          render();
          updateLists();
          log(`Deleted edge ${e.id}`);
        }
      }
    }
  }
}

function svgPointerMove(evt){
  if (dragging !== null) {
    const pt = svgPoint(evt);
    const node = nodes.find(n=>n.id===dragging);
    if (node) {
      node.x = Math.max(24, Math.min(1176, pt.x - dragOffset.x + 24*0)); // clamp on canvas
      node.y = Math.max(24, Math.min(496, pt.y - dragOffset.y + 24*0));
      render();
      updateLists();
    }
  }
}
function svgPointerUp(evt){
  dragging = null;
}

function nodeAt(pt) {
  // nodes drawn as circle radius 22
  for (let i = nodes.length-1; i>=0; i--) {
    const n = nodes[i];
    const dx = pt.x - n.x;
    const dy = pt.y - n.y;
    if (dx*dx+dy*dy <= 22*22) return n;
  }
  return null;
}
function edgeAt(pt) {
  // approx: check distance to segment
  for (let i = edges.length-1; i>=0; i--) {
    const e = edges[i];
    const a = nodes.find(n=>n.id===e.from);
    const b = nodes.find(n=>n.id===e.to);
    if (!a || !b) continue;
    const d = pointToSegmentDistance(pt, a, b);
    if (d < 8) return e;
  }
  return null;
}
function pointToSegmentDistance(p, a, b) {
  const x = p.x, y = p.y;
  const x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;
  const A = x - x1, B = y - y1, C = x2 - x1, D = y2 - y1;
  const dot = A*C + B*D;
  const len_sq = C*C + D*D;
  let param = -1;
  if (len_sq !== 0) param = dot / len_sq;
  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param*C; yy = y1 + param*D; }
  const dx = x - xx, dy = y - yy;
  return Math.sqrt(dx*dx + dy*dy);
}

/* Graph modification functions */
function addNode(x, y) {
  const id = String(nextNodeId++);
  nodes.push({id, x, y});
  refreshSourceOptions();
  return id;
}
function removeNode(id) {
  nodes = nodes.filter(n => n.id !== id);
  edges = edges.filter(e => e.from !== id && e.to !== id);
  refreshSourceOptions();
}
function addEdge(from, to, w) {
  const id = String(nextEdgeId++);
  edges.push({id, from, to, w: Number(w)});
  return id;
}
function removeEdge(id) {
  edges = edges.filter(e => e.id !== id);
}

/* Rendering */
function render() {
  // clear
  nodesLayer.innerHTML = '';
  edgesLayer.innerHTML = '';

  // Draw edges first
  edges.forEach(e=>{
    const a = nodes.find(n=>n.id===e.from);
    const b = nodes.find(n=>n.id===e.to);
    if (!a || !b) return;
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const len = Math.sqrt(dx*dx + dy*dy) || 1;
    const ux = dx / len;
    const uy = dy / len;
    const r = 22;
    const startX = a.x + ux*r;
    const startY = a.y + uy*r;
    const endX = b.x - ux*r;
    const endY = b.y - uy*r;

    // line
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('data-edge-id', e.id);

    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', startX);
    line.setAttribute('y1', startY);
    line.setAttribute('x2', endX);
    line.setAttribute('y2', endY);
    line.setAttribute('stroke', 'var(--edge)');
    line.setAttribute('stroke-width', '2');
    line.setAttribute('marker-end', 'url(#arrow)');
    line.setAttribute('class','edge-line');
    g.appendChild(line);

    // weight label
    const mx = (startX + endX) / 2;
    const my = (startY + endY) / 2;
    const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
    txt.setAttribute('x', mx+6);
    txt.setAttribute('y', my-6);
    txt.setAttribute('fill', '#cbd5e1');
    txt.setAttribute('font-size', '12');
    txt.setAttribute('stroke', 'none');
    txt.textContent = e.w;
    g.appendChild(txt);

    // arrow for undirected small offset for self-loops etc not handled
    // click handler
    g.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      if (mode === 'delete') {
        if (confirm(`Delete edge ${e.from} → ${e.to} (w=${e.w})?`)) {
          removeEdge(e.id);
          render();
          updateLists();
          log(`Deleted edge ${e.id}`);
        }
      } else {
        // show properties
        const newW = prompt(`Edit weight for edge ${e.from} → ${e.to}:`, String(e.w));
        if (newW !== null) {
          const v = Number(newW);
          if (!Number.isFinite(v)) alert('Invalid weight.');
          else {
            e.w = v;
            render();
            updateLists();
            log(`Edge ${e.from} → ${e.to} weight set to ${v}`);
          }
        }
      }
    });

    edgesLayer.appendChild(g);
  });

  // Draw nodes
  nodes.forEach(n=>{
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    g.setAttribute('data-node-id', n.id);

    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('r','22');
    circle.setAttribute('fill','var(--node-fill)');
    circle.setAttribute('stroke','var(--node-stroke)');
    circle.setAttribute('stroke-width','2');
    g.appendChild(circle);

    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x','0');
    label.setAttribute('y','6');
    label.setAttribute('text-anchor','middle');
    label.setAttribute('fill','#001219');
    label.setAttribute('font-weight','700');
    label.setAttribute('font-size','13');
    label.textContent = n.id;
    g.appendChild(label);

    const distLabel = document.createElementNS('http://www.w3.org/2000/svg','text');
    distLabel.setAttribute('x','0');
    distLabel.setAttribute('y','26');
    distLabel.setAttribute('text-anchor','middle');
    distLabel.setAttribute('fill','#e6eef8');
    distLabel.setAttribute('font-size','11');
    distLabel.setAttribute('class','dist-label');
    const d = state.distances[n.id];
    distLabel.textContent = d === undefined ? '' : (d === Infinity ? '∞' : d);
    g.appendChild(distLabel);

    g.addEventListener('mousedown', (ev)=>{
      ev.stopPropagation();
      if (mode === 'addEdge') {
        if (!addEdgeFrom) {
          addEdgeFrom = n.id;
          modeLabel.textContent = 'Select target node for edge';
        } else {
          const to = n.id;
          const from = addEdgeFrom;
          const w = parseFloat(prompt(`Weight for edge ${from} → ${to} (can be negative):`, "0"));
          if (!Number.isFinite(w)) {
            alert('Invalid weight. Edge aborted.');
          } else {
            addEdge(from, to, w);
            if (undirectedCheckbox.checked) addEdge(to, from, w);
            log(`Added edge ${from} → ${to} (${w})`);
          }
          addEdgeFrom = null;
          setMode('select');
          render();
          updateLists();
        }
      } else if (mode === 'delete') {
        if (confirm(`Delete node ${n.id} and its edges?`)) {
          removeNode(n.id);
          render();
          updateLists();
          log(`Deleted node ${n.id}`);
        }
      } else {
        // select / drag
        dragging = n.id;
        const pt = svgPoint(ev);
        dragOffset.x = pt.x - n.x;
        dragOffset.y = pt.y - n.y;
      }
    });

    nodesLayer.appendChild(g);
  });

  // After drawing base, color edges according to algorithm state
  // Look for edges that have temporary classes in state (we'll set dataset)
  edgesLayer.querySelectorAll('g').forEach(g=>{
    const eid = g.getAttribute('data-edge-id');
    const e = edges.find(x=>x.id===eid);
    if (!e) return;
    const line = g.querySelector('line');
    // default
    line.setAttribute('stroke', 'var(--edge)');
    line.setAttribute('marker-end', 'url(#arrow)');
    // check if marked
    const info = e._info || {};
    if (info.type === 'checking') {
      line.setAttribute('stroke', 'var(--yellow)');
      line.setAttribute('marker-end', 'url(#arrow-yellow)');
      g.querySelector('text').setAttribute('fill', 'var(--yellow)');
    } else if (info.type === 'improved') {
      line.setAttribute('stroke', 'var(--good)');
      line.setAttribute('marker-end', 'url(#arrow-green)');
      g.querySelector('text').setAttribute('fill', 'var(--good)');
    } else if (info.type === 'neg') {
      line.setAttribute('stroke', 'var(--bad)');
      line.setAttribute('marker-end', 'url(#arrow-red)');
      g.querySelector('text').setAttribute('fill', 'var(--bad)');
    } else {
      g.querySelector('text').setAttribute('fill', '#cbd5e1');
    }
  });

  // highlight predecessor tree if asked
  if (state.treeHighlight) {
    const pred = state.pred || {};
    edgesLayer.querySelectorAll('g').forEach(g=>{
      const eid = g.getAttribute('data-edge-id');
      const e = edges.find(x=>x.id===eid);
      if (!e) return;
      if (pred[e.to] === e.from) {
        const line = g.querySelector('line');
        line.setAttribute('stroke', 'rgba(99,102,241,0.98)');
        line.setAttribute('stroke-width', '3');
        g.querySelector('text').setAttribute('fill', '#eef2ff');
      }
    });
  }
}

/* UI lists */
function updateLists() {
  // nodes dropdowns
  const sourceId = sourceSelect.value || (nodes[0] && nodes[0].id) || '';
  populateSourceOptions(sourceId);

  // nodes list
  nodesList.innerHTML = '';
  nodes.forEach(n=>{
    const el = document.createElement('div');
    el.className = 'row';
    el.innerHTML = `<div class="node-label"><strong>${n.id}</strong> <div class="small-muted">(${Math.round(n.x)},${Math.round(n.y)})</div></div>
      <div class="small-muted">d=${state.distances[n.id]===undefined? '—' : (state.distances[n.id]===Infinity ? '∞' : state.distances[n.id])}<span style="margin-left:8px;color:var(--muted)">pred=${state.pred[n.id]===undefined? '—': state.pred[n.id]}</span></div>`;
    nodesList.appendChild(el);
  });

  // edges list
  edgesList.innerHTML = '';
  edges.forEach(e=>{
    const el = document.createElement('div');
    el.className = 'row';
    el.innerHTML = `<div class="node-label"><strong>${e.from} → ${e.to}</strong><div class="small-muted">id:${e.id}</div></div>
      <div class="small-muted">w=${e.w}</div>`;
    edgesList.appendChild(el);
  });

  iterationDisplay.textContent = state.iter;
  edgeIndexDisplay.textContent = state.edgeIndex;
}

function populateSourceOptions(selectedId) {
  sourceSelect.innerHTML = '';
  sourceSelectSide.innerHTML = '';
  nodes.forEach(n=>{
    const opt = document.createElement('option'); opt.value = n.id; opt.textContent = n.id;
    sourceSelect.appendChild(opt);
    const opt2 = opt.cloneNode(true);
    sourceSelectSide.appendChild(opt2);
  });
  if (selectedId && Array.from(sourceSelect.options).some(o=>o.value===selectedId)) {
    sourceSelect.value = selectedId;
    sourceSelectSide.value = selectedId;
  } else {
    if (nodes[0]) {
      sourceSelect.value = nodes[0].id;
      sourceSelectSide.value = nodes[0].id;
    }
  }
}

function refreshSourceOptions() {
  populateSourceOptions(sourceSelect.value);
}

/* Bellman-Ford Implementation with step control */

function initAlgorithm() {
  state.V = nodes.length;
  state.E = edges.length;
  state.distances = {};
  state.pred = {};
  nodes.forEach(n=>{
    state.distances[n.id] = Infinity;
    state.pred[n.id] = null;
  });
  const src = sourceSelect.value || nodes[0] && nodes[0].id;
  if (!src) {
    alert('Please add nodes and select a source.');
    return false;
  }
  state.distances[src] = 0;
  state.iter = 1;
  state.edgeIndex = 0;
  state.finished = false;
  state.negativeCycle = false;
  state.running = false;
  state.treeHighlight = false;
  // clear edge info
  edges.forEach(e=> e._info = null);
  log(`Initialized. Source = ${src}`);
  render();
  updateLists();
  return true;
}

function stepOnce() {
  if (state.finished) {
    log('Algorithm already finished. Reset to run again.');
    return;
  }
  if (state.iter > Math.max(1, state.V-1)) {
    // After V-1 iterations, check for negative cycles
    const neg = detectNegativeCycleAfterRelaxations();
    if (neg) {
      state.negativeCycle = true;
      log('Negative cycle detected! Highlighted in red.');
      state.finished = true;
      render();
      updateLists();
      return;
    } else {
      log('No negative cycle detected. Algorithm complete.');
      state.finished = true;
      render();
      updateLists();
      return;
    }
  }
  if (edges.length === 0) {
    // nothing to relax
    state.iter++;
    if (state.iter > state.V-1) {
      state.finished = true;
      log('No edges to relax. Algorithm complete.');
    }
    render();
    updateLists();
    return;
  }
  const e = edges[state.edgeIndex];
  // mark checking
  edges.forEach(ed => ed._info = null);
  e._info = {type:'checking'};
  render();

  // relax
  const u = e.from, v = e.to, w = e.w;
  const du = state.distances[u];
  const dv = state.distances[v];
  if (du !== Infinity && du + w < dv) {
    state.distances[v] = du + w;
    state.pred[v] = u;
    e._info = {type:'improved'};
    log(`Relaxed edge ${u} → ${v}: updated d[${v}] from ${dv===Infinity?'∞':dv} to ${state.distances[v]}`);
  } else {
    log(`Checked edge ${u} → ${v}: no improvement.`);
  }

  // advance edgeIndex / iteration
  state.edgeIndex++;
  if (state.edgeIndex >= edges.length) {
    state.edgeIndex = 0;
    state.iter++;
  }
  render();
  updateLists();
}

function detectNegativeCycleAfterRelaxations() {
  // If any edge can be relaxed, there's a negative cycle reachable
  let found = false;
  let markerEdge = null;
  for (const e of edges) {
    const du = state.distances[e.from];
    if (du !== Infinity && du + e.w < state.distances[e.to]) {
      found = true;
      markerEdge = e;
      break;
    }
  }
  if (!found) {
    return false;
  }
  // Try to extract nodes in cycle: start from markerEdge.to and follow pred V times, then loop detection
  let v = markerEdge.to;
  for (let i=0;i<state.V;i++) {
    v = state.pred[v] || v;
  }
  // now traverse until we loop back to v
  const cycleNodes = new Set();
  let cur = v;
  do {
    cycleNodes.add(cur);
    cur = state.pred[cur] || cur;
    // avoid infinite fallback, break if too many steps
    if (cycleNodes.size > state.V) break;
  } while (cur !== v && cur !== null && cur !== undefined);

  // mark edges that are inside cycle (pred relationships)
  edges.forEach(e => e._info = null);
  edges.forEach(e=>{
    if (cycleNodes.has(e.from) && cycleNodes.has(e.to) && state.pred[e.to] === e.from) e._info = {type:'neg'};
  });
  // ensure marker edge shown red too
  const me = edges.find(e=>e.id===markerEdge.id);
  if (me) me._info = {type:'neg'};

  render();
  return true;
}

function iterateOnce() {
  // perform a full iteration over all edges
  if (state.finished) { log('Algorithm already finished. Reset to run again.'); return; }
  if (!initCheckSource()) return;
  for (let i=0;i<edges.length;i++) {
    const e = edges[i];
    // mark checking
    edges.forEach(ed => ed._info = null);
    e._info = {type:'checking'};
    render();
    // small delay simulation could be added, but here synchronous
    const u = e.from, v = e.to, w = e.w;
    const du = state.distances[u];
    if (du !== Infinity && du + w < state.distances[v]) {
      state.distances[v] = du + w;
      state.pred[v] = u;
      e._info = {type:'improved'};
      log(`Relaxed edge ${u} → ${v}: updated d[${v}] to ${state.distances[v]}`);
    } else {
      log(`Checked edge ${u} → ${v}: no improvement.`);
    }
  }
  state.iter++;
  if (state.iter > state.V-1) {
    // check negative cycle
    const neg = detectNegativeCycleAfterRelaxations();
    if (neg) {
      state.negativeCycle = true;
      state.finished = true;
      log('Negative cycle detected after iterations.');
    } else {
      state.finished = true;
      log('Completed all iterations. No negative cycle detected.');
    }
  } else {
    log(`Completed iteration ${state.iter-1}.`);
  }
  render();
  updateLists();
}

function initCheckSource() {
  if (Object.keys(state.distances).length === 0) {
    // hasn't been initialized
    return initAlgorithm();
  }
  return true;
}

stepBtn.addEventListener('click', ()=>{
  if (!initCheckSource()) return;
  stepOnce();
});

iterBtn.addEventListener('click', ()=>{
  if (!initCheckSource()) return;
  iterateOnce();
});

runBtn.addEventListener('click', ()=>{
  if (!initCheckSource()) return;
  // run to completion (synchronously, but we animate states)
  runToCompletion();
});

function runToCompletion() {
  if (state.finished) { log('Already finished.'); return; }
  runBtn.disabled = true;
  stepBtn.disabled = true;
  iterBtn.disabled = true;
  autoBtn.disabled = true;

  const maxSteps = (state.V - 1) * Math.max(1, edges.length) + edges.length + 5;
  let steps = 0;
  const timer = setInterval(()=>{
    if (state.finished || steps > maxSteps) {
      clearInterval(timer);
      runBtn.disabled = false;
      stepBtn.disabled = false;
      iterBtn.disabled = false;
      autoBtn.disabled = false;
      log('Run completed.');
      return;
    }
    stepOnce();
    steps++;
  }, 250);
}

let autoRunning = false;
autoBtn.addEventListener('click', ()=>{
  if (!initCheckSource()) return;
  if (!autoRunning) {
    autoRunning = true;
    autoBtn.textContent = 'Stop';
    state.autoTimer = setInterval(()=>{
      if (state.finished) {
        clearInterval(state.autoTimer);
        autoRunning = false;
        autoBtn.textContent = 'Auto';
        return;
      }
      stepOnce();
    }, 600);
  } else {
    autoRunning = false;
    autoBtn.textContent = 'Auto';
    clearInterval(state.autoTimer);
  }
});

resetBtn.addEventListener('click', ()=>{
  if (confirm('Reset algorithm state (keeps graph)?')) {
    state.distances = {};
    state.pred = {};
    state.iter = 0;
    state.edgeIndex = 0;
    state.finished = true;
    state.negativeCycle = false;
    edges.forEach(e=>e._info = null);
    state.treeHighlight = false;
    render();
    updateLists();
    log('Algorithm state reset.');
  }
});

markPathBtn.addEventListener('click', ()=>{
  state.treeHighlight = !state.treeHighlight;
  render();
});
clearHighlightsBtn.addEventListener('click', ()=>{
  state.treeHighlight = false;
  edges.forEach(e=>e._info = null);
  render();
});

/* Negative cycle detection on run (helper already implemented) */

/* Utility: find nodes/edges by id */
function getNode(id){ return nodes.find(n=>n.id===id); }
function getEdge(id){ return edges.find(e=>e.id===id); }

/* Presets */
preset1.addEventListener('click', ()=>{
  clearGraph();
  // Create sample graph (no negative cycle)
  addNode(140, 120); //0
  addNode(420, 80); //1
  addNode(720, 120); //2
  addNode(240, 320); //3
  addNode(540, 320); //4
  addEdge('0','1',6);
  addEdge('0','3',7);
  addEdge('1','2',5);
  addEdge('1','3',8);
  addEdge('1','4', -4);
  addEdge('2','1', -2);
  addEdge('3','2', -3);
  addEdge('3','4',9);
  addEdge('4','2',7);
  nextNodeId = nodes.length;
  nextEdgeId = edges.length;
  refreshSourceOptions();
  render();
  updateLists();
  log('Loaded Example 1.');
});

preset2.addEventListener('click', ()=>{
  clearGraph();
  // negative cycle example
  addNode(160, 120); //0
  addNode(460, 120); //1
  addNode(760, 120); //2
  addEdge('0','1',1);
  addEdge('1','2', -1);
  addEdge('2','1', -3); // creates negative cycle between 1 and 2
  refreshSourceOptions();
  render();
  updateLists();
  log('Loaded Negative Cycle example.');
});

clearBtn.addEventListener('click', ()=>{
  if (confirm('Clear entire graph?')) {
    clearGraph();
    render();
    updateLists();
    log('Graph cleared.');
  }
});

function clearGraph() {
  nodes = [];
  edges = [];
  nextNodeId = 0;
  nextEdgeId = 0;
  state = {
    distances: {},
    pred: {},
    V:0, E:0, iter:0, edgeIndex:0, finished:true, negativeCycle:false, autoTimer:null, running:false, treeHighlight:false
  };
  refreshSourceOptions();
}

/* Helpers for running detection */
function detectNegativeCycle() {
  // not used directly
  return detectNegativeCycleAfterRelaxations();
}

/* Initialization on load */
(function init(){
  // add a tiny demo graph
  addNode(140, 120);
  addNode(320, 90);
  addNode(500, 140);
  addNode(260, 300);
  addEdge('0','1',5);
  addEdge('0','3',2);
  addEdge('1','2',-3);
  addEdge('2','3',1);
  refreshSourceOptions();
  render();
  updateLists();
  log('Welcome! Use "Add Node" (click) and "Add Edge" (click nodes) to build a graph. Then pick a source and Step/Run.');
})();

/* Utility to find negative cycle nodes (used above) implemented earlier */

/* Small extra: keep source selection synchronized */
sourceSelect.addEventListener('change', ()=>{
  sourceSelectSide.value = sourceSelect.value;
});
sourceSelectSide.addEventListener('change', ()=>{
  sourceSelect.value = sourceSelectSide.value;
});

/* Escape: reset addEdgeFrom when clicking background */
svg.addEventListener('click', (ev)=>{
  if (mode === 'addEdge' && addEdgeFrom) {
    // clicking empty space cancels
    addEdgeFrom = null;
    setMode('select');
  }
});

/* Keyboard shortcuts */
window.addEventListener('keydown', (ev)=>{
  if (ev.key === 'n') setMode('addNode');
  if (ev.key === 'e') setMode('addEdge');
  if (ev.key === 's') setMode('select');
  if (ev.key === 'Delete') setMode('delete');
});

/* End of script */
</script>
</body>
</html>