<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Priority Queue (Binary Heap) Visualizer</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#06b6d4;
    --muted:#94a3b8;
    --glass: rgba(255,255,255,0.03);
    --card:#071028;
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{background:linear-gradient(180deg,#031026 0%, #071426 60%);color:#e6eef6;padding:18px;box-sizing:border-box;}
  .wrap{max-width:1100px;margin:0 auto;display:grid;grid-template-columns:360px 1fr;gap:18px;}
  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.03);
    padding:14px;border-radius:10px;box-shadow: 0 6px 18px rgba(2,6,23,0.6);
  }
  h1{font-size:18px;margin:0 0 10px;color:var(--accent);}
  label{display:block;color:var(--muted);font-size:13px;margin-top:12px;}
  .row{display:flex;gap:8px;align-items:center;margin-top:8px;}
  input[type="text"], input[type="number"], select{
    background:var(--glass);border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:6px;color:#e6eef6;outline:none;width:100%;
  }
  button{
    background:linear-gradient(90deg,var(--accent),#8b5cf6);
    border:none;color:#021124;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer;
  }
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);}
  .small{padding:6px 8px;font-size:13px}
  .controls{display:flex;flex-direction:column;gap:8px;}
  .stats{display:flex;gap:8px;align-items:center;margin-top:10px;}
  .badge{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:999px;color:var(--muted);font-weight:600;}
  .view{display:flex;flex-direction:column;gap:12px;}
  .heap-area{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);padding:12px;border-radius:10px;min-height:340px;position:relative;overflow:auto;}
  .array-view{display:flex;gap:8px;flex-wrap:wrap;align-items:center;padding:10px;background:linear-gradient(90deg, rgba(255,255,255,0.015), transparent);border-radius:8px;}
  .cell{min-width:72px;padding:8px;border-radius:8px;background:linear-gradient(180deg,#062132,#0b2a3f);border:1px solid rgba(255,255,255,0.03);color:#dff6fb;font-weight:700;display:flex;flex-direction:column;align-items:center;justify-content:center;}
  .cell .val{font-size:14px}
  .cell .pri{font-size:12px;color:var(--muted);margin-top:4px}
  .tree-wrap{position:relative;padding:24px 8px 40px;}
  .level{display:grid;grid-auto-flow:column;gap:10px;justify-items:center;align-items:start;margin:6px 0}
  .node{width:86px;height:52px;border-radius:10px;background:linear-gradient(180deg,#08303f,#063046);display:flex;flex-direction:column;align-items:center;justify-content:center;color:#dff6fb;border:1px solid rgba(255,255,255,0.035)}
  .node .nv{font-weight:700}
  svg.connector{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;overflow:visible}
  .log{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;height:120px;overflow:auto;color:var(--muted);font-size:13px}
  .footer{display:flex;justify-content:space-between;align-items:center;margin-top:8px;color:var(--muted);font-size:13px}
  .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .muted{color:var(--muted);font-size:13px}
  .speed{display:flex;gap:8px;align-items:center}
  input[type="range"]{width:120px}
  .help{font-size:13px;color:var(--muted);margin-top:10px}
  @media (max-width:900px){
    .wrap{grid-template-columns:1fr; max-width:760px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h1>Priority Queue — Binary Heap</h1>
    <div class="controls">
      <label>Mode</label>
      <select id="mode">
        <option value="min">Min-Heap (smallest priority first)</option>
        <option value="max">Max-Heap (largest priority first)</option>
      </select>

      <label>Insert item</label>
      <div class="row">
        <input id="val" type="text" placeholder="Value (string)" />
        <input id="pri" type="number" placeholder="Priority (number)" />
        <button id="enqueue" class="small">Enqueue</button>
      </div>

      <div class="controls-grid">
        <button id="dequeue" class="small">Dequeue</button>
        <button id="peek" class="small ghost">Peek</button>
        <button id="clear" class="small ghost">Clear</button>
        <button id="random" class="small">Insert Random</button>
      </div>

      <label>Find / Modify</label>
      <div class="row">
        <input id="findVal" type="text" placeholder="Value to find" />
        <input id="newPri" type="number" placeholder="New priority" />
        <button id="changePri" class="small">Change Priority</button>
      </div>
      <div class="row">
        <button id="remove" class="small ghost">Remove by Value</button>
        <button id="bulk" class="small">Bulk Random (10)</button>
      </div>

      <label>Animation speed</label>
      <div class="row speed">
        <input id="speed" type="range" min="50" max="1000" value="300">
        <div class="muted" id="speedVal">300ms</div>
      </div>

      <div class="stats">
        <div class="badge">Size: <span id="size">0</span></div>
        <div class="badge">Root: <span id="root">—</span></div>
      </div>

      <div class="help">
        This visualizer uses a binary heap array. Each node displays value and priority.
        Operations animate the swaps that occur during bubble-up / bubble-down.
      </div>
    </div>
  </div>

  <div class="panel view">
    <div class="heap-area">
      <div class="array-view" id="arrayView" aria-live="polite"></div>
      <div class="tree-wrap" id="treeWrap"></div>
      <svg class="connector" id="connector"></svg>
    </div>

    <div style="display:flex;gap:12px">
      <div style="flex:1">
        <div class="log" id="log"></div>
      </div>
      <div style="width:180px">
        <div class="footer">
          <div class="muted">Implementation</div>
        </div>
        <div style="margin-top:8px">
          <div class="muted">Binary heap stored in array (0-based). Comparator depends on mode.</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/*
 Priority Queue (Binary Heap) visualizer
 - Supports min and max heap
 - Items: {value: string, priority: number}
 - Animations use recorded swap sequences
*/

class PriorityQueue {
  constructor(comparator){
    this.data = [];
    this.compare = comparator; // returns true if a has higher priority than b
  }

  size(){ return this.data.length; }
  isEmpty(){ return this.data.length === 0; }

  peek(){ return this.data[0] ?? null; }

  // Enqueue with recording of swaps: returns array of swap pairs (i,j) in order
  enqueue(item){
    const steps = [];
    this.data.push(item);
    let i = this.data.length - 1;
    while(i > 0){
      const p = Math.floor((i-1)/2);
      if (this.compare(this.data[i], this.data[p])){
        steps.push([i,p]);
        this.swap(i,p);
        i = p;
      } else break;
    }
    return steps;
  }

  // Dequeue root, returns {item, steps}
  dequeue(){
    if(this.isEmpty()) return {item:null, steps:[]};
    const steps = [];
    const root = this.data[0];
    if(this.data.length === 1){
      this.data.pop();
      return {item:root, steps};
    }
    // move last to root then sink
    this.data[0] = this.data.pop();
    let i = 0;
    while(true){
      const l = 2*i + 1;
      const r = 2*i + 2;
      let best = i;
      if(l < this.data.length && this.compare(this.data[l], this.data[best])) best = l;
      if(r < this.data.length && this.compare(this.data[r], this.data[best])) best = r;
      if(best !== i){
        steps.push([i,best]);
        this.swap(i,best);
        i = best;
      } else break;
    }
    return {item:root, steps};
  }

  // Find index of first item by value
  findIndexByValue(value){
    for(let i=0;i<this.data.length;i++){
      if(this.data[i].value === value) return i;
    }
    return -1;
  }

  // Change priority of first matching value and reheapify; returns steps (may include up and down)
  changePriority(value, newPriority){
    const i = this.findIndexByValue(value);
    if(i === -1) return {ok:false, steps:[]};
    const old = this.data[i].priority;
    this.data[i].priority = newPriority;
    const steps = [];
    // if new is higher priority relative to comparator, bubble up; otherwise sink
    // We'll attempt both: bubble up first, then sink. Record swaps.
    let idx = i;
    while(idx > 0){
      const p = Math.floor((idx-1)/2);
      if(this.compare(this.data[idx], this.data[p])){
        steps.push([idx,p]);
        this.swap(idx,p);
        idx = p;
      } else break;
    }
    if(idx === i){ // did not move up, try sink
      idx = i;
      while(true){
        const l = 2*idx + 1;
        const r = 2*idx + 2;
        let best = idx;
        if(l < this.data.length && this.compare(this.data[l], this.data[best])) best = l;
        if(r < this.data.length && this.compare(this.data[r], this.data[best])) best = r;
        if(best !== idx){
          steps.push([idx,best]);
          this.swap(idx,best);
          idx = best;
        } else break;
      }
    }
    return {ok:true, steps};
  }

  removeByValue(value){
    const i = this.findIndexByValue(value);
    if(i === -1) return {ok:false, steps:[]};
    const last = this.data.pop();
    const steps = [];
    if(i < this.data.length){
      this.data[i] = last;
      // try reheapify
      let idx = i;
      while(idx > 0){
        const p = Math.floor((idx-1)/2);
        if(this.compare(this.data[idx], this.data[p])){
          steps.push([idx,p]);
          this.swap(idx,p);
          idx = p;
        } else break;
      }
      if(idx === i){
        while(true){
          const l = 2*idx + 1;
          const r = 2*idx + 2;
          let best = idx;
          if(l < this.data.length && this.compare(this.data[l], this.data[best])) best = l;
          if(r < this.data.length && this.compare(this.data[r], this.data[best])) best = r;
          if(best !== idx){
            steps.push([idx,best]);
            this.swap(idx,best);
            idx = best;
          } else break;
        }
      }
    }
    return {ok:true, steps};
  }

  clear(){ this.data = []; }

  swap(i,j){
    const t = this.data[i]; this.data[i] = this.data[j]; this.data[j] = t;
  }

  toArray(){ return this.data.slice(); }
}

/* ---- UI and Visualization ---- */

const arrayView = document.getElementById('arrayView');
const treeWrap = document.getElementById('treeWrap');
const connector = document.getElementById('connector');
const logEl = document.getElementById('log');
const sizeEl = document.getElementById('size');
const rootEl = document.getElementById('root');

const modeEl = document.getElementById('mode');
const valEl = document.getElementById('val');
const priEl = document.getElementById('pri');
const enqueueBtn = document.getElementById('enqueue');
const dequeueBtn = document.getElementById('dequeue');
const peekBtn = document.getElementById('peek');
const clearBtn = document.getElementById('clear');
const randomBtn = document.getElementById('random');
const bulkBtn = document.getElementById('bulk');
const findValEl = document.getElementById('findVal');
const newPriEl = document.getElementById('newPri');
const changeBtn = document.getElementById('changePri');
const removeBtn = document.getElementById('remove');
const speedEl = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');

let pq = null;
let animating = false;

function makeComparator(mode){
  if(mode === 'min'){
    return (a,b) => a.priority < b.priority;
  } else {
    return (a,b) => a.priority > b.priority;
  }
}

function initPQ(){
  pq = new PriorityQueue(makeComparator(modeEl.value));
  renderAll();
  log('Initialized ' + (modeEl.value === 'min' ? 'min-heap' : 'max-heap'));
}
initPQ();

modeEl.addEventListener('change', ()=>{
  initPQ();
});

function log(msg){
  const time = new Date().toLocaleTimeString();
  logEl.innerHTML = `<div style="margin-bottom:6px">[${time}] ${escapeHtml(msg)}</div>` + logEl.innerHTML;
}

function escapeHtml(s){
  return (''+s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function updateStats(){
  sizeEl.textContent = pq.size();
  rootEl.textContent = pq.peek() ? `${pq.peek().value} (${pq.peek().priority})` : '—';
}

function renderArray(highlight = []){
  arrayView.innerHTML = '';
  pq.toArray().forEach((item, idx) => {
    const c = document.createElement('div');
    c.className = 'cell';
    if(highlight.includes(idx)){
      c.style.boxShadow = '0 6px 20px rgba(6,182,212,0.12), 0 0 0 3px rgba(6,182,212,0.06) inset';
      c.style.transform = 'translateY(-4px)';
    }
    const v = document.createElement('div'); v.className='val'; v.textContent = item.value;
    const p = document.createElement('div'); p.className='pri'; p.textContent = 'pri: '+item.priority;
    c.appendChild(v); c.appendChild(p);
    arrayView.appendChild(c);
  });
  if(pq.size()===0){
    const emp = document.createElement('div'); emp.className='muted'; emp.textContent='(heap is empty)';
    arrayView.appendChild(emp);
  }
}

function buildTreeNodes(){
  treeWrap.innerHTML = '';
  const arr = pq.toArray();
  if(arr.length === 0) return;
  // Compute levels
  let level = 0;
  let index = 0;
  const nodes = [];
  while(index < arr.length){
    const count = Math.min(2**level, arr.length - index);
    const levelDiv = document.createElement('div');
    levelDiv.className = 'level';
    levelDiv.style.gridTemplateColumns = `repeat(${count}, 1fr)`;
    // create placeholders to keep spacing when level isn't full? We'll just create exactly count nodes.
    for(let i=0;i<count;i++){
      const node = document.createElement('div');
      node.className = 'node';
      node.dataset.index = index;
      node.innerHTML = `<div class="nv">${escapeHtml(arr[index].value)}</div><div class="pri" style="font-size:12px;color:var(--muted);margin-top:6px">${arr[index].priority}</div>`;
      levelDiv.appendChild(node);
      nodes.push(node);
      index++;
    }
    treeWrap.appendChild(levelDiv);
    level++;
  }
  return nodes;
}

function drawConnectors(nodes){
  // Clear
  while (connector.firstChild) connector.removeChild(connector.firstChild);
  if(!nodes || nodes.length===0) return;
  // Compute bbox positions for each node
  const positions = nodes.map(n => {
    const r = n.getBoundingClientRect();
    const parentR = treeWrap.getBoundingClientRect();
    return {
      x: r.left - parentR.left + r.width/2,
      y: r.top - parentR.top + r.height/2
    };
  });
  // Draw lines parent->child for binary heap (i => 2i+1 and 2i+2 if exist)
  const svgNS = "http://www.w3.org/2000/svg";
  for(let i=0;i<nodes.length;i++){
    const left = 2*i + 1;
    const right = 2*i + 2;
    if(left < nodes.length){
      const p = positions[i], c = positions[left];
      const line = document.createElementNS(svgNS, 'line');
      line.setAttribute('x1', p.x); line.setAttribute('y1', p.y + 22);
      line.setAttribute('x2', c.x); line.setAttribute('y2', c.y - 22);
      line.setAttribute('stroke', 'rgba(255,255,255,0.06)');
      line.setAttribute('stroke-width', 1.5);
      connector.appendChild(line);
    }
    if(right < nodes.length){
      const p = positions[i], c = positions[right];
      const line = document.createElementNS(svgNS, 'line');
      line.setAttribute('x1', p.x); line.setAttribute('y1', p.y + 22);
      line.setAttribute('x2', c.x); line.setAttribute('y2', c.y - 22);
      line.setAttribute('stroke', 'rgba(255,255,255,0.06)');
      line.setAttribute('stroke-width', 1.5);
      connector.appendChild(line);
    }
  }
}

function renderAll(highlight=[]){
  updateStats();
  renderArray(highlight);
  // small delay to allow DOM placement then build tree and draw connectors
  setTimeout(()=>{
    const nodes = buildTreeNodes();
    setTimeout(()=>drawConnectors(nodes), 10);
  }, 10);
}

/* Animation runner: given steps list of [i,j] swaps, animate them sequentially */
function animateSwaps(steps, finalCallback){
  if(!steps || steps.length===0){
    renderAll();
    if(finalCallback) finalCallback();
    return;
  }
  animating = true;
  const speed = Number(speedEl.value);
  let i = 0;
  const doStep = () => {
    if(i >= steps.length){
      animating = false;
      renderAll();
      if(finalCallback) finalCallback();
      return;
    }
    const [a,b] = steps[i];
    // Highlight positions a and b, then swap in the underlying pq.data is already swapped in our implementation
    renderAll([a,b]);
    i++;
    setTimeout(doStep, speed);
  };
  // render starting state (first swap already applied in pq methods), show highlights
  renderAll([steps[0][0], steps[0][1]]);
  setTimeout(doStep, speed);
}

/* ---- Button handlers ---- */

enqueueBtn.addEventListener('click', ()=>{
  if(animating) return;
  const v = valEl.value.trim() || ('item'+Math.floor(Math.random()*1000));
  const p = Number(priEl.value);
  if(isNaN(p)) { log('Priority must be a number'); return; }
  const steps = pq.enqueue({value:v, priority:p});
  log(`Enqueued "${v}" with priority ${p}`);
  animateSwaps(steps, ()=>{ renderAll(); });
  valEl.value=''; priEl.value='';
});

dequeueBtn.addEventListener('click', ()=>{
  if(animating) return;
  if(pq.isEmpty()){ log('Cannot dequeue — queue is empty'); return; }
  const res = pq.dequeue();
  log(`Dequeued "${res.item.value}" (priority ${res.item.priority})`);
  animateSwaps(res.steps, ()=>{ renderAll(); });
});

peekBtn.addEventListener('click', ()=>{
  const top = pq.peek();
  if(!top) log('Peek → empty');
  else log(`Peek → "${top.value}" (priority ${top.priority})`);
});

clearBtn.addEventListener('click', ()=>{
  if(animating) return;
  pq.clear();
  renderAll();
  log('Cleared heap');
});

randomBtn.addEventListener('click', ()=>{
  if(animating) return;
  const v = 'v'+Math.floor(Math.random()*999);
  const p = Math.floor(Math.random()*100);
  const steps = pq.enqueue({value:v, priority:p});
  log(`Enqueued random "${v}" (${p})`);
  animateSwaps(steps, ()=>renderAll());
});

bulkBtn.addEventListener('click', ()=>{
  if(animating) return;
  // Insert 10 random items without animation one by one but then animate a short flash
  const bulkItems = [];
  for(let i=0;i<10;i++){
    const v = 'v'+Math.floor(Math.random()*9999);
    const p = Math.floor(Math.random()*100);
    const steps = pq.enqueue({value:v, priority:p});
    bulkItems.push({v,p,steps});
  }
  log(`Bulk inserted 10 items`);
  // show final structure
  renderAll();
  // Flash last inserted nodes
  const lastSteps = bulkItems.length ? bulkItems[bulkItems.length-1].steps : [];
  animateSwaps(lastSteps, ()=>renderAll());
});

changeBtn.addEventListener('click', ()=>{
  if(animating) return;
  const val = findValEl.value.trim();
  const newPri = Number(newPriEl.value);
  if(!val){ log('Provide a value to find'); return; }
  if(isNaN(newPri)){ log('New priority must be a number'); return; }
  const res = pq.changePriority(val, newPri);
  if(!res.ok){ log(`Value "${val}" not found`); return; }
  log(`Changed priority of "${val}" → ${newPri}`);
  animateSwaps(res.steps, ()=>renderAll());
});

removeBtn.addEventListener('click', ()=>{
  if(animating) return;
  const val = findValEl.value.trim();
  if(!val){ log('Provide a value to remove'); return; }
  const res = pq.removeByValue(val);
  if(!res.ok){ log(`Value "${val}" not found`); return; }
  log(`Removed "${val}"`);
  animateSwaps(res.steps, ()=>renderAll());
});

speedEl.addEventListener('input', ()=>{
  speedVal.textContent = speedEl.value+'ms';
});

/* Allow clicking array items to prefill find field */
arrayView.addEventListener('click', (e)=>{
  const cell = e.target.closest('.cell');
  if(!cell) return;
  const idx = Array.from(arrayView.children).indexOf(cell);
  if(idx >= 0){
    const item = pq.toArray()[idx];
    if(item){
      findValEl.value = item.value;
      newPriEl.value = item.priority;
      log(`Selected "${item.value}" from array (priority ${item.priority})`);
    }
  }
});

// Initial render
renderAll();
log('Priority Queue visualizer ready — try inserting items.');

/* Accessibility: keyboard shortcuts */
document.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter' && document.activeElement === priEl){
    enqueueBtn.click();
  }
});

</script>
</body>
</html>