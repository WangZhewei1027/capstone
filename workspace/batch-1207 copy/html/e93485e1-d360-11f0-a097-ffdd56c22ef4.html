<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Knapsack Problem — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", Arial; margin: 18px; color: #111; }
    h1 { margin-top: 0 }
    .container { display: flex; gap: 18px; align-items: flex-start; flex-wrap: wrap; }
    .panel { background: #fff; border: 1px solid #ddd; padding: 12px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.04); min-width: 300px; }
    label { display: block; margin-top: 8px; font-size: 13px; color: #333; }
    input[type="number"], input[type="text"] { width: 100%; box-sizing: border-box; padding: 6px 8px; margin-top: 6px; border-radius: 6px; border: 1px solid #ccc; }
    button { margin-top: 10px; padding: 8px 12px; border-radius: 6px; border: 1px solid #2b6cb0; background: linear-gradient(#2b6cb0, #205a9a); color: white; cursor: pointer; }
    button.secondary { background: #f4f6fb; color: #0b3b66; border: 1px solid #cdd9ea; }
    button.danger { background: linear-gradient(#f97373,#ef4444); border-color: #e11d48; }
    .items-list { margin-top: 8px; border-top: 1px dashed #e6eef8; padding-top: 8px; }
    .item { display:flex; gap: 8px; align-items:center; margin-bottom:8px; }
    .item input { width: auto; }
    .small { font-size: 13px; color: #444; }
    table { border-collapse: collapse; width: 100%; margin-top: 8px; }
    th, td { border: 1px solid #e7eef8; padding: 6px 8px; text-align: center; font-family: monospace; }
    th { background: #f7fbff; }
    .selected { background: linear-gradient(90deg, rgba(197,237,255,0.8), rgba(220,248,255,0.6)); }
    .highlight { background: #fff8dc; }
    .ratio { color: #0b3b66; font-weight: 600; }
    .result { margin-top: 12px; padding: 10px; background:#f7fdfa; border:1px solid #e3f7ec; border-radius:6px; }
    .note { margin-top: 10px; font-size: 13px; color: #444; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .small-btn { padding:6px 8px; font-size:13px; border-radius:6px; }
    .footer { margin-top: 16px; font-size: 12px; color: #666; }
  </style>
</head>
<body>
  <h1>Knapsack Problem — Interactive Demo</h1>
  <div class="container">
    <div class="panel" style="flex:1 1 360px; max-width:420px;">
      <h3>Items</h3>
      <div class="small">Add items with a weight (positive integer) and a value (number). Names optional.</div>
      <div style="margin-top:8px;">
        <label>Name <input id="itemName" type="text" placeholder="Item A"></label>
        <label>Weight <input id="itemWeight" type="number" min="1" value="3"></label>
        <label>Value <input id="itemValue" type="number" min="0" value="4"></label>
        <div class="controls">
          <button id="addItemBtn">Add item</button>
          <button id="randomBtn" class="secondary small-btn">Generate random set</button>
          <button id="clearBtn" class="danger small-btn">Clear all</button>
        </div>
      </div>

      <div class="items-list" id="itemsList"></div>

      <label style="margin-top:10px">Knapsack Capacity <input id="capacityInput" type="number" min="0" value="7"></label>

      <label style="margin-top:8px">Choose algorithm</label>
      <div class="controls">
        <button id="runDpBtn" class="small-btn">0/1 Knapsack (DP)</button>
        <button id="runFracBtn" class="small-btn secondary">Fractional Knapsack (Greedy)</button>
        <button id="animateDpBtn" class="small-btn">Animate DP table</button>
      </div>

      <div class="note">
        - 0/1 Knapsack: items are indivisible (each item taken at most once). Uses dynamic programming, exact solution for integer weights.<br>
        - Fractional Knapsack: allows taking fractions of items; solved by greedy ratio (value/weight).
      </div>
    </div>

    <div class="panel" style="flex:2 1 520px; min-width:320px;">
      <h3>Output & Visualization</h3>
      <div id="outputArea">
        <div class="small">Run an algorithm to see results here.</div>
      </div>
      <div id="dpTableContainer" style="overflow:auto; margin-top:12px;"></div>
      <div id="fracTableContainer" style="overflow:auto; margin-top:12px;"></div>
    </div>
  </div>

  <div class="footer">
    Complexity: 0/1 DP O(n * W) time and O(n * W) memory (W = capacity). Fractional greedy O(n log n) due to sorting.
  </div>

  <script>
    // State
    let items = [
      {name:'A', w:3, v:4},
      {name:'B', w:4, v:5},
      {name:'C', w:2, v:3}
    ];

    // DOM
    const itemsList = document.getElementById('itemsList');
    const itemName = document.getElementById('itemName');
    const itemWeight = document.getElementById('itemWeight');
    const itemValue = document.getElementById('itemValue');
    const addItemBtn = document.getElementById('addItemBtn');
    const randomBtn = document.getElementById('randomBtn');
    const clearBtn = document.getElementById('clearBtn');
    const capacityInput = document.getElementById('capacityInput');
    const runDpBtn = document.getElementById('runDpBtn');
    const runFracBtn = document.getElementById('runFracBtn');
    const animateDpBtn = document.getElementById('animateDpBtn');
    const outputArea = document.getElementById('outputArea');
    const dpTableContainer = document.getElementById('dpTableContainer');
    const fracTableContainer = document.getElementById('fracTableContainer');

    // Helpers
    function renderItems() {
      itemsList.innerHTML = '';
      items.forEach((it, idx) => {
        const el = document.createElement('div');
        el.className = 'item';
        el.innerHTML = `
          <div style="width:38px; font-weight:600">${it.name || ('#'+(idx+1))}</div>
          <div class="small" style="flex:1">weight: <strong>${it.w}</strong>, value: <strong>${it.v}</strong></div>
          <div>
            <button class="small-btn secondary" data-idx="${idx}">Edit</button>
            <button class="small-btn danger" data-del="${idx}">Del</button>
          </div>
        `;
        itemsList.appendChild(el);
      });
      // attach handlers
      itemsList.querySelectorAll('button[data-idx]').forEach(b=>{
        b.onclick = () => {
          const i = +b.getAttribute('data-idx');
          const it = items[i];
          const newName = prompt('Name', it.name);
          if (newName === null) return;
          const newW = parseInt(prompt('Weight (positive integer)', it.w), 10);
          if (!Number.isInteger(newW) || newW <= 0) { alert('Invalid weight'); return; }
          const newV = Number(prompt('Value (number)', it.v));
          if (isNaN(newV)) { alert('Invalid value'); return; }
          items[i] = {name: newName, w: newW, v: newV};
          renderItems();
        };
      });
      itemsList.querySelectorAll('button[data-del]').forEach(b=>{
        b.onclick = () => {
          const i = +b.getAttribute('data-del');
          items.splice(i,1);
          renderItems();
        };
      });
    }

    addItemBtn.onclick = () => {
      const name = itemName.value.trim() || null;
      const w = parseInt(itemWeight.value, 10);
      const v = Number(itemValue.value);
      if (!Number.isInteger(w) || w <= 0) { alert('Weight must be a positive integer.'); return; }
      if (isNaN(v)) { alert('Value must be a number.'); return; }
      items.push({name, w, v});
      itemName.value = '';
      itemWeight.value = 1;
      itemValue.value = 0;
      renderItems();
    };

    randomBtn.onclick = () => {
      items = [];
      const n = Math.floor(Math.random()*6) + 4; // 4..9 items
      for (let i=0;i<n;i++){
        const w = Math.floor(Math.random()*10) + 1;
        const v = Math.floor(Math.random()*20) + 1;
        items.push({name: String.fromCharCode(65+i), w, v});
      }
      const cap = Math.floor((items.reduce((s,it)=>s+it.w,0)) * (0.35 + Math.random()*0.45));
      capacityInput.value = Math.max(1, cap);
      renderItems();
    };

    clearBtn.onclick = () => {
      if (!confirm('Clear all items?')) return;
      items = [];
      renderItems();
      outputArea.innerHTML = '<div class="small">Cleared.</div>';
      dpTableContainer.innerHTML = '';
      fracTableContainer.innerHTML = '';
    };

    // 0/1 Knapsack DP (integer weights)
    function knapsackDP(items, capacity) {
      const n = items.length;
      const W = capacity;
      // dp[i][w] = max value using first i items (i from 0..n), capacity w (0..W)
      const dp = Array.from({length: n+1}, ()=> new Array(W+1).fill(0));
      for (let i=1;i<=n;i++){
        const wi = items[i-1].w;
        const vi = items[i-1].v;
        for (let w=0; w<=W; w++){
          if (wi > w) dp[i][w] = dp[i-1][w];
          else dp[i][w] = Math.max(dp[i-1][w], dp[i-1][w-wi] + vi);
        }
      }
      // reconstruct chosen items
      let w = W;
      const chosen = [];
      for (let i=n; i>0; i--){
        if (dp[i][w] !== dp[i-1][w]) {
          chosen.push(i-1);
          w -= items[i-1].w;
        }
      }
      chosen.reverse();
      return {value: dp[n][W], chosen, dp};
    }

    // Fractional knapsack greedy
    function fractionalKnapsack(items, capacity) {
      const W = capacity;
      const arr = items.map((it, i) => ({...it, idx:i, ratio: it.v / it.w}));
      arr.sort((a,b) => b.ratio - a.ratio);
      let remaining = W;
      let totalValue = 0;
      const result = [];
      for (const it of arr) {
        if (remaining <= 0) break;
        if (it.w <= remaining) {
          result.push({idx: it.idx, take: 1, value: it.v, weight: it.w, ratio: it.ratio});
          remaining -= it.w;
          totalValue += it.v;
        } else {
          const frac = remaining / it.w;
          result.push({idx: it.idx, take: frac, value: it.v * frac, weight: remaining, ratio: it.ratio});
          totalValue += it.v * frac;
          remaining = 0;
        }
      }
      return {value: totalValue, selection: result};
    }

    function renderDPResult(res, items, capacity) {
      outputArea.innerHTML = '';
      dpTableContainer.innerHTML = '';
      fracTableContainer.innerHTML = '';

      const selNames = res.chosen.map(i => items[i].name || ('#'+(i+1)));
      const out = document.createElement('div');
      out.innerHTML = `
        <div class="result">
          <div><strong>Optimal total value:</strong> ${res.value}</div>
          <div style="margin-top:6px"><strong>Items selected (${res.chosen.length}):</strong> ${selNames.length ? selNames.join(', ') : '(none)'}</div>
          <div class="small" style="margin-top:6px">Capacity used: ${res.chosen.reduce((s,i)=>s+items[i].w,0)} / ${capacity}</div>
        </div>
      `;
      outputArea.appendChild(out);

      // Render DP table
      const dp = res.dp;
      const n = items.length;
      const W = capacity;
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const trHead = document.createElement('tr');
      trHead.appendChild(document.createElement('th')); // corner
      for (let w=0; w<=W; w++){
        const th = document.createElement('th');
        th.textContent = w;
        trHead.appendChild(th);
      }
      thead.appendChild(trHead);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      // row 0
      const tr0 = document.createElement('tr');
      const th0 = document.createElement('th'); th0.textContent = '0(items)';
      tr0.appendChild(th0);
      for (let w=0; w<=W; w++){
        const td = document.createElement('td'); td.textContent = dp[0][w];
        tr0.appendChild(td);
      }
      tbody.appendChild(tr0);
      for (let i=1;i<=n;i++){
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = (items[i-1].name || ('#'+i)) + ` (w=${items[i-1].w}, v=${items[i-1].v})`;
        tr.appendChild(th);
        for (let w=0; w<=W; w++){
          const td = document.createElement('td');
          td.textContent = dp[i][w];
          // highlight cells that are part of chosen solution path
          if (res.chosen.includes(i-1)) {
            // if chosen, and capacity w is >= cumulative weight threshold — can't mark all with confidence.
            // We'll mark the cell at the time of selection (dp[i][w] != dp[i-1][w])
            if (dp[i][w] !== dp[i-1][w]) {
              td.classList.add('selected');
            }
          }
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      const wrap = document.createElement('div');
      wrap.innerHTML = `<div style="margin-top:10px;font-weight:600">DP table (rows: items processed, cols: capacity 0..W). Selected transitions highlighted:</div>`;
      wrap.appendChild(table);
      dpTableContainer.appendChild(wrap);

      // Show chosen items detail
      const detail = document.createElement('div');
      detail.style.marginTop = '8px';
      const list = res.chosen.map(i=> {
        const it = items[i];
        return `<div class="small">${it.name || ('#'+(i+1))} — weight ${it.w}, value ${it.v}</div>`;
      }).join('');
      detail.innerHTML = `<div style="margin-top:8px"><strong>Chosen items detail:</strong>${ list || '<div class="small">none</div>' }</div>`;
      dpTableContainer.appendChild(detail);
    }

    function renderFractionalResult(res, items, capacity) {
      outputArea.innerHTML = '';
      dpTableContainer.innerHTML = '';
      fracTableContainer.innerHTML = '';

      const out = document.createElement('div');
      out.innerHTML = `
        <div class="result">
          <div><strong>Maximum value achievable (fractional):</strong> ${res.value.toFixed(4)}</div>
          <div style="margin-top:6px"><strong>Capacity used:</strong> ${res.selection.reduce((s,sel)=>s+sel.weight,0)} / ${capacity}</div>
        </div>
      `;
      outputArea.appendChild(out);

      // Table of selections in order of ratio
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      thead.innerHTML = `<tr><th>Order</th><th>Item</th><th>Weight taken</th><th>Value taken</th><th>Fraction</th><th>Ratio (v/w)</th></tr>`;
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      res.selection.forEach((s, idx)=>{
        const tr = document.createElement('tr');
        const it = items[s.idx];
        tr.innerHTML = `<td>${idx+1}</td>
                        <td>${it.name || ('#'+(s.idx+1))} (w=${it.w}, v=${it.v})</td>
                        <td>${s.weight}</td>
                        <td>${Number(s.value).toFixed(4)}</td>
                        <td>${Number(s.take).toFixed(4)}</td>
                        <td class="ratio">${Number(s.ratio).toFixed(4)}</td>`;
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      fracTableContainer.innerHTML = `<div style="font-weight:600;margin-bottom:6px">Greedy selection by value/weight ratio</div>`;
      fracTableContainer.appendChild(table);
    }

    // Animate DP table building step-by-step
    async function animateDP(items, capacity) {
      dpTableContainer.innerHTML = '';
      fracTableContainer.innerHTML = '';
      outputArea.innerHTML = '<div class="small">Animating DP table. This shows dp[i][w] values being filled. (Click "Run DP" to compute final selection.)</div>';

      const n = items.length;
      const W = capacity;
      const dp = Array.from({length: n+1}, ()=> new Array(W+1).fill(0));

      // Create table UI
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const trHead = document.createElement('tr');
      trHead.appendChild(document.createElement('th'));
      for (let w=0; w<=W; w++){
        const th = document.createElement('th');
        th.textContent = w;
        trHead.appendChild(th);
      }
      thead.appendChild(trHead);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      // row 0
      const tr0 = document.createElement('tr');
      const th0 = document.createElement('th'); th0.textContent = '0(items)';
      tr0.appendChild(th0);
      for (let w=0; w<=W; w++){
        const td = document.createElement('td'); td.textContent = '0';
        tr0.appendChild(td);
      }
      tbody.appendChild(tr0);
      for (let i=1;i<=n;i++){
        const tr = document.createElement('tr');
        const th = document.createElement('th'); th.textContent = (items[i-1].name || ('#'+i)) + ` (w=${items[i-1].w}, v=${items[i-1].v})`;
        tr.appendChild(th);
        for (let w=0; w<=W; w++){
          const td = document.createElement('td'); td.textContent = ''; td.dataset.i = i; td.dataset.w = w;
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      dpTableContainer.appendChild(table);

      // Fill cells with animation
      function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
      for (let i=1;i<=n;i++){
        const wi = items[i-1].w;
        const vi = items[i-1].v;
        for (let w=0; w<=W; w++){
          // compute dp[i][w]
          let val;
          if (wi > w) val = dp[i-1][w];
          else val = Math.max(dp[i-1][w], dp[i-1][w-wi] + vi);
          dp[i][w] = val;
          // update cell in UI
          const cell = tbody.querySelector(`td[data-i="${i}"][data-w="${w}"]`);
          cell.textContent = val;
          // temporarily highlight the cell
          cell.classList.add('highlight');
          // also show the option values as tooltip-like small text
          const opt1 = dp[i-1][w];
          const opt2 = (wi<=w) ? dp[i-1][w-wi] + vi : '-';
          cell.title = `without item: ${opt1}\nwith item: ${opt2}`;
          await sleep(60); // delay for animation
          cell.classList.remove('highlight');
        }
      }
      outputArea.innerHTML = '<div class="small">Animation finished. You can now click "Run DP" to see which items are selected.</div>';
      return dp;
    }

    // Button handlers
    runDpBtn.onclick = () => {
      const cap = parseInt(capacityInput.value, 10);
      if (!Number.isInteger(cap) || cap < 0) { alert('Capacity must be a non-negative integer.'); return; }
      if (items.length === 0) { alert('No items.'); return; }
      const res = knapsackDP(items, cap);
      renderDPResult(res, items, cap);
    };

    runFracBtn.onclick = () => {
      const cap = Number(capacityInput.value);
      if (!isFinite(cap) || cap < 0) { alert('Capacity must be a non-negative number.'); return; }
      if (items.length === 0) { alert('No items.'); return; }
      const res = fractionalKnapsack(items, cap);
      renderFractionalResult(res, items, cap);
    };

    animateDpBtn.onclick = async () => {
      const cap = parseInt(capacityInput.value, 10);
      if (!Number.isInteger(cap) || cap < 0) { alert('Capacity must be a non-negative integer.'); return; }
      if (items.length === 0) { alert('No items.'); return; }
      animateDp(items, cap);
    };

    // Initial render
    renderItems();
    outputArea.innerHTML = '<div class="small">Try the controls: add items, set capacity, then run an algorithm.</div>';
  </script>
</body>
</html>