{
  "id": "f181dcb1-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:22:55.617Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "# Kruskal's Algorithm Visualization\n\nHere's a complete HTML file that visually demonstrates and explains Kruskal's algorithm for finding the minimum spanning tree in a weighted graph.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Kruskal's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            line-height: 1.6;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n            color: #333;\n        }\n        \n        header {\n            text-align: center;\n            margin-bottom: 30px;\n        }\n        \n        h1 {\n            color: #2c3e50;\n            border-bottom: 2px solid #3498db;\n            padding-bottom: 10px;\n        }\n        \n        .container {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 20px;\n            justify-content: space-between;\n        }\n        \n        .graph-container {\n            flex: 1;\n            min-width: 500px;\n            background: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n            margin-bottom: 20px;\n        }\n        \n        .control-panel {\n            flex-basis: 300px;\n            background: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n            margin-bottom: 20px;\n        }\n        \n        .explanation {\n            flex: 1 100%;\n            background: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n            margin-top: 20px;\n        }\n        \n        #graphCanvas {\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background-color: #fafafa;\n            width: 100%;\n            height: 400px;\n        }\n        \n        button {\n            background-color: #3498db;\n            color: white;\n            border: none;\n            padding: 10px 15px;\n            margin: 5px;\n            border-radius: 5px;\n            cursor: pointer;\n            transition: background-color 0.3s;\n        }\n        \n        button:hover {\n            background-color: #2980b9;\n        }\n        \n        button:disabled {\n            background-color: #bdc3c7;\n            cursor: not-allowed;\n        }\n        \n        .mst-edge {\n            stroke: #e74c3c;\n            stroke-width: 3;\n        }\n        \n        .edge-label {\n            fill: #2c3e50;\n            font-size: 14px;\n        }\n        \n        .node {\n            fill: #3498db;\n            stroke: #2980b9;\n            stroke-width: 2;\n            cursor: pointer;\n        }\n        \n        .node-label {\n            fill: white;\n            font-weight: bold;\n            text-anchor: middle;\n            pointer-events: none;\n        }\n        \n        .progress-indicator {\n            margin: 20px 0;\n            padding: 10px;\n            background-color: #ecf0f1;\n            border-radius: 5px;\n            border-left: 4px solid #3498db;\n        }\n        \n        .step {\n            margin-bottom: 15px;\n            padding: 10px;\n            background-color: #f8f9fa;\n            border-radius: 5px;\n            border-left: 4px solid #27ae60;\n        }\n        \n        .edge-list {\n            margin-top: 15px;\n            max-height: 200px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            padding: 10px;\n        }\n        \n        .edge-item {\n            padding: 5px;\n            margin: 3px 0;\n            border-radius: 3px;\n            background-color: #f1f8ff;\n        }\n        \n        .mst-item {\n            background-color: #e8f5e9;\n        }\n        \n        .slider-container {\n            margin: 15px 0;\n        }\n        \n        .slider-container label {\n            display: block;\n            margin-bottom: 5px;\n            font-weight: bold;\n        }\n        \n        input[type=\"range\"] {\n            width: 100%;\n        }\n    </style>\n</head>\n<body>\n    <header>\n        <h1>Kruskal's Algorithm Visualization</h1>\n        <p>Find the Minimum Spanning Tree (MST) of a weighted graph</p>\n    </header>\n    \n    <div class=\"container\">\n        <div class=\"graph-container\">\n            <h2>Graph Visualization</h2>\n            <svg id=\"graphCanvas\" width=\"100%\" height=\"400\"></svg>\n        </div>\n        \n        <div class=\"control-panel\">\n            <h2>Controls</h2>\n            <div>\n                <button id=\"prevStep\">Previous Step</button>\n                <button id=\"nextStep\">Next Step</button>\n                <button id=\"reset\">Reset</button>\n                <button id=\"autoRun\">Auto Run</button>\n            </div>\n            \n            <div class=\"slider-container\">\n                <label for=\"speedSlider\">Speed: <span id=\"speedValue\">Medium</span></label>\n                <input type=\"range\" id=\"speedSlider\" min=\"1\" max=\"5\" value=\"3\">\n            </div>\n            \n            <div class=\"progress-indicator\">\n                <h3>Algorithm Progress</h3>\n                <div id=\"progressText\">Ready to start</div>\n            </div>\n            \n            <h3>Edges (sorted by weight)</h3>\n            <div id=\"edgesList\" class=\"edge-list\"></div>\n            \n            <h3>MST Edges</h3>\n            <div id=\"mstEdges\" class=\"edge-list\"></div>\n        </div>\n        \n        <div class=\"explanation\">\n            <h2>How Kruskal's Algorithm Works</h2>\n            \n            <div class=\"step\">\n                <h3>Step 1: Sort Edges</h3>\n                <p>First, we sort all the edges in the graph in non-decreasing order of their weights.</p>\n            </div>\n            \n            <div class=\"step\">\n                <h3>Step 2: Initialize Forest</h3>\n                <p>We start with a forest where each vertex is its own tree (using a disjoint set/union-find data structure).</p>\n            </div>\n            \n            <div class=\"step\">\n                <h3>Step 3: Iterate Through Sorted Edges</h3>\n                <p>We iterate through the sorted edges. For each edge:</p>\n                <ul>\n                    <li>If adding the edge doesn't form a cycle (i.e., the vertices belong to different sets), we add it to the MST</li>\n                    <li>If adding the edge forms a cycle (vertices belong to the same set), we skip it</li>\n                </ul>\n            </div>\n            \n            <div class=\"step\">\n                <h3>Step 4: Completion</h3>\n                <p>We continue this process until we have selected (V-1) edges, where V is the number of vertices in the graph.</p>\n            </div>\n            \n            <div class=\"step\">\n                <h3>Time Complexity</h3>\n                <p>The time complexity of Kruskal's algorithm is O(E log E) or O(E log V), where E is the number of edges and V is the number of vertices.</p>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        // Graph data structure\n        class Graph {\n            constructor() {\n                this.vertices = [];\n                this.edges = [];\n            }\n            \n            addVertex(x, y, label) {\n                this.vertices.push({ id: this.vertices.length, x, y, label });\n            }\n            \n            addEdge(v1, v2, weight) {\n                this.edges.push({ \n                    id: this.edges.length, \n                    v1: this.vertices[v1], \n                    v2: this.vertices[v2], \n                    weight,\n                    inMST: false,\n                    considered: false\n                });\n            }\n        }\n        \n        // Disjoint Set (Union-Find) data structure for cycle detection\n        class DisjointSet {\n            constructor(size) {\n                this.parent = new Array(size);\n                this.rank = new Array(size);\n                \n                for (let i = 0; i < size; i++) {\n                    this.parent[i] = i;\n                    this.rank[i] = 0;\n                }\n            }\n            \n            find(x) {\n                if (this.parent[x] !== x) {\n                    this.parent[x] = this.find(this.parent[x]); // Path compression\n                }\n                return this.parent[x];\n            }\n            \n            union(x, y) {\n                let rootX = this.find(x);\n                let rootY = this.find(y);\n                \n                if (rootX === rootY) return false; // Already in the same set\n                \n                // Union by rank\n                if (this.rank[rootX] < this.rank[rootY]) {\n                    this.parent[rootX] = rootY;\n                } else if (this.rank[rootX] > this.rank[rootY]) {\n                    this.parent[rootY] = rootX;\n                } else {\n                    this.parent[rootY] = rootX;\n                    this.rank[rootX]++;\n                }\n                \n                return true;\n            }\n        }\n        \n        // Visualization controller\n        class KruskalVisualizer {\n            constructor(graph) {\n                this.graph = graph;\n                this.currentStep = 0;\n                this.animationSpeed = 1000; // ms\n                this.edgesSorted = [...this.graph.edges].sort((a, b) => a.weight - b.weight);\n                this.disjointSet = new DisjointSet(this.graph.vertices.length);\n                this.mstEdges = [];\n                this.autoRunInterval = null;\n                \n                this.initializeDOM();\n                this.renderGraph();\n                this.updateControls();\n            }\n            \n            initializeDOM() {\n                this.canvas = document.getElementById('graphCanvas');\n                this.ctx = this.canvas.getContext('2d');\n                \n                // Control buttons\n                document.getElementById('prevStep').addEventListener('click', () => this.previousStep());\n                document.getElementById('nextStep').addEventListener('click', () => this.nextStep());\n                document.getElementById('reset').addEventListener('click', () => this.reset());\n                document.getElementById('autoRun').addEventListener('click', () => this.toggleAutoRun());\n                \n                // Speed slider\n                const speedSlider = document.getElementById('speedSlider');\n                const speedValue = document.getElementById('speedValue');\n                \n                speedSlider.addEventListener('input', (e) => {\n                    const speed = e.target.value;\n                    this.animationSpeed = 2000 - (speed - 1) * 400; // 2000ms to 400ms\n                    \n                    // Update speed label\n                    const speeds = ['Very Slow', 'Slow', 'Medium', 'Fast', 'Very Fast'];\n                    speedValue.textContent = speeds[speed - 1];\n                    \n                    // Update auto-run if active\n                    if (this.autoRunInterval) {\n                        clearInterval(this.autoRunInterval);\n                        this.startAutoRun();\n                    }\n                });\n            }\n            \n            renderGraph() {\n                // Clear canvas\n                this.canvas.innerHTML = '';\n                \n                // Draw edges\n                this.graph.edges.forEach(edge => {\n                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n                    line.setAttribute('x1', edge.v1.x);\n                    line.setAttribute('y1', edge.v1.y);\n                    line.setAttribute('x2', edge.v2.x);\n                    line.setAttribute('y2', edge.v2.y);\n                    \n                    if (edge.inMST) {\n                        line.setAttribute('class', 'mst-edge');\n                    } else if (edge.considered) {\n                        line.setAttribute('stroke', '#f39c12');\n                        line.setAttribute('stroke-width', '3');\n                    } else {\n                        line.setAttribute('stroke', '#7f8c8d');\n                        line.setAttribute('stroke-width', '2');\n                    }\n                    \n                    this.canvas.appendChild(line);\n                    \n                    // Edge weight label\n                    const midX = (edge.v1.x + edge.v2.x) / 2;\n                    const midY = (edge.v1.y + edge.v2.y) / 2;\n                    \n                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n                    text.setAttribute('x', midX);\n                    text.setAttribute('y', midY - 10);\n                    text.setAttribute('class', 'edge-label');\n                    text.textContent = edge.weight;\n                    \n                    this.canvas.appendChild(text);\n                });\n                \n                // Draw vertices\n                this.graph.vertices.forEach(vertex => {\n                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n                    circle.setAttribute('cx', vertex.x);\n                    circle.setAttribute('cy', vertex.y);\n                    circle.setAttribute('r', 20);\n                    circle.setAttribute('class', 'node');\n                    \n                    this.canvas.appendChild(circle);\n                    \n                    // Vertex label\n                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n                    text.setAttribute('x', vertex.x);\n                    text.setAttribute('y', vertex.y + 5);\n                    text.setAttribute('class', 'node-label');\n                    text.textContent = vertex.label;\n                    \n                    this.canvas.appendChild(text);\n                });\n                \n                // Update edge lists\n                this.updateEdgeLists();\n            }\n            \n            updateEdgeLists() {\n                const edgesList = document.getElementById('edgesList');\n                const mstEdgesList = document.getElementById('mstEdges');\n                \n                edgesList.innerHTML = '';\n                mstEdgesList.innerHTML = '';\n                \n                // Sorted edges list\n                this.edgesSorted.forEach((edge, index) => {\n                    const edgeItem = document.createElement('div');\n                    edgeItem.className = 'edge-item';\n                    \n                    if (index === this.currentStep && this.currentStep < this.edgesSorted.length) {\n                        edgeItem.style.backgroundColor = '#fff3cd';\n                    }\n                    \n                    if (edge.considered) {\n                        edgeItem.style.textDecoration = 'line-through';\n                        edgeItem.style.color = '#6c757d';\n                    }\n                    \n                    if (edge.inMST) {\n                        edgeItem.className += ' mst-item';\n                    }\n                    \n                    edgeItem.textContent = `${edge.v1.label}-${edge.v2.label} (Weight: ${edge.weight})`;\n                    edgesList.appendChild(edgeItem);\n                });\n                \n                // MST edges list\n                this.mstEdges.forEach(edge => {\n                    const edgeItem = document.createElement('div');\n                    edgeItem.className = 'edge-item mst-item';\n                    edgeItem.textContent = `${edge.v1.label}-${edge.v2.label} (Weight: ${edge.weight})`;\n                    mstEdgesList.appendChild(edgeItem);\n                });\n            }\n            \n            nextStep() {\n                if (this.currentStep >= this.edgesSorted.length) return;\n                \n                const edge = this.edgesSorted[this.currentStep];\n                edge.considered = true;\n                \n                const v1Index = this.graph.vertices.indexOf(edge.v1);\n                const v2Index = this.graph.vertices.indexOf(edge.v2);\n                \n                // Check if adding this edge creates a cycle\n                if (this.disjointSet.union(v1Index, v2Index)) {\n                    // No cycle - add to MST\n                    edge.inMST = true;\n                    this.mstEdges.push(edge);\n                    \n                    document.getElementById('progressText').textContent = \n                        `Added edge ${edge.v1.label}-${edge.v2.label} to MST (weight: ${edge.weight})`;\n                } else {\n                    // Cycle would be created - skip this edge\n                    document.getElementById('progressText').textContent = \n                        `Skipped edge ${edge.v1.label}-${edge.v2.label} - would create cycle`;\n                }\n                \n                this.currentStep++;\n                this.renderGraph();\n                this.updateControls();\n                \n                // Check if MST is complete\n                if (this.mstEdges.length === this.graph.vertices.length - 1) {\n                    document.getElementById('progressText').textContent = \n                        `MST Complete! Total weight: ${this.calculateMSTWeight()}`;\n                    this.stopAutoRun();\n                }\n            }\n            \n            previousStep() {\n                if (this.currentStep <= 0) return;\n                \n                this.currentStep--;\n                const edge = this.edgesSorted[this.currentStep];\n                edge.considered = false;\n                \n                if (edge.inMST) {\n                    edge.inMST = false;\n                    this.mstEdges.pop();\n                    \n                    // Reset the union operation (simplified - in a real scenario we'd need to track operations)\n                    // For visualization purposes, we'll just reset the disjoint set\n                    this.resetDisjointSet();\n                    \n                    // Reapply all MST edges up to the previous step\n                    for (let i = 0; i < this.currentStep; i++) {\n                        const prevEdge = this.edgesSorted[i];\n                        if (prevEdge.inMST) {\n                            const v1Index = this.graph.vertices.indexOf(prevEdge.v1);\n                            const v2Index = this.graph.vertices.indexOf(prevEdge.v2);\n                            this.disjointSet.union(v1Index, v2Index);\n                        }\n                    }\n                }\n                \n                this.renderGraph();\n                this.updateControls();\n                document.getElementById('progressText').textContent = `Step ${this.currentStep}`;\n            }\n            \n            resetDisjointSet() {\n                this.disjointSet = new DisjointSet(this.graph.vertices.length);\n            }\n            \n            reset() {\n                this.currentStep = 0;\n                this.mstEdges = [];\n                this.resetDisjointSet();\n                \n                this.graph.edges.forEach(edge => {\n                    edge.inMST = false;\n                    edge.considered = false;\n                });\n                \n                this.renderGraph();\n                this.updateControls();\n                document.getElementById('progressText').textContent = 'Ready to start';\n                this.stopAutoRun();\n            }\n            \n            updateControls() {\n                document.getElementById('prevStep').disabled = this.currentStep === 0;\n                document.getElementById('nextStep').disabled"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}