{
  "id": "d79d63f1-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:29.156Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Kruskal’s Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background: #f0f0f0;\n    min-height: 100vh;\n  }\n  header {\n    background-color: #34495e;\n    color: white;\n    padding: 1em 2em;\n    width: 100%;\n    text-align: center;\n    box-shadow: 0 2px 6px rgba(0,0,0,0.3);\n  }\n  #container {\n    display: flex;\n    margin: 20px;\n    width: 90vw;\n    max-width: 1000px;\n  }\n  #graph {\n    flex: 2;\n    border: 1px solid #ccc;\n    background: white;\n    border-radius: 8px;\n    position: relative;\n  }\n  #info {\n    flex: 1;\n    margin-left: 20px;\n    background: #fff;\n    border-radius: 8px;\n    padding: 15px;\n    box-shadow: 0 0 8px rgba(0,0,0,0.12);\n    max-height: 600px;\n    overflow-y: auto;\n  }\n  h2 {\n    margin-top: 0;\n  }\n  button {\n    background-color: #2980b9;\n    color: white;\n    border: none;\n    padding: 10px 16px;\n    font-size: 1rem;\n    border-radius: 5px;\n    cursor: pointer;\n  }\n  button:disabled {\n    background-color: #95a5a6;\n    cursor: not-allowed;\n  }\n  #edgesList {\n    margin: 10px 0;\n    max-height: 200px;\n    overflow-y: auto;\n  }\n  .log-entry {\n    font-family: monospace;\n    margin: 4px 0;\n  }\n\n  svg {\n    width: 100%;\n    height: 600px;\n  }\n  .node circle {\n    fill: #3498db;\n    stroke: #2980b9;\n    stroke-width: 2px;\n  }\n  .node text {\n    fill: white;\n    font-weight: bold;\n    user-select: none;\n  }\n  .edge {\n    fill: none;\n    stroke: #7f8c8d;\n    stroke-width: 3;\n    cursor: default;\n  }\n  .edge.weight-label {\n    font-size: 14px;\n    fill: #2c3e50;\n    user-select: none;\n    pointer-events: none;\n  }\n  .edge.selected {\n    stroke: #27ae60;\n    stroke-width: 4;\n  }\n  .edge.skipped {\n    stroke: #c0392b;\n    stroke-dasharray: 5 5;\n  }\n  .ds-highlight {\n    fill: #e67e22 !important;\n  }\n</style>\n</head>\n<body>\n<header>\n  <h1>Kruskal’s Algorithm Visualization</h1>\n  <p>Step through Minimum Spanning Tree construction on a weighted undirected graph</p>\n</header>\n<div id=\"container\">\n  <div id=\"graph\">\n    <svg id=\"svgGraph\" viewBox=\"0 0 800 600\" xmlns=\"http://www.w3.org/2000/svg\" aria-label=\"Graph visualization\"></svg>\n  </div>\n  <div id=\"info\" aria-live=\"polite\" aria-atomic=\"true\">\n    <h2>Control Panel</h2>\n    <p><strong>Steps:</strong> Kruskal’s algorithm sorts all edges by weight and adds them greedily unless they form a cycle.</p>\n    <button id=\"nextStepBtn\">Next Step</button>\n    <button id=\"resetBtn\" style=\"margin-left: 10px;\">Reset</button>\n    <h3>Current Step Info</h3>\n    <div id=\"currentStepInfo\">Press \"Next Step\" to start.</div>\n    <h3>Edge being considered</h3>\n    <div id=\"edgeInfo\">-</div>\n    <h3>Disjoint Set Forest</h3>\n    <div id=\"dsInfo\"></div>\n    <h3>Edges selected in MST</h3>\n    <ul id=\"mstEdges\"></ul>\n  </div>\n</div>\n\n<script>\n(() => {\n  /*\n  Visualization of Kruskal's algorithm.\n\n  Approach:\n  - Fixed weighted undirected graph.\n  - On loading: \n    - Display nodes and edges.\n    - Edges are sorted by weight.\n  - On each step:\n    - Consider next edge in sorted order.\n    - Check if it forms a cycle via union-find.\n    - If no cycle, include edge in MST and union sets.\n    - Update visualization:\n      - Highlight considered edge\n      - Mark selected edges in green\n      - Mark skipped edges in red dashed\n    - Show DS info and log\n  */\n\n  const svg = document.getElementById('svgGraph');\n  const nextBtn = document.getElementById('nextStepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const currentStepInfo = document.getElementById('currentStepInfo');\n  const edgeInfo = document.getElementById('edgeInfo');\n  const dsInfo = document.getElementById('dsInfo');\n  const mstEdgesList = document.getElementById('mstEdges');\n\n  // Graph data representation: nodes and edges\n  // Coordinates for nice layout.\n  const nodes = [\n    { id: 0, label: 'A', x: 150, y: 100 },\n    { id: 1, label: 'B', x: 350, y: 50 },\n    { id: 2, label: 'C', x: 550, y: 100 },\n    { id: 3, label: 'D', x: 200, y: 300 },\n    { id: 4, label: 'E', x: 400, y: 300 },\n    { id: 5, label: 'F', x: 600, y: 300 }\n  ];\n\n  // Undirected edges: u,v and weight\n  // E.g. edge from node 0 to node 1 with weight 4\n  const edges = [\n    { id: 0, u: 0, v: 1, w: 4 },\n    { id: 1, u: 0, v: 3, w: 2 },\n    { id: 2, u: 1, v: 2, w: 6 },\n    { id: 3, u: 1, v: 4, w: 5 },\n    { id: 4, u: 2, v: 5, w: 1 },\n    { id: 5, u: 3, v: 4, w: 3 },\n    { id: 6, u: 4, v: 5, w: 7 },\n    { id: 7, u: 3, v: 5, w: 8 }\n  ];\n\n  // We'll display edges as lines with weight labels midway\n\n  // Union-Find (Disjoint Set) Implementation\n  class UnionFind {\n    constructor(n) {\n      this.parent = new Array(n);\n      this.rank = new Array(n);\n      for(let i=0; i<n; i++) {\n        this.parent[i] = i;\n        this.rank[i] = 0;\n      }\n    }\n    find(x) {\n      if(this.parent[x] !== x) {\n        this.parent[x] = this.find(this.parent[x]); // path compression\n      }\n      return this.parent[x];\n    }\n    union(a, b) {\n      let rootA = this.find(a);\n      let rootB = this.find(b);\n      if(rootA === rootB) return false;\n      // union by rank\n      if(this.rank[rootA] < this.rank[rootB]) {\n        this.parent[rootA] = rootB;\n      } else if(this.rank[rootA] > this.rank[rootB]) {\n        this.parent[rootB] = rootA;\n      } else {\n        this.parent[rootB] = rootA;\n        this.rank[rootA]++;\n      }\n      return true;\n    }\n    getSets() {\n      // Return array mapping node -> root parent\n      return this.parent.map((_,i) => this.find(i));\n    }\n  }\n\n  // State variables for stepping through algorithm\n  let uf;\n  let sortedEdges = [];\n  let currentEdgeIndex = -1; // before first step\n  let mstEdges = [];\n\n  // SVG element groups\n  let edgeElements = new Map(); // edgeId -> SVG line element\n  let edgeWeightElements = new Map(); // edgeId -> SVG text element\n  let nodeElements = new Map(); // nodeId -> SVG group element (circle + text)\n\n  function clearSVG() {\n    while(svg.firstChild) svg.removeChild(svg.firstChild);\n  }\n\n  function drawGraph() {\n    clearSVG();\n\n    // Draw edges first (under nodes)\n    edges.forEach(edge => {\n      const from = nodes[edge.u];\n      const to = nodes[edge.v];\n      const line = document.createElementNS(\"http://www.w3.org/2000/svg\", 'line');\n      line.setAttribute('x1', from.x);\n      line.setAttribute('y1', from.y);\n      line.setAttribute('x2', to.x);\n      line.setAttribute('y2', to.y);\n      line.setAttribute('class', 'edge');\n      line.setAttribute('id', `edge${edge.id}`);\n      line.setAttribute('aria-label', `Edge ${nodes[edge.u].label} - ${nodes[edge.v].label} with weight ${edge.w}`);\n      svg.appendChild(line);\n      edgeElements.set(edge.id, line);\n\n      // Weight Text\n      const midX = (from.x + to.x) / 2;\n      const midY = (from.y + to.y) / 2;\n      const weightText = document.createElementNS(\"http://www.w3.org/2000/svg\", 'text');\n      weightText.setAttribute('x', midX);\n      weightText.setAttribute('y', midY - 8);\n      weightText.setAttribute('text-anchor', 'middle');\n      weightText.setAttribute('class', 'edge weight-label');\n      weightText.textContent = edge.w;\n      svg.appendChild(weightText);\n      edgeWeightElements.set(edge.id, weightText);\n    });\n\n    // Draw nodes on top of edges\n    nodes.forEach(node => {\n      const group = document.createElementNS(\"http://www.w3.org/2000/svg\", 'g');\n      group.setAttribute('class', 'node');\n      group.setAttribute('id', `node${node.id}`);\n\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", 'circle');\n      circle.setAttribute('cx', node.x);\n      circle.setAttribute('cy', node.y);\n      circle.setAttribute('r', 25);\n      group.appendChild(circle);\n\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", 'text');\n      text.setAttribute('x', node.x);\n      text.setAttribute('y', node.y + 6);\n      text.setAttribute('text-anchor', 'middle');\n      text.textContent = node.label;\n      group.appendChild(text);\n\n      svg.appendChild(group);\n      nodeElements.set(node.id, group);\n    });\n  }\n\n  // Reset state for new run\n  function reset() {\n    uf = new UnionFind(nodes.length);\n    // Sort edges by weight ascending\n    sortedEdges = edges.slice().sort((a,b) => a.w - b.w);\n    currentEdgeIndex = -1;\n    mstEdges = [];\n    drawGraph();\n    updateUIBeforeStep();\n  }\n\n  // Serialize current UF state for display\n  function renderUF() {\n    // Show two lines:\n    // parent array\n    // rank array\n    const p = uf.parent.map((val,i) => `${i}->${val}`).join(', ');\n    const sets = uf.getSets();\n    const repr = [];\n    // Group nodes by root parent:\n    const groups = new Map();\n    sets.forEach((root,i) => {\n      if(!groups.has(root)) groups.set(root, []);\n      groups.get(root).push(nodes[i].label);\n    });\n    let groupStr = \"\";\n    for(let [root,members] of groups) {\n      groupStr += members.join(\", \") + \" | \";\n    }\n    return `<strong>Parents:</strong> ${p}<br/><strong>Sets (connected components):</strong> ${groupStr.slice(0,-3)}`;\n  }\n\n  // Update UI on each step (before considering next edge)\n  function updateUIBeforeStep() {\n    currentStepInfo.textContent = \"Press 'Next Step' to process the next edge in ascending weight order.\";\n    edgeInfo.textContent = \"-\";\n    dsInfo.innerHTML = renderUF();\n    renderMSTEdges();\n    resetBtn.disabled = false;\n    nextBtn.disabled = false;\n    // Clear all edge highlights\n    edges.forEach(e => {\n      let line = edgeElements.get(e.id);\n      line.classList.remove('selected', 'skipped');\n      line.style.transition = 'stroke 0.4s ease';\n      line.style.stroke = '#7f8c8d';\n      line.style.strokeWidth = '3';\n    });\n  }\n\n  // Render MST edge list\n  function renderMSTEdges() {\n    mstEdgesList.innerHTML = '';\n    if(mstEdges.length === 0) {\n      mstEdgesList.innerHTML = '<li><em>No edges selected yet.</em></li>';\n      return;\n    }\n    mstEdges.forEach(e => {\n      const li = document.createElement('li');\n      li.textContent = `${nodes[e.u].label} - ${nodes[e.v].label} (weight: ${e.w})`;\n      mstEdgesList.appendChild(li);\n    });\n  }\n\n  // Step function: consider next edge\n  function nextStep() {\n    currentEdgeIndex++;\n    if(currentEdgeIndex >= sortedEdges.length) {\n      currentStepInfo.textContent = \"Algorithm finished. Minimum Spanning Tree complete.\";\n      edgeInfo.textContent = \"-\";\n      nextBtn.disabled = true;\n      resetBtn.disabled = false;\n      dsInfo.innerHTML = renderUF();\n      return;\n    }\n\n    const edge = sortedEdges[currentEdgeIndex];\n    const u = edge.u, v = edge.v;\n\n    currentStepInfo.textContent = `Considering edge ${nodes[u].label} - ${nodes[v].label} with weight ${edge.w}`;\n    edgeInfo.textContent = `Checking if adding this edge creates a cycle...`;\n\n    // Highlight the considered edge with a distinct color\n    edges.forEach(e => {\n      const line = edgeElements.get(e.id);\n      line.style.transition = 'stroke 0.4s ease';\n      line.style.strokeWidth = '3';\n      if(e.id === edge.id) {\n        line.style.stroke = '#f39c12'; // orange\n        line.classList.remove('selected','skipped');\n      } else if(mstEdges.find(mstE => mstE.id === e.id)) {\n        line.style.stroke = '#27ae60'; // green MST edge\n        line.classList.add('selected');\n        line.classList.remove('skipped');\n        line.style.strokeWidth = '4';\n      } else if(e.id < currentEdgeIndex) {\n        // Previously considered but skipped edges\n        if(!mstEdges.find(mstE => mstE.id === e.id)) {\n          line.style.stroke = '#c0392b'; // red\n          line.classList.add('skipped');\n          line.classList.remove('selected');\n          line.style.strokeWidth = '3';\n        }\n      } else {\n        // Not considered yet edges\n        line.style.stroke = '#7f8c8d';\n        line.classList.remove('selected','skipped');\n      }\n    });\n\n    // Check if edge creates a cycle (i.e. same set?)\n    if(uf.find(u) !== uf.find(v)) {\n      // No cycle - union\n      uf.union(u, v);\n      mstEdges.push(edge);\n      edgeInfo.textContent += \" No cycle formed. Edge added to MST.\";\n    } else {\n      // Cycle formed - skip\n      edgeInfo.textContent += \" Cycle detected! Edge skipped.\";\n    }\n\n    dsInfo.innerHTML = renderUF();\n    renderMSTEdges();\n\n    // If MST complete (n-1 edges selected)\n    if(mstEdges.length === nodes.length - 1) {\n      currentStepInfo.textContent = \"MST complete! Algorithm finished.\";\n      nextBtn.disabled = true;\n      resetBtn.disabled = false;\n\n      // Highlight MST edges strongly, and others faded\n      edges.forEach(e => {\n        const line = edgeElements.get(e.id);\n        if(mstEdges.find(mstE => mstE.id === e.id)) {\n          line.style.stroke = '#27ae60';\n          line.style.strokeWidth = '5';\n          line.classList.add('selected');\n          line.classList.remove('skipped');\n        } else {\n          line.style.stroke = '#bdc3c7';\n          line.style.strokeWidth = '2';\n          line.classList.remove('selected','skipped');\n        }\n      });\n    }\n\n  }\n\n  // Initialize UI and setup event handlers\n  function init() {\n    reset();\n    nextBtn.addEventListener('click', nextStep);\n    resetBtn.addEventListener('click', reset);\n  }\n\n  init();\n\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}