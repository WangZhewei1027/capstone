{
  "id": "e932ff41-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:38:30.290Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Heap (Min/Max)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<title>Heap (Min / Max) Interactive Demo</title>\n<style>\n  :root{\n    --bg:#0f1724;\n    --card:#0b1220;\n    --accent:#06b6d4;\n    --muted:#94a3b8;\n    --good:#16a34a;\n    --danger:#ef4444;\n    --glass: rgba(255,255,255,0.03);\n  }\n  html,body{height:100%;}\n  body{\n    margin:0;\n    font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    background: linear-gradient(180deg,var(--bg),#071028 40%);\n    color:#e6eef6;\n    padding:20px;\n    -webkit-font-smoothing:antialiased;\n    -moz-osx-font-smoothing:grayscale;\n  }\n  .wrap{\n    max-width:1100px;\n    margin:0 auto;\n    display:grid;\n    grid-template-columns: 420px 1fr;\n    gap:18px;\n  }\n\n  .panel{\n    background:linear-gradient(180deg,var(--card), rgba(255,255,255,0.02));\n    border-radius:12px;\n    padding:16px;\n    box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n  }\n  .controls h2{\n    margin:0 0 8px 0;\n    font-size:18px;\n    letter-spacing:0.2px;\n  }\n  .row{\n    display:flex;\n    gap:8px;\n    align-items:center;\n    margin-bottom:10px;\n    flex-wrap:wrap;\n  }\n  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px;}\n  select,input[type=number],input[type=text]{\n    padding:8px 10px;\n    border-radius:8px;\n    border:none;\n    background:var(--glass);\n    color:inherit;\n    outline: none;\n    min-width:0;\n  }\n  button{\n    padding:8px 10px;\n    border-radius:8px;\n    border:1px solid rgba(255,255,255,0.06);\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n    color:inherit;\n    cursor:pointer;\n  }\n  button.primary{\n    background:linear-gradient(180deg,var(--accent),#0891b2);\n    border:none;\n    color:#072024;\n    font-weight:600;\n  }\n  button.warn{\n    background:linear-gradient(180deg,#f97316,#ea580c);\n    border:none;\n    color:white;\n  }\n  .small{font-size:13px;padding:6px 8px;border-radius:6px;}\n  .muted{color:var(--muted);font-size:13px;}\n  .big{\n    display:flex;\n    gap:12px;\n    align-items:center;\n  }\n\n  /* array view */\n  .array-view{\n    display:flex;\n    gap:8px;\n    align-items:flex-end;\n    padding:12px 6px;\n    overflow:auto;\n  }\n  .box{\n    min-width:46px;\n    height:48px;\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n    border:1px solid rgba(255,255,255,0.04);\n    border-radius:8px;\n    display:flex;\n    align-items:center;\n    justify-content:center;\n    font-weight:700;\n    position:relative;\n    transition: transform 300ms ease, box-shadow 200ms ease;\n  }\n  .box.index{\n    font-size:12px;\n    color:var(--muted);\n    position:absolute;\n    top:-18px;\n    left:6px;\n  }\n  .box.highlight{\n    box-shadow: 0 6px 20px rgba(3,105,161,0.25);\n    transform: translateY(-6px) scale(1.02);\n    border-color: rgba(6,182,212,0.9);\n  }\n  .box.swap{\n    background:linear-gradient(90deg,#fffbeb,#fff7ed);\n    color:#452b00;\n    border-color:#f59e0b;\n    box-shadow: 0 8px 28px rgba(245,158,11,0.18);\n  }\n\n  /* tree area */\n  .canvas-wrap{\n    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);\n    border-radius:10px;\n    padding:12px;\n    height:380px;\n    position:relative;\n    overflow:hidden;\n  }\n  svg {\n    width:100%;\n    height:100%;\n    display:block;\n  }\n  .node{\n    transition: transform 400ms ease;\n  }\n  .node circle{\n    fill:var(--card);\n    stroke:rgba(255,255,255,0.06);\n    stroke-width:1.2;\n    transition: fill 200ms ease, r 200ms ease;\n  }\n  .node text{\n    fill:var(--muted);\n    font-weight:700;\n    font-size:12px;\n  }\n  .node.highlight circle{\n    fill:var(--accent);\n  }\n  .node.swap circle{\n    fill:#fffbeb;\n    stroke:#f59e0b;\n  }\n  .link {\n    stroke: rgba(255,255,255,0.06);\n    stroke-width:2;\n  }\n\n  .log{\n    margin-top:12px;\n    font-family:monospace;\n    font-size:12px;\n    line-height:1.4;\n    max-height:180px;\n    overflow:auto;\n    background:rgba(255,255,255,0.02);\n    padding:8px;\n    border-radius:8px;\n    border:1px solid rgba(255,255,255,0.03);\n  }\n  .footer{\n    margin-top:12px;\n    font-size:13px;\n    color:var(--muted);\n  }\n  .badge{\n    font-size:12px;\n    padding:4px 8px;\n    border-radius:999px;\n    background:rgba(255,255,255,0.03);\n    color:var(--muted);\n    border:1px solid rgba(255,255,255,0.02);\n  }\n  .legend{display:flex;gap:10px; margin-top:8px; flex-wrap:wrap;}\n  .legend div{font-size:12px;color:var(--muted);}\n  .controls .muted {margin-top:6px;}\n  .center{display:flex;align-items:center;justify-content:center;}\n  @media (max-width:980px){\n    .wrap{grid-template-columns:1fr; padding-bottom:120px;}\n    .canvas-wrap{height:300px;}\n  }\n</style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <div class=\"panel controls\">\n      <h2>Heap (Min / Max) — Interactive Visualizer</h2>\n      <div class=\"row\">\n        <label for=\"type\">Type</label>\n        <select id=\"type\">\n          <option value=\"min\">Min Heap (smallest root)</option>\n          <option value=\"max\">Max Heap (largest root)</option>\n        </select>\n        <div style=\"flex:1\"></div>\n        <span class=\"badge\" id=\"countBadge\">0 items</span>\n      </div>\n\n      <div class=\"row\">\n        <div style=\"flex:1\">\n          <label for=\"value\">Value to insert</label>\n          <input id=\"value\" type=\"number\" value=\"7\" />\n        </div>\n        <div style=\"width:120px\">\n          <label>&nbsp;</label>\n          <button id=\"insertBtn\" class=\"primary\" style=\"width:100%;\">Insert</button>\n        </div>\n      </div>\n\n      <div class=\"row\">\n        <div style=\"flex:1\">\n          <label>Quick actions</label>\n          <div style=\"display:flex;gap:8px;\">\n            <button id=\"extractBtn\" class=\"small\">Extract root</button>\n            <button id=\"peekBtn\" class=\"small\">Peek root</button>\n            <button id=\"clearBtn\" class=\"small\">Clear</button>\n          </div>\n        </div>\n        <div style=\"width:140px\">\n          <label>Animation</label>\n          <div style=\"display:flex;gap:6px;\">\n            <button id=\"toggleAnim\" class=\"small\">Animate: ON</button>\n            <button id=\"stepBtn\" class=\"small\">Step Mode</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"row\">\n        <div style=\"flex:1\">\n          <label>Build / Generate</label>\n          <div style=\"display:flex;gap:8px;\">\n            <input id=\"listInput\" type=\"text\" placeholder=\"e.g. 5,3,8,1,9\" />\n            <button id=\"buildBtn\" class=\"small\">Build heap</button>\n            <button id=\"randBtn\" class=\"small\">Random</button>\n          </div>\n          <div class=\"muted\">Paste a comma-separated list, or generate random values. Building uses bottom-up heapify (O(n)).</div>\n        </div>\n      </div>\n\n      <div class=\"row\">\n        <div style=\"flex:1\">\n          <label>Heap sort</label>\n          <div style=\"display:flex;gap:8px;\">\n            <button id=\"heapSortBtn\" class=\"small\">Heap sort</button>\n            <button id=\"visualSortBtn\" class=\"small\">Visualize sort</button>\n          </div>\n          <div class=\"muted\">Heap sort repeatedly extracts root to produce a sorted array.</div>\n        </div>\n      </div>\n\n      <div class=\"row\">\n        <label>Array representation</label>\n        <div class=\"array-view\" id=\"arrayView\" style=\"min-height:72px;\"></div>\n      </div>\n\n      <div class=\"row\">\n        <label>Legend & Tips</label>\n        <div class=\"legend\">\n          <div class=\"muted\">Nodes are shown by level (root at top). Swapping during bubble-up/sink-down is animated when Animation is ON.</div>\n        </div>\n      </div>\n\n      <div class=\"log\" id=\"log\"></div>\n      <div class=\"footer\">Try inserting numbers, building from an array, and visualizing heapify and heap sort. Switch between min and max to see behavior differences.</div>\n    </div>\n\n    <div class=\"panel\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;\">\n        <div>\n          <strong id=\"title\">Heap Visualization</strong>\n          <div class=\"muted\" id=\"subtitle\">Tree & links (SVG)</div>\n        </div>\n        <div class=\"muted\">Interactive demo • <span id=\"opsInfo\">No operations yet</span></div>\n      </div>\n\n      <div class=\"canvas-wrap\" id=\"canvasWrap\">\n        <svg id=\"svgCanvas\" viewBox=\"0 0 1000 400\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n      </div>\n\n      <div style=\"display:flex;gap:8px;margin-top:12px;align-items:center;\">\n        <div class=\"muted\">Swap speed:</div>\n        <input id=\"speed\" type=\"range\" min=\"50\" max=\"1200\" value=\"360\" style=\"flex:1\" />\n        <div class=\"muted\" id=\"speedVal\">360ms</div>\n      </div>\n\n    </div>\n  </div>\n\n<script>\n/*\n  Heap visualizer (single-file).\n  - Supports Min/Max heaps\n  - Visual tree (SVG) and array boxes\n  - Animate bubble-up / sink-down swaps\n  - Build heap (bottom-up), heap sort, insert, extract\n  - Step-by-step mode via awaiting manual \"Next\" (Step Mode toggles)\n*/\n\n(() => {\n  const svg = document.getElementById('svgCanvas');\n  const arrayView = document.getElementById('arrayView');\n  const logEl = document.getElementById('log');\n  const countBadge = document.getElementById('countBadge');\n  const typeSel = document.getElementById('type');\n  const valueInput = document.getElementById('value');\n  const insertBtn = document.getElementById('insertBtn');\n  const extractBtn = document.getElementById('extractBtn');\n  const peekBtn = document.getElementById('peekBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const buildBtn = document.getElementById('buildBtn');\n  const listInput = document.getElementById('listInput');\n  const randBtn = document.getElementById('randBtn');\n  const heapSortBtn = document.getElementById('heapSortBtn');\n  const visualSortBtn = document.getElementById('visualSortBtn');\n  const toggleAnim = document.getElementById('toggleAnim');\n  const stepBtn = document.getElementById('stepBtn');\n  const speedRange = document.getElementById('speed');\n  const speedVal = document.getElementById('speedVal');\n  const opsInfo = document.getElementById('opsInfo');\n\n  let animate = true;\n  let stepMode = false;\n  let pendingStepResolve = null;\n\n  // Utility: wait for ms\n  const wait = ms => new Promise(r => setTimeout(r, ms));\n\n  // Wait until user clicks \"next step\" when stepMode active\n  function waitForStep() {\n    if (!stepMode) return Promise.resolve();\n    opsInfo.textContent = 'Waiting for Next Step... (click Step Mode button to toggle off)';\n    return new Promise(resolve => {\n      pendingStepResolve = resolve;\n    });\n  }\n\n  stepBtn.addEventListener('click', () => {\n    stepMode = !stepMode;\n    stepBtn.classList.toggle('primary', stepMode);\n    stepBtn.textContent = stepMode ? 'Step: ON (click to disable)' : 'Step Mode';\n    if (!stepMode && pendingStepResolve) {\n      pendingStepResolve();\n      pendingStepResolve = null;\n    }\n  });\n\n  toggleAnim.addEventListener('click', () => {\n    animate = !animate;\n    toggleAnim.textContent = 'Animate: ' + (animate ? 'ON' : 'OFF');\n    toggleAnim.classList.toggle('primary', animate);\n  });\n\n  speedRange.addEventListener('input', () => {\n    speedVal.textContent = speedRange.value + 'ms';\n  });\n\n  // Heap class\n  class Heap {\n    constructor(isMin = true) {\n      this.isMin = !!isMin;\n      this.data = [];\n      this.logEnabled = true;\n      this.stepCallbacks = []; // (type, i, j) called on swaps\n    }\n    cmp(a,b){\n      return this.isMin ? a < b : a > b;\n    }\n    size(){ return this.data.length; }\n    peek(){ return this.size() ? this.data[0] : null; }\n\n    // register step callback to visualize swaps or steps\n    onStep(cb){ this.stepCallbacks.push(cb); }\n\n    // bubble up index i\n    async bubbleUp(i){\n      while(i > 0){\n        const p = Math.floor((i-1)/2);\n        if (this.cmp(this.data[i], this.data[p])) {\n          // swap\n          [this.data[i], this.data[p]] = [this.data[p], this.data[i]];\n          await this._notify('swap', i, p);\n          i = p;\n        } else break;\n      }\n    }\n\n    // sink down index i (heapify down)\n    async sinkDown(i){\n      const n = this.size();\n      while(true){\n        const left = 2*i + 1;\n        const right = left + 1;\n        let candidate = i;\n        if (left < n && this.cmp(this.data[left], this.data[candidate])) candidate = left;\n        if (right < n && this.cmp(this.data[right], this.data[candidate])) candidate = right;\n        if (candidate !== i){\n          [this.data[i], this.data[candidate]] = [this.data[candidate], this.data[i]];\n          await this._notify('swap', i, candidate);\n          i = candidate;\n        } else break;\n      }\n    }\n\n    // Insert value\n    async insert(val){\n      this.data.push(val);\n      await this._notify('insert', this.size()-1);\n      await this.bubbleUp(this.size()-1);\n    }\n\n    // Extract root\n    async extract(){\n      if (this.size()===0) return null;\n      const root = this.data[0];\n      const last = this.data.pop();\n      if (this.size() > 0){\n        this.data[0] = last;\n        await this._notify('replaceRoot', 0);\n        await this.sinkDown(0);\n      } else {\n        await this._notify('removeLast', null);\n      }\n      return root;\n    }\n\n    // Build heap from array using bottom-up heapify\n    async buildFromArray(arr){\n      this.data = arr.slice();\n      await this._notify('buildStart', null);\n      for (let i = Math.floor(this.size()/2)-1; i >= 0; i--){\n        await this._notify('heapifyStart', i);\n        await this.sinkDown(i);\n      }\n      await this._notify('buildEnd', null);\n    }\n\n    // Heap sort (non-destructive: copies heap)\n    heapSortArray(){\n      const copy = new Heap(this.isMin);\n      copy.data = this.data.slice();\n      const out = [];\n      while(copy.size()){\n        out.push(copy.data[0]);\n        const last = copy.data.pop();\n        if (copy.size() > 0){\n          copy.data[0] = last;\n          // simple sink on copy (no animation)\n          let i=0;\n          while(true){\n            const left = 2*i+1, right = left+1;\n            let candidate = i;\n            if (left < copy.size() && copy.cmp(copy.data[left], copy.data[candidate])) candidate = left;\n            if (right < copy.size() && copy.cmp(copy.data[right], copy.data[candidate])) candidate = right;\n            if (candidate !== i){\n              [copy.data[i], copy.data[candidate]] = [copy.data[candidate], copy.data[i]];\n              i = candidate;\n            } else break;\n          }\n        }\n      }\n      return out;\n    }\n\n    // Internal: notify callbacks with optional animation delays\n    async _notify(type, i, j){\n      for (const cb of this.stepCallbacks) {\n        // cb returns a promise that resolves when visualization done\n        const p = cb(type, i, j, this.data.slice());\n        if (p && typeof p.then === 'function') {\n          await p;\n        }\n      }\n    }\n  }\n\n  // Visualization helpers\n  function log(msg){\n    const el = document.createElement('div');\n    el.textContent = (new Date()).toTimeString().slice(0,8) + ' • ' + msg;\n    logEl.prepend(el);\n  }\n  function setCount(n){\n    countBadge.textContent = n + (n===1 ? ' item' : ' items');\n  }\n\n  // Position nodes for binary heap\n  function computeLayout(n, width = 1000, height = 380){\n    // compute level & position\n    const nodes = [];\n    for (let i=0;i<n;i++){\n      const level = Math.floor(Math.log2(i+1));\n      const firstIndexInLevel = Math.pow(2,level) - 1;\n      const posInLevel = i - firstIndexInLevel;\n      const nodesInLevel = Math.pow(2,level);\n      const y = 40 + level * 70;\n      const horizontalGap = width / (nodesInLevel + 1);\n      const x = horizontalGap * (posInLevel + 1);\n      nodes.push({i, x, y, level});\n    }\n    return nodes;\n  }\n\n  // Render heap (array boxes + svg tree)\n  function renderHeap(heap, highlight = {}) {\n    const arr = heap.data;\n    // arrayView\n    arrayView.innerHTML = '';\n    arr.forEach((v, idx) => {\n      const b = document.createElement('div');\n      b.className = 'box';\n      if (highlight.idx === idx) b.classList.add('highlight');\n      if (highlight.swap && (highlight.swap[0]===idx || highlight.swap[1]===idx)) b.classList.add('swap');\n      const idxElem = document.createElement('div');\n      idxElem.className = 'box index';\n      idxElem.textContent = idx;\n      b.appendChild(idxElem);\n      const content = document.createElement('div');\n      content.textContent = v;\n      b.appendChild(content);\n      arrayView.appendChild(b);\n    });\n\n    setCount(arr.length);\n\n    // SVG tree\n    const width = 1000, height = 400;\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n    svg.innerHTML = '';\n    if (arr.length === 0) {\n      // show a small placeholder instruction\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('x', width/2);\n      text.setAttribute('y', height/2);\n      text.setAttribute('text-anchor','middle');\n      text.setAttribute('fill','rgba(255,255,255,0.12)');\n      text.setAttribute('font-size','16');\n      text.textContent = 'Heap is empty — insert values or build from an array';\n      svg.appendChild(text);\n      return;\n    }\n    const nodes = computeLayout(arr.length, width, height);\n    // draw links\n    nodes.forEach(n => {\n      const left = 2*n.i + 1;\n      const right = left + 1;\n      if (left < arr.length){\n        const n2 = nodes[left];\n        const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n        line.setAttribute('x1', n.x);\n        line.setAttribute('y1', n.y + 18);\n        line.setAttribute('x2', n2.x);\n        line.setAttribute('y2', n2.y - 18);\n        line.setAttribute('class','link');\n        svg.appendChild(line);\n      }\n      if (right < arr.length){\n        const n2 = nodes[right];\n        const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n        line.setAttribute('x1', n.x);\n        line.setAttribute('y1', n.y + 18);\n        line.setAttribute('x2', n2.x);\n        line.setAttribute('y2', n2.y - 18);\n        line.setAttribute('class','link');\n        svg.appendChild(line);\n      }\n    });\n\n    nodes.forEach(n => {\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      g.setAttribute('transform', `translate(${n.x}, ${n.y})`);\n      g.setAttribute('class','node');\n      // highlight logic\n      if (highlight.idx === n.i) g.classList.add('highlight');\n      if (highlight.swap && (highlight.swap[0]===n.i || highlight.swap[1]===n.i)) g.classList.add('swap');\n\n      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      circle.setAttribute('r', 20);\n      g.appendChild(circle);\n\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('text-anchor','middle');\n      text.setAttribute('dy','6');\n      text.textContent = arr[n.i];\n      g.appendChild(text);\n\n      const idxText = document.createElementNS('http://www.w3.org/2000/svg','text');\n      idxText.setAttribute('text-anchor','middle');\n      idxText.setAttribute('dy','36');\n      idxText.setAttribute('font-size','10');\n      idxText.setAttribute('fill','rgba(255,255,255,0.25)');\n      idxText.textContent = n.i;\n      g.appendChild(idxText);\n\n      svg.appendChild(g);\n    });\n  }\n\n  // Animation callback used by heap to visualize steps\n  function makeVisualizer(heap){\n    return async (type, i, j, snapshot) => {\n      // type: 'swap', 'insert', 'replaceRoot', 'removeLast', 'buildStart', 'heapifyStart', 'buildEnd'\n      // i, j are indices involved (j may be undefined)\n      // snapshot is the current array after the operation\n      opsInfo.textContent = type + (i !== null && i !== undefined ? ` (${i}${j!==undefined?','+j:''})` : '');\n      const ms = parseInt(speedRange.value,10) || 360;\n      if (type === 'swap'){\n        // show swap highlight and animate\n        renderHeap(heap, {swap:[i,j]});\n        if (animate) await wait(ms);\n        else await wait(50);\n      } else if (type === 'insert'){\n        renderHeap(heap, {idx:i});\n        if (animate) await wait(Math.min(ms, 300));\n      } else if (type === 'replaceRoot' || type === 'removeLast'){\n        renderHeap(heap, {});\n        if (animate) await wait(Math.min(ms, 220));\n      } else if (type === 'buildStart'){\n        log('Starting build from array: ' + snapshot.join(', '));\n        renderHeap(heap,{});\n        await wait(120);\n      } else if (type === 'heapifyStart'){\n        log('Heapify at index ' + i);\n        renderHeap(heap,{idx:i});\n        if (animate) await wait(ms/1.6);\n      } else if (type === 'buildEnd'){\n        log('Build finished');\n        renderHeap(heap,{});\n        await wait(220);\n      } else {\n        renderHeap(heap,{});\n        await wait(90);\n      }\n\n      // Wait for step mode if active (pauses between steps)\n      if (stepMode) {\n        await waitForStep();\n      }\n    };\n  }\n\n  // Create heap instance\n  let heap = new Heap(true);\n  heap.onStep(makeVisualizer(heap));\n\n  // UI wiring\n  function refreshTitle(){\n    const isMin = typeSel.value === 'min';\n    document.getElementById('title').textContent = (isMin ? 'Min Heap' : 'Max Heap') + ' Visualization';\n    document.getElementById('subtitle').textContent = (isMin ? 'Root is smallest element' : 'Root is largest element');\n  }\n\n  function resetHeap(isMin){\n    heap = new Heap(isMin);\n    heap.onStep(makeVisualizer(heap));\n    renderHeap(heap,{});\n    log('Heap reset to ' + (isMin ? 'Min' : 'Max'));\n    opsInfo.textContent = 'Reset';\n  }\n\n  typeSel.addEventListener('change', () => {\n    const isMin = typeSel.value === 'min';\n    resetHeap(isMin);\n    refreshTitle();\n  });\n\n  insertBtn.addEventListener('click', async () => {\n    const val = Number(valueInput.value);\n    if (!Number.isFinite(val)) {\n      alert('Please enter a valid number.');\n      return;\n    }\n    log('Inserting ' + val);\n    await heap.insert(val);\n    renderHeap(heap,{});\n    opsInfo.textContent = 'Inserted ' + val;\n  });\n\n  extractBtn.addEventListener('click', async () => {\n    if (heap.size()===0){\n      log('Extract attempted on empty heap');\n      return;\n    }\n    log('Extract root -> ' + heap.peek());\n    const root = await heap.extract();\n    renderHeap(heap,{});\n    opsInfo.textContent = 'Extracted ' + root;\n  });\n\n  peekBtn.addEventListener('click', () => {\n    const p = heap.peek();\n    log('Peek: ' + (p===null? 'null' : p));\n    opsInfo.textContent = 'Peek ' + (p===null? 'null' : p);\n  });\n\n  clearBtn.addEventListener('click', () => {\n    resetHeap(typeSel.value === 'min');\n    renderHeap(heap,{});\n  });\n\n  buildBtn.addEventListener('click', async () => {\n    const txt = listInput.value.trim();\n    if (!txt) {\n      alert('Please paste a comma-separated list like: 5,3,8,1,9');\n      return;\n    }\n    const parts = txt.split(',').map(s => s.trim()).filter(Boolean).map(Number);\n    if (parts.some(x => !Number.isFinite(x))){\n      alert('Invalid list: ensure all items are numbers.');\n      return;\n    }\n    // limit size to avoid overflow visuals\n    if (parts.length > 60){\n      if (!confirm('Large list >60 items. This may be slow to visualize. Proceed?')) return;\n    }\n    log('Building heap from array: ' + parts.join(', '));\n    await heap.buildFromArray(parts);\n    renderHeap(heap,{});\n    opsInfo.textContent = 'Built from array';\n  });\n\n  randBtn.addEventListener('click', async () => {\n    const n = Math.min(30, Math.max(5, Math.floor(Math.random()*20)+5));\n    const arr = Array.from({length:n}, () => Math.floor(Math.random()*99)+1);\n    listInput.value = arr.join(',');\n    log('Generated random array ('+n+' items)');\n    await heap.buildFromArray(arr);\n    renderHeap(heap,{});\n    opsInfo.textContent = 'Random build';\n  });\n\n  heapSortBtn.addEventListener('click', () => {\n    if (heap.size()===0){\n      alert('Heap empty');\n      return;\n    }\n    const sorted = heap.heapSortArray();\n    // For min heap, repeated extracts produce ascending order; for max heap descending.\n    log('Heap sort result: ' + sorted.join(', '));\n    alert('Heap sort result:\\n' + sorted.join(', '));\n    opsInfo.textContent = 'Heap sorted (see log)';\n  });\n\n  visualSortBtn.addEventListener('click', async () => {\n    if (heap.size()===0){\n      alert('Heap empty');\n      return;\n    }\n    // Visualize extracting repeatedly\n    log('Visual heap sort starting...');\n    const copy = new Heap(heap.isMin);\n    copy.data = heap.data.slice();\n    copy.onStep(async (t,i,j,snap) => {\n      // reuse global visualizer but operate on displayed heap for clarity\n      const ms = parseInt(speedRange.value,10) || 360;\n      // We'll animate swaps on the displayed heap as we perform extracts on the copy,\n      // but show the array of extracted elements separately.\n      return; // simplified: do non-animated sort but show progress\n    });\n\n    const out = [];\n    while(copy.size()){\n      out.push(copy.data[0]);\n      const last = copy.data.pop();\n      if (copy.size() > 0){\n        copy.data[0] = last;\n        // sink down\n        let i = 0;\n        while(true){\n          const left = 2*i + 1;\n          const right = left + 1;\n          let candidate = i;\n          if (left < copy.size() && copy.cmp(copy.data[left], copy.data[candidate])) candidate = left;\n          if (right < copy.size() && copy.cmp(copy.data[right], copy.data[candidate])) candidate = right;\n          if (candidate !== i){\n            [copy.data[i], copy.data[candidate]] = [copy.data[candidate], copy.data[i]];\n            i = candidate;\n          } else break;\n        }\n      }\n    }\n    log('Heap sort result: ' + out.join(', '));\n    alert('Heap sort result:\\n' + out.join(', '));\n    opsInfo.textContent = 'Visual sort done (non-animated)';\n  });\n\n  // Initial render\n  renderHeap(heap,{});\n  refreshTitle();\n  log('Ready — select min or max and try operations.');\n\n  // Allow user to proceed next step by clicking the Step Mode button (when in stepMode)\n  // We'll make the Step Mode button also act as a \"Next\" when in stepMode:\n  stepBtn.addEventListener('click', () => {\n    if (stepMode) {\n      // entering step mode; label indicates on. User will toggle off to resume continuous.\n      // But we also allow clicking while in mode to release one step:\n      if (pendingStepResolve) {\n        pendingStepResolve();\n        pendingStepResolve = null;\n      }\n    } else {\n      // leaving step mode resume others\n      if (pendingStepResolve) {\n        pendingStepResolve();\n        pendingStepResolve = null;\n      }\n    }\n  });\n\n  // Extra: allow clicking on array box to remove that item (for experimentation)\n  arrayView.addEventListener('click', async (ev) => {\n    const boxes = [...arrayView.children];\n    const idx = boxes.indexOf(ev.target.closest('.box'));\n    if (idx >=0){\n      if (!confirm('Remove element at index '+idx+' (value '+heap.data[idx]+')?')) return;\n      // Remove and rebuild\n      heap.data.splice(idx,1);\n      renderHeap(heap,{});\n      log('Removed element at index ' + idx);\n    }\n  });\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap (Min/Max)"
    }
  ],
  "topic": "Heap (Min/Max)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}