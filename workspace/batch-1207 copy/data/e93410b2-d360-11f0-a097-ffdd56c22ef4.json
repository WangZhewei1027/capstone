{
  "id": "e93410b2-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:31.724Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Breadth-First Search (BFS) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#111;\n      --panel:#0f1720;\n      --muted:#94a3b8;\n      --accent:#38bdf8;\n      --success:#4ade80;\n      --danger:#fb7185;\n      --wall:#111827;\n      --cell-size:26px;\n    }\n    *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;}\n    html,body{height:100%; margin:0; background:linear-gradient(180deg,#071023 0%, #00121a 100%); color:#e6eef6;}\n    .container{display:grid; grid-template-columns: 720px 1fr; gap:18px; padding:18px; max-width:1200px; margin:18px auto;}\n    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:12px; border-radius:8px;}\n    .header{display:flex; gap:12px; align-items:center; margin-bottom:8px;}\n    h1{font-size:18px; margin:0;}\n    .controls{display:flex; gap:6px; flex-wrap:wrap; align-items:center;}\n    button{background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--muted); padding:8px 10px; border-radius:6px; cursor:pointer;}\n    button.primary{background:var(--accent); color:#022; border:0;}\n    button.warn{background:var(--danger); color:#fff; border:0;}\n    button.success{background:var(--success); color:#022; border:0;}\n    button:active{transform:translateY(1px);}\n    .small{font-size:13px; color:var(--muted);}\n    .grid-wrap{display:flex; gap:12px;}\n    .grid{display:grid; grid-template-rows: repeat(var(--rows), var(--cell-size)); grid-template-columns: repeat(var(--cols), var(--cell-size)); gap:2px; background:transparent; padding:8px; border-radius:8px;}\n    .cell{width:var(--cell-size); height:var(--cell-size); border-radius:4px; background:rgba(255,255,255,0.02); display:flex; align-items:center; justify-content:center; font-size:11px; color:transparent; cursor:pointer; user-select:none;}\n    .cell.wall{background:var(--wall); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);}\n    .cell.start{background:linear-gradient(180deg,#16a34a,#059669); color:#032; font-weight:700;}\n    .cell.target{background:linear-gradient(180deg,#ef4444,#dc2626); color:#420000; font-weight:700;}\n    .cell.frontier{background:linear-gradient(180deg,#60a5fa,#3b82f6); color:#042; box-shadow:0 0 6px rgba(59,130,246,0.35);}\n    .cell.visited{background:linear-gradient(180deg,#c7d2fe,#a78bfa); color:#042;}\n    .cell.current{background:linear-gradient(180deg,#fb923c,#f97316); color:#2b0500; box-shadow:0 0 8px rgba(249,115,22,0.4);}\n    .cell.path{background:linear-gradient(180deg,#fde68a,#f59e0b); color:#4b2300; border:1px solid rgba(0,0,0,0.2);}\n    .legend{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:8px;}\n    .legend .item{display:flex; gap:6px; align-items:center; color:var(--muted);}\n    .swatch{width:18px; height:18px; border-radius:4px; border:1px solid rgba(255,255,255,0.03);}\n    .right-col{display:flex; flex-direction:column; gap:12px;}\n    textarea{width:100%; height:200px; background:transparent; color:var(--muted); border:1px dashed rgba(255,255,255,0.04); padding:8px; border-radius:6px; resize:vertical;}\n    .status{font-size:13px; color:var(--muted);}\n    .queue-view{display:flex; flex-wrap:wrap; gap:6px; padding:8px; background:rgba(255,255,255,0.02); border-radius:6px; min-height:36px;}\n    .q-item{padding:6px 8px; border-radius:6px; background:rgba(255,255,255,0.03); font-size:12px;}\n    .controls-row{display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap;}\n    .settings{display:flex; gap:8px; align-items:center; color:var(--muted); flex-wrap:wrap;}\n    label{font-size:13px; color:var(--muted);}\n    input[type=range]{width:140px;}\n    .footer{font-size:12px; color:var(--muted); margin-top:6px;}\n    .hint{font-size:13px; color:var(--muted); margin-top:8px;}\n    .muted-box{background:rgba(255,255,255,0.01); padding:8px; border-radius:6px; border:1px solid rgba(255,255,255,0.02); color:var(--muted);}\n    @media (max-width:1000px){\n      .container{grid-template-columns: 1fr; padding:12px;}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"card\">\n      <div class=\"header\">\n        <h1>Breadth-First Search (BFS) — Visualizer</h1>\n        <div class=\"small\">Unweighted shortest path on a grid (4-neighbors)</div>\n      </div>\n\n      <div class=\"controls-row\">\n        <div class=\"controls\">\n          <button id=\"runBtn\" class=\"primary\">Run</button>\n          <button id=\"stepBtn\">Step</button>\n          <button id=\"pauseBtn\">Pause</button>\n          <button id=\"resetBtn\">Reset</button>\n          <button id=\"clearWallsBtn\">Clear Walls</button>\n          <button id=\"randomWallsBtn\">Random Walls</button>\n        </div>\n\n        <div style=\"margin-left:auto;\" class=\"settings\">\n          <label>Speed</label>\n          <input id=\"speedRange\" type=\"range\" min=\"10\" max=\"800\" value=\"120\" />\n          <label id=\"speedLabel\" class=\"small\">120 ms</label>\n          <label>Rows</label>\n          <input id=\"rowsInput\" type=\"number\" min=\"6\" max=\"40\" value=\"20\" style=\"width:56px;padding:6px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)\"/>\n          <label>Cols</label>\n          <input id=\"colsInput\" type=\"number\" min=\"6\" max=\"60\" value=\"28\" style=\"width:56px;padding:6px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)\"/>\n          <button id=\"resizeBtn\">Resize Grid</button>\n        </div>\n      </div>\n\n      <div class=\"grid-wrap\">\n        <div>\n          <div id=\"grid\" class=\"grid\" style=\"--rows:20; --cols:28;\"></div>\n\n          <div class=\"legend\">\n            <div class=\"item\"><div class=\"swatch start\"></div> start</div>\n            <div class=\"item\"><div class=\"swatch target\"></div> target</div>\n            <div class=\"item\"><div class=\"swatch frontier\"></div> frontier (queue)</div>\n            <div class=\"item\"><div class=\"swatch visited\"></div> visited</div>\n            <div class=\"item\"><div class=\"swatch path\"></div> final path</div>\n            <div class=\"item\"><div class=\"swatch wall\"></div> wall</div>\n          </div>\n\n          <div class=\"hint muted-box\">\n            Click a cell to toggle a wall. Shift+Click a cell to set the start. Ctrl/Command+Click to set the target.\n            <div style=\"margin-top:6px\">When running: BFS explores level-by-level. Once the target is found, BFS reconstructs the shortest path using parent pointers.</div>\n          </div>\n        </div>\n\n        <div class=\"right-col\">\n          <div class=\"card\" style=\"padding:10px;\">\n            <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n              <div style=\"font-weight:600\">Status</div>\n              <div id=\"counts\" class=\"small\">Visited: 0 • Queue: 0</div>\n            </div>\n            <div style=\"margin-top:8px;\">\n              <div class=\"status\" id=\"statusText\">Idle — set walls, start and target then Run.</div>\n              <div style=\"margin-top:8px\">\n                <div style=\"font-weight:600;margin-bottom:6px\">Queue (front at left)</div>\n                <div id=\"queue\" class=\"queue-view\"></div>\n              </div>\n            </div>\n            <div style=\"margin-top:8px;\">\n              <button id=\"reconstructBtn\" class=\"success\">Show Path (if found)</button>\n            </div>\n          </div>\n\n          <div class=\"card\">\n            <div style=\"font-weight:700;margin-bottom:6px\">Pseudocode</div>\n            <textarea readonly rows=\"12\">\nBFS(start):\n  queue ← empty queue\n  enqueue start\n  visited[start] ← true\n  parent[start] ← null\n\n  while queue not empty:\n    node ← dequeue\n    if node is target: break\n    for each neighbor of node:\n      if neighbor not visited and not a wall:\n        visited[neighbor] ← true\n        parent[neighbor] ← node\n        enqueue neighbor\n\n  reconstruct path by following parent pointers from target to start\n            </textarea>\n          </div>\n\n          <div class=\"card\">\n            <div style=\"font-weight:700;margin-bottom:6px\">Tips</div>\n            <ul style=\"margin:0;color:var(--muted);padding-left:16px\">\n              <li>Use walls to create obstacles and see how BFS navigates.</li>\n              <li>BFS guarantees the shortest path (fewest steps) on an unweighted grid.</li>\n              <li>Try mazes or random walls and adjust speed.</li>\n              <li>Step mode lets you advance one expansion at a time.</li>\n            </ul>\n          </div>\n\n          <div class=\"card\">\n            <div style=\"font-weight:700;margin-bottom:6px\">Controls Reference</div>\n            <div class=\"small\">Run/Pause/Step — control animation. Reset — clear visited/frontier/path but keep walls. Clear Walls — remove all walls. Random — add random obstacles. Resize grid to change dimensions.</div>\n          </div>\n\n        </div>\n      </div>\n\n    </div>\n  </div>\n\n  <script>\n    // BFS Visualizer\n    (function(){\n      // DOM elements\n      const gridEl = document.getElementById('grid');\n      const runBtn = document.getElementById('runBtn');\n      const pauseBtn = document.getElementById('pauseBtn');\n      const stepBtn = document.getElementById('stepBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const clearWallsBtn = document.getElementById('clearWallsBtn');\n      const randomWallsBtn = document.getElementById('randomWallsBtn');\n      const queueEl = document.getElementById('queue');\n      const statusText = document.getElementById('statusText');\n      const countsEl = document.getElementById('counts');\n      const reconstructBtn = document.getElementById('reconstructBtn');\n      const speedRange = document.getElementById('speedRange');\n      const speedLabel = document.getElementById('speedLabel');\n      const rowsInput = document.getElementById('rowsInput');\n      const colsInput = document.getElementById('colsInput');\n      const resizeBtn = document.getElementById('resizeBtn');\n\n      // Settings\n      let rows = parseInt(rowsInput.value,10) || 20;\n      let cols = parseInt(colsInput.value,10) || 28;\n      const defaultStart = {r: Math.floor(rows/2), c: Math.floor(cols/4)};\n      const defaultTarget = {r: Math.floor(rows/2), c: Math.floor(cols*3/4)};\n\n      // State\n      let start = {...defaultStart};\n      let target = {...defaultTarget};\n      let cells = []; // array of elements\n      let grid = []; // metadata objects {wall, visited, parent}\n      let running = false;\n      let paused = false;\n      let timer = null;\n      let delay = parseInt(speedRange.value,10);\n      let queue = [];\n      let visitedCount = 0;\n      let found = false;\n\n      // Initialize grid\n      function initGrid() {\n        // clamp rows/cols\n        rows = Math.max(6, Math.min(40, parseInt(rowsInput.value,10) || 20));\n        cols = Math.max(6, Math.min(60, parseInt(colsInput.value,10) || 28));\n        rowsInput.value = rows; colsInput.value = cols;\n\n        gridEl.style.setProperty('--rows', rows);\n        gridEl.style.setProperty('--cols', cols);\n\n        gridEl.innerHTML = '';\n        cells = new Array(rows*cols);\n        grid = new Array(rows);\n        for (let r=0;r<rows;r++){\n          grid[r] = new Array(cols);\n          for (let c=0;c<cols;c++){\n            const idx = r*cols + c;\n            const div = document.createElement('div');\n            div.className = 'cell';\n            div.dataset.r = r;\n            div.dataset.c = c;\n            div.title = `(${r},${c})`;\n            // events\n            div.addEventListener('click', onCellClick);\n            div.addEventListener('contextmenu', e => e.preventDefault());\n            gridEl.appendChild(div);\n            cells[idx] = div;\n            grid[r][c] = {wall:false, visited:false, parent:null};\n          }\n        }\n        // reset start/target to reasonable positions if out of bounds\n        if (start.r >= rows || start.c >= cols) start = {...defaultStart, r: Math.floor(rows/2), c: Math.floor(cols/4)};\n        if (target.r >= rows || target.c >= cols) target = {...defaultTarget, r: Math.floor(rows/2), c: Math.floor(cols*3/4)};\n        markSpecials();\n        resetSearch(true);\n      }\n\n      function cellIndex(r,c){ return r*cols + c; }\n\n      function markSpecials(){\n        // clear special classes first\n        for (let i=0;i<cells.length;i++){\n          cells[i].classList.remove('start','target');\n        }\n        cells[cellIndex(start.r,start.c)].classList.add('start');\n        cells[cellIndex(target.r,target.c)].classList.add('target');\n      }\n\n      // click handler: toggle wall / set start / set target\n      function onCellClick(e){\n        const r = parseInt(this.dataset.r,10);\n        const c = parseInt(this.dataset.c,10);\n        if (e.shiftKey) {\n          // set start\n          if (!grid[r][c].wall && !(r===target.r && c===target.c)) {\n            start = {r,c};\n            markSpecials();\n            resetSearch(true);\n          }\n          return;\n        }\n        if (e.ctrlKey || e.metaKey){\n          // set target\n          if (!grid[r][c].wall && !(r===start.r && c===start.c)) {\n            target = {r,c};\n            markSpecials();\n            resetSearch(true);\n          }\n          return;\n        }\n        // toggle wall (do not allow placing wall on start/target)\n        if ((r===start.r && c===start.c) || (r===target.r && c===target.c)) return;\n        grid[r][c].wall = !grid[r][c].wall;\n        updateCellVisual(r,c);\n        resetSearch(true);\n      }\n\n      function updateCellVisual(r,c){\n        const el = cells[cellIndex(r,c)];\n        el.classList.toggle('wall', grid[r][c].wall);\n        // remove search-related classes if wall\n        if (grid[r][c].wall){\n          el.classList.remove('frontier','visited','current','path');\n        }\n      }\n\n      // BFS implementation as generator-like stepper\n      function resetSearch(fullClear){\n        stopRunning();\n        // clear visited/parent/path/frontier but keep walls (unless fullClear also clears walls)\n        if (fullClear === true){\n          for (let r=0;r<rows;r++){\n            for (let c=0;c<cols;c++){\n              grid[r][c].visited = false;\n              grid[r][c].parent = null;\n              // if fullClear is true but we want to keep walls on Reset? Here reset preserves walls unless Clear Walls pressed.\n              // We'll keep walls. So no action to change wall flag.\n              const el = cells[cellIndex(r,c)];\n              el.classList.remove('frontier','visited','current','path');\n            }\n          }\n        }\n        queue = [];\n        visitedCount = 0;\n        found = false;\n        updateCounts();\n        queueEl.innerHTML = '';\n        statusText.textContent = 'Idle — ready';\n      }\n\n      function clearWalls(){\n        for (let r=0;r<rows;r++){\n          for (let c=0;c<cols;c++){\n            grid[r][c].wall = false;\n            updateCellVisual(r,c);\n          }\n        }\n        resetSearch(true);\n      }\n\n      function randomWalls(prob=0.25){\n        for (let r=0;r<rows;r++){\n          for (let c=0;c<cols;c++){\n            // avoid start and target\n            if ((r===start.r && c===start.c) || (r===target.r && c===target.c)) { grid[r][c].wall = false; continue;}\n            grid[r][c].wall = Math.random() < prob;\n            updateCellVisual(r,c);\n          }\n        }\n        resetSearch(true);\n      }\n\n      // BFS neighbor generator (4-neighbors)\n      function neighbors(r,c){\n        const dirs = [[-1,0],[1,0],[0,-1],[0,1]];\n        for (const [dr,dc] of dirs){\n          const nr = r+dr, nc = c+dc;\n          if (nr>=0 && nr<rows && nc>=0 && nc<cols) yieldNeighbor(nr,nc);\n        }\n      }\n      function* neighborGen(r,c){\n        const dirs = [[-1,0],[1,0],[0,-1],[0,1]];\n        for (const [dr,dc] of dirs){\n          const nr = r+dr, nc = c+dc;\n          if (nr>=0 && nr<rows && nc>=0 && nc<cols) yield {r:nr,c:nc};\n        }\n      }\n\n      // Run BFS: we will implement it as a step function that does one \"dequeue\" per step\n      function startBFS(){\n        if (running) return;\n        // prepare\n        resetVisitedClasses();\n        queue = [];\n        visitedCount = 0;\n        found = false;\n        // mark start visited and enqueue\n        grid[start.r][start.c].visited = true;\n        grid[start.r][start.c].parent = null;\n        queue.push({r:start.r,c:start.c});\n        updateCellClass(start.r,start.c,'frontier');\n        updateQueueView();\n        updateCounts();\n        running = true;\n        paused = false;\n        statusText.textContent = 'Running BFS...';\n        scheduleStep();\n      }\n\n      // Step of BFS: process one queue pop\n      function bfsStep(){\n        if (!running) return;\n        if (queue.length === 0){\n          statusText.textContent = 'Finished — target not reachable';\n          running = false;\n          updateQueueView();\n          return;\n        }\n        // dequeue\n        const node = queue.shift();\n        updateQueueView();\n        const {r,c} = node;\n        // mark as current for a moment\n        updateCellClass(r,c,'current');\n        // check if target\n        if (r===target.r && c===target.c){\n          found = true;\n          statusText.textContent = `Target found! Distance: ${reconstructDistance()}`;\n          running = false;\n          // mark path\n          reconstructPathVisual();\n          updateCounts();\n          return;\n        }\n        // expand neighbors\n        for (const nb of neighborGen(r,c)){\n          const nr = nb.r, nc = nb.c;\n          if (grid[nr][nc].wall) continue;\n          if (!grid[nr][nc].visited){\n            grid[nr][nc].visited = true;\n            grid[nr][nc].parent = {r,c};\n            queue.push({r:nr,c:nc});\n            updateCellClass(nr,nc,'frontier');\n            visitedCount++;\n          }\n        }\n        // mark node as visited (done)\n        updateCellClass(r,c,'visited',true);\n        updateCounts();\n        // schedule next if still running and not paused\n        if (running && !paused) scheduleStep();\n      }\n\n      function scheduleStep(){\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n          bfsStep();\n        }, delay);\n      }\n\n      function stopRunning(){\n        running = false;\n        paused = false;\n        clearTimeout(timer);\n      }\n\n      function resetVisitedClasses(){\n        for (let r=0;r<rows;r++){\n          for (let c=0;c<cols;c++){\n            grid[r][c].visited = false;\n            grid[r][c].parent = null;\n            const el = cells[cellIndex(r,c)];\n            el.classList.remove('frontier','visited','current','path');\n            if (grid[r][c].wall) el.classList.add('wall'); else el.classList.remove('wall');\n          }\n        }\n        markSpecials();\n      }\n\n      function updateCellClass(r,c,cls,removeFrontier=false){\n        const el = cells[cellIndex(r,c)];\n        // clear 'current' / 'frontier' if making visited or path\n        if (cls === 'current'){\n          el.classList.remove('frontier','visited','path');\n          el.classList.add('current');\n        } else if (cls === 'visited'){\n          el.classList.remove('current','frontier');\n          if (!el.classList.contains('start') && !el.classList.contains('target'))\n            el.classList.add('visited');\n        } else if (cls === 'frontier'){\n          if (!el.classList.contains('start') && !el.classList.contains('target') && !el.classList.contains('wall'))\n            el.classList.add('frontier');\n        } else if (cls === 'path'){\n          el.classList.remove('frontier','visited','current');\n          el.classList.add('path');\n        }\n      }\n\n      function updateQueueView(){\n        queueEl.innerHTML = '';\n        for (let i=0;i<queue.length;i++){\n          const q = queue[i];\n          const div = document.createElement('div');\n          div.className = 'q-item';\n          div.textContent = `(${q.r},${q.c})`;\n          queueEl.appendChild(div);\n        }\n      }\n\n      function updateCounts(){\n        countsEl.textContent = `Visited: ${visitedCount} • Queue: ${queue.length}`;\n      }\n\n      // reconstruct path visual from target via parents\n      function reconstructPathVisual(){\n        if (!found && !grid[target.r][target.c].parent) {\n          statusText.textContent = 'No path to reconstruct';\n          return;\n        }\n        let cur = {r: target.r, c: target.c};\n        const path = [];\n        while (cur){\n          path.push(cur);\n          cur = grid[cur.r][cur.c].parent;\n        }\n        // path includes start...target\n        for (const p of path){\n          // skip start/target styling (but path style on intermediate)\n          if ((p.r===start.r && p.c===start.c) || (p.r===target.r && p.c===target.c)) continue;\n          updateCellClass(p.r,p.c,'path');\n        }\n      }\n\n      function reconstructDistance(){\n        let d = 0;\n        let cur = {r: target.r, c: target.c};\n        while (cur && !(cur.r===start.r && cur.c===start.c)){\n          cur = grid[cur.r][cur.c].parent;\n          d++;\n          if (!cur) return 'unknown';\n        }\n        return d;\n      }\n\n      // Event handlers for control buttons\n      runBtn.addEventListener('click', () => {\n        if (!running){\n          startBFS();\n        } else {\n          // if paused, unpause\n          if (paused){ paused = false; statusText.textContent = 'Running BFS...'; scheduleStep(); }\n        }\n      });\n      pauseBtn.addEventListener('click', () => {\n        if (running){\n          paused = true;\n          clearTimeout(timer);\n          statusText.textContent = 'Paused';\n        }\n      });\n      stepBtn.addEventListener('click', () => {\n        if (!running){\n          // start BFS in single-step mode\n          resetVisitedClasses();\n          queue = [];\n          visitedCount = 0;\n          found = false;\n          grid[start.r][start.c].visited = true;\n          grid[start.r][start.c].parent = null;\n          queue.push({r:start.r,c:start.c});\n          updateCellClass(start.r,start.c,'frontier');\n          updateQueueView();\n          running = true;\n          paused = true;\n        }\n        // do exactly one step\n        bfsStep();\n        // keep paused\n        paused = true;\n        running = running && !found; // if found, running false\n      });\n\n      resetBtn.addEventListener('click', () => {\n        resetSearch(true);\n        statusText.textContent = 'Reset — cleared search state';\n      });\n\n      clearWallsBtn.addEventListener('click', () => {\n        clearWalls();\n        statusText.textContent = 'All walls cleared';\n      });\n\n      randomWallsBtn.addEventListener('click', () => {\n        randomWalls(0.25 + Math.random()*0.25);\n        statusText.textContent = 'Random walls applied';\n      });\n\n      reconstructBtn.addEventListener('click', () => {\n        reconstructPathVisual();\n      });\n\n      speedRange.addEventListener('input', () => {\n        delay = parseInt(speedRange.value,10);\n        speedLabel.textContent = `${delay} ms`;\n      });\n\n      resizeBtn.addEventListener('click', () => {\n        // apply new size\n        initGrid();\n      });\n\n      // keyboard shortcuts\n      document.addEventListener('keydown', (e) => {\n        if (e.key === ' ') { e.preventDefault(); if (running && !paused) { paused=true; statusText.textContent='Paused'; } else runBtn.click(); }\n        if (e.key === 'r') randomWallsBtn.click();\n        if (e.key === 'c') clearWallsBtn.click();\n      });\n\n      // initial setup\n      initGrid();\n\n      // Expose small helpers for debugging in console (optional)\n      window.bfsViz = {\n        startBFS, bfsStep, resetSearch, randomWalls, clearWalls, reconstructPathVisual, getGrid: ()=>grid\n      };\n\n      // Make sure start/target cells are styled distinct in legend swatches (pure cosmetic)\n      (function styleLegend(){\n        const swatches = document.querySelectorAll('.swatch');\n        if (swatches[0]) swatches[0].classList.add('start');\n        if (swatches[1]) swatches[1].classList.add('target');\n        if (swatches[2]) swatches[2].classList.add('frontier');\n        if (swatches[3]) swatches[3].classList.add('visited');\n        if (swatches[4]) swatches[4].classList.add('path');\n        if (swatches[5]) swatches[5].classList.add('wall');\n      })();\n\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}