{
  "id": "e9337471-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:38:46.664Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Priority Queue",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<title>Priority Queue (Binary Heap) Visualizer</title>\n<style>\n  :root{\n    --bg:#0f1724;\n    --panel:#0b1220;\n    --accent:#06b6d4;\n    --muted:#94a3b8;\n    --glass: rgba(255,255,255,0.03);\n    --card:#071028;\n  }\n  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n  body{background:linear-gradient(180deg,#031026 0%, #071426 60%);color:#e6eef6;padding:18px;box-sizing:border-box;}\n  .wrap{max-width:1100px;margin:0 auto;display:grid;grid-template-columns:360px 1fr;gap:18px;}\n  .panel{\n    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n    border:1px solid rgba(255,255,255,0.03);\n    padding:14px;border-radius:10px;box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n  }\n  h1{font-size:18px;margin:0 0 10px;color:var(--accent);}\n  label{display:block;color:var(--muted);font-size:13px;margin-top:12px;}\n  .row{display:flex;gap:8px;align-items:center;margin-top:8px;}\n  input[type=\"text\"], input[type=\"number\"], select{\n    background:var(--glass);border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:6px;color:#e6eef6;outline:none;width:100%;\n  }\n  button{\n    background:linear-gradient(90deg,var(--accent),#8b5cf6);\n    border:none;color:#021124;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer;\n  }\n  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);}\n  .small{padding:6px 8px;font-size:13px}\n  .controls{display:flex;flex-direction:column;gap:8px;}\n  .stats{display:flex;gap:8px;align-items:center;margin-top:10px;}\n  .badge{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:999px;color:var(--muted);font-weight:600;}\n  .view{display:flex;flex-direction:column;gap:12px;}\n  .heap-area{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);padding:12px;border-radius:10px;min-height:340px;position:relative;overflow:auto;}\n  .array-view{display:flex;gap:8px;flex-wrap:wrap;align-items:center;padding:10px;background:linear-gradient(90deg, rgba(255,255,255,0.015), transparent);border-radius:8px;}\n  .cell{min-width:72px;padding:8px;border-radius:8px;background:linear-gradient(180deg,#062132,#0b2a3f);border:1px solid rgba(255,255,255,0.03);color:#dff6fb;font-weight:700;display:flex;flex-direction:column;align-items:center;justify-content:center;}\n  .cell .val{font-size:14px}\n  .cell .pri{font-size:12px;color:var(--muted);margin-top:4px}\n  .tree-wrap{position:relative;padding:24px 8px 40px;}\n  .level{display:grid;grid-auto-flow:column;gap:10px;justify-items:center;align-items:start;margin:6px 0}\n  .node{width:86px;height:52px;border-radius:10px;background:linear-gradient(180deg,#08303f,#063046);display:flex;flex-direction:column;align-items:center;justify-content:center;color:#dff6fb;border:1px solid rgba(255,255,255,0.035)}\n  .node .nv{font-weight:700}\n  svg.connector{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;overflow:visible}\n  .log{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;height:120px;overflow:auto;color:var(--muted);font-size:13px}\n  .footer{display:flex;justify-content:space-between;align-items:center;margin-top:8px;color:var(--muted);font-size:13px}\n  .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}\n  .muted{color:var(--muted);font-size:13px}\n  .speed{display:flex;gap:8px;align-items:center}\n  input[type=\"range\"]{width:120px}\n  .help{font-size:13px;color:var(--muted);margin-top:10px}\n  @media (max-width:900px){\n    .wrap{grid-template-columns:1fr; max-width:760px}\n  }\n</style>\n</head>\n<body>\n<div class=\"wrap\">\n  <div class=\"panel\">\n    <h1>Priority Queue — Binary Heap</h1>\n    <div class=\"controls\">\n      <label>Mode</label>\n      <select id=\"mode\">\n        <option value=\"min\">Min-Heap (smallest priority first)</option>\n        <option value=\"max\">Max-Heap (largest priority first)</option>\n      </select>\n\n      <label>Insert item</label>\n      <div class=\"row\">\n        <input id=\"val\" type=\"text\" placeholder=\"Value (string)\" />\n        <input id=\"pri\" type=\"number\" placeholder=\"Priority (number)\" />\n        <button id=\"enqueue\" class=\"small\">Enqueue</button>\n      </div>\n\n      <div class=\"controls-grid\">\n        <button id=\"dequeue\" class=\"small\">Dequeue</button>\n        <button id=\"peek\" class=\"small ghost\">Peek</button>\n        <button id=\"clear\" class=\"small ghost\">Clear</button>\n        <button id=\"random\" class=\"small\">Insert Random</button>\n      </div>\n\n      <label>Find / Modify</label>\n      <div class=\"row\">\n        <input id=\"findVal\" type=\"text\" placeholder=\"Value to find\" />\n        <input id=\"newPri\" type=\"number\" placeholder=\"New priority\" />\n        <button id=\"changePri\" class=\"small\">Change Priority</button>\n      </div>\n      <div class=\"row\">\n        <button id=\"remove\" class=\"small ghost\">Remove by Value</button>\n        <button id=\"bulk\" class=\"small\">Bulk Random (10)</button>\n      </div>\n\n      <label>Animation speed</label>\n      <div class=\"row speed\">\n        <input id=\"speed\" type=\"range\" min=\"50\" max=\"1000\" value=\"300\">\n        <div class=\"muted\" id=\"speedVal\">300ms</div>\n      </div>\n\n      <div class=\"stats\">\n        <div class=\"badge\">Size: <span id=\"size\">0</span></div>\n        <div class=\"badge\">Root: <span id=\"root\">—</span></div>\n      </div>\n\n      <div class=\"help\">\n        This visualizer uses a binary heap array. Each node displays value and priority.\n        Operations animate the swaps that occur during bubble-up / bubble-down.\n      </div>\n    </div>\n  </div>\n\n  <div class=\"panel view\">\n    <div class=\"heap-area\">\n      <div class=\"array-view\" id=\"arrayView\" aria-live=\"polite\"></div>\n      <div class=\"tree-wrap\" id=\"treeWrap\"></div>\n      <svg class=\"connector\" id=\"connector\"></svg>\n    </div>\n\n    <div style=\"display:flex;gap:12px\">\n      <div style=\"flex:1\">\n        <div class=\"log\" id=\"log\"></div>\n      </div>\n      <div style=\"width:180px\">\n        <div class=\"footer\">\n          <div class=\"muted\">Implementation</div>\n        </div>\n        <div style=\"margin-top:8px\">\n          <div class=\"muted\">Binary heap stored in array (0-based). Comparator depends on mode.</div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<script>\n/*\n Priority Queue (Binary Heap) visualizer\n - Supports min and max heap\n - Items: {value: string, priority: number}\n - Animations use recorded swap sequences\n*/\n\nclass PriorityQueue {\n  constructor(comparator){\n    this.data = [];\n    this.compare = comparator; // returns true if a has higher priority than b\n  }\n\n  size(){ return this.data.length; }\n  isEmpty(){ return this.data.length === 0; }\n\n  peek(){ return this.data[0] ?? null; }\n\n  // Enqueue with recording of swaps: returns array of swap pairs (i,j) in order\n  enqueue(item){\n    const steps = [];\n    this.data.push(item);\n    let i = this.data.length - 1;\n    while(i > 0){\n      const p = Math.floor((i-1)/2);\n      if (this.compare(this.data[i], this.data[p])){\n        steps.push([i,p]);\n        this.swap(i,p);\n        i = p;\n      } else break;\n    }\n    return steps;\n  }\n\n  // Dequeue root, returns {item, steps}\n  dequeue(){\n    if(this.isEmpty()) return {item:null, steps:[]};\n    const steps = [];\n    const root = this.data[0];\n    if(this.data.length === 1){\n      this.data.pop();\n      return {item:root, steps};\n    }\n    // move last to root then sink\n    this.data[0] = this.data.pop();\n    let i = 0;\n    while(true){\n      const l = 2*i + 1;\n      const r = 2*i + 2;\n      let best = i;\n      if(l < this.data.length && this.compare(this.data[l], this.data[best])) best = l;\n      if(r < this.data.length && this.compare(this.data[r], this.data[best])) best = r;\n      if(best !== i){\n        steps.push([i,best]);\n        this.swap(i,best);\n        i = best;\n      } else break;\n    }\n    return {item:root, steps};\n  }\n\n  // Find index of first item by value\n  findIndexByValue(value){\n    for(let i=0;i<this.data.length;i++){\n      if(this.data[i].value === value) return i;\n    }\n    return -1;\n  }\n\n  // Change priority of first matching value and reheapify; returns steps (may include up and down)\n  changePriority(value, newPriority){\n    const i = this.findIndexByValue(value);\n    if(i === -1) return {ok:false, steps:[]};\n    const old = this.data[i].priority;\n    this.data[i].priority = newPriority;\n    const steps = [];\n    // if new is higher priority relative to comparator, bubble up; otherwise sink\n    // We'll attempt both: bubble up first, then sink. Record swaps.\n    let idx = i;\n    while(idx > 0){\n      const p = Math.floor((idx-1)/2);\n      if(this.compare(this.data[idx], this.data[p])){\n        steps.push([idx,p]);\n        this.swap(idx,p);\n        idx = p;\n      } else break;\n    }\n    if(idx === i){ // did not move up, try sink\n      idx = i;\n      while(true){\n        const l = 2*idx + 1;\n        const r = 2*idx + 2;\n        let best = idx;\n        if(l < this.data.length && this.compare(this.data[l], this.data[best])) best = l;\n        if(r < this.data.length && this.compare(this.data[r], this.data[best])) best = r;\n        if(best !== idx){\n          steps.push([idx,best]);\n          this.swap(idx,best);\n          idx = best;\n        } else break;\n      }\n    }\n    return {ok:true, steps};\n  }\n\n  removeByValue(value){\n    const i = this.findIndexByValue(value);\n    if(i === -1) return {ok:false, steps:[]};\n    const last = this.data.pop();\n    const steps = [];\n    if(i < this.data.length){\n      this.data[i] = last;\n      // try reheapify\n      let idx = i;\n      while(idx > 0){\n        const p = Math.floor((idx-1)/2);\n        if(this.compare(this.data[idx], this.data[p])){\n          steps.push([idx,p]);\n          this.swap(idx,p);\n          idx = p;\n        } else break;\n      }\n      if(idx === i){\n        while(true){\n          const l = 2*idx + 1;\n          const r = 2*idx + 2;\n          let best = idx;\n          if(l < this.data.length && this.compare(this.data[l], this.data[best])) best = l;\n          if(r < this.data.length && this.compare(this.data[r], this.data[best])) best = r;\n          if(best !== idx){\n            steps.push([idx,best]);\n            this.swap(idx,best);\n            idx = best;\n          } else break;\n        }\n      }\n    }\n    return {ok:true, steps};\n  }\n\n  clear(){ this.data = []; }\n\n  swap(i,j){\n    const t = this.data[i]; this.data[i] = this.data[j]; this.data[j] = t;\n  }\n\n  toArray(){ return this.data.slice(); }\n}\n\n/* ---- UI and Visualization ---- */\n\nconst arrayView = document.getElementById('arrayView');\nconst treeWrap = document.getElementById('treeWrap');\nconst connector = document.getElementById('connector');\nconst logEl = document.getElementById('log');\nconst sizeEl = document.getElementById('size');\nconst rootEl = document.getElementById('root');\n\nconst modeEl = document.getElementById('mode');\nconst valEl = document.getElementById('val');\nconst priEl = document.getElementById('pri');\nconst enqueueBtn = document.getElementById('enqueue');\nconst dequeueBtn = document.getElementById('dequeue');\nconst peekBtn = document.getElementById('peek');\nconst clearBtn = document.getElementById('clear');\nconst randomBtn = document.getElementById('random');\nconst bulkBtn = document.getElementById('bulk');\nconst findValEl = document.getElementById('findVal');\nconst newPriEl = document.getElementById('newPri');\nconst changeBtn = document.getElementById('changePri');\nconst removeBtn = document.getElementById('remove');\nconst speedEl = document.getElementById('speed');\nconst speedVal = document.getElementById('speedVal');\n\nlet pq = null;\nlet animating = false;\n\nfunction makeComparator(mode){\n  if(mode === 'min'){\n    return (a,b) => a.priority < b.priority;\n  } else {\n    return (a,b) => a.priority > b.priority;\n  }\n}\n\nfunction initPQ(){\n  pq = new PriorityQueue(makeComparator(modeEl.value));\n  renderAll();\n  log('Initialized ' + (modeEl.value === 'min' ? 'min-heap' : 'max-heap'));\n}\ninitPQ();\n\nmodeEl.addEventListener('change', ()=>{\n  initPQ();\n});\n\nfunction log(msg){\n  const time = new Date().toLocaleTimeString();\n  logEl.innerHTML = `<div style=\"margin-bottom:6px\">[${time}] ${escapeHtml(msg)}</div>` + logEl.innerHTML;\n}\n\nfunction escapeHtml(s){\n  return (''+s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');\n}\n\nfunction updateStats(){\n  sizeEl.textContent = pq.size();\n  rootEl.textContent = pq.peek() ? `${pq.peek().value} (${pq.peek().priority})` : '—';\n}\n\nfunction renderArray(highlight = []){\n  arrayView.innerHTML = '';\n  pq.toArray().forEach((item, idx) => {\n    const c = document.createElement('div');\n    c.className = 'cell';\n    if(highlight.includes(idx)){\n      c.style.boxShadow = '0 6px 20px rgba(6,182,212,0.12), 0 0 0 3px rgba(6,182,212,0.06) inset';\n      c.style.transform = 'translateY(-4px)';\n    }\n    const v = document.createElement('div'); v.className='val'; v.textContent = item.value;\n    const p = document.createElement('div'); p.className='pri'; p.textContent = 'pri: '+item.priority;\n    c.appendChild(v); c.appendChild(p);\n    arrayView.appendChild(c);\n  });\n  if(pq.size()===0){\n    const emp = document.createElement('div'); emp.className='muted'; emp.textContent='(heap is empty)';\n    arrayView.appendChild(emp);\n  }\n}\n\nfunction buildTreeNodes(){\n  treeWrap.innerHTML = '';\n  const arr = pq.toArray();\n  if(arr.length === 0) return;\n  // Compute levels\n  let level = 0;\n  let index = 0;\n  const nodes = [];\n  while(index < arr.length){\n    const count = Math.min(2**level, arr.length - index);\n    const levelDiv = document.createElement('div');\n    levelDiv.className = 'level';\n    levelDiv.style.gridTemplateColumns = `repeat(${count}, 1fr)`;\n    // create placeholders to keep spacing when level isn't full? We'll just create exactly count nodes.\n    for(let i=0;i<count;i++){\n      const node = document.createElement('div');\n      node.className = 'node';\n      node.dataset.index = index;\n      node.innerHTML = `<div class=\"nv\">${escapeHtml(arr[index].value)}</div><div class=\"pri\" style=\"font-size:12px;color:var(--muted);margin-top:6px\">${arr[index].priority}</div>`;\n      levelDiv.appendChild(node);\n      nodes.push(node);\n      index++;\n    }\n    treeWrap.appendChild(levelDiv);\n    level++;\n  }\n  return nodes;\n}\n\nfunction drawConnectors(nodes){\n  // Clear\n  while (connector.firstChild) connector.removeChild(connector.firstChild);\n  if(!nodes || nodes.length===0) return;\n  // Compute bbox positions for each node\n  const positions = nodes.map(n => {\n    const r = n.getBoundingClientRect();\n    const parentR = treeWrap.getBoundingClientRect();\n    return {\n      x: r.left - parentR.left + r.width/2,\n      y: r.top - parentR.top + r.height/2\n    };\n  });\n  // Draw lines parent->child for binary heap (i => 2i+1 and 2i+2 if exist)\n  const svgNS = \"http://www.w3.org/2000/svg\";\n  for(let i=0;i<nodes.length;i++){\n    const left = 2*i + 1;\n    const right = 2*i + 2;\n    if(left < nodes.length){\n      const p = positions[i], c = positions[left];\n      const line = document.createElementNS(svgNS, 'line');\n      line.setAttribute('x1', p.x); line.setAttribute('y1', p.y + 22);\n      line.setAttribute('x2', c.x); line.setAttribute('y2', c.y - 22);\n      line.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n      line.setAttribute('stroke-width', 1.5);\n      connector.appendChild(line);\n    }\n    if(right < nodes.length){\n      const p = positions[i], c = positions[right];\n      const line = document.createElementNS(svgNS, 'line');\n      line.setAttribute('x1', p.x); line.setAttribute('y1', p.y + 22);\n      line.setAttribute('x2', c.x); line.setAttribute('y2', c.y - 22);\n      line.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n      line.setAttribute('stroke-width', 1.5);\n      connector.appendChild(line);\n    }\n  }\n}\n\nfunction renderAll(highlight=[]){\n  updateStats();\n  renderArray(highlight);\n  // small delay to allow DOM placement then build tree and draw connectors\n  setTimeout(()=>{\n    const nodes = buildTreeNodes();\n    setTimeout(()=>drawConnectors(nodes), 10);\n  }, 10);\n}\n\n/* Animation runner: given steps list of [i,j] swaps, animate them sequentially */\nfunction animateSwaps(steps, finalCallback){\n  if(!steps || steps.length===0){\n    renderAll();\n    if(finalCallback) finalCallback();\n    return;\n  }\n  animating = true;\n  const speed = Number(speedEl.value);\n  let i = 0;\n  const doStep = () => {\n    if(i >= steps.length){\n      animating = false;\n      renderAll();\n      if(finalCallback) finalCallback();\n      return;\n    }\n    const [a,b] = steps[i];\n    // Highlight positions a and b, then swap in the underlying pq.data is already swapped in our implementation\n    renderAll([a,b]);\n    i++;\n    setTimeout(doStep, speed);\n  };\n  // render starting state (first swap already applied in pq methods), show highlights\n  renderAll([steps[0][0], steps[0][1]]);\n  setTimeout(doStep, speed);\n}\n\n/* ---- Button handlers ---- */\n\nenqueueBtn.addEventListener('click', ()=>{\n  if(animating) return;\n  const v = valEl.value.trim() || ('item'+Math.floor(Math.random()*1000));\n  const p = Number(priEl.value);\n  if(isNaN(p)) { log('Priority must be a number'); return; }\n  const steps = pq.enqueue({value:v, priority:p});\n  log(`Enqueued \"${v}\" with priority ${p}`);\n  animateSwaps(steps, ()=>{ renderAll(); });\n  valEl.value=''; priEl.value='';\n});\n\ndequeueBtn.addEventListener('click', ()=>{\n  if(animating) return;\n  if(pq.isEmpty()){ log('Cannot dequeue — queue is empty'); return; }\n  const res = pq.dequeue();\n  log(`Dequeued \"${res.item.value}\" (priority ${res.item.priority})`);\n  animateSwaps(res.steps, ()=>{ renderAll(); });\n});\n\npeekBtn.addEventListener('click', ()=>{\n  const top = pq.peek();\n  if(!top) log('Peek → empty');\n  else log(`Peek → \"${top.value}\" (priority ${top.priority})`);\n});\n\nclearBtn.addEventListener('click', ()=>{\n  if(animating) return;\n  pq.clear();\n  renderAll();\n  log('Cleared heap');\n});\n\nrandomBtn.addEventListener('click', ()=>{\n  if(animating) return;\n  const v = 'v'+Math.floor(Math.random()*999);\n  const p = Math.floor(Math.random()*100);\n  const steps = pq.enqueue({value:v, priority:p});\n  log(`Enqueued random \"${v}\" (${p})`);\n  animateSwaps(steps, ()=>renderAll());\n});\n\nbulkBtn.addEventListener('click', ()=>{\n  if(animating) return;\n  // Insert 10 random items without animation one by one but then animate a short flash\n  const bulkItems = [];\n  for(let i=0;i<10;i++){\n    const v = 'v'+Math.floor(Math.random()*9999);\n    const p = Math.floor(Math.random()*100);\n    const steps = pq.enqueue({value:v, priority:p});\n    bulkItems.push({v,p,steps});\n  }\n  log(`Bulk inserted 10 items`);\n  // show final structure\n  renderAll();\n  // Flash last inserted nodes\n  const lastSteps = bulkItems.length ? bulkItems[bulkItems.length-1].steps : [];\n  animateSwaps(lastSteps, ()=>renderAll());\n});\n\nchangeBtn.addEventListener('click', ()=>{\n  if(animating) return;\n  const val = findValEl.value.trim();\n  const newPri = Number(newPriEl.value);\n  if(!val){ log('Provide a value to find'); return; }\n  if(isNaN(newPri)){ log('New priority must be a number'); return; }\n  const res = pq.changePriority(val, newPri);\n  if(!res.ok){ log(`Value \"${val}\" not found`); return; }\n  log(`Changed priority of \"${val}\" → ${newPri}`);\n  animateSwaps(res.steps, ()=>renderAll());\n});\n\nremoveBtn.addEventListener('click', ()=>{\n  if(animating) return;\n  const val = findValEl.value.trim();\n  if(!val){ log('Provide a value to remove'); return; }\n  const res = pq.removeByValue(val);\n  if(!res.ok){ log(`Value \"${val}\" not found`); return; }\n  log(`Removed \"${val}\"`);\n  animateSwaps(res.steps, ()=>renderAll());\n});\n\nspeedEl.addEventListener('input', ()=>{\n  speedVal.textContent = speedEl.value+'ms';\n});\n\n/* Allow clicking array items to prefill find field */\narrayView.addEventListener('click', (e)=>{\n  const cell = e.target.closest('.cell');\n  if(!cell) return;\n  const idx = Array.from(arrayView.children).indexOf(cell);\n  if(idx >= 0){\n    const item = pq.toArray()[idx];\n    if(item){\n      findValEl.value = item.value;\n      newPriEl.value = item.priority;\n      log(`Selected \"${item.value}\" from array (priority ${item.priority})`);\n    }\n  }\n});\n\n// Initial render\nrenderAll();\nlog('Priority Queue visualizer ready — try inserting items.');\n\n/* Accessibility: keyboard shortcuts */\ndocument.addEventListener('keydown', (e)=>{\n  if(e.key === 'Enter' && document.activeElement === priEl){\n    enqueueBtn.click();\n  }\n});\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Priority Queue"
    }
  ],
  "topic": "Priority Queue",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}