{
  "id": "d79d3ce2-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:59.757Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Bellman-Ford Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    display: flex;\n    height: 100vh;\n    overflow: hidden;\n  }\n  #container {\n    display: flex;\n    flex-direction: row;\n    flex-grow: 1;\n  }\n  #graph-container {\n    flex: 1;\n    background: #f5f5f5;\n    position: relative;\n  }\n  svg {\n    width: 100%;\n    height: 100vh;\n  }\n  #controls {\n    width: 350px;\n    background: #222;\n    color: #eee;\n    padding: 20px;\n    box-sizing: border-box;\n    display: flex;\n    flex-direction: column;\n  }\n  #controls h2 {\n    margin-top: 0;\n    margin-bottom: 15px;\n    text-align: center;\n  }\n  label {\n    font-weight: bold;\n    margin-top: 10px;\n  }\n  textarea {\n    width: 100%;\n    height: 80px;\n    resize: vertical;\n    font-family: monospace;\n    font-size: 14px;\n    margin-top: 5px;\n    box-sizing: border-box;\n  }\n  select, input[type=number] {\n    width: 100%;\n    margin-top: 5px;\n    padding: 5px;\n    box-sizing: border-box;\n    font-size: 14px;\n  }\n  button {\n    margin-top: 15px;\n    padding: 10px;\n    font-size: 16px;\n    cursor: pointer;\n    background: #0b79d0;\n    color: white;\n    border: none;\n    border-radius: 3px;\n  }\n  button:disabled {\n    background: #666;\n    cursor: not-allowed;\n  }\n  #messages {\n    margin-top: 15px;\n    height: 130px;\n    overflow-y: auto;\n    background: #111;\n    border: 1px solid #444;\n    padding: 8px;\n    font-family: monospace;\n    font-size: 13px;\n    white-space: pre-wrap;\n  }\n  #distances {\n    margin-top: 15px;\n    background: #111;\n    border: 1px solid #444;\n    padding: 8px;\n    font-size: 14px;\n    min-height: 80px;\n    overflow-y: auto;\n    font-family: monospace;\n  }\n  .node circle {\n    fill: #3498db;\n    stroke: #2980b9;\n    stroke-width: 3px;\n    cursor: pointer;\n    transition: fill 0.3s;\n  }\n  .node text {\n    fill: white;\n    font-weight: bold;\n    pointer-events: none;\n    user-select: none;\n  }\n  .edge path {\n    stroke: #444;\n    stroke-width: 2px;\n    fill: none;\n    marker-end: url(#arrowhead);\n    transition: stroke 0.3s, stroke-width 0.3s;\n  }\n  .edge text {\n    fill: #222;\n    font-weight: bold;\n    font-size: 12px;\n    user-select: none;\n  }\n  .edge.highlight path {\n    stroke: #e74c3c;\n    stroke-width: 4px;\n  }\n  .node.start circle {\n    fill: #27ae60;\n    stroke: #1f8c4a;\n  }\n  .node.relaxed circle {\n    fill: #f39c12;\n    stroke: #d67e00;\n  }\n  .negative-cycle {\n    color: #e74c3c;\n    font-weight: bold;\n    font-size: 16px;\n    text-align: center;\n    margin-top: 15px;\n  }\n  #step-info {\n    margin-top: 10px;\n    font-family: monospace;\n    background: #222;\n    padding: 6px;\n    border-radius: 3px;\n    font-size: 13px;\n    min-height: 60px;\n    overflow-y: auto;\n  }\n  footer {\n    position: absolute;\n    bottom: 5px;\n    left: 20px;\n    color: #999;\n    font-size: 12px;\n  }\n</style>\n</head>\n<body>\n<div id=\"container\">\n  <div id=\"graph-container\">\n    <svg id=\"graph\"></svg>\n    <footer>Bellman-Ford Algorithm Visualization - Click nodes to select start vertex before running.</footer>\n  </div>\n  <div id=\"controls\">\n    <h2>Bellman-Ford Algorithm</h2>\n    <label for=\"vertex-count\">Number of Vertices (2-20):</label>\n    <input type=\"number\" id=\"vertex-count\" min=\"2\" max=\"20\" value=\"5\" />\n    <label for=\"edge-list\">Edges (one per line: from to weight):</label>\n    <textarea id=\"edge-list\" placeholder=\"Example:\n0 1 6\n0 2 7\n1 2 8\n1 3 5\n1 4 -4\n2 3 -3\n2 4 9\n3 1 -2\n4 0 2\n4 3 7\"></textarea>\n    <label for=\"start-vertex\">Start Vertex:</label>\n    <select id=\"start-vertex\"></select>\n    <button id=\"btn-generate\">Generate Graph</button>\n    <button id=\"btn-start\" disabled>Run Bellman-Ford Step-by-Step</button>\n    <button id=\"btn-next\" disabled>Next Step</button>\n    <button id=\"btn-reset\" disabled>Reset</button>\n    <div id=\"messages\"></div>\n    <div id=\"distances\"></div>\n    <div id=\"step-info\"></div>\n  </div>\n</div>\n\n<script>\n(() => {\n  // HTML Elements\n  const svg = document.getElementById(\"graph\");\n  const vertexCountInput = document.getElementById(\"vertex-count\");\n  const edgeListInput = document.getElementById(\"edge-list\");\n  const startVertexSelect = document.getElementById(\"start-vertex\");\n  const btnGenerate = document.getElementById(\"btn-generate\");\n  const btnStart = document.getElementById(\"btn-start\");\n  const btnNext = document.getElementById(\"btn-next\");\n  const btnReset = document.getElementById(\"btn-reset\");\n  const messagesDiv = document.getElementById(\"messages\");\n  const distancesDiv = document.getElementById(\"distances\");\n  const stepInfoDiv = document.getElementById(\"step-info\");\n\n  let graph = { vertices: 0, edges: [] };\n  let nodePositions = [];\n  let nodeElements = [];\n  let edgeElements = [];\n  let distances = [];\n  let predecessors = [];\n  let startVertex = 0;\n  let iteration = 0;\n  let stepEdgeIndex = 0;\n  let isRunning = false;\n  let negativeCycleDetected = false;\n  let relaxationLogs = [];\n  // For animation step tracking:\n  // We'll run V-1 iterations, each iteration tries all edges in order\n  // Finally one extra iteration for negative cycle detection\n\n  // Utility: Clear SVG\n  function clearSVG() {\n    while (svg.lastChild) svg.removeChild(svg.lastChild);\n  }\n\n  // Draw arrowhead marker for directed edges\n  function drawArrowMarker() {\n    const markerId = \"arrowhead\";\n    // Check if marker already defined\n    if (svg.querySelector(\"#\" + markerId)) return;\n\n    const marker = document.createElementNS(\"http://www.w3.org/2000/svg\", \"marker\");\n    marker.setAttribute(\"id\", markerId);\n    marker.setAttribute(\"markerWidth\", \"10\");\n    marker.setAttribute(\"markerHeight\", \"7\");\n    marker.setAttribute(\"refX\", \"10\");\n    marker.setAttribute(\"refY\", \"3.5\");\n    marker.setAttribute(\"orient\", \"auto\");\n    marker.setAttribute(\"fill\", \"#444\");\n\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    path.setAttribute(\"d\", \"M0,0 L10,3.5 L0,7 L2,3.5 z\");\n    marker.appendChild(path);\n\n    const defs = document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n    defs.appendChild(marker);\n    svg.appendChild(defs);\n  }\n\n  // Calculate positions for vertices on a circle\n  function calculatePositions(vertexCount, width = svg.clientWidth, height = svg.clientHeight) {\n    const radius = Math.min(width, height) / 2.5;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const positions = [];\n    for (let i = 0; i < vertexCount; i++) {\n      const angle = (2 * Math.PI * i) / vertexCount - Math.PI / 2;\n      positions.push({\n        x: centerX + radius * Math.cos(angle),\n        y: centerY + radius * Math.sin(angle)\n      });\n    }\n    return positions;\n  }\n\n  // Draw the whole graph\n  function drawGraph() {\n    clearSVG();\n    drawArrowMarker();\n\n    // Draw edges first so they appear below nodes\n    edgeElements = [];\n    graph.edges.forEach((edge, idx) => {\n      const fromPos = nodePositions[edge.from];\n      const toPos = nodePositions[edge.to];\n      const edgeGroup = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      edgeGroup.classList.add(\"edge\");\n      edgeGroup.setAttribute(\"data-edge-index\", idx);\n\n      // Create curved path if from == to (self loop) or if multiple edges between same nodes\n      // For simplicity, we'll draw straight lines for all edges here\n      // But to avoid overlap, we adjust edges if there are edges in both directions between two nodes\n\n      let dx = toPos.x - fromPos.x;\n      let dy = toPos.y - fromPos.y;\n      let dist = Math.sqrt(dx*dx + dy*dy);\n      if (dist === 0) dist = 1; // avoid div zero\n\n      // Normalize direction vector\n      const nx = dx / dist;\n      const ny = dy / dist;\n\n      // Arrow line start/end adjusted so it doesn't touch node circle centers but node edge:\n      // nodes radius: 20\n      const r = 20;\n\n      // Adjusted points\n      let startX = fromPos.x + nx * r;\n      let startY = fromPos.y + ny * r;\n      let endX = toPos.x - nx * r;\n      let endY = toPos.y - ny * r;\n\n      // To avoid arrow overlap for edges in opposite directions, shift slightly\n      const isOpposite = graph.edges.some((e2, i2) => \n        i2 !== idx &&\n        e2.from === edge.to &&\n        e2.to === edge.from\n      );\n      if (isOpposite) {\n        // Shift perpendicular by 8 pixels\n        const perpX = -ny;\n        const perpY = nx;\n        startX += perpX * 8;\n        startY += perpY * 8;\n        endX += perpX * 8;\n        endY += perpY * 8;\n      }\n\n      const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n      path.setAttribute(\"d\", `M${startX},${startY} L${endX},${endY}`);\n      path.setAttribute(\"marker-end\", \"url(#arrowhead)\");\n      edgeGroup.appendChild(path);\n\n      // Label the edge weight - position it at middle point plus slight orthogonal offset\n      const labelX = (startX + endX) / 2;\n      const labelY = (startY + endY) / 2;\n\n      // Offset label orthogonal by 12px\n      const labelOffset = 12;\n      const labelPosX = labelX - ny * labelOffset;\n      const labelPosY = labelY + nx * labelOffset;\n\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute(\"x\", labelPosX);\n      text.setAttribute(\"y\", labelPosY);\n      text.textContent = edge.weight;\n      edgeGroup.appendChild(text);\n\n      svg.appendChild(edgeGroup);\n      edgeElements.push(edgeGroup);\n    });\n\n    // Draw nodes\n    nodeElements = [];\n    graph.vertices = parseInt(graph.vertices);\n    for (let i = 0; i < graph.vertices; i++) {\n      const pos = nodePositions[i];\n      const group = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      group.classList.add(\"node\");\n      group.setAttribute(\"data-node\", i);\n      group.style.cursor = \"pointer\";\n\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      circle.setAttribute(\"cx\", pos.x);\n      circle.setAttribute(\"cy\", pos.y);\n      circle.setAttribute(\"r\", 20);\n      group.appendChild(circle);\n\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute(\"x\", pos.x);\n      text.setAttribute(\"y\", pos.y + 6);\n      text.setAttribute(\"text-anchor\", \"middle\");\n      text.textContent = i;\n      group.appendChild(text);\n\n      svg.appendChild(group);\n      nodeElements.push(group);\n    }\n\n    // Add node click handlers to select start vertex\n    nodeElements.forEach((nodeEl, i) => {\n      nodeEl.onclick = () => {\n        if (isRunning) return;\n        selectStartVertex(i);\n      };\n    });\n  }\n\n  // Parse edges from text area\n  function parseEdges(inputText, vertexCount) {\n    const lines = inputText.trim().split(\"\\n\");\n    const edges = [];\n    for (let line of lines) {\n      if (!line.trim()) continue;\n      // from to weight\n      const parts = line.trim().split(/\\s+/);\n      if (parts.length !== 3) throw new Error(\"Each edge line must contain exactly 3 values: from to weight.\");\n      let [fromS, toS, wS] = parts;\n      let from = parseInt(fromS);\n      let to = parseInt(toS);\n      let weight = Number(wS);\n      if (isNaN(from) || isNaN(to) || isNaN(weight)) throw new Error(\"Invalid edge line: \" + line);\n      if (from < 0 || from >= vertexCount || to < 0 || to >= vertexCount) {\n        throw new Error(`Edge vertex indices out of range (0 to ${vertexCount-1}): ${line}`);\n      }\n      edges.push({from, to, weight});\n    }\n    return edges;\n  }\n\n  // Update start vertex dropdown options\n  function updateStartVertexOptions(vertexCount) {\n    startVertexSelect.innerHTML = \"\";\n    for (let i = 0; i < vertexCount; i++) {\n      const option = document.createElement(\"option\");\n      option.value = i;\n      option.textContent = i;\n      startVertexSelect.appendChild(option);\n    }\n    startVertexSelect.value = \"0\";\n    startVertex = 0;\n  }\n\n  // Display messages in messagesDiv\n  function appendMessage(msg, isError = false) {\n    messagesDiv.textContent += msg + \"\\n\";\n    messagesDiv.scrollTop = messagesDiv.scrollHeight;\n    if (isError) {\n      messagesDiv.style.color = \"#e74c3c\";\n    } else {\n      messagesDiv.style.color = \"#eee\";\n    }\n  }\n\n  // Display distances in a formatted way\n  function displayDistances() {\n    let text = \"Distances from start vertex \" + startVertex + \":\\n\";\n    for (let i = 0; i < graph.vertices; i++) {\n      let distText = (distances[i] === Infinity) ? \"∞\" : distances[i].toString();\n      text += `  ${i}: ${distText}\\n`;\n    }\n    distancesDiv.textContent = text;\n  }\n\n  // Highlight start node and update node colors based on relaxation\n  function updateNodeColors() {\n    nodeElements.forEach((group, i) => {\n      group.classList.remove(\"start\", \"relaxed\");\n      if (i === startVertex) group.classList.add(\"start\");\n    });\n  }\n\n  // Highlight a particular edge by index\n  function highlightEdge(edgeIndex) {\n    edgeElements.forEach((edgeGroup, i) => {\n      edgeGroup.classList.toggle(\"highlight\", i === edgeIndex);\n    });\n  }\n\n  // Bellman-Ford state and steps\n  // We'll implement stepwise relaxation for each edge.\n  // For iteration i, we relax all edges in order.\n\n  function resetState() {\n    iteration = 0;\n    stepEdgeIndex = 0;\n    distances = new Array(graph.vertices).fill(Infinity);\n    predecessors = new Array(graph.vertices).fill(null);\n    distances[startVertex] = 0;\n    negativeCycleDetected = false;\n    relaxationLogs = [];\n    isRunning = false;\n    btnNext.disabled = true;\n    btnStart.disabled = false;\n    btnReset.disabled = false;\n    stepInfoDiv.textContent = \"\";\n    updateNodeColors();\n    displayDistances();\n    highlightEdge(-1);\n    appendMessage(\"Ready to start Bellman-Ford algorithm.\");\n  }\n\n  // One relaxation step for the current edge during the current iteration\n  function stepRelaxEdge() {\n    if (negativeCycleDetected) return;\n\n    const edge = graph.edges[stepEdgeIndex];\n    const u = edge.from;\n    const v = edge.to;\n    const w = edge.weight;\n\n    let didRelax = false;\n    const distU = distances[u];\n    const distV = distances[v];\n    let logMsg = `Iter ${iteration + 1}, edge ${u} -> ${v} (w=${w}): `;\n\n    if (distU !== Infinity && distU + w < distV) {\n      distances[v] = distU + w;\n      predecessors[v] = u;\n      didRelax = true;\n      logMsg += `Relaxed - distance updated from ${distV === Infinity ? \"∞\" : distV} to ${distances[v]}`;\n      // Highlight relaxed node\n      nodeElements[v].classList.add(\"relaxed\");\n    } else {\n      logMsg += \"No relaxation\";\n      nodeElements[v].classList.remove(\"relaxed\");\n    }\n\n    relaxationLogs.push(logMsg);\n    displayDistances();\n    stepInfoDiv.textContent = logMsg;\n    highlightEdge(stepEdgeIndex);\n\n    stepEdgeIndex++;\n\n    // If finished relaxing all edges in iteration\n    if (stepEdgeIndex >= graph.edges.length) {\n      iteration++;\n      stepEdgeIndex = 0;\n\n      // After V-1 iterations, run one more iteration to check negative cycles\n      if (iteration === graph.vertices) {\n        // Detect negative cycle step\n        let negativeFound = false;\n        for (let i = 0; i < graph.edges.length; i++) {\n          const e = graph.edges[i];\n          const u = e.from;\n          const v = e.to;\n          const w = e.weight;\n          if (distances[u] !== Infinity && distances[u] + w < distances[v]) {\n            negativeFound = true;\n            highlightEdge(i);\n            stepInfoDiv.textContent = `Negative weight cycle detected! Edge ${u} -> ${v} can still relax distance.`;\n            appendMessage(\"Negative weight cycle detected! Algorithm terminated.\");\n            negativeCycleDetected = true;\n            break;\n          }\n        }\n        if (!negativeFound) {\n          appendMessage(\"No negative weight cycles detected. Algorithm complete.\");\n          stepInfoDiv.textContent = \"Algorithm complete: Shortest distances finalized.\";\n        }\n        btnNext.disabled = true;\n      }\n    }\n  }\n\n  // Step through the algorithm\n  function nextStep() {\n    if (!isRunning) return;\n    if (negativeCycleDetected) return;\n    if (iteration >= graph.vertices) return;\n    stepRelaxEdge();\n  }\n\n  // Handle start button click: initialize and start algo\n  function startAlgorithm() {\n    if (isRunning) return;\n    isRunning = true;\n    btnNext.disabled = false;\n    btnStart.disabled = true;\n    btnGenerate.disabled = true;\n    vertexCountInput.disabled = true;\n    edgeListInput.disabled = true;\n    startVertexSelect.disabled = true;\n    btnReset.disabled = false;\n    appendMessage(`Starting Bellman-Ford from vertex ${startVertex}...`);\n  }\n\n  // Handle reset button click\n  function resetAlgorithm() {\n    isRunning = false;\n    btnNext.disabled = true;\n    btnStart.disabled = false;\n    btnGenerate.disabled = false;\n    vertexCountInput.disabled = false;\n    edgeListInput.disabled = false;\n    startVertexSelect.disabled = false;\n    btnReset.disabled = true;\n    iteration = 0;\n    stepEdgeIndex = 0;\n    negativeCycleDetected = false;\n    distances = [];\n    predecessors = [];\n    relaxationLogs = [];\n    stepInfoDiv.textContent = \"\";\n    messagesDiv.textContent = \"\";\n    distancesDiv.textContent = \"\";\n    updateNodeColors();\n    highlightEdge(-1);\n  }\n\n  // Select start vertex from dropdown or graph node clicks\n  function selectStartVertex(newStart) {\n    if (isRunning) return;\n    startVertex = newStart;\n    startVertexSelect.value = newStart;\n    updateNodeColors();\n    appendMessage(`Start vertex set to ${startVertex}.`);\n    distancesDiv.textContent = \"\";\n    stepInfoDiv.textContent = \"\";\n  }\n\n  // Generate graph from inputs\n  function generateGraph() {\n    try {\n      const vertexCount = parseInt(vertexCountInput.value);\n      if (isNaN(vertexCount) || vertexCount < 2 || vertexCount > 20)\n        throw new Error(\"Vertex count must be an integer between 2 and 20.\");\n\n      // Parse edges\n      const edges = parseEdges(edgeListInput.value, vertexCount);\n\n      graph = {\n        vertices: vertexCount,\n        edges: edges\n      };\n\n      nodePositions = calculatePositions(vertexCount);\n      drawGraph();\n      updateStartVertexOptions(vertexCount);\n      selectStartVertex(0);\n\n      btnStart.disabled = false;\n      btnReset.disabled = true;\n      btnNext.disabled = true;\n      messagesDiv.textContent = \"\";\n      distancesDiv.textContent = \"\";\n      stepInfoDiv.textContent = \"\";\n      appendMessage(\"Graph generated successfully.\");\n    } catch (e) {\n      messagesDiv.textContent = \"\";\n      appendMessage(\"Error: \" + e.message, true);\n      btnStart.disabled = true;\n    }\n  }\n\n  // Event bindings\n  btnGenerate.addEventListener(\"click\", () => {\n    resetAlgorithm();\n    generateGraph();\n  });\n  btnStart.addEventListener(\"click\", () => {\n    distances = new Array(graph.vertices).fill(Infinity);\n    predecessors = new Array(graph.vertices).fill(null);\n    distances[startVertex] = 0;\n    iteration = 0;\n    stepEdgeIndex = 0;\n    negativeCycleDetected = false;\n    relaxationLogs = [];\n    isRunning = true;\n    btnNext.disabled = false;\n    btnStart.disabled = true;\n    btnGenerate.disabled = true;\n    vertexCountInput.disabled = true;\n    edgeListInput.disabled = true;\n    startVertexSelect.disabled = true;\n    messagesDiv.textContent = \"\";\n    distancesDiv.textContent = \"\";\n    stepInfoDiv.textContent = \"\";\n    appendMessage(`Started Bellman-Ford from vertex ${startVertex}.`);\n    displayDistances();\n    updateNodeColors();\n    highlightEdge(-1);\n  });\n  btnNext.addEventListener(\"click\", () => {\n    nextStep();\n  });\n  btnReset.addEventListener(\"click\", () => {\n    resetAlgorithm();\n  });\n  startVertexSelect.addEventListener(\"change\", e => {\n    selectStartVertex(parseInt(e.target.value));\n  });\n\n  // On load: fill example edges\n  function fillExample() {\n    vertexCountInput.value = 5;\n    edgeListInput.value = `0 1 6\n0 2 7\n1 2 8\n1 3 5\n1 4 -4\n2 3 -3\n2 4 9\n3 1 -2\n4 0 2\n4 3 7`;\n  }\n\n  fillExample();\n  generateGraph();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}