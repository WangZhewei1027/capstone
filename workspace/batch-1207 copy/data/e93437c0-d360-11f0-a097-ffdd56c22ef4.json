{
  "id": "e93437c0-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:10.581Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html>\n<head>\n  <meta charset=\"utf-8\"/>\n  <title>Dijkstra's Algorithm Visualizer</title>\n  <style>\n    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background: #f4f6f8; }\n    #container { display:flex; height:100vh; }\n    #canvas-pane { flex:1; position:relative; background: #ffffff; border-right: 1px solid #ddd; }\n    canvas { width:100%; height:100%; display:block; }\n    #sidebar { width:380px; box-sizing:border-box; padding:16px; background:#fafafa; overflow:auto; }\n    h2 { margin:6px 0 12px 0; font-weight:600; font-size:18px; }\n    .controls { display:flex; flex-wrap:wrap; gap:8px; margin-bottom:12px; }\n    button, select, input[type=\"number\"] { padding:8px 10px; border-radius:6px; border:1px solid #bbb; background:white; cursor:pointer; }\n    button:hover { box-shadow: 0 1px 3px rgba(0,0,0,0.08); }\n    .mode-btn.active { background:#2b8cff; color:white; border-color:#1a6fe0; }\n    .small { padding:6px 8px; font-size:13px; }\n    label { display:block; margin-top:8px; font-size:13px; color:#444; }\n    .info { margin-top:12px; background:white; padding:10px; border-radius:8px; border:1px solid #eee; font-size:13px; }\n    pre { white-space:pre-wrap; font-family:monospace; font-size:13px; margin:8px 0 0 0; background:#f6f8fa; padding:8px; border-radius:6px; overflow:auto; max-height:180px; }\n    .pq, .adj { font-family:monospace; font-size:13px; }\n    .status { margin-top:8px; font-weight:700; }\n    .legend { margin-top:8px; font-size:13px; color:#444; }\n    .split { display:flex; gap:8px; margin-top:8px; }\n    .split > * { flex:1; }\n    .small-muted { font-size:12px; color:#666; margin-top:6px; }\n    .footer { margin-top:12px; font-size:12px; color:#666; }\n  </style>\n</head>\n<body>\n  <div id=\"container\">\n    <div id=\"canvas-pane\">\n      <canvas id=\"c\"></canvas>\n    </div>\n    <div id=\"sidebar\">\n      <h2>Dijkstra's Algorithm — Visualizer</h2>\n      <div class=\"controls\">\n        <button id=\"mode-add-node\" class=\"mode-btn active small\">Add Node</button>\n        <button id=\"mode-add-edge\" class=\"mode-btn small\">Add Edge</button>\n        <button id=\"mode-move\" class=\"mode-btn small\">Move Node</button>\n        <button id=\"mode-delete\" class=\"mode-btn small\">Delete</button>\n      </div>\n\n      <div class=\"controls\">\n        <button id=\"set-start\" class=\"small\">Set Start</button>\n        <button id=\"set-target\" class=\"small\">Set Target</button>\n        <button id=\"show-path\" class=\"small\">Show Shortest Path</button>\n      </div>\n\n      <label>Edge weight (default when creating)</label>\n      <input id=\"default-weight\" type=\"number\" value=\"1\" step=\"0.1\" min=\"0\" />\n\n      <div class=\"controls\" style=\"margin-top:12px;\">\n        <button id=\"init-run\" class=\"small\">Init Dijkstra</button>\n        <button id=\"step-btn\" class=\"small\">Step</button>\n        <button id=\"run-btn\" class=\"small\">Run</button>\n        <button id=\"pause-btn\" class=\"small\" disabled>Pause</button>\n        <button id=\"reset-btn\" class=\"small\">Reset</button>\n      </div>\n\n      <div style=\"margin-top:10px;\">\n        <label><input type=\"checkbox\" id=\"undirected\" checked /> Undirected edges</label>\n      </div>\n\n      <div class=\"info\">\n        <div><strong>Status:</strong> <span id=\"status-text\">Idle</span></div>\n        <div class=\"status\">Start: <span id=\"start-node\">—</span> &nbsp; Target: <span id=\"target-node\">—</span></div>\n        <div class=\"legend\">\n          Node: label (distance) — visited nodes are gray; current node highlighted in blue; shortest path in green.\n        </div>\n      </div>\n\n      <div class=\"info\" style=\"margin-top:12px;\">\n        <strong>Priority Queue (min by distance)</strong>\n        <div class=\"pq\" id=\"pq-box\" style=\"margin-top:8px;\">[]</div>\n        <strong style=\"margin-top:8px; display:block;\">Adjacency</strong>\n        <div class=\"adj\" id=\"adj-box\" style=\"margin-top:8px;\">(empty)</div>\n      </div>\n\n      <div class=\"info\" style=\"margin-top:12px;\">\n        <strong>Pseudocode (highlighted as it runs)</strong>\n        <pre id=\"pseudocode\">\n1  procedure Dijkstra(Graph, source):\n2      for each vertex v in Graph:\n3          dist[v] := ∞\n4          prev[v] := undefined\n5      dist[source] := 0\n6      Q := all vertices in Graph\n7      while Q is not empty:\n8          u := vertex in Q with smallest dist[u]\n9          remove u from Q\n10         if dist[u] = ∞: break\n11         for each neighbor v of u:\n12             alt := dist[u] + weight(u,v)\n13             if alt < dist[v]:\n14                 dist[v] := alt\n15                 prev[v] := u\n        </pre>\n      </div>\n\n      <div class=\"footer\">\n        Tips:\n        <ul style=\"margin:6px 0 0 18px; padding:0;\">\n          <li>Click canvas to add nodes. Use \"Add Edge\" to connect nodes (click source then target).</li>\n          <li>Set a start node, then \"Init Dijkstra\", then Step or Run.</li>\n          <li>Non-negative weights only. Use \"Undirected\" for two-way edges.</li>\n        </ul>\n      </div>\n    </div>\n  </div>\n\n  <script>\n  // Dijkstra Visualizer - single-file implementation (no external libs)\n  (function(){\n    // Canvas setup\n    const canvas = document.getElementById('c');\n    const pane = document.getElementById('canvas-pane');\n    function resizeCanvas(){\n      canvas.width = pane.clientWidth;\n      canvas.height = pane.clientHeight;\n      draw();\n    }\n    window.addEventListener('resize', resizeCanvas);\n    resizeCanvas();\n\n    const ctx = canvas.getContext('2d');\n\n    // UI elements\n    const modes = {\n      addNode: document.getElementById('mode-add-node'),\n      addEdge: document.getElementById('mode-add-edge'),\n      move: document.getElementById('mode-move'),\n      del: document.getElementById('mode-delete')\n    };\n    const setStartBtn = document.getElementById('set-start');\n    const setTargetBtn = document.getElementById('set-target');\n    const showPathBtn = document.getElementById('show-path');\n    const defaultWeightInput = document.getElementById('default-weight');\n    const undirectedCheckbox = document.getElementById('undirected');\n    const initRunBtn = document.getElementById('init-run');\n    const stepBtn = document.getElementById('step-btn');\n    const runBtn = document.getElementById('run-btn');\n    const pauseBtn = document.getElementById('pause-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    const statusText = document.getElementById('status-text');\n    const startNodeSpan = document.getElementById('start-node');\n    const targetNodeSpan = document.getElementById('target-node');\n    const pqBox = document.getElementById('pq-box');\n    const adjBox = document.getElementById('adj-box');\n    const pseudo = document.getElementById('pseudocode');\n\n    // Graph model\n    let nodes = []; // {id,x,y}\n    let edges = []; // {id,u,v,weight}\n    let nodeIdCounter = 1;\n    let edgeIdCounter = 1;\n\n    // Visual settings\n    const NODE_R = 22;\n\n    // Interaction state\n    let currentMode = 'addNode';\n    let tempEdgeSource = null;\n    let draggingNode = null;\n    let draggingOffset = {x:0,y:0};\n    let selectingStart = false;\n    let selectingTarget = false;\n\n    // Dijkstra algorithm state\n    let algo = {\n      started: false,\n      distances: {}, // id -> number\n      prev: {}, // id -> id or null\n      visited: {}, // id -> bool\n      pq: [], // array of {id,dist} (kept unsophisticated)\n      current: null, // current u being processed\n      finished: false\n    };\n\n    let autoRunInterval = null;\n\n    // Helpers\n    function getNodeAt(x,y){\n      for(let i=nodes.length-1;i>=0;i--){\n        const n = nodes[i];\n        const dx = x - n.x, dy = y - n.y;\n        if (Math.hypot(dx,dy) <= NODE_R) return n;\n      }\n      return null;\n    }\n    function distBetween(n1,n2){\n      const dx = n1.x-n2.x, dy = n1.y-n2.y;\n      return Math.hypot(dx,dy);\n    }\n    function addNode(x,y){\n      const id = String(nodeIdCounter++);\n      nodes.push({id, x, y});\n      draw();\n      updateAdjBox();\n    }\n    function removeNode(node){\n      edges = edges.filter(e => e.u !== node.id && e.v !== node.id);\n      nodes = nodes.filter(n => n.id !== node.id);\n      if (algo.started) resetAlgorithm();\n      draw();\n      updateAdjBox();\n    }\n    function addEdge(u,v,w){\n      // prevent duplicates: if an edge with same endpoints exists, just update weight\n      const exists = edges.find(e => (e.u===u && e.v===v) || (undirectedCheckbox.checked && e.u===v && e.v===u));\n      if (exists){\n        exists.weight = w;\n      } else {\n        edges.push({id:String(edgeIdCounter++), u, v, weight: w});\n      }\n      draw();\n      updateAdjBox();\n    }\n    function removeEdgeBetween(u,v){\n      edges = edges.filter(e => !( (e.u===u && e.v===v) || (e.u===v && e.v===u) ));\n      draw();\n      updateAdjBox();\n    }\n    function neighborsOf(id){\n      const res = [];\n      for(const e of edges){\n        if (e.u === id) res.push({id: e.v, weight: e.weight});\n        if (undirectedCheckbox.checked && e.v === id) res.push({id: e.u, weight: e.weight});\n        // If edges are stored both directions, the above may duplicate; but we store single edges.\n      }\n      return res;\n    }\n    function updateAdjBox(){\n      if (nodes.length === 0){ adjBox.innerText = '(empty)'; return; }\n      const map = {};\n      for(const n of nodes) map[n.id] = [];\n      for(const e of edges){\n        map[e.u].push({v:e.v,w:e.weight});\n        if (undirectedCheckbox.checked) map[e.v].push({v:e.u,w:e.weight});\n      }\n      let s = '';\n      for(const id of Object.keys(map).sort((a,b)=>+a-+b)){\n        s += id + ' : ' + (map[id].map(o => `${o.v}(${o.w})`).join(', ') ) + '\\n';\n      }\n      adjBox.innerText = s;\n    }\n\n    // UI mode buttons\n    function setMode(m){\n      currentMode = m;\n      for(const k in modes) modes[k].classList.remove('active');\n      if (m === 'addNode') modes.addNode.classList.add('active');\n      if (m === 'addEdge') modes.addEdge.classList.add('active');\n      if (m === 'move') modes.move.classList.add('active');\n      if (m === 'del') modes.del.classList.add('active');\n      tempEdgeSource = null;\n      selectingStart = selectingTarget = false;\n      setStartBtn.classList.remove('active');\n      setTargetBtn.classList.remove('active');\n      draw();\n    }\n    modes.addNode.addEventListener('click', ()=> setMode('addNode'));\n    modes.addEdge.addEventListener('click', ()=> setMode('addEdge'));\n    modes.move.addEventListener('click', ()=> setMode('move'));\n    modes.del.addEventListener('click', ()=> setMode('del'));\n\n    // Set start/target\n    setStartBtn.addEventListener('click', ()=>{\n      selectingStart = !selectingStart;\n      selectingTarget = false;\n      setStartBtn.classList.toggle('active', selectingStart);\n      setTargetBtn.classList.remove('active');\n      setMode('move'); // keep mode common (we rely on click handlers)\n    });\n    setTargetBtn.addEventListener('click', ()=>{\n      selectingTarget = !selectingTarget;\n      selectingStart = false;\n      setTargetBtn.classList.toggle('active', selectingTarget);\n      setStartBtn.classList.remove('active');\n      setMode('move');\n    });\n\n    showPathBtn.addEventListener('click', ()=>{\n      draw(); // recompute path visualization based on prev array\n    });\n\n    // Canvas interactions\n    let mouseDown = false;\n    canvas.addEventListener('mousedown', (ev)=>{\n      const rect = canvas.getBoundingClientRect();\n      const x = (ev.clientX - rect.left);\n      const y = (ev.clientY - rect.top);\n      mouseDown = true;\n      const hit = getNodeAt(x,y);\n      if (selectingStart){\n        if (hit){ startNode = hit.id; startNodeSpan.innerText = startNode; selectingStart=false; setStartBtn.classList.remove('active'); resetAlgorithm(); draw(); }\n        return;\n      }\n      if (selectingTarget){\n        if (hit){ targetNode = hit.id; targetNodeSpan.innerText = targetNode; selectingTarget=false; setTargetBtn.classList.remove('active'); draw(); }\n        return;\n      }\n      if (currentMode === 'addNode'){\n        addNode(x,y);\n      } else if (currentMode === 'addEdge'){\n        if (hit){\n          if (!tempEdgeSource) {\n            tempEdgeSource = hit;\n          } else if (tempEdgeSource.id === hit.id){\n            tempEdgeSource = null;\n          } else {\n            // ask for weight\n            let w = parseFloat(defaultWeightInput.value);\n            if (isNaN(w) || w < 0) w = 1;\n            addEdge(tempEdgeSource.id, hit.id, +w);\n            tempEdgeSource = null;\n          }\n        }\n      } else if (currentMode === 'move'){\n        if (hit){\n          draggingNode = hit;\n          draggingOffset.x = x - hit.x;\n          draggingOffset.y = y - hit.y;\n        }\n      } else if (currentMode === 'del'){\n        if (hit){\n          removeNode(hit);\n        } else {\n          // maybe clicked on an edge: find closest edge to click\n          let clickedEdge = null;\n          let minDist = 9999;\n          for(const e of edges){\n            const n1 = nodes.find(n=>n.id===e.u), n2 = nodes.find(n=>n.id===e.v);\n            if (!n1 || !n2) continue;\n            const d = pointLineDistance({x,y}, n1, n2);\n            if (d < minDist){ minDist = d; clickedEdge = e; }\n          }\n          if (clickedEdge && minDist < 8){\n            removeEdgeBetween(clickedEdge.u, clickedEdge.v);\n          }\n        }\n      }\n      draw();\n    });\n    canvas.addEventListener('mousemove', (ev)=>{\n      const rect = canvas.getBoundingClientRect();\n      const x = (ev.clientX - rect.left);\n      const y = (ev.clientY - rect.top);\n      if (draggingNode){\n        draggingNode.x = x - draggingOffset.x;\n        draggingNode.y = y - draggingOffset.y;\n        draw();\n      }\n    });\n    canvas.addEventListener('mouseup', (ev)=>{ mouseDown=false; draggingNode=null; });\n    canvas.addEventListener('mouseleave', ()=>{ draggingNode=null; tempEdgeSource=null; });\n\n    function pointLineDistance(p, a, b){\n      const A = p.x - a.x, B = p.y - a.y;\n      const C = b.x - a.x, D = b.y - a.y;\n      const dot = A*C + B*D;\n      const len2 = C*C + D*D;\n      const t = (len2 === 0) ? -1 : Math.max(0, Math.min(1, dot/len2));\n      const projx = a.x + t*C, projy = a.y + t*D;\n      return Math.hypot(p.x-projx, p.y-projy);\n    }\n\n    // Start/target nodes\n    let startNode = null;\n    let targetNode = null;\n\n    // Algorithm core\n    function resetAlgorithm(){\n      algo = {\n        started: false,\n        distances: {},\n        prev: {},\n        visited: {},\n        pq: [],\n        current: null,\n        finished: false\n      };\n      statusText.innerText = 'Idle';\n      stepBtn.disabled = false;\n      runBtn.disabled = false;\n      pauseBtn.disabled = true;\n      clearPseudoHighlight();\n      draw();\n    }\n\n    function initDijkstra(){\n      if (!startNode){ alert('Set a start node first.'); return; }\n      // initialize distances\n      algo.distances = {};\n      algo.prev = {};\n      algo.visited = {};\n      for(const n of nodes){ algo.distances[n.id] = Infinity; algo.prev[n.id] = null; algo.visited[n.id] = false; }\n      algo.distances[startNode] = 0;\n      algo.pq = [{id:startNode, dist:0}];\n      algo.current = null;\n      algo.started = true;\n      algo.finished = false;\n      statusText.innerText = 'Initialized';\n      highlightPseudoLine(5); // dist[source] := 0 (line 5)\n      updatePQBox();\n      updateAdjBox();\n      draw();\n    }\n\n    function pqPush(id,dist){\n      algo.pq.push({id,dist});\n      // We won't deduplicate; when popping we skip visited or outdated entries\n    }\n    function pqPop(){\n      if (algo.pq.length === 0) return null;\n      // simple linear min search\n      let minIdx = 0;\n      for(let i=1;i<algo.pq.length;i++){\n        if (algo.pq[i].dist < algo.pq[minIdx].dist) minIdx = i;\n      }\n      const it = algo.pq.splice(minIdx,1)[0];\n      return it;\n    }\n\n    function stepDijkstra(){\n      if (!algo.started){ alert('Initialize Dijkstra (click \"Init Dijkstra\")'); return; }\n      if (algo.finished){ statusText.innerText = 'Finished'; return; }\n      highlightPseudoLine(7); // while Q not empty\n      // pop smallest\n      let popped = null;\n      while(true){\n        if (algo.pq.length === 0) break;\n        popped = pqPop();\n        if (!popped) break;\n        if (algo.visited[popped.id]) { popped = null; continue; } // skip\n        if (algo.distances[popped.id] !== popped.dist) { popped = popped; /* outdated but still possible; we allow */ }\n        break;\n      }\n      if (!popped){\n        // done\n        algo.finished = true;\n        algo.current = null;\n        statusText.innerText = 'Finished (queue empty)';\n        highlightPseudoLine(10); // if dist[u] = ∞: break\n        updatePQBox();\n        draw();\n        return;\n      }\n      const u = popped.id;\n      algo.current = u;\n      if (!isFinite(algo.distances[u])){\n        // unreachable: finish\n        algo.finished = true;\n        statusText.innerText = 'Finished (remaining nodes unreachable)';\n        updatePQBox();\n        draw();\n        return;\n      }\n      // process u\n      algo.visited[u] = true;\n      statusText.innerText = `Processing node ${u}`;\n      highlightPseudoLine(8); // u := vertex with smallest dist\n      highlightPseudoLine(9); // remove u from Q\n      updatePQBox();\n      draw();\n\n      // relax neighbors\n      const neighs = neighborsOf(u);\n      highlightPseudoLine(11); // for each neighbor\n      for(const nb of neighs){\n        const v = nb.id;\n        if (algo.visited[v]) continue;\n        const alt = algo.distances[u] + nb.weight;\n        highlightPseudoLine(12); // alt := ...\n        if (alt < algo.distances[v]){\n          algo.distances[v] = alt;\n          algo.prev[v] = u;\n          // push into pq\n          pqPush(v, alt);\n          highlightPseudoLine(13); // if alt < dist[v]\n          highlightPseudoLine(14); // dist[v] := alt\n          highlightPseudoLine(15); // prev[v] := u\n        }\n      }\n      updatePQBox();\n      draw();\n    }\n\n    // Run/pause management\n    runBtn.addEventListener('click', ()=>{\n      if (!algo.started){ alert('Initialize Dijkstra first.'); return; }\n      runBtn.disabled = true;\n      pauseBtn.disabled = false;\n      autoRunInterval = setInterval(()=>{\n        if (algo.finished){\n          clearInterval(autoRunInterval);\n          runBtn.disabled = false;\n          pauseBtn.disabled = true;\n          return;\n        }\n        stepDijkstra();\n      }, 600);\n    });\n    pauseBtn.addEventListener('click', ()=>{\n      if (autoRunInterval) clearInterval(autoRunInterval);\n      runBtn.disabled = false;\n      pauseBtn.disabled = true;\n    });\n\n    stepBtn.addEventListener('click', ()=>{\n      stepDijkstra();\n    });\n    initRunBtn.addEventListener('click', ()=>{\n      initDijkstra();\n    });\n    resetBtn.addEventListener('click', ()=>{\n      if (confirm('Reset algorithm state? Graph will remain.')) resetAlgorithm();\n    });\n\n    // Pseudocode highlighting utility\n    function clearPseudoHighlight(){\n      // no dynamic DOM lines, but we can simulate by wrapping lines? For simplicity, we change background temporarily per call.\n      // We'll change selection by toggling background color in <pre> using mark spans is complicated; instead, we will append a small comment for selected line in the pre's text.\n      // Simpler: just change the pre background to indicate activity.\n      pseudo.style.background = '#f6f8fa';\n    }\n    function highlightPseudoLine(lineNo){\n      // we briefly change background color and set status text; to be simple, animate background color\n      pseudo.style.background = '#fff9da';\n      setTimeout(()=> pseudo.style.background = '#f6f8fa', 300);\n    }\n\n    // Update PQ display\n    function updatePQBox(){\n      if (!algo.started){ pqBox.innerText = '[]'; return; }\n      // compress into map keeping smallest seen distance per id\n      const mp = {};\n      for(const it of algo.pq){\n        if (!(it.id in mp) || it.dist < mp[it.id]) mp[it.id] = it.dist;\n      }\n      // include nodes with known dist but not yet in pq? We'll show all nodes with distances\n      let arr = Object.keys(algo.distances).map(id => ({id, dist: algo.distances[id], visited: algo.visited[id]}));\n      arr.sort((a,b)=>{\n        if (a.visited !== b.visited) return a.visited ? 1 : -1;\n        return (isFinite(a.dist) ? a.dist : 1e12) - (isFinite(b.dist) ? b.dist : 1e12);\n      });\n      let s = '[' + arr.map(it => `${it.id}:${(isFinite(it.dist)?it.dist:'∞')}${it.visited?`(v)`:''}`).join(' , ') + ']';\n      pqBox.innerText = s;\n    }\n\n    // Drawing\n    function draw(){\n      ctx.clearRect(0,0,canvas.width,canvas.height);\n      // draw edges\n      for(const e of edges){\n        const n1 = nodes.find(n=>n.id===e.u), n2 = nodes.find(n=>n.id===e.v);\n        if (!n1 || !n2) continue;\n        drawEdge(n1,n2,e);\n      }\n      // If tempEdgeSource during edge creation, draw temporary line to mouse\n      if (tempEdgeSource && mouseDown === false){\n        // nothing; but we can draw a highlighted node\n      }\n      // draw nodes\n      for(const n of nodes){\n        drawNode(n);\n      }\n\n      // If tempEdgeSource (user selected first node to make edge), highlight it\n      if (tempEdgeSource){\n        ctx.beginPath();\n        ctx.strokeStyle = '#2b8cff';\n        ctx.lineWidth = 3;\n        ctx.arc(tempEdgeSource.x, tempEdgeSource.y, NODE_R+4, 0, Math.PI*2);\n        ctx.stroke();\n      }\n\n      // draw shortest path if requested: use algo.prev from target back to start\n      if (algo.started && targetNode && algo.prev[targetNode]){\n        const path = [];\n        let cur = targetNode;\n        while(cur){ path.push(cur); cur = algo.prev[cur]; }\n        // draw path edges\n        ctx.lineWidth = 6;\n        ctx.strokeStyle = '#28a745';\n        ctx.lineCap = 'round';\n        for(let i=0;i<path.length-1;i++){\n          const a = nodes.find(n=>n.id===path[i]);\n          const b = nodes.find(n=>n.id===path[i+1]);\n          if (a && b){\n            ctx.beginPath();\n            ctx.moveTo(a.x,a.y);\n            ctx.lineTo(b.x,b.y);\n            ctx.stroke();\n          }\n        }\n      }\n    }\n\n    function drawEdge(n1,n2,e){\n      ctx.beginPath();\n      // if undirected, draw single line. Color depends on whether either endpoint visited, or if it's part of shortest path.\n      ctx.lineWidth = 2;\n      const visitedCount = (algo.visited[n1.id]?1:0)+(algo.visited[n2.id]?1:0);\n      ctx.strokeStyle = visitedCount===2 ? '#bbb' : '#999';\n      ctx.moveTo(n1.x, n1.y);\n      ctx.lineTo(n2.x, n2.y);\n      ctx.stroke();\n\n      // draw weight at midpoint\n      const mx = (n1.x + n2.x)/2;\n      const my = (n1.y + n2.y)/2;\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.fillRect(mx-18, my-12, 36, 18);\n      ctx.fillStyle = '#111';\n      ctx.font = '12px monospace';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(e.weight), mx, my);\n    }\n\n    function drawNode(n){\n      // circle style: visited grey, current blue, otherwise white with border\n      const isVisited = algo.visited[n.id];\n      const isCurrent = (algo.current === n.id);\n      const inPath = (algo.started && targetNode && (() => {\n        let cur = targetNode;\n        while(cur){ if (cur === n.id) return true; cur = algo.prev[cur]; }\n        return false;\n      })());\n\n      // shadow/halo for current\n      if (isCurrent){\n        ctx.beginPath();\n        ctx.fillStyle = '#d9edff';\n        ctx.arc(n.x, n.y, NODE_R+6, 0, Math.PI*2);\n        ctx.fill();\n      }\n\n      ctx.beginPath();\n      ctx.lineWidth = 2;\n      if (isVisited) ctx.fillStyle = '#f0f0f0'; else ctx.fillStyle = '#ffffff';\n      ctx.strokeStyle = isCurrent ? '#2b8cff' : (inPath ? '#28a745' : '#555');\n      ctx.arc(n.x, n.y, NODE_R, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      // label\n      ctx.fillStyle = '#222';\n      ctx.font = 'bold 14px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(n.id, n.x, n.y-4);\n\n      // distance below\n      const distText = (algo.started && n.id in algo.distances) ? (isFinite(algo.distances[n.id]) ? String(algo.distances[n.id]) : '∞') : '—';\n      ctx.font = '12px monospace';\n      ctx.fillStyle = isVisited ? '#666' : '#111';\n      ctx.fillText('(' + distText + ')', n.x, n.y + 14);\n\n      // highlight start/target markers\n      if (n.id === startNode){\n        ctx.beginPath();\n        ctx.fillStyle = '#2b8cff';\n        ctx.arc(n.x - NODE_R - 8, n.y - NODE_R - 8, 6, 0, Math.PI*2);\n        ctx.fill();\n        ctx.font = '11px sans-serif';\n        ctx.fillStyle = '#2b8cff';\n        ctx.textAlign = 'left';\n        ctx.fillText('S', n.x - NODE_R - 2, n.y - NODE_R - 8);\n      }\n      if (n.id === targetNode){\n        ctx.beginPath();\n        ctx.fillStyle = '#28a745';\n        ctx.arc(n.x + NODE_R + 8, n.y - NODE_R - 8, 6, 0, Math.PI*2);\n        ctx.fill();\n        ctx.font = '11px sans-serif';\n        ctx.fillStyle = '#28a745';\n        ctx.textAlign = 'right';\n        ctx.fillText('T', n.x + NODE_R + 2, n.y - NODE_R - 8);\n      }\n    }\n\n    // Utilities: save/restore (not necessary but helpful)\n    function clearAll(){\n      nodes = [];\n      edges = [];\n      nodeIdCounter = 1;\n      edgeIdCounter = 1;\n      startNode = targetNode = null;\n      startNodeSpan.innerText = '—';\n      targetNodeSpan.innerText = '—';\n      resetAlgorithm();\n      updateAdjBox();\n      draw();\n    }\n\n    // initial sample graph for demonstration\n    function seedDemo(){\n      clearAll();\n      addNode(120,120); addNode(320,90); addNode(520,120); addNode(220,260); addNode(420,260);\n      addEdge('1','2',4); addEdge('1','4',1); addEdge('4','2',2); addEdge('2','3',1); addEdge('4','5',5); addEdge('5','3',3);\n      startNode = '1'; targetNode = '3';\n      startNodeSpan.innerText = startNode;\n      targetNodeSpan.innerText = targetNode;\n      resetAlgorithm();\n    }\n\n    // keyboard shortcuts\n    window.addEventListener('keydown', (e)=>{\n      if (e.key === 'n') setMode('addNode');\n      if (e.key === 'e') setMode('addEdge');\n      if (e.key === 'm') setMode('move');\n      if (e.key === 'Delete') setMode('del');\n    });\n\n    // initial setup\n    resetAlgorithm();\n    seedDemo();\n\n    // Draw loop\n    draw();\n\n  })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}