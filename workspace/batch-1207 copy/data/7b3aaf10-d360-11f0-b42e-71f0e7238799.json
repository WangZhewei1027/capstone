{
  "id": "7b3aaf10-d360-11f0-b42e-71f0e7238799",
  "timestamp": "2025-12-07T11:34:08.967Z",
  "model": "gpt-4o-mini",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Red-Black Tree Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            text-align: center;\n            margin: 0;\n            padding: 20px;\n        }\n        #tree-container {\n            width: 100%;\n            height: 400px;\n            overflow: auto;\n            position: relative;\n            border: 1px solid #ccc;\n        }\n        .node {\n            display: inline-block;\n            padding: 10px;\n            margin: 5px;\n            border-radius: 50%;\n            border: 2px solid;\n            position: relative;\n        }\n        .red {\n            background-color: red;\n            color: white;\n            border-color: darkred;\n        }\n        .black {\n            background-color: black;\n            color: white;\n            border-color: darkgray;\n        }\n    </style>\n</head>\n<body>\n    <h1>Red-Black Tree Visualization</h1>\n    <div id=\"tree-container\"></div>\n    <input type=\"number\" id=\"valueInput\" placeholder=\"Enter value\">\n    <button id=\"insertBtn\">Insert</button>\n    <script>\n        class Node {\n            constructor(value) {\n                this.value = value;\n                this.color = 'red'; // New nodes are red by default\n                this.left = null;\n                this.right = null;\n                this.parent = null;\n            }\n        }\n\n        class RedBlackTree {\n            constructor() {\n                this.root = null;\n            }\n\n            insert(value) {\n                let newNode = new Node(value);\n                this.root = this._insertRec(this.root, newNode);\n                this.fixViolations(newNode);\n            }\n\n            _insertRec(root, newNode) {\n                if (!root) {\n                    return newNode;\n                }\n                if (newNode.value < root.value) {\n                    root.left = this._insertRec(root.left, newNode);\n                    root.left.parent = root;\n                } else {\n                    root.right = this._insertRec(root.right, newNode);\n                    root.right.parent = root;\n                }\n                return root;\n            }\n\n            fixViolations(node) {\n                // Implementing the fixing process for simplicity, not fully implemented for all cases\n                while (node !== this.root && node.parent.color === 'red') {\n                    if (node.parent === node.parent.parent.left) {\n                        let uncle = node.parent.parent.right;\n                        if (uncle && uncle.color === 'red') {\n                            node.parent.color = 'black';\n                            uncle.color = 'black';\n                            node.parent.parent.color = 'red';\n                            node = node.parent.parent;\n                        } else {\n                            if (node === node.parent.right) {\n                                node = node.parent;\n                                this.rotateLeft(node);\n                            }\n                            node.parent.color = 'black';\n                            node.parent.parent.color = 'red';\n                            this.rotateRight(node.parent.parent);\n                        }\n                    } else {\n                        // Symmetric to the above case\n                        let uncle = node.parent.parent.left;\n                        if (uncle && uncle.color === 'red') {\n                            node.parent.color = 'black';\n                            uncle.color = 'black';\n                            node.parent.parent.color = 'red';\n                            node = node.parent.parent;\n                        } else {\n                            if (node === node.parent.left) {\n                                node = node.parent;\n                                this.rotateRight(node);\n                            }\n                            node.parent.color = 'black';\n                            node.parent.parent.color = 'red';\n                            this.rotateLeft(node.parent.parent);\n                        }\n                    }\n                }\n                this.root.color = 'black';\n            }\n\n            rotateLeft(node) {\n                let rightChild = node.right;\n                node.right = rightChild.left;\n                if (rightChild.left) rightChild.left.parent = node;\n                rightChild.parent = node.parent;\n                if (!node.parent) {\n                    this.root = rightChild;\n                } else if (node === node.parent.left) {\n                    node.parent.left = rightChild;\n                } else {\n                    node.parent.right = rightChild;\n                }\n                rightChild.left = node;\n                node.parent = rightChild;\n            }\n\n            rotateRight(node) {\n                let leftChild = node.left;\n                node.left = leftChild.right;\n                if (leftChild.right) leftChild.right.parent = node;\n                leftChild.parent = node.parent;\n                if (!node.parent) {\n                    this.root = leftChild;\n                } else if (node === node.parent.right) {\n                    node.parent.right = leftChild;\n                } else {\n                    node.parent.left = leftChild;\n                }\n                leftChild.right = node;\n                node.parent = leftChild;\n            }\n\n            visualize(container) {\n                container.innerHTML = '';\n                this._visualizeRec(this.root, container);\n            }\n\n            _visualizeRec(node, container) {\n                if (!node) return;\n                const nodeElement = document.createElement('div');\n                nodeElement.className = 'node ' + node.color;\n                nodeElement.innerText = node.value;\n                container.appendChild(nodeElement);\n                \n                // Position nodes based on depth\n                if (node.left || node.right) {\n                    const childrenContainer = document.createElement('div');\n                    childrenContainer.style.display = 'flex';\n                    if (node.left) this._visualizeRec(node.left, childrenContainer);\n                    if (node.right) this._visualizeRec(node.right, childrenContainer);\n                    container.appendChild(childrenContainer);\n                }\n            }\n        }\n\n        const rbTree = new RedBlackTree();\n        const treeContainer = document.getElementById(\"tree-container\");\n\n        document.getElementById(\"insertBtn\").onclick = function() {\n            const value = parseInt(document.getElementById(\"valueInput\").value);\n            if (!isNaN(value)) {\n                rbTree.insert(value);\n                rbTree.visualize(treeContainer);\n                document.getElementById(\"valueInput\").value = '';\n            }\n        };\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}