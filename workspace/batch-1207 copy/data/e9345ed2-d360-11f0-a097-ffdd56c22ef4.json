{
  "id": "e9345ed2-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:35.143Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>Topological Sort Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<style>\n  :root{--bg:#121212;--panel:#1e1e1e;--accent:#4fc3f7;--muted:#9aa3ad;--success:#7ed957;--danger:#ff6b6b;}\n  body{margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;background:linear-gradient(180deg,#0f1720,#081016);color:#e6eef6;display:flex;height:100vh;overflow:hidden}\n  .sidebar{width:360px;background:var(--panel);padding:16px;box-sizing:border-box;display:flex;flex-direction:column;gap:12px;overflow:auto}\n  .title{font-size:20px;font-weight:700;display:flex;align-items:center;gap:10px}\n  .controls{display:flex;flex-wrap:wrap;gap:8px}\n  button,select,input[type=range]{background:#0b1220;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 10px;border-radius:6px;cursor:pointer}\n  button.active{outline:2px solid rgba(79,195,247,0.2)}\n  .small{padding:6px 8px;font-size:13px}\n  .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}\n  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}\n  .info{font-size:13px;color:var(--muted);line-height:1.4}\n  .canvas-wrap{flex:1;background:linear-gradient(180deg,#071426,#05111a);display:flex;align-items:stretch;justify-content:center;padding:12px;position:relative}\n  svg{width:100%;height:100%;border-radius:8px}\n  .status{position:absolute;left:24px;bottom:24px;padding:8px 12px;border-radius:8px;background:rgba(0,0,0,0.35);backdrop-filter:blur(6px);font-size:13px;border:1px solid rgba(255,255,255,0.03)}\n  .legend{display:flex;gap:8px;flex-wrap:wrap}\n  .chip{padding:6px 8px;border-radius:6px;font-size:13px;background:rgba(255,255,255,0.02)}\n  .list{font-family:monospace;background:#0b1220;padding:8px;border-radius:6px;overflow:auto;max-height:140px}\n  .footer{margin-top:auto;font-size:12px;color:var(--muted)}\n  input[type=number]{width:70px;padding:6px 8px;border-radius:6px}\n  .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}\n  .hint{font-size:13px;color:var(--muted);margin-top:6px}\n  .error{color:var(--danger);font-weight:700}\n  .ok{color:var(--success);font-weight:700}\n  .node-label{pointer-events:none;fill:#fff;font-size:12px;font-weight:700;text-anchor:middle;dominant-baseline:central}\n  .edge{stroke:#8fa8bd;stroke-width:2;fill:none;opacity:0.9}\n  .edge.cycle{stroke:var(--danger);opacity:1}\n  .node{cursor:pointer;stroke:#101418;stroke-width:2}\n  .node.normal{fill:#0b6b8a}\n  .node.selected{fill:#4fc3f7;stroke:#0b1220}\n  .node.zero{fill:#7ed957}\n  .node.gray{fill:#f6c85f}\n  .node.black{fill:#7a7a7a}\n  .controls-row{display:flex;gap:8px;align-items:center}\n  .title small{font-size:12px;color:var(--muted);font-weight:500}\n  .muted{color:var(--muted)}\n  a{color:var(--accent);text-decoration:none}\n  .topo-output{font-family:monospace;padding:8px;border-radius:6px;background:#071724}\n</style>\n</head>\n<body>\n  <div class=\"sidebar\">\n    <div class=\"title\">Topological Sort Visualizer <small> (Kahn & DFS)</small></div>\n    <div class=\"panel\">\n      <div class=\"controls-row\" style=\"justify-content:space-between\">\n        <div style=\"display:flex;gap:8px\">\n          <button id=\"addNodeBtn\" class=\"small\">Add node</button>\n          <button id=\"edgeModeBtn\" class=\"small\">Add edge</button>\n          <button id=\"delModeBtn\" class=\"small\">Delete</button>\n        </div>\n        <div style=\"display:flex;gap:8px\">\n          <button id=\"clearBtn\" class=\"small\">Clear</button>\n        </div>\n      </div>\n      <div class=\"hint\">Click a node to select it. In \"Add edge\" mode click source then destination to create an edge. Drag nodes to reposition.</div>\n    </div>\n\n    <div class=\"panel\">\n      <label>Quick graph</label>\n      <div style=\"display:flex;gap:8px;align-items:center\">\n        <input id=\"randN\" type=\"number\" min=\"1\" max=\"26\" value=\"6\"/>\n        <input id=\"randP\" type=\"number\" min=\"0\" max=\"100\" value=\"25\"/>% prob\n        <button id=\"randBtn\" class=\"small\">Generate</button>\n      </div>\n      <div class=\"hint\">Generates a random directed graph (may contain cycles).</div>\n    </div>\n\n    <div class=\"panel\">\n      <label>Algorithms</label>\n      <div class=\"controls\">\n        <button id=\"kahnBtn\" class=\"small\">Run Kahn's algorithm</button>\n        <button id=\"kahnStepBtn\" class=\"small\">Step</button>\n        <button id=\"kahnPlayBtn\" class=\"small\">Play</button>\n        <button id=\"kahnStopBtn\" class=\"small\">Reset</button>\n      </div>\n      <div style=\"height:8px\"></div>\n      <div class=\"controls\">\n        <button id=\"dfsBtn\" class=\"small\">Run DFS topo</button>\n        <button id=\"dfsStepBtn\" class=\"small\">Step</button>\n        <button id=\"dfsPlayBtn\" class=\"small\">Play</button>\n        <button id=\"dfsStopBtn\" class=\"small\">Reset</button>\n      </div>\n      <div style=\"margin-top:8px;display:flex;gap:8px;align-items:center\">\n        <label style=\"margin:0\">Speed</label>\n        <input id=\"speed\" type=\"range\" min=\"200\" max=\"1500\" value=\"700\">\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <label>Algorithm state</label>\n      <div style=\"display:flex;gap:8px\">\n        <div style=\"flex:1\">\n          <div class=\"muted\">Indegrees</div>\n          <div id=\"indegrees\" class=\"list\"></div>\n        </div>\n        <div style=\"flex:1\">\n          <div class=\"muted\">Queue / Stack</div>\n          <div id=\"queue\" class=\"list\"></div>\n        </div>\n      </div>\n      <div style=\"margin-top:8px\">\n        <div class=\"muted\">Output (topological order so far)</div>\n        <div id=\"output\" class=\"topo-output\"></div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <label>Legend & status</label>\n      <div class=\"legend\" style=\"margin-bottom:8px\">\n        <div class=\"chip\">Blue: normal node</div>\n        <div class=\"chip\">Cyan: selected</div>\n        <div class=\"chip\">Green: zero indegree (Kahn)</div>\n        <div class=\"chip\">Yellow: visiting (DFS)</div>\n        <div class=\"chip\">Gray: finished (DFS)</div>\n      </div>\n      <div id=\"status\" class=\"info\">Ready</div>\n    </div>\n\n    <div class=\"footer\">Tip: Try creating a cycle to see detection. Implemented: Kahn's algorithm (BFS indegree) and DFS-based topological sort.</div>\n  </div>\n\n  <div class=\"canvas-wrap\">\n    <svg id=\"svg\" viewBox=\"0 0 1200 800\" preserveAspectRatio=\"xMidYMid meet\">\n      <defs>\n        <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n          <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#8fa8bd\"/>\n        </marker>\n        <marker id=\"arrow-red\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n          <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#ff6b6b\"/>\n        </marker>\n      </defs>\n      <g id=\"edges\"></g>\n      <g id=\"nodes\"></g>\n    </svg>\n    <div class=\"status\">\n      <div><strong>Mode:</strong> <span id=\"modeLabel\">Idle</span></div>\n      <div style=\"margin-top:6px\"><strong>Selected:</strong> <span id=\"selectedLabel\">None</span></div>\n    </div>\n  </div>\n\n<script>\n(function(){\n  // Simple topological sort visualizer with interactive graph building\n  const svg = document.getElementById('svg');\n  const edgesG = document.getElementById('edges');\n  const nodesG = document.getElementById('nodes');\n  const addNodeBtn = document.getElementById('addNodeBtn');\n  const edgeModeBtn = document.getElementById('edgeModeBtn');\n  const delModeBtn = document.getElementById('delModeBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const randBtn = document.getElementById('randBtn');\n  const randN = document.getElementById('randN');\n  const randP = document.getElementById('randP');\n  const modeLabel = document.getElementById('modeLabel');\n  const selectedLabel = document.getElementById('selectedLabel');\n  const status = document.getElementById('status');\n\n  const indegEl = document.getElementById('indegrees');\n  const queueEl = document.getElementById('queue');\n  const outputEl = document.getElementById('output');\n\n  const kahnBtn = document.getElementById('kahnBtn');\n  const kahnStepBtn = document.getElementById('kahnStepBtn');\n  const kahnPlayBtn = document.getElementById('kahnPlayBtn');\n  const kahnStopBtn = document.getElementById('kahnStopBtn');\n\n  const dfsBtn = document.getElementById('dfsBtn');\n  const dfsStepBtn = document.getElementById('dfsStepBtn');\n  const dfsPlayBtn = document.getElementById('dfsPlayBtn');\n  const dfsStopBtn = document.getElementById('dfsStopBtn');\n\n  const speedInput = document.getElementById('speed');\n\n  let nodes = []; // {id,label,x,y,el,circle,txt}\n  let edges = []; // {from,to,el,path}\n  let nextId = 0;\n\n  let mode = 'idle'; // 'idle','edge','delete'\n  let selectedNode = null;\n  let edgeFrom = null;\n\n  let drag = {node:null,offsetX:0,offsetY:0};\n\n  // Algorithm state controllers\n  let kahnRunner = null;\n  let kahnTimer = null;\n  let dfsRunner = null;\n  let dfsTimer = null;\n\n  function setMode(m){\n    mode = m;\n    modeLabel.textContent = m === 'idle' ? 'Idle' : m === 'edge' ? 'Add edge' : 'Delete';\n    addNodeBtn.classList.toggle('active', m==='idle' && false);\n    edgeModeBtn.classList.toggle('active', m==='edge');\n    delModeBtn.classList.toggle('active', m==='delete');\n    edgeFrom = null;\n    updateSelectedLabel();\n  }\n\n  addNodeBtn.addEventListener('click', ()=>{ addNodeAt(Math.random()*1000+100, Math.random()*500+100); });\n\n  edgeModeBtn.addEventListener('click', ()=> setMode(mode==='edge' ? 'idle' : 'edge'));\n  delModeBtn.addEventListener('click', ()=> setMode(mode==='delete' ? 'idle' : 'delete'));\n  clearBtn.addEventListener('click', ()=> { clearGraph(); setStatus('Cleared graph'); });\n\n  randBtn.addEventListener('click', ()=> {\n    const n = Math.max(1, Math.min(26, parseInt(randN.value)||6));\n    const p = Math.max(0, Math.min(100, parseInt(randP.value)||20));\n    generateRandom(n, p/100);\n  });\n\n  function addNodeAt(x,y,label){\n    const id = nextId++;\n    const lbl = label || idToLabel(id);\n    const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n    g.setAttribute('transform', `translate(${x},${y})`);\n    g.style.cursor = 'pointer';\n    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    circle.setAttribute('r', 26);\n    circle.setAttribute('class','node normal');\n    const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n    text.setAttribute('class','node-label');\n    text.textContent = lbl;\n    g.appendChild(circle);\n    g.appendChild(text);\n    nodesG.appendChild(g);\n    const node = {id, label:lbl, x, y, g, circle, text};\n    nodes.push(node);\n\n    g.addEventListener('mousedown', (ev)=>onNodeMouseDown(ev,node));\n    g.addEventListener('click', (ev)=>onNodeClick(ev,node));\n    render();\n    setStatus(`Added node ${lbl}`);\n    return node;\n  }\n\n  function idToLabel(i){\n    // A, B, ... Z, A1, B1 ...\n    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    if(i < 26) return letters[i];\n    return letters[i%26] + Math.floor(i/26);\n  }\n\n  function onNodeMouseDown(ev,node){\n    ev.stopPropagation();\n    if(mode === 'delete'){ deleteNode(node); return; }\n    drag.node = node;\n    const pt = svg.createSVGPoint();\n    pt.x = ev.clientX; pt.y = ev.clientY;\n    const ctm = svg.getScreenCTM().inverse();\n    const loc = pt.matrixTransform(ctm);\n    drag.offsetX = loc.x - node.x; drag.offsetY = loc.y - node.y;\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('mouseup', onMouseUp);\n  }\n\n  function onMouseMove(ev){\n    if(!drag.node) return;\n    const pt = svg.createSVGPoint();\n    pt.x = ev.clientX; pt.y = ev.clientY;\n    const ctm = svg.getScreenCTM().inverse();\n    const loc = pt.matrixTransform(ctm);\n    drag.node.x = loc.x - drag.offsetX;\n    drag.node.y = loc.y - drag.offsetY;\n    drag.node.g.setAttribute('transform', `translate(${drag.node.x},${drag.node.y})`);\n    updateEdgesForNode(drag.node);\n  }\n\n  function onMouseUp(){\n    drag.node = null;\n    window.removeEventListener('mousemove', onMouseMove);\n    window.removeEventListener('mouseup', onMouseUp);\n  }\n\n  function onNodeClick(ev,node){\n    ev.stopPropagation();\n    if(mode === 'edge'){\n      if(!edgeFrom){ edgeFrom = node; setStatus('Pick destination node'); updateSelectedLabel(); highlightNodeEdge(edgeFrom, true); return; }\n      if(edgeFrom === node){ setStatus('Cannot create self-loop'); highlightNodeEdge(edgeFrom,false); edgeFrom=null; updateSelectedLabel(); return; }\n      addEdge(edgeFrom, node);\n      setStatus(`Edge ${edgeFrom.label} → ${node.label} added`);\n      highlightNodeEdge(edgeFrom,false);\n      edgeFrom = null; updateSelectedLabel();\n      render();\n      return;\n    }\n    if(mode === 'delete'){\n      // delete edges incident to node then node\n      deleteNode(node);\n      return;\n    }\n    // select node (for highlighting)\n    if(selectedNode === node){ selectedNode = null; } else selectedNode = node;\n    updateSelectedLabel();\n    render();\n  }\n\n  function updateSelectedLabel(){\n    selectedLabel.textContent = selectedNode ? selectedNode.label : 'None';\n  }\n\n  function highlightNodeEdge(node, on){\n    if(!node) return;\n    node.circle.classList.toggle('selected', on);\n  }\n\n  function addEdge(u,v){\n    // prevent duplicates\n    if(edges.find(e=>e.from===u && e.to===v)) return;\n    const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n    path.setAttribute('class','edge');\n    path.setAttribute('marker-end','url(#arrow)');\n    edgesG.appendChild(path);\n    const e = {from:u,to:v, path};\n    edges.push(e);\n    updateEdgesForNode(u);\n    updateEdgesForNode(v);\n  }\n\n  function deleteEdge(edge){\n    edges = edges.filter(e=>e!==edge);\n    if(edge.path && edge.path.parentNode) edge.path.parentNode.removeChild(edge.path);\n    render();\n  }\n\n  function deleteNode(node){\n    // remove edges incident to node\n    edges.filter(e=>e.from===node || e.to===node).forEach(e=>deleteEdge(e));\n    nodes = nodes.filter(n=>n!==node);\n    if(node.g && node.g.parentNode) node.g.parentNode.removeChild(node.g);\n    setStatus(`Deleted node ${node.label}`);\n    render();\n  }\n\n  function clearGraph(){\n    nodes.forEach(n=>{ if(n.g && n.g.parentNode) n.g.parentNode.removeChild(n.g); });\n    edges.forEach(e=>{ if(e.path && e.path.parentNode) e.path.parentNode.removeChild(e.path); });\n    nodes = []; edges = []; nextId = 0;\n    selectedNode = null; edgeFrom = null;\n    setMode('idle');\n    stopAll();\n    render();\n  }\n\n  function updateEdgesForNode(node){\n    edges.forEach(e=> {\n      if(e.from===node || e.to===node) updateEdgePath(e);\n    });\n  }\n\n  function updateEdgePath(e){\n    const from = e.from, to = e.to;\n    const dx = to.x - from.x;\n    const dy = to.y - from.y;\n    const dist = Math.sqrt(dx*dx+dy*dy);\n    const r = 26;\n    // start and end points offset by circle radius\n    const ux = dx/dist, uy = dy/dist;\n    const startX = from.x + ux*r;\n    const startY = from.y + uy*r;\n    const endX = to.x - ux*(r+6); // stop a bit before arrow marker\n    const endY = to.y - uy*(r+6);\n    // simple curved path for readability if nodes are nearby\n    const midX = (startX + endX)/2 - uy*40;\n    const midY = (startY + endY)/2 + ux*40;\n    const d = `M ${startX} ${startY} Q ${midX} ${midY} ${endX} ${endY}`;\n    e.path.setAttribute('d', d);\n  }\n\n  function render(){\n    // update nodes positions and classes\n    nodes.forEach(n=>{\n      n.g.setAttribute('transform', `translate(${n.x},${n.y})`);\n      n.text.textContent = n.label;\n      // classes\n      n.circle.classList.remove('selected','zero','gray','black','normal');\n      if(edgeFrom === n) n.circle.classList.add('selected');\n      else if(selectedNode === n) n.circle.classList.add('selected');\n      else n.circle.classList.add('normal');\n    });\n    // update edges\n    edges.forEach(e=> updateEdgePath(e));\n    updateIndegreesDisplay();\n    updateQueueDisplay([]);\n    updateOutputDisplay([]);\n  }\n\n  // Build adjacency and indegree\n  function buildGraph(){\n    const adj = new Map();\n    const indeg = new Map();\n    nodes.forEach(n=>{ adj.set(n,[]); indeg.set(n,0); });\n    edges.forEach(e=>{\n      if(!adj.has(e.from) || !adj.has(e.to)) return;\n      adj.get(e.from).push(e.to);\n      indeg.set(e.to, indeg.get(e.to)+1);\n    });\n    return {adj, indeg};\n  }\n\n  function updateIndegreesDisplay(map){\n    const g = map || buildGraph().indeg;\n    let txt = '';\n    nodes.forEach(n=>{\n      const v = g.get(n)??0;\n      txt += `${n.label}: ${v}\\n`;\n    });\n    indegEl.textContent = txt;\n  }\n  function updateQueueDisplay(arr){ queueEl.textContent = (arr||[]).map(x=>x.label || x).join('  '); }\n  function updateOutputDisplay(arr){ outputEl.textContent = (arr||[]).map(n=>n.label || n).join(' → '); }\n\n  function setStatus(txt, cls){\n    status.textContent = txt;\n    if(cls==='error') status.classList.add('error'); else status.classList.remove('error');\n  }\n\n  // Kahn's algorithm as a generator of steps for animation\n  function* kahnGenerator(){\n    const {adj, indeg} = buildGraph();\n    // create a working copy\n    const indegW = new Map(indeg);\n    const Q = [];\n    for(const [node,d] of indegW.entries()) if(d===0) Q.push(node);\n    // sort queue by label for deterministic output\n    Q.sort((a,b)=>a.label.localeCompare(b.label));\n    yield {phase:'init', indeg: new Map(indegW), queue:Q.slice(), output:[]};\n    const out = [];\n    while(Q.length){\n      const u = Q.shift();\n      yield {phase:'pop', node:u, indeg: new Map(indegW), queue:Q.slice(), output: out.slice()};\n      out.push(u);\n      // decrease neighbors one by one (yield per neighbor)\n      for(const v of adj.get(u) || []){\n        indegW.set(v, indegW.get(v)-1);\n        yield {phase:'decr', from:u, to:v, indeg: new Map(indegW), queue: Q.slice(), output: out.slice()};\n        if(indegW.get(v)===0){\n          Q.push(v);\n          Q.sort((a,b)=>a.label.localeCompare(b.label));\n          yield {phase:'push', node:v, indeg:new Map(indegW), queue:Q.slice(), output:out.slice()};\n        }\n      }\n    }\n    yield {phase:'done', indeg:new Map(indegW), queue:Q.slice(), output:out.slice()};\n    // if not all nodes processed, there is a cycle\n  }\n\n  function runKahnStep(){\n    if(!kahnRunner) kahnRunner = kahnGenerator();\n    const step = kahnRunner.next();\n    if(step.done){ setStatus('Kahn finished'); kahnRunner=null; return; }\n    applyKahnStep(step.value);\n  }\n\n  function applyKahnStep(s){\n    // highlight according to phase\n    clearNodeStyles();\n    if(s.phase==='init'){\n      setStatus('Kahn init');\n    } else if(s.phase==='pop'){\n      setStatus(`Pop ${s.node.label} from queue`);\n      highlightNode(s.node,'zero');\n    } else if(s.phase==='decr'){\n      setStatus(`Decrement indegree: ${s.to.label} (from ${s.from.label})`);\n      highlightNode(s.from,'selected'); highlightNode(s.to,'gray');\n      // highlight edge\n      highlightEdge(s.from,s.to);\n    } else if(s.phase==='push'){\n      setStatus(`Push ${s.node.label} to queue (now zero indegree)`);\n      highlightNode(s.node,'zero');\n    } else if(s.phase==='done'){\n      setStatus('Kahn finished');\n    }\n    // update displays\n    updateIndegreesDisplay(s.indeg);\n    updateQueueDisplay(s.queue);\n    updateOutputDisplay(s.output);\n    // final check for cycle at done\n    if(s.phase==='done'){\n      if(s.output.length < nodes.length){\n        setStatus('Cycle detected — no topological ordering (Kahn)', 'error');\n        // mark cycle edges/nodes crudely: nodes not in output are part of cycle(s)\n        const outSet = new Set(s.output);\n        nodes.forEach(n=>{ if(!outSet.has(n)) n.circle.classList.add('cycle'); });\n        edges.forEach(e=>{\n          if(!outSet.has(e.from) && !outSet.has(e.to)) e.path.classList.add('cycle');\n        });\n      } else {\n        setStatus('Topological order (Kahn) complete');\n      }\n      kahnRunner = null;\n      stopKahnTimer();\n    }\n  }\n\n  function highlightNode(node, cls){\n    node.circle.classList.remove('normal','selected','zero','gray','black');\n    node.circle.classList.add(cls);\n  }\n\n  function clearNodeStyles(){\n    nodes.forEach(n=>{\n      n.circle.classList.remove('selected','zero','gray','black','cycle');\n      n.circle.classList.add('normal');\n    });\n    edges.forEach(e=> e.path.classList.remove('cycle'));\n  }\n\n  function highlightEdge(u,v){\n    edges.forEach(e=>{\n      if(e.from===u && e.to===v) e.path.classList.add('cycle');\n      else e.path.classList.remove('cycle');\n    });\n  }\n\n  function playKahn(){\n    if(kahnTimer) return;\n    if(!kahnRunner) kahnRunner = kahnGenerator();\n    kahnTimer = setInterval(()=> {\n      const nxt = kahnRunner.next();\n      if(nxt.done){ applyKahnStep(nxt.value); stopKahnTimer(); return; }\n      applyKahnStep(nxt.value);\n    }, parseInt(speedInput.value) || 700);\n  }\n\n  function stopKahnTimer(){ if(kahnTimer) clearInterval(kahnTimer); kahnTimer=null; kahnRunner=null; }\n\n  // DFS topological sort generator\n  function* dfsGenerator(){\n    const {adj} = buildGraph();\n    const color = new Map(); // white undefined, gray 'gray', black 'black'\n    const order = [];\n    const nodesList = Array.from(adj.keys()).sort((a,b)=>a.label.localeCompare(b.label));\n    // simulate recursion with explicit stack frames: {node, iter, returning}\n    function* visit(u){\n      color.set(u,'gray');\n      yield {phase:'visit', node:u, color: new Map(color), order: order.slice()};\n      const neighbors = adj.get(u) || [];\n      for(const v of neighbors){\n        if(!color.get(v)){\n          // recurse\n          yield* visit(v);\n        } else if(color.get(v) === 'gray'){\n          // back edge -> cycle\n          yield {phase:'backedge', from:u, to:v, color:new Map(color), order:order.slice()};\n        }\n      }\n      color.set(u,'black');\n      order.push(u);\n      yield {phase:'finish', node:u, color:new Map(color), order:order.slice()};\n    }\n\n    for(const u of nodesList){\n      if(!color.get(u)){\n        yield* visit(u);\n      }\n    }\n    yield {phase:'done', color:new Map(color), order: order.slice().reverse()}; // return reversed\n  }\n\n  function runDfsStep(){\n    if(!dfsRunner) dfsRunner = dfsGenerator();\n    const step = dfsRunner.next();\n    if(step.done){ setStatus('DFS finished'); dfsRunner=null; return; }\n    applyDfsStep(step.value);\n  }\n\n  function applyDfsStep(s){\n    clearNodeStyles();\n    if(s.phase==='visit'){\n      setStatus(`Visiting ${s.node.label}`);\n      s.color.forEach((c,node)=> {\n        node.circle.classList.remove('normal','selected','zero','gray','black');\n        if(c==='gray') node.circle.classList.add('gray');\n        else if(c==='black') node.circle.classList.add('black');\n        else node.circle.classList.add('normal');\n      });\n    } else if(s.phase==='backedge'){\n      setStatus(`Back edge detected ${s.from.label} → ${s.to.label} (cycle)`, 'error');\n      highlightEdge(s.from,s.to);\n      s.color.forEach((c,node)=> {\n        node.circle.classList.remove('normal','selected','zero','gray','black');\n        if(c==='gray') node.circle.classList.add('gray');\n        else if(c==='black') node.circle.classList.add('black');\n        else node.circle.classList.add('normal');\n      });\n    } else if(s.phase==='finish'){\n      setStatus(`Finished ${s.node.label}`);\n      s.color.forEach((c,node)=> {\n        node.circle.classList.remove('normal','selected','zero','gray','black');\n        if(c==='gray') node.circle.classList.add('gray');\n        else if(c==='black') node.circle.classList.add('black');\n        else node.circle.classList.add('normal');\n      });\n    } else if(s.phase==='done'){\n      setStatus('DFS topological sort complete');\n      // order is reversed of finishing times\n      updateOutputDisplay(s.order);\n      dfsRunner = null;\n    }\n    // update displays for color-based indegrees/queue placeholders\n    updateIndegreesDisplay(); // not relevant for DFS\n    updateQueueDisplay([]);\n    updateOutputDisplay(s.order || []);\n  }\n\n  function playDfs(){\n    if(dfsTimer) return;\n    if(!dfsRunner) dfsRunner = dfsGenerator();\n    dfsTimer = setInterval(()=> {\n      const nxt = dfsRunner.next();\n      if(nxt.done){ if(nxt.value) applyDfsStep(nxt.value); stopDfsTimer(); return; }\n      applyDfsStep(nxt.value);\n    }, parseInt(speedInput.value) || 700);\n  }\n\n  function stopDfsTimer(){ if(dfsTimer) clearInterval(dfsTimer); dfsTimer=null; dfsRunner=null; }\n\n  function stopAll(){\n    stopKahnTimer();\n    stopDfsTimer();\n  }\n\n  // Buttons\n  kahnStepBtn.addEventListener('click', ()=> { stopDfsTimer(); runKahnStep(); });\n  kahnBtn.addEventListener('click', ()=> { stopAll(); kahnRunner = kahnGenerator(); let s = kahnRunner.next(); if(!s.done) applyKahnStep(s.value); });\n  kahnPlayBtn.addEventListener('click', ()=> { stopDfsTimer(); playKahn(); });\n  kahnStopBtn.addEventListener('click', ()=> { stopKahnTimer(); clearNodeStyles(); updateIndegreesDisplay(); updateQueueDisplay([]); updateOutputDisplay([]); setStatus('Kahn reset'); });\n\n  dfsStepBtn.addEventListener('click', ()=> { stopKahnTimer(); runDfsStep(); });\n  dfsBtn.addEventListener('click', ()=> { stopAll(); dfsRunner = dfsGenerator(); let s = dfsRunner.next(); if(!s.done) applyDfsStep(s.value); });\n  dfsPlayBtn.addEventListener('click', ()=> { stopKahnTimer(); playDfs(); });\n  dfsStopBtn.addEventListener('click', ()=> { stopDfsTimer(); clearNodeStyles(); updateIndegreesDisplay(); updateQueueDisplay([]); updateOutputDisplay([]); setStatus('DFS reset'); });\n\n  // SVG background click to deselect / finalize edge\n  svg.addEventListener('click', (ev)=> {\n    if(mode === 'edge' && edgeFrom){\n      setStatus('Edge creation canceled'); highlightNodeEdge(edgeFrom,false); edgeFrom=null; updateSelectedLabel();\n    } else {\n      selectedNode = null; updateSelectedLabel(); render();\n    }\n  });\n\n  // generate random graph\n  function generateRandom(n, p){\n    clearGraph();\n    // place nodes in a grid-ish layout\n    const w = 1000, h = 600;\n    for(let i=0;i<n;i++){\n      const angle = Math.random()*Math.PI*2;\n      const r = 200 + Math.random()*200;\n      const x = w/2 + Math.cos(angle)*r;\n      const y = h/2 + Math.sin(angle)*r;\n      addNodeAt(x,y);\n    }\n    // add edges with probability p, but avoid too many cycles by biasing edges from lower index to higher index half the time\n    for(let i=0;i<n;i++){\n      for(let j=0;j<n;j++){\n        if(i===j) continue;\n        if(Math.random() < p){\n          // 60% chance directed i->j if i<j to reduce cycles\n          if(Math.random()<0.6 && i<j) addEdge(nodes[i], nodes[j]);\n          else if(Math.random()<0.6 && j<i) addEdge(nodes[j], nodes[i]);\n          else addEdge(nodes[i], nodes[j]);\n        }\n      }\n    }\n    setStatus(`Generated random graph (${n} nodes)`);\n    render();\n  }\n\n  // initial example\n  (function initExample(){\n    clearGraph();\n    const A = addNodeAt(220,160,'A');\n    const B = addNodeAt(420,120,'B');\n    const C = addNodeAt(620,160,'C');\n    const D = addNodeAt(320,300,'D');\n    const E = addNodeAt(520,320,'E');\n    addEdge(A,B); addEdge(A,D); addEdge(B,C); addEdge(B,D); addEdge(D,E); addEdge(C,E);\n    setStatus('Sample DAG loaded');\n    render();\n  })();\n\n  // Keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === 'e') setMode(mode==='edge' ? 'idle' : 'edge');\n    if(e.key === 'd') setMode(mode==='delete' ? 'idle' : 'delete');\n    if(e.key === 'a') addNodeAt(600+Math.random()*200-100, 350+Math.random()*200-100);\n    if(e.key === 'Escape') { setMode('idle'); edgeFrom=null; updateSelectedLabel(); }\n  });\n\n  // small helpers\n  function stopKahnTimer(){ if(kahnTimer) clearInterval(kahnTimer); kahnTimer=null; kahnRunner=null; }\n  function stopDfsTimer(){ if(dfsTimer) clearInterval(dfsTimer); dfsTimer=null; dfsRunner=null; }\n\n  // Prevent text selection while interacting\n  document.addEventListener('selectstart', (e)=>{ if(drag.node) e.preventDefault(); });\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}