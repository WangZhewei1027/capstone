{
  "id": "d79c5280-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:06.592Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Weighted Graph Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  #graphCanvas {\n    border: 1px solid #ccc;\n    background-color: #fafafa;\n    display: block;\n    margin: auto;\n  }\n  #info {\n    max-width: 600px;\n    margin: 20px auto;\n    text-align: center;\n  }\n  #controls {\n    max-width: 600px;\n    margin: 20px auto;\n    text-align: center;\n  }\n  button {\n    margin: 5px;\n    padding: 10px 16px;\n    font-size: 14px;\n  }\n  #explanation {\n    max-width: 600px;\n    margin: 20px auto;\n    font-size: 14px;\n    line-height: 1.5;\n  }\n</style>\n</head>\n<body>\n\n<h2 style=\"text-align:center\">Weighted Graph Visualization & Demo</h2>\n\n<canvas id=\"graphCanvas\" width=\"600\" height=\"400\"></canvas>\n\n<div id=\"info\"></div>\n\n<div id=\"controls\">\n  <button id=\"btnDijkstra\">Run Dijkstra's Shortest Path</button>\n  <button id=\"btnReset\">Reset Graph</button>\n</div>\n\n<div id=\"explanation\">\n  <h3>About Weighted Graphs</h3>\n  <p>\n    A <strong>weighted graph</strong> is a graph in which each edge has an associated numerical value, called a weight. These weights can represent costs, distances, or any measure relevant to the relationship between nodes.\n  </p>\n  <p>\n    In this demo, nodes are shown as circles, edges as lines labeled with their weights. You can run Dijkstra's algorithm to find the shortest path from a selected start node to all other nodes.\n  </p>\n  <p>\n    To run the algorithm, click the \"Run Dijkstra's Shortest Path\" button. Click on a node in the graph to select the start node (shown in green). The shortest distances will be displayed next to each node.\n  </p>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById(\"graphCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const info = document.getElementById(\"info\");\n  const btnDijkstra = document.getElementById(\"btnDijkstra\");\n  const btnReset = document.getElementById(\"btnReset\");\n\n  const width = canvas.width;\n  const height = canvas.height;\n\n  // Graph data structure\n  // Nodes have id, x/y position on canvas\n  // Edges have from, to, weight\n  class Graph {\n    constructor() {\n      this.nodes = [];\n      this.edges = [];\n      this.adjList = new Map();\n    }\n    addNode(id, x, y) {\n      this.nodes.push({ id, x, y });\n      this.adjList.set(id, []);\n    }\n    addEdge(from, to, weight) {\n      this.edges.push({ from, to, weight });\n      this.adjList.get(from).push({ node: to, weight });\n      this.adjList.get(to).push({ node: from, weight }); // undirected\n    }\n    getNeighbors(node) {\n      return this.adjList.get(node);\n    }\n  }\n\n  // Demo graph - preset nodes and edges\n  const graph = new Graph();\n\n  // Sample nodes placed roughly in a circle\n  const nodePositions = [\n    { id: \"A\", x: width / 2, y: 60 },\n    { id: \"B\", x: 130, y: 130 },\n    { id: \"C\", x: 90, y: 280 },\n    { id: \"D\", x: 270, y: 290 },\n    { id: \"E\", x: 430, y: 280 },\n    { id: \"F\", x: 480, y: 140 },\n    { id: \"G\", x: 370, y: 70 },\n  ];\n\n  nodePositions.forEach(n => graph.addNode(n.id, n.x, n.y));\n\n  // Add edges with weights\n  // The graph is undirected\n  const edgesData = [\n    [\"A\", \"B\", 7],\n    [\"A\", \"G\", 2],\n    [\"B\", \"C\", 3],\n    [\"B\", \"G\", 3],\n    [\"C\", \"D\", 4],\n    [\"C\", \"E\", 8],\n    [\"D\", \"E\", 5],\n    [\"E\", \"F\", 6],\n    [\"F\", \"G\", 4],\n  ];\n\n  edgesData.forEach(([from, to, w]) => graph.addEdge(from, to, w));\n\n  // Drawing parameters\n  const nodeRadius = 20;\n\n  // State variables\n  let selectedStartNode = null;\n  let distances = null;\n  let pathTree = null;\n\n  // Draw graph function\n  function drawGraph() {\n    ctx.clearRect(0, 0, width, height);\n\n    // Draw edges\n    graph.edges.forEach(edge => {\n      const fromNode = graph.nodes.find(n => n.id === edge.from);\n      const toNode = graph.nodes.find(n => n.id === edge.to);\n\n      ctx.beginPath();\n      ctx.strokeStyle = \"#999\";\n      ctx.lineWidth = 2;\n      ctx.moveTo(fromNode.x, fromNode.y);\n      ctx.lineTo(toNode.x, toNode.y);\n      ctx.stroke();\n\n      // Draw weight near mid point\n      const midX = (fromNode.x + toNode.x) / 2;\n      const midY = (fromNode.y + toNode.y) / 2;\n      ctx.fillStyle = \"#000\";\n      ctx.font = \"16px Arial\";\n      ctx.fillText(edge.weight, midX + 5, midY - 5);\n    });\n\n    // Draw nodes\n    graph.nodes.forEach(node => {\n      let fillColor = \"#ddd\";\n      let strokeColor = \"#666\";\n\n      if (node.id === selectedStartNode) {\n        fillColor = \"#6c9\";  // green for start\n        strokeColor = \"#383\";\n      }\n\n      ctx.beginPath();\n      ctx.fillStyle = fillColor;\n      ctx.strokeStyle = strokeColor;\n      ctx.lineWidth = 3;\n      ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // Draw node id\n      ctx.fillStyle = \"#000\";\n      ctx.font = \"bold 16px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(node.id, node.x, node.y);\n\n      // If distances computed, draw distance near node\n      if (distances && distances[node.id] !== Infinity) {\n        ctx.fillStyle = \"#222\";\n        ctx.font = \"14px Arial\";\n        ctx.textAlign = \"right\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(\"Dist: \" + distances[node.id], node.x + nodeRadius + 10, node.y);\n      }\n    });\n\n    // If path tree available, draw shortest path tree edges in highlight\n    if (pathTree) {\n      ctx.strokeStyle = \"#4a90e2\";\n      ctx.lineWidth = 4;\n      Object.entries(pathTree).forEach(([node, parent]) => {\n        if (!parent) return; // root\n\n        const fromNode = graph.nodes.find(n => n.id === node);\n        const toNode = graph.nodes.find(n => n.id === parent);\n\n        ctx.beginPath();\n        ctx.moveTo(fromNode.x, fromNode.y);\n        ctx.lineTo(toNode.x, toNode.y);\n        ctx.stroke();\n      });\n    }\n  }\n\n  // Utility: find node under mouse (simple radius check)\n  function getNodeAt(x, y) {\n    return graph.nodes.find(\n      node => Math.hypot(node.x - x, node.y - y) <= nodeRadius\n    );\n  }\n\n  // Dijkstra's algorithm for shortest path\n  // Returns distances and path tree (parent map)\n  function dijkstra(graph, startId) {\n    const dist = {};\n    const prev = {};\n\n    graph.nodes.forEach(node => {\n      dist[node.id] = Infinity;\n      prev[node.id] = null;\n    });\n    dist[startId] = 0;\n\n    const pq = new MinPriorityQueue();\n    pq.enqueue(startId, 0);\n\n    while (!pq.isEmpty()) {\n      const { element: u } = pq.dequeue();\n\n      for (const neighbor of graph.getNeighbors(u)) {\n        const alt = dist[u] + neighbor.weight;\n        if (alt < dist[neighbor.node]) {\n          dist[neighbor.node] = alt;\n          prev[neighbor.node] = u;\n          pq.enqueue(neighbor.node, alt);\n        }\n      }\n    }\n\n    return { distances: dist, pathTree: prev };\n  }\n\n  // Simple min priority queue using binary heap\n  class MinPriorityQueue {\n    constructor() {\n      this.heap = [];\n    }\n    enqueue(element, priority) {\n      this.heap.push({ element, priority });\n      this.bubbleUp();\n    }\n    bubbleUp() {\n      let idx = this.heap.length - 1;\n      const node = this.heap[idx];\n      while (idx > 0) {\n        let parentIdx = Math.floor((idx - 1) / 2);\n        let parent = this.heap[parentIdx];\n        if (node.priority >= parent.priority) break;\n        this.heap[parentIdx] = node;\n        this.heap[idx] = parent;\n        idx = parentIdx;\n      }\n    }\n    dequeue() {\n      const min = this.heap[0];\n      const end = this.heap.pop();\n      if (this.heap.length > 0) {\n        this.heap[0] = end;\n        this.sinkDown(0);\n      }\n      return min;\n    }\n    sinkDown(idx) {\n      const length = this.heap.length;\n      const node = this.heap[idx];\n\n      while (true) {\n        let leftIdx = 2 * idx + 1;\n        let rightIdx = 2 * idx + 2;\n        let swapIdx = null;\n\n        if (leftIdx < length) {\n          if (this.heap[leftIdx].priority < node.priority) {\n            swapIdx = leftIdx;\n          }\n        }\n        if (rightIdx < length) {\n          if (\n            (swapIdx === null && this.heap[rightIdx].priority < node.priority) ||\n            (swapIdx !== null && this.heap[rightIdx].priority < this.heap[leftIdx].priority)\n          ) {\n            swapIdx = rightIdx;\n          }\n        }\n        if (swapIdx === null) break;\n        this.heap[idx] = this.heap[swapIdx];\n        this.heap[swapIdx] = node;\n        idx = swapIdx;\n      }\n    }\n    isEmpty() {\n      return this.heap.length === 0;\n    }\n  }\n\n  // Event handlers\n  canvas.addEventListener(\"click\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const clickX = e.clientX - rect.left;\n    const clickY = e.clientY - rect.top;\n    const node = getNodeAt(clickX, clickY);\n\n    if (node) {\n      selectedStartNode = node.id;\n      distances = null;\n      pathTree = null;\n      info.textContent = `Selected start node: ${node.id}. Now click \"Run Dijkstra's Shortest Path\" to compute shortest paths.`;\n      drawGraph();\n    }\n  });\n\n  btnDijkstra.addEventListener(\"click\", () => {\n    if (!selectedStartNode) {\n      alert(\"Please select a start node by clicking on a node in the graph first.\");\n      return;\n    }\n    const result = dijkstra(graph, selectedStartNode);\n    distances = result.distances;\n    pathTree = result.pathTree;\n\n    info.textContent = `Shortest paths computed from node ${selectedStartNode}. Distance displayed next to each node. Blue edges show shortest path tree.`;\n\n    drawGraph();\n  });\n\n  btnReset.addEventListener(\"click\", () => {\n    selectedStartNode = null;\n    distances = null;\n    pathTree = null;\n    info.textContent = \"Graph reset. Click on a node to select a start node.\";\n    drawGraph();\n  });\n\n  // Initial draw\n  info.textContent = \"Click on a node to select start node.\";\n  drawGraph();\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}