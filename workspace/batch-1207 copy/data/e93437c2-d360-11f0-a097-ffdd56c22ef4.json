{
  "id": "e93437c2-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:31.564Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Floyd-Warshall Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>Floyd–Warshall Algorithm Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 12px; background: #f7f9fc; color:#111;}\n  h1 { margin: 0 0 8px 0; font-size: 20px; }\n  p.lead { margin: 6px 0 16px 0; color:#333; max-width: 900px; }\n  .controls { display:flex; gap:12px; flex-wrap:wrap; margin-bottom:12px; align-items:center;}\n  .panel { background: white; border: 1px solid #e0e6ef; padding: 10px; border-radius: 8px; box-shadow: 0 1px 2px rgba(20,30,50,0.04); }\n  label { font-size: 13px; color:#333; margin-right:6px;}\n  input[type=\"number\"] { width:68px; padding:6px; border-radius:6px; border:1px solid #cfd8e6; }\n  button { padding:8px 10px; border-radius:6px; border:1px solid #cfd8e6; background: #fff; cursor:pointer; }\n  button.primary { background: linear-gradient(#1e90ff,#0c7bd9); color:white; border-color: #0c7bd9; }\n  button.warn { background: linear-gradient(#ffb37d,#ff8a3d); border-color:#ff8a3d; color:#2b1b10; }\n  select { padding:6px; border-radius:6px; border:1px solid #cfd8e6; }\n  .layout { display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; }\n  .left { width:520px; min-width:320px;}\n  .right { flex:1; min-width:300px;}\n  table.matrix { border-collapse: collapse; margin-top:8px; }\n  table.matrix td, table.matrix th { border:1px solid #e6edf6; padding:6px 8px; text-align:center; min-width:52px; font-family:monospace; }\n  table.matrix th { background:#fbfdff; font-weight:600; }\n  td.editable { cursor:text; background:#fff; }\n  td.current { background:#fffbe6; }\n  td.knode { background:#e8f3ff; }\n  td.updated { background:#e6ffee; transition: background 0.8s ease; }\n  canvas { background: linear-gradient(180deg,#ffffff,#fbfdff); border:1px solid #e6edf6; border-radius:8px; display:block; }\n  .status { margin-top:10px; font-size:14px; }\n  .legend { margin-top:8px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-size:13px;}\n  .legend .item { display:inline-flex; gap:8px; align-items:center; }\n  .swatch { width:14px; height:12px; border-radius:3px; display:inline-block; border:1px solid rgba(0,0,0,0.06);}\n  .small { font-size:13px; color:#444; }\n  .note { font-size:13px; color:#666; margin-top:8px; }\n  .controls-row { display:flex; gap:8px; align-items:center; flex-wrap:wrap;}\n  .matrix-scroll { max-height:360px; overflow:auto; padding-right:6px; }\n  .footer { margin-top:12px; font-size:13px; color:#666; }\n  a { color:#0c7bd9; text-decoration: none; }\n</style>\n</head>\n<body>\n  <h1>Floyd–Warshall Algorithm — Interactive Demonstration</h1>\n  <p class=\"lead\">This demo runs the Floyd–Warshall all-pairs shortest paths algorithm step-by-step. You can edit the adjacency (weight) matrix, generate random graphs, step through or autoplay the algorithm, and reconstruct shortest paths. Use negative weights to see how the algorithm handles them; if a negative cycle exists you'll be notified.</p>\n\n  <div class=\"controls\">\n    <div class=\"panel\">\n      <div style=\"display:flex; gap:8px; align-items:center; margin-bottom:8px;\">\n        <label>Nodes:</label>\n        <input id=\"nodeCount\" type=\"number\" min=\"2\" max=\"12\" value=\"6\"/>\n        <button id=\"resizeBtn\">Resize</button>\n        <button id=\"randBtn\" class=\"primary\">Random Graph</button>\n        <button id=\"clearBtn\">Clear (∞)</button>\n      </div>\n\n      <div style=\"display:flex; gap:8px; align-items:center;\">\n        <button id=\"initBtn\">Initialize Matrices</button>\n        <button id=\"runAllBtn\" class=\"primary\">Run to End</button>\n        <button id=\"stepBtn\">Step</button>\n        <button id=\"playBtn\">Play</button>\n        <button id=\"pauseBtn\" disabled>Pause</button>\n        <button id=\"resetBtn\">Reset</button>\n      </div>\n\n      <div style=\"margin-top:8px; display:flex; gap:8px; align-items:center;\">\n        <label>Speed:</label>\n        <input id=\"speed\" type=\"range\" min=\"100\" max=\"2000\" value=\"600\"/>\n        <span id=\"speedVal\" class=\"small\">600ms</span>\n      </div>\n    </div>\n\n    <div class=\"panel\" style=\"min-width:300px;\">\n      <div style=\"display:flex; gap:8px; align-items:center; margin-bottom:6px;\">\n        <label>From:</label>\n        <select id=\"fromSelect\"></select>\n        <label>To:</label>\n        <select id=\"toSelect\"></select>\n        <button id=\"showPathBtn\">Show Path</button>\n        <button id=\"clearPathBtn\">Clear Highlight</button>\n      </div>\n\n      <div class=\"status panel\" id=\"info\" style=\"border:none; padding:0;\">\n        <div id=\"iteration\">Iteration: k = - (not started)</div>\n        <div id=\"pair\">Pair (i, j): -</div>\n        <div id=\"distanceInfo\">Selected distance: -</div>\n        <div id=\"negCycle\" style=\"color:#b34141; font-weight:600; margin-top:6px;\"></div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"layout\">\n    <div class=\"left panel\">\n      <div style=\"display:flex; gap:10px; align-items:center; justify-content:space-between;\">\n        <div style=\"font-weight:600;\">Adjacency / Weight Matrix (use Infinity as empty)</div>\n        <div class=\"small\">Double-click a cell to edit. Use \"Initialize Matrices\" to load to algorithm.</div>\n      </div>\n      <div class=\"matrix-scroll\" id=\"matrixWrap\" style=\"margin-top:8px;\">\n        <!-- Matrix table inserted here -->\n      </div>\n      <div class=\"legend\">\n        <div class=\"item small\"><span class=\"swatch\" style=\"background:#e8f3ff;border-color:#bfe0ff\"></span> current k node</div>\n        <div class=\"item small\"><span class=\"swatch\" style=\"background:#fffbe6;border-color:#ffe89d\"></span> current pair (i,j)</div>\n        <div class=\"item small\"><span class=\"swatch\" style=\"background:#e6ffee;border-color:#b5f0cf\"></span> recently updated</div>\n      </div>\n      <div class=\"note\">Notes: Use large positive number or \"Infinity\" for no direct edge. The graph is directed. Diagonal values default to 0.</div>\n    </div>\n\n    <div class=\"right panel\">\n      <canvas id=\"graphCanvas\" width=\"720\" height=\"480\"></canvas>\n      <div class=\"footer\">\n        Click \"Show Path\" after selecting From/To to reconstruct the current best path using the algorithm's current next matrix. If any dist[v][v] &lt; 0 a negative cycle exists and shortest paths may be undefined.\n      </div>\n    </div>\n  </div>\n\n<script>\n(function(){\n  // Utility\n  const INF = Infinity;\n  const ui = {\n    nodeCount: document.getElementById('nodeCount'),\n    resizeBtn: document.getElementById('resizeBtn'),\n    randBtn: document.getElementById('randBtn'),\n    clearBtn: document.getElementById('clearBtn'),\n    initBtn: document.getElementById('initBtn'),\n    runAllBtn: document.getElementById('runAllBtn'),\n    stepBtn: document.getElementById('stepBtn'),\n    playBtn: document.getElementById('playBtn'),\n    pauseBtn: document.getElementById('pauseBtn'),\n    resetBtn: document.getElementById('resetBtn'),\n    matrixWrap: document.getElementById('matrixWrap'),\n    fromSelect: document.getElementById('fromSelect'),\n    toSelect: document.getElementById('toSelect'),\n    showPathBtn: document.getElementById('showPathBtn'),\n    clearPathBtn: document.getElementById('clearPathBtn'),\n    iteration: document.getElementById('iteration'),\n    pair: document.getElementById('pair'),\n    distanceInfo: document.getElementById('distanceInfo'),\n    negCycle: document.getElementById('negCycle'),\n    canvas: document.getElementById('graphCanvas'),\n    speed: document.getElementById('speed'),\n    speedVal: document.getElementById('speedVal')\n  };\n\n  let n = parseInt(ui.nodeCount.value,10) || 5;\n  let adj = []; // editable adjacency matrix (user view)\n  let dist = []; // current distances\n  let nextM = []; // next matrix for path reconstruction\n  let initialDist = [];\n  // Floyd-Warshall iterative state\n  let kIdx = -1, iIdx = 0, jIdx = 0;\n  let playing = false;\n  let autoplayTimer = null;\n  let lastUpdated = null; // {i,j, timestamp}\n  let highlightedPathEdges = [];\n  let nodesPos = []; // positions for canvas\n\n  // Initialize matrices\n  function make2D(arr,n,size,fill){\n    arr.length = 0;\n    for(let i=0;i<n;i++){\n      let row = [];\n      for(let j=0;j<n;j++){\n        row.push(fill(i,j));\n      }\n      arr.push(row);\n    }\n  }\n\n  function createEmptyAdj(n){\n    // default: no edges (Infinity), diagonal 0\n    let m = [];\n    for(let i=0;i<n;i++){\n      let row = [];\n      for(let j=0;j<n;j++){\n        row.push(i===j ? 0 : INF);\n      }\n      m.push(row);\n    }\n    return m;\n  }\n\n  function randomGraph(n, density=0.45, maxW=12, allowNeg=false){\n    let m = createEmptyAdj(n);\n    for(let i=0;i<n;i++){\n      for(let j=0;j<n;j++){\n        if(i===j) continue;\n        if(Math.random() < density){\n          let sign = allowNeg && Math.random()<0.12 ? -1 : 1;\n          let w = Math.floor(Math.random()*(maxW-1))+1;\n          m[i][j] = sign * w;\n        } else {\n          m[i][j] = INF;\n        }\n      }\n    }\n    return m;\n  }\n\n  function renderMatrix(){\n    // create a table with header\n    ui.matrixWrap.innerHTML = '';\n    const tbl = document.createElement('table');\n    tbl.className = 'matrix';\n    const thead = document.createElement('thead');\n    const headRow = document.createElement('tr');\n    headRow.appendChild(document.createElement('th')); // corner\n    for(let j=0;j<n;j++){\n      const th = document.createElement('th');\n      th.textContent = j;\n      headRow.appendChild(th);\n    }\n    thead.appendChild(headRow);\n    tbl.appendChild(thead);\n\n    const tbody = document.createElement('tbody');\n    for(let i=0;i<n;i++){\n      const tr = document.createElement('tr');\n      const th = document.createElement('th');\n      th.textContent = i;\n      tr.appendChild(th);\n      for(let j=0;j<n;j++){\n        const td = document.createElement('td');\n        td.dataset.i = i;\n        td.dataset.j = j;\n        td.className = 'editable';\n        td.contentEditable = 'true';\n        td.spellcheck = false;\n        td.style.minWidth = '74px';\n        td.style.maxWidth = '220px';\n        td.style.overflow = 'auto';\n        td.textContent = isFinite(adj[i][j]) ? String(adj[i][j]) : '∞';\n        // events\n        td.addEventListener('blur', onCellEdit);\n        td.addEventListener('keydown', function(e){\n          if(e.key === 'Enter'){ e.preventDefault(); td.blur(); }\n        });\n        tr.appendChild(td);\n      }\n      tbody.appendChild(tr);\n    }\n    tbl.appendChild(tbody);\n    ui.matrixWrap.appendChild(tbl);\n    updateSelects();\n    scheduleCanvasDraw();\n  }\n\n  function onCellEdit(e){\n    const td = e.target;\n    const i = parseInt(td.dataset.i,10);\n    const j = parseInt(td.dataset.j,10);\n    const val = td.textContent.trim();\n    let parsed = parseNumberOrInfinity(val);\n    if(parsed === null){ // invalid -> revert\n      td.textContent = isFinite(adj[i][j]) ? String(adj[i][j]) : '∞';\n      return;\n    }\n    adj[i][j] = parsed;\n    // keep diagonal zero if edited to something else? allow editing diagonal to create negative cycles if user wants.\n    td.textContent = isFinite(adj[i][j]) ? String(adj[i][j]) : '∞';\n    setNotInitializedState();\n    scheduleCanvasDraw();\n  }\n\n  function parseNumberOrInfinity(text){\n    if(text === '' || text.toLowerCase() === 'inf' || text === '∞' || text.toLowerCase() === 'infinity') return INF;\n    // parse number with possible sign\n    const v = Number(text);\n    if(!Number.isFinite(v)) return null;\n    return v;\n  }\n\n  function setNotInitializedState(){\n    ui.iteration.textContent = 'Iteration: k = - (not started)';\n    ui.pair.textContent = 'Pair (i, j): -';\n    ui.distanceInfo.textContent = 'Selected distance: -';\n    ui.negCycle.textContent = '';\n    kIdx = -1;\n    iIdx = 0;\n    jIdx = 0;\n    playing = false;\n    stopAutoplay();\n  }\n\n  // Initialize algorithm's working matrices from adj\n  function initializeAlgorithm(){\n    dist = [];\n    nextM = [];\n    for(let i=0;i<n;i++){\n      dist[i] = [];\n      nextM[i] = [];\n      for(let j=0;j<n;j++){\n        dist[i][j] = adj[i][j];\n        nextM[i][j] = isFinite(adj[i][j]) ? j : null;\n      }\n      // ensure diagonal next points to itself\n      nextM[i][i] = i;\n      if(!isFinite(dist[i][i])) dist[i][i] = 0;\n    }\n    initialDist = dist.map(r => r.slice());\n    kIdx = 0;\n    iIdx = 0;\n    jIdx = 0;\n    ui.iteration.textContent = 'Iteration: k = 0';\n    ui.pair.textContent = `Pair (i, j): (0, 0)`;\n    ui.distanceInfo.textContent = 'Selected distance: -';\n    ui.negCycle.textContent = '';\n    lastUpdated = null;\n    highlightedPathEdges = [];\n    renderStateMatrix(); // show dist matrix with highlights\n    scheduleCanvasDraw();\n  }\n\n  function renderStateMatrix(){\n    // color cells depending on current k and current pair and any recent updates\n    const tds = ui.matrixWrap.querySelectorAll('td.editable');\n    tds.forEach(td=>{\n      const i = parseInt(td.dataset.i,10);\n      const j = parseInt(td.dataset.j,10);\n      td.classList.remove('knode','current','updated');\n      // display current dist (not original adjacency)\n      td.textContent = isFinite(dist[i][j]) ? String(dist[i][j]) : '∞';\n      if(kIdx >= 0 && i === kIdx) td.classList.add('knode');\n      if(i === iIdx && j === jIdx) td.classList.add('current');\n      if(lastUpdated && lastUpdated.i === i && lastUpdated.j === j){\n        td.classList.add('updated');\n        // clear updated after some time\n        setTimeout(()=>{ td.classList.remove('updated'); }, 800);\n      }\n    });\n    updateSelects();\n    updateInfoDisplays();\n  }\n\n  function updateSelects(){\n    // fill from/to selects with node indices\n    const currentLen = ui.fromSelect.children.length;\n    if(currentLen !== n){\n      ui.fromSelect.innerHTML = '';\n      ui.toSelect.innerHTML = '';\n      for(let i=0;i<n;i++){\n        const o1 = document.createElement('option'); o1.value = i; o1.textContent = i;\n        const o2 = document.createElement('option'); o2.value = i; o2.textContent = i;\n        ui.fromSelect.appendChild(o1);\n        ui.toSelect.appendChild(o2);\n      }\n    }\n  }\n\n  function floydStep(){\n    if(kIdx < 0 || kIdx >= n) return false;\n    // process current (iIdx, jIdx)\n    const i = iIdx, j = jIdx, k = kIdx;\n    const kij = (isFinite(dist[i][k]) && isFinite(dist[k][j])) ? dist[i][k] + dist[k][j] : INF;\n    if(kij < dist[i][j]){\n      dist[i][j] = kij;\n      // update next matrix to reconstruct path: next[i][j] = next[i][k]\n      nextM[i][j] = nextM[i][k];\n      lastUpdated = {i:i,j:j,ts:Date.now()};\n      // mark changed\n    }\n    // advance indices\n    jIdx++;\n    if(jIdx >= n){ jIdx = 0; iIdx++; }\n    if(iIdx >= n){ iIdx = 0; kIdx++; ui.iteration.textContent = `Iteration: k = ${kIdx}`; }\n    // update displays\n    ui.pair.textContent = `Pair (i, j): (${iIdx}, ${jIdx})`;\n    renderStateMatrix();\n    checkNegativeCycle();\n    // return whether finished\n    return !(kIdx < n);\n  }\n\n  function runToEnd(){\n    // run Floyd–Warshall to completion synchronously (fast)\n    for(let k = kIdx < 0 ? 0 : kIdx; k < n; k++){\n      for(let i = (k === kIdx ? iIdx : 0); i < n; i++){\n        for(let j = (k === kIdx && i === iIdx ? jIdx : 0); j < n; j++){\n          const alt = (isFinite(dist[i][k]) && isFinite(dist[k][j])) ? dist[i][k] + dist[k][j] : INF;\n          if(alt < dist[i][j]){\n            dist[i][j] = alt;\n            nextM[i][j] = nextM[i][k];\n          }\n        }\n      }\n    }\n    kIdx = n;\n    iIdx = 0; jIdx = 0;\n    ui.iteration.textContent = 'Iteration: finished';\n    ui.pair.textContent = 'Pair (i, j): -';\n    renderStateMatrix();\n    checkNegativeCycle();\n    scheduleCanvasDraw();\n  }\n\n  function checkNegativeCycle(){\n    let found = false;\n    for(let v=0; v<n; v++){\n      if(isFinite(dist[v][v]) && dist[v][v] < 0){\n        found = true;\n      }\n    }\n    if(found){\n      ui.negCycle.textContent = 'Negative cycle detected (some dist[v][v] < 0). Shortest paths may be undefined.';\n    } else {\n      ui.negCycle.textContent = '';\n    }\n  }\n\n  function scheduleCanvasDraw(){\n    drawGraph();\n  }\n\n  // Canvas graph visualization\n  const canvas = ui.canvas;\n  const ctx = canvas.getContext('2d');\n\n  function computeNodePositions(){\n    nodesPos = [];\n    const w = canvas.width, h = canvas.height;\n    const r = Math.min(w,h)/2 - 80;\n    const cx = w/2, cy = h/2;\n    for(let i=0;i<n;i++){\n      const ang = -Math.PI/2 + (2*Math.PI*i)/n;\n      const x = cx + r*Math.cos(ang);\n      const y = cy + r*Math.sin(ang);\n      nodesPos.push({x,y});\n    }\n  }\n\n  function drawGraph(){\n    computeNodePositions();\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    // draw edges\n    ctx.font = '13px system-ui, Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    // draw all directed edges that are finite in adj (original) as faint lines\n    for(let i=0;i<n;i++){\n      for(let j=0;j<n;j++){\n        if(i===j) continue;\n        const wgt = adj[i][j];\n        if(!isFinite(wgt)) continue;\n        drawEdge(nodesPos[i], nodesPos[j], String(wgt), '#d6e6ff', 1, false);\n      }\n    }\n    // draw shortest-path edges highlighted if path selected\n    for(const e of highlightedPathEdges){\n      drawEdge(nodesPos[e.u], nodesPos[e.v], '', '#2c7be5', 3, true);\n    }\n    // draw nodes\n    for(let i=0;i<n;i++){\n      const p = nodesPos[i];\n      const rad = 20;\n      // if current k, draw special color\n      if(kIdx >= 0 && i === kIdx){\n        ctx.fillStyle = '#e8f3ff';\n        ctx.strokeStyle = '#bfe0ff';\n      } else {\n        ctx.fillStyle = '#fff';\n        ctx.strokeStyle = '#dbe8ff';\n      }\n      ctx.lineWidth = 2;\n      roundRect(ctx, p.x-rad, p.y-rad, rad*2, rad*2, 8, true, true);\n      ctx.fillStyle = '#0c1f3a';\n      ctx.font = '13px system-ui, Arial';\n      ctx.fillText(String(i), p.x, p.y);\n    }\n  }\n\n  function drawEdge(a,b,label,color,lineWidth,arrow){\n    // draw curved arrow to avoid overlap for pair (i,j) and (j,i)\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.beginPath();\n    // simple straight with small offset\n    const dx = b.x - a.x, dy = b.y - a.y;\n    const distAB = Math.hypot(dx,dy);\n    const ux = dx / distAB, uy = dy / distAB;\n    const startX = a.x + ux*22;\n    const startY = a.y + uy*22;\n    const endX = b.x - ux*22;\n    const endY = b.y - uy*22;\n    const mx = (startX+endX)/2, my = (startY+endY)/2;\n    // curve control\n    const nx = -uy, ny = ux;\n    const curveOffset = 14;\n    const cx = mx + nx*curveOffset;\n    const cy = my + ny*curveOffset;\n    ctx.moveTo(startX,startY);\n    ctx.quadraticCurveTo(cx,cy,endX,endY);\n    ctx.stroke();\n    // draw arrowhead\n    if(arrow){\n      // find point near end for arrow\n      const t = 0.94;\n      // quadratic bezier point and derivative\n      const qx = (1-t)*(1-t)*startX + 2*(1-t)*t*cx + t*t*endX;\n      const qy = (1-t)*(1-t)*startY + 2*(1-t)*t*cy + t*t*endY;\n      const dxq = 2*(1-t)*(cx - startX) + 2*t*(endX - cx);\n      const dyq = 2*(1-t)*(cy - startY) + 2*t*(endY - cy);\n      const ang = Math.atan2(dyq,dxq);\n      const ah = 8;\n      ctx.beginPath();\n      ctx.moveTo(qx, qy);\n      ctx.lineTo(qx - ah*Math.cos(ang-0.4), qy - ah*Math.sin(ang-0.4));\n      ctx.lineTo(qx - ah*Math.cos(ang+0.4), qy - ah*Math.sin(ang+0.4));\n      ctx.closePath();\n      ctx.fill();\n    }\n    // draw label near midpoint\n    if(label){\n      ctx.fillStyle = '#0c1f3a';\n      ctx.font = '12px system-ui, Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      // compute point at t=0.5 on quadratic\n      const t = 0.5;\n      const qx = (1-t)*(1-t)*startX + 2*(1-t)*t*cx + t*t*endX;\n      const qy = (1-t)*(1-t)*startY + 2*(1-t)*t*cy + t*t*endY;\n      // small background\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.fillRect(qx-18, qy-10, 36, 20);\n      ctx.fillStyle = '#0c1f3a';\n      ctx.fillText(label, qx, qy);\n    }\n  }\n\n  function roundRect(ctx, x, y, w, h, r, fill, stroke){\n    if (typeof r === 'undefined') r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Path reconstruction using nextM (current)\n  function reconstructPath(u,v){\n    if(nextM[u][v] === null) return null;\n    const path = [u];\n    let cur = u;\n    const maxSteps = n+5;\n    for(let i=0;i<maxSteps && cur !== v; i++){\n      cur = nextM[cur][v];\n      if(cur === null || cur === undefined){ return null; }\n      path.push(cur);\n      if(path.length > n+2) return null;\n    }\n    if(path[path.length-1] !== v) return null;\n    return path;\n  }\n\n  function highlightPath(u,v){\n    highlightedPathEdges = [];\n    const path = reconstructPath(u,v);\n    if(!path){\n      alert('No path found (using current algorithm state).');\n      return;\n    }\n    for(let i=0;i<path.length-1;i++){\n      highlightedPathEdges.push({u: path[i], v: path[i+1]});\n    }\n    scheduleCanvasDraw();\n    // show distance\n    const d = dist[u][v];\n    ui.distanceInfo.textContent = 'Selected distance: ' + (isFinite(d) ? String(d) : '∞');\n  }\n\n  // Event wiring\n  ui.resizeBtn.addEventListener('click', ()=>{\n    const newN = Math.max(2, Math.min(12, parseInt(ui.nodeCount.value,10) || 2));\n    n = newN;\n    adj = createEmptyAdj(n);\n    renderMatrix();\n    setNotInitializedState();\n  });\n\n  ui.randBtn.addEventListener('click', ()=>{\n    const allowNeg = confirm('Allow some negative edges? (May create negative cycles)');\n    adj = randomGraph(n, 0.45, 12, allowNeg);\n    renderMatrix();\n    setNotInitializedState();\n  });\n\n  ui.clearBtn.addEventListener('click', ()=>{\n    adj = createEmptyAdj(n);\n    renderMatrix();\n    setNotInitializedState();\n  });\n\n  ui.initBtn.addEventListener('click', ()=>{\n    initializeAlgorithm();\n  });\n\n  ui.stepBtn.addEventListener('click', ()=>{\n    if(kIdx < 0){ alert('Initialize matrices first (click \"Initialize Matrices\").'); return; }\n    if(kIdx >= n){ alert('Algorithm already finished. Reset or re-initialize.'); return; }\n    const finished = floydStep();\n    if(finished){\n      ui.iteration.textContent = 'Iteration: finished';\n      ui.pair.textContent = 'Pair (i, j): -';\n      renderStateMatrix();\n    }\n  });\n\n  ui.runAllBtn.addEventListener('click', ()=>{\n    if(kIdx < 0){ alert('Initialize matrices first (click \"Initialize Matrices\").'); return; }\n    runToEnd();\n  });\n\n  ui.playBtn.addEventListener('click', ()=>{\n    if(kIdx < 0){ alert('Initialize matrices first (click \"Initialize Matrices\").'); return; }\n    if(kIdx >= n){ alert('Algorithm already finished.'); return; }\n    playing = true;\n    ui.playBtn.disabled = true;\n    ui.pauseBtn.disabled = false;\n    scheduleAutoplay();\n  });\n\n  ui.pauseBtn.addEventListener('click', ()=>{\n    playing = false;\n    ui.playBtn.disabled = false;\n    ui.pauseBtn.disabled = true;\n    stopAutoplay();\n  });\n\n  ui.resetBtn.addEventListener('click', ()=>{\n    if(!initialDist || !initialDist.length) { initializeAlgorithm(); return; }\n    // revert dist and next to initial\n    dist = initialDist.map(r=>r.slice());\n    nextM = [];\n    for(let i=0;i<n;i++){\n      nextM[i] = [];\n      for(let j=0;j<n;j++){\n        nextM[i][j] = isFinite(adj[i][j]) ? j : null;\n      }\n      nextM[i][i] = i;\n    }\n    kIdx = 0; iIdx=0; jIdx=0;\n    lastUpdated = null;\n    ui.iteration.textContent = 'Iteration: k = 0';\n    ui.pair.textContent = 'Pair (i, j): (0,0)';\n    renderStateMatrix();\n    scheduleCanvasDraw();\n  });\n\n  ui.showPathBtn.addEventListener('click', ()=>{\n    const u = parseInt(ui.fromSelect.value,10);\n    const v = parseInt(ui.toSelect.value,10);\n    highlightPath(u,v);\n  });\n\n  ui.clearPathBtn.addEventListener('click', ()=>{\n    highlightedPathEdges = [];\n    scheduleCanvasDraw();\n    ui.distanceInfo.textContent = 'Selected distance: -';\n  });\n\n  ui.speed.addEventListener('input', ()=>{\n    ui.speedVal.textContent = ui.speed.value + 'ms';\n    if(playing){\n      stopAutoplay();\n      scheduleAutoplay();\n    }\n  });\n\n  function scheduleAutoplay(){\n    if(!playing) return;\n    const delay = parseInt(ui.speed.value,10) || 600;\n    autoplayTimer = setTimeout(()=>{\n      const finished = floydStep();\n      if(finished){\n        playing = false;\n        ui.playBtn.disabled = false;\n        ui.pauseBtn.disabled = true;\n        stopAutoplay();\n        ui.iteration.textContent = 'Iteration: finished';\n      } else {\n        scheduleAutoplay();\n      }\n    }, delay);\n  }\n\n  function stopAutoplay(){\n    if(autoplayTimer){ clearTimeout(autoplayTimer); autoplayTimer = null; }\n  }\n\n  function start(){\n    // initial adjacency\n    adj = randomGraph(n, 0.45, 12, false);\n    renderMatrix();\n    setNotInitializedState();\n    computeNodePositions();\n    drawGraph();\n    window.addEventListener('resize', ()=>{ /* no-op for now */ });\n  }\n\n  // helper: draw once on load\n  start();\n\n  // expose small keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === ' '){ // space toggles play/pause\n      e.preventDefault();\n      if(playing) ui.pauseBtn.click(); else ui.playBtn.click();\n    }\n  });\n\n  // show current matrix values update animation\n  // keep canvas responsive: redraw on interval if changes\n  setInterval(()=>{\n    // occasionally re-render updated class remove (safety)\n    if(lastUpdated && Date.now() - lastUpdated.ts > 900) lastUpdated = null;\n  }, 500);\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Floyd-Warshall Algorithm"
    }
  ],
  "topic": "Floyd-Warshall Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}