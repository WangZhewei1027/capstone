{
  "id": "e9332650-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:38:40.867Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>Interactive Graph (Directed / Undirected)</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<style>\n  :root{--bg:#f7f9fc;--panel:#fff;--accent:#0b74de;--muted:#6b7280}\n  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial}\n  body{background:linear-gradient(180deg,#eef5ff 0%,#fbfdff 100%);display:flex;flex-direction:column}\n  header{padding:12px 18px;border-bottom:1px solid rgba(15,23,42,0.06);display:flex;gap:12px;align-items:center;background:var(--panel)}\n  h1{font-size:16px;margin:0;color:#07203a}\n  .toolbar{display:flex;gap:8px;align-items:center;margin-left:8px;flex-wrap:wrap}\n  button,select,input[type=\"text\"]{background:white;border:1px solid #e2e8f0;padding:6px 8px;border-radius:6px;font-size:13px}\n  button.primary{background:var(--accent);color:white;border-color:transparent}\n  .main{display:flex;flex:1;gap:12px;padding:12px;align-items:stretch}\n  .canvas-wrap{flex:1;background:var(--panel);border-radius:10px;padding:10px;box-shadow:0 2px 8px rgba(16,24,40,0.04);display:flex;flex-direction:column;min-height:420px}\n  #svgcanvas{flex:1;background:linear-gradient(180deg,#fff 0%,#fbfdff 100%);border-radius:6px;border:1px solid #e6eef8}\n  .side{width:320px;min-width:240px;background:var(--panel);border-radius:10px;padding:12px;box-shadow:0 2px 8px rgba(16,24,40,0.04);font-size:13px}\n  .status{padding:8px;border-radius:8px;background:#f1f8ff;color:#083d77;margin-top:8px}\n  label{display:flex;gap:8px;align-items:center;font-weight:600}\n  .controls{display:flex;gap:6px;flex-wrap:wrap;align-items:center}\n  textarea{width:100%;height:160px;font-family:monospace;padding:8px;border-radius:8px;border:1px solid #e6eef8}\n  .list{max-height:220px;overflow:auto;margin-top:8px;padding:6px;border-radius:8px;border:1px dashed #e6eef8;background:linear-gradient(180deg,#fff,#fbfdff)}\n  .small{font-size:12px;color:var(--muted)}\n  .node-label{font-weight:700;fill:#05263b}\n  .muted{color:#667085}\n  .hint{font-size:12px;color:#94a3b8;margin-top:8px}\n</style>\n</head>\n<body>\n<header>\n  <h1>Interactive Graph — Directed / Undirected</h1>\n  <div class=\"toolbar\">\n    <label class=\"small\">Mode:\n      <select id=\"modeSelect\" title=\"Switch between directed and undirected\">\n        <option value=\"directed\">Directed</option>\n        <option value=\"undirected\">Undirected</option>\n      </select>\n    </label>\n    <div class=\"controls\">\n      <button id=\"addNodeBtn\">Add Node</button>\n      <button id=\"addEdgeBtn\">Add Edge</button>\n      <button id=\"delBtn\">Delete</button>\n      <button id=\"clearBtn\">Clear</button>\n      <button id=\"randomBtn\">Random</button>\n      <button id=\"exportBtn\">Export</button>\n      <button id=\"importBtn\">Import</button>\n    </div>\n  </div>\n</header>\n\n<div class=\"main\">\n  <div class=\"canvas-wrap\">\n    <svg id=\"svgcanvas\" viewBox=\"0 0 1200 720\"></svg>\n    <div class=\"hint small\">Usage: Click \"Add Node\" then click canvas to place nodes. Click \"Add Edge\", then click source and target nodes. Drag nodes to reposition. Toggle mode to change drawing (directed shows arrows). Delete mode: click node/edge to remove.</div>\n  </div>\n\n  <aside class=\"side\">\n    <div><strong>Selected:</strong> <span id=\"selectedInfo\">None</span></div>\n    <div class=\"status\" id=\"modeStatus\">Mode: Directed</div>\n\n    <div style=\"margin-top:10px\">\n      <label class=\"small\">Edge weight on creation:\n        <input type=\"text\" id=\"weightInput\" placeholder=\"default 1\" style=\"width:80px\"/>\n      </label>\n    </div>\n\n    <div style=\"margin-top:10px\">\n      <button id=\"toggleLabelsBtn\">Toggle Labels</button>\n      <button id=\"toggleWeightsBtn\">Toggle Weights</button>\n      <button id=\"shortestBtn\">Shortest Path</button>\n    </div>\n\n    <div style=\"margin-top:10px\">\n      <label class=\"small\">Path: source\n        <input id=\"sourceInput\" style=\"width:60px\" placeholder=\"A\"/>\n      </label>\n      <label class=\"small\">target\n        <input id=\"targetInput\" style=\"width:60px\" placeholder=\"B\"/>\n      </label>\n    </div>\n\n    <div style=\"margin-top:12px\">\n      <strong>Adjacency List</strong>\n      <div class=\"list\" id=\"adjList\"></div>\n    </div>\n\n    <div style=\"margin-top:12px\">\n      <strong>Adjacency Matrix</strong>\n      <div class=\"list\" id=\"adjMatrix\"></div>\n    </div>\n\n    <div style=\"margin-top:12px\">\n      <strong>Import / Export</strong>\n      <textarea id=\"jsonArea\" placeholder='Paste exported graph JSON here'></textarea>\n    </div>\n  </aside>\n</div>\n\n<script>\n/*\nInteractive graph viewer/editor supporting directed and undirected graphs.\nSingle-file demo without external libs.\nAuthor: AI-generated\n*/\n\nconst svg = document.getElementById('svgcanvas');\nconst modeSelect = document.getElementById('modeSelect');\nconst addNodeBtn = document.getElementById('addNodeBtn');\nconst addEdgeBtn = document.getElementById('addEdgeBtn');\nconst delBtn = document.getElementById('delBtn');\nconst clearBtn = document.getElementById('clearBtn');\nconst randomBtn = document.getElementById('randomBtn');\nconst exportBtn = document.getElementById('exportBtn');\nconst importBtn = document.getElementById('importBtn');\nconst jsonArea = document.getElementById('jsonArea');\nconst selectedInfo = document.getElementById('selectedInfo');\nconst modeStatus = document.getElementById('modeStatus');\nconst weightInput = document.getElementById('weightInput');\nconst toggleLabelsBtn = document.getElementById('toggleLabelsBtn');\nconst toggleWeightsBtn = document.getElementById('toggleWeightsBtn');\nconst shortestBtn = document.getElementById('shortestBtn');\nconst sourceInput = document.getElementById('sourceInput');\nconst targetInput = document.getElementById('targetInput');\nconst adjListDiv = document.getElementById('adjList');\nconst adjMatrixDiv = document.getElementById('adjMatrix');\n\nlet state = {\n  nodes: [], // {id,label,x,y}\n  edges: [], // {id,from,to,weight}\n  directed: true,\n  showLabels: true,\n  showWeights: true,\n};\n\nlet idCounters = {node: 0, edge: 0};\n\nlet mode = 'idle'; // 'idle', 'addNode', 'addEdge', 'delete'\nlet edgePending = null; // nodeId when adding edge\nlet selected = null; // {type:'node'|'edge', id}\nlet dragging = null; // {id, offsetX, offsetY}\nlet highlightedPath = [];\n\nconst NS = \"http://www.w3.org/2000/svg\";\n\n// create defs for arrow marker\nfunction ensureDefs() {\n  let d = svg.querySelector('defs');\n  if (!d) {\n    d = document.createElementNS(NS,'defs');\n    svg.appendChild(d);\n  }\n  if (!document.getElementById('arrow')) {\n    const marker = document.createElementNS(NS,'marker');\n    marker.setAttribute('id','arrow');\n    marker.setAttribute('markerWidth','10');\n    marker.setAttribute('markerHeight','10');\n    marker.setAttribute('refX','10');\n    marker.setAttribute('refY','5');\n    marker.setAttribute('orient','auto');\n    marker.setAttribute('markerUnits','strokeWidth');\n    const path = document.createElementNS(NS,'path');\n    path.setAttribute('d','M0,0 L10,5 L0,10 z');\n    path.setAttribute('fill','#0b74de');\n    marker.appendChild(path);\n    d.appendChild(marker);\n  }\n}\nensureDefs();\n\nfunction setMode(newMode) {\n  mode = newMode;\n  addNodeBtn.classList.toggle('primary', mode==='addNode');\n  addEdgeBtn.classList.toggle('primary', mode==='addEdge');\n  delBtn.classList.toggle('primary', mode==='delete');\n  if (mode !== 'addEdge') {\n    edgePending = null;\n  }\n  updateStatus();\n}\n\nfunction updateStatus() {\n  modeStatus.textContent = `Mode: ${state.directed ? 'Directed' : 'Undirected'} — UI: ${mode}`;\n  if (mode === 'addEdge' && edgePending) {\n    selectedInfo.textContent = `Edge source: ${edgePending}`;\n  } else if (selected) {\n    selectedInfo.textContent = `${selected.type} ${selected.id}`;\n  } else {\n    selectedInfo.textContent = 'None';\n  }\n}\n\nmodeSelect.addEventListener('change', (e) => {\n  state.directed = e.target.value === 'directed';\n  // Keep edges as-is; drawing/adjacency will interpret based on directed flag\n  render();\n});\n\naddNodeBtn.addEventListener('click', () => setMode(mode==='addNode' ? 'idle' : 'addNode'));\naddEdgeBtn.addEventListener('click', () => setMode(mode==='addEdge' ? 'idle' : 'addEdge'));\ndelBtn.addEventListener('click', () => setMode(mode==='delete' ? 'idle' : 'delete'));\nclearBtn.addEventListener('click', () => {\n  if (!confirm('Clear entire graph?')) return;\n  state.nodes = []; state.edges = []; idCounters.node=0; idCounters.edge=0;\n  selected = null; edgePending=null;\n  render();\n});\nrandomBtn.addEventListener('click', () => {\n  const n = Math.floor(Math.random()*6)+4;\n  makeRandomGraph(n, Math.min(1, Math.random()*0.6+0.2));\n});\nexportBtn.addEventListener('click', () => {\n  const obj = {nodes: state.nodes, edges: state.edges, directed: state.directed};\n  jsonArea.value = JSON.stringify(obj, null, 2);\n});\nimportBtn.addEventListener('click', () => {\n  try {\n    const obj = JSON.parse(jsonArea.value);\n    if (!Array.isArray(obj.nodes) || !Array.isArray(obj.edges)) throw new Error('Invalid format');\n    state.nodes = obj.nodes.map(n=>({id:n.id,label:n.label,x:n.x,y:n.y}));\n    state.edges = obj.edges.map(e=>({id:e.id,from:e.from,to:e.to,weight:e.weight||1}));\n    state.directed = !!obj.directed;\n    // reset counters\n    idCounters.node = (state.nodes.reduce((m,n)=>Math.max(m, parseInt(n.id.replace(/[^\\d]/g,'' )||0)),0))+1;\n    idCounters.edge = (state.edges.reduce((m,e)=>Math.max(m, parseInt(e.id.replace(/[^\\d]/g,'' )||0)),0))+1;\n    modeSelect.value = state.directed ? 'directed':'undirected';\n    render();\n    alert('Imported successfully');\n  } catch (err) {\n    alert('Import failed: ' + err.message);\n  }\n});\n\ntoggleLabelsBtn.addEventListener('click', () => {\n  state.showLabels = !state.showLabels;\n  render();\n});\ntoggleWeightsBtn.addEventListener('click', () => {\n  state.showWeights = !state.showWeights;\n  render();\n});\n\nshortestBtn.addEventListener('click', () => {\n  const src = sourceInput.value.trim();\n  const dst = targetInput.value.trim();\n  if (!src || !dst) { alert('Enter source and target node labels (case-sensitive).'); return; }\n  const nodeByLabel = {};\n  state.nodes.forEach(n=> nodeByLabel[n.label]=n);\n  const s = nodeByLabel[src], t = nodeByLabel[dst];\n  if (!s || !t) { alert('Source or target node not found'); return; }\n  const path = shortestPath(s.id, t.id);\n  highlightedPath = path ? pathToEdgeIds(path) : [];\n  render();\n  if (!path) alert('No path found');\n});\n\n// canvas interactions\nsvg.addEventListener('mousedown', (e) => {\n  const pt = screenToSvg(e);\n  if (mode === 'addNode') {\n    const label = nextNodeLabel();\n    const id = 'n'+(++idCounters.node);\n    state.nodes.push({id,label,x:pt.x,y:pt.y});\n    render();\n    setMode('idle');\n  }\n});\n\nfunction nextNodeLabel() {\n  // label nodes as A,B,C,...,AA,...\n  const n = state.nodes.length;\n  let s = '';\n  let i = n;\n  do {\n    s = String.fromCharCode(65 + (i % 26)) + s;\n    i = Math.floor(i/26)-1;\n  } while (i>=0);\n  return s || 'A';\n}\n\nfunction screenToSvg(e) {\n  const rect = svg.getBoundingClientRect();\n  const x = (e.clientX - rect.left) * (svg.viewBox.baseVal.width / rect.width);\n  const y = (e.clientY - rect.top) * (svg.viewBox.baseVal.height / rect.height);\n  return {x,y};\n}\n\n// Rendering\nfunction render() {\n  while (svg.lastChild) svg.removeChild(svg.lastChild);\n  ensureDefs();\n  // background rect to capture clicks\n  const bg = document.createElementNS(NS,'rect');\n  bg.setAttribute('x',0); bg.setAttribute('y',0);\n  bg.setAttribute('width', svg.viewBox.baseVal.width);\n  bg.setAttribute('height', svg.viewBox.baseVal.height);\n  bg.setAttribute('fill','transparent');\n  svg.appendChild(bg);\n\n  // edges first\n  state.edges.forEach(e => {\n    const from = findNode(e.from), to = findNode(e.to);\n    if (!from || !to) return;\n    const opposite = findEdge(to.id, from.id);\n    const isOpposite = !!opposite && state.directed;\n    if (from.id === to.id) {\n      // self-loop: circular arc\n      const group = document.createElementNS(NS,'g');\n      const cx = from.x, cy = from.y;\n      const r = 26;\n      const path = document.createElementNS(NS,'path');\n      const d = `M ${cx} ${cy-r} C ${cx-48} ${cy-80} ${cx+48} ${cy-80} ${cx} ${cy-r}`;\n      path.setAttribute('d',d);\n      path.setAttribute('fill','none');\n      path.setAttribute('stroke','#88a8ff');\n      path.setAttribute('stroke-width',4);\n      if (state.directed) path.setAttribute('marker-end','url(#arrow)');\n      path.style.cursor='pointer';\n      path.addEventListener('click', (ev)=>{ ev.stopPropagation(); onEdgeClick(e.id); });\n      group.appendChild(path);\n      if (state.showWeights) {\n        const w = document.createElementNS(NS,'text');\n        w.setAttribute('x',cx);\n        w.setAttribute('y',cy-r-10);\n        w.setAttribute('text-anchor','middle');\n        w.setAttribute('font-size','12');\n        w.setAttribute('fill','#023047');\n        w.textContent = e.weight || '';\n        group.appendChild(w);\n      }\n      svg.appendChild(group);\n    } else {\n      // check if opposite exists and offset if both present\n      const x1 = from.x, y1 = from.y, x2 = to.x, y2 = to.y;\n      let dx = x2 - x1, dy = y2 - y1;\n      const len = Math.hypot(dx,dy) || 1;\n      dx/=len; dy/=len;\n      let offset = 0;\n      if (isOpposite) offset = 18;\n      const ox = -dy * offset, oy = dx * offset;\n      // compute endpoints offset by node radius\n      const r = 22;\n      const sx = x1 + dx*r + ox, sy = y1 + dy*r + oy;\n      const tx = x2 - dx*r + ox, ty = y2 - dy*r + oy;\n\n      const path = document.createElementNS(NS, isOpposite ? 'path' : 'line');\n      if (isOpposite) {\n        const mx = (sx+tx)/2, my = (sy+ty)/2;\n        // simple quadratic curve for offset\n        const cx_ctrl = mx + ox*0.6, cy_ctrl = my + oy*0.6;\n        const d = `M ${sx} ${sy} Q ${cx_ctrl} ${cy_ctrl} ${tx} ${ty}`;\n        path.setAttribute('d',d);\n      } else {\n        path.setAttribute('x1',sx); path.setAttribute('y1',sy);\n        path.setAttribute('x2',tx); path.setAttribute('y2',ty);\n      }\n      path.setAttribute('stroke','#0b74de');\n      path.setAttribute('stroke-width', state.showWeights ? 4 : 3);\n      path.setAttribute('fill','none');\n      path.style.cursor='pointer';\n      if (state.directed) path.setAttribute('marker-end','url(#arrow)');\n      if (highlightedPath.includes(e.id)) {\n        path.setAttribute('stroke','#ff7043');\n        path.setAttribute('stroke-width',6);\n      }\n      path.addEventListener('click', (ev)=>{ ev.stopPropagation(); onEdgeClick(e.id); });\n      svg.appendChild(path);\n\n      // weight label\n      if (state.showWeights) {\n        const txmid = (sx+tx)/2 + ox*0.2, tymid = (sy+ty)/2 + oy*0.2;\n        const tw = document.createElementNS(NS,'text');\n        tw.setAttribute('x', txmid);\n        tw.setAttribute('y', tymid);\n        tw.setAttribute('text-anchor','middle');\n        tw.setAttribute('font-size','12');\n        tw.setAttribute('fill','#023047');\n        tw.textContent = e.weight || '';\n        svg.appendChild(tw);\n      }\n    }\n  });\n\n  // nodes on top\n  state.nodes.forEach(n => {\n    const g = document.createElementNS(NS,'g');\n    g.setAttribute('transform', `translate(${n.x},${n.y})`);\n    g.style.cursor = 'pointer';\n\n    // circle\n    const c = document.createElementNS(NS,'circle');\n    c.setAttribute('r',22);\n    c.setAttribute('fill','#fff');\n    c.setAttribute('stroke','#0b74de');\n    c.setAttribute('stroke-width',2);\n    g.appendChild(c);\n\n    // label\n    if (state.showLabels) {\n      const t = document.createElementNS(NS,'text');\n      t.setAttribute('x',0); t.setAttribute('y',6);\n      t.setAttribute('text-anchor','middle');\n      t.setAttribute('font-size','14');\n      t.setAttribute('fill','#05263b');\n      t.textContent = n.label;\n      g.appendChild(t);\n    }\n\n    g.addEventListener('mousedown', (ev) => {\n      ev.stopPropagation();\n      const pt = screenToSvg(ev);\n      if (mode === 'addEdge') {\n        if (!edgePending) {\n          edgePending = n.id;\n        } else {\n          const fromId = edgePending, toId = n.id;\n          createEdge(fromId,toId);\n          edgePending = null;\n          setMode('idle');\n        }\n        render();\n        return;\n      }\n      if (mode === 'delete') {\n        // delete node and connected edges\n        state.edges = state.edges.filter(e=> e.from !== n.id && e.to !== n.id);\n        state.nodes = state.nodes.filter(nn=> nn.id !== n.id);\n        render();\n        return;\n      }\n      // start dragging\n      dragging = {id:n.id, offsetX: pt.x - n.x, offsetY: pt.y - n.y};\n      selected = {type:'node', id:n.id};\n      updateStatus();\n    });\n\n    g.addEventListener('click', (ev)=>{ ev.stopPropagation(); /* handled above */ });\n\n    svg.appendChild(g);\n  });\n\n  // update side panels\n  updateAdjacencies();\n  updateStatus();\n}\n\nfunction onEdgeClick(edgeId) {\n  if (mode === 'delete') {\n    state.edges = state.edges.filter(e=> e.id !== edgeId);\n    render(); return;\n  }\n  selected = {type:'edge', id:edgeId};\n  updateStatus();\n}\n\nfunction findNode(id) { return state.nodes.find(n=>n.id===id); }\nfunction findEdge(from,to) { return state.edges.find(e=> e.from===from && e.to===to); }\n\nfunction createEdge(fromId,toId) {\n  if (!state.directed) {\n    // in undirected mode, avoid duplicate undirected edge\n    const exists = state.edges.find(e=>{\n      return (e.from===fromId && e.to===toId) || (e.from===toId && e.to===fromId);\n    });\n    if (exists) { alert('Edge already exists (undirected)'); return; }\n  } else {\n    const exists = state.edges.find(e=> e.from===fromId && e.to===toId);\n    if (exists) { alert('Edge already exists (directed)'); return; }\n  }\n  const w = parseFloat(weightInput.value);\n  const id = 'e'+(++idCounters.edge);\n  state.edges.push({id,from:fromId,to:toId,weight: isNaN(w) ? 1 : w});\n  render();\n}\n\nfunction makeRandomGraph(n, density=0.4) {\n  state.nodes = []; state.edges = []; idCounters.node=0; idCounters.edge=0;\n  const margin = 60;\n  for (let i=0;i<n;i++){\n    const id = 'n'+(++idCounters.node);\n    const label = nextNodeLabel();\n    const x = margin + Math.random()*(svg.viewBox.baseVal.width-2*margin);\n    const y = margin + Math.random()*(svg.viewBox.baseVal.height-2*margin);\n    state.nodes.push({id,label,x,y});\n  }\n  for (let i=0;i<n;i++){\n    for (let j=0;j<n;j++){\n      if (i===j) continue;\n      if (Math.random() < density) {\n        if (!state.directed && j<i) continue; // avoid duplicates in undirected\n        const id = 'e'+(++idCounters.edge);\n        state.edges.push({id,from:state.nodes[i].id,to:state.nodes[j].id,weight:Math.floor(Math.random()*9)+1});\n      }\n    }\n  }\n  render();\n}\n\n// dragging handling on mousemove/up\nwindow.addEventListener('mousemove',(e)=>{\n  if (!dragging) return;\n  const pt = screenToSvg(e);\n  const node = findNode(dragging.id);\n  node.x = pt.x - dragging.offsetX;\n  node.y = pt.y - dragging.offsetY;\n  render(); // re-render while dragging\n});\nwindow.addEventListener('mouseup',(e)=>{\n  dragging = null;\n});\n\n// keyboard shortcuts for convenience\nwindow.addEventListener('keydown', (e)=>{\n  if (e.key === 'Escape') { setMode('idle'); edgePending=null; render();}\n  if (e.key === 'Delete' || e.key === 'Backspace') {\n    if (selected && selected.type==='node') {\n      state.nodes = state.nodes.filter(n=> n.id !== selected.id);\n      state.edges = state.edges.filter(ed=> ed.from !== selected.id && ed.to !== selected.id);\n      selected = null; render();\n    } else if (selected && selected.type==='edge') {\n      state.edges = state.edges.filter(ed=> ed.id !== selected.id);\n      selected = null; render();\n    }\n  }\n});\n\n// adjacency list/matrix display\nfunction updateAdjacencies() {\n  // adjacency list\n  const nodes = state.nodes;\n  const edges = state.edges;\n  const directed = state.directed;\n  const map = {};\n  nodes.forEach(n=> map[n.id]=[]);\n  edges.forEach(e=>{\n    map[e.from].push({to:e.to,weight:e.weight,edgeId:e.id});\n    if (!directed) {\n      map[e.to].push({to:e.from,weight:e.weight,edgeId:e.id});\n    }\n  });\n  adjListDiv.innerHTML = '';\n  nodes.forEach(n=>{\n    const div = document.createElement('div');\n    div.innerHTML = `<strong>${n.label}</strong> (${n.id}): ` + (map[n.id].length ? map[n.id].map(x=>`${labelOf(x.to)}${state.showWeights ? `(${x.weight})` : ''}`).join(', ') : '<span class=\"muted\">—</span>');\n    adjListDiv.appendChild(div);\n  });\n\n  // adjacency matrix\n  const header = [''].concat(nodes.map(n=>n.label));\n  const tbl = document.createElement('table');\n  tbl.setAttribute('cellspacing','6');\n  tbl.style.borderSpacing='6px';\n  const makeCell = (txt, bold=false) => {\n    const td = document.createElement('td');\n    td.textContent = txt;\n    if (bold) td.style.fontWeight='700';\n    td.style.fontSize='13px';\n    td.style.textAlign='center';\n    td.style.minWidth='28px';\n    return td;\n  };\n  // header row\n  const trh = document.createElement('tr');\n  header.forEach((h,idx)=> trh.appendChild(makeCell(h, idx===0?false:true)));\n  tbl.appendChild(trh);\n  nodes.forEach((rnode)=>{\n    const tr = document.createElement('tr');\n    tr.appendChild(makeCell(rnode.label,true));\n    nodes.forEach(cnode=>{\n      let val = 0;\n      const e = state.edges.find(ed => ed.from===rnode.id && ed.to===cnode.id);\n      if (e) val = state.showWeights ? e.weight : 1;\n      if (!state.directed && rnode.id!==cnode.id) {\n        const e2 = state.edges.find(ed => (ed.from===rnode.id && ed.to===cnode.id) || (ed.from===cnode.id && ed.to===rnode.id));\n        if (e2) val = state.showWeights ? e2.weight : 1;\n      }\n      tr.appendChild(makeCell(val || '0'));\n    });\n    tbl.appendChild(tr);\n  });\n  adjMatrixDiv.innerHTML=''; adjMatrixDiv.appendChild(tbl);\n}\n\nfunction labelOf(nodeId) {\n  const n = findNode(nodeId);\n  return n ? n.label : nodeId;\n}\n\n// helpers for shortest path (Dijkstra)\nfunction shortestPath(fromId, toId) {\n  // build adjacency with weights\n  const nodes = state.nodes.map(n=>n.id);\n  const adj = {};\n  nodes.forEach(id=> adj[id]=[]);\n  state.edges.forEach(e=>{\n    adj[e.from].push({to:e.to, w: Number(e.weight||1)});\n    if (!state.directed) adj[e.to].push({to:e.from, w: Number(e.weight||1)});\n  });\n  // Dijkstra\n  const dist = {}, prev = {};\n  const Q = new Set(nodes);\n  nodes.forEach(v=> { dist[v]=Infinity; prev[v]=null; });\n  dist[fromId]=0;\n  while (Q.size) {\n    let u = null; let best=Infinity;\n    Q.forEach(v=> { if (dist[v] < best) { best = dist[v]; u=v; }});\n    if (u === null || dist[u]===Infinity) break;\n    Q.delete(u);\n    if (u === toId) break;\n    for (const {to,w} of adj[u]) {\n      const alt = dist[u] + w;\n      if (alt < dist[to]) { dist[to]=alt; prev[to]=u; }\n    }\n  }\n  if (dist[toId] === Infinity) return null;\n  const path = [];\n  let cur = toId;\n  while (cur) { path.unshift(cur); cur = prev[cur]; }\n  return path;\n}\nfunction pathToEdgeIds(path) {\n  const ids = [];\n  for (let i=0;i<path.length-1;i++){\n    const u=path[i], v=path[i+1];\n    // find edge that connects u->v abiding directed/undirected\n    let e = state.edges.find(ed=> ed.from===u && ed.to===v);\n    if (!e && !state.directed) e = state.edges.find(ed=> (ed.from===u && ed.to===v) || (ed.from===v && ed.to===u));\n    if (e) ids.push(e.id);\n  }\n  return ids;\n}\n\n// small utilities\nsvg.addEventListener('click', (e)=> {\n  if (mode === 'addEdge' && edgePending) { edgePending=null; render(); return; }\n  // clicking background clears selection\n  selected = null; updateStatus();\n});\n\n// helpful: clicking on node label in adj list sets selection\nadjListDiv.addEventListener('click', (e)=> {\n  const txt = e.target.textContent || '';\n  const m = txt.match(/^([A-Z]+)/);\n  // ignore\n});\n\n// initialize with two nodes and an edge\n(function initDemo(){\n  state.directed = true;\n  modeSelect.value = 'directed';\n  const n1='n1', n2='n2', n3='n3';\n  state.nodes = [\n    {id:n1,label:'A',x:200,y:200},\n    {id:n2,label:'B',x:420,y:260},\n    {id:n3,label:'C',x:320,y:420}\n  ];\n  idCounters.node = 3;\n  state.edges = [{id:'e1',from:n1,to:n2,weight:2},{id:'e2',from:n2,to:n3,weight:3}];\n  idCounters.edge = 2;\n  render();\n})();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}