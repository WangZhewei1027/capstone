{
  "id": "e932b121-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:10.629Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Binary Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Binary Tree (BST) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root{\n      --bg:#f7fbff;\n      --panel:#ffffff;\n      --accent:#2b6cb0;\n      --accent-2:#225e9c;\n      --muted:#6b7280;\n      --green:#16a34a;\n      --danger:#ef4444;\n      --node:#eaf2ff;\n      --node-border:#2b6cb0;\n    }\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#e6f0ff);font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;color:#0f172a}\n    .app{\n      max-width:1100px;margin:24px auto;padding:18px;background:var(--panel);box-shadow:0 6px 30px rgba(15,23,42,0.08);border-radius:12px;\n      display:grid;grid-template-columns:360px 1fr;gap:18px;\n    }\n    header{grid-column:1/-1;display:flex;align-items:center;gap:12px}\n    h1{font-size:20px;margin:0}\n    p.subtitle{margin:0;color:var(--muted);font-size:13px}\n    .controls{\n      padding:12px;border-radius:8px;background:linear-gradient(180deg,#ffffff,#f8fbff);box-shadow:inset 0 1px rgba(255,255,255,0.6);\n    }\n    label{display:block;font-size:13px;margin:8px 0 6px;color:var(--muted)}\n    input[type=\"number\"],input[type=\"text\"],select{\n      width:100%;padding:8px;border:1px solid #d1d5db;border-radius:6px;font-size:14px;\n    }\n    .row{display:flex;gap:8px}\n    button{appearance:none;border:0;background:var(--accent);color:white;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600}\n    button.secondary{background:linear-gradient(180deg,#e6eefc,#dbefff);color:var(--accent-2);border:1px solid rgba(43,108,176,0.08)}\n    button.warn{background:var(--danger);}\n    button.ghost{background:transparent;color:var(--accent-2);border:1px solid #dbe9ff}\n    .small{padding:6px 8px;font-size:13px;border-radius:6px}\n    .info{margin-top:10px;padding:10px;border-radius:8px;background:#fbfdff;border:1px solid #eef6ff;font-size:13px;color:#0f172a}\n    .canvas-wrap{background:linear-gradient(180deg,#fcfeff,#eef8ff);border-radius:10px;padding:12px;min-height:560px;overflow:auto}\n    svg{width:100%;height:680px;display:block}\n    .node{cursor:pointer;transition:transform .12s ease}\n    .node:hover{transform:scale(1.04)}\n    .circle{fill:var(--node);stroke:var(--node-border);stroke-width:2}\n    .circle.highlight{fill:gold;stroke:#c47a00}\n    .circle.search{fill:#fef3c7;stroke:#f59e0b}\n    .circle.visit{fill:#bbf7d0;stroke:#16a34a}\n    text{font-weight:700;fill:#0f172a;font-size:12px;text-anchor:middle;dominant-baseline:middle}\n    line.edge{stroke:#9fb7d9;stroke-width:2}\n    .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}\n    .legend .item{display:flex;align-items:center;gap:6px;font-size:13px}\n    .swatch{width:14px;height:14px;border-radius:4px;border:1px solid rgba(0,0,0,0.06)}\n    .swatch.visit{background:#bbf7d0;border-color:#16a34a}\n    .swatch.search{background:#fef3c7;border-color:#f59e0b}\n    .swatch.highlight{background:gold;border-color:#c47a00}\n    .stats{margin-top:12px;display:flex;gap:12px;flex-wrap:wrap}\n    .stat{background:linear-gradient(180deg,#ffffff,#f7fbff);padding:8px;border-radius:8px;border:1px solid #eff6ff;min-width:120px}\n    footer{grid-column:1/-1;margin-top:8px;color:var(--muted);font-size:13px}\n    a.link{color:var(--accent-2);text-decoration:none;font-weight:600}\n    .traversal-list{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}\n    .chip{background:#f1f5f9;padding:6px 8px;border-radius:999px;border:1px solid #e2e8f0;font-weight:600;color:#0f172a}\n    .controls .hint{font-size:12px;color:var(--muted);margin-top:6px}\n    .badge{background:#eef2ff;color:var(--accent-2);padding:4px 8px;border-radius:999px;font-weight:700;border:1px solid #dbe9ff}\n    @media (max-width:920px){\n      .app{grid-template-columns:1fr;max-width:720px;padding:12px}\n      .canvas-wrap{order:2}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Binary Tree Visualizer\">\n    <header>\n      <div>\n        <h1>Binary Tree (BST) Visualizer</h1>\n        <p class=\"subtitle\">Interactive demonstration of a Binary Search Tree: insert, delete, search, traversals, and animations.</p>\n      </div>\n      <div style=\"margin-left:auto;display:flex;gap:8px;align-items:center\">\n        <span class=\"badge\">BST</span>\n        <span style=\"color:var(--muted);font-size:13px\">Nodes are placed by BST rules (value &lt; left, value &gt;= right)</span>\n      </div>\n    </header>\n\n    <aside class=\"controls\" aria-label=\"Controls\">\n      <label for=\"valueInput\">Insert a value (integer)</label>\n      <div class=\"row\" style=\"margin-bottom:8px\">\n        <input id=\"valueInput\" type=\"number\" placeholder=\"e.g. 42\" />\n        <button id=\"insertBtn\" class=\"small\">Insert</button>\n        <button id=\"deleteBtn\" class=\"small ghost\">Delete</button>\n      </div>\n      <div class=\"row\">\n        <input id=\"searchInput\" type=\"number\" placeholder=\"Search value\" />\n        <button id=\"searchBtn\" class=\"small secondary\">Search</button>\n      </div>\n\n      <label style=\"margin-top:10px\">Build / randomize</label>\n      <div class=\"row\" style=\"margin-bottom:8px\">\n        <input id=\"bulkInput\" type=\"text\" placeholder=\"Comma-separated e.g. 8,3,10,1,6\" />\n        <button id=\"buildBtn\" class=\"small\">Build</button>\n      </div>\n      <div class=\"row\" style=\"margin-bottom:8px\">\n        <select id=\"presetSelect\">\n          <option value=\"random\">Random 10</option>\n          <option value=\"sorted\">Sorted 10</option>\n          <option value=\"balanced\">Balanced 15</option>\n        </select>\n        <button id=\"presetBtn\" class=\"small\">Generate</button>\n        <button id=\"clearBtn\" class=\"small warn\">Clear</button>\n      </div>\n\n      <label style=\"margin-top:10px\">Traversals & animation</label>\n      <div class=\"row\" style=\"margin-bottom:8px\">\n        <button id=\"preBtn\" class=\"small secondary\">Preorder</button>\n        <button id=\"inBtn\" class=\"small secondary\">Inorder</button>\n        <button id=\"postBtn\" class=\"small secondary\">Postorder</button>\n        <button id=\"levelBtn\" class=\"small secondary\">Level</button>\n      </div>\n      <div class=\"row\" style=\"margin-bottom:6px\">\n        <label style=\"display:flex;align-items:center;gap:6px\"><input id=\"animateToggle\" type=\"checkbox\" checked/> Animate</label>\n        <label style=\"display:flex;align-items:center;gap:6px\"><input id=\"repeatToggle\" type=\"checkbox\"/> Repeat</label>\n      </div>\n      <div class=\"hint\">Click a node in the visualization to delete it quickly. Duplicate values allowed and go to the right by convention.</div>\n\n      <div class=\"info\" aria-live=\"polite\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center\">\n          <strong>Tree stats</strong>\n          <span id=\"rootValue\" style=\"color:var(--muted)\"></span>\n        </div>\n        <div class=\"stats\">\n          <div class=\"stat\"><div style=\"font-size:12px;color:var(--muted)\">Nodes</div><div id=\"nodeCount\" style=\"font-size:18px;font-weight:800\">0</div></div>\n          <div class=\"stat\"><div style=\"font-size:12px;color:var(--muted)\">Height</div><div id=\"heightVal\" style=\"font-size:18px;font-weight:800\">0</div></div>\n          <div class=\"stat\"><div style=\"font-size:12px;color:var(--muted)\">Last operation</div><div id=\"lastOp\" style=\"font-size:14px;font-weight:700;color:var(--muted)\">—</div></div>\n        </div>\n\n        <div style=\"margin-top:10px\">\n          <strong>Traversal result</strong>\n          <div id=\"traversalOutput\" class=\"traversal-list\" aria-live=\"polite\"></div>\n        </div>\n\n        <div class=\"legend\">\n          <div class=\"item\"><div class=\"swatch visit\"></div> Visited</div>\n          <div class=\"item\"><div class=\"swatch search\"></div> Search result</div>\n          <div class=\"item\"><div class=\"swatch highlight\"></div> Currently highlighted</div>\n        </div>\n      </div>\n      <div style=\"margin-top:8px;font-size:12px;color:var(--muted)\">Tip: Use \"Build\" with comma-separated list to create specific trees. \"Balanced\" preset builds a balanced BST from sorted unique values for demo.</div>\n    </aside>\n\n    <main class=\"canvas-wrap\" id=\"canvasWrap\" aria-label=\"Tree visualization\">\n      <svg id=\"svg\" viewBox=\"0 0 1200 700\" preserveAspectRatio=\"xMidYMin meet\" role=\"img\" aria-label=\"Binary tree diagram\"></svg>\n    </main>\n\n    <footer>\n      This demo implements a Binary Search Tree (BST) with standard operations and visual traversal. Source: interactive demo — no external libraries.\n    </footer>\n  </div>\n\n<script>\n/*\n  Binary Search Tree Visualizer\n  - Supports insert, delete, search\n  - Traversals: preorder, inorder, postorder, level-order with optional animation\n  - Click nodes to delete\n  - Visual layout computed via inorder x positions and depth-based y positions\n*/\n\n(() => {\n  // Utilities\n  const $ = sel => document.querySelector(sel);\n  const svg = $('#svg');\n  const svgNS = \"http://www.w3.org/2000/svg\";\n\n  // Tree Node definition\n  class Node {\n    constructor(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n      this.id = Node._nextId++;\n      // layout\n      this.x = 0;\n      this.y = 0;\n      this.depth = 0;\n    }\n  }\n  Node._nextId = 1;\n\n  // BST operations\n  class BST {\n    constructor() {\n      this.root = null;\n    }\n    insert(val){\n      const n = new Node(val);\n      if(!this.root){ this.root = n; return n; }\n      let cur = this.root;\n      while(true){\n        if(val < cur.val){\n          if(cur.left){ cur = cur.left; continue; }\n          cur.left = n; return n;\n        } else {\n          if(cur.right){ cur = cur.right; continue; }\n          cur.right = n; return n;\n        }\n      }\n    }\n    search(val){\n      let cur = this.root;\n      const path = [];\n      while(cur){\n        path.push(cur);\n        if(val === cur.val) return {found: cur, path};\n        cur = (val < cur.val) ? cur.left : cur.right;\n      }\n      return {found: null, path};\n    }\n    // delete by value: delete first matching node (standard BST delete)\n    delete(val){\n      const deleteRec = (node, val) => {\n        if(!node) return [null, null];\n        if(val < node.val){\n          const [newLeft, deleted] = deleteRec(node.left, val);\n          node.left = newLeft; return [node, deleted];\n        } else if(val > node.val){\n          const [newRight, deleted] = deleteRec(node.right, val);\n          node.right = newRight; return [node, deleted];\n        } else {\n          // found this node to delete\n          // case 0 or 1 child\n          if(!node.left) return [node.right, node];\n          if(!node.right) return [node.left, node];\n          // two children: replace with inorder successor (min of right subtree)\n          let succ = node.right;\n          while(succ.left) succ = succ.left;\n          const succVal = succ.val;\n          // delete successor\n          const [newRight, _] = deleteRec(node.right, succVal);\n          node.val = succVal;\n          node.right = newRight;\n          return [node, node];\n        }\n      };\n      const [newRoot, deleted] = deleteRec(this.root, val);\n      this.root = newRoot;\n      return deleted || null;\n    }\n\n    // delete by node id: helpful for clicking\n    deleteByNodeId(id){\n      // find value at id and delete one occurrence with that value and same id path\n      // We'll perform deletion by value but ensure that when multiple equal values exist\n      // we can remove the exact node: implement a recursive deletion by id\n      const deleteRec = (node, id) => {\n        if(!node) return [null, null];\n        if(node.id === id){\n          // same deletion cases as above\n          if(!node.left) return [node.right, node];\n          if(!node.right) return [node.left, node];\n          // two children: find successor\n          let succ = node.right;\n          while(succ.left) succ = succ.left;\n          const succId = succ.id;\n          const succVal = succ.val;\n          const [newRight, _] = deleteRec(node.right, succId);\n          node.val = succVal;\n          node.right = newRight;\n          return [node, node];\n        } else {\n          const [newLeft, deletedLeft] = deleteRec(node.left, id);\n          if(deletedLeft) { node.left = newLeft; return [node, deletedLeft]; }\n          const [newRight, deletedRight] = deleteRec(node.right, id);\n          node.right = newRight; return [node, deletedRight];\n        }\n      };\n      const [newRoot, deleted] = deleteRec(this.root, id);\n      this.root = newRoot;\n      return deleted || null;\n    }\n\n    countNodes(){\n      const c = (n) => n ? 1 + c(n.left) + c(n.right) : 0;\n      return c(this.root);\n    }\n    height(){\n      const h = (n) => n ? 1 + Math.max(h(n.left), h(n.right)) : 0;\n      return h(this.root);\n    }\n\n    // traversals\n    inorder(){ const out=[]; const f=(n)=>{ if(!n) return; f(n.left); out.push(n); f(n.right); }; f(this.root); return out; }\n    preorder(){ const out=[]; const f=(n)=>{ if(!n) return; out.push(n); f(n.left); f(n.right); }; f(this.root); return out; }\n    postorder(){ const out=[]; const f=(n)=>{ if(!n) return; f(n.left); f(n.right); out.push(n); }; f(this.root); return out; }\n    levelorder(){ const out=[]; if(!this.root) return out; const q=[this.root]; while(q.length){ const n=q.shift(); out.push(n); if(n.left) q.push(n.left); if(n.right) q.push(n.right); } return out; }\n  }\n\n  // Visualization and state\n  const tree = new BST();\n\n  // DOM references\n  const valueInput = $('#valueInput');\n  const insertBtn = $('#insertBtn');\n  const deleteBtn = $('#deleteBtn');\n  const searchInput = $('#searchInput');\n  const searchBtn = $('#searchBtn');\n  const buildBtn = $('#buildBtn');\n  const bulkInput = $('#bulkInput');\n  const presetBtn = $('#presetBtn');\n  const presetSelect = $('#presetSelect');\n  const clearBtn = $('#clearBtn');\n  const preBtn = $('#preBtn');\n  const inBtn = $('#inBtn');\n  const postBtn = $('#postBtn');\n  const levelBtn = $('#levelBtn');\n  const animateToggle = $('#animateToggle');\n  const repeatToggle = $('#repeatToggle');\n  const nodeCountEl = $('#nodeCount');\n  const heightEl = $('#heightVal');\n  const lastOpEl = $('#lastOp');\n  const traversalOutput = $('#traversalOutput');\n  const rootValueEl = $('#rootValue');\n\n  // Drawing helpers\n  const nodeRadius = 22;\n  const levelHeight = 90;\n  let maxX = 1100;\n  let animTimer = null;\n  let currentHighlights = new Set();\n\n  function clearSVG(){\n    while(svg.firstChild) svg.removeChild(svg.firstChild);\n  }\n\n  // Layout: compute x and y positions.\n  // We'll assign x by inorder position index * spacing.\n  function computeLayout(){\n    let idx = 0;\n    const spacing = 70;\n    const assign = (node, depth) => {\n      if(!node) return;\n      node.depth = depth;\n      assign(node.left, depth+1);\n      node.x = 60 + idx * spacing;\n      node.y = 40 + depth * levelHeight;\n      idx++;\n      assign(node.right, depth+1);\n    };\n    assign(tree.root, 0);\n    maxX = Math.max(1100, Math.max(120, idx * spacing + 100));\n    // adjust svg viewbox width\n    svg.setAttribute('viewBox', `0 0 ${maxX} 700`);\n  }\n\n  // Draw edges and nodes\n  function draw(){\n    clearSVG();\n    computeLayout();\n    if(!tree.root) return;\n\n    // draw edges recursively\n    const edges = [];\n    const nodes = [];\n    (function collect(n){\n      if(!n) return;\n      if(n.left) edges.push({from:n,to:n.left});\n      if(n.right) edges.push({from:n,to:n.right});\n      nodes.push(n);\n      collect(n.left); collect(n.right);\n    })(tree.root);\n\n    // draw edges first\n    edges.forEach(e=>{\n      const line = document.createElementNS(svgNS,'line');\n      line.setAttribute('x1', e.from.x);\n      line.setAttribute('y1', e.from.y + nodeRadius - 6);\n      line.setAttribute('x2', e.to.x);\n      line.setAttribute('y2', e.to.y - nodeRadius + 6);\n      line.setAttribute('class','edge');\n      svg.appendChild(line);\n    });\n\n    // draw nodes: group for interaction\n    nodes.forEach(n=>{\n      const g = document.createElementNS(svgNS,'g');\n      g.setAttribute('class','node');\n      g.setAttribute('data-id', n.id);\n      g.setAttribute('transform', `translate(${n.x}, ${n.y})`);\n      g.setAttribute('role','button');\n      g.setAttribute('tabindex','0');\n      // circle\n      const c = document.createElementNS(svgNS,'circle');\n      c.setAttribute('r', nodeRadius);\n      c.setAttribute('class','circle');\n      c.setAttribute('fill', 'var(--node)');\n      // text\n      const t = document.createElementNS(svgNS,'text');\n      t.textContent = String(n.val);\n      // attach\n      g.appendChild(c);\n      g.appendChild(t);\n      // events\n      g.addEventListener('click', (ev)=> {\n        ev.stopPropagation();\n        const id = Number(g.getAttribute('data-id'));\n        const deleted = tree.deleteByNodeId(id);\n        if(deleted){\n          setLastOp(`Deleted node ${deleted.val}`);\n          render();\n        }\n      });\n      g.addEventListener('keydown', (ev)=> {\n        if(ev.key === 'Enter' || ev.key === ' ') { g.click(); ev.preventDefault(); }\n      });\n      svg.appendChild(g);\n    });\n  }\n\n  // Utility to update stats\n  function updateStats(){\n    nodeCountEl.textContent = tree.countNodes();\n    heightEl.textContent = tree.height();\n    rootValueEl.textContent = tree.root ? `root: ${tree.root.val}` : '';\n  }\n\n  function setLastOp(s){\n    lastOpEl.textContent = s;\n  }\n\n  // Clear highlight classes\n  function clearHighlights(){\n    currentHighlights.clear();\n    // remove classes on circles\n    svg.querySelectorAll('circle').forEach(c=> {\n      c.classList.remove('visit','search','highlight');\n      c.style.fill = '';\n      c.style.stroke = '';\n    });\n  }\n\n  // Map node -> SVG element for that node\n  function svgElementForNode(node){\n    if(!node) return null;\n    const g = svg.querySelector(`g.node[data-id=\"${node.id}\"]`);\n    return g;\n  }\n\n  // Mark node style\n  function markNode(node, cls='visit'){\n    const g = svgElementForNode(node);\n    if(!g) return;\n    const c = g.querySelector('circle');\n    c.classList.add(cls);\n    if(cls === 'visit'){\n      c.style.fill = '#bbf7d0';\n      c.style.stroke = '#16a34a';\n    } else if(cls === 'search'){\n      c.style.fill = '#fef3c7';\n      c.style.stroke = '#f59e0b';\n    } else if(cls === 'highlight'){\n      c.style.fill = 'gold';\n      c.style.stroke = '#c47a00';\n    }\n    currentHighlights.add(node.id);\n  }\n\n  // Traversal animation manager\n  async function animateNodes(nodes, options = {delay:500, markClass:'visit', repeat:false}){\n    if(!nodes || nodes.length === 0){\n      traversalOutput.innerHTML = '';\n      return;\n    }\n    const delay = options.delay || 500;\n    const markClass = options.markClass || 'visit';\n    const outValues = [];\n    let idx = 0;\n    let stopped = false;\n\n    // if not animate, mark all at once\n    if(!animateToggle.checked){\n      clearHighlights();\n      nodes.forEach(n => markNode(n, options.resultClass || 'visit'));\n      outValues.push(...nodes.map(n=>n.val));\n      updateTraversalOutput(outValues);\n      await new Promise(r => setTimeout(r, 100));\n      return;\n    }\n\n    // animated step\n    const step = async () => {\n      if(idx >= nodes.length){\n        updateTraversalOutput(outValues);\n        return;\n      }\n      const n = nodes[idx++];\n      clearHighlights();\n      markNode(n, markClass);\n      outValues.push(n.val);\n      updateTraversalOutput(outValues);\n      await new Promise(r => setTimeout(r, delay));\n      if(stopped) return;\n      if(idx < nodes.length) return step();\n      if(repeatToggle.checked && !stopped){\n        // small pause then repeat\n        await new Promise(r => setTimeout(r, 600));\n        idx = 0;\n        outValues.length = 0;\n        return step();\n      }\n    };\n\n    await step();\n  }\n\n  function updateTraversalOutput(arr){\n    traversalOutput.innerHTML = '';\n    arr.forEach(v=>{\n      const span = document.createElement('div');\n      span.className = 'chip';\n      span.textContent = v;\n      traversalOutput.appendChild(span);\n    });\n  }\n\n  // Render function: draws and updates stats\n  function render(){\n    clearHighlights();\n    draw();\n    updateStats();\n  }\n\n  // Wiring up buttons\n  insertBtn.addEventListener('click', ()=>{\n    const v = Number(valueInput.value);\n    if(Number.isNaN(v)){ alert('Please enter a number to insert.'); return; }\n    const n = tree.insert(v);\n    setLastOp(`Inserted ${v}`);\n    valueInput.value = '';\n    render();\n    // highlight inserted node briefly\n    setTimeout(()=>{ clearHighlights(); markNode(n,'highlight'); }, 40);\n  });\n\n  deleteBtn.addEventListener('click', ()=>{\n    const v = Number(valueInput.value);\n    if(Number.isNaN(v)){ alert('Please enter a number to delete.'); return; }\n    const deleted = tree.delete(v);\n    if(deleted){\n      setLastOp(`Deleted ${v}`);\n      render();\n    } else {\n      setLastOp(`Value ${v} not found`);\n    }\n  });\n\n  searchBtn.addEventListener('click', async ()=>{\n    const v = Number(searchInput.value);\n    if(Number.isNaN(v)){ alert('Please enter a number to search.'); return; }\n    // perform search and animate along path\n    const res = tree.search(v);\n    clearHighlights();\n    const delay = 500;\n    for(let i=0;i<res.path.length;i++){\n      const node = res.path[i];\n      clearHighlights();\n      markNode(node,'visit');\n      updateTraversalOutput(res.path.slice(0,i+1).map(n=>n.val));\n      await new Promise(r=>setTimeout(r, delay));\n    }\n    if(res.found){\n      // mark found differently\n      clearHighlights();\n      markNode(res.found,'search');\n      setLastOp(`Found ${v}`);\n    } else {\n      setLastOp(`${v} not found`);\n    }\n  });\n\n  // Bulk build\n  buildBtn.addEventListener('click', ()=>{\n    const text = bulkInput.value.trim();\n    if(!text) { alert('Enter comma separated numbers'); return; }\n    const parts = text.split(',').map(s=>s.trim()).filter(s=>s!=='');\n    const nums = parts.map(s => Number(s)).filter(n => !Number.isNaN(n));\n    if(nums.length === 0){ alert('No valid numbers found'); return; }\n    // clear existing tree\n    tree.root = null;\n    Node._nextId = 1;\n    nums.forEach(n => tree.insert(n));\n    setLastOp(`Built from list (${nums.length} values)`);\n    render();\n  });\n\n  presetBtn.addEventListener('click', ()=>{\n    const sel = presetSelect.value;\n    tree.root = null;\n    Node._nextId = 1;\n    if(sel === 'random'){\n      const arr = Array.from({length:10}, ()=>Math.floor(Math.random()*90)+1);\n      arr.forEach(v=>tree.insert(v));\n      setLastOp('Generated random tree');\n    } else if(sel === 'sorted'){\n      const arr = Array.from({length:10}, (_,i)=>i+1);\n      arr.forEach(v=>tree.insert(v));\n      setLastOp('Generated sorted tree (degenerate)');\n    } else if(sel === 'balanced'){\n      // create balanced BST from 15 unique sorted numbers\n      const arr = Array.from({length:15}, (_,i)=>i+1);\n      const insertMiddle = (a) => {\n        if(a.length===0) return;\n        const mid = Math.floor(a.length/2);\n        tree.insert(a[mid]);\n        insertMiddle(a.slice(0,mid));\n        insertMiddle(a.slice(mid+1));\n      };\n      insertMiddle(arr);\n      setLastOp('Generated balanced tree');\n    }\n    render();\n  });\n\n  clearBtn.addEventListener('click', ()=>{\n    tree.root = null;\n    Node._nextId = 1;\n    clearHighlights();\n    traversalOutput.innerHTML = '';\n    setLastOp('Cleared tree');\n    render();\n  });\n\n  // Traversal buttons\n  inBtn.addEventListener('click', async ()=>{\n    clearHighlights();\n    const nodes = tree.inorder();\n    setLastOp('Inorder traversal');\n    await animateNodes(nodes, {delay:500, markClass:'visit'});\n  });\n  preBtn.addEventListener('click', async ()=>{\n    clearHighlights();\n    const nodes = tree.preorder();\n    setLastOp('Preorder traversal');\n    await animateNodes(nodes, {delay:500, markClass:'visit'});\n  });\n  postBtn.addEventListener('click', async ()=>{\n    clearHighlights();\n    const nodes = tree.postorder();\n    setLastOp('Postorder traversal');\n    await animateNodes(nodes, {delay:500, markClass:'visit'});\n  });\n  levelBtn.addEventListener('click', async ()=>{\n    clearHighlights();\n    const nodes = tree.levelorder();\n    setLastOp('Level-order traversal');\n    await animateNodes(nodes, {delay:500, markClass:'visit'});\n  });\n\n  // Click background clears highlights\n  $('#canvasWrap').addEventListener('click', ()=>{\n    clearHighlights();\n    traversalOutput.innerHTML = '';\n  });\n\n  // initial demo tree\n  (function seedDemo(){\n    const demo = [50,30,70,20,40,60,80,10,25,35,45];\n    demo.forEach(v => tree.insert(v));\n    setLastOp('Initial demo tree');\n    render();\n  })();\n\n  // Resize handling (keep svg height big enough)\n  window.addEventListener('resize', ()=> render());\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Tree"
    }
  ],
  "topic": "Binary Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}