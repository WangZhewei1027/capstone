{
  "id": "f181b5a2-d366-11f0-9b19-a558354ece3e",
  "timestamp": "2025-12-07T12:21:41.244Z",
  "model": "deepseek-chat",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Bellman-Ford Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        \n        .container {\n            display: flex;\n            gap: 20px;\n            flex-wrap: wrap;\n        }\n        \n        .controls {\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n            flex: 1;\n            min-width: 300px;\n        }\n        \n        .visualization {\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n            flex: 2;\n            min-width: 500px;\n            position: relative;\n        }\n        \n        button {\n            background: #007bff;\n            color: white;\n            border: none;\n            padding: 10px 15px;\n            border-radius: 4px;\n            cursor: pointer;\n            margin: 5px;\n        }\n        \n        button:hover {\n            background: #0056b3;\n        }\n        \n        input, textarea {\n            width: 100%;\n            padding: 8px;\n            margin: 5px 0;\n            border: 1px solid #ddd;\n            border-radius: 4px;\n        }\n        \n        .step-info {\n            margin-top: 20px;\n            padding: 15px;\n            background: #f8f9fa;\n            border-radius: 4px;\n            border-left: 4px solid #007bff;\n        }\n        \n        canvas {\n            border: 1px solid #ddd;\n            background: #fff;\n        }\n        \n        .node {\n            position: absolute;\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            background: #007bff;\n            color: white;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n        }\n        \n        .edge {\n            position: absolute;\n            background: #333;\n            transform-origin: 0 0;\n        }\n        \n        .weight {\n            position: absolute;\n            background: white;\n            padding: 2px 5px;\n            border-radius: 3px;\n            font-size: 12px;\n            border: 1px solid #ddd;\n        }\n        \n        .distance {\n            position: absolute;\n            font-size: 12px;\n            color: #666;\n        }\n    </style>\n</head>\n<body>\n    <h1>Bellman-Ford Algorithm Visualization</h1>\n    \n    <div class=\"container\">\n        <div class=\"controls\">\n            <h3>Graph Input</h3>\n            <textarea id=\"graphInput\" rows=\"10\" placeholder=\"Enter graph in format:\n0,1,4\n0,2,2\n1,2,-3\n1,3,2\n2,3,1\nWhere each line is: source,destination,weight\">0,1,4\n0,2,2\n1,2,-3\n1,3,2\n2,3,1</textarea>\n            \n            <label>Number of Nodes:</label>\n            <input type=\"number\" id=\"nodeCount\" value=\"4\" min=\"2\" max=\"10\">\n            \n            <label>Start Node:</label>\n            <input type=\"number\" id=\"startNode\" value=\"0\" min=\"0\" max=\"9\">\n            \n            <button onclick=\"initializeGraph()\">Initialize Graph</button>\n            <button onclick=\"runBellmanFord()\">Run Bellman-Ford</button>\n            <button onclick=\"stepForward()\">Step Forward</button>\n            <button onclick=\"reset()\">Reset</button>\n            \n            <div class=\"step-info\" id=\"stepInfo\">\n                <strong>Instructions:</strong><br>\n                1. Enter graph edges in the format shown<br>\n                2. Set number of nodes and start node<br>\n                3. Click \"Run Bellman-Ford\" to execute the algorithm<br>\n                4. Use \"Step Forward\" to see each iteration<br>\n                5. Negative cycles will be detected and highlighted\n            </div>\n        </div>\n        \n        <div class=\"visualization\">\n            <canvas id=\"graphCanvas\" width=\"600\" height=\"400\"></canvas>\n            <div id=\"graphElements\"></div>\n            <div id=\"algorithmOutput\"></div>\n        </div>\n    </div>\n\n    <script>\n        let graph = [];\n        let distances = [];\n        let predecessors = [];\n        let currentNodePositions = [];\n        let currentStep = 0;\n        let totalSteps = 0;\n        let hasNegativeCycle = false;\n\n        function initializeGraph() {\n            const input = document.getElementById('graphInput').value.trim();\n            const nodeCount = parseInt(document.getElementById('nodeCount').value);\n            const startNode = parseInt(document.getElementById('startNode').value);\n            \n            graph = [];\n            distances = Array(nodeCount).fill(Infinity);\n            predecessors = Array(nodeCount).fill(null);\n            distances[startNode] = 0;\n            currentStep = 0;\n            hasNegativeCycle = false;\n            \n            // Parse input\n            const lines = input.split('\\n');\n            lines.forEach(line => {\n                const parts = line.split(',').map(Number);\n                if (parts.length === 3) {\n                    graph.push({ from: parts[0], to: parts[1], weight: parts[2] });\n                }\n            });\n            \n            totalSteps = nodeCount * graph.length;\n            \n            // Generate node positions for visualization\n            generateNodePositions(nodeCount);\n            \n            // Draw initial graph\n            drawGraph();\n            \n            document.getElementById('stepInfo').innerHTML = \n                `<strong>Graph Initialized:</strong><br>\n                Nodes: ${nodeCount}<br>\n                Edges: ${graph.length}<br>\n                Start Node: ${startNode}<br>\n                Distances initialized: ${distances.join(', ')}`;\n        }\n\n        function generateNodePositions(nodeCount) {\n            currentNodePositions = [];\n            const centerX = 300, centerY = 200;\n            const radius = 150;\n            \n            for (let i = 0; i < nodeCount; i++) {\n                const angle = (2 * Math.PI * i) / nodeCount;\n                const x = centerX + radius * Math.cos(angle);\n                const y = centerY + radius * Math.sin(angle);\n                currentNodePositions.push({ x, y });\n            }\n        }\n\n        function drawGraph() {\n            const canvas = document.getElementById('graphCanvas');\n            const ctx = canvas.getContext('2d');\n            const graphElements = document.getElementById('graphElements');\n            \n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            graphElements.innerHTML = '';\n            \n            // Draw edges\n            graph.forEach(edge => {\n                const fromPos = currentNodePositions[edge.from];\n                const toPos = currentNodePositions[edge.to];\n                \n                // Draw edge line\n                ctx.beginPath();\n                ctx.moveTo(fromPos.x, fromPos.y);\n                ctx.lineTo(toPos.x, toPos.y);\n                ctx.strokeStyle = edge.weight < 0 ? '#dc3545' : '#28a745';\n                ctx.lineWidth = 2;\n                ctx.stroke();\n                \n                // Add weight label\n                const weightDiv = document.createElement('div');\n                weightDiv.className = 'weight';\n                weightDiv.textContent = edge.weight;\n                weightDiv.style.left = ((fromPos.x + toPos.x) / 2 + 10) + 'px';\n                weightDiv.style.top = ((fromPos.y + toPos.y) / 2 - 10) + 'px';\n                graphElements.appendChild(weightDiv);\n                \n                // Draw arrow head\n                drawArrowHead(ctx, fromPos, toPos);\n            });\n            \n            // Draw nodes\n            currentNodePositions.forEach((pos, i) => {\n                const nodeDiv = document.createElement('div');\n                nodeDiv.className = 'node';\n                nodeDiv.textContent = i;\n                nodeDiv.style.left = (pos.x - 20) + 'px';\n                nodeDiv.style.top = (pos.y - 20) + 'px';\n                nodeDiv.style.background = distances[i] === Infinity ? '#6c757d' : \n                                          i === parseInt(document.getElementById('startNode').value) ? '#28a745' : '#007bff';\n                graphElements.appendChild(nodeDiv);\n                \n                // Add distance label\n                const distanceDiv = document.createElement('div');\n                distanceDiv.className = 'distance';\n                distanceDiv.textContent = `d[${i}] = ${distances[i] === Infinity ? '∞' : distances[i]}`;\n                distanceDiv.style.left = (pos.x - 15) + 'px';\n                distanceDiv.style.top = (pos.y + 25) + 'px';\n                graphElements.appendChild(distanceDiv);\n            });\n        }\n\n        function drawArrowHead(ctx, fromPos, toPos) {\n            const headLength = 10;\n            const dx = toPos.x - fromPos.x;\n            const dy = toPos.y - fromPos.y;\n            const angle = Math.atan2(dy, dx);\n            \n            // Adjust arrow position to start from edge of circle\n            const fromX = fromPos.x + 20 * Math.cos(angle);\n            const fromY = fromPos.y + 20 * Math.sin(angle);\n            const toX = toPos.x - 20 * Math.cos(angle);\n            const toY = toPos.y - 20 * Math.sin(angle);\n            \n            // Draw arrow head\n            ctx.beginPath();\n            ctx.moveTo(toX, toY);\n            ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI/6), \n                      toY - headLength * Math.sin(angle - Math.PI/6));\n            ctx.moveTo(toX, toY);\n            ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI/6), \n                      toY - headLength * Math.sin(angle + Math.PI/6));\n            ctx.stroke();\n        }\n\n        function runBellmanFord() {\n            const nodeCount = parseInt(document.getElementById('nodeCount').value);\n            const startNode = parseInt(document.getElementById('startNode').value);\n            \n            // Reset distances\n            distances = Array(nodeCount).fill(Infinity);\n            predecessors = Array(nodeCount).fill(null);\n            distances[startNode] = 0;\n            \n            hasNegativeCycle = false;\n            currentStep = 0;\n            \n            // Run algorithm\n            for (let i = 0; i < nodeCount - 1; i++) {\n                let updated = false;\n                \n                graph.forEach(edge => {\n                    if (distances[edge.from] !== Infinity && \n                        distances[edge.from] + edge.weight < distances[edge.to]) {\n                        distances[edge.to] = distances[edge.from] + edge.weight;\n                        predecessors[edge.to] = edge.from;\n                        updated = true;\n                    }\n                });\n                \n                currentStep++;\n                drawGraph();\n                \n                if (!updated) break;\n            }\n            \n            // Check for negative cycles\n            graph.forEach(edge => {\n                if (distances[edge.from] !== Infinity && \n                    distances[edge.from] + edge.weight < distances[edge.to]) {\n                    hasNegativeCycle = true;\n                }\n            });\n            \n            displayResults();\n        }\n\n        function stepForward() {\n            const nodeCount = parseInt(document.getElementById('nodeCount').value);\n            const startNode = parseInt(document.getElementById('startNode').value);\n            \n            if (currentStep === 0) {\n                distances = Array(nodeCount).fill(Infinity);\n                predecessors = Array(nodeCount).fill(null);\n                distances[startNode] = 0;\n            }\n            \n            if (currentStep < totalSteps) {\n                const edgeIndex = currentStep % graph.length;\n                const iteration = Math.floor(currentStep / graph.length);\n                \n                const edge = graph[edgeIndex];\n                \n                document.getElementById('stepInfo').innerHTML = \n                    `<strong>Step ${currentStep + 1}:</strong><br>\n                    Iteration: ${iteration + 1}<br>\n                    Processing edge: ${edge.from} → ${edge.to} (weight: ${edge.weight})<br>\n                    Current distances: [${distances.join(', ')}]`;\n                \n                if (iteration < nodeCount - 1) {\n                    if (distances[edge.from] !== Infinity && \n                        distances[edge.from] + edge.weight < distances[edge.to]) {\n                        distances[edge.to] = distances[edge.from] + edge.weight;\n                        predecessors[edge.to] = edge.from;\n                        \n                        document.getElementById('stepInfo').innerHTML += \n                            `<br><strong>UPDATE:</strong> d[${edge.to}] = ${distances[edge.to]}`;\n                    }\n                } else if (iteration === nodeCount - 1) {\n                    // Check for negative cycle in final iteration\n                    if (distances[edge.from] !== Infinity && \n                        distances[edge.from] + edge.weight < distances[edge.to]) {\n                        hasNegativeCycle = true;\n                    }\n                }\n                \n                currentStep++;\n                drawGraph();\n                \n                if (currentStep === totalSteps) {\n                    displayResults();\n                }\n            }\n        }\n\n        function displayResults() {\n            let output = '<h3>Algorithm Results:</h3>';\n            \n            if (hasNegativeCycle) {\n                output += '<p style=\"color: #dc3545;\"><strong>Negative cycle detected!</strong> Some distances may be incorrect.</p>';\n            } else {\n                output += '<p style=\"color: #28a745;\"><strong>No negative cycles detected.</strong></p>';\n            }\n            \n            output += '<table border=\"1\" style=\"width: 100%; border-collapse: collapse; margin-top: 10px;\">';\n            output += '<tr><th>Node</th><th>Distance</th><th>Path from Start</th></tr>';\n            \n            distances.forEach((distance, node) => {\n                output += `<tr><td>${node}</td><td>${distance === Infinity ? '∞' : distance}</td>`;\n                \n                if (distance === Infinity) {\n                    output += '<td>Unreachable</td>';\n                } else {\n                    const path = getPath(node);\n                    output += `<td>${path.join(' → ')}</td>`;\n                }\n                \n                output += '</tr>';\n            });\n            \n            output += '</table>';\n            \n            document.getElementById('algorithmOutput').innerHTML = output;\n        }\n\n        function getPath(node) {\n            const path = [];\n            let current = node;\n            \n            while (current !== null) {\n                path.unshift(current);\n                current = predecessors[current];\n            }\n            \n            return path.length > 0 ? path : [node];\n        }\n\n        function reset() {\n            currentStep = 0;\n            hasNegativeCycle = false;\n            initializeGraph();\n            document.getElementById('algorithmOutput').innerHTML = '';\n        }\n\n        // Initialize on load\n        window.onload = initializeGraph;\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}