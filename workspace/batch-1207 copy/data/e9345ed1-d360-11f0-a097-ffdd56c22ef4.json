{
  "id": "e9345ed1-d360-11f0-a097-ffdd56c22ef4",
  "timestamp": "2025-12-07T11:39:44.127Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Prim's Algorithm Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#f6f8fb;\n      --panel:#ffffff;\n      --muted:#6b7280;\n      --accent:#0ea5a4;\n      --danger:#ef4444;\n      --success:#10b981;\n      --edge:#94a3b8;\n    }\n    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;}\n    body{background:linear-gradient(180deg,#eef2ff 0%,var(--bg) 60%);padding:18px;box-sizing:border-box;color:#0f172a;}\n    h1{margin:0 0 8px;font-size:20px;}\n    .wrap{display:flex;gap:16px;align-items:flex-start;}\n    .left{\n      width:760px;\n      min-width:300px;\n      background:var(--panel);\n      border-radius:10px;\n      box-shadow:0 6px 18px rgba(15,23,42,0.08);\n      padding:12px;\n    }\n    .right{\n      width:360px;\n      background:var(--panel);\n      border-radius:10px;\n      box-shadow:0 6px 18px rgba(15,23,42,0.08);\n      padding:12px;\n      display:flex;flex-direction:column;gap:10px;\n      max-height:88vh;overflow:auto;\n    }\n    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px;}\n    button, select, input[type=\"range\"]{border:1px solid #e6eef8;padding:8px;border-radius:8px;background:#fff;cursor:pointer;}\n    button:hover{filter:brightness(.98);}\n    .canvas-wrap{position:relative;border-radius:8px;border:1px solid rgba(15,23,42,0.06);background:linear-gradient(180deg,#fff,#fafcff);height:640px;overflow:hidden;}\n    canvas{display:block;background:transparent;}\n    .hint{font-size:13px;color:var(--muted);margin-top:6px;}\n    .small{font-size:13px;color:var(--muted);}\n    .btn-primary{background:linear-gradient(90deg,var(--accent),#06b6d4);color:white;border:none;}\n    .btn-danger{background:var(--danger);color:#fff;border:none;}\n    .panel{padding:10px;border-radius:8px;border:1px solid rgba(15,23,42,0.04);background:linear-gradient(180deg,#fff,#fcfeff);}\n    .info-row{display:flex;gap:8px;align-items:center;justify-content:space-between}\n    .table{font-family:monospace;background:#f8fafc;padding:8px;border-radius:6px;max-height:220px;overflow:auto;border:1px dashed rgba(15,23,42,0.03);}\n    .node-list{display:flex;flex-direction:column;gap:6px;}\n    .status{padding:8px;border-radius:6px;background:#f1f5f9;font-size:13px;}\n    .legend{display:flex;gap:8px;flex-wrap:wrap;align-items:center}\n    .legend .item{display:flex;gap:6px;align-items:center;font-size:13px}\n    .legend .swatch{width:18px;height:12px;border-radius:4px;border:1px solid rgba(0,0,0,0.06)}\n    .edge-weight{font-family:monospace;font-size:12px;padding:2px 6px;background:rgba(255,255,255,0.8);border-radius:6px;border:1px solid rgba(15,23,42,0.04)}\n    .footer{font-size:13px;color:var(--muted);margin-top:8px;}\n    .control-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n    label{font-size:13px;color:var(--muted);}\n    input[type=number]{width:64px;padding:6px;border-radius:6px;border:1px solid #e6eef8}\n    .log{font-size:13px;background:#0f172a;color:white;padding:8px;border-radius:6px;white-space:pre-wrap}\n    .muted{color:var(--muted)}\n  </style>\n</head>\n<body>\n  <h1>Interactive Prim's Algorithm (Minimum Spanning Tree)</h1>\n  <div class=\"wrap\">\n    <div class=\"left\">\n      <div class=\"controls\">\n        <button id=\"addNodeBtn\">Add Node (click canvas)</button>\n        <button id=\"addEdgeBtn\">Add Edge (click two nodes)</button>\n        <button id=\"deleteBtn\">Delete Mode</button>\n        <button id=\"randomBtn\">Random Graph</button>\n        <button id=\"clearBtn\">Clear Graph</button>\n        <select id=\"startSelect\" title=\"Choose start node\"><option value=\"\">Start Node</option></select>\n        <button id=\"runBtn\" class=\"btn-primary\">Init Prim</button>\n        <button id=\"stepBtn\">Next Step</button>\n        <button id=\"autoBtn\">Auto Play</button>\n        <button id=\"pauseBtn\">Pause</button>\n        <button id=\"resetBtn\">Reset Steps</button>\n      </div>\n      <div class=\"canvas-wrap panel\" id=\"canvasWrap\">\n        <canvas id=\"graphCanvas\" width=\"740\" height=\"620\"></canvas>\n      </div>\n      <div class=\"hint\">\n        - Add nodes by clicking the canvas. Add edges by clicking \"Add Edge\" then selecting two nodes. Weights are prompted (or random if left blank).<br>\n        - Choose a start node from the dropdown (or click a node to select). Click \"Init Prim\" to initialize. Use \"Next Step\" to step through Prim's algorithm, or \"Auto Play\".\n      </div>\n    </div>\n\n    <div class=\"right\">\n      <div class=\"panel\">\n        <div class=\"info-row\">\n          <div><strong>Algorithm Status</strong></div>\n          <div id=\"mstWeight\" class=\"muted\">MST weight: 0</div>\n        </div>\n        <div style=\"height:8px\"></div>\n        <div class=\"legend\">\n          <div class=\"item\"><div class=\"swatch\" style=\"background:#94a3b8\"></div>Unselected edge</div>\n          <div class=\"item\"><div class=\"swatch\" style=\"background:orange\"></div>Candidate edge (updated key)</div>\n          <div class=\"item\"><div class=\"swatch\" style=\"background:#10b981\"></div>MST edge</div>\n          <div class=\"item\"><div class=\"swatch\" style=\"background:#f97316\"></div>Currently selected node</div>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center\">\n          <strong>Nodes & Keys</strong>\n          <div class=\"small muted\">key = best connecting edge weight</div>\n        </div>\n        <div class=\"table\" id=\"nodeTable\">No nodes yet.</div>\n      </div>\n\n      <div class=\"panel\">\n        <strong>Log / Steps</strong>\n        <div id=\"log\" class=\"log\" style=\"background:#0b1220\">No algorithm run yet.</div>\n      </div>\n\n      <div class=\"panel\">\n        <strong>Controls & Shortcuts</strong>\n        <div class=\"small muted\" style=\"margin-top:8px\">\n          - Click a node while in normal mode to set start node.<br>\n          - In \"Add Edge\" mode: click two nodes to create an edge (enter weight).<br>\n          - Delete Mode: click nodes or edges to remove them.<br>\n          - Random Graph creates nodes and edges with random weights; you can control n and density.\n        </div>\n        <div style=\"margin-top:8px\" class=\"control-row\">\n          <label>n</label><input id=\"randN\" type=\"number\" value=\"7\" min=\"2\" />\n          <label>density (0-1)</label><input id=\"randD\" type=\"range\" min=\"0\" max=\"1\" step=\"0.05\" value=\"0.45\" style=\"width:120px\" />\n          <label id=\"randDVal\" class=\"muted\">0.45</label>\n        </div>\n      </div>\n\n      <div class=\"footer muted\">Implementation: step-by-step Prim's algorithm. Data structures shown: key[], parent[], inMST[]. Edges colored as they become part of the MST or when they update a node's key.</div>\n    </div>\n  </div>\n\n<script>\n/*\n  Prim's Algorithm Interactive Demo\n  - Click \"Add Node\" then click canvas to add circles (nodes)\n  - Click \"Add Edge\" then click two nodes to add an undirected weighted edge (enter weight when prompted)\n  - Choose a start node (dropdown or click a node). Click \"Init Prim\" to initialize.\n  - Use \"Next Step\" to advance the algorithm: it picks the vertex with smallest key not in MST, adds its connecting edge,\n    then updates neighbor keys and parents. \"Auto Play\" advances automatically.\n  - Visual: nodes, edges, weights. Colors indicate candidate edges, MST edges, current node, etc.\n*/\n\n(function(){\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n\n  const addNodeBtn = document.getElementById('addNodeBtn');\n  const addEdgeBtn = document.getElementById('addEdgeBtn');\n  const deleteBtn = document.getElementById('deleteBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const runBtn = document.getElementById('runBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const autoBtn = document.getElementById('autoBtn');\n  const pauseBtn = document.getElementById('pauseBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const startSelect = document.getElementById('startSelect');\n  const nodeTable = document.getElementById('nodeTable');\n  const logEl = document.getElementById('log');\n  const mstWeightEl = document.getElementById('mstWeight');\n  const randN = document.getElementById('randN');\n  const randD = document.getElementById('randD');\n  const randDVal = document.getElementById('randDVal');\n\n  randD.addEventListener('input', ()=> randDVal.textContent = randD.value);\n\n  let mode = 'none'; // 'addNode', 'addEdge', 'delete'\n  let nodes = []; // {id,x,y}\n  let edges = []; // {id,a,b,weight,inMST,highlighted,candidate}\n  let nodeIdCounter = 0;\n  let edgeIdCounter = 0;\n\n  // Prim-related state\n  let primState = {\n    initialized:false,\n    inMST: [], // boolean per node\n    key: [], // per node\n    parent: [], // per node\n    current:null, // currently selected vertex this step\n    stepCount:0,\n    finished:false,\n  };\n  let autoTimer = null;\n  const AUTO_DELAY = 900;\n\n  // Interaction state\n  let pendingEdgeFrom = null;\n\n  // Canvas interactions\n  function canvasPos(evt){\n    const rect = canvas.getBoundingClientRect();\n    const x = (evt.clientX - rect.left);\n    const y = (evt.clientY - rect.top);\n    return {x,y};\n  }\n\n  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }\n\n  function findNodeAt(x,y){\n    for(let i=nodes.length-1;i>=0;i--){\n      const n = nodes[i];\n      if(dist(n,{x,y}) <= 16) return n;\n    }\n    return null;\n  }\n\n  function findEdgeAt(x,y){\n    // pick an edge if point is near the segment\n    for(let e of edges){\n      const a = nodes.find(n=>n.id===e.a);\n      const b = nodes.find(n=>n.id===e.b);\n      if(!a||!b) continue;\n      const d = pointToSegmentDistance({x,y}, a, b);\n      if(d < 8) return e;\n    }\n    return null;\n  }\n\n  function pointToSegmentDistance(p,a,b){\n    const vx = b.x - a.x;\n    const vy = b.y - a.y;\n    const wx = p.x - a.x;\n    const wy = p.y - a.y;\n    const c = (vx*wx + vy*wy) / (vx*vx + vy*vy || 1);\n    const t = Math.max(0, Math.min(1, c));\n    const px = a.x + t*vx;\n    const py = a.y + t*vy;\n    return Math.hypot(p.x-px, p.y-py);\n  }\n\n  canvas.addEventListener('click', (evt)=>{\n    const p = canvasPos(evt);\n    if(mode === 'addNode'){\n      addNode(p.x,p.y);\n      mode = 'none';\n      updateModeButtons();\n      return;\n    }\n    if(mode === 'addEdge'){\n      const node = findNodeAt(p.x,p.y);\n      if(!node){\n        // clicked empty area -> cancel\n        pendingEdgeFrom = null;\n        return;\n      }\n      if(!pendingEdgeFrom){\n        pendingEdgeFrom = node;\n        log(\"Selected node \" + node.id + \" as source for new edge. Click target node.\");\n      } else {\n        if(pendingEdgeFrom.id === node.id){\n          log(\"Cannot connect node to itself. Select a different node.\");\n          pendingEdgeFrom = null;\n          return;\n        }\n        const weightStr = prompt(\"Enter weight for the edge (positive number). Leave empty for random 1-20:\");\n        let w = parseFloat(weightStr);\n        if(!weightStr || isNaN(w) || w <= 0) w = Math.floor(Math.random()*20)+1;\n        addEdge(pendingEdgeFrom.id, node.id, w);\n        pendingEdgeFrom = null;\n        mode = 'none';\n        updateModeButtons();\n      }\n      return;\n    }\n    if(mode === 'delete'){\n      const node = findNodeAt(p.x,p.y);\n      if(node){\n        removeNode(node.id);\n        return;\n      }\n      const edge = findEdgeAt(p.x,p.y);\n      if(edge){\n        removeEdge(edge.id);\n        return;\n      }\n    }\n    // normal mode: clicking a node chooses it as start node\n    const node = findNodeAt(p.x,p.y);\n    if(node){\n      setStartNode(node.id);\n    }\n  });\n\n  // Buttons\n  addNodeBtn.addEventListener('click', ()=> { mode = 'addNode'; updateModeButtons(); log(\"Click on canvas to add a node.\"); });\n  addEdgeBtn.addEventListener('click', ()=> { mode = 'addEdge'; pendingEdgeFrom = null; updateModeButtons(); log(\"Click two nodes to add an edge.\"); });\n  deleteBtn.addEventListener('click', ()=> { mode = (mode==='delete') ? 'none' : 'delete'; updateModeButtons(); log(mode==='delete' ? \"Delete mode: click node or edge to remove.\" : \"Delete mode disabled.\"); });\n  clearBtn.addEventListener('click', ()=> { if(confirm(\"Clear entire graph?\")) clearGraph(); });\n  randomBtn.addEventListener('click', ()=> createRandomGraph());\n  runBtn.addEventListener('click', ()=> initPrim());\n  stepBtn.addEventListener('click', ()=> primStep());\n  autoBtn.addEventListener('click', ()=> startAuto());\n  pauseBtn.addEventListener('click', ()=> stopAuto());\n  resetBtn.addEventListener('click', ()=> resetPrim());\n\n  function updateModeButtons(){\n    addNodeBtn.style.border = mode==='addNode' ? '2px solid rgba(2,132,199,0.2)' : '';\n    addEdgeBtn.style.border = mode==='addEdge' ? '2px solid rgba(2,132,199,0.2)' : '';\n    deleteBtn.style.border = mode==='delete' ? '2px solid rgba(239,68,68,0.15)' : '';\n  }\n\n  function addNode(x,y){\n    const id = nodeIdCounter++;\n    nodes.push({id,x,y});\n    primResetState();\n    rebuildStartSelect();\n    log(\"Added node \" + id);\n    draw();\n  }\n\n  function addEdge(a,b,w){\n    // ensure undirected single edge and no duplicates\n    if(a===b) return;\n    if(edges.some(e => (e.a===a && e.b===b) || (e.a===b && e.b===a))){\n      log(\"Edge already exists between \" + a + \" and \" + b);\n      return;\n    }\n    const id = edgeIdCounter++;\n    edges.push({id,a,b,weight:Number(w), inMST:false, candidate:false});\n    primResetState();\n    log(`Added edge ${a} — ${b} (w=${w})`);\n    draw();\n  }\n\n  function removeNode(id){\n    nodes = nodes.filter(n=>n.id!==id);\n    edges = edges.filter(e=>e.a!==id && e.b!==id);\n    primResetState();\n    rebuildStartSelect();\n    log(\"Removed node \" + id);\n    draw();\n  }\n\n  function removeEdge(id){\n    edges = edges.filter(e=>e.id!==id);\n    primResetState();\n    log(\"Removed edge \" + id);\n    draw();\n  }\n\n  function clearGraph(){\n    nodes = [];\n    edges = [];\n    nodeIdCounter = 0;\n    edgeIdCounter = 0;\n    primResetState();\n    rebuildStartSelect();\n    log(\"Cleared graph\");\n    draw();\n  }\n\n  function createRandomGraph(){\n    const n = parseInt(randN.value) || 6;\n    const d = parseFloat(randD.value) || 0.45;\n    clearGraph();\n    // place nodes approx evenly\n    for(let i=0;i<n;i++){\n      const angle = (i/n) * Math.PI*2;\n      const cx = 380 + Math.cos(angle) * 200 * (0.6 + Math.random()*0.8);\n      const cy = 310 + Math.sin(angle) * 200 * (0.6 + Math.random()*0.8);\n      addNode(cx + (Math.random()-0.5)*30, cy + (Math.random()-0.5)*30);\n    }\n    // add edges by probability, ensure connectivity by connecting neighbors\n    for(let i=0;i<nodes.length;i++){\n      for(let j=i+1;j<nodes.length;j++){\n        if(Math.random() < d){\n          let w = Math.floor(Math.random()*20)+1;\n          addEdge(nodes[i].id, nodes[j].id, w);\n        }\n      }\n    }\n    // ensure connectivity: connect sequentially if graph ended up disconnected\n    const comps = getComponents();\n    if(comps.length>1){\n      for(let k=0;k<comps.length-1;k++){\n        const a = comps[k][0];\n        const b = comps[k+1][0];\n        addEdge(a,b, Math.floor(Math.random()*20)+1);\n      }\n    }\n    primResetState();\n    rebuildStartSelect();\n    log(\"Random graph created: n=\"+n+\" density=\"+d);\n    draw();\n  }\n\n  function getComponents(){\n    const adj = buildAdjacency();\n    const visited = new Set();\n    const comps = [];\n    for(let n of nodes){\n      if(visited.has(n.id)) continue;\n      const stack = [n.id];\n      const comp = [];\n      visited.add(n.id);\n      while(stack.length){\n        const u = stack.pop();\n        comp.push(u);\n        for(let v of adj[u] || []){\n          if(!visited.has(v)){\n            visited.add(v); stack.push(v);\n          }\n        }\n      }\n      comps.push(comp);\n    }\n    return comps;\n  }\n\n  function rebuildStartSelect(){\n    while(startSelect.options.length>1) startSelect.remove(1);\n    for(let n of nodes){\n      const o = document.createElement('option');\n      o.value = n.id;\n      o.textContent = n.id;\n      startSelect.appendChild(o);\n    }\n    startSelect.value = '';\n  }\n\n  startSelect.addEventListener('change', ()=>{\n    const v = startSelect.value;\n    if(v==='') return;\n    setStartNode(Number(v));\n  });\n\n  function setStartNode(id){\n    // highlight start node in UI\n    startSelect.value = id;\n    primResetState();\n    log(\"Start node set to \" + id);\n    draw();\n  }\n\n  // Prim algorithm core\n  function initPrim(){\n    if(nodes.length === 0) { alert(\"No nodes in graph.\"); return; }\n    let start = startSelect.value;\n    if(!start){\n      // pick first node by default\n      start = nodes[0].id;\n      startSelect.value = start;\n    } else start = Number(start);\n    // initialize arrays\n    const nCount = nodes.length;\n    primState.inMST = {};\n    primState.key = {};\n    primState.parent = {};\n    for(const nd of nodes){\n      primState.inMST[nd.id] = false;\n      primState.key[nd.id] = Infinity;\n      primState.parent[nd.id] = null;\n    }\n    primState.key[start] = 0;\n    primState.current = null;\n    primState.stepCount = 0;\n    primState.finished = false;\n    primState.initialized = true;\n    // reset edge flags\n    for(let e of edges){ e.inMST=false; e.candidate=false; }\n    log(\"Prim initialized. Start from node \" + start + \". Keys set. Ready to step.\");\n    updateNodeTable();\n    draw();\n  }\n\n  function primStep(){\n    if(!primState.initialized){\n      alert(\"Initialize Prim first (click 'Init Prim').\");\n      return;\n    }\n    if(primState.finished){\n      log(\"Prim already finished.\");\n      return;\n    }\n    // pick u with smallest key not in MST\n    let u = null;\n    let best = Infinity;\n    for(const nd of nodes){\n      if(!primState.inMST[nd.id] && primState.key[nd.id] < best){\n        best = primState.key[nd.id]; u = nd.id;\n      }\n    }\n    if(u === null){\n      // There is at least one vertex not inMST but unreachable (key == Infinity)\n      // Try to pick any remaining node to mark as separate component (graph disconnected)\n      const remaining = nodes.filter(n=>!primState.inMST[n.id]);\n      if(remaining.length === 0){\n        primState.finished = true;\n        log(\"Prim finished. MST complete.\");\n        updateNodeTable();\n        draw();\n        return;\n      } else {\n        // pick first unreachable node and mark it as component root (its key stays Infinity -> treat as 0 for selection)\n        u = remaining[0].id;\n        // If it's unreachable, we'll mark as added but won't add edge\n      }\n    }\n\n    primState.current = u;\n    primState.stepCount++;\n    // If parent exists, add that edge to MST\n    if(primState.parent[u] !== null){\n      const p = primState.parent[u];\n      const e = edges.find(e => (e.a===u && e.b===p) || (e.b===u && e.a===p));\n      if(e) e.inMST = true;\n      log(`Step ${primState.stepCount}: Select node ${u} (key=${primState.key[u]}) and add edge ${p}—${u} to MST.`);\n    } else {\n      if(primState.key[u]===Infinity){\n        log(`Step ${primState.stepCount}: Select unreachable node ${u} (no connecting edge) — new component.`);\n      } else {\n        log(`Step ${primState.stepCount}: Select start node ${u}.`);\n      }\n    }\n    primState.inMST[u] = true;\n\n    // Update neighbors\n    const adj = buildAdjacencyDetailed();\n    if(adj[u]){\n      for(const nb of adj[u]){\n        if(primState.inMST[nb.v]) continue;\n        if(nb.weight < primState.key[nb.v]){\n          primState.key[nb.v] = nb.weight;\n          primState.parent[nb.v] = u;\n          // mark edge as candidate (visual)\n          const e = edges.find(e => (e.a===u && e.b===nb.v) || (e.b===u && e.a===nb.v));\n          if(e) { e.candidate = true; }\n          log(`  Update: node ${nb.v} key <- ${nb.weight} (parent=${u})`);\n        } else {\n          // not improving\n          // optionally highlight the considered edge briefly (we'll just note)\n        }\n      }\n    }\n    // After updating, clear candidate flag for non-best edges\n    for(const e of edges){\n      if(e.candidate){\n        // keep candidate only if it's currently the parent-edge of some node\n        const keeps = nodes.some(n => primState.parent[n.id] !== null && ( (e.a===n.id && e.b===primState.parent[n.id]) || (e.b===n.id && e.a===primState.parent[n.id]) ));\n        if(!keeps) e.candidate = false;\n      }\n    }\n\n    // Check finish\n    const allIn = nodes.every(n => primState.inMST[n.id]);\n    if(allIn){\n      primState.finished = true;\n      log(\"Prim finished: all nodes in MST. Total weight = \" + totalMSTWeight());\n    }\n    updateNodeTable();\n    draw();\n  }\n\n  function buildAdjacency(){\n    const adj = {};\n    for(const n of nodes) adj[n.id] = [];\n    for(const e of edges){\n      adj[e.a].push(e.b);\n      adj[e.b].push(e.a);\n    }\n    return adj;\n  }\n\n  function buildAdjacencyDetailed(){\n    const adj = {};\n    for(const n of nodes) adj[n.id] = [];\n    for(const e of edges){\n      adj[e.a].push({v:e.b, weight:e.weight});\n      adj[e.b].push({v:e.a, weight:e.weight});\n    }\n    return adj;\n  }\n\n  function totalMSTWeight(){\n    let sum = 0;\n    for(const e of edges) if(e.inMST) sum += e.weight;\n    return sum;\n  }\n\n  function primResetState(){\n    // Called when graph changes: clear prim state but maintain initialization flag false\n    primState.initialized = false;\n    primState.inMST = [];\n    primState.key = [];\n    primState.parent = [];\n    primState.current = null;\n    primState.stepCount = 0;\n    primState.finished = false;\n    for(let e of edges){ e.inMST=false; e.candidate=false; }\n    stopAuto();\n    updateNodeTable();\n    draw();\n  }\n\n  function resetPrim(){\n    if(!primState.initialized){ log(\"Prim not initialized.\"); return; }\n    const prevStart = startSelect.value ? Number(startSelect.value) : (nodes.length?nodes[0].id:null);\n    initPrim();\n    if(prevStart !== null) startSelect.value = prevStart;\n    log(\"Prim reset to initial state.\");\n    draw();\n  }\n\n  function startAuto(){\n    if(!primState.initialized){\n      alert(\"Initialize Prim first.\");\n      return;\n    }\n    if(autoTimer) return;\n    autoTimer = setInterval(()=>{\n      if(primState.finished) stopAuto();\n      else primStep();\n    }, AUTO_DELAY);\n    log(\"Auto-play started.\");\n  }\n  function stopAuto(){\n    if(autoTimer){ clearInterval(autoTimer); autoTimer = null; log(\"Auto-play paused.\"); }\n  }\n\n  function log(msg){\n    const time = new Date().toLocaleTimeString();\n    logEl.textContent = time + \"   \" + msg + \"\\n\" + logEl.textContent;\n    // keep log to reasonable size\n    if(logEl.textContent.length > 8000) logEl.textContent = logEl.textContent.slice(0,8000);\n  }\n\n  // drawing\n  function draw(){\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    drawEdges();\n    drawNodes();\n    mstWeightEl.textContent = \"MST weight: \" + totalMSTWeight();\n  }\n\n  function drawEdges(){\n    // draw edges with different colors depending on state\n    for(const e of edges){\n      const a = nodes.find(n=>n.id===e.a);\n      const b = nodes.find(n=>n.id===e.b);\n      if(!a || !b) continue;\n      ctx.lineWidth = e.inMST ? 4 : 2;\n      ctx.lineCap = 'round';\n      ctx.beginPath();\n      ctx.moveTo(a.x,a.y);\n      ctx.lineTo(b.x,b.y);\n      if(e.inMST){\n        ctx.strokeStyle = '#10b981'; // green\n      } else if(e.candidate){\n        ctx.strokeStyle = 'orange';\n      } else {\n        ctx.strokeStyle = '#94a3b8';\n      }\n      ctx.stroke();\n      // weight label in middle\n      const mx = (a.x + b.x)/2;\n      const my = (a.y + b.y)/2;\n      const pad = 6;\n      ctx.fillStyle = '#ffffff';\n      ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n      ctx.lineWidth = 1;\n      roundRect(ctx, mx - 18, my - 12, 36, 20, 6, true, true);\n      ctx.fillStyle = '#0b1220';\n      ctx.font = '12px monospace';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(e.weight), mx, my);\n      ctx.beginPath();\n    }\n  }\n\n  function drawNodes(){\n    for(const n of nodes){\n      const r = 16;\n      // node background\n      ctx.beginPath();\n      ctx.arc(n.x, n.y, r, 0, Math.PI*2);\n      // color depending on prim state\n      let fill = '#ffffff';\n      let stroke = '#0b1220';\n      let lineWidth = 1;\n      if(primState.initialized && primState.inMST && primState.inMST[n.id]){\n        fill = '#ecfdf5'; // light green\n        stroke = '#10b981';\n        lineWidth = 2;\n      }\n      if(primState.current === n.id){\n        fill = '#fff7ed'; // current amber\n        stroke = '#f97316';\n        lineWidth = 2;\n      }\n      ctx.fillStyle = fill;\n      ctx.strokeStyle = stroke;\n      ctx.lineWidth = lineWidth;\n      ctx.fill();\n      ctx.stroke();\n\n      // node label (id)\n      ctx.fillStyle = '#0b1220';\n      ctx.font = '13px Inter, system-ui, monospace';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(n.id), n.x, n.y);\n\n      // small key indicator near node\n      if(primState.initialized && primState.key && primState.key[n.id] !== undefined){\n        const key = primState.key[n.id];\n        ctx.fillStyle = 'rgba(255,255,255,0.95)';\n        roundRect(ctx, n.x-26, n.y+18, 52, 18, 6, true, true);\n        ctx.fillStyle = '#0b1220';\n        ctx.font = '12px monospace';\n        ctx.fillText((key===Infinity? '∞' : key), n.x, n.y+27);\n      }\n    }\n  }\n\n  // utilities\n  function roundRect(ctx, x, y, w, h, r, fill = true, stroke = false) {\n    if (typeof r === 'undefined') r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function updateNodeTable(){\n    if(nodes.length === 0){ nodeTable.innerHTML = \"No nodes yet.\"; return; }\n    let html = '<div class=\"node-list\">';\n    for(const n of nodes){\n      const id = n.id;\n      const key = (primState.key && primState.key[id] !== undefined) ? (primState.key[id]===Infinity ? '∞' : primState.key[id]) : '-';\n      const parent = (primState.parent && primState.parent[id] !== undefined && primState.parent[id] !== null) ? primState.parent[id] : '-';\n      const inM = (primState.inMST && primState.inMST[id]) ? '✓' : '';\n      const cur = primState.current === id ? '<span style=\"color:#f97316\">current</span>' : '';\n      html += `<div style=\"display:flex;justify-content:space-between;gap:8px;padding:6px 4px;border-bottom:1px dashed rgba(0,0,0,0.03)\">\n        <div style=\"min-width:36px\"><strong>${id}</strong> ${cur}</div>\n        <div style=\"color:#475569\">key: <span style=\"font-family:monospace\">${key}</span></div>\n        <div style=\"color:#475569\">parent: <span style=\"font-family:monospace\">${parent}</span></div>\n        <div style=\"color:#475569\">inMST: ${inM}</div>\n      </div>`;\n    }\n    html += '</div>';\n    nodeTable.innerHTML = html;\n    mstWeightEl.textContent = \"MST weight: \" + totalMSTWeight();\n  }\n\n  // initial draw\n  draw();\n  updateModeButtons();\n  rebuildStartSelect();\n  updateNodeTable();\n\n  // convenience helpers for demo: seed some example graph (optional)\n  // create a small example when page loads\n  (function seedExample(){\n    // create 6 nodes\n    clearGraph();\n    const coords = [\n      {x:120,y:120},{x:620,y:110},{x:380,y:80},{x:220,y:420},{x:520,y:440},{x:100,y:280}\n    ];\n    for(let c of coords) addNode(c.x,c.y);\n    addEdge(0,1,7); addEdge(0,2,9); addEdge(0,5,14);\n    addEdge(1,2,10); addEdge(1,3,15); addEdge(2,3,11);\n    addEdge(2,5,2); addEdge(3,4,6); addEdge(4,5,9);\n    primResetState();\n    rebuildStartSelect();\n    log(\"Sample graph created (click start node and 'Init Prim').\");\n  })();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}