{
  "id": "d79d3ce1-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:36.742Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Dijkstra's Algorithm Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 20px;\n    background: #f0f0f0;\n  }\n  h1 {\n    text-align: center;\n  }\n  #graphCanvas {\n    background: white;\n    border: 1px solid #ccc;\n    display: block;\n    margin: 10px auto 30px auto;\n  }\n  .controls {\n    max-width: 900px;\n    margin: 0 auto 30px auto;\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n    gap: 15px;\n  }\n  label {\n    display: flex;\n    flex-direction: column;\n    font-size: 0.9rem;\n  }\n  input, select, button {\n    font-size: 1rem;\n    padding: 6px;\n    margin-top: 4px;\n  }\n  #log {\n    white-space: pre-wrap;\n    background: #222;\n    color: #eee;\n    padding: 15px;\n    max-width: 900px;\n    margin: 0 auto;\n    height: 250px;\n    overflow-y: auto;\n    border-radius: 6px;\n    font-family: monospace;\n    user-select: text;\n  }\n  footer {\n    max-width: 900px;\n    margin: 40px auto;\n    text-align: center;\n    color: #666;\n    font-size: 0.9rem;\n  }\n</style>\n</head>\n<body>\n<h1>Dijkstra's Algorithm Visualization</h1>\n\n<div class=\"controls\">\n  <label>\n    Start Node:\n    <select id=\"startNode\"></select>\n  </label>\n  <label>\n    End Node:\n    <select id=\"endNode\"></select>\n  </label>\n  <button id=\"runBtn\">Run Dijkstra</button>\n  <button id=\"resetBtn\">Reset Graph</button>\n</div>\n\n<canvas id=\"graphCanvas\" width=\"900\" height=\"600\" aria-label=\"Graph Visualization\"></canvas>\n\n<div id=\"log\" aria-live=\"polite\" aria-atomic=\"true\" role=\"log\" tabindex=\"0\">\n  Select start and end nodes and click \"Run Dijkstra\" to see the shortest path and the algorithm steps.\n</div>\n\n<script>\n(() => {\n  // Graph data structure:\n  // nodes: array of {id:string, x:number, y:number}\n  // edges: array of {from:string, to:string, weight:number}\n  // Undirected graph for this demo.\n  \n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  const startSelect = document.getElementById('startNode');\n  const endSelect = document.getElementById('endNode');\n  const runBtn = document.getElementById('runBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const logEl = document.getElementById('log');\n  const RADIUS = 20;\n\n  // Example fixed graph:\n  const nodes = [\n    {id: 'A', x: 150, y: 100},\n    {id: 'B', x: 350, y: 80},\n    {id: 'C', x: 550, y: 150},\n    {id: 'D', x: 700, y: 300},\n    {id: 'E', x: 600, y: 450},\n    {id: 'F', x: 400, y: 400},\n    {id: 'G', x: 200, y: 350},\n  ];\n\n  const edges = [\n    {from: 'A', to: 'B', weight: 4},\n    {from: 'A', to: 'G', weight: 7},\n    {from: 'B', to: 'C', weight: 6},\n    {from: 'B', to: 'G', weight: 2},\n    {from: 'C', to: 'D', weight: 3},\n    {from: 'C', to: 'E', weight: 1},\n    {from: 'D', to: 'E', weight: 5},\n    {from: 'E', to: 'F', weight: 7},\n    {from: 'F', to: 'G', weight: 3},\n  ];\n\n  // Adjacency list for fast lookup\n  let adjacency = {};\n\n  // State:\n  let distances = {};\n  let previous = {};\n  let visited = new Set();\n  let path = [];\n  let running = false;\n\n  // Colors\n  const COLOR_NODE_DEFAULT = '#3498db';\n  const COLOR_NODE_VISITED = '#95a5a6';\n  const COLOR_NODE_CURRENT = '#e67e22';\n  const COLOR_NODE_PATH = '#27ae60';\n  const COLOR_EDGE_DEFAULT = '#bdc3c7';\n  const COLOR_EDGE_PATH = '#2ecc71';\n  const COLOR_EDGE_CONSIDER = '#e74c3c';\n\n  // Initialize adjacency list as undirected graph\n  function buildAdjacency() {\n    adjacency = {};\n    nodes.forEach(n => adjacency[n.id] = []);\n    edges.forEach(({from, to, weight}) => {\n      adjacency[from].push({node: to, weight});\n      adjacency[to].push({node: from, weight});\n    });\n  }\n\n  function fillSelectOptions() {\n    [startSelect, endSelect].forEach(select => {\n      select.innerHTML = '';\n      nodes.forEach(({id}) => {\n        const opt = document.createElement('option');\n        opt.value = id;\n        opt.textContent = id;\n        select.appendChild(opt);\n      });\n    });\n    // Default different nodes\n    endSelect.selectedIndex = nodes.length > 1 ? 1 : 0;\n  }\n\n  function log(msg) {\n    logEl.textContent += '\\n' + msg;\n    logEl.scrollTop = logEl.scrollHeight;\n  }\n\n  function clearLog() {\n    logEl.textContent = '';\n  }\n\n  // Find node by id\n  function findNode(id) {\n    return nodes.find(n => n.id === id);\n  }\n\n  // Draw entire graph\n  // Highlight visited nodes, current node, path edges and nodes\n  function drawGraph(currentNode=null, considerEdges=[], finalPath=[]) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw edges first\n    edges.forEach(e => {\n      const fromNode = findNode(e.from);\n      const toNode = findNode(e.to);\n      // Check edge color\n      let color = COLOR_EDGE_DEFAULT;\n      const edgeKey1 = e.from + \"-\" + e.to;\n      const edgeKey2 = e.to + \"-\" + e.from;\n      // Highlight path edges\n      let onPath = false;\n      for(let i=0; i<finalPath.length - 1; i++){\n        if( (finalPath[i] === e.from && finalPath[i+1] === e.to) ||\n            (finalPath[i] === e.to && finalPath[i+1] === e.from)) {\n          onPath = true; break;\n        }\n      }\n      if(onPath) color = COLOR_EDGE_PATH;\n      else if(considerEdges.some(ed => (ed.from === e.from && ed.to === e.to) || (ed.from === e.to && ed.to === e.from))) color = COLOR_EDGE_CONSIDER;\n\n      ctx.strokeStyle = color;\n      ctx.lineWidth = onPath ? 5 : (color === COLOR_EDGE_CONSIDER ? 3 : 1.5);\n      ctx.beginPath();\n      ctx.moveTo(fromNode.x, fromNode.y);\n      ctx.lineTo(toNode.x, toNode.y);\n      ctx.stroke();\n\n      // Draw edge weight midpoint\n      const midX = (fromNode.x + toNode.x) /2;\n      const midY = (fromNode.y + toNode.y) /2;\n      ctx.fillStyle = 'black';\n      ctx.font = '14px Arial';\n      ctx.fillText(e.weight, midX - 7, midY - 5);\n    });\n\n    // Draw nodes\n    nodes.forEach(n => {\n      // Determine fill color\n      let fillColor = COLOR_NODE_DEFAULT;\n      if(finalPath.includes(n.id)) fillColor = COLOR_NODE_PATH;\n      else if(n.id === currentNode) fillColor = COLOR_NODE_CURRENT;\n      else if(visited.has(n.id)) fillColor = COLOR_NODE_VISITED;\n\n      ctx.fillStyle = fillColor;\n      ctx.strokeStyle = '#333';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(n.x, n.y, RADIUS, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      // Node label\n      ctx.fillStyle = '#fff';\n      ctx.font = 'bold 16px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(n.id, n.x, n.y);\n\n      // Distance label below node\n      if(distances[n.id] !== undefined && distances[n.id] !== Infinity) {\n        ctx.fillStyle = '#000';\n        ctx.font = '12px Arial';\n        ctx.fillText(distances[n.id] === Infinity ? \"∞\" : distances[n.id], n.x, n.y + RADIUS + 15);\n      }\n    });\n  }\n\n  // Dijkstra algorithm with step-by-step animation\n  // Returns a Promise that resolves when done\n  function runDijkstra(start, end) {\n    return new Promise(resolve => {\n      distances = {};\n      previous = {};\n      visited = new Set();\n      path = [];\n      running = true;\n\n      // Init distances and previous\n      nodes.forEach(n => {\n        distances[n.id] = Infinity;\n        previous[n.id] = null;\n      });\n      distances[start] = 0;\n\n      let unvisited = new Set(nodes.map(n=>n.id));\n\n      clearLog();\n      log(`Starting Dijkstra's algorithm from node ${start} to node ${end}.\\n`);\n\n      // Priority queue adaptation: just pick node with min dist in unvisited set\n      async function step() {\n        if(!running) return resolve();\n\n        // Select node u with smallest distance in unvisited\n        let u = null;\n        let minDist = Infinity;\n        for(let nodeId of unvisited) {\n          if(distances[nodeId] < minDist){\n            minDist = distances[nodeId];\n            u = nodeId;\n          }\n        }\n\n        if(u === null || minDist === Infinity){\n          log(`No more reachable nodes. Ending algorithm.`);\n          resolve();\n          return;\n        }\n\n        log(`Visiting node ${u} with current distance ${minDist}.`);\n\n        if(u === end) {\n          // Found shortest path to end\n          log(`Reached destination node ${end}.\\n`);\n          // Reconstruct path\n          let p = [];\n          let cur = end;\n          while(cur) {\n            p.unshift(cur);\n            cur = previous[cur];\n          }\n          path = p;\n          drawGraph(u, [], path);\n          log(`Shortest path: ${path.join(' -> ')}`);\n          log(`Total path cost: ${distances[end]}`);\n          resolve();\n          return;\n        }\n\n        // Mark current node visited\n        visited.add(u);\n        unvisited.delete(u);\n\n        // For each neighbor v of u still unvisited\n        const considerEdges = [];\n        for(let edge of adjacency[u]) {\n          let v = edge.node;\n          if(!unvisited.has(v)) continue;\n          considerEdges.push({from: u, to: v});\n\n          const alt = distances[u] + edge.weight;\n          if(alt < distances[v]) {\n            log(`Updated distance of node ${v} from ${distances[v]} to ${alt} via ${u}.`);\n            distances[v] = alt;\n            previous[v] = u;\n          } else {\n            log(`Distance of node ${v} not updated; current distance: ${distances[v]}, alternative: ${alt}`);\n          }\n        }\n\n        drawGraph(u, considerEdges, path);\n\n        // Wait 1.2s before next step to visualize\n        setTimeout(step, 1200);\n      }\n\n      step();\n    });\n  }\n\n  // Reset all states and redraw graph\n  function reset() {\n    distances = {};\n    previous = {};\n    visited = new Set();\n    path = [];\n    running = false;\n    clearLog();\n    logEl.textContent = 'Select start and end nodes and click \"Run Dijkstra\" to see the shortest path and the algorithm steps.';\n    drawGraph();\n  }\n\n  // Handle user interaction\n  runBtn.addEventListener('click', async () => {\n    if(running) return;\n    clearLog();\n    running = true;\n    const start = startSelect.value;\n    const end = endSelect.value;\n    if(start === end) {\n      log(`Start and end nodes are the same. Distance is 0.`);\n      running = false;\n      drawGraph(null, [], [start]);\n      return;\n    }\n    drawGraph();\n    await runDijkstra(start, end);\n    running = false;\n  });\n\n  resetBtn.addEventListener('click', () => {\n    if(running) return;\n    reset();\n  });\n\n  // Initialization\n  function init() {\n    buildAdjacency();\n    fillSelectOptions();\n    reset();\n  }\n\n  init();\n\n})();\n</script>\n\n<footer>\n  &copy; 2024 &mdash; Demo of Dijkstra's Algorithm (Undirected Weighted Graph)\n</footer>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}