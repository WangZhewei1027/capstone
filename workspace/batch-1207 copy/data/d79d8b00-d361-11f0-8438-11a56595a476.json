{
  "id": "d79d8b00-d361-11f0-8438-11a56595a476",
  "timestamp": "2025-12-07T11:44:41.417Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Prim's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    display: flex;\n    height: 100vh;\n    overflow: hidden;\n    background: #f4f4f4;\n  }\n  #controls {\n    width: 320px;\n    background: #fff;\n    border-right: 1px solid #ccc;\n    padding: 20px;\n    box-sizing: border-box;\n    overflow-y: auto;\n  }\n  #canvas-container {\n    flex: 1;\n    position: relative;\n    background: #222;\n  }\n  canvas {\n    display: block;\n    width: 100%;\n    height: 100%;\n    background: #222;\n  }\n  h2 {\n    margin-top: 0;\n  }\n  label {\n    display: block;\n    margin-top: 15px;\n    font-weight: bold;\n  }\n  input[type=number], select {\n    width: 100%;\n    padding: 6px 8px;\n    margin-top: 5px;\n    box-sizing: border-box;\n  }\n  button {\n    margin-top: 20px;\n    padding: 10px 15px;\n    background: #007acc;\n    border: none;\n    color: white;\n    font-weight: bold;\n    cursor: pointer;\n    width: 100%;\n    border-radius: 3px;\n  }\n  button:disabled {\n    background: #999;\n    cursor: default;\n  }\n  #log {\n    margin-top: 15px;\n    height: 180px;\n    overflow-y: auto;\n    background: #eee;\n    padding: 10px;\n    font-size: 14px;\n    line-height: 1.3;\n    border-radius: 4px;\n  }\n  #legend {\n    margin-top: 20px;\n    font-size: 14px;\n  }\n  #legend div {\n    display: flex;\n    align-items: center;\n    margin-bottom: 6px;\n  }\n  #legend span.color-box {\n    width: 20px;\n    height: 20px;\n    display: inline-block;\n    margin-right: 8px;\n    border-radius: 3px;\n    border: 1px solid #444;\n  }\n  /* Colors */\n  .color-graph { background: #666; }\n  .color-edge { background: #bbb; }\n  .color-edge-in-mst { background: #00cc44; }\n  .color-node { background: #888; }\n  .color-node-in-mst { background: #00cc44; }\n  .color-node-current { background: #ffcc00; }\n  .color-edge-candidate { background: #ff9933; }\n</style>\n</head>\n<body>\n  <div id=\"controls\">\n    <h2>Prim's Algorithm Demo</h2>\n    <label for=\"numNodes\">Number of Nodes (3 - 20):</label>\n    <input type=\"number\" id=\"numNodes\" value=\"8\" min=\"3\" max=\"20\" />\n    <label for=\"density\">Edge Density (%):</label>\n    <input type=\"number\" id=\"density\" value=\"50\" min=\"10\" max=\"100\" />\n    <label for=\"weightRange\">Max Edge Weight:</label>\n    <input type=\"number\" id=\"weightRange\" value=\"20\" min=\"1\" max=\"100\" />\n    <label for=\"speed\">Step Delay (ms):</label>\n    <select id=\"speed\">\n      <option value=\"1500\">Slow (1.5s)</option>\n      <option value=\"1000\" selected>Normal (1s)</option>\n      <option value=\"500\">Fast (0.5s)</option>\n      <option value=\"0\">Instant</option>\n    </select>\n    <button id=\"generateBtn\">Generate Graph</button>\n    <button id=\"startBtn\" disabled>Start Prim's Algorithm</button>\n    <button id=\"stepBtn\" disabled>Next Step</button>\n    <button id=\"resetBtn\" disabled>Reset</button>\n    <div id=\"legend\">\n      <h3>Legend:</h3>\n      <div><span class=\"color-box color-node\"></span>Unvisited Node</div>\n      <div><span class=\"color-box color-node-in-mst\"></span>Node in MST</div>\n      <div><span class=\"color-box color-node-current\"></span>Current Node</div>\n      <div><span class=\"color-box color-edge\"></span>Edge</div>\n      <div><span class=\"color-box color-edge-candidate\"></span>Candidate Edge</div>\n      <div><span class=\"color-box color-edge-in-mst\"></span>Edge in MST</div>\n    </div>\n    <div id=\"log\" aria-live=\"polite\"></div>\n  </div>\n  <div id=\"canvas-container\">\n    <canvas id=\"graphCanvas\"></canvas>\n  </div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n  const numNodesInput = document.getElementById('numNodes');\n  const densityInput = document.getElementById('density');\n  const weightRangeInput = document.getElementById('weightRange');\n  const speedInput = document.getElementById('speed');\n  const generateBtn = document.getElementById('generateBtn');\n  const startBtn = document.getElementById('startBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const logDiv = document.getElementById('log');\n\n  // Resize canvas to fill container\n  function resizeCanvas() {\n    const rect = canvas.parentElement.getBoundingClientRect();\n    canvas.width = rect.width;\n    canvas.height = rect.height;\n    if(graph) drawGraph();\n  }\n  window.addEventListener('resize', resizeCanvas);\n\n  // Graph data structures\n  let graph = null;\n  // graph = {\n  //   nodes: [{id, x, y}],\n  //   edges: [{from, to, weight}],\n  //   adjList: Map[nodeId -> Array of edges]\n  // }\n\n  // Prim's algorithm state\n  let primState = null;\n  // primState = {\n  //   visited: Set,\n  //   mstEdges: Array,\n  //   edgeCandidates: MinHeap of edges,\n  //   currentNode: nodeId,\n  //   stepIterator: generator,\n  //   running: boolean\n  // }\n\n  class MinHeap {\n    constructor() {\n      this.heap = [];\n    }\n    push(element) {\n      this.heap.push(element);\n      this._bubbleUp(this.heap.length - 1);\n    }\n    pop() {\n      if(this.heap.length === 0) return null;\n      if(this.heap.length === 1) return this.heap.pop();\n      const top = this.heap[0];\n      this.heap[0] = this.heap.pop();\n      this._sinkDown(0);\n      return top;\n    }\n    _bubbleUp(n) {\n      const element = this.heap[n];\n      while(n > 0) {\n        let parentN = Math.floor((n + 1)/2) - 1;\n        let parent = this.heap[parentN];\n        if(element.weight >= parent.weight) break;\n        this.heap[parentN] = element;\n        this.heap[n] = parent;\n        n = parentN;\n      }\n    }\n    _sinkDown(n) {\n      const length = this.heap.length;\n      const element = this.heap[n];\n      while(true) {\n        let child2N = (n + 1) * 2;\n        let child1N = child2N - 1;\n        let swap = null;\n        if(child1N < length) {\n          let child1 = this.heap[child1N];\n          if(child1.weight < element.weight) swap = child1N;\n        }\n        if(child2N < length) {\n          let child2 = this.heap[child2N];\n          if((swap === null ? element.weight : this.heap[child1N].weight) > child2.weight) swap = child2N;\n        }\n        if(swap === null) break;\n        this.heap[n] = this.heap[swap];\n        this.heap[swap] = element;\n        n = swap;\n      }\n    }\n    size() {\n      return this.heap.length;\n    }\n    // Optional - peek top element\n    peek() {\n      return this.heap.length > 0 ? this.heap[0] : null;\n    }\n    clear() {\n      this.heap = [];\n    }\n    toArray() {\n      return this.heap.slice().sort((a,b) => a.weight - b.weight);\n    }\n  }\n\n  // Generate a random connected undirected weighted graph\n  function generateGraph(numNodes, densityPercent, maxWeight) {\n    // Place nodes evenly in a circle\n    const nodes = [];\n    const radius = Math.min(canvas.width, canvas.height) / 2 * 0.8;\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n    for(let i = 0; i < numNodes; i++) {\n      let angle = (2 * Math.PI * i) / numNodes - Math.PI/2;\n      let x = centerX + radius * Math.cos(angle);\n      let y = centerY + radius * Math.sin(angle);\n      nodes.push({id: i, x, y});\n    }\n\n    // Fully connected base to guarantee connectedness by MST (a tree - chain)\n    let edges = [];\n    for(let i = 1; i < numNodes; i++) {\n      const w = 1 + Math.floor(Math.random()*maxWeight);\n      edges.push({from: i-1, to: i, weight: w});\n    }\n\n    // Possible edges excluding the chain edges added\n    const possibleEdges = [];\n    for(let i = 0; i < numNodes; i++) {\n      for(let j = i+1; j < numNodes; j++) {\n        // Ignore edges already added in the chain\n        if(j === i+1) continue;\n        possibleEdges.push({from: i, to: j});\n      }\n    }\n\n    // Calculate number of edges based on density\n    const maxEdges = numNodes*(numNodes-1)/2;\n    const targetEdges = Math.floor(maxEdges * (densityPercent/100));\n    const additionalEdgesNeeded = Math.max(0, targetEdges - edges.length);\n\n    // Shuffle possible edges array\n    for(let i = possibleEdges.length-1; i > 0; i--){\n      let r = Math.floor(Math.random()*(i+1));\n      [possibleEdges[i], possibleEdges[r]] = [possibleEdges[r], possibleEdges[i]];\n    }\n\n    // Add random edges with random weights\n    for(let i = 0; i < additionalEdgesNeeded && i < possibleEdges.length; i++) {\n      const e = possibleEdges[i];\n      const w = 1 + Math.floor(Math.random()*maxWeight);\n      edges.push({from: e.from, to: e.to, weight: w});\n    }\n\n    // Build adjacency list\n    const adjList = new Map();\n    for(let i = 0; i < numNodes; i++) adjList.set(i, []);\n    for(const e of edges) {\n      adjList.get(e.from).push({to: e.to, weight: e.weight});\n      adjList.get(e.to).push({to: e.from, weight: e.weight});\n    }\n\n    return {nodes, edges, adjList};\n  }\n\n  // Drawing colors and styles\n  const colors = {\n    background: '#222',\n    node: '#888',\n    nodeInMST: '#00cc44',\n    nodeCurrent: '#ffcc00',\n    edge: '#bbb',\n    edgeInMST: '#00cc44',\n    edgeCandidate: '#ff9933',\n    text: '#eee',\n    weightText: '#ddd',\n  };\n\n  // Draw graph: nodes and edges\n  function drawGraph(primState=null) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw all edges first\n    for(const e of graph.edges) {\n      // Base edge color\n      let color = colors.edge;\n      let lineWidth = 1.5;\n\n      // If edge in MST\n      if(primState && primState.mstEdges.find(ed => \n          (ed.from === e.from && ed.to === e.to) || \n          (ed.from === e.to && ed.to === e.from) )) {\n        color = colors.edgeInMST;\n        lineWidth = 4;\n      }\n      // If edge is a candidate (on min heap)\n      else if(primState && primState.edgeCandidates && primState.edgeCandidates.heap.find(ed => \n          (ed.from === e.from && ed.to === e.to) || \n          (ed.from === e.to && ed.to === e.from) )) {\n        color = colors.edgeCandidate;\n        lineWidth = 3;\n      }\n\n      const fromNode = graph.nodes[e.from];\n      const toNode = graph.nodes[e.to];\n      ctx.strokeStyle = color;\n      ctx.lineWidth = lineWidth;\n      ctx.beginPath();\n      ctx.moveTo(fromNode.x, fromNode.y);\n      ctx.lineTo(toNode.x, toNode.y);\n      ctx.stroke();\n\n      // Draw weight label (midpoint)\n      const mx = (fromNode.x + toNode.x)/2;\n      const my = (fromNode.y + toNode.y)/2;\n      ctx.fillStyle = colors.weightText;\n      ctx.font = \"12px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(e.weight, mx, my);\n    }\n\n    // Draw nodes\n    for(const node of graph.nodes) {\n      let color = colors.node;\n      let radius = 12;\n      if(primState) {\n        if(primState.visited.has(node.id)) {\n          color = colors.nodeInMST;\n          radius = 14;\n        }\n        if(primState.currentNode === node.id) {\n          color = colors.nodeCurrent;\n          radius = 18;\n        }\n      }\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, radius, 0, 2*Math.PI);\n      ctx.fill();\n\n      // Draw node id label\n      ctx.fillStyle = colors.text;\n      ctx.font = \"bold 14px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(node.id, node.x, node.y);\n    }\n  }\n\n  // Log helper\n  function log(msg) {\n    logDiv.innerHTML += msg + '<br>';\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n  function clearLog() {\n    logDiv.innerHTML = '';\n  }\n\n  // Prim's Algorithm generator for step-wise execution\n  function* primAlgorithm(startNode=0) {\n    const visited = new Set();\n    const mstEdges = [];\n    const edgeCandidates = new MinHeap();\n\n    visited.add(startNode);\n    let currentNode = startNode;\n\n    log(`Start at node ${startNode}.`);\n    yield {visited, mstEdges: mstEdges.slice(), edgeCandidates: edgeCandidates, currentNode};\n\n    // Add all edges from start node to heap\n    for(const e of graph.adjList.get(currentNode)) {\n      edgeCandidates.push({from: currentNode, to: e.to, weight: e.weight});\n    }\n    log(`Add edges adjacent to node ${currentNode} to candidate edges.`);\n\n    yield {visited, mstEdges: mstEdges.slice(), edgeCandidates: edgeCandidates, currentNode};\n\n    while(visited.size < graph.nodes.length) {\n      // Remove invalid edges with both endpoints in visited\n      while(edgeCandidates.size() > 0) {\n        const nextEdge = edgeCandidates.peek();\n        if(visited.has(nextEdge.to)) {\n          edgeCandidates.pop();\n        } else {\n          break;\n        }\n      }\n      if(edgeCandidates.size() === 0) {\n        log('No edges to expand - graph is disconnected!');\n        break;\n      }\n\n      // Pick edge with minimal weight connecting visited and unvisited\n      const minEdge = edgeCandidates.pop();\n      mstEdges.push(minEdge);\n      visited.add(minEdge.to);\n      currentNode = minEdge.to;\n\n      log(`Select edge (${minEdge.from} ↔ ${minEdge.to}) with weight ${minEdge.weight}.` +\n          ` Add node ${minEdge.to} to MST.`);\n\n      yield {visited, mstEdges: mstEdges.slice(), edgeCandidates: edgeCandidates, currentNode};\n\n      // Add edges from new node which lead to unvisited nodes\n      const newEdges = graph.adjList.get(currentNode)\n        .filter(e => !visited.has(e.to))\n        .map(e => ({from: currentNode, to: e.to, weight: e.weight}));\n      for(const e of newEdges) {\n        edgeCandidates.push(e);\n      }\n      if(newEdges.length > 0) {\n        log(`Add edges adjacent to node ${currentNode} to candidate edges.`);\n        yield {visited, mstEdges: mstEdges.slice(), edgeCandidates: edgeCandidates, currentNode};\n      }\n    }\n    log('Prim\\'s Algorithm completed. Minimum Spanning Tree constructed.');\n    yield {visited, mstEdges: mstEdges.slice(), edgeCandidates: edgeCandidates, currentNode:null, done:true};\n  }\n\n  // Controls and variables\n  let primIterator = null;\n  let primTimer = null;\n\n  function resetUI() {\n    startBtn.disabled = !graph;\n    stepBtn.disabled = true;\n    resetBtn.disabled = true;\n    generateBtn.disabled = false;\n    clearLog();\n    drawGraph();\n  }\n\n  function generate() {\n    const n = parseInt(numNodesInput.value);\n    const d = parseInt(densityInput.value);\n    const wMax = parseInt(weightRangeInput.value);\n    if(Number.isNaN(n) || n < 3 || n > 20) {\n      alert('Number of nodes must be between 3 and 20.');\n      return;\n    }\n    if(Number.isNaN(d) || d < 10 || d > 100) {\n      alert('Density must be between 10% and 100%.');\n      return;\n    }\n    if(Number.isNaN(wMax) || wMax < 1 || wMax > 100) {\n      alert('Max weight must be between 1 and 100.');\n      return;\n    }\n    graph = generateGraph(n, d, wMax);\n    clearLog();\n    log(`Graph generated with ${n} nodes and ${graph.edges.length} edges.`);\n    drawGraph();\n    startBtn.disabled = false;\n    stepBtn.disabled = true;\n    resetBtn.disabled = true;\n  }\n\n  function startPrim() {\n    if(!graph) return;\n    primIterator = primAlgorithm(0);\n    stepBtn.disabled = false;\n    startBtn.disabled = true;\n    generateBtn.disabled = true;\n    resetBtn.disabled = false;\n    clearLog();\n    advancePrimStep();\n    if(speedInput.value !== '0') {\n      primTimer = setInterval(() => {\n        advancePrimStep();\n      }, parseInt(speedInput.value));\n      stepBtn.disabled = true;\n    }\n  }\n\n  // Advance one step of Prim's algorithm\n  function advancePrimStep() {\n    if(!primIterator) return;\n    const res = primIterator.next();\n    if(res.done) {\n      drawGraph(res.value);\n      log('Algorithm finished.');\n      clearInterval(primTimer);\n      primTimer = null;\n      stepBtn.disabled = true;\n      startBtn.disabled = true;\n      resetBtn.disabled = false;\n      generateBtn.disabled = false;\n      return;\n    }\n    drawGraph(res.value);\n  }\n\n  function stepPrimManual() {\n    advancePrimStep();\n  }\n\n  function reset() {\n    if(primTimer) {\n      clearInterval(primTimer);\n      primTimer = null;\n    }\n    primIterator = null;\n    resetUI();\n  }\n\n  // Initialize\n  function init() {\n    resizeCanvas();\n    resetUI();\n  }\n\n  generateBtn.addEventListener('click', () => {\n    reset();\n    generate();\n  });\n  startBtn.addEventListener('click', () => startPrim());\n  stepBtn.addEventListener('click', () => stepPrimManual());\n  resetBtn.addEventListener('click', () => reset());\n\n  init();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}