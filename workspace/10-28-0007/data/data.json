[
  {
    "id": "13b188c0-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:26:22.156Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Array",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Array: Indexing & Insert/Delete (Interactive)</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #6ee7b7;\n      --muted: #94a3b8;\n      --card: #071226;\n      --danger: #fb7185;\n    }\n    /* Basic layout + safe margins */\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071025 0%, #07162b 100%);\n      color:#e6eef6;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app{\n      box-sizing:border-box;\n      padding: var(--safe-margin);\n      min-height:100%;\n      display:flex;\n      flex-direction:column;\n      gap: var(--gap);\n    }\n\n    header{\n      display:flex;\n      align-items: center;\n      justify-content: space-between;\n      gap: var(--gap);\n      flex-wrap:wrap;\n    }\n    .title {\n      display:flex;\n      flex-direction:column;\n      gap:4px;\n    }\n    h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing: -0.2px;\n    }\n    p.lead{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    main{\n      display:flex;\n      gap: var(--gap);\n      align-items: flex-start;\n      width:100%;\n    }\n\n    /* left controls column */\n    .controls{\n      flex:0 0 340px;\n      min-width:240px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.03);\n      padding:16px;\n      border-radius:10px;\n    }\n    .controls h2{\n      font-size:14px;\n      margin:0 0 8px 0;\n      color:var(--accent);\n    }\n    label{ font-size:13px; color:var(--muted); display:block; margin-bottom:6px; }\n    .row { display:flex; gap:12px; align-items:center; margin-bottom:12px; }\n    input[type=\"text\"], input[type=\"number\"]{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      padding:8px 10px;\n      border-radius:8px;\n      color:inherit;\n      outline:none;\n      min-width:0;\n    }\n    input[type=\"number\"]{ width:96px; }\n    button{\n      cursor:pointer;\n      padding:8px 12px;\n      background:linear-gradient(180deg,#0ea5a9,#07847f);\n      color:#021018;\n      border:0;\n      border-radius:8px;\n      font-weight:600;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n    }\n    button.ghost{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--muted);\n      font-weight:600;\n    }\n    .small{\n      padding:6px 10px;\n      font-size:13px;\n      border-radius:8px;\n    }\n    .controls .hint{ font-size:12px; color:var(--muted); margin-top:8px; }\n\n    /* visualization column */\n    .visual{\n      flex:1 1 0%;\n      min-width:0;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:10px;\n      padding:16px;\n      border: 1px solid rgba(255,255,255,0.03);\n    }\n    .vis-header{\n      display:flex;\n      align-items:center;\n      justify-content:space-between;\n      gap: var(--gap);\n      margin-bottom:12px;\n    }\n    .vis-area{\n      background: linear-gradient(180deg,#021226 0%, #051120 100%);\n      border-radius:10px;\n      padding:20px;\n      min-height:180px;\n      position:relative;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n\n    /* array row */\n    .array-row{\n      display:flex;\n      gap:16px;\n      align-items:flex-end;\n      flex-wrap:wrap;\n      min-height:92px;\n      align-content:flex-start;\n    }\n    .cell{\n      width:96px;\n      min-width:72px;\n      height:64px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      border-radius:10px;\n      display:flex;\n      flex-direction:column;\n      align-items:center;\n      justify-content:center;\n      gap:6px;\n      box-shadow: 0 6px 18px rgba(1,6,12,0.45);\n      transition: box-shadow 250ms ease, transform 250ms ease;\n      position:relative;\n      user-select:none;\n    }\n    .cell .value{\n      font-weight:700;\n      font-size:16px;\n      letter-spacing:-0.3px;\n    }\n    .cell .index{\n      font-size:12px;\n      color:var(--muted);\n    }\n    .cell.highlight{\n      box-shadow: 0 10px 30px rgba(110,231,183,0.15), 0 6px 18px rgba(2,6,12,0.6);\n      transform: translateY(-6px) scale(1.03);\n      border-color: rgba(110,231,183,0.35);\n    }\n\n    /* small animated badge for operations */\n    .op-badge{\n      position:absolute;\n      right:16px;\n      top:16px;\n      background:rgba(255,255,255,0.03);\n      padding:6px 8px;\n      border-radius:8px;\n      font-size:12px;\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.02);\n    }\n\n    /* explanation footer */\n    .explain{\n      margin-top:12px;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* accessibility focus */\n    button:focus, input:focus{\n      outline:2px solid rgba(110,231,183,0.14);\n      outline-offset:2px;\n    }\n\n    /* responsive */\n    @media (max-width:900px){\n      main{ flex-direction:column; }\n      .controls{ width:100%; }\n    }\n\n    /* subtle animation helpers */\n    .fade-out{\n      animation: fadeOut 320ms ease forwards;\n    }\n    @keyframes fadeOut{\n      to{ opacity:0; transform: scale(0.98); }\n    }\n    .pulse{\n      animation: pulse 700ms ease;\n    }\n    @keyframes pulse{\n      0%{ box-shadow: 0 10px 30px rgba(110,231,183,0.2); transform: translateY(-4px) scale(1.02); }\n      100%{ box-shadow:none; transform:none; }\n    }\n\n    /* informational panel */\n    .info{\n      margin-top:12px;\n      background: rgba(255,255,255,0.01);\n      padding:12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.02);\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* small legend */\n    .legend { display:flex; gap:12px; align-items:center; font-size:13px; color:var(--muted); }\n    .legend .dot{\n      width:12px; height:12px; border-radius:3px;\n      background:var(--accent); box-shadow:0 6px 14px rgba(110,231,183,0.08);\n    }\n    footer{ color:var(--muted); font-size:13px; margin-top:4px; }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Interactive array module\">\n    <header>\n      <div class=\"title\" aria-hidden=\"false\">\n        <h1>Array — Indexing & Insert/Delete Visualization</h1>\n        <p class=\"lead\">See how inserting and removing elements affects positions (shifts) and indexed access.</p>\n      </div>\n      <div style=\"display:flex;gap:12px;align-items:center;\">\n        <div style=\"text-align:right;\">\n          <div style=\"font-size:12px;color:var(--muted)\">Module</div>\n          <div style=\"font-weight:700\">Single Concept: Indexed Sequence</div>\n        </div>\n      </div>\n    </header>\n\n    <main>\n      <!-- Controls -->\n      <section class=\"controls\" aria-labelledby=\"controls-heading\">\n        <h2 id=\"controls-heading\">Controls</h2>\n\n        <div style=\"margin-bottom:8px;\">\n          <label for=\"value-input\">Value (string or number)</label>\n          <input id=\"value-input\" type=\"text\" aria-label=\"Value to add\" placeholder=\"e.g., 42 or 'apple'\">\n        </div>\n\n        <div class=\"row\" aria-hidden=\"false\">\n          <button id=\"push-btn\" class=\"small\" title=\"Push to end\">Push (end)</button>\n          <button id=\"pop-btn\" class=\"small ghost\" title=\"Remove from end\">Pop (end)</button>\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <label for=\"index-input\">Index (0-based)</label>\n          <div style=\"display:flex;gap:12px;\">\n            <input id=\"index-input\" type=\"number\" min=\"0\" aria-label=\"Index for insert or remove\" placeholder=\"index\">\n            <button id=\"insert-btn\" class=\"small\" title=\"Insert at index\">Insert</button>\n            <button id=\"remove-btn\" class=\"small ghost\" title=\"Remove at index\">Remove</button>\n          </div>\n          <div class=\"hint\">If index is larger than length, insert will append. Negative indices are clamped to 0.</div>\n        </div>\n\n        <hr style=\"border:none;height:1px;margin:12px 0;background:rgba(255,255,255,0.02)\">\n\n        <div style=\"display:flex;gap:12px;flex-wrap:wrap;\">\n          <button id=\"access-btn\" class=\"small\">Access by Index</button>\n          <button id=\"random-btn\" class=\"small ghost\">Randomize (demo)</button>\n          <button id=\"clear-btn\" class=\"small ghost\">Clear</button>\n        </div>\n\n        <div class=\"info\" role=\"note\" aria-live=\"polite\">\n          <strong>What you will see:</strong>\n          <div style=\"margin-top:8px;\">\n            - Push/Pop change the end without shifting neighbors.<br>\n            - Insert/Delete at a middle index animates a right/left shift of subsequent elements.\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px;font-size:13px;color:var(--muted);\">\n          Accessibility: All controls are keyboard-focusable. Use Tab and Enter/Space.\n        </div>\n      </section>\n\n      <!-- Visualization -->\n      <section class=\"visual\" aria-labelledby=\"visual-heading\">\n        <div class=\"vis-header\">\n          <div>\n            <h2 id=\"visual-heading\" style=\"margin:0;font-size:14px;color:var(--accent)\">Array Visualization</h2>\n            <div style=\"font-size:13px;color:var(--muted);margin-top:6px;\">\n              Boxes show value and index. Watch shifting animations when inserting/removing.\n            </div>\n          </div>\n          <div style=\"display:flex;gap:12px;align-items:center;\">\n            <div class=\"legend\" aria-hidden=\"true\"><div class=\"dot\"></div><div>Indexed cell</div></div>\n            <div style=\"font-size:13px;color:var(--muted)\">Length: <span id=\"length-badge\" style=\"font-weight:700;margin-left:6px\">0</span></div>\n          </div>\n        </div>\n\n        <div class=\"vis-area\" id=\"vis-area\" tabindex=\"0\">\n          <div class=\"op-badge\" id=\"op-badge\" aria-live=\"polite\">Ready</div>\n          <div class=\"array-row\" id=\"array-row\" aria-live=\"polite\" aria-relevant=\"additions removals\"></div>\n\n          <div class=\"explain\" id=\"explain\" aria-hidden=\"false\">\n            Tip: Click \"Access by Index\" after entering an index to highlight that cell (shows O(1) direct access).\n            When you insert/remove in the middle you'll see a visual shift of the elements to the right or left.\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px;display:flex;gap:12px;align-items:center;flex-wrap:wrap;\">\n          <div style=\"font-size:13px;color:var(--muted)\">Operation cost:</div>\n          <div id=\"cost-pill\" style=\"background:rgba(255,255,255,0.025);padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);min-width:110px;text-align:center;\">\n            <div style=\"font-size:13px;color:var(--muted)\">Insert/Delete at middle</div>\n            <div style=\"font-weight:700;margin-top:6px\" id=\"cost-value\">O(n) — elements shift</div>\n          </div>\n        </div>\n      </section>\n    </main>\n\n    <!-- Design Plan & Layout Description -->\n    <section style=\"margin-top:8px;\">\n      <h2 style=\"margin:0 0 6px 0;font-size:14px;color:var(--accent)\">Interactive Design Plan</h2>\n\n      <div style=\"background:rgba(255,255,255,0.01);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);color:var(--muted);font-size:13px;\">\n        <strong>Concept Title:</strong> Array — Indexing and shifting behavior on insert/delete<br><br>\n\n        <strong>Learning Objective:</strong> After interacting, users will be able to:\n        <ul>\n          <li>Identify array indices (0-based) and access an element directly.</li>\n          <li>Observe how inserting/removing at an index causes subsequent elements to shift positions.</li>\n          <li>Relate the visual shifts to the O(n) cost for middle insert/delete operations.</li>\n        </ul>\n\n        <strong>Interaction Design:</strong>\n        <div style=\"margin-top:6px;\">\n          - Click \"Push (end)\" to append a value; the new cell appears at the end with a brief pop animation.<br>\n          - Click \"Pop (end)\" to remove the last element; it fades out. No other elements move.<br>\n          - Enter Index + click \"Insert\": we perform a FLIP-style animation:\n            1) record current positions of visible cells,\n            2) update the array model (splice in new element),\n            3) compute position deltas and animate existing cells shifting right to their new positions, while the new cell fades/zooms into place.\n            This communicates that items after the insertion point must move.<br>\n          - Click \"Remove\" for an index: cells after that index shift left smoothly to fill the gap while the removed cell fades out.<br>\n          - Use \"Access by Index\" to highlight a single cell (simulates constant-time indexed access). This highlights the difference between direct access and shifting cost.<br>\n          - Visual feedback includes animated transforms, shadow/pulse for highlight, and an operation badge that updates with short textual feedback (e.g., \"Inserted at 2 — shifted 3 elements\").<br>\n          - All interactions are keyboard-accessible and announced via aria-live regions for screen readers.\n        </div>\n\n        <strong>Layout Description:</strong>\n        <div style=\"margin-top:6px;\">\n          - Overall container uses safe area margins of 24px on all sides. The main content arranges into two columns:\n            left column (controls) fixed-width (~340px) and right column (visualization) flexible to fill remaining space.\n          - Minimum spacing between interactive elements is 16px (CSS gap used widely). Controls use stacked groups with 12–16px gaps for clarity.\n          - Visualization area centers the array boxes horizontally and wraps to multiple lines on narrow screens (responsive).\n          - Color contrasts, focus outlines, and aria-live regions support accessibility. Buttons and inputs are sized for comfortable touch targets.\n        </div>\n      </div>\n    </section>\n\n    <footer>\n      Tips: Try inserting at index 0 repeatedly to see many elements shift — that's the main cost demonstration.\n    </footer>\n  </div>\n\n  <script>\n    (function(){\n      // Model\n      let arr = [];\n\n      // DOM refs\n      const row = document.getElementById('array-row');\n      const lengthBadge = document.getElementById('length-badge');\n      const opBadge = document.getElementById('op-badge');\n      const costValue = document.getElementById('cost-value');\n      const valueInput = document.getElementById('value-input');\n      const indexInput = document.getElementById('index-input');\n\n      // Buttons\n      const pushBtn = document.getElementById('push-btn');\n      const popBtn = document.getElementById('pop-btn');\n      const insertBtn = document.getElementById('insert-btn');\n      const removeBtn = document.getElementById('remove-btn');\n      const accessBtn = document.getElementById('access-btn');\n      const randomBtn = document.getElementById('random-btn');\n      const clearBtn = document.getElementById('clear-btn');\n\n      // Utility: normalize value (show strings with quotes)\n      function formatVal(v){\n        if (v === null) return 'null';\n        if (v === undefined) return 'undefined';\n        if (typeof v === 'string') {\n          if (/^\\d+$/.test(v)) return v; // numeric-looking string: keep raw\n          return '\"' + v + '\"';\n        }\n        return String(v);\n      }\n\n      // Render the array with FLIP animation\n      function render(withAnimation = true, opText = 'Ready') {\n        // record old positions\n        const oldRects = new Map();\n        row.querySelectorAll('.cell').forEach(el => {\n          oldRects.set(el.dataset.key, el.getBoundingClientRect());\n        });\n\n        // clear and rebuild\n        // Use keys for stable identity: key = index + \":\" + unique id (unique id stored on object)\n        row.innerHTML = '';\n        arr.forEach((item, idx) => {\n          const cell = document.createElement('div');\n          cell.className = 'cell';\n          const key = item.__id;\n          cell.setAttribute('data-key', key);\n          cell.setAttribute('role','group');\n          cell.setAttribute('aria-label', `Index ${idx}, value ${String(item.v)}`);\n          cell.tabIndex = 0;\n\n          const val = document.createElement('div');\n          val.className = 'value';\n          val.textContent = formatVal(item.v);\n\n          const ind = document.createElement('div');\n          ind.className = 'index';\n          ind.textContent = idx;\n\n          cell.appendChild(val);\n          cell.appendChild(ind);\n          row.appendChild(cell);\n        });\n\n        // update length\n        lengthBadge.textContent = arr.length;\n\n        // perform FLIP: compute new positions and animate differences\n        if (!withAnimation) {\n          opBadge.textContent = opText;\n          return;\n        }\n        const newRects = new Map();\n        row.querySelectorAll('.cell').forEach(el => {\n          newRects.set(el.dataset.key, el.getBoundingClientRect());\n        });\n\n        // For elements that exist in both, apply inverse transform then animate to zero\n        row.querySelectorAll('.cell').forEach(el => {\n          const key = el.dataset.key;\n          const oldRect = oldRects.get(key);\n          const newRect = newRects.get(key);\n          if (oldRect) {\n            const dx = oldRect.left - newRect.left;\n            const dy = oldRect.top - newRect.top;\n            if (dx || dy) {\n              el.style.transition = 'none';\n              el.style.transform = `translate(${dx}px, ${dy}px)`;\n              // force reflow\n              el.getBoundingClientRect();\n              requestAnimationFrame(() => {\n                el.style.transition = 'transform 360ms cubic-bezier(.22,.9,.35,1), box-shadow 240ms';\n                el.style.transform = '';\n              });\n            }\n          } else {\n            // new element: animate pulse in\n            el.style.opacity = 0;\n            el.style.transform = 'scale(0.96)';\n            el.style.transition = 'opacity 280ms ease, transform 280ms ease';\n            requestAnimationFrame(() => {\n              el.style.opacity = 1;\n              el.style.transform = '';\n            });\n          }\n        });\n\n        // elements removed: animate fade from clones\n        oldRects.forEach((rect, key) => {\n          if (!newRects.has(key)) {\n            // create a clone floating at old position\n            const clone = document.createElement('div');\n            clone.className = 'cell';\n            clone.style.position = 'fixed';\n            clone.style.left = rect.left + 'px';\n            clone.style.top = rect.top + 'px';\n            clone.style.width = rect.width + 'px';\n            clone.style.height = rect.height + 'px';\n            clone.style.margin = 0;\n            clone.style.zIndex = 1200;\n            clone.style.transition = 'transform 320ms ease, opacity 320ms ease';\n            // fill clone content based on key (we can find value in previous arr snapshot)\n            // For simplicity, just show a faded block\n            clone.style.opacity = 0.95;\n            clone.style.pointerEvents = 'none';\n            clone.innerHTML = '<div style=\"height:100%;display:flex;align-items:center;justify-content:center;color:var(--muted)\">removed</div>';\n            document.body.appendChild(clone);\n            requestAnimationFrame(() => {\n              clone.style.opacity = 0;\n              clone.style.transform = 'scale(0.96) translateY(-8px)';\n            });\n            setTimeout(() => clone.remove(), 360);\n          }\n        });\n\n        // update op badge\n        opBadge.textContent = opText;\n\n        // small accessibility announcement\n        setTimeout(()=> {\n          opBadge.setAttribute('aria-hidden','false');\n        }, 0);\n      }\n\n      // Create items with unique id\n      let uid = 1;\n      function makeItem(raw){\n        return { v: raw, __id: String(Date.now()) + '-' + (uid++) };\n      }\n\n      // Operations\n      function pushValue(raw){\n        if (raw === '') return;\n        const item = makeItem(raw);\n        arr.push(item);\n        render(true, `Pushed → \"${raw}\"`);\n      }\n\n      function popValue(){\n        if (arr.length === 0) {\n          render(false, 'Array empty');\n          return;\n        }\n        const removed = arr.pop();\n        render(true, `Popped ← ${formatVal(removed.v)}`);\n      }\n\n      function insertAt(raw, idx){\n        if (raw === '') return;\n        idx = Number(idx);\n        if (!Number.isFinite(idx) || isNaN(idx)) idx = arr.length;\n        idx = Math.max(0, Math.floor(idx));\n        const clamped = Math.min(idx, arr.length);\n        const item = makeItem(raw);\n        // Count how many elements will shift: those at positions >= clamped\n        const numShift = arr.length - clamped;\n        arr.splice(clamped, 0, item);\n        render(true, `Inserted at ${clamped} (shifted ${numShift} element${numShift===1?'':'s'})`);\n      }\n\n      function removeAt(idx){\n        idx = Number(idx);\n        if (!Number.isFinite(idx) || isNaN(idx)) {\n          render(false, 'Invalid index');\n          return;\n        }\n        idx = Math.floor(idx);\n        if (idx < 0 || idx >= arr.length) {\n          render(false, 'Index out of range');\n          return;\n        }\n        const removed = arr.splice(idx,1)[0];\n        const numShift = Math.max(0, arr.length - idx);\n        render(true, `Removed at ${idx} (shifted ${numShift} element${numShift===1?'':'s'})`);\n      }\n\n      function accessAt(idx){\n        idx = Number(idx);\n        if (!Number.isFinite(idx) || isNaN(idx)) {\n          render(false, 'Invalid index');\n          return;\n        }\n        idx = Math.floor(idx);\n        if (idx < 0 || idx >= arr.length) {\n          render(false, 'Index out of range');\n          return;\n        }\n        // highlight the cell\n        const cell = Array.from(row.children)[idx];\n        if (!cell) return;\n        // animate a pulse and temporary highlight\n        cell.classList.add('highlight');\n        cell.classList.add('pulse');\n        const val = arr[idx].v;\n        render(false, `Accessed index ${idx} → ${formatVal(val)}`);\n        setTimeout(()=> {\n          cell.classList.remove('pulse');\n          setTimeout(()=> cell.classList.remove('highlight'), 360);\n        }, 520);\n      }\n\n      // Randomize demo\n      function randomDemo(){\n        const sample = ['apple','banana','cat',42,7,'x','hello','99','z'];\n        arr = [];\n        const n = Math.floor(Math.random()*6)+3;\n        for (let i=0;i<n;i++){\n          arr.push(makeItem(String(sample[Math.floor(Math.random()*sample.length)])));\n        }\n        render(true, 'Randomized');\n      }\n\n      function clearAll(){\n        arr = [];\n        render(false, 'Cleared');\n      }\n\n      // Event bindings\n      pushBtn.addEventListener('click', ()=> {\n        pushValue(valueInput.value.trim());\n        valueInput.value = '';\n        valueInput.focus();\n      });\n      popBtn.addEventListener('click', ()=> popValue());\n      insertBtn.addEventListener('click', ()=> {\n        insertAt(valueInput.value.trim(), indexInput.value);\n        valueInput.value = '';\n        indexInput.value = '';\n        valueInput.focus();\n      });\n      removeBtn.addEventListener('click', ()=> {\n        removeAt(indexInput.value);\n        indexInput.value = '';\n      });\n      accessBtn.addEventListener('click', ()=> {\n        accessAt(indexInput.value);\n      });\n      randomBtn.addEventListener('click', randomDemo);\n      clearBtn.addEventListener('click', clearAll);\n\n      // keyboard: Enter in value input => push, Shift+Enter => insert at 0\n      valueInput.addEventListener('keydown', (e)=>{\n        if (e.key === 'Enter') {\n          e.preventDefault();\n          if (e.shiftKey) {\n            insertAt(valueInput.value.trim(), 0);\n          } else {\n            pushValue(valueInput.value.trim());\n            valueInput.value = '';\n          }\n        }\n      });\n\n      // initial demo\n      (function seed(){\n        const initial = ['a','b','c','d'];\n        arr = initial.map(x => makeItem(x));\n        render(false,'Ready');\n      })();\n\n      // Update cost text (constant demonstration)\n      costValue.textContent = 'O(n) — shifting elements after index';\n\n      // Accessibility: announce operations by updating opBadge (aria-live)\n      // Already handled via opBadge text changes.\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Array.\n\n**Project Overview:**\nTopic: Array\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Array"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "1893fdf0-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:26:30.351Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Linked List",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Linked List Explorer</title>\n  <style>\n    /* Safe area margins 24px and base layout */\n    :root {\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --accent: #38bdf8;\n      --muted: #94a3b8;\n      --node-bg: #111827;\n      --node-border: #334155;\n      --success: #10b981;\n      --danger: #f43f5e;\n    }\n\n    html,body {\n      height: 100%;\n      margin: 0;\n      background: linear-gradient(180deg,#071025 0%, #02101a 100%);\n      color: #e6eef8;\n      font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n\n    /* Container with safe area margins */\n    .page {\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height: 100vh;\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n    }\n\n    header {\n      display: flex;\n      align-items: flex-start;\n      gap: var(--gap);\n      flex-wrap: wrap;\n    }\n\n    h1 {\n      margin: 0;\n      font-size: 1.25rem;\n      letter-spacing: -0.02em;\n      color: #fff;\n    }\n\n    .meta {\n      max-width: 900px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.03);\n      padding: 14px;\n      border-radius: 10px;\n      display: flex;\n      flex-direction: column;\n      gap: 10px;\n    }\n\n    .small {\n      color: var(--muted);\n      font-size: 0.95rem;\n      line-height: 1.3;\n    }\n\n    .two-col {\n      display: flex;\n      gap: var(--gap);\n      align-items: flex-start;\n      width: 100%;\n      flex-wrap: wrap;\n    }\n\n    /* Interactive module layout */\n    .module {\n      display: flex;\n      gap: var(--gap);\n      align-items: stretch;\n      width: 100%;\n      flex-wrap: wrap;\n    }\n\n    .controls {\n      min-width: 280px;\n      max-width: 360px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.03);\n      padding: 16px;\n      border-radius: 10px;\n      box-sizing: border-box;\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n    }\n\n    .controls label {\n      display: block;\n      font-size: 0.9rem;\n      color: var(--muted);\n      margin-bottom: 6px;\n    }\n\n    .row {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n    }\n\n    input[type=\"text\"], input[type=\"number\"], select {\n      width: 100%;\n      padding: 10px 12px;\n      border-radius: 8px;\n      border: 1px solid rgba(255,255,255,0.04);\n      background: rgba(255,255,255,0.02);\n      color: #e6eef8;\n      box-sizing: border-box;\n      font-size: 0.95rem;\n    }\n\n    button {\n      padding: 10px 12px;\n      border-radius: 8px;\n      border: 0;\n      cursor: pointer;\n      background: linear-gradient(180deg, rgba(56,189,248,0.14), rgba(56,189,248,0.06));\n      color: var(--accent);\n      font-weight: 600;\n      transition: transform .12s ease, box-shadow .12s ease;\n    }\n\n    button:hover { transform: translateY(-2px); }\n    .btn-danger {\n      background: linear-gradient(180deg, rgba(244,63,94,0.12), rgba(244,63,94,0.05));\n      color: var(--danger);\n    }\n    .btn-success {\n      background: linear-gradient(180deg, rgba(16,185,129,0.12), rgba(16,185,129,0.05));\n      color: var(--success);\n    }\n\n    /* Canvas area */\n    .canvas-wrap {\n      flex: 1 1 480px;\n      min-height: 260px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border: 1px solid rgba(255,255,255,0.03);\n      padding: 16px;\n      border-radius: 10px;\n      box-sizing: border-box;\n      position: relative;\n      overflow: auto;\n    }\n\n    .canvas-top {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      gap: 12px;\n      margin-bottom: 12px;\n    }\n\n    .status {\n      color: var(--muted);\n      font-size: 0.95rem;\n    }\n\n    /* Node visuals */\n    .list {\n      display: flex;\n      gap: 28px; /* spacing between nodes */\n      align-items: center;\n      min-height: 120px;\n      padding: 18px;\n      box-sizing: border-box;\n      position: relative;\n    }\n\n    .node {\n      width: 110px;\n      min-width: 110px;\n      height: 60px;\n      background: linear-gradient(180deg, var(--node-bg), rgba(17,24,39,0.9));\n      border: 1px solid var(--node-border);\n      border-radius: 10px;\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n      padding: 8px 10px;\n      box-sizing: border-box;\n      position: relative;\n      transition: transform 400ms cubic-bezier(.2,.9,.2,1), opacity 300ms;\n      box-shadow: 0 4px 18px rgba(2,6,23,0.6);\n    }\n\n    .node .val {\n      font-size: 1.05rem;\n      font-weight: 700;\n      color: #e6eef8;\n      letter-spacing: -0.02em;\n    }\n\n    .node .next-slot {\n      width: 28px;\n      height: 36px;\n      border-radius: 6px;\n      border: 1px dashed rgba(255,255,255,0.03);\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      color: var(--muted);\n      font-size: 0.78rem;\n    }\n\n    /* Arrow drawing uses SVG lines placed under nodes */\n    svg.arrow-layer {\n      position: absolute;\n      left: 0;\n      top: 0;\n      pointer-events: none;\n      overflow: visible;\n    }\n\n    /* Head label */\n    .head-label {\n      display: inline-flex;\n      gap: 8px;\n      align-items: center;\n      color: var(--muted);\n      font-size: 0.9rem;\n    }\n\n    .pointer {\n      position: absolute;\n      width: 40px;\n      height: 40px;\n      border-radius: 50%;\n      background: linear-gradient(180deg, rgba(56,189,248,0.18), rgba(56,189,248,0.06));\n      border: 1px solid rgba(56,189,248,0.13);\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      color: var(--accent);\n      font-weight: 700;\n      transform: translate(-50%,-50%);\n      transition: transform 450ms cubic-bezier(.2,.9,.2,1);\n      box-shadow: 0 8px 26px rgba(3,15,32,0.6);\n    }\n\n    .node.highlight {\n      outline: 3px solid rgba(56,189,248,0.14);\n      transform: translateY(-6px);\n      box-shadow: 0 14px 30px rgba(3,15,32,0.7);\n    }\n\n    .node.removing {\n      opacity: 0;\n      transform: translateY(24px) scale(.95);\n    }\n\n    .controls .group {\n      display: flex;\n      gap: 8px;\n      flex-wrap: wrap;\n    }\n\n    .legend {\n      display:flex;\n      gap: 12px;\n      align-items: center;\n      color: var(--muted);\n      font-size: 0.9rem;\n    }\n\n    .dot {\n      width: 12px;\n      height: 12px;\n      border-radius: 4px;\n      background: rgba(56,189,248,0.18);\n      border: 1px solid rgba(56,189,248,0.28);\n    }\n\n    .info {\n      margin-top: 12px;\n      color: var(--muted);\n      font-size: 0.92rem;\n      line-height: 1.4;\n      background: rgba(255,255,255,0.01);\n      padding: 10px;\n      border-radius: 8px;\n    }\n\n    footer {\n      color: var(--muted);\n      font-size: 0.9rem;\n    }\n\n    /* Responsive */\n    @media (max-width: 880px) {\n      .module { flex-direction: column; }\n      .controls { max-width: 100%; width: auto; }\n      .canvas-wrap { min-height: 320px; }\n      .list { padding: 10px; gap: 20px; }\n      .node { width: 96px; min-width: 96px; height: 56px; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"page\" role=\"main\">\n    <header class=\"two-col\" aria-labelledby=\"concept-title\">\n      <div class=\"meta\" style=\"flex:1 1 520px;\">\n        <h1 id=\"concept-title\">Linked List — Interactive Explorer</h1>\n        <div class=\"small\">\n          Explore how a singly linked list stores nodes with values and \"next\" pointers.\n          Use operations to insert, delete, and traverse while visual animations show pointer updates and node movement.\n        </div>\n      </div>\n\n      <div class=\"meta\" style=\"flex:0 1 320px;\">\n        <strong style=\"display:block; margin-bottom:6px;\">Learning Objective</strong>\n        <div class=\"small\">\n          After interacting, you will understand:\n          - How nodes are linked by \"next\" pointers,\n          - How insertion at head/tail/position updates pointers,\n          - How deletion removes a node and reconnects the list,\n          - How traversal visits nodes sequentially from head.\n        </div>\n      </div>\n    </header>\n\n    <section class=\"module\" aria-label=\"Interactive linked list module\">\n      <!-- Controls -->\n      <aside class=\"controls\" aria-labelledby=\"controls-heading\">\n        <h2 id=\"controls-heading\" style=\"margin:0 0 6px 0; font-size:1rem;\">Controls</h2>\n\n        <div>\n          <label for=\"value-input\">Node value</label>\n          <input id=\"value-input\" type=\"text\" inputmode=\"text\" placeholder='e.g., 42 or \"A\"' aria-label=\"Node value\" />\n        </div>\n\n        <div>\n          <label for=\"pos-input\">Position (index)</label>\n          <input id=\"pos-input\" type=\"number\" min=\"0\" step=\"1\" placeholder=\"0 = head\" aria-label=\"Position index\" />\n        </div>\n\n        <div class=\"group\" role=\"group\" aria-label=\"Insertion buttons\">\n          <button id=\"insert-head\">Insert at Head</button>\n          <button id=\"insert-tail\" class=\"btn-success\">Insert at Tail</button>\n          <button id=\"insert-at\">Insert at Position</button>\n        </div>\n\n        <div class=\"group\" role=\"group\" aria-label=\"Deletion buttons\">\n          <button id=\"delete-pos\" class=\"btn-danger\">Delete at Position</button>\n          <button id=\"clear-list\" class=\"btn-danger\">Clear</button>\n        </div>\n\n        <hr style=\"border:0; height:1px; background:rgba(255,255,255,0.02); margin:8px 0;\" />\n\n        <div>\n          <label>Traversal</label>\n          <div class=\"row\" style=\"margin-top:6px;\">\n            <button id=\"step-back\">&larr; Prev</button>\n            <button id=\"step-forward\">Next &rarr;</button>\n            <button id=\"play\">Play</button>\n            <button id=\"reset-trav\" class=\"btn-danger\">Reset</button>\n          </div>\n        </div>\n\n        <div class=\"info\" aria-live=\"polite\" id=\"info\">\n          List is empty. Add nodes to begin.\n        </div>\n\n        <div style=\"margin-top:6px;\">\n          <div class=\"legend\">\n            <div class=\"dot\" aria-hidden=\"true\"></div>\n            <div>Highlighted = current during traversal</div>\n          </div>\n        </div>\n      </aside>\n\n      <!-- Canvas -->\n      <section class=\"canvas-wrap\" aria-label=\"Linked list canvas\">\n        <div class=\"canvas-top\">\n          <div class=\"head-label\">\n            <strong style=\"color:#fff; margin-right:8px;\">Head</strong>\n            <div id=\"head-status\" class=\"status\">null</div>\n          </div>\n          <div class=\"status\" id=\"len-status\">Length: 0</div>\n        </div>\n\n        <div class=\"list\" id=\"list\" tabindex=\"0\" aria-label=\"Linked list nodes\"></div>\n\n        <!-- SVG for arrows -->\n        <svg class=\"arrow-layer\" id=\"svg\" width=\"2000\" height=\"500\" aria-hidden=\"true\"></svg>\n\n        <!-- Floating pointer representing current traversal pointer -->\n        <div id=\"pointer\" class=\"pointer\" style=\"display:none;\">P</div>\n      </section>\n    </section>\n\n    <section class=\"meta small\" aria-label=\"Interaction design and layout description\">\n      <strong style=\"display:block; margin-bottom:8px;\">Interaction Design</strong>\n      <div>\n        - Users type a value and optionally a position. Buttons insert at head, tail, or a specific index.\n        - Delete by position removes the node; Clear removes all nodes.\n        - Traversal controls: Next/Prev step through nodes. Play auto-steps with an animation of the pointer moving along arrows.\n        - Visual feedback:\n          - Newly inserted nodes animate into place (slide + fade).\n          - Deleted nodes animate out (fade + drop) before pointers redraw.\n          - During traversal the current node is highlighted and a floating pointer \"P\" moves to that node (smooth transform).\n          - SVG curved arrows update to represent \"next\" pointers.\n        - Clicking a node selects it (for quick feedback). Keyboard focus on the list allows arrow-key traversal (← / →).\n      </div>\n\n      <strong style=\"display:block; margin-top:12px; margin-bottom:8px;\">Layout Description</strong>\n      <div>\n        - Safe area: 24px page padding on all sides; all interactive elements use at least 16px gaps.\n        - Left column: Controls (forms & buttons) sized for touch; right column: visual canvas with nodes and pointer.\n        - The canvas uses horizontal flex layout to display nodes left-to-right, with SVG arrows absolutely positioned under the nodes.\n        - Responsive: columns stack on narrow screens. Contrast, large touch targets, and aria attributes improve accessibility.\n      </div>\n    </section>\n\n    <footer class=\"small\">\n      Tip: Try inserting at head, then at tail, then delete middle items to observe pointer re-linking.\n    </footer>\n  </div>\n\n  <script>\n    // Simple singly linked list visualizer (array-backed model)\n    (function () {\n      // Elements\n      const listEl = document.getElementById('list');\n      const svg = document.getElementById('svg');\n      const pointerEl = document.getElementById('pointer');\n      const headStatus = document.getElementById('head-status');\n      const lenStatus = document.getElementById('len-status');\n      const info = document.getElementById('info');\n\n      const valueInput = document.getElementById('value-input');\n      const posInput = document.getElementById('pos-input');\n      const insertHeadBtn = document.getElementById('insert-head');\n      const insertTailBtn = document.getElementById('insert-tail');\n      const insertAtBtn = document.getElementById('insert-at');\n      const deletePosBtn = document.getElementById('delete-pos');\n      const clearListBtn = document.getElementById('clear-list');\n\n      const stepForwardBtn = document.getElementById('step-forward');\n      const stepBackBtn = document.getElementById('step-back');\n      const playBtn = document.getElementById('play');\n      const resetTravBtn = document.getElementById('reset-trav');\n\n      let nodes = []; // {id, value}\n      let idCounter = 1;\n\n      // Traversal state\n      let currentIndex = -1;\n      let playTimer = null;\n\n      // Utility: update status text\n      function updateStatus(message) {\n        info.textContent = message;\n      }\n\n      function updateHeadLen() {\n        headStatus.textContent = nodes.length ? nodes[0].value : 'null';\n        lenStatus.textContent = 'Length: ' + nodes.length;\n      }\n\n      // Create node element\n      function createNodeEl(node) {\n        const el = document.createElement('div');\n        el.className = 'node';\n        el.dataset.id = node.id;\n        el.setAttribute('role','group');\n        el.setAttribute('aria-label','node ' + (node.value));\n        el.innerHTML = `\n          <div class=\"val\">${escapeHtml(String(node.value))}</div>\n          <div class=\"next-slot\">next</div>\n        `;\n        // click selects node\n        el.addEventListener('click', () => {\n          const idx = nodes.findIndex(n => n.id == node.id);\n          if (idx >= 0) {\n            goToIndex(idx);\n            updateStatus('Selected node at index ' + idx + '.');\n          }\n        });\n        return el;\n      }\n\n      // Draw list: ensure svg arrows match positions\n      function drawList() {\n        // Clear SVG\n        while (svg.firstChild) svg.removeChild(svg.firstChild);\n        // Place nodes as children of listEl: their layout managed by flexbox.\n        // After render, compute positions to draw arrows.\n        requestAnimationFrame(() => {\n          const nodeEls = Array.from(listEl.children);\n          for (let i = 0; i < nodeEls.length - 1; i++) {\n            const a = nodeEls[i];\n            const b = nodeEls[i+1];\n            const rectA = a.getBoundingClientRect();\n            const rectB = b.getBoundingClientRect();\n            const containerRect = listEl.getBoundingClientRect();\n            // Compute coordinates relative to svg\n            const startX = rectA.right - containerRect.left - 12;\n            const startY = rectA.top - containerRect.top + rectA.height / 2;\n            const endX = rectB.left - containerRect.left + 12;\n            const endY = rectB.top - containerRect.top + rectB.height / 2;\n\n            // Draw a smooth cubic bezier arrow\n            const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n            const dx = Math.max(40, (endX - startX) / 2);\n            const d = `M ${startX} ${startY} C ${startX + dx} ${startY} ${endX - dx} ${endY} ${endX} ${endY}`;\n            path.setAttribute('d', d);\n            path.setAttribute('fill','none');\n            path.setAttribute('stroke','rgba(56,189,248,0.18)');\n            path.setAttribute('stroke-width','3');\n            path.setAttribute('stroke-linecap','round');\n            svg.appendChild(path);\n\n            // Arrowhead\n            const arrow = document.createElementNS('http://www.w3.org/2000/svg','polygon');\n            const arrowSize = 6;\n            // place arrow at end, simple triangle\n            arrow.setAttribute('points', `${endX},${endY} ${endX - arrowSize},${endY - arrowSize} ${endX - arrowSize},${endY + arrowSize}`);\n            arrow.setAttribute('fill','rgba(56,189,248,0.22)');\n            svg.appendChild(arrow);\n          }\n          // Resize svg to contain the list\n          const rect = listEl.getBoundingClientRect();\n          svg.setAttribute('width', Math.max(800, rect.width + 200));\n          svg.setAttribute('height', Math.max(200, rect.height + 60));\n          svg.style.left = (listEl.offsetLeft - 20) + 'px';\n          svg.style.top = (listEl.offsetTop + 10) + 'px';\n          // Reposition pointer if visible\n          if (currentIndex >= 0) {\n            movePointerTo(currentIndex);\n          } else {\n            pointerEl.style.display = 'none';\n          }\n        });\n      }\n\n      // Escape html to avoid injection into node display\n      function escapeHtml(str) {\n        return str.replace(/[&<>\"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[s]));\n      }\n\n      // Insert helpers\n      function insertAt(idx, value) {\n        if (idx < 0) idx = 0;\n        if (idx > nodes.length) idx = nodes.length;\n        const node = { id: idCounter++, value };\n        nodes.splice(idx, 0, node);\n        renderInsert(idx, node);\n        updateHeadLen();\n        updateStatus('Inserted \"' + value + '\" at index ' + idx + '.');\n      }\n\n      function renderInsert(idx, node) {\n        // Create element but place it visually offset (animated entrance)\n        const el = createNodeEl(node);\n        el.style.opacity = '0';\n        el.style.transform = 'translateY(-20px) scale(.98)';\n        // Insert into DOM at correct position\n        if (idx >= listEl.children.length) {\n          listEl.appendChild(el);\n        } else {\n          listEl.insertBefore(el, listEl.children[idx]);\n        }\n        // After a frame, animate to place\n        requestAnimationFrame(() => {\n          el.style.opacity = '1';\n          el.style.transform = '';\n        });\n        // Re-draw arrows after a short delay to let layout stabilize\n        setTimeout(drawList, 120);\n      }\n\n      // Delete at index\n      function deleteAt(idx) {\n        if (idx < 0 || idx >= nodes.length) {\n          updateStatus('Invalid index for deletion.');\n          return;\n        }\n        const removed = nodes.splice(idx,1)[0];\n        const el = Array.from(listEl.children)[idx];\n        if (el) {\n          el.classList.add('removing');\n          // animate out then remove\n          setTimeout(() => {\n            if (el.parentNode) el.parentNode.removeChild(el);\n            drawList();\n          }, 320);\n        } else {\n          drawList();\n        }\n        // Update traversal pointer\n        if (currentIndex === idx) {\n          currentIndex = -1;\n          pointerEl.style.display = 'none';\n        } else if (currentIndex > idx) {\n          currentIndex--;\n        }\n        updateHeadLen();\n        updateStatus('Deleted node \"' + removed.value + '\" at index ' + idx + '.');\n      }\n\n      function clearAll() {\n        nodes = [];\n        idCounter = 1;\n        currentIndex = -1;\n        // Remove children with animation\n        Array.from(listEl.children).forEach((el, i) => {\n          el.classList.add('removing');\n          setTimeout(() => {\n            if (el.parentNode) el.parentNode.removeChild(el);\n            drawList();\n          }, 220 + i*40);\n        });\n        drawList();\n        updateHeadLen();\n        updateStatus('Cleared list.');\n      }\n\n      // Traversal functions\n      function goToIndex(idx) {\n        if (idx < 0 || idx >= nodes.length) {\n          updateStatus('Index out of range.');\n          return;\n        }\n        currentIndex = idx;\n        highlightCurrent();\n        movePointerTo(idx);\n      }\n\n      function highlightCurrent() {\n        Array.from(listEl.children).forEach((el, i) => {\n          el.classList.toggle('highlight', i === currentIndex);\n        });\n      }\n\n      function movePointerTo(idx) {\n        const el = listEl.children[idx];\n        if (!el) {\n          pointerEl.style.display = 'none';\n          return;\n        }\n        const rect = el.getBoundingClientRect();\n        const containerRect = listEl.getBoundingClientRect();\n        const x = rect.left - containerRect.left + rect.width / 2 + listEl.offsetLeft;\n        const y = rect.top - containerRect.top + rect.height + listEl.offsetTop + 12;\n        pointerEl.style.display = '';\n        pointerEl.style.transform = `translate(${x}px, ${y}px)`;\n      }\n\n      function stepForward() {\n        if (nodes.length === 0) {\n          updateStatus('List is empty.');\n          return;\n        }\n        if (currentIndex < nodes.length - 1) currentIndex++;\n        else currentIndex = nodes.length - 1;\n        highlightCurrent();\n        movePointerTo(currentIndex);\n        updateStatus('At index ' + currentIndex + ' (value: ' + nodes[currentIndex].value + ')');\n      }\n\n      function stepBackward() {\n        if (nodes.length === 0) {\n          updateStatus('List is empty.');\n          return;\n        }\n        if (currentIndex > 0) currentIndex--;\n        else currentIndex = 0;\n        highlightCurrent();\n        movePointerTo(currentIndex);\n        updateStatus('At index ' + currentIndex + ' (value: ' + nodes[currentIndex].value + ')');\n      }\n\n      function playTraversal() {\n        if (playTimer) {\n          clearInterval(playTimer);\n          playTimer = null;\n          playBtn.textContent = 'Play';\n          updateStatus('Playback paused.');\n          return;\n        }\n        if (nodes.length === 0) {\n          updateStatus('List is empty.');\n          return;\n        }\n        playBtn.textContent = 'Pause';\n        if (currentIndex < 0) currentIndex = -1;\n        playTimer = setInterval(() => {\n          if (currentIndex < nodes.length - 1) {\n            currentIndex++;\n            highlightCurrent();\n            movePointerTo(currentIndex);\n            updateStatus('At index ' + currentIndex + ' (value: ' + nodes[currentIndex].value + ')');\n          } else {\n            clearInterval(playTimer);\n            playTimer = null;\n            playBtn.textContent = 'Play';\n            updateStatus('Traversal finished.');\n          }\n        }, 900);\n      }\n\n      function resetTraversal() {\n        currentIndex = -1;\n        highlightCurrent();\n        pointerEl.style.display = 'none';\n        if (playTimer) {\n          clearInterval(playTimer);\n          playTimer = null;\n          playBtn.textContent = 'Play';\n        }\n        updateStatus('Traversal reset.');\n      }\n\n      // DOM events\n      insertHeadBtn.addEventListener('click', () => {\n        const v = valueInput.value.trim();\n        if (!v) { updateStatus('Please enter a value to insert.'); return; }\n        insertAt(0, v);\n      });\n\n      insertTailBtn.addEventListener('click', () => {\n        const v = valueInput.value.trim();\n        if (!v) { updateStatus('Please enter a value to insert.'); return; }\n        insertAt(nodes.length, v);\n      });\n\n      insertAtBtn.addEventListener('click', () => {\n        const v = valueInput.value.trim();\n        const pos = Number(posInput.value);\n        if (!v) { updateStatus('Enter a value first.'); return; }\n        if (!Number.isFinite(pos) || Number.isNaN(pos)) {\n          updateStatus('Enter a valid numeric position (0..length).');\n          return;\n        }\n        insertAt(pos, v);\n      });\n\n      deletePosBtn.addEventListener('click', () => {\n        const pos = Number(posInput.value);\n        if (!Number.isFinite(pos) || Number.isNaN(pos)) {\n          updateStatus('Enter a valid numeric position to delete.');\n          return;\n        }\n        deleteAt(pos);\n      });\n\n      clearListBtn.addEventListener('click', () => {\n        clearAll();\n      });\n\n      stepForwardBtn.addEventListener('click', stepForward);\n      stepBackBtn.addEventListener('click', stepBackward);\n      playBtn.addEventListener('click', playTraversal);\n      resetTravBtn.addEventListener('click', resetTraversal);\n\n      // Keyboard navigation within list (left/right)\n      listEl.addEventListener('keydown', (e) => {\n        if (e.key === 'ArrowRight') {\n          stepForward();\n          e.preventDefault();\n        } else if (e.key === 'ArrowLeft') {\n          stepBackward();\n          e.preventDefault();\n        }\n      });\n\n      // Initial draw placeholder\n      updateHeadLen();\n      drawList();\n\n      // Expose some state in console for advanced users\n      window._ll = {\n        insertAt, deleteAt, nodesRef: () => nodes\n      };\n\n      // Small demo: populate with some nodes to start (comment this block if not desired)\n      (function seed() {\n        const sample = ['A','B','C'];\n        sample.forEach((v,i) => insertAt(i, v));\n        updateStatus('Demo list created with nodes A, B, C. Try inserting and traversing.');\n      })();\n\n      // Accessibility: announce changes via ARIA live (info div is aria-live)\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Linked List.\n\n**Project Overview:**\nTopic: Linked List\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Linked List"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "11512a90-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:27:45.145Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Stack",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Stack Module</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1720;\n      --card: #0b1220;\n      --accent: #06b6d4;\n      --muted: #94a3b8;\n      --success: #10b981;\n      --danger: #ef4444;\n      --glass: rgba(255,255,255,0.04);\n      --max-width: 1100px;\n    }\n\n    /* Safe area margins */\n    html,body{height:100%;}\n    body{\n      margin:0;\n      padding:var(--safe-margin);\n      background: linear-gradient(180deg,#071022 0%, #07111b 100%);\n      color:#e6eef6;\n      font-family: Inter, \"Segoe UI\", Roboto, system-ui, -apple-system, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      box-sizing:border-box;\n    }\n\n    .container{\n      width:100%;\n      max-width:var(--max-width);\n      display:grid;\n      grid-template-columns: 380px 1fr;\n      gap:var(--gap);\n      align-items:start;\n    }\n\n    /* Responsive: stack vertically on narrow screens */\n    @media (max-width:880px){\n      .container{grid-template-columns:1fr; padding-bottom: var(--safe-margin);}\n    }\n\n    /* Left column (controls + explanation card) */\n    .panel{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.04);\n      border-radius:12px;\n      padding:20px;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.55);\n      min-height: 320px;\n    }\n\n    .title{\n      display:flex;\n      align-items:center;\n      gap:12px;\n      margin-bottom:12px;\n    }\n    .title h1{\n      font-size:20px;\n      margin:0;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    .section{\n      margin-top:12px;\n    }\n\n    label{display:block; font-size:13px; color:var(--muted); margin-bottom:8px;}\n\n    .controls{\n      display:flex;\n      flex-wrap:wrap;\n      gap:var(--gap);\n      margin-top:8px;\n    }\n\n    input[type=\"text\"], input[type=\"number\"], select{\n      padding:10px 12px;\n      border-radius:8px;\n      background:var(--glass);\n      border:1px solid rgba(255,255,255,0.04);\n      color:inherit;\n      outline:none;\n      min-width:140px;\n      font-size:14px;\n    }\n    input:focus, button:focus{\n      box-shadow: 0 0 0 3px rgba(6,182,212,0.12);\n      border-color: var(--accent);\n    }\n\n    .btn{\n      appearance:none;\n      border:none;\n      background:linear-gradient(180deg,var(--accent), #028fa8);\n      color: #042025;\n      padding:10px 14px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      font-size:14px;\n      min-width:72px;\n      display:inline-flex;\n      align-items:center;\n      justify-content:center;\n      gap:8px;\n    }\n\n    .btn.secondary{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--muted);\n      font-weight:600;\n    }\n\n    .btn.danger{\n      background:linear-gradient(180deg,var(--danger), #c43030);\n      color:white;\n    }\n\n    /* Visualization column */\n    .visual{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.04);\n      border-radius:12px;\n      padding:20px;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.55);\n      min-height:420px;\n      display:flex;\n      flex-direction:column;\n      gap:16px;\n    }\n\n    .vis-header{\n      display:flex;\n      align-items:center;\n      justify-content:space-between;\n      gap:16px;\n    }\n    .vis-header .controls-mini{display:flex; gap:12px; align-items:center;}\n\n    .stack-area{\n      display:flex;\n      gap:24px;\n      align-items:flex-start;\n      justify-content:center;\n      padding:6px;\n      min-height:260px;\n      width:100%;\n    }\n    /* Stack container */\n    .stack-frame{\n      width:220px;\n      max-width:48vw;\n      min-width:180px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:12px;\n      padding:12px;\n      border:1px dashed rgba(255,255,255,0.03);\n    }\n    .stack-outer{\n      height:320px;\n      display:flex;\n      align-items:flex-start;\n      justify-content:center;\n      position:relative;\n      -webkit-user-select:none;\n      user-select:none;\n    }\n\n    .slots{\n      width:160px;\n      height:100%;\n      display:flex;\n      flex-direction:column-reverse; /* bottom is index 0 */\n      gap:8px;\n      padding:12px 8px;\n      align-items:stretch;\n    }\n\n    .slot{\n      height:48px;\n      border-radius:8px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      color:var(--muted);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:600;\n      position:relative;\n      overflow:hidden;\n      transition:transform 350ms cubic-bezier(.2,.9,.23,1), background 250ms, box-shadow 200ms;\n    }\n\n    .slot.empty{\n      color: rgba(255,255,255,0.12);\n      font-weight:500;\n      font-size:13px;\n    }\n\n    .slot.filled{\n      color:#06121a;\n      background:linear-gradient(180deg, #a9f0f6, #6ee4ec);\n    }\n\n    .slot.top{\n      box-shadow: 0 12px 25px rgba(6,182,212,0.12);\n      transform: translateY(-6px);\n    }\n\n    /* index labels */\n    .indices{\n      display:flex;\n      flex-direction:column-reverse;\n      gap:8px;\n      align-items:flex-end;\n      justify-content:flex-start;\n      padding-right:8px;\n      min-width:36px;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* top pointer */\n    .top-pointer{\n      position:absolute;\n      right: -70px;\n      top: 24px;\n      transform-origin:left center;\n      display:flex;\n      align-items:center;\n      gap:8px;\n      color:var(--muted);\n      font-weight:600;\n      background:transparent;\n    }\n\n    .top-pointer .value{\n      color:var(--accent);\n      font-weight:700;\n      font-size:15px;\n      background:rgba(6,182,212,0.06);\n      padding:6px 8px;\n      border-radius:8px;\n      border:1px solid rgba(6,182,212,0.08);\n    }\n\n    /* Log box */\n    .log{\n      background:rgba(255,255,255,0.02);\n      border:1px solid rgba(255,255,255,0.03);\n      border-radius:10px;\n      padding:10px;\n      color:var(--muted);\n      font-size:13px;\n      max-height:120px;\n      overflow:auto;\n    }\n\n    /* Animations */\n    .animate-in{\n      animation: slideIn 420ms cubic-bezier(.2,.9,.23,1) forwards;\n    }\n    .animate-pop{\n      animation: popOut 300ms ease forwards;\n    }\n    .shake{\n      animation: shake 420ms cubic-bezier(.36,.07,.19,.97);\n    }\n    .pulse{\n      animation: pulse 800ms ease;\n    }\n\n    @keyframes slideIn{\n      0%{ transform: translateY(-80px) scale(.96); opacity:0; }\n      60%{ transform: translateY(10px) scale(1.02); opacity:1; }\n      100%{ transform: translateY(0) scale(1); opacity:1; }\n    }\n    @keyframes popOut{\n      0%{ transform: translateY(0) scale(1); opacity:1; }\n      100%{ transform: translateY(-60px) scale(.8); opacity:0; }\n    }\n    @keyframes shake{\n      10%,90%{ transform: translateX(-1px); }\n      20%,80%{ transform: translateX(2px); }\n      30%,50%,70%{ transform: translateX(-4px); }\n      40%,60%{ transform: translateX(4px); }\n    }\n    @keyframes pulse{\n      0%{ box-shadow: 0 8px 22px rgba(6,182,212,0.06);}\n      50%{ box-shadow: 0 16px 36px rgba(6,182,212,0.12);}\n      100%{ box-shadow: 0 8px 22px rgba(6,182,212,0.06);}\n    }\n\n    /* small helpers */\n    .row{display:flex; gap:12px; align-items:center;}\n    .spacer{flex:1;}\n    .note{font-size:13px; color:var(--muted);}\n    .capacity-badge{\n      background:rgba(255,255,255,0.03);\n      padding:6px 8px;\n      border-radius:8px;\n      color:var(--muted);\n      font-weight:700;\n    }\n\n    /* footer small */\n    .meta{\n      font-size:13px;\n      color:var(--muted);\n      margin-top:8px;\n    }\n\n    /* ensure minimum spacing between interactive elements */\n    .controls > * { margin:0; }\n    .controls > * + * { margin-left: var(--gap); }\n    .controls-mini > * + * { margin-left: 12px; }\n\n    /* Accessibility focus outline for keyboard users */\n    :focus{ outline: none; }\n    button:focus-visible, input:focus-visible { outline: 3px solid rgba(6,182,212,0.12); border-radius:8px; }\n\n  </style>\n</head>\n<body>\n  <main class=\"container\" role=\"main\" aria-labelledby=\"module-title\">\n    <!-- LEFT PANEL: Concept, objective, interaction design, layout description, controls -->\n    <section class=\"panel\" aria-labelledby=\"module-title\">\n      <div class=\"title\">\n        <div>\n          <h1 id=\"module-title\">Stack — Last-In, First-Out (LIFO)</h1>\n          <div class=\"muted\">Interactive learning module</div>\n        </div>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"objective-label\">\n        <strong id=\"objective-label\">Learning objective</strong>\n        <p class=\"note\" style=\"margin-top:8px;\">\n          Understand how a stack stores items using LIFO behavior. After interacting, you will be able to:\n          push items onto the stack, pop and peek, observe index changes, and see underflow/overflow behavior.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"interaction-label\">\n        <strong id=\"interaction-label\">Interaction design</strong>\n        <p class=\"note\" style=\"margin-top:8px;\">\n          Interact with controls to push strings or numbers, pop the top item, peek, clear, or set capacity.\n          Visual animations show items sliding into the stack, popping out, and pointer updates. Errors (underflow/overflow)\n          cause a red shake and message. Keyboard accessible: Enter in the input performs push.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-labelledby=\"layout-label\">\n        <strong id=\"layout-label\">Layout description</strong>\n        <p class=\"note\" style=\"margin-top:8px;\">\n          This module keeps a clear two-column layout: controls and explanations on the left; visualization and logs on the right.\n          Safe margins are 24px; elements use at least 16px spacing. On smaller screens, the layout collapses to a single column\n          for readability and accessibility.\n        </p>\n      </div>\n\n      <div class=\"section\" style=\"margin-top:12px;\">\n        <label for=\"push-input\">Value to push (text allowed)</label>\n        <div class=\"controls\" role=\"group\" aria-label=\"Push controls\">\n          <input id=\"push-input\" type=\"text\" placeholder=\"e.g. 42 or 'apple'\" aria-label=\"Value to push\" />\n          <button id=\"push-btn\" class=\"btn\" aria-label=\"Push value\">Push</button>\n          <button id=\"pop-btn\" class=\"btn secondary\" aria-label=\"Pop top\">Pop</button>\n          <button id=\"peek-btn\" class=\"btn secondary\" aria-label=\"Peek top\">Peek</button>\n        </div>\n      </div>\n\n      <div class=\"section\" style=\"margin-top:12px;\">\n        <label for=\"capacity-range\">Capacity (max slots)</label>\n        <div class=\"row\" style=\"margin-top:6px;\">\n          <input id=\"capacity-range\" type=\"range\" min=\"1\" max=\"12\" value=\"8\" aria-label=\"Stack capacity\" />\n          <div class=\"capacity-badge\" id=\"capacity-badge\" aria-live=\"polite\">Capacity: 8</div>\n        </div>\n        <div class=\"row\" style=\"margin-top:12px;\">\n          <button id=\"auto-btn\" class=\"btn secondary\" aria-label=\"Auto-demo\">Auto demo</button>\n          <button id=\"clear-btn\" class=\"btn danger\" aria-label=\"Clear stack\">Clear</button>\n          <div class=\"spacer\"></div>\n          <div class=\"note\" aria-live=\"polite\" id=\"status\" style=\"min-width:160px;\"></div>\n        </div>\n      </div>\n\n      <div class=\"meta\" style=\"margin-top:14px;\">\n        Tips: Use the input + Enter to push quickly. Try capacity 3 and push more than 3 to see overflow.\n      </div>\n    </section>\n\n    <!-- RIGHT PANEL: Visualization & log -->\n    <section class=\"visual\" aria-label=\"Stack visualization area\">\n      <div class=\"vis-header\">\n        <div style=\"display:flex; flex-direction:column;\">\n          <div style=\"display:flex; gap:12px; align-items:center;\">\n            <div style=\"font-weight:700; font-size:18px;\">Visual Stack</div>\n            <div class=\"muted\" style=\"font-size:13px;\">LIFO — last item pushed is first popped</div>\n          </div>\n          <div class=\"note\" style=\"margin-top:6px;\">Slots show indexes (0 at bottom). The top pointer and index update as you push/pop.</div>\n        </div>\n\n        <div class=\"controls-mini\" aria-hidden=\"false\">\n          <div class=\"note\">Top =&nbsp;<span id=\"top-value\" class=\"capacity-badge\">-1</span></div>\n        </div>\n      </div>\n\n      <div class=\"stack-area\" aria-live=\"polite\">\n        <div class=\"stack-frame\" role=\"region\" aria-label=\"Stack frame\">\n          <div class=\"stack-outer\" id=\"stack-outer\">\n            <div style=\"display:flex; width:100%; gap:8px;\">\n              <div class=\"indices\" id=\"indices\" aria-hidden=\"true\"></div>\n              <div class=\"slots\" id=\"slots\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n            </div>\n            <div class=\"top-pointer\" id=\"top-pointer\" aria-hidden=\"true\">\n              <svg width=\"34\" height=\"18\" viewBox=\"0 0 34 18\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\">\n                <path d=\"M0 9h26\" stroke=\"rgba(255,255,255,0.06)\" stroke-width=\"1.6\" stroke-linecap=\"round\"/>\n                <path d=\"M18 0l16 9-16 9V0z\" fill=\"rgba(6,182,212,0.06)\"/>\n              </svg>\n              <div style=\"display:flex;flex-direction:column;\">\n                <div class=\"muted\" style=\"font-size:12px;\">Top index</div>\n                <div class=\"value\" id=\"top-index-display\">-1</div>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div style=\"flex:1; min-width:240px; display:flex; flex-direction:column; gap:12px;\">\n          <div style=\"flex:1; display:flex; flex-direction:column; gap:8px;\">\n            <div class=\"note\">Recent operations</div>\n            <div class=\"log\" id=\"log\" aria-live=\"polite\"></div>\n          </div>\n\n          <div style=\"display:flex; gap:12px; align-items:center; justify-content:flex-end;\">\n            <div class=\"note\">Stack size:&nbsp;<strong id=\"size-display\">0</strong></div>\n            <div class=\"note\">Capacity:&nbsp;<strong id=\"cap-display\">8</strong></div>\n          </div>\n        </div>\n      </div>\n    </section>\n  </main>\n\n  <script>\n    // Stack interactive module (vanilla JS)\n    (function(){\n      // State\n      let capacity = 8;\n      let stack = []; // bottom at index 0, top = stack.length - 1\n\n      // Controls\n      const pushInput = document.getElementById('push-input');\n      const pushBtn = document.getElementById('push-btn');\n      const popBtn = document.getElementById('pop-btn');\n      const peekBtn = document.getElementById('peek-btn');\n      const clearBtn = document.getElementById('clear-btn');\n      const autoBtn = document.getElementById('auto-btn');\n      const capacityRange = document.getElementById('capacity-range');\n      const capacityBadge = document.getElementById('capacity-badge');\n\n      // Visual elements\n      const slotsEl = document.getElementById('slots');\n      const indicesEl = document.getElementById('indices');\n      const logEl = document.getElementById('log');\n      const sizeDisplay = document.getElementById('size-display');\n      const capDisplay = document.getElementById('cap-display');\n      const topValue = document.getElementById('top-value');\n      const topIndexDisplay = document.getElementById('top-index-display');\n      const statusEl = document.getElementById('status');\n      const stackOuter = document.getElementById('stack-outer');\n\n      // Initialize UI\n      capacityRange.addEventListener('input', (e) => {\n        capacity = parseInt(e.target.value, 10);\n        capacityBadge.textContent = 'Capacity: ' + capacity;\n        capDisplay.textContent = capacity;\n        renderSlots();\n        announce('Capacity set to ' + capacity);\n      });\n\n      function announce(msg){\n        statusEl.textContent = msg;\n        setTimeout(()=>{ if(statusEl.textContent === msg) statusEl.textContent = ''; }, 2500);\n      }\n\n      function log(msg){\n        const p = document.createElement('div');\n        p.textContent = msg;\n        logEl.prepend(p);\n        // keep last 100 entries\n        while(logEl.childElementCount > 100) logEl.removeChild(logEl.lastChild);\n      }\n\n      function renderSlots(pulseIndex = null){\n        // Clear\n        slotsEl.innerHTML = '';\n        indicesEl.innerHTML = '';\n\n        // Render indices and slots (we always show full capacity)\n        for(let i = capacity - 1; i >= 0; i--){\n          // index label (displayed aligned)\n          const idx = document.createElement('div');\n          idx.textContent = i;\n          indicesEl.appendChild(idx);\n        }\n\n        for(let i = capacity - 1; i >= 0; i--){\n          const slot = document.createElement('div');\n          slot.className = 'slot empty';\n          // Determine if this slot is filled\n          if(i < stack.length){\n            const val = stack[i];\n            slot.classList.remove('empty');\n            slot.classList.add('filled');\n            slot.textContent = String(val);\n            slot.setAttribute('aria-label', 'Slot ' + i + ' value ' + String(val));\n          }else{\n            slot.textContent = 'empty';\n            slot.setAttribute('aria-label', 'Slot ' + i + ' empty');\n          }\n\n          // Mark top\n          if(i === stack.length - 1){\n            slot.classList.add('top');\n            slot.setAttribute('aria-current', 'true');\n            slot.title = 'Top of stack';\n          }\n\n          // pulse effect for peek or recent push\n          if(pulseIndex !== null && i === pulseIndex){\n            slot.classList.add('pulse');\n            setTimeout(()=>slot.classList.remove('pulse'), 900);\n          }\n\n          slotsEl.appendChild(slot);\n        }\n\n        // Top display values\n        const topIndex = stack.length - 1;\n        topValue.textContent = (topIndex >= 0) ? topIndex : -1;\n        topIndexDisplay.textContent = (topIndex >= 0) ? topIndex : -1;\n        sizeDisplay.textContent = stack.length;\n      }\n\n      function pushValue(value){\n        // Validate\n        if(stack.length >= capacity){\n          // overflow\n          indicateOverflow();\n          log('Overflow: attempted to push ' + value);\n          announce('Overflow — stack is full');\n          return false;\n        }\n        // Append to end (top)\n        stack.push(value);\n        log('Pushed: ' + value);\n        animatePush(stack.length - 1, value);\n        return true;\n      }\n\n      function popValue(){\n        if(stack.length === 0){\n          indicateUnderflow();\n          log('Underflow: attempted to pop');\n          announce('Underflow — stack is empty');\n          return null;\n        }\n        const val = stack.pop();\n        log('Popped: ' + val);\n        animatePop(stack.length, val); // popped index was new length\n        return val;\n      }\n\n      function peekValue(){\n        if(stack.length === 0){\n          indicateUnderflow();\n          log('Peek: stack empty');\n          announce('Stack is empty');\n          return null;\n        }\n        const topIdx = stack.length - 1;\n        log('Peek: ' + stack[topIdx]);\n        renderSlots(topIdx);\n        announce('Peeked value: ' + stack[topIdx]);\n        return stack[topIdx];\n      }\n\n      function clearStack(){\n        if(stack.length === 0){\n          announce('Stack already empty');\n          return;\n        }\n        stack = [];\n        renderSlots();\n        log('Cleared stack');\n        announce('Stack cleared');\n      }\n\n      // Visual feedback: overflow/underflow shake\n      function indicateOverflow(){\n        stackOuter.classList.add('shake');\n        stackOuter.style.borderColor = 'rgba(239,68,68,0.3)';\n        setTimeout(()=>{ stackOuter.classList.remove('shake'); stackOuter.style.borderColor = ''; }, 600);\n      }\n      function indicateUnderflow(){\n        stackOuter.classList.add('shake');\n        stackOuter.style.borderColor = 'rgba(239,68,68,0.3)';\n        setTimeout(()=>{ stackOuter.classList.remove('shake'); stackOuter.style.borderColor = ''; }, 600);\n      }\n\n      // Animations for push/pop\n      function animatePush(index, value){\n        // Re-render slots with the new data but animate the top element separately to show slide-in\n        renderSlots();\n        // find the corresponding slot element (slots are rendered top-down reverse order)\n        // slotsEl children are in order: bottom ... top? We used flex-direction: column-reverse so DOM order is bottom->top\n        // We rendered from capacity-1 down to 0, with column-reverse; simpler: find slot with top class\n        const slotEls = Array.from(slotsEl.querySelectorAll('.slot'));\n        const topSlot = slotEls.find(s => s.classList.contains('top'));\n        if(!topSlot) return;\n        topSlot.classList.add('animate-in');\n        setTimeout(()=> topSlot.classList.remove('animate-in'), 520);\n      }\n\n      function animatePop(index, value){\n        // index is the slot index that was removed (old top)\n        // Render first to show empty slot, then create a floating element that pops out for animation\n        renderSlots();\n        const floating = document.createElement('div');\n        floating.className = 'slot filled animate-pop';\n        floating.style.position = 'absolute';\n        floating.style.right = 'calc(50% + 10px)';\n        floating.style.top = '16px';\n        floating.style.width = '160px';\n        floating.style.height = '48px';\n        floating.style.borderRadius = '8px';\n        floating.style.display = 'flex';\n        floating.style.alignItems = 'center';\n        floating.style.justifyContent = 'center';\n        floating.style.background = 'linear-gradient(180deg,#a9f0f6,#6ee4ec)';\n        floating.style.fontWeight = '700';\n        floating.style.color = '#06121a';\n        floating.textContent = String(value);\n        floating.style.zIndex = 60;\n        stackOuter.appendChild(floating);\n        setTimeout(()=> {\n          floating.remove();\n        }, 320);\n      }\n\n      // Event wiring\n      pushBtn.addEventListener('click', () => {\n        const value = pushInput.value.trim();\n        if(value === ''){\n          announce('Enter a value to push');\n          return;\n        }\n        pushValue(value);\n        pushInput.value = '';\n        pushInput.focus();\n      });\n\n      popBtn.addEventListener('click', () => {\n        const val = popValue();\n        if(val !== null){\n          announce('Popped: ' + val);\n        }\n      });\n\n      peekBtn.addEventListener('click', () => {\n        const val = peekValue();\n        if(val !== null){\n          // visual highlight already applied in peekValue()\n        }\n      });\n\n      clearBtn.addEventListener('click', () => {\n        clearStack();\n      });\n\n      autoBtn.addEventListener('click', () => {\n        runAutoDemo();\n      });\n\n      // Keyboard: Enter to push\n      pushInput.addEventListener('keydown', (e) => {\n        if(e.key === 'Enter'){\n          pushBtn.click();\n          e.preventDefault();\n        }\n      });\n\n      // Auto demo: pushes several values with delay, then pops some\n      async function runAutoDemo(){\n        announce('Auto demo started');\n        autoBtn.disabled = true;\n        const sample = ['A','B','C','D','E','F','G','H','I'];\n        for(let i=0;i<5;i++){\n          if(stack.length < capacity) {\n            pushValue(sample[i % sample.length]);\n            await sleep(450);\n          } else {\n            indicateOverflow();\n            await sleep(450);\n            break;\n          }\n        }\n        await sleep(700);\n        for(let i=0;i<3;i++){\n          if(stack.length > 0){\n            popValue();\n            await sleep(420);\n          } else {\n            indicateUnderflow();\n            await sleep(400);\n            break;\n          }\n        }\n        announce('Auto demo finished');\n        autoBtn.disabled = false;\n      }\n\n      function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }\n\n      // Initialize default render\n      capacityRange.value = capacity;\n      capacityBadge.textContent = 'Capacity: ' + capacity;\n      capDisplay.textContent = capacity;\n      renderSlots();\n\n      // Accessibility: announce initial state\n      log('Module ready. Capacity: ' + capacity);\n      announce('Stack ready with capacity ' + capacity);\n\n      // Expose nothing to global scope\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Stack.\n\n**Project Overview:**\nTopic: Stack\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Stack"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Stack Module",
      "description": "Finite state machine modeling the interactive stack visualization application (push, pop, peek, capacity changes, auto-demo and visual/error animations).",
      "states": [
        {
          "name": "ready",
          "onEnter": "renderSlots / update UI",
          "on": {
            "PUSH_REQUEST": "pushing",
            "PUSH_REQUEST_EMPTY": "ready",
            "PUSH_REQUEST_OVERFLOW": "overflow",
            "POP_REQUEST": "popping",
            "POP_REQUEST_UNDERFLOW": "underflow",
            "PEEK_REQUEST": "peeking",
            "PEEK_REQUEST_UNDERFLOW": "underflow",
            "CLEAR_REQUEST": "clearing",
            "CAPACITY_CHANGE": "capacity_changing",
            "AUTO_START": "auto_demo"
          }
        },
        {
          "name": "pushing",
          "onEnter": "pushValue(value) -> (internal: validate capacity, update stack, log, renderSlots) then animatePush(topIndex)",
          "onExit": "remove push animation class (animate-in) if any",
          "on": {
            "ANIMATION_END_PUSH": "ready",
            "PUSH_OVERFLOW": "overflow"
          }
        },
        {
          "name": "popping",
          "onEnter": "popValue() -> (validate non-empty, update stack, log) then animatePop(poppedIndex, value)",
          "onExit": "remove floating element (handled by animation timeout)",
          "on": {
            "ANIMATION_END_POP": "ready",
            "POP_UNDERFLOW": "underflow"
          }
        },
        {
          "name": "peeking",
          "onEnter": "peekValue() -> (if non-empty: renderSlots(pulseIndex = top), log, announce)",
          "onExit": "remove pulse class after timeout (renderSlots sets timeout ~900ms)",
          "on": {
            "PEEK_ANIMATION_END": "ready",
            "PEEK_UNDERFLOW": "underflow"
          }
        },
        {
          "name": "clearing",
          "onEnter": "clearStack() -> (stack=[], renderSlots, log, announce)",
          "on": {
            "CLEARED": "ready"
          }
        },
        {
          "name": "capacity_changing",
          "onEnter": "set capacity, capacityBadge.textContent, capDisplay.textContent, renderSlots(), announce('Capacity set to X')",
          "on": {
            "CAPACITY_APPLIED": "ready"
          }
        },
        {
          "name": "overflow",
          "onEnter": "indicateOverflow() -> (add 'shake' class, set border color, log overflow, announce), keep visual shake for ~600ms",
          "onExit": "remove 'shake' class and clear border color (timeout clears after ~600ms)",
          "on": {
            "ERROR_ANIM_END": "ready"
          }
        },
        {
          "name": "underflow",
          "onEnter": "indicateUnderflow() -> (add 'shake' class, set border color, log underflow/peek empty, announce), keep visual shake for ~600ms",
          "onExit": "remove 'shake' class and clear border color (timeout clears after ~600ms)",
          "on": {
            "ERROR_ANIM_END": "ready"
          }
        },
        {
          "name": "auto_demo",
          "onEnter": "runAutoDemo() -> (disable autoBtn, perform scheduled pushes/pops with delays, internal pushes/pops trigger pushing/popping behaviors or their inline logic, handle overflow/underflow during demo, re-enable autoBtn, announce finished)",
          "onExit": "autoBtn.disabled = false",
          "on": {
            "AUTO_FINISHED": "ready",
            "AUTO_INTERRUPTED": "ready"
          }
        }
      ],
      "events": [
        "PUSH_REQUEST",
        "PUSH_REQUEST_EMPTY",
        "PUSH_REQUEST_OVERFLOW",
        "POP_REQUEST",
        "POP_REQUEST_UNDERFLOW",
        "PEEK_REQUEST",
        "PEEK_REQUEST_UNDERFLOW",
        "CLEAR_REQUEST",
        "CAPACITY_CHANGE",
        "AUTO_START",
        "ANIMATION_END_PUSH",
        "ANIMATION_END_POP",
        "PEEK_ANIMATION_END",
        "ERROR_ANIM_END",
        "CAPACITY_APPLIED",
        "CLEARED",
        "AUTO_FINISHED",
        "AUTO_INTERRUPTED",
        "PUSH_OVERFLOW",
        "POP_UNDERFLOW"
      ],
      "notes": "State timings and animation durations are implemented with timeouts in the code: push animate-in removed after ~520ms (ANIMATION_END_PUSH), pop floating element removed after ~320ms (ANIMATION_END_POP), peek pulse removed after ~900ms (PEEK_ANIMATION_END), shake (overflow/underflow) lasts ~600ms (ERROR_ANIM_END). Capacity changes are immediate (CAPACITY_CHANGE -> capacity_changing -> CAPACITY_APPLIED). Auto-demo runs asynchronously (AUTO_START -> auto_demo -> AUTO_FINISHED) and internally issues push/pop operations; the auto-demo disables only the auto button but other controls remain actionable in the implementation. Events like PUSH_REQUEST carry a payload 'value' in the real app; validation (empty string or capacity full) determines transitions to PUSH_REQUEST_EMPTY or PUSH_REQUEST_OVERFLOW which lead to no-op or overflow error states respectively."
    }
  },
  {
    "id": "077c88c0-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:27:47.936Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Queue",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Queue Explorer</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --accent: #06b6d4;\n      --muted: #94a3b8;\n      --success: #10b981;\n      --danger: #ef4444;\n      --surface: #0b1220;\n      --item-bg: linear-gradient(180deg,#073043 0%, #042837 100%);\n      --max-width: 1100px;\n      --radius: 10px;\n      --transition: 300ms cubic-bezier(.2,.9,.2,1);\n    }\n\n    /* Page layout and safe area */\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(160deg,#021024 0%, #07142a 60%);\n      color: #e6eef6;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app {\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height: 100vh;\n      display:flex;\n      align-items:flex-start;\n      justify-content:center;\n    }\n    .container {\n      width:100%;\n      max-width: var(--max-width);\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: calc(var(--radius) + 4px);\n      padding: 20px;\n      box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n      box-sizing:border-box;\n    }\n\n    /* Top header */\n    .header {\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      margin-bottom: var(--gap);\n    }\n    .title {\n      display:flex;\n      align-items:center;\n      gap:12px;\n    }\n    .title h1 {\n      font-size:1.25rem;\n      margin:0;\n      color: #eaf7fb;\n    }\n    .subtitle {\n      color:var(--muted);\n      font-size:0.92rem;\n      margin:0;\n    }\n\n    /* Grid layout for interactive module */\n    .grid {\n      display:grid;\n      grid-template-columns: 1fr 400px;\n      gap: var(--gap);\n    }\n\n    /* Make responsive */\n    @media (max-width:880px){\n      .grid {\n        grid-template-columns: 1fr;\n      }\n      .panel-controls {\n        order: 2;\n      }\n    }\n\n    /* Left panel: visualization */\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.0));\n      padding: 18px;\n      border-radius: var(--radius);\n      min-height: 260px;\n    }\n    .panel h2{\n      margin:0 0 8px 0;\n      font-size: 1rem;\n      color:#dff8ff;\n    }\n    .panel p {\n      margin:0 0 12px 0;\n      color:var(--muted);\n      font-size:0.92rem;\n    }\n\n    /* Visualization area */\n    .vis {\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      align-items:center;\n      justify-content:center;\n      padding:12px;\n    }\n    .queue-viewport {\n      width:100%;\n      min-height:120px;\n      background: linear-gradient(180deg, rgba(6,12,19,0.6), rgba(2,6,12,0.4));\n      border-radius: 10px;\n      padding: 18px;\n      box-sizing:border-box;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      position:relative;\n      overflow:hidden;\n      border: 1px solid rgba(255,255,255,0.03);\n    }\n\n    /* Visual queue track */\n    .queue-track {\n      display:flex;\n      gap:12px;\n      align-items:center;\n      transition: transform var(--transition);\n      will-change: transform;\n      padding: 8px;\n      min-width: 320px;\n      max-width: 100%;\n    }\n\n    /* Item cards */\n    .queue-item {\n      min-width: 84px;\n      max-width: 140px;\n      padding:10px 12px;\n      background: var(--item-bg);\n      border-radius: 8px;\n      color: #e6faff;\n      box-shadow: 0 6px 18px rgba(3,8,12,0.6);\n      border: 1px solid rgba(255,255,255,0.04);\n      display:flex;\n      flex-direction:column;\n      align-items:center;\n      gap:6px;\n      transform-origin: center;\n      transition: transform var(--transition), opacity var(--transition);\n    }\n    .queue-item .value {\n      font-weight:600;\n      font-size:1rem;\n      word-break:break-word;\n      text-align:center;\n    }\n    .queue-item .meta {\n      font-size:0.78rem;\n      color: var(--muted);\n    }\n\n    /* Labels for head/tail */\n    .label {\n      position:absolute;\n      top:8px;\n      font-size:0.72rem;\n      color:var(--muted);\n      padding:6px 8px;\n      border-radius:6px;\n      background: rgba(255,255,255,0.02);\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .label.head { left:12px; }\n    .label.tail { right:12px; }\n\n    /* Animations */\n    .enter {\n      transform: translateX(24px) scale(0.98);\n      opacity: 0;\n      animation: enterAnim var(--transition) forwards;\n    }\n    @keyframes enterAnim {\n      to { transform: translateX(0) scale(1); opacity:1; }\n    }\n    .exit {\n      animation: exitAnim var(--transition) forwards;\n    }\n    @keyframes exitAnim {\n      to { transform: translateX(-36px) scale(.9); opacity:0; }\n    }\n\n    /* Controls panel */\n    .panel-controls {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      padding: 18px;\n      border-radius: var(--radius);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      min-height:260px;\n    }\n    .controls-row {\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .input {\n      display:flex;\n      gap:8px;\n      align-items:center;\n      width:100%;\n    }\n    input[type=\"text\"]{\n      flex:1;\n      min-width: 120px;\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.04);\n      background: rgba(255,255,255,0.02);\n      color: #e6faff;\n      font-size:0.96rem;\n    }\n    input[type=\"text\"]::placeholder { color: #89a3b5; }\n    button {\n      padding:10px 12px;\n      border-radius:8px;\n      border: none;\n      cursor:pointer;\n      font-weight:600;\n      color:#041022;\n      background: var(--accent);\n      transition: transform 150ms ease, box-shadow 150ms ease;\n      min-width:90px;\n    }\n    button.secondary {\n      background: rgba(255,255,255,0.03);\n      color: #dff8ff;\n      border: 1px solid rgba(255,255,255,0.03);\n    }\n    button.danger {\n      background: var(--danger);\n      color: #fff;\n    }\n    button:active { transform: translateY(1px) scale(.998); }\n    button:focus { outline: 3px solid rgba(6,182,212,0.12); }\n\n    .info {\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .stat {\n      background: rgba(255,255,255,0.02);\n      padding:8px 10px;\n      border-radius:8px;\n      font-size:0.9rem;\n      color:var(--muted);\n      min-width:82px;\n      text-align:center;\n    }\n    .muted {\n      color:var(--muted);\n      font-size:0.9rem;\n    }\n\n    /* Small helper */\n    .notes {\n      color:var(--muted);\n      font-size:0.86rem;\n      margin-top:6px;\n    }\n\n    /* Accessibility focus ring for items */\n    .queue-item:focus {\n      outline: 3px solid rgba(6,182,212,0.12);\n    }\n\n    /* Live region visually hidden but accessible */\n    .visually-hidden {\n      position: absolute !important;\n      height: 1px; width: 1px;\n      overflow: hidden;\n      clip: rect(1px, 1px, 1px, 1px);\n      white-space: nowrap;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-labelledby=\"module-title\">\n    <div class=\"container\">\n      <header class=\"header\" aria-hidden=\"false\">\n        <div class=\"title\">\n          <h1 id=\"module-title\">Queue — FIFO Data Structure (Interactive Explorer)</h1>\n        </div>\n        <p class=\"subtitle\">Hands-on visualization of enqueue, dequeue, peek, and capacity. Keyboard accessible and animated.</p>\n      </header>\n\n      <div class=\"grid\">\n        <!-- LEFT: Visualization + Explanation -->\n        <section class=\"panel\" aria-labelledby=\"concept-heading\">\n          <h2 id=\"concept-heading\">Concept & Learning Goals</h2>\n          <p><strong>Concept:</strong> A Queue stores elements in FIFO (First-In, First-Out) order — elements are enqueued at the tail and removed (dequeued) from the head.</p>\n          <p><strong>Learning Objective:</strong> After using this module you should be able to:\n            <ul style=\"margin:6px 0 0 18px; color:var(--muted); font-size:0.92rem;\">\n              <li>Understand enqueue (add to tail) and dequeue (remove from head).</li>\n              <li>Observe how head and tail move as elements change.</li>\n              <li>See and feel the order-preserving nature of FIFO through animation.</li>\n            </ul>\n          </p>\n\n          <div class=\"vis\" aria-live=\"polite\">\n            <div class=\"queue-viewport\" role=\"region\" aria-label=\"Queue visualization area\">\n              <div class=\"label head\" id=\"head-label\">Head</div>\n              <div class=\"label tail\" id=\"tail-label\">Tail</div>\n\n              <div class=\"queue-track\" id=\"queueTrack\" role=\"list\" aria-labelledby=\"concept-heading\" tabindex=\"0\">\n                <!-- Items inserted dynamically -->\n              </div>\n            </div>\n\n            <div class=\"notes\" id=\"layoutDesc\">\n              Interaction: Type a value, press \"Enqueue\" (or Enter) to add. Press \"Dequeue\" to remove the head. The head slides out and the rest shift forward.\n            </div>\n          </div>\n        </section>\n\n        <!-- RIGHT: Controls -->\n        <aside class=\"panel-controls\" aria-labelledby=\"controls-heading\">\n          <h2 id=\"controls-heading\">Interactive Controls</h2>\n\n          <div class=\"input\" role=\"form\" aria-label=\"Queue controls\">\n            <input id=\"valueInput\" type=\"text\" placeholder=\"Enter value (text or number)\" aria-label=\"Value to enqueue\" />\n            <button id=\"enqueueBtn\" title=\"Enqueue (Add to tail)\">Enqueue</button>\n          </div>\n\n          <div class=\"controls-row\" style=\"margin-top:4px;\">\n            <button id=\"dequeueBtn\" class=\"secondary\" title=\"Dequeue (Remove from head)\">Dequeue</button>\n            <button id=\"peekBtn\" class=\"secondary\" title=\"Show head value\">Peek</button>\n            <button id=\"clearBtn\" class=\"danger\" title=\"Clear queue\">Clear</button>\n          </div>\n\n          <div style=\"display:flex; gap:var(--gap); align-items:center; justify-content:space-between; margin-top:8px;\">\n            <div class=\"info\" aria-hidden=\"false\">\n              <div class=\"stat\" id=\"sizeStat\" aria-live=\"polite\">Size: 0</div>\n              <div class=\"stat\" id=\"capStat\" aria-live=\"polite\">Capacity: 8</div>\n            </div>\n\n            <div style=\"text-align:right;\">\n              <label for=\"speedRange\" style=\"display:block; font-size:0.82rem; color:var(--muted);\">Animation speed</label>\n              <input id=\"speedRange\" type=\"range\" min=\"100\" max=\"800\" step=\"50\" value=\"300\" aria-label=\"Animation speed in milliseconds\" />\n            </div>\n          </div>\n\n          <div style=\"margin-top:6px;\" class=\"muted\">\n            Tips:\n            <ul style=\"margin:6px 0 0 18px;\">\n              <li>Press Enter in the input to enqueue quickly.</li>\n              <li>Items are read from left-to-right: leftmost is the head.</li>\n            </ul>\n          </div>\n\n          <div style=\"margin-top:8px;\" aria-live=\"polite\" id=\"message\" class=\"muted\">Ready.</div>\n          <div id=\"sr-live\" class=\"visually-hidden\" aria-live=\"assertive\" aria-atomic=\"true\"></div>\n        </aside>\n      </div>\n\n      <!-- Below: Interaction Design & Layout Description as required by brief (visible to user) -->\n      <section style=\"margin-top:var(--gap); background: rgba(255,255,255,0.01); padding:14px; border-radius:8px;\">\n        <h3 style=\"margin:0 0 8px 0;\">Interaction Design (what happens & why it helps)</h3>\n        <p style=\"margin:0 0 8px 0; color:var(--muted);\">\n          - Enqueue: creating an element at the tail animates it sliding into the track. This visualizes adding to the back of the queue.\n        </p>\n        <p style=\"margin:0 0 8px 0; color:var(--muted);\">\n          - Dequeue: the head item animates sliding out to the left and fades; then the remaining items visually shift forward. This demonstrates FIFO removal and how head/tail positions update.\n        </p>\n        <p style=\"margin:0 0 8px 0; color:var(--muted);\">\n          Controls are keyboard-accessible (Enter in the input enqueues). An ARIA live region announces actions for screen-reader users. The animation speed control lets you slow down or speed up to inspect each transition.\n        </p>\n\n        <h3 style=\"margin-top:12px;\">Layout Description</h3>\n        <p style=\"margin:0; color:var(--muted);\">\n          Spatial organization:\n          <ul style=\"margin:8px 0 0 18px;\">\n            <li>Top: Title and short description.</li>\n            <li>Left (main): Visualization panel with queue track, head & tail labels, and notes.</li>\n            <li>Right (controls): Inputs and buttons — arranged vertically for quick reach. Buttons are at least 16px apart and the overall container maintains 24px safe margins.</li>\n          </ul>\n          The design adapts: on narrow viewports the controls stack below the visualization. Minimum spacing between interactive elements is 16px and focus rings and ARIA labels ensure accessibility.\n        </p>\n      </section>\n    </div>\n  </div>\n\n  <script>\n    (function () {\n      // Configuration\n      let capacity = 8;\n      let animationMs = 300; // will be synced with slider\n      const queueTrack = document.getElementById('queueTrack');\n      const enqueueBtn = document.getElementById('enqueueBtn');\n      const dequeueBtn = document.getElementById('dequeueBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const peekBtn = document.getElementById('peekBtn');\n      const valueInput = document.getElementById('valueInput');\n      const sizeStat = document.getElementById('sizeStat');\n      const capStat = document.getElementById('capStat');\n      const message = document.getElementById('message');\n      const srLive = document.getElementById('sr-live');\n      const speedRange = document.getElementById('speedRange');\n\n      // Internal queue is represented in DOM order left-to-right.\n      // Keep an integer counter for IDs so multiple identical values are distinct elements.\n      let idCounter = 0;\n\n      function setMessage(text, srText = null) {\n        message.textContent = text;\n        if (srText === null) srText = text;\n        srLive.textContent = srText;\n      }\n\n      function updateStats() {\n        const size = queueTrack.children.length;\n        sizeStat.textContent = 'Size: ' + size;\n        capStat.textContent = 'Capacity: ' + capacity;\n        // Head and tail labels visibility\n        document.getElementById('head-label').style.display = size ? 'block' : 'none';\n        document.getElementById('tail-label').style.display = size ? 'block' : 'none';\n      }\n\n      // Create a queue item element\n      function createItem(value) {\n        const div = document.createElement('div');\n        div.className = 'queue-item enter';\n        div.setAttribute('role','listitem');\n        div.setAttribute('tabindex','0');\n        div.dataset.itemId = ++idCounter;\n\n        const val = document.createElement('div');\n        val.className = 'value';\n        val.textContent = String(value);\n\n        const meta = document.createElement('div');\n        meta.className = 'meta';\n        meta.textContent = 'enqueued';\n\n        div.appendChild(val);\n        div.appendChild(meta);\n\n        // Keyboard interaction for an item: allow inspecting its position\n        div.addEventListener('keydown', (e) => {\n          if (e.key === 'Enter' || e.key === ' ') {\n            const idx = Array.prototype.indexOf.call(queueTrack.children, div);\n            setMessage(`Item \"${val.textContent}\" is at position ${idx + 1} (head=1).`);\n            e.preventDefault();\n          }\n        });\n\n        return div;\n      }\n\n      // Enqueue operation\n      function enqueue(value) {\n        const size = queueTrack.children.length;\n        if (size >= capacity) {\n          setMessage('Queue is full. Cannot enqueue.', 'Queue is full.');\n          return;\n        }\n        const item = createItem(value);\n        item.style.transitionDuration = animationMs + 'ms';\n        queueTrack.appendChild(item);\n\n        // Force reflow & remove 'enter' class so animation plays\n        requestAnimationFrame(() => {\n          item.classList.remove('enter');\n        });\n\n        updateStats();\n        setMessage(`Enqueued \"${value}\".`);\n      }\n\n      // Dequeue operation\n      function dequeue() {\n        const first = queueTrack.firstElementChild;\n        if (!first) {\n          setMessage('Queue is empty. Nothing to dequeue.', 'Queue is empty.');\n          return;\n        }\n        // mark as exiting and announce\n        first.classList.add('exit');\n        first.style.transitionDuration = animationMs + 'ms';\n        const value = first.querySelector('.value').textContent;\n        setMessage(`Dequeuing \"${value}\"...`);\n        srLive.textContent = `Dequeued ${value}`;\n\n        // Remove after animation\n        setTimeout(() => {\n          if (first && first.parentNode === queueTrack) {\n            queueTrack.removeChild(first);\n            updateStats();\n            setMessage(`Dequeued \"${value}\".`);\n          }\n        }, animationMs + 20);\n      }\n\n      // Peek operation (show head value)\n      function peek() {\n        const first = queueTrack.firstElementChild;\n        if (!first) {\n          setMessage('Queue is empty (peek).', 'Queue is empty.');\n          return;\n        }\n        const value = first.querySelector('.value').textContent;\n        setMessage(`Peek: head is \"${value}\".`, `Head is ${value}`);\n      }\n\n      // Clear queue\n      function clearQueue() {\n        const items = Array.from(queueTrack.children);\n        if (items.length === 0) {\n          setMessage('Queue already empty.');\n          return;\n        }\n        // animate exit for each\n        items.forEach((it, idx) => {\n          setTimeout(() => {\n            it.classList.add('exit');\n            it.style.transitionDuration = (animationMs * 0.8) + 'ms';\n          }, idx * 40);\n        });\n        // remove all after a short delay\n        setTimeout(() => {\n          queueTrack.innerHTML = '';\n          updateStats();\n          setMessage('Cleared queue.');\n        }, animationMs + items.length * 40 + 20);\n      }\n\n      // Wire up buttons & input\n      enqueueBtn.addEventListener('click', () => {\n        const v = valueInput.value.trim();\n        if (v === '') {\n          setMessage('Please enter a value to enqueue.');\n          valueInput.focus();\n          return;\n        }\n        enqueue(v);\n        valueInput.value = '';\n        valueInput.focus();\n      });\n\n      dequeueBtn.addEventListener('click', () => dequeue());\n      peekBtn.addEventListener('click', () => peek());\n      clearBtn.addEventListener('click', () => clearQueue());\n\n      // Enter key in input enqueues\n      valueInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          e.preventDefault();\n          enqueueBtn.click();\n        }\n      });\n\n      // Speed slider adjusts animation duration\n      speedRange.addEventListener('input', (e) => {\n        animationMs = Number(e.target.value);\n        document.documentElement.style.setProperty('--transition', `${animationMs}ms cubic-bezier(.2,.9,.2,1)`);\n        setMessage(`Animation speed: ${animationMs} ms`);\n      });\n\n      // Example initial items (demonstrative)\n      function seedExample() {\n        const examples = ['A', 'B', 'C'];\n        examples.forEach((v, i) => {\n          setTimeout(() => {\n            enqueue(v);\n          }, 200 + i * 160);\n        });\n      }\n\n      // Expose ARIA friendly keyboard shortcuts for the buttons\n      document.addEventListener('keydown', (e) => {\n        // ctrl+e => enqueue focus, ctrl+d => dequeue\n        if (e.ctrlKey && !e.shiftKey && !e.altKey) {\n          if (e.key.toLowerCase() === 'e') {\n            valueInput.focus();\n            setMessage('Focused input. Type then press Enter to enqueue.');\n            e.preventDefault();\n          } else if (e.key.toLowerCase() === 'd') {\n            dequeue();\n            e.preventDefault();\n          } else if (e.key.toLowerCase() === 'p') {\n            peek();\n            e.preventDefault();\n          } else if (e.key.toLowerCase() === 'c') {\n            clearQueue();\n            e.preventDefault();\n          }\n        }\n      });\n\n      // Initialize UI\n      capStat.textContent = 'Capacity: ' + capacity;\n      updateStats();\n      setMessage('Ready. Tip: press Ctrl+E to focus input, Enter to enqueue.');\n\n      // Seed example items so users see animation immediately\n      seedExample();\n\n      // Ensure responsiveness: allow horizontal scroll on small screens\n      queueTrack.style.overflowX = 'auto';\n      queueTrack.style.webkitOverflowScrolling = 'touch';\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Queue.\n\n**Project Overview:**\nTopic: Queue\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Queue"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Queue Explorer",
      "description": "Models the interactive states and transitions for a FIFO queue visualization app (enqueue, dequeue, peek, clear, animation & UI interactions).",
      "states": [
        {
          "name": "initializing",
          "onEnter": "seedExample; updateStats; setMessage('Ready. Tip: press Ctrl+E to focus input, Enter to enqueue.')",
          "on": {
            "SEED_DONE": "idle"
          }
        },
        {
          "name": "idle",
          "onEnter": "updateStats",
          "onExit": "",
          "on": {
            "CLICK_ENQUEUE_EMPTY": "idle",
            "CLICK_ENQUEUE_FULL": "idle",
            "CLICK_ENQUEUE_VALID": "enqueueing",
            "INPUT_ENTER_EMPTY": "idle",
            "INPUT_ENTER_VALID": "enqueueing",
            "CLICK_DEQUEUE_EMPTY": "idle",
            "CLICK_DEQUEUE": "dequeuing",
            "CLICK_PEEK_EMPTY": "idle",
            "CLICK_PEEK": "peeking",
            "CLICK_CLEAR_EMPTY": "idle",
            "CLICK_CLEAR": "clearing",
            "SPEED_CHANGE": "idle",
            "CTRL_E": "focusInput",
            "CTRL_D": "dequeuing",
            "CTRL_P": "peeking",
            "CTRL_C": "clearing",
            "ITEM_ACTIVATE": "itemInspect"
          }
        },
        {
          "name": "enqueueing",
          "onEnter": "createItem(value); setTransitionDuration(item, animationMs); appendItemToTrack(item); requestAnimationFrame(removeEnterClass(item)); updateStats; setMessage(`Enqueued \"${value}\".`)",
          "onExit": "",
          "on": {
            "ENQUEUE_ANIM_DONE": "idle"
          }
        },
        {
          "name": "dequeuing",
          "onEnter": "addExitClass(firstItem); setTransitionDuration(firstItem, animationMs); setMessage(`Dequeuing \"${value}\"...`); srLiveUpdate(`Dequeued ${value}`); startTimeout(removeFirstAfter(animationMs+20))",
          "onExit": "removeFirstFromDOM; updateStats; setMessage(`Dequeued \"${value}\".`)",
          "on": {
            "DEQUEUE_ANIM_DONE": "idle"
          }
        },
        {
          "name": "clearing",
          "onEnter": "forEachItem(staggerAddExitClass(item, idx*40)); setMessage('Clearing queue.'); startTimeout(clearTrackAfter(animationMs + items.length*40 + 20))",
          "onExit": "clearTrack; updateStats; setMessage('Cleared queue.')",
          "on": {
            "CLEAR_ANIM_DONE": "idle"
          }
        },
        {
          "name": "peeking",
          "onEnter": "announceHeadValue(headValue); setMessage(`Peek: head is \"${headValue}\".`); srLiveUpdate(`Head is ${headValue}`)",
          "onExit": "",
          "on": {
            "PEEK_DONE": "idle"
          }
        },
        {
          "name": "focusInput",
          "onEnter": "focusValueInput(); setMessage('Focused input. Type then press Enter to enqueue.')",
          "onExit": "",
          "on": {
            "FOCUS_DONE": "idle"
          }
        },
        {
          "name": "itemInspect",
          "onEnter": "announceItemPosition(index, label); setMessage(`Item \"${value}\" is at position ${index+1} (head=1).`)",
          "onExit": "",
          "on": {
            "INSPECT_DONE": "idle"
          }
        }
      ],
      "events": [
        "SEED_START",
        "SEED_DONE",
        "CLICK_ENQUEUE",
        "INPUT_ENTER",
        "CLICK_ENQUEUE_EMPTY",
        "INPUT_ENTER_EMPTY",
        "CLICK_ENQUEUE_FULL",
        "CLICK_ENQUEUE_VALID",
        "INPUT_ENTER_VALID",
        "ENQUEUE_ANIM_DONE",
        "CLICK_DEQUEUE",
        "CLICK_DEQUEUE_EMPTY",
        "DEQUEUE_ANIM_DONE",
        "CLICK_PEEK",
        "CLICK_PEEK_EMPTY",
        "PEEK_DONE",
        "CLICK_CLEAR",
        "CLICK_CLEAR_EMPTY",
        "CLEAR_ANIM_DONE",
        "SPEED_CHANGE",
        "CTRL_E",
        "CTRL_D",
        "CTRL_P",
        "CTRL_C",
        "ITEM_ACTIVATE",
        "INSPECT_DONE"
      ],
      "notes": "This FSM models the primary interactive flows in the application. Many transitions are guarded by runtime checks (input empty, queue full, queue empty). Validation occurs in the event handlers before raising the definitive event (e.g., CLICK_ENQUEUE leads to either CLICK_ENQUEUE_EMPTY, CLICK_ENQUEUE_FULL, or CLICK_ENQUEUE_VALID). Animation-driven transitions are asynchronous: ENQUEUE_ANIM_DONE, DEQUEUE_ANIM_DONE and CLEAR_ANIM_DONE are raised after timeouts based on animationMs. Actions referenced in onEnter/onExit correspond to functions or sequences in the source: setMessage (updates UI message and sr-live), srLiveUpdate (updates screen-reader live region), createItem / appendItemToTrack, addExitClass, setTransitionDuration, removeFirstFromDOM / clearTrack, updateStats, seedExample, focusValueInput, and updateAnimationMs (on SPEED_CHANGE). The app stays conceptually in 'idle' between interactions; animation states (enqueueing, dequeuing, clearing) are transient and return to idle when their respective animations complete. Error/reporting outcomes (queue full / empty / empty-input) are treated as transitions that keep the app in idle while producing messages."
    }
  },
  {
    "id": "1f4cb9c0-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:28:01.073Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Set",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Set — Interactive Exploration</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --card-width: 120px;\n      --card-aspect: 1.5;\n      --bg: #fbfbfd;\n      --panel: #ffffff;\n      --muted: #6b6f76;\n      --accent: #1f6feb;\n      --success: #2ea44f;\n      --danger: #d73a49;\n      --shadow: 0 6px 18px rgba(18, 22, 26, 0.08);\n    }\n\n    /* Page safe margins */\n    html,body{\n      height:100%;\n      margin:0;\n      padding:0;\n      background:linear-gradient(180deg,#f6f8fb 0%, var(--bg) 100%);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      color:#0f1724;\n    }\n    .container{\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height:100vh;\n      display:flex;\n      flex-direction:column;\n      gap: var(--gap);\n      align-items:stretch;\n    }\n\n    header{\n      display:flex;\n      gap: var(--gap);\n      align-items:flex-start;\n      flex-wrap:wrap;\n    }\n    .title{\n      background:var(--panel);\n      padding:16px;\n      border-radius:10px;\n      box-shadow:var(--shadow);\n      flex:1 1 360px;\n      min-width:260px;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    .title h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:-0.2px;\n    }\n    .small{\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.3;\n    }\n\n    .controls{\n      display:flex;\n      gap: var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .controls .panel{\n      background:var(--panel);\n      padding:12px;\n      border-radius:10px;\n      box-shadow:var(--shadow);\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    button{\n      background:linear-gradient(180deg,#fff,#f2f5fb);\n      border:1px solid #e3e8ef;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      color:#0f1724;\n      box-shadow: 0 1px 0 rgba(255,255,255,0.6) inset;\n    }\n    button.primary{\n      background:linear-gradient(180deg,var(--accent), #155ec2);\n      color:white;\n      border:none;\n      box-shadow: 0 6px 14px rgba(31,110,235,0.18);\n    }\n    button.ghost{\n      background:transparent;\n      border:1px dashed #dfe6f3;\n      color:var(--muted);\n      font-weight:600;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    main{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      flex-wrap:wrap;\n    }\n\n    /* Left: board area */\n    .board-panel{\n      background:var(--panel);\n      padding:var(--gap);\n      border-radius:12px;\n      box-shadow:var(--shadow);\n      flex: 1 1 640px;\n      min-width:320px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      align-items:stretch;\n    }\n    .board-header{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:12px;\n    }\n    .board-grid{\n      display:grid;\n      gap:16px;\n      justify-content:center;\n      align-content:start;\n      grid-template-columns: repeat(auto-fill, minmax(var(--card-width), 1fr));\n      /* ensure spacing with min-card width */\n    }\n\n    /* Card */\n    .card{\n      width:var(--card-width);\n      aspect-ratio: var(--card-aspect);\n      background:white;\n      border-radius:10px;\n      border:2px solid transparent;\n      padding:10px;\n      box-sizing:border-box;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      transition:transform 180ms ease, box-shadow 180ms ease, border-color 180ms ease, opacity 250ms ease;\n      cursor:pointer;\n      box-shadow: 0 4px 12px rgba(12, 18, 30, 0.06);\n      position:relative;\n      outline:none;\n      min-width:100px;\n      min-height:120px;\n    }\n    .card:focus{\n      box-shadow: 0 8px 20px rgba(31,110,235,0.12);\n      transform:translateY(-4px);\n      border-color: rgba(31,110,235,0.16);\n    }\n    .card .svg-wrap{\n      width:100%;\n      height:100%;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n    }\n    .card.selected{\n      transform:translateY(-8px) scale(1.04);\n      border-color: rgba(46,164,79,0.14);\n      box-shadow: 0 16px 40px rgba(46,164,79,0.08);\n    }\n    .card.hint{\n      animation: pulse 1.4s ease-in-out infinite;\n      border-color: rgba(31,110,235,0.16);\n    }\n    @keyframes pulse{\n      0%{ box-shadow: 0 0 0 0 rgba(31,110,235,0.08); }\n      70%{ box-shadow: 0 0 0 10px rgba(31,110,235,0.02); }\n      100%{ box-shadow: 0 0 0 0 rgba(31,110,235,0); }\n    }\n\n    /* Correct / incorrect feedback */\n    .feedback{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      min-height:24px;\n    }\n    .feedback .msg{\n      padding:8px 12px;\n      border-radius:8px;\n      font-weight:600;\n      font-size:13px;\n    }\n    .feedback .success{\n      background:linear-gradient(90deg, rgba(46,164,79,0.12), rgba(46,164,79,0.06));\n      color:var(--success);\n    }\n    .feedback .error{\n      background:linear-gradient(90deg, rgba(215,58,73,0.08), rgba(215,58,73,0.04));\n      color:var(--danger);\n    }\n\n    /* Animations for incorrect selection */\n    .shake{\n      animation:shake 360ms ease;\n    }\n    @keyframes shake{\n      10%{ transform:translateX(-8px); }\n      30%{ transform:translateX(8px); }\n      50%{ transform:translateX(-6px); }\n      70%{ transform:translateX(6px); }\n      90%{ transform:translateX(-3px); }\n      100%{ transform:translateX(0); }\n    }\n\n    /* right column: explanation */\n    .explain{\n      width:380px;\n      min-width:260px;\n      background:var(--panel);\n      padding:var(--gap);\n      border-radius:12px;\n      box-shadow:var(--shadow);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .explain h2{\n      margin:0;\n      font-size:16px;\n    }\n    .feature-list{\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .legend{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n    }\n    .chip{\n      background:#f6f8fb;\n      padding:6px 8px;\n      border-radius:8px;\n      font-size:13px;\n      color:var(--muted);\n      border:1px solid #eef2fb;\n    }\n\n    /* responsive */\n    @media (max-width:960px){\n      .explain{ width:100%; }\n      .board-panel{ order:2; }\n      .explain{ order:1; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"application\" aria-label=\"Set interactive learning module\">\n    <!-- Header with concept details -->\n    <header>\n      <section class=\"title\" aria-labelledby=\"concept-title\">\n        <h1 id=\"concept-title\">Set — Identify a Set</h1>\n        <div class=\"small\">\n          Concept: A \"set\" is three cards where, for each attribute (count, symbol, shading, color), the values are all the same or all different.\n        </div>\n        <div style=\"display:flex;gap:8px;margin-top:8px;\">\n          <div class=\"chip\">Single Concept: Identifying sets</div>\n          <div class=\"chip\">Accessible • Responsive</div>\n          <div class=\"chip\">Vanilla JS</div>\n        </div>\n      </section>\n\n      <div class=\"controls\" aria-hidden=\"false\">\n        <div class=\"panel\" role=\"group\" aria-label=\"game controls\">\n          <button id=\"newBtn\" title=\"Start a new deal\">New Deal</button>\n          <button id=\"hintBtn\" title=\"Highlight part of a possible set\">Hint</button>\n          <button id=\"solveBtn\" title=\"Show a complete set\">Auto-solve</button>\n          <button id=\"moreBtn\" title=\"Deal 3 more cards (if needed)\">+3 Cards</button>\n        </div>\n\n        <div class=\"panel\" aria-hidden=\"true\" style=\"min-width:220px;\">\n          <div style=\"display:flex;flex-direction:column;\">\n            <div class=\"muted\">Deck</div>\n            <div id=\"deckCount\" style=\"font-weight:700\">81</div>\n          </div>\n          <div style=\"display:flex;flex-direction:column;\">\n            <div class=\"muted\">Board</div>\n            <div id=\"boardCount\" style=\"font-weight:700\">12</div>\n          </div>\n        </div>\n      </div>\n    </header>\n\n    <main>\n      <section class=\"board-panel\" aria-label=\"game board\">\n        <div class=\"board-header\">\n          <div style=\"display:flex;flex-direction:column;\">\n            <div style=\"font-weight:700\">Play Area</div>\n            <div class=\"muted\" style=\"font-size:13px\">Select three cards to test for a set. Click a selected card to unselect.</div>\n          </div>\n\n          <div style=\"display:flex;gap:12px;align-items:center;\">\n            <button id=\"checkBtn\" class=\"primary\" title=\"Check if the selected three cards make a set\">Check</button>\n            <button id=\"autoDealBtn\" class=\"ghost\" title=\"Automatically deal until a set exists\">Deal until set</button>\n          </div>\n        </div>\n\n        <div id=\"feedback\" class=\"feedback\" aria-live=\"polite\" aria-atomic=\"true\">\n          <div class=\"muted\">Tip: Use keyboard — arrow keys to move, Enter/Space to select.</div>\n        </div>\n\n        <div id=\"board\" class=\"board-grid\" tabindex=\"0\" aria-label=\"cards on board\">\n          <!-- Cards are injected here -->\n        </div>\n      </section>\n\n      <aside class=\"explain\" aria-labelledby=\"learn-heading\">\n        <h2 id=\"learn-heading\">Learning Objective</h2>\n        <div class=\"feature-list\">\n          <div>After interacting, you will be able to:</div>\n          <ul style=\"margin:6px 0 0 18px;color:var(--muted);\">\n            <li>Recognize when three cards form a set (all same or all different per attribute).</li>\n            <li>Apply quick checks and use hints to spot sets.</li>\n          </ul>\n          <div style=\"margin-top:8px;font-weight:700\">Interaction Design</div>\n          <div class=\"muted\">\n            Click or use keyboard to select cards. When three are selected, use Check to validate. Correct sets flash green and are replaced; incorrect selections shake and show which attributes fail. Hint highlights part of a set.\n          </div>\n\n          <div style=\"margin-top:8px;font-weight:700\">Layout</div>\n          <div class=\"muted\">\n            A responsive two-column layout: the left side is the interactive board; the right column explains rules and controls. Safe margins are 24px; interactive elements are separated by at least 16px.\n          </div>\n\n          <div style=\"margin-top:8px;font-weight:700\">Attributes</div>\n          <div class=\"legend\">\n            <div class=\"chip\">Count: 1 / 2 / 3</div>\n            <div class=\"chip\">Symbol: Diamond / Oval / Wave</div>\n            <div class=\"chip\">Shading: Solid / Striped / Open</div>\n            <div class=\"chip\">Color: Red / Green / Purple</div>\n          </div>\n        </div>\n      </aside>\n    </main>\n  </div>\n\n  <script>\n    // Set game: 4 features with 3 values each -> 81-card deck\n    (function(){\n      // Config\n      const COLORS = ['#d9534f','#27ae60','#8e44ad']; // red, green, purple\n      const SYMBOLS = ['diamond','oval','wave'];\n      const SHADINGS = ['solid','striped','open'];\n      const COUNTS = [1,2,3];\n\n      // State\n      let deck = [];\n      let board = [];\n      let selected = new Set();\n      let lastFeedbackTimeout = null;\n\n      const boardEl = document.getElementById('board');\n      const deckCountEl = document.getElementById('deckCount');\n      const boardCountEl = document.getElementById('boardCount');\n      const feedbackEl = document.getElementById('feedback');\n\n      // Controls\n      document.getElementById('newBtn').addEventListener('click', newDeal);\n      document.getElementById('moreBtn').addEventListener('click', dealThree);\n      document.getElementById('hintBtn').addEventListener('click', hint);\n      document.getElementById('checkBtn').addEventListener('click', checkSelection);\n      document.getElementById('solveBtn').addEventListener('click', autoSolve);\n      document.getElementById('autoDealBtn').addEventListener('click', dealUntilSet);\n\n      // Keyboard navigation\n      boardEl.addEventListener('keydown', handleBoardKey);\n\n      // Build deck\n      function makeDeck(){\n        const d = [];\n        for(let c=0;c<COUNTS.length;c++){\n          for(let s=0;s<SYMBOLS.length;s++){\n            for(let sh=0;sh<SHADINGS.length;sh++){\n              for(let col=0;col<COLORS.length;col++){\n                d.push({\n                  id: `${c}-${s}-${sh}-${col}-${Math.random().toString(36).slice(2,7)}`,\n                  count: COUNTS[c],\n                  symbol: SYMBOLS[s],\n                  shading: SHADINGS[sh],\n                  color: COLORS[col],\n                });\n              }\n            }\n          }\n        }\n        return shuffle(d);\n      }\n\n      function shuffle(a){\n        for(let i=a.length-1;i>0;i--){\n          const j=Math.floor(Math.random()*(i+1));\n          [a[i],a[j]]=[a[j],a[i]];\n        }\n        return a;\n      }\n\n      function newDeal(){\n        deck = makeDeck();\n        board = [];\n        selected.clear();\n        // initial 12\n        for(let i=0;i<12;i++) dealOneToBoard();\n        refresh();\n        // ensure at least one set exists, else deal more until exists or deck runs out\n        if(!findAnySet(board) && deck.length>0){\n          // deal upto 3 times (will add 3 each time)\n          let tries=0;\n          while(!findAnySet(board) && deck.length>0 && tries<3){\n            dealThree();\n            tries++;\n          }\n        }\n      }\n\n      function dealOneToBoard(){\n        if(deck.length===0) return;\n        board.push(deck.pop());\n      }\n\n      function dealThree(){\n        for(let i=0;i<3;i++) dealOneToBoard();\n        refresh();\n      }\n\n      function refresh(){\n        // update counts\n        deckCountEl.textContent = deck.length;\n        boardCountEl.textContent = board.length;\n        // render cards\n        boardEl.innerHTML='';\n        board.forEach((card, idx) => {\n          const cardEl = renderCard(card, idx);\n          boardEl.appendChild(cardEl);\n        });\n        // aria\n        boardEl.setAttribute('aria-label', `Board with ${board.length} cards`);\n      }\n\n      function renderCard(card, index){\n        const wrapper = document.createElement('button');\n        wrapper.className='card';\n        wrapper.setAttribute('data-index', index);\n        wrapper.setAttribute('aria-pressed', selected.has(index));\n        wrapper.setAttribute('aria-label', `${card.count} ${card.shading} ${card.symbol} in color`);\n        wrapper.tabIndex = 0;\n\n        // click selects\n        wrapper.addEventListener('click', (e)=>{\n          toggleSelect(index, wrapper);\n        });\n        wrapper.addEventListener('keydown', (e)=>{\n          if(e.key==='Enter' || e.key===' ') {\n            e.preventDefault();\n            toggleSelect(index, wrapper);\n          }\n        });\n\n        // mark selected/hint\n        if(selected.has(index)) wrapper.classList.add('selected');\n\n        // SVG content\n        const svgWrap = document.createElement('div');\n        svgWrap.className='svg-wrap';\n        svgWrap.innerHTML = generateCardSVG(card);\n        wrapper.appendChild(svgWrap);\n        return wrapper;\n      }\n\n      function generateCardSVG(card){\n        // Create an inline SVG with repeated shapes vertically centered\n        const width = 96, height = 96;\n        const count = card.count;\n        const spacing = 14;\n        const totalHeight = count * 20 + (count-1) * spacing;\n        const startY = (height - totalHeight)/2 + 10;\n        let shapes = '';\n        for(let i=0;i<count;i++){\n          const y = startY + i*(20+spacing);\n          shapes += drawSymbolSVG(card.symbol, 48, y, card.color, card.shading);\n        }\n        // For striped shading, include a <defs> pattern\n        const pattern = (card.shading==='striped') ? stripedPatternSVG(card.color) : '';\n        return `<svg viewBox=\"0 0 ${width} ${height}\" width=\"100%\" height=\"100%\" role=\"img\" focusable=\"false\">${pattern}${shapes}</svg>`;\n      }\n\n      function stripedPatternSVG(color){\n        return `<defs>\n          <pattern id=\"p-${color.replace('#','')}\" width=\"4\" height=\"4\" patternUnits=\"userSpaceOnUse\" patternTransform=\"rotate(45)\">\n            <rect width=\"2\" height=\"4\" fill=\"${color}\" opacity=\"0.18\"></rect>\n          </pattern>\n        </defs>`;\n      }\n\n      function drawSymbolSVG(symbol, cx, cy, color, shading){\n        // Each symbol drawn around x=cx, y=cy as center.\n        // Paths are simplified to keep code compact.\n        if(symbol==='diamond'){\n          const w=28,h=18;\n          const path = `<polygon points=\"${cx},${cy-h} ${cx+w},${cy} ${cx},${cy+h} ${cx-w},${cy}\" />`;\n          return shapeWrap(path, color, shading);\n        } else if(symbol==='oval'){\n          const rx=22, ry=12;\n          const path = `<ellipse cx=\"${cx}\" cy=\"${cy}\" rx=\"${rx}\" ry=\"${ry}\" />`;\n          return shapeWrap(path, color, shading);\n        } else { // wave\n          const path = `<path d=\"M ${cx-26} ${cy} C ${cx-10} ${cy-18}, ${cx+10} ${cy+18}, ${cx+26} ${cy}\" />`;\n          return shapeWrap(path, color, shading);\n        }\n      }\n\n      function shapeWrap(path, color, shading){\n        if(shading==='solid'){\n          return `<g fill=\"${color}\" stroke=\"${color}\" stroke-width=\"1.2\" style=\"transform:translateX(0)\"><g>${path}</g></g>`;\n        } else if(shading==='open'){\n          return `<g fill=\"none\" stroke=\"${color}\" stroke-width=\"2\">${path}</g>`;\n        } else { // striped\n          return `<g fill=\"url(#p-${color.replace('#','')})\" stroke=\"${color}\" stroke-width=\"1.2\">${path}</g>`;\n        }\n      }\n\n      function toggleSelect(idx, el){\n        if(selected.has(idx)){\n          selected.delete(idx);\n          el.classList.remove('selected');\n          el.setAttribute('aria-pressed','false');\n          showFeedback('Unselected', 'muted');\n        } else {\n          selected.add(idx);\n          el.classList.add('selected');\n          el.setAttribute('aria-pressed','true');\n          showFeedback(`${selected.size} selected`, 'muted');\n        }\n        if(selected.size===3){\n          // auto-check after short pause for user to see selections\n          setTimeout(()=>{ checkSelection(); }, 180);\n        }\n      }\n\n      function checkSelection(){\n        if(selected.size!==3){\n          showFeedback('Select exactly three cards to check.', 'error');\n          return;\n        }\n        const indices = Array.from(selected);\n        const cards = indices.map(i=>board[i]);\n        if(isSet(cards[0],cards[1],cards[2])){\n          // correct\n          markCorrect(indices);\n        } else {\n          markIncorrect(indices, cards);\n        }\n      }\n\n      function isSet(a,b,c){\n        // For every attribute, values are all same or all different.\n        const attrs = ['count','symbol','shading','color'];\n        return attrs.every(attr=>{\n          const vals = [a[attr], b[attr], c[attr]];\n          const unique = new Set(vals);\n          return (unique.size===1 || unique.size===3);\n        });\n      }\n\n      function markCorrect(indices){\n        showFeedback('Correct — that is a set!', 'success');\n        // animate then remove and replace\n        indices.forEach(i=>{\n          const cardBtn = boardEl.querySelector(`.card[data-index=\"${i}\"]`);\n          if(cardBtn){\n            cardBtn.style.transition = 'transform 300ms, opacity 300ms';\n            cardBtn.style.transform = 'scale(1.08)';\n            cardBtn.style.opacity = '0';\n          }\n        });\n        setTimeout(()=>{\n          // remove higher indices first to maintain indexes consistent\n          indices.sort((a,b)=>b-a).forEach(i=>{\n            board.splice(i,1);\n          });\n          selected.clear();\n          // replace from deck to maintain 12 if possible\n          while(board.length<12 && deck.length>0){\n            board.push(deck.pop());\n          }\n          refresh();\n          // after replacement, if no set exists, indicate\n          if(!findAnySet(board)){\n            showFeedback('No set on board. You can Deal +3 or use Deal until set.', 'muted');\n          }\n        }, 320);\n      }\n\n      function markIncorrect(indices, cards){\n        showFeedback('Not a set — analyze attributes highlighted.', 'error');\n        // briefly shake wrong ones and highlight attributes that fail\n        indices.forEach(i=>{\n          const cardBtn = boardEl.querySelector(`.card[data-index=\"${i}\"]`);\n          if(cardBtn){\n            cardBtn.classList.add('shake');\n            setTimeout(()=> cardBtn.classList.remove('shake'), 360);\n          }\n        });\n        // detailed attribute analysis\n        const badAttrs = failingAttributes(cards[0],cards[1],cards[2]);\n        setTimeout(()=>{ showFeedback('Conflict: ' + badAttrs.join(', '), 'error'); }, 400);\n        // keep selected but allow user to adjust\n      }\n\n      function failingAttributes(a,b,c){\n        const attrs = {'count':'Count','symbol':'Symbol','shading':'Shading','color':'Color'};\n        return Object.keys(attrs).filter(attr=>{\n          const vals = [a[attr], b[attr], c[attr]];\n          const unique = new Set(vals);\n          return !(unique.size===1 || unique.size===3);\n        }).map(k=>attrs[k]);\n      }\n\n      function showFeedback(msg, type){\n        clearTimeout(lastFeedbackTimeout);\n        feedbackEl.innerHTML='';\n        const div = document.createElement('div');\n        if(type==='success'){\n          div.className='msg success';\n        } else if(type==='error'){\n          div.className='msg error';\n        } else {\n          const m = document.createElement('div');\n          m.className='muted';\n          m.textContent = msg;\n          feedbackEl.appendChild(m);\n          lastFeedbackTimeout = setTimeout(()=>{ if(feedbackEl.innerHTML===m.outerHTML) feedbackEl.innerHTML = `<div class=\"muted\">Tip: Use keyboard — arrow keys to move, Enter/Space to select.</div>`; }, 3000);\n          return;\n        }\n        div.textContent=msg;\n        feedbackEl.appendChild(div);\n        lastFeedbackTimeout = setTimeout(()=>{ if(feedbackEl.contains(div)) feedbackEl.innerHTML = `<div class=\"muted\">Tip: Use keyboard — arrow keys to move, Enter/Space to select.</div>`; }, 3500);\n      }\n\n      function findAnySet(cards){\n        const n = cards.length;\n        for(let i=0;i<n;i++){\n          for(let j=i+1;j<n;j++){\n            for(let k=j+1;k<n;k++){\n              if(isSet(cards[i],cards[j],cards[k])) return [i,j,k];\n            }\n          }\n        }\n        return null;\n      }\n\n      function hint(){\n        const s = findAnySet(board);\n        clearHints();\n        if(!s){\n          showFeedback('No set on board to hint for.', 'error');\n          return;\n        }\n        // Highlight one of the cards mildly\n        const idx = s[0];\n        const el = boardEl.querySelector(`.card[data-index=\"${idx}\"]`);\n        if(el){\n          el.classList.add('hint');\n          setTimeout(()=> el.classList.remove('hint'), 2400);\n        }\n        showFeedback('Hint: highlighted one card from a valid set.', 'muted');\n      }\n\n      function autoSolve(){\n        const s = findAnySet(board);\n        if(!s){\n          showFeedback('No set on this board.', 'error');\n          return;\n        }\n        // select those three and animate selection then mark correct\n        selected.clear();\n        s.forEach(i=>{\n          const el = boardEl.querySelector(`.card[data-index=\"${i}\"]`);\n          if(el) { el.classList.add('selected'); }\n          selected.add(i);\n        });\n        setTimeout(()=> checkSelection(), 380);\n      }\n\n      function dealUntilSet(){\n        let safety=0;\n        while(!findAnySet(board) && deck.length>0 && safety<10){\n          dealThree();\n          safety++;\n        }\n        if(findAnySet(board)){\n          showFeedback('Dealt until a set appeared.', 'muted');\n        } else if(deck.length===0){\n          showFeedback('Deck empty and no set found.', 'error');\n        }\n      }\n\n      function clearHints(){\n        boardEl.querySelectorAll('.card.hint').forEach(n => n.classList.remove('hint'));\n        boardEl.querySelectorAll('.card.selected').forEach(n => n.classList.remove('selected'));\n      }\n\n      // Keyboard navigation among cards: arrow keys move focus\n      function handleBoardKey(e){\n        const focus = document.activeElement;\n        if(!focus || !focus.classList.contains('card')) return;\n        let idx = Number(focus.getAttribute('data-index'));\n        const cols = Math.max(2, Math.floor(boardEl.clientWidth / (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-width')) || 120)));\n        let targetIndex = null;\n        switch(e.key){\n          case 'ArrowRight':\n            targetIndex = (idx+1) % board.length;\n            break;\n          case 'ArrowLeft':\n            targetIndex = (idx-1+board.length) % board.length;\n            break;\n          case 'ArrowDown':\n            targetIndex = (idx + cols) % board.length;\n            break;\n          case 'ArrowUp':\n            targetIndex = (idx - cols + board.length) % board.length;\n            break;\n          default: return;\n        }\n        e.preventDefault();\n        const el = boardEl.querySelector(`.card[data-index=\"${targetIndex}\"]`);\n        if(el) el.focus();\n      }\n\n      // attribute analysis helper (for learning)\n      // start\n      newDeal();\n\n      // expose for debug (optional)\n      window.__setModule = {deck, board, isSet, findAnySet};\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Set.\n\n**Project Overview:**\nTopic: Set\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Set"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "FSM modeling interactive states and transitions of the Set learning module (card board, selection, checking, dealing, hinting, animations, and completion).",
      "states": [
        {
          "name": "idle",
          "onEnter": "refresh() -> update DOM, counts, render cards; show default tip feedback",
          "on": {
            "SELECT_CARD": "selecting",
            "NEW_DEAL": "idle",
            "DEAL_THREE": "dealing",
            "HINT": "hinting",
            "AUTO_SOLVE": "autoSolveDecision",
            "DEAL_UNTIL_SET": "dealUntilSet",
            "CHECK": "idle",
            "KEY_NAV": "idle"
          }
        },
        {
          "name": "selecting",
          "onEnter": "showFeedback(`${selected.size} selected`, 'muted')",
          "onExit": "clear any transient selection-only timers",
          "on": {
            "SELECT_CARD": "selecting_or_threeSelected",
            "UNSELECT_CARD": "selecting_or_idle",
            "CHECK": "checking_or_feedback",
            "HINT": "hinting",
            "DEAL_THREE": "dealing",
            "NEW_DEAL": "idle",
            "AUTO_SOLVE": "autoSolveDecision",
            "DEAL_UNTIL_SET": "dealUntilSet",
            "KEY_NAV": "selecting"
          }
        },
        {
          "name": "threeSelected",
          "onEnter": "startAutoCheckTimer(180ms) // (auto-check timeout started when 3 selected)",
          "onExit": "clearAutoCheckTimer()",
          "on": {
            "AUTO_CHECK_TIMEOUT": "checking",
            "CHECK": "checking",
            "UNSELECT_CARD": "selecting",
            "HINT": "hinting",
            "NEW_DEAL": "idle",
            "DEAL_THREE": "dealing"
          }
        },
        {
          "name": "checking",
          "onEnter": "evaluateSelection() -> if isSet emit CHECK_RESULT_CORRECT else emit CHECK_RESULT_INCORRECT",
          "on": {
            "CHECK_RESULT_CORRECT": "correct",
            "CHECK_RESULT_INCORRECT": "incorrect"
          }
        },
        {
          "name": "correct",
          "onEnter": "showFeedback('Correct — that is a set!', 'success'); animateRemoveSelected(320ms); startCorrectAnimationTimer(320ms)",
          "onExit": "clear animations; selected.clear(); replaceRemovedFromDeck(); refresh()",
          "on": {
            "CORRECT_ANIMATION_END": "postCorrectDecision"
          }
        },
        {
          "name": "incorrect",
          "onEnter": "showFeedback('Not a set — analyze attributes highlighted.', 'error'); animateShakeSelected(360ms); computeAndShowFailingAttributes(); startIncorrectTimer(400ms)",
          "onExit": "clear shake animation",
          "on": {
            "INCORRECT_ANIMATION_END": "threeSelected",
            "UNSELECT_CARD": "selecting",
            "SELECT_CARD": "selecting_or_threeSelected"
          }
        },
        {
          "name": "hinting",
          "onEnter": "clearHints(); findAnySet(); if set -> highlightOneCardHint(); showFeedback('Hint: highlighted one card from a valid set.', 'muted'); startHintTimer(2400ms)",
          "onExit": "clearHintHighlight()",
          "on": {
            "HINT_TIMEOUT": "returnToPriorSelectionState",
            "NEW_DEAL": "idle",
            "DEAL_THREE": "dealing",
            "AUTO_SOLVE": "autoSolveDecision",
            "DEAL_UNTIL_SET": "dealUntilSet"
          }
        },
        {
          "name": "dealing",
          "onEnter": "dealThreeToBoard() or dealUntilSet loop; refresh(); showFeedback(...) as appropriate",
          "onExit": "clear any dealing timers",
          "on": {
            "DEAL_COMPLETE": "idle_or_noSetDeckEmpty",
            "NEW_DEAL": "idle",
            "HINT": "hinting"
          }
        },
        {
          "name": "autoSolveDecision",
          "onEnter": "findAnySet(board) -> if found select those three (add selected classes), startAutoSolveTimer(380ms) else showFeedback('No set on this board.', 'error')",
          "on": {
            "AUTO_CHECK_TIMEOUT": "checking",
            "NO_SET_FOUND": "idle"
          }
        },
        {
          "name": "dealUntilSet",
          "onEnter": "loop: while(!findAnySet(board) && deck.length>0) dealThree(); refresh(); if(findAnySet) showFeedback('Dealt until a set appeared.', 'muted') else if(deck empty) showFeedback('Deck empty and no set found.', 'error')",
          "on": {
            "DEAL_LOOP_COMPLETE": "idle_or_noSetDeckEmpty"
          }
        },
        {
          "name": "noSetDeckEmpty",
          "onEnter": "showFeedback('Deck empty and no set found.', 'error')",
          "on": {
            "NEW_DEAL": "idle",
            "DEAL_THREE": "noSetDeckEmpty",
            "HINT": "noSetDeckEmpty",
            "AUTO_SOLVE": "noSetDeckEmpty",
            "CHECK": "noSetDeckEmpty"
          }
        },
        {
          "name": "postCorrectDecision",
          "onEnter": "after removal/replacement: if(!findAnySet(board) && deck.length===0) emit DECK_EMPTY_NO_SET else if(!findAnySet(board)) showFeedback('No set on board. You can Deal +3 or use Deal until set.', 'muted'); clear feedback timer",
          "on": {
            "DECK_EMPTY_NO_SET": "noSetDeckEmpty",
            "POST_REFRESH_IDLE": "idle"
          }
        }
      ],
      "events": [
        "SELECT_CARD",
        "UNSELECT_CARD",
        "NEW_DEAL",
        "DEAL_THREE",
        "HINT",
        "AUTO_SOLVE",
        "DEAL_UNTIL_SET",
        "CHECK",
        "AUTO_CHECK_TIMEOUT",
        "AUTO_CHECK_START",
        "AUTO_CHECK_END",
        "CHECK_RESULT_CORRECT",
        "CHECK_RESULT_INCORRECT",
        "CORRECT_ANIMATION_END",
        "INCORRECT_ANIMATION_END",
        "HINT_TIMEOUT",
        "DEAL_COMPLETE",
        "DEAL_LOOP_COMPLETE",
        "NO_SET_FOUND",
        "DECK_EMPTY_NO_SET",
        "POST_REFRESH_IDLE",
        "KEY_NAV"
      ],
      "notes": "This FSM models the primary UI flows: selecting cards (1-2), reaching 3 selections triggers an auto-check or manual Check leading to checking -> correct/incorrect flows, dealing (+3 or deal-until-set) modifies board and can lead to a board with no sets, hinting temporarily highlights one card, autoSolve selects and auto-checks a known set. Timers used in implementation: auto-check after 180ms when 3 cards are selected, auto-solve delay 380ms, correct removal animation ~320ms, incorrect shake ~360-400ms, hint highlight ~2400ms. Actions referenced in onEnter/onExit correspond to functions in the code: refresh(), showFeedback(...), findAnySet(), dealThree(), dealUntilSet(), animateRemoveSelected(), animateShakeSelected(), highlightOneCardHint(), clearHintHighlight(), startAutoCheckTimer(), clearAutoCheckTimer(), etc. The 'hinting' state is a transient overlay and returns to either 'idle' or 'selecting' depending on whether any cards remain selected. The FSM also exposes a terminal-like state 'noSetDeckEmpty' where the deck is empty and no set exists; New Deal resets to 'idle'. Dynamic branching decisions (e.g., whether a set exists or deck empty) are represented by decision transitions (autoSolveDecision, postCorrectDecision)."
    }
  },
  {
    "id": "24fedb00-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:28:05.439Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive BST Explorer</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --card: #0e1630;\n      --accent: #22c1c3;\n      --muted: #9aa6b2;\n      --text: #e6eef3;\n      --danger: #ff6b6b;\n      --success: #7be495;\n      --node-fill: #1f2a44;\n      --node-stroke: #253553;\n      --node-highlight: #ffd166;\n    }\n\n    html,body{\n      height:100%;\n      margin:0;\n      font-family: Inter, Roboto, system-ui, -apple-system, \"Segoe UI\", \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg, var(--bg) 0%, #041022 100%);\n      color:var(--text);\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    /* Safe area container */\n    .app {\n      box-sizing:border-box;\n      padding:var(--safe-margin);\n      min-height:100vh;\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n    }\n\n    /* Left pane: info + controls */\n    .left {\n      width:360px;\n      min-width:260px;\n      max-width:38%;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:20px;\n      box-shadow:0 6px 24px rgba(2,6,23,0.7);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    /* Right pane: visual area */\n    .right {\n      flex:1 1 auto;\n      min-width:320px;\n      height:720px;\n      background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:12px;\n      padding:16px;\n      position:relative;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    h1 {\n      font-size:20px;\n      margin:0;\n      color:var(--accent);\n      letter-spacing:0.2px;\n    }\n\n    .meta {\n      font-size:13px;\n      color:var(--muted);\n      line-height:1.4;\n    }\n\n    .section {\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      padding:12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n\n    .controls {\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    .row {\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n    }\n\n    input[type=\"number\"]{\n      background:transparent;\n      color:var(--text);\n      border:1px solid rgba(255,255,255,0.06);\n      padding:10px 12px;\n      border-radius:8px;\n      outline:none;\n      width:140px;\n      font-size:14px;\n    }\n    input[type=\"number\"]::placeholder { color: #6e7b86; }\n    input[type=\"number\"]:focus{\n      border-color:var(--accent);\n      box-shadow:0 0 0 4px rgba(34,193,195,0.06);\n    }\n\n    button {\n      background:var(--accent);\n      color:#011015;\n      border:none;\n      padding:10px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      min-width:64px;\n      transition:transform .08s ease, box-shadow .12s ease;\n    }\n    button:hover{ transform:translateY(-1px); }\n    button:active{ transform:translateY(0); }\n\n    .btn-ghost {\n      background:transparent;\n      color:var(--text);\n      border:1px solid rgba(255,255,255,0.06);\n    }\n\n    .btn-danger {\n      background:var(--danger);\n      color:#2b0f0f;\n    }\n\n    .btn-secondary {\n      background:var(--card);\n      color:var(--text);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    .small {\n      padding:8px 10px;\n      font-size:13px;\n      min-width:46px;\n    }\n\n    .controls .hint {\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Canvas area */\n    .canvas-wrap{\n      flex:1 1 auto;\n      background:linear-gradient(180deg, rgba(255,255,255,0.00), rgba(255,255,255,0.00));\n      border-radius:8px;\n      padding:12px;\n      position:relative;\n      overflow:auto;\n      border:1px dashed rgba(255,255,255,0.02);\n    }\n\n    /* svg fills the area */\n    svg{\n      width:100%;\n      height:100%;\n    }\n\n    /* Node styling using classes */\n    .node {\n      cursor:pointer;\n      transition:transform 420ms cubic-bezier(.2,.9,.3,1), opacity 240ms ease;\n    }\n\n    .node circle {\n      fill:var(--node-fill);\n      stroke:var(--node-stroke);\n      stroke-width:2px;\n      transition:fill 220ms ease, stroke 220ms ease, r 220ms ease;\n    }\n\n    .node text {\n      fill:var(--text);\n      font-size:12px;\n      font-weight:600;\n      text-anchor:middle;\n      dominant-baseline:middle;\n      pointer-events:none;\n    }\n\n    .node.highlight circle {\n      fill:var(--node-highlight);\n      stroke:#b86a00;\n    }\n\n    .node.found circle {\n      fill:var(--success);\n      stroke:#2a8f5b;\n    }\n\n    .edge {\n      stroke:rgba(255,255,255,0.08);\n      stroke-width:2px;\n      transition:stroke 220ms ease, opacity 220ms ease;\n      vector-effect: non-scaling-stroke;\n    }\n\n    .edge.highlight {\n      stroke:var(--accent);\n      stroke-width:3px;\n      opacity:1;\n    }\n\n    /* log/trace area */\n    .trace {\n      height:120px;\n      overflow:auto;\n      background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.005));\n      border-radius:8px;\n      padding:10px;\n      font-family:monospace;\n      font-size:13px;\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.02);\n    }\n\n    .footer-row {\n      display:flex;\n      justify-content:space-between;\n      gap:var(--gap);\n      align-items:center;\n    }\n\n    /* Responsive */\n    @media (max-width:920px){\n      .app { flex-direction:column; }\n      .left { width:100%; max-width:none; }\n      .right { width:100%; height:560px; }\n    }\n\n    /* Accessibility focus */\n    button:focus, input:focus {\n      box-shadow:0 0 0 4px rgba(34,193,195,0.06);\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Binary Search Tree interactive module\">\n    <aside class=\"left\" aria-labelledby=\"title\">\n      <div>\n        <h1 id=\"title\">Binary Search Tree (BST) — Interactive Explorer</h1>\n        <p class=\"meta\">Explore insertion, search, deletion and traversals with live visuals and step-by-step feedback.</p>\n      </div>\n\n      <div class=\"section\" aria-live=\"polite\">\n        <strong>Learning Objective</strong>\n        <p class=\"meta\" style=\"margin-top:8px;\">\n          After interacting with this module you will understand how values are placed in a BST,\n          how search and deletion proceed (including the in-order successor replacement),\n          and how in-order/pre-order/post-order traversals visit nodes. Visual feedback and animations reinforce the tree structure and algorithms.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-hidden=\"false\">\n        <strong>Interaction Design</strong>\n        <p class=\"meta\" style=\"margin-top:8px;\">\n          - Insert a number by typing and clicking \"Insert\" (or Enter). The insertion path is highlighted step-by-step, then the node appears and animates to its final position.<br>\n          - Search highlights the path visited; found nodes flash green.<br>\n          - Delete removes a node (standard BST deletion). If the node has two children, the in-order successor is used — the swap and removal are animated.<br>\n          - Traversal buttons animate the order of visiting nodes (highlighting them in sequence).<br>\n          - \"Random\" fills several values; \"Clear\" resets the tree. Logs show the algorithm steps.\n        </p>\n      </div>\n\n      <div class=\"section controls\" aria-label=\"Controls\">\n        <div class=\"row\" style=\"align-items:center;\">\n          <label for=\"valueInput\" class=\"meta\" style=\"min-width:72px;\">Value</label>\n          <input id=\"valueInput\" type=\"number\" placeholder=\"e.g., 42\" aria-label=\"Value to operate on\" />\n          <button id=\"insertBtn\" title=\"Insert value\">Insert</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"searchBtn\" class=\"btn-secondary small\" title=\"Search value\">Search</button>\n          <button id=\"deleteBtn\" class=\"btn-danger small\" title=\"Delete value\">Delete</button>\n          <button id=\"clearBtn\" class=\"btn-ghost small\" title=\"Clear tree\">Clear</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"randomBtn\" class=\"small btn-secondary\" title=\"Insert several random values\">Random</button>\n          <button id=\"fillBtn\" class=\"small btn-secondary\" title=\"Insert a demo set\">Demo</button>\n        </div>\n\n        <div class=\"row\" style=\"align-items:flex-start;\">\n          <div style=\"flex:1;\">\n            <div class=\"meta\" style=\"margin-bottom:8px;\">Traversals</div>\n            <div style=\"display:flex;gap:var(--gap);\">\n              <button id=\"inorderBtn\" class=\"small\">In-order</button>\n              <button id=\"preorderBtn\" class=\"small\">Pre-order</button>\n              <button id=\"postorderBtn\" class=\"small\">Post-order</button>\n            </div>\n            <div class=\"hint\" style=\"margin-top:8px;\">Traversal animations highlight nodes in visit order and append the sequence to the log.</div>\n          </div>\n        </div>\n\n        <div class=\"row\">\n          <div class=\"hint\">Tip: Use numerals only. Duplicates are rejected (BST here enforces unique keys).</div>\n        </div>\n      </div>\n\n      <div class=\"section\" aria-live=\"polite\">\n        <strong>Layout Description</strong>\n        <p class=\"meta\" style=\"margin-top:8px;\">\n          - Safe-area margin: 24px on all sides of the viewport (container padding).<br>\n          - Minimum spacing between controls: 16px (CSS gap used across rows and items).<br>\n          - Left column contains explanation and controls (fixed width). Right column is the responsive visualization canvas (SVG) where the tree is drawn. Controls are keyboard accessible and include clear visual focus states.\n        </p>\n      </div>\n\n      <div class=\"section\">\n        <strong>Console / Trace</strong>\n        <div id=\"log\" class=\"trace\" role=\"log\" aria-live=\"polite\" aria-atomic=\"false\"></div>\n      </div>\n    </aside>\n\n    <main class=\"right\" aria-label=\"Visualizer\">\n      <div class=\"footer-row\" style=\"align-items:flex-start;\">\n        <div>\n          <strong style=\"color:var(--accent);\">BST Visualizer</strong>\n          <div class=\"meta\" style=\"margin-top:6px;\">Click a node to set the input value to that node (shortcut). Paths and operations are animated for clarity.</div>\n        </div>\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <button id=\"fitBtn\" class=\"btn-secondary small\" title=\"Center and fit\">Fit</button>\n          <button id=\"stepModeBtn\" class=\"btn-secondary small\" title=\"Toggle step-by-step mode\">Step: Off</button>\n        </div>\n      </div>\n\n      <div class=\"canvas-wrap\" id=\"canvasWrap\" tabindex=\"0\" aria-label=\"Tree canvas\">\n        <!-- SVG will be injected here -->\n        <svg id=\"svgCanvas\" viewBox=\"0 0 1200 800\" preserveAspectRatio=\"xMinYMin meet\" role=\"img\" aria-label=\"Binary search tree diagram\"></svg>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    /*\n      Interactive BST Explorer\n      - Vanilla JS implementation of a BST with visual SVG rendering\n      - Supports insert, search, delete, traversals, random/demo data\n      - Animations: node transitions (transform), edge updates, path highlighting\n    */\n\n    // ---------- Utility & DOM ----------\n    const svg = document.getElementById('svgCanvas');\n    const logEl = document.getElementById('log');\n    const valueInput = document.getElementById('valueInput');\n    const insertBtn = document.getElementById('insertBtn');\n    const searchBtn = document.getElementById('searchBtn');\n    const deleteBtn = document.getElementById('deleteBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const randomBtn = document.getElementById('randomBtn');\n    const fillBtn = document.getElementById('fillBtn');\n    const inorderBtn = document.getElementById('inorderBtn');\n    const preorderBtn = document.getElementById('preorderBtn');\n    const postorderBtn = document.getElementById('postorderBtn');\n    const fitBtn = document.getElementById('fitBtn');\n    const stepModeBtn = document.getElementById('stepModeBtn');\n    const canvasWrap = document.getElementById('canvasWrap');\n\n    let stepMode = false;\n    stepModeBtn.addEventListener('click', () => {\n      stepMode = !stepMode;\n      stepModeBtn.textContent = 'Step: ' + (stepMode ? 'On' : 'Off');\n    });\n\n    // Logging helper\n    function log(text, cls) {\n      const p = document.createElement('div');\n      p.textContent = text;\n      if (cls) p.className = cls;\n      logEl.appendChild(p);\n      logEl.scrollTop = logEl.scrollHeight;\n    }\n    function clearLog(){ logEl.innerHTML = ''; }\n\n    // ---------- BST Model ----------\n    class BSTNode {\n      constructor(value) {\n        this.value = value;\n        this.left = null;\n        this.right = null;\n        this.parent = null;\n        // position for rendering\n        this.x = 0;\n        this.y = 0;\n        this.id = 'n' + Math.random().toString(36).substr(2,9);\n      }\n    }\n\n    class BST {\n      constructor() {\n        this.root = null;\n      }\n\n      insert(value) {\n        if (this.root === null) {\n          this.root = new BSTNode(value);\n          return {node: this.root, path: []};\n        }\n        let cur = this.root;\n        const path = [];\n        while (true) {\n          path.push(cur);\n          if (value === cur.value) {\n            return {node: null, path, reason: 'duplicate'};\n          } else if (value < cur.value) {\n            if (!cur.left) {\n              const n = new BSTNode(value);\n              n.parent = cur;\n              cur.left = n;\n              return {node: n, path};\n            }\n            cur = cur.left;\n          } else {\n            if (!cur.right) {\n              const n = new BSTNode(value);\n              n.parent = cur;\n              cur.right = n;\n              return {node: n, path};\n            }\n            cur = cur.right;\n          }\n        }\n      }\n\n      search(value) {\n        let cur = this.root;\n        const path = [];\n        while (cur) {\n          path.push(cur);\n          if (value === cur.value) return {found: cur, path};\n          cur = value < cur.value ? cur.left : cur.right;\n        }\n        return {found: null, path};\n      }\n\n      // delete node with value; returns info for animation\n      delete(value) {\n        const res = this.search(value);\n        if (!res.found) return {deleted: null, path: res.path, reason: 'not found'};\n        const node = res.found;\n        const path = res.path;\n\n        // helper: transplant u with v\n        const transplant = (u, v) => {\n          if (!u.parent) this.root = v;\n          else if (u === u.parent.left) u.parent.left = v;\n          else u.parent.right = v;\n          if (v) v.parent = u.parent;\n        };\n\n        if (!node.left) {\n          transplant(node, node.right);\n          return {deleted: node, path, replacedBy: node.right};\n        } else if (!node.right) {\n          transplant(node, node.left);\n          return {deleted: node, path, replacedBy: node.left};\n        } else {\n          // find in-order successor (min in right subtree)\n          let succ = node.right;\n          const succPath = [];\n          while (succ.left) {\n            succPath.push(succ);\n            succ = succ.left;\n          }\n          // succ is the minimum; succPath includes nodes on the way (excluding succ)\n          // We'll replace node.value with succ.value, then delete succ (which has at most right child)\n          const oldValue = node.value;\n          node.value = succ.value;\n          // Now delete succ (it has no left child)\n          transplant(succ, succ.right);\n          return {deleted: succ, path, replacedNode: node, swappedValue: oldValue};\n        }\n      }\n\n      // traversal functions that return arrays of nodes visited\n      inorder(node = this.root, out = []) {\n        if (!node) return out;\n        if (node.left) this.inorder(node.left, out);\n        out.push(node);\n        if (node.right) this.inorder(node.right, out);\n        return out;\n      }\n      preorder(node = this.root, out = []) {\n        if (!node) return out;\n        out.push(node);\n        if (node.left) this.preorder(node.left, out);\n        if (node.right) this.preorder(node.right, out);\n        return out;\n      }\n      postorder(node = this.root, out = []) {\n        if (!node) return out;\n        if (node.left) this.postorder(node.left, out);\n        if (node.right) this.postorder(node.right, out);\n        out.push(node);\n        return out;\n      }\n\n      // count nodes (helper)\n      count(node = this.root) {\n        if (!node) return 0;\n        return 1 + this.count(node.left) + this.count(node.right);\n      }\n    }\n\n    const tree = new BST();\n\n    // ---------- Rendering ----------\n    // We'll build SVG elements mapped by node.id\n    const NODE_RADIUS = 20;\n    const LEVEL_GAP = 80;\n    const H_SPACING = 40;\n\n    // maps node.id -> {g, circle, text, edgeToParent}\n    const elements = new Map();\n\n    function clearSVG() {\n      while (svg.firstChild) svg.removeChild(svg.firstChild);\n      elements.clear();\n    }\n\n    function computeLayout() {\n      // assign inorder x positions spaced by width, and y by depth\n      let x = 60; // left margin\n      const depthY = [];\n\n      function dfs(node, depth=0) {\n        if (!node) return;\n        if (depthY[depth] === undefined) depthY[depth] = depth * LEVEL_GAP + 60;\n        if (node.left) dfs(node.left, depth+1);\n        node.x = x;\n        node.y = depthY[depth];\n        x += NODE_RADIUS * 2 + H_SPACING;\n        if (node.right) dfs(node.right, depth+1);\n      }\n      dfs(tree.root);\n      // adjust svg viewBox width based on x used\n      const width = Math.max(1200, x + 100);\n      const height = Math.max(800, (depthY[depthY.length-1] || 200) + 200);\n      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n    }\n\n    function renderTree(animated = true) {\n      computeLayout();\n      // create or update nodes and edges\n      const newIds = new Set();\n      function walk(node) {\n        if (!node) return;\n        newIds.add(node.id);\n        if (!elements.has(node.id)) {\n          // create group for node + edge\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.classList.add('node');\n          g.setAttribute('data-id', node.id);\n          g.setAttribute('tabindex', '0');\n          g.setAttribute('role', 'button');\n          g.setAttribute('aria-label', 'Node ' + node.value);\n          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          circle.setAttribute('r', NODE_RADIUS);\n          circle.setAttribute('cx', 0);\n          circle.setAttribute('cy', 0);\n          const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n          text.textContent = node.value;\n          g.appendChild(circle);\n          g.appendChild(text);\n\n          // edge to parent if exists\n          let edge = null;\n          if (node.parent) {\n            edge = document.createElementNS('http://www.w3.org/2000/svg','line');\n            edge.classList.add('edge');\n            edge.setAttribute('data-from', node.parent.id);\n            edge.setAttribute('data-to', node.id);\n            svg.appendChild(edge);\n          }\n\n          svg.appendChild(g);\n          elements.set(node.id, {g,circle,text,edge});\n          // set initial position off-screen or at parent's position for smoother insertion\n          const px = node.parent ? node.parent.x : node.x;\n          const py = node.parent ? node.parent.y : node.y - 60;\n          g.setAttribute('transform', `translate(${px}, ${py})`);\n          g.style.opacity = '0';\n          // click sets input value\n          g.addEventListener('click', () => {\n            valueInput.value = node.value;\n            valueInput.focus();\n          });\n          g.addEventListener('keydown', (e) => {\n            if (e.key === 'Enter') {\n              valueInput.value = node.value;\n              valueInput.focus();\n            }\n          });\n        }\n        // update text (in case of swapped values during delete)\n        const el = elements.get(node.id);\n        el.text.textContent = node.value;\n        // set edge positions (if edge exists)\n        if (node.parent && el.edge) {\n          el.edge.setAttribute('x1', node.parent.x);\n          el.edge.setAttribute('y1', node.parent.y);\n          el.edge.setAttribute('x2', node.x);\n          el.edge.setAttribute('y2', node.y);\n        }\n        // move node to computed position\n        requestAnimationFrame(() => {\n          el.g.style.opacity = '1';\n          el.g.style.transition = 'transform 420ms cubic-bezier(.2,.9,.3,1), opacity 220ms ease';\n          el.g.setAttribute('transform', `translate(${node.x}, ${node.y})`);\n        });\n\n        // proceed\n        if (node.left) walk(node.left);\n        if (node.right) walk(node.right);\n      }\n      walk(tree.root);\n\n      // remove old elements not in newIds\n      for (const [id, obj] of elements.entries()) {\n        if (!newIds.has(id)) {\n          // animate fade out then remove\n          obj.g.style.transition = 'opacity 240ms ease';\n          obj.g.style.opacity = '0';\n          if (obj.edge) obj.edge.style.opacity = '0';\n          setTimeout(() => {\n            if (obj.g.parentNode) obj.g.parentNode.removeChild(obj.g);\n            if (obj.edge && obj.edge.parentNode) obj.edge.parentNode.removeChild(obj.edge);\n            elements.delete(id);\n          }, 260);\n        }\n      }\n    }\n\n    // helper to highlight path nodes and edges stepwise\n    async function animatePath(path, {highlightEnd=false, found=false, message} = {}) {\n      // path: array of BSTNode\n      for (let i=0;i<path.length;i++) {\n        const node = path[i];\n        const el = elements.get(node.id);\n        if (!el) continue;\n        // highlight node and edge from parent\n        el.g.classList.add('highlight');\n        if (el.edge) el.edge.classList.add('highlight');\n        log(`Visited ${node.value}${i===path.length-1 ? (found ? ' (found)' : '') : ''}`);\n        // await small pause or user step\n        await waitOrStep(420);\n        el.g.classList.remove('highlight');\n        if (el.edge) el.edge.classList.remove('highlight');\n      }\n      if (message) log(message);\n    }\n\n    // Wait helper that respects step mode\n    function waitOrStep(ms=400) {\n      return new Promise(resolve => {\n        if (!stepMode) return setTimeout(resolve, ms);\n        // show a small overlay or require user click? For simplicity, we'll wait for click on canvasWrap\n        const onClick = () => {\n          canvasWrap.removeEventListener('click', onClick);\n          resolve();\n        };\n        canvasWrap.addEventListener('click', onClick);\n        // also support pressing Enter\n        const onKey = (e) => {\n          if (e.key === 'Enter') {\n            window.removeEventListener('keydown', onKey);\n            canvasWrap.removeEventListener('click', onClick);\n            resolve();\n          }\n        };\n        window.addEventListener('keydown', onKey);\n      });\n    }\n\n    // Traversal animation\n    async function animateTraversal(nodes) {\n      if (!nodes || nodes.length===0) return;\n      const sequence = [];\n      for (let n of nodes) {\n        const el = elements.get(n.id);\n        if (!el) continue;\n        el.g.classList.add('highlight');\n        sequence.push(n.value);\n        log('Visit ' + n.value);\n        await waitOrStep(420);\n        el.g.classList.remove('highlight');\n        // mark visited briefly\n        el.g.classList.add('found');\n        setTimeout(()=> el.g.classList.remove('found'), 500);\n      }\n      log('Traversal sequence: [' + sequence.join(', ') + ']');\n    }\n\n    // ---------- Actions: Insert / Search / Delete ----------\n    async function doInsert(value) {\n      if (value === '' || value === null || isNaN(value)) {\n        log('Insert: invalid or empty input');\n        return;\n      }\n      value = Number(value);\n      const result = tree.insert(value);\n      if (result.reason === 'duplicate') {\n        log('Insert aborted: duplicate value ' + value);\n        // still animate path to the duplicate node\n        renderTree();\n        await animatePath(result.path, {message: 'Duplicate found; insertion cancelled.'});\n        return;\n      }\n      // show path traversal before node appears\n      renderTree(false); // ensure existing nodes present\n      await animatePath(result.path, {message: `Inserting ${value}...`});\n\n      // render tree and animate new node appearing\n      renderTree(true);\n      log('Inserted ' + value);\n    }\n\n    async function doSearch(value) {\n      if (value === '' || value === null || isNaN(value)) {\n        log('Search: invalid input');\n        return;\n      }\n      value = Number(value);\n      const res = tree.search(value);\n      renderTree(false);\n      await animatePath(res.path, {found: !!res.found});\n      if (res.found) {\n        const el = elements.get(res.found.id);\n        if (el) {\n          el.g.classList.add('found');\n          await waitOrStep(400);\n          setTimeout(()=> el.g.classList.remove('found'), 300);\n        }\n        log('Search result: found ' + value);\n      } else {\n        log('Search result: ' + value + ' not found');\n      }\n    }\n\n    async function doDelete(value) {\n      if (value === '' || value === null || isNaN(value)) {\n        log('Delete: invalid input');\n        return;\n      }\n      value = Number(value);\n      const res = tree.delete(value);\n      renderTree(false);\n      if (res.reason === 'not found') {\n        await animatePath(res.path, {message: 'Value not found; nothing to delete.'});\n        log('Delete aborted: not found ' + value);\n        return;\n      }\n      // animate path to node to delete\n      await animatePath(res.path, {message: 'Deleting ' + value + '...'});\n      // if swappedValue present, show swap animation (node value changed)\n      if (res.swappedValue !== undefined && res.replacedNode) {\n        // show the node that received the successor value\n        const node = res.replacedNode;\n        const el = elements.get(node.id);\n        if (el) {\n          el.g.classList.add('found');\n          log(`Replaced value ${res.swappedValue} with successor ${node.value}`);\n          await waitOrStep(520);\n          el.g.classList.remove('found');\n        }\n      } else {\n        log('Deleted ' + value);\n      }\n      // final render will animate remaining nodes to new positions\n      renderTree(true);\n    }\n\n    // ---------- Controls wiring ----------\n    insertBtn.addEventListener('click', async () => {\n      const v = valueInput.value;\n      await doInsert(v);\n      valueInput.value = '';\n      valueInput.focus();\n    });\n    // allow Enter in input to insert\n    valueInput.addEventListener('keydown', (e) => {\n      if (e.key === 'Enter') {\n        insertBtn.click();\n      }\n    });\n\n    searchBtn.addEventListener('click', async () => {\n      const v = valueInput.value;\n      await doSearch(v);\n      valueInput.focus();\n    });\n\n    deleteBtn.addEventListener('click', async () => {\n      const v = valueInput.value;\n      await doDelete(v);\n      valueInput.value = '';\n      valueInput.focus();\n    });\n\n    clearBtn.addEventListener('click', () => {\n      tree.root = null;\n      clearSVG();\n      clearLog();\n      log('Cleared tree.');\n    });\n\n    randomBtn.addEventListener('click', async () => {\n      const count = 8;\n      const range = 100;\n      for (let i=0;i<count;i++) {\n        const v = Math.floor(Math.random() * range);\n        await doInsert(v);\n        await new Promise(r=>setTimeout(r, 180));\n      }\n    });\n\n    fillBtn.addEventListener('click', async () => {\n      // demo data (balanced-ish)\n      const seq = [50,30,70,20,40,60,80,10,25,35,45];\n      for (let v of seq) {\n        await doInsert(v);\n        await new Promise(r=>setTimeout(r, 200));\n      }\n    });\n\n    inorderBtn.addEventListener('click', async () => {\n      const seq = tree.inorder();\n      await animateTraversal(seq);\n    });\n    preorderBtn.addEventListener('click', async () => {\n      const seq = tree.preorder();\n      await animateTraversal(seq);\n    });\n    postorderBtn.addEventListener('click', async () => {\n      const seq = tree.postorder();\n      await animateTraversal(seq);\n    });\n\n    fitBtn.addEventListener('click', () => {\n      // reset viewBox scaling to fit\n      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n      canvasWrap.scrollTo({ top: 0, left: 0, behavior: 'smooth' });\n      log('Fitted tree to view.');\n    });\n\n    // Initialize\n    clearSVG();\n    log('Binary Search Tree Explorer ready.');\n    // keyboard shortcuts: i = insert, s = search, d = delete, c = clear\n    window.addEventListener('keydown', (e) => {\n      if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;\n      if (e.key === 'i') { valueInput.focus(); }\n      if (e.key === 'c') { clearBtn.click(); }\n    });\n\n    // ensure responsive view sizing on load/resize\n    window.addEventListener('resize', () => {\n      renderTree(false);\n    });\n\n    // Provide an initial demo set for guidance\n    (async function initialDemo(){\n      const demo = [50, 30, 70, 20, 40, 60, 80];\n      for (let v of demo) {\n        await doInsert(v);\n      }\n      log('Demo tree created. Try inserting, searching, deleting, and running traversals.');\n    })();\n\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Binary Search Tree (BST).\n\n**Project Overview:**\nTopic: Binary Search Tree (BST)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "BST Visualizer - Interactive Application",
      "description": "Finite state machine modeling user interactions, animations and processing flow of a Binary Search Tree visualizer (insert, search, delete, traversals, bulk fills, step-by-step mode and view controls).",
      "states": [
        {
          "name": "idle",
          "onEnter": "renderTree / ready UI",
          "on": {
            "INSERT_CLICK": "inserting",
            "INPUT_ENTER": "inserting",
            "SEARCH_CLICK": "searching",
            "DELETE_CLICK": "deleting",
            "INORDER_CLICK": "traversing",
            "PREORDER_CLICK": "traversing",
            "POSTORDER_CLICK": "traversing",
            "RANDOM_CLICK": "bulk_inserting",
            "DEMO_CLICK": "bulk_inserting",
            "CLEAR_CLICK": "clearing",
            "FIT_CLICK": "fitting",
            "STEP_TOGGLE": "idle",
            "NODE_CLICK": "idle",
            "RESIZE": "idle"
          }
        },
        {
          "name": "inserting",
          "onEnter": "doInsert(valueInput) -> start insertion algorithm and render path",
          "onExit": "renderTree(final) (animate final positions)",
          "on": {
            "PATH_ANIM_STARTED": "inserting",
            "WAIT_FOR_STEP": "step_wait",
            "DUPLICATE_DETECTED": "idle",
            "INSERT_ANIM_DONE": "idle",
            "INSERT_ERROR": "idle"
          }
        },
        {
          "name": "searching",
          "onEnter": "doSearch(valueInput) -> compute path and animate",
          "onExit": "clear transient highlights",
          "on": {
            "PATH_ANIM_STARTED": "searching",
            "WAIT_FOR_STEP": "step_wait",
            "SEARCH_FOUND": "idle",
            "SEARCH_NOT_FOUND": "idle",
            "SEARCH_ERROR": "idle"
          }
        },
        {
          "name": "deleting",
          "onEnter": "doDelete(valueInput) -> compute path, animate deletion; may perform transplant or in-order successor swap",
          "onExit": "renderTree(final) (animate final positions and removal)",
          "on": {
            "PATH_ANIM_STARTED": "deleting",
            "WAIT_FOR_STEP": "step_wait",
            "DELETE_NOT_FOUND": "idle",
            "SWAP_REQUIRED": "swapping",
            "DELETE_COMPLETE": "idle",
            "DELETE_ERROR": "idle"
          }
        },
        {
          "name": "swapping",
          "onEnter": "animate swap/replacement (in-order successor replacement) and update node values",
          "onExit": "remove swapped-out node / cleanup highlights",
          "on": {
            "WAIT_FOR_STEP": "step_wait",
            "SWAP_DONE": "deleting",
            "SWAP_ERROR": "deleting"
          }
        },
        {
          "name": "traversing",
          "onEnter": "animateTraversal(sequence) -> highlight nodes in visit order and log sequence",
          "onExit": "clear traversal highlights",
          "on": {
            "WAIT_FOR_STEP": "step_wait",
            "TRAVERSAL_DONE": "idle",
            "TRAVERSAL_ERROR": "idle"
          }
        },
        {
          "name": "bulk_inserting",
          "onEnter": "doSequenceInsert(sequence) -> run multiple doInsert calls (Random / Demo)",
          "onExit": "renderTree(final)",
          "on": {
            "WAIT_FOR_STEP": "step_wait",
            "BULK_STEP": "bulk_inserting",
            "BULK_DONE": "idle",
            "BULK_ERROR": "idle"
          }
        },
        {
          "name": "step_wait",
          "onEnter": "waitOrStep() -> pause animation progress until user confirmation (canvas click or Enter) when stepMode is ON",
          "onExit": "resume previous operation / continue animation",
          "on": {
            "STEP_CONFIRM": "RESUME_PREVIOUS",
            "STEP_CANCEL": "RESUME_PREVIOUS",
            "TIMEOUT": "RESUME_PREVIOUS"
          }
        },
        {
          "name": "fitting",
          "onEnter": "fit view (fitBtn action): adjust preserveAspectRatio, scroll to origin, log",
          "onExit": "idle",
          "on": {
            "FIT_DONE": "idle"
          }
        },
        {
          "name": "clearing",
          "onEnter": "clear tree data (tree.root = null), clear SVG and logs, log 'Cleared tree.'",
          "onExit": "idle",
          "on": {
            "CLEARED": "idle"
          }
        }
      ],
      "events": [
        "INSERT_CLICK",
        "INPUT_ENTER",
        "SEARCH_CLICK",
        "DELETE_CLICK",
        "INORDER_CLICK",
        "PREORDER_CLICK",
        "POSTORDER_CLICK",
        "RANDOM_CLICK",
        "DEMO_CLICK",
        "CLEAR_CLICK",
        "FIT_CLICK",
        "STEP_TOGGLE",
        "NODE_CLICK",
        "RESIZE",
        "PATH_ANIM_STARTED",
        "WAIT_FOR_STEP",
        "STEP_CONFIRM",
        "STEP_CANCEL",
        "INSERT_ANIM_DONE",
        "DUPLICATE_DETECTED",
        "INSERT_ERROR",
        "SEARCH_FOUND",
        "SEARCH_NOT_FOUND",
        "SEARCH_ERROR",
        "DELETE_NOT_FOUND",
        "SWAP_REQUIRED",
        "SWAP_DONE",
        "DELETE_COMPLETE",
        "DELETE_ERROR",
        "TRAVERSAL_DONE",
        "TRAVERSAL_ERROR",
        "BULK_STEP",
        "BULK_DONE",
        "BULK_ERROR",
        "FIT_DONE",
        "CLEARED",
        "TIMEOUT",
        "RESUME_PREVIOUS"
      ],
      "notes": "Implementation notes and mapping details:\n- stepMode is a persistent mode toggle (STEP_TOGGLE) that changes behavior of waitOrStep: when ON, animations call WAIT_FOR_STEP and transition into step_wait. step_wait waits for STEP_CONFIRM (canvas click or Enter) then emits RESUME_PREVIOUS to continue the operation.\n- Asynchronous actions (doInsert, doSearch, doDelete, animateTraversal, bulk insert) are started in onEnter of their states and will emit events to drive transitions (e.g., INSERT_ANIM_DONE, SEARCH_FOUND/NOT_FOUND, SWAP_REQUIRED/SWAP_DONE, TRAVERSAL_DONE, BULK_DONE). These are conceptual events representing completion/error of async animation/logic.\n- NODE_CLICK does not change visual state beyond setting the input value (remains idle). Keyboard shortcuts (i, c, Enter) map to existing events (INPUT_ENTER, CLEAR_CLICK etc.).\n- Rendering and animation lifecycle: renderTree is used onEnter / onExit to create/update SVG elements; element fade/removal is asynchronous and is considered part of the animation sequences (covered by *_ANIM_DONE events).\n- The state machine uses a conceptual 'RESUME_PREVIOUS' event to denote returning from step_wait to the operation state; an implementation can store a history/stack to continue the interrupted promise/animation where it left off.\n- Errors and exceptional outcomes (INSERT_ERROR, SEARCH_ERROR, DELETE_ERROR, etc.) return to idle and log a message.\n- UI interactions that are instantaneous (FIT_CLICK, CLEAR_CLICK, STEP_TOGGLE, NODE_CLICK) are modeled as transient transitions back to idle after performing their onEnter actions."
    }
  },
  {
    "id": "16ed79e0-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:28:05.876Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Binary Tree",
    "answer": {
      "role": "assistant",
      "content": "Concept Title:\nBinary Tree — Structure & Traversals (interactive)\n\nLearning Objective:\nAfter using this module, the learner will be able to:\n- Build a binary tree by adding left/right children,\n- Visually identify root, internal nodes, and leaves,\n- Observe and understand preorder, inorder, postorder, and level-order traversals via animated step-by-step highlights,\n- See how tree height and node count change as the tree is modified.\n\nInteraction Design:\n- Build & Modify\n  - Add Root: When no tree exists, the \"Add Root\" control lets the user add the root node with a value (text/numeric). \n  - Add Child: Click a node to reveal an inline control offering \"Add Left\" and \"Add Right\". Those buttons create children (only if the chosen child slot is empty). The user can type a value before adding.\n  - Delete: The node action panel also exposes a \"Delete\" button that removes the node and its entire subtree (with a confirmation).\n- Layout & Movement\n  - The layout is automatically computed and updated on each tree change. Nodes reposition smoothly using CSS transitions so users can visually track structural changes (animation reinforces the concept of hierarchical layout).\n- Traversal Animations (visual feedback)\n  - Buttons for Preorder, Inorder, Postorder, and Level-order produce animated traversals:\n    - Nodes highlight one-by-one in traversal order (scale + color pulse).\n    - A textual sequence output at the bottom shows the order as chips appear in realtime.\n    - The current step is also shown with a short explanatory sentence (e.g., \"Visiting node 5 — now exploring left subtree\").\n  - Traversal can be paused or cleared.\n- Accessibility & Controls\n  - All interactive controls are keyboard-accessible and have aria-labels. Colors use good contrast; animation timings short and adjustable (a small speed slider is provided).\n- Reinforcement\n  - Node count and tree height update live to connect structural changes with tree properties.\n\nLayout Description:\n- Safe area: 24px padding around the whole viewport to maintain breathing room.\n- Two-column responsive layout:\n  - Left column (control panel, ~320px or 100% on narrow screens):\n    - Title and objective text on top.\n    - Controls: value input, Add Root button, traversal controls, speed slider, stats (node count & height), traversal output chips.\n    - Spacing: 16px minimum between interactive controls.\n  - Right column (visualization, flexible):\n    - Large SVG canvas that renders the tree. The canvas centers the tree horizontally and vertically within its area.\n    - Nodes are arranged using an in-order horizontal layout and depth-based vertical spacing.\n    - Each node is a group (<g>) containing a circle and label; connectors are smooth curved paths.\n- Balance & Focus:\n  - The control panel has compact text; the visualization area uses generous space, so the user's focus is the animated tree.\n  - Colors and emphasis: active nodes use a bright accent; disabled controls are muted.\n- Responsiveness:\n  - On narrow screens the layout stacks: visualization becomes full width under the control panel.\n  - All touch interactions (tap) are supported; larger tap targets are used.\n- Accessibility:\n  - Focus outlines, aria labels, and keyboard support for primary actions.\n  - Contrast-conscious palette.\n\nImplementation (self-contained HTML/CSS/JS):\nBelow is a single-file implementation. Open in any modern browser. It uses only vanilla HTML, CSS and JavaScript; no external assets.\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Binary Tree — Traversals & Structure</title>\n  <style>\n    :root{\n      --safe:24px;\n      --gap:16px;\n      --accent:#0b84ff;\n      --bg:#0f1720;\n      --panel:#0b1220;\n      --muted:#9aa6b2;\n      --success:#2ec4b6;\n      --danger:#ff6b6b;\n      --node-size:44px;\n      --level-gap:90px;\n      --duration:400ms;\n    }\n    *{box-sizing:border-box}\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,#08121a,#071018);color:#e6eef6;font-family:Inter,Segoe UI,Roboto,system-ui,-apple-system,Arial; -webkit-font-smoothing:antialiased;}\n    main{padding:var(--safe);display:flex;gap:var(--gap);min-height:100vh;}\n    /* Left Control Panel */\n    .panel{\n      width:320px;min-width:280px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:20px;box-shadow:0 6px 24px rgba(2,6,23,0.6);display:flex;flex-direction:column;gap:14px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .title{font-size:18px;font-weight:600;color:#fff;margin-bottom:4px}\n    .subtitle{font-size:13px;color:var(--muted);line-height:1.35}\n    .controls{display:flex;flex-direction:column;gap:12px;margin-top:4px}\n    label.input{display:flex;gap:8px;align-items:center}\n    input[type=\"text\"]{flex:1;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#e6eef6;}\n    button{background:var(--accent);color:white;padding:8px 10px;border-radius:8px;border:0;font-weight:600;cursor:pointer;}\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}\n    .row{display:flex;gap:8px}\n    .small{font-size:13px;color:var(--muted)}\n    .stats{display:flex;gap:12px;align-items:center}\n    .chip{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;font-weight:600;color:#dbe8ff;border:1px solid rgba(255,255,255,0.02)}\n    /* Traversal output */\n    .output{min-height:44px;display:flex;flex-wrap:wrap;gap:8px;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008));border:1px solid rgba(255,255,255,0.02)}\n    .chip.out{background:linear-gradient(90deg,var(--accent),#5fb3ff);color:#02213a;padding:6px 10px;border-radius:999px;font-weight:700}\n    .controls-footer{display:flex;flex-direction:column;gap:8px;margin-top:6px}\n    .speed{display:flex;align-items:center;gap:8px}\n    input[type=\"range\"]{width:100%}\n    /* Right Visualization area */\n    .vis{\n      flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));border-radius:12px;padding:18px;display:flex;flex-direction:column;gap:12px;min-height:360px;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.03)\n    }\n    .canvas-wrap{flex:1;display:flex;align-items:center;justify-content:center;min-height:300px;position:relative}\n    svg{width:100%;height:100%;display:block}\n    /* node styles */\n    .node circle{fill:#041227;stroke:rgba(255,255,255,0.06);stroke-width:2;transition:transform var(--duration) ease, stroke var(--duration) ease, fill var(--duration) ease;}\n    .node text{fill:#dbe8ff;font-size:14px;font-weight:700;pointer-events:none}\n    .node{cursor:pointer;transition:transform var(--duration) ease;transform-origin:center}\n    .node:hover circle{stroke:var(--accent);filter:drop-shadow(0 6px 14px rgba(11,132,255,0.18))}\n    .node:focus{outline:2px dashed rgba(11,132,255,0.18);outline-offset:6px}\n    .node.active circle{fill:var(--accent);stroke:#00284d;transform:scale(1.12)}\n    .connector{fill:none;stroke:rgba(255,255,255,0.06);stroke-width:2}\n    .connector.active{stroke:var(--accent);stroke-width:3}\n    /* popover panel for node actions */\n    .node-panel{position:absolute;background:#07121a;border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:8px;display:flex;gap:8px;box-shadow:0 8px 20px rgba(2,6,23,0.6);z-index:40}\n    .node-panel button{padding:6px 8px;font-size:13px}\n    /* small helpers */\n    .muted{color:var(--muted);font-size:13px}\n    .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}\n    .danger{background:var(--danger);border:0;color:white}\n    /* responsive */\n    @media (max-width:880px){\n      main{flex-direction:column;padding:16px}\n      .panel{width:100%}\n    }\n    /* transitions for SVG groups (via transform attr) */\n    g.node{transition:transform var(--duration) ease;}\n  </style>\n</head>\n<body>\n  <main>\n    <section class=\"panel\" aria-labelledby=\"title\">\n      <div>\n        <div id=\"title\" class=\"title\">Binary Tree — Structure & Traversals</div>\n        <div class=\"subtitle\">Interactively build a binary tree. Add left/right children, delete subtrees, then watch animated traversals (preorder, inorder, postorder, level-order).</div>\n      </div>\n\n      <div class=\"controls\" aria-live=\"polite\">\n        <div class=\"input\">\n          <label class=\"small\" for=\"nodeValue\">Node value</label>\n          <input id=\"nodeValue\" type=\"text\" placeholder=\"e.g. 5\" aria-label=\"Node value\" />\n        </div>\n\n        <div class=\"row\">\n          <button id=\"addRootBtn\">Add Root</button>\n          <button id=\"clearBtn\" class=\"ghost\" title=\"Clear entire tree\">Clear</button>\n        </div>\n\n        <div style=\"display:flex;gap:8px;align-items:center;\">\n          <div style=\"font-weight:700\">Traversals</div>\n          <div class=\"muted\" style=\"margin-left:auto;font-size:13px\">Speed</div>\n        </div>\n\n        <div class=\"controls-grid\">\n          <button data-trav=\"preorder\" class=\"ghost\" id=\"preBtn\">Preorder</button>\n          <button data-trav=\"inorder\" class=\"ghost\" id=\"inBtn\">Inorder</button>\n          <button data-trav=\"postorder\" class=\"ghost\" id=\"postBtn\">Postorder</button>\n          <button data-trav=\"level\" class=\"ghost\" id=\"levelBtn\">Level-order</button>\n        </div>\n\n        <div class=\"speed small\">\n          <input id=\"speedRange\" type=\"range\" min=\"200\" max=\"1400\" step=\"100\" value=\"600\" aria-label=\"Traversal speed\" />\n          <div id=\"speedLabel\" class=\"muted\" style=\"min-width:68px;text-align:right\">600ms</div>\n        </div>\n\n        <div class=\"stats\">\n          <div class=\"chip\" id=\"countChip\">Nodes: 0</div>\n          <div class=\"chip\" id=\"heightChip\">Height: 0</div>\n        </div>\n\n        <div>\n          <div class=\"small\" style=\"margin-bottom:6px\">Traversal output</div>\n          <div id=\"output\" class=\"output\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n        </div>\n\n        <div class=\"controls-footer\">\n          <div class=\"muted\">Tip: Click a node to add a left/right child or delete its subtree. Dragging is not required — layout updates smoothly so you can follow structure changes.</div>\n        </div>\n      </div>\n    </section>\n\n    <section class=\"vis\" aria-label=\"Tree visualization\">\n      <div class=\"canvas-wrap\">\n        <svg id=\"svg\" viewBox=\"0 0 1200 700\" preserveAspectRatio=\"xMidYMid meet\" role=\"img\" aria-label=\"Binary tree canvas\">\n          <defs>\n            <filter id=\"shadow\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\n              <feDropShadow dx=\"0\" dy=\"8\" stdDeviation=\"12\" flood-color=\"rgba(0,0,0,0.6)\"/>\n            </filter>\n          </defs>\n          <g id=\"connectors\"></g>\n          <g id=\"nodes\"></g>\n        </svg>\n      </div>\n      <!-- node action popover (hidden until needed) -->\n      <div id=\"nodePanel\" class=\"node-panel\" style=\"display:none\" role=\"dialog\" aria-hidden=\"true\">\n        <button id=\"addLeft\" title=\"Add left child\">Add Left</button>\n        <button id=\"addRight\" title=\"Add right child\">Add Right</button>\n        <button id=\"deleteNode\" class=\"danger\" title=\"Delete node\">Delete</button>\n      </div>\n    </section>\n  </main>\n\n  <script>\n    // Simple interactive Binary Tree module (vanilla JS)\n    (function(){\n      // DOM\n      const svg = document.getElementById('svg');\n      const nodesG = document.getElementById('nodes');\n      const connectorsG = document.getElementById('connectors');\n      const addRootBtn = document.getElementById('addRootBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const output = document.getElementById('output');\n      const nodeValueInput = document.getElementById('nodeValue');\n      const countChip = document.getElementById('countChip');\n      const heightChip = document.getElementById('heightChip');\n      const nodePanel = document.getElementById('nodePanel');\n      const addLeftBtn = document.getElementById('addLeft');\n      const addRightBtn = document.getElementById('addRight');\n      const deleteNodeBtn = document.getElementById('deleteNode');\n      const speedRange = document.getElementById('speedRange');\n      const speedLabel = document.getElementById('speedLabel');\n      const preBtn = document.getElementById('preBtn');\n      const inBtn = document.getElementById('inBtn');\n      const postBtn = document.getElementById('postBtn');\n      const levelBtn = document.getElementById('levelBtn');\n\n      let state = {\n        nodes: {}, // id -> node {id, value, left, right, parent}\n        root: null,\n        nextId: 1\n      };\n\n      let layout = {\n        width: 1100,\n        height: 650,\n        marginX: 40,\n        marginY: 40,\n        nodeSize: 44,\n        levelGap: 90\n      };\n\n      let panelTarget = null; // node id for nodePanel actions\n      let traversalTimer = null;\n\n      // utilities\n      function genId(){ return 'n'+(state.nextId++); }\n      function getNode(id){ return state.nodes[id] || null; }\n      function textVal(){ return nodeValueInput.value.trim() || null; }\n\n      // Add node helper\n      function createNode(value){\n        const id = genId();\n        state.nodes[id] = { id, value: value===null? id : value, left: null, right: null, parent: null };\n        return state.nodes[id];\n      }\n\n      // Attach child (left/right) to parentId. Returns node created or null on fail.\n      function attachChild(parentId, side, value){\n        const parent = getNode(parentId);\n        if(!parent) return null;\n        if(side==='left' && parent.left) return null;\n        if(side==='right' && parent.right) return null;\n        const node = createNode(value);\n        node.parent = parentId;\n        if(side==='left') parent.left = node.id;\n        else parent.right = node.id;\n        return node;\n      }\n\n      // Delete subtree rooted at id\n      function deleteSubtree(id){\n        const node = getNode(id);\n        if(!node) return;\n        // detach from parent\n        if(node.parent){\n          const p = getNode(node.parent);\n          if(p.left===id) p.left = null;\n          if(p.right===id) p.right = null;\n        } else {\n          state.root = null;\n        }\n        // delete recursively\n        (function del(nid){\n          const n = getNode(nid);\n          if(!n) return;\n          if(n.left) del(n.left);\n          if(n.right) del(n.right);\n          delete state.nodes[nid];\n        })(id);\n      }\n\n      // Clear tree\n      function clearTree(){\n        state.nodes = {};\n        state.root = null;\n        state.nextId = 1;\n        render();\n      }\n\n      // Layout: compute x positions using inorder traversal index\n      function computeLayout(){\n        const nodes = state.nodes;\n        let positions = {}; // id -> {x,y,depth}\n        let xIndex = 0;\n        function inorder(id, depth){\n          if(!id) return;\n          const n = nodes[id];\n          inorder(n.left, depth+1);\n          const x = xIndex++;\n          positions[id] = { xIndex: x, depth: depth };\n          inorder(n.right, depth+1);\n        }\n        if(state.root) inorder(state.root, 0);\n        // Map xIndex to pixel x\n        const totalLeaves = Math.max(1, xIndex);\n        const width = layout.width - layout.marginX*2;\n        const stepX = width / Math.max(1, totalLeaves);\n        for(const id in positions){\n          positions[id].x = layout.marginX + positions[id].xIndex * stepX + stepX/2;\n          positions[id].y = layout.marginY + positions[id].depth * layout.levelGap + 30;\n        }\n        return positions;\n      }\n\n      // Compute height and count\n      function computeStats(){\n        let count = 0, maxDepth = -1;\n        function dfs(id, depth){\n          if(!id) return;\n          count++;\n          maxDepth = Math.max(maxDepth, depth);\n          const n = getNode(id);\n          dfs(n.left, depth+1);\n          dfs(n.right, depth+1);\n        }\n        if(state.root) dfs(state.root, 0);\n        return {count, height: Math.max(0, maxDepth+1)};\n      }\n\n      // Render connectors and nodes\n      function render(){\n        // clear\n        while(connectorsG.firstChild) connectorsG.removeChild(connectorsG.firstChild);\n        while(nodesG.firstChild) nodesG.removeChild(nodesG.firstChild);\n        output.innerHTML = '';\n        // compute positions\n        const pos = computeLayout();\n        // draw connectors first (lines from parent to child)\n        for(const id in state.nodes){\n          const n = state.nodes[id];\n          if(n.left){\n            drawConnector(pos[id], pos[n.left], id, n.left);\n          }\n          if(n.right){\n            drawConnector(pos[id], pos[n.right], id, n.right);\n          }\n        }\n        // draw nodes\n        for(const id in state.nodes){\n          const n = state.nodes[id];\n          const p = pos[id];\n          const g = createNodeGroup(n, p);\n          nodesG.appendChild(g);\n        }\n        // update stats\n        const s = computeStats();\n        countChip.textContent = 'Nodes: ' + s.count;\n        heightChip.textContent = 'Height: ' + s.height;\n      }\n\n      function drawConnector(p1, p2, pid, cid){\n        if(!p1 || !p2) return;\n        const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n        // cubic bezier for a smooth connector\n        const dx = Math.abs(p2.x - p1.x);\n        const midX = (p1.x + p2.x)/2;\n        const controlY = (p1.y + p2.y)/2;\n        const d = `M ${p1.x} ${p1.y+18} C ${midX} ${p1.y+18} ${midX} ${p2.y-18} ${p2.x} ${p2.y-18}`;\n        path.setAttribute('d', d);\n        path.setAttribute('class','connector');\n        path.dataset.from = pid;\n        path.dataset.to = cid;\n        connectorsG.appendChild(path);\n      }\n\n      function createNodeGroup(node, pos){\n        const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n        g.setAttribute('class','node');\n        g.setAttribute('data-id', node.id);\n        g.setAttribute('tabindex','0');\n        const size = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-size')) || 44;\n        g.style.transform = `translate(${pos.x}px, ${pos.y}px)`;\n        // visual circle\n        const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');\n        circ.setAttribute('r', size/2);\n        circ.setAttribute('cx', 0);\n        circ.setAttribute('cy', 0);\n        // label\n        const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n        txt.setAttribute('x', 0);\n        txt.setAttribute('y', 5);\n        txt.setAttribute('text-anchor', 'middle');\n        txt.textContent = node.value;\n        g.appendChild(circ);\n        g.appendChild(txt);\n\n        // event handlers\n        g.addEventListener('click', (e)=>{\n          e.stopPropagation();\n          openNodePanel(node.id, pos);\n        });\n        g.addEventListener('keydown', (e)=>{\n          if(e.key === 'Enter' || e.key === ' '){\n            e.preventDefault();\n            openNodePanel(node.id, pos);\n          }\n        });\n\n        return g;\n      }\n\n      // Node action panel (floating HTML)\n      function openNodePanel(nodeId, pos){\n        panelTarget = nodeId;\n        const node = getNode(nodeId);\n        nodePanel.style.display = 'flex';\n        nodePanel.setAttribute('aria-hidden','false');\n        // position panel in svg coordinates -> transform to page\n        const svgRect = svg.getBoundingClientRect();\n        const x = svgRect.left + pos.x;\n        const y = svgRect.top + pos.y;\n        // position with offsets\n        nodePanel.style.left = (x + 20) + 'px';\n        nodePanel.style.top = (y - 20) + 'px';\n        // enable/disable add buttons depending on child existence\n        addLeftBtn.disabled = !!node.left;\n        addRightBtn.disabled = !!node.right;\n      }\n\n      // close panel on canvas click\n      document.addEventListener('click', (e)=>{\n        if(nodePanel.style.display !== 'none'){\n          nodePanel.style.display = 'none';\n          nodePanel.setAttribute('aria-hidden','true');\n          panelTarget = null;\n        }\n      });\n\n      addRootBtn.addEventListener('click', ()=>{\n        if(state.root){\n          alert('Root already exists. To replace, clear the tree first.');\n          return;\n        }\n        const val = textVal() || 'root';\n        const node = createNode(val);\n        state.root = node.id;\n        render();\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        if(confirm('Clear the entire tree?')){\n          clearTree();\n        }\n      });\n\n      addLeftBtn.addEventListener('click', (e)=>{\n        e.stopPropagation();\n        if(!panelTarget) return;\n        const val = textVal() || '';\n        const node = attachChild(panelTarget, 'left', val || null);\n        if(!node) { alert('Left child already exists.'); return; }\n        nodePanel.style.display = 'none';\n        render();\n      });\n      addRightBtn.addEventListener('click', (e)=>{\n        e.stopPropagation();\n        if(!panelTarget) return;\n        const val = textVal() || '';\n        const node = attachChild(panelTarget, 'right', val || null);\n        if(!node) { alert('Right child already exists.'); return; }\n        nodePanel.style.display = 'none';\n        render();\n      });\n\n      deleteNodeBtn.addEventListener('click', (e)=>{\n        e.stopPropagation();\n        if(!panelTarget) return;\n        if(!confirm('Delete this node and its subtree?')) return;\n        deleteSubtree(panelTarget);\n        nodePanel.style.display = 'none';\n        render();\n      });\n\n      // Traversal implementations (returns array of node ids)\n      function preorder(id, out=[]){\n        if(!id) return out;\n        out.push(id);\n        const n = getNode(id);\n        preorder(n.left, out);\n        preorder(n.right, out);\n        return out;\n      }\n      function inorder(id, out=[]){\n        if(!id) return out;\n        const n = getNode(id);\n        inorder(n.left, out);\n        out.push(id);\n        inorder(n.right, out);\n        return out;\n      }\n      function postorder(id, out=[]){\n        if(!id) return out;\n        const n = getNode(id);\n        postorder(n.left, out);\n        postorder(n.right, out);\n        out.push(id);\n        return out;\n      }\n      function levelorder(id){\n        const out = [];\n        if(!id) return out;\n        const q = [id];\n        while(q.length){\n          const cur = q.shift();\n          out.push(cur);\n          const n = getNode(cur);\n          if(n.left) q.push(n.left);\n          if(n.right) q.push(n.right);\n        }\n        return out;\n      }\n\n      // Utility to highlight nodes sequentially with animation\n      function animateTraversal(seq, valuesSeq){\n        clearTraversalAnimation();\n        if(seq.length===0) return;\n        const delay = parseInt(speedRange.value) || 600;\n        let i = 0;\n        function step(){\n          if(i>0){\n            const prev = document.querySelector('g.node[data-id=\"'+seq[i-1]+'\"]');\n            if(prev) prev.classList.remove('active');\n            // mark connector to next as active\n            const con = connectorsG.querySelector('path[data-from=\"'+seq[i-1]+'\"][data-to=\"'+seq[i]+'\"]');\n            if(con) con.classList.remove('active');\n          }\n          if(i >= seq.length){\n            // done\n            return;\n          }\n          const id = seq[i];\n          const g = document.querySelector('g.node[data-id=\"'+id+'\"]');\n          if(g){\n            g.classList.add('active');\n            // if coming from parent, mark connector\n            if(i>0){\n              const con = connectorsG.querySelector('path[data-from=\"'+seq[i-1]+'\"][data-to=\"'+id+'\"]');\n              if(con) con.classList.add('active');\n            }\n            // add to output chips\n            const chip = document.createElement('div');\n            chip.className = 'chip out';\n            chip.textContent = valuesSeq[i];\n            output.appendChild(chip);\n            // scroll output into view if necessary\n            output.scrollTop = output.scrollHeight;\n          }\n          i++;\n          traversalTimer = setTimeout(step, delay);\n        }\n        step();\n      }\n\n      function clearTraversalAnimation(){\n        if(traversalTimer) { clearTimeout(traversalTimer); traversalTimer = null; }\n        // clear active classes\n        document.querySelectorAll('g.node.active').forEach(el => el.classList.remove('active'));\n        connectorsG.querySelectorAll('path.active').forEach(el => el.classList.remove('active'));\n        // clear output chips\n        output.innerHTML = '';\n      }\n\n      // attach traversal button handlers\n      preBtn.addEventListener('click', ()=>runTraversal('preorder'));\n      inBtn.addEventListener('click', ()=>runTraversal('inorder'));\n      postBtn.addEventListener('click', ()=>runTraversal('postorder'));\n      levelBtn.addEventListener('click', ()=>runTraversal('level'));\n\n      function runTraversal(kind){\n        if(!state.root){ alert('Tree is empty. Add nodes first.'); return; }\n        clearTraversalAnimation();\n        let seqIds = [];\n        if(kind==='preorder') seqIds = preorder(state.root, []);\n        if(kind==='inorder') seqIds = inorder(state.root, []);\n        if(kind==='postorder') seqIds = postorder(state.root, []);\n        if(kind==='level') seqIds = levelorder(state.root);\n        // map ids to values for display\n        const valuesSeq = seqIds.map(id => getNode(id).value);\n        animateTraversal(seqIds, valuesSeq);\n      }\n\n      // speed control\n      speedRange.addEventListener('input', ()=>{\n        speedLabel.textContent = speedRange.value + 'ms';\n      });\n\n      // Resize handling: adjust svg viewBox width/height if container changes\n      function updateLayoutSize(){\n        const rect = svg.getBoundingClientRect();\n        // set layout width/height based on viewBox target values\n        // we keep constant viewBox, but re-render with layout adjustment if required\n      }\n      window.addEventListener('resize', updateLayoutSize);\n\n      // initial render\n      render();\n\n      // clicking empty canvas hides nodePanel and clears traversal highlight\n      svg.addEventListener('click', (e)=>{\n        clearTraversalAnimation();\n      });\n\n      // helper: clicking a connector toggles highlight for demonstration (optional)\n      connectorsG.addEventListener('click', (e)=>{\n        if(e.target.tagName === 'path'){\n          e.target.classList.toggle('active');\n        }\n      });\n\n      // Initialize sample tree for first-time demonstration (optional)\n      (function seedExample(){\n        const a = createNode('A');\n        state.root = a.id;\n        const b = attachChild(a.id,'left','B');\n        const c = attachChild(a.id,'right','C');\n        attachChild(b.id,'left','D');\n        attachChild(b.id,'right','E');\n        attachChild(c.id,'right','F');\n        render();\n      })();\n\n      // keyboard accessibility: Esc closes nodePanel\n      document.addEventListener('keydown', (e)=>{\n        if(e.key === 'Escape'){\n          nodePanel.style.display = 'none';\n          nodePanel.setAttribute('aria-hidden','true');\n        }\n      });\n\n    })();\n  </script>\n</body>\n</html>\n```\n\nNotes:\n- This single-file module focuses on one core concept — the Binary Tree structure and traversals — and makes the connection between operations (add/delete) and traversal behavior explicit through animated feedback.\n- The layout obeys the requested safe area (24px) and minimum spacing (16px) and adapts to different viewport sizes.\n- No external libraries or assets are used; everything is implemented with vanilla HTML, CSS, and JavaScript."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Binary Tree.\n\n**Project Overview:**\nTopic: Binary Tree\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Binary Tree"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Binary Tree — Traversals & Structure",
      "description": "Models the interactive states of the binary-tree UI: building / editing the tree (root/children/deletes), showing the node action popover, running animated traversals, and confirmation flows.",
      "states": [
        {
          "name": "idle",
          "onEnter": "render",
          "onExit": "",
          "on": {
            "CLICK_ADD_ROOT": "idle",
            "CLICK_CLEAR": "confirmingClear",
            "OPEN_NODE_PANEL": "nodePanelOpen",
            "RUN_TRAVERSAL_PREORDER": "traversalPlaying",
            "RUN_TRAVERSAL_INORDER": "traversalPlaying",
            "RUN_TRAVERSAL_POSTORDER": "traversalPlaying",
            "RUN_TRAVERSAL_LEVEL": "traversalPlaying",
            "CLICK_CANVAS": "idle",
            "CONNECTOR_TOGGLE": "idle",
            "SPEED_CHANGE": "idle"
          }
        },
        {
          "name": "nodePanelOpen",
          "onEnter": "openNodePanel (sets panelTarget, positions panel, enable/disable add buttons)",
          "onExit": "closeNodePanel (hide panel, clear panelTarget)",
          "on": {
            "CLICK_ADD_LEFT": "idle",
            "CLICK_ADD_RIGHT": "idle",
            "CLICK_DELETE_NODE": "confirmingDelete",
            "CLOSE_NODE_PANEL": "idle",
            "DOC_CLICK_CLOSE_PANEL": "idle",
            "ESCAPE_PRESSED": "idle",
            "RUN_TRAVERSAL_PREORDER": "traversalPlaying",
            "RUN_TRAVERSAL_INORDER": "traversalPlaying",
            "RUN_TRAVERSAL_POSTORDER": "traversalPlaying",
            "RUN_TRAVERSAL_LEVEL": "traversalPlaying"
          }
        },
        {
          "name": "confirmingClear",
          "onEnter": "showConfirmDialog('Clear entire tree?')",
          "onExit": "hideConfirmDialog",
          "on": {
            "CONFIRM_CLEAR_OK": "idle",
            "CONFIRM_CLEAR_CANCEL": "idle"
          }
        },
        {
          "name": "confirmingDelete",
          "onEnter": "showConfirmDialog('Delete this node and its subtree?')",
          "onExit": "hideConfirmDialog",
          "on": {
            "CONFIRM_DELETE_OK": "idle",
            "CONFIRM_DELETE_CANCEL": "nodePanelOpen"
          }
        },
        {
          "name": "traversalPlaying",
          "onEnter": "animateTraversal (compute sequence, clear previous animation, start timer, add active classes, append output chips)",
          "onExit": "clearTraversalAnimation (clear timer, remove active classes, clear output)",
          "on": {
            "TRAVERSAL_FINISHED": "idle",
            "CLICK_CANVAS": "idle",
            "CLEAR_TRAVERSAL": "idle",
            "RUN_TRAVERSAL_PREORDER": "traversalPlaying",
            "RUN_TRAVERSAL_INORDER": "traversalPlaying",
            "RUN_TRAVERSAL_POSTORDER": "traversalPlaying",
            "RUN_TRAVERSAL_LEVEL": "traversalPlaying",
            "CLICK_ADD_LEFT": "nodePanelOpen",
            "CLICK_ADD_RIGHT": "nodePanelOpen",
            "CLICK_DELETE_NODE": "confirmingDelete"
          }
        }
      ],
      "events": [
        "CLICK_ADD_ROOT",
        "ADD_ROOT_CREATED",
        "ADD_ROOT_REJECTED",
        "CLICK_CLEAR",
        "CONFIRM_CLEAR_OK",
        "CONFIRM_CLEAR_CANCEL",
        "OPEN_NODE_PANEL",
        "CLOSE_NODE_PANEL",
        "DOC_CLICK_CLOSE_PANEL",
        "ESCAPE_PRESSED",
        "CLICK_ADD_LEFT",
        "CLICK_ADD_RIGHT",
        "ATTACH_CHILD_SUCCESS",
        "ATTACH_CHILD_FAIL",
        "CLICK_DELETE_NODE",
        "CONFIRM_DELETE_OK",
        "CONFIRM_DELETE_CANCEL",
        "RUN_TRAVERSAL_PREORDER",
        "RUN_TRAVERSAL_INORDER",
        "RUN_TRAVERSAL_POSTORDER",
        "RUN_TRAVERSAL_LEVEL",
        "TRAVERSAL_STARTED",
        "TRAVERSAL_FINISHED",
        "CLICK_CANVAS",
        "CLEAR_TRAVERSAL",
        "SPEED_CHANGE",
        "CONNECTOR_TOGGLE"
      ],
      "notes": "Guards and side-effects: many event handlers perform checks and browser modal calls (alert/confirm). Examples:\n- CLICK_ADD_ROOT leads to creation only if no root exists; otherwise an alert is shown. (Modeled as ADD_ROOT_CREATED / ADD_ROOT_REJECTED outcomes.)\n- CLICK_CLEAR and CLICK_DELETE_NODE open native confirmation dialogs; CONFIRM_* events represent the user's response.\n- Node-panel actions (ADD LEFT / ADD RIGHT / DELETE) close the panel and call render() on success; failed attempts show alerts and leave state unchanged.\n- Traversal buttons can be pressed from both idle and while the node panel is open; the traversalPlaying state is entered from either state. animateTraversal is started on entering traversalPlaying and is stopped by TRAVERSAL_FINISHED, CLICK_CANVAS, or CLEAR_TRAVERSAL. Re-triggering a traversal while one is running restarts the animation (transition to traversalPlaying again).\n- onEnter/onExit actions reference concrete functions in the code: render(), openNodePanel(), closeNodePanel(), createNode()/attachChild()/deleteSubtree(), animateTraversal(), clearTraversalAnimation(), showConfirmDialog/hideConfirmDialog, update speed label.  \n- Connector toggles are per-connector visual toggles and do not change the primary application state; represented as CONNECTOR_TOGGLE event.\n- The FSM is simplified to a single-threaded state model. In the implementation the node-panel and traversal animation overlap (panel may remain visible during traversal); this model allows traversalPlaying to be entered from nodePanelOpen or idle, and returns to idle by default after finishing. If a confirm dialog is active, it blocks JS until resolved (native confirm), so confirming states are modeled explicitly."
    }
  },
  {
    "id": "21a9e3a0-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:28:16.221Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Heap (Min/Max)",
    "answer": {
      "role": "assistant",
      "content": "Concept Title:\nHeap (Min/Max) — Interactive Array + Tree Visualization with Step-by-Step Operations\n\nLearning Objective:\nAfter interacting with this module, users will:\n- Understand how a binary heap is represented as an array and as a binary tree.\n- Observe the difference between min-heap and max-heap behavior.\n- See how insert (sift-up) and extract (sift-down) work, step-by-step with comparisons and swaps.\n- Practice building a heap from an arbitrary list (heapify) and recognize bottom-up heap construction.\n\nInteraction Design:\n- Controls:\n  - Number input + \"Insert\" button (or press Enter) — inserts value into the heap and animates sift-up.\n  - \"Extract\" button — removes root (min or max depending on mode) and animates sift-down.\n  - \"Peek\" button — highlights root without modifying the heap.\n  - \"Random\" button — inserts a random value.\n  - Textarea + \"Build Heap\" — enter comma/space-separated numbers, then build heap via bottom-up heapify with animations (option to animate each swap).\n  - Toggle switch \"Min / Max\" — flips heap comparator; existing heap will be reinterpreted (rebuild) with animated heapify to reflect the new ordering.\n  - Speed slider — controls animation speed.\n  - Step Mode toggle — when enabled, operations step through each compare/swap; \"Next Step\" button advances.\n- Visual Feedback & Animations:\n  - Both tree and array views update together. Each node is a circular element positioned to visually represent the binary tree. Array boxes appear in row form.\n  - During operations, nodes being compared are highlighted (yellow), the chosen swap is highlighted (orange), and final positions flash (green).\n  - Swaps are animated with smooth position transitions (CSS transitions) so the viewer can follow node movement.\n  - A log area describes each compare/swap/action; it is an ARIA-live region for screen readers.\n  - When in Step Mode, each compare or swap is paused until the user clicks \"Next Step\".\n- Interaction Reinforcement:\n  - Watching the same operation in two representations (tree + array) simultaneously reinforces the array-index <-> tree-parent/children mapping.\n  - Color-coded comparisons and swaps reveal the direction of sift-up (toward root) and sift-down (toward leaves).\n  - Toggle between min/max demonstrates how comparator changes behavior across same data.\n\nLayout Description:\n- Safe area: The whole module is padded 24px on all sides (CSS body padding).\n- Overall layout: a responsive two-column layout for large screens and a stacked layout for small screens.\n  - Left column (visual) — tree visualization on top and array visualization below it.\n  - Right column (controls & logs) — controls at the top, operation buttons grouped clearly (16px spacing), speed and toggles below, then the Step controls, then the operation log.\n- Spacing & sizing:\n  - Minimum spacing between interactive elements is 16px.\n  - Buttons and inputs have accessible sizes and focus outlines.\n  - Tree container is horizontally centered with responsive node spacing; nodes size scales slightly with container width to remain legible.\n- Accessibility & Responsiveness:\n  - All controls have labels. Keyboard support: input Enter to insert, buttons have visible focus states, Step \"Next\" is keyboard-accessible.\n  - ARIA-live log updates describe actions.\n  - Colors chosen for good contrast; animations can be disabled by setting animation speed to minimum.\n- Visual balance:\n  - Title and objective at top center, then a balanced layout of visual area left and control panel right.\n  - Visual area uses absolute positioning for clarity, with the array below aligned to the same left edge.\n\nSelf-contained Implementation\nBelow is a single HTML file implementing the interactive module. Paste it into a file (e.g., heap.html) and open in a browser.\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Heap (Min/Max) Interactive</title>\n  <style>\n    :root{\n      --safe-padding: 24px;\n      --gap: 16px;\n      --node-size: 48px;\n      --node-font: 14px;\n      --transition: 400ms;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      padding:var(--safe-padding);\n      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;\n      background:#f7f9fc;\n      color:#0b2545;\n      box-sizing:border-box;\n    }\n    *{box-sizing:border-box}\n    header{\n      text-align:center;\n      margin-bottom:var(--gap);\n    }\n    h1{\n      margin:0 0 6px 0;\n      font-size:20px;\n    }\n    p.objective{\n      margin:0;\n      color:#234170;\n      opacity:.9;\n      font-size:13px;\n    }\n    .container{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n    }\n    /* Responsive: stack on narrow screens */\n    @media (max-width:980px){\n      .container{flex-direction:column;}\n    }\n    .visual{\n      flex:1 1 60%;\n      min-width:280px;\n      background:linear-gradient(180deg,#ffffff,#f2f7ff);\n      border:1px solid #dbe8ff;\n      padding:var(--gap);\n      border-radius:12px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .controls{\n      flex:0 0 360px;\n      min-width:240px;\n      background:#fff;\n      border:1px solid #e6eef8;\n      padding:var(--gap);\n      border-radius:12px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      height:fit-content;\n    }\n    /* Visual area parts */\n    .tree-area{\n      position:relative;\n      height:320px;\n      border-radius:8px;\n      background:linear-gradient(180deg,#fcfeff,#f8fbff);\n      border:1px dashed #e3eefb;\n      overflow:hidden;\n    }\n    .tree-canvas{\n      position:absolute;\n      inset:0;\n      padding:16px;\n    }\n    .node{\n      position:absolute;\n      width:var(--node-size);\n      height:var(--node-size);\n      border-radius:50%;\n      background:#2b7be4;\n      color:white;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:600;\n      font-size:var(--node-font);\n      box-shadow:0 6px 12px rgba(43,123,228,0.18);\n      transition: transform var(--transition) ease, left var(--transition) ease, top var(--transition) ease, background-color 180ms;\n      transform-origin:center;\n      z-index:10;\n    }\n    .node.small{ width:40px; height:40px; font-size:12px; }\n    .node.compare{ background:#ffc857; color:#1b1b1b; box-shadow:0 6px 14px rgba(255,200,87,0.18); }\n    .node.swap{ background:#ff7b54; color:white; box-shadow:0 10px 18px rgba(255,123,84,0.22); }\n    .node.done{ background:#3ddc97; color:white; }\n    .edge{\n      position:absolute;\n      height:2px;\n      background:rgba(11,37,69,0.12);\n      transform-origin:left center;\n      z-index:2;\n    }\n    /* array view */\n    .array-view{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      align-items:center;\n      padding:8px;\n      border-radius:6px;\n      background:linear-gradient(180deg,#fff,#fcfdff);\n      border:1px solid #eef6ff;\n      min-height:64px;\n    }\n    .array-item{\n      min-width:48px;\n      height:40px;\n      border-radius:6px;\n      background:#ffffff;\n      border:1px solid #cfe1ff;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:600;\n      color:#1a3a66;\n      transition: transform var(--transition) ease, background-color 240ms, border-color 240ms;\n    }\n    .array-item.compare{ background:#fff4d6; border-color:#ffd27a; color:#1b1b1b; }\n    .array-item.swap{ background:#ffd6d0; border-color:#ff8d80; color:#1b1b1b; }\n    .array-label{ font-size:12px; color:#4a6b95; margin-bottom:6px; }\n    /* controls: forms */\n    .group{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n    input[type=\"number\"], input[type=\"text\"], textarea{\n      padding:8px;\n      border-radius:8px;\n      border:1px solid #d7e8ff;\n      outline:none;\n      font-size:14px;\n      color:#0b2545;\n      background:#fbfdff;\n    }\n    textarea{ min-height:56px; resize:vertical; width:100%; }\n    button{\n      padding:8px 12px;\n      border-radius:8px;\n      border:1px solid transparent;\n      background:#2b7be4;\n      color:white;\n      font-weight:600;\n      cursor:pointer;\n      transition:transform 120ms;\n    }\n    button.secondary{\n      background:#fff;\n      color:#234170;\n      border-color:#d9e9ff;\n    }\n    button.ghost{\n      background:transparent;\n      color:#234170;\n      border:1px dashed #cfe1ff;\n    }\n    button:active{ transform:translateY(1px); }\n    .toggle{\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n      padding:6px;\n    }\n    .small-btn{ padding:6px 8px; font-size:13px; border-radius:8px; }\n    .muted{ color:#4a6b95; font-size:13px; }\n    .log{\n      background:#0b254530;\n      border:1px solid #e7f0ff;\n      padding:12px;\n      border-radius:8px;\n      font-family:monospace;\n      font-size:13px;\n      color:#08203b;\n      min-height:120px;\n      overflow:auto;\n    }\n    .controls .section-title{\n      margin:0;\n      font-size:13px;\n      color:#17427a;\n      font-weight:700;\n    }\n    .controls .hint{ font-size:12px; color:#4a6b95; }\n    .controls footer{ font-size:12px; color:#5d7aa6; text-align:center; margin-top:6px; }\n    .flex-col{ display:flex; flex-direction:column; gap:8px; }\n    .row{ display:flex; gap:8px; align-items:center; }\n    .speed-row{ display:flex; align-items:center; gap:8px; }\n    input[type=\"range\"]{ width:140px; }\n    /* responsive tweaks */\n    @media (max-width:480px){\n      :root{ --node-size:40px; --node-font:12px; }\n      .tree-area{ height:260px; }\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Heap (Min/Max) — Interactive Visualization</h1>\n    <p class=\"objective\">Insert, Extract, and Build heaps while watching array ↔ tree mappings and animated sift-up/sift-down.</p>\n  </header>\n\n  <main class=\"container\" role=\"main\">\n    <section class=\"visual\" aria-label=\"Heap visualization area\">\n      <div class=\"tree-area\" id=\"treeArea\" aria-hidden=\"false\">\n        <div class=\"tree-canvas\" id=\"treeCanvas\"></div>\n      </div>\n\n      <div>\n        <div class=\"array-label\">Array representation (indices 0 ... n-1)</div>\n        <div class=\"array-view\" id=\"arrayView\" aria-live=\"polite\"></div>\n      </div>\n    </section>\n\n    <aside class=\"controls\" aria-label=\"Controls for heap operations\">\n      <div class=\"flex-col\">\n        <div class=\"section-title\">Operations</div>\n        <div class=\"group\" role=\"form\" aria-label=\"Insert value\">\n          <input id=\"valueInput\" type=\"number\" step=\"1\" placeholder=\"Value to insert\" aria-label=\"Value to insert\" />\n          <button id=\"insertBtn\">Insert</button>\n          <button id=\"randBtn\" class=\"secondary\">Random</button>\n        </div>\n\n        <div class=\"group\" aria-label=\"Other operations\">\n          <button id=\"extractBtn\" class=\"small-btn\">Extract Root</button>\n          <button id=\"peekBtn\" class=\"small-btn secondary\">Peek</button>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Build / Rebuild</div>\n          <div class=\"hint\">Enter numbers separated by commas or spaces</div>\n          <textarea id=\"buildInput\" placeholder=\"e.g. 5, 3, 8, 1, 2\"></textarea>\n          <div class=\"group\">\n            <button id=\"buildBtn\">Build Heap</button>\n            <button id=\"clearBtn\" class=\"ghost\">Clear</button>\n          </div>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Mode & Speed</div>\n          <div class=\"group\">\n            <label class=\"toggle\">\n              <input type=\"checkbox\" id=\"modeToggle\" aria-label=\"Toggle min max\" />\n              <span class=\"muted\">Max-Heap</span>\n            </label>\n            <div class=\"speed-row\" title=\"Animation speed (lower = faster)\">\n              <label class=\"muted\">Speed</label>\n              <input id=\"speedRange\" type=\"range\" min=\"50\" max=\"1200\" value=\"400\" />\n              <span id=\"speedLabel\" class=\"muted\">400ms</span>\n            </div>\n          </div>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Step Mode</div>\n          <div class=\"hint\">Enable to step through compares/swaps</div>\n          <div class=\"group\">\n            <label class=\"toggle\"><input type=\"checkbox\" id=\"stepToggle\" /> <span class=\"muted\">Step Mode</span></label>\n            <button id=\"nextStepBtn\" class=\"small-btn secondary\" disabled>Next Step</button>\n          </div>\n        </div>\n\n        <div>\n          <div class=\"section-title\">Logs</div>\n          <div id=\"log\" class=\"log\" role=\"log\" aria-live=\"polite\"></div>\n        </div>\n\n        <footer>Tip: Press Enter in the value box to insert. Toggle Min/Max to see behavior change.</footer>\n      </div>\n    </aside>\n  </main>\n\n  <script>\n    (function(){\n      // Basic configuration\n      const state = {\n        heap: [],\n        isMin: true,\n        animDuration: 400,\n        stepMode: false,\n        pendingSteps: [],\n        stepping: false\n      };\n\n      // DOM references\n      const treeCanvas = document.getElementById('treeCanvas');\n      const arrayView = document.getElementById('arrayView');\n      const insertBtn = document.getElementById('insertBtn');\n      const extractBtn = document.getElementById('extractBtn');\n      const randBtn = document.getElementById('randBtn');\n      const valueInput = document.getElementById('valueInput');\n      const buildBtn = document.getElementById('buildBtn');\n      const buildInput = document.getElementById('buildInput');\n      const clearBtn = document.getElementById('clearBtn');\n      const modeToggle = document.getElementById('modeToggle'); // checked => Max-Heap\n      const speedRange = document.getElementById('speedRange');\n      const speedLabel = document.getElementById('speedLabel');\n      const stepToggle = document.getElementById('stepToggle');\n      const nextStepBtn = document.getElementById('nextStepBtn');\n      const logEl = document.getElementById('log');\n\n      // Utility: log\n      function log(msg){\n        const time = new Date().toLocaleTimeString();\n        logEl.textContent = `${time} — ${msg}\\n` + logEl.textContent;\n      }\n\n      // Utility: comparator based on state.isMin\n      function cmp(a,b){\n        return state.isMin ? (a < b) : (a > b);\n      }\n\n      // DOM creation helpers\n      function createNodeEl(value, idx){\n        const el = document.createElement('div');\n        el.className = 'node';\n        el.textContent = String(value);\n        el.dataset.index = idx;\n        return el;\n      }\n      function createArrayItem(value, idx){\n        const el = document.createElement('div');\n        el.className = 'array-item';\n        el.textContent = String(value);\n        el.dataset.index = idx;\n        el.title = `index ${idx}`;\n        return el;\n      }\n\n      // Layout computation: compute positions for nodes based on index\n      function computePositions(containerWidth, index){\n        // level, position within level\n        const level = Math.floor(Math.log2(index + 1));\n        const levelStart = Math.pow(2, level) - 1;\n        const posInLevel = index - levelStart;\n        const itemsInLevel = Math.pow(2, level);\n        const padding = 16;\n        const availableWidth = Math.max(100, containerWidth - padding * 2);\n        // compute x spacing so nodes in this level are evenly spaced\n        const gap = availableWidth / (itemsInLevel);\n        const x = padding + gap * posInLevel + gap/2 - (getNodeSize()/2);\n        const yGap = 72; // vertical spacing per level\n        const y = padding + level * yGap;\n        return {x, y, level};\n      }\n\n      function getNodeSize(){\n        // read computed CSS var or fallback\n        const s = getComputedStyle(document.documentElement).getPropertyValue('--node-size');\n        return parseFloat(s) || 48;\n      }\n\n      // Visual update: rebuild DOM nodes to match heap array\n      function render(){\n        // clear canvas edges and nodes\n        treeCanvas.innerHTML = '';\n        arrayView.innerHTML = '';\n\n        const containerWidth = treeCanvas.clientWidth;\n        const size = getNodeSize();\n        const n = state.heap.length;\n\n        // Create node elements\n        const nodeEls = [];\n        for(let i=0;i<n;i++){\n          const v = state.heap[i];\n          const el = createNodeEl(v, i);\n          el.style.width = size + 'px';\n          el.style.height = size + 'px';\n          el.style.lineHeight = size + 'px';\n          el.style.transitionDuration = state.animDuration + 'ms';\n          el.setAttribute('aria-label', `node ${v} at index ${i}`);\n          treeCanvas.appendChild(el);\n          nodeEls.push(el);\n        }\n\n        // create and position edges first (so they appear behind)\n        for(let i=0;i<n;i++){\n          const left = 2*i+1;\n          const right = 2*i+2;\n          const parentPos = computePositions(containerWidth, i);\n          const parentX = parentPos.x + size/2;\n          const parentY = parentPos.y + size/2;\n          [left,right].forEach(childIdx=>{\n            if(childIdx < n){\n              const childPos = computePositions(containerWidth, childIdx);\n              const childX = childPos.x + size/2;\n              const childY = childPos.y + size/2;\n              const dx = childX - parentX;\n              const dy = childY - parentY;\n              const length = Math.sqrt(dx*dx + dy*dy);\n              const angle = Math.atan2(dy, dx) * 180 / Math.PI;\n              const edge = document.createElement('div');\n              edge.className = 'edge';\n              edge.style.width = length + 'px';\n              edge.style.left = parentX + 'px';\n              edge.style.top = parentY + 'px';\n              edge.style.transform = `rotate(${angle}deg)`;\n              treeCanvas.appendChild(edge);\n            }\n          });\n        }\n\n        // position nodes (absolute left/top)\n        for(let i=0;i<n;i++){\n          const el = nodeEls[i];\n          const pos = computePositions(containerWidth, i);\n          el.style.left = pos.x + 'px';\n          el.style.top = pos.y + 'px';\n          el.dataset.index = i;\n        }\n\n        // Create array view items\n        for(let i=0;i<n;i++){\n          const item = createArrayItem(state.heap[i], i);\n          item.style.transitionDuration = state.animDuration + 'ms';\n          arrayView.appendChild(item);\n        }\n      }\n\n      // Helpers to highlight node and array items\n      function highlightCompare(i,j){\n        // i or j may be null (for root compare)\n        const nodes = treeCanvas.querySelectorAll('.node');\n        nodes.forEach(n => n.classList.remove('compare'));\n        if (i!=null) {\n          const el = treeCanvas.querySelector(`.node[data-index=\"${i}\"]`);\n          if(el) el.classList.add('compare');\n        }\n        if (j!=null) {\n          const el = treeCanvas.querySelector(`.node[data-index=\"${j}\"]`);\n          if(el) el.classList.add('compare');\n        }\n        const arrayItems = arrayView.querySelectorAll('.array-item');\n        arrayItems.forEach(a => a.classList.remove('compare'));\n        if(i!=null){\n          const a = arrayView.querySelector(`.array-item[data-index=\"${i}\"]`);\n          if(a) a.classList.add('compare');\n        }\n        if(j!=null){\n          const a = arrayView.querySelector(`.array-item[data-index=\"${j}\"]`);\n          if(a) a.classList.add('compare');\n        }\n      }\n      function highlightSwap(i,j){\n        const nodes = treeCanvas.querySelectorAll('.node');\n        nodes.forEach(n => n.classList.remove('swap'));\n        const a = treeCanvas.querySelector(`.node[data-index=\"${i}\"]`);\n        const b = treeCanvas.querySelector(`.node[data-index=\"${j}\"]`);\n        if(a) a.classList.add('swap');\n        if(b) b.classList.add('swap');\n        const arrayItems = arrayView.querySelectorAll('.array-item');\n        arrayItems.forEach(x => x.classList.remove('swap'));\n        const aa = arrayView.querySelector(`.array-item[data-index=\"${i}\"]`);\n        const bb = arrayView.querySelector(`.array-item[data-index=\"${j}\"]`);\n        if(aa) aa.classList.add('swap');\n        if(bb) bb.classList.add('swap');\n      }\n      function clearHighlights(){\n        treeCanvas.querySelectorAll('.node').forEach(n => {\n          n.classList.remove('compare','swap','done');\n        });\n        arrayView.querySelectorAll('.array-item').forEach(a=>{\n          a.classList.remove('compare','swap');\n        });\n      }\n\n      // Swap visual by swapping dataset indices then re-render movement\n      function animateSwap(i,j,instant=false){\n        return new Promise(resolve=>{\n          // swap values in model\n          const temp = state.heap[i]; state.heap[i] = state.heap[j]; state.heap[j] = temp;\n          // re-render but keep same nodes: we'll rebuild fully for simplicity and rely on transitions\n          render();\n          if(instant || state.animDuration===0){\n            setTimeout(()=>resolve(),10);\n          } else {\n            setTimeout(()=>resolve(), state.animDuration + 20);\n          }\n        });\n      }\n\n      // Step queue system\n      function enqueueStep(fn){\n        state.pendingSteps.push(fn);\n        if(!state.stepping && !state.stepMode){\n          // if not stepping, drain immediately\n          processSteps();\n        } else {\n          updateNextButton();\n        }\n      }\n      async function processSteps(){\n        if(state.stepping) return;\n        state.stepping = true;\n        while(state.pendingSteps.length){\n          if(state.stepMode){\n            // wait for user to click Next\n            updateNextButton(true);\n            await new Promise(res=>{\n              state._resolveNext = res;\n            });\n            updateNextButton(false);\n          }\n          const stepFn = state.pendingSteps.shift();\n          await stepFn();\n        }\n        state.stepping = false;\n        updateNextButton(false);\n      }\n      function updateNextButton(disabledWhenIdle=false){\n        nextStepBtn.disabled = !(state.stepMode) || !(state.pendingSteps.length>0) || (disabledWhenIdle && state.stepping===false);\n      }\n      nextStepBtn.addEventListener('click', ()=>{\n        if(state._resolveNext) state._resolveNext();\n      });\n\n      // Core heap operations with animation steps\n      function siftUpAnimated(idx){\n        enqueueStep(async ()=>{\n          let i = idx;\n          while(i>0){\n            const parent = Math.floor((i-1)/2);\n            log(`Compare: node ${state.heap[i]} (idx ${i}) with parent ${state.heap[parent]} (idx ${parent})`);\n            highlightCompare(i,parent);\n            await waitCompare();\n            if(cmp(state.heap[i], state.heap[parent])){\n              log(`Swap: ${state.heap[i]} <-> ${state.heap[parent]}`);\n              highlightSwap(i,parent);\n              await waitSwap();\n              await animateSwap(i,parent);\n              // continue up — after swap indices changed\n              i = parent;\n            } else {\n              break;\n            }\n          }\n          clearHighlights();\n          // mark done root of this action\n          renderDone();\n        });\n        processSteps();\n      }\n\n      function siftDownAnimated(startIdx){\n        enqueueStep(async ()=>{\n          let i = startIdx;\n          const n = state.heap.length;\n          while(true){\n            const left = 2*i + 1;\n            const right = 2*i + 2;\n            let candidate = i;\n            if(left < n){\n              log(`Compare child ${state.heap[left]} (idx ${left}) with parent ${state.heap[candidate]} (idx ${candidate})`);\n              highlightCompare(left, candidate);\n              await waitCompare();\n              if(cmp(state.heap[left], state.heap[candidate])) candidate = left;\n            }\n            if(right < n){\n              log(`Compare child ${state.heap[right]} (idx ${right}) with candidate ${state.heap[candidate]} (idx ${candidate})`);\n              highlightCompare(right, candidate);\n              await waitCompare();\n              if(cmp(state.heap[right], state.heap[candidate])) candidate = right;\n            }\n            if(candidate !== i){\n              log(`Swap: ${state.heap[i]} (idx ${i}) with ${state.heap[candidate]} (idx ${candidate})`);\n              highlightSwap(i, candidate);\n              await waitSwap();\n              await animateSwap(i, candidate);\n              i = candidate;\n            } else {\n              break;\n            }\n          }\n          clearHighlights();\n          renderDone();\n        });\n        processSteps();\n      }\n\n      // Wait helpers that obey step mode and speed\n      function waitCompare(){\n        return new Promise(resolve=>{\n          if(state.stepMode){\n            enqueueUserAction(resolve);\n          } else {\n            setTimeout(resolve, Math.max(80, state.animDuration/2));\n          }\n        });\n      }\n      function waitSwap(){\n        return new Promise(resolve=>{\n          if(state.stepMode){\n            enqueueUserAction(resolve);\n          } else {\n            setTimeout(resolve, state.animDuration);\n          }\n        });\n      }\n      function enqueueUserAction(resolve){\n        // Push a wrapper to pending that resolves when Next is pressed — we actually want to pause the operation\n        state.pendingSteps.unshift(async ()=>{\n          // This wrapper is a no-op used to pause; but we need to call resolve and continue\n          resolve();\n        });\n        processSteps();\n      }\n\n      function renderDone(){\n        // flash root or last modified nodes\n        treeCanvas.querySelectorAll('.node').forEach(n => n.classList.add('done'));\n        setTimeout(()=> treeCanvas.querySelectorAll('.node').forEach(n => n.classList.remove('done')), 600);\n      }\n\n      // Public ops\n      function insertValue(v){\n        log(`Insert requested: ${v}`);\n        state.heap.push(v);\n        render();\n        siftUpAnimated(state.heap.length - 1);\n      }\n\n      function extractRoot(){\n        if(state.heap.length===0){\n          log('Heap is empty.');\n          return;\n        }\n        log(`Extract root: ${state.heap[0]}`);\n        // swap root with last, pop, then sift-down from root\n        if(state.heap.length === 1){\n          const val = state.heap.pop();\n          render();\n          renderDone();\n          log(`Removed lone element ${val}`);\n          return;\n        }\n        // animate swap root with last and then removal\n        enqueueStep(async ()=>{\n          highlightSwap(0, state.heap.length - 1);\n          await waitSwap();\n          await animateSwap(0, state.heap.length - 1);\n          // pop last\n          const removed = state.heap.pop();\n          render();\n          log(`Popped ${removed}, now sift-down from root`);\n        });\n        // then sift-down\n        siftDownAnimated(0);\n        processSteps();\n      }\n\n      function peekRoot(){\n        if(state.heap.length===0){\n          log('Heap is empty.');\n          return;\n        }\n        const v = state.heap[0];\n        log(`Peek root: ${v}`);\n        highlightCompare(0,null);\n        setTimeout(()=>clearHighlights(), 600);\n      }\n\n      function buildHeapFromArray(arr){\n        state.heap = arr.slice();\n        render();\n        // bottom-up heapify\n        const n = state.heap.length;\n        const starts = [];\n        for(let i = Math.floor(n/2)-1; i >=0; i--){\n          starts.push(i);\n        }\n        // schedule each sift-down\n        enqueueStep(async ()=>{\n          log(`Building heap from array: [${state.heap.join(', ')}]`);\n        });\n        starts.forEach(i => {\n          enqueueStep(async ()=> {\n            log(`Heapify: sift-down from index ${i} (value ${state.heap[i]})`);\n            await new Promise(res => setTimeout(res, 40));\n            await new Promise(resolve => {\n              // reuse siftDownAnimated but as synchronous part of the queue\n              siftDownAnimated(i);\n              // siftDownAnimated enqueues its own steps; so we just wait a small time here\n              setTimeout(resolve, 10);\n            });\n          });\n        });\n        processSteps();\n      }\n\n      // UI bindings\n      insertBtn.addEventListener('click', ()=>{\n        const v = valueInput.value.trim();\n        if(v === '') return;\n        insertValue(Number(v));\n        valueInput.value = '';\n        valueInput.focus();\n      });\n      valueInput.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter'){\n          insertBtn.click();\n          e.preventDefault();\n        }\n      });\n      randBtn.addEventListener('click', ()=>{\n        const r = Math.floor(Math.random()*99) - 9; // -9..89\n        insertValue(r);\n      });\n      extractBtn.addEventListener('click', extractRoot);\n      peekBtn.addEventListener('click', peekRoot);\n      buildBtn.addEventListener('click', ()=>{\n        const raw = buildInput.value.trim();\n        if(!raw) return;\n        const arr = raw.split(/[\\s,]+/).map(x => Number(x)).filter(x=>!Number.isNaN(x));\n        if(arr.length === 0) return;\n        buildHeapFromArray(arr);\n      });\n      clearBtn.addEventListener('click', ()=>{\n        state.heap = [];\n        render();\n        log('Heap cleared.');\n      });\n      modeToggle.addEventListener('change', ()=>{\n        state.isMin = !modeToggle.checked; // checked => Max => isMin = false\n        log(`Mode changed: ${state.isMin ? 'Min-Heap' : 'Max-Heap'}. Rebuilding heap to new comparator.`);\n        // Rebuild by performing heapify on current array to reflect new comparator\n        enqueueStep(async ()=>{\n          // Just perform bottom-up heapify\n          render();\n        });\n        buildHeapFromArray(state.heap.slice());\n      });\n      speedRange.addEventListener('input', ()=>{\n        const val = Number(speedRange.value);\n        state.animDuration = val;\n        speedLabel.textContent = val + 'ms';\n        // apply to nodes\n        document.querySelectorAll('.node, .array-item').forEach(el => {\n          el.style.transitionDuration = val + 'ms';\n        });\n      });\n      stepToggle.addEventListener('change', ()=>{\n        state.stepMode = stepToggle.checked;\n        if(!state.stepMode){\n          // if disabling step mode, drain steps automatically\n          processSteps();\n        } else {\n          updateNextButton();\n        }\n        log(`Step Mode ${state.stepMode ? 'enabled' : 'disabled'}`);\n      });\n      nextStepBtn.addEventListener('click', ()=>{\n        // handled earlier\n      });\n\n      // initial render\n      render();\n\n      // expose some helpers for swapping visually when array changes\n      // Also, keep window resize re-render for layout adjustments\n      window.addEventListener('resize', ()=>{\n        render();\n      });\n\n      // initial sample heap\n      (function seed(){\n        const sample = [7, 3, 9, 1, 5];\n        state.heap = [];\n        sample.forEach(v => insertValue(v));\n      })();\n\n      // small accessibility announcements\n      function announce(msg){\n        // log already is ARIA-live; echo\n        log(msg);\n      }\n\n      // Public small helpers\n      function wait(ms){ return new Promise(res => setTimeout(res, ms)); }\n\n      // ---- internal: ensure processSteps drains when non-step mode\n      // Already handled in enqueueStep/processSteps\n\n    })();\n  </script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Heap (Min/Max).\n\n**Project Overview:**\nTopic: Heap (Min/Max)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Heap (Min/Max)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Heap Interactive Application",
      "description": "Models the interactive states and transitions of the Heap (Min/Max) visualization UI including user operations (insert, extract, build, peek, clear), animation steps (compare / swap), step-mode behavior (wait for Next), and processing of the internal pending step queue.",
      "states": [
        {
          "name": "idle",
          "onEnter": "render; updateNextButton",
          "onExit": "none",
          "on": {
            "CLICK_INSERT": "inserting",
            "CLICK_RANDOM": "inserting",
            "KEY_ENTER_INSERT": "inserting",
            "CLICK_EXTRACT": "extracting",
            "CLICK_PEEK": "peeking",
            "CLICK_BUILD": "building",
            "CLICK_CLEAR": "clearing",
            "TOGGLE_MODE": "mode_rebuilding",
            "TOGGLE_STEP_MODE": "idle",
            "SPEED_CHANGE": "idle",
            "WINDOW_RESIZE": "idle"
          }
        },
        {
          "name": "inserting",
          "onEnter": "insertValue (push to model; render; enqueue siftUp step)",
          "onExit": "none",
          "on": {
            "ENQUEUE_STEP": "processing",
            "PROCESS_STEPS_START": "processing"
          }
        },
        {
          "name": "extracting",
          "onEnter": "extractRoot (enqueue swap/pop and siftDown steps; render as appropriate)",
          "onExit": "none",
          "on": {
            "ENQUEUE_STEP": "processing",
            "PROCESS_STEPS_START": "processing"
          }
        },
        {
          "name": "peeking",
          "onEnter": "peekRoot (highlightCompare(0,null); log; schedule clearHighlights)",
          "onExit": "clearHighlights",
          "on": {
            "ANIMATION_END": "idle",
            "TIMER_EXPIRE": "idle"
          }
        },
        {
          "name": "building",
          "onEnter": "buildHeapFromArray (set model array; render; enqueue bottom-up siftDown steps)",
          "onExit": "none",
          "on": {
            "ENQUEUE_STEP": "processing",
            "PROCESS_STEPS_START": "processing"
          }
        },
        {
          "name": "clearing",
          "onEnter": "clear heap model; render; log",
          "onExit": "none",
          "on": {
            "DONE": "idle"
          }
        },
        {
          "name": "mode_rebuilding",
          "onEnter": "toggle comparator (state.isMin) and enqueue rebuild (buildHeapFromArray) ; render; log",
          "onExit": "none",
          "on": {
            "ENQUEUE_STEP": "processing",
            "PROCESS_STEPS_START": "processing"
          }
        },
        {
          "name": "processing",
          "onEnter": "processSteps (set stepping=true; drain state.pendingSteps)",
          "onExit": "set stepping=false; updateNextButton(false)",
          "on": {
            "STEP_WAIT_REQUIRED": "waiting_for_next",
            "COMPARE_START": "comparing",
            "SWAP_START": "swapping",
            "PROCESS_STEPS_COMPLETE": "idle",
            "ENQUEUE_STEP": "processing",
            "TOGGLE_STEP_MODE_OFF": "processing"
          }
        },
        {
          "name": "waiting_for_next",
          "onEnter": "updateNextButton(true); pause processing until CLICK_NEXT_STEP (resolve pending wait)",
          "onExit": "updateNextButton(false)",
          "on": {
            "CLICK_NEXT_STEP": "processing",
            "TOGGLE_STEP_MODE": "processing",
            "STEP_MODE_DISABLED": "processing"
          }
        },
        {
          "name": "comparing",
          "onEnter": "highlightCompare(i,j); waitCompare (either auto timeout or enqueueUserAction)",
          "onExit": "clearHighlights",
          "on": {
            "COMPARE_COMPLETE": "processing",
            "STEP_WAIT_REQUIRED": "waiting_for_next"
          }
        },
        {
          "name": "swapping",
          "onEnter": "highlightSwap(i,j); waitSwap; animateSwap(i,j)",
          "onExit": "clearHighlights",
          "on": {
            "SWAP_COMPLETE": "processing",
            "STEP_WAIT_REQUIRED": "waiting_for_next"
          }
        },
        {
          "name": "done",
          "onEnter": "renderDone (flash done state on nodes)",
          "onExit": "clearHighlights",
          "on": {
            "ANIMATION_END": "idle",
            "TIMER_EXPIRE": "idle"
          }
        }
      ],
      "events": [
        "CLICK_INSERT",
        "CLICK_RANDOM",
        "KEY_ENTER_INSERT",
        "CLICK_EXTRACT",
        "CLICK_PEEK",
        "CLICK_BUILD",
        "CLICK_CLEAR",
        "TOGGLE_MODE",
        "SPEED_CHANGE",
        "TOGGLE_STEP_MODE",
        "CLICK_NEXT_STEP",
        "WINDOW_RESIZE",
        "ENQUEUE_STEP",
        "PROCESS_STEPS_START",
        "PROCESS_STEPS_COMPLETE",
        "STEP_WAIT_REQUIRED",
        "CLICK_NEXT_STEP",
        "COMPARE_START",
        "COMPARE_COMPLETE",
        "SWAP_START",
        "SWAP_COMPLETE",
        "ANIMATION_END",
        "TIMER_EXPIRE",
        "DONE",
        "TOGGLE_STEP_MODE_OFF"
      ],
      "notes": "The app maintains an internal pendingSteps queue and a 'stepping' flag. enqueueStep adds atomic async step functions to pendingSteps. processSteps drains the queue: when stepMode is enabled certain waits (waitCompare/waitSwap) convert to pauses that require user CLICK_NEXT_STEP to resolve. 'comparing' and 'swapping' states represent atomic visual steps (highlight + wait + possible animateSwap). insert/extract/build operations enqueue sequences of compare/swap steps and then trigger processing. Speed changes update animDuration used by animation timers but do not change FSM state. Mode toggle rebuilds heap by enqueueing heapify steps. render/renderDone/clearHighlights/highlightCompare/highlightSwap/animateSwap represent onEnter/onExit actions invoked by states."
    }
  },
  {
    "id": "115ee630-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:28:22.139Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Hash Map",
    "answer": {
      "role": "assistant",
      "content": "Below is a single, self-contained HTML file that includes:\n- The requested planning sections (Concept Title, Learning Objective, Interaction Design, Layout Description) as explanatory text inside the page.\n- A fully interactive Hash Map module (no external libraries/assets) that visualizes insertion, search, and deletion using a simple hash function (sum of character codes modulo bucket count). It includes animations (hash computation, moving nodes, traversal highlighting), accessibility considerations, and responsive layout with the specified safe area and spacing.\n\nYou can copy-paste this into a file named something like hash-map-demo.html and open it in a browser.\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Hash Map Demo</title>\n  <style>\n    :root{\n      --safe: 24px;\n      --gap: 16px;\n      --bg: #0f1720;\n      --panel: #071226;\n      --accent: #06b6d4;\n      --muted: #94a3b8;\n      --success: #16a34a;\n      --danger: #ef4444;\n      --glass: rgba(255,255,255,0.03);\n      --node-bg: linear-gradient(180deg,#0ea5a4 0%, #0284c7 100%);\n      --font-sans: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n    * { box-sizing: border-box; }\n    html,body { height: 100%; }\n    body{\n      margin:0;\n      padding: var(--safe);\n      font-family: var(--font-sans);\n      background: radial-gradient(1200px 600px at 10% 10%, rgba(6,182,212,0.06), transparent),\n                  radial-gradient(900px 450px at 90% 90%, rgba(96,165,250,0.03), transparent),\n                  var(--bg);\n      color: #e6eef6;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      min-height:100vh;\n    }\n    header{\n      display:flex;\n      align-items:flex-start;\n      gap:var(--gap);\n      margin-bottom: var(--gap);\n    }\n    h1{\n      font-size:20px;\n      margin:0;\n      line-height:1.1;\n    }\n    .meta {\n      color:var(--muted);\n      font-size:13px;\n      margin-top:6px;\n    }\n\n    /* Layout */\n    .container {\n      display: grid;\n      grid-template-columns: 420px 1fr;\n      gap: var(--gap);\n      align-items:start;\n    }\n    @media (max-width:920px){\n      .container { grid-template-columns: 1fr; }\n      header { flex-direction:column; align-items:flex-start; }\n    }\n\n    /* Left panel: controls & explanation */\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.04);\n      padding: var(--gap);\n      border-radius: 10px;\n      min-height: 240px;\n    }\n    .section-title { font-weight:600; margin:0 0 8px 0; }\n    .small { font-size:13px; color:var(--muted); line-height:1.4; }\n    label{ display:block; font-size:13px; margin-bottom:6px; color:#dbeafe; }\n    .controls { display:flex; gap:var(--gap); flex-wrap:wrap; align-items:center; margin-top:12px; }\n    input[type=\"text\"], input[type=\"number\"]{\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background: rgba(255,255,255,0.02);\n      color:inherit;\n      min-width:140px;\n    }\n    button {\n      padding:10px 14px;\n      background: linear-gradient(180deg,var(--accent), #0ea5b5);\n      border: none;\n      color: #022; \n      font-weight:600;\n      border-radius:8px;\n      cursor:pointer;\n      transition:transform .12s ease, box-shadow .12s ease;\n    }\n    button.secondary{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--muted);\n    }\n    button:active{ transform:translateY(1px); }\n    .row { display:flex; gap:12px; align-items:center; }\n\n    /* Right panel: visualization */\n    .viz {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.0));\n      border-radius:10px;\n      padding:var(--gap);\n      min-height:420px;\n      border:1px solid rgba(255,255,255,0.04);\n      position:relative;\n      overflow:hidden;\n    }\n    .viz-top{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:var(--gap);\n      margin-bottom:var(--gap);\n    }\n    .controls-inline { display:flex; gap:8px; align-items:center; }\n\n    /* buckets */\n    .buckets {\n      display:flex;\n      gap:18px;\n      flex-wrap:wrap;\n      align-items:flex-start;\n      padding:10px;\n      border-radius:8px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.015), transparent);\n      min-height:220px;\n      position:relative;\n    }\n    .bucket {\n      width:86px;\n      min-height:140px;\n      border-radius:8px;\n      background:var(--glass);\n      border:1px solid rgba(255,255,255,0.03);\n      padding:8px;\n      display:flex;\n      flex-direction:column;\n      align-items:center;\n      gap:8px;\n      position:relative;\n    }\n    .bucket .idx {\n      font-size:12px;\n      color:var(--muted);\n      background: rgba(255,255,255,0.02);\n      padding:4px 8px;\n      border-radius:6px;\n    }\n    .chain {\n      width:100%;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      margin-top:6px;\n      align-items:center;\n      min-height:60px;\n    }\n\n    /* node */\n    .node {\n      background: var(--node-bg);\n      color: #04111a;\n      padding:8px 10px;\n      border-radius:8px;\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      display:inline-flex;\n      gap:8px;\n      align-items:center;\n      justify-content:center;\n      min-width:66px;\n      font-weight:700;\n      transition:transform .35s cubic-bezier(.2,.9,.2,1), opacity .25s linear;\n      cursor:default;\n    }\n    .node .k { font-size:12px; color:#052; opacity:0.85; }\n    .node .v { font-size:12px; color:#052; opacity:0.65; font-weight:600; }\n\n    /* moving clone for animation */\n    .floating {\n      position:absolute;\n      pointer-events:none;\n      z-index:40;\n      will-change:transform, opacity;\n      transition: transform 600ms cubic-bezier(.2,.9,.2,1), opacity 180ms linear;\n    }\n\n    /* traversal highlight */\n    .highlight {\n      box-shadow: 0 0 0 3px rgba(6,182,212,0.12), 0 8px 24px rgba(6,182,212,0.12);\n      transform: translateY(-6px) scale(1.02);\n    }\n    .found {\n      box-shadow: 0 0 0 4px rgba(22,163,74,0.12), 0 10px 30px rgba(16,185,129,0.06);\n    }\n    .notfound {\n      animation: shake .5s ease;\n    }\n    @keyframes shake {\n      0% { transform: translateX(0); }\n      25% { transform: translateX(-8px); }\n      50% { transform: translateX(8px); }\n      75% { transform: translateX(-6px); }\n      100% { transform: translateX(0); }\n    }\n\n    /* hash computation strip */\n    .hash-strip {\n      display:flex;\n      gap:8px;\n      align-items:center;\n      flex-wrap:wrap;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .charbox {\n      width:34px;\n      height:34px;\n      border-radius:6px;\n      background: rgba(255,255,255,0.02);\n      border:1px solid rgba(255,255,255,0.03);\n      display:flex;\n      justify-content:center;\n      align-items:center;\n      font-weight:700;\n    }\n    .charbox .ord{\n      font-size:11px;\n      color:var(--muted);\n      display:block;\n      margin-top:4px;\n      font-weight:600;\n    }\n    .charbox.active {\n      background: linear-gradient(180deg, rgba(6,182,212,0.12), rgba(6,182,212,0.06));\n      border-color: rgba(6,182,212,0.25);\n      transform: translateY(-6px);\n      box-shadow: 0 10px 30px rgba(6,182,212,0.08);\n    }\n\n    .status {\n      font-size:13px;\n      color:var(--muted);\n      margin-top:12px;\n      min-height:18px;\n    }\n\n    /* small helper */\n    .muted { color:var(--muted); font-size:13px; }\n    footer { margin-top: var(--gap); color:var(--muted); font-size:13px; }\n\n    /* ensure spacing at least 16px between interactive elements in controls area */\n    .controls > * { margin:0; }\n  </style>\n</head>\n<body>\n  <header>\n    <div>\n      <h1>Hash Map — interactive visualization</h1>\n      <div class=\"meta\">Visual, step-by-step exploration of how hashing maps keys to buckets and how collisions are handled (separate chaining).</div>\n    </div>\n  </header>\n\n  <div class=\"container\" role=\"main\">\n    <!-- Left: Plan + Controls -->\n    <aside class=\"panel\" aria-labelledby=\"plan-title\">\n      <h2 id=\"plan-title\" class=\"section-title\">Concept & Learning Plan</h2>\n      <p class=\"small\"><strong>Concept Title:</strong> Hash Map (array of buckets + chaining)</p>\n      <p class=\"small\"><strong>Learning Objective:</strong> After interacting, you will understand how a hash function converts keys to bucket indices, how collisions accumulate in chains, and how insert/search/delete operations traverse and modify chains.</p>\n\n      <h3 class=\"section-title\" style=\"margin-top:12px;\">Interaction Design</h3>\n      <p class=\"small\">\n        - Type a key (string) and a value, then Insert. The module animates:\n        a) the per-character hash calculation (ASCII sums), b) modulo reduction to a bucket index, and c) movement of the node into the target bucket's chain.\n        </p>\n      <p class=\"small\">\n        - Search highlights nodes along the chain one-by-one. Found nodes are highlighted in green; not found gives a gentle shake.\n        - Delete traverses then removes the node with a fade/slide animation and repositions remaining nodes.\n        - You can change the bucket count; existing entries will be rehashed and animated to their new buckets.\n      </p>\n\n      <h3 class=\"section-title\" style=\"margin-top:12px;\">Layout Description</h3>\n      <p class=\"small\">\n        - Safe area: 24px on all sides (page padding). Minimum spacing between interactive elements is 16px (CSS gaps and margins).\n        - Left column contains descriptive text and controls (keyboard-accessible inputs and buttons).\n        - Right column is the visualization canvas with a top control strip and the bucket area beneath. The buckets are shown left-to-right and wrap on small screens.\n        - Colors, contrasts, and focusable controls are designed for accessibility. Layout is responsive: the grid becomes a stacked column under 920px width.\n      </p>\n\n      <hr style=\"border:none;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0;\">\n\n      <div>\n        <label for=\"bucketCount\">Buckets (array size): <span id=\"bucket-count-display\">7</span></label>\n        <input id=\"bucketCount\" type=\"range\" min=\"3\" max=\"13\" value=\"7\" aria-label=\"Bucket count slider\" />\n      </div>\n\n      <div style=\"margin-top:12px;\">\n        <label for=\"keyInput\">Key</label>\n        <input id=\"keyInput\" type=\"text\" placeholder=\"e.g. apple\" aria-label=\"Key input\" />\n        <label for=\"valueInput\" style=\"margin-top:8px;\">Value</label>\n        <input id=\"valueInput\" type=\"text\" placeholder=\"e.g. 42\" aria-label=\"Value input\" />\n      </div>\n\n      <div class=\"controls\" style=\"margin-top:12px;\">\n        <button id=\"insertBtn\">Insert</button>\n        <button id=\"searchBtn\" class=\"secondary\">Search</button>\n        <button id=\"deleteBtn\" class=\"secondary\">Delete</button>\n        <button id=\"clearBtn\" class=\"secondary\">Clear</button>\n      </div>\n\n      <div class=\"status\" id=\"status\" aria-live=\"polite\"></div>\n    </aside>\n\n    <!-- Right: Visualization -->\n    <section class=\"viz\" aria-label=\"Hash map visualization\">\n      <div class=\"viz-top\">\n        <div class=\"controls-inline\">\n          <div style=\"font-size:13px; color:var(--muted);\">Buckets:</div>\n          <div id=\"bucketSummary\" class=\"muted\" style=\"min-width:120px;\">0 entries</div>\n        </div>\n\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <div class=\"hash-strip\" id=\"hashStrip\" aria-hidden=\"true\" title=\"Displays per-character ASCII and running sum during hashing\"></div>\n        </div>\n      </div>\n\n      <div class=\"buckets\" id=\"buckets\" role=\"list\" aria-label=\"Buckets area\">\n        <!-- buckets inserted by JS -->\n      </div>\n\n      <footer style=\"opacity:0.9;\">\n        Tip: Try keys that collide (e.g., 'ab' and 'ba' often collide with simple hash). Use the bucket slider to see how bucket count affects collisions.\n      </footer>\n    </section>\n  </div>\n\n  <script>\n    (function(){\n      // Configuration & state\n      const body = document.body;\n      const bucketSlider = document.getElementById('bucketCount');\n      const bucketCountDisplay = document.getElementById('bucket-count-display');\n      const bucketsEl = document.getElementById('buckets');\n      const hashStrip = document.getElementById('hashStrip');\n      const insertBtn = document.getElementById('insertBtn');\n      const searchBtn = document.getElementById('searchBtn');\n      const deleteBtn = document.getElementById('deleteBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const keyInput = document.getElementById('keyInput');\n      const valueInput = document.getElementById('valueInput');\n      const status = document.getElementById('status');\n      const bucketSummary = document.getElementById('bucketSummary');\n\n      let bucketCount = Number(bucketSlider.value);\n      let map = []; // array of arrays: {key, value, id}\n      let uniqueId = 1;\n      let animLock = false;\n\n      // Initialize\n      function init() {\n        bucketCountDisplay.textContent = bucketCount;\n        createBuckets(bucketCount);\n        map = Array.from({length: bucketCount}, () => []);\n        updateSummary();\n      }\n\n      function createBuckets(n) {\n        bucketsEl.innerHTML = '';\n        for (let i=0;i<n;i++){\n          const b = document.createElement('div');\n          b.className = 'bucket';\n          b.dataset.idx = i;\n          b.setAttribute('role','listitem');\n          b.innerHTML = '<div class=\"idx\">index ' + i + '</div><div class=\"chain\" aria-label=\"chain\"></div>';\n          bucketsEl.appendChild(b);\n        }\n      }\n\n      // Hash function: sum of char codes mod bucketCount (simple: pedagogical)\n      function computeHash(key){\n        let sum = 0;\n        for (let i=0;i<key.length;i++){\n          sum += key.charCodeAt(i);\n        }\n        return {sum, idx: (key.length ? (sum % bucketCount) : 0)};\n      }\n\n      // Helpers for UI\n      function setStatus(msg, mode='info'){\n        status.textContent = msg || '';\n        status.style.color = (mode === 'error' ? 'var(--danger)' : mode === 'success' ? 'var(--success)' : 'var(--muted)');\n      }\n      function updateSummary(){\n        const count = map.reduce((s,arr)=>s+arr.length,0);\n        bucketSummary.textContent = count + ' entr' + (count===1? 'y':'ies');\n      }\n\n      // Bucket and node element utilities\n      function getBucketEl(idx){ return bucketsEl.querySelector('.bucket[data-idx=\"'+idx+'\"]'); }\n      function getChainEl(idx){ const b=getBucketEl(idx); return b ? b.querySelector('.chain') : null; }\n\n      function renderChainStatic(idx){\n        const chain = getChainEl(idx);\n        chain.innerHTML = '';\n        const entries = map[idx];\n        entries.forEach(item => {\n          const n = createNodeEl(item);\n          chain.appendChild(n);\n        });\n      }\n\n      function createNodeEl(item){\n        const n = document.createElement('div');\n        n.className = 'node';\n        n.dataset.id = item.id;\n        n.innerHTML = '<span class=\"k\">'+escapeHtml(item.key)+'</span>';\n        const val = document.createElement('span');\n        val.className = 'v';\n        val.textContent = item.value;\n        n.appendChild(val);\n        return n;\n      }\n\n      // Simple escape\n      function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }\n\n      // Animation: hash computation\n      function animateHashComputation(key){\n        return new Promise(resolve => {\n          hashStrip.innerHTML = '';\n          if (!key){\n            const empty = document.createElement('div');\n            empty.className = 'muted';\n            empty.textContent = '(empty key -> hash 0)';\n            hashStrip.appendChild(empty);\n            setTimeout(()=>resolve({sum:0, idx:0}), 400);\n            return;\n          }\n          // Build char boxes\n          const chars = key.split('');\n          const boxes = chars.map((ch, i) => {\n            const box = document.createElement('div');\n            box.className = 'charbox';\n            box.title = 'char: ' + ch;\n            box.innerHTML = '<div style=\"font-weight:700;\">'+escapeHtml(ch)+'</div><div class=\"ord\">'+ch.charCodeAt(0)+'</div>';\n            hashStrip.appendChild(box);\n            return box;\n          });\n\n          const sumBox = document.createElement('div');\n          sumBox.className = 'muted';\n          sumBox.style.marginLeft = '8px';\n          sumBox.style.minWidth = '120px';\n          sumBox.textContent = 'running sum: 0';\n          hashStrip.appendChild(sumBox);\n\n          let sum = 0;\n          let i = 0;\n          function step(){\n            if (i >= chars.length){\n              // final modulo\n              const idx = sum % bucketCount;\n              const res = document.createElement('div');\n              res.className = 'muted';\n              res.style.marginLeft = '8px';\n              res.innerHTML = 'sum = ' + sum + ' → index = ' + idx;\n              hashStrip.appendChild(res);\n              setTimeout(()=>resolve({sum, idx}), 600);\n              return;\n            }\n            const c = chars[i];\n            const box = boxes[i];\n            box.classList.add('active');\n            // animate for 420ms\n            setTimeout(()=>{\n              sum += c.charCodeAt(0);\n              sumBox.textContent = 'running sum: ' + sum;\n              box.classList.remove('active');\n              i++;\n              setTimeout(step, 160);\n            }, 420);\n          }\n          setTimeout(step, 120);\n        });\n      }\n\n      // Create a moving floating clone (from control area) to animate into bucket\n      function animateInsertToBucket(item, targetIdx){\n        return new Promise(resolve => {\n          const startEl = insertBtn;\n          const startRect = startEl.getBoundingClientRect();\n          const targetBucket = getBucketEl(targetIdx);\n          const chainEl = getChainEl(targetIdx);\n          const endRect = chainEl.getBoundingClientRect();\n          // create clone\n          const clone = createNodeEl(item);\n          clone.classList.add('floating');\n          document.body.appendChild(clone);\n          // set start position\n          const startX = startRect.left + startRect.width/2;\n          const startY = startRect.top + startRect.height/2;\n          const endX = endRect.left + endRect.width/2;\n          const endY = endRect.top + 10 + (map[targetIdx].length * 44); // stack offset\n          clone.style.left = (startX - 40) + 'px';\n          clone.style.top = (startY - 24) + 'px';\n          clone.style.opacity = '1';\n          clone.style.transform = 'translate3d(0,0,0) scale(1)';\n          // delay then move\n          requestAnimationFrame(()=> {\n            // slight upward lift\n            clone.style.transition = 'transform 620ms cubic-bezier(.2,.9,.2,1), left 620ms ease, top 620ms ease, opacity 220ms linear';\n            clone.style.left = (endX - 40) + 'px';\n            clone.style.top = (endY - 20) + 'px';\n            clone.style.transform = 'translate3d(0,0,0) scale(1)';\n          });\n          setTimeout(()=>{\n            // append final static node into chain\n            const node = createNodeEl(item);\n            chainEl.appendChild(node);\n            // fade out clone\n            clone.style.opacity = '0';\n            setTimeout(()=>{ clone.remove(); resolve(); }, 240);\n          }, 700);\n        });\n      }\n\n      // Insert logic: animate hash, then add to data & animate move\n      async function handleInsert(){\n        if (animLock) return;\n        const key = keyInput.value.trim();\n        const value = valueInput.value.trim();\n        if (!key){\n          setStatus('Enter a non-empty key to insert.', 'error'); return;\n        }\n        animLock = true;\n        setStatus('Computing hash...');\n        try {\n          const {sum, idx} = await animateHashComputation(key);\n          setStatus('Inserting into bucket ' + idx + ' (sum ' + sum + ')...');\n          // check duplicate key in chain -> update\n          const chain = map[idx];\n          const existing = chain.find(it=>it.key===key);\n          if (existing){\n            existing.value = value;\n            // update UI: find its node element and flash\n            renderChainStatic(idx);\n            const nodeEl = getChainEl(idx).querySelector('.node[data-id=\"'+existing.id+'\"]');\n            if (nodeEl){\n              nodeEl.classList.add('highlight');\n              setTimeout(()=>nodeEl.classList.remove('highlight'), 900);\n            }\n            setStatus('Updated existing key in bucket ' + idx, 'success');\n            updateSummary();\n            animLock = false;\n            return;\n          }\n          const newItem = {key, value, id: uniqueId++};\n          // add to data\n          map[idx].push(newItem);\n          // animate movement\n          await animateInsertToBucket(newItem, idx);\n          setStatus('Inserted key \"' + key + '\" in bucket ' + idx, 'success');\n          updateSummary();\n        } catch(e){\n          console.error(e);\n          setStatus('Error during insert.', 'error');\n        } finally {\n          animLock = false;\n        }\n      }\n\n      // Search: animate traversal in chain\n      async function handleSearch(){\n        if (animLock) return;\n        const key = keyInput.value.trim();\n        if (!key){\n          setStatus('Enter a key to search.', 'error'); return;\n        }\n        animLock = true;\n        setStatus('Computing hash...');\n        try {\n          const {sum, idx} = await animateHashComputation(key);\n          setStatus('Searching bucket ' + idx + ' (sum ' + sum + ')...');\n          const entries = map[idx];\n          if (!entries.length){\n            // shake bucket\n            const b = getBucketEl(idx);\n            b.classList.add('notfound');\n            setTimeout(()=>b.classList.remove('notfound'), 700);\n            setStatus('Key not found (bucket empty).', 'error');\n            animLock = false;\n            return;\n          }\n          // traverse\n          const chainEl = getChainEl(idx);\n          const nodes = Array.from(chainEl.querySelectorAll('.node'));\n          let found = null;\n          for (let i=0;i<nodes.length;i++){\n            const n = nodes[i];\n            n.classList.add('highlight');\n            await new Promise(res => setTimeout(res, 520));\n            const id = Number(n.dataset.id);\n            const item = entries.find(it=>it.id===id);\n            if (item && item.key === key){\n              found = {node:n, item};\n              n.classList.remove('highlight');\n              n.classList.add('found');\n              setStatus('Found key \"' + key + '\" → value: ' + item.value, 'success');\n              await new Promise(res=>setTimeout(res,700));\n              n.classList.remove('found');\n              break;\n            } else {\n              n.classList.remove('highlight');\n            }\n          }\n          if (!found){\n            // not found\n            const b = getBucketEl(idx);\n            b.classList.add('notfound');\n            setTimeout(()=>b.classList.remove('notfound'), 700);\n            setStatus('Key \"'+key+'\" not found in bucket ' + idx, 'error');\n          }\n        } catch(e){\n          console.error(e);\n          setStatus('Error during search.', 'error');\n        } finally {\n          animLock = false;\n        }\n      }\n\n      // Delete: traverse then remove\n      async function handleDelete(){\n        if (animLock) return;\n        const key = keyInput.value.trim();\n        if (!key){\n          setStatus('Enter a key to delete.', 'error'); return;\n        }\n        animLock = true;\n        setStatus('Computing hash...');\n        try {\n          const {sum, idx} = await animateHashComputation(key);\n          setStatus('Searching bucket ' + idx + ' for deletion...');\n          const entries = map[idx];\n          const chainEl = getChainEl(idx);\n          const nodes = Array.from(chainEl.querySelectorAll('.node'));\n          let foundIndex = -1;\n          for (let i=0;i<nodes.length;i++){\n            const n = nodes[i];\n            n.classList.add('highlight');\n            await new Promise(res => setTimeout(res, 520));\n            const id = Number(n.dataset.id);\n            const itemIndex = entries.findIndex(it=>it.id===id);\n            if (itemIndex !== -1 && entries[itemIndex].key === key){\n              foundIndex = itemIndex;\n              // animate removal\n              n.classList.remove('highlight');\n              n.style.transition = 'transform 360ms ease, opacity 260ms linear';\n              n.style.transform = 'translateY(-16px) scale(.98)';\n              n.style.opacity = '0';\n              await new Promise(res => setTimeout(res, 360));\n              // remove from DOM & data\n              entries.splice(itemIndex,1);\n              renderChainStatic(idx);\n              setStatus('Deleted key \"'+key+'\" from bucket ' + idx, 'success');\n              updateSummary();\n              break;\n            } else {\n              n.classList.remove('highlight');\n            }\n          }\n          if (foundIndex === -1){\n            const b = getBucketEl(idx);\n            b.classList.add('notfound');\n            setTimeout(()=>b.classList.remove('notfound'), 700);\n            setStatus('Key \"'+key+'\" not found for deletion.', 'error');\n          }\n        } catch(e){\n          console.error(e);\n          setStatus('Error during delete.', 'error');\n        } finally {\n          animLock = false;\n        }\n      }\n\n      // Clear all\n      function handleClear(){\n        if (animLock) return;\n        map = Array.from({length: bucketCount}, ()=>[]);\n        // animate fade-out by clearing chains\n        const chains = bucketsEl.querySelectorAll('.chain');\n        chains.forEach(c=>c.innerHTML='');\n        setStatus('Cleared all entries.', 'success');\n        updateSummary();\n      }\n\n      // Handle changing bucket count -> rehash all entries (animate movement)\n      async function handleBucketCountChange(newCount){\n        if (animLock) return;\n        if (newCount === bucketCount) return;\n        animLock = true;\n        setStatus('Resizing and rehashing all entries...');\n        // collect old items\n        const oldItems = [];\n        for (let i=0;i<map.length;i++){\n          for (const it of map[i]) oldItems.push(it);\n        }\n        // reset structure & UI\n        bucketCount = newCount;\n        bucketCountDisplay.textContent = bucketCount;\n        createBuckets(bucketCount);\n        const newMap = Array.from({length: bucketCount}, ()=>[]);\n        const movedPromises = [];\n        // rehash items one-by-one with animated move from old position\n        for (const it of oldItems){\n          const {sum, idx} = computeHash(it.key);\n          newMap[idx].push(it);\n          // For animation, simulate moving element from center to new bucket\n          // create floating clone from center of page\n          movedPromises.push((async ()=>{\n            // create clone\n            const clone = createNodeEl(it);\n            clone.classList.add('floating');\n            document.body.appendChild(clone);\n            // start at center\n            const containerRect = bucketsEl.getBoundingClientRect();\n            const startX = containerRect.left + containerRect.width/2;\n            const startY = containerRect.top + 20;\n            const chainEl = (function(){ const b = getBucketEl(idx); return b ? b.querySelector('.chain') : null; })();\n            const endRect = chainEl ? chainEl.getBoundingClientRect() : {left:startX, top:startY};\n            clone.style.left = (startX - 40) + 'px';\n            clone.style.top = (startY - 24) + 'px';\n            clone.style.opacity = '1';\n            requestAnimationFrame(()=> {\n              clone.style.transition = 'transform 520ms cubic-bezier(.2,.9,.2,1), left 520ms ease, top 520ms ease, opacity 220ms linear';\n              clone.style.left = (endRect.left + 10) + 'px';\n              clone.style.top = (endRect.top + 6 + (newMap[idx].length-1)*44) + 'px';\n            });\n            await new Promise(res => setTimeout(res, 600));\n            // append static\n            if (chainEl) chainEl.appendChild(createNodeEl(it));\n            clone.remove();\n          })());\n        }\n\n        // wait for all moved animations to complete\n        try {\n          await Promise.all(movedPromises);\n          // set new map\n          map = newMap;\n          updateSummary();\n          setStatus('Rehash complete. New bucket count: ' + bucketCount, 'success');\n        } catch(e){\n          console.error(e);\n          setStatus('Error during rehash.', 'error');\n        } finally {\n          animLock = false;\n        }\n      }\n\n      // Event listeners\n      insertBtn.addEventListener('click', handleInsert);\n      searchBtn.addEventListener('click', handleSearch);\n      deleteBtn.addEventListener('click', handleDelete);\n      clearBtn.addEventListener('click', handleClear);\n\n      bucketSlider.addEventListener('input', (e)=>{\n        const newCount = Number(e.target.value);\n        bucketCountDisplay.textContent = newCount;\n      });\n      bucketSlider.addEventListener('change', (e)=>{\n        const newCount = Number(e.target.value);\n        handleBucketCountChange(newCount);\n      });\n\n      // keyboard access: Enter to insert\n      keyInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') insertBtn.click(); });\n      valueInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') insertBtn.click(); });\n\n      // Initialize UI\n      init();\n\n      // Accessibility: announce initial guidance\n      setTimeout(()=>setStatus('Ready. Insert keys to explore hashing and collisions.'), 600);\n    })();\n  </script>\n</body>\n</html>\n```\n\nNotes and teaching choices:\n- This module focuses on a single, clear pedagogical concept: how a hash map maps keys to bucket indices and how collisions are handled via separate chaining.\n- The hash function is intentionally simple (sum of character codes modulo bucketCount) so students can reason about collisions and watch the numeric steps being computed.\n- Animations are used to reinforce the mapping (hash computation strip), the physical idea of placing an item into a bucket (node movement), and the cost of search/delete operations (node-by-node traversal).\n- Controls are keyboard accessible and the layout is responsive. All code is vanilla HTML/CSS/JS and fully self-contained."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Hash Map.\n\n**Project Overview:**\nTopic: Hash Map\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Hash Map"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Hash Map Interactive Visualization",
      "description": "Models the interactive states and transitions of the hash map visualization app: inserting, searching, deleting, resizing (rehash), clearing and the animations/visual feedback (hash computation, traversal, move/fade, highlights, bucket shake).",
      "states": [
        {
          "name": "idle",
          "onEnter": "SET_STATUS_READY; RELEASE_ANIM_LOCK",
          "on": {
            "INSERT_CLICK": "hashing_insert",
            "SEARCH_CLICK": "hashing_search",
            "DELETE_CLICK": "hashing_delete",
            "CLEAR_CLICK": "clearing",
            "BUCKET_SLIDER_INPUT": "slider_preview",
            "BUCKET_SLIDER_CHANGE": "resizing_rehashing",
            "ENTER_KEY": "hashing_insert"
          }
        },
        {
          "name": "slider_preview",
          "onEnter": "UPDATE_BUCKET_COUNT_DISPLAY",
          "on": {
            "BUCKET_SLIDER_CHANGE": "resizing_rehashing",
            "NOOP": "idle"
          }
        },
        {
          "name": "hashing_insert",
          "onEnter": "SET_ANIM_LOCK_TRUE; SET_STATUS_COMPUTING_HASH; COMPUTE_HASH_ANIMATION",
          "onExit": "CLEAR_HASH_STRIP",
          "on": {
            "HASH_COMPUTED_DUPLICATE": "updating_existing",
            "HASH_COMPUTED_NEW": "inserting_moving",
            "HASH_COMPUTED_EMPTY_KEY": "validation_error"
          }
        },
        {
          "name": "inserting_moving",
          "onEnter": "ADD_ITEM_TO_DATA; SET_STATUS_INSERTING; ANIMATE_INSERT_TO_BUCKET",
          "on": {
            "INSERT_ANIMATION_DONE": "idle",
            "ANIMATION_ERROR": "idle"
          },
          "onExit": "UPDATE_SUMMARY; SET_STATUS_SUCCESS; RELEASE_ANIM_LOCK"
        },
        {
          "name": "updating_existing",
          "onEnter": "UPDATE_EXISTING_VALUE_IN_DATA; RENDER_CHAIN_STATIC",
          "on": {
            "UPDATE_RENDERED": "idle"
          },
          "onExit": "FLASH_NODE; UPDATE_SUMMARY; SET_STATUS_SUCCESS; RELEASE_ANIM_LOCK"
        },
        {
          "name": "hashing_search",
          "onEnter": "SET_ANIM_LOCK_TRUE; SET_STATUS_COMPUTING_HASH; COMPUTE_HASH_ANIMATION",
          "onExit": "CLEAR_HASH_STRIP",
          "on": {
            "HASH_COMPUTED_BUCKET_EMPTY": "bucket_shake_notfound",
            "HASH_COMPUTED_BUCKET_NONEMPTY": "searching_traversal",
            "HASH_COMPUTED_EMPTY_KEY": "validation_error"
          }
        },
        {
          "name": "searching_traversal",
          "onEnter": "SET_STATUS_SEARCHING; TRAVERSE_CHAIN_ANIMATION",
          "on": {
            "TRAVERSE_NODE_FOUND": "search_found",
            "TRAVERSE_COMPLETE_NOT_FOUND": "bucket_shake_notfound"
          },
          "onExit": "CLEAR_TRAVERSAL_HIGHLIGHTS"
        },
        {
          "name": "search_found",
          "onEnter": "HIGHLIGHT_FOUND_NODE; SET_STATUS_SUCCESS",
          "on": {
            "FOUND_HIGHLIGHT_DONE": "idle"
          },
          "onExit": "REMOVE_FOUND_HIGHLIGHT; RELEASE_ANIM_LOCK"
        },
        {
          "name": "hashing_delete",
          "onEnter": "SET_ANIM_LOCK_TRUE; SET_STATUS_COMPUTING_HASH; COMPUTE_HASH_ANIMATION",
          "onExit": "CLEAR_HASH_STRIP",
          "on": {
            "HASH_COMPUTED_BUCKET_EMPTY": "bucket_shake_notfound",
            "HASH_COMPUTED_BUCKET_NONEMPTY": "deleting_traversal",
            "HASH_COMPUTED_EMPTY_KEY": "validation_error"
          }
        },
        {
          "name": "deleting_traversal",
          "onEnter": "SET_STATUS_SEARCHING_FOR_DELETE; TRAVERSE_CHAIN_ANIMATION",
          "on": {
            "DELETE_NODE_FOUND": "deleting_remove",
            "TRAVERSE_COMPLETE_NOT_FOUND": "bucket_shake_notfound"
          },
          "onExit": "CLEAR_TRAVERSAL_HIGHLIGHTS"
        },
        {
          "name": "deleting_remove",
          "onEnter": "ANIMATE_REMOVE_NODE; REMOVE_FROM_DATA; RENDER_CHAIN_STATIC",
          "on": {
            "DELETE_ANIMATION_DONE": "idle"
          },
          "onExit": "UPDATE_SUMMARY; SET_STATUS_SUCCESS; RELEASE_ANIM_LOCK"
        },
        {
          "name": "bucket_shake_notfound",
          "onEnter": "APPLY_BUCKET_SHAKE_CLASS; SET_STATUS_NOT_FOUND",
          "on": {
            "SHAKE_COMPLETE": "idle"
          },
          "onExit": "REMOVE_BUCKET_SHAKE_CLASS; RELEASE_ANIM_LOCK"
        },
        {
          "name": "validation_error",
          "onEnter": "SET_STATUS_VALIDATION_ERROR",
          "on": {
            "ACK": "idle"
          }
        },
        {
          "name": "resizing_rehashing",
          "onEnter": "SET_ANIM_LOCK_TRUE; SET_STATUS_RESIZING; CREATE_BUCKETS_UI; COMPUTE_REHASH_PLAN; ANIMATE_REHASH_MOVES",
          "on": {
            "REHASH_ANIMATION_DONE": "idle",
            "REHASH_ERROR": "idle"
          },
          "onExit": "COMMIT_NEW_MAP; UPDATE_SUMMARY; SET_STATUS_SUCCESS; RELEASE_ANIM_LOCK"
        },
        {
          "name": "clearing",
          "onEnter": "CLEAR_DATA; CLEAR_UI_CHAINS; SET_STATUS_CLEARED; UPDATE_SUMMARY",
          "on": {
            "CLEARED": "idle"
          }
        }
      ],
      "events": [
        "INSERT_CLICK",
        "SEARCH_CLICK",
        "DELETE_CLICK",
        "CLEAR_CLICK",
        "BUCKET_SLIDER_INPUT",
        "BUCKET_SLIDER_CHANGE",
        "ENTER_KEY",
        "HASH_COMPUTED_DUPLICATE",
        "HASH_COMPUTED_NEW",
        "HASH_COMPUTED_BUCKET_EMPTY",
        "HASH_COMPUTED_BUCKET_NONEMPTY",
        "HASH_COMPUTED_EMPTY_KEY",
        "INSERT_ANIMATION_DONE",
        "UPDATE_RENDERED",
        "TRAVERSE_NODE_FOUND",
        "TRAVERSE_COMPLETE_NOT_FOUND",
        "FOUND_HIGHLIGHT_DONE",
        "DELETE_NODE_FOUND",
        "DELETE_ANIMATION_DONE",
        "SHAKE_COMPLETE",
        "REHASH_ANIMATION_DONE",
        "CLEARED",
        "ANIMATION_ERROR",
        "REHASH_ERROR",
        "NOOP",
        "ACK"
      ],
      "notes": "High-level FSM maps user actions to animated sequences. The implementation uses an animLock (represented by SET_ANIM_LOCK_TRUE/RELEASE_ANIM_LOCK) to prevent concurrent operations. Hash computation is animated and emits HASH_COMPUTED_* events indicating the bucket result and whether the chain contains a duplicate or is empty. Traversal is sequential and produces TRAVERSE_NODE_FOUND or TRAVERSE_COMPLETE_NOT_FOUND. Resizing rehashes all items with animated moves. CLEAR is instantaneous in UI. Visual feedback actions include APPLY_BUCKET_SHAKE_CLASS, HIGHLIGHT/FOUND classes, and flashing updated nodes."
    }
  },
  {
    "id": "2bd0c420-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:28:26.016Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Hash Table",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Hash Table — Interactive Module (Separate Chaining)</title>\n  <style>\n    :root{\n      --bg:#f7fbff;\n      --card:#ffffff;\n      --accent:#0b66ff;\n      --muted:#6b7280;\n      --success:#16a34a;\n      --danger:#dc2626;\n      --shadow: 0 6px 18px rgba(11,102,255,0.06);\n      --gap:16px;\n    }\n    /* Safe area margins 24px */\n    html,body{height:100%;}\n    body{\n      margin:0;\n      padding:24px;\n      box-sizing:border-box;\n      font-family:Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background:linear-gradient(180deg,#f0f6ff 0%, var(--bg) 100%);\n      color:#0f172a;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    /* Top info card */\n    .top {\n      background:var(--card);\n      border-radius:10px;\n      padding:18px;\n      box-shadow:var(--shadow);\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      margin-bottom:var(--gap);\n    }\n    .title{\n      display:flex;\n      align-items:center;\n      gap:12px;\n    }\n    .title h1{\n      margin:0;\n      font-size:20px;\n      line-height:1.05;\n    }\n    .subtitle{\n      color:var(--muted);\n      font-size:13px;\n      margin:0;\n    }\n\n    /* Layout: controls + canvas */\n    .container{\n      display:grid;\n      grid-template-columns:360px 1fr;\n      gap:24px;\n      align-items:start;\n    }\n    @media (max-width:880px){\n      .container{\n        grid-template-columns:1fr;\n      }\n    }\n\n    /* Controls card */\n    .panel{\n      background:var(--card);\n      border-radius:10px;\n      padding:18px;\n      box-shadow:var(--shadow);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    label{\n      font-size:13px;\n      color:var(--muted);\n      display:block;\n      margin-bottom:6px;\n    }\n    .controls-row{display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap;}\n    input[type=\"text\"]{\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid #e6eefc;\n      min-width:0;\n      flex:1;\n      font-size:14px;\n      outline:none;\n    }\n    button{\n      background:var(--accent);\n      color:white;\n      border:0;\n      padding:10px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      min-width:84px;\n      box-shadow:0 6px 16px rgba(11,102,255,0.08);\n    }\n    button.ghost{\n      background:transparent;\n      color:var(--accent);\n      border:1px solid rgba(11,102,255,0.12);\n      box-shadow:none;\n    }\n    button.warn{\n      background:var(--danger);\n    }\n    .small{\n      padding:8px 10px;\n      min-width:60px;\n      font-size:13px;\n    }\n    .inline-note{\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Slider and selects */\n    select, input[type=\"range\"]{\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid #e6eefc;\n      background:white;\n      font-size:13px;\n    }\n\n    /* Canvas card */\n    .canvas{\n      background:linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);\n      border-radius:10px;\n      padding:18px;\n      box-shadow:var(--shadow);\n      min-height:420px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      overflow:hidden;\n    }\n\n    /* Hash function display */\n    .hash-info{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .badge{\n      font-size:13px;\n      padding:8px 10px;\n      border-radius:8px;\n      background:#f1f8ff;\n      color:var(--accent);\n      border:1px solid rgba(11,102,255,0.06);\n    }\n\n    /* Buckets row */\n    .buckets-wrap{\n      overflow:auto;\n      padding:12px;\n      border-radius:8px;\n      border:1px dashed #eef5ff;\n      background:linear-gradient(90deg, rgba(11,102,255,0.02), transparent);\n      flex:1;\n      min-height:220px;\n    }\n    .buckets{\n      display:flex;\n      gap:12px;\n      align-items:flex-start;\n      padding-bottom:12px;\n    }\n    .bucket{\n      width:120px;\n      min-width:120px;\n      background:#fbfbff;\n      border-radius:8px;\n      border:1px solid #eef3ff;\n      padding:10px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n      align-items:stretch;\n      position:relative;\n    }\n    .bucket .idx{\n      font-weight:700;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .chain{\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    .node{\n      background:linear-gradient(180deg,#ffffff,#f8fbff);\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid #e6f0ff;\n      display:flex;\n      align-items:center;\n      gap:8px;\n      box-shadow:0 3px 6px rgba(11,102,255,0.04);\n      font-size:14px;\n    }\n    .node .keytext{flex:1; word-break:break-all;}\n    .node.small{padding:6px 8px; font-size:13px;}\n    .node.highlight{\n      box-shadow:0 6px 18px rgba(11,102,255,0.12);\n      transform:translateY(-4px);\n      border-color:rgba(11,102,255,0.18);\n      transition:all 260ms ease;\n    }\n    .node.found{\n      outline:3px solid rgba(22,163,74,0.12);\n      transform:translateY(-6px);\n      transition:all 260ms ease;\n    }\n\n    /* Floating key used for animation */\n    .floating{\n      position:fixed;\n      z-index:9999;\n      pointer-events:none;\n      transition:transform 520ms cubic-bezier(.2,.9,.3,1), opacity 220ms linear;\n      will-change:transform, opacity;\n      transform-origin:center;\n    }\n\n    /* Stats row */\n    .stats{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .stat{\n      background:#fff;\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid #eef5ff;\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Small helper text & footer */\n    .explain{\n      font-size:13px;\n      color:var(--muted);\n      line-height:1.45;\n    }\n    .spaced{margin-top:8px;}\n    /* Accessibility focus */\n    button:focus, input:focus, select:focus {outline:3px solid rgba(11,102,255,0.12); outline-offset:2px;}\n  </style>\n</head>\n<body>\n  <main>\n    <section class=\"top\" aria-labelledby=\"main-title\">\n      <div class=\"title\">\n        <h1 id=\"main-title\">Hash Table — Separate Chaining (Visual Exploration)</h1>\n      </div>\n      <p class=\"subtitle\">\n        Interactive module to learn how keys are mapped to buckets using a hash function and how collisions are handled with separate chaining.\n      </p>\n    </section>\n\n    <div class=\"container\">\n      <!-- Controls -->\n      <aside class=\"panel\" aria-labelledby=\"controls-title\">\n        <h2 id=\"controls-title\" style=\"margin:0;font-size:15px;\">Controls & Actions</h2>\n\n        <div>\n          <label for=\"keyInput\">Key (string or number)</label>\n          <div class=\"controls-row\">\n            <input id=\"keyInput\" type=\"text\" placeholder=\"e.g. apple or 42\" aria-label=\"Key input\">\n            <button id=\"insertBtn\" title=\"Insert key\">Insert</button>\n            <button id=\"searchBtn\" class=\"ghost\" title=\"Search key\">Search</button>\n          </div>\n          <div style=\"display:flex;gap:12px;margin-top:8px;align-items:center;\">\n            <button id=\"removeBtn\" class=\"ghost small\">Remove</button>\n            <button id=\"clearBtn\" class=\"ghost small\">Clear Table</button>\n          </div>\n        </div>\n\n        <div>\n          <label for=\"sizeRange\">Table size (number of buckets): <span id=\"sizeLabel\">8</span></label>\n          <div class=\"controls-row\">\n            <input id=\"sizeRange\" type=\"range\" min=\"4\" max=\"20\" value=\"8\" aria-label=\"Table size\">\n            <button id=\"rehashBtn\" class=\"small\">Rehash</button>\n          </div>\n          <p class=\"inline-note spaced\">Changing the slider changes the target size. Click Rehash to rebuild and see reinsertions.</p>\n        </div>\n\n        <div>\n          <label for=\"hashSelect\">Hash function</label>\n          <div class=\"controls-row\">\n            <select id=\"hashSelect\" aria-label=\"Hash function\">\n              <option value=\"sum\">Sum of char codes (simple)</option>\n              <option value=\"poly\">Polynomial rolling (base 31)</option>\n              <option value=\"first\">First char code</option>\n            </select>\n            <div class=\"inline-note\">All functions then mod table size.</div>\n          </div>\n        </div>\n\n        <div>\n          <label>Play controls</label>\n          <div class=\"controls-row\">\n            <button id=\"stepInsertBtn\" class=\"ghost small\">Insert (step)</button>\n            <button id=\"stepSearchBtn\" class=\"ghost small\">Search (step)</button>\n            <button id=\"autoBtn\" class=\"small\">Auto animations</button>\n          </div>\n          <p class=\"inline-note spaced\">Step mode lets you advance each internal step (hash compute, inspect bucket, traverse chain).</p>\n        </div>\n\n        <div>\n          <h3 style=\"margin:0;font-size:14px;\">Concept Overview</h3>\n          <p class=\"explain spaced\">\n            Concept Title: Hash Table using Separate Chaining.\n            Learning Objective: Understand how a hash function maps keys to bucket indices, why collisions happen,\n            and how chaining stores multiple keys per bucket. Interact by inserting, searching, removing, and rehashing.\n          </p>\n        </div>\n      </aside>\n\n      <!-- Canvas -->\n      <section class=\"canvas\" aria-labelledby=\"canvas-title\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;\">\n          <div>\n            <h2 id=\"canvas-title\" style=\"margin:0;font-size:15px;\">Hash Table Visualizer</h2>\n            <div class=\"hash-info spaced\">\n              <div class=\"badge\" id=\"hashFnBadge\">Fn: sum % n</div>\n              <div class=\"inline-note\">Computed hash shown during insertion/search.</div>\n            </div>\n          </div>\n\n          <div class=\"stats\" aria-live=\"polite\">\n            <div class=\"stat\">Buckets: <strong id=\"statSize\">8</strong></div>\n            <div class=\"stat\">Keys: <strong id=\"statCount\">0</strong></div>\n            <div class=\"stat\">Load factor: <strong id=\"statLoad\">0.00</strong></div>\n            <div class=\"stat\">Collisions: <strong id=\"statCollisions\">0</strong></div>\n          </div>\n        </div>\n\n        <div class=\"buckets-wrap\" id=\"bucketsWrap\" aria-label=\"Buckets area\">\n          <div class=\"buckets\" id=\"buckets\" role=\"list\"></div>\n        </div>\n\n        <div style=\"display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;\">\n          <div class=\"explain\" id=\"stepExplain\">Tip: Type a key and Insert. Watch the key compute its hash and animate into the bucket. Search highlights traversal.</div>\n          <div style=\"display:flex;gap:10px;align-items:center;\">\n            <button id=\"demoBtn\" class=\"ghost\">Demo: Insert sample keys</button>\n            <button id=\"collapseBtn\" class=\"ghost\">Show Plan</button>\n          </div>\n        </div>\n\n        <!-- Hidden area for the planning text (Interaction Design & Layout Description) -->\n        <div id=\"plan\" style=\"display:none;margin-top:12px;padding:12px;border-radius:8px;background:#f9fbff;border:1px solid #eef6ff;\">\n          <h3 style=\"margin-top:0;\">Interaction Design</h3>\n          <p class=\"explain\">Users interact by typing keys and clicking Insert/Search/Remove. Each action animates: the key element \"flies\" from the input to the computed bucket index, then attaches as a node in a vertical chain. When a collision occurs (bucket already contains nodes), the new node is appended — the animation pauses and the collision counter increments. Searching animates traversal through the chain, highlighting nodes step-by-step until found or end reached. Rehashing visualizes re-inserting all keys into the new table size (fast animated reenlistment).</p>\n          <h3>Layout Description</h3>\n          <p class=\"explain\">Safe area margins: 24px on all sides. The layout is a two-column responsive grid: left column contains controls (fixed-width 360px) and right column is the visual canvas. Minimum spacing between interactive elements is 16px. The buckets scroll horizontally if they overflow, maintaining clarity. Controls are grouped and labeled with accessible elements. Visual feedback uses color, movement, and focus outlines for accessibility.</p>\n        </div>\n      </section>\n    </div>\n  </main>\n\n  <script>\n    // Hash Table Visualizer — Separate Chaining\n    (function(){\n      // State\n      let tableSize = 8;\n      let table = Array.from({length:tableSize},()=>[]);\n      let keyCount = 0;\n      let collisions = 0;\n      let autoAnimate = true;\n      let stepMode = {insert:false, search:false};\n      const bucketsEl = document.getElementById('buckets');\n      const bucketsWrap = document.getElementById('bucketsWrap');\n      const sizeRange = document.getElementById('sizeRange');\n      const sizeLabel = document.getElementById('sizeLabel');\n      const statSize = document.getElementById('statSize');\n      const statCount = document.getElementById('statCount');\n      const statLoad = document.getElementById('statLoad');\n      const statCollisions = document.getElementById('statCollisions');\n      const hashSelect = document.getElementById('hashSelect');\n      const hashFnBadge = document.getElementById('hashFnBadge');\n      const keyInput = document.getElementById('keyInput');\n      const insertBtn = document.getElementById('insertBtn');\n      const stepInsertBtn = document.getElementById('stepInsertBtn');\n      const searchBtn = document.getElementById('searchBtn');\n      const stepSearchBtn = document.getElementById('stepSearchBtn');\n      const removeBtn = document.getElementById('removeBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const rehashBtn = document.getElementById('rehashBtn');\n      const demoBtn = document.getElementById('demoBtn');\n      const collapseBtn = document.getElementById('collapseBtn');\n      const planEl = document.getElementById('plan');\n      const autoBtn = document.getElementById('autoBtn');\n      const stepExplain = document.getElementById('stepExplain');\n\n      // Utilities\n      function updateStats(){\n        statSize.textContent = tableSize;\n        statCount.textContent = keyCount;\n        statLoad.textContent = (keyCount / tableSize).toFixed(2);\n        statCollisions.textContent = collisions;\n      }\n\n      function normalizeKey(k){\n        return String(k);\n      }\n\n      function charSumHash(s){\n        // simple\n        let sum = 0;\n        for(let i=0;i<s.length;i++) sum += s.charCodeAt(i);\n        return sum;\n      }\n      function polyHash(s){\n        let hash = 0;\n        const base = 31;\n        for(let i=0;i<s.length;i++){\n          hash = (hash * base + s.charCodeAt(i)) >>> 0;\n        }\n        return hash;\n      }\n      function firstCharHash(s){\n        return s.length ? s.charCodeAt(0) : 0;\n      }\n\n      function computeHash(key){\n        const s = normalizeKey(key);\n        const fn = hashSelect.value;\n        let raw;\n        if(fn === 'sum') raw = charSumHash(s);\n        else if(fn === 'poly') raw = polyHash(s);\n        else raw = firstCharHash(s);\n        return {raw, index: raw % tableSize};\n      }\n\n      function setHashBadge(){\n        const map = {\n          'sum':'Fn: sum(charCodes) % n',\n          'poly':'Fn: poly(base=31) % n',\n          'first':'Fn: firstCharCode % n'\n        };\n        hashFnBadge.textContent = map[hashSelect.value];\n      }\n\n      // Rendering\n      function renderTable(){\n        bucketsEl.innerHTML = '';\n        for(let i=0;i<tableSize;i++){\n          const bucket = document.createElement('div');\n          bucket.className = 'bucket';\n          bucket.setAttribute('data-idx', i);\n          bucket.setAttribute('role','listitem');\n          bucket.innerHTML = `<div class=\"idx\">idx ${i}</div><div class=\"chain\" aria-label=\"chain\"></div>`;\n          const chain = bucket.querySelector('.chain');\n          for(let j=0;j<table[i].length;j++){\n            const node = createNodeElement(table[i][j]);\n            chain.appendChild(node);\n          }\n          bucketsEl.appendChild(bucket);\n        }\n        updateStats();\n      }\n\n      function createNodeElement(key){\n        const node = document.createElement('div');\n        node.className = 'node';\n        node.tabIndex = 0;\n        node.innerHTML = `<div class=\"keytext\">${escapeHtml(key)}</div><div style=\"color:var(--muted);font-size:12px;\">↳</div>`;\n        node.setAttribute('data-key', key);\n        return node;\n      }\n\n      function escapeHtml(str){\n        return String(str).replace(/[&<>\"']/g, function(m){return {'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[m];});\n      }\n\n      // Animation helpers\n      function createFloatingNode(text){\n        const el = document.createElement('div');\n        el.className = 'node floating';\n        el.style.position = 'fixed';\n        el.style.margin = '0';\n        el.style.zIndex = 9999;\n        el.innerHTML = `<div class=\"keytext\">${escapeHtml(text)}</div>`;\n        document.body.appendChild(el);\n        return el;\n      }\n\n      function animateToTarget(floating, targetRect){\n        return new Promise((resolve)=>{\n          // Place floating at its current position (already set)\n          // Compute transform to target center\n          const fRect = floating.getBoundingClientRect();\n          const dx = (targetRect.left + targetRect.width/2) - (fRect.left + fRect.width/2);\n          const dy = (targetRect.top + targetRect.height/2) - (fRect.top + fRect.height/2);\n          floating.style.transition = 'transform 520ms cubic-bezier(.2,.9,.3,1), opacity 220ms linear';\n          floating.style.transform = `translate(${dx}px, ${dy}px) scale(0.98)`;\n          floating.style.opacity = '1';\n          setTimeout(()=> {\n            resolve();\n          }, 560);\n        });\n      }\n\n      function flashElement(el, cls='highlight', duration=520){\n        return new Promise((resolve)=>{\n          el.classList.add(cls);\n          setTimeout(()=>{\n            el.classList.remove(cls);\n            resolve();\n          }, duration);\n        });\n      }\n\n      // Core operations with animations and optional step mode\n      async function insertKeyFlow(key, opts={step:false}){\n        if(!key && key !== 0) return;\n        const keyStr = normalizeKey(key);\n        const {raw, index} = computeHash(keyStr);\n        // show compute step\n        stepExplain.textContent = `Computing raw hash = ${raw} → index ${index}`;\n        // create floating element near input\n        const floating = createFloatingNode(keyStr);\n        const inputRect = keyInput.getBoundingClientRect();\n        floating.style.left = inputRect.left + 'px';\n        floating.style.top = inputRect.top + 'px';\n        floating.style.opacity = '0.98';\n        await new Promise(r=>requestAnimationFrame(r));\n\n        // animate to bucket area (to bucket header center)\n        const bucket = bucketsEl.querySelector(`.bucket[data-idx=\"${index}\"]`);\n        if(!bucket){\n          // Shouldn't happen\n          document.body.removeChild(floating);\n          return;\n        }\n        const targetRect = bucket.getBoundingClientRect();\n        // If bucket currently has items, that's a collision\n        const isCollision = table[index].length > 0;\n        if(isCollision) collisions++;\n\n        updateStats();\n        await animateToTarget(floating, targetRect);\n\n        // attach node to DOM and state\n        table[index].push(keyStr);\n        keyCount++;\n        // remove floating and re-render that bucket's chain\n        floating.style.opacity = '0';\n        setTimeout(()=> {\n          try{floating.remove();}catch(e){}\n        }, 160);\n        const chain = bucket.querySelector('.chain');\n        const newNode = createNodeElement(keyStr);\n        newNode.style.opacity = '0';\n        chain.appendChild(newNode);\n        // small enter animation\n        requestAnimationFrame(()=>{ newNode.style.transition='opacity 260ms ease, transform 200ms ease'; newNode.style.opacity='1'; newNode.style.transform='translateY(-2px)';});\n        setTimeout(()=>{ newNode.style.transform='none'; }, 260);\n\n        updateStats();\n        // highlight newly inserted\n        await flashElement(newNode, 'highlight', 480);\n        return {index, isCollision};\n      }\n\n      async function searchKeyFlow(key, opts={step:false}){\n        if(!key && key !== 0) return {found:false};\n        const keyStr = normalizeKey(key);\n        const {raw, index} = computeHash(keyStr);\n        stepExplain.textContent = `Computed hash = ${raw} → index ${index}`;\n        const bucket = bucketsEl.querySelector(`.bucket[data-idx=\"${index}\"]`);\n        if(!bucket){\n          return {found:false, index};\n        }\n        // highlight bucket header\n        await flashElement(bucket.querySelector('.idx'), 'highlight', 420);\n        const nodes = Array.from(bucket.querySelectorAll('.node'));\n        for(let i=0;i<nodes.length;i++){\n          const n = nodes[i];\n          // simulate inspection\n          n.classList.add('highlight');\n          stepExplain.textContent = `Inspecting node ${i+1}/${nodes.length}: \"${n.getAttribute('data-key')}\"`;\n          await new Promise(r=>setTimeout(r, autoAnimate ? 600 : 120)); // shorter wait in step mode\n          if(n.getAttribute('data-key') === keyStr){\n            // found\n            n.classList.remove('highlight');\n            n.classList.add('found');\n            stepExplain.textContent = `Found \"${keyStr}\" at index ${index}, chain position ${i+1}`;\n            await new Promise(r=>setTimeout(r, 700));\n            n.classList.remove('found');\n            return {found:true, index, pos:i};\n          }\n          n.classList.remove('highlight');\n        }\n        stepExplain.textContent = `Key \"${keyStr}\" not found in index ${index}`;\n        return {found:false, index};\n      }\n\n      async function removeKeyFlow(key){\n        if(!key && key !== 0) return;\n        const keyStr = normalizeKey(key);\n        const {index} = computeHash(keyStr);\n        const bucket = bucketsEl.querySelector(`.bucket[data-idx=\"${index}\"]`);\n        if(!bucket) return false;\n        const nodes = Array.from(bucket.querySelectorAll('.node'));\n        for(let i=0;i<nodes.length;i++){\n          const n = nodes[i];\n          n.classList.add('highlight');\n          await new Promise(r=>setTimeout(r, 360));\n          if(n.getAttribute('data-key') === keyStr){\n            // animate removal\n            n.style.transition = 'transform 320ms ease, opacity 260ms linear';\n            n.style.transform = 'translateX(-12px) scale(.98)';\n            n.style.opacity = '0';\n            // remove from state\n            const idx = table[index].indexOf(keyStr);\n            if(idx !== -1) table[index].splice(idx,1);\n            keyCount = Math.max(0, keyCount-1);\n            setTimeout(()=>{ n.remove(); updateStats(); }, 360);\n            return true;\n          }\n          n.classList.remove('highlight');\n        }\n        return false;\n      }\n\n      // API exposed to UI\n      insertBtn.addEventListener('click', async ()=>{\n        const v = keyInput.value.trim();\n        if(!v && v !== '0') return;\n        insertBtn.disabled = true;\n        await insertKeyFlow(v, {step:stepMode.insert});\n        insertBtn.disabled = false;\n        keyInput.value = '';\n        keyInput.focus();\n      });\n\n      searchBtn.addEventListener('click', async ()=>{\n        const v = keyInput.value.trim();\n        if(!v && v !== '0') return;\n        searchBtn.disabled = true;\n        const res = await searchKeyFlow(v, {step:stepMode.search});\n        searchBtn.disabled = false;\n      });\n\n      removeBtn.addEventListener('click', async ()=>{\n        const v = keyInput.value.trim();\n        if(!v && v !== '0') return;\n        removeBtn.disabled = true;\n        const ok = await removeKeyFlow(v);\n        removeBtn.disabled = false;\n        if(ok) stepExplain.textContent = `Removed \"${v}\"`;\n        else stepExplain.textContent = `Key \"${v}\" not found to remove.`;\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        table = Array.from({length:tableSize},()=>[]);\n        keyCount = 0;\n        collisions = 0;\n        renderTable();\n        stepExplain.textContent = 'Cleared table.';\n      });\n\n      // Rehash: optionally animate reinsertions\n      rehashBtn.addEventListener('click', async ()=>{\n        rehashBtn.disabled = true;\n        const newSize = parseInt(sizeRange.value,10);\n        const oldItems = [];\n        for(let i=0;i<table.length;i++){\n          for(const k of table[i]) oldItems.push(k);\n        }\n        tableSize = newSize;\n        setHashBadge();\n        table = Array.from({length:tableSize},()=>[]);\n        keyCount = 0;\n        collisions = 0;\n        renderTable();\n        // reinsert all keys (animated sequentially)\n        for(const k of oldItems){\n          await insertKeyFlow(k);\n        }\n        rehashBtn.disabled = false;\n        stepExplain.textContent = `Rehashed ${oldItems.length} keys into ${tableSize} buckets.`;\n      });\n\n      // Size slider\n      sizeRange.addEventListener('input', ()=>{\n        sizeLabel.textContent = sizeRange.value;\n        statSize.textContent = sizeRange.value;\n      });\n\n      // Hash select\n      hashSelect.addEventListener('change', ()=>{\n        setHashBadge();\n      });\n\n      // Step/Auto toggles\n      stepInsertBtn.addEventListener('click', ()=>{ stepMode.insert = !stepMode.insert; stepInsertBtn.classList.toggle('ghost'); stepInsertBtn.textContent = stepMode.insert ? 'Insert (step)' : 'Insert (step)'; stepExplain.textContent = stepMode.insert ? 'Step mode enabled for insert.' : 'Step mode disabled.'; });\n      stepSearchBtn.addEventListener('click', ()=>{ stepMode.search = !stepMode.search; stepSearchBtn.classList.toggle('ghost'); stepExplain.textContent = stepMode.search ? 'Step mode enabled for search.' : 'Step mode disabled.'; });\n      autoBtn.addEventListener('click', ()=>{ autoAnimate = !autoAnimate; autoBtn.textContent = autoAnimate ? 'Auto animations' : 'No-auto'; autoBtn.classList.toggle('ghost'); });\n\n      // Demo\n      demoBtn.addEventListener('click', async ()=>{\n        const samples = ['apple','banana','apricot','grape','pear','apple','42','42','zebra'];\n        demoBtn.disabled = true;\n        for(let s of samples){\n          await insertKeyFlow(s);\n        }\n        demoBtn.disabled = false;\n        stepExplain.textContent = 'Demo complete.';\n      });\n\n      // Collapse plan area\n      collapseBtn.addEventListener('click', ()=>{\n        planEl.style.display = (planEl.style.display === 'none') ? 'block' : 'none';\n        collapseBtn.textContent = planEl.style.display === 'none' ? 'Show Plan' : 'Hide Plan';\n      });\n\n      // Keyboard: Enter to insert\n      keyInput.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter'){\n          insertBtn.click();\n        }\n      });\n\n      // Simple drag-n-drop: allow dragging existing nodes into input to prefill (improves interactivity)\n      bucketsEl.addEventListener('click', (e)=>{\n        const node = e.target.closest('.node');\n        if(node){\n          const k = node.getAttribute('data-key');\n          keyInput.value = k;\n          keyInput.focus();\n        }\n      });\n\n      // Initial render\n      setHashBadge();\n      renderTable();\n\n      // Ensure accessibility and responsiveness: handle window resize\n      window.addEventListener('resize', ()=>{/* no-op but keeps layout fluid */});\n\n      // Expose some debug on window (not necessary)\n      window._hashviz = {\n        table, computeHash\n      };\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Hash Table.\n\n**Project Overview:**\nTopic: Hash Table\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Hash Table"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Hash Table — Separate Chaining (Visualizer)",
      "description": "Finite state machine modelling the interactive behaviors of the hash table visualizer (insertion, search, removal, rehash, demo, UI toggles and animation steps).",
      "states": [
        {
          "name": "idle",
          "onEnter": "enableControls; updateStats; setHashBadge",
          "onExit": "none",
          "on": {
            "CLICK_INSERT": "inserting",
            "KEY_ENTER": "inserting",
            "CLICK_SEARCH": "searching",
            "CLICK_REMOVE": "removing",
            "CLICK_CLEAR": "clearing",
            "CLICK_REHASH": "rehashing",
            "CLICK_DEMO": "demoing",
            "SLIDER_INPUT": "idle",
            "CHANGE_HASH_FN": "idle",
            "CLICK_STEP_INSERT": "idle",
            "CLICK_STEP_SEARCH": "idle",
            "CLICK_AUTO_TOGGLE": "idle",
            "CLICK_COLLAPSE": "idle",
            "NODE_CLICKED": "idle",
            "WINDOW_RESIZE": "idle"
          }
        },
        {
          "name": "inserting",
          "onEnter": "disableControls; computeHash; createFloatingNode; setStepExplain('Computing hash...')",
          "onExit": "enableControls; updateStats; setStepExplain('')",
          "on": {
            "ANIMATION_START": "inserting",
            "INSERT_ANIMATION_DONE": "attach_and_finalize_insert",
            "INSERT_DONE": "idle",
            "INSERT_ERROR": "idle",
            "CLICK_INSERT": "inserting",
            "CLICK_SEARCH": "inserting",
            "CLICK_REMOVE": "inserting",
            "CLICK_REHASH": "inserting",
            "CLICK_DEMO": "inserting",
            "CLICK_COLLAPSE": "inserting",
            "SLIDER_INPUT": "inserting",
            "CHANGE_HASH_FN": "inserting"
          }
        },
        {
          "name": "attach_and_finalize_insert",
          "onEnter": "attachNodeToChain; incrementKeyCount; ifCollisionIncrementCollisions; animateNewNodeEntry; flashNewNode; setStepExplain('Inserted key')",
          "onExit": "none",
          "on": {
            "FLASH_DONE": "inserting_finalize",
            "ATTACH_DONE": "inserting_finalize",
            "INSERT_DONE": "idle"
          }
        },
        {
          "name": "inserting_finalize",
          "onEnter": "cleanupFloatingNode; updateStats; setStepExplain('')",
          "onExit": "none",
          "on": {
            "OPERATION_FINISHED": "idle",
            "DEFAULT_TIMEOUT": "idle"
          }
        },
        {
          "name": "searching",
          "onEnter": "disableControls; computeHash; flashBucketHeader; setStepExplain('Computing hash...')",
          "onExit": "enableControls; setStepExplain('')",
          "on": {
            "FLASH_BUCKET_DONE": "search_traversing",
            "SEARCH_TRAVERSE_NEXT": "search_traversing",
            "SEARCH_FOUND": "search_final_found",
            "SEARCH_NOT_FOUND": "search_final_not_found",
            "CLICK_INSERT": "searching",
            "CLICK_SEARCH": "searching",
            "CLICK_REMOVE": "searching",
            "CLICK_REHASH": "searching",
            "CLICK_DEMO": "searching",
            "CLICK_COLLAPSE": "searching"
          }
        },
        {
          "name": "search_traversing",
          "onEnter": "traverseChainStepwise (highlight nodes sequentially; obey autoAnimate/stepMode); setStepExplain('Inspecting nodes...')",
          "onExit": "clearHighlights",
          "on": {
            "NODE_INSPECTED_MATCH": "search_final_found",
            "NODE_INSPECTED_NO_MATCH_CONTINUE": "search_traversing",
            "CHAIN_END": "search_final_not_found",
            "SEARCH_INTERRUPTED": "idle"
          }
        },
        {
          "name": "search_final_found",
          "onEnter": "markNodeFound; flashFound; setStepExplain('Found key.');",
          "onExit": "clearFoundMark",
          "on": {
            "FOUND_ANIM_DONE": "idle",
            "OPERATION_FINISHED": "idle"
          }
        },
        {
          "name": "search_final_not_found",
          "onEnter": "setStepExplain('Key not found');",
          "onExit": "none",
          "on": {
            "OPERATION_FINISHED": "idle",
            "DEFAULT_TIMEOUT": "idle"
          }
        },
        {
          "name": "removing",
          "onEnter": "disableControls; computeHash; setStepExplain('Computing hash...')",
          "onExit": "enableControls; setStepExplain('')",
          "on": {
            "REMOVE_TRAVERSE_NEXT": "removing",
            "NODE_MATCHED_FOR_REMOVE": "removing_animate_remove",
            "REMOVE_NOT_FOUND": "remove_final_not_found",
            "CLICK_COLLAPSE": "removing"
          }
        },
        {
          "name": "removing_animate_remove",
          "onEnter": "highlightNode; animateRemoval; removeFromState; decrementKeyCount; updateStats; setStepExplain('Removed key')",
          "onExit": "none",
          "on": {
            "REMOVE_ANIMATION_DONE": "idle",
            "OPERATION_FINISHED": "idle"
          }
        },
        {
          "name": "remove_final_not_found",
          "onEnter": "setStepExplain('Key not found to remove');",
          "onExit": "none",
          "on": {
            "OPERATION_FINISHED": "idle"
          }
        },
        {
          "name": "clearing",
          "onEnter": "disableControls; clearTable; resetStats; renderTable; setStepExplain('Cleared table.')",
          "onExit": "enableControls",
          "on": {
            "OPERATION_FINISHED": "idle",
            "DEFAULT_TIMEOUT": "idle"
          }
        },
        {
          "name": "rehashing",
          "onEnter": "disableControls; collectAllKeys; setTableSizeFromSlider; setHashBadge; clearTableAndRender; setStepExplain('Rehashing...')",
          "onExit": "enableControls; setStepExplain('')",
          "on": {
            "REHASH_REINSERT_NEXT": "rehashing_reinsert_loop",
            "REHASH_COMPLETE": "idle",
            "CLICK_COLLAPSE": "rehashing"
          }
        },
        {
          "name": "rehashing_reinsert_loop",
          "onEnter": "sequentially call insertKeyFlow for each old key (animated); updateStats per insert; setStepExplain('Reinserting keys...')",
          "onExit": "none",
          "on": {
            "REHASH_INSERT_STEP_DONE": "rehashing_reinsert_loop",
            "REHASH_ALL_DONE": "rehashing",
            "REHASH_COMPLETE": "idle"
          }
        },
        {
          "name": "demoing",
          "onEnter": "disableControls; setStepExplain('Demo: Inserting sample keys...'); sequentially insert sample keys (await insertKeyFlow for each)",
          "onExit": "enableControls; setStepExplain('')",
          "on": {
            "DEMO_INSERT_STEP_DONE": "demoing",
            "DEMO_COMPLETE": "idle",
            "CLICK_COLLAPSE": "demoing"
          }
        }
      ],
      "events": [
        "CLICK_INSERT",
        "KEY_ENTER",
        "CLICK_SEARCH",
        "CLICK_REMOVE",
        "CLICK_CLEAR",
        "CLICK_REHASH",
        "CLICK_DEMO",
        "SLIDER_INPUT",
        "CHANGE_HASH_FN",
        "CLICK_STEP_INSERT",
        "CLICK_STEP_SEARCH",
        "CLICK_AUTO_TOGGLE",
        "CLICK_COLLAPSE",
        "NODE_CLICKED",
        "WINDOW_RESIZE",
        "ANIMATION_START",
        "INSERT_ANIMATION_DONE",
        "ATTACH_DONE",
        "FLASH_DONE",
        "INSERT_DONE",
        "INSERT_ERROR",
        "FLASH_BUCKET_DONE",
        "SEARCH_TRAVERSE_NEXT",
        "NODE_INSPECTED_MATCH",
        "NODE_INSPECTED_NO_MATCH_CONTINUE",
        "CHAIN_END",
        "SEARCH_FOUND",
        "SEARCH_NOT_FOUND",
        "FOUND_ANIM_DONE",
        "REMOVE_TRAVERSE_NEXT",
        "NODE_MATCHED_FOR_REMOVE",
        "REMOVE_ANIMATION_DONE",
        "REMOVE_NOT_FOUND",
        "REHASH_REINSERT_NEXT",
        "REHASH_INSERT_STEP_DONE",
        "REHASH_ALL_DONE",
        "REHASH_COMPLETE",
        "DEMO_INSERT_STEP_DONE",
        "DEMO_COMPLETE",
        "OPERATION_FINISHED",
        "DEFAULT_TIMEOUT"
      ],
      "notes": "High-level FSM. Many UI flags (autoAnimate, stepMode.insert/search) are orthogonal to main states and modify timing/pauses but do not create new top-level states. Each busy state disables primary controls onEnter and re-enables them onExit. Insert/search/remove/rehash/demo flows are sequential and await animations; while busy the UI ignores additional action events (represented here by transitions from busy states back to themselves). onEnter/onExit action names correspond to code-level behaviors: computeHash (computeHash), createFloatingNode (createFloatingNode + position), animateToBucket (animateToTarget), attachNodeToChain (DOM append & state push), incrementKeyCount / decrementKeyCount, ifCollisionIncrementCollisions (increment collisions when bucket non-empty), flashNewNode/flashBucketHeader/flashFound (flashElement), traverseChainStepwise (loop over nodes with highlights), animateRemoval (removal transform/opacity), collectAllKeys (gather old items before rehash), setTableSizeFromSlider (read slider), clearTableAndRender (reset table & renderTable). Events like INSERT_DONE / SEARCH_FOUND are emitted by the animation/flow when complete. The plan/collapse interaction is modelled as CLICK_COLLAPSE events which are handled in-state (toggle DOM visibility) without changing the primary operational state in this FSM representation."
    }
  },
  {
    "id": "2cf7df00-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:28:54.396Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Red-Black Tree",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Red-Black Tree — Interactive Insertion & Rebalancing</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --panel-bg: #f8fafc;\n      --accent: #1f6feb;\n      --muted: #6b7280;\n      --node-radius: 20;\n      --level-height: 90;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      font-family: Inter, Roboto, Arial, sans-serif;\n      background: #ffffff;\n      color: #0f172a;\n    }\n    /* Safe area margins */\n    .app {\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height:100vh;\n      display:flex;\n      flex-direction:column;\n      gap: var(--gap);\n    }\n\n    header {\n      display:flex;\n      align-items:baseline;\n      gap: var(--gap);\n      flex-wrap:wrap;\n    }\n    h1 {\n      font-size:1.25rem;\n      margin:0;\n      line-height:1;\n    }\n    .subtle {\n      color:var(--muted);\n      font-size:0.95rem;\n    }\n\n    main {\n      display:flex;\n      gap: var(--gap);\n      align-items:flex-start;\n      width:100%;\n      flex:1 1 auto;\n      min-height: 320px;\n    }\n\n    /* Left panel: controls & explanations */\n    .controls {\n      width:360px;\n      min-width:280px;\n      max-width:38%;\n      background: var(--panel-bg);\n      border-radius:8px;\n      padding:18px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap: var(--gap);\n      box-shadow: 0 1px 2px rgba(15,23,42,0.06);\n    }\n    .controls .block {\n      display:flex;\n      gap: var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    label {\n      font-size:0.9rem;\n      color:var(--muted);\n    }\n    input[type=\"number\"]{\n      padding:10px 12px;\n      border-radius:6px;\n      border:1px solid #e6edf3;\n      font-size:0.95rem;\n      width:120px;\n      box-sizing:border-box;\n    }\n    button {\n      background: var(--accent);\n      color:white;\n      border: none;\n      padding:10px 14px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:0.95rem;\n    }\n    button.secondary{\n      background:transparent;\n      color:var(--accent);\n      border:1px solid rgba(31,111,235,0.12);\n    }\n    button.icon {\n      padding:8px 10px;\n      font-size:0.95rem;\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n    }\n    .controls .row {\n      display:flex;\n      gap: var(--gap);\n      align-items:center;\n      justify-content:flex-start;\n      flex-wrap:wrap;\n    }\n    .controls .small {\n      font-size:0.9rem;\n      color:var(--muted);\n    }\n    .slider {\n      width:160px;\n    }\n\n    /* Right panel: visual canvas */\n    .canvas-panel {\n      flex:1 1 auto;\n      min-width:0;\n      background: linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);\n      border-radius:8px;\n      padding:18px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap: var(--gap);\n      box-shadow: 0 1px 2px rgba(15,23,42,0.04);\n      overflow:hidden;\n    }\n    .canvas-header {\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:var(--gap);\n    }\n    .canvas-title {\n      font-size:0.95rem;\n      font-weight:600;\n    }\n    .canvas-sub {\n      color:var(--muted);\n      font-size:0.9rem;\n    }\n\n    /* SVG area */\n    .svg-wrap {\n      background: #ffffff;\n      border-radius:8px;\n      padding:12px;\n      box-sizing:border-box;\n      flex:1 1 auto;\n      min-height:300px;\n      display:flex;\n      align-items:flex-start;\n      justify-content:center;\n      overflow:auto;\n    }\n    svg {\n      width:100%;\n      height:100%;\n      min-height:240px;\n      overflow:visible;\n    }\n\n    /* Node styles */\n    .node-group {\n      cursor: default;\n      transition: transform 420ms ease, opacity 240ms ease;\n    }\n    .node-circle {\n      stroke: #0f172a;\n      stroke-width:1.5px;\n      transition: fill 300ms ease, stroke 300ms ease, r 240ms ease;\n    }\n    .node-text {\n      fill: #ffffff;\n      font-weight:700;\n      font-size:12px;\n      pointer-events:none;\n      text-anchor:middle;\n      dominant-baseline:central;\n    }\n    .node-label {\n      font-size:11px;\n      fill:var(--muted);\n    }\n    .edge {\n      stroke:#94a3b8;\n      stroke-width:2;\n      fill:none;\n      transition: stroke 200ms ease, opacity 200ms ease;\n    }\n    .edge.highlight {\n      stroke: #1f6feb;\n      stroke-width:2.5;\n      opacity:1;\n    }\n    .hint-box {\n      background:#fff;\n      border-radius:8px;\n      padding:10px;\n      border:1px solid #eef2f6;\n      font-size:0.92rem;\n      color:var(--muted);\n    }\n\n    /* legend */\n    .legend {\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .legend .item {\n      display:flex;\n      align-items:center;\n      gap:8px;\n      font-size:0.9rem;\n      color:var(--muted);\n    }\n    .dot {\n      width:16px;\n      height:16px;\n      border-radius:50%;\n      display:inline-block;\n      border:1px solid rgba(15,23,42,0.06);\n    }\n\n    /* step info area */\n    .step-info {\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      justify-content:space-between;\n      flex-wrap:wrap;\n    }\n\n    /* accessibility focus */\n    button:focus, input:focus {\n      outline:3px solid rgba(31,111,235,0.18);\n      outline-offset:2px;\n    }\n\n    /* responsive adjustments */\n    @media (max-width:900px){\n      main {\n        flex-direction:column;\n      }\n      .controls { width:100%; max-width:none; }\n      .canvas-panel { width:100%; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"main\">\n    <header>\n      <div>\n        <h1>Red-Black Tree — Insertion & Rebalancing (Interactive)</h1>\n        <div class=\"subtle\">Explore how insertions are handled by the Red-Black Tree via recoloring and rotations.</div>\n      </div>\n    </header>\n\n    <main>\n      <!-- Controls & explanation -->\n      <section class=\"controls\" aria-labelledby=\"controls-title\">\n        <div>\n          <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n            <strong id=\"controls-title\">Controls</strong>\n            <div class=\"small\">Safe margins: 24px • Spacing: ≥16px</div>\n          </div>\n          <div class=\"small\" style=\"margin-top:8px;\">\n            Concept: Single focused concept — RB-Tree insertion (cases, recolor, rotate).\n          </div>\n        </div>\n\n        <!-- Input row -->\n        <div class=\"block\">\n          <label for=\"value-input\">Value to insert</label>\n          <input id=\"value-input\" type=\"number\" aria-label=\"Value to insert\" placeholder=\"e.g. 42\" />\n          <button id=\"insert-btn\" aria-label=\"Insert value\">Insert</button>\n          <button id=\"random-btn\" class=\"secondary\" aria-label=\"Insert random value\">Random</button>\n        </div>\n\n        <!-- Playback controls -->\n        <div class=\"row\">\n          <button id=\"step-back\" class=\"secondary\" aria-label=\"Step back\">◀ Step</button>\n          <button id=\"play-pause\" aria-label=\"Play\">▶ Play</button>\n          <button id=\"step-forward\" class=\"secondary\" aria-label=\"Step forward\">Step ▶</button>\n          <button id=\"reset-btn\" class=\"secondary\" aria-label=\"Reset tree\">Reset</button>\n        </div>\n\n        <div class=\"row\">\n          <label class=\"small\">Speed</label>\n          <input id=\"speed\" class=\"slider\" type=\"range\" min=\"200\" max=\"1600\" step=\"100\" value=\"800\" aria-label=\"Animation speed (ms)\" />\n          <div class=\"small\" id=\"speed-label\">800 ms</div>\n        </div>\n\n        <div class=\"hint-box\" id=\"summary-box\" aria-live=\"polite\">\n          <strong>Learning objective:</strong>\n          After interacting you will be able to predict how a Red-Black Tree restores properties when inserting a node — which cases cause recoloring vs rotations, and why the root becomes black.\n        </div>\n\n        <!-- Interaction & layout description (as requested) -->\n        <details open style=\"background:transparent;border:none;\">\n          <summary style=\"font-weight:600;margin-top:6px;cursor:pointer;\">Interaction Design (how to use)</summary>\n          <div style=\"margin-top:8px;color:var(--muted);font-size:0.92rem;line-height:1.4;\">\n            - Type a numeric value and press Insert (or Random) to add a new node.<br/>\n            - Each insertion generates an ordered list of internal steps (insert node → recolor/rotate steps → final root recolor).<br/>\n            - Use Step ▶ / ◀ Step to walk the algorithm step-by-step, or Play to animate through steps automatically.<br/>\n            - Visual feedback: nodes animate to their computed positions; recoloring and edges update smoothly. Each rotation is labeled in the step info so you can connect code cases to the visuals.<br/>\n            - Accessibility: all controls are keyboard focusable; aria-live announcements announce step explanations.\n          </div>\n        </details>\n\n        <details style=\"background:transparent;border:none;\">\n          <summary style=\"font-weight:600;cursor:pointer;\">Layout Description</summary>\n          <div style=\"margin-top:8px;color:var(--muted);font-size:0.92rem;line-height:1.4;\">\n            Spatial organization:\n            <ul style=\"margin:8px 0 0 18px;padding:0;\">\n              <li>Left column (controls): fixed-width panel with input, playback buttons, speed, and explanations.</li>\n              <li>Right column (canvas): flexible SVG area that renders the tree, legend and a step info bar at top.</li>\n            </ul>\n            Spacing & responsiveness:\n            <ul style=\"margin:8px 0 0 18px;padding:0;\">\n              <li>Safe area: 24px of padding around the viewport (as required).</li>\n              <li>All UI groups use a minimum gap of 16px to keep controls distinct and tappable.</li>\n              <li>Responsive: on narrow viewports the layout stacks vertically; SVG scales to container width.</li>\n            </ul>\n          </div>\n        </details>\n      </section>\n\n      <!-- Canvas & visualization -->\n      <section class=\"canvas-panel\" aria-labelledby=\"canvas-title\">\n        <div class=\"canvas-header\">\n          <div>\n            <div id=\"canvas-title\" class=\"canvas-title\">Tree Visualization</div>\n            <div class=\"canvas-sub\">Nodes animate into position; colors indicate node color (red/black).</div>\n          </div>\n          <div class=\"legend\" aria-hidden=\"true\">\n            <div class=\"item\"><span class=\"dot\" style=\"background:#ef4444;border:1px solid rgba(0,0,0,0.06)\"></span> Red node</div>\n            <div class=\"item\"><span class=\"dot\" style=\"background:#0f172a\"></span> Black node</div>\n            <div class=\"item node-label\" style=\"margin-left:6px;\">Hover nodes to highlight parent/child</div>\n          </div>\n        </div>\n\n        <div class=\"svg-wrap\" id=\"svg-wrap\" role=\"img\" aria-label=\"Red-Black tree visualization\">\n          <svg id=\"svg\" viewBox=\"0 0 1000 600\" preserveAspectRatio=\"xMidYMid meet\" tabindex=\"0\"></svg>\n        </div>\n\n        <div class=\"step-info\">\n          <div class=\"small\" id=\"step-desc\">No operations yet — insert a value to begin.</div>\n          <div class=\"small\" id=\"node-count\">Nodes: 0</div>\n        </div>\n      </section>\n    </main>\n  </div>\n\n  <script>\n    /********************************************************************\n     * Red-Black Tree Interactive — Single-file implementation\n     * Focus: Demonstrate insertion and rebalancing (recolor & rotations)\n     * No external libraries. Vanilla JS, inline SVG, accessibility hints.\n     ********************************************************************/\n\n    /**********************\n     * Utility & state\n     **********************/\n    const svg = document.getElementById('svg');\n    const wrap = document.getElementById('svg-wrap');\n    const insertBtn = document.getElementById('insert-btn');\n    const randomBtn = document.getElementById('random-btn');\n    const resetBtn = document.getElementById('reset-btn');\n    const stepFwdBtn = document.getElementById('step-forward');\n    const stepBackBtn = document.getElementById('step-back');\n    const playPauseBtn = document.getElementById('play-pause');\n    const valueInput = document.getElementById('value-input');\n    const speedInput = document.getElementById('speed');\n    const speedLabel = document.getElementById('speed-label');\n    const stepDesc = document.getElementById('step-desc');\n    const nodeCount = document.getElementById('node-count');\n    const summaryBox = document.getElementById('summary-box');\n\n    let speed = parseInt(speedInput.value, 10);\n    speedLabel.textContent = speed + ' ms';\n\n    speedInput.addEventListener('input', () => {\n      speed = parseInt(speedInput.value, 10);\n      speedLabel.textContent = speed + ' ms';\n    });\n\n    // Unique id generator for nodes (keeps persistent ids across snapshots)\n    let nextId = 1;\n    function makeId(){ return nextId++; }\n\n    /**********************\n     * Red-Black Tree model\n     **********************/\n    class RBNode {\n      constructor(value){\n        this.id = makeId();\n        this.value = value;\n        this.left = null;\n        this.right = null;\n        this.parent = null;\n        this.color = 'R'; // new nodes start red\n      }\n    }\n\n    class RBTree {\n      constructor(){\n        this.root = null;\n      }\n\n      // Helper: standard BST insert, returns the newly inserted node\n      bstInsert(value){\n        const z = new RBNode(value);\n        let y = null;\n        let x = this.root;\n        while (x !== null){\n          y = x;\n          if (z.value < x.value) x = x.left;\n          else x = x.right;\n        }\n        z.parent = y;\n        if (y === null){\n          this.root = z;\n        } else if (z.value < y.value){\n          y.left = z;\n        } else {\n          y.right = z;\n        }\n        return z;\n      }\n\n      // rotate left at node x\n      rotateLeft(x){\n        const y = x.right;\n        if (!y) return;\n        x.right = y.left;\n        if (y.left) y.left.parent = x;\n        y.parent = x.parent;\n        if (x.parent === null){\n          this.root = y;\n        } else if (x === x.parent.left){\n          x.parent.left = y;\n        } else {\n          x.parent.right = y;\n        }\n        y.left = x;\n        x.parent = y;\n      }\n\n      // rotate right at node x\n      rotateRight(x){\n        const y = x.left;\n        if (!y) return;\n        x.left = y.right;\n        if (y.right) y.right.parent = x;\n        y.parent = x.parent;\n        if (x.parent === null){\n          this.root = y;\n        } else if (x === x.parent.right){\n          x.parent.right = y;\n        } else {\n          x.parent.left = y;\n        }\n        y.right = x;\n        x.parent = y;\n      }\n\n      // Insert with RB fixup, but capture intermediate steps via callback\n      insertWithSteps(value, stepCallback){\n        // check for duplicates\n        if (this.find(value)) {\n          stepCallback(this.snapshot('duplicate', `Value ${value} already exists (ignored)`));\n          return;\n        }\n        const z = this.bstInsert(value);\n        stepCallback(this.snapshot('insert', `Inserted ${z.value} as red`));\n\n        // fixup\n        while (z !== this.root && z.parent.color === 'R'){\n          const p = z.parent;\n          const g = p.parent;\n          if (!g) break; // safety\n\n          if (p === g.left){\n            const y = g.right; // uncle\n            if (y && y.color === 'R'){ // case 1: uncle red\n              p.color = 'B';\n              y.color = 'B';\n              g.color = 'R';\n              stepCallback(this.snapshot('recolor', `Case 1: recolor parent (${p.value}) and uncle (${y.value}) to BLACK; grandparent (${g.value}) to RED`));\n              z = g;\n            } else {\n              if (z === p.right){ // case 2: left-right\n                // convert to case 3\n                stepCallback(this.snapshot('rotate-left', `Case 2: rotateLeft at parent (${p.value})`));\n                this.rotateLeft(p);\n                stepCallback(this.snapshot('rotated', `After rotateLeft at ${p.value}`));\n                // now z becomes p\n                // adjust references: in our loop we'll treat z as p (the previous z's parent)\n                z = p;\n              }\n              // case 3: left-left\n              p.color = 'B';\n              g.color = 'R';\n              stepCallback(this.snapshot('rotate-right', `Case 3: rotateRight at grandparent (${g.value}); recolor parent (${p.value}) BLACK, grandparent RED`));\n              this.rotateRight(g);\n              stepCallback(this.snapshot('rotated', `After rotateRight at ${g.value}`));\n            }\n          } else {\n            // symmetric: p is right child\n            const y = g.left;\n            if (y && y.color === 'R'){\n              p.color = 'B';\n              y.color = 'B';\n              g.color = 'R';\n              stepCallback(this.snapshot('recolor', `Case 1: recolor parent (${p.value}) and uncle (${y.value}) to BLACK; grandparent (${g.value}) to RED`));\n              z = g;\n            } else {\n              if (z === p.left){\n                stepCallback(this.snapshot('rotate-right', `Case 2: rotateRight at parent (${p.value})`));\n                this.rotateRight(p);\n                stepCallback(this.snapshot('rotated', `After rotateRight at ${p.value}`));\n                z = p;\n              }\n              p.color = 'B';\n              g.color = 'R';\n              stepCallback(this.snapshot('rotate-left', `Case 3: rotateLeft at grandparent (${g.value}); recolor parent (${p.value}) BLACK, grandparent RED`));\n              this.rotateLeft(g);\n              stepCallback(this.snapshot('rotated', `After rotateLeft at ${g.value}`));\n            }\n          }\n        }\n\n        // ensure root is black\n        if (this.root.color !== 'B'){\n          this.root.color = 'B';\n          stepCallback(this.snapshot('recolor-root', `Root recolored to BLACK (final)`));\n        } else {\n          stepCallback(this.snapshot('done', `Insertion complete`));\n        }\n      }\n\n      // find by value\n      find(value){\n        let x = this.root;\n        while (x){\n          if (value === x.value) return x;\n          x = value < x.value ? x.left : x.right;\n        }\n        return null;\n      }\n\n      // produce a snapshot data object describing current nodes and highlight\n      snapshot(type='state', note=''){\n        // produce nodes array with ids, value, color, parentId\n        const nodes = [];\n        (function traverse(n){\n          if (!n) return;\n          nodes.push({\n            id: n.id,\n            value: n.value,\n            color: n.color,\n            parent: n.parent ? n.parent.id : null,\n            left: n.left ? n.left.id : null,\n            right: n.right ? n.right.id : null\n          });\n          traverse(n.left);\n          traverse(n.right);\n        })(this.root);\n\n        return {\n          type,\n          note,\n          nodes,\n          rootId: this.root ? this.root.id : null,\n          timestamp: Date.now()\n        };\n      }\n\n      // clear tree\n      clear(){\n        this.root = null;\n      }\n    }\n\n    /**********************\n     * Visualization\n     **********************/\n    let model = new RBTree();\n    let history = []; // snapshots\n    let currentStep = -1;\n    let playing = false;\n    let playTimer = null;\n\n    // Render snapshot to SVG\n    function renderSnapshot(snapshot){\n      // Clear SVG children\n      while (svg.firstChild) svg.removeChild(svg.firstChild);\n\n      if (!snapshot || !snapshot.nodes || snapshot.nodes.length === 0){\n        stepDesc.textContent = snapshot && snapshot.note ? snapshot.note : 'No nodes';\n        nodeCount.textContent = 'Nodes: 0';\n        return;\n      }\n\n      // Build a map of nodes\n      const nodesById = new Map();\n      snapshot.nodes.forEach(n => nodesById.set(n.id, Object.assign({}, n)));\n\n      // Build tree structure (for computing depth and inorder)\n      // Find root\n      const rootId = snapshot.rootId;\n      const root = rootId ? nodesById.get(rootId) : null;\n\n      // compute depth and inorder index\n      const positions = new Map(); // id -> {x,y,depth,order}\n      let order = 0;\n      const levelHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--level-height')) || 90;\n      function dfsAssign(n, depth){\n        if (!n) return;\n        const left = n.left ? nodesById.get(n.left) : null;\n        const right = n.right ? nodesById.get(n.right) : null;\n        dfsAssign(left, depth+1);\n        positions.set(n.id, {order: order++, depth});\n        dfsAssign(right, depth+1);\n      }\n      dfsAssign(root, 0);\n\n      // compute SVG width based on order\n      const hSpacing = 70; // horizontal spacing between inorder positions\n      const minWidth = 440;\n      const width = Math.max(minWidth, (order + 1) * hSpacing + 120);\n      const depthMax = Math.max(...Array.from(positions.values()).map(p => p.depth), 0);\n      const height = Math.max(320, (depthMax + 2) * levelHeight + 60);\n\n      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n      svg.setAttribute('width', width);\n      svg.setAttribute('height', height);\n\n      // compute absolute coordinates\n      positions.forEach((p, id) => {\n        const x = 60 + p.order * hSpacing;\n        const y = 40 + p.depth * levelHeight;\n        p.x = x;\n        p.y = y;\n      });\n\n      // Draw edges first\n      snapshot.nodes.forEach(n => {\n        if (n.left){\n          const p = positions.get(n.id);\n          const c = positions.get(n.left);\n          drawEdge(p.x, p.y, c.x, c.y);\n        }\n        if (n.right){\n          const p = positions.get(n.id);\n          const c = positions.get(n.right);\n          drawEdge(p.x, p.y, c.x, c.y);\n        }\n      });\n\n      // Draw nodes\n      snapshot.nodes.forEach(n => {\n        const pos = positions.get(n.id);\n        drawNode(n, pos.x, pos.y);\n      });\n\n      // update textual info\n      stepDesc.textContent = snapshot.note || snapshot.type || '';\n      nodeCount.textContent = 'Nodes: ' + snapshot.nodes.length;\n    }\n\n    // Draw edge line between parent and child\n    function drawEdge(x1,y1,x2,y2){\n      const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n      const dx = Math.abs(x2 - x1);\n      const midX = (x1 + x2) / 2;\n      const midY = (y1 + y2) / 2;\n      // simple curved path\n      const d = `M ${x1} ${y1+18} C ${midX} ${y1+18} ${midX} ${y2-18} ${x2} ${y2-18}`;\n      path.setAttribute('d', d);\n      path.setAttribute('class','edge');\n      svg.appendChild(path);\n    }\n\n    // Draw a node as a group with circle and text\n    function drawNode(node, x, y){\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      g.setAttribute('class','node-group');\n      g.setAttribute('transform', `translate(${x},${y})`);\n      g.setAttribute('data-id', node.id);\n      g.setAttribute('role','img');\n      g.setAttribute('aria-label', `Node ${node.value}, color ${node.color === 'R' ? 'red' : 'black'}`);\n\n      // circle\n      const c = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      c.setAttribute('r', parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-radius')) || 20);\n      c.setAttribute('class','node-circle');\n      c.setAttribute('fill', node.color === 'R' ? '#ef4444' : '#0f172a');\n      c.setAttribute('stroke', 'rgba(0,0,0,0.08)');\n      g.appendChild(c);\n\n      // text\n      const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n      t.setAttribute('class','node-text');\n      t.textContent = node.value;\n      g.appendChild(t);\n\n      // subtle id label above\n      const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');\n      lbl.setAttribute('class','node-label');\n      lbl.setAttribute('y', -28);\n      lbl.setAttribute('text-anchor','middle');\n      lbl.textContent = `id:${node.id}`;\n      g.appendChild(lbl);\n\n      // hover interactions: highlight parent/children edges by changing stroke\n      g.addEventListener('mouseenter', () => {\n        highlightRelations(node.id, true);\n      });\n      g.addEventListener('mouseleave', () => {\n        highlightRelations(node.id, false);\n      });\n\n      svg.appendChild(g);\n    }\n\n    function highlightRelations(nodeId, highlight){\n      // find edges and node groups to highlight\n      const groups = svg.querySelectorAll('.node-group');\n      groups.forEach(g => {\n        const id = parseInt(g.getAttribute('data-id'),10);\n        if (id === nodeId) {\n          g.style.transform = 'scale(1.06)';\n        } else {\n          g.style.transform = 'scale(1)';\n        }\n      });\n\n      const edges = svg.querySelectorAll('.edge');\n      edges.forEach(e => {\n        e.classList.toggle('highlight', highlight);\n        e.style.opacity = highlight ? '1' : '0.95';\n      });\n    }\n\n    /**********************\n     * History & playback\n     **********************/\n    function pushSnapshot(snap){\n      // append snapshot to history and set current to last\n      history.push(snap);\n      currentStep = history.length - 1;\n      updateButtons();\n      renderSnapshot(history[currentStep]);\n      announce(snap.note || snap.type);\n    }\n\n    function updateButtons(){\n      stepBackBtn.disabled = currentStep <= 0;\n      stepFwdBtn.disabled = currentStep >= history.length - 1;\n      playPauseBtn.textContent = playing ? '⏸ Pause' : '▶ Play';\n    }\n\n    function stepForward(){\n      if (currentStep < history.length - 1){\n        currentStep++;\n        renderSnapshot(history[currentStep]);\n        announce(history[currentStep].note || history[currentStep].type);\n        updateButtons();\n      }\n    }\n    function stepBack(){\n      if (currentStep > 0){\n        currentStep--;\n        renderSnapshot(history[currentStep]);\n        announce(history[currentStep].note || history[currentStep].type);\n        updateButtons();\n      }\n    }\n\n    function play(){\n      if (playing) return;\n      playing = true;\n      updateButtons();\n      playTimer = setInterval(() => {\n        if (currentStep >= history.length - 1){\n          pause();\n        } else {\n          stepForward();\n        }\n      }, speed);\n    }\n\n    function pause(){\n      playing = false;\n      updateButtons();\n      if (playTimer) { clearInterval(playTimer); playTimer = null; }\n    }\n\n    function announce(text){\n      // update aria-live region (summaryBox) for screen readers\n      summaryBox.textContent = 'Learning objective: After interacting you will be able to predict ...\\nStep: ' + (text || '');\n    }\n\n    /**********************\n     * UI event wiring\n     **********************/\n    insertBtn.addEventListener('click', () => {\n      const v = parseInt(valueInput.value, 10);\n      if (Number.isNaN(v)){\n        valueInput.focus();\n        return;\n      }\n      performInsert(v);\n    });\n\n    randomBtn.addEventListener('click', () => {\n      const v = Math.floor(Math.random() * 99) + 1;\n      valueInput.value = v;\n      performInsert(v);\n    });\n\n    resetBtn.addEventListener('click', () => {\n      pause();\n      model = new RBTree();\n      history = [];\n      currentStep = -1;\n      renderSnapshot(null);\n      updateButtons();\n      stepDesc.textContent = 'Tree cleared.';\n      nodeCount.textContent = 'Nodes: 0';\n      nextId = 1;\n      announce('Tree reset');\n    });\n\n    stepFwdBtn.addEventListener('click', () => {\n      pause();\n      stepForward();\n    });\n    stepBackBtn.addEventListener('click', () => {\n      pause();\n      stepBack();\n    });\n\n    playPauseBtn.addEventListener('click', () => {\n      if (playing) pause();\n      else {\n        // if no snapshots yet, nothing to play\n        if (history.length === 0) {\n          announce('No operations to play');\n          return;\n        }\n        play();\n      }\n    });\n\n    // keyboard: Enter on value input triggers insert\n    valueInput.addEventListener('keydown', (e) => {\n      if (e.key === 'Enter'){ insertBtn.click(); }\n    });\n\n    // Insert operation: produce step sequence and push into history\n    function performInsert(v){\n      pause();\n      // We'll capture the tree states in sequence. To keep history navigable, we append\n      // the insertion steps to existing history.\n      model.insertWithSteps(v, (snap) => {\n        // For each snapshot from model, clone nodes to decouple from later mutations\n        const cloned = JSON.parse(JSON.stringify(snap));\n        history.push(cloned);\n      });\n      // set current to the last snapshot we just appended\n      currentStep = history.length - 1;\n      updateButtons();\n      renderSnapshot(history[currentStep]);\n      announce(history[currentStep].note || history[currentStep].type);\n    }\n\n    // initialize with small helper tree\n    (function initSample(){\n      // optional: seed with a few values to show behavior\n      const seeds = [10, 18, 7];\n      seeds.forEach(v => model.insertWithSteps(v, (snap) => {\n        history.push(JSON.parse(JSON.stringify(snap)));\n      }));\n      currentStep = history.length - 1;\n      renderSnapshot(history[currentStep]);\n      updateButtons();\n    })();\n\n    // make SVG responsive in wrap\n    window.addEventListener('resize', () => {\n      // svg uses viewBox so it scales automatically; nothing else needed\n    });\n\n    // Provide keyboard shortcuts for convenience: P = play/pause, ] = step forward, [ = step back\n    window.addEventListener('keydown', (e) => {\n      if (e.key === 'p' || e.key === 'P'){\n        playPauseBtn.click();\n      } else if (e.key === ']') {\n        stepFwdBtn.click();\n      } else if (e.key === '[') {\n        stepBackBtn.click();\n      }\n    });\n\n    // Accessibility: make sure interactive elements are spaced >=16px (CSS ensures gap)\n    // Announce initial message\n    announce('Ready. Insert a value to begin exploring Red-Black Tree insertion.');\n\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Red-Black Tree.\n\n**Project Overview:**\nTopic: Red-Black Tree\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Red-Black Tree"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Red-Black Tree Interactive Application",
      "description": "Models the interactive states and user-driven transitions for a Red-Black Tree insertion & rebalancing visualizer (controls, playback, insert processing, snapshots, hover highlights, reset).",
      "states": [
        {
          "name": "initializing",
          "onEnter": "initSample",
          "onExit": "renderCurrentSnapshot",
          "on": {
            "INIT_COMPLETE": "viewing"
          }
        },
        {
          "name": "idle",
          "description": "No pending playback; ready for user input. Usually when there are no snapshots (empty tree) or playback is stopped and user hasn't navigated.",
          "onEnter": "renderEmptyOrCurrent; updateButtons; announceReady",
          "on": {
            "INSERT_CLICK": "inserting",
            "RANDOM_CLICK": "inserting",
            "RESET_CLICK": "resetting",
            "PLAY_TOGGLE": "playing",
            "STEP_FORWARD": "viewing",
            "STEP_BACK": "viewing",
            "SPEED_CHANGE": "idle",
            "INPUT_ENTER": "inserting",
            "HOVER_ENTER": "hovering",
            "HOVER_EXIT": "idle",
            "KEY_PRESS_PLAY": "playing",
            "KEY_PRESS_STEP_FORWARD": "viewing",
            "KEY_PRESS_STEP_BACK": "viewing"
          }
        },
        {
          "name": "inserting",
          "onEnter": "performInsert(v) ; pausePlayback",
          "onExit": "updateButtons; renderCurrentSnapshot; announceCurrentStep",
          "on": {
            "INSERT_COMPLETE": "viewing",
            "DUPLICATE_DETECTED": "viewing",
            "RESET_CLICK": "resetting",
            "SPEED_CHANGE": "inserting",
            "HOVER_ENTER": "hovering"
          }
        },
        {
          "name": "viewing",
          "description": "Viewing a particular snapshot from history. Step navigation is enabled. This is the normal non-playing view.",
          "onEnter": "renderCurrentSnapshot; updateButtons; announceCurrentStep",
          "onExit": "updateButtons",
          "on": {
            "STEP_FORWARD": "viewing",
            "STEP_BACK": "viewing",
            "PLAY_TOGGLE": "playing",
            "INSERT_CLICK": "inserting",
            "RANDOM_CLICK": "inserting",
            "RESET_CLICK": "resetting",
            "SPEED_CHANGE": "viewing",
            "HOVER_ENTER": "hovering",
            "HOVER_EXIT": "viewing",
            "KEY_PRESS_PLAY": "playing",
            "KEY_PRESS_STEP_FORWARD": "viewing",
            "KEY_PRESS_STEP_BACK": "viewing"
          }
        },
        {
          "name": "playing",
          "onEnter": "startPlayTimer",
          "onExit": "stopPlayTimer",
          "on": {
            "TIMER_TICK": "viewing",
            "PLAY_COMPLETE": "viewing",
            "PLAY_TOGGLE": "viewing",
            "STEP_FORWARD": "viewing",
            "STEP_BACK": "viewing",
            "INSERT_CLICK": "inserting",
            "RANDOM_CLICK": "inserting",
            "RESET_CLICK": "resetting",
            "SPEED_CHANGE": "playing",
            "HOVER_ENTER": "hovering"
          }
        },
        {
          "name": "resetting",
          "onEnter": "pausePlayback; clearTree; resetIds; clearHistory",
          "onExit": "renderEmptyOrCurrent; updateButtons; announce('Tree reset')",
          "on": {
            "INIT_COMPLETE": "viewing",
            "RESET_COMPLETE": "idle",
            "INSERT_CLICK": "inserting",
            "RANDOM_CLICK": "inserting"
          }
        },
        {
          "name": "hovering",
          "description": "Transient state triggered by pointer hover over a node; highlights relations in the visualization.",
          "onEnter": "highlightRelations(nodeId, true)",
          "onExit": "highlightRelations(nodeId, false)",
          "on": {
            "HOVER_EXIT": "viewing",
            "RESET_CLICK": "resetting",
            "PLAY_TOGGLE": "playing",
            "STEP_FORWARD": "viewing",
            "STEP_BACK": "viewing"
          }
        }
      ],
      "events": [
        "INIT_COMPLETE",
        "INSERT_CLICK",
        "RANDOM_CLICK",
        "INPUT_ENTER",
        "STEP_FORWARD",
        "STEP_BACK",
        "PLAY_TOGGLE",
        "PLAY_START",
        "PLAY_STOP",
        "TIMER_TICK",
        "PLAY_COMPLETE",
        "RESET_CLICK",
        "RESET_COMPLETE",
        "SPEED_CHANGE",
        "HOVER_ENTER",
        "HOVER_EXIT",
        "KEY_PRESS_PLAY",
        "KEY_PRESS_STEP_FORWARD",
        "KEY_PRESS_STEP_BACK",
        "INSERT_COMPLETE",
        "DUPLICATE_DETECTED",
        "WINDOW_RESIZE"
      ],
      "notes": "Key onEnter/onExit actions map to concrete functions in the code: initSample (seeds initial snapshots), performInsert(v) calls model.insertWithSteps and pushes snapshots into history, renderCurrentSnapshot renders history[currentStep], startPlayTimer/stopPlayTimer control setInterval used for playback (interval uses current 'speed' ms), pausePlayback clears the play timer, clearTree resets the RBTree and history and nextId. Hovering is modeled as a transient state that highlights relations. The implementation generates snapshots synchronously during insertWithSteps (including duplicate snapshots) so 'inserting' completes immediately to 'viewing' after snapshots are appended. The PLAY_TOGGLE action checks history length in code: if history is empty the UI announces 'No operations to play' and remains in viewing/idle; the FSM models PLAY_TOGGLE as transitioning to 'playing' presuming history exists."
    }
  },
  {
    "id": "22859da0-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:28:58.522Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Deque",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Deque Explorer — Circular-Buffer Visualization</title>\n  <style>\n    /* Safe area margins: 24px on all sides */\n    :root {\n      --safe: 24px;\n      --gap: 16px; /* minimum spacing */\n      --accent: #0b76ef;\n      --muted: #6b7280;\n      --bg: #f7fafc;\n      --slot-bg: #ffffff;\n      --occupied: #e6f0ff;\n      --danger: #ffebeb;\n      --radius: 10px;\n      --shadow: 0 6px 18px rgba(15, 23, 42, 0.08);\n    }\n    html, body {\n      height: 100%;\n      margin: 0;\n      background: linear-gradient(180deg, #fbfdff 0%, #f7fbff 100%);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      color: #0f172a;\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothing: grayscale;\n    }\n    main {\n      padding: var(--safe);\n      box-sizing: border-box;\n      min-height: 100vh;\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n    }\n\n    /* Top info card */\n    .info {\n      background: white;\n      padding: 18px;\n      border-radius: 12px;\n      box-shadow: var(--shadow);\n      display: grid;\n      grid-template-columns: 1fr;\n      gap: 12px;\n    }\n    .title-row {\n      display: flex;\n      gap: 12px;\n      align-items: baseline;\n      flex-wrap: wrap;\n    }\n    h1 {\n      margin: 0;\n      font-size: 1.25rem;\n      letter-spacing: -0.01em;\n    }\n    .chip {\n      background: var(--accent);\n      color: white;\n      padding: 6px 10px;\n      border-radius: 999px;\n      font-size: 0.85rem;\n      display: inline-block;\n    }\n    .meta {\n      display: flex;\n      gap: 12px;\n      color: var(--muted);\n      font-size: 0.95rem;\n      flex-wrap: wrap;\n    }\n    .panel-grid {\n      display: grid;\n      grid-template-columns: 1fr 1fr;\n      gap: 12px;\n    }\n    .panel {\n      background: #fbfdff;\n      border-radius: 10px;\n      padding: 12px;\n      font-size: 0.95rem;\n    }\n    .panel h3 {\n      margin: 0 0 8px 0;\n      font-size: 0.95rem;\n    }\n    .panel p {\n      margin: 0;\n      color: var(--muted);\n      line-height: 1.4;\n    }\n\n    /* Layout: main interactive area */\n    .interactive {\n      display: grid;\n      grid-template-columns: 380px 1fr;\n      gap: var(--gap);\n      align-items: start;\n    }\n\n    /* Left column: controls */\n    .controls {\n      background: white;\n      padding: 16px;\n      border-radius: 12px;\n      box-shadow: var(--shadow);\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n      min-width: 260px;\n    }\n    .controls .row {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n      flex-wrap: wrap;\n    }\n    label {\n      font-weight: 600;\n      color: #0f172a;\n    }\n    input[type=\"text\"] {\n      padding: 10px 12px;\n      border-radius: 8px;\n      border: 1px solid #e6edf6;\n      font-size: 0.95rem;\n      min-width: 120px;\n      outline: none;\n    }\n    input[type=\"range\"] {\n      width: 100%;\n    }\n\n    button {\n      cursor: pointer;\n      border: none;\n      background: var(--accent);\n      color: white;\n      padding: 10px 12px;\n      border-radius: 8px;\n      font-weight: 600;\n      box-shadow: 0 6px 12px rgba(11,118,239,0.12);\n      transition: transform 160ms ease, box-shadow 160ms ease;\n    }\n    button.secondary {\n      background: #f1f5f9;\n      color: #0f172a;\n      box-shadow: none;\n      font-weight: 600;\n      border: 1px solid #e6edf6;\n    }\n    button:active { transform: translateY(1px); }\n    button.small {\n      padding: 8px 10px;\n      font-size: 0.9rem;\n      border-radius: 8px;\n    }\n    .danger {\n      background: #ef4444;\n      box-shadow: 0 6px 12px rgba(239,68,68,0.12);\n    }\n\n    .status {\n      background: #fff;\n      border-radius: 10px;\n      padding: 12px;\n      display: flex;\n      gap: 12px;\n      align-items: center;\n      border: 1px dashed #e6edf6;\n    }\n    .status .item {\n      flex: 1;\n      text-align: center;\n    }\n    .status .value {\n      font-weight: 700;\n      font-size: 1.05rem;\n      color: var(--accent);\n    }\n\n    /* Right column: visualization */\n    .visual {\n      background: white;\n      padding: 18px;\n      border-radius: 12px;\n      box-shadow: var(--shadow);\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n      min-height: 320px;\n      overflow: hidden;\n    }\n\n    .deque-area {\n      padding: 12px;\n      border-radius: 12px;\n      background: linear-gradient(180deg,#ffffff,#fbfdff);\n      border: 1px solid #eef4fb;\n      position: relative;\n      overflow: visible;\n    }\n    .slots {\n      display: flex;\n      gap: 12px;\n      justify-content: center;\n      align-items: flex-end;\n      padding: 24px 8px;\n      flex-wrap: wrap;\n    }\n    .slot {\n      width: 64px;\n      height: 64px;\n      border-radius: 8px;\n      background: var(--slot-bg);\n      border: 1px solid #e6edf6;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      position: relative;\n      transition: transform 300ms cubic-bezier(.2,.9,.3,1), box-shadow 180ms;\n    }\n    .slot.occupied {\n      background: var(--occupied);\n      box-shadow: 0 6px 18px rgba(11,118,239,0.06);\n    }\n    .slot .value {\n      font-weight: 700;\n      color: #08325b;\n    }\n    .index {\n      position: absolute;\n      bottom: -18px;\n      left: 50%;\n      transform: translateX(-50%);\n      font-size: 0.75rem;\n      color: var(--muted);\n    }\n\n    /* head/tail markers */\n    .marker {\n      position: absolute;\n      top: 6px;\n      background: #0b76ef;\n      color: white;\n      padding: 4px 8px;\n      font-size: 0.75rem;\n      border-radius: 999px;\n      transform: translateX(-50%);\n      transition: left 400ms cubic-bezier(.2,.9,.3,1);\n      box-shadow: 0 6px 18px rgba(11,118,239,0.12);\n      white-space: nowrap;\n    }\n    .marker.tail { background: #059669; }\n\n    /* floating element used for animations */\n    .floating {\n      position: absolute;\n      width: 64px;\n      height: 64px;\n      border-radius: 8px;\n      background: var(--occupied);\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      font-weight: 700;\n      color: #08325b;\n      pointer-events: none;\n      box-shadow: 0 12px 30px rgba(2,6,23,0.08);\n      transition: transform 420ms cubic-bezier(.2,.9,.3,1), opacity 260ms ease;\n      z-index: 30;\n    }\n\n    /* small helper area for invariants and history */\n    .info-bottom {\n      display: flex;\n      gap: var(--gap);\n      align-items: flex-start;\n      flex-wrap: wrap;\n    }\n    .code {\n      background: #0f172a;\n      color: #e6eefc;\n      padding: 12px;\n      border-radius: 8px;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n      font-size: 0.9rem;\n      line-height: 1.4;\n      min-width: 220px;\n    }\n    .history {\n      background: #fff;\n      border: 1px dashed #e6edf6;\n      border-radius: 8px;\n      padding: 10px;\n      min-width: 180px;\n      max-height: 160px;\n      overflow: auto;\n      font-size: 0.9rem;\n    }\n    .history h4 { margin: 0 0 6px 0; font-size: 0.95rem; }\n    .history ul { padding-left: 16px; margin: 0; color: var(--muted); }\n    .sr-only {\n      position: absolute !important;\n      height: 1px; width: 1px;\n      overflow: hidden;\n      clip: rect(1px, 1px, 1px, 1px);\n      white-space: nowrap;\n    }\n\n    /* animations for invalid actions */\n    @keyframes shake {\n      10%, 90% { transform: translateX(-1px); }\n      20%, 80% { transform: translateX(2px); }\n      30%, 50%, 70% { transform: translateX(-4px); }\n      40%, 60% { transform: translateX(4px); }\n    }\n    .shake {\n      animation: shake 360ms;\n    }\n\n    /* responsive adjustments */\n    @media (max-width: 920px) {\n      .interactive { grid-template-columns: 1fr; }\n      .controls { order: 2; }\n      .visual { order: 1; }\n      .panel-grid { grid-template-columns: 1fr; }\n    }\n    @media (max-width: 420px) {\n      .slot { width: 54px; height: 54px; }\n      .floating { width: 54px; height: 54px; }\n    }\n  </style>\n</head>\n<body>\n  <main>\n    <!-- Concept Title and explanatory panels -->\n    <section class=\"info\" aria-labelledby=\"heading\">\n      <div class=\"title-row\">\n        <h1 id=\"heading\">Deque — Double-Ended Queue (Circular Buffer Visualization)</h1>\n        <div class=\"chip\" aria-hidden=\"true\">Interactive</div>\n      </div>\n\n      <div class=\"meta\" role=\"status\" aria-live=\"polite\">\n        <div>Concept: Deque (Double-Ended Queue)</div>\n        <div>Representation: Fixed-capacity circular buffer</div>\n      </div>\n\n      <div class=\"panel-grid\" role=\"region\" aria-label=\"Learning details\">\n        <div class=\"panel\">\n          <h3>Learning Objective</h3>\n          <p>Interactively learn how a deque supports push/pop operations at both ends, how head and tail indices move in a circular buffer, and how overflow/underflow occur at fixed capacity.</p>\n        </div>\n        <div class=\"panel\">\n          <h3>Interaction Design</h3>\n          <p>Use the controls to push values to the front/back, pop from either end, change capacity, and watch animated updates: elements slide into/out of slots, head/tail markers move, and invalid operations trigger a shake with clear messages.</p>\n        </div>\n      </div>\n    </section>\n\n    <!-- Interactive area -->\n    <section class=\"interactive\" aria-label=\"Deque interactive module\">\n      <!-- Controls column -->\n      <aside class=\"controls\" aria-labelledby=\"controls-title\">\n        <h2 id=\"controls-title\" style=\"margin:0;font-size:1rem\">Controls</h2>\n\n        <div class=\"row\" style=\"align-items:center;\">\n          <label for=\"value-input\" style=\"min-width: 80px;\">Value</label>\n          <input id=\"value-input\" type=\"text\" inputmode=\"text\" aria-label=\"Value to push\" placeholder=\"e.g. 42\" />\n          <button id=\"push-front\" class=\"small\" title=\"Push to front (left)\">Push Front</button>\n          <button id=\"push-back\" class=\"small\" title=\"Push to back (right)\">Push Back</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"pop-front\" class=\"secondary small\" title=\"Pop from front\">Pop Front</button>\n          <button id=\"pop-back\" class=\"secondary small\" title=\"Pop from back\">Pop Back</button>\n          <button id=\"clear\" class=\"small danger\" title=\"Clear all\">Clear</button>\n        </div>\n\n        <div>\n          <label for=\"capacity\" style=\"display:block; margin-bottom:6px;\">Capacity: <span id=\"cap-value\">8</span></label>\n          <input id=\"capacity\" type=\"range\" min=\"4\" max=\"12\" step=\"1\" value=\"8\" aria-label=\"Set capacity\" />\n        </div>\n\n        <div class=\"row\" style=\"align-items:center;\">\n          <button id=\"random-fill\" class=\"small\" title=\"Fill with random values\">Random Fill</button>\n          <button id=\"step-demo\" class=\"small secondary\" title=\"Run step demo\">Run Demo</button>\n        </div>\n\n        <div class=\"status\" aria-live=\"polite\" aria-atomic=\"true\">\n          <div class=\"item\">\n            <div style=\"font-size:0.8rem;color:var(--muted)\">Size</div>\n            <div id=\"size-val\" class=\"value\">0</div>\n          </div>\n          <div class=\"item\">\n            <div style=\"font-size:0.8rem;color:var(--muted)\">Head</div>\n            <div id=\"head-val\" class=\"value\">0</div>\n          </div>\n          <div class=\"item\">\n            <div style=\"font-size:0.8rem;color:var(--muted)\">Tail</div>\n            <div id=\"tail-val\" class=\"value\">0</div>\n          </div>\n        </div>\n\n        <div class=\"info-bottom\" style=\"margin-top:6px;\">\n          <div class=\"code\" aria-hidden=\"true\">\n            <div style=\"font-size:0.85rem;color:#cfe3ff;margin-bottom:6px;\">Invariant (circular buffer)</div>\n            <div>size = (tail - head + capacity) % capacity</div>\n            <div>pushBack: slot[tail]=val; tail=(tail+1)%cap</div>\n            <div>popFront: val=slot[head]; head=(head+1)%cap</div>\n            <div style=\"margin-top:6px;color:#a8b9d8;font-size:0.82rem;\">Full when size == capacity - 1 (sentinel)</div>\n          </div>\n\n          <div class=\"history\" aria-live=\"polite\" aria-atomic=\"true\">\n            <h4>History</h4>\n            <ul id=\"hist-list\"><li style=\"color:var(--muted)\">No actions yet</li></ul>\n          </div>\n        </div>\n      </aside>\n\n      <!-- Visualization column -->\n      <section class=\"visual\" aria-label=\"Visualization\">\n        <div class=\"deque-area\" id=\"deque-area\">\n          <!-- markers -->\n          <div id=\"marker-head\" class=\"marker\" style=\"left:0%\">HEAD</div>\n          <div id=\"marker-tail\" class=\"marker tail\" style=\"left:0%\">TAIL</div>\n\n          <!-- slots -->\n          <div class=\"slots\" id=\"slots\" role=\"list\" aria-label=\"Deque slots\">\n            <!-- slots created dynamically -->\n          </div>\n\n          <!-- floating element for animations -->\n          <div id=\"floating\" class=\"floating\" style=\"display:none;\" aria-hidden=\"true\"></div>\n        </div>\n\n        <div style=\"display:flex;gap:12px;align-items:center;justify-content:space-between;\">\n          <div style=\"color:var(--muted);font-size:0.95rem;\">\n            Visual representation: fixed-size array with circular wrap. Elements occupy slots; head points to first element; tail points to next free slot.\n          </div>\n\n          <div>\n            <button id=\"explain\" class=\"secondary small\" title=\"Show explanation\">Explanation</button>\n          </div>\n        </div>\n      </section>\n    </section>\n\n    <!-- Hidden live region for screen readers -->\n    <div id=\"live\" class=\"sr-only\" aria-live=\"assertive\" aria-atomic=\"true\"></div>\n\n    <script>\n      /* Interactive Deque — Vanilla JS\n         - Circular buffer implementation with animated visual feedback\n         - Accessibility: aria-live messages, keyboard focusable controls\n         - Safe margins and spacing respected by CSS above\n      */\n\n      (function () {\n        // DOM references\n        const slotsEl = document.getElementById('slots');\n        const capInput = document.getElementById('capacity');\n        const capValueEl = document.getElementById('cap-value');\n        const sizeVal = document.getElementById('size-val');\n        const headVal = document.getElementById('head-val');\n        const tailVal = document.getElementById('tail-val');\n        const valueInput = document.getElementById('value-input');\n        const pushFrontBtn = document.getElementById('push-front');\n        const pushBackBtn = document.getElementById('push-back');\n        const popFrontBtn = document.getElementById('pop-front');\n        const popBackBtn = document.getElementById('pop-back');\n        const clearBtn = document.getElementById('clear');\n        const randomFillBtn = document.getElementById('random-fill');\n        const stepDemoBtn = document.getElementById('step-demo');\n        const histList = document.getElementById('hist-list');\n        const markerHead = document.getElementById('marker-head');\n        const markerTail = document.getElementById('marker-tail');\n        const dequeArea = document.getElementById('deque-area');\n        const floating = document.getElementById('floating');\n        const live = document.getElementById('live');\n\n        // State\n        let capacity = parseInt(capInput.value, 10);\n        // We'll use one extra slot technique to differentiate full vs empty:\n        // capacity = actual buffer size (we display this many slots),\n        // but the deque can hold at most capacity-1 elements.\n        let buffer = new Array(capacity).fill(null);\n        let head = 0; // index of first element\n        let tail = 0; // next free index (i.e., one past the last element)\n        let size = 0; // number of elements\n        let history = [];\n\n        // Utility helpers\n        function mod(n, m) { return ((n % m) + m) % m; }\n        function isFull() { return size === capacity - 1; }\n        function isEmpty() { return size === 0; }\n\n        // Initialize slots visually\n        function renderSlots() {\n          slotsEl.innerHTML = '';\n          for (let i = 0; i < capacity; i++) {\n            const slot = document.createElement('div');\n            slot.className = 'slot';\n            slot.setAttribute('data-index', i);\n            slot.setAttribute('role', 'listitem');\n            slot.setAttribute('aria-label', `Slot ${i}`);\n            // content\n            const v = document.createElement('div');\n            v.className = 'value';\n            v.textContent = buffer[i] !== null ? buffer[i] : '';\n            if (buffer[i] !== null) {\n              slot.classList.add('occupied');\n            }\n            slot.appendChild(v);\n            const idx = document.createElement('div');\n            idx.className = 'index';\n            idx.textContent = i;\n            slot.appendChild(idx);\n            slotsEl.appendChild(slot);\n          }\n          updateMarkers();\n          updateStatus();\n        }\n\n        function updateSlotsInstant() {\n          const slotNodes = slotsEl.querySelectorAll('.slot');\n          slotNodes.forEach(slot => {\n            const idx = parseInt(slot.dataset.index, 10);\n            const inner = slot.querySelector('.value');\n            inner.textContent = buffer[idx] !== null ? buffer[idx] : '';\n            slot.classList.toggle('occupied', buffer[idx] !== null);\n          });\n        }\n\n        function updateMarkers() {\n          // Position markers above the slot elements\n          const slotNodes = slotsEl.querySelectorAll('.slot');\n          if (!slotNodes.length) return;\n          const headSlot = slotNodes[head];\n          const tailSlot = slotNodes[tail];\n          // compute center positions relative to dequeArea\n          const areaRect = dequeArea.getBoundingClientRect();\n          const headRect = headSlot.getBoundingClientRect();\n          const tailRect = tailSlot.getBoundingClientRect();\n          const headLeft = headRect.left + headRect.width / 2 - areaRect.left;\n          const tailLeft = tailRect.left + tailRect.width / 2 - areaRect.left;\n          markerHead.style.left = headLeft + 'px';\n          markerTail.style.left = tailLeft + 'px';\n          // show numeric details\n          headVal.textContent = head;\n          tailVal.textContent = tail;\n        }\n\n        function updateStatus() {\n          sizeVal.textContent = size;\n        }\n\n        function pushFront(value) {\n          if (isFull()) {\n            invalidAction('Overflow: deque is full.');\n            return;\n          }\n          // new head location is (head-1)\n          const newHead = mod(head - 1, capacity);\n          // visually animate: create floating element above area and move to slot center\n          animateInsert(value, newHead, 'front').then(() => {\n            buffer[newHead] = value;\n            head = newHead;\n            size++;\n            pushHistory(`pushFront(${value})`);\n            updateSlotsInstant();\n            updateMarkers();\n            announce(`Pushed ${value} to front. Head is now ${head}.`);\n          });\n        }\n\n        function pushBack(value) {\n          if (isFull()) {\n            invalidAction('Overflow: deque is full.');\n            return;\n          }\n          const dest = tail;\n          animateInsert(value, dest, 'back').then(() => {\n            buffer[dest] = value;\n            tail = mod(tail + 1, capacity);\n            size++;\n            pushHistory(`pushBack(${value})`);\n            updateSlotsInstant();\n            updateMarkers();\n            announce(`Pushed ${value} to back. Tail is now ${tail}.`);\n          });\n        }\n\n        function popFront() {\n          if (isEmpty()) {\n            invalidAction('Underflow: deque is empty.');\n            return;\n          }\n          const idx = head;\n          const val = buffer[idx];\n          animateRemove(idx, 'front').then(() => {\n            buffer[idx] = null;\n            head = mod(head + 1, capacity);\n            size--;\n            pushHistory(`popFront() -> ${val}`);\n            updateSlotsInstant();\n            updateMarkers();\n            announce(`Popped ${val} from front. Head is now ${head}.`);\n          });\n        }\n\n        function popBack() {\n          if (isEmpty()) {\n            invalidAction('Underflow: deque is empty.');\n            return;\n          }\n          const idx = mod(tail - 1, capacity);\n          const val = buffer[idx];\n          animateRemove(idx, 'back').then(() => {\n            buffer[idx] = null;\n            tail = idx;\n            size--;\n            pushHistory(`popBack() -> ${val}`);\n            updateSlotsInstant();\n            updateMarkers();\n            announce(`Popped ${val} from back. Tail is now ${tail}.`);\n          });\n        }\n\n        function clearAll() {\n          // visually clear with fade\n          const promises = [];\n          for (let i = 0; i < capacity; i++) {\n            if (buffer[i] !== null) {\n              promises.push(animateRemove(i, 'clear'));\n            }\n          }\n          Promise.all(promises).then(() => {\n            buffer = new Array(capacity).fill(null);\n            head = 0; tail = 0; size = 0;\n            pushHistory('clear()');\n            updateSlotsInstant();\n            updateMarkers();\n            announce('Deque cleared.');\n          });\n        }\n\n        // Animation helpers: animateInsert moves floating element into target slot\n        function animateInsert(value, targetIndex, dir) {\n          return new Promise(resolve => {\n            const slotNodes = slotsEl.querySelectorAll('.slot');\n            const targetSlot = slotNodes[targetIndex];\n            const areaRect = dequeArea.getBoundingClientRect();\n            const slotRect = targetSlot.getBoundingClientRect();\n            // floating start: above area (for front/back same)\n            floating.style.display = 'flex';\n            floating.textContent = value;\n            floating.style.opacity = '1';\n            // compute start position (center above the deque)\n            const startX = areaRect.left + areaRect.width / 2 - areaRect.left - (floating.offsetWidth / 2);\n            const startY = areaRect.top - areaRect.height * 0.15 - areaRect.top;\n            floating.style.transform = `translate(${startX}px, ${startY}px) scale(0.96)`;\n            // force layout to ensure transition\n            void floating.offsetWidth;\n            // target position (slot center)\n            const targetX = slotRect.left + slotRect.width / 2 - areaRect.left - (floating.offsetWidth / 2);\n            const targetY = slotRect.top + slotRect.height / 2 - areaRect.top - (floating.offsetHeight / 2);\n            // move\n            requestAnimationFrame(() => {\n              floating.style.transform = `translate(${targetX}px, ${targetY}px) scale(1)`;\n            });\n            // after animation completes\n            setTimeout(() => {\n              floating.style.opacity = '0';\n              // small delay before hiding to allow fade\n              setTimeout(() => {\n                floating.style.display = 'none';\n                resolve();\n              }, 140);\n            }, 460);\n          });\n        }\n\n        // animateRemove: move the element in slot out (upwards) then hide\n        function animateRemove(index, dir) {\n          return new Promise(resolve => {\n            const slotNodes = slotsEl.querySelectorAll('.slot');\n            const slot = slotNodes[index];\n            const valueEl = slot.querySelector('.value');\n            const val = valueEl.textContent;\n            // create a temporary floating element at slot position\n            const slotRect = slot.getBoundingClientRect();\n            const areaRect = dequeArea.getBoundingClientRect();\n            floating.style.display = 'flex';\n            floating.textContent = val;\n            floating.style.opacity = '1';\n            const startX = slotRect.left + slotRect.width / 2 - areaRect.left - (floating.offsetWidth / 2);\n            const startY = slotRect.top + slotRect.height / 2 - areaRect.top - (floating.offsetHeight / 2);\n            floating.style.transform = `translate(${startX}px, ${startY}px) scale(1)`;\n            // hide the slot content immediately (so it appears removed)\n            valueEl.textContent = '';\n            slot.classList.remove('occupied');\n            // move floating out\n            requestAnimationFrame(() => {\n              const outY = startY - areaRect.height * 0.25;\n              const outX = startX + (dir === 'back' ? 12 : -12);\n              floating.style.transform = `translate(${outX}px, ${outY}px) scale(0.94)`;\n              floating.style.opacity = '0';\n            });\n            setTimeout(() => {\n              floating.style.display = 'none';\n              resolve();\n            }, 420);\n          });\n        }\n\n        // Invalid action feedback: shake the container and announce\n        function invalidAction(msg) {\n          dequeArea.classList.add('shake');\n          announce(msg);\n          setTimeout(() => dequeArea.classList.remove('shake'), 380);\n        }\n\n        function pushHistory(text) {\n          history.unshift(text);\n          if (history.length > 20) history.pop();\n          renderHistory();\n        }\n        function renderHistory() {\n          histList.innerHTML = '';\n          if (history.length === 0) {\n            const li = document.createElement('li');\n            li.style.color = 'var(--muted)';\n            li.textContent = 'No actions yet';\n            histList.appendChild(li);\n            return;\n          }\n          history.forEach(h => {\n            const li = document.createElement('li');\n            li.textContent = h;\n            histList.appendChild(li);\n          });\n        }\n\n        function announce(msg) {\n          // for screen readers\n          live.textContent = msg;\n        }\n\n        // Hooks for controls\n        pushFrontBtn.addEventListener('click', () => {\n          const val = valueInput.value.trim();\n          if (!val) { invalidAction('Please enter a value to push.'); return; }\n          pushFront(val);\n          valueInput.value = '';\n          valueInput.focus();\n        });\n        pushBackBtn.addEventListener('click', () => {\n          const val = valueInput.value.trim();\n          if (!val) { invalidAction('Please enter a value to push.'); return; }\n          pushBack(val);\n          valueInput.value = '';\n          valueInput.focus();\n        });\n        popFrontBtn.addEventListener('click', () => popFront());\n        popBackBtn.addEventListener('click', () => popBack());\n        clearBtn.addEventListener('click', () => clearAll());\n\n        capInput.addEventListener('input', () => {\n          const newCap = parseInt(capInput.value, 10);\n          capValueEl.textContent = newCap;\n        });\n        capInput.addEventListener('change', () => {\n          const newCap = parseInt(capInput.value, 10);\n          // resizing behavior: reset buffer while preserving minimal content\n          // We'll reinitialize to avoid complex resize semantics.\n          capacity = newCap;\n          buffer = new Array(capacity).fill(null);\n          head = 0; tail = 0; size = 0;\n          renderSlots();\n          pushHistory(`setCapacity(${capacity})`);\n          announce(`Capacity set to ${capacity}. Deque cleared.`);\n        });\n\n        randomFillBtn.addEventListener('click', () => {\n          // randomly fill up to capacity-1 slots\n          clearAll();\n          setTimeout(() => {\n            const count = Math.max(1, Math.floor(Math.random() * (capacity - 1)) + 1);\n            const values = [];\n            for (let i = 0; i < count; i++) {\n              values.push(Math.floor(Math.random() * 99) + 1);\n            }\n            // sequential pushes to back with slight delays for animation clarity\n            (function pushSeq(i) {\n              if (i >= values.length) return;\n              pushBack(values[i]);\n              setTimeout(() => pushSeq(i + 1), 220);\n            })(0);\n          }, 220);\n        });\n\n        // Demo sequence: shows a small scripted series of operations\n        stepDemoBtn.addEventListener('click', () => {\n          const seq = [\n            () => { pushBack('A'); },\n            () => { pushBack('B'); },\n            () => { pushFront('Z'); },\n            () => { popBack(); },\n            () => { pushBack('C'); },\n            () => { pushBack('D'); },\n            () => { popFront(); },\n            () => { pushFront('Y'); }\n          ];\n          // clear first\n          clearAll();\n          setTimeout(() => {\n            let i=0;\n            const t = setInterval(() => {\n              if (i >= seq.length) { clearInterval(t); return; }\n              seq[i++]();\n            }, 700);\n          }, 240);\n        });\n\n        // Explanation button toggles a short overlay alert (non-modal)\n        document.getElementById('explain').addEventListener('click', () => {\n          alert('This visual shows a deque backed by a circular buffer. head points to the first element, tail to the next free slot. The buffer keeps one slot empty to distinguish full from empty; thus max elements = capacity - 1.');\n        });\n\n        // on resize, update markers\n        window.addEventListener('resize', () => updateMarkers());\n\n        // initial render\n        renderSlots();\n        renderHistory();\n\n        // Keyboard accessibility: press Enter in input to pushBack\n        valueInput.addEventListener('keydown', (e) => {\n          if (e.key === 'Enter') {\n            pushBackBtn.click();\n            e.preventDefault();\n          }\n        });\n\n        // small tweak: ensure markers positioned after fonts/layout ready\n        setTimeout(updateMarkers, 60);\n\n        // Expose for debugging (if open devtools)\n        window._dequeDemo = {\n          pushFront, pushBack, popFront, popBack, clearAll,\n          getState: () => ({buffer: buffer.slice(), head, tail, size, capacity})\n        };\n      })();\n    </script>\n  </main>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Deque.\n\n**Project Overview:**\nTopic: Deque\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Deque"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Deque Explorer",
      "description": "Models the interactive states and transitions of a deque (circular-buffer) visualization UI: user actions (push/pop/clear/resize/demo/random-fill/explain), animations (insert/remove/shake), batch operations and accessibility announcements.",
      "states": [
        {
          "name": "idle",
          "onEnter": "renderSlots / updateMarkers / updateStatus",
          "on": {
            "PUSH_FRONT": "INSERTING_FRONT",
            "PUSH_BACK": "INSERTING_BACK",
            "POP_FRONT": "REMOVING_FRONT",
            "POP_BACK": "REMOVING_BACK",
            "CLEAR": "CLEARING",
            "SET_CAPACITY": "RESIZING",
            "RANDOM_FILL": "RANDOM_FILLING",
            "STEP_DEMO": "RUNNING_DEMO",
            "INVALID_ACTION": "SHAKING",
            "EXPLAIN": "idle",
            "WINDOW_RESIZE": "idle"
          }
        },
        {
          "name": "INSERTING_FRONT",
          "onEnter": "validateInputAndCapacity -> animateInsert(value, targetIndex=newHead, 'front')",
          "onExit": "commitInsertFront (buffer[newHead]=value; head=newHead; size++; pushHistory; updateSlotsInstant; updateMarkers; announce)",
          "on": {
            "ANIMATION_DONE": "idle",
            "INVALID_ACTION": "SHAKING"
          }
        },
        {
          "name": "INSERTING_BACK",
          "onEnter": "validateInputAndCapacity -> animateInsert(value, targetIndex=tail, 'back')",
          "onExit": "commitInsertBack (buffer[tail]=value; tail=(tail+1)%capacity; size++; pushHistory; updateSlotsInstant; updateMarkers; announce)",
          "on": {
            "ANIMATION_DONE": "idle",
            "INVALID_ACTION": "SHAKING"
          }
        },
        {
          "name": "REMOVING_FRONT",
          "onEnter": "validateNotEmpty -> animateRemove(index=head, 'front')",
          "onExit": "commitRemoveFront (val=buffer[oldHead]; buffer[oldHead]=null; head=(head+1)%capacity; size--; pushHistory; updateSlotsInstant; updateMarkers; announce)",
          "on": {
            "ANIMATION_DONE": "idle",
            "INVALID_ACTION": "SHAKING"
          }
        },
        {
          "name": "REMOVING_BACK",
          "onEnter": "validateNotEmpty -> animateRemove(index=(tail-1)%capacity, 'back')",
          "onExit": "commitRemoveBack (idx=(tail-1)%capacity; val=buffer[idx]; buffer[idx]=null; tail=idx; size--; pushHistory; updateSlotsInstant; updateMarkers; announce)",
          "on": {
            "ANIMATION_DONE": "idle",
            "INVALID_ACTION": "SHAKING"
          }
        },
        {
          "name": "CLEARING",
          "onEnter": "collectOccupiedIndices -> run animateRemove for each occupied slot (Promise.all)",
          "onExit": "commitClear (buffer cleared; head=0; tail=0; size=0; pushHistory('clear()'); updateSlotsInstant; updateMarkers; announce)",
          "on": {
            "BATCH_DONE": "idle"
          }
        },
        {
          "name": "RESIZING",
          "onEnter": "applyNewCapacity -> buffer = new Array(capacity).fill(null); head=0; tail=0; size=0; renderSlots; pushHistory('setCapacity'); announce",
          "on": {
            "RESIZE_DONE": "idle"
          }
        },
        {
          "name": "RANDOM_FILLING",
          "onEnter": "clearAll() then after short delay generate random values and sequentially invoke pushBack(values[i]) with small inter-push delays",
          "onExit": "finalizeRandomFill (when last push scheduled; updateSlotsInstant; updateMarkers; announce)",
          "on": {
            "RANDOM_FILL_COMPLETE": "idle",
            "INVALID_ACTION": "SHAKING"
          }
        },
        {
          "name": "RUNNING_DEMO",
          "onEnter": "clearAll() then run scripted sequence of operations (push/pop) on interval",
          "onExit": "finalizeDemo (when script finishes; announce; pushHistory entries already recorded by each op)",
          "on": {
            "DEMO_COMPLETE": "idle",
            "INVALID_ACTION": "SHAKING"
          }
        },
        {
          "name": "SHAKING",
          "onEnter": "invalidAction (add shake class to dequeArea; announce message)",
          "onExit": "remove shake class",
          "on": {
            "SHAKE_DONE": "idle"
          }
        }
      ],
      "events": [
        "PUSH_FRONT",
        "PUSH_BACK",
        "POP_FRONT",
        "POP_BACK",
        "CLEAR",
        "SET_CAPACITY",
        "RANDOM_FILL",
        "STEP_DEMO",
        "EXPLAIN",
        "WINDOW_RESIZE",
        "ANIMATION_DONE",
        "BATCH_DONE",
        "RANDOM_FILL_COMPLETE",
        "DEMO_COMPLETE",
        "RESIZE_DONE",
        "INVALID_ACTION",
        "SHAKE_DONE"
      ],
      "notes": "Guards and side-effects: user-initiated events (PUSH_FRONT/PUSH_BACK) first validate input and capacity. If input empty or the deque is full, the code triggers INVALID_ACTION -> SHAKING and returns. Pop operations validate non-empty, otherwise INVALID_ACTION. Animation flows use Promises/timeouts: animateInsert and animateRemove resolve then commit model updates (buffer/head/tail/size), update visual DOM (updateSlotsInstant / updateMarkers), pushHistory and announce via ARIA live region before returning to idle (handled as ANIMATION_DONE or BATCH_DONE). CLEAR runs many animateRemove Promises concurrently and transitions on Promise.all completion. RANDOM_FILL and RUNNING_DEMO orchestrate sequences of push/pop operations using setTimeout/setInterval; they may spawn multiple animations but are represented as higher-level states that end when the scripted sequence completes (RANDOM_FILL_COMPLETE / DEMO_COMPLETE). The implementation allows operations to overlap in practice; this FSM models the intended serialized visual/feedback flows (i.e., each animation commits before logical completion and the higher-level sequences wait for scheduling). The 'EXPLAIN' action triggers a synchronous informational alert and does not change core deque state. Window resize triggers marker repositioning (updateMarkers) and does not alter deque data. History and live-region announcements are performed on commit actions for accessibility."
    }
  },
  {
    "id": "38685680-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:29:22.928Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Graph (Directed/Undirected)",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Graph: Directed vs Undirected — Interactive Module</title>\n  <style>\n    :root{\n      --safe-margin:24px;\n      --gap:16px;\n      --bg:#0f1722;\n      --panel:#071028;\n      --accent:#06b6d4;\n      --muted:#94a3b8;\n      --card:#0b1220;\n      --success:#10b981;\n      --danger:#ef4444;\n      --glass: rgba(255,255,255,0.03);\n      --radius:10px;\n      --text:#e6eef7;\n      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", \"Segoe UI Mono\", monospace;\n    }\n\n    /* Page safe area and basic typography */\n    html,body{\n      height:100%;\n      margin:0;\n      background:linear-gradient(180deg,#071126 0%, #06101a 100%);\n      color:var(--text);\n      font-family: Inter, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      padding:var(--safe-margin);\n      box-sizing:border-box;\n    }\n\n    /* Layout container */\n    .module{\n      display:flex;\n      gap:var(--gap);\n      align-items:stretch;\n      min-height:calc(100vh - calc(var(--safe-margin)*2));\n    }\n\n    /* Left: interactive canvas */\n    .canvas-panel{\n      flex:1;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:var(--radius);\n      padding:var(--gap);\n      min-width:320px;\n      position:relative;\n      overflow:hidden;\n      box-shadow: 0 8px 24px rgba(2,6,23,0.6);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    .canvas-header{\n      display:flex;\n      justify-content:space-between;\n      gap:var(--gap);\n      align-items:center;\n      margin-bottom:12px;\n    }\n\n    .title{\n      font-size:18px;\n      font-weight:600;\n      color:var(--text);\n    }\n    .subtitle{\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Graph area (relative) */\n    .graph-area{\n      position:relative;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:8px;\n      flex:1;\n      min-height:480px;\n      overflow:hidden;\n      outline: 2px dashed rgba(255,255,255,0.02);\n    }\n\n    /* SVG overlay spans full area */\n    svg.graph-svg{\n      position:absolute;\n      left:0; top:0;\n      width:100%; height:100%;\n      pointer-events:none; /* edges drawn via svg but interactive via HTML elements */\n    }\n\n    /* Node elements (HTML overlay) */\n    .node{\n      position:absolute;\n      width:44px;\n      height:44px;\n      border-radius:50%;\n      background:linear-gradient(180deg,#012e3a,#00394d);\n      border:2px solid rgba(255,255,255,0.06);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      color:var(--text);\n      font-weight:600;\n      cursor:grab;\n      user-select:none;\n      box-shadow:0 6px 18px rgba(2,6,23,0.6);\n      transition:transform 150ms ease, box-shadow 150ms ease;\n      z-index:2;\n      min-width:44px;\n      min-height:44px;\n    }\n    .node:active{ cursor:grabbing; }\n    .node:hover{ transform:scale(1.04); box-shadow:0 10px 26px rgba(2,6,23,0.7); }\n\n    .node.selected{\n      outline:3px solid rgba(6,182,212,0.14);\n      box-shadow: 0 14px 34px rgba(3,9,15,0.6);\n      transform:scale(1.06);\n    }\n\n    .node-label{\n      font-size:14px;\n      pointer-events:none;\n    }\n\n    /* Controls panel */\n    .controls{\n      width:360px;\n      max-width:40%;\n      min-width:300px;\n      background:var(--panel);\n      border-radius:var(--radius);\n      padding:var(--gap);\n      box-shadow: 0 8px 24px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    .controls h3{\n      margin:0;\n      font-size:15px;\n      color:var(--text);\n    }\n    .controls p{ margin:0; color:var(--muted); font-size:13px; }\n\n    .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }\n\n    button, .toggle{\n      background:linear-gradient(180deg,#052033,#02202a);\n      color:var(--text);\n      border:1px solid rgba(255,255,255,0.04);\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      font-size:13px;\n    }\n    button.secondary{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.04);\n      color:var(--muted);\n      font-weight:500;\n    }\n    .toggle{\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n    }\n\n    .switch{\n      width:48px;\n      height:28px;\n      background:#0b1220;\n      border-radius:999px;\n      display:inline-flex;\n      align-items:center;\n      padding:4px;\n      transition:background 180ms ease;\n    }\n    .knob{\n      width:20px; height:20px; border-radius:999px; background:linear-gradient(180deg,#08b8cf,#018b9b);\n      transform:translateX(0);\n      transition:transform 180ms ease, box-shadow 180ms ease;\n      box-shadow:0 4px 10px rgba(2,6,23,0.6);\n    }\n    .switch.on{ background: linear-gradient(90deg,#08303a,#023b45); }\n    .switch.on .knob{ transform:translateX(20px); }\n\n    .muted-note{ font-size:13px; color:var(--muted); }\n\n    /* Panel boxes */\n    .box{\n      background:var(--card);\n      padding:12px;\n      border-radius:10px;\n      border:1px solid rgba(255,255,255,0.02);\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n\n    /* Matrix table */\n    .matrix{\n      overflow:auto;\n      max-height:180px;\n      min-width:240px;\n      border-radius:8px;\n    }\n    table{\n      border-collapse:collapse;\n      width:100%;\n      font-family:var(--mono);\n      font-size:13px;\n      color:var(--muted);\n    }\n    th,td{\n      padding:6px;\n      text-align:center;\n      border:1px solid rgba(255,255,255,0.02);\n      min-width:36px;\n    }\n    th{\n      background:rgba(255,255,255,0.02);\n      color:var(--muted);\n      font-weight:600;\n    }\n    td.cell-on{\n      background:linear-gradient(90deg, rgba(6,182,212,0.08), rgba(6,182,212,0.03));\n      color:var(--accent);\n      transition:background 220ms ease;\n    }\n    td.flash{\n      animation:flash 700ms ease;\n    }\n    @keyframes flash{\n      0%{ background:rgba(6,182,212,0.25); transform:scale(1.02); }\n      100%{ background:transparent; transform:scale(1); }\n    }\n\n    /* adjacency list */\n    .alist-item{ display:flex; gap:8px; align-items:center; justify-content:space-between; }\n    .badge{\n      background:#022733;\n      padding:6px 8px;\n      border-radius:8px;\n      color:var(--muted);\n      font-size:13px;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n\n    /* Small helper */\n    .hint{ font-size:13px; color:var(--muted); }\n\n    /* Responsive */\n    @media (max-width:900px){\n      .module{ flex-direction:column; }\n      .controls{ width:100%; max-width:none; min-width:unset; }\n    }\n  </style>\n</head>\n<body>\n\n  <!-- Explanation & Plan -->\n  <div style=\"max-width:1200px; margin:0 auto 18px auto; color:var(--muted);\">\n    <div style=\"background:transparent; padding:12px 0;\">\n      <div style=\"font-weight:700; color:var(--text); font-size:20px; margin-bottom:6px;\">\n        Concept: Graph (Directed vs Undirected)\n      </div>\n      <div style=\"font-size:14px;\">\n        This interactive module demonstrates the difference between directed and undirected graphs through hands-on construction,\n        visualization, and live adjacency representations (matrix & list). Create nodes and edges, toggle the graph mode,\n        and observe how edge directionality changes adjacency, degrees, and visuals.\n      </div>\n    </div>\n\n    <!-- Learning objective -->\n    <div style=\"display:flex; gap:20px; margin-top:12px; flex-wrap:wrap;\">\n      <div style=\"background:var(--card); padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.02);\">\n        <strong>Learning Objective</strong>\n        <div style=\"color:var(--muted); margin-top:6px; max-width:680px;\">\n          After interacting with this module, you will understand:\n          - The visual and structural difference between directed and undirected edges.\n          - How edge orientation affects adjacency matrix symmetry and degree calculations (degree vs in-/out-degree).\n          - How the same set of nodes can represent different connectivity depending on directionality.\n        </div>\n      </div>\n\n      <div style=\"background:var(--card); padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.02);\">\n        <strong>Interaction Design</strong>\n        <div style=\"color:var(--muted); margin-top:6px; max-width:680px;\">\n          - Click anywhere in the graph area to add a node. Nodes are draggable.\n          - Enter \"Add Edge\" mode, then click a source node and a target node to create an edge.\n            In directed mode an arrow is created (source → target); in undirected mode a single undirected edge appears.\n          - Toggle the \"Directed\" switch to see all edges update their appearance and how the adjacency matrix/list changes.\n          - Select a node to inspect its degree (undirected) or in-/out-degree (directed). Clicking adjacency matrix cells toggles edges.\n          - Visual feedback: edges animate when created, arrowheads fade in for directed edges, table cells briefly flash on edge toggles, and connected edges highlight on node selection.\n        </div>\n      </div>\n\n      <div style=\"background:var(--card); padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.02);\">\n        <strong>Layout Description</strong>\n        <div style=\"color:var(--muted); margin-top:6px; max-width:680px;\">\n          - Safe area margins: 24px around the viewport (enforced by body padding).\n          - The module uses a two-column layout: left is the interactive graph canvas (flex:1), right is the controls panel (fixed width ≈360px).\n          - Minimum spacing of 16px between interactive elements (implemented via CSS variables).\n          - Accessibility & responsiveness: clear focus states, large enough touch targets, keyboard-compatible controls for toggles/buttons, and a responsive single-column stacking on narrow screens.\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <!-- Interactive Module -->\n  <div class=\"module\" role=\"application\" aria-label=\"Graph directed vs undirected interactive module\" style=\"max-width:1200px; margin:0 auto;\">\n    <!-- Left: Canvas -->\n    <div class=\"canvas-panel\" aria-label=\"Graph area\">\n      <div class=\"canvas-header\">\n        <div>\n          <div class=\"title\">Interactive Graph Builder</div>\n          <div class=\"subtitle\">Click to add nodes • Drag to reposition • Add edges to connect</div>\n        </div>\n        <div class=\"muted-note\">Tip: Click an adjacency table cell to toggle an edge</div>\n      </div>\n\n      <div class=\"graph-area\" id=\"graphArea\" tabindex=\"0\" aria-describedby=\"graphInstructions\">\n        <div id=\"graphInstructions\" style=\"position:absolute; left:12px; top:12px; z-index:3; color:var(--muted); font-size:13px;\">\n          Double-click to add a node quickly — or click once then press \"Add Node\" button.\n        </div>\n\n        <!-- SVG for edges/markers -->\n        <svg class=\"graph-svg\" id=\"graphSvg\" xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\">\n          <defs>\n            <marker id=\"arrow\" markerWidth=\"8\" markerHeight=\"8\" refX=\"8\" refY=\"4\" orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L8,4 L0,8 z\" fill=\"#06b6d4\"></path>\n            </marker>\n            <marker id=\"arrow-dark\" markerWidth=\"8\" markerHeight=\"8\" refX=\"8\" refY=\"4\" orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L8,4 L0,8 z\" fill=\"#08303a\" opacity=\"0.9\"></path>\n            </marker>\n          </defs>\n          <g id=\"edgesGroup\"></g>\n        </svg>\n      </div>\n    </div>\n\n    <!-- Right: Controls -->\n    <aside class=\"controls\" aria-label=\"Controls panel\">\n      <div class=\"row\" style=\"justify-content:space-between; align-items:center;\">\n        <div>\n          <h3>Controls</h3>\n          <div class=\"hint\">Build and inspect directed vs undirected connections</div>\n        </div>\n      </div>\n\n      <div class=\"box\" aria-label=\"Modes\">\n        <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n          <div style=\"display:flex; gap:8px; flex-direction:column;\">\n            <div style=\"font-weight:700;\">Mode</div>\n            <div class=\"muted-note\">Switch between directed and undirected</div>\n          </div>\n          <div class=\"toggle\" id=\"modeToggle\" role=\"switch\" aria-checked=\"false\" tabindex=\"0\">\n            <div class=\"switch\" id=\"switchKnob\" aria-hidden=\"true\">\n              <div class=\"knob\"></div>\n            </div>\n            <div style=\"font-size:13px; color:var(--muted);\" id=\"modeLabel\">Undirected</div>\n          </div>\n        </div>\n\n        <div style=\"display:flex; gap:12px; margin-top:10px; flex-wrap:wrap;\">\n          <button id=\"addNodeBtn\" title=\"Add Node (then click canvas to place)\">Add Node</button>\n          <button id=\"addEdgeBtn\" class=\"secondary\">Add Edge</button>\n          <button id=\"clearBtn\" class=\"secondary\">Clear</button>\n          <button id=\"sampleBtn\" class=\"secondary\">Sample Graph</button>\n        </div>\n      </div>\n\n      <div class=\"box\" aria-label=\"Selection info\">\n        <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n          <div style=\"font-weight:700;\">Selected</div>\n          <div class=\"muted-note\" id=\"selectedName\">None</div>\n        </div>\n        <div id=\"degreeBox\" style=\"color:var(--muted); font-size:13px; margin-top:6px;\">\n          Select a node to see degree info.\n        </div>\n      </div>\n\n      <div class=\"box\" aria-label=\"Adjacency representations\">\n        <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n          <div style=\"font-weight:700;\">Adjacency Matrix</div>\n          <div class=\"muted-note\">Click cells to toggle edges</div>\n        </div>\n        <div class=\"matrix\" id=\"matrixWrap\" aria-live=\"polite\" style=\"margin-top:8px;\"></div>\n\n        <div style=\"margin-top:12px; display:flex; justify-content:space-between; align-items:center;\">\n          <div style=\"font-weight:700;\">Adjacency List</div>\n          <div style=\"font-size:13px; color:var(--muted);\">Live</div>\n        </div>\n        <div id=\"alist\" style=\"margin-top:8px; color:var(--muted); font-size:13px;\"></div>\n      </div>\n\n      <div class=\"box\" style=\"background:linear-gradient(180deg,#041421,#02121a);\" aria-hidden=\"false\">\n        <div style=\"font-weight:700; color:var(--muted);\">Legend & Tips</div>\n        <div style=\"margin-top:8px; color:var(--muted); font-size:13px;\">\n          - Directed: edges show an arrow (A → B). Matrix may be asymmetric. Degrees split to in/out.<br>\n          - Undirected: edges have no arrow. Matrix is symmetric and degree is single value.<br>\n          - Use drag to inspect how edges follow nodes. Nodes are labeled sequentially when created.\n        </div>\n      </div>\n\n    </aside>\n  </div>\n\n  <script>\n    /*****************************************************************\n     * Interactive Graph Module\n     * Vanilla JS, single-file, no external assets/libraries.\n     *****************************************************************/\n\n    (function(){\n      // Safe spacing constants used in styling and JS interactions\n      const MIN_GAP = 16;\n\n      // DOM refs\n      const graphArea = document.getElementById('graphArea');\n      const graphSvg = document.getElementById('graphSvg');\n      const edgesGroup = document.getElementById('edgesGroup');\n      const addNodeBtn = document.getElementById('addNodeBtn');\n      const addEdgeBtn = document.getElementById('addEdgeBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const sampleBtn = document.getElementById('sampleBtn');\n      const modeToggle = document.getElementById('modeToggle');\n      const switchKnob = document.getElementById('switchKnob');\n      const modeLabel = document.getElementById('modeLabel');\n      const matrixWrap = document.getElementById('matrixWrap');\n      const alist = document.getElementById('alist');\n      const selectedName = document.getElementById('selectedName');\n      const degreeBox = document.getElementById('degreeBox');\n\n      // State\n      let nodes = []; // {id, x, y, label, el}\n      let edges = []; // {id, sourceId, targetId, directed}\n      let directedMode = false;\n      let nextNodeId = 1;\n      let addingEdge = false;\n      let pendingSource = null;\n      let selectedNode = null;\n      let placeMode = false; // \"Add Node\" button pressed; next click places node\n      let graphRect = null;\n\n      // Helpers\n      function uid(prefix='e'){ return prefix + Math.random().toString(36).slice(2,9); }\n\n      // Use computed client rect for coordinate conversions\n      function updateGraphRect(){\n        graphRect = graphArea.getBoundingClientRect();\n      }\n      window.addEventListener('resize', updateGraphRect);\n      updateGraphRect();\n\n      // Create node element at x,y relative to graphArea\n      function createNodeAt(x,y,label){\n        const id = 'n'+nextNodeId++;\n        const el = document.createElement('div');\n        el.className = 'node';\n        el.setAttribute('data-id', id);\n        el.setAttribute('role','button');\n        el.setAttribute('aria-label','Node '+(label||id));\n        el.tabIndex = 0;\n\n        const lbl = document.createElement('div');\n        lbl.className = 'node-label';\n        lbl.textContent = label || id;\n        el.appendChild(lbl);\n\n        // Position\n        el.style.left = (x - 22) + 'px';\n        el.style.top = (y - 22) + 'px';\n\n        // Add to DOM\n        graphArea.appendChild(el);\n\n        // Store node\n        const node = { id, x, y, label: label || id, el };\n        nodes.push(node);\n\n        // Interactivity: drag, click, keyboard\n        attachNodeEvents(node);\n\n        // Rerender adjacency/matrix\n        renderAll();\n\n        return node;\n      }\n\n      function attachNodeEvents(node){\n        const el = node.el;\n        let dragging = false;\n        let offset = {x:0,y:0};\n\n        function onPointerDown(e){\n          e.preventDefault();\n          if (e.button !== undefined && e.button !== 0) return;\n          dragging = true;\n          el.classList.add('selected');\n          selectNode(node.id);\n          const rect = el.getBoundingClientRect();\n          offset.x = e.clientX - rect.left;\n          offset.y = e.clientY - rect.top;\n          el.setPointerCapture && el.setPointerCapture(e.pointerId);\n        }\n\n        function onPointerMove(e){\n          if (!dragging) return;\n          let nx = e.clientX - graphRect.left - offset.x;\n          let ny = e.clientY - graphRect.top - offset.y;\n          // Keep inside bounds with margin MIN_GAP\n          nx = Math.max(0, Math.min(graphRect.width - el.offsetWidth, nx));\n          ny = Math.max(0, Math.min(graphRect.height - el.offsetHeight, ny));\n          el.style.left = nx + 'px';\n          el.style.top = ny + 'px';\n          node.x = nx + el.offsetWidth/2;\n          node.y = ny + el.offsetHeight/2;\n          // Update edges visually\n          updateEdgesPositions(node.id);\n        }\n\n        function onPointerUp(e){\n          if (dragging){\n            dragging = false;\n            el.classList.remove('selected');\n            el.releasePointerCapture && el.releasePointerCapture(e.pointerId);\n          }\n        }\n\n        // Click for selection or edge creation\n        el.addEventListener('pointerdown', onPointerDown);\n        window.addEventListener('pointermove', onPointerMove);\n        window.addEventListener('pointerup', onPointerUp);\n\n        // Single click handling (pointerup to allow drag)\n        el.addEventListener('click', function(ev){\n          ev.stopPropagation();\n          // If adding edge mode: choose source/target\n          if (addingEdge){\n            if (!pendingSource){\n              pendingSource = node;\n              highlightNode(node.id,true);\n            } else {\n              if (pendingSource.id === node.id){\n                // Self-loop prevented\n                flashNotice('Self-loops are not supported in this demo.');\n                highlightNode(pendingSource.id,false);\n                pendingSource = null;\n                return;\n              }\n              createEdge(pendingSource.id, node.id, directedMode);\n              highlightNode(pendingSource.id,false);\n              pendingSource = null;\n              addingEdge = false;\n              addEdgeBtn.classList.remove('active');\n              addEdgeBtn.textContent = 'Add Edge';\n            }\n            return;\n          }\n\n          // Normal selection\n          selectNode(node.id);\n        });\n\n        // Keyboard accessible: Enter to select\n        el.addEventListener('keydown', function(ev){\n          if (ev.key === 'Enter'){\n            el.click();\n          }\n        });\n      }\n\n      function highlightNode(nodeId, on){\n        const n = nodes.find(n=>n.id===nodeId);\n        if (!n) return;\n        if (on) n.el.classList.add('selected');\n        else n.el.classList.remove('selected');\n      }\n\n      function selectNode(nodeId){\n        // Deselect previous\n        if (selectedNode && selectedNode.id === nodeId) {\n          // toggle off\n          selectedNode = null;\n          selectedName.textContent = 'None';\n          degreeBox.textContent = 'Select a node to see degree info.';\n          renderAll();\n          return;\n        }\n        selectedNode = nodes.find(n=>n.id===nodeId) || null;\n        selectedName.textContent = selectedNode ? selectedNode.label : 'None';\n        renderAll();\n        updateDegreeInfo();\n      }\n\n      // Create an edge between nodes (IDs)\n      function createEdge(srcId, tgtId, directed=true, opts={}){\n        // Prevent duplicates for undirected: only one edge between pair\n        if (!directed){\n          const exists = edges.find(e => {\n            if (e.directed) return false;\n            return (e.sourceId===srcId && e.targetId===tgtId) || (e.sourceId===tgtId && e.targetId===srcId);\n          });\n          if (exists) {\n            flashMatrixCells([srcId,tgtId]);\n            return;\n          }\n        } else {\n          // For directed edges, allow duplicate both directions but prevent exact duplicate\n          const exists = edges.find(e => e.directed && e.sourceId===srcId && e.targetId===tgtId);\n          if (exists){\n            flashMatrixCells([srcId,tgtId]);\n            return;\n          }\n        }\n\n        const id = uid('edge');\n        const edge = { id, sourceId: srcId, targetId: tgtId, directed: directed };\n        edges.push(edge);\n        drawEdge(edge, true);\n        renderAll();\n      }\n\n      // Draw or redraw all edges\n      function drawEdge(edge, animate=false){\n        // Remove existing if present\n        const existing = edgesGroup.querySelector('[data-id=\"'+edge.id+'\"]');\n        if (existing) existing.remove();\n\n        // Coordinates\n        const s = nodes.find(n=>n.id===edge.sourceId);\n        const t = nodes.find(n=>n.id===edge.targetId);\n        if (!s || !t) return;\n\n        const sx = s.x, sy = s.y, tx = t.x, ty = t.y;\n\n        // Create SVG line\n        const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n        g.setAttribute('data-id', edge.id);\n        g.setAttribute('aria-hidden','true');\n\n        // For self-loops not allowed, but if they exist fallback to small arc\n        if (edge.sourceId === edge.targetId){\n          // small loop path\n          const p = document.createElementNS('http://www.w3.org/2000/svg','path');\n          const r = 24;\n          const d = `M ${sx} ${sy} C ${sx+r} ${sy-r} ${sx+r*2} ${sy+r} ${sx} ${sy}`;\n          p.setAttribute('d', d);\n          p.setAttribute('stroke', edge.directed ? '#06b6d4' : '#7dd3fc');\n          p.setAttribute('fill','none');\n          p.setAttribute('stroke-width','2');\n          p.setAttribute('stroke-linecap','round');\n          if (edge.directed) p.setAttribute('marker-end','url(#arrow)');\n          g.appendChild(p);\n        } else {\n          // Draw line from center to center, but shorten to avoid overlapping node circle\n          const dx = tx - sx, dy = ty - sy;\n          const dist = Math.sqrt(dx*dx + dy*dy);\n          const nodeRadius = 22;\n          const offsetX = (dx/dist) * nodeRadius;\n          const offsetY = (dy/dist) * nodeRadius;\n          const x1 = sx + offsetX;\n          const y1 = sy + offsetY;\n          const x2 = tx - offsetX;\n          const y2 = ty - offsetY;\n\n          const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n          line.setAttribute('x1', x1);\n          line.setAttribute('y1', y1);\n          line.setAttribute('x2', x2);\n          line.setAttribute('y2', y2);\n          line.setAttribute('stroke', edge.directed ? '#06b6d4' : '#7dd3fc');\n          line.setAttribute('stroke-width', '2.4');\n          line.setAttribute('stroke-linecap','round');\n          if (edge.directed){\n            line.setAttribute('marker-end','url(#arrow)');\n          }\n          // For animation: stroke-dasharray trick\n          if (animate){\n            try {\n              const length = Math.hypot(x2-x1,y2-y1);\n              line.style.strokeDasharray = length;\n              line.style.strokeDashoffset = length;\n              line.getBoundingClientRect(); // force layout\n              line.style.transition = 'stroke-dashoffset 420ms ease, opacity 420ms ease';\n              line.style.opacity = 0;\n              setTimeout(()=>{\n                line.style.strokeDashoffset = '0';\n                line.style.opacity = 1;\n              },10);\n            } catch(e){}\n          }\n\n          g.appendChild(line);\n\n          // If directed, add a transparent arrow path for better visuals (arrow already added via marker)\n          if (edge.directed){\n            // optionally could add extra small triangle, but marker suffices\n          }\n        }\n\n        edgesGroup.appendChild(g);\n      }\n\n      function updateEdgesPositions(nodeId){\n        // update all edges connected to nodeId\n        edges.forEach(e=>{\n          if (e.sourceId === nodeId || e.targetId === nodeId){\n            drawEdge(e, false);\n          }\n        });\n      }\n\n      function renderAll(){\n        // Re-draw all edges\n        edgesGroup.innerHTML = '';\n        edges.forEach(e => drawEdge(e, false));\n        // Update adjacency representations\n        renderMatrix();\n        renderAdjList();\n        // Highlight edges connected to selected node\n        highlightConnected();\n      }\n\n      function highlightConnected(){\n        // Add subtle highlight for connected edges and nodes\n        // Clear previous\n        nodes.forEach(n => n.el.style.opacity = '1');\n        const edgeGroups = edgesGroup.querySelectorAll('g');\n        edgeGroups.forEach(g => g.style.opacity = '0.9');\n\n        if (!selectedNode) return;\n        nodes.forEach(n => {\n          const connected = edges.some(e => \n            (!directedMode && ((e.sourceId===n.id && e.targetId===selectedNode.id) || (e.targetId===n.id && e.sourceId===selectedNode.id))) ||\n            (directedMode && (e.sourceId===n.id && e.targetId===selectedNode.id || e.sourceId===selectedNode.id && e.targetId===n.id))\n          );\n          if (!connected && n.id!==selectedNode.id) n.el.style.opacity = '0.45';\n        });\n\n        edgeGroups.forEach(g=>{\n          const id = g.getAttribute('data-id');\n          const e = edges.find(ed=>ed.id===id);\n          if (!e) return;\n          const connected = e.sourceId===selectedNode.id || e.targetId===selectedNode.id;\n          g.style.opacity = connected ? '1' : '0.25';\n        });\n      }\n\n      // Adjacency matrix rendering\n      function renderMatrix(){\n        matrixWrap.innerHTML = '';\n        if (nodes.length === 0) {\n          matrixWrap.innerHTML = '<div class=\"muted-note\">No nodes yet.</div>';\n          return;\n        }\n        const table = document.createElement('table');\n        const thead = document.createElement('thead');\n        const headerRow = document.createElement('tr');\n        headerRow.appendChild(document.createElement('th')); // corner\n        nodes.forEach(n => {\n          const th = document.createElement('th');\n          th.textContent = n.label;\n          headerRow.appendChild(th);\n        });\n        thead.appendChild(headerRow);\n        table.appendChild(thead);\n\n        const tbody = document.createElement('tbody');\n        nodes.forEach(rowNode => {\n          const tr = document.createElement('tr');\n          const th = document.createElement('th');\n          th.textContent = rowNode.label;\n          tr.appendChild(th);\n          nodes.forEach(colNode => {\n            const td = document.createElement('td');\n            td.tabIndex = 0;\n            const present = isEdgePresent(rowNode.id, colNode.id);\n            if (present) td.classList.add('cell-on');\n            td.textContent = present ? (directedMode ? '1' : '1') : '0';\n            td.title = (directedMode ? `Edge ${rowNode.label} → ${colNode.label}` : `${rowNode.label} — ${colNode.label}`);\n            td.setAttribute('data-row', rowNode.id);\n            td.setAttribute('data-col', colNode.id);\n\n            // Click toggles edge\n            td.addEventListener('click', function(ev){\n              ev.stopPropagation();\n              toggleEdgeFromMatrix(rowNode.id, colNode.id);\n            });\n            td.addEventListener('keydown', function(ev){\n              if (ev.key === 'Enter' || ev.key === ' ') {\n                ev.preventDefault(); td.click();\n              }\n            });\n\n            tr.appendChild(td);\n          });\n          tbody.appendChild(tr);\n        });\n        table.appendChild(tbody);\n        matrixWrap.appendChild(table);\n      }\n\n      // adjacency list\n      function renderAdjList(){\n        alist.innerHTML = '';\n        if (nodes.length === 0) {\n          alist.innerHTML = '<div class=\"muted-note\">No nodes yet.</div>';\n          return;\n        }\n\n        nodes.forEach(n=>{\n          const div = document.createElement('div');\n          div.className = 'alist-item';\n          const left = document.createElement('div');\n          left.style.display = 'flex';\n          left.style.gap = '8px';\n          const label = document.createElement('div');\n          label.style.fontWeight = 700; label.textContent = n.label;\n          left.appendChild(label);\n\n          const neighbors = getNeighbors(n.id);\n          const right = document.createElement('div');\n          right.className = 'badge';\n          // display in/out or neighbors\n          if (directedMode){\n            const out = neighbors.out.map(id=>nodeLabelById(id)).join(', ') || '—';\n            const inp = neighbors.in.map(id=>nodeLabelById(id)).join(', ') || '—';\n            right.innerHTML = `<div style=\"text-align:left;\"><small style=\"color:var(--muted)\">out:</small> ${out}</div><div style=\"text-align:left;\"><small style=\"color:var(--muted)\">in:</small> ${inp}</div>`;\n          } else {\n            const nb = neighbors.all.map(id=>nodeLabelById(id)).join(', ') || '—';\n            right.innerHTML = `<small style=\"color:var(--muted)\">neighbors</small><div>${nb}</div>`;\n          }\n\n          div.appendChild(left);\n          div.appendChild(right);\n          alist.appendChild(div);\n        });\n      }\n\n      function nodeLabelById(id){\n        const n = nodes.find(x=>x.id===id);\n        return n ? n.label : id;\n      }\n\n      function getNeighbors(nodeId){\n        if (directedMode){\n          const out = edges.filter(e=>e.sourceId===nodeId).map(e=>e.targetId);\n          const inp = edges.filter(e=>e.targetId===nodeId).map(e=>e.sourceId);\n          return { out, in: inp };\n        } else {\n          const all = edges.reduce((acc,e)=>{\n            if (e.sourceId===nodeId) acc.push(e.targetId);\n            else if (e.targetId===nodeId) acc.push(e.sourceId);\n            return acc;\n          }, []);\n          return { all };\n        }\n      }\n\n      function isEdgePresent(srcId, tgtId){\n        if (directedMode){\n          return edges.some(e => e.directed && e.sourceId===srcId && e.targetId===tgtId);\n        } else {\n          return edges.some(e => !e.directed && ((e.sourceId===srcId && e.targetId===tgtId) || (e.sourceId===tgtId && e.targetId===srcId)));\n        }\n      }\n\n      function toggleEdgeFromMatrix(srcId, tgtId){\n        // If in undirected mode and src==tgt do nothing\n        if (!directedMode && srcId===tgtId) return;\n\n        // If present, remove; else add (in directed mode add directed edge from src->tgt)\n        if (isEdgePresent(srcId,tgtId)){\n          // remove matching edges\n          edges = edges.filter(e=>{\n            if (directedMode){\n              return !(e.directed && e.sourceId===srcId && e.targetId===tgtId);\n            } else {\n              return !( !e.directed && ((e.sourceId===srcId && e.targetId===tgtId) || (e.sourceId===tgtId && e.targetId===srcId)) );\n            }\n          });\n        } else {\n          createEdge(srcId,tgtId,directedMode);\n        }\n        renderAll();\n        flashMatrixCells([srcId,tgtId]);\n      }\n\n      function flashMatrixCells(pairIds){\n        // highlight cells corresponding to pair\n        const tds = matrixWrap.querySelectorAll('td');\n        tds.forEach(td=>{\n          const r = td.getAttribute('data-row'), c = td.getAttribute('data-col');\n          if (pairIds.includes(r) && pairIds.includes(c)){\n            td.classList.add('flash');\n            setTimeout(()=>td.classList.remove('flash'),700);\n          }\n        });\n      }\n\n      function updateDegreeInfo(){\n        if (!selectedNode) return;\n        if (directedMode){\n          const out = edges.filter(e=>e.sourceId===selectedNode.id).length;\n          const inp = edges.filter(e=>e.targetId===selectedNode.id).length;\n          degreeBox.innerHTML = `<strong style=\"color:var(--accent)\">${selectedNode.label}</strong> — out-degree: <strong>${out}</strong>, in-degree: <strong>${inp}</strong>`;\n        } else {\n          const deg = edges.reduce((acc,e)=>{\n            if (e.sourceId===selectedNode.id || e.targetId===selectedNode.id) return acc+1;\n            return acc;\n          },0);\n          degreeBox.innerHTML = `<strong style=\"color:var(--accent)\">${selectedNode.label}</strong> — degree: <strong>${deg}</strong>`;\n        }\n      }\n\n      // UI actions\n      addNodeBtn.addEventListener('click', () => {\n        placeMode = true;\n        addNodeBtn.textContent = 'Click Canvas';\n        addNodeBtn.disabled = true;\n        setTimeout(()=>{ addNodeBtn.textContent = 'Add Node'; addNodeBtn.disabled = false; placeMode = false; }, 4000); // fallback\n      });\n\n      // Double click quickly to add node\n      graphArea.addEventListener('dblclick', function(ev){\n        updateGraphRect();\n        const x = ev.clientX - graphRect.left;\n        const y = ev.clientY - graphRect.top;\n        createNodeAt(x,y,'N'+(nextNodeId));\n      });\n\n      graphArea.addEventListener('click', function(ev){\n        // if in place mode (from Add Node button)\n        if (placeMode){\n          updateGraphRect();\n          const x = ev.clientX - graphRect.left;\n          const y = ev.clientY - graphRect.top;\n          createNodeAt(x,y,'N'+(nextNodeId));\n          placeMode = false;\n          addNodeBtn.textContent = 'Add Node';\n          return;\n        }\n        // if clicking empty area, deselect\n        if (ev.target === graphArea || ev.target === graphSvg){\n          // cancel add-edge if active\n          if (addingEdge){\n            addingEdge = false;\n            pendingSource = null;\n            addEdgeBtn.textContent = 'Add Edge';\n            addEdgeBtn.classList.remove('active');\n          }\n          selectNode(null);\n        }\n      });\n\n      addEdgeBtn.addEventListener('click', function(){\n        addingEdge = !addingEdge;\n        pendingSource = null;\n        addEdgeBtn.classList.toggle('active', addingEdge);\n        addEdgeBtn.textContent = addingEdge ? 'Select Source → Target' : 'Add Edge';\n        if (addingEdge) {\n          flashNotice('Add Edge: click source node, then target node');\n        }\n      });\n\n      clearBtn.addEventListener('click', function(){\n        if (!confirm('Clear all nodes and edges?')) return;\n        nodes.forEach(n=> n.el.remove());\n        nodes = [];\n        edges = [];\n        nextNodeId = 1;\n        selectedNode = null;\n        renderAll();\n        selectedName.textContent = 'None';\n        degreeBox.textContent = 'Select a node to see degree info.';\n      });\n\n      sampleBtn.addEventListener('click', function(){\n        // Clear then create sample nodes and edges\n        nodes.forEach(n=> n.el.remove());\n        nodes = []; edges = []; nextNodeId = 1; selectedNode=null;\n        // create nodes at preset positions relative to graph area\n        updateGraphRect();\n        const w = graphRect.width, h = graphRect.height;\n        const coords = [\n          {x: w*0.25, y: h*0.3},\n          {x: w*0.6,  y: h*0.25},\n          {x: w*0.8,  y: h*0.6},\n          {x: w*0.45, y: h*0.7},\n          {x: w*0.2,  y: h*0.6}\n        ];\n        coords.forEach((c,i)=> createNodeAt(c.x, c.y, 'N'+(i+1)));\n        // Add a few edges\n        setTimeout(()=>{\n          createEdge(nodes[0].id, nodes[1].id, directedMode);\n          createEdge(nodes[1].id, nodes[2].id, directedMode);\n          createEdge(nodes[2].id, nodes[3].id, directedMode);\n          createEdge(nodes[3].id, nodes[0].id, directedMode);\n          if (!directedMode){\n            createEdge(nodes[4].id, nodes[0].id, false);\n          } else {\n            createEdge(nodes[0].id, nodes[4].id, true);\n          }\n          renderAll();\n        }, 240);\n      });\n\n      // Mode toggle\n      function setDirectedMode(on){\n        directedMode = !!on;\n        switchKnob.parentElement.classList.toggle('on', directedMode);\n        modeLabel.textContent = directedMode ? 'Directed' : 'Undirected';\n        modeToggle.setAttribute('aria-checked', String(directedMode));\n        // Note: switching modes converts edges to preserved direction flags when toggling to directed,\n        // and to undirected edges when toggling to undirected keeping connectivity.\n        if (!directedMode){\n          // convert all edges to undirected: remove duplicates between pairs and merge\n          const pairs = {};\n          edges.forEach(e=>{\n            const a = e.sourceId, b = e.targetId;\n            const key = a < b ? a + '|' + b : b + '|' + a;\n            pairs[key] = { sourceId: a, targetId: b };\n          });\n          edges = Object.keys(pairs).map(k=>{\n            const p = pairs[k];\n            return { id: uid('edge'), sourceId: p.sourceId, targetId: p.targetId, directed: false };\n          });\n        } else {\n          // convert all edges to directed: keep existing orientations as they were stored\n          // For undirected edges, arbitrarily set sourceId->targetId\n          edges = edges.map(e => {\n            if (e.directed) return e;\n            return { id: uid('edge'), sourceId: e.sourceId, targetId: e.targetId, directed: true };\n          });\n        }\n        renderAll();\n      }\n\n      modeToggle.addEventListener('click', function(){\n        setDirectedMode(!directedMode);\n      });\n      modeToggle.addEventListener('keydown', function(ev){\n        if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); modeToggle.click(); }\n      });\n\n      // Some small utility: flash a temporary message in the graph area\n      function flashNotice(text){\n        const t = document.createElement('div');\n        t.style.position = 'absolute';\n        t.style.left = '50%';\n        t.style.top = '8px';\n        t.style.transform = 'translateX(-50%)';\n        t.style.background = 'linear-gradient(90deg, rgba(6,182,212,0.12), rgba(6,182,212,0.06))';\n        t.style.color = 'var(--accent)';\n        t.style.padding = '8px 12px';\n        t.style.borderRadius = '8px';\n        t.style.fontWeight = '700';\n        t.style.zIndex = 40;\n        t.textContent = text;\n        graphArea.appendChild(t);\n        setTimeout(()=>{ t.style.transition = 'opacity 300ms ease'; t.style.opacity = '0'; }, 900);\n        setTimeout(()=> t.remove(), 1300);\n      }\n\n      // Click on matrix cell toggles edge; implemented above.\n\n      // Initialize with undirected mode as default\n      setDirectedMode(false);\n\n      // Initial sample\n      // sampleBtn.click();\n\n      // Update graphRect on pointer interactions\n      graphArea.addEventListener('pointerdown', updateGraphRect);\n      graphArea.addEventListener('pointerup', updateGraphRect);\n      graphArea.addEventListener('pointermove', updateGraphRect);\n\n      // Expose small keyboard shortcut: 'E' to toggle add-edge, 'N' to add node mode, 'D' to toggle directed\n      document.addEventListener('keydown', function(ev){\n        if (ev.target && (ev.target.tagName === 'INPUT' || ev.target.tagName === 'TEXTAREA')) return;\n        if (ev.key === 'e' || ev.key === 'E') addEdgeBtn.click();\n        if (ev.key === 'n' || ev.key === 'N') addNodeBtn.click();\n        if (ev.key === 'd' || ev.key === 'D') modeToggle.click();\n      });\n\n      // Make sure nodes store center coordinates from initial placement\n      // When creating nodes using createNodeAt, we need to set node.x/node.y based on element position\n      // Adjust createNodeAt to compute node.x/y after append\n      // But ensure existing nodes have .x/.y correct on load\n      // (already assigned)\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Graph (Directed/Undirected).\n\n**Project Overview:**\nTopic: Graph (Directed/Undirected)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Graph (Directed/Undirected)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Graph Builder (Directed vs Undirected)",
      "description": "Finite state machine modeling the user interactions, modes, and visual behaviours of the interactive graph module (node creation, dragging, edge creation, matrix toggles, mode switching, sample/clear actions and transient animations).",
      "states": [
        {
          "name": "idle",
          "onEnter": "renderAll() // default render and ensure UI reflects current data (matrix, list, edges, highlights)",
          "onExit": "",
          "on": {
            "CLICK_ADD_NODE_BTN": "placing_node",
            "DOUBLE_CLICK_CANVAS": "idle",
            "PLACE_NODE_CLICK": "idle",
            "CLICK_ADD_EDGE_BTN": "adding_edge_waiting_source",
            "CLICK_NODE": "selected",
            "NODE_DRAG_START": "dragging",
            "CLICK_EMPTY_AREA": "idle",
            "CLICK_CLEAR_BTN": "idle",
            "CLICK_SAMPLE_BTN": "sample_loading",
            "TOGGLE_MODE": "toggling_mode",
            "MATRIX_CELL_CLICK": "idle",
            "KEY_SHORTCUT_ADD_NODE": "placing_node",
            "KEY_SHORTCUT_ADD_EDGE": "adding_edge_waiting_source",
            "KEY_SHORTCUT_TOGGLE_DIRECTED": "toggling_mode"
          }
        },
        {
          "name": "placing_node",
          "onEnter": "placeMode = true; update Add Node button text to 'Click Canvas'; start fallback PLACE_NODE_TIMEOUT timer (4s) that will cancel placement if no click",
          "onExit": "clear PLACE_NODE_TIMEOUT; placeMode = false; reset Add Node button text and enabled state",
          "on": {
            "PLACE_NODE_CLICK": "idle",
            "PLACE_NODE_TIMEOUT": "idle",
            "DOUBLE_CLICK_CANVAS": "idle",
            "CLICK_EMPTY_AREA": "placing_node"
          }
        },
        {
          "name": "adding_edge_waiting_source",
          "onEnter": "addingEdge = true; pendingSource = null; addEdgeBtn active=true; flashNotice('Add Edge: click source node, then target node')",
          "onExit": "if pendingSource then highlightNode(pendingSource.id,false); pendingSource = null; addEdgeBtn active=false; addEdgeBtn.text='Add Edge'; addingEdge = false",
          "on": {
            "CLICK_NODE": "adding_edge_waiting_target",
            "CLICK_ADD_EDGE_BTN": "idle",
            "CLICK_EMPTY_AREA": "idle",
            "CANCEL_ADD_EDGE": "idle",
            "KEY_SHORTCUT_ADD_EDGE": "idle"
          }
        },
        {
          "name": "adding_edge_waiting_target",
          "onEnter": "pendingSource set (the clicked node); highlightNode(pendingSource.id,true)",
          "onExit": "highlightNode(pendingSource?.id,false); pendingSource = null; addEdgeBtn active=false; addEdgeBtn.text='Add Edge'; addingEdge = false",
          "on": {
            "CLICK_NODE": "idle",
            "SELF_LOOP_ATTEMPT": "adding_edge_waiting_source",
            "CLICK_ADD_EDGE_BTN": "idle",
            "CLICK_EMPTY_AREA": "idle",
            "CANCEL_ADD_EDGE": "idle"
          }
        },
        {
          "name": "dragging",
          "onEnter": "dragging = true; node gets 'selected' class; capture pointer; updateGraphRect()",
          "onExit": "dragging = false; release pointer; updateEdgesPositions(draggedNode.id); remove 'selected' visual (but keep logical selection)",
          "on": {
            "NODE_DRAG_MOVE": "dragging",
            "NODE_DRAG_END": "selected",
            "CLICK_EMPTY_AREA": "selected"
          }
        },
        {
          "name": "selected",
          "onEnter": "selectedNode set; selectedName UI updated; updateDegreeInfo(); renderAll() to show highlights",
          "onExit": "selectedNode = null; selectedName = 'None'; degreeBox reset; renderAll()",
          "on": {
            "CLICK_NODE": "idle",
            "CLICK_ADD_EDGE_BTN": "adding_edge_waiting_source",
            "NODE_DRAG_START": "dragging",
            "CLICK_EMPTY_AREA": "idle",
            "MATRIX_CELL_CLICK": "selected",
            "TOGGLE_MODE": "toggling_mode",
            "KEY_SHORTCUT_ADD_EDGE": "adding_edge_waiting_source"
          }
        },
        {
          "name": "sample_loading",
          "onEnter": "clear existing nodes/edges; nextNodeId reset; create sample nodes at preset positions; schedule sample edges creation (timeout ~240ms) performing createEdge(...) which animates and then renderAll()",
          "onExit": "cancel scheduled timeouts if any; renderAll();",
          "on": {
            "SAMPLE_EDGES_CREATED": "idle",
            "CLICK_CLEAR_BTN": "idle",
            "TOGGLE_MODE": "toggling_mode"
          }
        },
        {
          "name": "toggling_mode",
          "onEnter": "directedMode toggled; update switch UI; set aria-checked; convert edges (undirected->directed or directed->undirected) per conversion logic; renderAll()",
          "onExit": "",
          "on": {
            "MODE_TOGGLE_COMPLETE": "idle",
            "CLICK_ADD_EDGE_BTN": "adding_edge_waiting_source",
            "CLICK_SAMPLE_BTN": "sample_loading"
          }
        }
      ],
      "events": [
        "CLICK_ADD_NODE_BTN",
        "PLACE_NODE_CLICK",
        "PLACE_NODE_TIMEOUT",
        "DOUBLE_CLICK_CANVAS",
        "CLICK_ADD_EDGE_BTN",
        "CLICK_NODE",
        "NODE_DRAG_START",
        "NODE_DRAG_MOVE",
        "NODE_DRAG_END",
        "CLICK_EMPTY_AREA",
        "CLICK_CLEAR_BTN",
        "CLICK_SAMPLE_BTN",
        "TOGGLE_MODE",
        "MODE_TOGGLE_COMPLETE",
        "MATRIX_CELL_CLICK",
        "MATRIX_CELL_TOGGLE_COMPLETE",
        "EDGE_CREATE_SUCCESS",
        "EDGE_CREATE_DUPLICATE",
        "SELF_LOOP_ATTEMPT",
        "SAMPLE_EDGES_CREATED",
        "CANCEL_ADD_EDGE",
        "KEY_SHORTCUT_ADD_EDGE",
        "KEY_SHORTCUT_ADD_NODE",
        "KEY_SHORTCUT_TOGGLE_DIRECTED"
      ],
      "notes": "Implementation notes and mapping of actions: \n- Mode (directedMode boolean) is orthogonal to the primary state machine: toggling_mode state runs conversion logic and then returns to idle. Mode affects edge creation, adjacency rendering and matrix behaviour.\n- Place node flow: clicking Add Node enters placing_node. A fallback timeout (~4s) resets placeMode. Double-click on canvas immediately creates a node (self-loop prevention applies elsewhere).\n- Add edge flow: adding_edge_waiting_source -> user clicks a source node -> adding_edge_waiting_target (pendingSource set) -> user clicks target node -> createEdge invoked (may animate). If target equals source, SELF_LOOP_ATTEMPT occurs and machine returns to waiting_source; if duplicate edge detected createEdge triggers EDGE_CREATE_DUPLICATE (matrix cells flash) but the UI still exits Add Edge mode as implemented.\n- Dragging is a transient state entered by pointerdown on a node, consuming NODE_DRAG_MOVE events and ending with NODE_DRAG_END which returns to selected (logical selection remains). Visual 'selected' class is added on drag start and removed on drag end (code removes class but selectedNode remains set).\n- Matrix cell clicks (MATRIX_CELL_CLICK) are handled from idle/selected states: toggleEdgeFromMatrix performs add/remove (with flashMatrixCells). After toggle the table cell briefly flashes (UI animation) but state remains idle/selected.\n- Sample graph loading: sample_loading creates nodes synchronously then schedules edges to be added after a timeout; when edges added SAMPLE_EDGES_CREATED transitions back to idle.\n- Clear: CLICK_CLEAR_BTN triggers a confirm() then clears nodes/edges and resets relevant counters and UI; modeled as an immediate idle self-transition with onEnter action 'clearAll'.\n- Keyboard shortcuts map to the same events (N -> CLICK_ADD_NODE_BTN/PLACE_NODE flows, E -> CLICK_ADD_EDGE_BTN, D -> TOGGLE_MODE).\n- Transient visuals/animations (edge draw animation, matrix cell flash, flashNotice message) are represented as onEnter actions on the relevant states or as actions performed on events (e.g. createEdge draws with animation and flashMatrixCells on duplicate). These are ephemeral and do not create dedicated long-lived FSM states beyond the small 'sample_loading' and 'placing_node' durations.\n- Selection toggling: clicking the currently selected node toggles selection off (selected -> idle). Clicking empty canvas also deselects.\n\nThis FSM intentionally models human-visible, persistent interaction modes (placing a node, adding an edge with source/target steps, dragging, selection, sample-loading and mode toggling) and summarizes the primary onEnter/onExit UI/data actions executed by the module.",
      "version": "1.0"
    }
  },
  {
    "id": "6fe90460-b40a-11f0-8f04-37d078910466",
    "timestamp": "2025-10-28T14:30:53.294Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Weighted Graph",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Weighted Graph — Interactive Dijkstra Exploration</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --sidebar-width: 340px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #38bdf8;\n      --muted: #94a3b8;\n      --success: #34d399;\n      --danger: #fb7185;\n      --glass: rgba(255,255,255,0.03);\n      --radius: 10px;\n      --elev: 10px;\n    }\n    *{box-sizing:border-box}\n    html,body{height:100%}\n    body{\n      margin:0;\n      padding:var(--safe-margin);\n      background: linear-gradient(180deg,#021124 0%, #071022 60%);\n      color:#e6eef8;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      min-height:100vh;\n      display:flex;\n      gap:var(--gap);\n      align-items:stretch;\n    }\n\n    /* Layout */\n    .container{\n      display:flex;\n      gap:var(--gap);\n      width:100%;\n      align-items:stretch;\n    }\n\n    /* Sidebar / Panel */\n    .panel{\n      width:var(--sidebar-width);\n      min-width:260px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:var(--radius);\n      padding:20px;\n      box-shadow: 0 8px 30px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n\n    header.title{\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    header.title h1{\n      margin:0;\n      font-size:16px;\n      letter-spacing:0.2px;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.25;\n    }\n\n    .section{\n      background:var(--glass);\n      border-radius:8px;\n      padding:12px;\n      font-size:13px;\n      line-height:1.3;\n    }\n\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap:10px;\n      margin-top:6px;\n    }\n\n    .btn-row{\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n    }\n\n    button, .icon-btn {\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--accent);\n      padding:8px 10px;\n      border-radius:8px;\n      font-weight:600;\n      cursor:pointer;\n      min-height:40px;\n      display:inline-flex;\n      align-items:center;\n      gap:8px;\n      transition:all 200ms ease;\n    }\n    button:hover{\n      transform:translateY(-2px);\n      box-shadow:0 6px 18px rgba(56,189,248,0.06);\n      border-color:rgba(56,189,248,0.18);\n    }\n    .btn-primary{\n      background:linear-gradient(90deg, rgba(56,189,248,0.12), rgba(52,211,153,0.06));\n      color:var(--accent);\n      border:1px solid rgba(56,189,248,0.18);\n    }\n    .btn-danger{\n      color:var(--danger);\n      border-color:rgba(251,113,133,0.08);\n    }\n    .small{\n      padding:6px 8px;\n      font-size:13px;\n      min-height:36px;\n    }\n\n    .info-row{\n      display:flex;\n      gap:10px;\n      align-items:center;\n      justify-content:space-between;\n    }\n\n    .status{\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n    .dot{\n      width:10px;height:10px;border-radius:50%;\n    }\n    .dot.ready{background:var(--accent)}\n    .dot.busy{background:#fbbf24}\n    .dot.off{background:#64748b}\n\n    /* Canvas area */\n    .canvas-wrap{\n      flex:1;\n      background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.008));\n      border-radius:var(--radius);\n      padding:14px;\n      display:flex;\n      flex-direction:column;\n      min-height:400px;\n      gap:12px;\n    }\n\n    .toolbar{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:flex-start;\n    }\n\n    .hint{\n      color:var(--muted);\n      font-size:13px;\n      margin-left:auto;\n    }\n\n    /* SVG graph */\n    #graph {\n      width:100%;\n      height:calc(100vh - 240px);\n      min-height:360px;\n      background:\n        radial-gradient(1200px 600px at 10% 10%, rgba(56,189,248,0.02), transparent 5%),\n        radial-gradient(900px 400px at 90% 90%, rgba(52,211,153,0.015), transparent 5%);\n      border-radius:8px;\n      overflow:hidden;\n      touch-action: none;\n      position:relative;\n    }\n    svg{width:100%;height:100%}\n\n    /* Node styling */\n    .node {\n      cursor:pointer;\n      transition:transform 160ms ease, box-shadow 160ms ease;\n    }\n    .node circle {\n      fill: #021627;\n      stroke: rgba(56,189,248,0.18);\n      stroke-width:2px;\n      transition:fill 160ms ease, stroke 160ms ease;\n    }\n    .node:hover circle {\n      stroke: rgba(56,189,248,0.36);\n      transform-origin:center;\n      transform:scale(1.04);\n    }\n    .node-label {\n      fill:#e6eef8;\n      font-size:13px;\n      pointer-events:none;\n      font-weight:700;\n      text-anchor:middle;\n      dominant-baseline:middle;\n    }\n\n    /* Distance badge */\n    .dist-badge {\n      fill:rgba(255,255,255,0.04);\n      stroke:rgba(255,255,255,0.06);\n      rx:6; ry:6;\n    }\n    .dist-text {\n      fill:var(--muted);\n      font-size:11px;\n      pointer-events:none;\n      text-anchor:middle;\n      dominant-baseline:middle;\n    }\n\n    /* Edge styling */\n    .edge-line {\n      stroke:rgba(255,255,255,0.06);\n      stroke-width:2;\n      transition:stroke 220ms ease, stroke-width 220ms ease, opacity 220ms ease;\n      filter: drop-shadow(0 4px 8px rgba(2,6,23,0.5));\n    }\n    .edge-label {\n      fill:#dbeafe;\n      font-size:12px;\n      font-weight:600;\n      pointer-events:auto;\n      user-select:none;\n    }\n    .edge-label-bg {\n      fill:rgba(2,6,23,0.6);\n      stroke:rgba(255,255,255,0.02);\n      rx:6; ry:6;\n    }\n    .edge-active {\n      stroke: #34d399;\n      stroke-width:4;\n    }\n    .edge-visited {\n      stroke: #fbbf24;\n      stroke-width:3;\n      opacity:0.9;\n    }\n\n    /* Path highlight */\n    .path-highlight {\n      stroke:#60a5fa;\n      stroke-width:5;\n      opacity:0.95;\n    }\n\n    /* Small form elements */\n    input[type=range] {\n      -webkit-appearance:none;\n      appearance:none;\n      height:4px;\n      background:rgba(255,255,255,0.04);\n      border-radius:999px;\n      outline:none;\n    }\n    input[type=range]::-webkit-slider-thumb{\n      -webkit-appearance:none;\n      width:14px;height:14px;border-radius:50%;\n      background:var(--accent);border:2px solid rgba(255,255,255,0.06);\n    }\n\n    label.small-muted{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}\n\n    footer.credits{\n      margin-top:auto;\n      font-size:12px;\n      color:var(--muted);\n    }\n\n    /* Responsive: stack on small screens */\n    @media (max-width:900px){\n      .container{flex-direction:column}\n      .panel{width:100%}\n      .canvas-wrap{width:100%}\n      #graph{height:56vh; min-height:300px}\n    }\n\n    /* Accessibility focus */\n    button:focus, .icon-btn:focus, .node:focus, .edge-label:focus {\n      outline:3px solid rgba(56,189,248,0.18);\n      outline-offset:3px;\n    }\n\n    /* Minor animations */\n    .pulse {\n      animation: pulse 900ms ease;\n    }\n    @keyframes pulse {\n      0% { transform:scale(1); opacity:1; }\n      50% { transform:scale(1.06); opacity:0.9; }\n      100% { transform:scale(1); opacity:1; }\n    }\n\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"main\" aria-label=\"Weighted Graph Interactive Module\">\n    <!-- Sidebar with design plan and controls -->\n    <aside class=\"panel\" aria-labelledby=\"module-title\">\n      <header class=\"title\">\n        <div>\n          <h1 id=\"module-title\">Weighted Graph — Shortest Path (Dijkstra)</h1>\n          <div class=\"muted\">Interactive exploration: add nodes, connect edges with weights, then visualize Dijkstra.</div>\n        </div>\n      </header>\n\n      <div class=\"section\" aria-describedby=\"objective\">\n        <strong>Learning Objective</strong>\n        <p id=\"objective\" class=\"muted\" style=\"margin:8px 0 0 0\">\n          After using this module, you will understand how weighted graphs represent distances and how Dijkstra's algorithm\n          finds the shortest path from a chosen source to a target through iterative relaxation of edge weights.\n        </p>\n      </div>\n\n      <div class=\"section\" aria-describedby=\"interaction\">\n        <strong>Interaction Design</strong>\n        <div id=\"interaction\" class=\"muted\" style=\"margin-top:8px\">\n          - Click \"Add Node\" then click the canvas to create a node. Drag nodes to rearrange.<br>\n          - Click \"Add Edge\", then click source node then target node; a weight prompt appears (positive number).<br>\n          - Double-click an edge weight to edit it. Click a node to set Source (green) and Target (red).<br>\n          - Press \"Run\" to animate Dijkstra step-by-step. Use \"Step\" to advance manually. Speed slider controls the animation pace.<br>\n          Visual feedback: node distance badges update smoothly; edges flash when relaxed; final shortest path highlighted.\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <strong>Layout Description</strong>\n        <div class=\"muted\" style=\"margin-top:8px\">\n          - Safe margins: 24px on all sides (page padding).<br>\n          - Minimum spacing: 16px gap used between major controls and sections.<br>\n          - Left panel holds instructions and controls (fixed width). Right area is the SVG canvas (flexible).<br>\n          - Accessible: keyboard shortcuts (N:Add node, E:Add edge, D:Delete, R:Run), focus outlines, ARIA labels, color contrast.\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <strong>Controls</strong>\n        <div class=\"controls\" aria-label=\"Graph controls\">\n          <div class=\"btn-row\" role=\"toolbar\" aria-label=\"Toolbar\">\n            <button id=\"btn-add-node\" class=\"btn-primary small\" title=\"Add Node (N)\">Add Node (N)</button>\n            <button id=\"btn-add-edge\" class=\"small\" title=\"Add Edge (E)\">Add Edge (E)</button>\n            <button id=\"btn-delete\" class=\"small\" title=\"Delete Mode (D)\">Delete Mode (D)</button>\n            <button id=\"btn-reset\" class=\"small btn-danger\" title=\"Clear graph\">Reset</button>\n          </div>\n\n          <div class=\"btn-row\" style=\"margin-top:6px\">\n            <button id=\"btn-set-source\" class=\"small\" title=\"Set Source\">Set Source</button>\n            <button id=\"btn-set-target\" class=\"small\" title=\"Set Target\">Set Target</button>\n            <button id=\"btn-run\" class=\"btn-primary small\" title=\"Run Dijkstra (R)\">Run (R)</button>\n            <button id=\"btn-step\" class=\"small\" title=\"Step through algorithm\">Step</button>\n          </div>\n\n          <div class=\"info-row\" style=\"margin-top:8px\">\n            <div>\n              <label class=\"small-muted\">Animation speed</label>\n              <input type=\"range\" id=\"speed\" min=\"0.2\" max=\"2\" value=\"1\" step=\"0.1\" aria-label=\"Animation speed\">\n            </div>\n            <div class=\"status\" aria-live=\"polite\">\n              <div class=\"dot off\" id=\"status-dot\" aria-hidden=\"true\"></div>\n              <div id=\"status-text\" class=\"muted\" style=\"font-size:13px\">Idle</div>\n            </div>\n          </div>\n\n          <div style=\"margin-top:8px\" class=\"muted\">\n            Shortcuts: N = Add Node · E = Add Edge · D = Delete Mode · R = Run/Reset\n          </div>\n        </div>\n      </div>\n\n      <footer class=\"credits\">\n        Built with vanilla HTML/CSS/JS — interactive learning tool for weighted graphs.\n      </footer>\n    </aside>\n\n    <!-- Main interactive canvas -->\n    <main class=\"canvas-wrap\" aria-label=\"Graph canvas and visualization area\">\n      <div class=\"toolbar\" role=\"toolbar\" aria-hidden=\"false\">\n        <div class=\"muted\">Canvas:</div>\n        <div class=\"hint\">Click canvas to create nodes when in Add Node mode. Drag nodes to move.</div>\n      </div>\n\n      <div id=\"graph\" aria-label=\"Graph drawing area\">\n        <svg id=\"svg-root\" viewBox=\"0 0 1200 800\" role=\"img\" aria-labelledby=\"svg-title\">\n          <title id=\"svg-title\">Weighted graph drawing area</title>\n          <defs>\n            <filter id=\"shadow\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\n              <feDropShadow dx=\"0\" dy=\"6\" stdDeviation=\"12\" flood-color=\"#000\" flood-opacity=\"0.35\"/>\n            </filter>\n          </defs>\n\n          <!-- Edges group -->\n          <g id=\"edges\"></g>\n\n          <!-- Nodes group on top -->\n          <g id=\"nodes\"></g>\n        </svg>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    (function(){\n      /* ---------- Basic state and utilities ---------- */\n      const svg = document.getElementById('svg-root');\n      const edgesLayer = document.getElementById('edges');\n      const nodesLayer = document.getElementById('nodes');\n      const graph = document.getElementById('graph');\n\n      const btnAddNode = document.getElementById('btn-add-node');\n      const btnAddEdge = document.getElementById('btn-add-edge');\n      const btnDelete = document.getElementById('btn-delete');\n      const btnReset = document.getElementById('btn-reset');\n      const btnRun = document.getElementById('btn-run');\n      const btnStep = document.getElementById('btn-step');\n      const btnSetSource = document.getElementById('btn-set-source');\n      const btnSetTarget = document.getElementById('btn-set-target');\n      const statusDot = document.getElementById('status-dot');\n      const statusText = document.getElementById('status-text');\n      const speedInput = document.getElementById('speed');\n\n      let mode = null; // 'add-node','add-edge','delete','idle'\n      let nodes = []; // {id,label,x,y,el}\n      let edges = []; // {id,a,b,weight,line,group,labelEl}\n      let nextNodeId = 0;\n      let sourceId = null, targetId = null;\n      let addingEdgeFrom = null;\n      let dragging = null;\n      let animationTimer = null;\n      let dijkstraState = null; // generator\n      let autoPlay = false;\n\n      const minSpacing = 16; // consistent spacing used in UI description\n\n      function setStatus(text, state){\n        statusText.textContent = text;\n        statusDot.className = 'dot ' + (state || 'off');\n      }\n\n      setStatus('Idle','off');\n\n      /* ---------- Helpers for SVG elements ---------- */\n      function createNodeSVG(node){\n        const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n        g.setAttribute('class','node');\n        g.setAttribute('data-id', node.id);\n        g.setAttribute('tabindex', 0);\n        g.setAttribute('role','button');\n        g.setAttribute('aria-label', `Node ${node.label}`);\n\n        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n        circle.setAttribute('r', 26);\n        circle.setAttribute('cx', node.x);\n        circle.setAttribute('cy', node.y);\n\n        const label = document.createElementNS('http://www.w3.org/2000/svg','text');\n        label.setAttribute('class','node-label');\n        label.setAttribute('x', node.x);\n        label.setAttribute('y', node.y);\n        label.textContent = node.label;\n\n        // Distance badge (small rounded rect + text)\n        const distGroup = document.createElementNS('http://www.w3.org/2000/svg','g');\n        distGroup.setAttribute('class','dist-group');\n        distGroup.setAttribute('transform', `translate(${node.x+30}, ${node.y-30})`);\n\n        const badge = document.createElementNS('http://www.w3.org/2000/svg','rect');\n        badge.setAttribute('class','dist-badge');\n        badge.setAttribute('width', 44);\n        badge.setAttribute('height', 22);\n        badge.setAttribute('x', -22);\n        badge.setAttribute('y', -11);\n\n        const distText = document.createElementNS('http://www.w3.org/2000/svg','text');\n        distText.setAttribute('class','dist-text');\n        distText.setAttribute('x', 0);\n        distText.setAttribute('y', 0);\n        distText.textContent = '∞';\n\n        distGroup.appendChild(badge);\n        distGroup.appendChild(distText);\n\n        g.appendChild(circle);\n        g.appendChild(label);\n        g.appendChild(distGroup);\n\n        // Events\n        g.addEventListener('mousedown', nodeMouseDown);\n        g.addEventListener('touchstart', nodeTouchStart, {passive:false});\n        g.addEventListener('dblclick', () => { /* reserved */ });\n        g.addEventListener('click', nodeClick);\n        g.addEventListener('keydown', (e)=>{ if(e.key==='Enter') nodeClick(); });\n\n        // store element refs\n        node.el = {group:g, circle:circle, label:label, distText:distText, distGroup:distGroup};\n        nodesLayer.appendChild(g);\n      }\n\n      function createEdgeSVG(edge){\n        const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n        g.setAttribute('class','edge');\n        g.setAttribute('data-id', edge.id);\n\n        const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n        line.setAttribute('class','edge-line');\n        line.setAttribute('x1', edge.ax);\n        line.setAttribute('y1', edge.ay);\n        line.setAttribute('x2', edge.bx);\n        line.setAttribute('y2', edge.by);\n        line.setAttribute('stroke-linecap','round');\n\n        // label group: background rect + text\n        const lblGroup = document.createElementNS('http://www.w3.org/2000/svg','g');\n        lblGroup.setAttribute('class','edge-label-group');\n        lblGroup.setAttribute('tabindex',0);\n        lblGroup.setAttribute('role','button');\n        lblGroup.addEventListener('dblclick', ()=>{ editEdgeWeight(edge); });\n        lblGroup.addEventListener('keydown', (e)=>{ if(e.key==='Enter') editEdgeWeight(edge); });\n\n        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');\n        rect.setAttribute('class','edge-label-bg');\n        rect.setAttribute('width', 36);\n        rect.setAttribute('height', 22);\n        rect.setAttribute('x', -18);\n        rect.setAttribute('y', -11);\n\n        const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n        txt.setAttribute('class','edge-label');\n        txt.setAttribute('text-anchor','middle');\n        txt.setAttribute('dominant-baseline','middle');\n        txt.setAttribute('x', 0);\n        txt.setAttribute('y', 0);\n        txt.textContent = edge.weight;\n\n        lblGroup.appendChild(rect);\n        lblGroup.appendChild(txt);\n\n        // position label at midpoint\n        const mx = (edge.ax + edge.bx)/2;\n        const my = (edge.ay + edge.by)/2;\n        lblGroup.setAttribute('transform', `translate(${mx}, ${my})`);\n\n        g.appendChild(line);\n        g.appendChild(lblGroup);\n\n        // events\n        g.addEventListener('click', (e)=> {\n          e.stopPropagation();\n          if(mode==='delete'){ removeEdge(edge.id); }\n        });\n\n        edgesLayer.appendChild(g);\n\n        edge.el = {group:g, line:line, labelGroup:lblGroup, labelText:txt, labelRect:rect};\n      }\n\n      function updateNodePosition(node){\n        const {x,y} = node;\n        node.el.circle.setAttribute('cx', x);\n        node.el.circle.setAttribute('cy', y);\n        node.el.label.setAttribute('x', x);\n        node.el.label.setAttribute('y', y);\n        node.el.distGroup.setAttribute('transform', `translate(${x+30}, ${y-30})`);\n      }\n\n      function updateEdgePosition(edge){\n        const a = nodeById(edge.a), b = nodeById(edge.b);\n        edge.ax = a.x; edge.ay = a.y;\n        edge.bx = b.x; edge.by = b.y;\n        edge.el.line.setAttribute('x1', edge.ax);\n        edge.el.line.setAttribute('y1', edge.ay);\n        edge.el.line.setAttribute('x2', edge.bx);\n        edge.el.line.setAttribute('y2', edge.by);\n        const mx = (edge.ax + edge.bx)/2;\n        const my = (edge.ay + edge.by)/2;\n        edge.el.labelGroup.setAttribute('transform', `translate(${mx}, ${my})`);\n        edge.el.labelText.textContent = edge.weight;\n      }\n\n      function nodeById(id){ return nodes.find(n=>n.id===id); }\n      function edgeById(id){ return edges.find(e=>e.id===id); }\n\n      /* ---------- Node and Edge operations ---------- */\n      function addNodeAt(x,y){\n        const label = String.fromCharCode(65 + (nextNodeId % 26));\n        const id = ++nextNodeId;\n        const node = {id, label, x, y};\n        nodes.push(node);\n        createNodeSVG(node);\n        return node;\n      }\n\n      function addEdge(aId,bId,weight){\n        if(aId===bId) return null;\n        // avoid duplicate edge\n        if(edges.some(e=> (e.a===aId && e.b===bId) || (e.a===bId && e.b===aId) )){\n          alert('Edge already exists between these nodes.');\n          return null;\n        }\n        const a = nodeById(aId), b = nodeById(bId);\n        const id = 'e' + (edges.length + 1);\n        const edge = {id, a:aId, b:bId, weight: Number(weight), ax:a.x, ay:a.y, bx:b.x, by:b.y};\n        edges.push(edge);\n        createEdgeSVG(edge);\n        // send edges behind nodes\n        edgesLayer.parentNode.insertBefore(edgesLayer, nodesLayer);\n        return edge;\n      }\n\n      function removeNode(id){\n        // remove edges connected to it\n        const related = edges.filter(e => e.a===id || e.b===id).map(e=>e.id);\n        related.forEach(removeEdge);\n        const idx = nodes.findIndex(n=>n.id===id);\n        if(idx>=0){\n          const node = nodes[idx];\n          nodesLayer.removeChild(node.el.group);\n          nodes.splice(idx,1);\n        }\n        if(sourceId===id) sourceId=null;\n        if(targetId===id) targetId=null;\n      }\n      function removeEdge(id){\n        const idx = edges.findIndex(e=>e.id===id);\n        if(idx>=0){\n          const edge = edges[idx];\n          edgesLayer.removeChild(edge.el.group);\n          edges.splice(idx,1);\n        }\n      }\n\n      function editEdgeWeight(edge){\n        const val = prompt('Enter new positive weight', String(edge.weight));\n        if(val!==null){\n          const w = parseFloat(val);\n          if(!isFinite(w) || w<=0){\n            alert('Please enter a positive number.');\n            return;\n          }\n          edge.weight = w;\n          edge.el.labelText.textContent = w;\n          pulseElement(edge.el.labelGroup);\n        }\n      }\n\n      /* ---------- Interaction: Mouse & Touch ---------- */\n      function getSvgPoint(evt){\n        const CTM = svg.getScreenCTM();\n        if(evt.touches && evt.touches[0]) evt = evt.touches[0];\n        return {\n          x: (evt.clientX - CTM.e) / CTM.a,\n          y: (evt.clientY - CTM.f) / CTM.d\n        };\n      }\n\n      // Canvas click for adding nodes\n      graph.addEventListener('click', (evt)=>{\n        if(mode!=='add-node') return;\n        const pt = getSvgPoint(evt);\n        const node = addNodeAt(pt.x, pt.y);\n        updateNodeVisuals();\n      });\n\n      // Node events\n      function nodeClick(evt){\n        evt.stopPropagation();\n        const id = this.getAttribute ? this.getAttribute('data-id') : this.group.dataset.id;\n        const nid = Number(id);\n        if(mode==='delete'){\n          removeNode(nid);\n          return;\n        }\n        if(mode==='add-edge'){\n          if(!addingEdgeFrom){\n            addingEdgeFrom = nid;\n            setStatus('Select target node for edge','busy');\n            highlightNode(nid, true);\n          } else {\n            const from = addingEdgeFrom;\n            const to = nid;\n            highlightingClear();\n            addingEdgeFrom = null;\n            setStatus('Idle','off');\n            if(from===to) return;\n            const weight = prompt('Enter edge weight (positive number)', '1');\n            if(weight===null) return;\n            const w = parseFloat(weight);\n            if(!isFinite(w) || w<=0){ alert('Invalid weight'); return; }\n            addEdge(from,to,w);\n            updateAllEdges();\n          }\n        } else if(mode==='set-source'){\n          sourceId = nid;\n          setStatus('Source set','ready');\n          highlightNode(nid, true, 'source');\n          mode = null;\n        } else if(mode==='set-target'){\n          targetId = nid;\n          setStatus('Target set','ready');\n          highlightNode(nid, true, 'target');\n          mode = null;\n        } else {\n          // Toggle selection: allow setting source/target faster\n          if(!sourceId){ sourceId = nid; highlightNode(nid,true,'source'); setStatus('Source selected','ready'); }\n          else if(!targetId && nid!==sourceId){ targetId = nid; highlightNode(nid,true,'target'); setStatus('Target selected','ready'); }\n          else if(nid===sourceId){ sourceId=null; highlightNode(nid,false); setStatus('Source cleared','off'); }\n          else if(nid===targetId){ targetId=null; highlightNode(nid,false); setStatus('Target cleared','off'); }\n        }\n      }\n\n      function highlightNode(id, on, role){\n        const node = nodeById(id);\n        if(!node) return;\n        if(on){\n          if(role==='source'){ node.el.circle.setAttribute('fill','#052e21'); node.el.circle.setAttribute('stroke','#34d399'); }\n          else if(role==='target'){ node.el.circle.setAttribute('fill','#2b0217'); node.el.circle.setAttribute('stroke','#fb7185'); }\n          else node.el.circle.setAttribute('stroke','#60a5fa');\n        } else {\n          node.el.circle.setAttribute('fill','#021627');\n          node.el.circle.setAttribute('stroke','rgba(56,189,248,0.18)');\n        }\n      }\n\n      function highlightingClear(){\n        nodes.forEach(n => { n.el.circle.setAttribute('stroke','rgba(56,189,248,0.18)'); });\n      }\n\n      // Dragging nodes\n      function nodeMouseDown(evt){\n        evt.preventDefault();\n        const id = Number(this.getAttribute('data-id'));\n        const node = nodeById(id);\n        dragging = {id, offsetX:0, offsetY:0};\n        const start = getSvgPoint(evt);\n        dragging.offsetX = node.x - start.x;\n        dragging.offsetY = node.y - start.y;\n        document.addEventListener('mousemove', nodeMouseMove);\n        document.addEventListener('mouseup', nodeMouseUp);\n      }\n      function nodeMouseMove(evt){\n        if(!dragging) return;\n        const pt = getSvgPoint(evt);\n        const node = nodeById(dragging.id);\n        node.x = pt.x + dragging.offsetX;\n        node.y = pt.y + dragging.offsetY;\n        updateNodePosition(node);\n        edges.forEach(updateEdgePosition);\n      }\n      function nodeMouseUp(){\n        dragging = null;\n        document.removeEventListener('mousemove', nodeMouseMove);\n        document.removeEventListener('mouseup', nodeMouseUp);\n      }\n\n      // Touch equivalents\n      function nodeTouchStart(evt){\n        evt.preventDefault();\n        const id = Number(this.getAttribute('data-id'));\n        const node = nodeById(id);\n        dragging = {id, offsetX:0, offsetY:0};\n        const start = getSvgPoint(evt);\n        dragging.offsetX = node.x - start.x;\n        dragging.offsetY = node.y - start.y;\n        document.addEventListener('touchmove', nodeTouchMove, {passive:false});\n        document.addEventListener('touchend', nodeTouchEnd);\n      }\n      function nodeTouchMove(evt){\n        evt.preventDefault();\n        if(!dragging) return;\n        const pt = getSvgPoint(evt);\n        const node = nodeById(dragging.id);\n        node.x = pt.x + dragging.offsetX;\n        node.y = pt.y + dragging.offsetY;\n        updateNodePosition(node);\n        edges.forEach(updateEdgePosition);\n      }\n      function nodeTouchEnd(){\n        dragging = null;\n        document.removeEventListener('touchmove', nodeTouchMove);\n        document.removeEventListener('touchend', nodeTouchEnd);\n      }\n\n      /* ---------- UI Controls ---------- */\n      btnAddNode.addEventListener('click', ()=>{ mode='add-node'; setStatus('Click canvas to add node','busy'); });\n      btnAddEdge.addEventListener('click', ()=>{ mode='add-edge'; addingEdgeFrom = null; setStatus('Select source node for edge','busy'); });\n      btnDelete.addEventListener('click', ()=>{ mode = (mode==='delete'? null:'delete'); setStatus(mode==='delete'?'Delete mode active':'Idle', mode==='delete'?'busy':'off'); });\n      btnReset.addEventListener('click', resetGraph);\n      btnSetSource.addEventListener('click', ()=>{ mode='set-source'; setStatus('Click a node to set source','busy'); });\n      btnSetTarget.addEventListener('click', ()=>{ mode='set-target'; setStatus('Click a node to set target','busy'); });\n\n      btnRun.addEventListener('click', ()=>{\n        if(!sourceId || !targetId){ alert('Select a source and a target node first.'); return; }\n        resetVisualState();\n        const steps = generateDijkstraSteps(sourceId);\n        dijkstraState = steps;\n        autoPlay = true;\n        setStatus('Running Dijkstra','busy');\n        runSteps();\n      });\n\n      btnStep.addEventListener('click', ()=>{\n        if(!sourceId || !targetId){ alert('Select source and target.'); return; }\n        if(!dijkstraState){\n          resetVisualState();\n          dijkstraState = generateDijkstraSteps(sourceId);\n        }\n        autoPlay = false;\n        stepOnce();\n      });\n\n      speedInput.addEventListener('input', ()=>{ /* speed used by animation timers */ });\n\n      // Keyboard shortcuts\n      window.addEventListener('keydown', (e)=>{\n        if(e.key==='n' || e.key==='N'){ btnAddNode.click(); }\n        if(e.key==='e' || e.key==='E'){ btnAddEdge.click(); }\n        if(e.key==='d' || e.key==='D'){ btnDelete.click(); }\n        if(e.key==='r' || e.key==='R'){ btnRun.click(); }\n      });\n\n      /* ---------- Visualization helpers ---------- */\n      function updateNodeVisuals(){\n        nodes.forEach(updateNodePosition);\n        edges.forEach(updateEdgePosition);\n      }\n\n      function updateAllEdges(){\n        edges.forEach(e => updateEdgePosition(e));\n      }\n\n      function resetGraph(){\n        // remove all nodes & edges\n        nodes.slice().forEach(n => removeNode(n.id));\n        edges.slice().forEach(e => removeEdge(e.id));\n        nextNodeId = 0;\n        sourceId = targetId = null;\n        mode = null;\n        setStatus('Cleared','off');\n      }\n\n      function resetVisualState(){\n        // clear styles\n        edges.forEach(e => {\n          e.el.line.classList.remove('edge-active','edge-visited');\n          e.el.line.style.opacity = '';\n        });\n        nodes.forEach(n => {\n          n.el.distText.textContent = '∞';\n          n.el.circle.setAttribute('fill','#021627');\n          n.el.circle.setAttribute('stroke','rgba(56,189,248,0.18)');\n        });\n        highlightNode(sourceId, true, 'source');\n        highlightNode(targetId, true, 'target');\n        dijkstraState = null;\n      }\n\n      function pulseElement(el){\n        el.classList.add('pulse');\n        setTimeout(()=> el.classList.remove('pulse'), 800);\n      }\n\n      /* ---------- Dijkstra: generator that yields visualization steps ---------- */\n      function generateDijkstraSteps(srcId){\n        // Build adjacency\n        const adj = new Map();\n        nodes.forEach(n => adj.set(n.id, []));\n        edges.forEach(e => {\n          adj.get(e.a).push({to:e.b, w:e.weight, edgeId:e.id});\n          adj.get(e.b).push({to:e.a, w:e.weight, edgeId:e.id});\n        });\n\n        const dist = new Map();\n        const prev = new Map();\n        nodes.forEach(n => { dist.set(n.id, Infinity); prev.set(n.id, null); });\n        dist.set(srcId,0);\n\n        const visited = new Set();\n        // Simple priority queue via array (fine for small interactive graphs)\n        const queue = [{id:srcId, dist:0}];\n\n        // initial yield to show source\n        return (function*(){\n          // set initial distances in UI\n          for(const n of nodes){\n            const val = dist.get(n.id);\n            n.el.distText.textContent = (val===Infinity ? '∞' : String(val));\n          }\n          yield {type:'init'};\n\n          while(queue.length){\n            // get node with smallest dist\n            queue.sort((a,b)=>a.dist-b.dist);\n            const cur = queue.shift();\n            if(visited.has(cur.id)) continue;\n            visited.add(cur.id);\n\n            // highlight current node\n            const curNode = nodeById(cur.id);\n            // mark current as visited (color)\n            curNode.el.circle.setAttribute('stroke','#fbbf24');\n            curNode.el.circle.setAttribute('fill','#07110a');\n            yield {type:'visit', id:cur.id};\n\n            // if reached target, finish (but still yield path)\n            if(cur.id === targetId){\n              // reconstruct path\n              const path = [];\n              let u = targetId;\n              while(u){\n                const p = prev.get(u);\n                if(!p) break;\n                path.push({from:p.node, to:u, edgeId:p.edgeId});\n                u = p.node;\n              }\n              yield {type:'found', path};\n              return;\n            }\n\n            // relax edges\n            for(const neighbour of adj.get(cur.id) || []){\n              yield {type:'relax-try', from:cur.id, to:neighbour.to, edgeId:neighbour.edgeId};\n              const nd = dist.get(cur.id) + neighbour.w;\n              if(nd < dist.get(neighbour.to)){\n                dist.set(neighbour.to, nd);\n                prev.set(neighbour.to, {node:cur.id, edgeId:neighbour.edgeId});\n                queue.push({id:neighbour.to, dist:nd});\n                // update UI distance\n                const nnode = nodeById(neighbour.to);\n                nnode.el.distText.textContent = String(nd);\n                pulseElement(nnode.el.distText);\n                // highlight edge as relaxed\n                yield {type:'relaxed', edgeId:neighbour.edgeId};\n              } else {\n                // not improved\n                yield {type:'relax-failed', edgeId:neighbour.edgeId};\n              }\n            }\n          }\n          yield {type:'done'};\n        })();\n      }\n\n      // Drive generator steps into animations\n      async function runSteps(){\n        if(!dijkstraState) return;\n        const speed = Number(speedInput.value) || 1;\n        const delay = (ms)=> new Promise(res=> setTimeout(res, ms));\n        while(true){\n          const {value, done} = dijkstraState.next();\n          if(done) break;\n          await processStep(value);\n          if(!autoPlay) break;\n          // adaptive delay: visited slower, relax quicker\n          let wait = 700 / speed;\n          if(value && (value.type==='relax-try' || value.type==='relax-failed' || value.type==='relaxed')) wait = 350 / speed;\n          if(value && value.type==='found') wait = 900 / speed;\n          await delay(wait);\n        }\n        if(autoPlay){\n          setStatus('Finished','ready');\n          autoPlay = false;\n        }\n      }\n\n      function stepOnce(){\n        if(!dijkstraState) return;\n        const {value, done} = dijkstraState.next();\n        if(done){ setStatus('Finished','ready'); dijkstraState=null; return; }\n        processStep(value);\n      }\n\n      async function processStep(step){\n        if(!step) return;\n        switch(step.type){\n          case 'init':\n            setStatus('Starting Dijkstra','busy');\n            break;\n          case 'visit':\n            // flash node\n            const n = nodeById(step.id);\n            n.el.circle.classList.add('pulse');\n            setTimeout(()=> n.el.circle.classList.remove('pulse'), 700);\n            break;\n          case 'relax-try':\n            // flash the edge line lightly\n            const e1 = edgeById(step.edgeId);\n            e1.el.line.classList.add('edge-visited');\n            setTimeout(()=> e1.el.line.classList.remove('edge-visited'), 500);\n            break;\n          case 'relaxed':\n            // stronger flash & increase stroke then restore\n            const e2 = edgeById(step.edgeId);\n            e2.el.line.classList.add('edge-active');\n            pulseElement(e2.el.labelGroup);\n            setTimeout(()=> e2.el.line.classList.remove('edge-active'), 900);\n            break;\n          case 'relax-failed':\n            const e3 = edgeById(step.edgeId);\n            e3.el.line.style.opacity = '0.6';\n            setTimeout(()=> e3.el.line.style.opacity = '', 600);\n            break;\n          case 'found':\n            // highlight final path\n            for(const seg of step.path){\n              const edge = edgeById(seg.edgeId);\n              edge.el.line.classList.add('path-highlight');\n              edge.el.line.style.transition = 'stroke-width 200ms ease';\n            }\n            setStatus('Shortest path found','ready');\n            break;\n          case 'done':\n            setStatus('Completed (target unreachable)','off');\n            break;\n        }\n      }\n\n      /* ---------- Misc helpers ---------- */\n      function updateAll(){\n        updateNodeVisuals();\n        updateAllEdges();\n      }\n\n      // Simple pulse for label groups\n      function pulseLabelGroup(g){ g.classList.add('pulse'); setTimeout(()=> g.classList.remove('pulse'), 700); }\n\n      // Expose a couple for debugging\n      window._graphAPI = { addNodeAt, addEdge, nodes, edges };\n\n      // Initialize with a small sample graph to get started\n      (function seed(){\n        const w = 1200, h = 800;\n        const a = addNodeAt(w*0.25, h*0.35);\n        const b = addNodeAt(w*0.4, h*0.6);\n        const c = addNodeAt(w*0.62, h*0.32);\n        const d = addNodeAt(w*0.78, h*0.62);\n        addEdge(a.id,b.id,4);\n        addEdge(a.id,c.id,1.5);\n        addEdge(b.id,c.id,2.2);\n        addEdge(c.id,d.id,3);\n        updateAll();\n      })();\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Weighted Graph.\n\n**Project Overview:**\nTopic: Weighted Graph\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Weighted Graph"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "FSM modeling user interaction and algorithm visualization states for a weighted-graph Dijkstra exploration app (modes, node/edge editing, dragging, and Dijkstra run/step playback).",
      "states": [
        {
          "name": "idle",
          "onEnter": "setModeNull; setStatus('Idle','off')",
          "onExit": "none",
          "on": {
            "BTN_ADD_NODE": "adding_node",
            "BTN_ADD_EDGE": "add_edge_select_source",
            "BTN_DELETE_TOGGLE": "delete_mode",
            "BTN_SET_SOURCE": "set_source",
            "BTN_SET_TARGET": "set_target",
            "BTN_RESET": "idle",
            "BTN_RUN": "dijkstra_running",
            "BTN_STEP": "dijkstra_paused",
            "GRAPH_CLICK": "idle",
            "NODE_CLICK": "idle",
            "NODE_MOUSEDOWN": "dragging",
            "EDGE_CLICK": "idle",
            "EDGE_LABEL_DBLCLICK": "editing_edge_weight"
          }
        },
        {
          "name": "adding_node",
          "onEnter": "setMode('add-node'); setStatus('Click canvas to add node','busy')",
          "onExit": "setStatus('Idle','off')",
          "on": {
            "GRAPH_CLICK": "adding_node",
            "BTN_ADD_NODE": "adding_node",
            "BTN_ADD_EDGE": "add_edge_select_source",
            "BTN_DELETE_TOGGLE": "delete_mode",
            "BTN_RESET": "idle",
            "BTN_RUN": "dijkstra_running",
            "NODE_MOUSEDOWN": "dragging",
            "EDGE_LABEL_DBLCLICK": "editing_edge_weight"
          }
        },
        {
          "name": "add_edge_select_source",
          "onEnter": "setMode('add-edge'); addingEdgeFrom=null; setStatus('Select source node for edge','busy')",
          "onExit": "addingEdgeFrom=null; setStatus('Idle','off')",
          "on": {
            "NODE_CLICK": "add_edge_select_target",
            "BTN_ADD_NODE": "adding_node",
            "BTN_DELETE_TOGGLE": "delete_mode",
            "BTN_RESET": "idle",
            "NODE_MOUSEDOWN": "dragging",
            "EDGE_LABEL_DBLCLICK": "editing_edge_weight"
          }
        },
        {
          "name": "add_edge_select_target",
          "onEnter": "setStatus('Select target node for edge','busy'); highlightNode(addingEdgeFrom,true)",
          "onExit": "highlightingClear(); addingEdgeFrom=null; setStatus('Idle','off')",
          "on": {
            "NODE_CLICK": "add_edge_select_source",
            "BTN_ADD_NODE": "adding_node",
            "BTN_DELETE_TOGGLE": "delete_mode",
            "BTN_RESET": "idle",
            "NODE_MOUSEDOWN": "dragging",
            "EDGE_LABEL_DBLCLICK": "editing_edge_weight"
          }
        },
        {
          "name": "delete_mode",
          "onEnter": "setMode('delete'); setStatus('Delete mode active','busy')",
          "onExit": "setModeNull; setStatus('Idle','off')",
          "on": {
            "NODE_CLICK": "delete_mode",
            "EDGE_CLICK": "delete_mode",
            "BTN_DELETE_TOGGLE": "idle",
            "BTN_RESET": "idle",
            "NODE_MOUSEDOWN": "dragging",
            "EDGE_LABEL_DBLCLICK": "editing_edge_weight"
          }
        },
        {
          "name": "set_source",
          "onEnter": "setMode('set-source'); setStatus('Click a node to set source','busy')",
          "onExit": "setModeNull; setStatus('Idle','off')",
          "on": {
            "NODE_CLICK": "idle",
            "BTN_RESET": "idle",
            "NODE_MOUSEDOWN": "dragging"
          }
        },
        {
          "name": "set_target",
          "onEnter": "setMode('set-target'); setStatus('Click a node to set target','busy')",
          "onExit": "setModeNull; setStatus('Idle','off')",
          "on": {
            "NODE_CLICK": "idle",
            "BTN_RESET": "idle",
            "NODE_MOUSEDOWN": "dragging"
          }
        },
        {
          "name": "dragging",
          "onEnter": "startDrag (attach move/end listeners, store previous mode)",
          "onExit": "stopDragAndRestoreMode (remove listeners, restore prior mode)",
          "on": {
            "NODE_MOUSEMOVE": "dragging",
            "NODE_TOUCHMOVE": "dragging",
            "NODE_MOUSEUP": "idle",
            "NODE_TOUCHEND": "idle"
          }
        },
        {
          "name": "editing_edge_weight",
          "onEnter": "editEdgeWeight(prompt); (validate weight, update edge.weight; pulseElement(label))",
          "onExit": "none",
          "on": {
            "EDGE_LABEL_DBLCLICK": "editing_edge_weight",
            "BTN_RESET": "idle",
            "NODE_MOUSEDOWN": "dragging"
          }
        },
        {
          "name": "dijkstra_running",
          "onEnter": "startDijkstra (resetVisualState; dijkstraState=generateDijkstraSteps(src); autoPlay=true; setStatus('Running Dijkstra','busy'); runSteps())",
          "onExit": "autoPlay=false (if running); clear any running timers",
          "on": {
            "DIJKSTRA_STEP": "dijkstra_running",
            "DIJKSTRA_VISIT": "dijkstra_running",
            "DIJKSTRA_RELAX_TRY": "dijkstra_running",
            "DIJKSTRA_RELAXED": "dijkstra_running",
            "DIJKSTRA_RELAX_FAILED": "dijkstra_running",
            "DIJKSTRA_FOUND": "dijkstra_done",
            "DIJKSTRA_DONE": "dijkstra_done",
            "BTN_STEP": "dijkstra_paused",
            "BTN_RESET": "idle",
            "NODE_MOUSEDOWN": "dragging"
          }
        },
        {
          "name": "dijkstra_paused",
          "onEnter": "pauseDijkstra (autoPlay=false); if dijkstraState absent then initialize generator and set initial UI",
          "onExit": "none",
          "on": {
            "BTN_STEP": "dijkstra_paused",
            "BTN_RUN": "dijkstra_running",
            "DIJKSTRA_FOUND": "dijkstra_done",
            "DIJKSTRA_DONE": "dijkstra_done",
            "BTN_RESET": "idle",
            "NODE_MOUSEDOWN": "dragging"
          }
        },
        {
          "name": "dijkstra_done",
          "onEnter": "finalizeDijkstra (setStatus('Finished' or 'Completed (target unreachable)','ready'/'off'); autoPlay=false; dijkstraState=null)",
          "onExit": "none",
          "on": {
            "BTN_RUN": "dijkstra_running",
            "BTN_STEP": "dijkstra_paused",
            "BTN_RESET": "idle",
            "NODE_MOUSEDOWN": "dragging"
          }
        }
      ],
      "events": [
        "BTN_ADD_NODE",
        "BTN_ADD_EDGE",
        "BTN_DELETE_TOGGLE",
        "BTN_RESET",
        "BTN_SET_SOURCE",
        "BTN_SET_TARGET",
        "BTN_RUN",
        "BTN_STEP",
        "GRAPH_CLICK",
        "NODE_CLICK",
        "EDGE_CLICK",
        "EDGE_LABEL_DBLCLICK",
        "NODE_MOUSEDOWN",
        "NODE_MOUSEMOVE",
        "NODE_MOUSEUP",
        "NODE_TOUCHSTART",
        "NODE_TOUCHMOVE",
        "NODE_TOUCHEND",
        "DIJKSTRA_STEP",
        "DIJKSTRA_VISIT",
        "DIJKSTRA_RELAX_TRY",
        "DIJKSTRA_RELAXED",
        "DIJKSTRA_RELAX_FAILED",
        "DIJKSTRA_FOUND",
        "DIJKSTRA_DONE"
      ],
      "notes": "Guards and side effects: BTN_RUN requires a source and target to be selected (otherwise the code shows an alert and stays in the current UI mode). Add-edge has an internal sub-state: selecting source then selecting target (mode 'add-edge' with addingEdgeFrom used). GRAPH_CLICK in adding_node triggers addNodeAt(x,y) and update visuals. NODE_CLICK behavior is context-sensitive: in delete_mode it removes the node; in add-edge it either sets addingEdgeFrom (source) or finalizes edge by prompting for weight and adding the edge; in set_source/set_target it assigns and then returns to idle; in idle it toggles source/target selection. Dragging is orthogonal: a NODE_MOUSEDOWN enters dragging, which restores the previous mode on NODE_MOUSEUP/TOUCHEND. Dijkstra steps are driven by a generator: internal events (DIJKSTRA_VISIT, DIJKSTRA_RELAX_TRY, DIJKSTRA_RELAXED, DIJKSTRA_RELAX_FAILED, DIJKSTRA_FOUND, DIJKSTRA_DONE) correspond to visual actions (flash node, flash edge, highlight path). The FSM models these internal algorithm events as transitions that keep the run/paused states. Edge-weight editing uses a prompt and validates a positive number before applying; invalid input results in alert and no change. Some transitions are self-loops (e.g., repeated add-node clicks) and many transitions cause UI side-effects listed in onEnter/onExit action descriptions."
    }
  }
]