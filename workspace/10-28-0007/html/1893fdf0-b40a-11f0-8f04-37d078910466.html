<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Linked List Explorer</title>
  <style>
    /* Safe area margins 24px and base layout */
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #38bdf8;
      --muted: #94a3b8;
      --node-bg: #111827;
      --node-border: #334155;
      --success: #10b981;
      --danger: #f43f5e;
    }

    html,body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg,#071025 0%, #02101a 100%);
      color: #e6eef8;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    /* Container with safe area margins */
    .page {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    header {
      display: flex;
      align-items: flex-start;
      gap: var(--gap);
      flex-wrap: wrap;
    }

    h1 {
      margin: 0;
      font-size: 1.25rem;
      letter-spacing: -0.02em;
      color: #fff;
    }

    .meta {
      max-width: 900px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      padding: 14px;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .small {
      color: var(--muted);
      font-size: 0.95rem;
      line-height: 1.3;
    }

    .two-col {
      display: flex;
      gap: var(--gap);
      align-items: flex-start;
      width: 100%;
      flex-wrap: wrap;
    }

    /* Interactive module layout */
    .module {
      display: flex;
      gap: var(--gap);
      align-items: stretch;
      width: 100%;
      flex-wrap: wrap;
    }

    .controls {
      min-width: 280px;
      max-width: 360px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      padding: 16px;
      border-radius: 10px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .controls label {
      display: block;
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    input[type="text"], input[type="number"], select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.04);
      background: rgba(255,255,255,0.02);
      color: #e6eef8;
      box-sizing: border-box;
      font-size: 0.95rem;
    }

    button {
      padding: 10px 12px;
      border-radius: 8px;
      border: 0;
      cursor: pointer;
      background: linear-gradient(180deg, rgba(56,189,248,0.14), rgba(56,189,248,0.06));
      color: var(--accent);
      font-weight: 600;
      transition: transform .12s ease, box-shadow .12s ease;
    }

    button:hover { transform: translateY(-2px); }
    .btn-danger {
      background: linear-gradient(180deg, rgba(244,63,94,0.12), rgba(244,63,94,0.05));
      color: var(--danger);
    }
    .btn-success {
      background: linear-gradient(180deg, rgba(16,185,129,0.12), rgba(16,185,129,0.05));
      color: var(--success);
    }

    /* Canvas area */
    .canvas-wrap {
      flex: 1 1 480px;
      min-height: 260px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border: 1px solid rgba(255,255,255,0.03);
      padding: 16px;
      border-radius: 10px;
      box-sizing: border-box;
      position: relative;
      overflow: auto;
    }

    .canvas-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .status {
      color: var(--muted);
      font-size: 0.95rem;
    }

    /* Node visuals */
    .list {
      display: flex;
      gap: 28px; /* spacing between nodes */
      align-items: center;
      min-height: 120px;
      padding: 18px;
      box-sizing: border-box;
      position: relative;
    }

    .node {
      width: 110px;
      min-width: 110px;
      height: 60px;
      background: linear-gradient(180deg, var(--node-bg), rgba(17,24,39,0.9));
      border: 1px solid var(--node-border);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      box-sizing: border-box;
      position: relative;
      transition: transform 400ms cubic-bezier(.2,.9,.2,1), opacity 300ms;
      box-shadow: 0 4px 18px rgba(2,6,23,0.6);
    }

    .node .val {
      font-size: 1.05rem;
      font-weight: 700;
      color: #e6eef8;
      letter-spacing: -0.02em;
    }

    .node .next-slot {
      width: 28px;
      height: 36px;
      border-radius: 6px;
      border: 1px dashed rgba(255,255,255,0.03);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 0.78rem;
    }

    /* Arrow drawing uses SVG lines placed under nodes */
    svg.arrow-layer {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
      overflow: visible;
    }

    /* Head label */
    .head-label {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .pointer {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(180deg, rgba(56,189,248,0.18), rgba(56,189,248,0.06));
      border: 1px solid rgba(56,189,248,0.13);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent);
      font-weight: 700;
      transform: translate(-50%,-50%);
      transition: transform 450ms cubic-bezier(.2,.9,.2,1);
      box-shadow: 0 8px 26px rgba(3,15,32,0.6);
    }

    .node.highlight {
      outline: 3px solid rgba(56,189,248,0.14);
      transform: translateY(-6px);
      box-shadow: 0 14px 30px rgba(3,15,32,0.7);
    }

    .node.removing {
      opacity: 0;
      transform: translateY(24px) scale(.95);
    }

    .controls .group {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .legend {
      display:flex;
      gap: 12px;
      align-items: center;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .dot {
      width: 12px;
      height: 12px;
      border-radius: 4px;
      background: rgba(56,189,248,0.18);
      border: 1px solid rgba(56,189,248,0.28);
    }

    .info {
      margin-top: 12px;
      color: var(--muted);
      font-size: 0.92rem;
      line-height: 1.4;
      background: rgba(255,255,255,0.01);
      padding: 10px;
      border-radius: 8px;
    }

    footer {
      color: var(--muted);
      font-size: 0.9rem;
    }

    /* Responsive */
    @media (max-width: 880px) {
      .module { flex-direction: column; }
      .controls { max-width: 100%; width: auto; }
      .canvas-wrap { min-height: 320px; }
      .list { padding: 10px; gap: 20px; }
      .node { width: 96px; min-width: 96px; height: 56px; }
    }
  </style>
</head>
<body>
  <div class="page" role="main">
    <header class="two-col" aria-labelledby="concept-title">
      <div class="meta" style="flex:1 1 520px;">
        <h1 id="concept-title">Linked List — Interactive Explorer</h1>
        <div class="small">
          Explore how a singly linked list stores nodes with values and "next" pointers.
          Use operations to insert, delete, and traverse while visual animations show pointer updates and node movement.
        </div>
      </div>

      <div class="meta" style="flex:0 1 320px;">
        <strong style="display:block; margin-bottom:6px;">Learning Objective</strong>
        <div class="small">
          After interacting, you will understand:
          - How nodes are linked by "next" pointers,
          - How insertion at head/tail/position updates pointers,
          - How deletion removes a node and reconnects the list,
          - How traversal visits nodes sequentially from head.
        </div>
      </div>
    </header>

    <section class="module" aria-label="Interactive linked list module">
      <!-- Controls -->
      <aside class="controls" aria-labelledby="controls-heading">
        <h2 id="controls-heading" style="margin:0 0 6px 0; font-size:1rem;">Controls</h2>

        <div>
          <label for="value-input">Node value</label>
          <input id="value-input" type="text" inputmode="text" placeholder='e.g., 42 or "A"' aria-label="Node value" />
        </div>

        <div>
          <label for="pos-input">Position (index)</label>
          <input id="pos-input" type="number" min="0" step="1" placeholder="0 = head" aria-label="Position index" />
        </div>

        <div class="group" role="group" aria-label="Insertion buttons">
          <button id="insert-head">Insert at Head</button>
          <button id="insert-tail" class="btn-success">Insert at Tail</button>
          <button id="insert-at">Insert at Position</button>
        </div>

        <div class="group" role="group" aria-label="Deletion buttons">
          <button id="delete-pos" class="btn-danger">Delete at Position</button>
          <button id="clear-list" class="btn-danger">Clear</button>
        </div>

        <hr style="border:0; height:1px; background:rgba(255,255,255,0.02); margin:8px 0;" />

        <div>
          <label>Traversal</label>
          <div class="row" style="margin-top:6px;">
            <button id="step-back">&larr; Prev</button>
            <button id="step-forward">Next &rarr;</button>
            <button id="play">Play</button>
            <button id="reset-trav" class="btn-danger">Reset</button>
          </div>
        </div>

        <div class="info" aria-live="polite" id="info">
          List is empty. Add nodes to begin.
        </div>

        <div style="margin-top:6px;">
          <div class="legend">
            <div class="dot" aria-hidden="true"></div>
            <div>Highlighted = current during traversal</div>
          </div>
        </div>
      </aside>

      <!-- Canvas -->
      <section class="canvas-wrap" aria-label="Linked list canvas">
        <div class="canvas-top">
          <div class="head-label">
            <strong style="color:#fff; margin-right:8px;">Head</strong>
            <div id="head-status" class="status">null</div>
          </div>
          <div class="status" id="len-status">Length: 0</div>
        </div>

        <div class="list" id="list" tabindex="0" aria-label="Linked list nodes"></div>

        <!-- SVG for arrows -->
        <svg class="arrow-layer" id="svg" width="2000" height="500" aria-hidden="true"></svg>

        <!-- Floating pointer representing current traversal pointer -->
        <div id="pointer" class="pointer" style="display:none;">P</div>
      </section>
    </section>

    <section class="meta small" aria-label="Interaction design and layout description">
      <strong style="display:block; margin-bottom:8px;">Interaction Design</strong>
      <div>
        - Users type a value and optionally a position. Buttons insert at head, tail, or a specific index.
        - Delete by position removes the node; Clear removes all nodes.
        - Traversal controls: Next/Prev step through nodes. Play auto-steps with an animation of the pointer moving along arrows.
        - Visual feedback:
          - Newly inserted nodes animate into place (slide + fade).
          - Deleted nodes animate out (fade + drop) before pointers redraw.
          - During traversal the current node is highlighted and a floating pointer "P" moves to that node (smooth transform).
          - SVG curved arrows update to represent "next" pointers.
        - Clicking a node selects it (for quick feedback). Keyboard focus on the list allows arrow-key traversal (← / →).
      </div>

      <strong style="display:block; margin-top:12px; margin-bottom:8px;">Layout Description</strong>
      <div>
        - Safe area: 24px page padding on all sides; all interactive elements use at least 16px gaps.
        - Left column: Controls (forms & buttons) sized for touch; right column: visual canvas with nodes and pointer.
        - The canvas uses horizontal flex layout to display nodes left-to-right, with SVG arrows absolutely positioned under the nodes.
        - Responsive: columns stack on narrow screens. Contrast, large touch targets, and aria attributes improve accessibility.
      </div>
    </section>

    <footer class="small">
      Tip: Try inserting at head, then at tail, then delete middle items to observe pointer re-linking.
    </footer>
  </div>

  <script>
    // Simple singly linked list visualizer (array-backed model)
    (function () {
      // Elements
      const listEl = document.getElementById('list');
      const svg = document.getElementById('svg');
      const pointerEl = document.getElementById('pointer');
      const headStatus = document.getElementById('head-status');
      const lenStatus = document.getElementById('len-status');
      const info = document.getElementById('info');

      const valueInput = document.getElementById('value-input');
      const posInput = document.getElementById('pos-input');
      const insertHeadBtn = document.getElementById('insert-head');
      const insertTailBtn = document.getElementById('insert-tail');
      const insertAtBtn = document.getElementById('insert-at');
      const deletePosBtn = document.getElementById('delete-pos');
      const clearListBtn = document.getElementById('clear-list');

      const stepForwardBtn = document.getElementById('step-forward');
      const stepBackBtn = document.getElementById('step-back');
      const playBtn = document.getElementById('play');
      const resetTravBtn = document.getElementById('reset-trav');

      let nodes = []; // {id, value}
      let idCounter = 1;

      // Traversal state
      let currentIndex = -1;
      let playTimer = null;

      // Utility: update status text
      function updateStatus(message) {
        info.textContent = message;
      }

      function updateHeadLen() {
        headStatus.textContent = nodes.length ? nodes[0].value : 'null';
        lenStatus.textContent = 'Length: ' + nodes.length;
      }

      // Create node element
      function createNodeEl(node) {
        const el = document.createElement('div');
        el.className = 'node';
        el.dataset.id = node.id;
        el.setAttribute('role','group');
        el.setAttribute('aria-label','node ' + (node.value));
        el.innerHTML = `
          <div class="val">${escapeHtml(String(node.value))}</div>
          <div class="next-slot">next</div>
        `;
        // click selects node
        el.addEventListener('click', () => {
          const idx = nodes.findIndex(n => n.id == node.id);
          if (idx >= 0) {
            goToIndex(idx);
            updateStatus('Selected node at index ' + idx + '.');
          }
        });
        return el;
      }

      // Draw list: ensure svg arrows match positions
      function drawList() {
        // Clear SVG
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        // Place nodes as children of listEl: their layout managed by flexbox.
        // After render, compute positions to draw arrows.
        requestAnimationFrame(() => {
          const nodeEls = Array.from(listEl.children);
          for (let i = 0; i < nodeEls.length - 1; i++) {
            const a = nodeEls[i];
            const b = nodeEls[i+1];
            const rectA = a.getBoundingClientRect();
            const rectB = b.getBoundingClientRect();
            const containerRect = listEl.getBoundingClientRect();
            // Compute coordinates relative to svg
            const startX = rectA.right - containerRect.left - 12;
            const startY = rectA.top - containerRect.top + rectA.height / 2;
            const endX = rectB.left - containerRect.left + 12;
            const endY = rectB.top - containerRect.top + rectB.height / 2;

            // Draw a smooth cubic bezier arrow
            const path = document.createElementNS('http://www.w3.org/2000/svg','path');
            const dx = Math.max(40, (endX - startX) / 2);
            const d = `M ${startX} ${startY} C ${startX + dx} ${startY} ${endX - dx} ${endY} ${endX} ${endY}`;
            path.setAttribute('d', d);
            path.setAttribute('fill','none');
            path.setAttribute('stroke','rgba(56,189,248,0.18)');
            path.setAttribute('stroke-width','3');
            path.setAttribute('stroke-linecap','round');
            svg.appendChild(path);

            // Arrowhead
            const arrow = document.createElementNS('http://www.w3.org/2000/svg','polygon');
            const arrowSize = 6;
            // place arrow at end, simple triangle
            arrow.setAttribute('points', `${endX},${endY} ${endX - arrowSize},${endY - arrowSize} ${endX - arrowSize},${endY + arrowSize}`);
            arrow.setAttribute('fill','rgba(56,189,248,0.22)');
            svg.appendChild(arrow);
          }
          // Resize svg to contain the list
          const rect = listEl.getBoundingClientRect();
          svg.setAttribute('width', Math.max(800, rect.width + 200));
          svg.setAttribute('height', Math.max(200, rect.height + 60));
          svg.style.left = (listEl.offsetLeft - 20) + 'px';
          svg.style.top = (listEl.offsetTop + 10) + 'px';
          // Reposition pointer if visible
          if (currentIndex >= 0) {
            movePointerTo(currentIndex);
          } else {
            pointerEl.style.display = 'none';
          }
        });
      }

      // Escape html to avoid injection into node display
      function escapeHtml(str) {
        return str.replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
      }

      // Insert helpers
      function insertAt(idx, value) {
        if (idx < 0) idx = 0;
        if (idx > nodes.length) idx = nodes.length;
        const node = { id: idCounter++, value };
        nodes.splice(idx, 0, node);
        renderInsert(idx, node);
        updateHeadLen();
        updateStatus('Inserted "' + value + '" at index ' + idx + '.');
      }

      function renderInsert(idx, node) {
        // Create element but place it visually offset (animated entrance)
        const el = createNodeEl(node);
        el.style.opacity = '0';
        el.style.transform = 'translateY(-20px) scale(.98)';
        // Insert into DOM at correct position
        if (idx >= listEl.children.length) {
          listEl.appendChild(el);
        } else {
          listEl.insertBefore(el, listEl.children[idx]);
        }
        // After a frame, animate to place
        requestAnimationFrame(() => {
          el.style.opacity = '1';
          el.style.transform = '';
        });
        // Re-draw arrows after a short delay to let layout stabilize
        setTimeout(drawList, 120);
      }

      // Delete at index
      function deleteAt(idx) {
        if (idx < 0 || idx >= nodes.length) {
          updateStatus('Invalid index for deletion.');
          return;
        }
        const removed = nodes.splice(idx,1)[0];
        const el = Array.from(listEl.children)[idx];
        if (el) {
          el.classList.add('removing');
          // animate out then remove
          setTimeout(() => {
            if (el.parentNode) el.parentNode.removeChild(el);
            drawList();
          }, 320);
        } else {
          drawList();
        }
        // Update traversal pointer
        if (currentIndex === idx) {
          currentIndex = -1;
          pointerEl.style.display = 'none';
        } else if (currentIndex > idx) {
          currentIndex--;
        }
        updateHeadLen();
        updateStatus('Deleted node "' + removed.value + '" at index ' + idx + '.');
      }

      function clearAll() {
        nodes = [];
        idCounter = 1;
        currentIndex = -1;
        // Remove children with animation
        Array.from(listEl.children).forEach((el, i) => {
          el.classList.add('removing');
          setTimeout(() => {
            if (el.parentNode) el.parentNode.removeChild(el);
            drawList();
          }, 220 + i*40);
        });
        drawList();
        updateHeadLen();
        updateStatus('Cleared list.');
      }

      // Traversal functions
      function goToIndex(idx) {
        if (idx < 0 || idx >= nodes.length) {
          updateStatus('Index out of range.');
          return;
        }
        currentIndex = idx;
        highlightCurrent();
        movePointerTo(idx);
      }

      function highlightCurrent() {
        Array.from(listEl.children).forEach((el, i) => {
          el.classList.toggle('highlight', i === currentIndex);
        });
      }

      function movePointerTo(idx) {
        const el = listEl.children[idx];
        if (!el) {
          pointerEl.style.display = 'none';
          return;
        }
        const rect = el.getBoundingClientRect();
        const containerRect = listEl.getBoundingClientRect();
        const x = rect.left - containerRect.left + rect.width / 2 + listEl.offsetLeft;
        const y = rect.top - containerRect.top + rect.height + listEl.offsetTop + 12;
        pointerEl.style.display = '';
        pointerEl.style.transform = `translate(${x}px, ${y}px)`;
      }

      function stepForward() {
        if (nodes.length === 0) {
          updateStatus('List is empty.');
          return;
        }
        if (currentIndex < nodes.length - 1) currentIndex++;
        else currentIndex = nodes.length - 1;
        highlightCurrent();
        movePointerTo(currentIndex);
        updateStatus('At index ' + currentIndex + ' (value: ' + nodes[currentIndex].value + ')');
      }

      function stepBackward() {
        if (nodes.length === 0) {
          updateStatus('List is empty.');
          return;
        }
        if (currentIndex > 0) currentIndex--;
        else currentIndex = 0;
        highlightCurrent();
        movePointerTo(currentIndex);
        updateStatus('At index ' + currentIndex + ' (value: ' + nodes[currentIndex].value + ')');
      }

      function playTraversal() {
        if (playTimer) {
          clearInterval(playTimer);
          playTimer = null;
          playBtn.textContent = 'Play';
          updateStatus('Playback paused.');
          return;
        }
        if (nodes.length === 0) {
          updateStatus('List is empty.');
          return;
        }
        playBtn.textContent = 'Pause';
        if (currentIndex < 0) currentIndex = -1;
        playTimer = setInterval(() => {
          if (currentIndex < nodes.length - 1) {
            currentIndex++;
            highlightCurrent();
            movePointerTo(currentIndex);
            updateStatus('At index ' + currentIndex + ' (value: ' + nodes[currentIndex].value + ')');
          } else {
            clearInterval(playTimer);
            playTimer = null;
            playBtn.textContent = 'Play';
            updateStatus('Traversal finished.');
          }
        }, 900);
      }

      function resetTraversal() {
        currentIndex = -1;
        highlightCurrent();
        pointerEl.style.display = 'none';
        if (playTimer) {
          clearInterval(playTimer);
          playTimer = null;
          playBtn.textContent = 'Play';
        }
        updateStatus('Traversal reset.');
      }

      // DOM events
      insertHeadBtn.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (!v) { updateStatus('Please enter a value to insert.'); return; }
        insertAt(0, v);
      });

      insertTailBtn.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (!v) { updateStatus('Please enter a value to insert.'); return; }
        insertAt(nodes.length, v);
      });

      insertAtBtn.addEventListener('click', () => {
        const v = valueInput.value.trim();
        const pos = Number(posInput.value);
        if (!v) { updateStatus('Enter a value first.'); return; }
        if (!Number.isFinite(pos) || Number.isNaN(pos)) {
          updateStatus('Enter a valid numeric position (0..length).');
          return;
        }
        insertAt(pos, v);
      });

      deletePosBtn.addEventListener('click', () => {
        const pos = Number(posInput.value);
        if (!Number.isFinite(pos) || Number.isNaN(pos)) {
          updateStatus('Enter a valid numeric position to delete.');
          return;
        }
        deleteAt(pos);
      });

      clearListBtn.addEventListener('click', () => {
        clearAll();
      });

      stepForwardBtn.addEventListener('click', stepForward);
      stepBackBtn.addEventListener('click', stepBackward);
      playBtn.addEventListener('click', playTraversal);
      resetTravBtn.addEventListener('click', resetTraversal);

      // Keyboard navigation within list (left/right)
      listEl.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight') {
          stepForward();
          e.preventDefault();
        } else if (e.key === 'ArrowLeft') {
          stepBackward();
          e.preventDefault();
        }
      });

      // Initial draw placeholder
      updateHeadLen();
      drawList();

      // Expose some state in console for advanced users
      window._ll = {
        insertAt, deleteAt, nodesRef: () => nodes
      };

      // Small demo: populate with some nodes to start (comment this block if not desired)
      (function seed() {
        const sample = ['A','B','C'];
        sample.forEach((v,i) => insertAt(i, v));
        updateStatus('Demo list created with nodes A, B, C. Try inserting and traversing.');
      })();

      // Accessibility: announce changes via ARIA live (info div is aria-live)
    })();
  </script>
</body>
</html>