<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Weighted Graph — Interactive Dijkstra Exploration</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --sidebar-width: 340px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #38bdf8;
      --muted: #94a3b8;
      --success: #34d399;
      --danger: #fb7185;
      --glass: rgba(255,255,255,0.03);
      --radius: 10px;
      --elev: 10px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      padding:var(--safe-margin);
      background: linear-gradient(180deg,#021124 0%, #071022 60%);
      color:#e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      min-height:100vh;
      display:flex;
      gap:var(--gap);
      align-items:stretch;
    }

    /* Layout */
    .container{
      display:flex;
      gap:var(--gap);
      width:100%;
      align-items:stretch;
    }

    /* Sidebar / Panel */
    .panel{
      width:var(--sidebar-width);
      min-width:260px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:20px;
      box-shadow: 0 8px 30px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    header.title{
      display:flex;
      gap:12px;
      align-items:center;
    }
    header.title h1{
      margin:0;
      font-size:16px;
      letter-spacing:0.2px;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
      line-height:1.25;
    }

    .section{
      background:var(--glass);
      border-radius:8px;
      padding:12px;
      font-size:13px;
      line-height:1.3;
    }

    .controls{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:6px;
    }

    .btn-row{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }

    button, .icon-btn {
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--accent);
      padding:8px 10px;
      border-radius:8px;
      font-weight:600;
      cursor:pointer;
      min-height:40px;
      display:inline-flex;
      align-items:center;
      gap:8px;
      transition:all 200ms ease;
    }
    button:hover{
      transform:translateY(-2px);
      box-shadow:0 6px 18px rgba(56,189,248,0.06);
      border-color:rgba(56,189,248,0.18);
    }
    .btn-primary{
      background:linear-gradient(90deg, rgba(56,189,248,0.12), rgba(52,211,153,0.06));
      color:var(--accent);
      border:1px solid rgba(56,189,248,0.18);
    }
    .btn-danger{
      color:var(--danger);
      border-color:rgba(251,113,133,0.08);
    }
    .small{
      padding:6px 8px;
      font-size:13px;
      min-height:36px;
    }

    .info-row{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }

    .status{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
    }
    .dot.ready{background:var(--accent)}
    .dot.busy{background:#fbbf24}
    .dot.off{background:#64748b}

    /* Canvas area */
    .canvas-wrap{
      flex:1;
      background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.008));
      border-radius:var(--radius);
      padding:14px;
      display:flex;
      flex-direction:column;
      min-height:400px;
      gap:12px;
    }

    .toolbar{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:flex-start;
    }

    .hint{
      color:var(--muted);
      font-size:13px;
      margin-left:auto;
    }

    /* SVG graph */
    #graph {
      width:100%;
      height:calc(100vh - 240px);
      min-height:360px;
      background:
        radial-gradient(1200px 600px at 10% 10%, rgba(56,189,248,0.02), transparent 5%),
        radial-gradient(900px 400px at 90% 90%, rgba(52,211,153,0.015), transparent 5%);
      border-radius:8px;
      overflow:hidden;
      touch-action: none;
      position:relative;
    }
    svg{width:100%;height:100%}

    /* Node styling */
    .node {
      cursor:pointer;
      transition:transform 160ms ease, box-shadow 160ms ease;
    }
    .node circle {
      fill: #021627;
      stroke: rgba(56,189,248,0.18);
      stroke-width:2px;
      transition:fill 160ms ease, stroke 160ms ease;
    }
    .node:hover circle {
      stroke: rgba(56,189,248,0.36);
      transform-origin:center;
      transform:scale(1.04);
    }
    .node-label {
      fill:#e6eef8;
      font-size:13px;
      pointer-events:none;
      font-weight:700;
      text-anchor:middle;
      dominant-baseline:middle;
    }

    /* Distance badge */
    .dist-badge {
      fill:rgba(255,255,255,0.04);
      stroke:rgba(255,255,255,0.06);
      rx:6; ry:6;
    }
    .dist-text {
      fill:var(--muted);
      font-size:11px;
      pointer-events:none;
      text-anchor:middle;
      dominant-baseline:middle;
    }

    /* Edge styling */
    .edge-line {
      stroke:rgba(255,255,255,0.06);
      stroke-width:2;
      transition:stroke 220ms ease, stroke-width 220ms ease, opacity 220ms ease;
      filter: drop-shadow(0 4px 8px rgba(2,6,23,0.5));
    }
    .edge-label {
      fill:#dbeafe;
      font-size:12px;
      font-weight:600;
      pointer-events:auto;
      user-select:none;
    }
    .edge-label-bg {
      fill:rgba(2,6,23,0.6);
      stroke:rgba(255,255,255,0.02);
      rx:6; ry:6;
    }
    .edge-active {
      stroke: #34d399;
      stroke-width:4;
    }
    .edge-visited {
      stroke: #fbbf24;
      stroke-width:3;
      opacity:0.9;
    }

    /* Path highlight */
    .path-highlight {
      stroke:#60a5fa;
      stroke-width:5;
      opacity:0.95;
    }

    /* Small form elements */
    input[type=range] {
      -webkit-appearance:none;
      appearance:none;
      height:4px;
      background:rgba(255,255,255,0.04);
      border-radius:999px;
      outline:none;
    }
    input[type=range]::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:14px;height:14px;border-radius:50%;
      background:var(--accent);border:2px solid rgba(255,255,255,0.06);
    }

    label.small-muted{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}

    footer.credits{
      margin-top:auto;
      font-size:12px;
      color:var(--muted);
    }

    /* Responsive: stack on small screens */
    @media (max-width:900px){
      .container{flex-direction:column}
      .panel{width:100%}
      .canvas-wrap{width:100%}
      #graph{height:56vh; min-height:300px}
    }

    /* Accessibility focus */
    button:focus, .icon-btn:focus, .node:focus, .edge-label:focus {
      outline:3px solid rgba(56,189,248,0.18);
      outline-offset:3px;
    }

    /* Minor animations */
    .pulse {
      animation: pulse 900ms ease;
    }
    @keyframes pulse {
      0% { transform:scale(1); opacity:1; }
      50% { transform:scale(1.06); opacity:0.9; }
      100% { transform:scale(1); opacity:1; }
    }

  </style>
</head>
<body>
  <div class="container" role="main" aria-label="Weighted Graph Interactive Module">
    <!-- Sidebar with design plan and controls -->
    <aside class="panel" aria-labelledby="module-title">
      <header class="title">
        <div>
          <h1 id="module-title">Weighted Graph — Shortest Path (Dijkstra)</h1>
          <div class="muted">Interactive exploration: add nodes, connect edges with weights, then visualize Dijkstra.</div>
        </div>
      </header>

      <div class="section" aria-describedby="objective">
        <strong>Learning Objective</strong>
        <p id="objective" class="muted" style="margin:8px 0 0 0">
          After using this module, you will understand how weighted graphs represent distances and how Dijkstra's algorithm
          finds the shortest path from a chosen source to a target through iterative relaxation of edge weights.
        </p>
      </div>

      <div class="section" aria-describedby="interaction">
        <strong>Interaction Design</strong>
        <div id="interaction" class="muted" style="margin-top:8px">
          - Click "Add Node" then click the canvas to create a node. Drag nodes to rearrange.<br>
          - Click "Add Edge", then click source node then target node; a weight prompt appears (positive number).<br>
          - Double-click an edge weight to edit it. Click a node to set Source (green) and Target (red).<br>
          - Press "Run" to animate Dijkstra step-by-step. Use "Step" to advance manually. Speed slider controls the animation pace.<br>
          Visual feedback: node distance badges update smoothly; edges flash when relaxed; final shortest path highlighted.
        </div>
      </div>

      <div class="section">
        <strong>Layout Description</strong>
        <div class="muted" style="margin-top:8px">
          - Safe margins: 24px on all sides (page padding).<br>
          - Minimum spacing: 16px gap used between major controls and sections.<br>
          - Left panel holds instructions and controls (fixed width). Right area is the SVG canvas (flexible).<br>
          - Accessible: keyboard shortcuts (N:Add node, E:Add edge, D:Delete, R:Run), focus outlines, ARIA labels, color contrast.
        </div>
      </div>

      <div class="section">
        <strong>Controls</strong>
        <div class="controls" aria-label="Graph controls">
          <div class="btn-row" role="toolbar" aria-label="Toolbar">
            <button id="btn-add-node" class="btn-primary small" title="Add Node (N)">Add Node (N)</button>
            <button id="btn-add-edge" class="small" title="Add Edge (E)">Add Edge (E)</button>
            <button id="btn-delete" class="small" title="Delete Mode (D)">Delete Mode (D)</button>
            <button id="btn-reset" class="small btn-danger" title="Clear graph">Reset</button>
          </div>

          <div class="btn-row" style="margin-top:6px">
            <button id="btn-set-source" class="small" title="Set Source">Set Source</button>
            <button id="btn-set-target" class="small" title="Set Target">Set Target</button>
            <button id="btn-run" class="btn-primary small" title="Run Dijkstra (R)">Run (R)</button>
            <button id="btn-step" class="small" title="Step through algorithm">Step</button>
          </div>

          <div class="info-row" style="margin-top:8px">
            <div>
              <label class="small-muted">Animation speed</label>
              <input type="range" id="speed" min="0.2" max="2" value="1" step="0.1" aria-label="Animation speed">
            </div>
            <div class="status" aria-live="polite">
              <div class="dot off" id="status-dot" aria-hidden="true"></div>
              <div id="status-text" class="muted" style="font-size:13px">Idle</div>
            </div>
          </div>

          <div style="margin-top:8px" class="muted">
            Shortcuts: N = Add Node · E = Add Edge · D = Delete Mode · R = Run/Reset
          </div>
        </div>
      </div>

      <footer class="credits">
        Built with vanilla HTML/CSS/JS — interactive learning tool for weighted graphs.
      </footer>
    </aside>

    <!-- Main interactive canvas -->
    <main class="canvas-wrap" aria-label="Graph canvas and visualization area">
      <div class="toolbar" role="toolbar" aria-hidden="false">
        <div class="muted">Canvas:</div>
        <div class="hint">Click canvas to create nodes when in Add Node mode. Drag nodes to move.</div>
      </div>

      <div id="graph" aria-label="Graph drawing area">
        <svg id="svg-root" viewBox="0 0 1200 800" role="img" aria-labelledby="svg-title">
          <title id="svg-title">Weighted graph drawing area</title>
          <defs>
            <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
              <feDropShadow dx="0" dy="6" stdDeviation="12" flood-color="#000" flood-opacity="0.35"/>
            </filter>
          </defs>

          <!-- Edges group -->
          <g id="edges"></g>

          <!-- Nodes group on top -->
          <g id="nodes"></g>
        </svg>
      </div>
    </main>
  </div>

  <script>
    (function(){
      /* ---------- Basic state and utilities ---------- */
      const svg = document.getElementById('svg-root');
      const edgesLayer = document.getElementById('edges');
      const nodesLayer = document.getElementById('nodes');
      const graph = document.getElementById('graph');

      const btnAddNode = document.getElementById('btn-add-node');
      const btnAddEdge = document.getElementById('btn-add-edge');
      const btnDelete = document.getElementById('btn-delete');
      const btnReset = document.getElementById('btn-reset');
      const btnRun = document.getElementById('btn-run');
      const btnStep = document.getElementById('btn-step');
      const btnSetSource = document.getElementById('btn-set-source');
      const btnSetTarget = document.getElementById('btn-set-target');
      const statusDot = document.getElementById('status-dot');
      const statusText = document.getElementById('status-text');
      const speedInput = document.getElementById('speed');

      let mode = null; // 'add-node','add-edge','delete','idle'
      let nodes = []; // {id,label,x,y,el}
      let edges = []; // {id,a,b,weight,line,group,labelEl}
      let nextNodeId = 0;
      let sourceId = null, targetId = null;
      let addingEdgeFrom = null;
      let dragging = null;
      let animationTimer = null;
      let dijkstraState = null; // generator
      let autoPlay = false;

      const minSpacing = 16; // consistent spacing used in UI description

      function setStatus(text, state){
        statusText.textContent = text;
        statusDot.className = 'dot ' + (state || 'off');
      }

      setStatus('Idle','off');

      /* ---------- Helpers for SVG elements ---------- */
      function createNodeSVG(node){
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('class','node');
        g.setAttribute('data-id', node.id);
        g.setAttribute('tabindex', 0);
        g.setAttribute('role','button');
        g.setAttribute('aria-label', `Node ${node.label}`);

        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('r', 26);
        circle.setAttribute('cx', node.x);
        circle.setAttribute('cy', node.y);

        const label = document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('class','node-label');
        label.setAttribute('x', node.x);
        label.setAttribute('y', node.y);
        label.textContent = node.label;

        // Distance badge (small rounded rect + text)
        const distGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
        distGroup.setAttribute('class','dist-group');
        distGroup.setAttribute('transform', `translate(${node.x+30}, ${node.y-30})`);

        const badge = document.createElementNS('http://www.w3.org/2000/svg','rect');
        badge.setAttribute('class','dist-badge');
        badge.setAttribute('width', 44);
        badge.setAttribute('height', 22);
        badge.setAttribute('x', -22);
        badge.setAttribute('y', -11);

        const distText = document.createElementNS('http://www.w3.org/2000/svg','text');
        distText.setAttribute('class','dist-text');
        distText.setAttribute('x', 0);
        distText.setAttribute('y', 0);
        distText.textContent = '∞';

        distGroup.appendChild(badge);
        distGroup.appendChild(distText);

        g.appendChild(circle);
        g.appendChild(label);
        g.appendChild(distGroup);

        // Events
        g.addEventListener('mousedown', nodeMouseDown);
        g.addEventListener('touchstart', nodeTouchStart, {passive:false});
        g.addEventListener('dblclick', () => { /* reserved */ });
        g.addEventListener('click', nodeClick);
        g.addEventListener('keydown', (e)=>{ if(e.key==='Enter') nodeClick(); });

        // store element refs
        node.el = {group:g, circle:circle, label:label, distText:distText, distGroup:distGroup};
        nodesLayer.appendChild(g);
      }

      function createEdgeSVG(edge){
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('class','edge');
        g.setAttribute('data-id', edge.id);

        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('class','edge-line');
        line.setAttribute('x1', edge.ax);
        line.setAttribute('y1', edge.ay);
        line.setAttribute('x2', edge.bx);
        line.setAttribute('y2', edge.by);
        line.setAttribute('stroke-linecap','round');

        // label group: background rect + text
        const lblGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
        lblGroup.setAttribute('class','edge-label-group');
        lblGroup.setAttribute('tabindex',0);
        lblGroup.setAttribute('role','button');
        lblGroup.addEventListener('dblclick', ()=>{ editEdgeWeight(edge); });
        lblGroup.addEventListener('keydown', (e)=>{ if(e.key==='Enter') editEdgeWeight(edge); });

        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rect.setAttribute('class','edge-label-bg');
        rect.setAttribute('width', 36);
        rect.setAttribute('height', 22);
        rect.setAttribute('x', -18);
        rect.setAttribute('y', -11);

        const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
        txt.setAttribute('class','edge-label');
        txt.setAttribute('text-anchor','middle');
        txt.setAttribute('dominant-baseline','middle');
        txt.setAttribute('x', 0);
        txt.setAttribute('y', 0);
        txt.textContent = edge.weight;

        lblGroup.appendChild(rect);
        lblGroup.appendChild(txt);

        // position label at midpoint
        const mx = (edge.ax + edge.bx)/2;
        const my = (edge.ay + edge.by)/2;
        lblGroup.setAttribute('transform', `translate(${mx}, ${my})`);

        g.appendChild(line);
        g.appendChild(lblGroup);

        // events
        g.addEventListener('click', (e)=> {
          e.stopPropagation();
          if(mode==='delete'){ removeEdge(edge.id); }
        });

        edgesLayer.appendChild(g);

        edge.el = {group:g, line:line, labelGroup:lblGroup, labelText:txt, labelRect:rect};
      }

      function updateNodePosition(node){
        const {x,y} = node;
        node.el.circle.setAttribute('cx', x);
        node.el.circle.setAttribute('cy', y);
        node.el.label.setAttribute('x', x);
        node.el.label.setAttribute('y', y);
        node.el.distGroup.setAttribute('transform', `translate(${x+30}, ${y-30})`);
      }

      function updateEdgePosition(edge){
        const a = nodeById(edge.a), b = nodeById(edge.b);
        edge.ax = a.x; edge.ay = a.y;
        edge.bx = b.x; edge.by = b.y;
        edge.el.line.setAttribute('x1', edge.ax);
        edge.el.line.setAttribute('y1', edge.ay);
        edge.el.line.setAttribute('x2', edge.bx);
        edge.el.line.setAttribute('y2', edge.by);
        const mx = (edge.ax + edge.bx)/2;
        const my = (edge.ay + edge.by)/2;
        edge.el.labelGroup.setAttribute('transform', `translate(${mx}, ${my})`);
        edge.el.labelText.textContent = edge.weight;
      }

      function nodeById(id){ return nodes.find(n=>n.id===id); }
      function edgeById(id){ return edges.find(e=>e.id===id); }

      /* ---------- Node and Edge operations ---------- */
      function addNodeAt(x,y){
        const label = String.fromCharCode(65 + (nextNodeId % 26));
        const id = ++nextNodeId;
        const node = {id, label, x, y};
        nodes.push(node);
        createNodeSVG(node);
        return node;
      }

      function addEdge(aId,bId,weight){
        if(aId===bId) return null;
        // avoid duplicate edge
        if(edges.some(e=> (e.a===aId && e.b===bId) || (e.a===bId && e.b===aId) )){
          alert('Edge already exists between these nodes.');
          return null;
        }
        const a = nodeById(aId), b = nodeById(bId);
        const id = 'e' + (edges.length + 1);
        const edge = {id, a:aId, b:bId, weight: Number(weight), ax:a.x, ay:a.y, bx:b.x, by:b.y};
        edges.push(edge);
        createEdgeSVG(edge);
        // send edges behind nodes
        edgesLayer.parentNode.insertBefore(edgesLayer, nodesLayer);
        return edge;
      }

      function removeNode(id){
        // remove edges connected to it
        const related = edges.filter(e => e.a===id || e.b===id).map(e=>e.id);
        related.forEach(removeEdge);
        const idx = nodes.findIndex(n=>n.id===id);
        if(idx>=0){
          const node = nodes[idx];
          nodesLayer.removeChild(node.el.group);
          nodes.splice(idx,1);
        }
        if(sourceId===id) sourceId=null;
        if(targetId===id) targetId=null;
      }
      function removeEdge(id){
        const idx = edges.findIndex(e=>e.id===id);
        if(idx>=0){
          const edge = edges[idx];
          edgesLayer.removeChild(edge.el.group);
          edges.splice(idx,1);
        }
      }

      function editEdgeWeight(edge){
        const val = prompt('Enter new positive weight', String(edge.weight));
        if(val!==null){
          const w = parseFloat(val);
          if(!isFinite(w) || w<=0){
            alert('Please enter a positive number.');
            return;
          }
          edge.weight = w;
          edge.el.labelText.textContent = w;
          pulseElement(edge.el.labelGroup);
        }
      }

      /* ---------- Interaction: Mouse & Touch ---------- */
      function getSvgPoint(evt){
        const CTM = svg.getScreenCTM();
        if(evt.touches && evt.touches[0]) evt = evt.touches[0];
        return {
          x: (evt.clientX - CTM.e) / CTM.a,
          y: (evt.clientY - CTM.f) / CTM.d
        };
      }

      // Canvas click for adding nodes
      graph.addEventListener('click', (evt)=>{
        if(mode!=='add-node') return;
        const pt = getSvgPoint(evt);
        const node = addNodeAt(pt.x, pt.y);
        updateNodeVisuals();
      });

      // Node events
      function nodeClick(evt){
        evt.stopPropagation();
        const id = this.getAttribute ? this.getAttribute('data-id') : this.group.dataset.id;
        const nid = Number(id);
        if(mode==='delete'){
          removeNode(nid);
          return;
        }
        if(mode==='add-edge'){
          if(!addingEdgeFrom){
            addingEdgeFrom = nid;
            setStatus('Select target node for edge','busy');
            highlightNode(nid, true);
          } else {
            const from = addingEdgeFrom;
            const to = nid;
            highlightingClear();
            addingEdgeFrom = null;
            setStatus('Idle','off');
            if(from===to) return;
            const weight = prompt('Enter edge weight (positive number)', '1');
            if(weight===null) return;
            const w = parseFloat(weight);
            if(!isFinite(w) || w<=0){ alert('Invalid weight'); return; }
            addEdge(from,to,w);
            updateAllEdges();
          }
        } else if(mode==='set-source'){
          sourceId = nid;
          setStatus('Source set','ready');
          highlightNode(nid, true, 'source');
          mode = null;
        } else if(mode==='set-target'){
          targetId = nid;
          setStatus('Target set','ready');
          highlightNode(nid, true, 'target');
          mode = null;
        } else {
          // Toggle selection: allow setting source/target faster
          if(!sourceId){ sourceId = nid; highlightNode(nid,true,'source'); setStatus('Source selected','ready'); }
          else if(!targetId && nid!==sourceId){ targetId = nid; highlightNode(nid,true,'target'); setStatus('Target selected','ready'); }
          else if(nid===sourceId){ sourceId=null; highlightNode(nid,false); setStatus('Source cleared','off'); }
          else if(nid===targetId){ targetId=null; highlightNode(nid,false); setStatus('Target cleared','off'); }
        }
      }

      function highlightNode(id, on, role){
        const node = nodeById(id);
        if(!node) return;
        if(on){
          if(role==='source'){ node.el.circle.setAttribute('fill','#052e21'); node.el.circle.setAttribute('stroke','#34d399'); }
          else if(role==='target'){ node.el.circle.setAttribute('fill','#2b0217'); node.el.circle.setAttribute('stroke','#fb7185'); }
          else node.el.circle.setAttribute('stroke','#60a5fa');
        } else {
          node.el.circle.setAttribute('fill','#021627');
          node.el.circle.setAttribute('stroke','rgba(56,189,248,0.18)');
        }
      }

      function highlightingClear(){
        nodes.forEach(n => { n.el.circle.setAttribute('stroke','rgba(56,189,248,0.18)'); });
      }

      // Dragging nodes
      function nodeMouseDown(evt){
        evt.preventDefault();
        const id = Number(this.getAttribute('data-id'));
        const node = nodeById(id);
        dragging = {id, offsetX:0, offsetY:0};
        const start = getSvgPoint(evt);
        dragging.offsetX = node.x - start.x;
        dragging.offsetY = node.y - start.y;
        document.addEventListener('mousemove', nodeMouseMove);
        document.addEventListener('mouseup', nodeMouseUp);
      }
      function nodeMouseMove(evt){
        if(!dragging) return;
        const pt = getSvgPoint(evt);
        const node = nodeById(dragging.id);
        node.x = pt.x + dragging.offsetX;
        node.y = pt.y + dragging.offsetY;
        updateNodePosition(node);
        edges.forEach(updateEdgePosition);
      }
      function nodeMouseUp(){
        dragging = null;
        document.removeEventListener('mousemove', nodeMouseMove);
        document.removeEventListener('mouseup', nodeMouseUp);
      }

      // Touch equivalents
      function nodeTouchStart(evt){
        evt.preventDefault();
        const id = Number(this.getAttribute('data-id'));
        const node = nodeById(id);
        dragging = {id, offsetX:0, offsetY:0};
        const start = getSvgPoint(evt);
        dragging.offsetX = node.x - start.x;
        dragging.offsetY = node.y - start.y;
        document.addEventListener('touchmove', nodeTouchMove, {passive:false});
        document.addEventListener('touchend', nodeTouchEnd);
      }
      function nodeTouchMove(evt){
        evt.preventDefault();
        if(!dragging) return;
        const pt = getSvgPoint(evt);
        const node = nodeById(dragging.id);
        node.x = pt.x + dragging.offsetX;
        node.y = pt.y + dragging.offsetY;
        updateNodePosition(node);
        edges.forEach(updateEdgePosition);
      }
      function nodeTouchEnd(){
        dragging = null;
        document.removeEventListener('touchmove', nodeTouchMove);
        document.removeEventListener('touchend', nodeTouchEnd);
      }

      /* ---------- UI Controls ---------- */
      btnAddNode.addEventListener('click', ()=>{ mode='add-node'; setStatus('Click canvas to add node','busy'); });
      btnAddEdge.addEventListener('click', ()=>{ mode='add-edge'; addingEdgeFrom = null; setStatus('Select source node for edge','busy'); });
      btnDelete.addEventListener('click', ()=>{ mode = (mode==='delete'? null:'delete'); setStatus(mode==='delete'?'Delete mode active':'Idle', mode==='delete'?'busy':'off'); });
      btnReset.addEventListener('click', resetGraph);
      btnSetSource.addEventListener('click', ()=>{ mode='set-source'; setStatus('Click a node to set source','busy'); });
      btnSetTarget.addEventListener('click', ()=>{ mode='set-target'; setStatus('Click a node to set target','busy'); });

      btnRun.addEventListener('click', ()=>{
        if(!sourceId || !targetId){ alert('Select a source and a target node first.'); return; }
        resetVisualState();
        const steps = generateDijkstraSteps(sourceId);
        dijkstraState = steps;
        autoPlay = true;
        setStatus('Running Dijkstra','busy');
        runSteps();
      });

      btnStep.addEventListener('click', ()=>{
        if(!sourceId || !targetId){ alert('Select source and target.'); return; }
        if(!dijkstraState){
          resetVisualState();
          dijkstraState = generateDijkstraSteps(sourceId);
        }
        autoPlay = false;
        stepOnce();
      });

      speedInput.addEventListener('input', ()=>{ /* speed used by animation timers */ });

      // Keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.key==='n' || e.key==='N'){ btnAddNode.click(); }
        if(e.key==='e' || e.key==='E'){ btnAddEdge.click(); }
        if(e.key==='d' || e.key==='D'){ btnDelete.click(); }
        if(e.key==='r' || e.key==='R'){ btnRun.click(); }
      });

      /* ---------- Visualization helpers ---------- */
      function updateNodeVisuals(){
        nodes.forEach(updateNodePosition);
        edges.forEach(updateEdgePosition);
      }

      function updateAllEdges(){
        edges.forEach(e => updateEdgePosition(e));
      }

      function resetGraph(){
        // remove all nodes & edges
        nodes.slice().forEach(n => removeNode(n.id));
        edges.slice().forEach(e => removeEdge(e.id));
        nextNodeId = 0;
        sourceId = targetId = null;
        mode = null;
        setStatus('Cleared','off');
      }

      function resetVisualState(){
        // clear styles
        edges.forEach(e => {
          e.el.line.classList.remove('edge-active','edge-visited');
          e.el.line.style.opacity = '';
        });
        nodes.forEach(n => {
          n.el.distText.textContent = '∞';
          n.el.circle.setAttribute('fill','#021627');
          n.el.circle.setAttribute('stroke','rgba(56,189,248,0.18)');
        });
        highlightNode(sourceId, true, 'source');
        highlightNode(targetId, true, 'target');
        dijkstraState = null;
      }

      function pulseElement(el){
        el.classList.add('pulse');
        setTimeout(()=> el.classList.remove('pulse'), 800);
      }

      /* ---------- Dijkstra: generator that yields visualization steps ---------- */
      function generateDijkstraSteps(srcId){
        // Build adjacency
        const adj = new Map();
        nodes.forEach(n => adj.set(n.id, []));
        edges.forEach(e => {
          adj.get(e.a).push({to:e.b, w:e.weight, edgeId:e.id});
          adj.get(e.b).push({to:e.a, w:e.weight, edgeId:e.id});
        });

        const dist = new Map();
        const prev = new Map();
        nodes.forEach(n => { dist.set(n.id, Infinity); prev.set(n.id, null); });
        dist.set(srcId,0);

        const visited = new Set();
        // Simple priority queue via array (fine for small interactive graphs)
        const queue = [{id:srcId, dist:0}];

        // initial yield to show source
        return (function*(){
          // set initial distances in UI
          for(const n of nodes){
            const val = dist.get(n.id);
            n.el.distText.textContent = (val===Infinity ? '∞' : String(val));
          }
          yield {type:'init'};

          while(queue.length){
            // get node with smallest dist
            queue.sort((a,b)=>a.dist-b.dist);
            const cur = queue.shift();
            if(visited.has(cur.id)) continue;
            visited.add(cur.id);

            // highlight current node
            const curNode = nodeById(cur.id);
            // mark current as visited (color)
            curNode.el.circle.setAttribute('stroke','#fbbf24');
            curNode.el.circle.setAttribute('fill','#07110a');
            yield {type:'visit', id:cur.id};

            // if reached target, finish (but still yield path)
            if(cur.id === targetId){
              // reconstruct path
              const path = [];
              let u = targetId;
              while(u){
                const p = prev.get(u);
                if(!p) break;
                path.push({from:p.node, to:u, edgeId:p.edgeId});
                u = p.node;
              }
              yield {type:'found', path};
              return;
            }

            // relax edges
            for(const neighbour of adj.get(cur.id) || []){
              yield {type:'relax-try', from:cur.id, to:neighbour.to, edgeId:neighbour.edgeId};
              const nd = dist.get(cur.id) + neighbour.w;
              if(nd < dist.get(neighbour.to)){
                dist.set(neighbour.to, nd);
                prev.set(neighbour.to, {node:cur.id, edgeId:neighbour.edgeId});
                queue.push({id:neighbour.to, dist:nd});
                // update UI distance
                const nnode = nodeById(neighbour.to);
                nnode.el.distText.textContent = String(nd);
                pulseElement(nnode.el.distText);
                // highlight edge as relaxed
                yield {type:'relaxed', edgeId:neighbour.edgeId};
              } else {
                // not improved
                yield {type:'relax-failed', edgeId:neighbour.edgeId};
              }
            }
          }
          yield {type:'done'};
        })();
      }

      // Drive generator steps into animations
      async function runSteps(){
        if(!dijkstraState) return;
        const speed = Number(speedInput.value) || 1;
        const delay = (ms)=> new Promise(res=> setTimeout(res, ms));
        while(true){
          const {value, done} = dijkstraState.next();
          if(done) break;
          await processStep(value);
          if(!autoPlay) break;
          // adaptive delay: visited slower, relax quicker
          let wait = 700 / speed;
          if(value && (value.type==='relax-try' || value.type==='relax-failed' || value.type==='relaxed')) wait = 350 / speed;
          if(value && value.type==='found') wait = 900 / speed;
          await delay(wait);
        }
        if(autoPlay){
          setStatus('Finished','ready');
          autoPlay = false;
        }
      }

      function stepOnce(){
        if(!dijkstraState) return;
        const {value, done} = dijkstraState.next();
        if(done){ setStatus('Finished','ready'); dijkstraState=null; return; }
        processStep(value);
      }

      async function processStep(step){
        if(!step) return;
        switch(step.type){
          case 'init':
            setStatus('Starting Dijkstra','busy');
            break;
          case 'visit':
            // flash node
            const n = nodeById(step.id);
            n.el.circle.classList.add('pulse');
            setTimeout(()=> n.el.circle.classList.remove('pulse'), 700);
            break;
          case 'relax-try':
            // flash the edge line lightly
            const e1 = edgeById(step.edgeId);
            e1.el.line.classList.add('edge-visited');
            setTimeout(()=> e1.el.line.classList.remove('edge-visited'), 500);
            break;
          case 'relaxed':
            // stronger flash & increase stroke then restore
            const e2 = edgeById(step.edgeId);
            e2.el.line.classList.add('edge-active');
            pulseElement(e2.el.labelGroup);
            setTimeout(()=> e2.el.line.classList.remove('edge-active'), 900);
            break;
          case 'relax-failed':
            const e3 = edgeById(step.edgeId);
            e3.el.line.style.opacity = '0.6';
            setTimeout(()=> e3.el.line.style.opacity = '', 600);
            break;
          case 'found':
            // highlight final path
            for(const seg of step.path){
              const edge = edgeById(seg.edgeId);
              edge.el.line.classList.add('path-highlight');
              edge.el.line.style.transition = 'stroke-width 200ms ease';
            }
            setStatus('Shortest path found','ready');
            break;
          case 'done':
            setStatus('Completed (target unreachable)','off');
            break;
        }
      }

      /* ---------- Misc helpers ---------- */
      function updateAll(){
        updateNodeVisuals();
        updateAllEdges();
      }

      // Simple pulse for label groups
      function pulseLabelGroup(g){ g.classList.add('pulse'); setTimeout(()=> g.classList.remove('pulse'), 700); }

      // Expose a couple for debugging
      window._graphAPI = { addNodeAt, addEdge, nodes, edges };

      // Initialize with a small sample graph to get started
      (function seed(){
        const w = 1200, h = 800;
        const a = addNodeAt(w*0.25, h*0.35);
        const b = addNodeAt(w*0.4, h*0.6);
        const c = addNodeAt(w*0.62, h*0.32);
        const d = addNodeAt(w*0.78, h*0.62);
        addEdge(a.id,b.id,4);
        addEdge(a.id,c.id,1.5);
        addEdge(b.id,c.id,2.2);
        addEdge(c.id,d.id,3);
        updateAll();
      })();

    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Application",
  "description": "FSM modeling user interaction and algorithm visualization states for a weighted-graph Dijkstra exploration app (modes, node/edge editing, dragging, and Dijkstra run/step playback).",
  "states": [
    {
      "name": "idle",
      "onEnter": "setModeNull; setStatus('Idle','off')",
      "onExit": "none",
      "on": {
        "BTN_ADD_NODE": "adding_node",
        "BTN_ADD_EDGE": "add_edge_select_source",
        "BTN_DELETE_TOGGLE": "delete_mode",
        "BTN_SET_SOURCE": "set_source",
        "BTN_SET_TARGET": "set_target",
        "BTN_RESET": "idle",
        "BTN_RUN": "dijkstra_running",
        "BTN_STEP": "dijkstra_paused",
        "GRAPH_CLICK": "idle",
        "NODE_CLICK": "idle",
        "NODE_MOUSEDOWN": "dragging",
        "EDGE_CLICK": "idle",
        "EDGE_LABEL_DBLCLICK": "editing_edge_weight"
      }
    },
    {
      "name": "adding_node",
      "onEnter": "setMode('add-node'); setStatus('Click canvas to add node','busy')",
      "onExit": "setStatus('Idle','off')",
      "on": {
        "GRAPH_CLICK": "adding_node",
        "BTN_ADD_NODE": "adding_node",
        "BTN_ADD_EDGE": "add_edge_select_source",
        "BTN_DELETE_TOGGLE": "delete_mode",
        "BTN_RESET": "idle",
        "BTN_RUN": "dijkstra_running",
        "NODE_MOUSEDOWN": "dragging",
        "EDGE_LABEL_DBLCLICK": "editing_edge_weight"
      }
    },
    {
      "name": "add_edge_select_source",
      "onEnter": "setMode('add-edge'); addingEdgeFrom=null; setStatus('Select source node for edge','busy')",
      "onExit": "addingEdgeFrom=null; setStatus('Idle','off')",
      "on": {
        "NODE_CLICK": "add_edge_select_target",
        "BTN_ADD_NODE": "adding_node",
        "BTN_DELETE_TOGGLE": "delete_mode",
        "BTN_RESET": "idle",
        "NODE_MOUSEDOWN": "dragging",
        "EDGE_LABEL_DBLCLICK": "editing_edge_weight"
      }
    },
    {
      "name": "add_edge_select_target",
      "onEnter": "setStatus('Select target node for edge','busy'); highlightNode(addingEdgeFrom,true)",
      "onExit": "highlightingClear(); addingEdgeFrom=null; setStatus('Idle','off')",
      "on": {
        "NODE_CLICK": "add_edge_select_source",
        "BTN_ADD_NODE": "adding_node",
        "BTN_DELETE_TOGGLE": "delete_mode",
        "BTN_RESET": "idle",
        "NODE_MOUSEDOWN": "dragging",
        "EDGE_LABEL_DBLCLICK": "editing_edge_weight"
      }
    },
    {
      "name": "delete_mode",
      "onEnter": "setMode('delete'); setStatus('Delete mode active','busy')",
      "onExit": "setModeNull; setStatus('Idle','off')",
      "on": {
        "NODE_CLICK": "delete_mode",
        "EDGE_CLICK": "delete_mode",
        "BTN_DELETE_TOGGLE": "idle",
        "BTN_RESET": "idle",
        "NODE_MOUSEDOWN": "dragging",
        "EDGE_LABEL_DBLCLICK": "editing_edge_weight"
      }
    },
    {
      "name": "set_source",
      "onEnter": "setMode('set-source'); setStatus('Click a node to set source','busy')",
      "onExit": "setModeNull; setStatus('Idle','off')",
      "on": {
        "NODE_CLICK": "idle",
        "BTN_RESET": "idle",
        "NODE_MOUSEDOWN": "dragging"
      }
    },
    {
      "name": "set_target",
      "onEnter": "setMode('set-target'); setStatus('Click a node to set target','busy')",
      "onExit": "setModeNull; setStatus('Idle','off')",
      "on": {
        "NODE_CLICK": "idle",
        "BTN_RESET": "idle",
        "NODE_MOUSEDOWN": "dragging"
      }
    },
    {
      "name": "dragging",
      "onEnter": "startDrag (attach move/end listeners, store previous mode)",
      "onExit": "stopDragAndRestoreMode (remove listeners, restore prior mode)",
      "on": {
        "NODE_MOUSEMOVE": "dragging",
        "NODE_TOUCHMOVE": "dragging",
        "NODE_MOUSEUP": "idle",
        "NODE_TOUCHEND": "idle"
      }
    },
    {
      "name": "editing_edge_weight",
      "onEnter": "editEdgeWeight(prompt); (validate weight, update edge.weight; pulseElement(label))",
      "onExit": "none",
      "on": {
        "EDGE_LABEL_DBLCLICK": "editing_edge_weight",
        "BTN_RESET": "idle",
        "NODE_MOUSEDOWN": "dragging"
      }
    },
    {
      "name": "dijkstra_running",
      "onEnter": "startDijkstra (resetVisualState; dijkstraState=generateDijkstraSteps(src); autoPlay=true; setStatus('Running Dijkstra','busy'); runSteps())",
      "onExit": "autoPlay=false (if running); clear any running timers",
      "on": {
        "DIJKSTRA_STEP": "dijkstra_running",
        "DIJKSTRA_VISIT": "dijkstra_running",
        "DIJKSTRA_RELAX_TRY": "dijkstra_running",
        "DIJKSTRA_RELAXED": "dijkstra_running",
        "DIJKSTRA_RELAX_FAILED": "dijkstra_running",
        "DIJKSTRA_FOUND": "dijkstra_done",
        "DIJKSTRA_DONE": "dijkstra_done",
        "BTN_STEP": "dijkstra_paused",
        "BTN_RESET": "idle",
        "NODE_MOUSEDOWN": "dragging"
      }
    },
    {
      "name": "dijkstra_paused",
      "onEnter": "pauseDijkstra (autoPlay=false); if dijkstraState absent then initialize generator and set initial UI",
      "onExit": "none",
      "on": {
        "BTN_STEP": "dijkstra_paused",
        "BTN_RUN": "dijkstra_running",
        "DIJKSTRA_FOUND": "dijkstra_done",
        "DIJKSTRA_DONE": "dijkstra_done",
        "BTN_RESET": "idle",
        "NODE_MOUSEDOWN": "dragging"
      }
    },
    {
      "name": "dijkstra_done",
      "onEnter": "finalizeDijkstra (setStatus('Finished' or 'Completed (target unreachable)','ready'/'off'); autoPlay=false; dijkstraState=null)",
      "onExit": "none",
      "on": {
        "BTN_RUN": "dijkstra_running",
        "BTN_STEP": "dijkstra_paused",
        "BTN_RESET": "idle",
        "NODE_MOUSEDOWN": "dragging"
      }
    }
  ],
  "events": [
    "BTN_ADD_NODE",
    "BTN_ADD_EDGE",
    "BTN_DELETE_TOGGLE",
    "BTN_RESET",
    "BTN_SET_SOURCE",
    "BTN_SET_TARGET",
    "BTN_RUN",
    "BTN_STEP",
    "GRAPH_CLICK",
    "NODE_CLICK",
    "EDGE_CLICK",
    "EDGE_LABEL_DBLCLICK",
    "NODE_MOUSEDOWN",
    "NODE_MOUSEMOVE",
    "NODE_MOUSEUP",
    "NODE_TOUCHSTART",
    "NODE_TOUCHMOVE",
    "NODE_TOUCHEND",
    "DIJKSTRA_STEP",
    "DIJKSTRA_VISIT",
    "DIJKSTRA_RELAX_TRY",
    "DIJKSTRA_RELAXED",
    "DIJKSTRA_RELAX_FAILED",
    "DIJKSTRA_FOUND",
    "DIJKSTRA_DONE"
  ],
  "notes": "Guards and side effects: BTN_RUN requires a source and target to be selected (otherwise the code shows an alert and stays in the current UI mode). Add-edge has an internal sub-state: selecting source then selecting target (mode 'add-edge' with addingEdgeFrom used). GRAPH_CLICK in adding_node triggers addNodeAt(x,y) and update visuals. NODE_CLICK behavior is context-sensitive: in delete_mode it removes the node; in add-edge it either sets addingEdgeFrom (source) or finalizes edge by prompting for weight and adding the edge; in set_source/set_target it assigns and then returns to idle; in idle it toggles source/target selection. Dragging is orthogonal: a NODE_MOUSEDOWN enters dragging, which restores the previous mode on NODE_MOUSEUP/TOUCHEND. Dijkstra steps are driven by a generator: internal events (DIJKSTRA_VISIT, DIJKSTRA_RELAX_TRY, DIJKSTRA_RELAXED, DIJKSTRA_RELAX_FAILED, DIJKSTRA_FOUND, DIJKSTRA_DONE) correspond to visual actions (flash node, flash edge, highlight path). The FSM models these internal algorithm events as transitions that keep the run/paused states. Edge-weight editing uses a prompt and validates a positive number before applying; invalid input results in alert and no change. Some transitions are self-loops (e.g., repeated add-node clicks) and many transitions cause UI side-effects listed in onEnter/onExit action descriptions."
}
  </script>
</body>
</html>