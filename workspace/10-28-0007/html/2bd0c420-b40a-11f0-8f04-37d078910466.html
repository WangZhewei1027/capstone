<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hash Table — Interactive Module (Separate Chaining)</title>
  <style>
    :root{
      --bg:#f7fbff;
      --card:#ffffff;
      --accent:#0b66ff;
      --muted:#6b7280;
      --success:#16a34a;
      --danger:#dc2626;
      --shadow: 0 6px 18px rgba(11,102,255,0.06);
      --gap:16px;
    }
    /* Safe area margins 24px */
    html,body{height:100%;}
    body{
      margin:0;
      padding:24px;
      box-sizing:border-box;
      font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:linear-gradient(180deg,#f0f6ff 0%, var(--bg) 100%);
      color:#0f172a;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Top info card */
    .top {
      background:var(--card);
      border-radius:10px;
      padding:18px;
      box-shadow:var(--shadow);
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-bottom:var(--gap);
    }
    .title{
      display:flex;
      align-items:center;
      gap:12px;
    }
    .title h1{
      margin:0;
      font-size:20px;
      line-height:1.05;
    }
    .subtitle{
      color:var(--muted);
      font-size:13px;
      margin:0;
    }

    /* Layout: controls + canvas */
    .container{
      display:grid;
      grid-template-columns:360px 1fr;
      gap:24px;
      align-items:start;
    }
    @media (max-width:880px){
      .container{
        grid-template-columns:1fr;
      }
    }

    /* Controls card */
    .panel{
      background:var(--card);
      border-radius:10px;
      padding:18px;
      box-shadow:var(--shadow);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    label{
      font-size:13px;
      color:var(--muted);
      display:block;
      margin-bottom:6px;
    }
    .controls-row{display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap;}
    input[type="text"]{
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #e6eefc;
      min-width:0;
      flex:1;
      font-size:14px;
      outline:none;
    }
    button{
      background:var(--accent);
      color:white;
      border:0;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      min-width:84px;
      box-shadow:0 6px 16px rgba(11,102,255,0.08);
    }
    button.ghost{
      background:transparent;
      color:var(--accent);
      border:1px solid rgba(11,102,255,0.12);
      box-shadow:none;
    }
    button.warn{
      background:var(--danger);
    }
    .small{
      padding:8px 10px;
      min-width:60px;
      font-size:13px;
    }
    .inline-note{
      font-size:13px;
      color:var(--muted);
    }

    /* Slider and selects */
    select, input[type="range"]{
      padding:8px 10px;
      border-radius:8px;
      border:1px solid #e6eefc;
      background:white;
      font-size:13px;
    }

    /* Canvas card */
    .canvas{
      background:linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);
      border-radius:10px;
      padding:18px;
      box-shadow:var(--shadow);
      min-height:420px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      overflow:hidden;
    }

    /* Hash function display */
    .hash-info{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .badge{
      font-size:13px;
      padding:8px 10px;
      border-radius:8px;
      background:#f1f8ff;
      color:var(--accent);
      border:1px solid rgba(11,102,255,0.06);
    }

    /* Buckets row */
    .buckets-wrap{
      overflow:auto;
      padding:12px;
      border-radius:8px;
      border:1px dashed #eef5ff;
      background:linear-gradient(90deg, rgba(11,102,255,0.02), transparent);
      flex:1;
      min-height:220px;
    }
    .buckets{
      display:flex;
      gap:12px;
      align-items:flex-start;
      padding-bottom:12px;
    }
    .bucket{
      width:120px;
      min-width:120px;
      background:#fbfbff;
      border-radius:8px;
      border:1px solid #eef3ff;
      padding:10px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:stretch;
      position:relative;
    }
    .bucket .idx{
      font-weight:700;
      color:var(--muted);
      font-size:13px;
    }
    .chain{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .node{
      background:linear-gradient(180deg,#ffffff,#f8fbff);
      padding:8px 10px;
      border-radius:8px;
      border:1px solid #e6f0ff;
      display:flex;
      align-items:center;
      gap:8px;
      box-shadow:0 3px 6px rgba(11,102,255,0.04);
      font-size:14px;
    }
    .node .keytext{flex:1; word-break:break-all;}
    .node.small{padding:6px 8px; font-size:13px;}
    .node.highlight{
      box-shadow:0 6px 18px rgba(11,102,255,0.12);
      transform:translateY(-4px);
      border-color:rgba(11,102,255,0.18);
      transition:all 260ms ease;
    }
    .node.found{
      outline:3px solid rgba(22,163,74,0.12);
      transform:translateY(-6px);
      transition:all 260ms ease;
    }

    /* Floating key used for animation */
    .floating{
      position:fixed;
      z-index:9999;
      pointer-events:none;
      transition:transform 520ms cubic-bezier(.2,.9,.3,1), opacity 220ms linear;
      will-change:transform, opacity;
      transform-origin:center;
    }

    /* Stats row */
    .stats{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .stat{
      background:#fff;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid #eef5ff;
      font-size:13px;
      color:var(--muted);
    }

    /* Small helper text & footer */
    .explain{
      font-size:13px;
      color:var(--muted);
      line-height:1.45;
    }
    .spaced{margin-top:8px;}
    /* Accessibility focus */
    button:focus, input:focus, select:focus {outline:3px solid rgba(11,102,255,0.12); outline-offset:2px;}
  </style>
</head>
<body>
  <main>
    <section class="top" aria-labelledby="main-title">
      <div class="title">
        <h1 id="main-title">Hash Table — Separate Chaining (Visual Exploration)</h1>
      </div>
      <p class="subtitle">
        Interactive module to learn how keys are mapped to buckets using a hash function and how collisions are handled with separate chaining.
      </p>
    </section>

    <div class="container">
      <!-- Controls -->
      <aside class="panel" aria-labelledby="controls-title">
        <h2 id="controls-title" style="margin:0;font-size:15px;">Controls & Actions</h2>

        <div>
          <label for="keyInput">Key (string or number)</label>
          <div class="controls-row">
            <input id="keyInput" type="text" placeholder="e.g. apple or 42" aria-label="Key input">
            <button id="insertBtn" title="Insert key">Insert</button>
            <button id="searchBtn" class="ghost" title="Search key">Search</button>
          </div>
          <div style="display:flex;gap:12px;margin-top:8px;align-items:center;">
            <button id="removeBtn" class="ghost small">Remove</button>
            <button id="clearBtn" class="ghost small">Clear Table</button>
          </div>
        </div>

        <div>
          <label for="sizeRange">Table size (number of buckets): <span id="sizeLabel">8</span></label>
          <div class="controls-row">
            <input id="sizeRange" type="range" min="4" max="20" value="8" aria-label="Table size">
            <button id="rehashBtn" class="small">Rehash</button>
          </div>
          <p class="inline-note spaced">Changing the slider changes the target size. Click Rehash to rebuild and see reinsertions.</p>
        </div>

        <div>
          <label for="hashSelect">Hash function</label>
          <div class="controls-row">
            <select id="hashSelect" aria-label="Hash function">
              <option value="sum">Sum of char codes (simple)</option>
              <option value="poly">Polynomial rolling (base 31)</option>
              <option value="first">First char code</option>
            </select>
            <div class="inline-note">All functions then mod table size.</div>
          </div>
        </div>

        <div>
          <label>Play controls</label>
          <div class="controls-row">
            <button id="stepInsertBtn" class="ghost small">Insert (step)</button>
            <button id="stepSearchBtn" class="ghost small">Search (step)</button>
            <button id="autoBtn" class="small">Auto animations</button>
          </div>
          <p class="inline-note spaced">Step mode lets you advance each internal step (hash compute, inspect bucket, traverse chain).</p>
        </div>

        <div>
          <h3 style="margin:0;font-size:14px;">Concept Overview</h3>
          <p class="explain spaced">
            Concept Title: Hash Table using Separate Chaining.
            Learning Objective: Understand how a hash function maps keys to bucket indices, why collisions happen,
            and how chaining stores multiple keys per bucket. Interact by inserting, searching, removing, and rehashing.
          </p>
        </div>
      </aside>

      <!-- Canvas -->
      <section class="canvas" aria-labelledby="canvas-title">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
          <div>
            <h2 id="canvas-title" style="margin:0;font-size:15px;">Hash Table Visualizer</h2>
            <div class="hash-info spaced">
              <div class="badge" id="hashFnBadge">Fn: sum % n</div>
              <div class="inline-note">Computed hash shown during insertion/search.</div>
            </div>
          </div>

          <div class="stats" aria-live="polite">
            <div class="stat">Buckets: <strong id="statSize">8</strong></div>
            <div class="stat">Keys: <strong id="statCount">0</strong></div>
            <div class="stat">Load factor: <strong id="statLoad">0.00</strong></div>
            <div class="stat">Collisions: <strong id="statCollisions">0</strong></div>
          </div>
        </div>

        <div class="buckets-wrap" id="bucketsWrap" aria-label="Buckets area">
          <div class="buckets" id="buckets" role="list"></div>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
          <div class="explain" id="stepExplain">Tip: Type a key and Insert. Watch the key compute its hash and animate into the bucket. Search highlights traversal.</div>
          <div style="display:flex;gap:10px;align-items:center;">
            <button id="demoBtn" class="ghost">Demo: Insert sample keys</button>
            <button id="collapseBtn" class="ghost">Show Plan</button>
          </div>
        </div>

        <!-- Hidden area for the planning text (Interaction Design & Layout Description) -->
        <div id="plan" style="display:none;margin-top:12px;padding:12px;border-radius:8px;background:#f9fbff;border:1px solid #eef6ff;">
          <h3 style="margin-top:0;">Interaction Design</h3>
          <p class="explain">Users interact by typing keys and clicking Insert/Search/Remove. Each action animates: the key element "flies" from the input to the computed bucket index, then attaches as a node in a vertical chain. When a collision occurs (bucket already contains nodes), the new node is appended — the animation pauses and the collision counter increments. Searching animates traversal through the chain, highlighting nodes step-by-step until found or end reached. Rehashing visualizes re-inserting all keys into the new table size (fast animated reenlistment).</p>
          <h3>Layout Description</h3>
          <p class="explain">Safe area margins: 24px on all sides. The layout is a two-column responsive grid: left column contains controls (fixed-width 360px) and right column is the visual canvas. Minimum spacing between interactive elements is 16px. The buckets scroll horizontally if they overflow, maintaining clarity. Controls are grouped and labeled with accessible elements. Visual feedback uses color, movement, and focus outlines for accessibility.</p>
        </div>
      </section>
    </div>
  </main>

  <script>
    // Hash Table Visualizer — Separate Chaining
    (function(){
      // State
      let tableSize = 8;
      let table = Array.from({length:tableSize},()=>[]);
      let keyCount = 0;
      let collisions = 0;
      let autoAnimate = true;
      let stepMode = {insert:false, search:false};
      const bucketsEl = document.getElementById('buckets');
      const bucketsWrap = document.getElementById('bucketsWrap');
      const sizeRange = document.getElementById('sizeRange');
      const sizeLabel = document.getElementById('sizeLabel');
      const statSize = document.getElementById('statSize');
      const statCount = document.getElementById('statCount');
      const statLoad = document.getElementById('statLoad');
      const statCollisions = document.getElementById('statCollisions');
      const hashSelect = document.getElementById('hashSelect');
      const hashFnBadge = document.getElementById('hashFnBadge');
      const keyInput = document.getElementById('keyInput');
      const insertBtn = document.getElementById('insertBtn');
      const stepInsertBtn = document.getElementById('stepInsertBtn');
      const searchBtn = document.getElementById('searchBtn');
      const stepSearchBtn = document.getElementById('stepSearchBtn');
      const removeBtn = document.getElementById('removeBtn');
      const clearBtn = document.getElementById('clearBtn');
      const rehashBtn = document.getElementById('rehashBtn');
      const demoBtn = document.getElementById('demoBtn');
      const collapseBtn = document.getElementById('collapseBtn');
      const planEl = document.getElementById('plan');
      const autoBtn = document.getElementById('autoBtn');
      const stepExplain = document.getElementById('stepExplain');

      // Utilities
      function updateStats(){
        statSize.textContent = tableSize;
        statCount.textContent = keyCount;
        statLoad.textContent = (keyCount / tableSize).toFixed(2);
        statCollisions.textContent = collisions;
      }

      function normalizeKey(k){
        return String(k);
      }

      function charSumHash(s){
        // simple
        let sum = 0;
        for(let i=0;i<s.length;i++) sum += s.charCodeAt(i);
        return sum;
      }
      function polyHash(s){
        let hash = 0;
        const base = 31;
        for(let i=0;i<s.length;i++){
          hash = (hash * base + s.charCodeAt(i)) >>> 0;
        }
        return hash;
      }
      function firstCharHash(s){
        return s.length ? s.charCodeAt(0) : 0;
      }

      function computeHash(key){
        const s = normalizeKey(key);
        const fn = hashSelect.value;
        let raw;
        if(fn === 'sum') raw = charSumHash(s);
        else if(fn === 'poly') raw = polyHash(s);
        else raw = firstCharHash(s);
        return {raw, index: raw % tableSize};
      }

      function setHashBadge(){
        const map = {
          'sum':'Fn: sum(charCodes) % n',
          'poly':'Fn: poly(base=31) % n',
          'first':'Fn: firstCharCode % n'
        };
        hashFnBadge.textContent = map[hashSelect.value];
      }

      // Rendering
      function renderTable(){
        bucketsEl.innerHTML = '';
        for(let i=0;i<tableSize;i++){
          const bucket = document.createElement('div');
          bucket.className = 'bucket';
          bucket.setAttribute('data-idx', i);
          bucket.setAttribute('role','listitem');
          bucket.innerHTML = `<div class="idx">idx ${i}</div><div class="chain" aria-label="chain"></div>`;
          const chain = bucket.querySelector('.chain');
          for(let j=0;j<table[i].length;j++){
            const node = createNodeElement(table[i][j]);
            chain.appendChild(node);
          }
          bucketsEl.appendChild(bucket);
        }
        updateStats();
      }

      function createNodeElement(key){
        const node = document.createElement('div');
        node.className = 'node';
        node.tabIndex = 0;
        node.innerHTML = `<div class="keytext">${escapeHtml(key)}</div><div style="color:var(--muted);font-size:12px;">↳</div>`;
        node.setAttribute('data-key', key);
        return node;
      }

      function escapeHtml(str){
        return String(str).replace(/[&<>"']/g, function(m){return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m];});
      }

      // Animation helpers
      function createFloatingNode(text){
        const el = document.createElement('div');
        el.className = 'node floating';
        el.style.position = 'fixed';
        el.style.margin = '0';
        el.style.zIndex = 9999;
        el.innerHTML = `<div class="keytext">${escapeHtml(text)}</div>`;
        document.body.appendChild(el);
        return el;
      }

      function animateToTarget(floating, targetRect){
        return new Promise((resolve)=>{
          // Place floating at its current position (already set)
          // Compute transform to target center
          const fRect = floating.getBoundingClientRect();
          const dx = (targetRect.left + targetRect.width/2) - (fRect.left + fRect.width/2);
          const dy = (targetRect.top + targetRect.height/2) - (fRect.top + fRect.height/2);
          floating.style.transition = 'transform 520ms cubic-bezier(.2,.9,.3,1), opacity 220ms linear';
          floating.style.transform = `translate(${dx}px, ${dy}px) scale(0.98)`;
          floating.style.opacity = '1';
          setTimeout(()=> {
            resolve();
          }, 560);
        });
      }

      function flashElement(el, cls='highlight', duration=520){
        return new Promise((resolve)=>{
          el.classList.add(cls);
          setTimeout(()=>{
            el.classList.remove(cls);
            resolve();
          }, duration);
        });
      }

      // Core operations with animations and optional step mode
      async function insertKeyFlow(key, opts={step:false}){
        if(!key && key !== 0) return;
        const keyStr = normalizeKey(key);
        const {raw, index} = computeHash(keyStr);
        // show compute step
        stepExplain.textContent = `Computing raw hash = ${raw} → index ${index}`;
        // create floating element near input
        const floating = createFloatingNode(keyStr);
        const inputRect = keyInput.getBoundingClientRect();
        floating.style.left = inputRect.left + 'px';
        floating.style.top = inputRect.top + 'px';
        floating.style.opacity = '0.98';
        await new Promise(r=>requestAnimationFrame(r));

        // animate to bucket area (to bucket header center)
        const bucket = bucketsEl.querySelector(`.bucket[data-idx="${index}"]`);
        if(!bucket){
          // Shouldn't happen
          document.body.removeChild(floating);
          return;
        }
        const targetRect = bucket.getBoundingClientRect();
        // If bucket currently has items, that's a collision
        const isCollision = table[index].length > 0;
        if(isCollision) collisions++;

        updateStats();
        await animateToTarget(floating, targetRect);

        // attach node to DOM and state
        table[index].push(keyStr);
        keyCount++;
        // remove floating and re-render that bucket's chain
        floating.style.opacity = '0';
        setTimeout(()=> {
          try{floating.remove();}catch(e){}
        }, 160);
        const chain = bucket.querySelector('.chain');
        const newNode = createNodeElement(keyStr);
        newNode.style.opacity = '0';
        chain.appendChild(newNode);
        // small enter animation
        requestAnimationFrame(()=>{ newNode.style.transition='opacity 260ms ease, transform 200ms ease'; newNode.style.opacity='1'; newNode.style.transform='translateY(-2px)';});
        setTimeout(()=>{ newNode.style.transform='none'; }, 260);

        updateStats();
        // highlight newly inserted
        await flashElement(newNode, 'highlight', 480);
        return {index, isCollision};
      }

      async function searchKeyFlow(key, opts={step:false}){
        if(!key && key !== 0) return {found:false};
        const keyStr = normalizeKey(key);
        const {raw, index} = computeHash(keyStr);
        stepExplain.textContent = `Computed hash = ${raw} → index ${index}`;
        const bucket = bucketsEl.querySelector(`.bucket[data-idx="${index}"]`);
        if(!bucket){
          return {found:false, index};
        }
        // highlight bucket header
        await flashElement(bucket.querySelector('.idx'), 'highlight', 420);
        const nodes = Array.from(bucket.querySelectorAll('.node'));
        for(let i=0;i<nodes.length;i++){
          const n = nodes[i];
          // simulate inspection
          n.classList.add('highlight');
          stepExplain.textContent = `Inspecting node ${i+1}/${nodes.length}: "${n.getAttribute('data-key')}"`;
          await new Promise(r=>setTimeout(r, autoAnimate ? 600 : 120)); // shorter wait in step mode
          if(n.getAttribute('data-key') === keyStr){
            // found
            n.classList.remove('highlight');
            n.classList.add('found');
            stepExplain.textContent = `Found "${keyStr}" at index ${index}, chain position ${i+1}`;
            await new Promise(r=>setTimeout(r, 700));
            n.classList.remove('found');
            return {found:true, index, pos:i};
          }
          n.classList.remove('highlight');
        }
        stepExplain.textContent = `Key "${keyStr}" not found in index ${index}`;
        return {found:false, index};
      }

      async function removeKeyFlow(key){
        if(!key && key !== 0) return;
        const keyStr = normalizeKey(key);
        const {index} = computeHash(keyStr);
        const bucket = bucketsEl.querySelector(`.bucket[data-idx="${index}"]`);
        if(!bucket) return false;
        const nodes = Array.from(bucket.querySelectorAll('.node'));
        for(let i=0;i<nodes.length;i++){
          const n = nodes[i];
          n.classList.add('highlight');
          await new Promise(r=>setTimeout(r, 360));
          if(n.getAttribute('data-key') === keyStr){
            // animate removal
            n.style.transition = 'transform 320ms ease, opacity 260ms linear';
            n.style.transform = 'translateX(-12px) scale(.98)';
            n.style.opacity = '0';
            // remove from state
            const idx = table[index].indexOf(keyStr);
            if(idx !== -1) table[index].splice(idx,1);
            keyCount = Math.max(0, keyCount-1);
            setTimeout(()=>{ n.remove(); updateStats(); }, 360);
            return true;
          }
          n.classList.remove('highlight');
        }
        return false;
      }

      // API exposed to UI
      insertBtn.addEventListener('click', async ()=>{
        const v = keyInput.value.trim();
        if(!v && v !== '0') return;
        insertBtn.disabled = true;
        await insertKeyFlow(v, {step:stepMode.insert});
        insertBtn.disabled = false;
        keyInput.value = '';
        keyInput.focus();
      });

      searchBtn.addEventListener('click', async ()=>{
        const v = keyInput.value.trim();
        if(!v && v !== '0') return;
        searchBtn.disabled = true;
        const res = await searchKeyFlow(v, {step:stepMode.search});
        searchBtn.disabled = false;
      });

      removeBtn.addEventListener('click', async ()=>{
        const v = keyInput.value.trim();
        if(!v && v !== '0') return;
        removeBtn.disabled = true;
        const ok = await removeKeyFlow(v);
        removeBtn.disabled = false;
        if(ok) stepExplain.textContent = `Removed "${v}"`;
        else stepExplain.textContent = `Key "${v}" not found to remove.`;
      });

      clearBtn.addEventListener('click', ()=>{
        table = Array.from({length:tableSize},()=>[]);
        keyCount = 0;
        collisions = 0;
        renderTable();
        stepExplain.textContent = 'Cleared table.';
      });

      // Rehash: optionally animate reinsertions
      rehashBtn.addEventListener('click', async ()=>{
        rehashBtn.disabled = true;
        const newSize = parseInt(sizeRange.value,10);
        const oldItems = [];
        for(let i=0;i<table.length;i++){
          for(const k of table[i]) oldItems.push(k);
        }
        tableSize = newSize;
        setHashBadge();
        table = Array.from({length:tableSize},()=>[]);
        keyCount = 0;
        collisions = 0;
        renderTable();
        // reinsert all keys (animated sequentially)
        for(const k of oldItems){
          await insertKeyFlow(k);
        }
        rehashBtn.disabled = false;
        stepExplain.textContent = `Rehashed ${oldItems.length} keys into ${tableSize} buckets.`;
      });

      // Size slider
      sizeRange.addEventListener('input', ()=>{
        sizeLabel.textContent = sizeRange.value;
        statSize.textContent = sizeRange.value;
      });

      // Hash select
      hashSelect.addEventListener('change', ()=>{
        setHashBadge();
      });

      // Step/Auto toggles
      stepInsertBtn.addEventListener('click', ()=>{ stepMode.insert = !stepMode.insert; stepInsertBtn.classList.toggle('ghost'); stepInsertBtn.textContent = stepMode.insert ? 'Insert (step)' : 'Insert (step)'; stepExplain.textContent = stepMode.insert ? 'Step mode enabled for insert.' : 'Step mode disabled.'; });
      stepSearchBtn.addEventListener('click', ()=>{ stepMode.search = !stepMode.search; stepSearchBtn.classList.toggle('ghost'); stepExplain.textContent = stepMode.search ? 'Step mode enabled for search.' : 'Step mode disabled.'; });
      autoBtn.addEventListener('click', ()=>{ autoAnimate = !autoAnimate; autoBtn.textContent = autoAnimate ? 'Auto animations' : 'No-auto'; autoBtn.classList.toggle('ghost'); });

      // Demo
      demoBtn.addEventListener('click', async ()=>{
        const samples = ['apple','banana','apricot','grape','pear','apple','42','42','zebra'];
        demoBtn.disabled = true;
        for(let s of samples){
          await insertKeyFlow(s);
        }
        demoBtn.disabled = false;
        stepExplain.textContent = 'Demo complete.';
      });

      // Collapse plan area
      collapseBtn.addEventListener('click', ()=>{
        planEl.style.display = (planEl.style.display === 'none') ? 'block' : 'none';
        collapseBtn.textContent = planEl.style.display === 'none' ? 'Show Plan' : 'Hide Plan';
      });

      // Keyboard: Enter to insert
      keyInput.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){
          insertBtn.click();
        }
      });

      // Simple drag-n-drop: allow dragging existing nodes into input to prefill (improves interactivity)
      bucketsEl.addEventListener('click', (e)=>{
        const node = e.target.closest('.node');
        if(node){
          const k = node.getAttribute('data-key');
          keyInput.value = k;
          keyInput.focus();
        }
      });

      // Initial render
      setHashBadge();
      renderTable();

      // Ensure accessibility and responsiveness: handle window resize
      window.addEventListener('resize', ()=>{/* no-op but keeps layout fluid */});

      // Expose some debug on window (not necessary)
      window._hashviz = {
        table, computeHash
      };
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Hash Table — Separate Chaining (Visualizer)",
  "description": "Finite state machine modelling the interactive behaviors of the hash table visualizer (insertion, search, removal, rehash, demo, UI toggles and animation steps).",
  "states": [
    {
      "name": "idle",
      "onEnter": "enableControls; updateStats; setHashBadge",
      "onExit": "none",
      "on": {
        "CLICK_INSERT": "inserting",
        "KEY_ENTER": "inserting",
        "CLICK_SEARCH": "searching",
        "CLICK_REMOVE": "removing",
        "CLICK_CLEAR": "clearing",
        "CLICK_REHASH": "rehashing",
        "CLICK_DEMO": "demoing",
        "SLIDER_INPUT": "idle",
        "CHANGE_HASH_FN": "idle",
        "CLICK_STEP_INSERT": "idle",
        "CLICK_STEP_SEARCH": "idle",
        "CLICK_AUTO_TOGGLE": "idle",
        "CLICK_COLLAPSE": "idle",
        "NODE_CLICKED": "idle",
        "WINDOW_RESIZE": "idle"
      }
    },
    {
      "name": "inserting",
      "onEnter": "disableControls; computeHash; createFloatingNode; setStepExplain('Computing hash...')",
      "onExit": "enableControls; updateStats; setStepExplain('')",
      "on": {
        "ANIMATION_START": "inserting",
        "INSERT_ANIMATION_DONE": "attach_and_finalize_insert",
        "INSERT_DONE": "idle",
        "INSERT_ERROR": "idle",
        "CLICK_INSERT": "inserting",
        "CLICK_SEARCH": "inserting",
        "CLICK_REMOVE": "inserting",
        "CLICK_REHASH": "inserting",
        "CLICK_DEMO": "inserting",
        "CLICK_COLLAPSE": "inserting",
        "SLIDER_INPUT": "inserting",
        "CHANGE_HASH_FN": "inserting"
      }
    },
    {
      "name": "attach_and_finalize_insert",
      "onEnter": "attachNodeToChain; incrementKeyCount; ifCollisionIncrementCollisions; animateNewNodeEntry; flashNewNode; setStepExplain('Inserted key')",
      "onExit": "none",
      "on": {
        "FLASH_DONE": "inserting_finalize",
        "ATTACH_DONE": "inserting_finalize",
        "INSERT_DONE": "idle"
      }
    },
    {
      "name": "inserting_finalize",
      "onEnter": "cleanupFloatingNode; updateStats; setStepExplain('')",
      "onExit": "none",
      "on": {
        "OPERATION_FINISHED": "idle",
        "DEFAULT_TIMEOUT": "idle"
      }
    },
    {
      "name": "searching",
      "onEnter": "disableControls; computeHash; flashBucketHeader; setStepExplain('Computing hash...')",
      "onExit": "enableControls; setStepExplain('')",
      "on": {
        "FLASH_BUCKET_DONE": "search_traversing",
        "SEARCH_TRAVERSE_NEXT": "search_traversing",
        "SEARCH_FOUND": "search_final_found",
        "SEARCH_NOT_FOUND": "search_final_not_found",
        "CLICK_INSERT": "searching",
        "CLICK_SEARCH": "searching",
        "CLICK_REMOVE": "searching",
        "CLICK_REHASH": "searching",
        "CLICK_DEMO": "searching",
        "CLICK_COLLAPSE": "searching"
      }
    },
    {
      "name": "search_traversing",
      "onEnter": "traverseChainStepwise (highlight nodes sequentially; obey autoAnimate/stepMode); setStepExplain('Inspecting nodes...')",
      "onExit": "clearHighlights",
      "on": {
        "NODE_INSPECTED_MATCH": "search_final_found",
        "NODE_INSPECTED_NO_MATCH_CONTINUE": "search_traversing",
        "CHAIN_END": "search_final_not_found",
        "SEARCH_INTERRUPTED": "idle"
      }
    },
    {
      "name": "search_final_found",
      "onEnter": "markNodeFound; flashFound; setStepExplain('Found key.');",
      "onExit": "clearFoundMark",
      "on": {
        "FOUND_ANIM_DONE": "idle",
        "OPERATION_FINISHED": "idle"
      }
    },
    {
      "name": "search_final_not_found",
      "onEnter": "setStepExplain('Key not found');",
      "onExit": "none",
      "on": {
        "OPERATION_FINISHED": "idle",
        "DEFAULT_TIMEOUT": "idle"
      }
    },
    {
      "name": "removing",
      "onEnter": "disableControls; computeHash; setStepExplain('Computing hash...')",
      "onExit": "enableControls; setStepExplain('')",
      "on": {
        "REMOVE_TRAVERSE_NEXT": "removing",
        "NODE_MATCHED_FOR_REMOVE": "removing_animate_remove",
        "REMOVE_NOT_FOUND": "remove_final_not_found",
        "CLICK_COLLAPSE": "removing"
      }
    },
    {
      "name": "removing_animate_remove",
      "onEnter": "highlightNode; animateRemoval; removeFromState; decrementKeyCount; updateStats; setStepExplain('Removed key')",
      "onExit": "none",
      "on": {
        "REMOVE_ANIMATION_DONE": "idle",
        "OPERATION_FINISHED": "idle"
      }
    },
    {
      "name": "remove_final_not_found",
      "onEnter": "setStepExplain('Key not found to remove');",
      "onExit": "none",
      "on": {
        "OPERATION_FINISHED": "idle"
      }
    },
    {
      "name": "clearing",
      "onEnter": "disableControls; clearTable; resetStats; renderTable; setStepExplain('Cleared table.')",
      "onExit": "enableControls",
      "on": {
        "OPERATION_FINISHED": "idle",
        "DEFAULT_TIMEOUT": "idle"
      }
    },
    {
      "name": "rehashing",
      "onEnter": "disableControls; collectAllKeys; setTableSizeFromSlider; setHashBadge; clearTableAndRender; setStepExplain('Rehashing...')",
      "onExit": "enableControls; setStepExplain('')",
      "on": {
        "REHASH_REINSERT_NEXT": "rehashing_reinsert_loop",
        "REHASH_COMPLETE": "idle",
        "CLICK_COLLAPSE": "rehashing"
      }
    },
    {
      "name": "rehashing_reinsert_loop",
      "onEnter": "sequentially call insertKeyFlow for each old key (animated); updateStats per insert; setStepExplain('Reinserting keys...')",
      "onExit": "none",
      "on": {
        "REHASH_INSERT_STEP_DONE": "rehashing_reinsert_loop",
        "REHASH_ALL_DONE": "rehashing",
        "REHASH_COMPLETE": "idle"
      }
    },
    {
      "name": "demoing",
      "onEnter": "disableControls; setStepExplain('Demo: Inserting sample keys...'); sequentially insert sample keys (await insertKeyFlow for each)",
      "onExit": "enableControls; setStepExplain('')",
      "on": {
        "DEMO_INSERT_STEP_DONE": "demoing",
        "DEMO_COMPLETE": "idle",
        "CLICK_COLLAPSE": "demoing"
      }
    }
  ],
  "events": [
    "CLICK_INSERT",
    "KEY_ENTER",
    "CLICK_SEARCH",
    "CLICK_REMOVE",
    "CLICK_CLEAR",
    "CLICK_REHASH",
    "CLICK_DEMO",
    "SLIDER_INPUT",
    "CHANGE_HASH_FN",
    "CLICK_STEP_INSERT",
    "CLICK_STEP_SEARCH",
    "CLICK_AUTO_TOGGLE",
    "CLICK_COLLAPSE",
    "NODE_CLICKED",
    "WINDOW_RESIZE",
    "ANIMATION_START",
    "INSERT_ANIMATION_DONE",
    "ATTACH_DONE",
    "FLASH_DONE",
    "INSERT_DONE",
    "INSERT_ERROR",
    "FLASH_BUCKET_DONE",
    "SEARCH_TRAVERSE_NEXT",
    "NODE_INSPECTED_MATCH",
    "NODE_INSPECTED_NO_MATCH_CONTINUE",
    "CHAIN_END",
    "SEARCH_FOUND",
    "SEARCH_NOT_FOUND",
    "FOUND_ANIM_DONE",
    "REMOVE_TRAVERSE_NEXT",
    "NODE_MATCHED_FOR_REMOVE",
    "REMOVE_ANIMATION_DONE",
    "REMOVE_NOT_FOUND",
    "REHASH_REINSERT_NEXT",
    "REHASH_INSERT_STEP_DONE",
    "REHASH_ALL_DONE",
    "REHASH_COMPLETE",
    "DEMO_INSERT_STEP_DONE",
    "DEMO_COMPLETE",
    "OPERATION_FINISHED",
    "DEFAULT_TIMEOUT"
  ],
  "notes": "High-level FSM. Many UI flags (autoAnimate, stepMode.insert/search) are orthogonal to main states and modify timing/pauses but do not create new top-level states. Each busy state disables primary controls onEnter and re-enables them onExit. Insert/search/remove/rehash/demo flows are sequential and await animations; while busy the UI ignores additional action events (represented here by transitions from busy states back to themselves). onEnter/onExit action names correspond to code-level behaviors: computeHash (computeHash), createFloatingNode (createFloatingNode + position), animateToBucket (animateToTarget), attachNodeToChain (DOM append & state push), incrementKeyCount / decrementKeyCount, ifCollisionIncrementCollisions (increment collisions when bucket non-empty), flashNewNode/flashBucketHeader/flashFound (flashElement), traverseChainStepwise (loop over nodes with highlights), animateRemoval (removal transform/opacity), collectAllKeys (gather old items before rehash), setTableSizeFromSlider (read slider), clearTableAndRender (reset table & renderTable). Events like INSERT_DONE / SEARCH_FOUND are emitted by the animation/flow when complete. The plan/collapse interaction is modelled as CLICK_COLLAPSE events which are handled in-state (toggle DOM visibility) without changing the primary operational state in this FSM representation."
}
  </script>
</body>
</html>