<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Hash Map Demo</title>
  <style>
    :root{
      --safe: 24px;
      --gap: 16px;
      --bg: #0f1720;
      --panel: #071226;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --success: #16a34a;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.03);
      --node-bg: linear-gradient(180deg,#0ea5a4 0%, #0284c7 100%);
      --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    * { box-sizing: border-box; }
    html,body { height: 100%; }
    body{
      margin:0;
      padding: var(--safe);
      font-family: var(--font-sans);
      background: radial-gradient(1200px 600px at 10% 10%, rgba(6,182,212,0.06), transparent),
                  radial-gradient(900px 450px at 90% 90%, rgba(96,165,250,0.03), transparent),
                  var(--bg);
      color: #e6eef6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      min-height:100vh;
    }
    header{
      display:flex;
      align-items:flex-start;
      gap:var(--gap);
      margin-bottom: var(--gap);
    }
    h1{
      font-size:20px;
      margin:0;
      line-height:1.1;
    }
    .meta {
      color:var(--muted);
      font-size:13px;
      margin-top:6px;
    }

    /* Layout */
    .container {
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: var(--gap);
      align-items:start;
    }
    @media (max-width:920px){
      .container { grid-template-columns: 1fr; }
      header { flex-direction:column; align-items:flex-start; }
    }

    /* Left panel: controls & explanation */
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      padding: var(--gap);
      border-radius: 10px;
      min-height: 240px;
    }
    .section-title { font-weight:600; margin:0 0 8px 0; }
    .small { font-size:13px; color:var(--muted); line-height:1.4; }
    label{ display:block; font-size:13px; margin-bottom:6px; color:#dbeafe; }
    .controls { display:flex; gap:var(--gap); flex-wrap:wrap; align-items:center; margin-top:12px; }
    input[type="text"], input[type="number"]{
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.02);
      color:inherit;
      min-width:140px;
    }
    button {
      padding:10px 14px;
      background: linear-gradient(180deg,var(--accent), #0ea5b5);
      border: none;
      color: #022; 
      font-weight:600;
      border-radius:8px;
      cursor:pointer;
      transition:transform .12s ease, box-shadow .12s ease;
    }
    button.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
    }
    button:active{ transform:translateY(1px); }
    .row { display:flex; gap:12px; align-items:center; }

    /* Right panel: visualization */
    .viz {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.0));
      border-radius:10px;
      padding:var(--gap);
      min-height:420px;
      border:1px solid rgba(255,255,255,0.04);
      position:relative;
      overflow:hidden;
    }
    .viz-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:var(--gap);
      margin-bottom:var(--gap);
    }
    .controls-inline { display:flex; gap:8px; align-items:center; }

    /* buckets */
    .buckets {
      display:flex;
      gap:18px;
      flex-wrap:wrap;
      align-items:flex-start;
      padding:10px;
      border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.015), transparent);
      min-height:220px;
      position:relative;
    }
    .bucket {
      width:86px;
      min-height:140px;
      border-radius:8px;
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.03);
      padding:8px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      position:relative;
    }
    .bucket .idx {
      font-size:12px;
      color:var(--muted);
      background: rgba(255,255,255,0.02);
      padding:4px 8px;
      border-radius:6px;
    }
    .chain {
      width:100%;
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:6px;
      align-items:center;
      min-height:60px;
    }

    /* node */
    .node {
      background: var(--node-bg);
      color: #04111a;
      padding:8px 10px;
      border-radius:8px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      display:inline-flex;
      gap:8px;
      align-items:center;
      justify-content:center;
      min-width:66px;
      font-weight:700;
      transition:transform .35s cubic-bezier(.2,.9,.2,1), opacity .25s linear;
      cursor:default;
    }
    .node .k { font-size:12px; color:#052; opacity:0.85; }
    .node .v { font-size:12px; color:#052; opacity:0.65; font-weight:600; }

    /* moving clone for animation */
    .floating {
      position:absolute;
      pointer-events:none;
      z-index:40;
      will-change:transform, opacity;
      transition: transform 600ms cubic-bezier(.2,.9,.2,1), opacity 180ms linear;
    }

    /* traversal highlight */
    .highlight {
      box-shadow: 0 0 0 3px rgba(6,182,212,0.12), 0 8px 24px rgba(6,182,212,0.12);
      transform: translateY(-6px) scale(1.02);
    }
    .found {
      box-shadow: 0 0 0 4px rgba(22,163,74,0.12), 0 10px 30px rgba(16,185,129,0.06);
    }
    .notfound {
      animation: shake .5s ease;
    }
    @keyframes shake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-8px); }
      50% { transform: translateX(8px); }
      75% { transform: translateX(-6px); }
      100% { transform: translateX(0); }
    }

    /* hash computation strip */
    .hash-strip {
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:13px;
    }
    .charbox {
      width:34px;
      height:34px;
      border-radius:6px;
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      display:flex;
      justify-content:center;
      align-items:center;
      font-weight:700;
    }
    .charbox .ord{
      font-size:11px;
      color:var(--muted);
      display:block;
      margin-top:4px;
      font-weight:600;
    }
    .charbox.active {
      background: linear-gradient(180deg, rgba(6,182,212,0.12), rgba(6,182,212,0.06));
      border-color: rgba(6,182,212,0.25);
      transform: translateY(-6px);
      box-shadow: 0 10px 30px rgba(6,182,212,0.08);
    }

    .status {
      font-size:13px;
      color:var(--muted);
      margin-top:12px;
      min-height:18px;
    }

    /* small helper */
    .muted { color:var(--muted); font-size:13px; }
    footer { margin-top: var(--gap); color:var(--muted); font-size:13px; }

    /* ensure spacing at least 16px between interactive elements in controls area */
    .controls > * { margin:0; }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Hash Map — interactive visualization</h1>
      <div class="meta">Visual, step-by-step exploration of how hashing maps keys to buckets and how collisions are handled (separate chaining).</div>
    </div>
  </header>

  <div class="container" role="main">
    <!-- Left: Plan + Controls -->
    <aside class="panel" aria-labelledby="plan-title">
      <h2 id="plan-title" class="section-title">Concept & Learning Plan</h2>
      <p class="small"><strong>Concept Title:</strong> Hash Map (array of buckets + chaining)</p>
      <p class="small"><strong>Learning Objective:</strong> After interacting, you will understand how a hash function converts keys to bucket indices, how collisions accumulate in chains, and how insert/search/delete operations traverse and modify chains.</p>

      <h3 class="section-title" style="margin-top:12px;">Interaction Design</h3>
      <p class="small">
        - Type a key (string) and a value, then Insert. The module animates:
        a) the per-character hash calculation (ASCII sums), b) modulo reduction to a bucket index, and c) movement of the node into the target bucket's chain.
        </p>
      <p class="small">
        - Search highlights nodes along the chain one-by-one. Found nodes are highlighted in green; not found gives a gentle shake.
        - Delete traverses then removes the node with a fade/slide animation and repositions remaining nodes.
        - You can change the bucket count; existing entries will be rehashed and animated to their new buckets.
      </p>

      <h3 class="section-title" style="margin-top:12px;">Layout Description</h3>
      <p class="small">
        - Safe area: 24px on all sides (page padding). Minimum spacing between interactive elements is 16px (CSS gaps and margins).
        - Left column contains descriptive text and controls (keyboard-accessible inputs and buttons).
        - Right column is the visualization canvas with a top control strip and the bucket area beneath. The buckets are shown left-to-right and wrap on small screens.
        - Colors, contrasts, and focusable controls are designed for accessibility. Layout is responsive: the grid becomes a stacked column under 920px width.
      </p>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0;">

      <div>
        <label for="bucketCount">Buckets (array size): <span id="bucket-count-display">7</span></label>
        <input id="bucketCount" type="range" min="3" max="13" value="7" aria-label="Bucket count slider" />
      </div>

      <div style="margin-top:12px;">
        <label for="keyInput">Key</label>
        <input id="keyInput" type="text" placeholder="e.g. apple" aria-label="Key input" />
        <label for="valueInput" style="margin-top:8px;">Value</label>
        <input id="valueInput" type="text" placeholder="e.g. 42" aria-label="Value input" />
      </div>

      <div class="controls" style="margin-top:12px;">
        <button id="insertBtn">Insert</button>
        <button id="searchBtn" class="secondary">Search</button>
        <button id="deleteBtn" class="secondary">Delete</button>
        <button id="clearBtn" class="secondary">Clear</button>
      </div>

      <div class="status" id="status" aria-live="polite"></div>
    </aside>

    <!-- Right: Visualization -->
    <section class="viz" aria-label="Hash map visualization">
      <div class="viz-top">
        <div class="controls-inline">
          <div style="font-size:13px; color:var(--muted);">Buckets:</div>
          <div id="bucketSummary" class="muted" style="min-width:120px;">0 entries</div>
        </div>

        <div style="display:flex;gap:12px;align-items:center;">
          <div class="hash-strip" id="hashStrip" aria-hidden="true" title="Displays per-character ASCII and running sum during hashing"></div>
        </div>
      </div>

      <div class="buckets" id="buckets" role="list" aria-label="Buckets area">
        <!-- buckets inserted by JS -->
      </div>

      <footer style="opacity:0.9;">
        Tip: Try keys that collide (e.g., 'ab' and 'ba' often collide with simple hash). Use the bucket slider to see how bucket count affects collisions.
      </footer>
    </section>
  </div>

  <script>
    (function(){
      // Configuration & state
      const body = document.body;
      const bucketSlider = document.getElementById('bucketCount');
      const bucketCountDisplay = document.getElementById('bucket-count-display');
      const bucketsEl = document.getElementById('buckets');
      const hashStrip = document.getElementById('hashStrip');
      const insertBtn = document.getElementById('insertBtn');
      const searchBtn = document.getElementById('searchBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const clearBtn = document.getElementById('clearBtn');
      const keyInput = document.getElementById('keyInput');
      const valueInput = document.getElementById('valueInput');
      const status = document.getElementById('status');
      const bucketSummary = document.getElementById('bucketSummary');

      let bucketCount = Number(bucketSlider.value);
      let map = []; // array of arrays: {key, value, id}
      let uniqueId = 1;
      let animLock = false;

      // Initialize
      function init() {
        bucketCountDisplay.textContent = bucketCount;
        createBuckets(bucketCount);
        map = Array.from({length: bucketCount}, () => []);
        updateSummary();
      }

      function createBuckets(n) {
        bucketsEl.innerHTML = '';
        for (let i=0;i<n;i++){
          const b = document.createElement('div');
          b.className = 'bucket';
          b.dataset.idx = i;
          b.setAttribute('role','listitem');
          b.innerHTML = '<div class="idx">index ' + i + '</div><div class="chain" aria-label="chain"></div>';
          bucketsEl.appendChild(b);
        }
      }

      // Hash function: sum of char codes mod bucketCount (simple: pedagogical)
      function computeHash(key){
        let sum = 0;
        for (let i=0;i<key.length;i++){
          sum += key.charCodeAt(i);
        }
        return {sum, idx: (key.length ? (sum % bucketCount) : 0)};
      }

      // Helpers for UI
      function setStatus(msg, mode='info'){
        status.textContent = msg || '';
        status.style.color = (mode === 'error' ? 'var(--danger)' : mode === 'success' ? 'var(--success)' : 'var(--muted)');
      }
      function updateSummary(){
        const count = map.reduce((s,arr)=>s+arr.length,0);
        bucketSummary.textContent = count + ' entr' + (count===1? 'y':'ies');
      }

      // Bucket and node element utilities
      function getBucketEl(idx){ return bucketsEl.querySelector('.bucket[data-idx="'+idx+'"]'); }
      function getChainEl(idx){ const b=getBucketEl(idx); return b ? b.querySelector('.chain') : null; }

      function renderChainStatic(idx){
        const chain = getChainEl(idx);
        chain.innerHTML = '';
        const entries = map[idx];
        entries.forEach(item => {
          const n = createNodeEl(item);
          chain.appendChild(n);
        });
      }

      function createNodeEl(item){
        const n = document.createElement('div');
        n.className = 'node';
        n.dataset.id = item.id;
        n.innerHTML = '<span class="k">'+escapeHtml(item.key)+'</span>';
        const val = document.createElement('span');
        val.className = 'v';
        val.textContent = item.value;
        n.appendChild(val);
        return n;
      }

      // Simple escape
      function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

      // Animation: hash computation
      function animateHashComputation(key){
        return new Promise(resolve => {
          hashStrip.innerHTML = '';
          if (!key){
            const empty = document.createElement('div');
            empty.className = 'muted';
            empty.textContent = '(empty key -> hash 0)';
            hashStrip.appendChild(empty);
            setTimeout(()=>resolve({sum:0, idx:0}), 400);
            return;
          }
          // Build char boxes
          const chars = key.split('');
          const boxes = chars.map((ch, i) => {
            const box = document.createElement('div');
            box.className = 'charbox';
            box.title = 'char: ' + ch;
            box.innerHTML = '<div style="font-weight:700;">'+escapeHtml(ch)+'</div><div class="ord">'+ch.charCodeAt(0)+'</div>';
            hashStrip.appendChild(box);
            return box;
          });

          const sumBox = document.createElement('div');
          sumBox.className = 'muted';
          sumBox.style.marginLeft = '8px';
          sumBox.style.minWidth = '120px';
          sumBox.textContent = 'running sum: 0';
          hashStrip.appendChild(sumBox);

          let sum = 0;
          let i = 0;
          function step(){
            if (i >= chars.length){
              // final modulo
              const idx = sum % bucketCount;
              const res = document.createElement('div');
              res.className = 'muted';
              res.style.marginLeft = '8px';
              res.innerHTML = 'sum = ' + sum + ' → index = ' + idx;
              hashStrip.appendChild(res);
              setTimeout(()=>resolve({sum, idx}), 600);
              return;
            }
            const c = chars[i];
            const box = boxes[i];
            box.classList.add('active');
            // animate for 420ms
            setTimeout(()=>{
              sum += c.charCodeAt(0);
              sumBox.textContent = 'running sum: ' + sum;
              box.classList.remove('active');
              i++;
              setTimeout(step, 160);
            }, 420);
          }
          setTimeout(step, 120);
        });
      }

      // Create a moving floating clone (from control area) to animate into bucket
      function animateInsertToBucket(item, targetIdx){
        return new Promise(resolve => {
          const startEl = insertBtn;
          const startRect = startEl.getBoundingClientRect();
          const targetBucket = getBucketEl(targetIdx);
          const chainEl = getChainEl(targetIdx);
          const endRect = chainEl.getBoundingClientRect();
          // create clone
          const clone = createNodeEl(item);
          clone.classList.add('floating');
          document.body.appendChild(clone);
          // set start position
          const startX = startRect.left + startRect.width/2;
          const startY = startRect.top + startRect.height/2;
          const endX = endRect.left + endRect.width/2;
          const endY = endRect.top + 10 + (map[targetIdx].length * 44); // stack offset
          clone.style.left = (startX - 40) + 'px';
          clone.style.top = (startY - 24) + 'px';
          clone.style.opacity = '1';
          clone.style.transform = 'translate3d(0,0,0) scale(1)';
          // delay then move
          requestAnimationFrame(()=> {
            // slight upward lift
            clone.style.transition = 'transform 620ms cubic-bezier(.2,.9,.2,1), left 620ms ease, top 620ms ease, opacity 220ms linear';
            clone.style.left = (endX - 40) + 'px';
            clone.style.top = (endY - 20) + 'px';
            clone.style.transform = 'translate3d(0,0,0) scale(1)';
          });
          setTimeout(()=>{
            // append final static node into chain
            const node = createNodeEl(item);
            chainEl.appendChild(node);
            // fade out clone
            clone.style.opacity = '0';
            setTimeout(()=>{ clone.remove(); resolve(); }, 240);
          }, 700);
        });
      }

      // Insert logic: animate hash, then add to data & animate move
      async function handleInsert(){
        if (animLock) return;
        const key = keyInput.value.trim();
        const value = valueInput.value.trim();
        if (!key){
          setStatus('Enter a non-empty key to insert.', 'error'); return;
        }
        animLock = true;
        setStatus('Computing hash...');
        try {
          const {sum, idx} = await animateHashComputation(key);
          setStatus('Inserting into bucket ' + idx + ' (sum ' + sum + ')...');
          // check duplicate key in chain -> update
          const chain = map[idx];
          const existing = chain.find(it=>it.key===key);
          if (existing){
            existing.value = value;
            // update UI: find its node element and flash
            renderChainStatic(idx);
            const nodeEl = getChainEl(idx).querySelector('.node[data-id="'+existing.id+'"]');
            if (nodeEl){
              nodeEl.classList.add('highlight');
              setTimeout(()=>nodeEl.classList.remove('highlight'), 900);
            }
            setStatus('Updated existing key in bucket ' + idx, 'success');
            updateSummary();
            animLock = false;
            return;
          }
          const newItem = {key, value, id: uniqueId++};
          // add to data
          map[idx].push(newItem);
          // animate movement
          await animateInsertToBucket(newItem, idx);
          setStatus('Inserted key "' + key + '" in bucket ' + idx, 'success');
          updateSummary();
        } catch(e){
          console.error(e);
          setStatus('Error during insert.', 'error');
        } finally {
          animLock = false;
        }
      }

      // Search: animate traversal in chain
      async function handleSearch(){
        if (animLock) return;
        const key = keyInput.value.trim();
        if (!key){
          setStatus('Enter a key to search.', 'error'); return;
        }
        animLock = true;
        setStatus('Computing hash...');
        try {
          const {sum, idx} = await animateHashComputation(key);
          setStatus('Searching bucket ' + idx + ' (sum ' + sum + ')...');
          const entries = map[idx];
          if (!entries.length){
            // shake bucket
            const b = getBucketEl(idx);
            b.classList.add('notfound');
            setTimeout(()=>b.classList.remove('notfound'), 700);
            setStatus('Key not found (bucket empty).', 'error');
            animLock = false;
            return;
          }
          // traverse
          const chainEl = getChainEl(idx);
          const nodes = Array.from(chainEl.querySelectorAll('.node'));
          let found = null;
          for (let i=0;i<nodes.length;i++){
            const n = nodes[i];
            n.classList.add('highlight');
            await new Promise(res => setTimeout(res, 520));
            const id = Number(n.dataset.id);
            const item = entries.find(it=>it.id===id);
            if (item && item.key === key){
              found = {node:n, item};
              n.classList.remove('highlight');
              n.classList.add('found');
              setStatus('Found key "' + key + '" → value: ' + item.value, 'success');
              await new Promise(res=>setTimeout(res,700));
              n.classList.remove('found');
              break;
            } else {
              n.classList.remove('highlight');
            }
          }
          if (!found){
            // not found
            const b = getBucketEl(idx);
            b.classList.add('notfound');
            setTimeout(()=>b.classList.remove('notfound'), 700);
            setStatus('Key "'+key+'" not found in bucket ' + idx, 'error');
          }
        } catch(e){
          console.error(e);
          setStatus('Error during search.', 'error');
        } finally {
          animLock = false;
        }
      }

      // Delete: traverse then remove
      async function handleDelete(){
        if (animLock) return;
        const key = keyInput.value.trim();
        if (!key){
          setStatus('Enter a key to delete.', 'error'); return;
        }
        animLock = true;
        setStatus('Computing hash...');
        try {
          const {sum, idx} = await animateHashComputation(key);
          setStatus('Searching bucket ' + idx + ' for deletion...');
          const entries = map[idx];
          const chainEl = getChainEl(idx);
          const nodes = Array.from(chainEl.querySelectorAll('.node'));
          let foundIndex = -1;
          for (let i=0;i<nodes.length;i++){
            const n = nodes[i];
            n.classList.add('highlight');
            await new Promise(res => setTimeout(res, 520));
            const id = Number(n.dataset.id);
            const itemIndex = entries.findIndex(it=>it.id===id);
            if (itemIndex !== -1 && entries[itemIndex].key === key){
              foundIndex = itemIndex;
              // animate removal
              n.classList.remove('highlight');
              n.style.transition = 'transform 360ms ease, opacity 260ms linear';
              n.style.transform = 'translateY(-16px) scale(.98)';
              n.style.opacity = '0';
              await new Promise(res => setTimeout(res, 360));
              // remove from DOM & data
              entries.splice(itemIndex,1);
              renderChainStatic(idx);
              setStatus('Deleted key "'+key+'" from bucket ' + idx, 'success');
              updateSummary();
              break;
            } else {
              n.classList.remove('highlight');
            }
          }
          if (foundIndex === -1){
            const b = getBucketEl(idx);
            b.classList.add('notfound');
            setTimeout(()=>b.classList.remove('notfound'), 700);
            setStatus('Key "'+key+'" not found for deletion.', 'error');
          }
        } catch(e){
          console.error(e);
          setStatus('Error during delete.', 'error');
        } finally {
          animLock = false;
        }
      }

      // Clear all
      function handleClear(){
        if (animLock) return;
        map = Array.from({length: bucketCount}, ()=>[]);
        // animate fade-out by clearing chains
        const chains = bucketsEl.querySelectorAll('.chain');
        chains.forEach(c=>c.innerHTML='');
        setStatus('Cleared all entries.', 'success');
        updateSummary();
      }

      // Handle changing bucket count -> rehash all entries (animate movement)
      async function handleBucketCountChange(newCount){
        if (animLock) return;
        if (newCount === bucketCount) return;
        animLock = true;
        setStatus('Resizing and rehashing all entries...');
        // collect old items
        const oldItems = [];
        for (let i=0;i<map.length;i++){
          for (const it of map[i]) oldItems.push(it);
        }
        // reset structure & UI
        bucketCount = newCount;
        bucketCountDisplay.textContent = bucketCount;
        createBuckets(bucketCount);
        const newMap = Array.from({length: bucketCount}, ()=>[]);
        const movedPromises = [];
        // rehash items one-by-one with animated move from old position
        for (const it of oldItems){
          const {sum, idx} = computeHash(it.key);
          newMap[idx].push(it);
          // For animation, simulate moving element from center to new bucket
          // create floating clone from center of page
          movedPromises.push((async ()=>{
            // create clone
            const clone = createNodeEl(it);
            clone.classList.add('floating');
            document.body.appendChild(clone);
            // start at center
            const containerRect = bucketsEl.getBoundingClientRect();
            const startX = containerRect.left + containerRect.width/2;
            const startY = containerRect.top + 20;
            const chainEl = (function(){ const b = getBucketEl(idx); return b ? b.querySelector('.chain') : null; })();
            const endRect = chainEl ? chainEl.getBoundingClientRect() : {left:startX, top:startY};
            clone.style.left = (startX - 40) + 'px';
            clone.style.top = (startY - 24) + 'px';
            clone.style.opacity = '1';
            requestAnimationFrame(()=> {
              clone.style.transition = 'transform 520ms cubic-bezier(.2,.9,.2,1), left 520ms ease, top 520ms ease, opacity 220ms linear';
              clone.style.left = (endRect.left + 10) + 'px';
              clone.style.top = (endRect.top + 6 + (newMap[idx].length-1)*44) + 'px';
            });
            await new Promise(res => setTimeout(res, 600));
            // append static
            if (chainEl) chainEl.appendChild(createNodeEl(it));
            clone.remove();
          })());
        }

        // wait for all moved animations to complete
        try {
          await Promise.all(movedPromises);
          // set new map
          map = newMap;
          updateSummary();
          setStatus('Rehash complete. New bucket count: ' + bucketCount, 'success');
        } catch(e){
          console.error(e);
          setStatus('Error during rehash.', 'error');
        } finally {
          animLock = false;
        }
      }

      // Event listeners
      insertBtn.addEventListener('click', handleInsert);
      searchBtn.addEventListener('click', handleSearch);
      deleteBtn.addEventListener('click', handleDelete);
      clearBtn.addEventListener('click', handleClear);

      bucketSlider.addEventListener('input', (e)=>{
        const newCount = Number(e.target.value);
        bucketCountDisplay.textContent = newCount;
      });
      bucketSlider.addEventListener('change', (e)=>{
        const newCount = Number(e.target.value);
        handleBucketCountChange(newCount);
      });

      // keyboard access: Enter to insert
      keyInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') insertBtn.click(); });
      valueInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') insertBtn.click(); });

      // Initialize UI
      init();

      // Accessibility: announce initial guidance
      setTimeout(()=>setStatus('Ready. Insert keys to explore hashing and collisions.'), 600);
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Hash Map Interactive Visualization",
  "description": "Models the interactive states and transitions of the hash map visualization app: inserting, searching, deleting, resizing (rehash), clearing and the animations/visual feedback (hash computation, traversal, move/fade, highlights, bucket shake).",
  "states": [
    {
      "name": "idle",
      "onEnter": "SET_STATUS_READY; RELEASE_ANIM_LOCK",
      "on": {
        "INSERT_CLICK": "hashing_insert",
        "SEARCH_CLICK": "hashing_search",
        "DELETE_CLICK": "hashing_delete",
        "CLEAR_CLICK": "clearing",
        "BUCKET_SLIDER_INPUT": "slider_preview",
        "BUCKET_SLIDER_CHANGE": "resizing_rehashing",
        "ENTER_KEY": "hashing_insert"
      }
    },
    {
      "name": "slider_preview",
      "onEnter": "UPDATE_BUCKET_COUNT_DISPLAY",
      "on": {
        "BUCKET_SLIDER_CHANGE": "resizing_rehashing",
        "NOOP": "idle"
      }
    },
    {
      "name": "hashing_insert",
      "onEnter": "SET_ANIM_LOCK_TRUE; SET_STATUS_COMPUTING_HASH; COMPUTE_HASH_ANIMATION",
      "onExit": "CLEAR_HASH_STRIP",
      "on": {
        "HASH_COMPUTED_DUPLICATE": "updating_existing",
        "HASH_COMPUTED_NEW": "inserting_moving",
        "HASH_COMPUTED_EMPTY_KEY": "validation_error"
      }
    },
    {
      "name": "inserting_moving",
      "onEnter": "ADD_ITEM_TO_DATA; SET_STATUS_INSERTING; ANIMATE_INSERT_TO_BUCKET",
      "on": {
        "INSERT_ANIMATION_DONE": "idle",
        "ANIMATION_ERROR": "idle"
      },
      "onExit": "UPDATE_SUMMARY; SET_STATUS_SUCCESS; RELEASE_ANIM_LOCK"
    },
    {
      "name": "updating_existing",
      "onEnter": "UPDATE_EXISTING_VALUE_IN_DATA; RENDER_CHAIN_STATIC",
      "on": {
        "UPDATE_RENDERED": "idle"
      },
      "onExit": "FLASH_NODE; UPDATE_SUMMARY; SET_STATUS_SUCCESS; RELEASE_ANIM_LOCK"
    },
    {
      "name": "hashing_search",
      "onEnter": "SET_ANIM_LOCK_TRUE; SET_STATUS_COMPUTING_HASH; COMPUTE_HASH_ANIMATION",
      "onExit": "CLEAR_HASH_STRIP",
      "on": {
        "HASH_COMPUTED_BUCKET_EMPTY": "bucket_shake_notfound",
        "HASH_COMPUTED_BUCKET_NONEMPTY": "searching_traversal",
        "HASH_COMPUTED_EMPTY_KEY": "validation_error"
      }
    },
    {
      "name": "searching_traversal",
      "onEnter": "SET_STATUS_SEARCHING; TRAVERSE_CHAIN_ANIMATION",
      "on": {
        "TRAVERSE_NODE_FOUND": "search_found",
        "TRAVERSE_COMPLETE_NOT_FOUND": "bucket_shake_notfound"
      },
      "onExit": "CLEAR_TRAVERSAL_HIGHLIGHTS"
    },
    {
      "name": "search_found",
      "onEnter": "HIGHLIGHT_FOUND_NODE; SET_STATUS_SUCCESS",
      "on": {
        "FOUND_HIGHLIGHT_DONE": "idle"
      },
      "onExit": "REMOVE_FOUND_HIGHLIGHT; RELEASE_ANIM_LOCK"
    },
    {
      "name": "hashing_delete",
      "onEnter": "SET_ANIM_LOCK_TRUE; SET_STATUS_COMPUTING_HASH; COMPUTE_HASH_ANIMATION",
      "onExit": "CLEAR_HASH_STRIP",
      "on": {
        "HASH_COMPUTED_BUCKET_EMPTY": "bucket_shake_notfound",
        "HASH_COMPUTED_BUCKET_NONEMPTY": "deleting_traversal",
        "HASH_COMPUTED_EMPTY_KEY": "validation_error"
      }
    },
    {
      "name": "deleting_traversal",
      "onEnter": "SET_STATUS_SEARCHING_FOR_DELETE; TRAVERSE_CHAIN_ANIMATION",
      "on": {
        "DELETE_NODE_FOUND": "deleting_remove",
        "TRAVERSE_COMPLETE_NOT_FOUND": "bucket_shake_notfound"
      },
      "onExit": "CLEAR_TRAVERSAL_HIGHLIGHTS"
    },
    {
      "name": "deleting_remove",
      "onEnter": "ANIMATE_REMOVE_NODE; REMOVE_FROM_DATA; RENDER_CHAIN_STATIC",
      "on": {
        "DELETE_ANIMATION_DONE": "idle"
      },
      "onExit": "UPDATE_SUMMARY; SET_STATUS_SUCCESS; RELEASE_ANIM_LOCK"
    },
    {
      "name": "bucket_shake_notfound",
      "onEnter": "APPLY_BUCKET_SHAKE_CLASS; SET_STATUS_NOT_FOUND",
      "on": {
        "SHAKE_COMPLETE": "idle"
      },
      "onExit": "REMOVE_BUCKET_SHAKE_CLASS; RELEASE_ANIM_LOCK"
    },
    {
      "name": "validation_error",
      "onEnter": "SET_STATUS_VALIDATION_ERROR",
      "on": {
        "ACK": "idle"
      }
    },
    {
      "name": "resizing_rehashing",
      "onEnter": "SET_ANIM_LOCK_TRUE; SET_STATUS_RESIZING; CREATE_BUCKETS_UI; COMPUTE_REHASH_PLAN; ANIMATE_REHASH_MOVES",
      "on": {
        "REHASH_ANIMATION_DONE": "idle",
        "REHASH_ERROR": "idle"
      },
      "onExit": "COMMIT_NEW_MAP; UPDATE_SUMMARY; SET_STATUS_SUCCESS; RELEASE_ANIM_LOCK"
    },
    {
      "name": "clearing",
      "onEnter": "CLEAR_DATA; CLEAR_UI_CHAINS; SET_STATUS_CLEARED; UPDATE_SUMMARY",
      "on": {
        "CLEARED": "idle"
      }
    }
  ],
  "events": [
    "INSERT_CLICK",
    "SEARCH_CLICK",
    "DELETE_CLICK",
    "CLEAR_CLICK",
    "BUCKET_SLIDER_INPUT",
    "BUCKET_SLIDER_CHANGE",
    "ENTER_KEY",
    "HASH_COMPUTED_DUPLICATE",
    "HASH_COMPUTED_NEW",
    "HASH_COMPUTED_BUCKET_EMPTY",
    "HASH_COMPUTED_BUCKET_NONEMPTY",
    "HASH_COMPUTED_EMPTY_KEY",
    "INSERT_ANIMATION_DONE",
    "UPDATE_RENDERED",
    "TRAVERSE_NODE_FOUND",
    "TRAVERSE_COMPLETE_NOT_FOUND",
    "FOUND_HIGHLIGHT_DONE",
    "DELETE_NODE_FOUND",
    "DELETE_ANIMATION_DONE",
    "SHAKE_COMPLETE",
    "REHASH_ANIMATION_DONE",
    "CLEARED",
    "ANIMATION_ERROR",
    "REHASH_ERROR",
    "NOOP",
    "ACK"
  ],
  "notes": "High-level FSM maps user actions to animated sequences. The implementation uses an animLock (represented by SET_ANIM_LOCK_TRUE/RELEASE_ANIM_LOCK) to prevent concurrent operations. Hash computation is animated and emits HASH_COMPUTED_* events indicating the bucket result and whether the chain contains a duplicate or is empty. Traversal is sequential and produces TRAVERSE_NODE_FOUND or TRAVERSE_COMPLETE_NOT_FOUND. Resizing rehashes all items with animated moves. CLEAR is instantaneous in UI. Visual feedback actions include APPLY_BUCKET_SHAKE_CLASS, HIGHLIGHT/FOUND classes, and flashing updated nodes."
}
  </script>
</body>
</html>