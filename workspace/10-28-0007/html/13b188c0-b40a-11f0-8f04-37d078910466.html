<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Array: Indexing & Insert/Delete (Interactive)</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #6ee7b7;
      --muted: #94a3b8;
      --card: #071226;
      --danger: #fb7185;
    }
    /* Basic layout + safe margins */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071025 0%, #07162b 100%);
      color:#e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      box-sizing:border-box;
      padding: var(--safe-margin);
      min-height:100%;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    header{
      display:flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--gap);
      flex-wrap:wrap;
    }
    .title {
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing: -0.2px;
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    main{
      display:flex;
      gap: var(--gap);
      align-items: flex-start;
      width:100%;
    }

    /* left controls column */
    .controls{
      flex:0 0 340px;
      min-width:240px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      padding:16px;
      border-radius:10px;
    }
    .controls h2{
      font-size:14px;
      margin:0 0 8px 0;
      color:var(--accent);
    }
    label{ font-size:13px; color:var(--muted); display:block; margin-bottom:6px; }
    .row { display:flex; gap:12px; align-items:center; margin-bottom:12px; }
    input[type="text"], input[type="number"]{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      padding:8px 10px;
      border-radius:8px;
      color:inherit;
      outline:none;
      min-width:0;
    }
    input[type="number"]{ width:96px; }
    button{
      cursor:pointer;
      padding:8px 12px;
      background:linear-gradient(180deg,#0ea5a9,#07847f);
      color:#021018;
      border:0;
      border-radius:8px;
      font-weight:600;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }
    button.ghost{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      font-weight:600;
    }
    .small{
      padding:6px 10px;
      font-size:13px;
      border-radius:8px;
    }
    .controls .hint{ font-size:12px; color:var(--muted); margin-top:8px; }

    /* visualization column */
    .visual{
      flex:1 1 0%;
      min-width:0;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:10px;
      padding:16px;
      border: 1px solid rgba(255,255,255,0.03);
    }
    .vis-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: var(--gap);
      margin-bottom:12px;
    }
    .vis-area{
      background: linear-gradient(180deg,#021226 0%, #051120 100%);
      border-radius:10px;
      padding:20px;
      min-height:180px;
      position:relative;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    /* array row */
    .array-row{
      display:flex;
      gap:16px;
      align-items:flex-end;
      flex-wrap:wrap;
      min-height:92px;
      align-content:flex-start;
    }
    .cell{
      width:96px;
      min-width:72px;
      height:64px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      border-radius:10px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:6px;
      box-shadow: 0 6px 18px rgba(1,6,12,0.45);
      transition: box-shadow 250ms ease, transform 250ms ease;
      position:relative;
      user-select:none;
    }
    .cell .value{
      font-weight:700;
      font-size:16px;
      letter-spacing:-0.3px;
    }
    .cell .index{
      font-size:12px;
      color:var(--muted);
    }
    .cell.highlight{
      box-shadow: 0 10px 30px rgba(110,231,183,0.15), 0 6px 18px rgba(2,6,12,0.6);
      transform: translateY(-6px) scale(1.03);
      border-color: rgba(110,231,183,0.35);
    }

    /* small animated badge for operations */
    .op-badge{
      position:absolute;
      right:16px;
      top:16px;
      background:rgba(255,255,255,0.03);
      padding:6px 8px;
      border-radius:8px;
      font-size:12px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.02);
    }

    /* explanation footer */
    .explain{
      margin-top:12px;
      color:var(--muted);
      font-size:13px;
    }

    /* accessibility focus */
    button:focus, input:focus{
      outline:2px solid rgba(110,231,183,0.14);
      outline-offset:2px;
    }

    /* responsive */
    @media (max-width:900px){
      main{ flex-direction:column; }
      .controls{ width:100%; }
    }

    /* subtle animation helpers */
    .fade-out{
      animation: fadeOut 320ms ease forwards;
    }
    @keyframes fadeOut{
      to{ opacity:0; transform: scale(0.98); }
    }
    .pulse{
      animation: pulse 700ms ease;
    }
    @keyframes pulse{
      0%{ box-shadow: 0 10px 30px rgba(110,231,183,0.2); transform: translateY(-4px) scale(1.02); }
      100%{ box-shadow:none; transform:none; }
    }

    /* informational panel */
    .info{
      margin-top:12px;
      background: rgba(255,255,255,0.01);
      padding:12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
      font-size:13px;
      color:var(--muted);
    }

    /* small legend */
    .legend { display:flex; gap:12px; align-items:center; font-size:13px; color:var(--muted); }
    .legend .dot{
      width:12px; height:12px; border-radius:3px;
      background:var(--accent); box-shadow:0 6px 14px rgba(110,231,183,0.08);
    }
    footer{ color:var(--muted); font-size:13px; margin-top:4px; }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Interactive array module">
    <header>
      <div class="title" aria-hidden="false">
        <h1>Array — Indexing & Insert/Delete Visualization</h1>
        <p class="lead">See how inserting and removing elements affects positions (shifts) and indexed access.</p>
      </div>
      <div style="display:flex;gap:12px;align-items:center;">
        <div style="text-align:right;">
          <div style="font-size:12px;color:var(--muted)">Module</div>
          <div style="font-weight:700">Single Concept: Indexed Sequence</div>
        </div>
      </div>
    </header>

    <main>
      <!-- Controls -->
      <section class="controls" aria-labelledby="controls-heading">
        <h2 id="controls-heading">Controls</h2>

        <div style="margin-bottom:8px;">
          <label for="value-input">Value (string or number)</label>
          <input id="value-input" type="text" aria-label="Value to add" placeholder="e.g., 42 or 'apple'">
        </div>

        <div class="row" aria-hidden="false">
          <button id="push-btn" class="small" title="Push to end">Push (end)</button>
          <button id="pop-btn" class="small ghost" title="Remove from end">Pop (end)</button>
        </div>

        <div style="margin-top:8px;">
          <label for="index-input">Index (0-based)</label>
          <div style="display:flex;gap:12px;">
            <input id="index-input" type="number" min="0" aria-label="Index for insert or remove" placeholder="index">
            <button id="insert-btn" class="small" title="Insert at index">Insert</button>
            <button id="remove-btn" class="small ghost" title="Remove at index">Remove</button>
          </div>
          <div class="hint">If index is larger than length, insert will append. Negative indices are clamped to 0.</div>
        </div>

        <hr style="border:none;height:1px;margin:12px 0;background:rgba(255,255,255,0.02)">

        <div style="display:flex;gap:12px;flex-wrap:wrap;">
          <button id="access-btn" class="small">Access by Index</button>
          <button id="random-btn" class="small ghost">Randomize (demo)</button>
          <button id="clear-btn" class="small ghost">Clear</button>
        </div>

        <div class="info" role="note" aria-live="polite">
          <strong>What you will see:</strong>
          <div style="margin-top:8px;">
            - Push/Pop change the end without shifting neighbors.<br>
            - Insert/Delete at a middle index animates a right/left shift of subsequent elements.
          </div>
        </div>

        <div style="margin-top:12px;font-size:13px;color:var(--muted);">
          Accessibility: All controls are keyboard-focusable. Use Tab and Enter/Space.
        </div>
      </section>

      <!-- Visualization -->
      <section class="visual" aria-labelledby="visual-heading">
        <div class="vis-header">
          <div>
            <h2 id="visual-heading" style="margin:0;font-size:14px;color:var(--accent)">Array Visualization</h2>
            <div style="font-size:13px;color:var(--muted);margin-top:6px;">
              Boxes show value and index. Watch shifting animations when inserting/removing.
            </div>
          </div>
          <div style="display:flex;gap:12px;align-items:center;">
            <div class="legend" aria-hidden="true"><div class="dot"></div><div>Indexed cell</div></div>
            <div style="font-size:13px;color:var(--muted)">Length: <span id="length-badge" style="font-weight:700;margin-left:6px">0</span></div>
          </div>
        </div>

        <div class="vis-area" id="vis-area" tabindex="0">
          <div class="op-badge" id="op-badge" aria-live="polite">Ready</div>
          <div class="array-row" id="array-row" aria-live="polite" aria-relevant="additions removals"></div>

          <div class="explain" id="explain" aria-hidden="false">
            Tip: Click "Access by Index" after entering an index to highlight that cell (shows O(1) direct access).
            When you insert/remove in the middle you'll see a visual shift of the elements to the right or left.
          </div>
        </div>

        <div style="margin-top:12px;display:flex;gap:12px;align-items:center;flex-wrap:wrap;">
          <div style="font-size:13px;color:var(--muted)">Operation cost:</div>
          <div id="cost-pill" style="background:rgba(255,255,255,0.025);padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);min-width:110px;text-align:center;">
            <div style="font-size:13px;color:var(--muted)">Insert/Delete at middle</div>
            <div style="font-weight:700;margin-top:6px" id="cost-value">O(n) — elements shift</div>
          </div>
        </div>
      </section>
    </main>

    <!-- Design Plan & Layout Description -->
    <section style="margin-top:8px;">
      <h2 style="margin:0 0 6px 0;font-size:14px;color:var(--accent)">Interactive Design Plan</h2>

      <div style="background:rgba(255,255,255,0.01);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);color:var(--muted);font-size:13px;">
        <strong>Concept Title:</strong> Array — Indexing and shifting behavior on insert/delete<br><br>

        <strong>Learning Objective:</strong> After interacting, users will be able to:
        <ul>
          <li>Identify array indices (0-based) and access an element directly.</li>
          <li>Observe how inserting/removing at an index causes subsequent elements to shift positions.</li>
          <li>Relate the visual shifts to the O(n) cost for middle insert/delete operations.</li>
        </ul>

        <strong>Interaction Design:</strong>
        <div style="margin-top:6px;">
          - Click "Push (end)" to append a value; the new cell appears at the end with a brief pop animation.<br>
          - Click "Pop (end)" to remove the last element; it fades out. No other elements move.<br>
          - Enter Index + click "Insert": we perform a FLIP-style animation:
            1) record current positions of visible cells,
            2) update the array model (splice in new element),
            3) compute position deltas and animate existing cells shifting right to their new positions, while the new cell fades/zooms into place.
            This communicates that items after the insertion point must move.<br>
          - Click "Remove" for an index: cells after that index shift left smoothly to fill the gap while the removed cell fades out.<br>
          - Use "Access by Index" to highlight a single cell (simulates constant-time indexed access). This highlights the difference between direct access and shifting cost.<br>
          - Visual feedback includes animated transforms, shadow/pulse for highlight, and an operation badge that updates with short textual feedback (e.g., "Inserted at 2 — shifted 3 elements").<br>
          - All interactions are keyboard-accessible and announced via aria-live regions for screen readers.
        </div>

        <strong>Layout Description:</strong>
        <div style="margin-top:6px;">
          - Overall container uses safe area margins of 24px on all sides. The main content arranges into two columns:
            left column (controls) fixed-width (~340px) and right column (visualization) flexible to fill remaining space.
          - Minimum spacing between interactive elements is 16px (CSS gap used widely). Controls use stacked groups with 12–16px gaps for clarity.
          - Visualization area centers the array boxes horizontally and wraps to multiple lines on narrow screens (responsive).
          - Color contrasts, focus outlines, and aria-live regions support accessibility. Buttons and inputs are sized for comfortable touch targets.
        </div>
      </div>
    </section>

    <footer>
      Tips: Try inserting at index 0 repeatedly to see many elements shift — that's the main cost demonstration.
    </footer>
  </div>

  <script>
    (function(){
      // Model
      let arr = [];

      // DOM refs
      const row = document.getElementById('array-row');
      const lengthBadge = document.getElementById('length-badge');
      const opBadge = document.getElementById('op-badge');
      const costValue = document.getElementById('cost-value');
      const valueInput = document.getElementById('value-input');
      const indexInput = document.getElementById('index-input');

      // Buttons
      const pushBtn = document.getElementById('push-btn');
      const popBtn = document.getElementById('pop-btn');
      const insertBtn = document.getElementById('insert-btn');
      const removeBtn = document.getElementById('remove-btn');
      const accessBtn = document.getElementById('access-btn');
      const randomBtn = document.getElementById('random-btn');
      const clearBtn = document.getElementById('clear-btn');

      // Utility: normalize value (show strings with quotes)
      function formatVal(v){
        if (v === null) return 'null';
        if (v === undefined) return 'undefined';
        if (typeof v === 'string') {
          if (/^\d+$/.test(v)) return v; // numeric-looking string: keep raw
          return '"' + v + '"';
        }
        return String(v);
      }

      // Render the array with FLIP animation
      function render(withAnimation = true, opText = 'Ready') {
        // record old positions
        const oldRects = new Map();
        row.querySelectorAll('.cell').forEach(el => {
          oldRects.set(el.dataset.key, el.getBoundingClientRect());
        });

        // clear and rebuild
        // Use keys for stable identity: key = index + ":" + unique id (unique id stored on object)
        row.innerHTML = '';
        arr.forEach((item, idx) => {
          const cell = document.createElement('div');
          cell.className = 'cell';
          const key = item.__id;
          cell.setAttribute('data-key', key);
          cell.setAttribute('role','group');
          cell.setAttribute('aria-label', `Index ${idx}, value ${String(item.v)}`);
          cell.tabIndex = 0;

          const val = document.createElement('div');
          val.className = 'value';
          val.textContent = formatVal(item.v);

          const ind = document.createElement('div');
          ind.className = 'index';
          ind.textContent = idx;

          cell.appendChild(val);
          cell.appendChild(ind);
          row.appendChild(cell);
        });

        // update length
        lengthBadge.textContent = arr.length;

        // perform FLIP: compute new positions and animate differences
        if (!withAnimation) {
          opBadge.textContent = opText;
          return;
        }
        const newRects = new Map();
        row.querySelectorAll('.cell').forEach(el => {
          newRects.set(el.dataset.key, el.getBoundingClientRect());
        });

        // For elements that exist in both, apply inverse transform then animate to zero
        row.querySelectorAll('.cell').forEach(el => {
          const key = el.dataset.key;
          const oldRect = oldRects.get(key);
          const newRect = newRects.get(key);
          if (oldRect) {
            const dx = oldRect.left - newRect.left;
            const dy = oldRect.top - newRect.top;
            if (dx || dy) {
              el.style.transition = 'none';
              el.style.transform = `translate(${dx}px, ${dy}px)`;
              // force reflow
              el.getBoundingClientRect();
              requestAnimationFrame(() => {
                el.style.transition = 'transform 360ms cubic-bezier(.22,.9,.35,1), box-shadow 240ms';
                el.style.transform = '';
              });
            }
          } else {
            // new element: animate pulse in
            el.style.opacity = 0;
            el.style.transform = 'scale(0.96)';
            el.style.transition = 'opacity 280ms ease, transform 280ms ease';
            requestAnimationFrame(() => {
              el.style.opacity = 1;
              el.style.transform = '';
            });
          }
        });

        // elements removed: animate fade from clones
        oldRects.forEach((rect, key) => {
          if (!newRects.has(key)) {
            // create a clone floating at old position
            const clone = document.createElement('div');
            clone.className = 'cell';
            clone.style.position = 'fixed';
            clone.style.left = rect.left + 'px';
            clone.style.top = rect.top + 'px';
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.margin = 0;
            clone.style.zIndex = 1200;
            clone.style.transition = 'transform 320ms ease, opacity 320ms ease';
            // fill clone content based on key (we can find value in previous arr snapshot)
            // For simplicity, just show a faded block
            clone.style.opacity = 0.95;
            clone.style.pointerEvents = 'none';
            clone.innerHTML = '<div style="height:100%;display:flex;align-items:center;justify-content:center;color:var(--muted)">removed</div>';
            document.body.appendChild(clone);
            requestAnimationFrame(() => {
              clone.style.opacity = 0;
              clone.style.transform = 'scale(0.96) translateY(-8px)';
            });
            setTimeout(() => clone.remove(), 360);
          }
        });

        // update op badge
        opBadge.textContent = opText;

        // small accessibility announcement
        setTimeout(()=> {
          opBadge.setAttribute('aria-hidden','false');
        }, 0);
      }

      // Create items with unique id
      let uid = 1;
      function makeItem(raw){
        return { v: raw, __id: String(Date.now()) + '-' + (uid++) };
      }

      // Operations
      function pushValue(raw){
        if (raw === '') return;
        const item = makeItem(raw);
        arr.push(item);
        render(true, `Pushed → "${raw}"`);
      }

      function popValue(){
        if (arr.length === 0) {
          render(false, 'Array empty');
          return;
        }
        const removed = arr.pop();
        render(true, `Popped ← ${formatVal(removed.v)}`);
      }

      function insertAt(raw, idx){
        if (raw === '') return;
        idx = Number(idx);
        if (!Number.isFinite(idx) || isNaN(idx)) idx = arr.length;
        idx = Math.max(0, Math.floor(idx));
        const clamped = Math.min(idx, arr.length);
        const item = makeItem(raw);
        // Count how many elements will shift: those at positions >= clamped
        const numShift = arr.length - clamped;
        arr.splice(clamped, 0, item);
        render(true, `Inserted at ${clamped} (shifted ${numShift} element${numShift===1?'':'s'})`);
      }

      function removeAt(idx){
        idx = Number(idx);
        if (!Number.isFinite(idx) || isNaN(idx)) {
          render(false, 'Invalid index');
          return;
        }
        idx = Math.floor(idx);
        if (idx < 0 || idx >= arr.length) {
          render(false, 'Index out of range');
          return;
        }
        const removed = arr.splice(idx,1)[0];
        const numShift = Math.max(0, arr.length - idx);
        render(true, `Removed at ${idx} (shifted ${numShift} element${numShift===1?'':'s'})`);
      }

      function accessAt(idx){
        idx = Number(idx);
        if (!Number.isFinite(idx) || isNaN(idx)) {
          render(false, 'Invalid index');
          return;
        }
        idx = Math.floor(idx);
        if (idx < 0 || idx >= arr.length) {
          render(false, 'Index out of range');
          return;
        }
        // highlight the cell
        const cell = Array.from(row.children)[idx];
        if (!cell) return;
        // animate a pulse and temporary highlight
        cell.classList.add('highlight');
        cell.classList.add('pulse');
        const val = arr[idx].v;
        render(false, `Accessed index ${idx} → ${formatVal(val)}`);
        setTimeout(()=> {
          cell.classList.remove('pulse');
          setTimeout(()=> cell.classList.remove('highlight'), 360);
        }, 520);
      }

      // Randomize demo
      function randomDemo(){
        const sample = ['apple','banana','cat',42,7,'x','hello','99','z'];
        arr = [];
        const n = Math.floor(Math.random()*6)+3;
        for (let i=0;i<n;i++){
          arr.push(makeItem(String(sample[Math.floor(Math.random()*sample.length)])));
        }
        render(true, 'Randomized');
      }

      function clearAll(){
        arr = [];
        render(false, 'Cleared');
      }

      // Event bindings
      pushBtn.addEventListener('click', ()=> {
        pushValue(valueInput.value.trim());
        valueInput.value = '';
        valueInput.focus();
      });
      popBtn.addEventListener('click', ()=> popValue());
      insertBtn.addEventListener('click', ()=> {
        insertAt(valueInput.value.trim(), indexInput.value);
        valueInput.value = '';
        indexInput.value = '';
        valueInput.focus();
      });
      removeBtn.addEventListener('click', ()=> {
        removeAt(indexInput.value);
        indexInput.value = '';
      });
      accessBtn.addEventListener('click', ()=> {
        accessAt(indexInput.value);
      });
      randomBtn.addEventListener('click', randomDemo);
      clearBtn.addEventListener('click', clearAll);

      // keyboard: Enter in value input => push, Shift+Enter => insert at 0
      valueInput.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter') {
          e.preventDefault();
          if (e.shiftKey) {
            insertAt(valueInput.value.trim(), 0);
          } else {
            pushValue(valueInput.value.trim());
            valueInput.value = '';
          }
        }
      });

      // initial demo
      (function seed(){
        const initial = ['a','b','c','d'];
        arr = initial.map(x => makeItem(x));
        render(false,'Ready');
      })();

      // Update cost text (constant demonstration)
      costValue.textContent = 'O(n) — shifting elements after index';

      // Accessibility: announce operations by updating opBadge (aria-live)
      // Already handled via opBadge text changes.
    })();
  </script>
</body>
</html>