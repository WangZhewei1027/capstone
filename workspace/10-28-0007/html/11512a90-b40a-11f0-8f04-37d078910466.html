<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Stack Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1720;
      --card: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --success: #10b981;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.04);
      --max-width: 1100px;
    }

    /* Safe area margins */
    html,body{height:100%;}
    body{
      margin:0;
      padding:var(--safe-margin);
      background: linear-gradient(180deg,#071022 0%, #07111b 100%);
      color:#e6eef6;
      font-family: Inter, "Segoe UI", Roboto, system-ui, -apple-system, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
    }

    .container{
      width:100%;
      max-width:var(--max-width);
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:var(--gap);
      align-items:start;
    }

    /* Responsive: stack vertically on narrow screens */
    @media (max-width:880px){
      .container{grid-template-columns:1fr; padding-bottom: var(--safe-margin);}
    }

    /* Left column (controls + explanation card) */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      border-radius:12px;
      padding:20px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.55);
      min-height: 320px;
    }

    .title{
      display:flex;
      align-items:center;
      gap:12px;
      margin-bottom:12px;
    }
    .title h1{
      font-size:20px;
      margin:0;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
    }

    .section{
      margin-top:12px;
    }

    label{display:block; font-size:13px; color:var(--muted); margin-bottom:8px;}

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:var(--gap);
      margin-top:8px;
    }

    input[type="text"], input[type="number"], select{
      padding:10px 12px;
      border-radius:8px;
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.04);
      color:inherit;
      outline:none;
      min-width:140px;
      font-size:14px;
    }
    input:focus, button:focus{
      box-shadow: 0 0 0 3px rgba(6,182,212,0.12);
      border-color: var(--accent);
    }

    .btn{
      appearance:none;
      border:none;
      background:linear-gradient(180deg,var(--accent), #028fa8);
      color: #042025;
      padding:10px 14px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      font-size:14px;
      min-width:72px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
    }

    .btn.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      font-weight:600;
    }

    .btn.danger{
      background:linear-gradient(180deg,var(--danger), #c43030);
      color:white;
    }

    /* Visualization column */
    .visual{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      border-radius:12px;
      padding:20px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.55);
      min-height:420px;
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .vis-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
    }
    .vis-header .controls-mini{display:flex; gap:12px; align-items:center;}

    .stack-area{
      display:flex;
      gap:24px;
      align-items:flex-start;
      justify-content:center;
      padding:6px;
      min-height:260px;
      width:100%;
    }
    /* Stack container */
    .stack-frame{
      width:220px;
      max-width:48vw;
      min-width:180px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:12px;
      padding:12px;
      border:1px dashed rgba(255,255,255,0.03);
    }
    .stack-outer{
      height:320px;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      position:relative;
      -webkit-user-select:none;
      user-select:none;
    }

    .slots{
      width:160px;
      height:100%;
      display:flex;
      flex-direction:column-reverse; /* bottom is index 0 */
      gap:8px;
      padding:12px 8px;
      align-items:stretch;
    }

    .slot{
      height:48px;
      border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      color:var(--muted);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:600;
      position:relative;
      overflow:hidden;
      transition:transform 350ms cubic-bezier(.2,.9,.23,1), background 250ms, box-shadow 200ms;
    }

    .slot.empty{
      color: rgba(255,255,255,0.12);
      font-weight:500;
      font-size:13px;
    }

    .slot.filled{
      color:#06121a;
      background:linear-gradient(180deg, #a9f0f6, #6ee4ec);
    }

    .slot.top{
      box-shadow: 0 12px 25px rgba(6,182,212,0.12);
      transform: translateY(-6px);
    }

    /* index labels */
    .indices{
      display:flex;
      flex-direction:column-reverse;
      gap:8px;
      align-items:flex-end;
      justify-content:flex-start;
      padding-right:8px;
      min-width:36px;
      color:var(--muted);
      font-size:13px;
    }

    /* top pointer */
    .top-pointer{
      position:absolute;
      right: -70px;
      top: 24px;
      transform-origin:left center;
      display:flex;
      align-items:center;
      gap:8px;
      color:var(--muted);
      font-weight:600;
      background:transparent;
    }

    .top-pointer .value{
      color:var(--accent);
      font-weight:700;
      font-size:15px;
      background:rgba(6,182,212,0.06);
      padding:6px 8px;
      border-radius:8px;
      border:1px solid rgba(6,182,212,0.08);
    }

    /* Log box */
    .log{
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      border-radius:10px;
      padding:10px;
      color:var(--muted);
      font-size:13px;
      max-height:120px;
      overflow:auto;
    }

    /* Animations */
    .animate-in{
      animation: slideIn 420ms cubic-bezier(.2,.9,.23,1) forwards;
    }
    .animate-pop{
      animation: popOut 300ms ease forwards;
    }
    .shake{
      animation: shake 420ms cubic-bezier(.36,.07,.19,.97);
    }
    .pulse{
      animation: pulse 800ms ease;
    }

    @keyframes slideIn{
      0%{ transform: translateY(-80px) scale(.96); opacity:0; }
      60%{ transform: translateY(10px) scale(1.02); opacity:1; }
      100%{ transform: translateY(0) scale(1); opacity:1; }
    }
    @keyframes popOut{
      0%{ transform: translateY(0) scale(1); opacity:1; }
      100%{ transform: translateY(-60px) scale(.8); opacity:0; }
    }
    @keyframes shake{
      10%,90%{ transform: translateX(-1px); }
      20%,80%{ transform: translateX(2px); }
      30%,50%,70%{ transform: translateX(-4px); }
      40%,60%{ transform: translateX(4px); }
    }
    @keyframes pulse{
      0%{ box-shadow: 0 8px 22px rgba(6,182,212,0.06);}
      50%{ box-shadow: 0 16px 36px rgba(6,182,212,0.12);}
      100%{ box-shadow: 0 8px 22px rgba(6,182,212,0.06);}
    }

    /* small helpers */
    .row{display:flex; gap:12px; align-items:center;}
    .spacer{flex:1;}
    .note{font-size:13px; color:var(--muted);}
    .capacity-badge{
      background:rgba(255,255,255,0.03);
      padding:6px 8px;
      border-radius:8px;
      color:var(--muted);
      font-weight:700;
    }

    /* footer small */
    .meta{
      font-size:13px;
      color:var(--muted);
      margin-top:8px;
    }

    /* ensure minimum spacing between interactive elements */
    .controls > * { margin:0; }
    .controls > * + * { margin-left: var(--gap); }
    .controls-mini > * + * { margin-left: 12px; }

    /* Accessibility focus outline for keyboard users */
    :focus{ outline: none; }
    button:focus-visible, input:focus-visible { outline: 3px solid rgba(6,182,212,0.12); border-radius:8px; }

  </style>
</head>
<body>
  <main class="container" role="main" aria-labelledby="module-title">
    <!-- LEFT PANEL: Concept, objective, interaction design, layout description, controls -->
    <section class="panel" aria-labelledby="module-title">
      <div class="title">
        <div>
          <h1 id="module-title">Stack â€” Last-In, First-Out (LIFO)</h1>
          <div class="muted">Interactive learning module</div>
        </div>
      </div>

      <div class="section" aria-labelledby="objective-label">
        <strong id="objective-label">Learning objective</strong>
        <p class="note" style="margin-top:8px;">
          Understand how a stack stores items using LIFO behavior. After interacting, you will be able to:
          push items onto the stack, pop and peek, observe index changes, and see underflow/overflow behavior.
        </p>
      </div>

      <div class="section" aria-labelledby="interaction-label">
        <strong id="interaction-label">Interaction design</strong>
        <p class="note" style="margin-top:8px;">
          Interact with controls to push strings or numbers, pop the top item, peek, clear, or set capacity.
          Visual animations show items sliding into the stack, popping out, and pointer updates. Errors (underflow/overflow)
          cause a red shake and message. Keyboard accessible: Enter in the input performs push.
        </p>
      </div>

      <div class="section" aria-labelledby="layout-label">
        <strong id="layout-label">Layout description</strong>
        <p class="note" style="margin-top:8px;">
          This module keeps a clear two-column layout: controls and explanations on the left; visualization and logs on the right.
          Safe margins are 24px; elements use at least 16px spacing. On smaller screens, the layout collapses to a single column
          for readability and accessibility.
        </p>
      </div>

      <div class="section" style="margin-top:12px;">
        <label for="push-input">Value to push (text allowed)</label>
        <div class="controls" role="group" aria-label="Push controls">
          <input id="push-input" type="text" placeholder="e.g. 42 or 'apple'" aria-label="Value to push" />
          <button id="push-btn" class="btn" aria-label="Push value">Push</button>
          <button id="pop-btn" class="btn secondary" aria-label="Pop top">Pop</button>
          <button id="peek-btn" class="btn secondary" aria-label="Peek top">Peek</button>
        </div>
      </div>

      <div class="section" style="margin-top:12px;">
        <label for="capacity-range">Capacity (max slots)</label>
        <div class="row" style="margin-top:6px;">
          <input id="capacity-range" type="range" min="1" max="12" value="8" aria-label="Stack capacity" />
          <div class="capacity-badge" id="capacity-badge" aria-live="polite">Capacity: 8</div>
        </div>
        <div class="row" style="margin-top:12px;">
          <button id="auto-btn" class="btn secondary" aria-label="Auto-demo">Auto demo</button>
          <button id="clear-btn" class="btn danger" aria-label="Clear stack">Clear</button>
          <div class="spacer"></div>
          <div class="note" aria-live="polite" id="status" style="min-width:160px;"></div>
        </div>
      </div>

      <div class="meta" style="margin-top:14px;">
        Tips: Use the input + Enter to push quickly. Try capacity 3 and push more than 3 to see overflow.
      </div>
    </section>

    <!-- RIGHT PANEL: Visualization & log -->
    <section class="visual" aria-label="Stack visualization area">
      <div class="vis-header">
        <div style="display:flex; flex-direction:column;">
          <div style="display:flex; gap:12px; align-items:center;">
            <div style="font-weight:700; font-size:18px;">Visual Stack</div>
            <div class="muted" style="font-size:13px;">LIFO â€” last item pushed is first popped</div>
          </div>
          <div class="note" style="margin-top:6px;">Slots show indexes (0 at bottom). The top pointer and index update as you push/pop.</div>
        </div>

        <div class="controls-mini" aria-hidden="false">
          <div class="note">Top =&nbsp;<span id="top-value" class="capacity-badge">-1</span></div>
        </div>
      </div>

      <div class="stack-area" aria-live="polite">
        <div class="stack-frame" role="region" aria-label="Stack frame">
          <div class="stack-outer" id="stack-outer">
            <div style="display:flex; width:100%; gap:8px;">
              <div class="indices" id="indices" aria-hidden="true"></div>
              <div class="slots" id="slots" aria-live="polite" aria-atomic="true"></div>
            </div>
            <div class="top-pointer" id="top-pointer" aria-hidden="true">
              <svg width="34" height="18" viewBox="0 0 34 18" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <path d="M0 9h26" stroke="rgba(255,255,255,0.06)" stroke-width="1.6" stroke-linecap="round"/>
                <path d="M18 0l16 9-16 9V0z" fill="rgba(6,182,212,0.06)"/>
              </svg>
              <div style="display:flex;flex-direction:column;">
                <div class="muted" style="font-size:12px;">Top index</div>
                <div class="value" id="top-index-display">-1</div>
              </div>
            </div>
          </div>
        </div>

        <div style="flex:1; min-width:240px; display:flex; flex-direction:column; gap:12px;">
          <div style="flex:1; display:flex; flex-direction:column; gap:8px;">
            <div class="note">Recent operations</div>
            <div class="log" id="log" aria-live="polite"></div>
          </div>

          <div style="display:flex; gap:12px; align-items:center; justify-content:flex-end;">
            <div class="note">Stack size:&nbsp;<strong id="size-display">0</strong></div>
            <div class="note">Capacity:&nbsp;<strong id="cap-display">8</strong></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Stack interactive module (vanilla JS)
    (function(){
      // State
      let capacity = 8;
      let stack = []; // bottom at index 0, top = stack.length - 1

      // Controls
      const pushInput = document.getElementById('push-input');
      const pushBtn = document.getElementById('push-btn');
      const popBtn = document.getElementById('pop-btn');
      const peekBtn = document.getElementById('peek-btn');
      const clearBtn = document.getElementById('clear-btn');
      const autoBtn = document.getElementById('auto-btn');
      const capacityRange = document.getElementById('capacity-range');
      const capacityBadge = document.getElementById('capacity-badge');

      // Visual elements
      const slotsEl = document.getElementById('slots');
      const indicesEl = document.getElementById('indices');
      const logEl = document.getElementById('log');
      const sizeDisplay = document.getElementById('size-display');
      const capDisplay = document.getElementById('cap-display');
      const topValue = document.getElementById('top-value');
      const topIndexDisplay = document.getElementById('top-index-display');
      const statusEl = document.getElementById('status');
      const stackOuter = document.getElementById('stack-outer');

      // Initialize UI
      capacityRange.addEventListener('input', (e) => {
        capacity = parseInt(e.target.value, 10);
        capacityBadge.textContent = 'Capacity: ' + capacity;
        capDisplay.textContent = capacity;
        renderSlots();
        announce('Capacity set to ' + capacity);
      });

      function announce(msg){
        statusEl.textContent = msg;
        setTimeout(()=>{ if(statusEl.textContent === msg) statusEl.textContent = ''; }, 2500);
      }

      function log(msg){
        const p = document.createElement('div');
        p.textContent = msg;
        logEl.prepend(p);
        // keep last 100 entries
        while(logEl.childElementCount > 100) logEl.removeChild(logEl.lastChild);
      }

      function renderSlots(pulseIndex = null){
        // Clear
        slotsEl.innerHTML = '';
        indicesEl.innerHTML = '';

        // Render indices and slots (we always show full capacity)
        for(let i = capacity - 1; i >= 0; i--){
          // index label (displayed aligned)
          const idx = document.createElement('div');
          idx.textContent = i;
          indicesEl.appendChild(idx);
        }

        for(let i = capacity - 1; i >= 0; i--){
          const slot = document.createElement('div');
          slot.className = 'slot empty';
          // Determine if this slot is filled
          if(i < stack.length){
            const val = stack[i];
            slot.classList.remove('empty');
            slot.classList.add('filled');
            slot.textContent = String(val);
            slot.setAttribute('aria-label', 'Slot ' + i + ' value ' + String(val));
          }else{
            slot.textContent = 'empty';
            slot.setAttribute('aria-label', 'Slot ' + i + ' empty');
          }

          // Mark top
          if(i === stack.length - 1){
            slot.classList.add('top');
            slot.setAttribute('aria-current', 'true');
            slot.title = 'Top of stack';
          }

          // pulse effect for peek or recent push
          if(pulseIndex !== null && i === pulseIndex){
            slot.classList.add('pulse');
            setTimeout(()=>slot.classList.remove('pulse'), 900);
          }

          slotsEl.appendChild(slot);
        }

        // Top display values
        const topIndex = stack.length - 1;
        topValue.textContent = (topIndex >= 0) ? topIndex : -1;
        topIndexDisplay.textContent = (topIndex >= 0) ? topIndex : -1;
        sizeDisplay.textContent = stack.length;
      }

      function pushValue(value){
        // Validate
        if(stack.length >= capacity){
          // overflow
          indicateOverflow();
          log('Overflow: attempted to push ' + value);
          announce('Overflow â€” stack is full');
          return false;
        }
        // Append to end (top)
        stack.push(value);
        log('Pushed: ' + value);
        animatePush(stack.length - 1, value);
        return true;
      }

      function popValue(){
        if(stack.length === 0){
          indicateUnderflow();
          log('Underflow: attempted to pop');
          announce('Underflow â€” stack is empty');
          return null;
        }
        const val = stack.pop();
        log('Popped: ' + val);
        animatePop(stack.length, val); // popped index was new length
        return val;
      }

      function peekValue(){
        if(stack.length === 0){
          indicateUnderflow();
          log('Peek: stack empty');
          announce('Stack is empty');
          return null;
        }
        const topIdx = stack.length - 1;
        log('Peek: ' + stack[topIdx]);
        renderSlots(topIdx);
        announce('Peeked value: ' + stack[topIdx]);
        return stack[topIdx];
      }

      function clearStack(){
        if(stack.length === 0){
          announce('Stack already empty');
          return;
        }
        stack = [];
        renderSlots();
        log('Cleared stack');
        announce('Stack cleared');
      }

      // Visual feedback: overflow/underflow shake
      function indicateOverflow(){
        stackOuter.classList.add('shake');
        stackOuter.style.borderColor = 'rgba(239,68,68,0.3)';
        setTimeout(()=>{ stackOuter.classList.remove('shake'); stackOuter.style.borderColor = ''; }, 600);
      }
      function indicateUnderflow(){
        stackOuter.classList.add('shake');
        stackOuter.style.borderColor = 'rgba(239,68,68,0.3)';
        setTimeout(()=>{ stackOuter.classList.remove('shake'); stackOuter.style.borderColor = ''; }, 600);
      }

      // Animations for push/pop
      function animatePush(index, value){
        // Re-render slots with the new data but animate the top element separately to show slide-in
        renderSlots();
        // find the corresponding slot element (slots are rendered top-down reverse order)
        // slotsEl children are in order: bottom ... top? We used flex-direction: column-reverse so DOM order is bottom->top
        // We rendered from capacity-1 down to 0, with column-reverse; simpler: find slot with top class
        const slotEls = Array.from(slotsEl.querySelectorAll('.slot'));
        const topSlot = slotEls.find(s => s.classList.contains('top'));
        if(!topSlot) return;
        topSlot.classList.add('animate-in');
        setTimeout(()=> topSlot.classList.remove('animate-in'), 520);
      }

      function animatePop(index, value){
        // index is the slot index that was removed (old top)
        // Render first to show empty slot, then create a floating element that pops out for animation
        renderSlots();
        const floating = document.createElement('div');
        floating.className = 'slot filled animate-pop';
        floating.style.position = 'absolute';
        floating.style.right = 'calc(50% + 10px)';
        floating.style.top = '16px';
        floating.style.width = '160px';
        floating.style.height = '48px';
        floating.style.borderRadius = '8px';
        floating.style.display = 'flex';
        floating.style.alignItems = 'center';
        floating.style.justifyContent = 'center';
        floating.style.background = 'linear-gradient(180deg,#a9f0f6,#6ee4ec)';
        floating.style.fontWeight = '700';
        floating.style.color = '#06121a';
        floating.textContent = String(value);
        floating.style.zIndex = 60;
        stackOuter.appendChild(floating);
        setTimeout(()=> {
          floating.remove();
        }, 320);
      }

      // Event wiring
      pushBtn.addEventListener('click', () => {
        const value = pushInput.value.trim();
        if(value === ''){
          announce('Enter a value to push');
          return;
        }
        pushValue(value);
        pushInput.value = '';
        pushInput.focus();
      });

      popBtn.addEventListener('click', () => {
        const val = popValue();
        if(val !== null){
          announce('Popped: ' + val);
        }
      });

      peekBtn.addEventListener('click', () => {
        const val = peekValue();
        if(val !== null){
          // visual highlight already applied in peekValue()
        }
      });

      clearBtn.addEventListener('click', () => {
        clearStack();
      });

      autoBtn.addEventListener('click', () => {
        runAutoDemo();
      });

      // Keyboard: Enter to push
      pushInput.addEventListener('keydown', (e) => {
        if(e.key === 'Enter'){
          pushBtn.click();
          e.preventDefault();
        }
      });

      // Auto demo: pushes several values with delay, then pops some
      async function runAutoDemo(){
        announce('Auto demo started');
        autoBtn.disabled = true;
        const sample = ['A','B','C','D','E','F','G','H','I'];
        for(let i=0;i<5;i++){
          if(stack.length < capacity) {
            pushValue(sample[i % sample.length]);
            await sleep(450);
          } else {
            indicateOverflow();
            await sleep(450);
            break;
          }
        }
        await sleep(700);
        for(let i=0;i<3;i++){
          if(stack.length > 0){
            popValue();
            await sleep(420);
          } else {
            indicateUnderflow();
            await sleep(400);
            break;
          }
        }
        announce('Auto demo finished');
        autoBtn.disabled = false;
      }

      function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

      // Initialize default render
      capacityRange.value = capacity;
      capacityBadge.textContent = 'Capacity: ' + capacity;
      capDisplay.textContent = capacity;
      renderSlots();

      // Accessibility: announce initial state
      log('Module ready. Capacity: ' + capacity);
      announce('Stack ready with capacity ' + capacity);

      // Expose nothing to global scope
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Stack Module",
  "description": "Finite state machine modeling the interactive stack visualization application (push, pop, peek, capacity changes, auto-demo and visual/error animations).",
  "states": [
    {
      "name": "ready",
      "onEnter": "renderSlots / update UI",
      "on": {
        "PUSH_REQUEST": "pushing",
        "PUSH_REQUEST_EMPTY": "ready",
        "PUSH_REQUEST_OVERFLOW": "overflow",
        "POP_REQUEST": "popping",
        "POP_REQUEST_UNDERFLOW": "underflow",
        "PEEK_REQUEST": "peeking",
        "PEEK_REQUEST_UNDERFLOW": "underflow",
        "CLEAR_REQUEST": "clearing",
        "CAPACITY_CHANGE": "capacity_changing",
        "AUTO_START": "auto_demo"
      }
    },
    {
      "name": "pushing",
      "onEnter": "pushValue(value) -> (internal: validate capacity, update stack, log, renderSlots) then animatePush(topIndex)",
      "onExit": "remove push animation class (animate-in) if any",
      "on": {
        "ANIMATION_END_PUSH": "ready",
        "PUSH_OVERFLOW": "overflow"
      }
    },
    {
      "name": "popping",
      "onEnter": "popValue() -> (validate non-empty, update stack, log) then animatePop(poppedIndex, value)",
      "onExit": "remove floating element (handled by animation timeout)",
      "on": {
        "ANIMATION_END_POP": "ready",
        "POP_UNDERFLOW": "underflow"
      }
    },
    {
      "name": "peeking",
      "onEnter": "peekValue() -> (if non-empty: renderSlots(pulseIndex = top), log, announce)",
      "onExit": "remove pulse class after timeout (renderSlots sets timeout ~900ms)",
      "on": {
        "PEEK_ANIMATION_END": "ready",
        "PEEK_UNDERFLOW": "underflow"
      }
    },
    {
      "name": "clearing",
      "onEnter": "clearStack() -> (stack=[], renderSlots, log, announce)",
      "on": {
        "CLEARED": "ready"
      }
    },
    {
      "name": "capacity_changing",
      "onEnter": "set capacity, capacityBadge.textContent, capDisplay.textContent, renderSlots(), announce('Capacity set to X')",
      "on": {
        "CAPACITY_APPLIED": "ready"
      }
    },
    {
      "name": "overflow",
      "onEnter": "indicateOverflow() -> (add 'shake' class, set border color, log overflow, announce), keep visual shake for ~600ms",
      "onExit": "remove 'shake' class and clear border color (timeout clears after ~600ms)",
      "on": {
        "ERROR_ANIM_END": "ready"
      }
    },
    {
      "name": "underflow",
      "onEnter": "indicateUnderflow() -> (add 'shake' class, set border color, log underflow/peek empty, announce), keep visual shake for ~600ms",
      "onExit": "remove 'shake' class and clear border color (timeout clears after ~600ms)",
      "on": {
        "ERROR_ANIM_END": "ready"
      }
    },
    {
      "name": "auto_demo",
      "onEnter": "runAutoDemo() -> (disable autoBtn, perform scheduled pushes/pops with delays, internal pushes/pops trigger pushing/popping behaviors or their inline logic, handle overflow/underflow during demo, re-enable autoBtn, announce finished)",
      "onExit": "autoBtn.disabled = false",
      "on": {
        "AUTO_FINISHED": "ready",
        "AUTO_INTERRUPTED": "ready"
      }
    }
  ],
  "events": [
    "PUSH_REQUEST",
    "PUSH_REQUEST_EMPTY",
    "PUSH_REQUEST_OVERFLOW",
    "POP_REQUEST",
    "POP_REQUEST_UNDERFLOW",
    "PEEK_REQUEST",
    "PEEK_REQUEST_UNDERFLOW",
    "CLEAR_REQUEST",
    "CAPACITY_CHANGE",
    "AUTO_START",
    "ANIMATION_END_PUSH",
    "ANIMATION_END_POP",
    "PEEK_ANIMATION_END",
    "ERROR_ANIM_END",
    "CAPACITY_APPLIED",
    "CLEARED",
    "AUTO_FINISHED",
    "AUTO_INTERRUPTED",
    "PUSH_OVERFLOW",
    "POP_UNDERFLOW"
  ],
  "notes": "State timings and animation durations are implemented with timeouts in the code: push animate-in removed after ~520ms (ANIMATION_END_PUSH), pop floating element removed after ~320ms (ANIMATION_END_POP), peek pulse removed after ~900ms (PEEK_ANIMATION_END), shake (overflow/underflow) lasts ~600ms (ERROR_ANIM_END). Capacity changes are immediate (CAPACITY_CHANGE -> capacity_changing -> CAPACITY_APPLIED). Auto-demo runs asynchronously (AUTO_START -> auto_demo -> AUTO_FINISHED) and internally issues push/pop operations; the auto-demo disables only the auto button but other controls remain actionable in the implementation. Events like PUSH_REQUEST carry a payload 'value' in the real app; validation (empty string or capacity full) determines transitions to PUSH_REQUEST_EMPTY or PUSH_REQUEST_OVERFLOW which lead to no-op or overflow error states respectively."
}
  </script>
</body>
</html>