<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Red-Black Tree — Interactive Insertion & Rebalancing</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --panel-bg: #f8fafc;
      --accent: #1f6feb;
      --muted: #6b7280;
      --node-radius: 20;
      --level-height: 90;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, Roboto, Arial, sans-serif;
      background: #ffffff;
      color: #0f172a;
    }
    /* Safe area margins */
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    header {
      display:flex;
      align-items:baseline;
      gap: var(--gap);
      flex-wrap:wrap;
    }
    h1 {
      font-size:1.25rem;
      margin:0;
      line-height:1;
    }
    .subtle {
      color:var(--muted);
      font-size:0.95rem;
    }

    main {
      display:flex;
      gap: var(--gap);
      align-items:flex-start;
      width:100%;
      flex:1 1 auto;
      min-height: 320px;
    }

    /* Left panel: controls & explanations */
    .controls {
      width:360px;
      min-width:280px;
      max-width:38%;
      background: var(--panel-bg);
      border-radius:8px;
      padding:18px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      box-shadow: 0 1px 2px rgba(15,23,42,0.06);
    }
    .controls .block {
      display:flex;
      gap: var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    label {
      font-size:0.9rem;
      color:var(--muted);
    }
    input[type="number"]{
      padding:10px 12px;
      border-radius:6px;
      border:1px solid #e6edf3;
      font-size:0.95rem;
      width:120px;
      box-sizing:border-box;
    }
    button {
      background: var(--accent);
      color:white;
      border: none;
      padding:10px 14px;
      border-radius:8px;
      cursor:pointer;
      font-size:0.95rem;
    }
    button.secondary{
      background:transparent;
      color:var(--accent);
      border:1px solid rgba(31,111,235,0.12);
    }
    button.icon {
      padding:8px 10px;
      font-size:0.95rem;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .controls .row {
      display:flex;
      gap: var(--gap);
      align-items:center;
      justify-content:flex-start;
      flex-wrap:wrap;
    }
    .controls .small {
      font-size:0.9rem;
      color:var(--muted);
    }
    .slider {
      width:160px;
    }

    /* Right panel: visual canvas */
    .canvas-panel {
      flex:1 1 auto;
      min-width:0;
      background: linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);
      border-radius:8px;
      padding:18px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      box-shadow: 0 1px 2px rgba(15,23,42,0.04);
      overflow:hidden;
    }
    .canvas-header {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:var(--gap);
    }
    .canvas-title {
      font-size:0.95rem;
      font-weight:600;
    }
    .canvas-sub {
      color:var(--muted);
      font-size:0.9rem;
    }

    /* SVG area */
    .svg-wrap {
      background: #ffffff;
      border-radius:8px;
      padding:12px;
      box-sizing:border-box;
      flex:1 1 auto;
      min-height:300px;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      overflow:auto;
    }
    svg {
      width:100%;
      height:100%;
      min-height:240px;
      overflow:visible;
    }

    /* Node styles */
    .node-group {
      cursor: default;
      transition: transform 420ms ease, opacity 240ms ease;
    }
    .node-circle {
      stroke: #0f172a;
      stroke-width:1.5px;
      transition: fill 300ms ease, stroke 300ms ease, r 240ms ease;
    }
    .node-text {
      fill: #ffffff;
      font-weight:700;
      font-size:12px;
      pointer-events:none;
      text-anchor:middle;
      dominant-baseline:central;
    }
    .node-label {
      font-size:11px;
      fill:var(--muted);
    }
    .edge {
      stroke:#94a3b8;
      stroke-width:2;
      fill:none;
      transition: stroke 200ms ease, opacity 200ms ease;
    }
    .edge.highlight {
      stroke: #1f6feb;
      stroke-width:2.5;
      opacity:1;
    }
    .hint-box {
      background:#fff;
      border-radius:8px;
      padding:10px;
      border:1px solid #eef2f6;
      font-size:0.92rem;
      color:var(--muted);
    }

    /* legend */
    .legend {
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    .legend .item {
      display:flex;
      align-items:center;
      gap:8px;
      font-size:0.9rem;
      color:var(--muted);
    }
    .dot {
      width:16px;
      height:16px;
      border-radius:50%;
      display:inline-block;
      border:1px solid rgba(15,23,42,0.06);
    }

    /* step info area */
    .step-info {
      display:flex;
      gap:var(--gap);
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }

    /* accessibility focus */
    button:focus, input:focus {
      outline:3px solid rgba(31,111,235,0.18);
      outline-offset:2px;
    }

    /* responsive adjustments */
    @media (max-width:900px){
      main {
        flex-direction:column;
      }
      .controls { width:100%; max-width:none; }
      .canvas-panel { width:100%; }
    }
  </style>
</head>
<body>
  <div class="app" role="main">
    <header>
      <div>
        <h1>Red-Black Tree — Insertion & Rebalancing (Interactive)</h1>
        <div class="subtle">Explore how insertions are handled by the Red-Black Tree via recoloring and rotations.</div>
      </div>
    </header>

    <main>
      <!-- Controls & explanation -->
      <section class="controls" aria-labelledby="controls-title">
        <div>
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <strong id="controls-title">Controls</strong>
            <div class="small">Safe margins: 24px • Spacing: ≥16px</div>
          </div>
          <div class="small" style="margin-top:8px;">
            Concept: Single focused concept — RB-Tree insertion (cases, recolor, rotate).
          </div>
        </div>

        <!-- Input row -->
        <div class="block">
          <label for="value-input">Value to insert</label>
          <input id="value-input" type="number" aria-label="Value to insert" placeholder="e.g. 42" />
          <button id="insert-btn" aria-label="Insert value">Insert</button>
          <button id="random-btn" class="secondary" aria-label="Insert random value">Random</button>
        </div>

        <!-- Playback controls -->
        <div class="row">
          <button id="step-back" class="secondary" aria-label="Step back">◀ Step</button>
          <button id="play-pause" aria-label="Play">▶ Play</button>
          <button id="step-forward" class="secondary" aria-label="Step forward">Step ▶</button>
          <button id="reset-btn" class="secondary" aria-label="Reset tree">Reset</button>
        </div>

        <div class="row">
          <label class="small">Speed</label>
          <input id="speed" class="slider" type="range" min="200" max="1600" step="100" value="800" aria-label="Animation speed (ms)" />
          <div class="small" id="speed-label">800 ms</div>
        </div>

        <div class="hint-box" id="summary-box" aria-live="polite">
          <strong>Learning objective:</strong>
          After interacting you will be able to predict how a Red-Black Tree restores properties when inserting a node — which cases cause recoloring vs rotations, and why the root becomes black.
        </div>

        <!-- Interaction & layout description (as requested) -->
        <details open style="background:transparent;border:none;">
          <summary style="font-weight:600;margin-top:6px;cursor:pointer;">Interaction Design (how to use)</summary>
          <div style="margin-top:8px;color:var(--muted);font-size:0.92rem;line-height:1.4;">
            - Type a numeric value and press Insert (or Random) to add a new node.<br/>
            - Each insertion generates an ordered list of internal steps (insert node → recolor/rotate steps → final root recolor).<br/>
            - Use Step ▶ / ◀ Step to walk the algorithm step-by-step, or Play to animate through steps automatically.<br/>
            - Visual feedback: nodes animate to their computed positions; recoloring and edges update smoothly. Each rotation is labeled in the step info so you can connect code cases to the visuals.<br/>
            - Accessibility: all controls are keyboard focusable; aria-live announcements announce step explanations.
          </div>
        </details>

        <details style="background:transparent;border:none;">
          <summary style="font-weight:600;cursor:pointer;">Layout Description</summary>
          <div style="margin-top:8px;color:var(--muted);font-size:0.92rem;line-height:1.4;">
            Spatial organization:
            <ul style="margin:8px 0 0 18px;padding:0;">
              <li>Left column (controls): fixed-width panel with input, playback buttons, speed, and explanations.</li>
              <li>Right column (canvas): flexible SVG area that renders the tree, legend and a step info bar at top.</li>
            </ul>
            Spacing & responsiveness:
            <ul style="margin:8px 0 0 18px;padding:0;">
              <li>Safe area: 24px of padding around the viewport (as required).</li>
              <li>All UI groups use a minimum gap of 16px to keep controls distinct and tappable.</li>
              <li>Responsive: on narrow viewports the layout stacks vertically; SVG scales to container width.</li>
            </ul>
          </div>
        </details>
      </section>

      <!-- Canvas & visualization -->
      <section class="canvas-panel" aria-labelledby="canvas-title">
        <div class="canvas-header">
          <div>
            <div id="canvas-title" class="canvas-title">Tree Visualization</div>
            <div class="canvas-sub">Nodes animate into position; colors indicate node color (red/black).</div>
          </div>
          <div class="legend" aria-hidden="true">
            <div class="item"><span class="dot" style="background:#ef4444;border:1px solid rgba(0,0,0,0.06)"></span> Red node</div>
            <div class="item"><span class="dot" style="background:#0f172a"></span> Black node</div>
            <div class="item node-label" style="margin-left:6px;">Hover nodes to highlight parent/child</div>
          </div>
        </div>

        <div class="svg-wrap" id="svg-wrap" role="img" aria-label="Red-Black tree visualization">
          <svg id="svg" viewBox="0 0 1000 600" preserveAspectRatio="xMidYMid meet" tabindex="0"></svg>
        </div>

        <div class="step-info">
          <div class="small" id="step-desc">No operations yet — insert a value to begin.</div>
          <div class="small" id="node-count">Nodes: 0</div>
        </div>
      </section>
    </main>
  </div>

  <script>
    /********************************************************************
     * Red-Black Tree Interactive — Single-file implementation
     * Focus: Demonstrate insertion and rebalancing (recolor & rotations)
     * No external libraries. Vanilla JS, inline SVG, accessibility hints.
     ********************************************************************/

    /**********************
     * Utility & state
     **********************/
    const svg = document.getElementById('svg');
    const wrap = document.getElementById('svg-wrap');
    const insertBtn = document.getElementById('insert-btn');
    const randomBtn = document.getElementById('random-btn');
    const resetBtn = document.getElementById('reset-btn');
    const stepFwdBtn = document.getElementById('step-forward');
    const stepBackBtn = document.getElementById('step-back');
    const playPauseBtn = document.getElementById('play-pause');
    const valueInput = document.getElementById('value-input');
    const speedInput = document.getElementById('speed');
    const speedLabel = document.getElementById('speed-label');
    const stepDesc = document.getElementById('step-desc');
    const nodeCount = document.getElementById('node-count');
    const summaryBox = document.getElementById('summary-box');

    let speed = parseInt(speedInput.value, 10);
    speedLabel.textContent = speed + ' ms';

    speedInput.addEventListener('input', () => {
      speed = parseInt(speedInput.value, 10);
      speedLabel.textContent = speed + ' ms';
    });

    // Unique id generator for nodes (keeps persistent ids across snapshots)
    let nextId = 1;
    function makeId(){ return nextId++; }

    /**********************
     * Red-Black Tree model
     **********************/
    class RBNode {
      constructor(value){
        this.id = makeId();
        this.value = value;
        this.left = null;
        this.right = null;
        this.parent = null;
        this.color = 'R'; // new nodes start red
      }
    }

    class RBTree {
      constructor(){
        this.root = null;
      }

      // Helper: standard BST insert, returns the newly inserted node
      bstInsert(value){
        const z = new RBNode(value);
        let y = null;
        let x = this.root;
        while (x !== null){
          y = x;
          if (z.value < x.value) x = x.left;
          else x = x.right;
        }
        z.parent = y;
        if (y === null){
          this.root = z;
        } else if (z.value < y.value){
          y.left = z;
        } else {
          y.right = z;
        }
        return z;
      }

      // rotate left at node x
      rotateLeft(x){
        const y = x.right;
        if (!y) return;
        x.right = y.left;
        if (y.left) y.left.parent = x;
        y.parent = x.parent;
        if (x.parent === null){
          this.root = y;
        } else if (x === x.parent.left){
          x.parent.left = y;
        } else {
          x.parent.right = y;
        }
        y.left = x;
        x.parent = y;
      }

      // rotate right at node x
      rotateRight(x){
        const y = x.left;
        if (!y) return;
        x.left = y.right;
        if (y.right) y.right.parent = x;
        y.parent = x.parent;
        if (x.parent === null){
          this.root = y;
        } else if (x === x.parent.right){
          x.parent.right = y;
        } else {
          x.parent.left = y;
        }
        y.right = x;
        x.parent = y;
      }

      // Insert with RB fixup, but capture intermediate steps via callback
      insertWithSteps(value, stepCallback){
        // check for duplicates
        if (this.find(value)) {
          stepCallback(this.snapshot('duplicate', `Value ${value} already exists (ignored)`));
          return;
        }
        const z = this.bstInsert(value);
        stepCallback(this.snapshot('insert', `Inserted ${z.value} as red`));

        // fixup
        while (z !== this.root && z.parent.color === 'R'){
          const p = z.parent;
          const g = p.parent;
          if (!g) break; // safety

          if (p === g.left){
            const y = g.right; // uncle
            if (y && y.color === 'R'){ // case 1: uncle red
              p.color = 'B';
              y.color = 'B';
              g.color = 'R';
              stepCallback(this.snapshot('recolor', `Case 1: recolor parent (${p.value}) and uncle (${y.value}) to BLACK; grandparent (${g.value}) to RED`));
              z = g;
            } else {
              if (z === p.right){ // case 2: left-right
                // convert to case 3
                stepCallback(this.snapshot('rotate-left', `Case 2: rotateLeft at parent (${p.value})`));
                this.rotateLeft(p);
                stepCallback(this.snapshot('rotated', `After rotateLeft at ${p.value}`));
                // now z becomes p
                // adjust references: in our loop we'll treat z as p (the previous z's parent)
                z = p;
              }
              // case 3: left-left
              p.color = 'B';
              g.color = 'R';
              stepCallback(this.snapshot('rotate-right', `Case 3: rotateRight at grandparent (${g.value}); recolor parent (${p.value}) BLACK, grandparent RED`));
              this.rotateRight(g);
              stepCallback(this.snapshot('rotated', `After rotateRight at ${g.value}`));
            }
          } else {
            // symmetric: p is right child
            const y = g.left;
            if (y && y.color === 'R'){
              p.color = 'B';
              y.color = 'B';
              g.color = 'R';
              stepCallback(this.snapshot('recolor', `Case 1: recolor parent (${p.value}) and uncle (${y.value}) to BLACK; grandparent (${g.value}) to RED`));
              z = g;
            } else {
              if (z === p.left){
                stepCallback(this.snapshot('rotate-right', `Case 2: rotateRight at parent (${p.value})`));
                this.rotateRight(p);
                stepCallback(this.snapshot('rotated', `After rotateRight at ${p.value}`));
                z = p;
              }
              p.color = 'B';
              g.color = 'R';
              stepCallback(this.snapshot('rotate-left', `Case 3: rotateLeft at grandparent (${g.value}); recolor parent (${p.value}) BLACK, grandparent RED`));
              this.rotateLeft(g);
              stepCallback(this.snapshot('rotated', `After rotateLeft at ${g.value}`));
            }
          }
        }

        // ensure root is black
        if (this.root.color !== 'B'){
          this.root.color = 'B';
          stepCallback(this.snapshot('recolor-root', `Root recolored to BLACK (final)`));
        } else {
          stepCallback(this.snapshot('done', `Insertion complete`));
        }
      }

      // find by value
      find(value){
        let x = this.root;
        while (x){
          if (value === x.value) return x;
          x = value < x.value ? x.left : x.right;
        }
        return null;
      }

      // produce a snapshot data object describing current nodes and highlight
      snapshot(type='state', note=''){
        // produce nodes array with ids, value, color, parentId
        const nodes = [];
        (function traverse(n){
          if (!n) return;
          nodes.push({
            id: n.id,
            value: n.value,
            color: n.color,
            parent: n.parent ? n.parent.id : null,
            left: n.left ? n.left.id : null,
            right: n.right ? n.right.id : null
          });
          traverse(n.left);
          traverse(n.right);
        })(this.root);

        return {
          type,
          note,
          nodes,
          rootId: this.root ? this.root.id : null,
          timestamp: Date.now()
        };
      }

      // clear tree
      clear(){
        this.root = null;
      }
    }

    /**********************
     * Visualization
     **********************/
    let model = new RBTree();
    let history = []; // snapshots
    let currentStep = -1;
    let playing = false;
    let playTimer = null;

    // Render snapshot to SVG
    function renderSnapshot(snapshot){
      // Clear SVG children
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      if (!snapshot || !snapshot.nodes || snapshot.nodes.length === 0){
        stepDesc.textContent = snapshot && snapshot.note ? snapshot.note : 'No nodes';
        nodeCount.textContent = 'Nodes: 0';
        return;
      }

      // Build a map of nodes
      const nodesById = new Map();
      snapshot.nodes.forEach(n => nodesById.set(n.id, Object.assign({}, n)));

      // Build tree structure (for computing depth and inorder)
      // Find root
      const rootId = snapshot.rootId;
      const root = rootId ? nodesById.get(rootId) : null;

      // compute depth and inorder index
      const positions = new Map(); // id -> {x,y,depth,order}
      let order = 0;
      const levelHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--level-height')) || 90;
      function dfsAssign(n, depth){
        if (!n) return;
        const left = n.left ? nodesById.get(n.left) : null;
        const right = n.right ? nodesById.get(n.right) : null;
        dfsAssign(left, depth+1);
        positions.set(n.id, {order: order++, depth});
        dfsAssign(right, depth+1);
      }
      dfsAssign(root, 0);

      // compute SVG width based on order
      const hSpacing = 70; // horizontal spacing between inorder positions
      const minWidth = 440;
      const width = Math.max(minWidth, (order + 1) * hSpacing + 120);
      const depthMax = Math.max(...Array.from(positions.values()).map(p => p.depth), 0);
      const height = Math.max(320, (depthMax + 2) * levelHeight + 60);

      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);

      // compute absolute coordinates
      positions.forEach((p, id) => {
        const x = 60 + p.order * hSpacing;
        const y = 40 + p.depth * levelHeight;
        p.x = x;
        p.y = y;
      });

      // Draw edges first
      snapshot.nodes.forEach(n => {
        if (n.left){
          const p = positions.get(n.id);
          const c = positions.get(n.left);
          drawEdge(p.x, p.y, c.x, c.y);
        }
        if (n.right){
          const p = positions.get(n.id);
          const c = positions.get(n.right);
          drawEdge(p.x, p.y, c.x, c.y);
        }
      });

      // Draw nodes
      snapshot.nodes.forEach(n => {
        const pos = positions.get(n.id);
        drawNode(n, pos.x, pos.y);
      });

      // update textual info
      stepDesc.textContent = snapshot.note || snapshot.type || '';
      nodeCount.textContent = 'Nodes: ' + snapshot.nodes.length;
    }

    // Draw edge line between parent and child
    function drawEdge(x1,y1,x2,y2){
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      const dx = Math.abs(x2 - x1);
      const midX = (x1 + x2) / 2;
      const midY = (y1 + y2) / 2;
      // simple curved path
      const d = `M ${x1} ${y1+18} C ${midX} ${y1+18} ${midX} ${y2-18} ${x2} ${y2-18}`;
      path.setAttribute('d', d);
      path.setAttribute('class','edge');
      svg.appendChild(path);
    }

    // Draw a node as a group with circle and text
    function drawNode(node, x, y){
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class','node-group');
      g.setAttribute('transform', `translate(${x},${y})`);
      g.setAttribute('data-id', node.id);
      g.setAttribute('role','img');
      g.setAttribute('aria-label', `Node ${node.value}, color ${node.color === 'R' ? 'red' : 'black'}`);

      // circle
      const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('r', parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-radius')) || 20);
      c.setAttribute('class','node-circle');
      c.setAttribute('fill', node.color === 'R' ? '#ef4444' : '#0f172a');
      c.setAttribute('stroke', 'rgba(0,0,0,0.08)');
      g.appendChild(c);

      // text
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('class','node-text');
      t.textContent = node.value;
      g.appendChild(t);

      // subtle id label above
      const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
      lbl.setAttribute('class','node-label');
      lbl.setAttribute('y', -28);
      lbl.setAttribute('text-anchor','middle');
      lbl.textContent = `id:${node.id}`;
      g.appendChild(lbl);

      // hover interactions: highlight parent/children edges by changing stroke
      g.addEventListener('mouseenter', () => {
        highlightRelations(node.id, true);
      });
      g.addEventListener('mouseleave', () => {
        highlightRelations(node.id, false);
      });

      svg.appendChild(g);
    }

    function highlightRelations(nodeId, highlight){
      // find edges and node groups to highlight
      const groups = svg.querySelectorAll('.node-group');
      groups.forEach(g => {
        const id = parseInt(g.getAttribute('data-id'),10);
        if (id === nodeId) {
          g.style.transform = 'scale(1.06)';
        } else {
          g.style.transform = 'scale(1)';
        }
      });

      const edges = svg.querySelectorAll('.edge');
      edges.forEach(e => {
        e.classList.toggle('highlight', highlight);
        e.style.opacity = highlight ? '1' : '0.95';
      });
    }

    /**********************
     * History & playback
     **********************/
    function pushSnapshot(snap){
      // append snapshot to history and set current to last
      history.push(snap);
      currentStep = history.length - 1;
      updateButtons();
      renderSnapshot(history[currentStep]);
      announce(snap.note || snap.type);
    }

    function updateButtons(){
      stepBackBtn.disabled = currentStep <= 0;
      stepFwdBtn.disabled = currentStep >= history.length - 1;
      playPauseBtn.textContent = playing ? '⏸ Pause' : '▶ Play';
    }

    function stepForward(){
      if (currentStep < history.length - 1){
        currentStep++;
        renderSnapshot(history[currentStep]);
        announce(history[currentStep].note || history[currentStep].type);
        updateButtons();
      }
    }
    function stepBack(){
      if (currentStep > 0){
        currentStep--;
        renderSnapshot(history[currentStep]);
        announce(history[currentStep].note || history[currentStep].type);
        updateButtons();
      }
    }

    function play(){
      if (playing) return;
      playing = true;
      updateButtons();
      playTimer = setInterval(() => {
        if (currentStep >= history.length - 1){
          pause();
        } else {
          stepForward();
        }
      }, speed);
    }

    function pause(){
      playing = false;
      updateButtons();
      if (playTimer) { clearInterval(playTimer); playTimer = null; }
    }

    function announce(text){
      // update aria-live region (summaryBox) for screen readers
      summaryBox.textContent = 'Learning objective: After interacting you will be able to predict ...\nStep: ' + (text || '');
    }

    /**********************
     * UI event wiring
     **********************/
    insertBtn.addEventListener('click', () => {
      const v = parseInt(valueInput.value, 10);
      if (Number.isNaN(v)){
        valueInput.focus();
        return;
      }
      performInsert(v);
    });

    randomBtn.addEventListener('click', () => {
      const v = Math.floor(Math.random() * 99) + 1;
      valueInput.value = v;
      performInsert(v);
    });

    resetBtn.addEventListener('click', () => {
      pause();
      model = new RBTree();
      history = [];
      currentStep = -1;
      renderSnapshot(null);
      updateButtons();
      stepDesc.textContent = 'Tree cleared.';
      nodeCount.textContent = 'Nodes: 0';
      nextId = 1;
      announce('Tree reset');
    });

    stepFwdBtn.addEventListener('click', () => {
      pause();
      stepForward();
    });
    stepBackBtn.addEventListener('click', () => {
      pause();
      stepBack();
    });

    playPauseBtn.addEventListener('click', () => {
      if (playing) pause();
      else {
        // if no snapshots yet, nothing to play
        if (history.length === 0) {
          announce('No operations to play');
          return;
        }
        play();
      }
    });

    // keyboard: Enter on value input triggers insert
    valueInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter'){ insertBtn.click(); }
    });

    // Insert operation: produce step sequence and push into history
    function performInsert(v){
      pause();
      // We'll capture the tree states in sequence. To keep history navigable, we append
      // the insertion steps to existing history.
      model.insertWithSteps(v, (snap) => {
        // For each snapshot from model, clone nodes to decouple from later mutations
        const cloned = JSON.parse(JSON.stringify(snap));
        history.push(cloned);
      });
      // set current to the last snapshot we just appended
      currentStep = history.length - 1;
      updateButtons();
      renderSnapshot(history[currentStep]);
      announce(history[currentStep].note || history[currentStep].type);
    }

    // initialize with small helper tree
    (function initSample(){
      // optional: seed with a few values to show behavior
      const seeds = [10, 18, 7];
      seeds.forEach(v => model.insertWithSteps(v, (snap) => {
        history.push(JSON.parse(JSON.stringify(snap)));
      }));
      currentStep = history.length - 1;
      renderSnapshot(history[currentStep]);
      updateButtons();
    })();

    // make SVG responsive in wrap
    window.addEventListener('resize', () => {
      // svg uses viewBox so it scales automatically; nothing else needed
    });

    // Provide keyboard shortcuts for convenience: P = play/pause, ] = step forward, [ = step back
    window.addEventListener('keydown', (e) => {
      if (e.key === 'p' || e.key === 'P'){
        playPauseBtn.click();
      } else if (e.key === ']') {
        stepFwdBtn.click();
      } else if (e.key === '[') {
        stepBackBtn.click();
      }
    });

    // Accessibility: make sure interactive elements are spaced >=16px (CSS ensures gap)
    // Announce initial message
    announce('Ready. Insert a value to begin exploring Red-Black Tree insertion.');

  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Red-Black Tree Interactive Application",
  "description": "Models the interactive states and user-driven transitions for a Red-Black Tree insertion & rebalancing visualizer (controls, playback, insert processing, snapshots, hover highlights, reset).",
  "states": [
    {
      "name": "initializing",
      "onEnter": "initSample",
      "onExit": "renderCurrentSnapshot",
      "on": {
        "INIT_COMPLETE": "viewing"
      }
    },
    {
      "name": "idle",
      "description": "No pending playback; ready for user input. Usually when there are no snapshots (empty tree) or playback is stopped and user hasn't navigated.",
      "onEnter": "renderEmptyOrCurrent; updateButtons; announceReady",
      "on": {
        "INSERT_CLICK": "inserting",
        "RANDOM_CLICK": "inserting",
        "RESET_CLICK": "resetting",
        "PLAY_TOGGLE": "playing",
        "STEP_FORWARD": "viewing",
        "STEP_BACK": "viewing",
        "SPEED_CHANGE": "idle",
        "INPUT_ENTER": "inserting",
        "HOVER_ENTER": "hovering",
        "HOVER_EXIT": "idle",
        "KEY_PRESS_PLAY": "playing",
        "KEY_PRESS_STEP_FORWARD": "viewing",
        "KEY_PRESS_STEP_BACK": "viewing"
      }
    },
    {
      "name": "inserting",
      "onEnter": "performInsert(v) ; pausePlayback",
      "onExit": "updateButtons; renderCurrentSnapshot; announceCurrentStep",
      "on": {
        "INSERT_COMPLETE": "viewing",
        "DUPLICATE_DETECTED": "viewing",
        "RESET_CLICK": "resetting",
        "SPEED_CHANGE": "inserting",
        "HOVER_ENTER": "hovering"
      }
    },
    {
      "name": "viewing",
      "description": "Viewing a particular snapshot from history. Step navigation is enabled. This is the normal non-playing view.",
      "onEnter": "renderCurrentSnapshot; updateButtons; announceCurrentStep",
      "onExit": "updateButtons",
      "on": {
        "STEP_FORWARD": "viewing",
        "STEP_BACK": "viewing",
        "PLAY_TOGGLE": "playing",
        "INSERT_CLICK": "inserting",
        "RANDOM_CLICK": "inserting",
        "RESET_CLICK": "resetting",
        "SPEED_CHANGE": "viewing",
        "HOVER_ENTER": "hovering",
        "HOVER_EXIT": "viewing",
        "KEY_PRESS_PLAY": "playing",
        "KEY_PRESS_STEP_FORWARD": "viewing",
        "KEY_PRESS_STEP_BACK": "viewing"
      }
    },
    {
      "name": "playing",
      "onEnter": "startPlayTimer",
      "onExit": "stopPlayTimer",
      "on": {
        "TIMER_TICK": "viewing",
        "PLAY_COMPLETE": "viewing",
        "PLAY_TOGGLE": "viewing",
        "STEP_FORWARD": "viewing",
        "STEP_BACK": "viewing",
        "INSERT_CLICK": "inserting",
        "RANDOM_CLICK": "inserting",
        "RESET_CLICK": "resetting",
        "SPEED_CHANGE": "playing",
        "HOVER_ENTER": "hovering"
      }
    },
    {
      "name": "resetting",
      "onEnter": "pausePlayback; clearTree; resetIds; clearHistory",
      "onExit": "renderEmptyOrCurrent; updateButtons; announce('Tree reset')",
      "on": {
        "INIT_COMPLETE": "viewing",
        "RESET_COMPLETE": "idle",
        "INSERT_CLICK": "inserting",
        "RANDOM_CLICK": "inserting"
      }
    },
    {
      "name": "hovering",
      "description": "Transient state triggered by pointer hover over a node; highlights relations in the visualization.",
      "onEnter": "highlightRelations(nodeId, true)",
      "onExit": "highlightRelations(nodeId, false)",
      "on": {
        "HOVER_EXIT": "viewing",
        "RESET_CLICK": "resetting",
        "PLAY_TOGGLE": "playing",
        "STEP_FORWARD": "viewing",
        "STEP_BACK": "viewing"
      }
    }
  ],
  "events": [
    "INIT_COMPLETE",
    "INSERT_CLICK",
    "RANDOM_CLICK",
    "INPUT_ENTER",
    "STEP_FORWARD",
    "STEP_BACK",
    "PLAY_TOGGLE",
    "PLAY_START",
    "PLAY_STOP",
    "TIMER_TICK",
    "PLAY_COMPLETE",
    "RESET_CLICK",
    "RESET_COMPLETE",
    "SPEED_CHANGE",
    "HOVER_ENTER",
    "HOVER_EXIT",
    "KEY_PRESS_PLAY",
    "KEY_PRESS_STEP_FORWARD",
    "KEY_PRESS_STEP_BACK",
    "INSERT_COMPLETE",
    "DUPLICATE_DETECTED",
    "WINDOW_RESIZE"
  ],
  "notes": "Key onEnter/onExit actions map to concrete functions in the code: initSample (seeds initial snapshots), performInsert(v) calls model.insertWithSteps and pushes snapshots into history, renderCurrentSnapshot renders history[currentStep], startPlayTimer/stopPlayTimer control setInterval used for playback (interval uses current 'speed' ms), pausePlayback clears the play timer, clearTree resets the RBTree and history and nextId. Hovering is modeled as a transient state that highlights relations. The implementation generates snapshots synchronously during insertWithSteps (including duplicate snapshots) so 'inserting' completes immediately to 'viewing' after snapshots are appended. The PLAY_TOGGLE action checks history length in code: if history is empty the UI announces 'No operations to play' and remains in viewing/idle; the FSM models PLAY_TOGGLE as transitioning to 'playing' presuming history exists."
}
  </script>
</body>
</html>