<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Graph: Directed vs Undirected — Interactive Module</title>
  <style>
    :root{
      --safe-margin:24px;
      --gap:16px;
      --bg:#0f1722;
      --panel:#071028;
      --accent:#06b6d4;
      --muted:#94a3b8;
      --card:#0b1220;
      --success:#10b981;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.03);
      --radius:10px;
      --text:#e6eef7;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Segoe UI Mono", monospace;
    }

    /* Page safe area and basic typography */
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#071126 0%, #06101a 100%);
      color:var(--text);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:var(--safe-margin);
      box-sizing:border-box;
    }

    /* Layout container */
    .module{
      display:flex;
      gap:var(--gap);
      align-items:stretch;
      min-height:calc(100vh - calc(var(--safe-margin)*2));
    }

    /* Left: interactive canvas */
    .canvas-panel{
      flex:1;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:var(--gap);
      min-width:320px;
      position:relative;
      overflow:hidden;
      box-shadow: 0 8px 24px rgba(2,6,23,0.6);
      border:1px solid rgba(255,255,255,0.03);
    }

    .canvas-header{
      display:flex;
      justify-content:space-between;
      gap:var(--gap);
      align-items:center;
      margin-bottom:12px;
    }

    .title{
      font-size:18px;
      font-weight:600;
      color:var(--text);
    }
    .subtitle{
      font-size:13px;
      color:var(--muted);
    }

    /* Graph area (relative) */
    .graph-area{
      position:relative;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:8px;
      flex:1;
      min-height:480px;
      overflow:hidden;
      outline: 2px dashed rgba(255,255,255,0.02);
    }

    /* SVG overlay spans full area */
    svg.graph-svg{
      position:absolute;
      left:0; top:0;
      width:100%; height:100%;
      pointer-events:none; /* edges drawn via svg but interactive via HTML elements */
    }

    /* Node elements (HTML overlay) */
    .node{
      position:absolute;
      width:44px;
      height:44px;
      border-radius:50%;
      background:linear-gradient(180deg,#012e3a,#00394d);
      border:2px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--text);
      font-weight:600;
      cursor:grab;
      user-select:none;
      box-shadow:0 6px 18px rgba(2,6,23,0.6);
      transition:transform 150ms ease, box-shadow 150ms ease;
      z-index:2;
      min-width:44px;
      min-height:44px;
    }
    .node:active{ cursor:grabbing; }
    .node:hover{ transform:scale(1.04); box-shadow:0 10px 26px rgba(2,6,23,0.7); }

    .node.selected{
      outline:3px solid rgba(6,182,212,0.14);
      box-shadow: 0 14px 34px rgba(3,9,15,0.6);
      transform:scale(1.06);
    }

    .node-label{
      font-size:14px;
      pointer-events:none;
    }

    /* Controls panel */
    .controls{
      width:360px;
      max-width:40%;
      min-width:300px;
      background:var(--panel);
      border-radius:var(--radius);
      padding:var(--gap);
      box-shadow: 0 8px 24px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      border:1px solid rgba(255,255,255,0.03);
    }

    .controls h3{
      margin:0;
      font-size:15px;
      color:var(--text);
    }
    .controls p{ margin:0; color:var(--muted); font-size:13px; }

    .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }

    button, .toggle{
      background:linear-gradient(180deg,#052033,#02202a);
      color:var(--text);
      border:1px solid rgba(255,255,255,0.04);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
    }
    button.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      font-weight:500;
    }
    .toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
    }

    .switch{
      width:48px;
      height:28px;
      background:#0b1220;
      border-radius:999px;
      display:inline-flex;
      align-items:center;
      padding:4px;
      transition:background 180ms ease;
    }
    .knob{
      width:20px; height:20px; border-radius:999px; background:linear-gradient(180deg,#08b8cf,#018b9b);
      transform:translateX(0);
      transition:transform 180ms ease, box-shadow 180ms ease;
      box-shadow:0 4px 10px rgba(2,6,23,0.6);
    }
    .switch.on{ background: linear-gradient(90deg,#08303a,#023b45); }
    .switch.on .knob{ transform:translateX(20px); }

    .muted-note{ font-size:13px; color:var(--muted); }

    /* Panel boxes */
    .box{
      background:var(--card);
      padding:12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.02);
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    /* Matrix table */
    .matrix{
      overflow:auto;
      max-height:180px;
      min-width:240px;
      border-radius:8px;
    }
    table{
      border-collapse:collapse;
      width:100%;
      font-family:var(--mono);
      font-size:13px;
      color:var(--muted);
    }
    th,td{
      padding:6px;
      text-align:center;
      border:1px solid rgba(255,255,255,0.02);
      min-width:36px;
    }
    th{
      background:rgba(255,255,255,0.02);
      color:var(--muted);
      font-weight:600;
    }
    td.cell-on{
      background:linear-gradient(90deg, rgba(6,182,212,0.08), rgba(6,182,212,0.03));
      color:var(--accent);
      transition:background 220ms ease;
    }
    td.flash{
      animation:flash 700ms ease;
    }
    @keyframes flash{
      0%{ background:rgba(6,182,212,0.25); transform:scale(1.02); }
      100%{ background:transparent; transform:scale(1); }
    }

    /* adjacency list */
    .alist-item{ display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .badge{
      background:#022733;
      padding:6px 8px;
      border-radius:8px;
      color:var(--muted);
      font-size:13px;
      border:1px solid rgba(255,255,255,0.02);
    }

    /* Small helper */
    .hint{ font-size:13px; color:var(--muted); }

    /* Responsive */
    @media (max-width:900px){
      .module{ flex-direction:column; }
      .controls{ width:100%; max-width:none; min-width:unset; }
    }
  </style>
</head>
<body>

  <!-- Explanation & Plan -->
  <div style="max-width:1200px; margin:0 auto 18px auto; color:var(--muted);">
    <div style="background:transparent; padding:12px 0;">
      <div style="font-weight:700; color:var(--text); font-size:20px; margin-bottom:6px;">
        Concept: Graph (Directed vs Undirected)
      </div>
      <div style="font-size:14px;">
        This interactive module demonstrates the difference between directed and undirected graphs through hands-on construction,
        visualization, and live adjacency representations (matrix & list). Create nodes and edges, toggle the graph mode,
        and observe how edge directionality changes adjacency, degrees, and visuals.
      </div>
    </div>

    <!-- Learning objective -->
    <div style="display:flex; gap:20px; margin-top:12px; flex-wrap:wrap;">
      <div style="background:var(--card); padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.02);">
        <strong>Learning Objective</strong>
        <div style="color:var(--muted); margin-top:6px; max-width:680px;">
          After interacting with this module, you will understand:
          - The visual and structural difference between directed and undirected edges.
          - How edge orientation affects adjacency matrix symmetry and degree calculations (degree vs in-/out-degree).
          - How the same set of nodes can represent different connectivity depending on directionality.
        </div>
      </div>

      <div style="background:var(--card); padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.02);">
        <strong>Interaction Design</strong>
        <div style="color:var(--muted); margin-top:6px; max-width:680px;">
          - Click anywhere in the graph area to add a node. Nodes are draggable.
          - Enter "Add Edge" mode, then click a source node and a target node to create an edge.
            In directed mode an arrow is created (source → target); in undirected mode a single undirected edge appears.
          - Toggle the "Directed" switch to see all edges update their appearance and how the adjacency matrix/list changes.
          - Select a node to inspect its degree (undirected) or in-/out-degree (directed). Clicking adjacency matrix cells toggles edges.
          - Visual feedback: edges animate when created, arrowheads fade in for directed edges, table cells briefly flash on edge toggles, and connected edges highlight on node selection.
        </div>
      </div>

      <div style="background:var(--card); padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.02);">
        <strong>Layout Description</strong>
        <div style="color:var(--muted); margin-top:6px; max-width:680px;">
          - Safe area margins: 24px around the viewport (enforced by body padding).
          - The module uses a two-column layout: left is the interactive graph canvas (flex:1), right is the controls panel (fixed width ≈360px).
          - Minimum spacing of 16px between interactive elements (implemented via CSS variables).
          - Accessibility & responsiveness: clear focus states, large enough touch targets, keyboard-compatible controls for toggles/buttons, and a responsive single-column stacking on narrow screens.
        </div>
      </div>
    </div>
  </div>

  <!-- Interactive Module -->
  <div class="module" role="application" aria-label="Graph directed vs undirected interactive module" style="max-width:1200px; margin:0 auto;">
    <!-- Left: Canvas -->
    <div class="canvas-panel" aria-label="Graph area">
      <div class="canvas-header">
        <div>
          <div class="title">Interactive Graph Builder</div>
          <div class="subtitle">Click to add nodes • Drag to reposition • Add edges to connect</div>
        </div>
        <div class="muted-note">Tip: Click an adjacency table cell to toggle an edge</div>
      </div>

      <div class="graph-area" id="graphArea" tabindex="0" aria-describedby="graphInstructions">
        <div id="graphInstructions" style="position:absolute; left:12px; top:12px; z-index:3; color:var(--muted); font-size:13px;">
          Double-click to add a node quickly — or click once then press "Add Node" button.
        </div>

        <!-- SVG for edges/markers -->
        <svg class="graph-svg" id="graphSvg" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <defs>
            <marker id="arrow" markerWidth="8" markerHeight="8" refX="8" refY="4" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L8,4 L0,8 z" fill="#06b6d4"></path>
            </marker>
            <marker id="arrow-dark" markerWidth="8" markerHeight="8" refX="8" refY="4" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L8,4 L0,8 z" fill="#08303a" opacity="0.9"></path>
            </marker>
          </defs>
          <g id="edgesGroup"></g>
        </svg>
      </div>
    </div>

    <!-- Right: Controls -->
    <aside class="controls" aria-label="Controls panel">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <div>
          <h3>Controls</h3>
          <div class="hint">Build and inspect directed vs undirected connections</div>
        </div>
      </div>

      <div class="box" aria-label="Modes">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="display:flex; gap:8px; flex-direction:column;">
            <div style="font-weight:700;">Mode</div>
            <div class="muted-note">Switch between directed and undirected</div>
          </div>
          <div class="toggle" id="modeToggle" role="switch" aria-checked="false" tabindex="0">
            <div class="switch" id="switchKnob" aria-hidden="true">
              <div class="knob"></div>
            </div>
            <div style="font-size:13px; color:var(--muted);" id="modeLabel">Undirected</div>
          </div>
        </div>

        <div style="display:flex; gap:12px; margin-top:10px; flex-wrap:wrap;">
          <button id="addNodeBtn" title="Add Node (then click canvas to place)">Add Node</button>
          <button id="addEdgeBtn" class="secondary">Add Edge</button>
          <button id="clearBtn" class="secondary">Clear</button>
          <button id="sampleBtn" class="secondary">Sample Graph</button>
        </div>
      </div>

      <div class="box" aria-label="Selection info">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700;">Selected</div>
          <div class="muted-note" id="selectedName">None</div>
        </div>
        <div id="degreeBox" style="color:var(--muted); font-size:13px; margin-top:6px;">
          Select a node to see degree info.
        </div>
      </div>

      <div class="box" aria-label="Adjacency representations">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700;">Adjacency Matrix</div>
          <div class="muted-note">Click cells to toggle edges</div>
        </div>
        <div class="matrix" id="matrixWrap" aria-live="polite" style="margin-top:8px;"></div>

        <div style="margin-top:12px; display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700;">Adjacency List</div>
          <div style="font-size:13px; color:var(--muted);">Live</div>
        </div>
        <div id="alist" style="margin-top:8px; color:var(--muted); font-size:13px;"></div>
      </div>

      <div class="box" style="background:linear-gradient(180deg,#041421,#02121a);" aria-hidden="false">
        <div style="font-weight:700; color:var(--muted);">Legend & Tips</div>
        <div style="margin-top:8px; color:var(--muted); font-size:13px;">
          - Directed: edges show an arrow (A → B). Matrix may be asymmetric. Degrees split to in/out.<br>
          - Undirected: edges have no arrow. Matrix is symmetric and degree is single value.<br>
          - Use drag to inspect how edges follow nodes. Nodes are labeled sequentially when created.
        </div>
      </div>

    </aside>
  </div>

  <script>
    /*****************************************************************
     * Interactive Graph Module
     * Vanilla JS, single-file, no external assets/libraries.
     *****************************************************************/

    (function(){
      // Safe spacing constants used in styling and JS interactions
      const MIN_GAP = 16;

      // DOM refs
      const graphArea = document.getElementById('graphArea');
      const graphSvg = document.getElementById('graphSvg');
      const edgesGroup = document.getElementById('edgesGroup');
      const addNodeBtn = document.getElementById('addNodeBtn');
      const addEdgeBtn = document.getElementById('addEdgeBtn');
      const clearBtn = document.getElementById('clearBtn');
      const sampleBtn = document.getElementById('sampleBtn');
      const modeToggle = document.getElementById('modeToggle');
      const switchKnob = document.getElementById('switchKnob');
      const modeLabel = document.getElementById('modeLabel');
      const matrixWrap = document.getElementById('matrixWrap');
      const alist = document.getElementById('alist');
      const selectedName = document.getElementById('selectedName');
      const degreeBox = document.getElementById('degreeBox');

      // State
      let nodes = []; // {id, x, y, label, el}
      let edges = []; // {id, sourceId, targetId, directed}
      let directedMode = false;
      let nextNodeId = 1;
      let addingEdge = false;
      let pendingSource = null;
      let selectedNode = null;
      let placeMode = false; // "Add Node" button pressed; next click places node
      let graphRect = null;

      // Helpers
      function uid(prefix='e'){ return prefix + Math.random().toString(36).slice(2,9); }

      // Use computed client rect for coordinate conversions
      function updateGraphRect(){
        graphRect = graphArea.getBoundingClientRect();
      }
      window.addEventListener('resize', updateGraphRect);
      updateGraphRect();

      // Create node element at x,y relative to graphArea
      function createNodeAt(x,y,label){
        const id = 'n'+nextNodeId++;
        const el = document.createElement('div');
        el.className = 'node';
        el.setAttribute('data-id', id);
        el.setAttribute('role','button');
        el.setAttribute('aria-label','Node '+(label||id));
        el.tabIndex = 0;

        const lbl = document.createElement('div');
        lbl.className = 'node-label';
        lbl.textContent = label || id;
        el.appendChild(lbl);

        // Position
        el.style.left = (x - 22) + 'px';
        el.style.top = (y - 22) + 'px';

        // Add to DOM
        graphArea.appendChild(el);

        // Store node
        const node = { id, x, y, label: label || id, el };
        nodes.push(node);

        // Interactivity: drag, click, keyboard
        attachNodeEvents(node);

        // Rerender adjacency/matrix
        renderAll();

        return node;
      }

      function attachNodeEvents(node){
        const el = node.el;
        let dragging = false;
        let offset = {x:0,y:0};

        function onPointerDown(e){
          e.preventDefault();
          if (e.button !== undefined && e.button !== 0) return;
          dragging = true;
          el.classList.add('selected');
          selectNode(node.id);
          const rect = el.getBoundingClientRect();
          offset.x = e.clientX - rect.left;
          offset.y = e.clientY - rect.top;
          el.setPointerCapture && el.setPointerCapture(e.pointerId);
        }

        function onPointerMove(e){
          if (!dragging) return;
          let nx = e.clientX - graphRect.left - offset.x;
          let ny = e.clientY - graphRect.top - offset.y;
          // Keep inside bounds with margin MIN_GAP
          nx = Math.max(0, Math.min(graphRect.width - el.offsetWidth, nx));
          ny = Math.max(0, Math.min(graphRect.height - el.offsetHeight, ny));
          el.style.left = nx + 'px';
          el.style.top = ny + 'px';
          node.x = nx + el.offsetWidth/2;
          node.y = ny + el.offsetHeight/2;
          // Update edges visually
          updateEdgesPositions(node.id);
        }

        function onPointerUp(e){
          if (dragging){
            dragging = false;
            el.classList.remove('selected');
            el.releasePointerCapture && el.releasePointerCapture(e.pointerId);
          }
        }

        // Click for selection or edge creation
        el.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);

        // Single click handling (pointerup to allow drag)
        el.addEventListener('click', function(ev){
          ev.stopPropagation();
          // If adding edge mode: choose source/target
          if (addingEdge){
            if (!pendingSource){
              pendingSource = node;
              highlightNode(node.id,true);
            } else {
              if (pendingSource.id === node.id){
                // Self-loop prevented
                flashNotice('Self-loops are not supported in this demo.');
                highlightNode(pendingSource.id,false);
                pendingSource = null;
                return;
              }
              createEdge(pendingSource.id, node.id, directedMode);
              highlightNode(pendingSource.id,false);
              pendingSource = null;
              addingEdge = false;
              addEdgeBtn.classList.remove('active');
              addEdgeBtn.textContent = 'Add Edge';
            }
            return;
          }

          // Normal selection
          selectNode(node.id);
        });

        // Keyboard accessible: Enter to select
        el.addEventListener('keydown', function(ev){
          if (ev.key === 'Enter'){
            el.click();
          }
        });
      }

      function highlightNode(nodeId, on){
        const n = nodes.find(n=>n.id===nodeId);
        if (!n) return;
        if (on) n.el.classList.add('selected');
        else n.el.classList.remove('selected');
      }

      function selectNode(nodeId){
        // Deselect previous
        if (selectedNode && selectedNode.id === nodeId) {
          // toggle off
          selectedNode = null;
          selectedName.textContent = 'None';
          degreeBox.textContent = 'Select a node to see degree info.';
          renderAll();
          return;
        }
        selectedNode = nodes.find(n=>n.id===nodeId) || null;
        selectedName.textContent = selectedNode ? selectedNode.label : 'None';
        renderAll();
        updateDegreeInfo();
      }

      // Create an edge between nodes (IDs)
      function createEdge(srcId, tgtId, directed=true, opts={}){
        // Prevent duplicates for undirected: only one edge between pair
        if (!directed){
          const exists = edges.find(e => {
            if (e.directed) return false;
            return (e.sourceId===srcId && e.targetId===tgtId) || (e.sourceId===tgtId && e.targetId===srcId);
          });
          if (exists) {
            flashMatrixCells([srcId,tgtId]);
            return;
          }
        } else {
          // For directed edges, allow duplicate both directions but prevent exact duplicate
          const exists = edges.find(e => e.directed && e.sourceId===srcId && e.targetId===tgtId);
          if (exists){
            flashMatrixCells([srcId,tgtId]);
            return;
          }
        }

        const id = uid('edge');
        const edge = { id, sourceId: srcId, targetId: tgtId, directed: directed };
        edges.push(edge);
        drawEdge(edge, true);
        renderAll();
      }

      // Draw or redraw all edges
      function drawEdge(edge, animate=false){
        // Remove existing if present
        const existing = edgesGroup.querySelector('[data-id="'+edge.id+'"]');
        if (existing) existing.remove();

        // Coordinates
        const s = nodes.find(n=>n.id===edge.sourceId);
        const t = nodes.find(n=>n.id===edge.targetId);
        if (!s || !t) return;

        const sx = s.x, sy = s.y, tx = t.x, ty = t.y;

        // Create SVG line
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('data-id', edge.id);
        g.setAttribute('aria-hidden','true');

        // For self-loops not allowed, but if they exist fallback to small arc
        if (edge.sourceId === edge.targetId){
          // small loop path
          const p = document.createElementNS('http://www.w3.org/2000/svg','path');
          const r = 24;
          const d = `M ${sx} ${sy} C ${sx+r} ${sy-r} ${sx+r*2} ${sy+r} ${sx} ${sy}`;
          p.setAttribute('d', d);
          p.setAttribute('stroke', edge.directed ? '#06b6d4' : '#7dd3fc');
          p.setAttribute('fill','none');
          p.setAttribute('stroke-width','2');
          p.setAttribute('stroke-linecap','round');
          if (edge.directed) p.setAttribute('marker-end','url(#arrow)');
          g.appendChild(p);
        } else {
          // Draw line from center to center, but shorten to avoid overlapping node circle
          const dx = tx - sx, dy = ty - sy;
          const dist = Math.sqrt(dx*dx + dy*dy);
          const nodeRadius = 22;
          const offsetX = (dx/dist) * nodeRadius;
          const offsetY = (dy/dist) * nodeRadius;
          const x1 = sx + offsetX;
          const y1 = sy + offsetY;
          const x2 = tx - offsetX;
          const y2 = ty - offsetY;

          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', x1);
          line.setAttribute('y1', y1);
          line.setAttribute('x2', x2);
          line.setAttribute('y2', y2);
          line.setAttribute('stroke', edge.directed ? '#06b6d4' : '#7dd3fc');
          line.setAttribute('stroke-width', '2.4');
          line.setAttribute('stroke-linecap','round');
          if (edge.directed){
            line.setAttribute('marker-end','url(#arrow)');
          }
          // For animation: stroke-dasharray trick
          if (animate){
            try {
              const length = Math.hypot(x2-x1,y2-y1);
              line.style.strokeDasharray = length;
              line.style.strokeDashoffset = length;
              line.getBoundingClientRect(); // force layout
              line.style.transition = 'stroke-dashoffset 420ms ease, opacity 420ms ease';
              line.style.opacity = 0;
              setTimeout(()=>{
                line.style.strokeDashoffset = '0';
                line.style.opacity = 1;
              },10);
            } catch(e){}
          }

          g.appendChild(line);

          // If directed, add a transparent arrow path for better visuals (arrow already added via marker)
          if (edge.directed){
            // optionally could add extra small triangle, but marker suffices
          }
        }

        edgesGroup.appendChild(g);
      }

      function updateEdgesPositions(nodeId){
        // update all edges connected to nodeId
        edges.forEach(e=>{
          if (e.sourceId === nodeId || e.targetId === nodeId){
            drawEdge(e, false);
          }
        });
      }

      function renderAll(){
        // Re-draw all edges
        edgesGroup.innerHTML = '';
        edges.forEach(e => drawEdge(e, false));
        // Update adjacency representations
        renderMatrix();
        renderAdjList();
        // Highlight edges connected to selected node
        highlightConnected();
      }

      function highlightConnected(){
        // Add subtle highlight for connected edges and nodes
        // Clear previous
        nodes.forEach(n => n.el.style.opacity = '1');
        const edgeGroups = edgesGroup.querySelectorAll('g');
        edgeGroups.forEach(g => g.style.opacity = '0.9');

        if (!selectedNode) return;
        nodes.forEach(n => {
          const connected = edges.some(e => 
            (!directedMode && ((e.sourceId===n.id && e.targetId===selectedNode.id) || (e.targetId===n.id && e.sourceId===selectedNode.id))) ||
            (directedMode && (e.sourceId===n.id && e.targetId===selectedNode.id || e.sourceId===selectedNode.id && e.targetId===n.id))
          );
          if (!connected && n.id!==selectedNode.id) n.el.style.opacity = '0.45';
        });

        edgeGroups.forEach(g=>{
          const id = g.getAttribute('data-id');
          const e = edges.find(ed=>ed.id===id);
          if (!e) return;
          const connected = e.sourceId===selectedNode.id || e.targetId===selectedNode.id;
          g.style.opacity = connected ? '1' : '0.25';
        });
      }

      // Adjacency matrix rendering
      function renderMatrix(){
        matrixWrap.innerHTML = '';
        if (nodes.length === 0) {
          matrixWrap.innerHTML = '<div class="muted-note">No nodes yet.</div>';
          return;
        }
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headerRow.appendChild(document.createElement('th')); // corner
        nodes.forEach(n => {
          const th = document.createElement('th');
          th.textContent = n.label;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        nodes.forEach(rowNode => {
          const tr = document.createElement('tr');
          const th = document.createElement('th');
          th.textContent = rowNode.label;
          tr.appendChild(th);
          nodes.forEach(colNode => {
            const td = document.createElement('td');
            td.tabIndex = 0;
            const present = isEdgePresent(rowNode.id, colNode.id);
            if (present) td.classList.add('cell-on');
            td.textContent = present ? (directedMode ? '1' : '1') : '0';
            td.title = (directedMode ? `Edge ${rowNode.label} → ${colNode.label}` : `${rowNode.label} — ${colNode.label}`);
            td.setAttribute('data-row', rowNode.id);
            td.setAttribute('data-col', colNode.id);

            // Click toggles edge
            td.addEventListener('click', function(ev){
              ev.stopPropagation();
              toggleEdgeFromMatrix(rowNode.id, colNode.id);
            });
            td.addEventListener('keydown', function(ev){
              if (ev.key === 'Enter' || ev.key === ' ') {
                ev.preventDefault(); td.click();
              }
            });

            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        matrixWrap.appendChild(table);
      }

      // adjacency list
      function renderAdjList(){
        alist.innerHTML = '';
        if (nodes.length === 0) {
          alist.innerHTML = '<div class="muted-note">No nodes yet.</div>';
          return;
        }

        nodes.forEach(n=>{
          const div = document.createElement('div');
          div.className = 'alist-item';
          const left = document.createElement('div');
          left.style.display = 'flex';
          left.style.gap = '8px';
          const label = document.createElement('div');
          label.style.fontWeight = 700; label.textContent = n.label;
          left.appendChild(label);

          const neighbors = getNeighbors(n.id);
          const right = document.createElement('div');
          right.className = 'badge';
          // display in/out or neighbors
          if (directedMode){
            const out = neighbors.out.map(id=>nodeLabelById(id)).join(', ') || '—';
            const inp = neighbors.in.map(id=>nodeLabelById(id)).join(', ') || '—';
            right.innerHTML = `<div style="text-align:left;"><small style="color:var(--muted)">out:</small> ${out}</div><div style="text-align:left;"><small style="color:var(--muted)">in:</small> ${inp}</div>`;
          } else {
            const nb = neighbors.all.map(id=>nodeLabelById(id)).join(', ') || '—';
            right.innerHTML = `<small style="color:var(--muted)">neighbors</small><div>${nb}</div>`;
          }

          div.appendChild(left);
          div.appendChild(right);
          alist.appendChild(div);
        });
      }

      function nodeLabelById(id){
        const n = nodes.find(x=>x.id===id);
        return n ? n.label : id;
      }

      function getNeighbors(nodeId){
        if (directedMode){
          const out = edges.filter(e=>e.sourceId===nodeId).map(e=>e.targetId);
          const inp = edges.filter(e=>e.targetId===nodeId).map(e=>e.sourceId);
          return { out, in: inp };
        } else {
          const all = edges.reduce((acc,e)=>{
            if (e.sourceId===nodeId) acc.push(e.targetId);
            else if (e.targetId===nodeId) acc.push(e.sourceId);
            return acc;
          }, []);
          return { all };
        }
      }

      function isEdgePresent(srcId, tgtId){
        if (directedMode){
          return edges.some(e => e.directed && e.sourceId===srcId && e.targetId===tgtId);
        } else {
          return edges.some(e => !e.directed && ((e.sourceId===srcId && e.targetId===tgtId) || (e.sourceId===tgtId && e.targetId===srcId)));
        }
      }

      function toggleEdgeFromMatrix(srcId, tgtId){
        // If in undirected mode and src==tgt do nothing
        if (!directedMode && srcId===tgtId) return;

        // If present, remove; else add (in directed mode add directed edge from src->tgt)
        if (isEdgePresent(srcId,tgtId)){
          // remove matching edges
          edges = edges.filter(e=>{
            if (directedMode){
              return !(e.directed && e.sourceId===srcId && e.targetId===tgtId);
            } else {
              return !( !e.directed && ((e.sourceId===srcId && e.targetId===tgtId) || (e.sourceId===tgtId && e.targetId===srcId)) );
            }
          });
        } else {
          createEdge(srcId,tgtId,directedMode);
        }
        renderAll();
        flashMatrixCells([srcId,tgtId]);
      }

      function flashMatrixCells(pairIds){
        // highlight cells corresponding to pair
        const tds = matrixWrap.querySelectorAll('td');
        tds.forEach(td=>{
          const r = td.getAttribute('data-row'), c = td.getAttribute('data-col');
          if (pairIds.includes(r) && pairIds.includes(c)){
            td.classList.add('flash');
            setTimeout(()=>td.classList.remove('flash'),700);
          }
        });
      }

      function updateDegreeInfo(){
        if (!selectedNode) return;
        if (directedMode){
          const out = edges.filter(e=>e.sourceId===selectedNode.id).length;
          const inp = edges.filter(e=>e.targetId===selectedNode.id).length;
          degreeBox.innerHTML = `<strong style="color:var(--accent)">${selectedNode.label}</strong> — out-degree: <strong>${out}</strong>, in-degree: <strong>${inp}</strong>`;
        } else {
          const deg = edges.reduce((acc,e)=>{
            if (e.sourceId===selectedNode.id || e.targetId===selectedNode.id) return acc+1;
            return acc;
          },0);
          degreeBox.innerHTML = `<strong style="color:var(--accent)">${selectedNode.label}</strong> — degree: <strong>${deg}</strong>`;
        }
      }

      // UI actions
      addNodeBtn.addEventListener('click', () => {
        placeMode = true;
        addNodeBtn.textContent = 'Click Canvas';
        addNodeBtn.disabled = true;
        setTimeout(()=>{ addNodeBtn.textContent = 'Add Node'; addNodeBtn.disabled = false; placeMode = false; }, 4000); // fallback
      });

      // Double click quickly to add node
      graphArea.addEventListener('dblclick', function(ev){
        updateGraphRect();
        const x = ev.clientX - graphRect.left;
        const y = ev.clientY - graphRect.top;
        createNodeAt(x,y,'N'+(nextNodeId));
      });

      graphArea.addEventListener('click', function(ev){
        // if in place mode (from Add Node button)
        if (placeMode){
          updateGraphRect();
          const x = ev.clientX - graphRect.left;
          const y = ev.clientY - graphRect.top;
          createNodeAt(x,y,'N'+(nextNodeId));
          placeMode = false;
          addNodeBtn.textContent = 'Add Node';
          return;
        }
        // if clicking empty area, deselect
        if (ev.target === graphArea || ev.target === graphSvg){
          // cancel add-edge if active
          if (addingEdge){
            addingEdge = false;
            pendingSource = null;
            addEdgeBtn.textContent = 'Add Edge';
            addEdgeBtn.classList.remove('active');
          }
          selectNode(null);
        }
      });

      addEdgeBtn.addEventListener('click', function(){
        addingEdge = !addingEdge;
        pendingSource = null;
        addEdgeBtn.classList.toggle('active', addingEdge);
        addEdgeBtn.textContent = addingEdge ? 'Select Source → Target' : 'Add Edge';
        if (addingEdge) {
          flashNotice('Add Edge: click source node, then target node');
        }
      });

      clearBtn.addEventListener('click', function(){
        if (!confirm('Clear all nodes and edges?')) return;
        nodes.forEach(n=> n.el.remove());
        nodes = [];
        edges = [];
        nextNodeId = 1;
        selectedNode = null;
        renderAll();
        selectedName.textContent = 'None';
        degreeBox.textContent = 'Select a node to see degree info.';
      });

      sampleBtn.addEventListener('click', function(){
        // Clear then create sample nodes and edges
        nodes.forEach(n=> n.el.remove());
        nodes = []; edges = []; nextNodeId = 1; selectedNode=null;
        // create nodes at preset positions relative to graph area
        updateGraphRect();
        const w = graphRect.width, h = graphRect.height;
        const coords = [
          {x: w*0.25, y: h*0.3},
          {x: w*0.6,  y: h*0.25},
          {x: w*0.8,  y: h*0.6},
          {x: w*0.45, y: h*0.7},
          {x: w*0.2,  y: h*0.6}
        ];
        coords.forEach((c,i)=> createNodeAt(c.x, c.y, 'N'+(i+1)));
        // Add a few edges
        setTimeout(()=>{
          createEdge(nodes[0].id, nodes[1].id, directedMode);
          createEdge(nodes[1].id, nodes[2].id, directedMode);
          createEdge(nodes[2].id, nodes[3].id, directedMode);
          createEdge(nodes[3].id, nodes[0].id, directedMode);
          if (!directedMode){
            createEdge(nodes[4].id, nodes[0].id, false);
          } else {
            createEdge(nodes[0].id, nodes[4].id, true);
          }
          renderAll();
        }, 240);
      });

      // Mode toggle
      function setDirectedMode(on){
        directedMode = !!on;
        switchKnob.parentElement.classList.toggle('on', directedMode);
        modeLabel.textContent = directedMode ? 'Directed' : 'Undirected';
        modeToggle.setAttribute('aria-checked', String(directedMode));
        // Note: switching modes converts edges to preserved direction flags when toggling to directed,
        // and to undirected edges when toggling to undirected keeping connectivity.
        if (!directedMode){
          // convert all edges to undirected: remove duplicates between pairs and merge
          const pairs = {};
          edges.forEach(e=>{
            const a = e.sourceId, b = e.targetId;
            const key = a < b ? a + '|' + b : b + '|' + a;
            pairs[key] = { sourceId: a, targetId: b };
          });
          edges = Object.keys(pairs).map(k=>{
            const p = pairs[k];
            return { id: uid('edge'), sourceId: p.sourceId, targetId: p.targetId, directed: false };
          });
        } else {
          // convert all edges to directed: keep existing orientations as they were stored
          // For undirected edges, arbitrarily set sourceId->targetId
          edges = edges.map(e => {
            if (e.directed) return e;
            return { id: uid('edge'), sourceId: e.sourceId, targetId: e.targetId, directed: true };
          });
        }
        renderAll();
      }

      modeToggle.addEventListener('click', function(){
        setDirectedMode(!directedMode);
      });
      modeToggle.addEventListener('keydown', function(ev){
        if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); modeToggle.click(); }
      });

      // Some small utility: flash a temporary message in the graph area
      function flashNotice(text){
        const t = document.createElement('div');
        t.style.position = 'absolute';
        t.style.left = '50%';
        t.style.top = '8px';
        t.style.transform = 'translateX(-50%)';
        t.style.background = 'linear-gradient(90deg, rgba(6,182,212,0.12), rgba(6,182,212,0.06))';
        t.style.color = 'var(--accent)';
        t.style.padding = '8px 12px';
        t.style.borderRadius = '8px';
        t.style.fontWeight = '700';
        t.style.zIndex = 40;
        t.textContent = text;
        graphArea.appendChild(t);
        setTimeout(()=>{ t.style.transition = 'opacity 300ms ease'; t.style.opacity = '0'; }, 900);
        setTimeout(()=> t.remove(), 1300);
      }

      // Click on matrix cell toggles edge; implemented above.

      // Initialize with undirected mode as default
      setDirectedMode(false);

      // Initial sample
      // sampleBtn.click();

      // Update graphRect on pointer interactions
      graphArea.addEventListener('pointerdown', updateGraphRect);
      graphArea.addEventListener('pointerup', updateGraphRect);
      graphArea.addEventListener('pointermove', updateGraphRect);

      // Expose small keyboard shortcut: 'E' to toggle add-edge, 'N' to add node mode, 'D' to toggle directed
      document.addEventListener('keydown', function(ev){
        if (ev.target && (ev.target.tagName === 'INPUT' || ev.target.tagName === 'TEXTAREA')) return;
        if (ev.key === 'e' || ev.key === 'E') addEdgeBtn.click();
        if (ev.key === 'n' || ev.key === 'N') addNodeBtn.click();
        if (ev.key === 'd' || ev.key === 'D') modeToggle.click();
      });

      // Make sure nodes store center coordinates from initial placement
      // When creating nodes using createNodeAt, we need to set node.x/node.y based on element position
      // Adjust createNodeAt to compute node.x/y after append
      // But ensure existing nodes have .x/.y correct on load
      // (already assigned)
    })();
  </script>


  <script id="fsm" type="application/json">
    {
  "topic": "Interactive Graph Builder (Directed vs Undirected)",
  "description": "Finite state machine modeling the user interactions, modes, and visual behaviours of the interactive graph module (node creation, dragging, edge creation, matrix toggles, mode switching, sample/clear actions and transient animations).",
  "states": [
    {
      "name": "idle",
      "onEnter": "renderAll() // default render and ensure UI reflects current data (matrix, list, edges, highlights)",
      "onExit": "",
      "on": {
        "CLICK_ADD_NODE_BTN": "placing_node",
        "DOUBLE_CLICK_CANVAS": "idle",
        "PLACE_NODE_CLICK": "idle",
        "CLICK_ADD_EDGE_BTN": "adding_edge_waiting_source",
        "CLICK_NODE": "selected",
        "NODE_DRAG_START": "dragging",
        "CLICK_EMPTY_AREA": "idle",
        "CLICK_CLEAR_BTN": "idle",
        "CLICK_SAMPLE_BTN": "sample_loading",
        "TOGGLE_MODE": "toggling_mode",
        "MATRIX_CELL_CLICK": "idle",
        "KEY_SHORTCUT_ADD_NODE": "placing_node",
        "KEY_SHORTCUT_ADD_EDGE": "adding_edge_waiting_source",
        "KEY_SHORTCUT_TOGGLE_DIRECTED": "toggling_mode"
      }
    },
    {
      "name": "placing_node",
      "onEnter": "placeMode = true; update Add Node button text to 'Click Canvas'; start fallback PLACE_NODE_TIMEOUT timer (4s) that will cancel placement if no click",
      "onExit": "clear PLACE_NODE_TIMEOUT; placeMode = false; reset Add Node button text and enabled state",
      "on": {
        "PLACE_NODE_CLICK": "idle",
        "PLACE_NODE_TIMEOUT": "idle",
        "DOUBLE_CLICK_CANVAS": "idle",
        "CLICK_EMPTY_AREA": "placing_node"
      }
    },
    {
      "name": "adding_edge_waiting_source",
      "onEnter": "addingEdge = true; pendingSource = null; addEdgeBtn active=true; flashNotice('Add Edge: click source node, then target node')",
      "onExit": "if pendingSource then highlightNode(pendingSource.id,false); pendingSource = null; addEdgeBtn active=false; addEdgeBtn.text='Add Edge'; addingEdge = false",
      "on": {
        "CLICK_NODE": "adding_edge_waiting_target",
        "CLICK_ADD_EDGE_BTN": "idle",
        "CLICK_EMPTY_AREA": "idle",
        "CANCEL_ADD_EDGE": "idle",
        "KEY_SHORTCUT_ADD_EDGE": "idle"
      }
    },
    {
      "name": "adding_edge_waiting_target",
      "onEnter": "pendingSource set (the clicked node); highlightNode(pendingSource.id,true)",
      "onExit": "highlightNode(pendingSource?.id,false); pendingSource = null; addEdgeBtn active=false; addEdgeBtn.text='Add Edge'; addingEdge = false",
      "on": {
        "CLICK_NODE": "idle",
        "SELF_LOOP_ATTEMPT": "adding_edge_waiting_source",
        "CLICK_ADD_EDGE_BTN": "idle",
        "CLICK_EMPTY_AREA": "idle",
        "CANCEL_ADD_EDGE": "idle"
      }
    },
    {
      "name": "dragging",
      "onEnter": "dragging = true; node gets 'selected' class; capture pointer; updateGraphRect()",
      "onExit": "dragging = false; release pointer; updateEdgesPositions(draggedNode.id); remove 'selected' visual (but keep logical selection)",
      "on": {
        "NODE_DRAG_MOVE": "dragging",
        "NODE_DRAG_END": "selected",
        "CLICK_EMPTY_AREA": "selected"
      }
    },
    {
      "name": "selected",
      "onEnter": "selectedNode set; selectedName UI updated; updateDegreeInfo(); renderAll() to show highlights",
      "onExit": "selectedNode = null; selectedName = 'None'; degreeBox reset; renderAll()",
      "on": {
        "CLICK_NODE": "idle",
        "CLICK_ADD_EDGE_BTN": "adding_edge_waiting_source",
        "NODE_DRAG_START": "dragging",
        "CLICK_EMPTY_AREA": "idle",
        "MATRIX_CELL_CLICK": "selected",
        "TOGGLE_MODE": "toggling_mode",
        "KEY_SHORTCUT_ADD_EDGE": "adding_edge_waiting_source"
      }
    },
    {
      "name": "sample_loading",
      "onEnter": "clear existing nodes/edges; nextNodeId reset; create sample nodes at preset positions; schedule sample edges creation (timeout ~240ms) performing createEdge(...) which animates and then renderAll()",
      "onExit": "cancel scheduled timeouts if any; renderAll();",
      "on": {
        "SAMPLE_EDGES_CREATED": "idle",
        "CLICK_CLEAR_BTN": "idle",
        "TOGGLE_MODE": "toggling_mode"
      }
    },
    {
      "name": "toggling_mode",
      "onEnter": "directedMode toggled; update switch UI; set aria-checked; convert edges (undirected->directed or directed->undirected) per conversion logic; renderAll()",
      "onExit": "",
      "on": {
        "MODE_TOGGLE_COMPLETE": "idle",
        "CLICK_ADD_EDGE_BTN": "adding_edge_waiting_source",
        "CLICK_SAMPLE_BTN": "sample_loading"
      }
    }
  ],
  "events": [
    "CLICK_ADD_NODE_BTN",
    "PLACE_NODE_CLICK",
    "PLACE_NODE_TIMEOUT",
    "DOUBLE_CLICK_CANVAS",
    "CLICK_ADD_EDGE_BTN",
    "CLICK_NODE",
    "NODE_DRAG_START",
    "NODE_DRAG_MOVE",
    "NODE_DRAG_END",
    "CLICK_EMPTY_AREA",
    "CLICK_CLEAR_BTN",
    "CLICK_SAMPLE_BTN",
    "TOGGLE_MODE",
    "MODE_TOGGLE_COMPLETE",
    "MATRIX_CELL_CLICK",
    "MATRIX_CELL_TOGGLE_COMPLETE",
    "EDGE_CREATE_SUCCESS",
    "EDGE_CREATE_DUPLICATE",
    "SELF_LOOP_ATTEMPT",
    "SAMPLE_EDGES_CREATED",
    "CANCEL_ADD_EDGE",
    "KEY_SHORTCUT_ADD_EDGE",
    "KEY_SHORTCUT_ADD_NODE",
    "KEY_SHORTCUT_TOGGLE_DIRECTED"
  ],
  "notes": "Implementation notes and mapping of actions: \n- Mode (directedMode boolean) is orthogonal to the primary state machine: toggling_mode state runs conversion logic and then returns to idle. Mode affects edge creation, adjacency rendering and matrix behaviour.\n- Place node flow: clicking Add Node enters placing_node. A fallback timeout (~4s) resets placeMode. Double-click on canvas immediately creates a node (self-loop prevention applies elsewhere).\n- Add edge flow: adding_edge_waiting_source -> user clicks a source node -> adding_edge_waiting_target (pendingSource set) -> user clicks target node -> createEdge invoked (may animate). If target equals source, SELF_LOOP_ATTEMPT occurs and machine returns to waiting_source; if duplicate edge detected createEdge triggers EDGE_CREATE_DUPLICATE (matrix cells flash) but the UI still exits Add Edge mode as implemented.\n- Dragging is a transient state entered by pointerdown on a node, consuming NODE_DRAG_MOVE events and ending with NODE_DRAG_END which returns to selected (logical selection remains). Visual 'selected' class is added on drag start and removed on drag end (code removes class but selectedNode remains set).\n- Matrix cell clicks (MATRIX_CELL_CLICK) are handled from idle/selected states: toggleEdgeFromMatrix performs add/remove (with flashMatrixCells). After toggle the table cell briefly flashes (UI animation) but state remains idle/selected.\n- Sample graph loading: sample_loading creates nodes synchronously then schedules edges to be added after a timeout; when edges added SAMPLE_EDGES_CREATED transitions back to idle.\n- Clear: CLICK_CLEAR_BTN triggers a confirm() then clears nodes/edges and resets relevant counters and UI; modeled as an immediate idle self-transition with onEnter action 'clearAll'.\n- Keyboard shortcuts map to the same events (N -> CLICK_ADD_NODE_BTN/PLACE_NODE flows, E -> CLICK_ADD_EDGE_BTN, D -> TOGGLE_MODE).\n- Transient visuals/animations (edge draw animation, matrix cell flash, flashNotice message) are represented as onEnter actions on the relevant states or as actions performed on events (e.g. createEdge draws with animation and flashMatrixCells on duplicate). These are ephemeral and do not create dedicated long-lived FSM states beyond the small 'sample_loading' and 'placing_node' durations.\n- Selection toggling: clicking the currently selected node toggles selection off (selected -> idle). Clicking empty canvas also deselects.\n\nThis FSM intentionally models human-visible, persistent interaction modes (placing a node, adding an edge with source/target steps, dragging, selection, sample-loading and mode toggling) and summarizes the primary onEnter/onExit UI/data actions executed by the module.",
  "version": "1.0"
}
  </script>
</body>
</html>