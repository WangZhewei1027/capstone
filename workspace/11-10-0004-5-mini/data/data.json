[
  {
    "id": "c72b9cd0-bde5-11f0-95af-4764f61ee009",
    "timestamp": "2025-11-10T03:31:43.518Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Stack",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Stack — Interactive Learning Module</title>\n  <style>\n    /* Safe area margins: 24px around viewport */\n    :root {\n      --safe-margin: 24px;\n      --min-gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #7c5cff;\n      --accent-2: #3ddc97;\n      --muted: #93a0b8;\n      --glass: rgba(255,255,255,0.03);\n      --danger: #ff6b6b;\n      --success: #2dd4bf;\n      --max-width: 1100px;\n      --stack-width: 220px;\n      --chip-height: 40px;\n    }\n    html,body {\n      height: 100%;\n      margin: 0;\n      background: linear-gradient(180deg, #071028 0%, #071221 60%);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      color: #e6eef8;\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothing: grayscale;\n    }\n    .app {\n      max-width: var(--max-width);\n      margin: var(--safe-margin) auto;\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 12px;\n      box-shadow: 0 10px 30px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);\n    }\n    header {\n      display: flex;\n      gap: var(--min-gap);\n      align-items: baseline;\n      flex-wrap: wrap;\n      margin-bottom: 18px;\n    }\n    h1 {\n      font-size: 20px;\n      margin: 0;\n      letter-spacing: -0.2px;\n    }\n    .subtitle {\n      color: var(--muted);\n      font-size: 13px;\n      margin-left: auto;\n    }\n\n    /* Layout: two-column responsive */\n    .container {\n      display: grid;\n      grid-template-columns: 1fr 420px;\n      gap: var(--min-gap);\n    }\n    @media (max-width: 980px) {\n      .container { grid-template-columns: 1fr; }\n    }\n\n    /* Left: Visual interactive area */\n    .visual {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);\n      padding: 18px;\n      border-radius: 10px;\n      min-height: 420px;\n      display: flex;\n      flex-direction: column;\n      gap: 18px;\n    }\n    .stack-shell {\n      display: flex;\n      gap: var(--min-gap);\n      align-items: flex-start;\n      flex-wrap: wrap;\n    }\n\n    /* Stack canvas */\n    .stack-canvas {\n      width: var(--stack-width);\n      min-height: 320px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));\n      border: 1px solid rgba(255,255,255,0.04);\n      border-radius: 10px;\n      padding: 12px;\n      box-sizing: border-box;\n      position: relative;\n    }\n    .stack-title {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      margin-bottom: 8px;\n      font-size: 13px;\n      color: var(--muted);\n    }\n    .stack-visual {\n      --slot-h: 48px;\n      display: flex;\n      flex-direction: column-reverse; /* bottom = base, top = end */\n      gap: 10px;\n      align-items: center;\n      justify-content: flex-start;\n      height: calc(var(--slot-h) * 6 + 10px * 5); /* default capacity 6 for layout */\n      padding: 8px 6px;\n      box-sizing: border-box;\n      width: 100%;\n      position: relative;\n    }\n    .stack-slot {\n      width: 100%;\n      height: 48px;\n      border-radius: 8px;\n      background: rgba(255,255,255,0.02);\n      border: 1px dashed rgba(255,255,255,0.03);\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      color: var(--muted);\n      font-weight: 600;\n      position: relative;\n      box-sizing: border-box;\n    }\n    .stack-item {\n      position: absolute;\n      left: 6px;\n      right: 6px;\n      height: 40px;\n      border-radius: 8px;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      background: linear-gradient(90deg, rgba(124,92,255,0.18), rgba(61,220,151,0.08));\n      border: 1px solid rgba(255,255,255,0.06);\n      color: #ffffff;\n      font-weight: 700;\n      transform-origin: center;\n      transition: transform 400ms cubic-bezier(.2,.9,.2,1), opacity 300ms;\n      box-shadow: 0 6px 18px rgba(12,14,20,0.6);\n    }\n    .stack-item.top-highlight {\n      box-shadow: 0 10px 30px rgba(124,92,255,0.18);\n      outline: 3px solid rgba(124,92,255,0.12);\n    }\n    .stack-index {\n      position: absolute;\n      left: -34px;\n      top: 6px;\n      font-size: 12px;\n      color: var(--muted);\n      width: 28px;\n      text-align: right;\n    }\n\n    /* Controls panel (right) */\n    .controls {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);\n      padding: 18px;\n      border-radius: 10px;\n      display: flex;\n      flex-direction: column;\n      gap: 16px;\n      min-height: 420px;\n      box-sizing: border-box;\n    }\n    label {\n      font-size: 13px;\n      color: var(--muted);\n      display: block;\n      margin-bottom: 6px;\n    }\n    .input-row {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n    }\n    input[type=\"text\"] {\n      flex: 1;\n      padding: 10px 12px;\n      border-radius: 8px;\n      border: 1px solid rgba(255,255,255,0.04);\n      background: rgba(255,255,255,0.02);\n      color: #eaf2ff;\n      font-size: 14px;\n      outline: none;\n    }\n    input[type=\"text\"]:focus {\n      box-shadow: 0 6px 18px rgba(124,92,255,0.06);\n      border-color: rgba(124,92,255,0.32);\n    }\n    button {\n      padding: 10px 12px;\n      border-radius: 8px;\n      border: none;\n      cursor: pointer;\n      font-weight: 700;\n      font-size: 13px;\n      color: #061425;\n      background: linear-gradient(90deg, var(--accent), var(--accent-2));\n      box-shadow: 0 8px 20px rgba(12,14,20,0.45);\n    }\n    button.secondary {\n      background: rgba(255,255,255,0.03);\n      color: var(--muted);\n      border: 1px solid rgba(255,255,255,0.02);\n      box-shadow: none;\n    }\n    .btn-row {\n      display: flex;\n      gap: 12px;\n      flex-wrap: wrap;\n    }\n    .small {\n      padding: 8px 10px;\n      font-size: 13px;\n    }\n\n    /* Palette of draggable chips */\n    .palette {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n      flex-wrap: wrap;\n      padding: 8px 4px;\n      border-radius: 8px;\n      background: rgba(255,255,255,0.01);\n    }\n    .chip {\n      height: var(--chip-height);\n      min-width: 64px;\n      padding: 0 12px;\n      border-radius: 10px;\n      background: linear-gradient(90deg, rgba(124,92,255,0.18), rgba(61,220,151,0.06));\n      display: inline-flex;\n      align-items: center;\n      justify-content: center;\n      color: #fff;\n      font-weight: 700;\n      cursor: grab;\n      user-select: none;\n      border: 1px solid rgba(255,255,255,0.06);\n    }\n    .chip:active { cursor: grabbing; }\n\n    /* Messages and log */\n    .message {\n      font-size: 13px;\n      color: var(--muted);\n      min-height: 20px;\n    }\n    .message.important { color: var(--accent); font-weight: 700; }\n    .message.error { color: var(--danger); font-weight: 700; }\n    .log {\n      margin-top: 6px;\n      background: rgba(0,0,0,0.04);\n      padding: 8px;\n      border-radius: 8px;\n      max-height: 120px;\n      overflow: auto;\n      font-size: 13px;\n      color: var(--muted);\n    }\n\n    /* Animations: floating clone moving */\n    .floating {\n      position: fixed;\n      pointer-events: none;\n      z-index: 9999;\n      transition: transform 420ms cubic-bezier(.2,.9,.2,1), opacity 320ms;\n      will-change: transform, opacity;\n    }\n    .shake {\n      animation: shake 420ms;\n    }\n    @keyframes shake {\n      0% { transform: translateX(0); }\n      20% { transform: translateX(-8px); }\n      40% { transform: translateX(8px); }\n      60% { transform: translateX(-6px); }\n      80% { transform: translateX(6px); }\n      100% { transform: translateX(0); }\n    }\n    .fade-out {\n      opacity: 0;\n      transform: scale(0.9) translateY(-8px);\n    }\n\n    /* small helpers */\n    .muted { color: var(--muted); }\n    .row { display:flex; gap:12px; align-items:center; }\n    .flex { flex:1; }\n    .explain {\n      font-size: 13px;\n      color: var(--muted);\n      line-height: 1.4;\n      margin-top: 6px;\n    }\n\n    /* Accessibility focus */\n    button:focus, .chip:focus, input:focus {\n      outline: 3px solid rgba(124,92,255,0.12);\n      outline-offset: 2px;\n    }\n\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Stack interactive module\">\n    <header>\n      <h1>Stack — LIFO (Last In, First Out)</h1>\n      <div class=\"subtitle\">Interactive module • Push, Pop, Peek, Drag & Drop • Animations</div>\n    </header>\n\n    <!-- Interactive Design Plan (required textual sections) -->\n    <section class=\"explain\" aria-hidden=\"false\">\n      <strong>Concept Title:</strong> Stack — Last In, First Out (LIFO) data structure.<br>\n      <strong>Learning Objective:</strong> After interacting with this module, you should be able to:\n      <ul>\n        <li>Understand the LIFO behavior of a stack (push adds to the top, pop removes from the top).</li>\n        <li>Perform push/pop/peek operations and observe visual & animated state changes.</li>\n        <li>Recognize stack overflow and underflow conditions and how capacity limits affect operations.</li>\n      </ul>\n      <strong>Interaction Design:</strong>\n      <p class=\"muted\">\n        Users interact via: typing values and pressing \"Push\", dragging chips from the palette into the stack area,\n        and using \"Pop\", \"Peek\", \"Clear\" buttons. Each push produces an animated item that moves into the top slot;\n        popping animates the top item out. Visual highlights mark the current top element. When capacity is exceeded\n        a shake animation and an error message indicate overflow; attempting to pop from an empty stack triggers\n        an underflow message and feedback. A live operation log and accessible ARIA messages describe state changes.\n      </p>\n      <strong>Layout Description:</strong>\n      <p class=\"muted\">\n        The page uses a two-column responsive layout with a visual canvas (left) and controls/explanations (right).\n        Safe area margins are 24px and minimum spacing between interactive elements is 16px. The left column shows the\n        stack visualization and index markers. The right column contains controls (input, push/pop/peek buttons, capacity\n        slider), a draggable palette, messages, and an operation log. Visual hierarchy and spacing keep focus on the stack\n        while controls are clearly labeled and keyboard accessible.\n      </p>\n    </section>\n\n    <!-- Main interactive container -->\n    <div class=\"container\" style=\"margin-top:14px;\">\n      <!-- Visual stack area -->\n      <div class=\"visual\" aria-live=\"polite\">\n        <div class=\"stack-shell\" style=\"justify-content: space-between;\">\n          <div class=\"stack-canvas\" id=\"stackCanvas\" aria-label=\"Stack visualization\">\n            <div class=\"stack-title\">\n              <div>Stack (top at top)</div>\n              <div class=\"muted\" id=\"capacityLabel\">Capacity: 6</div>\n            </div>\n\n            <div class=\"stack-visual\" id=\"stackVisual\" tabindex=\"0\" aria-describedby=\"stackHint\" role=\"listbox\">\n              <!-- stack slots and items inserted dynamically -->\n            </div>\n\n            <div id=\"stackHint\" class=\"muted\" style=\"margin-top:8px; font-size:13px;\">\n              Tip: Drag chips into the stack or use the controls to push values. Use Pop to remove from top.\n            </div>\n          </div>\n\n          <!-- Array-style view for memory visualization -->\n          <div style=\"flex:1; min-width:260px;\">\n            <div style=\"font-size:13px; color:var(--muted); margin-bottom:8px;\">Memory view (top index shown)</div>\n            <div style=\"background:var(--glass); padding:12px; border-radius:8px; min-height:220px;\">\n              <div id=\"memoryView\" class=\"log\" aria-live=\"polite\" style=\"min-height:180px;\"></div>\n            </div>\n          </div>\n        </div>\n\n        <!-- Palette for draggable chips -->\n        <div style=\"margin-top:12px;\">\n          <div style=\"display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;\">\n            <div style=\"font-size:13px; color:var(--muted);\">Value palette — drag into stack</div>\n            <div style=\"font-size:12px; color:var(--muted);\">Keyboard: type and Push or create chip</div>\n          </div>\n          <div class=\"palette\" id=\"palette\" aria-label=\"Palette of values\" role=\"list\">\n            <!-- default chips -->\n            <div class=\"chip\" role=\"option\" tabindex=\"0\" data-value=\"A\">A</div>\n            <div class=\"chip\" role=\"option\" tabindex=\"0\" data-value=\"B\">B</div>\n            <div class=\"chip\" role=\"option\" tabindex=\"0\" data-value=\"C\">C</div>\n            <div class=\"chip\" role=\"option\" tabindex=\"0\" data-value=\"1\">1</div>\n            <div class=\"chip\" role=\"option\" tabindex=\"0\" data-value=\"2\">2</div>\n            <div class=\"chip\" role=\"option\" tabindex=\"0\" data-value=\"3\">3</div>\n          </div>\n        </div>\n\n      </div>\n\n      <!-- Controls panel -->\n      <aside class=\"controls\" aria-label=\"Controls\">\n        <div>\n          <label for=\"valueInput\">Value (type then Push)</label>\n          <div class=\"input-row\">\n            <input id=\"valueInput\" type=\"text\" placeholder=\"Enter value (e.g. X, 42, hello)\" aria-label=\"Value to push\" />\n            <button id=\"pushBtn\" class=\"small\">Push</button>\n            <button id=\"createChipBtn\" class=\"small secondary\" title=\"Add typed value to palette\">Create Chip</button>\n          </div>\n        </div>\n\n        <div>\n          <label>Operations</label>\n          <div class=\"btn-row\">\n            <button id=\"popBtn\" class=\"small\">Pop</button>\n            <button id=\"peekBtn\" class=\"small secondary\">Peek</button>\n            <button id=\"clearBtn\" class=\"small secondary\">Clear</button>\n            <div style=\"flex:1\"></div>\n            <div style=\"align-self:center; font-size:13px; color:var(--muted);\">Size: <span id=\"sizeLabel\">0</span></div>\n          </div>\n        </div>\n\n        <div>\n          <label for=\"capacityRange\">Capacity</label>\n          <div class=\"row\">\n            <input id=\"capacityRange\" type=\"range\" min=\"2\" max=\"10\" value=\"6\" aria-label=\"Stack capacity slider\" />\n            <div style=\"width:48px; text-align:right; font-weight:700;\" id=\"capacityValue\">6</div>\n          </div>\n          <div class=\"muted\" style=\"font-size:12px; margin-top:6px;\">\n            Adjust capacity to see how overflow behaves. Default capacity lets you experiment without immediate overflow.\n          </div>\n        </div>\n\n        <div>\n          <label>Messages</label>\n          <div id=\"message\" class=\"message\" role=\"status\" aria-live=\"polite\"></div>\n          <div id=\"opLog\" class=\"log\" aria-live=\"polite\"></div>\n        </div>\n\n        <div style=\"margin-top:auto; font-size:12px;\" class=\"muted\">\n          Controls are keyboard accessible. Use Tab to focus palette chips and Enter to drag-push them,\n          or type a value and press Enter to Push.\n        </div>\n\n      </aside>\n    </div>\n  </div>\n\n  <script>\n    /*\n      Stack Interactive Module (vanilla JS)\n      - Supports push, pop, peek, clear\n      - Drag chips into stack, or click focused chip to push\n      - Animated floating clone moves into stack; popped items animate out\n      - Capacity slider controls maximum size (overflow triggers shake + message)\n      - Accessible: aria-live messages, keyboard support\n    */\n\n    (function () {\n      // DOM elements\n      const stackVisual = document.getElementById('stackVisual');\n      const memoryView = document.getElementById('memoryView');\n      const opLog = document.getElementById('opLog');\n      const messageEl = document.getElementById('message');\n      const sizeLabel = document.getElementById('sizeLabel');\n      const capacityRange = document.getElementById('capacityRange');\n      const capacityLabel = document.getElementById('capacityLabel');\n      const capacityValue = document.getElementById('capacityValue');\n      const valueInput = document.getElementById('valueInput');\n      const pushBtn = document.getElementById('pushBtn');\n      const popBtn = document.getElementById('popBtn');\n      const peekBtn = document.getElementById('peekBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const palette = document.getElementById('palette');\n      const createChipBtn = document.getElementById('createChipBtn');\n\n      // Internal stack state\n      let stack = [];\n      let capacity = parseInt(capacityRange.value, 10) || 6;\n      let animating = false;\n\n      // Initialize UI\n      capacityLabel.textContent = `Capacity: ${capacity}`;\n      capacityValue.textContent = capacity;\n      renderStack();\n\n      // Utilities\n      function logOp(text) {\n        const time = new Date().toLocaleTimeString();\n        opLog.insertAdjacentHTML('afterbegin', `<div style=\"padding:6px 0\">[${time}] ${escapeHtml(text)}</div>`);\n      }\n      function setMessage(text, type = 'info') {\n        messageEl.textContent = text;\n        messageEl.className = 'message';\n        if (type === 'error') messageEl.classList.add('error');\n        if (type === 'important') messageEl.classList.add('important');\n      }\n      function escapeHtml(s) {\n        return (''+s).replace(/[&<>\"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[m]));\n      }\n\n      // Render stack slots and items\n      function renderStack() {\n        // Clear existing\n        stackVisual.innerHTML = '';\n        // We'll create capacity number of slots visually (index 0 at base)\n        const slots = [];\n        for (let i = 0; i < capacity; i++) {\n          const slot = document.createElement('div');\n          slot.className = 'stack-slot';\n          // show index on the left\n          const idx = document.createElement('div');\n          idx.className = 'stack-index muted';\n          idx.textContent = i;\n          slot.appendChild(idx);\n          stackVisual.appendChild(slot);\n          slots.push(slot);\n        }\n\n        // Place items absolutely within the stackVisual container.\n        // We'll compute bottom positions for each item.\n        // First, grab the coordinates to compute transforms.\n        requestAnimationFrame(() => {\n          const rect = stackVisual.getBoundingClientRect();\n          const slotHeight = (slots[0].getBoundingClientRect().height + 10) || 58;\n          stack.forEach((val, idx) => {\n            const item = document.createElement('div');\n            item.className = 'stack-item';\n            item.setAttribute('role','option');\n            item.setAttribute('aria-label', `Stack item ${val} at index ${idx}`);\n            item.textContent = val;\n            // Compute bottom offset: index 0 is base, so bottom = base + idx * (slotHeight)\n            const bottomOffset = 8 + idx * slotHeight;\n            item.style.bottom = bottomOffset + 'px';\n            // place top highlight for the last item\n            if (idx === stack.length - 1) item.classList.add('top-highlight');\n            stackVisual.appendChild(item);\n          });\n\n          // Update labels and memory view\n          sizeLabel.textContent = stack.length;\n          capacityLabel.textContent = `Capacity: ${capacity}`;\n          capacityValue.textContent = capacity;\n\n          // Memory view: show top index first for clarity\n          memoryView.innerHTML = '';\n          if (stack.length === 0) {\n            memoryView.textContent = '[ empty ]';\n          } else {\n            for (let i = stack.length - 1; i >= 0; i--) {\n              memoryView.insertAdjacentHTML('beforeend', `<div><strong>index ${i}:</strong> ${escapeHtml(stack[i])}</div>`);\n            }\n          }\n        });\n      }\n\n      // Visual animation helpers: animate push (floating clone) to slot, animate pop out\n      function animatePush(value) {\n        if (animating) return Promise.reject('busy');\n        if (stack.length >= capacity) {\n          // overflow feedback: shake and message\n          shakeStack();\n          setMessage('Stack overflow — capacity reached', 'error');\n          logOp('Push failed: overflow');\n          return Promise.reject('overflow');\n        }\n        animating = true;\n        setMessage(`Pushing \"${value}\" ...`, 'important');\n\n        // Create floating clone (start near palette or input)\n        const startEl = document.activeElement && document.activeElement.classList.contains('chip') ? document.activeElement : null;\n        let startRect = startEl ? startEl.getBoundingClientRect() : valueInput.getBoundingClientRect();\n        const clone = document.createElement('div');\n        clone.className = 'chip floating';\n        clone.textContent = value;\n        clone.style.left = (startRect.left) + 'px';\n        clone.style.top = (startRect.top) + 'px';\n        clone.style.width = startRect.width + 'px';\n        clone.style.height = startRect.height + 'px';\n        document.body.appendChild(clone);\n\n        // target position: top slot coordinates\n        // We first render new stack item offscreen to compute target\n        const targetIndex = stack.length; // new index\n        // We'll compute the bottom position for the target slot\n        const slots = stackVisual.querySelectorAll('.stack-slot');\n        const slotRect = slots.length > 0 ? slots[0].getBoundingClientRect() : stackVisual.getBoundingClientRect();\n        // compute slot height (including gap)\n        const itemHeight = 40; // defined in CSS\n        const slotHeight = slotRect.height + 10; // approximate using CSS layout gap\n        // We'll compute target center point within stackVisual\n        const canvasRect = stackVisual.getBoundingClientRect();\n        const bottomOffset = 8 + targetIndex * slotHeight;\n        const targetY = canvasRect.bottom - bottomOffset - (itemHeight / 2);\n        const targetX = canvasRect.left + 12; // left padding\n\n        // compute transform delta\n        const startCenterX = startRect.left + startRect.width / 2;\n        const startCenterY = startRect.top + startRect.height / 2;\n        const targetCenterX = targetX + (canvasRect.width - 24) / 2;\n        const targetCenterY = targetY;\n\n        // position clone centered for smoother motion\n        clone.style.transform = `translate(-50%,-50%)`;\n        clone.style.left = startCenterX + 'px';\n        clone.style.top = startCenterY + 'px';\n        // force repaint\n        clone.getBoundingClientRect();\n\n        // move clone to target\n        requestAnimationFrame(() => {\n          clone.style.transition = 'transform 480ms cubic-bezier(.2,.9,.2,1), opacity 320ms';\n          const dx = targetCenterX - startCenterX;\n          const dy = targetCenterY - startCenterY;\n          clone.style.transform = `translate(${dx}px, ${dy}px) scale(0.98) translate(-50%,-50%)`;\n        });\n\n        return new Promise((resolve) => {\n          setTimeout(() => {\n            // finalize: remove clone, update data & render with small entrance animation\n            clone.classList.add('fade-out');\n            setTimeout(() => {\n              clone.remove();\n            }, 200);\n\n            // push into state\n            stack.push(value);\n            renderStack();\n            // briefly flash the top item\n            const items = stackVisual.querySelectorAll('.stack-item');\n            const top = items[items.length - 1];\n            if (top) {\n              top.style.transform = 'scale(1.06)';\n              setTimeout(() => {\n                top.style.transform = 'scale(1)';\n              }, 220);\n            }\n\n            setMessage(`Pushed \"${value}\"`, 'important');\n            logOp(`push(${value})`);\n            animating = false;\n            resolve();\n          }, 520);\n        });\n      }\n\n      function animatePop() {\n        if (animating) return Promise.reject('busy');\n        if (stack.length === 0) {\n          setMessage('Stack underflow — nothing to pop', 'error');\n          logOp('Pop failed: underflow');\n          // bounce stack for feedback\n          bounceStack();\n          return Promise.reject('underflow');\n        }\n        animating = true;\n        const value = stack[stack.length - 1];\n        setMessage(`Popping \"${value}\" ...`, 'important');\n        // get current top element location\n        const items = stackVisual.querySelectorAll('.stack-item');\n        const top = items[items.length - 1];\n        if (!top) {\n          // fallback: just pop state\n          stack.pop();\n          renderStack();\n          setMessage(`Popped \"${value}\"`);\n          logOp(`pop() -> ${value}`);\n          animating = false;\n          return Promise.resolve(value);\n        }\n        const rect = top.getBoundingClientRect();\n        // create floating clone at top position\n        const clone = top.cloneNode(true);\n        clone.classList.add('floating');\n        clone.style.left = rect.left + 'px';\n        clone.style.top = rect.top + 'px';\n        clone.style.width = rect.width + 'px';\n        clone.style.height = rect.height + 'px';\n        document.body.appendChild(clone);\n        // animate out upward & fade\n        requestAnimationFrame(() => {\n          clone.style.transition = 'transform 420ms ease-in, opacity 320ms';\n          clone.style.transform = 'translateY(-120px) scale(0.9)';\n          clone.style.opacity = '0';\n        });\n\n        return new Promise((resolve) => {\n          setTimeout(() => {\n            clone.remove();\n            stack.pop();\n            renderStack();\n            setMessage(`Popped \"${value}\"`);\n            logOp(`pop() -> ${value}`);\n            animating = false;\n            resolve(value);\n          }, 420);\n        });\n      }\n\n      function animatePeek() {\n        if (stack.length === 0) {\n          setMessage('Stack is empty — nothing to peek', 'error');\n          logOp('Peek: empty');\n          return;\n        }\n        const value = stack[stack.length - 1];\n        setMessage(`Peek -> \"${value}\"`, 'important');\n        logOp(`peek() -> ${value}`);\n        // highlight top item briefly\n        const items = stackVisual.querySelectorAll('.stack-item');\n        const top = items[items.length - 1];\n        if (top) {\n          top.animate([\n            { transform: 'translateY(0) scale(1)' },\n            { transform: 'translateY(-6px) scale(1.02)' },\n            { transform: 'translateY(0) scale(1)' }\n          ], { duration: 420, easing: 'ease-in-out' });\n        }\n      }\n\n      function shakeStack() {\n        stackVisual.classList.add('shake');\n        setTimeout(() => stackVisual.classList.remove('shake'), 460);\n      }\n      function bounceStack() {\n        stackVisual.animate([\n          { transform: 'translateY(0)' },\n          { transform: 'translateY(-8px)' },\n          { transform: 'translateY(0)' }\n        ], { duration: 340, easing: 'cubic-bezier(.2,.9,.2,1)' });\n      }\n\n      // Event handlers: buttons\n      pushBtn.addEventListener('click', () => {\n        const val = valueInput.value.trim();\n        if (!val) {\n          setMessage('Please enter a value or drag a chip.', 'error');\n          return;\n        }\n        animatePush(val).then(() => {\n          valueInput.value = '';\n          valueInput.focus();\n        }).catch(()=>{});\n      });\n\n      popBtn.addEventListener('click', () => {\n        animatePop().catch(()=>{});\n      });\n\n      peekBtn.addEventListener('click', () => {\n        animatePeek();\n      });\n\n      clearBtn.addEventListener('click', () => {\n        stack = [];\n        renderStack();\n        setMessage('Stack cleared');\n        logOp('clear()');\n      });\n\n      // capacity change\n      capacityRange.addEventListener('input', (e) => {\n        capacity = parseInt(e.target.value, 10);\n        capacityLabel.textContent = `Capacity: ${capacity}`;\n        capacityValue.textContent = capacity;\n        // if current stack exceeds new capacity, visually indicate (but keep items)\n        if (stack.length > capacity) {\n          setMessage('Capacity reduced below current size — overflow state visually shown', 'error');\n          shakeStack();\n        } else {\n          setMessage(`Capacity set to ${capacity}`);\n        }\n        renderStack();\n      });\n\n      // Keyboard: Enter in input triggers push\n      valueInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          e.preventDefault();\n          pushBtn.click();\n        }\n      });\n\n      // Create chip from input text into palette\n      createChipBtn.addEventListener('click', () => {\n        const val = valueInput.value.trim();\n        if (!val) {\n          setMessage('Type a value to create a chip.', 'error');\n          return;\n        }\n        const chip = createPaletteChip(val);\n        palette.appendChild(chip);\n        setMessage(`Created chip \"${val}\" in palette`);\n        valueInput.value = '';\n        valueInput.focus();\n      });\n\n      // Create a palette chip element\n      function createPaletteChip(val) {\n        const chip = document.createElement('div');\n        chip.className = 'chip';\n        chip.setAttribute('role','option');\n        chip.setAttribute('tabindex','0');\n        chip.dataset.value = val;\n        chip.textContent = val;\n        makeDraggable(chip);\n        return chip;\n      }\n\n      // Make existing palette chips draggable & keyboard-pushable\n      function makeDraggable(el) {\n        // mouse/touch drag\n        let dragging = false;\n        let clone = null;\n        let startX = 0, startY = 0;\n\n        function pointerStart(e) {\n          if (animating) return;\n          dragging = true;\n          el.setPointerCapture && el.setPointerCapture(e.pointerId);\n          startX = e.clientX;\n          startY = e.clientY;\n          clone = el.cloneNode(true);\n          clone.classList.add('floating');\n          clone.style.left = e.clientX + 'px';\n          clone.style.top = e.clientY + 'px';\n          clone.style.width = el.getBoundingClientRect().width + 'px';\n          clone.style.height = el.getBoundingClientRect().height + 'px';\n          document.body.appendChild(clone);\n        }\n        function pointerMove(e) {\n          if (!dragging || !clone) return;\n          clone.style.left = e.clientX + 'px';\n          clone.style.top = e.clientY + 'px';\n        }\n        function pointerEnd(e) {\n          if (!dragging) return;\n          dragging = false;\n          if (clone) {\n            // check if release point is within stackVisual\n            const svRect = stackVisual.getBoundingClientRect();\n            if (e.clientX >= svRect.left && e.clientX <= svRect.right && e.clientY >= svRect.top && e.clientY <= svRect.bottom) {\n              // push\n              const val = el.dataset.value || el.textContent;\n              animatePush(val).catch(()=>{});\n            } else {\n              // just remove clone\n              clone.remove();\n            }\n            clone = null;\n          }\n        }\n\n        // For pointer events\n        el.addEventListener('pointerdown', pointerStart);\n        window.addEventListener('pointermove', pointerMove);\n        window.addEventListener('pointerup', pointerEnd);\n\n        // Keyboard accessibility: Enter or Space pushes value\n        el.addEventListener('keydown', (ev) => {\n          if (ev.key === 'Enter' || ev.key === ' ') {\n            ev.preventDefault();\n            const val = el.dataset.value || el.textContent;\n            animatePush(val).catch(()=>{});\n          }\n        });\n      }\n\n      // Initialize palette chips\n      const initialChips = palette.querySelectorAll('.chip');\n      initialChips.forEach(ch => {\n        ch.dataset.value = ch.textContent.trim();\n        makeDraggable(ch);\n      });\n\n      // Allow clicking on top area to focus stack and support delete/pop via keyboard (optional)\n      stackVisual.addEventListener('keydown', (e) => {\n        if (e.key === 'Delete' || e.key === 'Backspace') {\n          popBtn.click();\n        }\n      });\n\n      // Helpful initial message\n      setMessage('Ready — drag chips or type a value and Push. Use Pop to remove the top value.');\n\n      // Accessibility: expose operations to ARIA\n      // (We already use aria-live regions; further ARIA roles can be added if needed.)\n\n      // Ensure minimum spacing: dynamic enforcement not required as CSS uses gap variables.\n\n      // Expose some functions for console experimentation (developer)\n      window._stackDemo = {\n        push: (v) => animatePush(v),\n        pop: () => animatePop(),\n        peek: () => animatePeek(),\n        state: () => ({stack: stack.slice(), capacity})\n      };\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Stack.\n\n**Project Overview:**\nTopic: Stack\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Stack"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "a97ac080-bde5-11f0-95af-4764f61ee009",
    "timestamp": "2025-11-10T03:31:49.630Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Queue",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Module: Queue (FIFO)</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --card: #0b1220;\n      --accent: #06b6d4;\n      --muted: #94a3b8;\n      --success: #10b981;\n      --danger: #ef4444;\n      --slot-bg: #071126;\n      --slot-border: rgba(255,255,255,0.06);\n      --focus: 3px rgba(6,182,212,0.12);\n      --duration: 360ms;\n    }\n\n    /* Safe-area margins */\n    html,body{\n      height:100%;\n      margin:0;\n      padding:var(--safe-margin);\n      background: linear-gradient(180deg, #071024 0%, #04111a 100%);\n      color:#e6eef8;\n      font-family: Inter, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      box-sizing:border-box;\n    }\n    * { box-sizing: inherit; }\n\n    /* Layout container */\n    .wrapper{\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      max-width:1100px;\n      margin:0 auto;\n    }\n\n    header{\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:-0.3px;\n    }\n    p.lead{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* Two-column module area */\n    .module{\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n    }\n    /* Left: info & controls */\n    .panel{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      padding:16px;\n      border-radius:10px;\n      width:360px;\n      min-width:260px;\n      flex:0 0 360px;\n    }\n    .panel h2{\n      margin:0 0 8px 0;\n      font-size:16px;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* Controls */\n    .controls{\n      margin-top:12px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    label{\n      display:block;\n      font-size:13px;\n      color:var(--muted);\n      margin-bottom:8px;\n    }\n    input[type=\"text\"], input[type=\"number\"], select {\n      width:100%;\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background: rgba(255,255,255,0.02);\n      color:inherit;\n      font-size:14px;\n      outline:none;\n    }\n    input[type=\"text\"]:focus, input[type=\"number\"]:focus, select:focus{\n      box-shadow:var(--focus);\n      border-color:var(--accent);\n    }\n\n    .btn-row{\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n    }\n    button{\n      cursor:pointer;\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background: rgba(255,255,255,0.02);\n      color:inherit;\n      font-size:14px;\n      min-width:96px;\n    }\n    button.primary{\n      background:linear-gradient(180deg,var(--accent), #0695aa);\n      border: none;\n      color: #022; \n      font-weight:600;\n    }\n    button.ghost{\n      background: transparent;\n      border:1px dashed rgba(255,255,255,0.04);\n    }\n    button:disabled{\n      opacity:0.36;\n      cursor:not-allowed;\n    }\n    .small{\n      padding:8px 10px;\n      min-width:80px;\n    }\n\n    /* Right: visualization */\n    .visual{\n      flex:1 1 0;\n      min-width:300px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));\n      border:1px solid rgba(255,255,255,0.03);\n      border-radius:10px;\n      padding:20px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    .queue-area{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      align-items:center;\n      justify-content:center;\n    }\n\n    .slots{\n      display:flex;\n      gap:12px;\n      padding:12px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.008), rgba(255,255,255,0.006));\n      border-radius:10px;\n      width:100%;\n      justify-content:center;\n      overflow:hidden;\n    }\n\n    .slot{\n      width:72px;\n      height:56px;\n      border-radius:8px;\n      background:var(--slot-bg);\n      border:1px solid var(--slot-border);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      position:relative;\n      font-size:14px;\n      color:var(--muted);\n      transition: transform var(--duration) ease, box-shadow var(--duration);\n      min-width:72px;\n    }\n    .slot.filled{\n      color:#071026;\n      background:linear-gradient(180deg,#9ae6f6,#06b6d4);\n      box-shadow: 0 6px 18px rgba(6,182,212,0.12);\n      font-weight:700;\n    }\n\n    /* head/tail badges */\n    .badge{\n      position:absolute;\n      bottom:-16px;\n      left:50%;\n      transform:translateX(-50%);\n      background:rgba(255,255,255,0.04);\n      color:var(--muted);\n      padding:4px 6px;\n      border-radius:6px;\n      font-size:12px;\n      pointer-events:none;\n    }\n    .badge.head{ background: rgba(16,185,129,0.12); color:var(--success); }\n    .badge.tail{ background: rgba(6,182,212,0.08); color:var(--accent); }\n\n    /* animations */\n    .incoming{\n      animation: popIn var(--duration) ease;\n    }\n    @keyframes popIn{\n      from { transform: translateY(-16px) scale(0.92); opacity:0; }\n      to   { transform: translateY(0) scale(1); opacity:1; }\n    }\n    .outgoing{\n      animation: flyOut var(--duration) ease forwards;\n    }\n    @keyframes flyOut{\n      0% { transform: translateY(0) scale(1); opacity:1; }\n      100% { transform: translateY(-30px) scale(0.9); opacity:0; }\n    }\n\n    /* indices & log */\n    .indices{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .log{\n      background: rgba(255,255,255,0.02);\n      padding:12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.02);\n      font-size:13px;\n      color:var(--muted);\n      max-height:140px;\n      overflow:auto;\n    }\n    .log-item{\n      padding:6px 0;\n      border-bottom:1px dashed rgba(255,255,255,0.01);\n    }\n    .log-item:last-child{ border-bottom:none; }\n\n    /* responsive */\n    @media (max-width:920px){\n      .module{ flex-direction:column; }\n      .panel{ width:100%; flex:unset; }\n    }\n\n    /* focus styles for accessibility */\n    button:focus, input:focus {\n      outline: none;\n      box-shadow: var(--focus);\n    }\n\n    /* spacing rules to ensure minimum 16px between interactive elements */\n    .controls > * { margin-bottom: var(--gap); }\n    .btn-row > * { margin-bottom:0; }\n  </style>\n</head>\n<body>\n  <div class=\"wrapper\" role=\"main\">\n\n    <!-- Header + Design Plan -->\n    <header>\n      <h1>Queue (FIFO) — Interactive Module</h1>\n      <p class=\"lead\">Practice and visualize the First-In-First-Out behavior of a Queue by enqueueing and dequeueing values. Watch how head and tail move and items exit in order.</p>\n    </header>\n\n    <div class=\"module\" aria-labelledby=\"module-title\">\n\n      <!-- Left Panel: Concept + Controls -->\n      <aside class=\"panel\" aria-label=\"Module controls and explanation\">\n        <h2 id=\"module-title\">Concept & Objectives</h2>\n        <p class=\"muted\">\n          Concept Title: Queue (FIFO)\n        </p>\n        <p style=\"margin-top:8px;\">\n          Learning Objective:\n        </p>\n        <p class=\"muted\" style=\"margin-top:6px;\">\n          After using this module you should be able to:\n          <ul style=\"margin:8px 0 0 18px; color:var(--muted);\">\n            <li>Explain FIFO ordering: earliest enqueued item leaves first.</li>\n            <li>Perform enqueue, dequeue, peek, and clear operations and see pointer changes.</li>\n            <li>Recognize when the queue is empty or full and observe visual feedback.</li>\n          </ul>\n        </p>\n\n        <div style=\"margin-top:8px;\">\n          <h2 style=\"font-size:15px; margin-bottom:6px;\">Interaction Design</h2>\n          <p class=\"muted\" style=\"margin:0;\">\n            How to interact:\n          </p>\n          <ul style=\"margin:8px 0 0 18px; color:var(--muted);\">\n            <li>Type a value and press Enqueue (or Enter) to add an item. Watch it animate into the rightmost slot.</li>\n            <li>Click Dequeue to remove the front item. It will animate out and remaining items shift left — demonstrating FIFO.</li>\n            <li>Peek shows the current front item without removing it. Clear empties the queue.</li>\n            <li>Adjust Capacity to see how the queue behaves when full. Controls disable appropriately.</li>\n          </ul>\n          <p class=\"muted\" style=\"margin-top:8px;\">\n            Visual feedback & animations:\n            Items animate in and out; head and tail badges update colorfully. Logs show each operation and the queue's internal indices.\n          </p>\n        </div>\n\n        <!-- Controls -->\n        <form class=\"controls\" id=\"controls\" onsubmit=\"return false;\" aria-label=\"Queue controls\">\n          <div>\n            <label for=\"value\">Value to enqueue</label>\n            <input id=\"value\" type=\"text\" placeholder=\"e.g. A, 42, foo\" aria-label=\"Value to enqueue\" />\n          </div>\n\n          <div>\n            <label for=\"capacity\">Capacity (number of slots)</label>\n            <input id=\"capacity\" type=\"number\" min=\"1\" max=\"12\" value=\"6\" aria-label=\"Queue capacity\" />\n          </div>\n\n          <div class=\"btn-row\" role=\"group\" aria-label=\"Queue operation buttons\">\n            <button id=\"enqueueBtn\" class=\"primary\" type=\"button\">Enqueue</button>\n            <button id=\"dequeueBtn\" class=\"small\" type=\"button\">Dequeue</button>\n            <button id=\"peekBtn\" class=\"small ghost\" type=\"button\">Peek</button>\n            <button id=\"clearBtn\" class=\"small\" type=\"button\">Clear</button>\n          </div>\n\n          <div class=\"btn-row\" style=\"margin-top:8px;\">\n            <button id=\"randomBtn\" class=\"small\" type=\"button\">Fill Random</button>\n            <button id=\"autoBtn\" class=\"small ghost\" type=\"button\" aria-pressed=\"false\">Auto Enqueue</button>\n          </div>\n\n          <div style=\"margin-top:8px;\">\n            <label class=\"muted\">Operation log</label>\n            <div id=\"summary\" class=\"muted\" aria-live=\"polite\" style=\"font-size:13px; margin-top:6px;\">Queue is empty.</div>\n          </div>\n        </form>\n      </aside>\n\n      <!-- Right Panel: Visualization -->\n      <section class=\"visual\" aria-label=\"Queue visualization area\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <div>\n            <strong style=\"font-size:15px;\">Queue Visualizer</strong>\n            <div class=\"muted\" style=\"font-size:13px; margin-top:4px;\">Slots show values; head/tail badges indicate front and next-insert index.</div>\n          </div>\n          <div class=\"muted\" style=\"font-size:13px;\">FIFO: First-In, First-Out</div>\n        </div>\n\n        <div class=\"queue-area\">\n          <div id=\"slots\" class=\"slots\" role=\"list\" aria-label=\"Queue slots\">\n            <!-- slots generated by JS -->\n          </div>\n\n          <div class=\"indices\" aria-hidden=\"false\" id=\"indices\">\n            <!-- head/tail/size info -->\n          </div>\n        </div>\n\n        <div>\n          <label class=\"muted\">Detailed log</label>\n          <div id=\"log\" class=\"log\" role=\"log\" aria-live=\"polite\" aria-atomic=\"false\">\n            <!-- operations appended here -->\n          </div>\n        </div>\n      </section>\n\n    </div>\n\n  </div>\n\n  <script>\n    (function(){\n      // Accessibility: trap focus and keyboard labels are native via elements.\n      // Module state\n      const capacityInput = document.getElementById('capacity');\n      const valueInput = document.getElementById('value');\n      const enqueueBtn = document.getElementById('enqueueBtn');\n      const dequeueBtn = document.getElementById('dequeueBtn');\n      const peekBtn = document.getElementById('peekBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const randomBtn = document.getElementById('randomBtn');\n      const autoBtn = document.getElementById('autoBtn');\n\n      const slotsEl = document.getElementById('slots');\n      const logEl = document.getElementById('log');\n      const summaryEl = document.getElementById('summary');\n      const indicesEl = document.getElementById('indices');\n\n      let queue = []; // array storing values left-to-right\n      let capacity = parseInt(capacityInput.value, 10) || 6;\n      let autoInterval = null;\n\n      const ANIM = 360; // ms - must match CSS var --duration\n\n      // Utilities\n      function log(msg, tone){\n        const item = document.createElement('div');\n        item.className = 'log-item';\n        item.textContent = `${new Date().toLocaleTimeString()}: ${msg}`;\n        if(tone === 'error') item.style.color = 'var(--danger)';\n        if(tone === 'ok') item.style.color = 'var(--muted)';\n        logEl.prepend(item);\n      }\n\n      function updateSummary(){\n        summaryEl.textContent = `Size: ${queue.length} / ${capacity}. ${queue.length === 0 ? 'Queue is empty.' : queue.length === capacity ? 'Queue is full.' : '' }`;\n      }\n\n      function updateIndices(){\n        indicesEl.innerHTML = '';\n        const head = document.createElement('div');\n        head.textContent = `head = 0`;\n        head.style.marginRight = '8px';\n        indicesEl.appendChild(head);\n\n        const tail = document.createElement('div');\n        tail.textContent = `tail = ${queue.length}`;\n        indicesEl.appendChild(tail);\n\n        const size = document.createElement('div');\n        size.textContent = `size = ${queue.length}`;\n        size.style.color = 'var(--muted)';\n        indicesEl.appendChild(size);\n      }\n\n      function createSlot(value, index){\n        const s = document.createElement('div');\n        s.className = 'slot';\n        s.setAttribute('role','listitem');\n        s.setAttribute('aria-label', value === null ? `Empty slot ${index}` : `Slot ${index} containing ${value}`);\n        if(value !== null && value !== undefined){\n          s.classList.add('filled');\n          s.textContent = value;\n        } else {\n          s.textContent = '';\n        }\n        // badges for head and tail\n        if(index === 0){\n          const b = document.createElement('div');\n          b.className = 'badge head';\n          b.textContent = 'HEAD';\n          s.appendChild(b);\n        }\n        if(index === queue.length){ // tail indicates next insertion index\n          const b2 = document.createElement('div');\n          b2.className = 'badge tail';\n          b2.textContent = 'TAIL';\n          s.appendChild(b2);\n        }\n        return s;\n      }\n\n      function renderSlots(animateShift=false){\n        // Create desired slots: capacity many\n        slotsEl.innerHTML = '';\n        for(let i=0;i<capacity;i++){\n          const val = queue[i] !== undefined ? queue[i] : null;\n          const slot = createSlot(val, i);\n          slotsEl.appendChild(slot);\n        }\n        updateSummary();\n        updateIndices();\n        // Disable/Enable controls based on state\n        enqueueBtn.disabled = queue.length >= capacity;\n        dequeueBtn.disabled = queue.length === 0;\n        peekBtn.disabled = queue.length === 0;\n      }\n\n      // Enqueue with animation\n      function enqueue(value){\n        if(value === null || value === undefined || String(value).trim() === ''){\n          valueInput.focus();\n          log('Enqueue aborted: empty value', 'error');\n          return;\n        }\n        if(queue.length >= capacity){\n          log('Enqueue failed: queue is full', 'error');\n          return;\n        }\n        // Create a floating pill that animates into the rightmost empty slot\n        const slotIndex = queue.length;\n        const targetSlot = slotsEl.children[slotIndex];\n        const floating = document.createElement('div');\n        floating.style.position = 'absolute';\n        floating.style.zIndex = 999;\n        floating.style.padding = '8px 12px';\n        floating.style.borderRadius = '8px';\n        floating.style.background = 'linear-gradient(180deg,#9ae6f6,#06b6d4)';\n        floating.style.color = '#022';\n        floating.style.fontWeight = '700';\n        floating.style.left = (valueInput.getBoundingClientRect().left) + 'px';\n        floating.style.top = (valueInput.getBoundingClientRect().top) + 'px';\n        floating.textContent = value;\n        document.body.appendChild(floating);\n\n        // compute target center\n        const startRect = floating.getBoundingClientRect();\n        const targetRect = targetSlot.getBoundingClientRect();\n        const dx = targetRect.left + targetRect.width/2 - (startRect.left + startRect.width/2);\n        const dy = targetRect.top + targetRect.height/2 - (startRect.top + startRect.height/2);\n\n        floating.animate([\n          { transform: 'translate(0,0) scale(0.98)', opacity: 0.95 },\n          { transform: `translate(${dx}px, ${dy}px) scale(1)`, opacity: 1 }\n        ], { duration: ANIM, easing: 'cubic-bezier(.2,.8,.2,1)'});\n\n        setTimeout(()=> {\n          // finalize\n          document.body.removeChild(floating);\n          queue.push(value);\n          // add visual fill class on slot with incoming animation\n          const slot = slotsEl.children[slotIndex];\n          slot.classList.add('filled','incoming');\n          slot.textContent = value;\n          // re-append badges to keep head/tail correct\n          // remove any existing badges\n          for(const ch of slot.querySelectorAll('.badge')) ch.remove();\n          if(slotIndex === 0){\n            const b = document.createElement('div');\n            b.className = 'badge head';\n            b.textContent = 'HEAD';\n            slot.appendChild(b);\n          }\n          const tailSlot = slotsEl.children[queue.length];\n          // update previous tail badge if any\n          for(const s of slotsEl.querySelectorAll('.slot .badge.tail')) {\n            s.remove();\n          }\n          if(queue.length <= capacity-1){\n            const b2 = document.createElement('div');\n            b2.className = 'badge tail';\n            b2.textContent = 'TAIL';\n            // append to correct slot\n            slotsEl.children[queue.length].appendChild(b2);\n          }\n\n          setTimeout(()=> { // remove incoming class\n            slot.classList.remove('incoming');\n          }, ANIM + 50);\n\n          log(`Enqueued \"${value}\"`, 'ok');\n          updateSummary();\n          updateIndices();\n          enqueueBtn.disabled = queue.length >= capacity;\n          dequeueBtn.disabled = queue.length === 0;\n        }, ANIM + 10);\n\n      }\n\n      // Dequeue with animation\n      function dequeue(){\n        if(queue.length === 0){\n          log('Dequeue failed: queue is empty', 'error');\n          return;\n        }\n        // animate head slot outgoing\n        const headSlot = slotsEl.children[0];\n        // create an outgoing visual by cloning\n        const outgoing = headSlot.cloneNode(true);\n        outgoing.style.position = 'absolute';\n        const headRect = headSlot.getBoundingClientRect();\n        outgoing.style.left = headRect.left + 'px';\n        outgoing.style.top = headRect.top + 'px';\n        outgoing.style.width = headRect.width + 'px';\n        outgoing.style.height = headRect.height + 'px';\n        outgoing.style.zIndex = 1000;\n        document.body.appendChild(outgoing);\n        outgoing.classList.add('outgoing');\n\n        setTimeout(()=> {\n          document.body.removeChild(outgoing);\n        }, ANIM + 10);\n\n        const removed = queue.shift();\n        log(`Dequeued \"${removed}\"`, 'ok');\n\n        // Re-render slots with a small shift animation for remaining items\n        // We'll animate each existing filled slot to the left slightly for visual shift\n        // First re-render empty then populate with animated incoming for each slot to simulate motion\n        for(let i=0;i<capacity;i++){\n          slotsEl.children[i].classList.remove('filled','incoming');\n          slotsEl.children[i].textContent = '';\n          for(const ch of slotsEl.children[i].querySelectorAll('.badge')) ch.remove();\n        }\n\n        // populate after a tiny timeout to allow outgoing to start\n        setTimeout(()=> {\n          for(let i=0;i<queue.length;i++){\n            const s = slotsEl.children[i];\n            s.textContent = queue[i];\n            s.classList.add('filled');\n            // subtle shift animation\n            s.animate([\n              { transform: 'translateX(8px)', opacity: 0.9 },\n              { transform: 'translateX(0)', opacity: 1 }\n            ], { duration: ANIM, easing: 'cubic-bezier(.2,.8,.2,1)'});\n          }\n          // badges\n          if(queue.length > 0){\n            const b = document.createElement('div');\n            b.className = 'badge head';\n            b.textContent = 'HEAD';\n            slotsEl.children[0].appendChild(b);\n\n            // tail points to next insert index\n            if(queue.length <= capacity-1){\n              const b2 = document.createElement('div');\n              b2.className = 'badge tail';\n              b2.textContent = 'TAIL';\n              slotsEl.children[queue.length].appendChild(b2);\n            }\n          } else {\n            // empty queue -> tail = 0\n            const b2 = document.createElement('div');\n            b2.className = 'badge tail';\n            b2.textContent = 'TAIL';\n            slotsEl.children[0].appendChild(b2);\n          }\n\n          updateSummary();\n          updateIndices();\n          enqueueBtn.disabled = queue.length >= capacity;\n          dequeueBtn.disabled = queue.length === 0;\n          peekBtn.disabled = queue.length === 0;\n        }, Math.min(ANIM, 220));\n      }\n\n      function peek(){\n        if(queue.length === 0){\n          log('Peek: queue is empty', 'error');\n          return;\n        }\n        const front = queue[0];\n        log(`Peek: \"${front}\" is at the front`, 'ok');\n        // flash head slot to show peek\n        const head = slotsEl.children[0];\n        head.animate([\n          { boxShadow: '0 0 0 rgba(255,255,255,0)' },\n          { boxShadow: '0 10px 26px rgba(6,182,212,0.14)' },\n          { boxShadow: '0 0 0 rgba(255,255,255,0)' }\n        ], { duration: 420, easing: 'ease-out' });\n      }\n\n      function clearQueue(){\n        if(queue.length === 0){\n          log('Clear: queue already empty', 'ok');\n          return;\n        }\n        queue = [];\n        // animate clearing by fading each filled slot\n        for(let i=0;i<capacity;i++){\n          const s = slotsEl.children[i];\n          if(s.classList.contains('filled')){\n            s.animate([\n              { transform: 'translateY(0)', opacity:1 },\n              { transform: 'translateY(-10px) scale(0.98)', opacity:0.0 }\n            ], { duration: ANIM, easing: 'ease-in' });\n          }\n        }\n        setTimeout(()=> {\n          renderSlots();\n          log('Cleared queue', 'ok');\n        }, ANIM + 20);\n      }\n\n      // Fill with random strings to demonstrate\n      function fillRandom(){\n        const sample = ['A','B','C','D','E','1','2','3','X','Y','Z','foo','bar'];\n        clearQueue();\n        // enqueue up to capacity with small delays so animations visible\n        let i=0;\n        const toAdd = Math.min(capacity, Math.floor(Math.random()*capacity)+1);\n        const interval = setInterval(()=> {\n          if(i >= toAdd) { clearInterval(interval); return; }\n          const v = sample[Math.floor(Math.random()*sample.length)] + (Math.random()<0.4 ? Math.floor(Math.random()*9) : '');\n          enqueue(v);\n          i++;\n        }, ANIM + 100);\n      }\n\n      // Auto enqueue toggle\n      function toggleAuto(){\n        if(autoInterval){\n          clearInterval(autoInterval);\n          autoInterval = null;\n          autoBtn.textContent = 'Auto Enqueue';\n          autoBtn.setAttribute('aria-pressed','false');\n          log('Auto enqueue stopped', 'ok');\n          return;\n        }\n        autoBtn.textContent = 'Stop Auto';\n        autoBtn.setAttribute('aria-pressed','true');\n        log('Auto enqueue started', 'ok');\n        autoInterval = setInterval(()=> {\n          if(queue.length >= capacity){\n            // stop when full\n            clearInterval(autoInterval);\n            autoInterval = null;\n            autoBtn.textContent = 'Auto Enqueue';\n            autoBtn.setAttribute('aria-pressed','false');\n            log('Auto enqueue stopped (queue full)', 'ok');\n            return;\n          }\n          const randomValue = Math.random().toString(36).substring(2,5).toUpperCase();\n          enqueue(randomValue);\n        }, ANIM + 600);\n      }\n\n      // Initial render\n      function init(){\n        // create empty slots first\n        for(let i=0;i<capacity;i++){\n          const slot = createSlot(null, i);\n          slotsEl.appendChild(slot);\n        }\n        // initial tail badge at 0\n        const b2 = document.createElement('div');\n        b2.className = 'badge tail';\n        b2.textContent = 'TAIL';\n        slotsEl.children[0].appendChild(b2);\n\n        updateSummary();\n        updateIndices();\n        dequeueBtn.disabled = true;\n        peekBtn.disabled = true;\n      }\n\n      // Event bindings\n      enqueueBtn.addEventListener('click', ()=> {\n        const v = valueInput.value;\n        enqueue(v);\n        valueInput.value = '';\n        valueInput.focus();\n      });\n\n      // Allow Enter key in input to enqueue\n      valueInput.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter'){\n          e.preventDefault();\n          enqueueBtn.click();\n        }\n      });\n\n      dequeueBtn.addEventListener('click', ()=> dequeue());\n      peekBtn.addEventListener('click', ()=> peek());\n      clearBtn.addEventListener('click', ()=> clearQueue());\n      randomBtn.addEventListener('click', ()=> fillRandom());\n      autoBtn.addEventListener('click', ()=> toggleAuto());\n\n      capacityInput.addEventListener('change', ()=>{\n        const newCap = parseInt(capacityInput.value, 10) || 1;\n        // clamp to 1..12\n        capacity = Math.max(1, Math.min(12, newCap));\n        capacityInput.value = capacity;\n        // if new capacity is less than current size, drop tail items visually\n        if(queue.length > capacity){\n          queue = queue.slice(0, capacity);\n          log('Capacity reduced: dropped items beyond new capacity', 'error');\n        }\n        renderSlots();\n      });\n\n      // Initialize\n      init();\n\n      // Expose for debugging (not necessary)\n      window._queueModule = { enqueue, dequeue, peek, clearQueue, renderSlots };\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Queue.\n\n**Project Overview:**\nTopic: Queue\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Queue"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Queue Visualizer (FIFO)",
      "description": "Models the interactive states and transitions for a Queue visualizer UI that supports enqueue, dequeue, peek, clear, random fill, auto-enqueue, and capacity changes with animations and logging.",
      "states": [
        {
          "name": "idle",
          "onEnter": "renderSlots",
          "onExit": "noop",
          "on": {
            "INIT": "idle",
            "ENQUEUE_CLICK": "enqueueing",
            "ENTER_KEY": "enqueueing",
            "ENQUEUE_FAILED_EMPTY": "idle",
            "ENQUEUE_FAILED_FULL": "idle",
            "DEQUEUE_CLICK": "dequeueing",
            "DEQUEUE_FAILED_EMPTY": "idle",
            "PEEK_CLICK": "peeking",
            "PEEK_FAILED_EMPTY": "idle",
            "CLEAR_CLICK": "clearing",
            "FILL_RANDOM_CLICK": "fillingRandom",
            "AUTO_TOGGLE_ON": "autoRunning",
            "AUTO_TOGGLE_OFF": "idle",
            "CAPACITY_CHANGE": "idle"
          }
        },
        {
          "name": "enqueueing",
          "onEnter": "startEnqueueAnimation",
          "onExit": "finalizeEnqueue",
          "on": {
            "ENQUEUE_ANIMATION_END": "idle",
            "ENQUEUE_FAILED_FULL": "idle",
            "ENQUEUE_ABORT": "idle"
          }
        },
        {
          "name": "dequeueing",
          "onEnter": "startDequeueAnimation",
          "onExit": "finalizeDequeue",
          "on": {
            "DEQUEUE_ANIMATION_END": "idle",
            "DEQUEUE_FAILED_EMPTY": "idle"
          }
        },
        {
          "name": "peeking",
          "onEnter": "flashHeadAndLog",
          "onExit": "noop",
          "on": {
            "PEEK_ANIMATION_END": "idle",
            "PEEK_FAILED_EMPTY": "idle"
          }
        },
        {
          "name": "clearing",
          "onEnter": "startClearAnimation",
          "onExit": "finalizeClear",
          "on": {
            "CLEAR_ANIMATION_END": "idle"
          }
        },
        {
          "name": "fillingRandom",
          "onEnter": "clearThenEnqueueSequence",
          "onExit": "noop",
          "on": {
            "FILL_RANDOM_STEP_COMPLETE": "fillingRandom",
            "FILL_RANDOM_FINISHED": "idle",
            "FILL_RANDOM_ABORT": "idle"
          }
        },
        {
          "name": "autoRunning",
          "onEnter": "startAutoInterval",
          "onExit": "stopAutoInterval",
          "on": {
            "AUTO_STEP": "enqueueing",
            "AUTO_STOP": "idle",
            "AUTO_TOGGLE_OFF": "idle",
            "AUTO_STOPPED_FULL": "idle",
            "ENQUEUE_FAILED_FULL": "autoRunning"
          }
        }
      ],
      "events": [
        "INIT",
        "ENQUEUE_CLICK",
        "ENTER_KEY",
        "ENQUEUE_ANIMATION_END",
        "ENQUEUE_FAILED_EMPTY",
        "ENQUEUE_FAILED_FULL",
        "ENQUEUE_ABORT",
        "DEQUEUE_CLICK",
        "DEQUEUE_ANIMATION_END",
        "DEQUEUE_FAILED_EMPTY",
        "PEEK_CLICK",
        "PEEK_ANIMATION_END",
        "PEEK_FAILED_EMPTY",
        "CLEAR_CLICK",
        "CLEAR_ANIMATION_END",
        "FILL_RANDOM_CLICK",
        "FILL_RANDOM_STEP_COMPLETE",
        "FILL_RANDOM_FINISHED",
        "FILL_RANDOM_ABORT",
        "AUTO_TOGGLE_ON",
        "AUTO_TOGGLE_OFF",
        "AUTO_STEP",
        "AUTO_STOP",
        "AUTO_STOPPED_FULL",
        "CAPACITY_CHANGE"
      ],
      "notes": "States represent interactive modes in the UI. onEnter/onExit names map to the functions/actions in the code (e.g. startEnqueueAnimation creates the floating element and pushes a value after ANIM ms; finalizeEnqueue updates slot badges and logging). Events include both user-triggered actions (button clicks, Enter key) and internal lifecycle events (animation end, auto-step, capacity change). Error conditions (empty input, full queue) are modeled as explicit failed events that return to idle while producing log/error actions. Auto-running is modeled as a distinct state that repeatedly issues AUTO_STEP events which transition into enqueueing; when auto stops (manual toggle or queue full) it returns to idle. Rendering and controls enabling/disabling are performed on idle onEnter (renderSlots/updateSummary/updateIndices)."
    }
  },
  {
    "id": "cb6cc8f0-bde5-11f0-95af-4764f61ee009",
    "timestamp": "2025-11-10T03:31:50.656Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Linked List",
    "answer": {
      "role": "assistant",
      "content": "Below is a complete, self-contained HTML file that implements a single interactive module teaching the singly linked list. It includes the required textual sections (Concept Title, Learning Objective, Interaction Design, Layout Description) and a hands-on visualization with animations, accessibility features, and responsive layout. Copy-paste into a file (e.g., linked-list.html) and open in a browser.\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Linked List Module</title>\n  <style>\n    /* Safe area margins: 24px on all sides */\n    :root {\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #06b6d4;\n      --muted: #94a3b8;\n      --node-bg: #12223a;\n      --node-border: #184e63;\n      --success: #16a34a;\n      --danger: #ef4444;\n      --shadow: 0 6px 18px rgba(2,6,23,0.6);\n    }\n\n    html,body {\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg, #071025 0%, #071428 100%);\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      color: #e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    .app {\n      padding: var(--safe-margin);\n      box-sizing: border-box;\n      min-height:100%;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    .header {\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      flex-wrap:wrap;\n    }\n\n    .title {\n      flex:1 1 360px;\n    }\n    .title h1 {\n      margin:0 0 8px 0;\n      font-size:20px;\n      letter-spacing: -0.2px;\n    }\n    .subtitle {\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    .meta {\n      min-width:240px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      padding:12px;\n      border-radius:10px;\n      box-shadow: var(--shadow);\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    .layout {\n      display:grid;\n      grid-template-columns: 360px 1fr;\n      gap:var(--gap);\n      align-items:start;\n    }\n\n    /* Controls column */\n    .controls {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      padding:16px;\n      border-radius:12px;\n      box-shadow: var(--shadow);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    .controls label {\n      font-size:13px;\n      color:var(--muted);\n    }\n    .input-row {\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n    }\n    input[type=\"text\"], input[type=\"number\"], select {\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.04);\n      background: rgba(255,255,255,0.02);\n      color: #e6eef8;\n      outline:none;\n      font-size:14px;\n      flex:1;\n    }\n    button {\n      padding:10px 12px;\n      border-radius:8px;\n      border: none;\n      background: linear-gradient(180deg, var(--accent), #028aa6);\n      color: #042f36;\n      font-weight:600;\n      cursor:pointer;\n      box-shadow: 0 6px 12px rgba(3,20,30,0.45);\n    }\n    button.secondary {\n      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));\n      color: var(--muted);\n      border:1px solid rgba(255,255,255,0.03);\n      box-shadow:none;\n    }\n    .btn-row {\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n    }\n\n    .hint {\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Visualizer */\n    .visual {\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border:1px solid rgba(255,255,255,0.03);\n      padding:16px;\n      border-radius:12px;\n      box-shadow: var(--shadow);\n      min-height:320px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    .canvas {\n      background: linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:10px;\n      padding:16px;\n      overflow:auto;\n      min-height:160px;\n      display:flex;\n      align-items:center;\n      gap:24px; /* at least 16px but keep nicer spacing */\n      position:relative;\n    }\n\n    .node {\n      background: linear-gradient(180deg, #0f2638, #071422);\n      border-radius:10px;\n      border:1px solid var(--node-border);\n      padding:10px;\n      width:120px;\n      min-width:120px;\n      display:flex;\n      align-items:center;\n      gap:8px;\n      box-shadow: 0 8px 18px rgba(0,0,0,0.6);\n      transform-origin:center;\n      transition: transform 420ms cubic-bezier(.2,.9,.3,1), opacity 260ms;\n      position:relative;\n      outline: none;\n    }\n    .node:focus {\n      box-shadow: 0 12px 28px rgba(2,10,20,0.6), 0 0 0 3px rgba(6,182,212,0.12);\n      transform: translateY(-4px);\n    }\n\n    .node .value {\n      flex:1;\n      font-weight:700;\n      color:#dff6fb;\n      font-size:16px;\n      text-align:center;\n    }\n    .node .ptr {\n      width:28px;\n      height:28px;\n      border-radius:6px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      color:var(--muted);\n      font-size:12px;\n      position:relative;\n    }\n    .node.selected {\n      box-shadow: 0 12px 30px rgba(3,20,30,0.7), 0 0 0 4px rgba(6,182,212,0.14);\n      transform: translateY(-6px) scale(1.02);\n    }\n\n    .node.removing {\n      opacity:0;\n      transform: translateY(-24px) scale(0.95);\n    }\n\n    .node.inserting {\n      opacity:0;\n      transform: translateY(24px) scale(0.9);\n      animation: drop-in 420ms forwards cubic-bezier(.2,.9,.3,1);\n    }\n    @keyframes drop-in {\n      to { opacity:1; transform: translateY(0) scale(1); }\n    }\n\n    /* Head label */\n    .head-label {\n      position:absolute;\n      top:8px;\n      left:16px;\n      font-size:13px;\n      color:var(--muted);\n      display:flex;\n      align-items:center;\n      gap:8px;\n    }\n    .null-label {\n      position:absolute;\n      right:24px;\n      bottom:12px;\n      font-size:13px;\n      color:var(--muted);\n      display:flex;\n      align-items:center;\n      gap:8px;\n    }\n\n    /* Traversal highlight */\n    .node.current {\n      animation: pulse 900ms infinite;\n      box-shadow: 0 14px 36px rgba(6,182,212,0.14);\n      transform: translateY(-8px) scale(1.02);\n    }\n    @keyframes pulse {\n      0% { box-shadow: 0 12px 28px rgba(6,182,212,0.08); }\n      50% { box-shadow: 0 20px 46px rgba(6,182,212,0.16); }\n      100% { box-shadow: 0 12px 28px rgba(6,182,212,0.08); }\n    }\n\n    /* small footer log */\n    .log {\n      background:rgba(255,255,255,0.01);\n      border-radius:8px;\n      padding:12px;\n      font-size:13px;\n      color:var(--muted);\n      min-height:48px;\n    }\n\n    /* responsive */\n    @media (max-width:900px){\n      .layout { grid-template-columns: 1fr; }\n      .controls { order:2; }\n      .visual { order:1; }\n      .header { align-items:flex-start; }\n    }\n\n    /* minimal arrow svg overlay */\n    .svg-overlay {\n      position:absolute;\n      inset:0;\n      pointer-events:none;\n    }\n\n    /* focus styles for keyboard accessibility on node buttons */\n    .node[tabindex] { outline:none; }\n    .sr-only { position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden; }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"main\">\n    <div class=\"header\" aria-hidden=\"false\">\n      <div class=\"title\">\n        <h1>Linked List — Singly Linked List (Interactive)</h1>\n        <p class=\"subtitle\">Explore nodes, insertions, deletions, and traversal with animated feedback.</p>\n      </div>\n      <div class=\"meta\" aria-labelledby=\"meta-heading\">\n        <strong id=\"meta-heading\">Quick Overview</strong>\n        <p style=\"margin:8px 0 0 0; color:var(--muted); font-size:13px;\">\n          This module focuses on a single concept: singly linked lists and how nodes connect through \"next\" pointers. Use the controls to add, insert, remove and step through nodes to see how references change.\n        </p>\n      </div>\n    </div>\n\n    <div class=\"layout\" role=\"region\" aria-label=\"Linked list interactive module\">\n      <!-- Controls Column -->\n      <section class=\"controls\" aria-labelledby=\"controls-heading\">\n        <h2 id=\"controls-heading\" style=\"margin:0 0 8px 0; font-size:15px;\">Controls</h2>\n\n        <div>\n          <label for=\"value-input\">Node value</label>\n          <div class=\"input-row\" style=\"margin-top:8px;\">\n            <input id=\"value-input\" type=\"text\" placeholder=\"e.g. 42\" aria-label=\"Node value\" />\n            <button id=\"add-head-btn\" title=\"Insert at head\">Add Head</button>\n          </div>\n        </div>\n\n        <div>\n          <label for=\"value-insert\">Insert / Remove</label>\n          <div class=\"input-row\" style=\"margin-top:8px;\">\n            <input id=\"value-insert\" type=\"text\" placeholder=\"value to insert\" aria-label=\"Value to insert after selected node\" />\n            <button id=\"insert-after-btn\" class=\"secondary\">Insert After</button>\n          </div>\n          <div style=\"margin-top:8px;\">\n            <button id=\"append-btn\" class=\"secondary\">Append Tail</button>\n            <button id=\"delete-btn\" class=\"danger\" style=\"background: linear-gradient(180deg,#ef4444,#d33); color:#fff; border:none;\">Delete Selected</button>\n          </div>\n        </div>\n\n        <div>\n          <label>Traversal</label>\n          <div class=\"btn-row\" style=\"margin-top:8px;\">\n            <button id=\"traverse-step\" class=\"secondary\">Step</button>\n            <button id=\"traverse-play\">Play</button>\n            <button id=\"traverse-reset\" class=\"secondary\">Reset</button>\n            <select id=\"speed\" style=\"width:110px;\">\n              <option value=\"800\">Slow</option>\n              <option value=\"500\" selected>Normal</option>\n              <option value=\"250\">Fast</option>\n            </select>\n          </div>\n          <p class=\"hint\" style=\"margin-top:8px;\">Select a node by clicking it (or Tab → Enter). Use Insert After to place a node after the selected node.</p>\n        </div>\n\n        <div>\n          <label>Accessibility & Feedback</label>\n          <div style=\"margin-top:8px;\">\n            <button id=\"reset-btn\" class=\"secondary\">Reset List</button>\n            <button id=\"random-btn\" class=\"secondary\">Generate Example</button>\n          </div>\n          <p class=\"hint\" style=\"margin-top:8px;\">All operations announce changes via the log area and are keyboard-accessible.</p>\n        </div>\n\n        <div style=\"margin-top:8px;\">\n          <label style=\"display:block; margin-bottom:8px;\">Concept & Objective</label>\n          <div style=\"background:rgba(255,255,255,0.01); padding:10px; border-radius:8px; font-size:13px; color:var(--muted);\">\n            <strong>Concept Title:</strong> Singly Linked List (nodes with a value and a next pointer)<br>\n            <strong>Learning Objective:</strong> After using this module you will understand node relationships, how insertion and removal affect pointers, and how traversal visits nodes sequentially.\n          </div>\n        </div>\n\n      </section>\n\n      <!-- Visualizer Column -->\n      <section class=\"visual\" aria-labelledby=\"visual-heading\">\n        <h2 id=\"visual-heading\" style=\"margin:0 0 8px 0; font-size:15px;\">Visualizer</h2>\n        <div class=\"canvas\" id=\"canvas\" role=\"region\" aria-label=\"Linked list canvas\">\n          <div class=\"head-label\" id=\"head-label\">Head →</div>\n          <div id=\"nodes\" style=\"display:flex; gap:24px; align-items:center; padding:8px;\"></div>\n          <div class=\"null-label\" id=\"null-label\">Null</div>\n          <svg class=\"svg-overlay\" id=\"overlay\" aria-hidden=\"true\"></svg>\n        </div>\n\n        <div class=\"log\" id=\"log\" aria-live=\"polite\" aria-atomic=\"true\">\n          The list is empty. Use \"Add Head\" or \"Append Tail\" to create nodes.\n        </div>\n      </section>\n    </div>\n\n    <!-- Explanatory sections: Interaction Design & Layout Description -->\n    <section style=\"background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); padding:16px; border-radius:12px; border:1px solid rgba(255,255,255,0.02);\">\n      <h3 style=\"margin:0 0 8px 0;\">Interaction Design</h3>\n      <p style=\"margin:0 0 8px 0; color:var(--muted); font-size:13px;\">\n        - Click a node or use keyboard Tab + Enter to select it. Selected nodes are visually elevated. <br>\n        - Add Head: creates a new node at the front; it animates into place. <br>\n        - Append Tail: adds a node at the end; nodes shift and connecting arrows update. <br>\n        - Insert After: insert a new node immediately after the currently selected node. If none is selected, the button is disabled. <br>\n        - Delete Selected: removes the selected node with a fade/slide animation; pointers update accordingly. <br>\n        - Traversal: Step advances a \"current\" highlight to the next node and announces the value. Play automatically steps through nodes with a chosen speed; Reset stops traversal and clears highlights. <br>\n        - Visual feedback includes node insert/delete animations, a pulsing highlight for the current traversal node, and SVG arrows that update positions smoothly.\n      </p>\n\n      <h3 style=\"margin:12px 0 8px 0;\">Layout Description</h3>\n      <p style=\"margin:0; color:var(--muted); font-size:13px;\">\n        - Safe area: the entire layout uses a 24px padding on all sides. Controls and visuals use a minimum 16px spacing. <br>\n        - The page uses a two-column layout: the left column contains controls and forms (fixed min-width 360px); the right column contains the interactive visual canvas and log. <br>\n        - The canvas shows nodes in a horizontal row with arrows drawn via an SVG overlay. It is scrollable on small screens. Controls wrap under the visualizer for narrow viewports to maintain clarity and focus. <br>\n        - Accessibility: controls have labels, nodes are keyboard-focusable, and user actions produce text updates in an aria-live log for screen readers.\n      </p>\n    </section>\n  </div>\n\n  <script>\n    // ===========================\n    // Linked List Interactive Module (Vanilla JS)\n    // ===========================\n    (function () {\n      // Model: singly linked list represented as an array of nodes {id, value}\n      let nodes = []; // order represents links: nodes[i].next -> nodes[i+1] or null\n      let selectedId = null;\n      let currentTraversalIndex = -1;\n      let traversalTimer = null;\n\n      // DOM elements\n      const nodesContainer = document.getElementById('nodes');\n      const overlay = document.getElementById('overlay');\n      const logEl = document.getElementById('log');\n      const valueInput = document.getElementById('value-input');\n      const addHeadBtn = document.getElementById('add-head-btn');\n      const appendBtn = document.getElementById('append-btn');\n      const insertAfterBtn = document.getElementById('insert-after-btn');\n      const deleteBtn = document.getElementById('delete-btn');\n      const resetBtn = document.getElementById('reset-btn');\n      const randomBtn = document.getElementById('random-btn');\n      const traverseStepBtn = document.getElementById('traverse-step');\n      const traversePlayBtn = document.getElementById('traverse-play');\n      const traverseResetBtn = document.getElementById('traverse-reset');\n      const speedSelect = document.getElementById('speed');\n      const valueInsert = document.getElementById('value-insert');\n\n      // Utility: unique IDs\n      let idCounter = 1;\n      function newId() { return 'n' + (idCounter++); }\n\n      // Logging helper\n      function log(msg) {\n        logEl.textContent = msg;\n      }\n\n      // Render nodes as DOM elements, compute arrow positions\n      function render() {\n        // Clear container\n        nodesContainer.innerHTML = '';\n        // Create node elements\n        nodes.forEach((node, index) => {\n          const el = document.createElement('div');\n          el.className = 'node';\n          el.setAttribute('data-id', node.id);\n          el.setAttribute('role', 'button');\n          el.setAttribute('tabindex', '0');\n          el.setAttribute('aria-pressed', selectedId === node.id ? 'true' : 'false');\n          if (selectedId === node.id) el.classList.add('selected');\n          if (node.inserting) el.classList.add('inserting');\n          if (node.removing) el.classList.add('removing');\n\n          const value = document.createElement('div');\n          value.className = 'value';\n          value.textContent = node.value;\n\n          const ptr = document.createElement('div');\n          ptr.className = 'ptr';\n          ptr.innerHTML = '&#8594;'; // right arrow for pointer field\n          ptr.setAttribute('aria-hidden', 'true');\n          el.appendChild(value);\n          el.appendChild(ptr);\n\n          // Click & keyboard handlers\n          el.addEventListener('click', () => selectNode(node.id));\n          el.addEventListener('keydown', (e) => {\n            if (e.key === 'Enter' || e.key === ' ') {\n              e.preventDefault();\n              selectNode(node.id);\n            }\n          });\n\n          nodesContainer.appendChild(el);\n        });\n\n        // Update overlay to draw arrows\n        updateOverlay();\n\n        // Update button states\n        insertAfterBtn.disabled = selectedId === null;\n        deleteBtn.disabled = selectedId === null;\n      }\n\n      // Select a node by id\n      function selectNode(id) {\n        if (!nodes.find(n => n.id === id)) return;\n        selectedId = id;\n        render();\n        const node = nodes.find(n => n.id === id);\n        log('Selected node with value: ' + node.value);\n      }\n\n      // Add at head\n      function addHead(value) {\n        const id = newId();\n        const node = { id, value: String(value), inserting:true };\n        nodes.unshift(node);\n        selectedId = node.id;\n        render();\n        // clear inserting flag after animation\n        setTimeout(() => { node.inserting = false; render(); }, 500);\n        log('Inserted ' + value + ' at head');\n      }\n\n      // Append tail\n      function appendTail(value) {\n        const id = newId();\n        const node = { id, value: String(value), inserting:true };\n        nodes.push(node);\n        selectedId = node.id;\n        render();\n        setTimeout(() => { node.inserting = false; render(); }, 500);\n        log('Appended ' + value + ' to tail');\n      }\n\n      // Insert after selected\n      function insertAfterSelected(value) {\n        if (selectedId === null) {\n          log('No node selected to insert after.');\n          return;\n        }\n        const idx = nodes.findIndex(n => n.id === selectedId);\n        if (idx === -1) return;\n        const node = { id: newId(), value: String(value), inserting:true };\n        nodes.splice(idx + 1, 0, node);\n        selectedId = node.id;\n        render();\n        setTimeout(() => { node.inserting = false; render(); }, 500);\n        log('Inserted ' + value + ' after selected node');\n      }\n\n      // Delete selected\n      function deleteSelected() {\n        if (selectedId === null) {\n          log('No node selected to delete.');\n          return;\n        }\n        const idx = nodes.findIndex(n => n.id === selectedId);\n        if (idx === -1) return;\n        const removed = nodes[idx];\n        removed.removing = true;\n        render();\n        // remove from model after animation\n        setTimeout(() => {\n          nodes = nodes.filter(n => n.id !== removed.id);\n          selectedId = null;\n          render();\n          log('Deleted node with value: ' + removed.value);\n        }, 420);\n      }\n\n      // Reset list\n      function resetList() {\n        nodes = [];\n        selectedId = null;\n        stopTraversal();\n        render();\n        log('List reset.');\n      }\n\n      // Generate example\n      function randomExample() {\n        resetList();\n        const sample = ['A', 'B', 'C', 'D'].map((v,i) => ({ id: newId(), value: v }));\n        nodes = sample;\n        selectedId = nodes.length ? nodes[0].id : null;\n        render();\n        log('Example list: ' + nodes.map(n => n.value).join(' -> '));\n      }\n\n      // Update SVG overlay arrows between nodes\n      function updateOverlay() {\n        // Clear current drawing\n        while (overlay.firstChild) overlay.removeChild(overlay.firstChild);\n        if (nodes.length === 0) return;\n        const nodeEls = Array.from(nodesContainer.querySelectorAll('.node'));\n        // For each node except last, draw an arrow from node.ptr center to next node.value center\n        const canvasRect = nodesContainer.getBoundingClientRect();\n        overlay.setAttribute('width', nodesContainer.clientWidth);\n        overlay.setAttribute('height', nodesContainer.clientHeight);\n        nodeEls.forEach((el, i) => {\n          if (i === nodeEls.length - 1) return;\n          const nextEl = nodeEls[i + 1];\n          // pointer box inside current node is .ptr\n          const ptr = el.querySelector('.ptr');\n          const fromRect = ptr.getBoundingClientRect();\n          const toRect = nextEl.querySelector('.value').getBoundingClientRect();\n\n          // compute positions relative to overlay\n          const left = nodesContainer.getBoundingClientRect().left;\n          const top = nodesContainer.getBoundingClientRect().top;\n          const x1 = fromRect.right - left;\n          const y1 = fromRect.top + fromRect.height / 2 - top;\n          const x2 = toRect.left - left;\n          const y2 = toRect.top + toRect.height / 2 - top;\n\n          // draw a cubic bezier for nicer arc\n          const mid = (x1 + x2) / 2;\n          const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n          const d = `M ${x1} ${y1} C ${mid} ${y1} ${mid} ${y2} ${x2} ${y2}`;\n          path.setAttribute('d', d);\n          path.setAttribute('fill', 'none');\n          path.setAttribute('stroke', 'rgba(6,182,212,0.18)');\n          path.setAttribute('stroke-width', '2');\n          path.setAttribute('stroke-linecap', 'round');\n          overlay.appendChild(path);\n\n          // arrowhead\n          const marker = document.createElementNS('http://www.w3.org/2000/svg','path');\n          const arrowSize = 5;\n          const arrow = document.createElementNS('http://www.w3.org/2000/svg','path');\n          // small triangle path relative to x2,y2 - rotate not computed, so draw a simple small V\n          arrow.setAttribute('d', `M ${x2-6} ${y2-6} L ${x2} ${y2} L ${x2-6} ${y2+6}`);\n          arrow.setAttribute('stroke', 'rgba(6,182,212,0.9)');\n          arrow.setAttribute('stroke-width', '2');\n          arrow.setAttribute('fill', 'none');\n          overlay.appendChild(arrow);\n        });\n      }\n\n      // Traversal: step, play, reset\n      function stepTraversal() {\n        if (nodes.length === 0) {\n          log('List is empty. Nothing to traverse.');\n          return;\n        }\n        // increment index\n        currentTraversalIndex++;\n        if (currentTraversalIndex >= nodes.length) {\n          // finished\n          stopTraversal();\n          log('Traversal finished.');\n          currentTraversalIndex = nodes.length - 1;\n          clearTraversalHighlight();\n          return;\n        }\n        highlightTraversalIndex(currentTraversalIndex);\n        log('Visiting node: ' + nodes[currentTraversalIndex].value);\n      }\n\n      function highlightTraversalIndex(i) {\n        clearTraversalHighlight();\n        const nodeEls = Array.from(nodesContainer.querySelectorAll('.node'));\n        if (i >= 0 && i < nodeEls.length) {\n          nodeEls[i].classList.add('current');\n          // ensure visible\n          nodeEls[i].scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });\n        }\n      }\n\n      function clearTraversalHighlight() {\n        const nodeEls = Array.from(nodesContainer.querySelectorAll('.node.current'));\n        nodeEls.forEach(el => el.classList.remove('current'));\n      }\n\n      function playTraversal() {\n        if (nodes.length === 0) {\n          log('Nothing to traverse.');\n          return;\n        }\n        stopTraversal();\n        if (currentTraversalIndex >= nodes.length - 1) currentTraversalIndex = -1;\n        const delay = Number(speedSelect.value) || 500;\n        traversalTimer = setInterval(() => {\n          currentTraversalIndex++;\n          if (currentTraversalIndex >= nodes.length) {\n            stopTraversal();\n            log('Traversal finished.');\n            return;\n          }\n          highlightTraversalIndex(currentTraversalIndex);\n          log('Visiting node: ' + nodes[currentTraversalIndex].value);\n        }, delay);\n        log('Traversal started.');\n      }\n\n      function stopTraversal() {\n        if (traversalTimer) {\n          clearInterval(traversalTimer);\n          traversalTimer = null;\n        }\n      }\n\n      function resetTraversal() {\n        stopTraversal();\n        currentTraversalIndex = -1;\n        clearTraversalHighlight();\n        log('Traversal reset.');\n      }\n\n      // Bind UI actions\n      addHeadBtn.addEventListener('click', () => {\n        const v = valueInput.value.trim();\n        if (v === '') { valueInput.focus(); return; }\n        addHead(v);\n        valueInput.value = '';\n      });\n\n      appendBtn.addEventListener('click', () => {\n        const v = valueInput.value.trim();\n        if (v === '') { valueInput.focus(); return; }\n        appendTail(v);\n        valueInput.value = '';\n      });\n\n      insertAfterBtn.addEventListener('click', () => {\n        const v = valueInsert.value.trim();\n        if (v === '') { valueInsert.focus(); return; }\n        insertAfterSelected(v);\n        valueInsert.value = '';\n      });\n\n      deleteBtn.addEventListener('click', () => {\n        deleteSelected();\n      });\n\n      resetBtn.addEventListener('click', () => {\n        resetList();\n      });\n\n      randomBtn.addEventListener('click', () => {\n        randomExample();\n      });\n\n      traverseStepBtn.addEventListener('click', () => {\n        stepTraversal();\n      });\n      traversePlayBtn.addEventListener('click', () => {\n        // toggle play/stop\n        if (traversalTimer) {\n          stopTraversal();\n          traversePlayBtn.textContent = 'Play';\n          log('Traversal paused.');\n        } else {\n          playTraversal();\n          traversePlayBtn.textContent = 'Pause';\n        }\n      });\n      traverseResetBtn.addEventListener('click', () => {\n        resetTraversal();\n        traversePlayBtn.textContent = 'Play';\n      });\n\n      // When window resizes, redraw arrows\n      window.addEventListener('resize', () => { updateOverlay(); });\n\n      // Initial render\n      render();\n\n      // Accessibility: keyboard shortcuts\n      window.addEventListener('keydown', (e) => {\n        if (e.ctrlKey && e.key === 'n') {\n          e.preventDefault();\n          valueInput.focus();\n        }\n      });\n\n      // Provide a couple example nodes at load\n      nodes = [\n        { id: newId(), value: '10' },\n        { id: newId(), value: '20' },\n        { id: newId(), value: '30' }\n      ];\n      selectedId = nodes.length ? nodes[0].id : null;\n      render();\n      log('Example list loaded: ' + nodes.map(n => n.value).join(' -> '));\n\n      // Observe mutations to nodes container to update overlay after layout changes\n      const ro = new ResizeObserver(() => updateOverlay());\n      ro.observe(nodesContainer);\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Linked List.\n\n**Project Overview:**\nTopic: Linked List\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Linked List"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "d6af79b0-bde5-11f0-95af-4764f61ee009",
    "timestamp": "2025-11-10T03:32:09.547Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "Concept Title\nBinary Search Tree (BST) — Build, Search, and Delete with Animated Steps\n\nLearning Objective\nAfter interacting with this module, users will be able to:\n- Understand how values are positioned in a BST (left < node < right).\n- Observe, step-by-step, how insertion, search, and deletion progress through comparisons.\n- See the structural change in the tree after deletion (cases: leaf, one child, two children).\n- Visualize inorder traversal as a way to retrieve sorted values from a BST.\n\nInteraction Design\n- Insert a value:\n  - Type a number and press \"Insert\". The app animates from the root, highlighting each comparison node (pulse + label). When the insertion point is reached, a new node appears and smoothly transitions into its position.\n- Search for a value:\n  - Type a number and press \"Search\". The app animates the search path: each visited node pulses and shows whether we go left or right. If found, the node glows green; if not found, the last visited node glows red.\n- Delete a value:\n  - Type a number and press \"Delete\". The app animates the search for the node; if found, it animates the deletion according to the case:\n    - Leaf node: node fades out and remaining nodes shift to new positions.\n    - One child: child moves into the deleted node's position.\n    - Two children: successor is highlighted, its value is copied to the deleted node (animated value swap), then the successor is deleted (with fade and reposition).\n- Inorder Traversal:\n  - Press \"Inorder\" to animate visiting nodes left-to-right. Nodes pulse in order and a list on the control panel fills with the sorted sequence.\n- Controls also include \"Random (n)\" to create random BST of n nodes and \"Clear\" to reset.\n- Interaction feedback:\n  - Node comparisons animate with a short pulse and a status text describing the decision (e.g., \"5 < 8 → go right\").\n  - Smooth transitions (CSS transition on transform & opacity) show tree layout changes.\n  - Buttons are keyboard-accessible; input accepts numbers and prevents invalid input.\n\nLayout Description (Spatial Organization)\n- Safe margins: 24px padding applied on all sides of the viewport to maintain the safe area.\n- The page has two main horizontal areas (responsive):\n  - Left column (controls & explanations), width: 320px on wide screens, full-width stacked on small screens:\n    - Top: Concept title and Learning Objective summary.\n    - Middle: Input form and action buttons (Insert, Search, Delete, Inorder, Random, Clear). Each interactive element has at least 16px spacing between neighbors (vertical rhythm).\n    - Bottom: Status panel that shows step descriptions and traversal results.\n  - Right column (canvas area) for visualization (SVG) that occupies remaining space:\n    - The tree visualization centers within the canvas. Nodes and edges use readable sizes; depth spacing ensures clarity.\n    - The canvas is responsive: it scales to the available width and re-computes layout on resize.\n    - Minimum spacing between control column and canvas is 16px.\n- Accessibility:\n  - All form controls have labels and aria-live status for announcements.\n  - Buttons and inputs usable with keyboard only.\n  - Color choices include clear borders and high-contrast highlights.\n- Responsiveness:\n  - On narrow screens (<720px), the control column stacks above the canvas for vertical flow.\n  - SVG viewBox is used so scaling preserves crispness.\n\nSelf-contained Implementation (vanilla HTML, CSS, JavaScript)\nBelow is a single HTML file implementing the interactive BST module. Copy-paste into a .html file and open in a browser.\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive BST Explorer</title>\n  <style>\n    :root{\n      --safe-pad:24px;\n      --gap:16px;\n      --panel-width:320px;\n      --node-radius:22;\n      --node-diameter:44px;\n      --depth-gap:80px;\n      --h-gap:20px;\n      --accent:#2b7cff;\n      --success:#16a34a;\n      --danger:#dc2626;\n      --muted:#666;\n      --bg:#f6f8fb;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      font-family:system-ui,-apple-system,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif;\n      background:linear-gradient(180deg,#ffffff,#f7fbff);\n      color:#0f172a;\n    }\n    .app{\n      padding:var(--safe-pad);\n      box-sizing:border-box;\n      min-height:100vh;\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n    }\n\n    /* Left panel (controls) */\n    .panel{\n      flex:0 0 var(--panel-width);\n      min-width:250px;\n      background:white;\n      border-radius:12px;\n      padding:18px;\n      box-shadow:0 6px 18px rgba(19,38,63,0.06);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .title{\n      margin:0;\n      font-size:18px;\n      font-weight:700;\n      color:#07203b;\n    }\n    .subtitle{\n      margin:0;\n      font-size:13px;\n      color:var(--muted);\n      line-height:1.3;\n    }\n    .controls{\n      display:flex;\n      gap:var(--gap);\n      flex-direction:column;\n    }\n    label{font-size:13px;color:#16324f}\n    .row{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n    }\n    input[type=\"number\"]{\n      padding:10px 12px;\n      font-size:14px;\n      border:1px solid #d1dbe8;\n      border-radius:8px;\n      width:100%;\n      box-sizing:border-box;\n    }\n    button{\n      background:var(--accent);\n      color:white;\n      border:0;\n      padding:10px 12px;\n      border-radius:8px;\n      font-size:14px;\n      cursor:pointer;\n      transition:transform .12s ease, box-shadow .12s ease;\n    }\n    button.secondary{\n      background:#f0f6ff;\n      color:var(--accent);\n      border:1px solid rgba(43,124,255,0.12);\n    }\n    button.warn{\n      background:var(--danger);\n      color:white;\n    }\n    button:active{transform:translateY(1px)}\n    .controls .actions{\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n    }\n    .status{\n      background:#fbfdff;\n      border:1px solid #eef6ff;\n      padding:12px;\n      border-radius:8px;\n      font-size:13px;\n      color:#15324b;\n      min-height:54px;\n    }\n    .status p{margin:0 0 8px 0;font-size:13px}\n    .status .trail{font-weight:600;color:var(--accent);}\n    .result-list{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      margin-top:8px;\n    }\n    .chip{\n      background:#eef6ff;\n      color:var(--accent);\n      padding:6px 8px;\n      font-size:13px;\n      border-radius:6px;\n      min-width:28px;\n      text-align:center;\n    }\n\n    /* Canvas area */\n    .canvas-wrap{\n      flex:1 1 auto;\n      min-height:420px;\n      background:linear-gradient(180deg,#ffffff,#fbfdff);\n      border-radius:12px;\n      padding:12px;\n      box-shadow:0 6px 20px rgba(13,30,54,0.04);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      overflow:hidden;\n    }\n    .canvas-toolbar{\n      display:flex;\n      align-items:center;\n      justify-content:space-between;\n      gap:var(--gap);\n      padding:8px 12px;\n    }\n    .canvas-area{\n      flex:1 1 auto;\n      min-height:360px;\n      background:linear-gradient(90deg,#fbfdff,#f6f9ff);\n      border-radius:10px;\n      position:relative;\n      overflow:auto;\n      padding:24px 12px;\n    }\n\n    /* SVG tree */\n    svg{\n      width:100%;\n      height:100%;\n      overflow:visible;\n    }\n    .edge{\n      stroke:#b6c7de;\n      stroke-width:2;\n      stroke-linecap:round;\n    }\n    .node{\n      transform-origin:center;\n      transition:transform 450ms cubic-bezier(.22,.9,.27,1), opacity 350ms ease;\n      cursor:default;\n    }\n    .node circle{\n      fill:white;\n      stroke:#2b7cff;\n      stroke-width:2.5;\n      transition:stroke 180ms ease, fill 180ms ease;\n    }\n    .node text{\n      fill:#07203b;\n      font-weight:700;\n      font-size:13px;\n      pointer-events:none;\n    }\n    .node .small{\n      font-weight:600;\n      font-size:11px;\n      fill:#12406b;\n    }\n    .node.highlight circle{\n      box-shadow:0 6px 12px rgba(43,124,255,0.12);\n      stroke-width:3.5;\n      stroke:var(--accent);\n      transform:scale(1.08);\n      transition:transform 260ms ease, stroke 260ms ease;\n    }\n    .node.found circle{ fill:var(--success); stroke:var(--success); }\n    .node.notfound circle{ fill:var(--danger); stroke:var(--danger); }\n    .node.found text, .node.notfound text{ fill:white }\n\n    .fade-out{ opacity:0; transform:scale(0.6); }\n\n    /* Accessibility & small screen */\n    @media (max-width:720px){\n      .app{flex-direction:column}\n      .panel{width:100%; order:0}\n      .canvas-wrap{order:1}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-labelledby=\"title\">\n    <aside class=\"panel\" aria-label=\"Controls\">\n      <div>\n        <h1 class=\"title\" id=\"title\">BST Explorer</h1>\n        <p class=\"subtitle\">Interactive build, search, and delete in a Binary Search Tree. Watch comparisons and structural changes animate.</p>\n      </div>\n\n      <div class=\"controls\" aria-live=\"polite\">\n        <div>\n          <label for=\"valueInput\">Value (integer)</label>\n          <input id=\"valueInput\" type=\"number\" aria-label=\"value input\" placeholder=\"e.g. 42\" />\n        </div>\n\n        <div class=\"actions\" role=\"group\" aria-label=\"Actions\">\n          <button id=\"insertBtn\" title=\"Insert value\">Insert</button>\n          <button id=\"searchBtn\" class=\"secondary\" title=\"Search for value\">Search</button>\n          <button id=\"deleteBtn\" class=\"secondary\" title=\"Delete value\">Delete</button>\n          <button id=\"inorderBtn\" class=\"secondary\" title=\"Inorder traversal\">Inorder</button>\n        </div>\n\n        <div class=\"row\">\n          <label for=\"randomCount\">Random</label>\n          <input id=\"randomCount\" type=\"number\" min=\"1\" max=\"30\" value=\"7\" style=\"width:80px\" />\n          <button id=\"randomBtn\" class=\"secondary\">Build</button>\n          <button id=\"clearBtn\" class=\"secondary\">Clear</button>\n        </div>\n      </div>\n\n      <div class=\"status\" aria-live=\"polite\" id=\"status\">\n        <p id=\"statusText\">Status: Ready</p>\n        <div><strong>Trail:</strong> <span class=\"trail\" id=\"trail\">—</span></div>\n        <div style=\"margin-top:8px\"><strong>Inorder result:</strong></div>\n        <div class=\"result-list\" id=\"resultList\" aria-live=\"polite\"></div>\n      </div>\n    </aside>\n\n    <main class=\"canvas-wrap\" aria-label=\"Tree visualization\">\n      <div class=\"canvas-toolbar\">\n        <div style=\"font-size:14px;color:#16324f\">Visualization</div>\n        <div style=\"font-size:13px;color:var(--muted)\">Tip: use numbers 0–999. Repeated inserts are ignored.</div>\n      </div>\n\n      <div class=\"canvas-area\" id=\"canvasArea\" tabindex=\"0\" aria-label=\"Binary search tree canvas\">\n        <svg id=\"svgRoot\" xmlns=\"http://www.w3.org/2000/svg\" role=\"img\" aria-label=\"BST visualization\"></svg>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    (function(){\n      // Configuration\n      const NODE_RADIUS = 22;\n      const DEPTH_GAP = 80;\n      const H_GAP = 32; // minimum horizontal gap\n      const TRANSITION_MS = 450;\n\n      // DOM elements\n      const svg = document.getElementById('svgRoot');\n      const valueInput = document.getElementById('valueInput');\n      const insertBtn = document.getElementById('insertBtn');\n      const searchBtn = document.getElementById('searchBtn');\n      const deleteBtn = document.getElementById('deleteBtn');\n      const randomBtn = document.getElementById('randomBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const randomCount = document.getElementById('randomCount');\n      const statusText = document.getElementById('statusText');\n      const trailEl = document.getElementById('trail');\n      const resultList = document.getElementById('resultList');\n      const inorderBtn = document.getElementById('inorderBtn');\n\n      // Simple BST data structure\n      class Node {\n        constructor(value){\n          this.value = value;\n          this.left = null;\n          this.right = null;\n          this.parent = null;\n          // UI state\n          this.id = Node.nextId++;\n          this.x = 0;\n          this.y = 0;\n        }\n      }\n      Node.nextId = 1;\n\n      class BST {\n        constructor(){\n          this.root = null;\n          this.nodes = new Map(); // id -> node\n        }\n        insert(value){\n          if(this.root === null){\n            const n = new Node(value);\n            this.root = n;\n            this.nodes.set(n.id, n);\n            return {node:n, created:true, path:[n]};\n          }\n          let cur = this.root;\n          let path = [cur];\n          while(true){\n            if(value === cur.value) return {node:cur, created:false, path};\n            if(value < cur.value){\n              if(cur.left){\n                cur = cur.left; path.push(cur);\n              } else {\n                const n = new Node(value);\n                cur.left = n; n.parent = cur; this.nodes.set(n.id,n);\n                path.push(n);\n                return {node:n, created:true, path};\n              }\n            } else {\n              if(cur.right){\n                cur = cur.right; path.push(cur);\n              } else {\n                const n = new Node(value);\n                cur.right = n; n.parent = cur; this.nodes.set(n.id,n);\n                path.push(n);\n                return {node:n, created:true, path};\n              }\n            }\n          }\n        }\n\n        searchPath(value){\n          let cur = this.root;\n          const path = [];\n          while(cur){\n            path.push(cur);\n            if(value === cur.value) break;\n            cur = value < cur.value ? cur.left : cur.right;\n          }\n          return path;\n        }\n\n        find(value){\n          let cur = this.root;\n          while(cur){\n            if(value === cur.value) return cur;\n            cur = value < cur.value ? cur.left : cur.right;\n          }\n          return null;\n        }\n\n        transplant(u,v){\n          // replace subtree rooted at u with v\n          if(!u.parent) this.root = v;\n          else if(u === u.parent.left) u.parent.left = v;\n          else u.parent.right = v;\n          if(v) v.parent = u.parent;\n        }\n\n        minimum(node){\n          let cur = node;\n          while(cur.left) cur = cur.left;\n          return cur;\n        }\n\n        delete(value){\n          const node = this.find(value);\n          if(!node) return {deleted:false, node:null};\n          // Cases animatable: leaf, one child, two children\n          if(!node.left && !node.right){\n            this.transplant(node,null);\n            this.nodes.delete(node.id);\n            return {deleted:true, node, case:'leaf'};\n          } else if(!node.left){\n            this.transplant(node,node.right);\n            this.nodes.delete(node.id);\n            return {deleted:true, node, case:'one-right', child:node.right};\n          } else if(!node.right){\n            this.transplant(node,node.left);\n            this.nodes.delete(node.id);\n            return {deleted:true, node, case:'one-left', child:node.left};\n          } else {\n            const succ = this.minimum(node.right);\n            if(succ.parent !== node){\n              this.transplant(succ, succ.right);\n              succ.right = node.right; if(succ.right) succ.right.parent = succ;\n            }\n            this.transplant(node, succ);\n            succ.left = node.left; if(succ.left) succ.left.parent = succ;\n            // keep succ node id, remove old node\n            this.nodes.delete(node.id);\n            return {deleted:true, node, case:'two-children', successor:succ};\n          }\n        }\n\n        inorderList(){\n          const out = [];\n          (function rec(n){\n            if(!n) return;\n            rec(n.left); out.push(n.value); rec(n.right);\n          })(this.root);\n          return out;\n        }\n\n        // utility to traverse nodes stored\n        allNodes(){\n          return Array.from(this.nodes.values());\n        }\n      }\n\n      // UI rendering & layout\n      const tree = new BST();\n\n      function computeLayout(){\n        // Use inorder numbering to compute x positions to avoid overlap.\n        let index = 0;\n        function dfs(node, depth){\n          if(!node) return;\n          dfs(node.left, depth+1);\n          node.x = (index++ ) * (NODE_RADIUS*2 + H_GAP);\n          node.y = depth * DEPTH_GAP;\n          dfs(node.right, depth+1);\n        }\n        index = 0;\n        dfs(tree.root, 0);\n\n        // If empty, nothing to draw.\n      }\n\n      function render(){\n        // compute layout, set svg viewbox, draw edges and nodes\n        computeLayout();\n        const nodes = tree.allNodes();\n        if(nodes.length === 0){\n          svg.innerHTML = '<text x=\"20\" y=\"40\" fill=\"#4b5563\" font-size=\"14\">The tree is empty. Insert some values to begin.</text>';\n          return;\n        }\n\n        // Determine bounds\n        let minX = Infinity, maxX = -Infinity, maxY = 0;\n        nodes.forEach(n=>{\n          if(n.x < minX) minX = n.x;\n          if(n.x > maxX) maxX = n.x;\n          if(n.y > maxY) maxY = n.y;\n        });\n        minX = Math.min(minX,0);\n        maxX = Math.max(maxX, NODE_RADIUS*2);\n        const width = (maxX - minX) + NODE_RADIUS*4;\n        const height = maxY + NODE_RADIUS*4;\n\n        svg.setAttribute('viewBox', `${minX - NODE_RADIUS*2} -20 ${width} ${height + 40}`);\n\n        // Draw edges and nodes as single pass for consistent order\n        // Build elements and preserve existing ones for transition\n        const existing = {};\n        svg.querySelectorAll('[data-id]').forEach(el=>{\n          existing[el.dataset.id] = el;\n        });\n\n        const frag = document.createDocumentFragment();\n\n        // draw edges first\n        nodes.forEach(n=>{\n          if(n.left){\n            const id = `e-${n.id}-${n.left.id}`;\n            const existingEl = existing[id];\n            const x1 = n.x, y1 = n.y;\n            const x2 = n.left.x, y2 = n.left.y;\n            let line;\n            if(existingEl && existingEl.tagName === 'line'){\n              line = existingEl;\n              line.setAttribute('x1', x1);\n              line.setAttribute('y1', y1);\n              line.setAttribute('x2', x2);\n              line.setAttribute('y2', y2);\n              delete existing[id];\n            } else {\n              line = document.createElementNS('http://www.w3.org/2000/svg','line');\n              line.setAttribute('class','edge');\n              line.setAttribute('data-id',id);\n              line.setAttribute('x1',x1);\n              line.setAttribute('y1',y1);\n              line.setAttribute('x2',x2);\n              line.setAttribute('y2',y2);\n            }\n            frag.appendChild(line);\n          }\n          if(n.right){\n            const id = `e-${n.id}-${n.right.id}`;\n            const existingEl = existing[id];\n            const x1 = n.x, y1 = n.y;\n            const x2 = n.right.x, y2 = n.right.y;\n            let line;\n            if(existingEl && existingEl.tagName === 'line'){\n              line = existingEl;\n              line.setAttribute('x1', x1);\n              line.setAttribute('y1', y1);\n              line.setAttribute('x2', x2);\n              line.setAttribute('y2', y2);\n              delete existing[id];\n            } else {\n              line = document.createElementNS('http://www.w3.org/2000/svg','line');\n              line.setAttribute('class','edge');\n              line.setAttribute('data-id',id);\n              line.setAttribute('x1',x1);\n              line.setAttribute('y1',y1);\n              line.setAttribute('x2',x2);\n              line.setAttribute('y2',y2);\n            }\n            frag.appendChild(line);\n          }\n        });\n\n        // draw nodes\n        nodes.forEach(n=>{\n          const id = `n-${n.id}`;\n          let g;\n          const existingEl = existing[id];\n          if(existingEl && existingEl.tagName === 'g'){\n            g = existingEl;\n            delete existing[id];\n          } else {\n            g = document.createElementNS('http://www.w3.org/2000/svg','g');\n            g.setAttribute('class','node');\n            g.setAttribute('data-id', id);\n            g.setAttribute('role','img');\n            // circle\n            const c = document.createElementNS('http://www.w3.org/2000/svg','circle');\n            c.setAttribute('r', NODE_RADIUS);\n            c.setAttribute('cx',0);\n            c.setAttribute('cy',0);\n            g.appendChild(c);\n            // text\n            const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n            t.setAttribute('x',0);\n            t.setAttribute('y',6);\n            t.setAttribute('text-anchor','middle');\n            t.textContent = String(n.value);\n            g.appendChild(t);\n          }\n          // update transform\n          g.style.transform = `translate(${n.x}px, ${n.y}px)`;\n          frag.appendChild(g);\n        });\n\n        // append remaining existing nodes (to remove)\n        Object.keys(existing).forEach(k=>{\n          const el = existing[k];\n          el.classList.add('fade-out');\n          // schedule removal after transition\n          setTimeout(()=>{ if(el.parentNode) el.parentNode.removeChild(el); }, TRANSITION_MS + 80);\n        });\n\n        // clear svg and append fragment\n        // We can't simply replace entire svg contents for smooth transitions, but here we reconstruct.\n        // Remove edges/nodes that are not in frag (already scheduled). Append or replace as needed.\n        // For simplicity, clear and append everything (transitions on transform will still animate if elements are re-used)\n        svg.innerHTML = '';\n        svg.appendChild(frag);\n      }\n\n      // Animation helpers\n      function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }\n\n      async function animatePath(path, highlightFound=false){\n        // path: array of nodes visited order (includes target if found)\n        trailEl.textContent = path.map(n=>n.value).join(' → ');\n        for(let i=0;i<path.length;i++){\n          const n = path[i];\n          const nid = `n-${n.id}`;\n          const el = svg.querySelector(`[data-id=\"${nid}\"]`);\n          if(!el) continue;\n          el.classList.add('highlight');\n          statusText.textContent = `Visiting ${n.value}`;\n          await sleep(520);\n          el.classList.remove('highlight');\n        }\n        if(highlightFound){\n          const last = path[path.length-1];\n          if(last && last.value === path[path.length-1].value){\n            const nid = `n-${last.id}`;\n            const el = svg.querySelector(`[data-id=\"${nid}\"]`);\n            if(el){\n              el.classList.add('found');\n              statusText.textContent = `Found ${last.value}`;\n              await sleep(800);\n              el.classList.remove('found');\n            }\n          }\n        }\n      }\n\n      async function animateSearch(value){\n        if(!tree.root){\n          statusText.textContent = 'Tree is empty.';\n          trailEl.textContent = '—';\n          return;\n        }\n        const path = tree.searchPath(value);\n        trailEl.textContent = path.map(n=>n.value).join(' → ');\n        for(let i=0;i<path.length;i++){\n          const n = path[i];\n          const el = svg.querySelector(`[data-id=\"n-${n.id}\"]`);\n          if(!el) continue;\n          el.classList.add('highlight');\n          statusText.textContent = `${value} ${value === n.value ? '==' : (value < n.value ? '<' : '>')} ${n.value} → ${value === n.value ? 'match' : (value < n.value ? 'go left' : 'go right')}`;\n          await sleep(600);\n          el.classList.remove('highlight');\n          if(value === n.value){\n            el.classList.add('found');\n            await sleep(700);\n            el.classList.remove('found');\n            statusText.textContent = `Value ${value} found.`;\n            return;\n          }\n        }\n        // not found\n        const last = path[path.length-1];\n        const lastEl = svg.querySelector(`[data-id=\"n-${last.id}\"]`);\n        if(lastEl){\n          lastEl.classList.add('notfound');\n          statusText.textContent = `Value ${value} not found.`;\n          await sleep(700);\n          lastEl.classList.remove('notfound');\n        }\n      }\n\n      async function animateInsert(value){\n        // Insert operation with animated comparisons and final placement\n        if(!tree.root){\n          const res = tree.insert(value);\n          render();\n          statusText.textContent = `Inserted ${value} as root.`;\n          trailEl.textContent = String(value);\n          return;\n        }\n        let cur = tree.root;\n        const path = [];\n        while(true){\n          path.push(cur);\n          const curEl = svg.querySelector(`[data-id=\"n-${cur.id}\"]`);\n          if(curEl){\n            curEl.classList.add('highlight');\n            statusText.textContent = `Compare ${value} with ${cur.value}`;\n            await sleep(520);\n            curEl.classList.remove('highlight');\n          }\n          if(value === cur.value){\n            statusText.textContent = `${value} already exists — no insert.`;\n            trailEl.textContent = path.map(n=>n.value).join(' → ');\n            return;\n          } else if(value < cur.value){\n            if(cur.left){\n              cur = cur.left;\n            } else {\n              // create node visually near parent and animate to position\n              const res = tree.insert(value);\n              // render will create node at its final transform (but we want to drop it in)\n              render();\n              const newNode = res.node;\n              const newEl = svg.querySelector(`[data-id=\"n-${newNode.id}\"]`);\n              if(newEl){\n                // start it scaled down and translated above\n                newEl.style.transform = `translate(${newNode.x}px, ${newNode.y - 40}px) scale(0.6)`;\n                newEl.style.opacity = '0';\n                await sleep(50);\n                newEl.style.transition = `transform ${TRANSITION_MS}ms cubic-bezier(.22,.9,.27,1), opacity 260ms ease`;\n                newEl.style.opacity = '1';\n                newEl.style.transform = `translate(${newNode.x}px, ${newNode.y}px)`;\n                statusText.textContent = `Inserted ${value} to the left of ${cur.value}.`;\n                trailEl.textContent = path.map(n=>n.value).concat([value]).join(' → ');\n                await sleep(TRANSITION_MS+60);\n              }\n              return;\n            }\n          } else {\n            if(cur.right){\n              cur = cur.right;\n            } else {\n              const res = tree.insert(value);\n              render();\n              const newNode = res.node;\n              const newEl = svg.querySelector(`[data-id=\"n-${newNode.id}\"]`);\n              if(newEl){\n                newEl.style.transform = `translate(${newNode.x}px, ${newNode.y - 40}px) scale(0.6)`;\n                newEl.style.opacity = '0';\n                await sleep(50);\n                newEl.style.transition = `transform ${TRANSITION_MS}ms cubic-bezier(.22,.9,.27,1), opacity 260ms ease`;\n                newEl.style.opacity = '1';\n                newEl.style.transform = `translate(${newNode.x}px, ${newNode.y}px)`;\n                statusText.textContent = `Inserted ${value} to the right of ${cur.value}.`;\n                trailEl.textContent = path.map(n=>n.value).concat([value]).join(' → ');\n                await sleep(TRANSITION_MS+60);\n              }\n              return;\n            }\n          }\n        }\n      }\n\n      async function animateDelete(value){\n        if(!tree.root){\n          statusText.textContent = 'Tree is empty.';\n          return;\n        }\n        const path = tree.searchPath(value);\n        trailEl.textContent = path.map(n=>n.value).join(' → ');\n        // search animation\n        for(let i=0;i<path.length;i++){\n          const n = path[i];\n          const el = svg.querySelector(`[data-id=\"n-${n.id}\"]`);\n          if(!el) continue;\n          el.classList.add('highlight');\n          statusText.textContent = `Compare ${value} with ${n.value}`;\n          await sleep(520);\n          el.classList.remove('highlight');\n          if(value === n.value) break;\n        }\n        const target = tree.find(value);\n        if(!target){\n          statusText.textContent = `${value} not found — nothing to delete.`;\n          return;\n        }\n        // highlight target\n        const tEl = svg.querySelector(`[data-id=\"n-${target.id}\"]`);\n        if(tEl){\n          tEl.classList.add('highlight');\n          statusText.textContent = `Deleting ${value} ...`;\n          await sleep(600);\n          tEl.classList.remove('highlight');\n        }\n\n        // Determine deletion case visually\n        if(!target.left && !target.right){\n          // leaf\n          if(tEl){\n            tEl.classList.add('fade-out');\n            await sleep(180);\n            // perform delete in data then re-render\n            tree.delete(value);\n            render();\n            statusText.textContent = `Deleted leaf ${value}.`;\n            await sleep(300);\n          } else {\n            tree.delete(value);\n            render();\n            statusText.textContent = `Deleted ${value}.`;\n          }\n        } else if(!target.left || !target.right){\n          // one child\n          // animate child moving up\n          const child = target.left || target.right;\n          const cEl = svg.querySelector(`[data-id=\"n-${child.id}\"]`);\n          if(cEl && tEl){\n            // move child to target pos while fading target\n            cEl.style.transition = `transform ${TRANSITION_MS}ms cubic-bezier(.22,.9,.27,1)`;\n            cEl.style.transform = `translate(${target.x}px, ${target.y}px)`;\n            tEl.classList.add('fade-out');\n            await sleep(TRANSITION_MS+50);\n            tree.delete(value);\n            render();\n            statusText.textContent = `Deleted ${value}; child moved up.`;\n            await sleep(200);\n          } else {\n            tree.delete(value);\n            render();\n            statusText.textContent = `Deleted ${value}.`;\n          }\n        } else {\n          // two children: show successor, copy value, then delete successor\n          const succ = tree.minimum(target.right);\n          const succEl = svg.querySelector(`[data-id=\"n-${succ.id}\"]`);\n          const targetEl = svg.querySelector(`[data-id=\"n-${target.id}\"]`);\n          if(succEl && targetEl){\n            // highlight successor\n            succEl.classList.add('highlight');\n            statusText.textContent = `Successor ${succ.value} found; will replace ${target.value}`;\n            await sleep(700);\n            succEl.classList.remove('highlight');\n            // animate \"copy\" of value: create temporary text that moves\n            const tempText = document.createElementNS('http://www.w3.org/2000/svg','text');\n            tempText.setAttribute('x',0);\n            tempText.setAttribute('y',6);\n            tempText.setAttribute('text-anchor','middle');\n            tempText.setAttribute('fill','#07203b');\n            tempText.setAttribute('font-weight','700');\n            tempText.textContent = String(succ.value);\n            tempText.style.transition = `transform ${TRANSITION_MS}ms cubic-bezier(.22,.9,.27,1), opacity 260ms ease`;\n            // position temp at succ position (absolute in svg)\n            const succPosX = succ.x, succPosY = succ.y;\n            tempText.style.transform = `translate(${succPosX}px, ${succPosY}px)`;\n            tempText.style.opacity = '0.0001';\n            svg.appendChild(tempText);\n            await sleep(20);\n            tempText.style.opacity = '1';\n            // move to target pos\n            tempText.style.transform = `translate(${target.x}px, ${target.y}px)`;\n            await sleep(TRANSITION_MS+30);\n            // update target node's value in data structure\n            const oldValue = target.value;\n            target.value = succ.value;\n            // remove temp\n            svg.removeChild(tempText);\n            // visually update target\n            render();\n            statusText.textContent = `Replaced ${oldValue} with ${target.value}. Now removing successor ${succ.value}.`;\n            await sleep(300);\n            // delete successor node\n            tree.delete(succ.value);\n            render();\n            statusText.textContent = `Deleted ${oldValue}.`;\n            await sleep(300);\n          } else {\n            tree.delete(value);\n            render();\n            statusText.textContent = `Deleted ${value}.`;\n          }\n        }\n      }\n\n      // Wire up controls\n      insertBtn.addEventListener('click', async ()=>{\n        const v = parseInt(valueInput.value,10);\n        if(isNaN(v)){ statusText.textContent = 'Enter a valid integer.'; valueInput.focus(); return; }\n        insertBtn.disabled = true;\n        await animateInsert(v);\n        insertBtn.disabled = false;\n        valueInput.select();\n      });\n\n      searchBtn.addEventListener('click', async ()=>{\n        const v = parseInt(valueInput.value,10);\n        if(isNaN(v)){ statusText.textContent = 'Enter a valid integer.'; valueInput.focus(); return; }\n        searchBtn.disabled = true;\n        await animateSearch(v);\n        searchBtn.disabled = false;\n      });\n\n      deleteBtn.addEventListener('click', async ()=>{\n        const v = parseInt(valueInput.value,10);\n        if(isNaN(v)){ statusText.textContent = 'Enter a valid integer.'; valueInput.focus(); return; }\n        deleteBtn.disabled = true;\n        await animateDelete(v);\n        deleteBtn.disabled = false;\n      });\n\n      inorderBtn.addEventListener('click', async ()=>{\n        if(!tree.root){ statusText.textContent = 'Tree is empty.'; resultList.innerHTML = ''; return; }\n        statusText.textContent = 'Animating inorder traversal...';\n        const list = [];\n        // inorder traversal with animation\n        async function rec(n){\n          if(!n) return;\n          await rec(n.left);\n          const el = svg.querySelector(`[data-id=\"n-${n.id}\"]`);\n          if(el){\n            el.classList.add('highlight');\n            await sleep(460);\n            el.classList.remove('highlight');\n          }\n          list.push(n.value);\n          updateResultList(list);\n          await sleep(100);\n          await rec(n.right);\n        }\n        updateResultList([]);\n        await rec(tree.root);\n        statusText.textContent = 'Inorder traversal complete.';\n      });\n\n      randomBtn.addEventListener('click', ()=>{\n        const count = Math.max(1, Math.min(30, parseInt(randomCount.value,10) || 7));\n        // clear and insert random unique numbers\n        tree.root = null; tree.nodes.clear(); Node.nextId = 1;\n        const vals = new Set();\n        while(vals.size < count){\n          vals.add(Math.floor(Math.random()*100));\n        }\n        Array.from(vals).forEach(v=>tree.insert(v));\n        render();\n        statusText.textContent = `Built random tree (${count} nodes).`;\n        updateResultList([]);\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        tree.root = null; tree.nodes.clear(); Node.nextId = 1;\n        render();\n        statusText.textContent = 'Cleared tree.';\n        trailEl.textContent = '—';\n        updateResultList([]);\n      });\n\n      function updateResultList(arr){\n        resultList.innerHTML = '';\n        for(const v of arr){\n          const c = document.createElement('div');\n          c.className = 'chip';\n          c.textContent = String(v);\n          resultList.appendChild(c);\n        }\n      }\n\n      // initial render\n      render();\n\n      // keyboard: Enter to insert, Shift+Enter to search\n      valueInput.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter'){\n          if(e.shiftKey) searchBtn.click();\n          else insertBtn.click();\n        }\n      });\n\n      // resize observer for canvas scaling\n      window.addEventListener('resize', ()=>{ render(); });\n\n      // initial hint values\n      valueInput.value = '';\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Binary Search Tree (BST).\n\n**Project Overview:**\nTopic: Binary Search Tree (BST)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "dc168830-bde5-11f0-95af-4764f61ee009",
    "timestamp": "2025-11-10T03:32:18.611Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "K-Nearest Neighbors (KNN)",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>K-Nearest Neighbors (KNN) Interactive Module</title>\n  <style>\n    /* Safe area margins: 24px on all sides */\n    :root {\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1720;\n      --panel: #0b1220;\n      --accent1: #3b82f6; /* blue */\n      --accent2: #ef4444; /* red */\n      --muted: #94a3b8;\n      --surface: #0b1220;\n      --glass: rgba(255,255,255,0.03);\n    }\n\n    html,body {\n      height: 100%;\n      margin: 0;\n      padding: var(--safe-margin);\n      background: linear-gradient(180deg,#071021 0%, #04111a 100%);\n      color: #e6eef8;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      box-sizing: border-box;\n    }\n\n    /* Layout */\n    .container {\n      display: grid;\n      grid-template-columns: 320px 1fr;\n      gap: var(--gap);\n      align-items: start;\n      height: calc(100vh - (var(--safe-margin) * 2));\n    }\n\n    /* Responsive: stack on small screens */\n    @media (max-width: 880px) {\n      .container {\n        grid-template-columns: 1fr;\n        grid-auto-rows: auto;\n        height: auto;\n      }\n    }\n\n    .panel {\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 12px;\n      padding: 16px;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\n      min-width: 0;\n    }\n\n    /* Left controls */\n    .left {\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n      min-height: 0;\n    }\n\n    .title {\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n    }\n\n    .title h1 {\n      margin: 0;\n      font-size: 18px;\n      line-height: 1.1;\n    }\n\n    .meta {\n      color: var(--muted);\n      font-size: 13px;\n      margin: 0;\n    }\n\n    .controls {\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n    }\n\n    label {\n      display: block;\n      font-size: 13px;\n      color: var(--muted);\n      margin-bottom: 8px;\n    }\n\n    .row {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n      flex-wrap: wrap;\n    }\n\n    .btn {\n      appearance: none;\n      background: var(--glass);\n      color: #e6eef8;\n      border: 1px solid rgba(255,255,255,0.04);\n      padding: 8px 12px;\n      border-radius: 8px;\n      cursor: pointer;\n      font-size: 13px;\n      transition: transform .12s ease, background .12s ease;\n    }\n\n    .btn:active { transform: translateY(1px); }\n    .btn.secondary { background: transparent; border: 1px dashed rgba(255,255,255,0.04); }\n\n    .legend {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n    }\n\n    .legend .item {\n      display: flex;\n      gap: 8px;\n      align-items: center;\n      font-size: 13px;\n      color: var(--muted);\n    }\n\n    .swatch {\n      width: 14px;\n      height: 14px;\n      border-radius: 50%;\n      box-shadow: 0 2px 6px rgba(0,0,0,0.6);\n      flex-shrink: 0;\n    }\n\n    /* Slider and inputs */\n    .control-group {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n    }\n\n    input[type=\"range\"] {\n      width: 100%;\n      accent-color: #60a5fa;\n    }\n\n    input[type=\"number\"] {\n      width: 64px;\n      padding: 8px;\n      border-radius: 8px;\n      border: none;\n      background: rgba(255,255,255,0.02);\n      color: inherit;\n      text-align: center;\n    }\n\n    select {\n      padding: 8px;\n      border-radius: 8px;\n      border: none;\n      background: rgba(255,255,255,0.02);\n      color: inherit;\n    }\n\n    /* Right visualization area */\n    .viz {\n      display: flex;\n      flex-direction: column;\n      gap: var(--gap);\n      min-height: 0;\n    }\n\n    .canvas-panel {\n      position: relative;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius: 12px;\n      padding: 12px;\n      flex: 1 1 auto;\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n      min-height: 320px;\n    }\n\n    .plot {\n      position: relative;\n      border-radius: 8px;\n      overflow: hidden;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border: 1px solid rgba(255,255,255,0.03);\n      height: 560px;\n      max-height: calc(100vh - 320px);\n      min-height: 280px;\n    }\n\n    @media (max-width: 880px) {\n      .plot {\n        height: 360px;\n        max-height: none;\n      }\n    }\n\n    /* Canvas layers: classification field (canvas), svg points on top */\n    .plot canvas {\n      width: 100%;\n      height: 100%;\n      display: block;\n      image-rendering: pixelated;\n      transition: opacity 360ms ease;\n      opacity: 1;\n    }\n\n    .plot canvas.hidden {\n      opacity: 0;\n      pointer-events: none;\n    }\n\n    .plot svg {\n      position: absolute;\n      inset: 0;\n      width: 100%;\n      height: 100%;\n      overflow: visible;\n      pointer-events: none; /* we use per-element pointer handling */\n    }\n\n    /* Points */\n    .point {\n      cursor: grab;\n      pointer-events: all;\n      transform-origin: center;\n      transition: r 140ms ease, opacity 200ms ease;\n    }\n\n    .point:active { cursor: grabbing; }\n\n    .test-point {\n      stroke: #fff;\n      stroke-width: 2;\n      cursor: move;\n      pointer-events: all;\n    }\n\n    /* Highlight neighbor */\n    .neighbor {\n      filter: drop-shadow(0 6px 12px rgba(0,0,0,0.6));\n      animation: pulse 1100ms ease-in-out infinite;\n    }\n\n    @keyframes pulse {\n      0% { transform: scale(1); opacity: 1; }\n      50% { transform: scale(1.15); opacity: 0.85; }\n      100% { transform: scale(1); opacity: 1; }\n    }\n\n    .connector {\n      stroke: rgba(255,255,255,0.12);\n      stroke-width: 1.5;\n    }\n\n    /* Info bar */\n    .info {\n      display: flex;\n      justify-content: space-between;\n      gap: var(--gap);\n      align-items: center;\n      padding: 8px 12px;\n      border-radius: 8px;\n      background: rgba(255,255,255,0.01);\n      font-size: 13px;\n      color: var(--muted);\n    }\n\n    .info .result {\n      display: flex;\n      gap: 12px;\n      align-items: center;\n      font-weight: 600;\n      color: #e6eef8;\n      font-size: 15px;\n    }\n\n    .dist-list {\n      max-height: 160px;\n      overflow: auto;\n      margin-top: 8px;\n      padding: 8px;\n      background: rgba(255,255,255,0.01);\n      border-radius: 8px;\n      font-size: 13px;\n      color: var(--muted);\n    }\n\n    .dist-list table {\n      width: 100%;\n      border-collapse: collapse;\n      color: inherit;\n      font-size: 13px;\n    }\n\n    .dist-list td {\n      padding: 6px 4px;\n      vertical-align: middle;\n    }\n\n    .dist-list .class-dot {\n      width: 10px;\n      height: 10px;\n      border-radius: 50%;\n      display: inline-block;\n      margin-right: 8px;\n    }\n\n    .sr-only {\n      position: absolute !important;\n      width: 1px !important;\n      height: 1px !important;\n      padding: 0 !important;\n      margin: -1px !important;\n      overflow: hidden !important;\n      clip: rect(0,0,0,0) !important;\n      white-space: nowrap !important;\n      border: 0 !important;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"application\" aria-label=\"K-Nearest Neighbors interactive module\">\n    <!-- Left Panel: Explanation and Controls -->\n    <div class=\"panel left\" aria-hidden=\"false\">\n      <div class=\"title\" aria-hidden=\"false\">\n        <h1>Concept: K-Nearest Neighbors (KNN)</h1>\n        <p class=\"meta\">Interactive exploration of how K affects classification. Drag points, adjust K, and place a test point to see voting and neighbours.</p>\n      </div>\n\n      <!-- Learning Objective -->\n      <div class=\"panel\" style=\"padding:12px;\">\n        <strong style=\"display:block;margin-bottom:8px;\">Learning objective</strong>\n        <div style=\"color:var(--muted);font-size:13px;line-height:1.4;\">\n          After interacting you should be able to:\n          <ul style=\"margin:8px 0 0 16px;\">\n            <li>Explain how K determines which nearby labeled points influence a prediction.</li>\n            <li>See how changing K and distance metric affects the decision region.</li>\n            <li>Observe tie-breaking and how noisy points influence local decisions.</li>\n          </ul>\n        </div>\n      </div>\n\n      <!-- Interaction Design -->\n      <div class=\"panel\" style=\"padding:12px;\">\n        <strong style=\"display:block;margin-bottom:8px;\">Interaction design</strong>\n        <div style=\"color:var(--muted);font-size:13px;line-height:1.4;\">\n          Use the controls below and interact with the plot:\n          <ul style=\"margin:8px 0 0 16px;\">\n            <li>Click Add Point (then click canvas) to add a blue or red labeled point.</li>\n            <li>Drag any training point or the test point to new positions.</li>\n            <li>Slide K to change how many neighbours vote — nearest K are highlighted and animated.</li>\n            <li>Toggle the classification field to compute a colored decision surface (recomputes at a modest resolution).</li>\n            <li>Keyboard: select the test point (click it) then use arrow keys to nudge by small steps.</li>\n          </ul>\n        </div>\n      </div>\n\n      <!-- Controls -->\n      <div class=\"controls\" aria-hidden=\"false\">\n        <div>\n          <label for=\"kRange\">K: <span id=\"kValue\">3</span></label>\n          <div class=\"control-group\">\n            <input id=\"kRange\" type=\"range\" min=\"1\" max=\"15\" value=\"3\" aria-label=\"K neighbors slider\">\n            <input id=\"kNumber\" type=\"number\" min=\"1\" max=\"50\" value=\"3\" aria-label=\"K neighbors number\">\n          </div>\n        </div>\n\n        <div>\n          <label>Distance metric</label>\n          <div class=\"row\" role=\"radiogroup\" aria-label=\"Distance metric\">\n            <label style=\"display:flex;gap:8px;align-items:center;cursor:pointer;\">\n              <input type=\"radio\" name=\"metric\" value=\"euclidean\" checked> Euclidean\n            </label>\n            <label style=\"display:flex;gap:8px;align-items:center;cursor:pointer;\">\n              <input type=\"radio\" name=\"metric\" value=\"manhattan\"> Manhattan\n            </label>\n            <label style=\"display:flex;gap:8px;align-items:center;cursor:pointer;\">\n              <input type=\"radio\" name=\"metric\" value=\"chebyshev\"> Chebyshev\n            </label>\n          </div>\n        </div>\n\n        <div>\n          <label>Add points</label>\n          <div class=\"row\">\n            <button id=\"addBlue\" class=\"btn\" aria-pressed=\"false\">Add Blue</button>\n            <button id=\"addRed\" class=\"btn\" aria-pressed=\"false\" style=\"background:transparent;border:1px solid rgba(255,255,255,0.04);\">Add Red</button>\n            <button id=\"randomize\" class=\"btn secondary\">Randomize</button>\n            <button id=\"clear\" class=\"btn secondary\">Clear</button>\n          </div>\n          <div style=\"margin-top:8px;font-size:13px;color:var(--muted);\">After clicking Add, click inside the plot to place the new point.</div>\n        </div>\n\n        <div>\n          <label>Decision surface</label>\n          <div class=\"row\">\n            <button id=\"toggleField\" class=\"btn secondary\" aria-pressed=\"false\">Show Field</button>\n            <label style=\"display:flex;gap:8px;align-items:center;cursor:pointer;margin-left:8px;\">\n              <input id=\"showConnect\" type=\"checkbox\"> Show connector lines\n            </label>\n          </div>\n          <div style=\"margin-top:8px;color:var(--muted);font-size:13px;\">Field is computed at a reduced resolution for speed. Toggled recomputation animates opacity.</div>\n        </div>\n\n        <div>\n          <label>Legend & tips</label>\n          <div class=\"legend\" aria-hidden=\"true\">\n            <div class=\"item\"><span class=\"swatch\" style=\"background:var(--accent1)\"></span> Class A (blue)</div>\n            <div class=\"item\"><span class=\"swatch\" style=\"background:var(--accent2)\"></span> Class B (red)</div>\n            <div class=\"item\" style=\"color:var(--muted);font-size:12px;\">Test point has white border</div>\n          </div>\n        </div>\n      </div>\n\n    </div>\n\n    <!-- Right Panel: Visualization -->\n    <div class=\"panel viz\" role=\"region\" aria-label=\"Visualization panel\">\n      <div class=\"canvas-panel\" role=\"region\" aria-label=\"KNN plot area\" >\n        <div class=\"plot\" id=\"plot\" tabindex=\"0\" aria-label=\"Interactive scatter plot. Click to add points.\">\n          <!-- classification field canvas (below) -->\n          <canvas id=\"fieldCanvas\"></canvas>\n          <!-- SVG overlay for points and interactions -->\n          <svg id=\"overlay\" xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"false\"></svg>\n        </div>\n\n        <div class=\"info\" role=\"status\" aria-live=\"polite\">\n          <div>\n            <div style=\"color:var(--muted);font-size:12px\">Prediction</div>\n            <div class=\"result\" id=\"prediction\">—</div>\n            <div style=\"font-size:12px;color:var(--muted);margin-left:8px;\">(probability shown as fraction of K)</div>\n          </div>\n          <div style=\"text-align:right\">\n            <div style=\"color:var(--muted);font-size:12px\">Distance metric</div>\n            <div id=\"metricLabel\" style=\"font-weight:600;color:var(--muted)\">Euclidean</div>\n          </div>\n        </div>\n\n        <div style=\"display:flex;gap:var(--gap);align-items:flex-start;flex-wrap:wrap;\">\n          <div style=\"flex:1 1 320px;min-width:0;\">\n            <div style=\"font-weight:600;margin-bottom:8px;\">Neighbors (closest first)</div>\n            <div class=\"dist-list\" id=\"distList\" aria-live=\"polite\">\n              <table id=\"distTable\"><tbody></tbody></table>\n            </div>\n          </div>\n\n          <div style=\"width:240px;min-width:240px;\">\n            <div style=\"font-weight:600;margin-bottom:8px;\">Controls / tips</div>\n            <div style=\"color:var(--muted);font-size:13px;line-height:1.4\">\n              • Click an existing point to select and drag.<br>\n              • Click the test point (white border) then arrow keys to nudge.<br>\n              • Hold Shift while dragging to snap to a grid (coarse).<br>\n              • Use Randomize to place a new dataset.\n            </div>\n          </div>\n        </div>\n\n      </div>\n    </div>\n\n  </div>\n\n  <!-- Accessibility helper -->\n  <div class=\"sr-only\" aria-live=\"polite\" id=\"ariaStatus\"></div>\n\n  <script>\n    /**\n     * KNN Interactive Module (vanilla JS)\n     * - Uses an HTML canvas for the classification field (decision surface).\n     * - Uses SVG overlay for points and interactive elements.\n     * - Points are draggable via pointer events.\n     * - Test point is distinct and can be moved and keyboard-nudged.\n     */\n\n    (function () {\n      // Utilities\n      function $(sel, root=document) { return root.querySelector(sel); }\n      function $all(sel, root=document) { return Array.from(root.querySelectorAll(sel)); }\n      function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }\n      function distSq(a,b, metric='euclidean') {\n        const dx = a.x - b.x, dy = a.y - b.y;\n        if (metric === 'euclidean') return dx*dx + dy*dy;\n        if (metric === 'manhattan') return Math.abs(dx)+Math.abs(dy);\n        if (metric === 'chebyshev') return Math.max(Math.abs(dx), Math.abs(dy));\n        return dx*dx + dy*dy;\n      }\n      function formatNum(n){ return (Math.round(n*1000)/1000).toString(); }\n\n      // DOM refs\n      const plot = $('#plot');\n      const overlay = $('#overlay');\n      const fieldCanvas = $('#fieldCanvas');\n      const kRange = $('#kRange');\n      const kNumber = $('#kNumber');\n      const kValueLabel = $('#kValue');\n      const toggleField = $('#toggleField');\n      const addBlue = $('#addBlue');\n      const addRed = $('#addRed');\n      const randomize = $('#randomize');\n      const clearBtn = $('#clear');\n      const showConnect = $('#showConnect');\n      const distTableBody = $('#distTable tbody');\n      const predictionLabel = $('#prediction');\n      const metricLabel = $('#metricLabel');\n      const ariaStatus = $('#ariaStatus');\n\n      // Colors\n      const COLORS = {\n        A: getComputedStyle(document.documentElement).getPropertyValue('--accent1').trim() || '#3b82f6',\n        B: getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim() || '#ef4444'\n      };\n\n      // State\n      const state = {\n        width: 800,\n        height: 560,\n        devicePixelRatio: Math.max(1, window.devicePixelRatio || 1),\n        points: [], // training points: {id, x,y (0-1), cls: 'A'|'B'}\n        testPoint: { x: 0.5, y: 0.5 },\n        k: parseInt(kRange.value,10),\n        metric: 'euclidean',\n        showField: false,\n        addingClass: null, // 'A'|'B' when user clicked Add\n        showConnectors: false,\n        neighborIndices: [], // indices of nearest neighbors\n      };\n\n      // ID generation\n      let idSeq = 1;\n      function nextId(){ return idSeq++; }\n\n      // Initialize canvas size & svg\n      function resizePlot() {\n        const rect = plot.getBoundingClientRect();\n        const w = Math.max(120, Math.floor(rect.width));\n        const h = Math.max(120, Math.floor(rect.height));\n        state.width = w;\n        state.height = h;\n        // adjust canvas for DPR but keep logical smaller resolution for field\n        const dpr = state.devicePixelRatio;\n        fieldCanvas.width = w * dpr;\n        fieldCanvas.height = h * dpr;\n        fieldCanvas.style.width = w + 'px';\n        fieldCanvas.style.height = h + 'px';\n        // overlay SVG size\n        overlay.setAttribute('viewBox', `0 0 ${w} ${h}`);\n        overlay.setAttribute('width', w);\n        overlay.setAttribute('height', h);\n        // redraw\n        renderAll();\n      }\n\n      window.addEventListener('resize', () => {\n        // debounce\n        clearTimeout(window.__knn_resize);\n        window.__knn_resize = setTimeout(resizePlot, 80);\n      });\n\n      // Coordinate transforms: normalized <-> pixel\n      function toPx(p) {\n        return { x: p.x * state.width, y: p.y * state.height };\n      }\n      function fromPx(px) {\n        return { x: clamp(px.x / state.width, 0, 1), y: clamp(px.y / state.height, 0, 1) };\n      }\n\n      // Create initial random dataset\n      function seedRandom(n=8) {\n        state.points = [];\n        for (let i=0;i<n;i++){\n          state.points.push({ id: nextId(), x: Math.random()*0.5+0.0, y: Math.random()*0.5+0.0, cls: 'A' });\n          state.points.push({ id: nextId(), x: Math.random()*0.5+0.5, y: Math.random()*0.5+0.5, cls: 'B' });\n        }\n        // add some scattered noise points\n        for (let i=0;i<4;i++){\n          state.points.push({ id: nextId(), x: Math.random(), y: Math.random(), cls: (Math.random()>0.5?'A':'B') });\n        }\n        renderAll();\n      }\n\n      // Render everything: field (maybe), points, connectors, neighbor list, prediction\n      function renderAll() {\n        renderField(); // will compute if showField\n        renderSVGOverlay();\n        computeNeighborsAndUpdateUI();\n      }\n\n      // Field computation: color each pixel by majority vote of K nearest training points.\n      // We'll compute at a reduced resolution for speed and upscale.\n      let lastFieldImage = null;\n      function renderField() {\n        const ctx = fieldCanvas.getContext('2d');\n        if (!state.showField || state.points.length === 0) {\n          fieldCanvas.classList.add('hidden');\n          return;\n        }\n        fieldCanvas.classList.remove('hidden');\n\n        // For speed: compute at a coarse resolution, e.g., 160px on the smaller side\n        const target = Math.min(260, Math.max(120, Math.floor(Math.min(state.width, state.height) * 0.6)));\n        const aspect = state.width / state.height;\n        const w = Math.floor(target * aspect);\n        const h = Math.floor(target);\n        // create an offscreen canvas for computation\n        const off = document.createElement('canvas');\n        off.width = w;\n        off.height = h;\n        const ox = off.getContext('2d');\n        const img = ox.createImageData(w,h);\n        const px = img.data;\n        const pts = state.points;\n        const k = Math.max(1, Math.min(state.k, pts.length));\n        const metric = state.metric;\n\n        // Pixel loop\n        for (let j=0;j<h;j++){\n          for (let i=0;i<w;i++){\n            const nx = (i + 0.5) / w;\n            const ny = (j + 0.5) / h;\n            // compute distances to every point\n            const arr = [];\n            for (let p of pts){\n              const ds = distForPixel(p, nx, ny, metric);\n              arr.push({ cls: p.cls, d: ds });\n            }\n            // sort by distance\n            arr.sort((a,b) => a.d - b.d);\n            // majority vote among top-k\n            const counts = { A: 0, B: 0 };\n            for (let t=0;t<k;t++) counts[arr[t].cls]++;\n            let chosen = counts.A > counts.B ? 'A' : (counts.B > counts.A ? 'B' : null);\n            if (!chosen) {\n              // tie-breaker: choose class with smaller sum of distances among top-k\n              const sums = { A: 0, B: 0 };\n              for (let t=0;t<k;t++) sums[arr[t].cls] += arr[t].d;\n              chosen = sums.A <= sums.B ? 'A' : 'B';\n            }\n            // color blend slightly based on distance of nearest neighbor (local confidence)\n            const nearestD = arr[0].d;\n            const maxConfidence = 0.2; // influence of confidence (lower = more confident)\n            let alpha = clamp(1 - Math.min(1, nearestD / (0.1*0.1)), 0.18, 0.98);\n            const color = chosen === 'A' ? hexToRgb(COLORS.A) : hexToRgb(COLORS.B);\n            const idx = (j*w + i)*4;\n            px[idx] = Math.round(color.r * alpha + 5*(1-alpha));\n            px[idx+1] = Math.round(color.g * alpha + 7*(1-alpha));\n            px[idx+2] = Math.round(color.b * alpha + 9*(1-alpha));\n            px[idx+3] = 220; // alpha\n          }\n        }\n\n        ox.putImageData(img, 0, 0);\n\n        // upscale to main canvas (consider device pixel ratio)\n        const scale = state.devicePixelRatio;\n        ctx.clearRect(0,0, fieldCanvas.width, fieldCanvas.height);\n        ctx.imageSmoothingEnabled = true;\n        ctx.drawImage(off, 0, 0, fieldCanvas.width, fieldCanvas.height);\n\n        // Animate appearance by toggling opacity (CSS transition)\n        fieldCanvas.classList.remove('hidden');\n      }\n\n      // helper: distance metric for pixel coordinates (normalized)\n      function distForPixel(p, nx, ny, metric) {\n        const dx = p.x - nx, dy = p.y - ny;\n        if (metric === 'euclidean') return Math.sqrt(dx*dx + dy*dy);\n        if (metric === 'manhattan') return Math.abs(dx) + Math.abs(dy);\n        if (metric === 'chebyshev') return Math.max(Math.abs(dx), Math.abs(dy));\n        return Math.sqrt(dx*dx + dy*dy);\n      }\n\n      // Convert hex color to rgb object\n      function hexToRgb(hex) {\n        const h = hex.replace('#','').trim();\n        const bigint = parseInt(h,16);\n        if (h.length === 3) {\n          const r = parseInt(h[0]+h[0],16);\n          const g = parseInt(h[1]+h[1],16);\n          const b = parseInt(h[2]+h[2],16);\n          return {r,g,b};\n        }\n        return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };\n      }\n\n      // Render SVG overlay: points, test point, connectors\n      function renderSVGOverlay() {\n        // Clear overlay\n        while (overlay.firstChild) overlay.removeChild(overlay.firstChild);\n\n        // draw connectors for neighbors if enabled\n        if (state.showConnectors && state.neighborIndices.length > 0) {\n          for (let i=0;i<state.neighborIndices.length;i++){\n            const pi = state.points[state.neighborIndices[i]];\n            if (!pi) continue;\n            const ppx = toPx(pi);\n            const tpx = toPx(state.testPoint);\n            const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n            line.setAttribute('x1', ppx.x);\n            line.setAttribute('y1', ppx.y);\n            line.setAttribute('x2', tpx.x);\n            line.setAttribute('y2', tpx.y);\n            line.setAttribute('class','connector');\n            line.setAttribute('stroke', 'rgba(255,255,255,0.08)');\n            overlay.appendChild(line);\n          }\n        }\n\n        // draw training points\n        for (let i=0;i<state.points.length;i++){\n          const p = state.points[i];\n          const px = toPx(p);\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('transform', `translate(${px.x},${px.y})`);\n          g.style.pointerEvents = 'all';\n          g.dataset.index = i;\n          // Circle\n          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          circle.setAttribute('r', 8);\n          circle.setAttribute('cx', 0);\n          circle.setAttribute('cy', 0);\n          circle.setAttribute('fill', p.cls === 'A' ? COLORS.A : COLORS.B);\n          circle.setAttribute('class', 'point');\n          circle.setAttribute('data-id', p.id);\n          // If it's a neighbor highlight, mark class\n          if (state.neighborIndices.includes(i)) {\n            circle.classList.add('neighbor');\n            circle.setAttribute('r', 10);\n          }\n          // pointer handling\n          circle.style.cursor = 'grab';\n          circle.addEventListener('pointerdown', onPointPointerDown);\n          // Provide a title for accessibility\n          circle.setAttribute('aria-label', `Training point ${i+1}, class ${p.cls}`);\n          g.appendChild(circle);\n          overlay.appendChild(g);\n        }\n\n        // draw test point on top\n        const tp = state.testPoint;\n        const tpx = toPx(tp);\n        const gtest = document.createElementNS('http://www.w3.org/2000/svg','g');\n        gtest.setAttribute('transform', `translate(${tpx.x},${tpx.y})`);\n        gtest.style.pointerEvents = 'all';\n        // outer halo\n        const halo = document.createElementNS('http://www.w3.org/2000/svg','circle');\n        halo.setAttribute('r', 12);\n        halo.setAttribute('cx', 0);\n        halo.setAttribute('cy', 0);\n        halo.setAttribute('fill', 'none');\n        halo.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n        halo.setAttribute('stroke-width', '2');\n        gtest.appendChild(halo);\n        // main circle\n        const tc = document.createElementNS('http://www.w3.org/2000/svg','circle');\n        tc.setAttribute('r', 9);\n        tc.setAttribute('cx', 0);\n        tc.setAttribute('cy', 0);\n        tc.setAttribute('fill', '#fff0');\n        tc.setAttribute('class','test-point');\n        tc.setAttribute('stroke', '#ffffff');\n        tc.setAttribute('stroke-width', 2.5);\n        tc.setAttribute('fill-opacity', 0.06);\n        tc.style.cursor = 'move';\n        tc.setAttribute('aria-label', 'Test point. Click to select and drag, then use arrow keys to nudge.');\n        tc.addEventListener('pointerdown', onTestPointerDown);\n        gtest.appendChild(tc);\n\n        overlay.appendChild(gtest);\n      }\n\n      // Pointer interactions for training points\n      let dragState = null;\n      function onPointPointerDown(e) {\n        e.preventDefault();\n        const g = e.currentTarget.parentNode;\n        const idx = parseInt(g.dataset.index,10);\n        if (isNaN(idx)) return;\n        const start = { x: e.clientX, y: e.clientY };\n        const p0 = { x: state.points[idx].x, y: state.points[idx].y };\n        dragState = {\n          type: 'point',\n          index: idx,\n          start,\n          p0,\n          pointerId: e.pointerId\n        };\n        e.currentTarget.setPointerCapture(e.pointerId);\n        overlay.addEventListener('pointermove', onPointerMove);\n        overlay.addEventListener('pointerup', onPointerUp, { once: true });\n      }\n\n      // Pointer interactions for test point\n      function onTestPointerDown(e) {\n        e.preventDefault();\n        const start = { x: e.clientX, y: e.clientY };\n        const p0 = { x: state.testPoint.x, y: state.testPoint.y };\n        dragState = {\n          type: 'test',\n          start,\n          p0,\n          pointerId: e.pointerId\n        };\n        e.currentTarget.setPointerCapture(e.pointerId);\n        overlay.addEventListener('pointermove', onPointerMove);\n        overlay.addEventListener('pointerup', onPointerUp, { once: true });\n        // mark selected for keyboard nudging\n        overlay.setAttribute('data-selected', 'test');\n        plot.focus();\n      }\n\n      function onPointerMove(e) {\n        if (!dragState) return;\n        const dx = e.clientX - dragState.start.x;\n        const dy = e.clientY - dragState.start.y;\n        const svgRect = plot.getBoundingClientRect();\n        // map mouse position to normalized coords\n        if (dragState.type === 'point') {\n          // move point relative to initial\n          const px = { x: (dragState.p0.x * state.width) + dx, y: (dragState.p0.y * state.height) + dy };\n          // support Shift snapping\n          if (e.shiftKey) {\n            // snap to 10x10 grid\n            px.x = Math.round(px.x / (state.width/10)) * (state.width/10);\n            px.y = Math.round(px.y / (state.height/10)) * (state.height/10);\n          }\n          const norm = fromPx(px);\n          state.points[dragState.index].x = norm.x;\n          state.points[dragState.index].y = norm.y;\n        } else if (dragState.type === 'test') {\n          const px = { x: (dragState.p0.x * state.width) + dx, y: (dragState.p0.y * state.height) + dy };\n          if (e.shiftKey) {\n            px.x = Math.round(px.x / (state.width/10)) * (state.width/10);\n            px.y = Math.round(px.y / (state.height/10)) * (state.height/10);\n          }\n          const norm = fromPx(px);\n          state.testPoint.x = norm.x;\n          state.testPoint.y = norm.y;\n        }\n        renderAll();\n      }\n\n      function onPointerUp(e) {\n        if (!dragState) return;\n        try {\n          overlay.releasePointerCapture(dragState.pointerId);\n        } catch (err) {}\n        dragState = null;\n        overlay.removeEventListener('pointermove', onPointerMove);\n        // finalize\n        renderAll();\n      }\n\n      // Click in plot to add points when in adding mode\n      plot.addEventListener('pointerdown', (e) => {\n        // ensure clicking on empty area; don't intercept drag events already started on points\n        if (state.addingClass) {\n          const rect = plot.getBoundingClientRect();\n          const px = { x: e.clientX - rect.left, y: e.clientY - rect.top };\n          const norm = fromPx(px);\n          state.points.push({ id: nextId(), x: norm.x, y: norm.y, cls: state.addingClass });\n          // clear adding mode\n          state.addingClass = null;\n          addBlue.setAttribute('aria-pressed','false');\n          addRed.setAttribute('aria-pressed','false');\n          renderAll();\n          ariaStatus.textContent = `Added a ${state.points[state.points.length-1].cls === 'A' ? 'blue' : 'red'} point at (${formatNum(norm.x)}, ${formatNum(norm.y)}).`;\n        }\n      });\n\n      // Keyboard nudging for test point (when overlay is focused)\n      plot.addEventListener('keydown', (e) => {\n        const selected = overlay.getAttribute('data-selected');\n        if (selected !== 'test') return;\n        let handled = false;\n        const step = e.shiftKey ? 0.02 : 0.005;\n        if (e.key === 'ArrowUp') { state.testPoint.y = clamp(state.testPoint.y - step, 0,1); handled=true; }\n        if (e.key === 'ArrowDown') { state.testPoint.y = clamp(state.testPoint.y + step, 0,1); handled=true; }\n        if (e.key === 'ArrowLeft') { state.testPoint.x = clamp(state.testPoint.x - step, 0,1); handled=true; }\n        if (e.key === 'ArrowRight') { state.testPoint.x = clamp(state.testPoint.x + step, 0,1); handled=true; }\n        if (handled) { e.preventDefault(); renderAll(); }\n      });\n\n      // Compute neighbors and update UI list & prediction\n      function computeNeighborsAndUpdateUI() {\n        const pts = state.points;\n        if (pts.length === 0) {\n          state.neighborIndices = [];\n          predictionLabel.textContent = '—';\n          distTableBody.innerHTML = '<tr><td style=\"color:var(--muted);\">Add training points to classify the test point.</td></tr>';\n          return;\n        }\n        // compute distance list\n        const arr = [];\n        for (let i=0;i<pts.length;i++){\n          const p = pts[i];\n          const d = distSq(p, state.testPoint, state.metric);\n          // For sorting: for Manhattan we used non-squared distances earlier; here for uniformity we can use actual metric\n          let dispDistance;\n          if (state.metric === 'euclidean') dispDistance = Math.sqrt(d);\n          else dispDistance = d; // for Manhattan/Chebyshev we set distSq to use direct values in distSq earlier\n          arr.push({ index: i, cls: p.cls, d: dispDistance });\n        }\n        arr.sort((a,b) => a.d - b.d);\n        const k = Math.max(1, Math.min(state.k, arr.length));\n        // store neighbor indices\n        state.neighborIndices = arr.slice(0,k).map(x=>x.index);\n\n        // build table\n        distTableBody.innerHTML = '';\n        for (let i=0;i<arr.length;i++){\n          const row = document.createElement('tr');\n          const td1 = document.createElement('td');\n          td1.innerHTML = `<span class=\"class-dot\" style=\"background:${arr[i].cls==='A'?COLORS.A:COLORS.B}\"></span> #${arr[i].index+1}`;\n          const td2 = document.createElement('td');\n          td2.style.textAlign = 'right';\n          td2.style.color = (i<k) ? '#fff' : 'var(--muted)';\n          td2.textContent = `${formatNum(arr[i].d)}`;\n          row.appendChild(td1);\n          row.appendChild(td2);\n          distTableBody.appendChild(row);\n        }\n\n        // majority vote among top-k\n        const votes = { A: 0, B: 0 };\n        for (let t=0;t<k;t++) votes[arr[t].cls]++;\n        let chosen = votes.A > votes.B ? 'A' : (votes.B > votes.A ? 'B' : null);\n        let reason = '';\n        if (!chosen) {\n          // tie-breaker: choose class with smaller sum of distances among top-k\n          const sums = { A: 0, B: 0 };\n          for (let t=0;t<k;t++) sums[arr[t].cls] += arr[t].d;\n          chosen = sums.A <= sums.B ? 'A' : 'B';\n          reason = ' (tie broken by sum of distances)';\n        }\n        const prob = Math.round((votes[chosen] / k)*100);\n        predictionLabel.innerHTML = `<span style=\"display:inline-block;width:12px;height:12px;border-radius:50%;background:${chosen==='A'?COLORS.A:COLORS.B};margin-right:8px;\"></span>Class ${chosen === 'A' ? 'A (blue)' : 'B (red)'} — ${votes[chosen]}/${k} votes${reason}`;\n        metricLabel.textContent = state.metric.charAt(0).toUpperCase() + state.metric.slice(1);\n\n        // announce for screen readers\n        ariaStatus.textContent = `Prediction: class ${chosen === 'A' ? 'A' : 'B'}. ${votes[chosen]} out of ${k} neighbors voted for the chosen class.`;\n\n        // re-render overlay to animate neighbor highlights\n        renderSVGOverlay();\n      }\n\n      // UI event handlers\n      kRange.addEventListener('input', (e) => {\n        const val = parseInt(e.target.value,10);\n        state.k = val;\n        kNumber.value = val;\n        kValueLabel.textContent = val;\n        renderAll();\n      });\n      kNumber.addEventListener('input', (e) => {\n        let val = parseInt(e.target.value,10);\n        if (isNaN(val)) val = state.k;\n        val = clamp(val,1, Math.max(1, state.points.length || 1));\n        state.k = val;\n        kRange.value = val;\n        kValueLabel.textContent = val;\n        renderAll();\n      });\n\n      $all('input[name=\"metric\"]').forEach(r => r.addEventListener('change', (e) => {\n        state.metric = e.target.value;\n        renderAll();\n      }));\n\n      toggleField.addEventListener('click', (e) => {\n        state.showField = !state.showField;\n        toggleField.setAttribute('aria-pressed', String(state.showField));\n        toggleField.textContent = state.showField ? 'Hide Field' : 'Show Field';\n        // animate change via opacity\n        if (state.showField) {\n          fieldCanvas.classList.remove('hidden');\n        } else {\n          fieldCanvas.classList.add('hidden');\n        }\n        renderAll();\n      });\n\n      addBlue.addEventListener('click', () => {\n        state.addingClass = state.addingClass === 'A' ? null : 'A';\n        addBlue.setAttribute('aria-pressed', String(state.addingClass === 'A'));\n        addRed.setAttribute('aria-pressed', 'false');\n      });\n      addRed.addEventListener('click', () => {\n        state.addingClass = state.addingClass === 'B' ? null : 'B';\n        addRed.setAttribute('aria-pressed', String(state.addingClass === 'B'));\n        addBlue.setAttribute('aria-pressed', 'false');\n      });\n\n      randomize.addEventListener('click', () => {\n        seedRandom(7);\n        ariaStatus.textContent = 'Randomized dataset.';\n      });\n\n      clearBtn.addEventListener('click', () => {\n        state.points = [];\n        renderAll();\n        ariaStatus.textContent = 'Cleared all training points.';\n      });\n\n      showConnect.addEventListener('change', (e) => {\n        state.showConnectors = e.target.checked;\n        renderAll();\n      });\n\n      // initial seed\n      seedRandom(5);\n\n      // initial size\n      resizePlot();\n\n      // ensure devicePixelRatio updates on zoom\n      let dprObserver = null;\n      try {\n        // monitor window.devicePixelRatio changes if supported\n        const mq = window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);\n        if (mq && mq.addEventListener) {\n          mq.addEventListener('change', () => {\n            state.devicePixelRatio = Math.max(1, window.devicePixelRatio || 1);\n            resizePlot();\n          });\n        }\n      } catch (err) {}\n\n      // Accessibility: clicking outside deselects test\n      document.addEventListener('pointerdown', (e) => {\n        if (!plot.contains(e.target)) {\n          overlay.removeAttribute('data-selected');\n        }\n      });\n\n      // Expose functions to global for debugging (optional)\n      window.__knn = {\n        state,\n        renderAll,\n        seedRandom\n      };\n\n      // Small initial announcement\n      ariaStatus.textContent = 'K nearest neighbors interactive module loaded. Use controls to explore.';\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of K-Nearest Neighbors (KNN).\n\n**Project Overview:**\nTopic: K-Nearest Neighbors (KNN)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "K-Nearest Neighbors (KNN)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "e087ec10-bde5-11f0-95af-4764f61ee009",
    "timestamp": "2025-11-10T03:32:26.065Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Bubble Sort",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Bubble Sort Explorer</title>\n  <style>\n    /* Safe area margins and base styles */\n    :root{\n      --safe-pad: 24px;\n      --gap: 16px;\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --muted: #98a2b3;\n      --accent: #38bdf8;\n      --good: #34d399;\n      --danger: #fb7185;\n      --glass: rgba(255,255,255,0.02);\n      --bar-gap: 8px;\n      --max-bars: 20;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071125 0%, #071022 100%);\n      color:#e6eef6;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app {\n      padding: var(--safe-pad);\n      min-height:100%;\n      box-sizing:border-box;\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      justify-content:center;\n    }\n\n    /* Layout: left info + controls, right visualization */\n    .left {\n      width: 360px;\n      min-width: 280px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n      border-radius:12px;\n      padding:20px;\n      box-sizing:border-box;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      border: 1px solid rgba(255,255,255,0.03);\n    }\n\n    .right {\n      flex:1;\n      min-width:320px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:12px;\n      padding:20px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      border: 1px solid rgba(255,255,255,0.03);\n    }\n\n    /* Info sections */\n    .title {\n      font-size:20px;\n      font-weight:600;\n      color:var(--accent);\n      display:flex;\n      gap:12px;\n      align-items:center;\n    }\n    .subtitle {\n      font-size:13px;\n      color:var(--muted);\n      margin-top:4px;\n    }\n\n    .section {\n      background: rgba(255,255,255,0.02);\n      padding:12px;\n      border-radius:8px;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    .section h4 {\n      margin:0;\n      font-size:13px;\n      color:#e6f5ff;\n    }\n    .section p {\n      margin:0;\n      font-size:13px;\n      color:var(--muted);\n      line-height:1.4;\n    }\n\n    /* Controls */\n    .controls {\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .row {\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n    }\n    .btn {\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      color:#e8f6ff;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:13px;\n      min-height:40px;\n      display:inline-flex;\n      align-items:center;\n      justify-content:center;\n      gap:8px;\n    }\n    .btn:active { transform:translateY(1px); }\n    .btn.primary {\n      background:linear-gradient(180deg,#0369a1,#035378);\n      box-shadow: 0 6px 18px rgba(2,6,23,0.6);\n      border: none;\n    }\n    .btn.ghost {\n      background:transparent;\n      border:1px dashed rgba(255,255,255,0.04);\n    }\n    .btn.small { padding:6px 10px; font-size:13px; min-height:36px; }\n\n    input[type=\"text\"], input[type=\"number\"], select {\n      background: rgba(255,255,255,0.02);\n      border:1px solid rgba(255,255,255,0.03);\n      color:#e6f5ff;\n      padding:8px 10px;\n      border-radius:8px;\n      font-size:13px;\n      outline:none;\n    }\n    input[type=\"range\"] {\n      width:100%;\n      accent-color:var(--accent);\n    }\n\n    .stats {\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n    }\n    .stat {\n      background: rgba(255,255,255,0.02);\n      padding:8px 10px;\n      border-radius:8px;\n      min-width:100px;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .stat strong { display:block; color:#e6f5ff; font-size:15px; }\n\n    /* Visualization area */\n    .viz {\n      height:420px;\n      background: linear-gradient(180deg, rgba(8,15,28,0.5), rgba(6,10,18,0.2));\n      border-radius:8px;\n      padding:16px;\n      position:relative;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      overflow:hidden;\n    }\n    .viz-header {\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:12px;\n    }\n    .legend {\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n    .legend .key {\n      display:flex;\n      gap:8px;\n      align-items:center;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .swatch {\n      width:12px; height:12px; border-radius:3px;\n    }\n\n    .bars-wrap {\n      flex:1;\n      position:relative;\n      border-radius:6px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);\n      display:block;\n      padding:12px;\n      box-sizing:border-box;\n      overflow:hidden;\n    }\n\n    /* Bars container will be positioned relative; bars are inline-block */\n    .bars {\n      position:relative;\n      height:100%;\n      width:100%;\n    }\n    .bar {\n      position:absolute;\n      bottom:12px;\n      width: calc((100% - (var(--bar-gap) * (var(--count) - 1))) / var(--count));\n      background:linear-gradient(180deg,#60a5fa,#0369a1);\n      border-radius:6px 6px 4px 4px;\n      display:flex;\n      align-items:flex-end;\n      justify-content:center;\n      color:#021124;\n      font-weight:700;\n      font-size:12px;\n      transition: height 350ms cubic-bezier(.22,.9,.18,1), background 220ms, transform 300ms;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.35);\n    }\n    .bar .label {\n      transform:translateY(6px);\n      color:rgba(0,0,0,0.6);\n      padding-bottom:6px;\n    }\n\n    .bar.compare { background: linear-gradient(180deg,#fef08a,#f59e0b); }\n    .bar.swap { background: linear-gradient(180deg,#fb7185,#ef4444); transform: translateY(-6px); }\n    .bar.sorted { background: linear-gradient(180deg,#34d399,#10b981); color:#042014; }\n\n    /* Swap horizontal nudge animation */\n    .nudge-left { animation: nudge-left 300ms ease; }\n    .nudge-right { animation: nudge-right 300ms ease; }\n    @keyframes nudge-left {\n      0% { transform: translateX(0); }\n      50% { transform: translateX(-18px) translateY(-6px); }\n      100% { transform: translateX(0); }\n    }\n    @keyframes nudge-right {\n      0% { transform: translateX(0); }\n      50% { transform: translateX(18px) translateY(-6px); }\n      100% { transform: translateX(0); }\n    }\n\n    /* Footer control tips */\n    .tips { font-size:12px; color:var(--muted); }\n\n    /* Responsive: stack on small screens */\n    @media (max-width:980px){\n      .app { flex-direction:column; padding:16px; }\n      .left, .right { width:100%; }\n      .left { order:2; }\n      .right { order:1; }\n      .viz { height:360px; }\n    }\n\n    /* Accessibility focus */\n    .btn:focus, input:focus { outline: 2px dashed rgba(56,189,248,0.3); outline-offset:4px; }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"main\" aria-labelledby=\"title\">\n    <!-- LEFT: Info and Controls -->\n    <aside class=\"left\" aria-label=\"Controls and explanation\">\n      <div>\n        <div id=\"title\" class=\"title\">Bubble Sort — Visual & Interactive</div>\n        <div class=\"subtitle\">Step through comparisons and swaps to internalize how Bubble Sort works.</div>\n      </div>\n\n      <!-- Concept & Objectives -->\n      <div class=\"section\" aria-hidden=\"false\">\n        <h4>Concept Title</h4>\n        <p><strong>Bubble Sort</strong>: a simple comparison-based sorting algorithm that repeatedly passes through a list, compares adjacent items, and swaps them if they are in the wrong order.</p>\n\n        <h4>Learning Objective</h4>\n        <p>After interacting with this module you will be able to:\n          - identify when adjacent elements are compared,\n          - see how swaps move larger elements toward the end (the \"bubble\" effect),\n          - recognize how each pass reduces the unsorted portion until fully sorted.</p>\n      </div>\n\n      <!-- Interaction Design -->\n      <div class=\"section\" aria-hidden=\"false\">\n        <h4>Interaction Design</h4>\n        <p>\n          Controls:\n          - \"Shuffle\" generates a random array; \"Apply\" accepts a custom comma-separated array.\n          - Play/Pause auto-steps through frames; Next/Prev step one action.\n          - Speed slider controls playback delay.\n        </p>\n        <p>\n          Visual feedback:\n          - Compared pair is highlighted in yellow.\n          - Swapped pair flashes red and receives a small horizontal nudge to emphasize the exchange.\n          - Sorted items turn green and are fixed at the right side as passes complete.\n          - Counters for comparisons, swaps, and current pass update live.\n        </p>\n        <p>\n          Interaction modes:\n          - Click buttons, use keyboard: Space to Play/Pause, → Next step, ← Previous step.\n          - Accessible labels and clear color contrast are used; numbers are shown on bars for screen readers.\n        </p>\n      </div>\n\n      <!-- Controls -->\n      <div class=\"controls\" role=\"region\" aria-label=\"Controls\">\n        <div class=\"row\" style=\"align-items:center;\">\n          <input id=\"arrayInput\" type=\"text\" aria-label=\"Custom array input\" placeholder=\"e.g. 5,3,8,1,4\" />\n          <button id=\"applyBtn\" class=\"btn small primary\" aria-label=\"Apply custom array\">Apply</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"shuffleBtn\" class=\"btn ghost\" aria-label=\"Shuffle new random array\">Shuffle</button>\n          <button id=\"resetBtn\" class=\"btn\" aria-label=\"Reset visualization\">Reset</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"prevBtn\" class=\"btn small\" aria-label=\"Previous step\">◀ Prev</button>\n          <button id=\"playBtn\" class=\"btn small primary\" aria-label=\"Play or pause\">▶ Play</button>\n          <button id=\"nextBtn\" class=\"btn small\" aria-label=\"Next step\">Next ▶</button>\n        </div>\n\n        <div style=\"display:flex;flex-direction:column;gap:8px;\">\n          <label for=\"speed\" style=\"font-size:13px;color:var(--muted);\">Speed <span id=\"speedLabel\" style=\"color:#e6f5ff;font-weight:600;\">500ms</span></label>\n          <input id=\"speed\" type=\"range\" min=\"100\" max=\"1500\" value=\"500\" />\n        </div>\n\n        <div class=\"row\" style=\"align-items:center;\">\n          <div style=\"flex:1;\">\n            <label for=\"count\" style=\"font-size:13px;color:var(--muted);\">Array size</label>\n            <select id=\"count\" aria-label=\"Array size selector\" style=\"width:100%;\">\n              <option value=\"6\">6</option>\n              <option value=\"8\" selected>8</option>\n              <option value=\"10\">10</option>\n              <option value=\"14\">14</option>\n              <option value=\"18\">18</option>\n            </select>\n          </div>\n          <div style=\"width:120px;\">\n            <label style=\"font-size:13px;color:var(--muted);\">Order</label>\n            <select id=\"order\" aria-label=\"Sort order\" style=\"width:100%;\">\n              <option value=\"asc\" selected>Ascending</option>\n              <option value=\"desc\">Descending</option>\n            </select>\n          </div>\n        </div>\n      </div>\n\n      <!-- Stats -->\n      <div class=\"section\" aria-live=\"polite\">\n        <h4>Runtime & Progress</h4>\n        <div class=\"stats\">\n          <div class=\"stat\"><strong id=\"pass\">Pass 0</strong><span class=\"muted\">Current pass</span></div>\n          <div class=\"stat\"><strong id=\"compCount\">Comparisons: 0</strong></div>\n          <div class=\"stat\"><strong id=\"swapCount\">Swaps: 0</strong></div>\n          <div class=\"stat\"><strong id=\"frameIdx\">Step: 0</strong></div>\n        </div>\n        <p class=\"tips\" style=\"margin-top:8px;\">\n          Tip: Bubble Sort is stable and easy to visualize — it's excellent for learning, though not optimal for large arrays.\n        </p>\n      </div>\n\n      <div style=\"display:flex;gap:10px;\">\n        <button id=\"explainBtn\" class=\"btn\" aria-label=\"Show explanation\">Explain pass</button>\n        <button id=\"resetAllBtn\" class=\"btn ghost\" aria-label=\"Reset all settings\">Reset All</button>\n      </div>\n    </aside>\n\n    <!-- RIGHT: Visualization -->\n    <main class=\"right\" aria-label=\"Visualization and timeline\">\n      <div class=\"viz\" role=\"region\" aria-label=\"Bubble sort visualization\">\n        <div class=\"viz-header\">\n          <div style=\"display:flex;flex-direction:column;\">\n            <div style=\"font-size:14px;font-weight:600;color:#e6f5ff;\">Array Visualization</div>\n            <div style=\"font-size:12px;color:var(--muted);\">Compare (yellow) → Swap (red) → Sorted (green)</div>\n          </div>\n          <div class=\"legend\" aria-hidden=\"true\">\n            <div class=\"key\"><span class=\"swatch\" style=\"background:#f59e0b\"></span>Compare</div>\n            <div class=\"key\"><span class=\"swatch\" style=\"background:#ef4444\"></span>Swap</div>\n            <div class=\"key\"><span class=\"swatch\" style=\"background:#10b981\"></span>Sorted</div>\n          </div>\n        </div>\n\n        <div class=\"bars-wrap\" id=\"barsWrap\">\n          <div id=\"bars\" class=\"bars\" aria-hidden=\"false\" style=\"--bar-gap: 8px; --count: 8;\"></div>\n        </div>\n\n        <div style=\"display:flex;justify-content:space-between;align-items:center;gap:12px;\">\n          <div style=\"font-size:13px;color:var(--muted);\" id=\"statusText\">Ready</div>\n          <div style=\"font-size:13px;color:var(--muted);\">Keyboard: Space Play/Pause • ← / → Step</div>\n        </div>\n      </div>\n\n      <!-- Explanation / Timeline (collapsible) -->\n      <div class=\"section\">\n        <h4>How this visualization maps to Bubble Sort</h4>\n        <p>Each \"step\" is either a comparison between adjacent elements or a swap when they are out of order. A pass goes from the start to the end of the array and pushes the largest unsorted element to its correct position at the end. The sorted region grows from right to left.</p>\n        <p style=\"font-size:13px;color:var(--muted);margin-top:8px;\">\n          Use Next/Prev to step conceptually (one comparison or swap per step). Play will animate through the exact sequence of compare and swap actions recorded by the Bubble Sort algorithm.\n        </p>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    /**\n     * Bubble Sort Visualizer\n     * - Precomputes frames (snapshots) of array states and actions.\n     * - Provides Play/Pause, Next/Prev, Shuffle, Apply custom array.\n     * - Animations via CSS classes and transitions.\n     *\n     * Accessibility & responsive layout considerations included.\n     */\n\n    // Utility helpers\n    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }\n    function createRandomArray(n){\n      const arr = [];\n      for(let i=0;i<n;i++) arr.push(Math.floor(Math.random()*98) + 2); // 2..99\n      return arr;\n    }\n\n    // State\n    const state = {\n      array: [],\n      frames: [], // each frame: { arr:[], action: {type:'compare'|'swap'|'mark', i, j }, pass, comparisons, swaps }\n      frameIndex: 0,\n      playing: false,\n      timer: null,\n      speed: 500,\n      order: 'asc'\n    };\n\n    // DOM\n    const barsEl = document.getElementById('bars');\n    const barsWrap = document.getElementById('barsWrap');\n    const applyBtn = document.getElementById('applyBtn');\n    const shuffleBtn = document.getElementById('shuffleBtn');\n    const resetBtn = document.getElementById('resetBtn');\n    const prevBtn = document.getElementById('prevBtn');\n    const nextBtn = document.getElementById('nextBtn');\n    const playBtn = document.getElementById('playBtn');\n    const speedEl = document.getElementById('speed');\n    const speedLabel = document.getElementById('speedLabel');\n    const countEl = document.getElementById('count');\n    const orderEl = document.getElementById('order');\n    const arrayInput = document.getElementById('arrayInput');\n    const passEl = document.getElementById('pass');\n    const compCountEl = document.getElementById('compCount');\n    const swapCountEl = document.getElementById('swapCount');\n    const frameIdxEl = document.getElementById('frameIdx');\n    const statusText = document.getElementById('statusText');\n    const explainBtn = document.getElementById('explainBtn');\n    const resetAllBtn = document.getElementById('resetAllBtn');\n\n    // Initialize with default array\n    function init(){\n      const size = parseInt(countEl.value,10) || 8;\n      state.array = createRandomArray(size);\n      state.order = orderEl.value || 'asc';\n      buildFramesAndRender();\n      attachUI();\n      updateSpeedLabel();\n    }\n\n    // Build frames by running bubble sort and recording every compare/swap/mark\n    function buildFrames(arr, order='asc'){\n      const a = arr.slice();\n      const frames = [];\n      let comparisons = 0, swaps = 0;\n      const n = a.length;\n\n      // push initial frame\n      frames.push({\n        arr: a.slice(),\n        action: null,\n        pass: 0,\n        comparisons,\n        swaps,\n        sortedBoundary: n\n      });\n\n      for(let pass=1; pass<=n; pass++){\n        let swappedThisPass = false;\n        for(let i=0;i<n-pass;i++){\n          // compare frame\n          comparisons++;\n          frames.push({\n            arr: a.slice(),\n            action: { type:'compare', i:i, j:i+1 },\n            pass,\n            comparisons,\n            swaps,\n            sortedBoundary: n - (pass - 1)\n          });\n\n          const left = a[i], right = a[i+1];\n          const outOfOrder = (order==='asc') ? left > right : left < right;\n          if(outOfOrder){\n            // swap frame\n            [a[i], a[i+1]] = [a[i+1], a[i]];\n            swaps++;\n            swappedThisPass = true;\n            frames.push({\n              arr: a.slice(),\n              action: { type:'swap', i:i, j:i+1 },\n              pass,\n              comparisons,\n              swaps,\n              sortedBoundary: n - (pass - 1)\n            });\n          }\n        }\n        // After pass, mark the boundary (last element now sorted)\n        frames.push({\n          arr: a.slice(),\n          action: { type:'mark', index: n - pass },\n          pass,\n          comparisons,\n          swaps,\n          sortedBoundary: n - (pass - 1)\n        });\n        if(!swappedThisPass){\n          // already sorted early exit; mark remaining as sorted\n          for(let k = n-pass-1; k>=0; k--){\n            frames.push({\n              arr: a.slice(),\n              action: { type:'mark', index: k },\n              pass: pass,\n              comparisons,\n              swaps,\n              sortedBoundary: k\n            });\n          }\n          break;\n        }\n      }\n      // final frame to show completed\n      frames.push({\n        arr: a.slice(),\n        action: null,\n        pass: Math.ceil(n),\n        comparisons,\n        swaps,\n        sortedBoundary: 0\n      });\n      return frames;\n    }\n\n    // Render bars based on current frame\n    function renderFrame(index){\n      index = clamp(index, 0, state.frames.length - 1);\n      state.frameIndex = index;\n      const frame = state.frames[index];\n      const arr = frame.arr;\n      const count = arr.length;\n      barsEl.style.setProperty('--count', count.toString());\n      barsEl.style.setProperty('--bar-gap', '8px');\n\n      // If bars are not present or count changed, rebuild DOM\n      if(barsEl.children.length !== count){\n        barsEl.innerHTML = '';\n        for(let i=0;i<count;i++){\n          const b = document.createElement('div');\n          b.className = 'bar';\n          b.setAttribute('role','img');\n          b.setAttribute('aria-label', 'array element ' + i);\n          const label = document.createElement('div');\n          label.className = 'label';\n          b.appendChild(label);\n          barsEl.appendChild(b);\n        }\n      }\n\n      // update each bar's height/value\n      const maxVal = Math.max(...arr, 1);\n      const wrapHeight = barsWrap.clientHeight - 40; // some padding for labels\n      for(let i=0;i<count;i++){\n        const b = barsEl.children[i];\n        const val = arr[i];\n        const heightPct = (val / maxVal);\n        const px = Math.max(18, Math.round(wrapHeight * heightPct));\n        b.style.height = px + 'px';\n        b.querySelector('.label').textContent = val;\n        // reset classes\n        b.classList.remove('compare', 'swap', 'sorted', 'nudge-left', 'nudge-right');\n        b.style.zIndex = 1;\n      }\n\n      // apply action-based highlights & animations\n      if(frame.action){\n        if(frame.action.type === 'compare'){\n          const i = frame.action.i, j = frame.action.j;\n          barsEl.children[i].classList.add('compare');\n          barsEl.children[j].classList.add('compare');\n          statusText.textContent = `Comparing indices ${i} & ${j}`;\n        } else if(frame.action.type === 'swap'){\n          const i = frame.action.i, j = frame.action.j;\n          const bi = barsEl.children[i];\n          const bj = barsEl.children[j];\n          // apply swap styles\n          bi.classList.add('swap');\n          bj.classList.add('swap');\n          bi.style.zIndex = 3;\n          bj.style.zIndex = 3;\n          // nudge animation to emphasize the swap (left/right)\n          bi.classList.add('nudge-left');\n          bj.classList.add('nudge-right');\n          statusText.textContent = `Swapped indices ${i} & ${j}`;\n          // remove nudge classes after animation ends to avoid persistent animation\n          setTimeout(()=>{ bi.classList.remove('nudge-left'); bj.classList.remove('nudge-right'); }, 320);\n        } else if(frame.action.type === 'mark'){\n          const idx = frame.action.index;\n          if(idx >= 0 && idx < barsEl.children.length){\n            barsEl.children[idx].classList.add('sorted');\n          }\n          statusText.textContent = `Marked index ${idx} as sorted`;\n        }\n      } else {\n        statusText.textContent = 'Idle';\n      }\n\n      // Also mark sorted region based on sortedBoundary\n      const boundary = frame.sortedBoundary ?? 0;\n      for(let k=boundary; k<barsEl.children.length; k++){\n        barsEl.children[k].classList.add('sorted');\n      }\n\n      // Update stats\n      passEl.textContent = 'Pass ' + (frame.pass || 0);\n      compCountEl.textContent = 'Comparisons: ' + (frame.comparisons || 0);\n      swapCountEl.textContent = 'Swaps: ' + (frame.swaps || 0);\n      frameIdxEl.textContent = 'Step: ' + index + ' / ' + (state.frames.length-1);\n    }\n\n    // Build frames using current state.array and order, then render first frame\n    function buildFramesAndRender(){\n      state.frames = buildFrames(state.array, state.order);\n      state.frameIndex = 0;\n      renderFrame(0);\n    }\n\n    // Playback controls\n    function play(){\n      if(state.playing) return;\n      state.playing = true;\n      playBtn.textContent = '⏸ Pause';\n      scheduleNext();\n    }\n    function pause(){\n      state.playing = false;\n      playBtn.textContent = '▶ Play';\n      if(state.timer){ clearTimeout(state.timer); state.timer = null; }\n    }\n    function togglePlay(){\n      if(state.playing) pause(); else play();\n    }\n    function scheduleNext(){\n      if(!state.playing) return;\n      state.timer = setTimeout(()=>{\n        nextStep();\n        if(state.frameIndex >= state.frames.length -1){\n          pause();\n        } else {\n          scheduleNext();\n        }\n      }, state.speed);\n    }\n\n    function nextStep(){\n      const next = clamp(state.frameIndex + 1, 0, state.frames.length - 1);\n      state.frameIndex = next;\n      renderFrame(next);\n    }\n    function prevStep(){\n      const prev = clamp(state.frameIndex - 1, 0, state.frames.length - 1);\n      state.frameIndex = prev;\n      renderFrame(prev);\n    }\n\n    // UI wiring\n    function attachUI(){\n      // Shuffle\n      shuffleBtn.onclick = ()=>{\n        const size = clamp(parseInt(countEl.value,10) || 8, 2, 20);\n        state.array = createRandomArray(size);\n        state.order = orderEl.value || 'asc';\n        buildFramesAndRender();\n        pause();\n      };\n\n      // Apply custom array\n      applyBtn.onclick = ()=> applyCustomArray();\n      arrayInput.addEventListener('keyup', (e)=>{ if(e.key === 'Enter') applyCustomArray(); });\n\n      // Reset (back to initial frame)\n      resetBtn.onclick = ()=>{\n        state.frameIndex = 0;\n        renderFrame(0);\n        pause();\n      };\n\n      // Reset all (shuffle + settings)\n      resetAllBtn.onclick = ()=>{\n        countEl.value = '8';\n        orderEl.value = 'asc';\n        arrayInput.value = '';\n        init();\n        pause();\n      };\n\n      // Step controls\n      nextBtn.onclick = ()=>{ nextStep(); pause(); };\n      prevBtn.onclick = ()=>{ prevStep(); pause(); };\n      playBtn.onclick = ()=> togglePlay();\n\n      // Speed\n      speedEl.oninput = (e)=>{\n        state.speed = parseInt(e.target.value,10) || 500;\n        updateSpeedLabel();\n      };\n\n      // Count / order change\n      countEl.onchange = ()=>{\n        const size = clamp(parseInt(countEl.value,10) || 8, 2, 20);\n        state.array = createRandomArray(size);\n        buildFramesAndRender();\n        pause();\n      };\n      orderEl.onchange = ()=>{\n        state.order = orderEl.value;\n        buildFramesAndRender();\n        pause();\n      };\n\n      // Keyboard shortcuts\n      window.addEventListener('keydown', (e)=>{\n        const tag = document.activeElement.tagName.toLowerCase();\n        if(tag === 'input' || tag === 'textarea') return; // don't override typing\n        if(e.code === 'Space'){\n          e.preventDefault();\n          togglePlay();\n        } else if(e.code === 'ArrowRight'){\n          e.preventDefault();\n          nextStep(); pause();\n        } else if(e.code === 'ArrowLeft'){\n          e.preventDefault();\n          prevStep(); pause();\n        }\n      });\n\n      explainBtn.onclick = ()=> alert('Bubble Sort passes repeatedly compare adjacent elements and swap them when out of order. After each full pass, the largest unsorted item settles at the right. Continue until no swaps occur in a pass.');\n\n    }\n\n    function applyCustomArray(){\n      const raw = arrayInput.value.trim();\n      if(!raw) { alert('Enter a comma-separated list like: 5,3,8,1,4'); return; }\n      const parts = raw.split(',').map(s=>s.trim()).filter(s=>s.length>0);\n      if(parts.length === 0){ alert('No values detected.'); return; }\n      if(parts.length > 20){ alert('Please enter 20 values or fewer.'); return; }\n      const nums = [];\n      for(const p of parts){\n        const v = Number(p);\n        if(Number.isNaN(v)){ alert('Invalid number: ' + p); return; }\n        nums.push(Math.round(v));\n      }\n      state.array = nums;\n      // update UI count if possible\n      countEl.value = String(Math.min(Math.max(nums.length,2),20));\n      buildFramesAndRender();\n      pause();\n    }\n\n    function updateSpeedLabel(){\n      speedLabel.textContent = state.speed + 'ms';\n    }\n\n    // Initialize on load\n    init();\n\n    // Ensure initial frame sizing once images/fonts load\n    window.addEventListener('resize', ()=> renderFrame(state.frameIndex));\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Bubble Sort.\n\n**Project Overview:**\nTopic: Bubble Sort\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Bubble Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "eed25e90-bde5-11f0-95af-4764f61ee009",
    "timestamp": "2025-11-10T03:32:50.042Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Heap (Min/Max)",
    "answer": {
      "role": "assistant",
      "content": "Below is a single-file, self-contained HTML page that teaches and demonstrates Min/ and Max-Heap behavior. It contains:\n\n- Concept Title, Learning Objective, Interaction Design, and Layout Description sections (as part of the interface).\n- An interactive visualization of a heap (binary-tree + array view).\n- Controls to Insert numbers, Extract root, Toggle Min/Max behavior, Randomize, Build from an array, and Step-by-step animation with narration.\n- Animated bubble-up and bubble-down operations with clear visual feedback (highlighting comparisons, swaps, and narration).\n- Accessibility considerations and responsive layout with the specified safe area (24px) and element spacing (min 16px).\n\nCopy the entire content into a file (e.g., heap-demo.html) and open it in a modern browser.\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Heap (Min / Max) Interactive Module</title>\n  <style>\n    :root{\n      --safe-pad:24px;\n      --gap:16px;\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#2dd4bf;\n      --muted:#94a3b8;\n      --success:#34d399;\n      --danger:#fb7185;\n      --surface:#071026;\n      --font-sans: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      --node-size:48px;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background:linear-gradient(180deg,#071029 0%, #031027 100%);\n      color:#e6eef6;\n      font-family:var(--font-sans);\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app{\n      box-sizing:border-box;\n      padding:var(--safe-pad);\n      min-height:100%;\n      display:flex;\n      gap:var(--gap);\n      align-items:stretch;\n    }\n\n    /* Layout columns */\n    .sidebar{\n      width:360px;\n      min-width:260px;\n      max-width:420px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      border-radius:12px;\n      padding:20px;\n      box-shadow: 0 6px 20px rgba(0,0,0,0.5);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .main{\n      flex:1;\n      min-width:0;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      border-radius:12px;\n      padding:20px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      box-shadow: 0 6px 20px rgba(0,0,0,0.45);\n    }\n\n    /* Info sections */\n    .title{\n      font-size:20px;\n      font-weight:700;\n      display:flex;\n      gap:8px;\n      align-items:baseline;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n    }\n    .card{\n      background:rgba(255,255,255,0.01);\n      border-radius:8px;\n      padding:12px;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n\n    /* Controls */\n    .controls{\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .row{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    input[type=\"number\"], input[type=\"text\"]{\n      appearance:none;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background:rgba(255,255,255,0.02);\n      color:inherit;\n      padding:10px 12px;\n      font-size:14px;\n      min-width:0;\n    }\n    button{\n      border:0;\n      background:var(--accent);\n      color:#002022;\n      padding:10px 14px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      transition:transform .08s ease, box-shadow .12s ease;\n    }\n    button.secondary{\n      background:transparent;\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.04);\n    }\n    button:active{ transform:translateY(1px) }\n    .toggle{\n      display:inline-flex;\n      gap:8px;\n      align-items:center;\n    }\n    .switch{\n      width:52px;\n      height:28px;\n      background:rgba(255,255,255,0.06);\n      border-radius:20px;\n      padding:4px;\n      display:inline-flex;\n      align-items:center;\n      cursor:pointer;\n      position:relative;\n    }\n    .switch .knob{\n      width:20px;height:20px;border-radius:50%;background:white;\n      transition:transform .18s cubic-bezier(.2,.9,.2,1);\n      transform:translateX(0);\n    }\n    .switch.on{ background:linear-gradient(90deg,var(--success),#10b981); }\n    .switch.on .knob{ transform:translateX(24px); }\n\n    .small{\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Visualization */\n    .viz{\n      flex:1;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .canvas{\n      position:relative;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:10px;\n      border:1px solid rgba(255,255,255,0.02);\n      height:420px;\n      overflow:hidden;\n      padding:12px;\n    }\n    .tree-area{\n      position:relative;\n      width:100%;\n      height:320px;\n      user-select:none;\n    }\n    /* nodes (absolute positioned) */\n    .node{\n      position:absolute;\n      width:var(--node-size);\n      height:var(--node-size);\n      border-radius:50%;\n      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      border:2px solid rgba(255,255,255,0.06);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      font-weight:700;\n      transition: left 420ms cubic-bezier(.2,.9,.2,1), top 420ms cubic-bezier(.2,.9,.2,1), transform 180ms ease, background 220ms;\n      box-shadow: 0 8px 18px rgba(2,6,23,0.6);\n      font-size:14px;\n      color:#e6f6f4;\n    }\n    .node.min{ background:linear-gradient(180deg,#042b24,#06302a); border-color:rgba(45,212,191,0.18) }\n    .node.max{ background:linear-gradient(180deg,#2c0520,#300622); border-color:rgba(251,113,133,0.18) }\n    .node.compare{ transform:scale(1.12); box-shadow:0 12px 30px rgba(0,0,0,0.6); }\n    .node.swap{ outline:3px solid rgba(255,255,255,0.06); transform:scale(1.08) rotate(3deg); }\n\n    /* connectors use SVG lines */\n    .connectors{ position:absolute; inset:0; pointer-events:none; }\n\n    /* array view */\n    .array{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      padding:8px;\n      overflow:auto;\n      border-radius:8px;\n      background:rgba(0,0,0,0.14);\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .arr-item{\n      min-width:48px;height:48px;border-radius:8px;background:rgba(255,255,255,0.02);\n      display:flex;align-items:center;justify-content:center;font-weight:700;\n      border:1px solid rgba(255,255,255,0.04);\n      color:#dff8f4;\n    }\n    .arr-index{ font-size:12px;color:var(--muted); text-align:center;margin-top:6px; }\n\n    /* narration / step log */\n    .narration{\n      min-height:36px;\n      font-size:14px;\n      color:var(--muted);\n      padding:8px;\n      border-radius:8px;\n      background:rgba(255,255,255,0.01);\n      border:1px solid rgba(255,255,255,0.02);\n    }\n\n    /* responsive */\n    @media (max-width:980px){\n      .app{ flex-direction:column; padding:16px; }\n      .sidebar{ width:100%; max-width:none; }\n      .main{ width:100% }\n    }\n    /* spacing for controls: ensure min spacing 16px between interactive elements */\n    .controls > *{ margin-bottom:0; }\n    .gap-16{ gap:16px; }\n    /* accessibility focus states */\n    button:focus, input:focus, .switch:focus{\n      outline:3px solid rgba(45,212,191,0.12);\n      outline-offset:2px;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"main\" aria-labelledby=\"title\">\n    <aside class=\"sidebar\" aria-label=\"Information and Controls\">\n      <div>\n        <div class=\"title\" id=\"title\">\n          Heap (Min / Max) — Interactive\n        </div>\n        <div class=\"muted small\" style=\"margin-top:6px\">Binary Heap visualized as tree + array. Animated bubble-up / bubble-down.</div>\n      </div>\n\n      <div class=\"card\" aria-hidden=\"false\">\n        <div style=\"font-weight:700\">Learning Objective</div>\n        <div class=\"small muted\" style=\"margin-top:6px\">\n          Understand how insert and extract operations maintain the heap property for Min-Heap and Max-Heap. Observe comparisons and swaps (bubble-up / bubble-down) both in the tree and the array representation.\n        </div>\n      </div>\n\n      <div class=\"card\">\n        <div style=\"font-weight:700; margin-bottom:8px\">Interaction Design</div>\n        <div class=\"small muted\">\n          - Insert a number: type a value and press Insert (or Enter). Watch the new node animate into place, compare with parent nodes, and bubble up as needed.<br>\n          - Extract root: removes the root (min or max depending on mode). Watch the last node move to the root and bubble-down with comparisons and swaps. <br>\n          - Toggle Min/Max: switch behavior instantly; heap will re-heapify if you press \"Build from array\" or randomize. <br>\n          - Use Step mode to advance bubble steps manually and follow narration. <br>\n          Animations highlight comparisons (yellowish), swaps (green), and final settled nodes (subtle color).\n        </div>\n      </div>\n\n      <div class=\"card controls\" aria-label=\"Heap Controls\">\n        <div style=\"font-weight:700; margin-bottom:6px\">Controls</div>\n        <div class=\"row\" style=\"align-items:center\">\n          <input id=\"inputValue\" type=\"number\" placeholder=\"Number\" aria-label=\"Value to insert\" />\n          <button id=\"btnInsert\" title=\"Insert value\">Insert</button>\n          <button id=\"btnExtract\" class=\"secondary\" title=\"Extract root\">Extract Root</button>\n        </div>\n\n        <div class=\"row\">\n          <div class=\"toggle small\">\n            <div id=\"modeSwitch\" class=\"switch on\" role=\"switch\" tabindex=\"0\" aria-checked=\"true\" aria-label=\"Toggle Min or Max heap\">\n              <div class=\"knob\" aria-hidden=\"true\"></div>\n            </div>\n            <div class=\"small\" id=\"modeLabel\">Mode: Min-Heap</div>\n          </div>\n          <div style=\"margin-left:auto\" class=\"small muted\">Heap size: <span id=\"heapSize\">0</span></div>\n        </div>\n\n        <div class=\"row\" style=\"align-items:center\">\n          <button id=\"btnRandom\" class=\"secondary\">Randomize</button>\n          <button id=\"btnClear\" class=\"secondary\">Clear</button>\n          <button id=\"btnBuild\" class=\"secondary\">Build from array</button>\n        </div>\n\n        <div class=\"row\">\n          <input type=\"text\" id=\"arrayInput\" placeholder=\"e.g. 5,3,8,1\" aria-label=\"Comma separated array\" />\n        </div>\n\n        <div class=\"row\" style=\"align-items:center\">\n          <button id=\"btnStep\" class=\"secondary\">Step</button>\n          <button id=\"btnAuto\" class=\"secondary\">Auto Run</button>\n          <div style=\"margin-left:auto\" class=\"small muted\">Speed:\n            <input id=\"speed\" type=\"range\" min=\"100\" max=\"1200\" step=\"50\" value=\"420\" aria-label=\"Animation speed\" />\n          </div>\n        </div>\n\n        <div class=\"narration\" id=\"narration\" aria-live=\"polite\">Ready. Insert numbers to begin.</div>\n      </div>\n\n      <div class=\"card small muted\" style=\"font-size:12px\">\n        Layout details: Safe area margins are 24px. Minimum spacing between controls is 16px. Responsive: on narrow screens controls stack above visualization.\n      </div>\n    </aside>\n\n    <main class=\"main\" aria-label=\"Visualization Area\">\n      <div class=\"viz\">\n        <div style=\"display:flex;align-items:center;gap:12px;justify-content:space-between\">\n          <div style=\"font-weight:700\">Heap Visualization</div>\n          <div class=\"small muted\">Tree + Array view — nodes animated on swap / compare</div>\n        </div>\n\n        <div class=\"canvas\" id=\"canvas\" role=\"region\" aria-label=\"Heap tree visualization\">\n          <div class=\"tree-area\" id=\"treeArea\"></div>\n          <svg class=\"connectors\" id=\"connectors\" preserveAspectRatio=\"none\"></svg>\n        </div>\n\n        <div>\n          <div style=\"font-weight:700; margin-bottom:8px\">Array representation</div>\n          <div class=\"array\" id=\"arrayView\" role=\"list\" aria-label=\"Heap array view\"></div>\n        </div>\n      </div>\n    </main>\n  </div>\n\n  <script>\n    /* Heap Interactive Module - Vanilla JS\n       Features:\n       - Min/Max toggle\n       - Insert with animated bubble-up\n       - Extract root with animated bubble-down\n       - Randomize, Clear, Build from array\n       - Step mode and Auto Run\n       - Tree layout + SVG connectors\n    */\n\n    // Utility\n    const sleep = ms => new Promise(r => setTimeout(r, ms));\n\n    // DOM references\n    const inputValue = document.getElementById('inputValue');\n    const btnInsert = document.getElementById('btnInsert');\n    const btnExtract = document.getElementById('btnExtract');\n    const modeSwitch = document.getElementById('modeSwitch');\n    const modeLabel = document.getElementById('modeLabel');\n    const heapSizeEl = document.getElementById('heapSize');\n    const treeArea = document.getElementById('treeArea');\n    const connectors = document.getElementById('connectors');\n    const arrayView = document.getElementById('arrayView');\n    const narration = document.getElementById('narration');\n    const btnRandom = document.getElementById('btnRandom');\n    const btnClear = document.getElementById('btnClear');\n    const arrayInput = document.getElementById('arrayInput');\n    const btnBuild = document.getElementById('btnBuild');\n    const btnStep = document.getElementById('btnStep');\n    const btnAuto = document.getElementById('btnAuto');\n    const speedControl = document.getElementById('speed');\n\n    // State\n    let heap = []; // array of numbers\n    let isMin = true; // mode\n    let nodes = []; // DOM node elements\n    let running = false; // when an operation is animating\n    let stepMode = false;\n    let autoRun = false;\n    let stepQueue = []; // queued generator steps\n\n    // Accessibility / initial\n    updateModeUI();\n\n    // Helpers - comparator\n    function cmp(a,b){\n      return isMin ? a - b : b - a; // positive if a should be below b (a > b in min-heap)\n    }\n\n    // Layout math: compute positions for each node index\n    function layoutPositions(width, height, n) {\n      if (n === 0) return [];\n      const positions = [];\n      const maxLevel = Math.floor(Math.log2(Math.max(1,n)));\n      const levelHeight = (height) / (maxLevel + 2);\n      for (let i=0;i<n;i++){\n        const level = Math.floor(Math.log2(i+1));\n        const indexInLevel = i - (1<<level) + 1;\n        const nodesInLevel = 1<<level;\n        const x = Math.round(((indexInLevel + 1) / (nodesInLevel + 1)) * width);\n        const y = Math.round((level + 1) * levelHeight);\n        positions.push({x,y,level});\n      }\n      return positions;\n    }\n\n    // Render functions\n    function renderAll(immediate = false){\n      const w = treeArea.clientWidth;\n      const h = treeArea.clientHeight;\n      const positions = layoutPositions(w, h, heap.length);\n      // Update nodes array to match heap length\n      while (nodes.length < heap.length){\n        const el = document.createElement('div');\n        el.className = 'node';\n        el.setAttribute('role','img');\n        el.setAttribute('aria-label','heap node');\n        el.style.left = '0px';\n        el.style.top = '0px';\n        el.style.width = getComputedStyle(document.documentElement).getPropertyValue('--node-size') || '48px';\n        treeArea.appendChild(el);\n        nodes.push(el);\n      }\n      while (nodes.length > heap.length){\n        const el = nodes.pop();\n        if (el.parentElement) el.parentElement.removeChild(el);\n      }\n      // assign classes and content\n      nodes.forEach((el,i)=>{\n        el.textContent = String(heap[i]);\n        el.classList.toggle('min', isMin);\n        el.classList.toggle('max', !isMin);\n        el.dataset.index = i;\n      });\n\n      // Position nodes\n      nodes.forEach((el,i)=>{\n        const p = positions[i] || {x:0,y:0};\n        // center by subtracting half width/height\n        const size = el.getBoundingClientRect();\n        const nodeW = size.width || parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--node-size')) || 48;\n        const nodeH = size.height || nodeW;\n        const left = Math.max(8, p.x - nodeW/2);\n        const top = Math.max(8, p.y - nodeH/2);\n        if (immediate){\n          el.style.transition = 'none';\n          el.style.left = left + 'px';\n          el.style.top = top + 'px';\n          // force reflow\n          void el.offsetWidth;\n          el.style.transition = '';\n        } else {\n          el.style.left = left + 'px';\n          el.style.top = top + 'px';\n        }\n      });\n\n      // Render connectors using SVG lines\n      connectors.setAttribute('width', treeArea.clientWidth);\n      connectors.setAttribute('height', treeArea.clientHeight);\n      connectors.innerHTML = '';\n      for (let i=0;i<heap.length;i++){\n        const leftChild = 2*i + 1;\n        const rightChild = 2*i + 2;\n        const p = positions[i];\n        if (!p) continue;\n        const cx = p.x;\n        const cy = p.y;\n        [leftChild, rightChild].forEach(child=>{\n          if (child < heap.length){\n            const cp = positions[child];\n            const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n            line.setAttribute('x1', cx);\n            line.setAttribute('y1', cy + 22);\n            line.setAttribute('x2', cp.x);\n            line.setAttribute('y2', cp.y - 18);\n            line.setAttribute('stroke', 'rgba(255,255,255,0.04)');\n            line.setAttribute('stroke-width', '2');\n            line.setAttribute('stroke-linecap','round');\n            connectors.appendChild(line);\n          }\n        });\n      }\n\n      // Update array view\n      arrayView.innerHTML = '';\n      heap.forEach((v,i)=>{\n        const el = document.createElement('div');\n        el.className = 'arr-item';\n        el.setAttribute('role','listitem');\n        el.textContent = v;\n        const idx = document.createElement('div');\n        idx.className = 'arr-index';\n        idx.textContent = i;\n        const wrap = document.createElement('div');\n        wrap.style.textAlign = 'center';\n        wrap.appendChild(el);\n        wrap.appendChild(idx);\n        arrayView.appendChild(wrap);\n      });\n\n      heapSizeEl.textContent = heap.length;\n    }\n\n    // swap elements in array and reflect visually (no animation control here)\n    function swap(i,j){\n      const tmp = heap[i]; heap[i] = heap[j]; heap[j] = tmp;\n    }\n\n    // Narration helper\n    function narrate(msg){\n      narration.textContent = msg;\n    }\n\n    // Operation Animations (async to allow step-by-step)\n    async function animateInsert(value){\n      if (running) return;\n      running = true;\n      try {\n        narrate(`Inserting ${value}...`);\n        // Append value\n        heap.push(value);\n        renderAll(true);\n        await sleep(80);\n\n        // Bubble-up algorithm with animations\n        let i = heap.length - 1;\n        nodes[i].classList.add('compare');\n        await sleep(200);\n        while (i > 0){\n          const parent = Math.floor((i-1)/2);\n          nodes[parent].classList.add('compare');\n          narrate(`Compare node ${heap[i]} with parent ${heap[parent]}`);\n          await sleep(getSpeed());\n          // highlight comparison\n          if (cmp(heap[i], heap[parent]) < 0){\n            // child should go up: swap\n            narrate(`Swap ${heap[i]} ↔ ${heap[parent]}`);\n            nodes[i].classList.add('swap');\n            nodes[parent].classList.add('swap');\n            swap(i,parent);\n            renderAll();\n            await sleep(getSpeed());\n            nodes[i].classList.remove('swap','compare');\n            nodes[parent].classList.remove('swap','compare');\n            i = parent;\n            nodes[i].classList.add('compare');\n            if (stepMode){\n              narrate(`Paused after swap. Press Step to continue.`);\n              running = false;\n              return enqueueStep(async ()=> await animateInsertResume(i));\n            }\n          } else {\n            narrate(`No swap needed. Insert finished.`);\n            nodes[i].classList.remove('compare');\n            nodes[parent].classList.remove('compare');\n            break;\n          }\n        }\n        narrate(`Insert complete.`);\n      } finally {\n        running = false;\n        renderAll();\n      }\n\n      async function animateInsertResume(currentIndex){\n        running = true;\n        let i = currentIndex;\n        while (i > 0){\n          const parent = Math.floor((i-1)/2);\n          nodes[parent].classList.add('compare');\n          narrate(`Compare node ${heap[i]} with parent ${heap[parent]}`);\n          await sleep(getSpeed());\n          if (cmp(heap[i], heap[parent]) < 0){\n            narrate(`Swap ${heap[i]} ↔ ${heap[parent]}`);\n            nodes[i].classList.add('swap');\n            nodes[parent].classList.add('swap');\n            swap(i,parent);\n            renderAll();\n            await sleep(getSpeed());\n            nodes[i].classList.remove('swap','compare');\n            nodes[parent].classList.remove('swap','compare');\n            i = parent;\n            nodes[i].classList.add('compare');\n            if (stepMode){\n              narrate(`Paused after swap. Press Step to continue.`);\n              running = false;\n              return enqueueStep(async ()=> await animateInsertResume(i));\n            }\n          } else {\n            narrate(`No swap needed. Insert finished.`);\n            nodes[i].classList.remove('compare');\n            nodes[parent].classList.remove('compare');\n            break;\n          }\n        }\n        narrate(`Insert complete.`);\n        running = false;\n      }\n    }\n\n    function enqueueStep(fn){\n      stepQueue.push(fn);\n      // if autoRun active, run them\n      if (autoRun) runStepQueue();\n    }\n\n    async function runStepQueue(){\n      if (running) return;\n      while (stepQueue.length > 0){\n        const fn = stepQueue.shift();\n        await fn();\n      }\n    }\n\n    async function animateExtract(){\n      if (running || heap.length === 0) return;\n      running = true;\n      try {\n        narrate(`Extracting root (${heap[0]})...`);\n        if (heap.length === 1){\n          heap.pop();\n          renderAll();\n          narrate(`Heap is now empty.`);\n          return;\n        }\n        // swap root and last, remove last\n        const lastIdx = heap.length - 1;\n        nodes[0].classList.add('swap');\n        nodes[lastIdx].classList.add('swap');\n        narrate(`Swap root ${heap[0]} with last ${heap[lastIdx]}`);\n        swap(0,lastIdx);\n        renderAll();\n        await sleep(getSpeed());\n        nodes[0].classList.remove('swap');\n        nodes[lastIdx].classList.remove('swap');\n        // remove last element (which was root)\n        const removed = heap.pop();\n        renderAll(true);\n        narrate(`Removed ${removed}. Bubble-down new root ${heap[0]}.`);\n        await sleep(240);\n\n        // bubble-down\n        let i = 0;\n        while (true){\n          const left = 2*i + 1;\n          const right = 2*i + 2;\n          let best = i;\n          if (left < heap.length){\n            nodes[left].classList.add('compare');\n            nodes[i].classList.add('compare');\n            narrate(`Compare root ${heap[i]} with left child ${heap[left]}`);\n            await sleep(getSpeed());\n            if (cmp(heap[left], heap[best]) < 0) best = left;\n            nodes[left].classList.remove('compare');\n            nodes[i].classList.remove('compare');\n          }\n          if (right < heap.length){\n            nodes[right].classList.add('compare');\n            nodes[best].classList.add('compare');\n            narrate(`Compare candidate ${heap[best]} with right child ${heap[right]}`);\n            await sleep(getSpeed());\n            if (cmp(heap[right], heap[best]) < 0) best = right;\n            nodes[right].classList.remove('compare');\n            nodes[best].classList.remove('compare');\n          }\n          if (best !== i){\n            narrate(`Swap ${heap[i]} ↔ ${heap[best]}`);\n            nodes[i].classList.add('swap');\n            nodes[best].classList.add('swap');\n            swap(i,best);\n            renderAll();\n            await sleep(getSpeed());\n            nodes[i].classList.remove('swap');\n            nodes[best].classList.remove('swap');\n            i = best;\n            if (stepMode){\n              narrate(`Paused after swap. Press Step to continue.`);\n              running = false;\n              return enqueueStep(async ()=> await animateExtractResume(i));\n            }\n          } else {\n            narrate(`Bubble-down complete.`);\n            break;\n          }\n        }\n      } finally {\n        running = false;\n        renderAll();\n      }\n\n      async function animateExtractResume(startIndex){\n        running = true;\n        let i = startIndex;\n        while (true){\n          const left = 2*i + 1;\n          const right = 2*i + 2;\n          let best = i;\n          if (left < heap.length){\n            nodes[left].classList.add('compare');\n            nodes[i].classList.add('compare');\n            narrate(`Compare root ${heap[i]} with left child ${heap[left]}`);\n            await sleep(getSpeed());\n            if (cmp(heap[left], heap[best]) < 0) best = left;\n            nodes[left].classList.remove('compare');\n            nodes[i].classList.remove('compare');\n          }\n          if (right < heap.length){\n            nodes[right].classList.add('compare');\n            nodes[best].classList.add('compare');\n            narrate(`Compare candidate ${heap[best]} with right child ${heap[right]}`);\n            await sleep(getSpeed());\n            if (cmp(heap[right], heap[best]) < 0) best = right;\n            nodes[right].classList.remove('compare');\n            nodes[best].classList.remove('compare');\n          }\n          if (best !== i){\n            narrate(`Swap ${heap[i]} ↔ ${heap[best]}`);\n            nodes[i].classList.add('swap');\n            nodes[best].classList.add('swap');\n            swap(i,best);\n            renderAll();\n            await sleep(getSpeed());\n            nodes[i].classList.remove('swap');\n            nodes[best].classList.remove('swap');\n            i = best;\n            if (stepMode){\n              narrate(`Paused after swap. Press Step to continue.`);\n              running = false;\n              return enqueueStep(async ()=> await animateExtractResume(i));\n            }\n          } else {\n            narrate(`Bubble-down complete.`);\n            break;\n          }\n        }\n        running = false;\n        renderAll();\n      }\n    }\n\n    // Simple heapify build (bottom-up) with animation (optional)\n    async function buildFromArray(arr){\n      if (running) return;\n      running = true;\n      try {\n        heap = arr.slice();\n        renderAll(true);\n        narrate('Building heap (bottom-up)...');\n        await sleep(200);\n        const n = heap.length;\n        for (let i = Math.floor(n/2) - 1; i >= 0; i--){\n          await heapifyStep(i);\n          if (stepMode){\n            narrate('Paused during build. Press Step to continue.');\n            running = false;\n            return enqueueStep(async ()=> await buildFromArrayResume(i-1));\n          }\n        }\n        narrate('Build complete.');\n      } finally {\n        running = false;\n        renderAll();\n      }\n\n      async function buildFromArrayResume(startIdx){\n        running = true;\n        let i;\n        for (i = startIdx; i >=0; i--){\n          await heapifyStep(i);\n          if (stepMode){\n            narrate('Paused during build. Press Step to continue.');\n            running = false;\n            return enqueueStep(async ()=> await buildFromArrayResume(i-1));\n          }\n        }\n        narrate('Build complete.');\n        running = false;\n      }\n\n      async function heapifyStep(i){\n        let largest = i;\n        while (true){\n          const left = 2*i +1;\n          const right = 2*i +2;\n          let best = i;\n          if (left < heap.length){\n            nodes[left].classList.add('compare');\n            nodes[best].classList.add('compare');\n            narrate(`Compare ${heap[best]} with left ${heap[left]}`);\n            await sleep(getSpeed());\n            if (cmp(heap[left], heap[best]) < 0) best = left;\n            nodes[left].classList.remove('compare');\n            nodes[best].classList.remove('compare');\n          }\n          if (right < heap.length){\n            nodes[right].classList.add('compare');\n            nodes[best].classList.add('compare');\n            narrate(`Compare ${heap[best]} with right ${heap[right]}`);\n            await sleep(getSpeed());\n            if (cmp(heap[right], heap[best]) < 0) best = right;\n            nodes[right].classList.remove('compare');\n            nodes[best].classList.remove('compare');\n          }\n          if (best !== i){\n            narrate(`Swap ${heap[i]} ↔ ${heap[best]}`);\n            nodes[i].classList.add('swap');\n            nodes[best].classList.add('swap');\n            swap(i,best);\n            renderAll();\n            await sleep(getSpeed());\n            nodes[i].classList.remove('swap');\n            nodes[best].classList.remove('swap');\n            i = best;\n            if (stepMode){\n              narrate('Paused after swap. Press Step to continue.');\n              return;\n            }\n            // continue sifting\n          } else {\n            break;\n          }\n        }\n      }\n    }\n\n    // UI bindings\n    btnInsert.addEventListener('click', ()=>{\n      const v = parseFloat(inputValue.value);\n      if (!isFinite(v)) { narrate('Enter a valid number to insert.'); inputValue.focus(); return; }\n      inputValue.value = '';\n      animateInsert(v);\n    });\n    inputValue.addEventListener('keydown',(e)=>{\n      if (e.key === 'Enter'){ btnInsert.click(); }\n    });\n\n    btnExtract.addEventListener('click', ()=>{\n      if (heap.length === 0) { narrate('Heap is empty.'); return; }\n      animateExtract();\n    });\n\n    modeSwitch.addEventListener('click', toggleMode);\n    modeSwitch.addEventListener('keydown',(e)=>{ if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleMode(); } });\n\n    function toggleMode(){\n      if (running) { narrate('Wait for current animation to finish before toggling mode.'); return; }\n      isMin = !isMin;\n      updateModeUI();\n      renderAll(true);\n      narrate(`Switched to ${isMin ? 'Min-Heap' : 'Max-Heap'}. Press Build from array to re-heapify existing values.`);\n    }\n\n    function updateModeUI(){\n      modeSwitch.classList.toggle('on', isMin);\n      modeLabel.textContent = 'Mode: ' + (isMin ? 'Min-Heap' : 'Max-Heap');\n      modeSwitch.setAttribute('aria-checked', String(isMin));\n    }\n\n    btnRandom.addEventListener('click', ()=>{\n      if (running) return;\n      const count = Math.floor(Math.random()*6)+3;\n      heap = Array.from({length:count}, ()=> Math.floor(Math.random()*90)+1);\n      renderAll(true);\n      narrate('Random array generated. Press Build from array to heapify or start inserting.');\n    });\n\n    btnClear.addEventListener('click', ()=>{\n      if (running) return;\n      heap = [];\n      renderAll(true);\n      narrate('Heap cleared.');\n    });\n\n    btnBuild.addEventListener('click', ()=>{\n      if (running) return;\n      // parse array input\n      const txt = arrayInput.value.trim();\n      if (txt){\n        const parts = txt.split(',').map(s=>parseFloat(s.trim())).filter(x=>isFinite(x));\n        if (parts.length === 0){\n          narrate('No valid numbers found in array input.');\n          return;\n        }\n        buildFromArray(parts);\n      } else {\n        // build from current heap array\n        buildFromArray(heap.slice());\n      }\n    });\n\n    // Step / Auto\n    btnStep.addEventListener('click', async ()=>{\n      stepMode = true;\n      if (stepQueue.length > 0 && !running){\n        await runStepQueue();\n      } else {\n        narrate('Step mode enabled. Trigger operations (Insert/Extract/Build) to produce steps.');\n      }\n    });\n\n    btnAuto.addEventListener('click', ()=>{\n      autoRun = !autoRun;\n      btnAuto.classList.toggle('secondary', !autoRun);\n      btnAuto.textContent = autoRun ? 'Auto Run: On' : 'Auto Run';\n      if (autoRun) runStepQueue();\n    });\n\n    speedControl.addEventListener('input', ()=>{ /* speed read by getSpeed() */ });\n\n    function getSpeed(){\n      return parseInt(speedControl.value,10) || 420;\n    }\n\n    // Dragging: optional enhancement to allow reordering? Not required; left out to keep focused on heap ops.\n\n    // Initialization\n    window.addEventListener('resize', ()=> renderAll(true));\n    renderAll(true);\n\n    // Keyboard helpful hints\n    document.addEventListener('keydown', (e)=>{\n      if (e.ctrlKey && e.key === 'r') { e.preventDefault(); btnRandom.click(); }\n      if (e.ctrlKey && e.key === 'c') { e.preventDefault(); btnClear.click(); }\n    });\n\n    // For demonstration: helpful default array\n    arrayInput.value = '7,3,5,1,9,8';\n\n    // Small accessibility: focus first input on load\n    window.addEventListener('load', ()=> inputValue.focus());\n  </script>\n</body>\n</html>\n\nNotes:\n- The page focuses on a single concept: heap operations (Min vs Max).\n- Visual feedback includes animated node movement, highlighted comparisons, and swap emphasis. Narration explains each step.\n- All code is self-contained and uses only vanilla HTML, CSS, and JavaScript."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Heap (Min/Max).\n\n**Project Overview:**\nTopic: Heap (Min/Max)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Heap (Min/Max)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": false,
    "hasTest": false
  },
  {
    "id": "5e4c0220-bde7-11f0-8591-4fc0953aab32",
    "timestamp": "2025-11-10T03:44:40.665Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Bubble Sort",
    "answer": {
      "role": "assistant",
      "content": "Design Plan (brief)\n- Concept Title: Interactive Bubble Sort Visualization\n- Learning Objective: After interacting with the module, the user will understand how the Bubble Sort algorithm repeatedly compares adjacent elements, swaps when necessary, how its passes shrink the unsorted suffix, how optimization can short-circuit if no swaps occur, and will be able to step through and watch the comparisons and swaps visually.\n- Interaction Design: Users can generate a random array, supply a custom array (typing CSV), change array size and speed, start/pause automatic animation, step one comparison/swap at a time, and reset. Clicking a bar opens a small inline editor to change its value. Visual feedback includes: highlighted pair under comparison, animated swaps (bars slide horizontally and heights update), tail-of-sorted shaded, live counters (comparisons, swaps, passes), and a pseudocode block with the current line highlighted. All control actions are disabled while an animation is in progress to avoid state conflicts.\n- Layout Description: Single responsive card with 24px safe margins. Top row: title + short objective. Main content: two-column layout on wide screens (left column controls & explanations, right column visualization), stacks vertically on small screens. Controls grouped with a minimum 16px gap. Visualization uses an absolute-positioned bar area with animated transitions. Accessible buttons, labels, and keyboard focus states included.\n\nSelf-contained implementation (vanilla HTML/CSS/JS)\nSave the following as a single HTML file and open in a browser:\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Bubble Sort</title>\n  <style>\n    :root{\n      --gap:16px;\n      --safe:24px;\n      --bg:#0f1724;\n      --card:#0b1220;\n      --accent:#3b82f6;\n      --muted:#94a3b8;\n      --success:#10b981;\n      --danger:#ef4444;\n      --glass: rgba(255,255,255,0.03);\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background:\n        linear-gradient(180deg, rgba(255,255,255,0.02), transparent 30%),\n        var(--bg);\n      color:#e6eef8;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    /* Safe area margins: 24px */\n    .app {\n      padding:var(--safe);\n      box-sizing:border-box;\n      min-height:100vh;\n      display:flex;\n      align-items:flex-start;\n      justify-content:center;\n    }\n    .module {\n      width:100%;\n      max-width:1200px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:24px;\n      box-sizing:border-box;\n      box-shadow: 0 10px 30px rgba(2,6,23,0.6);\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    /* Header */\n    .header {\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      justify-content:space-between;\n    }\n    .title {\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n    .title h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing: -0.2px;\n    }\n    .subtitle{\n      margin:0;\n      color:var(--muted);\n      font-size:13px;\n      max-width:760px;\n    }\n\n    /* Main layout: two columns on wide, stacked on narrow */\n    .main {\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n    }\n    .col {\n      background:var(--glass);\n      border-radius:10px;\n      padding:16px;\n      box-sizing:border-box;\n    }\n    .left {\n      flex:0 0 360px;\n      min-width:280px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .right {\n      flex:1 1 auto;\n      min-height:320px;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n\n    /* Controls */\n    .controls {\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n    }\n    .row {\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    label {\n      font-size:13px;\n      color:var(--muted);\n    }\n    input[type=\"text\"], input[type=\"number\"], .btn, select {\n      background:rgba(255,255,255,0.03);\n      border:1px solid rgba(255,255,255,0.04);\n      color:inherit;\n      padding:8px 10px;\n      border-radius:8px;\n      font-size:13px;\n      outline:none;\n    }\n    input[type=\"range\"]{\n      width:160px;\n    }\n    .btn {\n      cursor:pointer;\n      user-select:none;\n      transition:all .12s ease;\n      display:inline-flex;\n      gap:8px;\n      align-items:center;\n      justify-content:center;\n    }\n    .btn.primary{\n      background:linear-gradient(90deg,var(--accent),#60a5fa);\n      color:#021124;\n      border:0;\n      padding:8px 12px;\n      border-radius:10px;\n      font-weight:600;\n    }\n    .btn.ghost{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.04);\n      padding:8px 10px;\n      border-radius:8px;\n    }\n    .btn:disabled{ opacity:0.45; cursor:not-allowed; transform:none; }\n\n    /* Stats */\n    .stats {\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n    }\n    .stat {\n      background:rgba(255,255,255,0.02);\n      padding:8px 12px;\n      border-radius:10px;\n      font-size:13px;\n      color:var(--muted);\n      min-width:84px;\n      text-align:center;\n    }\n    .stat strong{ display:block; color:#e6eef8; font-size:15px; }\n\n    /* Visualization */\n    .viz {\n      position:relative;\n      background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent);\n      border-radius:10px;\n      padding:16px;\n      min-height:320px;\n      overflow:hidden;\n    }\n    .bar-area {\n      position:relative;\n      height:240px;\n      margin-top:8px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);\n      border-radius:8px;\n    }\n    .bar {\n      position:absolute;\n      bottom:10px;\n      width:40px;\n      background:linear-gradient(180deg,#60a5fa,#2563eb);\n      border-radius:6px;\n      display:flex;\n      align-items:flex-end;\n      justify-content:center;\n      color:#021124;\n      font-weight:700;\n      font-size:12px;\n      box-shadow: 0 6px 14px rgba(37,99,235,0.18);\n      transition: left var(--anim,300ms) ease, transform var(--anim,300ms) ease, height var(--anim,300ms) ease, background-color 120ms ease;\n      cursor:pointer;\n    }\n    .bar .label{\n      background:rgba(255,255,255,0.85);\n      padding:2px 6px;\n      border-radius:6px;\n      transform:translateY(6px);\n      font-weight:700;\n      font-size:11px;\n    }\n    .bar.compare {\n      box-shadow: 0 12px 30px rgba(59,130,246,0.18);\n      transform:translateY(-8px);\n      background:linear-gradient(180deg,#93c5fd,#3b82f6);\n    }\n    .bar.swap {\n      background:linear-gradient(180deg,#fb7185,#ef4444);\n      box-shadow: 0 12px 30px rgba(239,68,68,0.18);\n    }\n    .bar.sorted {\n      background:linear-gradient(180deg,#10b981,#059669);\n      box-shadow: 0 8px 20px rgba(16,185,129,0.12);\n      color:#e6fff4;\n    }\n    .indices {\n      display:flex;\n      justify-content:space-between;\n      margin-top:8px;\n      color:var(--muted);\n      font-size:12px;\n    }\n\n    /* Pseudocode box */\n    .code {\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n      background:rgba(2,6,23,0.6);\n      border:1px solid rgba(255,255,255,0.03);\n      padding:12px;\n      border-radius:8px;\n      font-size:13px;\n      color:var(--muted);\n      max-height:200px;\n      overflow:auto;\n    }\n    .code .line {\n      padding:6px 8px;\n      border-radius:6px;\n      margin-bottom:6px;\n    }\n    .code .line.current {\n      background:linear-gradient(90deg, rgba(59,130,246,0.12), rgba(59,130,246,0.04));\n      color:#e6eef8;\n      border:1px solid rgba(59,130,246,0.15);\n    }\n\n    /* Footer help */\n    .help {\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    /* Responsive */\n    @media (max-width:900px){\n      .main{\n        flex-direction:column;\n      }\n      .left{ width:100%; min-width:unset; flex:unset;}\n      .right{ width:100%; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"module\" role=\"main\" aria-label=\"Bubble Sort Interactive Module\">\n      <div class=\"header\">\n        <div class=\"title\">\n          <h1>Bubble Sort — Visual, Step-by-Step</h1>\n          <p class=\"subtitle\">Watch adjacent elements being compared and swapped. Step through the algorithm or play it, change speed and array, and see an early-exit optimization in action.</p>\n        </div>\n        <div style=\"display:flex;flex-direction:column;gap:8px;align-items:flex-end\">\n          <div style=\"color:var(--muted);font-size:13px;text-align:right\">Concept<strong style=\"display:block;color:#e6eef8\">Bubble Sort</strong></div>\n          <div style=\"color:var(--muted);font-size:13px;text-align:right\">Objective<strong style=\"display:block;color:#e6eef8\">Understand comparisons, swaps, passes, and optimization</strong></div>\n        </div>\n      </div>\n\n      <div class=\"main\">\n        <!-- LEFT COLUMN: Controls & explanation -->\n        <div class=\"col left\" aria-label=\"Controls and explanation\">\n          <div class=\"controls\">\n            <div>\n              <label for=\"size\">Array size: <span id=\"sizeLabel\">8</span></label>\n              <div class=\"row\" style=\"margin-top:8px;\">\n                <input id=\"size\" type=\"range\" min=\"3\" max=\"20\" value=\"8\" />\n                <button id=\"randBtn\" class=\"btn ghost\" title=\"Generate random array\">Random</button>\n                <button id=\"sortedBtn\" class=\"btn ghost\" title=\"Generate sorted array\">Sorted</button>\n                <button id=\"revBtn\" class=\"btn ghost\" title=\"Generate reverse-sorted array\">Reverse</button>\n              </div>\n            </div>\n\n            <div>\n              <label for=\"custom\">Custom array (comma separated)</label>\n              <div class=\"row\" style=\"margin-top:8px;\">\n                <input id=\"custom\" type=\"text\" placeholder=\"e.g., 5,3,8,1,4\" aria-label=\"Custom array input\"/>\n                <button id=\"loadBtn\" class=\"btn primary\" title=\"Load custom array\">Load</button>\n              </div>\n            </div>\n\n            <div>\n              <label>Playback</label>\n              <div class=\"row\" style=\"margin-top:8px;\">\n                <button id=\"playBtn\" class=\"btn primary\" title=\"Play / Pause\">Play</button>\n                <button id=\"stepBtn\" class=\"btn ghost\" title=\"Step one comparison/swap\">Step</button>\n                <button id=\"resetBtn\" class=\"btn ghost\" title=\"Reset algorithm\">Reset</button>\n                <label style=\"display:inline-flex;align-items:center;gap:8px;\">\n                  <input id=\"optimize\" type=\"checkbox\" checked /> Optimized\n                </label>\n              </div>\n            </div>\n\n            <div>\n              <label>Speed</label>\n              <div class=\"row\" style=\"margin-top:8px;\">\n                <input id=\"speed\" type=\"range\" min=\"50\" max=\"1200\" value=\"400\" />\n                <div style=\"color:var(--muted);font-size:13px;margin-left:8px;\">Delay: <span id=\"speedLabel\">400ms</span></div>\n              </div>\n            </div>\n\n            <div>\n              <label>Statistics</label>\n              <div class=\"row stats\" style=\"margin-top:8px;\">\n                <div class=\"stat\"><div>Comparisons</div><strong id=\"cmp\">0</strong></div>\n                <div class=\"stat\"><div>Swaps</div><strong id=\"swp\">0</strong></div>\n                <div class=\"stat\"><div>Passes</div><strong id=\"pass\">0</strong></div>\n              </div>\n            </div>\n\n            <div>\n              <label>Pseudocode</label>\n              <div class=\"code\" id=\"pseudocode\" aria-hidden=\"false\">\n                <div class=\"line\" data-line=\"1\">for i from 0 to n-1:</div>\n                <div class=\"line\" data-line=\"2\">  swapped = false</div>\n                <div class=\"line\" data-line=\"3\">  for j from 0 to n-2-i:</div>\n                <div class=\"line\" data-line=\"4\">    if arr[j] > arr[j+1]:</div>\n                <div class=\"line\" data-line=\"5\">      swap arr[j] and arr[j+1]</div>\n                <div class=\"line\" data-line=\"6\">      swapped = true</div>\n                <div class=\"line\" data-line=\"7\">  if not swapped: break  # array is sorted</div>\n              </div>\n            </div>\n\n            <div>\n              <label>How to interact</label>\n              <div class=\"help\">Click Play to animate; use Step to move one comparison at a time. Click a bar to edit its value. You can load a custom CSV, generate random/sorted/reverse arrays, or change size and speed.</div>\n            </div>\n          </div>\n        </div>\n\n        <!-- RIGHT COLUMN: Visualization -->\n        <div class=\"col right\" aria-label=\"Visualization\">\n          <div class=\"viz\">\n            <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n              <div style=\"font-size:14px;color:var(--muted)\">Visualization</div>\n              <div style=\"display:flex;gap:12px;align-items:center;\">\n                <div style=\"font-size:13px;color:var(--muted)\">Comparing <strong id=\"curPair\" style=\"color:#e6eef8\">—</strong></div>\n                <div style=\"font-size:13px;color:var(--muted)\">Mode <strong id=\"modeLabel\" style=\"color:#e6eef8\">Optimized</strong></div>\n              </div>\n            </div>\n\n            <div class=\"bar-area\" id=\"barArea\" tabindex=\"0\" aria-label=\"Array bars area\" role=\"region\">\n              <!-- Bars rendered here -->\n            </div>\n\n            <div class=\"indices\" aria-hidden=\"true\">\n              <div>Left: index 0</div>\n              <div>Right: index <span id=\"maxIndex\">n-1</span></div>\n            </div>\n          </div>\n\n        </div>\n      </div>\n\n      <div style=\"display:flex;justify-content:space-between;align-items:center;gap:var(--gap)\">\n        <div style=\"color:var(--muted);font-size:13px\">Tip: Try a reverse array to see worst-case swaps.</div>\n        <div style=\"color:var(--muted);font-size:13px\">Built with plain HTML, CSS, and JavaScript.</div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    (function(){\n      // DOM references\n      const barArea = document.getElementById('barArea');\n      const sizeRange = document.getElementById('size');\n      const sizeLabel = document.getElementById('sizeLabel');\n      const randBtn = document.getElementById('randBtn');\n      const sortedBtn = document.getElementById('sortedBtn');\n      const revBtn = document.getElementById('revBtn');\n      const loadBtn = document.getElementById('loadBtn');\n      const customInput = document.getElementById('custom');\n      const playBtn = document.getElementById('playBtn');\n      const stepBtn = document.getElementById('stepBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const speedInput = document.getElementById('speed');\n      const speedLabel = document.getElementById('speedLabel');\n      const optimizeCheck = document.getElementById('optimize');\n      const cmpEl = document.getElementById('cmp');\n      const swpEl = document.getElementById('swp');\n      const passEl = document.getElementById('pass');\n      const curPair = document.getElementById('curPair');\n      const modeLabel = document.getElementById('modeLabel');\n      const pseudocode = document.getElementById('pseudocode');\n      const maxIndexEl = document.getElementById('maxIndex');\n\n      // State\n      let arr = [];\n      let bars = []; // DOM elements\n      let positions = []; // current x positions\n      let animating = false;\n      let running = false;\n      let timer = null;\n      let speed = parseInt(speedInput.value,10); // ms\n      let comparisons = 0;\n      let swaps = 0;\n      let passes = 0;\n\n      // Bubble pointers\n      let n = 8;\n      let i = 0; // pass\n      let j = 0; // index inside pass\n      let optimized = optimizeCheck.checked;\n      let swappedInPass = false;\n\n      // Layout constants\n      const paddingLR = 16; // left padding of bar area\n      const barWidth = 40;\n      const gap = 8; // gap between bars\n      const minValue = 1;\n      const maxValue = 100;\n\n      // Initialize\n      function init(){\n        sizeLabel.textContent = n;\n        maxIndexEl.textContent = n-1;\n        speedLabel.textContent = speed + 'ms';\n        modeLabel.textContent = optimized ? 'Optimized' : 'Standard';\n        bind();\n        generateRandom(n);\n      }\n\n      function bind(){\n        sizeRange.addEventListener('input', (e)=>{\n          n = parseInt(e.target.value,10);\n          sizeLabel.textContent = n;\n          sizeRange.value = n;\n        });\n        sizeRange.addEventListener('change', ()=>{\n          resetAll();\n          generateRandom(n);\n        });\n        randBtn.addEventListener('click', ()=>{ resetAll(); generateRandom(n); });\n        sortedBtn.addEventListener('click', ()=>{ resetAll(); generateSorted(n); });\n        revBtn.addEventListener('click', ()=>{ resetAll(); generateReverse(n); });\n        loadBtn.addEventListener('click', ()=>{ loadCustom(); });\n        playBtn.addEventListener('click', togglePlay);\n        stepBtn.addEventListener('click', stepOnce);\n        resetBtn.addEventListener('click', resetAll);\n        speedInput.addEventListener('input', (e)=>{ speed = parseInt(e.target.value,10); speedLabel.textContent = speed + 'ms'; });\n        optimizeCheck.addEventListener('change', (e)=>{ optimized = e.target.checked; modeLabel.textContent = optimized ? 'Optimized' : 'Standard'; });\n        barArea.addEventListener('keydown', (e)=>{ if(e.key===' '){ e.preventDefault(); togglePlay(); } });\n        // pseudocode clicks: not interactive, but allow highlighting programmatically\n      }\n\n      function generateRandom(size){\n        arr = Array.from({length:size}, ()=> randomInt(minValue, maxValue));\n        n = arr.length;\n        resetPointers();\n        render();\n      }\n      function generateSorted(size){\n        arr = Array.from({length:size}, (_,k)=> Math.round((k+1) * (maxValue/size)));\n        n = arr.length;\n        resetPointers();\n        render();\n      }\n      function generateReverse(size){\n        arr = Array.from({length:size}, (_,k)=> Math.round((size-k) * (maxValue/size)));\n        n = arr.length;\n        resetPointers();\n        render();\n      }\n      function loadCustom(){\n        const txt = customInput.value.trim();\n        if(!txt) return alert('Please enter comma separated numbers.');\n        const parts = txt.split(',').map(s=>s.trim()).filter(s=>s!=='');\n        const nums = parts.map(s=> Number(s));\n        if(nums.some(x=>Number.isNaN(x))){\n          alert('Invalid numbers in input. Use commas to separate values.');\n          return;\n        }\n        arr = nums.map(v=>Math.max(minValue, Math.min(maxValue, Math.round(v))));\n        n = arr.length;\n        sizeRange.value = n;\n        sizeLabel.textContent = n;\n        resetPointers();\n        render();\n      }\n\n      function resetPointers(){\n        i = 0; j = 0;\n        comparisons = 0; swaps = 0; passes = 0;\n        swappedInPass = false;\n        running = false;\n        updateStats();\n        running = false;\n        playBtn.textContent = 'Play';\n        curPair.textContent = '—';\n        highlightPseudo(null);\n        maxIndexEl.textContent = n-1;\n        enableControls(true);\n        clearAnimationQueue();\n      }\n\n      function resetAll(){\n        resetPointers();\n        // Keep array but re-render positions (no animations)\n        render(true);\n      }\n\n      function updateStats(){\n        cmpEl.textContent = comparisons;\n        swpEl.textContent = swaps;\n        passEl.textContent = passes;\n      }\n\n      function render(noAnimation){\n        // clear\n        barArea.innerHTML = '';\n        bars = [];\n        positions = [];\n        const areaWidth = barArea.clientWidth || (barArea.getBoundingClientRect().width||600);\n        // Calculate bar positions centered horizontally\n        const totalWidth = n * barWidth + Math.max(0, n-1) * gap;\n        const startX = Math.max(8, (areaWidth - totalWidth)/2);\n        for(let idx=0; idx<n; idx++){\n          const val = arr[idx];\n          const el = document.createElement('div');\n          el.className = 'bar';\n          el.setAttribute('role','button');\n          el.setAttribute('tabindex','0');\n          el.setAttribute('data-index', idx);\n          el.style.width = barWidth + 'px';\n          const maxH = 200;\n          const height = Math.max(24, Math.round((val / maxValue) * maxH));\n          el.style.height = height + 'px';\n          const x = startX + idx*(barWidth + gap);\n          el.style.left = x + 'px';\n          el.style.setProperty('--anim', noAnimation ? '0ms' : speed + 'ms');\n          el.innerHTML = '<div class=\"label\">' + val + '</div>';\n          // click to edit value\n          el.addEventListener('click', (ev)=>{\n            if(animating) return;\n            const cur = arr[idx];\n            const s = prompt('Edit value at index ' + idx + ' (1-100):', cur);\n            if(s === null) return;\n            const v = Number(s);\n            if(Number.isNaN(v)) return alert('Invalid number.');\n            arr[idx] = Math.max(minValue, Math.min(maxValue, Math.round(v)));\n            render(true);\n            resetPointers();\n          });\n          // keyboard edit\n          el.addEventListener('keydown', (ev)=>{\n            if(ev.key === 'Enter'){\n              el.click();\n            }\n          });\n          barArea.appendChild(el);\n          bars.push(el);\n          positions.push(x);\n        }\n        // highlight sorted tail if any\n        updateSortedTail();\n      }\n\n      function updatePositionsInstant(){\n        for(let idx=0; idx<bars.length; idx++){\n          bars[idx].style.setProperty('--anim', '0ms');\n          bars[idx].style.left = positions[idx] + 'px';\n          bars[idx].style.height = Math.max(24, Math.round((arr[idx]/100)*200)) + 'px';\n          bars[idx].querySelector('.label').textContent = arr[idx];\n        }\n      }\n\n      function updatePositionsAnimated(duration){\n        for(let idx=0; idx<bars.length; idx++){\n          bars[idx].style.setProperty('--anim', duration + 'ms');\n          bars[idx].style.left = positions[idx] + 'px';\n          bars[idx].style.height = Math.max(24, Math.round((arr[idx]/100)*200)) + 'px';\n          bars[idx].querySelector('.label').textContent = arr[idx];\n        }\n      }\n\n      // Algorithm primitives for stepping\n      function highlightPseudo(line){\n        const lines = pseudocode.querySelectorAll('.line');\n        lines.forEach(l => l.classList.toggle('current', Number(l.getAttribute('data-line')) === line));\n      }\n\n      function setComparing(a,b){\n        // Clear previous classes\n        bars.forEach(bar => bar.classList.remove('compare','swap'));\n        if(a != null && b != null){\n          bars[a].classList.add('compare');\n          bars[b].classList.add('compare');\n          curPair.textContent = a + ' ↔ ' + b;\n        } else {\n          curPair.textContent = '—';\n        }\n      }\n\n      function setSwapping(a,b){\n        bars[a].classList.remove('compare');\n        bars[b].classList.remove('compare');\n        bars[a].classList.add('swap');\n        bars[b].classList.add('swap');\n      }\n\n      function clearAnimationQueue(){\n        if(timer) { clearTimeout(timer); timer = null; }\n        animating = false;\n      }\n\n      function togglePlay(){\n        if(animating) return; // don't toggle mid-animation\n        running = !running;\n        playBtn.textContent = running ? 'Pause' : 'Play';\n        if(running) {\n          stepLoop();\n        }\n      }\n\n      function stepOnce(){\n        if(animating) return;\n        running = false;\n        playBtn.textContent = 'Play';\n        stepLogic();\n      }\n\n      // Core step logic implementing bubble sort step-by-step\n      async function stepLogic(){\n        if(n <= 1) return;\n        // If finished\n        if(i >= n-1){\n          highlightPseudo(null);\n          setComparing(null,null);\n          running = false;\n          playBtn.textContent = 'Play';\n          return;\n        }\n\n        // Pseudocode: line 3 (inner loop) unless starting new pass\n        highlightPseudo(3);\n\n        // Compare arr[j] and arr[j+1]\n        highlightPseudo(4);\n        setComparing(j, j+1);\n        comparisons++; updateStats();\n\n        // Small delay to show comparison\n        animating = true;\n        await wait(speed * 0.6);\n\n        if(arr[j] > arr[j+1]){\n          // swap\n          highlightPseudo(5);\n          setSwapping(j, j+1);\n          swaps++; updateStats();\n          swappedInPass = true;\n          // animate swap: swap values in arr and animate DOM positions by swapping left positions\n          // Determine visual indices for bars: we maintain bars order equal to array indices.\n          // We'll animate left positions and then swap elements in bars array to maintain mapping.\n          // Compute current left positions\n          const lefts = bars.map(b => parseFloat(b.style.left));\n          // Swap bars positions visually\n          const a = j, bIdx = j+1;\n          // Swap left coordinates in positions array\n          const tmpLeft = positions[a];\n          positions[a] = positions[bIdx];\n          positions[bIdx] = tmpLeft;\n          // Animate left and height change\n          updatePositionsAnimated(speed);\n          // Wait for animation\n          await wait(speed + 10);\n          // Swap bars elements in our bars array to keep index mapping: bars[idx] corresponds visually to index\n          const tmpBar = bars[a];\n          bars[a] = bars[bIdx];\n          bars[bIdx] = tmpBar;\n          // Swap arr values (so future comparisons use new order)\n          const tmp = arr[a];\n          arr[a] = arr[bIdx];\n          arr[bIdx] = tmp;\n          // Update label text and heights to reflect swapped values\n          updatePositionsAnimated(0);\n        } else {\n          // no swap: small highlight\n          bars[j].classList.remove('compare');\n          bars[j+1].classList.remove('compare');\n        }\n\n        // Move j forward\n        j++;\n        // If we've reached end of inner loop for this pass\n        if(j >= n - 1 - i){\n          passes++; updateStats();\n          highlightPseudo(2); // swapped = false line\n          // Mark sorted tail: element at index n-1-i is in correct position\n          markSorted(n-1 - i);\n          i++;\n          j = 0;\n          if(!swappedInPass && optimized){\n            // early exit\n            highlightPseudo(7);\n            // mark remaining as sorted\n            for(let k=0;k<n-i;k++){\n              markSorted(k);\n            }\n            // Finish\n            animating = false;\n            running = false;\n            playBtn.textContent = 'Play';\n            setComparing(null,null);\n            highlightPseudo(null);\n            return;\n          }\n          swappedInPass = false;\n        }\n\n        animating = false;\n        setComparing(null,null);\n        updateSortedTail();\n\n        // If running in autoplay, queue next step\n        if(running){\n          timer = setTimeout(()=> stepLogic(), 20);\n        }\n      }\n\n      async function stepLoop(){\n        if(animating) return;\n        if(i >= n-1){\n          running = false;\n          playBtn.textContent = 'Play';\n          return;\n        }\n        await stepLogic();\n        if(running) {\n          // queue next\n          timer = setTimeout(()=> stepLoop(), 20);\n        }\n      }\n\n      // Utility: mark an index as sorted (style)\n      function markSorted(index){\n        if(bars[index]){\n          bars[index].classList.add('sorted');\n        }\n      }\n\n      function updateSortedTail(){\n        // Clear all sorted classes and reapply for sorted tail based on i\n        for(let k=0;k<n;k++){\n          bars[k].classList.toggle('sorted', k >= n - i);\n        }\n      }\n\n      // Helper: wait (ms)\n      function wait(ms){\n        return new Promise(resolve => setTimeout(resolve, ms));\n      }\n\n      // Helpers\n      function randomInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }\n\n      // Initialize elements and computed positions after DOM layout\n      window.addEventListener('load', ()=>{\n        init();\n      });\n\n      // Recompute positions on resize\n      window.addEventListener('resize', ()=>{\n        // recalculate positions array and apply to bars\n        if(bars.length !== n) return;\n        const areaWidth = barArea.clientWidth;\n        const totalWidth = n * barWidth + Math.max(0, n-1) * gap;\n        const startX = Math.max(8, (areaWidth - totalWidth)/2);\n        for(let idx=0; idx<n; idx++){\n          positions[idx] = startX + idx*(barWidth + gap);\n        }\n        updatePositionsInstant();\n      });\n\n      // When first rendering or generating, compute positions according to area\n      // Overwrite render to set positions properly\n      // We'll override render to compute positions and set bars accordingly\n      // (Render already computes startX; we need to set positions array used later for animations.)\n      const originalRender = render;\n      render = function(noAnimation){\n        // compute positions\n        const areaWidth = barArea.clientWidth || (barArea.getBoundingClientRect().width||600);\n        const totalWidth = n * barWidth + Math.max(0, n-1) * gap;\n        const startX = Math.max(8, (areaWidth - totalWidth)/2);\n        positions = [];\n        for(let idx=0; idx<n; idx++){\n          positions.push(startX + idx*(barWidth + gap));\n        }\n        // Remove old bars\n        barArea.innerHTML = '';\n        bars = [];\n        for(let idx=0; idx<n; idx++){\n          const val = arr[idx];\n          const el = document.createElement('div');\n          el.className = 'bar';\n          el.setAttribute('role','button');\n          el.setAttribute('tabindex','0');\n          el.setAttribute('data-index', idx);\n          el.style.width = barWidth + 'px';\n          const maxH = 200;\n          const height = Math.max(24, Math.round((val / maxValue) * maxH));\n          el.style.height = height + 'px';\n          const x = positions[idx];\n          el.style.left = x + 'px';\n          el.style.setProperty('--anim', noAnimation ? '0ms' : speed + 'ms');\n          el.innerHTML = '<div class=\"label\">' + val + '</div>';\n          (function(localIdx){\n            el.addEventListener('click', (ev)=>{\n              if(animating) return;\n              const cur = arr[localIdx];\n              const s = prompt('Edit value at index ' + localIdx + ' (1-100):', cur);\n              if(s === null) return;\n              const v = Number(s);\n              if(Number.isNaN(v)) return alert('Invalid number.');\n              arr[localIdx] = Math.max(minValue, Math.min(maxValue, Math.round(v)));\n              render(true);\n              resetPointers();\n            });\n            el.addEventListener('keydown', (ev)=>{\n              if(ev.key === 'Enter'){\n                el.click();\n              }\n            });\n          })(idx);\n          barArea.appendChild(el);\n          bars.push(el);\n        }\n        // reset pointers styles and stats\n        updateSortedTail();\n        updateStats();\n      };\n\n    })();\n  </script>\n</body>\n</html>\n```\n\nNotes and accessibility:\n- Safe area margins are 24px and element gaps are at least 16px.\n- Controls are reachable by keyboard (bars are focusable; Enter edits).\n- Visual feedback: comparisons highlight bars, swaps animate bars sliding horizontally, sorted elements get a distinct color.\n- No external libraries or assets — plain HTML/CSS/JS."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Bubble Sort.\n\n**Project Overview:**\nTopic: Bubble Sort\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Bubble Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Auto-generated FSM from partial data",
      "states": [
        {
          "name": "idle\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "running\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "animating\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "editing\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "loading\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "finished\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        }
      ],
      "events": [
        "PLAY_TOGGLE",
        "STEP",
        "RESET",
        "RANDOMIZE",
        "SORTED_ARRAY",
        "REVERSE_ARRAY",
        "LOAD_CUSTOM",
        "SIZE_CHANGE",
        "SPEED_CHANGE",
        "TOGGLE_OPTIMIZE",
        "BAR_EDIT_START",
        "ANIMATION_START",
        "FINISH",
        "ANIMATION_END_CONTINUE",
        "ANIMATION_END_STOP",
        "COMPARE_DONE",
        "SWAP_DONE",
        "PASS_COMPLETE",
        "EARLY_EXIT",
        "EDIT_CONFIRM",
        "EDIT_CANCEL",
        "LOAD_DONE",
        "ERROR"
      ],
      "notes": "Generated using fallback parsing due to JSON format issues"
    }
  },
  {
    "id": "6e678b20-bde7-11f0-8591-4fc0953aab32",
    "timestamp": "2025-11-10T03:44:43.938Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive Binary Search Tree Explorer</title>\n  <style>\n    :root{\n      --safe-pad: 24px;        /* Safe area margin */\n      --gap: 16px;            /* Minimum spacing */\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #38bdf8;\n      --muted: #94a3b8;\n      --success: #34d399;\n      --danger: #fb7185;\n      --node-radius: 20;\n      --level-gap: 90;\n      --h-spacing: 60;\n    }\n\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,var(--bg), #061022 180%);\n      color: #e6eef6;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n\n    /* Safe area and layout */\n    .container{\n      padding: var(--safe-pad);\n      box-sizing: border-box;\n      min-height:100vh;\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n      justify-content:center;\n    }\n\n    /* Left Info + Controls Panel */\n    .panel{\n      width:360px;\n      min-width:300px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.04);\n      border-radius:12px;\n      padding:20px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:var(--gap);\n      box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n    }\n\n    h1{\n      margin:0;\n      font-size:18px;\n      color:#eaffff;\n      letter-spacing:0.2px;\n    }\n\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.3;\n      margin-top:4px;\n    }\n\n    .section{\n      background: transparent;\n      padding: 10px;\n      border-radius:8px;\n      display:flex;\n      flex-direction:column;\n      gap:8px;\n    }\n\n    label{\n      font-size:13px;\n      color:#d9f4ff;\n    }\n\n    input[type=\"text\"]{\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background: rgba(255,255,255,0.02);\n      color: #e6f7ff;\n      outline:none;\n      font-size:14px;\n    }\n    .controls-row{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      flex-wrap:wrap;\n    }\n\n    button{\n      background: linear-gradient(180deg,#07202b,#062028);\n      color: #e6f7ff;\n      border: 1px solid rgba(255,255,255,0.04);\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:13px;\n      min-width:64px;\n      transition: transform .08s ease, box-shadow .12s;\n    }\n    button:active{ transform: translateY(1px); }\n    button.primary{\n      background: linear-gradient(180deg,#049fd6,#0388bc);\n      box-shadow: 0 6px 18px rgba(3,136,188,0.18);\n    }\n    button.warn{\n      background: linear-gradient(180deg,#ff8a8f,#ff6b76);\n    }\n\n    .small{\n      padding:6px 10px;\n      font-size:12px;\n      min-width:unset;\n    }\n\n    .row{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      justify-content:space-between;\n    }\n\n    .info-list{\n      font-size:13px;\n      color:var(--muted);\n      display:flex;\n      flex-direction:column;\n      gap:6px;\n    }\n\n    .status{\n      background: rgba(255,255,255,0.02);\n      padding:8px;\n      border-radius:8px;\n      font-size:13px;\n      color:#cfefff;\n      min-height:40px;\n    }\n\n    /* Canvas area */\n    .stage{\n      flex:1;\n      min-width:360px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:16px;\n      box-sizing:border-box;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    .stage-top{\n      display:flex;\n      align-items:center;\n      justify-content:space-between;\n      gap:var(--gap);\n    }\n\n    .legend{\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    .canvas-wrap{\n      position:relative;\n      background: linear-gradient(90deg, rgba(255,255,255,0.006), rgba(255,255,255,0.004));\n      border-radius:8px;\n      padding:12px;\n      min-height:420px;\n      overflow:auto;\n      border:1px dashed rgba(255,255,255,0.02);\n    }\n\n    /* SVG will be sized responsively; nodes and edges */\n    svg{\n      width:100%;\n      height:520px;\n      display:block;\n    }\n\n    /* Node visuals */\n    .node-group{\n      cursor: default;\n      transition: transform 600ms cubic-bezier(.2,.9,.3,1);\n      transform-origin: center;\n    }\n\n    .node-circle{\n      fill: linear-gradient(180deg,#073b4a,#0a5165);\n      fill: #052b35;\n      stroke: rgba(255,255,255,0.06);\n      stroke-width:1.8px;\n      transition: fill .25s ease, r .25s ease;\n      filter: drop-shadow(0 6px 10px rgba(3,12,22,0.6));\n    }\n    .node-text{\n      font-size:13px;\n      fill: #e6f7ff;\n      pointer-events:none;\n      font-weight:600;\n    }\n\n    .edge{\n      stroke: rgba(255,255,255,0.08);\n      stroke-width:2px;\n      stroke-linecap:round;\n    }\n\n    .edge.highlight{\n      stroke: var(--accent);\n      stroke-width:3px;\n      stroke-opacity:0.95;\n    }\n\n    .node-circle.highlight{\n      fill: var(--accent);\n      stroke: rgba(255,255,255,0.14);\n    }\n\n    .pulse{\n      animation: pulse 900ms ease-in-out infinite alternate;\n    }\n    @keyframes pulse{\n      from { transform: scale(1); filter: drop-shadow(0 6px 18px rgba(3,12,22,0.5)); }\n      to { transform: scale(1.06); filter: drop-shadow(0 10px 28px rgba(3,12,22,0.6)); }\n    }\n\n    .traversal-list{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      align-items:center;\n    }\n    .chip{\n      padding:6px 10px;\n      border-radius:999px;\n      background: rgba(255,255,255,0.02);\n      border: 1px solid rgba(255,255,255,0.03);\n      color:#dff8ff;\n      font-weight:600;\n    }\n\n    /* Responsive adjustments */\n    @media (max-width:960px){\n      .container{ flex-direction:column; padding:18px; }\n      .panel{ width:100%; }\n      .stage{ width:100%; }\n      svg{ height:520px; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"main\" aria-label=\"Binary Search Tree interactive module\">\n    <!-- Left Panel: Title, Objectives, Controls -->\n    <aside class=\"panel\" aria-labelledby=\"title\">\n      <div>\n        <h1 id=\"title\">Binary Search Tree (BST) Explorer</h1>\n        <div class=\"muted\">Understand insertion, search, deletion, and in-order traversal with step-by-step visual feedback.</div>\n      </div>\n\n      <div class=\"section\" aria-live=\"polite\">\n        <label><strong>Learning Objective</strong></label>\n        <div class=\"muted\">After interacting you should be able to:</div>\n        <ul class=\"info-list\" style=\"margin:0; padding-left:18px;\">\n          <li>Explain how BST organizes data (left &lt; node &lt; right).</li>\n          <li>Perform insertion/search/delete operations and trace comparisons.</li>\n          <li>Observe in-order traversal producing sorted order.</li>\n        </ul>\n      </div>\n\n      <div class=\"section\" aria-label=\"Interaction Design\">\n        <label><strong>Interaction Design</strong></label>\n        <div class=\"muted\">\n          - Type one or more integers (space/comma separated). Use Insert / Delete / Search.<br>\n          - Step Mode: step through each comparison and pointer move; nodes highlight as you compare. Auto Play runs the steps automatically.<br>\n          - In-order traversal highlights nodes left→root→right and shows the sorted sequence.\n        </div>\n      </div>\n\n      <div class=\"section\" aria-label=\"Controls\">\n        <label for=\"valueInput\">Values</label>\n        <input id=\"valueInput\" type=\"text\" placeholder=\"e.g., 50 or 10 30 70\" aria-describedby=\"valuesHelp\" />\n\n        <div class=\"controls-row\">\n          <button id=\"insertBtn\" class=\"primary\" aria-label=\"Insert values\">Insert</button>\n          <button id=\"deleteBtn\" aria-label=\"Delete values\">Delete</button>\n          <button id=\"searchBtn\" aria-label=\"Search values\">Search</button>\n        </div>\n\n        <div class=\"controls-row\">\n          <button id=\"stepToggle\" class=\"small\" aria-pressed=\"false\">Step Mode</button>\n          <button id=\"autoPlayBtn\" class=\"small\">Auto Play</button>\n          <button id=\"randomBtn\" class=\"small\" title=\"Generate random tree\">Random</button>\n          <button id=\"clearBtn\" class=\"small warn\">Clear</button>\n        </div>\n\n        <div style=\"display:flex;gap:var(--gap);align-items:center;\">\n          <label style=\"margin:0;font-size:13px;color:var(--muted);\">Speed</label>\n          <input id=\"speedRange\" type=\"range\" min=\"200\" max=\"1600\" step=\"100\" value=\"700\" />\n        </div>\n\n      </div>\n\n      <div class=\"section\" aria-live=\"polite\">\n        <label><strong>Layout Description</strong></label>\n        <div class=\"muted\">\n          - Left panel: controls and concise explanations. Right: scalable SVG canvas for tree visualization.<br>\n          - Safe area: 24px padding on all sides; interactive elements spaced at least 16px.<br>\n          - Nodes placed by depth (vertical gap) and in-order horizontal spacing to preserve readability and avoid overlap. Responsive for smaller screens.\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <label><strong>Status</strong></label>\n        <div id=\"status\" class=\"status\" aria-live=\"assertive\">Ready — insert a number to begin.</div>\n      </div>\n\n    </aside>\n\n    <!-- Right: Visualization stage -->\n    <main class=\"stage\" aria-label=\"Visualization and canvas\">\n      <div class=\"stage-top\">\n        <div class=\"legend\">Canvas: Visualizes nodes and comparisons. Click nodes for details.</div>\n        <div class=\"legend muted\">Tip: No duplicate values permitted</div>\n      </div>\n\n      <div class=\"canvas-wrap\" role=\"region\" aria-label=\"BST visualization canvas\">\n        <svg id=\"svgCanvas\" viewBox=\"0 0 1200 520\" preserveAspectRatio=\"xMinYMin meet\" tabindex=\"0\" aria-label=\"Binary Search Tree\">\n          <!-- Edges and nodes appended here -->\n        </svg>\n      </div>\n\n      <div style=\"display:flex;gap:var(--gap);align-items:center;justify-content:space-between;\">\n        <div>\n          <label style=\"font-size:13px;color:var(--muted);margin-right:8px;\">In-order traversal:</label>\n          <div id=\"traversal\" class=\"traversal-list\" aria-live=\"polite\"></div>\n        </div>\n        <div>\n          <button id=\"traverseBtn\" class=\"small\">Traverse</button>\n        </div>\n      </div>\n\n    </main>\n  </div>\n\n  <script>\n    /********************************************************************\n     * Interactive BST Explorer\n     * - Single concept: Binary Search Tree insert/search/delete/traverse\n     * - Implements step-mode with visual highlights and animations\n     * - Self-contained: vanilla HTML/CSS/JS only\n     ********************************************************************/\n\n    /* -------------------------\n       Utility & DOM references\n       ------------------------- */\n    const svg = document.getElementById('svgCanvas');\n    const insertBtn = document.getElementById('insertBtn');\n    const deleteBtn = document.getElementById('deleteBtn');\n    const searchBtn = document.getElementById('searchBtn');\n    const traverseBtn = document.getElementById('traverseBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const randomBtn = document.getElementById('randomBtn');\n    const stepToggle = document.getElementById('stepToggle');\n    const autoPlayBtn = document.getElementById('autoPlayBtn');\n    const valueInput = document.getElementById('valueInput');\n    const statusEl = document.getElementById('status');\n    const traversalEl = document.getElementById('traversal');\n    const speedRange = document.getElementById('speedRange');\n\n    let STEP_MODE = false;\n    let AUTO_PLAY = false;\n    let stepQueue = [];    // events for current operation\n    let running = false;   // whether we are auto-processing steps\n    let speed = parseInt(speedRange.value,10);\n\n    // layout variables\n    const NODE_R = 20;\n    const LEVEL_GAP = 90;\n    const H_SPACING = 60;\n    const SVG_WIDTH = 1200;\n    const SVG_HEIGHT = 520;\n\n    // data structures\n    class Node {\n      constructor(value){\n        this.value = value;\n        this.left = null;\n        this.right = null;\n        this.x = 0;\n        this.y = 0;\n        this.id = Node._id++;\n      }\n    }\n    Node._id = 1;\n\n    let root = null;\n\n    /* -------------------------\n       Visualization helpers\n       ------------------------- */\n\n    function clearSVG(){\n      while(svg.firstChild) svg.removeChild(svg.firstChild);\n    }\n\n    function createSVGElement(tag, attrs={}){\n      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);\n      for(const k in attrs){\n        el.setAttribute(k, attrs[k]);\n      }\n      return el;\n    }\n\n    function updateStatus(msg, tone){\n      statusEl.textContent = msg;\n      if(tone === 'error') statusEl.style.color = 'var(--danger)';\n      else if(tone === 'success') statusEl.style.color = 'var(--success)';\n      else statusEl.style.color = '#cfefff';\n    }\n\n    /* -------------------------\n       Tree layout calculation\n       ------------------------- */\n\n    function computePositions(){\n      // assign x positions by in-order index\n      let index = 0;\n      function inorderAssign(node, depth){\n        if(!node) return;\n        inorderAssign(node.left, depth+1);\n        node.x = (index++) * H_SPACING + 60; // left margin\n        node.y = 40 + depth * LEVEL_GAP;\n        inorderAssign(node.right, depth+1);\n      }\n      index = 0;\n      inorderAssign(root, 0);\n    }\n\n    /* -------------------------\n       SVG drawing update\n       ------------------------- */\n\n    function render(){\n      clearSVG();\n      if(!root) return;\n      computePositions();\n\n      // Draw edges first\n      const edgesGroup = createSVGElement('g', {class:'edges'});\n      const nodesGroup = createSVGElement('g', {class:'nodes'});\n      svg.appendChild(edgesGroup);\n      svg.appendChild(nodesGroup);\n\n      // map id->node for event binding\n      const allNodes = [];\n      function collect(node){\n        if(!node) return;\n        allNodes.push(node);\n        collect(node.left);\n        collect(node.right);\n      }\n      collect(root);\n\n      // draw edges\n      allNodes.forEach(node => {\n        if(node.parent){\n          const line = createSVGElement('line', {\n            class: 'edge',\n            x1: node.parent.x,\n            y1: node.parent.y + NODE_R,\n            x2: node.x,\n            y2: node.y - NODE_R\n          });\n          line.dataset.to = node.id;\n          line.dataset.from = node.parent.id;\n          edgesGroup.appendChild(line);\n        }\n      });\n\n      // draw nodes\n      allNodes.forEach(node => {\n        const g = createSVGElement('g', {class:'node-group', transform: `translate(${node.x},${node.y})`});\n        g.setAttribute('data-id', node.id);\n        // circle\n        const circ = createSVGElement('circle', {\n          class: 'node-circle',\n          r: NODE_R,\n          cx: 0, cy: 0\n        });\n        // text (centered)\n        const txt = createSVGElement('text', {\n          class: 'node-text',\n          x: 0, y: 5,\n          'text-anchor': 'middle'\n        });\n        txt.textContent = node.value;\n        g.appendChild(circ);\n        g.appendChild(txt);\n\n        // tooltip (aria)\n        g.setAttribute('role','button');\n        g.setAttribute('tabindex','0');\n        g.setAttribute('aria-label', `Node ${node.value}`);\n\n        // click to copy value to input\n        g.addEventListener('click', ()=>{\n          valueInput.value = String(node.value);\n          updateStatus(`Picked value ${node.value} — ready to operate`);\n        });\n\n        g.addEventListener('keydown',(e)=>{\n          if(e.key === 'Enter' || e.key === ' '){\n            e.preventDefault();\n            g.click();\n          }\n        });\n\n        nodesGroup.appendChild(g);\n      });\n\n      // After drawing, adjust svg viewBox width if needed to keep spacing\n      const maxX = Math.max(...allNodes.map(n => n.x));\n      const minX = Math.min(...allNodes.map(n => n.x));\n      const pad = 120;\n      const width = Math.max(SVG_WIDTH, maxX + pad);\n      svg.setAttribute('viewBox', `0 0 ${width} ${SVG_HEIGHT}`);\n    }\n\n    /* -------------------------\n       Tree operations with event recording\n       ------------------------- */\n\n    // We'll generate \"steps\" describing comparisons, moves, inserts, deletes.\n    // A step: {type: 'compare'|'move'|'insert'|'delete'|'replace'|'found', node: Node?, value: number, extra: {}}\n\n    function insertValuesFromInput(){\n      const vals = parseInputValues(valueInput.value);\n      if(vals.length === 0){ updateStatus('No valid integers provided', 'error'); return; }\n      // sequentially insert each value\n      (async ()=>{\n        for(const v of vals){\n          if(hasValue(root, v)){\n            updateStatus(`Value ${v} already exists; duplicates not allowed`, 'error');\n            await sleep(700);\n            continue;\n          }\n          await runOperationWithSteps(() => generateInsertSteps(v));\n        }\n      })();\n    }\n\n    function parseInputValues(text){\n      if(!text) return [];\n      return text.split(/[\\s,]+/)\n        .map(s => s.trim())\n        .filter(Boolean)\n        .map(Number)\n        .filter(n => Number.isFinite(n));\n    }\n\n    function hasValue(node, v){\n      if(!node) return false;\n      if(node.value === v) return true;\n      if(v < node.value) return hasValue(node.left, v);\n      return hasValue(node.right, v);\n    }\n\n    function generateInsertSteps(v){\n      // returns array of steps implementing insertion\n      const steps = [];\n      if(!root){\n        steps.push({type:'insert', value:v, parent:null, attach:'root'});\n        return steps;\n      }\n      let cur = root;\n      let parent = null;\n      while(cur){\n        steps.push({type:'compare', node:cur, value:v});\n        parent = cur;\n        if(v < cur.value){\n          steps.push({type:'move', from:cur, direction:'left'});\n          if(!cur.left){\n            steps.push({type:'insert', value:v, parent:cur, attach:'left'});\n            break;\n          }\n          cur = cur.left;\n        } else {\n          steps.push({type:'move', from:cur, direction:'right'});\n          if(!cur.right){\n            steps.push({type:'insert', value:v, parent:cur, attach:'right'});\n            break;\n          }\n          cur = cur.right;\n        }\n      }\n      return steps;\n    }\n\n    function runOperationWithSteps(generator){\n      // generator is a function that returns steps (array)\n      if(running) {\n        updateStatus('Operation in progress — wait', 'error');\n        return Promise.resolve();\n      }\n      stepQueue = generator();\n      return processSteps(stepQueue);\n    }\n\n    async function processSteps(steps){\n      running = true;\n      const delay = () => new Promise(res => setTimeout(res, speedRange.value));\n      // Clear temporary highlights\n      clearHighlights();\n      render(); // ensure current drawing\n\n      for(let i=0;i<steps.length;i++){\n        const s = steps[i];\n        if(s.type === 'compare'){\n          highlightNode(s.node, 'compare');\n          updateStatus(`Comparing ${s.node.value} with ${s.value}`);\n          if(STEP_MODE){\n            await waitForUserOrAuto();\n          } else {\n            await delay();\n          }\n          removeHighlight(s.node);\n        } else if(s.type === 'move'){\n          // highlight edge and node\n          highlightNode(s.from, 'move');\n          highlightEdgeToChild(s.from, s.direction);\n          updateStatus(`Go ${s.direction} from ${s.from.value}`);\n          if(STEP_MODE){\n            await waitForUserOrAuto();\n          } else {\n            await delay();\n          }\n          clearHighlights();\n        } else if(s.type === 'insert'){\n          updateStatus(`Inserting ${s.value}`);\n          // actually perform insertion in data model\n          if(s.attach === 'root'){\n            const n = new Node(s.value);\n            root = n;\n          } else {\n            const n = new Node(s.value);\n            const parent = s.parent;\n            if(s.attach === 'left') parent.left = n;\n            else parent.right = n;\n            n.parent = parent;\n          }\n          render();\n          // visual pulse on new node\n          const newNode = findNodeByValue(root, s.value);\n          if(newNode){\n            highlightNode(newNode, 'new');\n            if(STEP_MODE){\n              await waitForUserOrAuto();\n            } else {\n              await delay();\n            }\n            removeHighlight(newNode);\n          } else {\n            await delay();\n          }\n        } else if(s.type === 'found'){\n          updateStatus(`Found ${s.value}`);\n          highlightNode(s.node,'found');\n          if(STEP_MODE) await waitForUserOrAuto();\n          else await delay();\n          removeHighlight(s.node);\n        } else if(s.type === 'not-found'){\n          updateStatus(`${s.value} not found`);\n          await delay();\n        } else if(s.type === 'replace'){\n          updateStatus(`Replacing ${s.target.value} with ${s.with.value}`);\n          // perform replace value\n          s.target.value = s.with.value;\n          render();\n          highlightNode(s.target,'replace');\n          if(STEP_MODE) await waitForUserOrAuto();\n          else await delay();\n          removeHighlight(s.target);\n        } else if(s.type === 'delete'){\n          updateStatus(`Deleting ${s.value}`);\n          // delete node from tree (physically remove)\n          removeNodeByValue(s.value);\n          render();\n          await delay();\n        }\n      }\n      running = false;\n      updateStatus('Operation complete', 'success');\n      updateTraversalDisplay();\n    }\n\n    function waitForUserOrAuto(){\n      return new Promise(resolve => {\n        if(AUTO_PLAY){\n          const t = parseInt(speedRange.value,10);\n          setTimeout(resolve, t);\n        } else {\n          // wait for Step Mode \"Next\" (here we use the autoPlayBtn click as \"Next\")\n          // We'll reuse autoPlayBtn as a 'Next' when in step mode and not auto\n          const handler = () => {\n            autoPlayBtn.removeEventListener('click', handler);\n            resolve();\n          };\n          autoPlayBtn.addEventListener('click', handler);\n        }\n      });\n    }\n\n    /* -------------------------\n       Search operation\n       ------------------------- */\n\n    function searchValuesFromInput(){\n      const vals = parseInputValues(valueInput.value);\n      if(vals.length === 0){ updateStatus('No valid integers provided', 'error'); return; }\n      (async ()=>{\n        for(const v of vals){\n          await runOperationWithSteps(() => generateSearchSteps(v));\n        }\n      })();\n    }\n\n    function generateSearchSteps(v){\n      const steps = [];\n      let cur = root;\n      while(cur){\n        steps.push({type:'compare', node:cur, value:v});\n        if(cur.value === v){\n          steps.push({type:'found', node:cur, value:v});\n          return steps;\n        }\n        if(v < cur.value){\n          steps.push({type:'move', from:cur, direction:'left'});\n          cur = cur.left;\n        } else {\n          steps.push({type:'move', from:cur, direction:'right'});\n          cur = cur.right;\n        }\n      }\n      steps.push({type:'not-found', value:v});\n      return steps;\n    }\n\n    /* -------------------------\n       Delete operation\n       ------------------------- */\n\n    function deleteValuesFromInput(){\n      const vals = parseInputValues(valueInput.value);\n      if(vals.length === 0){ updateStatus('No valid integers provided', 'error'); return; }\n      (async ()=>{\n        for(const v of vals){\n          if(!hasValue(root, v)){\n            updateStatus(`Value ${v} not found — cannot delete`, 'error');\n            await sleep(700);\n            continue;\n          }\n          await runOperationWithSteps(() => generateDeleteSteps(v));\n        }\n      })();\n    }\n\n    function generateDeleteSteps(v){\n      // We'll record the usual recursive deletion steps, including finding in-order successor\n      const steps = [];\n      function recurse(node, parent){\n        if(!node) return;\n        steps.push({type:'compare', node, value:v});\n        if(v < node.value){\n          steps.push({type:'move', from:node, direction:'left'});\n          recurse(node.left, node);\n        } else if(v > node.value){\n          steps.push({type:'move', from:node, direction:'right'});\n          recurse(node.right, node);\n        } else {\n          // node to delete found\n          steps.push({type:'found', node, value:v});\n          // three cases:\n          if(!node.left && !node.right){\n            // leaf\n            steps.push({type:'delete', value:v});\n            return;\n          } else if(node.left && !node.right){\n            // replace node with left subtree (by value swap or pointer rewiring)\n            // For educational clarity: we'll replace node.value with leftmost/rightmost as needed.\n            // Simpler: attach child to parent\n            steps.push({type:'delete', value:v});\n            return;\n          } else if(!node.left && node.right){\n            steps.push({type:'delete', value:v});\n            return;\n          } else {\n            // two children: find in-order successor (min in right subtree)\n            let succ = node.right;\n            while(succ.left){\n              steps.push({type:'move', from:succ, direction:'left'});\n              succ = succ.left;\n            }\n            // replace node's value with succ's value\n            steps.push({type:'replace', target:node, with:succ});\n            // then delete successor node (which has at most right child)\n            steps.push({type:'delete', value:succ.value});\n            return;\n          }\n        }\n      }\n      recurse(root, null);\n      return steps;\n    }\n\n    function removeNodeByValue(v){\n      root = removeRec(root, v);\n      // Clean up parent pointers\n      function setParents(node, parent = null){\n        if(!node) return;\n        node.parent = parent;\n        setParents(node.left, node);\n        setParents(node.right, node);\n      }\n      setParents(root, null);\n    }\n\n    function removeRec(node, v){\n      if(!node) return null;\n      if(v < node.value){\n        node.left = removeRec(node.left, v);\n        return node;\n      } else if(v > node.value){\n        node.right = removeRec(node.right, v);\n        return node;\n      } else {\n        // found\n        if(!node.left && !node.right) return null;\n        if(!node.left) return node.right;\n        if(!node.right) return node.left;\n        // two children: replace with in-order successor (min in right)\n        let succ = node.right;\n        while(succ.left) succ = succ.left;\n        node.value = succ.value;\n        node.right = removeRec(node.right, succ.value);\n        return node;\n      }\n    }\n\n    /* -------------------------\n       Node lookup & highlight helpers\n       ------------------------- */\n\n    function findNodeByValue(node, v){\n      if(!node) return null;\n      if(node.value === v) return node;\n      if(v < node.value) return findNodeByValue(node.left, v);\n      return findNodeByValue(node.right, v);\n    }\n\n    function highlightNode(node, kind){\n      if(!node) return;\n      const g = svg.querySelector(`g.node-group[data-id=\"${node.id}\"]`);\n      if(!g) return;\n      const circ = g.querySelector('circle.node-circle');\n      if(kind === 'compare'){\n        circ.classList.add('pulse');\n        circ.style.fill = '#2b84a5';\n      } else if(kind === 'move'){\n        circ.classList.add('pulse');\n        circ.style.fill = '#3aa8d6';\n      } else if(kind === 'new'){\n        circ.classList.add('pulse');\n        circ.style.fill = 'var(--success)';\n      } else if(kind === 'found'){\n        circ.classList.add('pulse');\n        circ.style.fill = 'var(--accent)';\n      } else if(kind === 'replace'){\n        circ.classList.add('pulse');\n        circ.style.fill = '#f6c85f';\n      } else {\n        circ.classList.add('pulse');\n      }\n    }\n\n    function removeHighlight(node){\n      if(!node) return;\n      const g = svg.querySelector(`g.node-group[data-id=\"${node.id}\"]`);\n      if(!g) return;\n      const circ = g.querySelector('circle.node-circle');\n      circ.classList.remove('pulse');\n      circ.style.fill = '';\n    }\n\n    function highlightEdgeToChild(node, direction){\n      if(!node) return;\n      let child = direction === 'left' ? node.left : node.right;\n      if(!child) return;\n      // find edge with data-to = child.id\n      const edge = svg.querySelector(`line.edge[data-to=\"${child.id}\"]`);\n      if(edge) edge.classList.add('highlight');\n      // remove after a short time (handled by step flow)\n    }\n\n    function clearHighlights(){\n      const pulses = svg.querySelectorAll('circle.node-circle.pulse');\n      pulses.forEach(c => { c.classList.remove('pulse'); c.style.fill = ''; });\n      const edgeHs = svg.querySelectorAll('line.edge.highlight');\n      edgeHs.forEach(e => e.classList.remove('highlight'));\n    }\n\n    /* -------------------------\n       Traversal display\n       ------------------------- */\n\n    function updateTraversalDisplay(){\n      traversalEl.innerHTML = '';\n      const seq = [];\n      (function inorder(node){\n        if(!node) return;\n        inorder(node.left);\n        seq.push(node);\n        inorder(node.right);\n      })(root);\n      if(seq.length === 0){\n        traversalEl.textContent = '—';\n        return;\n      }\n      seq.forEach(n => {\n        const el = document.createElement('div');\n        el.className = 'chip';\n        el.textContent = n.value;\n        traversalEl.appendChild(el);\n      });\n    }\n\n    function animateTraversal(){\n      // highlight nodes in-order sequentially\n      const seq = [];\n      (function inorder(node){\n        if(!node) return;\n        inorder(node.left);\n        seq.push(node);\n        inorder(node.right);\n      })(root);\n\n      if(seq.length === 0){\n        updateStatus('Tree is empty', 'error');\n        return;\n      }\n      (async ()=>{\n        for(const n of seq){\n          highlightNode(n,'found');\n          updateStatus(`Visited ${n.value}`);\n          await sleep(Math.max(300, speedRange.value*0.5));\n          removeHighlight(n);\n        }\n        updateStatus('In-order traversal complete', 'success');\n      })();\n    }\n\n    /* -------------------------\n       Utility\n       ------------------------- */\n\n    function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }\n\n    /* -------------------------\n       Event wiring & UI\n       ------------------------- */\n\n    insertBtn.addEventListener('click', ()=>{\n      insertValuesFromInput();\n    });\n    searchBtn.addEventListener('click', ()=>{ searchValuesFromInput(); });\n    deleteBtn.addEventListener('click', ()=>{ deleteValuesFromInput(); });\n\n    clearBtn.addEventListener('click', ()=>{\n      root = null;\n      Node._id = 1;\n      render();\n      updateTraversalDisplay();\n      updateStatus('Tree cleared');\n    });\n\n    randomBtn.addEventListener('click', ()=>{\n      // create random tree with 7 values\n      root = null;\n      Node._id = 1;\n      const count = 7;\n      const vals = [];\n      while(vals.length < count){\n        const n = Math.floor(Math.random() * 99) + 1;\n        if(!vals.includes(n)) vals.push(n);\n      }\n      vals.forEach(v => {\n        // plain insertion\n        if(!root) root = new Node(v);\n        else {\n          let cur = root;\n          while(true){\n            if(v < cur.value){\n              if(!cur.left){ cur.left = new Node(v); cur.left.parent = cur; break; }\n              cur = cur.left;\n            } else {\n              if(!cur.right){ cur.right = new Node(v); cur.right.parent = cur; break; }\n              cur = cur.right;\n            }\n          }\n        }\n      });\n      render();\n      updateTraversalDisplay();\n      updateStatus('Random tree generated', 'success');\n    });\n\n    traverseBtn.addEventListener('click', ()=>{ animateTraversal(); });\n\n    stepToggle.addEventListener('click', ()=>{\n      STEP_MODE = !STEP_MODE;\n      stepToggle.setAttribute('aria-pressed', String(STEP_MODE));\n      stepToggle.style.background = STEP_MODE ? 'linear-gradient(180deg,#1b3a4a,#153243)' : '';\n      updateStatus(STEP_MODE ? 'Step mode ON — use Auto Play as Next' : 'Step mode OFF');\n    });\n\n    autoPlayBtn.addEventListener('click', ()=>{\n      // If in step mode and not auto, this acts as the \"Next\" button for step progress.\n      if(STEP_MODE){\n        // Toggle AUTO_PLAY for convenience\n        AUTO_PLAY = !AUTO_PLAY;\n        autoPlayBtn.textContent = AUTO_PLAY ? 'Auto:On' : 'Auto Play';\n        autoPlayBtn.style.background = AUTO_PLAY ? 'linear-gradient(180deg,#1a7b9a,#13667c)' : '';\n        updateStatus(AUTO_PLAY ? 'Auto-play enabled for step mode' : 'Auto-play disabled');\n      } else {\n        // If not in step mode, run a queued single \"next\" tick (no-op)\n        updateStatus('Auto Play is meaningful only in Step Mode. Toggle Step Mode to step through operations.');\n      }\n    });\n\n    speedRange.addEventListener('input', ()=>{\n      speed = parseInt(speedRange.value,10);\n    });\n\n    // keyboard shortcuts\n    document.addEventListener('keydown', (e)=>{\n      if(e.ctrlKey && e.key === 'i'){ insertValuesFromInput(); }\n      if(e.ctrlKey && e.key === 'f'){ searchValuesFromInput(); }\n      if(e.ctrlKey && e.key === 'd'){ deleteValuesFromInput(); }\n    });\n\n    // On initial load, render empty\n    render();\n    updateTraversalDisplay();\n\n    // Attach parent pointers when rendering initially (root may be created programmatically)\n    function setParentPointers(){\n      function traverse(node, parent=null){\n        if(!node) return;\n        node.parent = parent;\n        traverse(node.left, node);\n        traverse(node.right, node);\n      }\n      traverse(root, null);\n    }\n\n    // Whenever render called, ensure parent links are set\n    const originalRender = render;\n    render = function(){\n      setParentPointers();\n      originalRender();\n      updateTraversalDisplay();\n    };\n\n    // Expose for console debugging (optional)\n    window.__bst = { root, render, insertValuesFromInput };\n\n    // final small helper to ensure the newly defined render replacement works\n    render();\n\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Binary Search Tree (BST).\n\n**Project Overview:**\nTopic: Binary Search Tree (BST)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Auto-generated FSM from partial data",
      "states": [
        {
          "name": "idle\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "processing\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "comparing\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "moving\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "inserting\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "found\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "not_found\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "replacing\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        }
      ],
      "events": [
        "INSERT",
        "SEARCH",
        "DELETE",
        "TRAVERSE",
        "RANDOM",
        "CLEAR",
        "STEP_TOGGLE",
        "AUTO_TOGGLE",
        "SPEED_CHANGE",
        "NODE_CLICK",
        "NODE_KEY",
        "OP_STEP_COMPARE",
        "OP_STEP_MOVE",
        "OP_STEP_INSERT",
        "OP_STEP_FOUND",
        "OP_STEP_NOT_FOUND",
        "OP_STEP_REPLACE",
        "OP_STEP_DELETE",
        "OP_COMPLETE",
        "ERROR",
        "NEXT_STEP",
        "AUTO_TIMEOUT",
        "CANCEL",
        "AUTO_TOGGLE_ON",
        "AUTO_TOGGLE_OFF",
        "ANIMATION_COMPLETE",
        "ACK_ERROR"
      ],
      "notes": "Generated using fallback parsing due to JSON format issues"
    }
  },
  {
    "id": "6deeffc0-bde7-11f0-8591-4fc0953aab32",
    "timestamp": "2025-11-10T03:44:54.098Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "K-Nearest Neighbors (KNN)",
    "answer": {
      "role": "assistant",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>K-Nearest Neighbors — Interactive Module</title>\n  <style>\n    :root{\n      --safe-margin: 24px;\n      --gap: 16px;\n      --bg: #0f1720;\n      --panel: #0b1220;\n      --muted: #9aa7b7;\n      --accent: #60a5fa;\n      --red: #ef4444;\n      --blue: #3b82f6;\n      --query: #10b981;\n      --glass: rgba(255,255,255,0.04);\n      --card-radius: 12px;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n    *{box-sizing:border-box}\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071024 0%, #071622 60%);color:#e6eef6}\n    main{\n      padding: var(--safe-margin);\n      min-height:100%;\n      display:flex;\n      align-items:flex-start;\n      justify-content:center;\n      gap:var(--gap);\n    }\n\n    /* Layout */\n    .module{\n      width:100%;\n      max-width:1200px;\n      display:flex;\n      gap:var(--gap);\n      align-items:flex-start;\n    }\n    .left, .right{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:var(--card-radius);\n      padding:18px;\n      box-shadow: 0 6px 22px rgba(2,6,23,0.6);\n    }\n    .left{flex:1; min-width:420px; display:flex; flex-direction:column; gap:var(--gap)}\n    .right{width:380px; min-width:300px; display:flex; flex-direction:column; gap:var(--gap)}\n\n    /* Header / Title */\n    .title{\n      display:flex;\n      align-items:baseline;\n      gap:12px;\n    }\n    .title h1{font-size:20px;margin:0}\n    .subtitle{color:var(--muted); font-size:13px; margin:0}\n\n    /* Canvas area */\n    .canvas-wrap{\n      background:var(--panel);\n      border-radius:10px;\n      padding:12px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      align-items:stretch;\n    }\n    .controls{\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n      align-items:center;\n    }\n    .controls > *{min-width:0}\n    .tool-buttons{\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n    .tool-buttons button, button.control{\n      background:var(--glass);\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.04);\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      font-size:13px;\n    }\n    .tool-buttons button.active{\n      background:linear-gradient(90deg, rgba(96,165,250,0.16), rgba(16,185,129,0.06));\n      color:#e6f2ff;\n      box-shadow: 0 4px 14px rgba(96,165,250,0.08);\n    }\n    label.inline{display:inline-flex;align-items:center;gap:8px;color:var(--muted);font-size:13px}\n    .k-control{display:flex;gap:8px;align-items:center}\n    input[type=\"range\"]{width:160px}\n\n    canvas{\n      border-radius:8px;\n      width:100%;\n      height:460px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);\n      outline: 2px solid rgba(255,255,255,0.02);\n      cursor:crosshair;\n    }\n\n    /* Info / legend */\n    .legend{display:flex;gap:12px;align-items:center;flex-wrap:wrap}\n    .chip{display:inline-flex;align-items:center;gap:8px;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}\n    .dot{width:12px;height:12px;border-radius:50%}\n    .dot.red{background:var(--red)}\n    .dot.blue{background:var(--blue)}\n    .dot.query{background:var(--query)}\n\n    /* Right column text sections */\n    .panel{\n      background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));\n      padding:14px;\n      border-radius:10px;\n      color:var(--muted);\n      font-size:14px;\n      line-height:1.4;\n    }\n    h3{margin:0 0 8px 0;font-size:15px}\n    p.small{font-size:13px;color:var(--muted);margin:6px 0}\n\n    /* Result badge */\n    .result{\n      display:flex;\n      align-items:center;\n      justify-content:space-between;\n      gap:12px;\n    }\n    .result .big{\n      font-size:20px;\n      font-weight:600;\n    }\n    .result .badge{\n      padding:8px 12px;border-radius:8px;color:white;font-weight:600;\n    }\n    .badge.red{background:linear-gradient(90deg,#ff6b6b,#ef4444)}\n    .badge.blue{background:linear-gradient(90deg,#60a5fa,#3b82f6)}\n    .badge.unknown{background:linear-gradient(90deg,#9ca3ff,#a78bfa)}\n\n    /* small footer */\n    .hint{font-size:13px;color:var(--muted)}\n\n    /* responsiveness */\n    @media (max-width:980px){\n      .module{flex-direction:column}\n      .left,.right{width:100%}\n      canvas{height:360px}\n    }\n\n  </style>\n</head>\n<body>\n  <main>\n    <div class=\"module\" role=\"application\" aria-label=\"Interactive K-Nearest Neighbors module\">\n      <!-- LEFT: interactive canvas and controls -->\n      <section class=\"left\" aria-labelledby=\"title\">\n        <div class=\"title\" id=\"title\">\n          <div>\n            <h1>K-Nearest Neighbors (KNN) — Interactive Visualizer</h1>\n            <p class=\"subtitle\">Explore classification by adjusting K and placing points.</p>\n          </div>\n        </div>\n\n        <div class=\"canvas-wrap\" role=\"region\" aria-label=\"Interactive canvas and controls\">\n          <div class=\"controls\" role=\"toolbar\" aria-label=\"Tools\">\n            <div class=\"tool-buttons\" role=\"group\" aria-label=\"Point tools\">\n              <button id=\"tool-move\" class=\"control active\" title=\"Move points (default)\">Move</button>\n              <button id=\"tool-red\" class=\"control\" title=\"Add red class point\">Add Red</button>\n              <button id=\"tool-blue\" class=\"control\" title=\"Add blue class point\">Add Blue</button>\n              <button id=\"tool-query\" class=\"control\" title=\"Place query point\">Place Query</button>\n              <button id=\"tool-delete\" class=\"control\" title=\"Delete point\">Delete</button>\n            </div>\n\n            <div style=\"flex:1\"></div>\n\n            <div class=\"k-control\" aria-label=\"K selector\">\n              <label class=\"inline\" for=\"kRange\" style=\"white-space:nowrap\">k</label>\n              <input type=\"range\" id=\"kRange\" min=\"1\" max=\"7\" value=\"3\" aria-valuemin=\"1\" aria-valuemax=\"15\" aria-valuenow=\"3\">\n              <div id=\"kValue\" class=\"chip\" style=\"min-width:48px;justify-content:center\">3</div>\n            </div>\n\n            <div style=\"display:flex;gap:12px;align-items:center\">\n              <label class=\"inline\" aria-label=\"Distance metric\">Metric:\n                <select id=\"metric\" style=\"margin-left:8px;padding:6px;border-radius:8px;background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04)\">\n                  <option value=\"euclid\">Euclidean</option>\n                  <option value=\"manhattan\">Manhattan</option>\n                </select>\n              </label>\n            </div>\n\n          </div>\n\n          <canvas id=\"knnCanvas\" width=\"840\" height=\"600\" role=\"img\" aria-label=\"KNN scatter plot\"></canvas>\n\n          <div style=\"display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap\">\n            <div class=\"legend\" aria-hidden=\"true\">\n              <div class=\"chip\"><span class=\"dot red\"></span> Class A</div>\n              <div class=\"chip\"><span class=\"dot blue\"></span> Class B</div>\n              <div class=\"chip\"><span class=\"dot query\"></span> Query</div>\n            </div>\n\n            <div style=\"display:flex;gap:12px;align-items:center\">\n              <button id=\"clearButton\" class=\"control\" title=\"Reset all points\">Clear</button>\n              <div class=\"hint\">Tip: Drag points to reposition. Press Delete to remove selected point.</div>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"panel\" aria-live=\"polite\">\n          <h3>Live Info</h3>\n          <p class=\"small\" id=\"liveText\">Place training points and a query point to see KNN classification. Neighbors are highlighted and decision region updates automatically.</p>\n        </div>\n      </section>\n\n      <!-- RIGHT: Explanations, objectives, interaction design, layout description -->\n      <aside class=\"right\" aria-labelledby=\"conceptTitle\">\n        <div class=\"panel\" id=\"conceptTitle\">\n          <h3>Concept Title</h3>\n          <p class=\"small\">K-Nearest Neighbors (KNN) — a simple instance-based classifier that assigns a label to a query based on the labels of the k closest training examples.</p>\n        </div>\n\n        <div class=\"panel\">\n          <h3>Learning Objective</h3>\n          <p class=\"small\">After interacting with this module you will be able to:\n            - see how changing k affects classification,\n            - observe how distance metrics influence neighbors,\n            - and intuitively understand the trade-off between local sensitivity (small k) and smoothing (large k).\n          </p>\n        </div>\n\n        <div class=\"panel\">\n          <h3>Interaction Design</h3>\n          <p class=\"small\">\n            Controls:\n            - Select a tool: Move, Add Red, Add Blue, Place Query, or Delete.\n            - Click on the canvas to add points (in add modes) or place the query.\n            - Drag training points to reposition them in Move mode.\n            - Use the k slider to change the number of neighbors considered.\n            - Choose Euclidean or Manhattan distance to see different neighbor shapes.\n          </p>\n          <p class=\"small\">\n            Visual feedback:\n            - The canvas displays a colored decision region (red/blue) computed by voting among the k nearest training points.\n            - The k nearest neighbors to the query are connected with lines and given an animated pulse.\n            - The classification result is shown in the Result badge below.\n            - Animations and gradual color transitions reinforce how local points influence the decision.\n          </p>\n        </div>\n\n        <div class=\"panel\">\n          <h3>Layout Description</h3>\n          <p class=\"small\">\n            Spatial organization:\n            - Left column: interactive area (controls above, canvas large in middle, legend and actions below).\n            - Right column: instructional panels (title, objective, interaction details).\n            - Safe margins of 24px on all sides; internal gaps of at least 16px between controls.\n            - Controls grouped by function with clear visual affordances; canvas uses high contrast markers and large hit targets for accessibility.\n            - Responsive: columns stack on narrow screens, canvas height reduces for smaller devices.\n          </p>\n        </div>\n\n        <div class=\"panel\">\n          <h3>Result</h3>\n          <div class=\"result\" aria-live=\"polite\">\n            <div>\n              <div class=\"big\" id=\"resultLabel\">No query</div>\n              <div class=\"small\" id=\"resultDetail\" style=\"color:var(--muted)\">Place a query point to classify it.</div>\n            </div>\n            <div id=\"resultBadge\" class=\"badge unknown\">—</div>\n          </div>\n        </div>\n\n      </aside>\n    </div>\n  </main>\n\n  <script>\n    // Interactive KNN Visualizer (vanilla JS)\n    // Strict but straightforward implementation. No libraries.\n    (function(){\n      // Layout & constraints\n      const canvas = document.getElementById('knnCanvas');\n      const ctx = canvas.getContext('2d');\n      // For device pixel ratio crispness\n      function setupCanvasSize() {\n        const ratio = Math.min(window.devicePixelRatio || 1, 2);\n        const style = window.getComputedStyle(canvas);\n        const cssW = parseInt(style.width);\n        const cssH = parseInt(style.height);\n        canvas.width = Math.round(cssW * ratio);\n        canvas.height = Math.round(cssH * ratio);\n        ctx.setTransform(ratio,0,0,ratio,0,0);\n      }\n      setupCanvasSize();\n      window.addEventListener('resize', () => { setupCanvasSize(); draw(); });\n\n      // State\n      let training = []; // {id,x,y,label} label: 'red'|'blue'\n      let query = null; // {x,y}\n      let selectedPointId = null;\n      let dragging = null;\n      let mouseDown = false;\n\n      const tools = {\n        MOVE: 'move', RED: 'red', BLUE: 'blue', QUERY: 'query', DELETE: 'delete'\n      };\n      let currentTool = tools.MOVE;\n\n      // UI elements\n      const btnMove = document.getElementById('tool-move');\n      const btnRed = document.getElementById('tool-red');\n      const btnBlue = document.getElementById('tool-blue');\n      const btnQuery = document.getElementById('tool-query');\n      const btnDelete = document.getElementById('tool-delete');\n      const clearButton = document.getElementById('clearButton');\n      const kRange = document.getElementById('kRange');\n      const kValue = document.getElementById('kValue');\n      const metricSelect = document.getElementById('metric');\n      const liveText = document.getElementById('liveText');\n      const resultLabel = document.getElementById('resultLabel');\n      const resultDetail = document.getElementById('resultDetail');\n      const resultBadge = document.getElementById('resultBadge');\n\n      function setTool(toolButton, toolName) {\n        [btnMove, btnRed, btnBlue, btnQuery, btnDelete].forEach(b => b.classList.remove('active'));\n        toolButton.classList.add('active');\n        currentTool = toolName;\n        canvas.style.cursor = (toolName === tools.MOVE) ? 'grab' : 'crosshair';\n        if (toolName === tools.DELETE) canvas.style.cursor = 'not-allowed';\n      }\n\n      btnMove.addEventListener('click', () => setTool(btnMove, tools.MOVE));\n      btnRed.addEventListener('click', () => setTool(btnRed, tools.RED));\n      btnBlue.addEventListener('click', () => setTool(btnBlue, tools.BLUE));\n      btnQuery.addEventListener('click', () => setTool(btnQuery, tools.QUERY));\n      btnDelete.addEventListener('click', () => setTool(btnDelete, tools.DELETE));\n      clearButton.addEventListener('click', () => {\n        training = []; query = null; selectedPointId = null; updateKMax(); draw(); updateResult();\n      });\n\n      // K control\n      function updateKMax(){\n        const max = Math.max(1, training.length);\n        kRange.max = Math.max(1, Math.min(25, max));\n        if (Number(kRange.value) > kRange.max) kRange.value = kRange.max;\n        kValue.textContent = kRange.value;\n        kRange.setAttribute('aria-valuemax', kRange.max);\n        kRange.setAttribute('aria-valuenow', kRange.value);\n      }\n      kRange.addEventListener('input', ()=>{ kValue.textContent = kRange.value; kRange.setAttribute('aria-valuenow', kRange.value); draw(); updateResult(); });\n      metricSelect.addEventListener('change', ()=> { draw(); updateResult(); });\n\n      // Utility\n      function canvasPos(evt){\n        const rect = canvas.getBoundingClientRect();\n        return {\n          x: (evt.clientX - rect.left),\n          y: (evt.clientY - rect.top)\n        };\n      }\n\n      // Point helpers\n      let idCounter = 1;\n      function addTraining(x,y,label){\n        training.push({id: idCounter++, x, y, label});\n        updateKMax();\n        draw();\n      }\n      function setQuery(x,y){ query = {x,y}; draw(); updateResult(); }\n\n      function findPointAt(x,y, radius=10){\n        // search training points first (topmost = last)\n        for(let i=training.length-1;i>=0;i--){\n          const p = training[i];\n          const dx = p.x - x, dy = p.y - y;\n          if (Math.hypot(dx,dy) <= radius) return {type:'train', point:p};\n        }\n        if (query){\n          const dx = query.x - x, dy = query.y - y;\n          if (Math.hypot(dx,dy) <= radius) return {type:'query', point:query};\n        }\n        return null;\n      }\n\n      // Distance functions\n      function dist(a,b, metric){\n        const dx = a.x - b.x, dy = a.y - b.y;\n        if (metric === 'manhattan') return Math.abs(dx)+Math.abs(dy);\n        return Math.hypot(dx,dy);\n      }\n\n      // Nearest neighbors\n      function kNearest(q, k, metric){\n        if (!q) return [];\n        const arr = training.map(p => ({p, d: dist(p,q,metric)}));\n        arr.sort((a,b)=>a.d-b.d);\n        return arr.slice(0,k);\n      }\n\n      // Decision region computation: sample grid and compute majority among k nearest.\n      // Compute a coarse grid for performance.\n      function computeDecisionGrid(cellSize = 6){\n        const w = canvas.clientWidth, h = canvas.clientHeight;\n        const cols = Math.ceil(w / cellSize), rows = Math.ceil(h / cellSize);\n        const grid = new Uint8Array(cols*rows); // 0 none, 1 red, 2 blue, 3 tie\n        const metric = metricSelect.value;\n        const k = Math.max(1, Math.min(parseInt(kRange.value), Math.max(1, training.length)));\n        if (training.length === 0) return {cols,rows,cellSize,grid};\n        for (let r=0;r<rows;r++){\n          for (let c=0;c<cols;c++){\n            const x = c*cellSize + cellSize/2;\n            const y = r*cellSize + cellSize/2;\n            // vote by k nearest\n            const arr = training.map(p=>({label:p.label,d:dist({x,y},p,metric)}));\n            arr.sort((a,b)=>a.d-b.d);\n            const counts = {red:0,blue:0};\n            for (let i=0;i<k && i<arr.length;i++) counts[arr[i].label]++;\n            let val = 0;\n            if (counts.red > counts.blue) val = 1;\n            else if (counts.blue > counts.red) val = 2;\n            else val = 3; // tie/unknown\n            grid[r*cols + c] = val;\n          }\n        }\n        return {cols,rows,cellSize,grid};\n      }\n\n      // Rendering\n      let animTime = 0;\n      function draw(time){\n        if (time) animTime = time/1000;\n        const w = canvas.clientWidth, h = canvas.clientHeight;\n        ctx.clearRect(0,0,w,h);\n\n        // Decision region\n        const gridData = computeDecisionGrid(6);\n        const {cols,rows,cellSize,grid} = gridData;\n        for (let r=0;r<rows;r++){\n          for (let c=0;c<cols;c++){\n            const val = grid[r*cols + c];\n            if (val === 0) continue;\n            const x = c*cellSize, y = r*cellSize;\n            if (val === 1) ctx.fillStyle = 'rgba(239,68,68,0.08)'; // red pastel\n            else if (val === 2) ctx.fillStyle = 'rgba(59,130,246,0.08)';\n            else ctx.fillStyle = 'rgba(156,163,175,0.04)'; // tie = grayish\n            ctx.fillRect(x, y, cellSize+1, cellSize+1);\n          }\n        }\n\n        // Axes grid lines (subtle)\n        ctx.strokeStyle = 'rgba(255,255,255,0.02)';\n        ctx.lineWidth = 1;\n        for (let x=0;x<w;x+=60){\n          ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,h); ctx.stroke();\n        }\n        for (let y=0;y<h;y+=60){\n          ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(w,y+0.5); ctx.stroke();\n        }\n\n        // Draw training points\n        for (let p of training){\n          drawPoint(p.x,p.y, p.label === 'red' ? '#ef4444' : '#3b82f6', 8, p.id === selectedPointId);\n        }\n\n        // If query exists, compute neighbors\n        if (query){\n          // draw lines to k nearest\n          const k = Math.max(1, Math.min(parseInt(kRange.value), Math.max(1, training.length)));\n          const metric = metricSelect.value;\n          const neighbors = kNearest(query, k, metric);\n          // Draw neighbor lines\n          for (let i=0;i<neighbors.length;i++){\n            const item = neighbors[i];\n            ctx.strokeStyle = (item.p.label === 'red') ? 'rgba(239,68,68,0.9)' : 'rgba(59,130,246,0.9)';\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            ctx.moveTo(query.x, query.y);\n            ctx.lineTo(item.p.x, item.p.y);\n            ctx.stroke();\n            // animated pulse at neighbor\n            const pulse = 6 + 4*Math.abs(Math.sin(animTime*3 + i));\n            ctx.beginPath();\n            ctx.strokeStyle = (item.p.label === 'red') ? 'rgba(239,68,68,0.22)' : 'rgba(59,130,246,0.22)';\n            ctx.lineWidth = 2;\n            ctx.arc(item.p.x, item.p.y, 12 + pulse, 0, Math.PI*2);\n            ctx.stroke();\n          }\n\n          // Draw query point big\n          ctx.beginPath();\n          ctx.fillStyle = 'rgba(16,185,129,0.12)';\n          ctx.arc(query.x, query.y, 18, 0, Math.PI*2);\n          ctx.fill();\n\n          ctx.beginPath();\n          ctx.fillStyle = '#10b981';\n          ctx.strokeStyle = '#0b6b4a';\n          ctx.lineWidth = 2;\n          ctx.arc(query.x, query.y, 8, 0, Math.PI*2);\n          ctx.fill();\n          ctx.stroke();\n        }\n\n        // Bring points to top (draw outlines)\n        for (let p of training){\n          ctx.beginPath();\n          ctx.strokeStyle = 'rgba(0,0,0,0.45)';\n          ctx.lineWidth = 2;\n          ctx.arc(p.x, p.y, 9, 0, Math.PI*2);\n          ctx.stroke();\n        }\n\n        // Selected point highlight\n        if (selectedPointId){\n          const p = training.find(pp=>pp.id===selectedPointId);\n          if (p){\n            ctx.beginPath();\n            ctx.strokeStyle = 'rgba(96,165,250,0.9)';\n            ctx.lineWidth = 2;\n            ctx.arc(p.x, p.y, 14, 0, Math.PI*2);\n            ctx.stroke();\n          }\n        }\n\n        // overlay text for small training counts\n        if (training.length === 0){\n          ctx.fillStyle = 'rgba(255,255,255,0.06)';\n          ctx.font = '14px Inter, Arial';\n          ctx.fillText('No training points yet — add red/blue points to explore.', 14, 20);\n        }\n\n        // schedule next frame for animation\n        requestAnimationFrame(draw);\n      }\n\n      function drawPoint(x,y,color,radius, selected=false){\n        ctx.beginPath();\n        ctx.fillStyle = color;\n        ctx.arc(x,y, radius, 0, Math.PI*2);\n        ctx.fill();\n      }\n\n      // Interaction: mouse events\n      canvas.addEventListener('mousedown', (e)=>{\n        mouseDown = true;\n        const pos = canvasPos(e);\n        if (currentTool === tools.MOVE){\n          const hit = findPointAt(pos.x,pos.y, 12);\n          if (hit && hit.type === 'train'){\n            dragging = hit.point;\n            selectedPointId = hit.point.id;\n            canvas.style.cursor = 'grabbing';\n          } else if (hit && hit.type === 'query'){\n            dragging = query; selectedPointId = null; canvas.style.cursor = 'grabbing';\n          } else {\n            selectedPointId = null;\n          }\n          draw();\n          updateResult();\n        } else if (currentTool === tools.RED || currentTool === tools.BLUE){\n          addTraining(pos.x,pos.y, currentTool === tools.RED ? 'red' : 'blue');\n        } else if (currentTool === tools.QUERY){\n          setQuery(pos.x,pos.y);\n        } else if (currentTool === tools.DELETE){\n          const hit = findPointAt(pos.x,pos.y, 12);\n          if (hit){\n            if (hit.type === 'train'){\n              training = training.filter(p=>p.id !== hit.point.id);\n            } else if (hit.type === 'query'){\n              query = null;\n            }\n            selectedPointId = null;\n            updateKMax(); draw(); updateResult();\n          }\n        }\n      });\n\n      canvas.addEventListener('mousemove', (e)=>{\n        const pos = canvasPos(e);\n        if (dragging && mouseDown){\n          dragging.x = pos.x;\n          dragging.y = pos.y;\n          draw();\n          updateResult();\n        }\n      });\n\n      window.addEventListener('mouseup', (e)=>{\n        mouseDown = false;\n        if (dragging) {\n          dragging = null; canvas.style.cursor = currentTool === tools.MOVE ? 'grab' : 'crosshair';\n        }\n      });\n\n      // Keyboard: delete selected training point when selected\n      window.addEventListener('keydown', (e)=>{\n        if (e.key === 'Delete' || e.key === 'Backspace'){\n          if (selectedPointId){\n            training = training.filter(p=>p.id !== selectedPointId);\n            selectedPointId = null;\n            updateKMax(); draw(); updateResult();\n          } else if (query){\n            query = null; draw(); updateResult();\n          }\n        }\n      });\n\n      // Update result panel\n      function updateResult(){\n        if (!query){\n          resultLabel.textContent = 'No query';\n          resultDetail.textContent = 'Place a query point to classify it.';\n          resultBadge.textContent = '—';\n          resultBadge.className = 'badge unknown';\n          return;\n        }\n        if (training.length === 0){\n          resultLabel.textContent = 'No training points';\n          resultDetail.textContent = 'Add some red/blue training points.';\n          resultBadge.textContent = '—';\n          resultBadge.className = 'badge unknown';\n          return;\n        }\n        const metric = metricSelect.value;\n        const k = Math.max(1, Math.min(parseInt(kRange.value), Math.max(1, training.length)));\n        const neighbors = kNearest(query, k, metric);\n        const counts = {red:0,blue:0};\n        for (let n of neighbors) counts[n.p.label]++;\n        let label = null; let certainty = 0;\n        if (counts.red > counts.blue){ label='Red (A)'; resultBadge.className='badge red'; resultBadge.textContent='A'; }\n        else if (counts.blue > counts.red){ label='Blue (B)'; resultBadge.className='badge blue'; resultBadge.textContent='B'; }\n        else { label='Tie/Undecided'; resultBadge.className='badge unknown'; resultBadge.textContent='?'; }\n        // compute distances for detail\n        const dstr = neighbors.slice(0,Math.min(5,neighbors.length)).map(n => `${n.p.label.charAt(0).toUpperCase()}:${n.d.toFixed(1)}`).join(', ');\n        resultLabel.textContent = label;\n        resultDetail.textContent = `k=${k} · metric=${metric} · neighbors: ${dstr}`;\n      }\n\n      // Initial seeds for demonstration\n      function seedDemo(){\n        training = [];\n        addTraining(120,150,'red'); addTraining(160,220,'red'); addTraining(200,120,'red');\n        addTraining(420,360,'blue'); addTraining(500,320,'blue'); addTraining(480,380,'blue');\n        setQuery(320,240);\n      }\n\n      // Hook up UI initial states\n      setTool(btnMove, tools.MOVE);\n      updateKMax();\n      seedDemo();\n      updateKMax();\n      // Start animation loop\n      requestAnimationFrame(draw);\n      // Update result panel whenever controls change\n      kRange.addEventListener('input', updateResult);\n      metricSelect.addEventListener('change', updateResult);\n\n      // Periodic update for result to reflect animation changes and neighbor changes\n      setInterval(updateResult, 200);\n\n      // Accessibility notes: allow keyboard to switch tools (1-5)\n      window.addEventListener('keydown', (e)=>{\n        if (e.key === '1') setTool(btnMove, tools.MOVE);\n        if (e.key === '2') setTool(btnRed, tools.RED);\n        if (e.key === '3') setTool(btnBlue, tools.BLUE);\n        if (e.key === '4') setTool(btnQuery, tools.QUERY);\n        if (e.key === '5') setTool(btnDelete, tools.DELETE);\n      });\n\n      // Expose draw for debug (not necessary)\n      window._knn = {training, setQuery, addTraining, draw};\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of K-Nearest Neighbors (KNN).\n\n**Project Overview:**\nTopic: K-Nearest Neighbors (KNN)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization — placement of text, controls, and visuals — including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** — using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "K-Nearest Neighbors (KNN)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Auto-generated FSM from partial data",
      "states": [
        {
          "name": "init\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "mode_move_idle\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "mode_add_red\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "mode_add_blue\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "mode_place_query\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "mode_delete\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "dragging_training\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        },
        {
          "name": "dragging_query\\",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {}
        }
      ],
      "events": [
        "INITIALIZE",
        "SEED_DEMO",
        "TOOL_MOVE_CLICK",
        "TOOL_RED_CLICK",
        "TOOL_BLUE_CLICK",
        "TOOL_QUERY_CLICK",
        "TOOL_DELETE_CLICK",
        "CANVAS_MOUSEDOWN_TRAIN",
        "CANVAS_MOUSEDOWN_QUERY",
        "CANVAS_MOUSEDOWN_EMPTY",
        "KEY_DELETE_PRESS",
        "CLEAR_CLICK",
        "K_RANGE_CHANGE",
        "METRIC_CHANGE",
        "WINDOW_RESIZE",
        "TIMER_TICK",
        "RESULT_COMPUTED_RED",
        "RESULT_COMPUTED_BLUE",
        "RESULT_COMPUTED_TIE",
        "RESULT_NO_QUERY",
        "RESULT_NO_TRAINING",
        "ADD_TRAINING_RED",
        "ADD_TRAINING_BLUE",
        "SET_QUERY_POINT",
        "DELETE_TRAINING_POINT",
        "DELETE_QUERY_POINT",
        "CANVAS_MOUSEMOVE",
        "CANVAS_MOUSEUP"
      ],
      "notes": "Generated using fallback parsing due to JSON format issues"
    }
  }
]