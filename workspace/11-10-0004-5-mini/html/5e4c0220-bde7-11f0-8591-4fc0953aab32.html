<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Bubble Sort</title>
  <style>
    :root{
      --gap:16px;
      --safe:24px;
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#3b82f6;
      --muted:#94a3b8;
      --success:#10b981;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{
      height:100%;
      margin:0;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.02), transparent 30%),
        var(--bg);
      color:#e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    /* Safe area margins: 24px */
    .app {
      padding:var(--safe);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      align-items:flex-start;
      justify-content:center;
    }
    .module {
      width:100%;
      max-width:1200px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:24px;
      box-sizing:border-box;
      box-shadow: 0 10px 30px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    /* Header */
    .header {
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      justify-content:space-between;
    }
    .title {
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .title h1{
      margin:0;
      font-size:20px;
      letter-spacing: -0.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:13px;
      max-width:760px;
    }

    /* Main layout: two columns on wide, stacked on narrow */
    .main {
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
    }
    .col {
      background:var(--glass);
      border-radius:10px;
      padding:16px;
      box-sizing:border-box;
    }
    .left {
      flex:0 0 360px;
      min-width:280px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .right {
      flex:1 1 auto;
      min-height:320px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    /* Controls */
    .controls {
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .row {
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    label {
      font-size:13px;
      color:var(--muted);
    }
    input[type="text"], input[type="number"], .btn, select {
      background:rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.04);
      color:inherit;
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      outline:none;
    }
    input[type="range"]{
      width:160px;
    }
    .btn {
      cursor:pointer;
      user-select:none;
      transition:all .12s ease;
      display:inline-flex;
      gap:8px;
      align-items:center;
      justify-content:center;
    }
    .btn.primary{
      background:linear-gradient(90deg,var(--accent),#60a5fa);
      color:#021124;
      border:0;
      padding:8px 12px;
      border-radius:10px;
      font-weight:600;
    }
    .btn.ghost{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      padding:8px 10px;
      border-radius:8px;
    }
    .btn:disabled{ opacity:0.45; cursor:not-allowed; transform:none; }

    /* Stats */
    .stats {
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }
    .stat {
      background:rgba(255,255,255,0.02);
      padding:8px 12px;
      border-radius:10px;
      font-size:13px;
      color:var(--muted);
      min-width:84px;
      text-align:center;
    }
    .stat strong{ display:block; color:#e6eef8; font-size:15px; }

    /* Visualization */
    .viz {
      position:relative;
      background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent);
      border-radius:10px;
      padding:16px;
      min-height:320px;
      overflow:hidden;
    }
    .bar-area {
      position:relative;
      height:240px;
      margin-top:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      border-radius:8px;
    }
    .bar {
      position:absolute;
      bottom:10px;
      width:40px;
      background:linear-gradient(180deg,#60a5fa,#2563eb);
      border-radius:6px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:#021124;
      font-weight:700;
      font-size:12px;
      box-shadow: 0 6px 14px rgba(37,99,235,0.18);
      transition: left var(--anim,300ms) ease, transform var(--anim,300ms) ease, height var(--anim,300ms) ease, background-color 120ms ease;
      cursor:pointer;
    }
    .bar .label{
      background:rgba(255,255,255,0.85);
      padding:2px 6px;
      border-radius:6px;
      transform:translateY(6px);
      font-weight:700;
      font-size:11px;
    }
    .bar.compare {
      box-shadow: 0 12px 30px rgba(59,130,246,0.18);
      transform:translateY(-8px);
      background:linear-gradient(180deg,#93c5fd,#3b82f6);
    }
    .bar.swap {
      background:linear-gradient(180deg,#fb7185,#ef4444);
      box-shadow: 0 12px 30px rgba(239,68,68,0.18);
    }
    .bar.sorted {
      background:linear-gradient(180deg,#10b981,#059669);
      box-shadow: 0 8px 20px rgba(16,185,129,0.12);
      color:#e6fff4;
    }
    .indices {
      display:flex;
      justify-content:space-between;
      margin-top:8px;
      color:var(--muted);
      font-size:12px;
    }

    /* Pseudocode box */
    .code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      background:rgba(2,6,23,0.6);
      border:1px solid rgba(255,255,255,0.03);
      padding:12px;
      border-radius:8px;
      font-size:13px;
      color:var(--muted);
      max-height:200px;
      overflow:auto;
    }
    .code .line {
      padding:6px 8px;
      border-radius:6px;
      margin-bottom:6px;
    }
    .code .line.current {
      background:linear-gradient(90deg, rgba(59,130,246,0.12), rgba(59,130,246,0.04));
      color:#e6eef8;
      border:1px solid rgba(59,130,246,0.15);
    }

    /* Footer help */
    .help {
      color:var(--muted);
      font-size:13px;
    }

    /* Responsive */
    @media (max-width:900px){
      .main{
        flex-direction:column;
      }
      .left{ width:100%; min-width:unset; flex:unset;}
      .right{ width:100%; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="module" role="main" aria-label="Bubble Sort Interactive Module">
      <div class="header">
        <div class="title">
          <h1>Bubble Sort — Visual, Step-by-Step</h1>
          <p class="subtitle">Watch adjacent elements being compared and swapped. Step through the algorithm or play it, change speed and array, and see an early-exit optimization in action.</p>
        </div>
        <div style="display:flex;flex-direction:column;gap:8px;align-items:flex-end">
          <div style="color:var(--muted);font-size:13px;text-align:right">Concept<strong style="display:block;color:#e6eef8">Bubble Sort</strong></div>
          <div style="color:var(--muted);font-size:13px;text-align:right">Objective<strong style="display:block;color:#e6eef8">Understand comparisons, swaps, passes, and optimization</strong></div>
        </div>
      </div>

      <div class="main">
        <!-- LEFT COLUMN: Controls & explanation -->
        <div class="col left" aria-label="Controls and explanation">
          <div class="controls">
            <div>
              <label for="size">Array size: <span id="sizeLabel">8</span></label>
              <div class="row" style="margin-top:8px;">
                <input id="size" type="range" min="3" max="20" value="8" />
                <button id="randBtn" class="btn ghost" title="Generate random array">Random</button>
                <button id="sortedBtn" class="btn ghost" title="Generate sorted array">Sorted</button>
                <button id="revBtn" class="btn ghost" title="Generate reverse-sorted array">Reverse</button>
              </div>
            </div>

            <div>
              <label for="custom">Custom array (comma separated)</label>
              <div class="row" style="margin-top:8px;">
                <input id="custom" type="text" placeholder="e.g., 5,3,8,1,4" aria-label="Custom array input"/>
                <button id="loadBtn" class="btn primary" title="Load custom array">Load</button>
              </div>
            </div>

            <div>
              <label>Playback</label>
              <div class="row" style="margin-top:8px;">
                <button id="playBtn" class="btn primary" title="Play / Pause">Play</button>
                <button id="stepBtn" class="btn ghost" title="Step one comparison/swap">Step</button>
                <button id="resetBtn" class="btn ghost" title="Reset algorithm">Reset</button>
                <label style="display:inline-flex;align-items:center;gap:8px;">
                  <input id="optimize" type="checkbox" checked /> Optimized
                </label>
              </div>
            </div>

            <div>
              <label>Speed</label>
              <div class="row" style="margin-top:8px;">
                <input id="speed" type="range" min="50" max="1200" value="400" />
                <div style="color:var(--muted);font-size:13px;margin-left:8px;">Delay: <span id="speedLabel">400ms</span></div>
              </div>
            </div>

            <div>
              <label>Statistics</label>
              <div class="row stats" style="margin-top:8px;">
                <div class="stat"><div>Comparisons</div><strong id="cmp">0</strong></div>
                <div class="stat"><div>Swaps</div><strong id="swp">0</strong></div>
                <div class="stat"><div>Passes</div><strong id="pass">0</strong></div>
              </div>
            </div>

            <div>
              <label>Pseudocode</label>
              <div class="code" id="pseudocode" aria-hidden="false">
                <div class="line" data-line="1">for i from 0 to n-1:</div>
                <div class="line" data-line="2">  swapped = false</div>
                <div class="line" data-line="3">  for j from 0 to n-2-i:</div>
                <div class="line" data-line="4">    if arr[j] > arr[j+1]:</div>
                <div class="line" data-line="5">      swap arr[j] and arr[j+1]</div>
                <div class="line" data-line="6">      swapped = true</div>
                <div class="line" data-line="7">  if not swapped: break  # array is sorted</div>
              </div>
            </div>

            <div>
              <label>How to interact</label>
              <div class="help">Click Play to animate; use Step to move one comparison at a time. Click a bar to edit its value. You can load a custom CSV, generate random/sorted/reverse arrays, or change size and speed.</div>
            </div>
          </div>
        </div>

        <!-- RIGHT COLUMN: Visualization -->
        <div class="col right" aria-label="Visualization">
          <div class="viz">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div style="font-size:14px;color:var(--muted)">Visualization</div>
              <div style="display:flex;gap:12px;align-items:center;">
                <div style="font-size:13px;color:var(--muted)">Comparing <strong id="curPair" style="color:#e6eef8">—</strong></div>
                <div style="font-size:13px;color:var(--muted)">Mode <strong id="modeLabel" style="color:#e6eef8">Optimized</strong></div>
              </div>
            </div>

            <div class="bar-area" id="barArea" tabindex="0" aria-label="Array bars area" role="region">
              <!-- Bars rendered here -->
            </div>

            <div class="indices" aria-hidden="true">
              <div>Left: index 0</div>
              <div>Right: index <span id="maxIndex">n-1</span></div>
            </div>
          </div>

        </div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;gap:var(--gap)">
        <div style="color:var(--muted);font-size:13px">Tip: Try a reverse array to see worst-case swaps.</div>
        <div style="color:var(--muted);font-size:13px">Built with plain HTML, CSS, and JavaScript.</div>
      </div>
    </div>
  </div>

  <script>
    (function(){
      // DOM references
      const barArea = document.getElementById('barArea');
      const sizeRange = document.getElementById('size');
      const sizeLabel = document.getElementById('sizeLabel');
      const randBtn = document.getElementById('randBtn');
      const sortedBtn = document.getElementById('sortedBtn');
      const revBtn = document.getElementById('revBtn');
      const loadBtn = document.getElementById('loadBtn');
      const customInput = document.getElementById('custom');
      const playBtn = document.getElementById('playBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');
      const speedInput = document.getElementById('speed');
      const speedLabel = document.getElementById('speedLabel');
      const optimizeCheck = document.getElementById('optimize');
      const cmpEl = document.getElementById('cmp');
      const swpEl = document.getElementById('swp');
      const passEl = document.getElementById('pass');
      const curPair = document.getElementById('curPair');
      const modeLabel = document.getElementById('modeLabel');
      const pseudocode = document.getElementById('pseudocode');
      const maxIndexEl = document.getElementById('maxIndex');

      // State
      let arr = [];
      let bars = []; // DOM elements
      let positions = []; // current x positions
      let animating = false;
      let running = false;
      let timer = null;
      let speed = parseInt(speedInput.value,10); // ms
      let comparisons = 0;
      let swaps = 0;
      let passes = 0;

      // Bubble pointers
      let n = 8;
      let i = 0; // pass
      let j = 0; // index inside pass
      let optimized = optimizeCheck.checked;
      let swappedInPass = false;

      // Layout constants
      const paddingLR = 16; // left padding of bar area
      const barWidth = 40;
      const gap = 8; // gap between bars
      const minValue = 1;
      const maxValue = 100;

      // Initialize
      function init(){
        sizeLabel.textContent = n;
        maxIndexEl.textContent = n-1;
        speedLabel.textContent = speed + 'ms';
        modeLabel.textContent = optimized ? 'Optimized' : 'Standard';
        bind();
        generateRandom(n);
      }

      function bind(){
        sizeRange.addEventListener('input', (e)=>{
          n = parseInt(e.target.value,10);
          sizeLabel.textContent = n;
          sizeRange.value = n;
        });
        sizeRange.addEventListener('change', ()=>{
          resetAll();
          generateRandom(n);
        });
        randBtn.addEventListener('click', ()=>{ resetAll(); generateRandom(n); });
        sortedBtn.addEventListener('click', ()=>{ resetAll(); generateSorted(n); });
        revBtn.addEventListener('click', ()=>{ resetAll(); generateReverse(n); });
        loadBtn.addEventListener('click', ()=>{ loadCustom(); });
        playBtn.addEventListener('click', togglePlay);
        stepBtn.addEventListener('click', stepOnce);
        resetBtn.addEventListener('click', resetAll);
        speedInput.addEventListener('input', (e)=>{ speed = parseInt(e.target.value,10); speedLabel.textContent = speed + 'ms'; });
        optimizeCheck.addEventListener('change', (e)=>{ optimized = e.target.checked; modeLabel.textContent = optimized ? 'Optimized' : 'Standard'; });
        barArea.addEventListener('keydown', (e)=>{ if(e.key===' '){ e.preventDefault(); togglePlay(); } });
        // pseudocode clicks: not interactive, but allow highlighting programmatically
      }

      function generateRandom(size){
        arr = Array.from({length:size}, ()=> randomInt(minValue, maxValue));
        n = arr.length;
        resetPointers();
        render();
      }
      function generateSorted(size){
        arr = Array.from({length:size}, (_,k)=> Math.round((k+1) * (maxValue/size)));
        n = arr.length;
        resetPointers();
        render();
      }
      function generateReverse(size){
        arr = Array.from({length:size}, (_,k)=> Math.round((size-k) * (maxValue/size)));
        n = arr.length;
        resetPointers();
        render();
      }
      function loadCustom(){
        const txt = customInput.value.trim();
        if(!txt) return alert('Please enter comma separated numbers.');
        const parts = txt.split(',').map(s=>s.trim()).filter(s=>s!=='');
        const nums = parts.map(s=> Number(s));
        if(nums.some(x=>Number.isNaN(x))){
          alert('Invalid numbers in input. Use commas to separate values.');
          return;
        }
        arr = nums.map(v=>Math.max(minValue, Math.min(maxValue, Math.round(v))));
        n = arr.length;
        sizeRange.value = n;
        sizeLabel.textContent = n;
        resetPointers();
        render();
      }

      function resetPointers(){
        i = 0; j = 0;
        comparisons = 0; swaps = 0; passes = 0;
        swappedInPass = false;
        running = false;
        updateStats();
        running = false;
        playBtn.textContent = 'Play';
        curPair.textContent = '—';
        highlightPseudo(null);
        maxIndexEl.textContent = n-1;
        enableControls(true);
        clearAnimationQueue();
      }

      function resetAll(){
        resetPointers();
        // Keep array but re-render positions (no animations)
        render(true);
      }

      function updateStats(){
        cmpEl.textContent = comparisons;
        swpEl.textContent = swaps;
        passEl.textContent = passes;
      }

      function render(noAnimation){
        // clear
        barArea.innerHTML = '';
        bars = [];
        positions = [];
        const areaWidth = barArea.clientWidth || (barArea.getBoundingClientRect().width||600);
        // Calculate bar positions centered horizontally
        const totalWidth = n * barWidth + Math.max(0, n-1) * gap;
        const startX = Math.max(8, (areaWidth - totalWidth)/2);
        for(let idx=0; idx<n; idx++){
          const val = arr[idx];
          const el = document.createElement('div');
          el.className = 'bar';
          el.setAttribute('role','button');
          el.setAttribute('tabindex','0');
          el.setAttribute('data-index', idx);
          el.style.width = barWidth + 'px';
          const maxH = 200;
          const height = Math.max(24, Math.round((val / maxValue) * maxH));
          el.style.height = height + 'px';
          const x = startX + idx*(barWidth + gap);
          el.style.left = x + 'px';
          el.style.setProperty('--anim', noAnimation ? '0ms' : speed + 'ms');
          el.innerHTML = '<div class="label">' + val + '</div>';
          // click to edit value
          el.addEventListener('click', (ev)=>{
            if(animating) return;
            const cur = arr[idx];
            const s = prompt('Edit value at index ' + idx + ' (1-100):', cur);
            if(s === null) return;
            const v = Number(s);
            if(Number.isNaN(v)) return alert('Invalid number.');
            arr[idx] = Math.max(minValue, Math.min(maxValue, Math.round(v)));
            render(true);
            resetPointers();
          });
          // keyboard edit
          el.addEventListener('keydown', (ev)=>{
            if(ev.key === 'Enter'){
              el.click();
            }
          });
          barArea.appendChild(el);
          bars.push(el);
          positions.push(x);
        }
        // highlight sorted tail if any
        updateSortedTail();
      }

      function updatePositionsInstant(){
        for(let idx=0; idx<bars.length; idx++){
          bars[idx].style.setProperty('--anim', '0ms');
          bars[idx].style.left = positions[idx] + 'px';
          bars[idx].style.height = Math.max(24, Math.round((arr[idx]/100)*200)) + 'px';
          bars[idx].querySelector('.label').textContent = arr[idx];
        }
      }

      function updatePositionsAnimated(duration){
        for(let idx=0; idx<bars.length; idx++){
          bars[idx].style.setProperty('--anim', duration + 'ms');
          bars[idx].style.left = positions[idx] + 'px';
          bars[idx].style.height = Math.max(24, Math.round((arr[idx]/100)*200)) + 'px';
          bars[idx].querySelector('.label').textContent = arr[idx];
        }
      }

      // Algorithm primitives for stepping
      function highlightPseudo(line){
        const lines = pseudocode.querySelectorAll('.line');
        lines.forEach(l => l.classList.toggle('current', Number(l.getAttribute('data-line')) === line));
      }

      function setComparing(a,b){
        // Clear previous classes
        bars.forEach(bar => bar.classList.remove('compare','swap'));
        if(a != null && b != null){
          bars[a].classList.add('compare');
          bars[b].classList.add('compare');
          curPair.textContent = a + ' ↔ ' + b;
        } else {
          curPair.textContent = '—';
        }
      }

      function setSwapping(a,b){
        bars[a].classList.remove('compare');
        bars[b].classList.remove('compare');
        bars[a].classList.add('swap');
        bars[b].classList.add('swap');
      }

      function clearAnimationQueue(){
        if(timer) { clearTimeout(timer); timer = null; }
        animating = false;
      }

      function togglePlay(){
        if(animating) return; // don't toggle mid-animation
        running = !running;
        playBtn.textContent = running ? 'Pause' : 'Play';
        if(running) {
          stepLoop();
        }
      }

      function stepOnce(){
        if(animating) return;
        running = false;
        playBtn.textContent = 'Play';
        stepLogic();
      }

      // Core step logic implementing bubble sort step-by-step
      async function stepLogic(){
        if(n <= 1) return;
        // If finished
        if(i >= n-1){
          highlightPseudo(null);
          setComparing(null,null);
          running = false;
          playBtn.textContent = 'Play';
          return;
        }

        // Pseudocode: line 3 (inner loop) unless starting new pass
        highlightPseudo(3);

        // Compare arr[j] and arr[j+1]
        highlightPseudo(4);
        setComparing(j, j+1);
        comparisons++; updateStats();

        // Small delay to show comparison
        animating = true;
        await wait(speed * 0.6);

        if(arr[j] > arr[j+1]){
          // swap
          highlightPseudo(5);
          setSwapping(j, j+1);
          swaps++; updateStats();
          swappedInPass = true;
          // animate swap: swap values in arr and animate DOM positions by swapping left positions
          // Determine visual indices for bars: we maintain bars order equal to array indices.
          // We'll animate left positions and then swap elements in bars array to maintain mapping.
          // Compute current left positions
          const lefts = bars.map(b => parseFloat(b.style.left));
          // Swap bars positions visually
          const a = j, bIdx = j+1;
          // Swap left coordinates in positions array
          const tmpLeft = positions[a];
          positions[a] = positions[bIdx];
          positions[bIdx] = tmpLeft;
          // Animate left and height change
          updatePositionsAnimated(speed);
          // Wait for animation
          await wait(speed + 10);
          // Swap bars elements in our bars array to keep index mapping: bars[idx] corresponds visually to index
          const tmpBar = bars[a];
          bars[a] = bars[bIdx];
          bars[bIdx] = tmpBar;
          // Swap arr values (so future comparisons use new order)
          const tmp = arr[a];
          arr[a] = arr[bIdx];
          arr[bIdx] = tmp;
          // Update label text and heights to reflect swapped values
          updatePositionsAnimated(0);
        } else {
          // no swap: small highlight
          bars[j].classList.remove('compare');
          bars[j+1].classList.remove('compare');
        }

        // Move j forward
        j++;
        // If we've reached end of inner loop for this pass
        if(j >= n - 1 - i){
          passes++; updateStats();
          highlightPseudo(2); // swapped = false line
          // Mark sorted tail: element at index n-1-i is in correct position
          markSorted(n-1 - i);
          i++;
          j = 0;
          if(!swappedInPass && optimized){
            // early exit
            highlightPseudo(7);
            // mark remaining as sorted
            for(let k=0;k<n-i;k++){
              markSorted(k);
            }
            // Finish
            animating = false;
            running = false;
            playBtn.textContent = 'Play';
            setComparing(null,null);
            highlightPseudo(null);
            return;
          }
          swappedInPass = false;
        }

        animating = false;
        setComparing(null,null);
        updateSortedTail();

        // If running in autoplay, queue next step
        if(running){
          timer = setTimeout(()=> stepLogic(), 20);
        }
      }

      async function stepLoop(){
        if(animating) return;
        if(i >= n-1){
          running = false;
          playBtn.textContent = 'Play';
          return;
        }
        await stepLogic();
        if(running) {
          // queue next
          timer = setTimeout(()=> stepLoop(), 20);
        }
      }

      // Utility: mark an index as sorted (style)
      function markSorted(index){
        if(bars[index]){
          bars[index].classList.add('sorted');
        }
      }

      function updateSortedTail(){
        // Clear all sorted classes and reapply for sorted tail based on i
        for(let k=0;k<n;k++){
          bars[k].classList.toggle('sorted', k >= n - i);
        }
      }

      // Helper: wait (ms)
      function wait(ms){
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      // Helpers
      function randomInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

      // Initialize elements and computed positions after DOM layout
      window.addEventListener('load', ()=>{
        init();
      });

      // Recompute positions on resize
      window.addEventListener('resize', ()=>{
        // recalculate positions array and apply to bars
        if(bars.length !== n) return;
        const areaWidth = barArea.clientWidth;
        const totalWidth = n * barWidth + Math.max(0, n-1) * gap;
        const startX = Math.max(8, (areaWidth - totalWidth)/2);
        for(let idx=0; idx<n; idx++){
          positions[idx] = startX + idx*(barWidth + gap);
        }
        updatePositionsInstant();
      });

      // When first rendering or generating, compute positions according to area
      // Overwrite render to set positions properly
      // We'll override render to compute positions and set bars accordingly
      // (Render already computes startX; we need to set positions array used later for animations.)
      const originalRender = render;
      render = function(noAnimation){
        // compute positions
        const areaWidth = barArea.clientWidth || (barArea.getBoundingClientRect().width||600);
        const totalWidth = n * barWidth + Math.max(0, n-1) * gap;
        const startX = Math.max(8, (areaWidth - totalWidth)/2);
        positions = [];
        for(let idx=0; idx<n; idx++){
          positions.push(startX + idx*(barWidth + gap));
        }
        // Remove old bars
        barArea.innerHTML = '';
        bars = [];
        for(let idx=0; idx<n; idx++){
          const val = arr[idx];
          const el = document.createElement('div');
          el.className = 'bar';
          el.setAttribute('role','button');
          el.setAttribute('tabindex','0');
          el.setAttribute('data-index', idx);
          el.style.width = barWidth + 'px';
          const maxH = 200;
          const height = Math.max(24, Math.round((val / maxValue) * maxH));
          el.style.height = height + 'px';
          const x = positions[idx];
          el.style.left = x + 'px';
          el.style.setProperty('--anim', noAnimation ? '0ms' : speed + 'ms');
          el.innerHTML = '<div class="label">' + val + '</div>';
          (function(localIdx){
            el.addEventListener('click', (ev)=>{
              if(animating) return;
              const cur = arr[localIdx];
              const s = prompt('Edit value at index ' + localIdx + ' (1-100):', cur);
              if(s === null) return;
              const v = Number(s);
              if(Number.isNaN(v)) return alert('Invalid number.');
              arr[localIdx] = Math.max(minValue, Math.min(maxValue, Math.round(v)));
              render(true);
              resetPointers();
            });
            el.addEventListener('keydown', (ev)=>{
              if(ev.key === 'Enter'){
                el.click();
              }
            });
          })(idx);
          barArea.appendChild(el);
          bars.push(el);
        }
        // reset pointers styles and stats
        updateSortedTail();
        updateStats();
      };

    })();
  </script>
</body>
</html>