<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Heap (Min / Max) Interactive Module</title>
  <style>
    :root{
      --safe-pad:24px;
      --gap:16px;
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#2dd4bf;
      --muted:#94a3b8;
      --success:#34d399;
      --danger:#fb7185;
      --surface:#071026;
      --font-sans: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      --node-size:48px;
    }
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#071029 0%, #031027 100%);
      color:#e6eef6;
      font-family:var(--font-sans);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      box-sizing:border-box;
      padding:var(--safe-pad);
      min-height:100%;
      display:flex;
      gap:var(--gap);
      align-items:stretch;
    }

    /* Layout columns */
    .sidebar{
      width:360px;
      min-width:260px;
      max-width:420px;
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      border-radius:12px;
      padding:20px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.5);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .main{
      flex:1;
      min-width:0;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      border-radius:12px;
      padding:20px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      box-shadow: 0 6px 20px rgba(0,0,0,0.45);
    }

    /* Info sections */
    .title{
      font-size:20px;
      font-weight:700;
      display:flex;
      gap:8px;
      align-items:baseline;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
    }
    .card{
      background:rgba(255,255,255,0.01);
      border-radius:8px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.02);
    }

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    input[type="number"], input[type="text"]{
      appearance:none;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:rgba(255,255,255,0.02);
      color:inherit;
      padding:10px 12px;
      font-size:14px;
      min-width:0;
    }
    button{
      border:0;
      background:var(--accent);
      color:#002022;
      padding:10px 14px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      transition:transform .08s ease, box-shadow .12s ease;
    }
    button.secondary{
      background:transparent;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.04);
    }
    button:active{ transform:translateY(1px) }
    .toggle{
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .switch{
      width:52px;
      height:28px;
      background:rgba(255,255,255,0.06);
      border-radius:20px;
      padding:4px;
      display:inline-flex;
      align-items:center;
      cursor:pointer;
      position:relative;
    }
    .switch .knob{
      width:20px;height:20px;border-radius:50%;background:white;
      transition:transform .18s cubic-bezier(.2,.9,.2,1);
      transform:translateX(0);
    }
    .switch.on{ background:linear-gradient(90deg,var(--success),#10b981); }
    .switch.on .knob{ transform:translateX(24px); }

    .small{
      font-size:13px;
      color:var(--muted);
    }

    /* Visualization */
    .viz{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .canvas{
      position:relative;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.02);
      height:420px;
      overflow:hidden;
      padding:12px;
    }
    .tree-area{
      position:relative;
      width:100%;
      height:320px;
      user-select:none;
    }
    /* nodes (absolute positioned) */
    .node{
      position:absolute;
      width:var(--node-size);
      height:var(--node-size);
      border-radius:50%;
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:2px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      transition: left 420ms cubic-bezier(.2,.9,.2,1), top 420ms cubic-bezier(.2,.9,.2,1), transform 180ms ease, background 220ms;
      box-shadow: 0 8px 18px rgba(2,6,23,0.6);
      font-size:14px;
      color:#e6f6f4;
    }
    .node.min{ background:linear-gradient(180deg,#042b24,#06302a); border-color:rgba(45,212,191,0.18) }
    .node.max{ background:linear-gradient(180deg,#2c0520,#300622); border-color:rgba(251,113,133,0.18) }
    .node.compare{ transform:scale(1.12); box-shadow:0 12px 30px rgba(0,0,0,0.6); }
    .node.swap{ outline:3px solid rgba(255,255,255,0.06); transform:scale(1.08) rotate(3deg); }

    /* connectors use SVG lines */
    .connectors{ position:absolute; inset:0; pointer-events:none; }

    /* array view */
    .array{
      display:flex;
      gap:8px;
      align-items:center;
      padding:8px;
      overflow:auto;
      border-radius:8px;
      background:rgba(0,0,0,0.14);
      border:1px solid rgba(255,255,255,0.02);
    }
    .arr-item{
      min-width:48px;height:48px;border-radius:8px;background:rgba(255,255,255,0.02);
      display:flex;align-items:center;justify-content:center;font-weight:700;
      border:1px solid rgba(255,255,255,0.04);
      color:#dff8f4;
    }
    .arr-index{ font-size:12px;color:var(--muted); text-align:center;margin-top:6px; }

    /* narration / step log */
    .narration{
      min-height:36px;
      font-size:14px;
      color:var(--muted);
      padding:8px;
      border-radius:8px;
      background:rgba(255,255,255,0.01);
      border:1px solid rgba(255,255,255,0.02);
    }

    /* responsive */
    @media (max-width:980px){
      .app{ flex-direction:column; padding:16px; }
      .sidebar{ width:100%; max-width:none; }
      .main{ width:100% }
    }
    /* spacing for controls: ensure min spacing 16px between interactive elements */
    .controls > *{ margin-bottom:0; }
    .gap-16{ gap:16px; }
    /* accessibility focus states */
    button:focus, input:focus, .switch:focus{
      outline:3px solid rgba(45,212,191,0.12);
      outline-offset:2px;
    }
  </style>
</head>
<body>
  <div class="app" role="main" aria-labelledby="title">
    <aside class="sidebar" aria-label="Information and Controls">
      <div>
        <div class="title" id="title">
          Heap (Min / Max) — Interactive
        </div>
        <div class="muted small" style="margin-top:6px">Binary Heap visualized as tree + array. Animated bubble-up / bubble-down.</div>
      </div>

      <div class="card" aria-hidden="false">
        <div style="font-weight:700">Learning Objective</div>
        <div class="small muted" style="margin-top:6px">
          Understand how insert and extract operations maintain the heap property for Min-Heap and Max-Heap. Observe comparisons and swaps (bubble-up / bubble-down) both in the tree and the array representation.
        </div>
      </div>

      <div class="card">
        <div style="font-weight:700; margin-bottom:8px">Interaction Design</div>
        <div class="small muted">
          - Insert a number: type a value and press Insert (or Enter). Watch the new node animate into place, compare with parent nodes, and bubble up as needed.<br>
          - Extract root: removes the root (min or max depending on mode). Watch the last node move to the root and bubble-down with comparisons and swaps. <br>
          - Toggle Min/Max: switch behavior instantly; heap will re-heapify if you press "Build from array" or randomize. <br>
          - Use Step mode to advance bubble steps manually and follow narration. <br>
          Animations highlight comparisons (yellowish), swaps (green), and final settled nodes (subtle color).
        </div>
      </div>

      <div class="card controls" aria-label="Heap Controls">
        <div style="font-weight:700; margin-bottom:6px">Controls</div>
        <div class="row" style="align-items:center">
          <input id="inputValue" type="number" placeholder="Number" aria-label="Value to insert" />
          <button id="btnInsert" title="Insert value">Insert</button>
          <button id="btnExtract" class="secondary" title="Extract root">Extract Root</button>
        </div>

        <div class="row">
          <div class="toggle small">
            <div id="modeSwitch" class="switch on" role="switch" tabindex="0" aria-checked="true" aria-label="Toggle Min or Max heap">
              <div class="knob" aria-hidden="true"></div>
            </div>
            <div class="small" id="modeLabel">Mode: Min-Heap</div>
          </div>
          <div style="margin-left:auto" class="small muted">Heap size: <span id="heapSize">0</span></div>
        </div>

        <div class="row" style="align-items:center">
          <button id="btnRandom" class="secondary">Randomize</button>
          <button id="btnClear" class="secondary">Clear</button>
          <button id="btnBuild" class="secondary">Build from array</button>
        </div>

        <div class="row">
          <input type="text" id="arrayInput" placeholder="e.g. 5,3,8,1" aria-label="Comma separated array" />
        </div>

        <div class="row" style="align-items:center">
          <button id="btnStep" class="secondary">Step</button>
          <button id="btnAuto" class="secondary">Auto Run</button>
          <div style="margin-left:auto" class="small muted">Speed:
            <input id="speed" type="range" min="100" max="1200" step="50" value="420" aria-label="Animation speed" />
          </div>
        </div>

        <div class="narration" id="narration" aria-live="polite">Ready. Insert numbers to begin.</div>
      </div>

      <div class="card small muted" style="font-size:12px">
        Layout details: Safe area margins are 24px. Minimum spacing between controls is 16px. Responsive: on narrow screens controls stack above visualization.
      </div>
    </aside>

    <main class="main" aria-label="Visualization Area">
      <div class="viz">
        <div style="display:flex;align-items:center;gap:12px;justify-content:space-between">
          <div style="font-weight:700">Heap Visualization</div>
          <div class="small muted">Tree + Array view — nodes animated on swap / compare</div>
        </div>

        <div class="canvas" id="canvas" role="region" aria-label="Heap tree visualization">
          <div class="tree-area" id="treeArea"></div>
          <svg class="connectors" id="connectors" preserveAspectRatio="none"></svg>
        </div>

        <div>
          <div style="font-weight:700; margin-bottom:8px">Array representation</div>
          <div class="array" id="arrayView" role="list" aria-label="Heap array view"></div>
        </div>
      </div>
    </main>
  </div>

  <script>
    /* Heap Interactive Module - Vanilla JS
       Features:
       - Min/Max toggle
       - Insert with animated bubble-up
       - Extract root with animated bubble-down
       - Randomize, Clear, Build from array
       - Step mode and Auto Run
       - Tree layout + SVG connectors
    */

    // Utility
    const sleep = ms => new Promise(r => setTimeout(r, ms));

    // DOM references
    const inputValue = document.getElementById('inputValue');
    const btnInsert = document.getElementById('btnInsert');
    const btnExtract = document.getElementById('btnExtract');
    const modeSwitch = document.getElementById('modeSwitch');
    const modeLabel = document.getElementById('modeLabel');
    const heapSizeEl = document.getElementById('heapSize');
    const treeArea = document.getElementById('treeArea');
    const connectors = document.getElementById('connectors');
    const arrayView = document.getElementById('arrayView');
    const narration = document.getElementById('narration');
    const btnRandom = document.getElementById('btnRandom');
    const btnClear = document.getElementById('btnClear');
    const arrayInput = document.getElementById('arrayInput');
    const btnBuild = document.getElementById('btnBuild');
    const btnStep = document.getElementById('btnStep');
    const btnAuto = document.getElementById('btnAuto');
    const speedControl = document.getElementById('speed');

    // State
    let heap = []; // array of numbers
    let isMin = true; // mode
    let nodes = []; // DOM node elements
    let running = false; // when an operation is animating
    let stepMode = false;
    let autoRun = false;
    let stepQueue = []; // queued generator steps

    // Accessibility / initial
    updateModeUI();

    // Helpers - comparator
    function cmp(a,b){
      return isMin ? a - b : b - a; // positive if a should be below b (a > b in min-heap)
    }

    // Layout math: compute positions for each node index
    function layoutPositions(width, height, n) {
      if (n === 0) return [];
      const positions = [];
      const maxLevel = Math.floor(Math.log2(Math.max(1,n)));
      const levelHeight = (height) / (maxLevel + 2);
      for (let i=0;i<n;i++){
        const level = Math.floor(Math.log2(i+1));
        const indexInLevel = i - (1<<level) + 1;
        const nodesInLevel = 1<<level;
        const x = Math.round(((indexInLevel + 1) / (nodesInLevel + 1)) * width);
        const y = Math.round((level + 1) * levelHeight);
        positions.push({x,y,level});
      }
      return positions;
    }

    // Render functions
    function renderAll(immediate = false){
      const w = treeArea.clientWidth;
      const h = treeArea.clientHeight;
      const positions = layoutPositions(w, h, heap.length);
      // Update nodes array to match heap length
      while (nodes.length < heap.length){
        const el = document.createElement('div');
        el.className = 'node';
        el.setAttribute('role','img');
        el.setAttribute('aria-label','heap node');
        el.style.left = '0px';
        el.style.top = '0px';
        el.style.width = getComputedStyle(document.documentElement).getPropertyValue('--node-size') || '48px';
        treeArea.appendChild(el);
        nodes.push(el);
      }
      while (nodes.length > heap.length){
        const el = nodes.pop();
        if (el.parentElement) el.parentElement.removeChild(el);
      }
      // assign classes and content
      nodes.forEach((el,i)=>{
        el.textContent = String(heap[i]);
        el.classList.toggle('min', isMin);
        el.classList.toggle('max', !isMin);
        el.dataset.index = i;
      });

      // Position nodes
      nodes.forEach((el,i)=>{
        const p = positions[i] || {x:0,y:0};
        // center by subtracting half width/height
        const size = el.getBoundingClientRect();
        const nodeW = size.width || parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--node-size')) || 48;
        const nodeH = size.height || nodeW;
        const left = Math.max(8, p.x - nodeW/2);
        const top = Math.max(8, p.y - nodeH/2);
        if (immediate){
          el.style.transition = 'none';
          el.style.left = left + 'px';
          el.style.top = top + 'px';
          // force reflow
          void el.offsetWidth;
          el.style.transition = '';
        } else {
          el.style.left = left + 'px';
          el.style.top = top + 'px';
        }
      });

      // Render connectors using SVG lines
      connectors.setAttribute('width', treeArea.clientWidth);
      connectors.setAttribute('height', treeArea.clientHeight);
      connectors.innerHTML = '';
      for (let i=0;i<heap.length;i++){
        const leftChild = 2*i + 1;
        const rightChild = 2*i + 2;
        const p = positions[i];
        if (!p) continue;
        const cx = p.x;
        const cy = p.y;
        [leftChild, rightChild].forEach(child=>{
          if (child < heap.length){
            const cp = positions[child];
            const line = document.createElementNS('http://www.w3.org/2000/svg','line');
            line.setAttribute('x1', cx);
            line.setAttribute('y1', cy + 22);
            line.setAttribute('x2', cp.x);
            line.setAttribute('y2', cp.y - 18);
            line.setAttribute('stroke', 'rgba(255,255,255,0.04)');
            line.setAttribute('stroke-width', '2');
            line.setAttribute('stroke-linecap','round');
            connectors.appendChild(line);
          }
        });
      }

      // Update array view
      arrayView.innerHTML = '';
      heap.forEach((v,i)=>{
        const el = document.createElement('div');
        el.className = 'arr-item';
        el.setAttribute('role','listitem');
        el.textContent = v;
        const idx = document.createElement('div');
        idx.className = 'arr-index';
        idx.textContent = i;
        const wrap = document.createElement('div');
        wrap.style.textAlign = 'center';
        wrap.appendChild(el);
        wrap.appendChild(idx);
        arrayView.appendChild(wrap);
      });

      heapSizeEl.textContent = heap.length;
    }

    // swap elements in array and reflect visually (no animation control here)
    function swap(i,j){
      const tmp = heap[i]; heap[i] = heap[j]; heap[j] = tmp;
    }

    // Narration helper
    function narrate(msg){
      narration.textContent = msg;
    }

    // Operation Animations (async to allow step-by-step)
    async function animateInsert(value){
      if (running) return;
      running = true;
      try {
        narrate(`Inserting ${value}...`);
        // Append value
        heap.push(value);
        renderAll(true);
        await sleep(80);

        // Bubble-up algorithm with animations
        let i = heap.length - 1;
        nodes[i].classList.add('compare');
        await sleep(200);
        while (i > 0){
          const parent = Math.floor((i-1)/2);
          nodes[parent].classList.add('compare');
          narrate(`Compare node ${heap[i]} with parent ${heap[parent]}`);
          await sleep(getSpeed());
          // highlight comparison
          if (cmp(heap[i], heap[parent]) < 0){
            // child should go up: swap
            narrate(`Swap ${heap[i]} ↔ ${heap[parent]}`);
            nodes[i].classList.add('swap');
            nodes[parent].classList.add('swap');
            swap(i,parent);
            renderAll();
            await sleep(getSpeed());
            nodes[i].classList.remove('swap','compare');
            nodes[parent].classList.remove('swap','compare');
            i = parent;
            nodes[i].classList.add('compare');
            if (stepMode){
              narrate(`Paused after swap. Press Step to continue.`);
              running = false;
              return enqueueStep(async ()=> await animateInsertResume(i));
            }
          } else {
            narrate(`No swap needed. Insert finished.`);
            nodes[i].classList.remove('compare');
            nodes[parent].classList.remove('compare');
            break;
          }
        }
        narrate(`Insert complete.`);
      } finally {
        running = false;
        renderAll();
      }

      async function animateInsertResume(currentIndex){
        running = true;
        let i = currentIndex;
        while (i > 0){
          const parent = Math.floor((i-1)/2);
          nodes[parent].classList.add('compare');
          narrate(`Compare node ${heap[i]} with parent ${heap[parent]}`);
          await sleep(getSpeed());
          if (cmp(heap[i], heap[parent]) < 0){
            narrate(`Swap ${heap[i]} ↔ ${heap[parent]}`);
            nodes[i].classList.add('swap');
            nodes[parent].classList.add('swap');
            swap(i,parent);
            renderAll();
            await sleep(getSpeed());
            nodes[i].classList.remove('swap','compare');
            nodes[parent].classList.remove('swap','compare');
            i = parent;
            nodes[i].classList.add('compare');
            if (stepMode){
              narrate(`Paused after swap. Press Step to continue.`);
              running = false;
              return enqueueStep(async ()=> await animateInsertResume(i));
            }
          } else {
            narrate(`No swap needed. Insert finished.`);
            nodes[i].classList.remove('compare');
            nodes[parent].classList.remove('compare');
            break;
          }
        }
        narrate(`Insert complete.`);
        running = false;
      }
    }

    function enqueueStep(fn){
      stepQueue.push(fn);
      // if autoRun active, run them
      if (autoRun) runStepQueue();
    }

    async function runStepQueue(){
      if (running) return;
      while (stepQueue.length > 0){
        const fn = stepQueue.shift();
        await fn();
      }
    }

    async function animateExtract(){
      if (running || heap.length === 0) return;
      running = true;
      try {
        narrate(`Extracting root (${heap[0]})...`);
        if (heap.length === 1){
          heap.pop();
          renderAll();
          narrate(`Heap is now empty.`);
          return;
        }
        // swap root and last, remove last
        const lastIdx = heap.length - 1;
        nodes[0].classList.add('swap');
        nodes[lastIdx].classList.add('swap');
        narrate(`Swap root ${heap[0]} with last ${heap[lastIdx]}`);
        swap(0,lastIdx);
        renderAll();
        await sleep(getSpeed());
        nodes[0].classList.remove('swap');
        nodes[lastIdx].classList.remove('swap');
        // remove last element (which was root)
        const removed = heap.pop();
        renderAll(true);
        narrate(`Removed ${removed}. Bubble-down new root ${heap[0]}.`);
        await sleep(240);

        // bubble-down
        let i = 0;
        while (true){
          const left = 2*i + 1;
          const right = 2*i + 2;
          let best = i;
          if (left < heap.length){
            nodes[left].classList.add('compare');
            nodes[i].classList.add('compare');
            narrate(`Compare root ${heap[i]} with left child ${heap[left]}`);
            await sleep(getSpeed());
            if (cmp(heap[left], heap[best]) < 0) best = left;
            nodes[left].classList.remove('compare');
            nodes[i].classList.remove('compare');
          }
          if (right < heap.length){
            nodes[right].classList.add('compare');
            nodes[best].classList.add('compare');
            narrate(`Compare candidate ${heap[best]} with right child ${heap[right]}`);
            await sleep(getSpeed());
            if (cmp(heap[right], heap[best]) < 0) best = right;
            nodes[right].classList.remove('compare');
            nodes[best].classList.remove('compare');
          }
          if (best !== i){
            narrate(`Swap ${heap[i]} ↔ ${heap[best]}`);
            nodes[i].classList.add('swap');
            nodes[best].classList.add('swap');
            swap(i,best);
            renderAll();
            await sleep(getSpeed());
            nodes[i].classList.remove('swap');
            nodes[best].classList.remove('swap');
            i = best;
            if (stepMode){
              narrate(`Paused after swap. Press Step to continue.`);
              running = false;
              return enqueueStep(async ()=> await animateExtractResume(i));
            }
          } else {
            narrate(`Bubble-down complete.`);
            break;
          }
        }
      } finally {
        running = false;
        renderAll();
      }

      async function animateExtractResume(startIndex){
        running = true;
        let i = startIndex;
        while (true){
          const left = 2*i + 1;
          const right = 2*i + 2;
          let best = i;
          if (left < heap.length){
            nodes[left].classList.add('compare');
            nodes[i].classList.add('compare');
            narrate(`Compare root ${heap[i]} with left child ${heap[left]}`);
            await sleep(getSpeed());
            if (cmp(heap[left], heap[best]) < 0) best = left;
            nodes[left].classList.remove('compare');
            nodes[i].classList.remove('compare');
          }
          if (right < heap.length){
            nodes[right].classList.add('compare');
            nodes[best].classList.add('compare');
            narrate(`Compare candidate ${heap[best]} with right child ${heap[right]}`);
            await sleep(getSpeed());
            if (cmp(heap[right], heap[best]) < 0) best = right;
            nodes[right].classList.remove('compare');
            nodes[best].classList.remove('compare');
          }
          if (best !== i){
            narrate(`Swap ${heap[i]} ↔ ${heap[best]}`);
            nodes[i].classList.add('swap');
            nodes[best].classList.add('swap');
            swap(i,best);
            renderAll();
            await sleep(getSpeed());
            nodes[i].classList.remove('swap');
            nodes[best].classList.remove('swap');
            i = best;
            if (stepMode){
              narrate(`Paused after swap. Press Step to continue.`);
              running = false;
              return enqueueStep(async ()=> await animateExtractResume(i));
            }
          } else {
            narrate(`Bubble-down complete.`);
            break;
          }
        }
        running = false;
        renderAll();
      }
    }

    // Simple heapify build (bottom-up) with animation (optional)
    async function buildFromArray(arr){
      if (running) return;
      running = true;
      try {
        heap = arr.slice();
        renderAll(true);
        narrate('Building heap (bottom-up)...');
        await sleep(200);
        const n = heap.length;
        for (let i = Math.floor(n/2) - 1; i >= 0; i--){
          await heapifyStep(i);
          if (stepMode){
            narrate('Paused during build. Press Step to continue.');
            running = false;
            return enqueueStep(async ()=> await buildFromArrayResume(i-1));
          }
        }
        narrate('Build complete.');
      } finally {
        running = false;
        renderAll();
      }

      async function buildFromArrayResume(startIdx){
        running = true;
        let i;
        for (i = startIdx; i >=0; i--){
          await heapifyStep(i);
          if (stepMode){
            narrate('Paused during build. Press Step to continue.');
            running = false;
            return enqueueStep(async ()=> await buildFromArrayResume(i-1));
          }
        }
        narrate('Build complete.');
        running = false;
      }

      async function heapifyStep(i){
        let largest = i;
        while (true){
          const left = 2*i +1;
          const right = 2*i +2;
          let best = i;
          if (left < heap.length){
            nodes[left].classList.add('compare');
            nodes[best].classList.add('compare');
            narrate(`Compare ${heap[best]} with left ${heap[left]}`);
            await sleep(getSpeed());
            if (cmp(heap[left], heap[best]) < 0) best = left;
            nodes[left].classList.remove('compare');
            nodes[best].classList.remove('compare');
          }
          if (right < heap.length){
            nodes[right].classList.add('compare');
            nodes[best].classList.add('compare');
            narrate(`Compare ${heap[best]} with right ${heap[right]}`);
            await sleep(getSpeed());
            if (cmp(heap[right], heap[best]) < 0) best = right;
            nodes[right].classList.remove('compare');
            nodes[best].classList.remove('compare');
          }
          if (best !== i){
            narrate(`Swap ${heap[i]} ↔ ${heap[best]}`);
            nodes[i].classList.add('swap');
            nodes[best].classList.add('swap');
            swap(i,best);
            renderAll();
            await sleep(getSpeed());
            nodes[i].classList.remove('swap');
            nodes[best].classList.remove('swap');
            i = best;
            if (stepMode){
              narrate('Paused after swap. Press Step to continue.');
              return;
            }
            // continue sifting
          } else {
            break;
          }
        }
      }
    }

    // UI bindings
    btnInsert.addEventListener('click', ()=>{
      const v = parseFloat(inputValue.value);
      if (!isFinite(v)) { narrate('Enter a valid number to insert.'); inputValue.focus(); return; }
      inputValue.value = '';
      animateInsert(v);
    });
    inputValue.addEventListener('keydown',(e)=>{
      if (e.key === 'Enter'){ btnInsert.click(); }
    });

    btnExtract.addEventListener('click', ()=>{
      if (heap.length === 0) { narrate('Heap is empty.'); return; }
      animateExtract();
    });

    modeSwitch.addEventListener('click', toggleMode);
    modeSwitch.addEventListener('keydown',(e)=>{ if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleMode(); } });

    function toggleMode(){
      if (running) { narrate('Wait for current animation to finish before toggling mode.'); return; }
      isMin = !isMin;
      updateModeUI();
      renderAll(true);
      narrate(`Switched to ${isMin ? 'Min-Heap' : 'Max-Heap'}. Press Build from array to re-heapify existing values.`);
    }

    function updateModeUI(){
      modeSwitch.classList.toggle('on', isMin);
      modeLabel.textContent = 'Mode: ' + (isMin ? 'Min-Heap' : 'Max-Heap');
      modeSwitch.setAttribute('aria-checked', String(isMin));
    }

    btnRandom.addEventListener('click', ()=>{
      if (running) return;
      const count = Math.floor(Math.random()*6)+3;
      heap = Array.from({length:count}, ()=> Math.floor(Math.random()*90)+1);
      renderAll(true);
      narrate('Random array generated. Press Build from array to heapify or start inserting.');
    });

    btnClear.addEventListener('click', ()=>{
      if (running) return;
      heap = [];
      renderAll(true);
      narrate('Heap cleared.');
    });

    btnBuild.addEventListener('click', ()=>{
      if (running) return;
      // parse array input
      const txt = arrayInput.value.trim();
      if (txt){
        const parts = txt.split(',').map(s=>parseFloat(s.trim())).filter(x=>isFinite(x));
        if (parts.length === 0){
          narrate('No valid numbers found in array input.');
          return;
        }
        buildFromArray(parts);
      } else {
        // build from current heap array
        buildFromArray(heap.slice());
      }
    });

    // Step / Auto
    btnStep.addEventListener('click', async ()=>{
      stepMode = true;
      if (stepQueue.length > 0 && !running){
        await runStepQueue();
      } else {
        narrate('Step mode enabled. Trigger operations (Insert/Extract/Build) to produce steps.');
      }
    });

    btnAuto.addEventListener('click', ()=>{
      autoRun = !autoRun;
      btnAuto.classList.toggle('secondary', !autoRun);
      btnAuto.textContent = autoRun ? 'Auto Run: On' : 'Auto Run';
      if (autoRun) runStepQueue();
    });

    speedControl.addEventListener('input', ()=>{ /* speed read by getSpeed() */ });

    function getSpeed(){
      return parseInt(speedControl.value,10) || 420;
    }

    // Dragging: optional enhancement to allow reordering? Not required; left out to keep focused on heap ops.

    // Initialization
    window.addEventListener('resize', ()=> renderAll(true));
    renderAll(true);

    // Keyboard helpful hints
    document.addEventListener('keydown', (e)=>{
      if (e.ctrlKey && e.key === 'r') { e.preventDefault(); btnRandom.click(); }
      if (e.ctrlKey && e.key === 'c') { e.preventDefault(); btnClear.click(); }
    });

    // For demonstration: helpful default array
    arrayInput.value = '7,3,5,1,9,8';

    // Small accessibility: focus first input on load
    window.addEventListener('load', ()=> inputValue.focus());
  </script>
</body>
</html>