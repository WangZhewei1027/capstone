<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Bubble Sort Explorer</title>
  <style>
    /* Safe area margins and base styles */
    :root{
      --safe-pad: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #98a2b3;
      --accent: #38bdf8;
      --good: #34d399;
      --danger: #fb7185;
      --glass: rgba(255,255,255,0.02);
      --bar-gap: 8px;
      --max-bars: 20;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071125 0%, #071022 100%);
      color:#e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app {
      padding: var(--safe-pad);
      min-height:100%;
      box-sizing:border-box;
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      justify-content:center;
    }

    /* Layout: left info + controls, right visualization */
    .left {
      width: 360px;
      min-width: 280px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:12px;
      padding:20px;
      box-sizing:border-box;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      border: 1px solid rgba(255,255,255,0.03);
    }

    .right {
      flex:1;
      min-width:320px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:12px;
      padding:20px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      border: 1px solid rgba(255,255,255,0.03);
    }

    /* Info sections */
    .title {
      font-size:20px;
      font-weight:600;
      color:var(--accent);
      display:flex;
      gap:12px;
      align-items:center;
    }
    .subtitle {
      font-size:13px;
      color:var(--muted);
      margin-top:4px;
    }

    .section {
      background: rgba(255,255,255,0.02);
      padding:12px;
      border-radius:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .section h4 {
      margin:0;
      font-size:13px;
      color:#e6f5ff;
    }
    .section p {
      margin:0;
      font-size:13px;
      color:var(--muted);
      line-height:1.4;
    }

    /* Controls */
    .controls {
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .row {
      display:flex;
      gap:var(--gap);
      align-items:center;
    }
    .btn {
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      color:#e8f6ff;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
      min-height:40px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
    }
    .btn:active { transform:translateY(1px); }
    .btn.primary {
      background:linear-gradient(180deg,#0369a1,#035378);
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      border: none;
    }
    .btn.ghost {
      background:transparent;
      border:1px dashed rgba(255,255,255,0.04);
    }
    .btn.small { padding:6px 10px; font-size:13px; min-height:36px; }

    input[type="text"], input[type="number"], select {
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      color:#e6f5ff;
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      outline:none;
    }
    input[type="range"] {
      width:100%;
      accent-color:var(--accent);
    }

    .stats {
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }
    .stat {
      background: rgba(255,255,255,0.02);
      padding:8px 10px;
      border-radius:8px;
      min-width:100px;
      font-size:13px;
      color:var(--muted);
    }
    .stat strong { display:block; color:#e6f5ff; font-size:15px; }

    /* Visualization area */
    .viz {
      height:420px;
      background: linear-gradient(180deg, rgba(8,15,28,0.5), rgba(6,10,18,0.2));
      border-radius:8px;
      padding:16px;
      position:relative;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow:hidden;
    }
    .viz-header {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    .legend {
      display:flex;
      gap:8px;
      align-items:center;
    }
    .legend .key {
      display:flex;
      gap:8px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }
    .swatch {
      width:12px; height:12px; border-radius:3px;
    }

    .bars-wrap {
      flex:1;
      position:relative;
      border-radius:6px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      display:block;
      padding:12px;
      box-sizing:border-box;
      overflow:hidden;
    }

    /* Bars container will be positioned relative; bars are inline-block */
    .bars {
      position:relative;
      height:100%;
      width:100%;
    }
    .bar {
      position:absolute;
      bottom:12px;
      width: calc((100% - (var(--bar-gap) * (var(--count) - 1))) / var(--count));
      background:linear-gradient(180deg,#60a5fa,#0369a1);
      border-radius:6px 6px 4px 4px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:#021124;
      font-weight:700;
      font-size:12px;
      transition: height 350ms cubic-bezier(.22,.9,.18,1), background 220ms, transform 300ms;
      box-shadow: 0 6px 20px rgba(2,6,23,0.35);
    }
    .bar .label {
      transform:translateY(6px);
      color:rgba(0,0,0,0.6);
      padding-bottom:6px;
    }

    .bar.compare { background: linear-gradient(180deg,#fef08a,#f59e0b); }
    .bar.swap { background: linear-gradient(180deg,#fb7185,#ef4444); transform: translateY(-6px); }
    .bar.sorted { background: linear-gradient(180deg,#34d399,#10b981); color:#042014; }

    /* Swap horizontal nudge animation */
    .nudge-left { animation: nudge-left 300ms ease; }
    .nudge-right { animation: nudge-right 300ms ease; }
    @keyframes nudge-left {
      0% { transform: translateX(0); }
      50% { transform: translateX(-18px) translateY(-6px); }
      100% { transform: translateX(0); }
    }
    @keyframes nudge-right {
      0% { transform: translateX(0); }
      50% { transform: translateX(18px) translateY(-6px); }
      100% { transform: translateX(0); }
    }

    /* Footer control tips */
    .tips { font-size:12px; color:var(--muted); }

    /* Responsive: stack on small screens */
    @media (max-width:980px){
      .app { flex-direction:column; padding:16px; }
      .left, .right { width:100%; }
      .left { order:2; }
      .right { order:1; }
      .viz { height:360px; }
    }

    /* Accessibility focus */
    .btn:focus, input:focus { outline: 2px dashed rgba(56,189,248,0.3); outline-offset:4px; }
  </style>
</head>
<body>
  <div class="app" role="main" aria-labelledby="title">
    <!-- LEFT: Info and Controls -->
    <aside class="left" aria-label="Controls and explanation">
      <div>
        <div id="title" class="title">Bubble Sort — Visual & Interactive</div>
        <div class="subtitle">Step through comparisons and swaps to internalize how Bubble Sort works.</div>
      </div>

      <!-- Concept & Objectives -->
      <div class="section" aria-hidden="false">
        <h4>Concept Title</h4>
        <p><strong>Bubble Sort</strong>: a simple comparison-based sorting algorithm that repeatedly passes through a list, compares adjacent items, and swaps them if they are in the wrong order.</p>

        <h4>Learning Objective</h4>
        <p>After interacting with this module you will be able to:
          - identify when adjacent elements are compared,
          - see how swaps move larger elements toward the end (the "bubble" effect),
          - recognize how each pass reduces the unsorted portion until fully sorted.</p>
      </div>

      <!-- Interaction Design -->
      <div class="section" aria-hidden="false">
        <h4>Interaction Design</h4>
        <p>
          Controls:
          - "Shuffle" generates a random array; "Apply" accepts a custom comma-separated array.
          - Play/Pause auto-steps through frames; Next/Prev step one action.
          - Speed slider controls playback delay.
        </p>
        <p>
          Visual feedback:
          - Compared pair is highlighted in yellow.
          - Swapped pair flashes red and receives a small horizontal nudge to emphasize the exchange.
          - Sorted items turn green and are fixed at the right side as passes complete.
          - Counters for comparisons, swaps, and current pass update live.
        </p>
        <p>
          Interaction modes:
          - Click buttons, use keyboard: Space to Play/Pause, → Next step, ← Previous step.
          - Accessible labels and clear color contrast are used; numbers are shown on bars for screen readers.
        </p>
      </div>

      <!-- Controls -->
      <div class="controls" role="region" aria-label="Controls">
        <div class="row" style="align-items:center;">
          <input id="arrayInput" type="text" aria-label="Custom array input" placeholder="e.g. 5,3,8,1,4" />
          <button id="applyBtn" class="btn small primary" aria-label="Apply custom array">Apply</button>
        </div>

        <div class="row">
          <button id="shuffleBtn" class="btn ghost" aria-label="Shuffle new random array">Shuffle</button>
          <button id="resetBtn" class="btn" aria-label="Reset visualization">Reset</button>
        </div>

        <div class="row">
          <button id="prevBtn" class="btn small" aria-label="Previous step">◀ Prev</button>
          <button id="playBtn" class="btn small primary" aria-label="Play or pause">▶ Play</button>
          <button id="nextBtn" class="btn small" aria-label="Next step">Next ▶</button>
        </div>

        <div style="display:flex;flex-direction:column;gap:8px;">
          <label for="speed" style="font-size:13px;color:var(--muted);">Speed <span id="speedLabel" style="color:#e6f5ff;font-weight:600;">500ms</span></label>
          <input id="speed" type="range" min="100" max="1500" value="500" />
        </div>

        <div class="row" style="align-items:center;">
          <div style="flex:1;">
            <label for="count" style="font-size:13px;color:var(--muted);">Array size</label>
            <select id="count" aria-label="Array size selector" style="width:100%;">
              <option value="6">6</option>
              <option value="8" selected>8</option>
              <option value="10">10</option>
              <option value="14">14</option>
              <option value="18">18</option>
            </select>
          </div>
          <div style="width:120px;">
            <label style="font-size:13px;color:var(--muted);">Order</label>
            <select id="order" aria-label="Sort order" style="width:100%;">
              <option value="asc" selected>Ascending</option>
              <option value="desc">Descending</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Stats -->
      <div class="section" aria-live="polite">
        <h4>Runtime & Progress</h4>
        <div class="stats">
          <div class="stat"><strong id="pass">Pass 0</strong><span class="muted">Current pass</span></div>
          <div class="stat"><strong id="compCount">Comparisons: 0</strong></div>
          <div class="stat"><strong id="swapCount">Swaps: 0</strong></div>
          <div class="stat"><strong id="frameIdx">Step: 0</strong></div>
        </div>
        <p class="tips" style="margin-top:8px;">
          Tip: Bubble Sort is stable and easy to visualize — it's excellent for learning, though not optimal for large arrays.
        </p>
      </div>

      <div style="display:flex;gap:10px;">
        <button id="explainBtn" class="btn" aria-label="Show explanation">Explain pass</button>
        <button id="resetAllBtn" class="btn ghost" aria-label="Reset all settings">Reset All</button>
      </div>
    </aside>

    <!-- RIGHT: Visualization -->
    <main class="right" aria-label="Visualization and timeline">
      <div class="viz" role="region" aria-label="Bubble sort visualization">
        <div class="viz-header">
          <div style="display:flex;flex-direction:column;">
            <div style="font-size:14px;font-weight:600;color:#e6f5ff;">Array Visualization</div>
            <div style="font-size:12px;color:var(--muted);">Compare (yellow) → Swap (red) → Sorted (green)</div>
          </div>
          <div class="legend" aria-hidden="true">
            <div class="key"><span class="swatch" style="background:#f59e0b"></span>Compare</div>
            <div class="key"><span class="swatch" style="background:#ef4444"></span>Swap</div>
            <div class="key"><span class="swatch" style="background:#10b981"></span>Sorted</div>
          </div>
        </div>

        <div class="bars-wrap" id="barsWrap">
          <div id="bars" class="bars" aria-hidden="false" style="--bar-gap: 8px; --count: 8;"></div>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;">
          <div style="font-size:13px;color:var(--muted);" id="statusText">Ready</div>
          <div style="font-size:13px;color:var(--muted);">Keyboard: Space Play/Pause • ← / → Step</div>
        </div>
      </div>

      <!-- Explanation / Timeline (collapsible) -->
      <div class="section">
        <h4>How this visualization maps to Bubble Sort</h4>
        <p>Each "step" is either a comparison between adjacent elements or a swap when they are out of order. A pass goes from the start to the end of the array and pushes the largest unsorted element to its correct position at the end. The sorted region grows from right to left.</p>
        <p style="font-size:13px;color:var(--muted);margin-top:8px;">
          Use Next/Prev to step conceptually (one comparison or swap per step). Play will animate through the exact sequence of compare and swap actions recorded by the Bubble Sort algorithm.
        </p>
      </div>
    </main>
  </div>

  <script>
    /**
     * Bubble Sort Visualizer
     * - Precomputes frames (snapshots) of array states and actions.
     * - Provides Play/Pause, Next/Prev, Shuffle, Apply custom array.
     * - Animations via CSS classes and transitions.
     *
     * Accessibility & responsive layout considerations included.
     */

    // Utility helpers
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function createRandomArray(n){
      const arr = [];
      for(let i=0;i<n;i++) arr.push(Math.floor(Math.random()*98) + 2); // 2..99
      return arr;
    }

    // State
    const state = {
      array: [],
      frames: [], // each frame: { arr:[], action: {type:'compare'|'swap'|'mark', i, j }, pass, comparisons, swaps }
      frameIndex: 0,
      playing: false,
      timer: null,
      speed: 500,
      order: 'asc'
    };

    // DOM
    const barsEl = document.getElementById('bars');
    const barsWrap = document.getElementById('barsWrap');
    const applyBtn = document.getElementById('applyBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const resetBtn = document.getElementById('resetBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const playBtn = document.getElementById('playBtn');
    const speedEl = document.getElementById('speed');
    const speedLabel = document.getElementById('speedLabel');
    const countEl = document.getElementById('count');
    const orderEl = document.getElementById('order');
    const arrayInput = document.getElementById('arrayInput');
    const passEl = document.getElementById('pass');
    const compCountEl = document.getElementById('compCount');
    const swapCountEl = document.getElementById('swapCount');
    const frameIdxEl = document.getElementById('frameIdx');
    const statusText = document.getElementById('statusText');
    const explainBtn = document.getElementById('explainBtn');
    const resetAllBtn = document.getElementById('resetAllBtn');

    // Initialize with default array
    function init(){
      const size = parseInt(countEl.value,10) || 8;
      state.array = createRandomArray(size);
      state.order = orderEl.value || 'asc';
      buildFramesAndRender();
      attachUI();
      updateSpeedLabel();
    }

    // Build frames by running bubble sort and recording every compare/swap/mark
    function buildFrames(arr, order='asc'){
      const a = arr.slice();
      const frames = [];
      let comparisons = 0, swaps = 0;
      const n = a.length;

      // push initial frame
      frames.push({
        arr: a.slice(),
        action: null,
        pass: 0,
        comparisons,
        swaps,
        sortedBoundary: n
      });

      for(let pass=1; pass<=n; pass++){
        let swappedThisPass = false;
        for(let i=0;i<n-pass;i++){
          // compare frame
          comparisons++;
          frames.push({
            arr: a.slice(),
            action: { type:'compare', i:i, j:i+1 },
            pass,
            comparisons,
            swaps,
            sortedBoundary: n - (pass - 1)
          });

          const left = a[i], right = a[i+1];
          const outOfOrder = (order==='asc') ? left > right : left < right;
          if(outOfOrder){
            // swap frame
            [a[i], a[i+1]] = [a[i+1], a[i]];
            swaps++;
            swappedThisPass = true;
            frames.push({
              arr: a.slice(),
              action: { type:'swap', i:i, j:i+1 },
              pass,
              comparisons,
              swaps,
              sortedBoundary: n - (pass - 1)
            });
          }
        }
        // After pass, mark the boundary (last element now sorted)
        frames.push({
          arr: a.slice(),
          action: { type:'mark', index: n - pass },
          pass,
          comparisons,
          swaps,
          sortedBoundary: n - (pass - 1)
        });
        if(!swappedThisPass){
          // already sorted early exit; mark remaining as sorted
          for(let k = n-pass-1; k>=0; k--){
            frames.push({
              arr: a.slice(),
              action: { type:'mark', index: k },
              pass: pass,
              comparisons,
              swaps,
              sortedBoundary: k
            });
          }
          break;
        }
      }
      // final frame to show completed
      frames.push({
        arr: a.slice(),
        action: null,
        pass: Math.ceil(n),
        comparisons,
        swaps,
        sortedBoundary: 0
      });
      return frames;
    }

    // Render bars based on current frame
    function renderFrame(index){
      index = clamp(index, 0, state.frames.length - 1);
      state.frameIndex = index;
      const frame = state.frames[index];
      const arr = frame.arr;
      const count = arr.length;
      barsEl.style.setProperty('--count', count.toString());
      barsEl.style.setProperty('--bar-gap', '8px');

      // If bars are not present or count changed, rebuild DOM
      if(barsEl.children.length !== count){
        barsEl.innerHTML = '';
        for(let i=0;i<count;i++){
          const b = document.createElement('div');
          b.className = 'bar';
          b.setAttribute('role','img');
          b.setAttribute('aria-label', 'array element ' + i);
          const label = document.createElement('div');
          label.className = 'label';
          b.appendChild(label);
          barsEl.appendChild(b);
        }
      }

      // update each bar's height/value
      const maxVal = Math.max(...arr, 1);
      const wrapHeight = barsWrap.clientHeight - 40; // some padding for labels
      for(let i=0;i<count;i++){
        const b = barsEl.children[i];
        const val = arr[i];
        const heightPct = (val / maxVal);
        const px = Math.max(18, Math.round(wrapHeight * heightPct));
        b.style.height = px + 'px';
        b.querySelector('.label').textContent = val;
        // reset classes
        b.classList.remove('compare', 'swap', 'sorted', 'nudge-left', 'nudge-right');
        b.style.zIndex = 1;
      }

      // apply action-based highlights & animations
      if(frame.action){
        if(frame.action.type === 'compare'){
          const i = frame.action.i, j = frame.action.j;
          barsEl.children[i].classList.add('compare');
          barsEl.children[j].classList.add('compare');
          statusText.textContent = `Comparing indices ${i} & ${j}`;
        } else if(frame.action.type === 'swap'){
          const i = frame.action.i, j = frame.action.j;
          const bi = barsEl.children[i];
          const bj = barsEl.children[j];
          // apply swap styles
          bi.classList.add('swap');
          bj.classList.add('swap');
          bi.style.zIndex = 3;
          bj.style.zIndex = 3;
          // nudge animation to emphasize the swap (left/right)
          bi.classList.add('nudge-left');
          bj.classList.add('nudge-right');
          statusText.textContent = `Swapped indices ${i} & ${j}`;
          // remove nudge classes after animation ends to avoid persistent animation
          setTimeout(()=>{ bi.classList.remove('nudge-left'); bj.classList.remove('nudge-right'); }, 320);
        } else if(frame.action.type === 'mark'){
          const idx = frame.action.index;
          if(idx >= 0 && idx < barsEl.children.length){
            barsEl.children[idx].classList.add('sorted');
          }
          statusText.textContent = `Marked index ${idx} as sorted`;
        }
      } else {
        statusText.textContent = 'Idle';
      }

      // Also mark sorted region based on sortedBoundary
      const boundary = frame.sortedBoundary ?? 0;
      for(let k=boundary; k<barsEl.children.length; k++){
        barsEl.children[k].classList.add('sorted');
      }

      // Update stats
      passEl.textContent = 'Pass ' + (frame.pass || 0);
      compCountEl.textContent = 'Comparisons: ' + (frame.comparisons || 0);
      swapCountEl.textContent = 'Swaps: ' + (frame.swaps || 0);
      frameIdxEl.textContent = 'Step: ' + index + ' / ' + (state.frames.length-1);
    }

    // Build frames using current state.array and order, then render first frame
    function buildFramesAndRender(){
      state.frames = buildFrames(state.array, state.order);
      state.frameIndex = 0;
      renderFrame(0);
    }

    // Playback controls
    function play(){
      if(state.playing) return;
      state.playing = true;
      playBtn.textContent = '⏸ Pause';
      scheduleNext();
    }
    function pause(){
      state.playing = false;
      playBtn.textContent = '▶ Play';
      if(state.timer){ clearTimeout(state.timer); state.timer = null; }
    }
    function togglePlay(){
      if(state.playing) pause(); else play();
    }
    function scheduleNext(){
      if(!state.playing) return;
      state.timer = setTimeout(()=>{
        nextStep();
        if(state.frameIndex >= state.frames.length -1){
          pause();
        } else {
          scheduleNext();
        }
      }, state.speed);
    }

    function nextStep(){
      const next = clamp(state.frameIndex + 1, 0, state.frames.length - 1);
      state.frameIndex = next;
      renderFrame(next);
    }
    function prevStep(){
      const prev = clamp(state.frameIndex - 1, 0, state.frames.length - 1);
      state.frameIndex = prev;
      renderFrame(prev);
    }

    // UI wiring
    function attachUI(){
      // Shuffle
      shuffleBtn.onclick = ()=>{
        const size = clamp(parseInt(countEl.value,10) || 8, 2, 20);
        state.array = createRandomArray(size);
        state.order = orderEl.value || 'asc';
        buildFramesAndRender();
        pause();
      };

      // Apply custom array
      applyBtn.onclick = ()=> applyCustomArray();
      arrayInput.addEventListener('keyup', (e)=>{ if(e.key === 'Enter') applyCustomArray(); });

      // Reset (back to initial frame)
      resetBtn.onclick = ()=>{
        state.frameIndex = 0;
        renderFrame(0);
        pause();
      };

      // Reset all (shuffle + settings)
      resetAllBtn.onclick = ()=>{
        countEl.value = '8';
        orderEl.value = 'asc';
        arrayInput.value = '';
        init();
        pause();
      };

      // Step controls
      nextBtn.onclick = ()=>{ nextStep(); pause(); };
      prevBtn.onclick = ()=>{ prevStep(); pause(); };
      playBtn.onclick = ()=> togglePlay();

      // Speed
      speedEl.oninput = (e)=>{
        state.speed = parseInt(e.target.value,10) || 500;
        updateSpeedLabel();
      };

      // Count / order change
      countEl.onchange = ()=>{
        const size = clamp(parseInt(countEl.value,10) || 8, 2, 20);
        state.array = createRandomArray(size);
        buildFramesAndRender();
        pause();
      };
      orderEl.onchange = ()=>{
        state.order = orderEl.value;
        buildFramesAndRender();
        pause();
      };

      // Keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        const tag = document.activeElement.tagName.toLowerCase();
        if(tag === 'input' || tag === 'textarea') return; // don't override typing
        if(e.code === 'Space'){
          e.preventDefault();
          togglePlay();
        } else if(e.code === 'ArrowRight'){
          e.preventDefault();
          nextStep(); pause();
        } else if(e.code === 'ArrowLeft'){
          e.preventDefault();
          prevStep(); pause();
        }
      });

      explainBtn.onclick = ()=> alert('Bubble Sort passes repeatedly compare adjacent elements and swap them when out of order. After each full pass, the largest unsorted item settles at the right. Continue until no swaps occur in a pass.');

    }

    function applyCustomArray(){
      const raw = arrayInput.value.trim();
      if(!raw) { alert('Enter a comma-separated list like: 5,3,8,1,4'); return; }
      const parts = raw.split(',').map(s=>s.trim()).filter(s=>s.length>0);
      if(parts.length === 0){ alert('No values detected.'); return; }
      if(parts.length > 20){ alert('Please enter 20 values or fewer.'); return; }
      const nums = [];
      for(const p of parts){
        const v = Number(p);
        if(Number.isNaN(v)){ alert('Invalid number: ' + p); return; }
        nums.push(Math.round(v));
      }
      state.array = nums;
      // update UI count if possible
      countEl.value = String(Math.min(Math.max(nums.length,2),20));
      buildFramesAndRender();
      pause();
    }

    function updateSpeedLabel(){
      speedLabel.textContent = state.speed + 'ms';
    }

    // Initialize on load
    init();

    // Ensure initial frame sizing once images/fonts load
    window.addEventListener('resize', ()=> renderFrame(state.frameIndex));
  </script>
</body>
</html>