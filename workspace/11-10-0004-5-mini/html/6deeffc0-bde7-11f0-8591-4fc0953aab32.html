<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>K-Nearest Neighbors — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1720;
      --panel: #0b1220;
      --muted: #9aa7b7;
      --accent: #60a5fa;
      --red: #ef4444;
      --blue: #3b82f6;
      --query: #10b981;
      --glass: rgba(255,255,255,0.04);
      --card-radius: 12px;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071024 0%, #071622 60%);color:#e6eef6}
    main{
      padding: var(--safe-margin);
      min-height:100%;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      gap:var(--gap);
    }

    /* Layout */
    .module{
      width:100%;
      max-width:1200px;
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
    }
    .left, .right{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--card-radius);
      padding:18px;
      box-shadow: 0 6px 22px rgba(2,6,23,0.6);
    }
    .left{flex:1; min-width:420px; display:flex; flex-direction:column; gap:var(--gap)}
    .right{width:380px; min-width:300px; display:flex; flex-direction:column; gap:var(--gap)}

    /* Header / Title */
    .title{
      display:flex;
      align-items:baseline;
      gap:12px;
    }
    .title h1{font-size:20px;margin:0}
    .subtitle{color:var(--muted); font-size:13px; margin:0}

    /* Canvas area */
    .canvas-wrap{
      background:var(--panel);
      border-radius:10px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:stretch;
    }
    .controls{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
      align-items:center;
    }
    .controls > *{min-width:0}
    .tool-buttons{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .tool-buttons button, button.control{
      background:var(--glass);
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.04);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }
    .tool-buttons button.active{
      background:linear-gradient(90deg, rgba(96,165,250,0.16), rgba(16,185,129,0.06));
      color:#e6f2ff;
      box-shadow: 0 4px 14px rgba(96,165,250,0.08);
    }
    label.inline{display:inline-flex;align-items:center;gap:8px;color:var(--muted);font-size:13px}
    .k-control{display:flex;gap:8px;align-items:center}
    input[type="range"]{width:160px}

    canvas{
      border-radius:8px;
      width:100%;
      height:460px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      outline: 2px solid rgba(255,255,255,0.02);
      cursor:crosshair;
    }

    /* Info / legend */
    .legend{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .chip{display:inline-flex;align-items:center;gap:8px;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}
    .dot{width:12px;height:12px;border-radius:50%}
    .dot.red{background:var(--red)}
    .dot.blue{background:var(--blue)}
    .dot.query{background:var(--query)}

    /* Right column text sections */
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
      padding:14px;
      border-radius:10px;
      color:var(--muted);
      font-size:14px;
      line-height:1.4;
    }
    h3{margin:0 0 8px 0;font-size:15px}
    p.small{font-size:13px;color:var(--muted);margin:6px 0}

    /* Result badge */
    .result{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .result .big{
      font-size:20px;
      font-weight:600;
    }
    .result .badge{
      padding:8px 12px;border-radius:8px;color:white;font-weight:600;
    }
    .badge.red{background:linear-gradient(90deg,#ff6b6b,#ef4444)}
    .badge.blue{background:linear-gradient(90deg,#60a5fa,#3b82f6)}
    .badge.unknown{background:linear-gradient(90deg,#9ca3ff,#a78bfa)}

    /* small footer */
    .hint{font-size:13px;color:var(--muted)}

    /* responsiveness */
    @media (max-width:980px){
      .module{flex-direction:column}
      .left,.right{width:100%}
      canvas{height:360px}
    }

  </style>
</head>
<body>
  <main>
    <div class="module" role="application" aria-label="Interactive K-Nearest Neighbors module">
      <!-- LEFT: interactive canvas and controls -->
      <section class="left" aria-labelledby="title">
        <div class="title" id="title">
          <div>
            <h1>K-Nearest Neighbors (KNN) — Interactive Visualizer</h1>
            <p class="subtitle">Explore classification by adjusting K and placing points.</p>
          </div>
        </div>

        <div class="canvas-wrap" role="region" aria-label="Interactive canvas and controls">
          <div class="controls" role="toolbar" aria-label="Tools">
            <div class="tool-buttons" role="group" aria-label="Point tools">
              <button id="tool-move" class="control active" title="Move points (default)">Move</button>
              <button id="tool-red" class="control" title="Add red class point">Add Red</button>
              <button id="tool-blue" class="control" title="Add blue class point">Add Blue</button>
              <button id="tool-query" class="control" title="Place query point">Place Query</button>
              <button id="tool-delete" class="control" title="Delete point">Delete</button>
            </div>

            <div style="flex:1"></div>

            <div class="k-control" aria-label="K selector">
              <label class="inline" for="kRange" style="white-space:nowrap">k</label>
              <input type="range" id="kRange" min="1" max="7" value="3" aria-valuemin="1" aria-valuemax="15" aria-valuenow="3">
              <div id="kValue" class="chip" style="min-width:48px;justify-content:center">3</div>
            </div>

            <div style="display:flex;gap:12px;align-items:center">
              <label class="inline" aria-label="Distance metric">Metric:
                <select id="metric" style="margin-left:8px;padding:6px;border-radius:8px;background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04)">
                  <option value="euclid">Euclidean</option>
                  <option value="manhattan">Manhattan</option>
                </select>
              </label>
            </div>

          </div>

          <canvas id="knnCanvas" width="840" height="600" role="img" aria-label="KNN scatter plot"></canvas>

          <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap">
            <div class="legend" aria-hidden="true">
              <div class="chip"><span class="dot red"></span> Class A</div>
              <div class="chip"><span class="dot blue"></span> Class B</div>
              <div class="chip"><span class="dot query"></span> Query</div>
            </div>

            <div style="display:flex;gap:12px;align-items:center">
              <button id="clearButton" class="control" title="Reset all points">Clear</button>
              <div class="hint">Tip: Drag points to reposition. Press Delete to remove selected point.</div>
            </div>
          </div>
        </div>

        <div class="panel" aria-live="polite">
          <h3>Live Info</h3>
          <p class="small" id="liveText">Place training points and a query point to see KNN classification. Neighbors are highlighted and decision region updates automatically.</p>
        </div>
      </section>

      <!-- RIGHT: Explanations, objectives, interaction design, layout description -->
      <aside class="right" aria-labelledby="conceptTitle">
        <div class="panel" id="conceptTitle">
          <h3>Concept Title</h3>
          <p class="small">K-Nearest Neighbors (KNN) — a simple instance-based classifier that assigns a label to a query based on the labels of the k closest training examples.</p>
        </div>

        <div class="panel">
          <h3>Learning Objective</h3>
          <p class="small">After interacting with this module you will be able to:
            - see how changing k affects classification,
            - observe how distance metrics influence neighbors,
            - and intuitively understand the trade-off between local sensitivity (small k) and smoothing (large k).
          </p>
        </div>

        <div class="panel">
          <h3>Interaction Design</h3>
          <p class="small">
            Controls:
            - Select a tool: Move, Add Red, Add Blue, Place Query, or Delete.
            - Click on the canvas to add points (in add modes) or place the query.
            - Drag training points to reposition them in Move mode.
            - Use the k slider to change the number of neighbors considered.
            - Choose Euclidean or Manhattan distance to see different neighbor shapes.
          </p>
          <p class="small">
            Visual feedback:
            - The canvas displays a colored decision region (red/blue) computed by voting among the k nearest training points.
            - The k nearest neighbors to the query are connected with lines and given an animated pulse.
            - The classification result is shown in the Result badge below.
            - Animations and gradual color transitions reinforce how local points influence the decision.
          </p>
        </div>

        <div class="panel">
          <h3>Layout Description</h3>
          <p class="small">
            Spatial organization:
            - Left column: interactive area (controls above, canvas large in middle, legend and actions below).
            - Right column: instructional panels (title, objective, interaction details).
            - Safe margins of 24px on all sides; internal gaps of at least 16px between controls.
            - Controls grouped by function with clear visual affordances; canvas uses high contrast markers and large hit targets for accessibility.
            - Responsive: columns stack on narrow screens, canvas height reduces for smaller devices.
          </p>
        </div>

        <div class="panel">
          <h3>Result</h3>
          <div class="result" aria-live="polite">
            <div>
              <div class="big" id="resultLabel">No query</div>
              <div class="small" id="resultDetail" style="color:var(--muted)">Place a query point to classify it.</div>
            </div>
            <div id="resultBadge" class="badge unknown">—</div>
          </div>
        </div>

      </aside>
    </div>
  </main>

  <script>
    // Interactive KNN Visualizer (vanilla JS)
    // Strict but straightforward implementation. No libraries.
    (function(){
      // Layout & constraints
      const canvas = document.getElementById('knnCanvas');
      const ctx = canvas.getContext('2d');
      // For device pixel ratio crispness
      function setupCanvasSize() {
        const ratio = Math.min(window.devicePixelRatio || 1, 2);
        const style = window.getComputedStyle(canvas);
        const cssW = parseInt(style.width);
        const cssH = parseInt(style.height);
        canvas.width = Math.round(cssW * ratio);
        canvas.height = Math.round(cssH * ratio);
        ctx.setTransform(ratio,0,0,ratio,0,0);
      }
      setupCanvasSize();
      window.addEventListener('resize', () => { setupCanvasSize(); draw(); });

      // State
      let training = []; // {id,x,y,label} label: 'red'|'blue'
      let query = null; // {x,y}
      let selectedPointId = null;
      let dragging = null;
      let mouseDown = false;

      const tools = {
        MOVE: 'move', RED: 'red', BLUE: 'blue', QUERY: 'query', DELETE: 'delete'
      };
      let currentTool = tools.MOVE;

      // UI elements
      const btnMove = document.getElementById('tool-move');
      const btnRed = document.getElementById('tool-red');
      const btnBlue = document.getElementById('tool-blue');
      const btnQuery = document.getElementById('tool-query');
      const btnDelete = document.getElementById('tool-delete');
      const clearButton = document.getElementById('clearButton');
      const kRange = document.getElementById('kRange');
      const kValue = document.getElementById('kValue');
      const metricSelect = document.getElementById('metric');
      const liveText = document.getElementById('liveText');
      const resultLabel = document.getElementById('resultLabel');
      const resultDetail = document.getElementById('resultDetail');
      const resultBadge = document.getElementById('resultBadge');

      function setTool(toolButton, toolName) {
        [btnMove, btnRed, btnBlue, btnQuery, btnDelete].forEach(b => b.classList.remove('active'));
        toolButton.classList.add('active');
        currentTool = toolName;
        canvas.style.cursor = (toolName === tools.MOVE) ? 'grab' : 'crosshair';
        if (toolName === tools.DELETE) canvas.style.cursor = 'not-allowed';
      }

      btnMove.addEventListener('click', () => setTool(btnMove, tools.MOVE));
      btnRed.addEventListener('click', () => setTool(btnRed, tools.RED));
      btnBlue.addEventListener('click', () => setTool(btnBlue, tools.BLUE));
      btnQuery.addEventListener('click', () => setTool(btnQuery, tools.QUERY));
      btnDelete.addEventListener('click', () => setTool(btnDelete, tools.DELETE));
      clearButton.addEventListener('click', () => {
        training = []; query = null; selectedPointId = null; updateKMax(); draw(); updateResult();
      });

      // K control
      function updateKMax(){
        const max = Math.max(1, training.length);
        kRange.max = Math.max(1, Math.min(25, max));
        if (Number(kRange.value) > kRange.max) kRange.value = kRange.max;
        kValue.textContent = kRange.value;
        kRange.setAttribute('aria-valuemax', kRange.max);
        kRange.setAttribute('aria-valuenow', kRange.value);
      }
      kRange.addEventListener('input', ()=>{ kValue.textContent = kRange.value; kRange.setAttribute('aria-valuenow', kRange.value); draw(); updateResult(); });
      metricSelect.addEventListener('change', ()=> { draw(); updateResult(); });

      // Utility
      function canvasPos(evt){
        const rect = canvas.getBoundingClientRect();
        return {
          x: (evt.clientX - rect.left),
          y: (evt.clientY - rect.top)
        };
      }

      // Point helpers
      let idCounter = 1;
      function addTraining(x,y,label){
        training.push({id: idCounter++, x, y, label});
        updateKMax();
        draw();
      }
      function setQuery(x,y){ query = {x,y}; draw(); updateResult(); }

      function findPointAt(x,y, radius=10){
        // search training points first (topmost = last)
        for(let i=training.length-1;i>=0;i--){
          const p = training[i];
          const dx = p.x - x, dy = p.y - y;
          if (Math.hypot(dx,dy) <= radius) return {type:'train', point:p};
        }
        if (query){
          const dx = query.x - x, dy = query.y - y;
          if (Math.hypot(dx,dy) <= radius) return {type:'query', point:query};
        }
        return null;
      }

      // Distance functions
      function dist(a,b, metric){
        const dx = a.x - b.x, dy = a.y - b.y;
        if (metric === 'manhattan') return Math.abs(dx)+Math.abs(dy);
        return Math.hypot(dx,dy);
      }

      // Nearest neighbors
      function kNearest(q, k, metric){
        if (!q) return [];
        const arr = training.map(p => ({p, d: dist(p,q,metric)}));
        arr.sort((a,b)=>a.d-b.d);
        return arr.slice(0,k);
      }

      // Decision region computation: sample grid and compute majority among k nearest.
      // Compute a coarse grid for performance.
      function computeDecisionGrid(cellSize = 6){
        const w = canvas.clientWidth, h = canvas.clientHeight;
        const cols = Math.ceil(w / cellSize), rows = Math.ceil(h / cellSize);
        const grid = new Uint8Array(cols*rows); // 0 none, 1 red, 2 blue, 3 tie
        const metric = metricSelect.value;
        const k = Math.max(1, Math.min(parseInt(kRange.value), Math.max(1, training.length)));
        if (training.length === 0) return {cols,rows,cellSize,grid};
        for (let r=0;r<rows;r++){
          for (let c=0;c<cols;c++){
            const x = c*cellSize + cellSize/2;
            const y = r*cellSize + cellSize/2;
            // vote by k nearest
            const arr = training.map(p=>({label:p.label,d:dist({x,y},p,metric)}));
            arr.sort((a,b)=>a.d-b.d);
            const counts = {red:0,blue:0};
            for (let i=0;i<k && i<arr.length;i++) counts[arr[i].label]++;
            let val = 0;
            if (counts.red > counts.blue) val = 1;
            else if (counts.blue > counts.red) val = 2;
            else val = 3; // tie/unknown
            grid[r*cols + c] = val;
          }
        }
        return {cols,rows,cellSize,grid};
      }

      // Rendering
      let animTime = 0;
      function draw(time){
        if (time) animTime = time/1000;
        const w = canvas.clientWidth, h = canvas.clientHeight;
        ctx.clearRect(0,0,w,h);

        // Decision region
        const gridData = computeDecisionGrid(6);
        const {cols,rows,cellSize,grid} = gridData;
        for (let r=0;r<rows;r++){
          for (let c=0;c<cols;c++){
            const val = grid[r*cols + c];
            if (val === 0) continue;
            const x = c*cellSize, y = r*cellSize;
            if (val === 1) ctx.fillStyle = 'rgba(239,68,68,0.08)'; // red pastel
            else if (val === 2) ctx.fillStyle = 'rgba(59,130,246,0.08)';
            else ctx.fillStyle = 'rgba(156,163,175,0.04)'; // tie = grayish
            ctx.fillRect(x, y, cellSize+1, cellSize+1);
          }
        }

        // Axes grid lines (subtle)
        ctx.strokeStyle = 'rgba(255,255,255,0.02)';
        ctx.lineWidth = 1;
        for (let x=0;x<w;x+=60){
          ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,h); ctx.stroke();
        }
        for (let y=0;y<h;y+=60){
          ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(w,y+0.5); ctx.stroke();
        }

        // Draw training points
        for (let p of training){
          drawPoint(p.x,p.y, p.label === 'red' ? '#ef4444' : '#3b82f6', 8, p.id === selectedPointId);
        }

        // If query exists, compute neighbors
        if (query){
          // draw lines to k nearest
          const k = Math.max(1, Math.min(parseInt(kRange.value), Math.max(1, training.length)));
          const metric = metricSelect.value;
          const neighbors = kNearest(query, k, metric);
          // Draw neighbor lines
          for (let i=0;i<neighbors.length;i++){
            const item = neighbors[i];
            ctx.strokeStyle = (item.p.label === 'red') ? 'rgba(239,68,68,0.9)' : 'rgba(59,130,246,0.9)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(query.x, query.y);
            ctx.lineTo(item.p.x, item.p.y);
            ctx.stroke();
            // animated pulse at neighbor
            const pulse = 6 + 4*Math.abs(Math.sin(animTime*3 + i));
            ctx.beginPath();
            ctx.strokeStyle = (item.p.label === 'red') ? 'rgba(239,68,68,0.22)' : 'rgba(59,130,246,0.22)';
            ctx.lineWidth = 2;
            ctx.arc(item.p.x, item.p.y, 12 + pulse, 0, Math.PI*2);
            ctx.stroke();
          }

          // Draw query point big
          ctx.beginPath();
          ctx.fillStyle = 'rgba(16,185,129,0.12)';
          ctx.arc(query.x, query.y, 18, 0, Math.PI*2);
          ctx.fill();

          ctx.beginPath();
          ctx.fillStyle = '#10b981';
          ctx.strokeStyle = '#0b6b4a';
          ctx.lineWidth = 2;
          ctx.arc(query.x, query.y, 8, 0, Math.PI*2);
          ctx.fill();
          ctx.stroke();
        }

        // Bring points to top (draw outlines)
        for (let p of training){
          ctx.beginPath();
          ctx.strokeStyle = 'rgba(0,0,0,0.45)';
          ctx.lineWidth = 2;
          ctx.arc(p.x, p.y, 9, 0, Math.PI*2);
          ctx.stroke();
        }

        // Selected point highlight
        if (selectedPointId){
          const p = training.find(pp=>pp.id===selectedPointId);
          if (p){
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(96,165,250,0.9)';
            ctx.lineWidth = 2;
            ctx.arc(p.x, p.y, 14, 0, Math.PI*2);
            ctx.stroke();
          }
        }

        // overlay text for small training counts
        if (training.length === 0){
          ctx.fillStyle = 'rgba(255,255,255,0.06)';
          ctx.font = '14px Inter, Arial';
          ctx.fillText('No training points yet — add red/blue points to explore.', 14, 20);
        }

        // schedule next frame for animation
        requestAnimationFrame(draw);
      }

      function drawPoint(x,y,color,radius, selected=false){
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(x,y, radius, 0, Math.PI*2);
        ctx.fill();
      }

      // Interaction: mouse events
      canvas.addEventListener('mousedown', (e)=>{
        mouseDown = true;
        const pos = canvasPos(e);
        if (currentTool === tools.MOVE){
          const hit = findPointAt(pos.x,pos.y, 12);
          if (hit && hit.type === 'train'){
            dragging = hit.point;
            selectedPointId = hit.point.id;
            canvas.style.cursor = 'grabbing';
          } else if (hit && hit.type === 'query'){
            dragging = query; selectedPointId = null; canvas.style.cursor = 'grabbing';
          } else {
            selectedPointId = null;
          }
          draw();
          updateResult();
        } else if (currentTool === tools.RED || currentTool === tools.BLUE){
          addTraining(pos.x,pos.y, currentTool === tools.RED ? 'red' : 'blue');
        } else if (currentTool === tools.QUERY){
          setQuery(pos.x,pos.y);
        } else if (currentTool === tools.DELETE){
          const hit = findPointAt(pos.x,pos.y, 12);
          if (hit){
            if (hit.type === 'train'){
              training = training.filter(p=>p.id !== hit.point.id);
            } else if (hit.type === 'query'){
              query = null;
            }
            selectedPointId = null;
            updateKMax(); draw(); updateResult();
          }
        }
      });

      canvas.addEventListener('mousemove', (e)=>{
        const pos = canvasPos(e);
        if (dragging && mouseDown){
          dragging.x = pos.x;
          dragging.y = pos.y;
          draw();
          updateResult();
        }
      });

      window.addEventListener('mouseup', (e)=>{
        mouseDown = false;
        if (dragging) {
          dragging = null; canvas.style.cursor = currentTool === tools.MOVE ? 'grab' : 'crosshair';
        }
      });

      // Keyboard: delete selected training point when selected
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'Delete' || e.key === 'Backspace'){
          if (selectedPointId){
            training = training.filter(p=>p.id !== selectedPointId);
            selectedPointId = null;
            updateKMax(); draw(); updateResult();
          } else if (query){
            query = null; draw(); updateResult();
          }
        }
      });

      // Update result panel
      function updateResult(){
        if (!query){
          resultLabel.textContent = 'No query';
          resultDetail.textContent = 'Place a query point to classify it.';
          resultBadge.textContent = '—';
          resultBadge.className = 'badge unknown';
          return;
        }
        if (training.length === 0){
          resultLabel.textContent = 'No training points';
          resultDetail.textContent = 'Add some red/blue training points.';
          resultBadge.textContent = '—';
          resultBadge.className = 'badge unknown';
          return;
        }
        const metric = metricSelect.value;
        const k = Math.max(1, Math.min(parseInt(kRange.value), Math.max(1, training.length)));
        const neighbors = kNearest(query, k, metric);
        const counts = {red:0,blue:0};
        for (let n of neighbors) counts[n.p.label]++;
        let label = null; let certainty = 0;
        if (counts.red > counts.blue){ label='Red (A)'; resultBadge.className='badge red'; resultBadge.textContent='A'; }
        else if (counts.blue > counts.red){ label='Blue (B)'; resultBadge.className='badge blue'; resultBadge.textContent='B'; }
        else { label='Tie/Undecided'; resultBadge.className='badge unknown'; resultBadge.textContent='?'; }
        // compute distances for detail
        const dstr = neighbors.slice(0,Math.min(5,neighbors.length)).map(n => `${n.p.label.charAt(0).toUpperCase()}:${n.d.toFixed(1)}`).join(', ');
        resultLabel.textContent = label;
        resultDetail.textContent = `k=${k} · metric=${metric} · neighbors: ${dstr}`;
      }

      // Initial seeds for demonstration
      function seedDemo(){
        training = [];
        addTraining(120,150,'red'); addTraining(160,220,'red'); addTraining(200,120,'red');
        addTraining(420,360,'blue'); addTraining(500,320,'blue'); addTraining(480,380,'blue');
        setQuery(320,240);
      }

      // Hook up UI initial states
      setTool(btnMove, tools.MOVE);
      updateKMax();
      seedDemo();
      updateKMax();
      // Start animation loop
      requestAnimationFrame(draw);
      // Update result panel whenever controls change
      kRange.addEventListener('input', updateResult);
      metricSelect.addEventListener('change', updateResult);

      // Periodic update for result to reflect animation changes and neighbor changes
      setInterval(updateResult, 200);

      // Accessibility notes: allow keyboard to switch tools (1-5)
      window.addEventListener('keydown', (e)=>{
        if (e.key === '1') setTool(btnMove, tools.MOVE);
        if (e.key === '2') setTool(btnRed, tools.RED);
        if (e.key === '3') setTool(btnBlue, tools.BLUE);
        if (e.key === '4') setTool(btnQuery, tools.QUERY);
        if (e.key === '5') setTool(btnDelete, tools.DELETE);
      });

      // Expose draw for debug (not necessary)
      window._knn = {training, setQuery, addTraining, draw};
    })();
  </script>
</body>
</html>