<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stack — Interactive Learning Module</title>
  <style>
    /* Safe area margins: 24px around viewport */
    :root {
      --safe-margin: 24px;
      --min-gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #7c5cff;
      --accent-2: #3ddc97;
      --muted: #93a0b8;
      --glass: rgba(255,255,255,0.03);
      --danger: #ff6b6b;
      --success: #2dd4bf;
      --max-width: 1100px;
      --stack-width: 220px;
      --chip-height: 40px;
    }
    html,body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg, #071028 0%, #071221 60%);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #e6eef8;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .app {
      max-width: var(--max-width);
      margin: var(--safe-margin) auto;
      padding: var(--safe-margin);
      box-sizing: border-box;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    }
    header {
      display: flex;
      gap: var(--min-gap);
      align-items: baseline;
      flex-wrap: wrap;
      margin-bottom: 18px;
    }
    h1 {
      font-size: 20px;
      margin: 0;
      letter-spacing: -0.2px;
    }
    .subtitle {
      color: var(--muted);
      font-size: 13px;
      margin-left: auto;
    }

    /* Layout: two-column responsive */
    .container {
      display: grid;
      grid-template-columns: 1fr 420px;
      gap: var(--min-gap);
    }
    @media (max-width: 980px) {
      .container { grid-template-columns: 1fr; }
    }

    /* Left: Visual interactive area */
    .visual {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      padding: 18px;
      border-radius: 10px;
      min-height: 420px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .stack-shell {
      display: flex;
      gap: var(--min-gap);
      align-items: flex-start;
      flex-wrap: wrap;
    }

    /* Stack canvas */
    .stack-canvas {
      width: var(--stack-width);
      min-height: 320px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 10px;
      padding: 12px;
      box-sizing: border-box;
      position: relative;
    }
    .stack-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 13px;
      color: var(--muted);
    }
    .stack-visual {
      --slot-h: 48px;
      display: flex;
      flex-direction: column-reverse; /* bottom = base, top = end */
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
      height: calc(var(--slot-h) * 6 + 10px * 5); /* default capacity 6 for layout */
      padding: 8px 6px;
      box-sizing: border-box;
      width: 100%;
      position: relative;
    }
    .stack-slot {
      width: 100%;
      height: 48px;
      border-radius: 8px;
      background: rgba(255,255,255,0.02);
      border: 1px dashed rgba(255,255,255,0.03);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-weight: 600;
      position: relative;
      box-sizing: border-box;
    }
    .stack-item {
      position: absolute;
      left: 6px;
      right: 6px;
      height: 40px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(90deg, rgba(124,92,255,0.18), rgba(61,220,151,0.08));
      border: 1px solid rgba(255,255,255,0.06);
      color: #ffffff;
      font-weight: 700;
      transform-origin: center;
      transition: transform 400ms cubic-bezier(.2,.9,.2,1), opacity 300ms;
      box-shadow: 0 6px 18px rgba(12,14,20,0.6);
    }
    .stack-item.top-highlight {
      box-shadow: 0 10px 30px rgba(124,92,255,0.18);
      outline: 3px solid rgba(124,92,255,0.12);
    }
    .stack-index {
      position: absolute;
      left: -34px;
      top: 6px;
      font-size: 12px;
      color: var(--muted);
      width: 28px;
      text-align: right;
    }

    /* Controls panel (right) */
    .controls {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      padding: 18px;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      min-height: 420px;
      box-sizing: border-box;
    }
    label {
      font-size: 13px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }
    .input-row {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    input[type="text"] {
      flex: 1;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.04);
      background: rgba(255,255,255,0.02);
      color: #eaf2ff;
      font-size: 14px;
      outline: none;
    }
    input[type="text"]:focus {
      box-shadow: 0 6px 18px rgba(124,92,255,0.06);
      border-color: rgba(124,92,255,0.32);
    }
    button {
      padding: 10px 12px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: 700;
      font-size: 13px;
      color: #061425;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      box-shadow: 0 8px 20px rgba(12,14,20,0.45);
    }
    button.secondary {
      background: rgba(255,255,255,0.03);
      color: var(--muted);
      border: 1px solid rgba(255,255,255,0.02);
      box-shadow: none;
    }
    .btn-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .small {
      padding: 8px 10px;
      font-size: 13px;
    }

    /* Palette of draggable chips */
    .palette {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      padding: 8px 4px;
      border-radius: 8px;
      background: rgba(255,255,255,0.01);
    }
    .chip {
      height: var(--chip-height);
      min-width: 64px;
      padding: 0 12px;
      border-radius: 10px;
      background: linear-gradient(90deg, rgba(124,92,255,0.18), rgba(61,220,151,0.06));
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 700;
      cursor: grab;
      user-select: none;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .chip:active { cursor: grabbing; }

    /* Messages and log */
    .message {
      font-size: 13px;
      color: var(--muted);
      min-height: 20px;
    }
    .message.important { color: var(--accent); font-weight: 700; }
    .message.error { color: var(--danger); font-weight: 700; }
    .log {
      margin-top: 6px;
      background: rgba(0,0,0,0.04);
      padding: 8px;
      border-radius: 8px;
      max-height: 120px;
      overflow: auto;
      font-size: 13px;
      color: var(--muted);
    }

    /* Animations: floating clone moving */
    .floating {
      position: fixed;
      pointer-events: none;
      z-index: 9999;
      transition: transform 420ms cubic-bezier(.2,.9,.2,1), opacity 320ms;
      will-change: transform, opacity;
    }
    .shake {
      animation: shake 420ms;
    }
    @keyframes shake {
      0% { transform: translateX(0); }
      20% { transform: translateX(-8px); }
      40% { transform: translateX(8px); }
      60% { transform: translateX(-6px); }
      80% { transform: translateX(6px); }
      100% { transform: translateX(0); }
    }
    .fade-out {
      opacity: 0;
      transform: scale(0.9) translateY(-8px);
    }

    /* small helpers */
    .muted { color: var(--muted); }
    .row { display:flex; gap:12px; align-items:center; }
    .flex { flex:1; }
    .explain {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.4;
      margin-top: 6px;
    }

    /* Accessibility focus */
    button:focus, .chip:focus, input:focus {
      outline: 3px solid rgba(124,92,255,0.12);
      outline-offset: 2px;
    }

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Stack interactive module">
    <header>
      <h1>Stack — LIFO (Last In, First Out)</h1>
      <div class="subtitle">Interactive module • Push, Pop, Peek, Drag & Drop • Animations</div>
    </header>

    <!-- Interactive Design Plan (required textual sections) -->
    <section class="explain" aria-hidden="false">
      <strong>Concept Title:</strong> Stack — Last In, First Out (LIFO) data structure.<br>
      <strong>Learning Objective:</strong> After interacting with this module, you should be able to:
      <ul>
        <li>Understand the LIFO behavior of a stack (push adds to the top, pop removes from the top).</li>
        <li>Perform push/pop/peek operations and observe visual & animated state changes.</li>
        <li>Recognize stack overflow and underflow conditions and how capacity limits affect operations.</li>
      </ul>
      <strong>Interaction Design:</strong>
      <p class="muted">
        Users interact via: typing values and pressing "Push", dragging chips from the palette into the stack area,
        and using "Pop", "Peek", "Clear" buttons. Each push produces an animated item that moves into the top slot;
        popping animates the top item out. Visual highlights mark the current top element. When capacity is exceeded
        a shake animation and an error message indicate overflow; attempting to pop from an empty stack triggers
        an underflow message and feedback. A live operation log and accessible ARIA messages describe state changes.
      </p>
      <strong>Layout Description:</strong>
      <p class="muted">
        The page uses a two-column responsive layout with a visual canvas (left) and controls/explanations (right).
        Safe area margins are 24px and minimum spacing between interactive elements is 16px. The left column shows the
        stack visualization and index markers. The right column contains controls (input, push/pop/peek buttons, capacity
        slider), a draggable palette, messages, and an operation log. Visual hierarchy and spacing keep focus on the stack
        while controls are clearly labeled and keyboard accessible.
      </p>
    </section>

    <!-- Main interactive container -->
    <div class="container" style="margin-top:14px;">
      <!-- Visual stack area -->
      <div class="visual" aria-live="polite">
        <div class="stack-shell" style="justify-content: space-between;">
          <div class="stack-canvas" id="stackCanvas" aria-label="Stack visualization">
            <div class="stack-title">
              <div>Stack (top at top)</div>
              <div class="muted" id="capacityLabel">Capacity: 6</div>
            </div>

            <div class="stack-visual" id="stackVisual" tabindex="0" aria-describedby="stackHint" role="listbox">
              <!-- stack slots and items inserted dynamically -->
            </div>

            <div id="stackHint" class="muted" style="margin-top:8px; font-size:13px;">
              Tip: Drag chips into the stack or use the controls to push values. Use Pop to remove from top.
            </div>
          </div>

          <!-- Array-style view for memory visualization -->
          <div style="flex:1; min-width:260px;">
            <div style="font-size:13px; color:var(--muted); margin-bottom:8px;">Memory view (top index shown)</div>
            <div style="background:var(--glass); padding:12px; border-radius:8px; min-height:220px;">
              <div id="memoryView" class="log" aria-live="polite" style="min-height:180px;"></div>
            </div>
          </div>
        </div>

        <!-- Palette for draggable chips -->
        <div style="margin-top:12px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
            <div style="font-size:13px; color:var(--muted);">Value palette — drag into stack</div>
            <div style="font-size:12px; color:var(--muted);">Keyboard: type and Push or create chip</div>
          </div>
          <div class="palette" id="palette" aria-label="Palette of values" role="list">
            <!-- default chips -->
            <div class="chip" role="option" tabindex="0" data-value="A">A</div>
            <div class="chip" role="option" tabindex="0" data-value="B">B</div>
            <div class="chip" role="option" tabindex="0" data-value="C">C</div>
            <div class="chip" role="option" tabindex="0" data-value="1">1</div>
            <div class="chip" role="option" tabindex="0" data-value="2">2</div>
            <div class="chip" role="option" tabindex="0" data-value="3">3</div>
          </div>
        </div>

      </div>

      <!-- Controls panel -->
      <aside class="controls" aria-label="Controls">
        <div>
          <label for="valueInput">Value (type then Push)</label>
          <div class="input-row">
            <input id="valueInput" type="text" placeholder="Enter value (e.g. X, 42, hello)" aria-label="Value to push" />
            <button id="pushBtn" class="small">Push</button>
            <button id="createChipBtn" class="small secondary" title="Add typed value to palette">Create Chip</button>
          </div>
        </div>

        <div>
          <label>Operations</label>
          <div class="btn-row">
            <button id="popBtn" class="small">Pop</button>
            <button id="peekBtn" class="small secondary">Peek</button>
            <button id="clearBtn" class="small secondary">Clear</button>
            <div style="flex:1"></div>
            <div style="align-self:center; font-size:13px; color:var(--muted);">Size: <span id="sizeLabel">0</span></div>
          </div>
        </div>

        <div>
          <label for="capacityRange">Capacity</label>
          <div class="row">
            <input id="capacityRange" type="range" min="2" max="10" value="6" aria-label="Stack capacity slider" />
            <div style="width:48px; text-align:right; font-weight:700;" id="capacityValue">6</div>
          </div>
          <div class="muted" style="font-size:12px; margin-top:6px;">
            Adjust capacity to see how overflow behaves. Default capacity lets you experiment without immediate overflow.
          </div>
        </div>

        <div>
          <label>Messages</label>
          <div id="message" class="message" role="status" aria-live="polite"></div>
          <div id="opLog" class="log" aria-live="polite"></div>
        </div>

        <div style="margin-top:auto; font-size:12px;" class="muted">
          Controls are keyboard accessible. Use Tab to focus palette chips and Enter to drag-push them,
          or type a value and press Enter to Push.
        </div>

      </aside>
    </div>
  </div>

  <script>
    /*
      Stack Interactive Module (vanilla JS)
      - Supports push, pop, peek, clear
      - Drag chips into stack, or click focused chip to push
      - Animated floating clone moves into stack; popped items animate out
      - Capacity slider controls maximum size (overflow triggers shake + message)
      - Accessible: aria-live messages, keyboard support
    */

    (function () {
      // DOM elements
      const stackVisual = document.getElementById('stackVisual');
      const memoryView = document.getElementById('memoryView');
      const opLog = document.getElementById('opLog');
      const messageEl = document.getElementById('message');
      const sizeLabel = document.getElementById('sizeLabel');
      const capacityRange = document.getElementById('capacityRange');
      const capacityLabel = document.getElementById('capacityLabel');
      const capacityValue = document.getElementById('capacityValue');
      const valueInput = document.getElementById('valueInput');
      const pushBtn = document.getElementById('pushBtn');
      const popBtn = document.getElementById('popBtn');
      const peekBtn = document.getElementById('peekBtn');
      const clearBtn = document.getElementById('clearBtn');
      const palette = document.getElementById('palette');
      const createChipBtn = document.getElementById('createChipBtn');

      // Internal stack state
      let stack = [];
      let capacity = parseInt(capacityRange.value, 10) || 6;
      let animating = false;

      // Initialize UI
      capacityLabel.textContent = `Capacity: ${capacity}`;
      capacityValue.textContent = capacity;
      renderStack();

      // Utilities
      function logOp(text) {
        const time = new Date().toLocaleTimeString();
        opLog.insertAdjacentHTML('afterbegin', `<div style="padding:6px 0">[${time}] ${escapeHtml(text)}</div>`);
      }
      function setMessage(text, type = 'info') {
        messageEl.textContent = text;
        messageEl.className = 'message';
        if (type === 'error') messageEl.classList.add('error');
        if (type === 'important') messageEl.classList.add('important');
      }
      function escapeHtml(s) {
        return (''+s).replace(/[&<>"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
      }

      // Render stack slots and items
      function renderStack() {
        // Clear existing
        stackVisual.innerHTML = '';
        // We'll create capacity number of slots visually (index 0 at base)
        const slots = [];
        for (let i = 0; i < capacity; i++) {
          const slot = document.createElement('div');
          slot.className = 'stack-slot';
          // show index on the left
          const idx = document.createElement('div');
          idx.className = 'stack-index muted';
          idx.textContent = i;
          slot.appendChild(idx);
          stackVisual.appendChild(slot);
          slots.push(slot);
        }

        // Place items absolutely within the stackVisual container.
        // We'll compute bottom positions for each item.
        // First, grab the coordinates to compute transforms.
        requestAnimationFrame(() => {
          const rect = stackVisual.getBoundingClientRect();
          const slotHeight = (slots[0].getBoundingClientRect().height + 10) || 58;
          stack.forEach((val, idx) => {
            const item = document.createElement('div');
            item.className = 'stack-item';
            item.setAttribute('role','option');
            item.setAttribute('aria-label', `Stack item ${val} at index ${idx}`);
            item.textContent = val;
            // Compute bottom offset: index 0 is base, so bottom = base + idx * (slotHeight)
            const bottomOffset = 8 + idx * slotHeight;
            item.style.bottom = bottomOffset + 'px';
            // place top highlight for the last item
            if (idx === stack.length - 1) item.classList.add('top-highlight');
            stackVisual.appendChild(item);
          });

          // Update labels and memory view
          sizeLabel.textContent = stack.length;
          capacityLabel.textContent = `Capacity: ${capacity}`;
          capacityValue.textContent = capacity;

          // Memory view: show top index first for clarity
          memoryView.innerHTML = '';
          if (stack.length === 0) {
            memoryView.textContent = '[ empty ]';
          } else {
            for (let i = stack.length - 1; i >= 0; i--) {
              memoryView.insertAdjacentHTML('beforeend', `<div><strong>index ${i}:</strong> ${escapeHtml(stack[i])}</div>`);
            }
          }
        });
      }

      // Visual animation helpers: animate push (floating clone) to slot, animate pop out
      function animatePush(value) {
        if (animating) return Promise.reject('busy');
        if (stack.length >= capacity) {
          // overflow feedback: shake and message
          shakeStack();
          setMessage('Stack overflow — capacity reached', 'error');
          logOp('Push failed: overflow');
          return Promise.reject('overflow');
        }
        animating = true;
        setMessage(`Pushing "${value}" ...`, 'important');

        // Create floating clone (start near palette or input)
        const startEl = document.activeElement && document.activeElement.classList.contains('chip') ? document.activeElement : null;
        let startRect = startEl ? startEl.getBoundingClientRect() : valueInput.getBoundingClientRect();
        const clone = document.createElement('div');
        clone.className = 'chip floating';
        clone.textContent = value;
        clone.style.left = (startRect.left) + 'px';
        clone.style.top = (startRect.top) + 'px';
        clone.style.width = startRect.width + 'px';
        clone.style.height = startRect.height + 'px';
        document.body.appendChild(clone);

        // target position: top slot coordinates
        // We first render new stack item offscreen to compute target
        const targetIndex = stack.length; // new index
        // We'll compute the bottom position for the target slot
        const slots = stackVisual.querySelectorAll('.stack-slot');
        const slotRect = slots.length > 0 ? slots[0].getBoundingClientRect() : stackVisual.getBoundingClientRect();
        // compute slot height (including gap)
        const itemHeight = 40; // defined in CSS
        const slotHeight = slotRect.height + 10; // approximate using CSS layout gap
        // We'll compute target center point within stackVisual
        const canvasRect = stackVisual.getBoundingClientRect();
        const bottomOffset = 8 + targetIndex * slotHeight;
        const targetY = canvasRect.bottom - bottomOffset - (itemHeight / 2);
        const targetX = canvasRect.left + 12; // left padding

        // compute transform delta
        const startCenterX = startRect.left + startRect.width / 2;
        const startCenterY = startRect.top + startRect.height / 2;
        const targetCenterX = targetX + (canvasRect.width - 24) / 2;
        const targetCenterY = targetY;

        // position clone centered for smoother motion
        clone.style.transform = `translate(-50%,-50%)`;
        clone.style.left = startCenterX + 'px';
        clone.style.top = startCenterY + 'px';
        // force repaint
        clone.getBoundingClientRect();

        // move clone to target
        requestAnimationFrame(() => {
          clone.style.transition = 'transform 480ms cubic-bezier(.2,.9,.2,1), opacity 320ms';
          const dx = targetCenterX - startCenterX;
          const dy = targetCenterY - startCenterY;
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(0.98) translate(-50%,-50%)`;
        });

        return new Promise((resolve) => {
          setTimeout(() => {
            // finalize: remove clone, update data & render with small entrance animation
            clone.classList.add('fade-out');
            setTimeout(() => {
              clone.remove();
            }, 200);

            // push into state
            stack.push(value);
            renderStack();
            // briefly flash the top item
            const items = stackVisual.querySelectorAll('.stack-item');
            const top = items[items.length - 1];
            if (top) {
              top.style.transform = 'scale(1.06)';
              setTimeout(() => {
                top.style.transform = 'scale(1)';
              }, 220);
            }

            setMessage(`Pushed "${value}"`, 'important');
            logOp(`push(${value})`);
            animating = false;
            resolve();
          }, 520);
        });
      }

      function animatePop() {
        if (animating) return Promise.reject('busy');
        if (stack.length === 0) {
          setMessage('Stack underflow — nothing to pop', 'error');
          logOp('Pop failed: underflow');
          // bounce stack for feedback
          bounceStack();
          return Promise.reject('underflow');
        }
        animating = true;
        const value = stack[stack.length - 1];
        setMessage(`Popping "${value}" ...`, 'important');
        // get current top element location
        const items = stackVisual.querySelectorAll('.stack-item');
        const top = items[items.length - 1];
        if (!top) {
          // fallback: just pop state
          stack.pop();
          renderStack();
          setMessage(`Popped "${value}"`);
          logOp(`pop() -> ${value}`);
          animating = false;
          return Promise.resolve(value);
        }
        const rect = top.getBoundingClientRect();
        // create floating clone at top position
        const clone = top.cloneNode(true);
        clone.classList.add('floating');
        clone.style.left = rect.left + 'px';
        clone.style.top = rect.top + 'px';
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';
        document.body.appendChild(clone);
        // animate out upward & fade
        requestAnimationFrame(() => {
          clone.style.transition = 'transform 420ms ease-in, opacity 320ms';
          clone.style.transform = 'translateY(-120px) scale(0.9)';
          clone.style.opacity = '0';
        });

        return new Promise((resolve) => {
          setTimeout(() => {
            clone.remove();
            stack.pop();
            renderStack();
            setMessage(`Popped "${value}"`);
            logOp(`pop() -> ${value}`);
            animating = false;
            resolve(value);
          }, 420);
        });
      }

      function animatePeek() {
        if (stack.length === 0) {
          setMessage('Stack is empty — nothing to peek', 'error');
          logOp('Peek: empty');
          return;
        }
        const value = stack[stack.length - 1];
        setMessage(`Peek -> "${value}"`, 'important');
        logOp(`peek() -> ${value}`);
        // highlight top item briefly
        const items = stackVisual.querySelectorAll('.stack-item');
        const top = items[items.length - 1];
        if (top) {
          top.animate([
            { transform: 'translateY(0) scale(1)' },
            { transform: 'translateY(-6px) scale(1.02)' },
            { transform: 'translateY(0) scale(1)' }
          ], { duration: 420, easing: 'ease-in-out' });
        }
      }

      function shakeStack() {
        stackVisual.classList.add('shake');
        setTimeout(() => stackVisual.classList.remove('shake'), 460);
      }
      function bounceStack() {
        stackVisual.animate([
          { transform: 'translateY(0)' },
          { transform: 'translateY(-8px)' },
          { transform: 'translateY(0)' }
        ], { duration: 340, easing: 'cubic-bezier(.2,.9,.2,1)' });
      }

      // Event handlers: buttons
      pushBtn.addEventListener('click', () => {
        const val = valueInput.value.trim();
        if (!val) {
          setMessage('Please enter a value or drag a chip.', 'error');
          return;
        }
        animatePush(val).then(() => {
          valueInput.value = '';
          valueInput.focus();
        }).catch(()=>{});
      });

      popBtn.addEventListener('click', () => {
        animatePop().catch(()=>{});
      });

      peekBtn.addEventListener('click', () => {
        animatePeek();
      });

      clearBtn.addEventListener('click', () => {
        stack = [];
        renderStack();
        setMessage('Stack cleared');
        logOp('clear()');
      });

      // capacity change
      capacityRange.addEventListener('input', (e) => {
        capacity = parseInt(e.target.value, 10);
        capacityLabel.textContent = `Capacity: ${capacity}`;
        capacityValue.textContent = capacity;
        // if current stack exceeds new capacity, visually indicate (but keep items)
        if (stack.length > capacity) {
          setMessage('Capacity reduced below current size — overflow state visually shown', 'error');
          shakeStack();
        } else {
          setMessage(`Capacity set to ${capacity}`);
        }
        renderStack();
      });

      // Keyboard: Enter in input triggers push
      valueInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          pushBtn.click();
        }
      });

      // Create chip from input text into palette
      createChipBtn.addEventListener('click', () => {
        const val = valueInput.value.trim();
        if (!val) {
          setMessage('Type a value to create a chip.', 'error');
          return;
        }
        const chip = createPaletteChip(val);
        palette.appendChild(chip);
        setMessage(`Created chip "${val}" in palette`);
        valueInput.value = '';
        valueInput.focus();
      });

      // Create a palette chip element
      function createPaletteChip(val) {
        const chip = document.createElement('div');
        chip.className = 'chip';
        chip.setAttribute('role','option');
        chip.setAttribute('tabindex','0');
        chip.dataset.value = val;
        chip.textContent = val;
        makeDraggable(chip);
        return chip;
      }

      // Make existing palette chips draggable & keyboard-pushable
      function makeDraggable(el) {
        // mouse/touch drag
        let dragging = false;
        let clone = null;
        let startX = 0, startY = 0;

        function pointerStart(e) {
          if (animating) return;
          dragging = true;
          el.setPointerCapture && el.setPointerCapture(e.pointerId);
          startX = e.clientX;
          startY = e.clientY;
          clone = el.cloneNode(true);
          clone.classList.add('floating');
          clone.style.left = e.clientX + 'px';
          clone.style.top = e.clientY + 'px';
          clone.style.width = el.getBoundingClientRect().width + 'px';
          clone.style.height = el.getBoundingClientRect().height + 'px';
          document.body.appendChild(clone);
        }
        function pointerMove(e) {
          if (!dragging || !clone) return;
          clone.style.left = e.clientX + 'px';
          clone.style.top = e.clientY + 'px';
        }
        function pointerEnd(e) {
          if (!dragging) return;
          dragging = false;
          if (clone) {
            // check if release point is within stackVisual
            const svRect = stackVisual.getBoundingClientRect();
            if (e.clientX >= svRect.left && e.clientX <= svRect.right && e.clientY >= svRect.top && e.clientY <= svRect.bottom) {
              // push
              const val = el.dataset.value || el.textContent;
              animatePush(val).catch(()=>{});
            } else {
              // just remove clone
              clone.remove();
            }
            clone = null;
          }
        }

        // For pointer events
        el.addEventListener('pointerdown', pointerStart);
        window.addEventListener('pointermove', pointerMove);
        window.addEventListener('pointerup', pointerEnd);

        // Keyboard accessibility: Enter or Space pushes value
        el.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter' || ev.key === ' ') {
            ev.preventDefault();
            const val = el.dataset.value || el.textContent;
            animatePush(val).catch(()=>{});
          }
        });
      }

      // Initialize palette chips
      const initialChips = palette.querySelectorAll('.chip');
      initialChips.forEach(ch => {
        ch.dataset.value = ch.textContent.trim();
        makeDraggable(ch);
      });

      // Allow clicking on top area to focus stack and support delete/pop via keyboard (optional)
      stackVisual.addEventListener('keydown', (e) => {
        if (e.key === 'Delete' || e.key === 'Backspace') {
          popBtn.click();
        }
      });

      // Helpful initial message
      setMessage('Ready — drag chips or type a value and Push. Use Pop to remove the top value.');

      // Accessibility: expose operations to ARIA
      // (We already use aria-live regions; further ARIA roles can be added if needed.)

      // Ensure minimum spacing: dynamic enforcement not required as CSS uses gap variables.

      // Expose some functions for console experimentation (developer)
      window._stackDemo = {
        push: (v) => animatePush(v),
        pop: () => animatePop(),
        peek: () => animatePeek(),
        state: () => ({stack: stack.slice(), capacity})
      };
    })();
  </script>
</body>
</html>