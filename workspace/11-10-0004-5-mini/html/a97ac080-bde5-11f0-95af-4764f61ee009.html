<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Module: Queue (FIFO)</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --success: #10b981;
      --danger: #ef4444;
      --slot-bg: #071126;
      --slot-border: rgba(255,255,255,0.06);
      --focus: 3px rgba(6,182,212,0.12);
      --duration: 360ms;
    }

    /* Safe-area margins */
    html,body{
      height:100%;
      margin:0;
      padding:var(--safe-margin);
      background: linear-gradient(180deg, #071024 0%, #04111a 100%);
      color:#e6eef8;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      box-sizing:border-box;
    }
    * { box-sizing: inherit; }

    /* Layout container */
    .wrapper{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      max-width:1100px;
      margin:0 auto;
    }

    header{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:-0.3px;
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* Two-column module area */
    .module{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
    }
    /* Left: info & controls */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      padding:16px;
      border-radius:10px;
      width:360px;
      min-width:260px;
      flex:0 0 360px;
    }
    .panel h2{
      margin:0 0 8px 0;
      font-size:16px;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
    }

    /* Controls */
    .controls{
      margin-top:12px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    label{
      display:block;
      font-size:13px;
      color:var(--muted);
      margin-bottom:8px;
    }
    input[type="text"], input[type="number"], select {
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.02);
      color:inherit;
      font-size:14px;
      outline:none;
    }
    input[type="text"]:focus, input[type="number"]:focus, select:focus{
      box-shadow:var(--focus);
      border-color:var(--accent);
    }

    .btn-row{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
    }
    button{
      cursor:pointer;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.02);
      color:inherit;
      font-size:14px;
      min-width:96px;
    }
    button.primary{
      background:linear-gradient(180deg,var(--accent), #0695aa);
      border: none;
      color: #022; 
      font-weight:600;
    }
    button.ghost{
      background: transparent;
      border:1px dashed rgba(255,255,255,0.04);
    }
    button:disabled{
      opacity:0.36;
      cursor:not-allowed;
    }
    .small{
      padding:8px 10px;
      min-width:80px;
    }

    /* Right: visualization */
    .visual{
      flex:1 1 0;
      min-width:300px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));
      border:1px solid rgba(255,255,255,0.03);
      border-radius:10px;
      padding:20px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .queue-area{
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
      justify-content:center;
    }

    .slots{
      display:flex;
      gap:12px;
      padding:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.008), rgba(255,255,255,0.006));
      border-radius:10px;
      width:100%;
      justify-content:center;
      overflow:hidden;
    }

    .slot{
      width:72px;
      height:56px;
      border-radius:8px;
      background:var(--slot-bg);
      border:1px solid var(--slot-border);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      font-size:14px;
      color:var(--muted);
      transition: transform var(--duration) ease, box-shadow var(--duration);
      min-width:72px;
    }
    .slot.filled{
      color:#071026;
      background:linear-gradient(180deg,#9ae6f6,#06b6d4);
      box-shadow: 0 6px 18px rgba(6,182,212,0.12);
      font-weight:700;
    }

    /* head/tail badges */
    .badge{
      position:absolute;
      bottom:-16px;
      left:50%;
      transform:translateX(-50%);
      background:rgba(255,255,255,0.04);
      color:var(--muted);
      padding:4px 6px;
      border-radius:6px;
      font-size:12px;
      pointer-events:none;
    }
    .badge.head{ background: rgba(16,185,129,0.12); color:var(--success); }
    .badge.tail{ background: rgba(6,182,212,0.08); color:var(--accent); }

    /* animations */
    .incoming{
      animation: popIn var(--duration) ease;
    }
    @keyframes popIn{
      from { transform: translateY(-16px) scale(0.92); opacity:0; }
      to   { transform: translateY(0) scale(1); opacity:1; }
    }
    .outgoing{
      animation: flyOut var(--duration) ease forwards;
    }
    @keyframes flyOut{
      0% { transform: translateY(0) scale(1); opacity:1; }
      100% { transform: translateY(-30px) scale(0.9); opacity:0; }
    }

    /* indices & log */
    .indices{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:13px;
    }
    .log{
      background: rgba(255,255,255,0.02);
      padding:12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
      font-size:13px;
      color:var(--muted);
      max-height:140px;
      overflow:auto;
    }
    .log-item{
      padding:6px 0;
      border-bottom:1px dashed rgba(255,255,255,0.01);
    }
    .log-item:last-child{ border-bottom:none; }

    /* responsive */
    @media (max-width:920px){
      .module{ flex-direction:column; }
      .panel{ width:100%; flex:unset; }
    }

    /* focus styles for accessibility */
    button:focus, input:focus {
      outline: none;
      box-shadow: var(--focus);
    }

    /* spacing rules to ensure minimum 16px between interactive elements */
    .controls > * { margin-bottom: var(--gap); }
    .btn-row > * { margin-bottom:0; }
  </style>
</head>
<body>
  <div class="wrapper" role="main">

    <!-- Header + Design Plan -->
    <header>
      <h1>Queue (FIFO) — Interactive Module</h1>
      <p class="lead">Practice and visualize the First-In-First-Out behavior of a Queue by enqueueing and dequeueing values. Watch how head and tail move and items exit in order.</p>
    </header>

    <div class="module" aria-labelledby="module-title">

      <!-- Left Panel: Concept + Controls -->
      <aside class="panel" aria-label="Module controls and explanation">
        <h2 id="module-title">Concept & Objectives</h2>
        <p class="muted">
          Concept Title: Queue (FIFO)
        </p>
        <p style="margin-top:8px;">
          Learning Objective:
        </p>
        <p class="muted" style="margin-top:6px;">
          After using this module you should be able to:
          <ul style="margin:8px 0 0 18px; color:var(--muted);">
            <li>Explain FIFO ordering: earliest enqueued item leaves first.</li>
            <li>Perform enqueue, dequeue, peek, and clear operations and see pointer changes.</li>
            <li>Recognize when the queue is empty or full and observe visual feedback.</li>
          </ul>
        </p>

        <div style="margin-top:8px;">
          <h2 style="font-size:15px; margin-bottom:6px;">Interaction Design</h2>
          <p class="muted" style="margin:0;">
            How to interact:
          </p>
          <ul style="margin:8px 0 0 18px; color:var(--muted);">
            <li>Type a value and press Enqueue (or Enter) to add an item. Watch it animate into the rightmost slot.</li>
            <li>Click Dequeue to remove the front item. It will animate out and remaining items shift left — demonstrating FIFO.</li>
            <li>Peek shows the current front item without removing it. Clear empties the queue.</li>
            <li>Adjust Capacity to see how the queue behaves when full. Controls disable appropriately.</li>
          </ul>
          <p class="muted" style="margin-top:8px;">
            Visual feedback & animations:
            Items animate in and out; head and tail badges update colorfully. Logs show each operation and the queue's internal indices.
          </p>
        </div>

        <!-- Controls -->
        <form class="controls" id="controls" onsubmit="return false;" aria-label="Queue controls">
          <div>
            <label for="value">Value to enqueue</label>
            <input id="value" type="text" placeholder="e.g. A, 42, foo" aria-label="Value to enqueue" />
          </div>

          <div>
            <label for="capacity">Capacity (number of slots)</label>
            <input id="capacity" type="number" min="1" max="12" value="6" aria-label="Queue capacity" />
          </div>

          <div class="btn-row" role="group" aria-label="Queue operation buttons">
            <button id="enqueueBtn" class="primary" type="button">Enqueue</button>
            <button id="dequeueBtn" class="small" type="button">Dequeue</button>
            <button id="peekBtn" class="small ghost" type="button">Peek</button>
            <button id="clearBtn" class="small" type="button">Clear</button>
          </div>

          <div class="btn-row" style="margin-top:8px;">
            <button id="randomBtn" class="small" type="button">Fill Random</button>
            <button id="autoBtn" class="small ghost" type="button" aria-pressed="false">Auto Enqueue</button>
          </div>

          <div style="margin-top:8px;">
            <label class="muted">Operation log</label>
            <div id="summary" class="muted" aria-live="polite" style="font-size:13px; margin-top:6px;">Queue is empty.</div>
          </div>
        </form>
      </aside>

      <!-- Right Panel: Visualization -->
      <section class="visual" aria-label="Queue visualization area">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <strong style="font-size:15px;">Queue Visualizer</strong>
            <div class="muted" style="font-size:13px; margin-top:4px;">Slots show values; head/tail badges indicate front and next-insert index.</div>
          </div>
          <div class="muted" style="font-size:13px;">FIFO: First-In, First-Out</div>
        </div>

        <div class="queue-area">
          <div id="slots" class="slots" role="list" aria-label="Queue slots">
            <!-- slots generated by JS -->
          </div>

          <div class="indices" aria-hidden="false" id="indices">
            <!-- head/tail/size info -->
          </div>
        </div>

        <div>
          <label class="muted">Detailed log</label>
          <div id="log" class="log" role="log" aria-live="polite" aria-atomic="false">
            <!-- operations appended here -->
          </div>
        </div>
      </section>

    </div>

  </div>

  <script>
    (function(){
      // Accessibility: trap focus and keyboard labels are native via elements.
      // Module state
      const capacityInput = document.getElementById('capacity');
      const valueInput = document.getElementById('value');
      const enqueueBtn = document.getElementById('enqueueBtn');
      const dequeueBtn = document.getElementById('dequeueBtn');
      const peekBtn = document.getElementById('peekBtn');
      const clearBtn = document.getElementById('clearBtn');
      const randomBtn = document.getElementById('randomBtn');
      const autoBtn = document.getElementById('autoBtn');

      const slotsEl = document.getElementById('slots');
      const logEl = document.getElementById('log');
      const summaryEl = document.getElementById('summary');
      const indicesEl = document.getElementById('indices');

      let queue = []; // array storing values left-to-right
      let capacity = parseInt(capacityInput.value, 10) || 6;
      let autoInterval = null;

      const ANIM = 360; // ms - must match CSS var --duration

      // Utilities
      function log(msg, tone){
        const item = document.createElement('div');
        item.className = 'log-item';
        item.textContent = `${new Date().toLocaleTimeString()}: ${msg}`;
        if(tone === 'error') item.style.color = 'var(--danger)';
        if(tone === 'ok') item.style.color = 'var(--muted)';
        logEl.prepend(item);
      }

      function updateSummary(){
        summaryEl.textContent = `Size: ${queue.length} / ${capacity}. ${queue.length === 0 ? 'Queue is empty.' : queue.length === capacity ? 'Queue is full.' : '' }`;
      }

      function updateIndices(){
        indicesEl.innerHTML = '';
        const head = document.createElement('div');
        head.textContent = `head = 0`;
        head.style.marginRight = '8px';
        indicesEl.appendChild(head);

        const tail = document.createElement('div');
        tail.textContent = `tail = ${queue.length}`;
        indicesEl.appendChild(tail);

        const size = document.createElement('div');
        size.textContent = `size = ${queue.length}`;
        size.style.color = 'var(--muted)';
        indicesEl.appendChild(size);
      }

      function createSlot(value, index){
        const s = document.createElement('div');
        s.className = 'slot';
        s.setAttribute('role','listitem');
        s.setAttribute('aria-label', value === null ? `Empty slot ${index}` : `Slot ${index} containing ${value}`);
        if(value !== null && value !== undefined){
          s.classList.add('filled');
          s.textContent = value;
        } else {
          s.textContent = '';
        }
        // badges for head and tail
        if(index === 0){
          const b = document.createElement('div');
          b.className = 'badge head';
          b.textContent = 'HEAD';
          s.appendChild(b);
        }
        if(index === queue.length){ // tail indicates next insertion index
          const b2 = document.createElement('div');
          b2.className = 'badge tail';
          b2.textContent = 'TAIL';
          s.appendChild(b2);
        }
        return s;
      }

      function renderSlots(animateShift=false){
        // Create desired slots: capacity many
        slotsEl.innerHTML = '';
        for(let i=0;i<capacity;i++){
          const val = queue[i] !== undefined ? queue[i] : null;
          const slot = createSlot(val, i);
          slotsEl.appendChild(slot);
        }
        updateSummary();
        updateIndices();
        // Disable/Enable controls based on state
        enqueueBtn.disabled = queue.length >= capacity;
        dequeueBtn.disabled = queue.length === 0;
        peekBtn.disabled = queue.length === 0;
      }

      // Enqueue with animation
      function enqueue(value){
        if(value === null || value === undefined || String(value).trim() === ''){
          valueInput.focus();
          log('Enqueue aborted: empty value', 'error');
          return;
        }
        if(queue.length >= capacity){
          log('Enqueue failed: queue is full', 'error');
          return;
        }
        // Create a floating pill that animates into the rightmost empty slot
        const slotIndex = queue.length;
        const targetSlot = slotsEl.children[slotIndex];
        const floating = document.createElement('div');
        floating.style.position = 'absolute';
        floating.style.zIndex = 999;
        floating.style.padding = '8px 12px';
        floating.style.borderRadius = '8px';
        floating.style.background = 'linear-gradient(180deg,#9ae6f6,#06b6d4)';
        floating.style.color = '#022';
        floating.style.fontWeight = '700';
        floating.style.left = (valueInput.getBoundingClientRect().left) + 'px';
        floating.style.top = (valueInput.getBoundingClientRect().top) + 'px';
        floating.textContent = value;
        document.body.appendChild(floating);

        // compute target center
        const startRect = floating.getBoundingClientRect();
        const targetRect = targetSlot.getBoundingClientRect();
        const dx = targetRect.left + targetRect.width/2 - (startRect.left + startRect.width/2);
        const dy = targetRect.top + targetRect.height/2 - (startRect.top + startRect.height/2);

        floating.animate([
          { transform: 'translate(0,0) scale(0.98)', opacity: 0.95 },
          { transform: `translate(${dx}px, ${dy}px) scale(1)`, opacity: 1 }
        ], { duration: ANIM, easing: 'cubic-bezier(.2,.8,.2,1)'});

        setTimeout(()=> {
          // finalize
          document.body.removeChild(floating);
          queue.push(value);
          // add visual fill class on slot with incoming animation
          const slot = slotsEl.children[slotIndex];
          slot.classList.add('filled','incoming');
          slot.textContent = value;
          // re-append badges to keep head/tail correct
          // remove any existing badges
          for(const ch of slot.querySelectorAll('.badge')) ch.remove();
          if(slotIndex === 0){
            const b = document.createElement('div');
            b.className = 'badge head';
            b.textContent = 'HEAD';
            slot.appendChild(b);
          }
          const tailSlot = slotsEl.children[queue.length];
          // update previous tail badge if any
          for(const s of slotsEl.querySelectorAll('.slot .badge.tail')) {
            s.remove();
          }
          if(queue.length <= capacity-1){
            const b2 = document.createElement('div');
            b2.className = 'badge tail';
            b2.textContent = 'TAIL';
            // append to correct slot
            slotsEl.children[queue.length].appendChild(b2);
          }

          setTimeout(()=> { // remove incoming class
            slot.classList.remove('incoming');
          }, ANIM + 50);

          log(`Enqueued "${value}"`, 'ok');
          updateSummary();
          updateIndices();
          enqueueBtn.disabled = queue.length >= capacity;
          dequeueBtn.disabled = queue.length === 0;
        }, ANIM + 10);

      }

      // Dequeue with animation
      function dequeue(){
        if(queue.length === 0){
          log('Dequeue failed: queue is empty', 'error');
          return;
        }
        // animate head slot outgoing
        const headSlot = slotsEl.children[0];
        // create an outgoing visual by cloning
        const outgoing = headSlot.cloneNode(true);
        outgoing.style.position = 'absolute';
        const headRect = headSlot.getBoundingClientRect();
        outgoing.style.left = headRect.left + 'px';
        outgoing.style.top = headRect.top + 'px';
        outgoing.style.width = headRect.width + 'px';
        outgoing.style.height = headRect.height + 'px';
        outgoing.style.zIndex = 1000;
        document.body.appendChild(outgoing);
        outgoing.classList.add('outgoing');

        setTimeout(()=> {
          document.body.removeChild(outgoing);
        }, ANIM + 10);

        const removed = queue.shift();
        log(`Dequeued "${removed}"`, 'ok');

        // Re-render slots with a small shift animation for remaining items
        // We'll animate each existing filled slot to the left slightly for visual shift
        // First re-render empty then populate with animated incoming for each slot to simulate motion
        for(let i=0;i<capacity;i++){
          slotsEl.children[i].classList.remove('filled','incoming');
          slotsEl.children[i].textContent = '';
          for(const ch of slotsEl.children[i].querySelectorAll('.badge')) ch.remove();
        }

        // populate after a tiny timeout to allow outgoing to start
        setTimeout(()=> {
          for(let i=0;i<queue.length;i++){
            const s = slotsEl.children[i];
            s.textContent = queue[i];
            s.classList.add('filled');
            // subtle shift animation
            s.animate([
              { transform: 'translateX(8px)', opacity: 0.9 },
              { transform: 'translateX(0)', opacity: 1 }
            ], { duration: ANIM, easing: 'cubic-bezier(.2,.8,.2,1)'});
          }
          // badges
          if(queue.length > 0){
            const b = document.createElement('div');
            b.className = 'badge head';
            b.textContent = 'HEAD';
            slotsEl.children[0].appendChild(b);

            // tail points to next insert index
            if(queue.length <= capacity-1){
              const b2 = document.createElement('div');
              b2.className = 'badge tail';
              b2.textContent = 'TAIL';
              slotsEl.children[queue.length].appendChild(b2);
            }
          } else {
            // empty queue -> tail = 0
            const b2 = document.createElement('div');
            b2.className = 'badge tail';
            b2.textContent = 'TAIL';
            slotsEl.children[0].appendChild(b2);
          }

          updateSummary();
          updateIndices();
          enqueueBtn.disabled = queue.length >= capacity;
          dequeueBtn.disabled = queue.length === 0;
          peekBtn.disabled = queue.length === 0;
        }, Math.min(ANIM, 220));
      }

      function peek(){
        if(queue.length === 0){
          log('Peek: queue is empty', 'error');
          return;
        }
        const front = queue[0];
        log(`Peek: "${front}" is at the front`, 'ok');
        // flash head slot to show peek
        const head = slotsEl.children[0];
        head.animate([
          { boxShadow: '0 0 0 rgba(255,255,255,0)' },
          { boxShadow: '0 10px 26px rgba(6,182,212,0.14)' },
          { boxShadow: '0 0 0 rgba(255,255,255,0)' }
        ], { duration: 420, easing: 'ease-out' });
      }

      function clearQueue(){
        if(queue.length === 0){
          log('Clear: queue already empty', 'ok');
          return;
        }
        queue = [];
        // animate clearing by fading each filled slot
        for(let i=0;i<capacity;i++){
          const s = slotsEl.children[i];
          if(s.classList.contains('filled')){
            s.animate([
              { transform: 'translateY(0)', opacity:1 },
              { transform: 'translateY(-10px) scale(0.98)', opacity:0.0 }
            ], { duration: ANIM, easing: 'ease-in' });
          }
        }
        setTimeout(()=> {
          renderSlots();
          log('Cleared queue', 'ok');
        }, ANIM + 20);
      }

      // Fill with random strings to demonstrate
      function fillRandom(){
        const sample = ['A','B','C','D','E','1','2','3','X','Y','Z','foo','bar'];
        clearQueue();
        // enqueue up to capacity with small delays so animations visible
        let i=0;
        const toAdd = Math.min(capacity, Math.floor(Math.random()*capacity)+1);
        const interval = setInterval(()=> {
          if(i >= toAdd) { clearInterval(interval); return; }
          const v = sample[Math.floor(Math.random()*sample.length)] + (Math.random()<0.4 ? Math.floor(Math.random()*9) : '');
          enqueue(v);
          i++;
        }, ANIM + 100);
      }

      // Auto enqueue toggle
      function toggleAuto(){
        if(autoInterval){
          clearInterval(autoInterval);
          autoInterval = null;
          autoBtn.textContent = 'Auto Enqueue';
          autoBtn.setAttribute('aria-pressed','false');
          log('Auto enqueue stopped', 'ok');
          return;
        }
        autoBtn.textContent = 'Stop Auto';
        autoBtn.setAttribute('aria-pressed','true');
        log('Auto enqueue started', 'ok');
        autoInterval = setInterval(()=> {
          if(queue.length >= capacity){
            // stop when full
            clearInterval(autoInterval);
            autoInterval = null;
            autoBtn.textContent = 'Auto Enqueue';
            autoBtn.setAttribute('aria-pressed','false');
            log('Auto enqueue stopped (queue full)', 'ok');
            return;
          }
          const randomValue = Math.random().toString(36).substring(2,5).toUpperCase();
          enqueue(randomValue);
        }, ANIM + 600);
      }

      // Initial render
      function init(){
        // create empty slots first
        for(let i=0;i<capacity;i++){
          const slot = createSlot(null, i);
          slotsEl.appendChild(slot);
        }
        // initial tail badge at 0
        const b2 = document.createElement('div');
        b2.className = 'badge tail';
        b2.textContent = 'TAIL';
        slotsEl.children[0].appendChild(b2);

        updateSummary();
        updateIndices();
        dequeueBtn.disabled = true;
        peekBtn.disabled = true;
      }

      // Event bindings
      enqueueBtn.addEventListener('click', ()=> {
        const v = valueInput.value;
        enqueue(v);
        valueInput.value = '';
        valueInput.focus();
      });

      // Allow Enter key in input to enqueue
      valueInput.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){
          e.preventDefault();
          enqueueBtn.click();
        }
      });

      dequeueBtn.addEventListener('click', ()=> dequeue());
      peekBtn.addEventListener('click', ()=> peek());
      clearBtn.addEventListener('click', ()=> clearQueue());
      randomBtn.addEventListener('click', ()=> fillRandom());
      autoBtn.addEventListener('click', ()=> toggleAuto());

      capacityInput.addEventListener('change', ()=>{
        const newCap = parseInt(capacityInput.value, 10) || 1;
        // clamp to 1..12
        capacity = Math.max(1, Math.min(12, newCap));
        capacityInput.value = capacity;
        // if new capacity is less than current size, drop tail items visually
        if(queue.length > capacity){
          queue = queue.slice(0, capacity);
          log('Capacity reduced: dropped items beyond new capacity', 'error');
        }
        renderSlots();
      });

      // Initialize
      init();

      // Expose for debugging (not necessary)
      window._queueModule = { enqueue, dequeue, peek, clearQueue, renderSlots };
    })();
  </script>
</body>
</html>