<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Binary Search Tree Explorer</title>
  <style>
    :root{
      --safe-pad: 24px;        /* Safe area margin */
      --gap: 16px;            /* Minimum spacing */
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #38bdf8;
      --muted: #94a3b8;
      --success: #34d399;
      --danger: #fb7185;
      --node-radius: 20;
      --level-gap: 90;
      --h-spacing: 60;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,var(--bg), #061022 180%);
      color: #e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Safe area and layout */
    .container{
      padding: var(--safe-pad);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      justify-content:center;
    }

    /* Left Info + Controls Panel */
    .panel{
      width:360px;
      min-width:300px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      border-radius:12px;
      padding:20px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
    }

    h1{
      margin:0;
      font-size:18px;
      color:#eaffff;
      letter-spacing:0.2px;
    }

    .muted{
      color:var(--muted);
      font-size:13px;
      line-height:1.3;
      margin-top:4px;
    }

    .section{
      background: transparent;
      padding: 10px;
      border-radius:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    label{
      font-size:13px;
      color:#d9f4ff;
    }

    input[type="text"]{
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.02);
      color: #e6f7ff;
      outline:none;
      font-size:14px;
    }
    .controls-row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }

    button{
      background: linear-gradient(180deg,#07202b,#062028);
      color: #e6f7ff;
      border: 1px solid rgba(255,255,255,0.04);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
      min-width:64px;
      transition: transform .08s ease, box-shadow .12s;
    }
    button:active{ transform: translateY(1px); }
    button.primary{
      background: linear-gradient(180deg,#049fd6,#0388bc);
      box-shadow: 0 6px 18px rgba(3,136,188,0.18);
    }
    button.warn{
      background: linear-gradient(180deg,#ff8a8f,#ff6b76);
    }

    .small{
      padding:6px 10px;
      font-size:12px;
      min-width:unset;
    }

    .row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      justify-content:space-between;
    }

    .info-list{
      font-size:13px;
      color:var(--muted);
      display:flex;
      flex-direction:column;
      gap:6px;
    }

    .status{
      background: rgba(255,255,255,0.02);
      padding:8px;
      border-radius:8px;
      font-size:13px;
      color:#cfefff;
      min-height:40px;
    }

    /* Canvas area */
    .stage{
      flex:1;
      min-width:360px;
      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
      border:1px solid rgba(255,255,255,0.03);
    }

    .stage-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:var(--gap);
    }

    .legend{
      color:var(--muted);
      font-size:13px;
    }

    .canvas-wrap{
      position:relative;
      background: linear-gradient(90deg, rgba(255,255,255,0.006), rgba(255,255,255,0.004));
      border-radius:8px;
      padding:12px;
      min-height:420px;
      overflow:auto;
      border:1px dashed rgba(255,255,255,0.02);
    }

    /* SVG will be sized responsively; nodes and edges */
    svg{
      width:100%;
      height:520px;
      display:block;
    }

    /* Node visuals */
    .node-group{
      cursor: default;
      transition: transform 600ms cubic-bezier(.2,.9,.3,1);
      transform-origin: center;
    }

    .node-circle{
      fill: linear-gradient(180deg,#073b4a,#0a5165);
      fill: #052b35;
      stroke: rgba(255,255,255,0.06);
      stroke-width:1.8px;
      transition: fill .25s ease, r .25s ease;
      filter: drop-shadow(0 6px 10px rgba(3,12,22,0.6));
    }
    .node-text{
      font-size:13px;
      fill: #e6f7ff;
      pointer-events:none;
      font-weight:600;
    }

    .edge{
      stroke: rgba(255,255,255,0.08);
      stroke-width:2px;
      stroke-linecap:round;
    }

    .edge.highlight{
      stroke: var(--accent);
      stroke-width:3px;
      stroke-opacity:0.95;
    }

    .node-circle.highlight{
      fill: var(--accent);
      stroke: rgba(255,255,255,0.14);
    }

    .pulse{
      animation: pulse 900ms ease-in-out infinite alternate;
    }
    @keyframes pulse{
      from { transform: scale(1); filter: drop-shadow(0 6px 18px rgba(3,12,22,0.5)); }
      to { transform: scale(1.06); filter: drop-shadow(0 10px 28px rgba(3,12,22,0.6)); }
    }

    .traversal-list{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .chip{
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.03);
      color:#dff8ff;
      font-weight:600;
    }

    /* Responsive adjustments */
    @media (max-width:960px){
      .container{ flex-direction:column; padding:18px; }
      .panel{ width:100%; }
      .stage{ width:100%; }
      svg{ height:520px; }
    }
  </style>
</head>
<body>
  <div class="container" role="main" aria-label="Binary Search Tree interactive module">
    <!-- Left Panel: Title, Objectives, Controls -->
    <aside class="panel" aria-labelledby="title">
      <div>
        <h1 id="title">Binary Search Tree (BST) Explorer</h1>
        <div class="muted">Understand insertion, search, deletion, and in-order traversal with step-by-step visual feedback.</div>
      </div>

      <div class="section" aria-live="polite">
        <label><strong>Learning Objective</strong></label>
        <div class="muted">After interacting you should be able to:</div>
        <ul class="info-list" style="margin:0; padding-left:18px;">
          <li>Explain how BST organizes data (left &lt; node &lt; right).</li>
          <li>Perform insertion/search/delete operations and trace comparisons.</li>
          <li>Observe in-order traversal producing sorted order.</li>
        </ul>
      </div>

      <div class="section" aria-label="Interaction Design">
        <label><strong>Interaction Design</strong></label>
        <div class="muted">
          - Type one or more integers (space/comma separated). Use Insert / Delete / Search.<br>
          - Step Mode: step through each comparison and pointer move; nodes highlight as you compare. Auto Play runs the steps automatically.<br>
          - In-order traversal highlights nodes left→root→right and shows the sorted sequence.
        </div>
      </div>

      <div class="section" aria-label="Controls">
        <label for="valueInput">Values</label>
        <input id="valueInput" type="text" placeholder="e.g., 50 or 10 30 70" aria-describedby="valuesHelp" />

        <div class="controls-row">
          <button id="insertBtn" class="primary" aria-label="Insert values">Insert</button>
          <button id="deleteBtn" aria-label="Delete values">Delete</button>
          <button id="searchBtn" aria-label="Search values">Search</button>
        </div>

        <div class="controls-row">
          <button id="stepToggle" class="small" aria-pressed="false">Step Mode</button>
          <button id="autoPlayBtn" class="small">Auto Play</button>
          <button id="randomBtn" class="small" title="Generate random tree">Random</button>
          <button id="clearBtn" class="small warn">Clear</button>
        </div>

        <div style="display:flex;gap:var(--gap);align-items:center;">
          <label style="margin:0;font-size:13px;color:var(--muted);">Speed</label>
          <input id="speedRange" type="range" min="200" max="1600" step="100" value="700" />
        </div>

      </div>

      <div class="section" aria-live="polite">
        <label><strong>Layout Description</strong></label>
        <div class="muted">
          - Left panel: controls and concise explanations. Right: scalable SVG canvas for tree visualization.<br>
          - Safe area: 24px padding on all sides; interactive elements spaced at least 16px.<br>
          - Nodes placed by depth (vertical gap) and in-order horizontal spacing to preserve readability and avoid overlap. Responsive for smaller screens.
        </div>
      </div>

      <div class="section">
        <label><strong>Status</strong></label>
        <div id="status" class="status" aria-live="assertive">Ready — insert a number to begin.</div>
      </div>

    </aside>

    <!-- Right: Visualization stage -->
    <main class="stage" aria-label="Visualization and canvas">
      <div class="stage-top">
        <div class="legend">Canvas: Visualizes nodes and comparisons. Click nodes for details.</div>
        <div class="legend muted">Tip: No duplicate values permitted</div>
      </div>

      <div class="canvas-wrap" role="region" aria-label="BST visualization canvas">
        <svg id="svgCanvas" viewBox="0 0 1200 520" preserveAspectRatio="xMinYMin meet" tabindex="0" aria-label="Binary Search Tree">
          <!-- Edges and nodes appended here -->
        </svg>
      </div>

      <div style="display:flex;gap:var(--gap);align-items:center;justify-content:space-between;">
        <div>
          <label style="font-size:13px;color:var(--muted);margin-right:8px;">In-order traversal:</label>
          <div id="traversal" class="traversal-list" aria-live="polite"></div>
        </div>
        <div>
          <button id="traverseBtn" class="small">Traverse</button>
        </div>
      </div>

    </main>
  </div>

  <script>
    /********************************************************************
     * Interactive BST Explorer
     * - Single concept: Binary Search Tree insert/search/delete/traverse
     * - Implements step-mode with visual highlights and animations
     * - Self-contained: vanilla HTML/CSS/JS only
     ********************************************************************/

    /* -------------------------
       Utility & DOM references
       ------------------------- */
    const svg = document.getElementById('svgCanvas');
    const insertBtn = document.getElementById('insertBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const searchBtn = document.getElementById('searchBtn');
    const traverseBtn = document.getElementById('traverseBtn');
    const clearBtn = document.getElementById('clearBtn');
    const randomBtn = document.getElementById('randomBtn');
    const stepToggle = document.getElementById('stepToggle');
    const autoPlayBtn = document.getElementById('autoPlayBtn');
    const valueInput = document.getElementById('valueInput');
    const statusEl = document.getElementById('status');
    const traversalEl = document.getElementById('traversal');
    const speedRange = document.getElementById('speedRange');

    let STEP_MODE = false;
    let AUTO_PLAY = false;
    let stepQueue = [];    // events for current operation
    let running = false;   // whether we are auto-processing steps
    let speed = parseInt(speedRange.value,10);

    // layout variables
    const NODE_R = 20;
    const LEVEL_GAP = 90;
    const H_SPACING = 60;
    const SVG_WIDTH = 1200;
    const SVG_HEIGHT = 520;

    // data structures
    class Node {
      constructor(value){
        this.value = value;
        this.left = null;
        this.right = null;
        this.x = 0;
        this.y = 0;
        this.id = Node._id++;
      }
    }
    Node._id = 1;

    let root = null;

    /* -------------------------
       Visualization helpers
       ------------------------- */

    function clearSVG(){
      while(svg.firstChild) svg.removeChild(svg.firstChild);
    }

    function createSVGElement(tag, attrs={}){
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for(const k in attrs){
        el.setAttribute(k, attrs[k]);
      }
      return el;
    }

    function updateStatus(msg, tone){
      statusEl.textContent = msg;
      if(tone === 'error') statusEl.style.color = 'var(--danger)';
      else if(tone === 'success') statusEl.style.color = 'var(--success)';
      else statusEl.style.color = '#cfefff';
    }

    /* -------------------------
       Tree layout calculation
       ------------------------- */

    function computePositions(){
      // assign x positions by in-order index
      let index = 0;
      function inorderAssign(node, depth){
        if(!node) return;
        inorderAssign(node.left, depth+1);
        node.x = (index++) * H_SPACING + 60; // left margin
        node.y = 40 + depth * LEVEL_GAP;
        inorderAssign(node.right, depth+1);
      }
      index = 0;
      inorderAssign(root, 0);
    }

    /* -------------------------
       SVG drawing update
       ------------------------- */

    function render(){
      clearSVG();
      if(!root) return;
      computePositions();

      // Draw edges first
      const edgesGroup = createSVGElement('g', {class:'edges'});
      const nodesGroup = createSVGElement('g', {class:'nodes'});
      svg.appendChild(edgesGroup);
      svg.appendChild(nodesGroup);

      // map id->node for event binding
      const allNodes = [];
      function collect(node){
        if(!node) return;
        allNodes.push(node);
        collect(node.left);
        collect(node.right);
      }
      collect(root);

      // draw edges
      allNodes.forEach(node => {
        if(node.parent){
          const line = createSVGElement('line', {
            class: 'edge',
            x1: node.parent.x,
            y1: node.parent.y + NODE_R,
            x2: node.x,
            y2: node.y - NODE_R
          });
          line.dataset.to = node.id;
          line.dataset.from = node.parent.id;
          edgesGroup.appendChild(line);
        }
      });

      // draw nodes
      allNodes.forEach(node => {
        const g = createSVGElement('g', {class:'node-group', transform: `translate(${node.x},${node.y})`});
        g.setAttribute('data-id', node.id);
        // circle
        const circ = createSVGElement('circle', {
          class: 'node-circle',
          r: NODE_R,
          cx: 0, cy: 0
        });
        // text (centered)
        const txt = createSVGElement('text', {
          class: 'node-text',
          x: 0, y: 5,
          'text-anchor': 'middle'
        });
        txt.textContent = node.value;
        g.appendChild(circ);
        g.appendChild(txt);

        // tooltip (aria)
        g.setAttribute('role','button');
        g.setAttribute('tabindex','0');
        g.setAttribute('aria-label', `Node ${node.value}`);

        // click to copy value to input
        g.addEventListener('click', ()=>{
          valueInput.value = String(node.value);
          updateStatus(`Picked value ${node.value} — ready to operate`);
        });

        g.addEventListener('keydown',(e)=>{
          if(e.key === 'Enter' || e.key === ' '){
            e.preventDefault();
            g.click();
          }
        });

        nodesGroup.appendChild(g);
      });

      // After drawing, adjust svg viewBox width if needed to keep spacing
      const maxX = Math.max(...allNodes.map(n => n.x));
      const minX = Math.min(...allNodes.map(n => n.x));
      const pad = 120;
      const width = Math.max(SVG_WIDTH, maxX + pad);
      svg.setAttribute('viewBox', `0 0 ${width} ${SVG_HEIGHT}`);
    }

    /* -------------------------
       Tree operations with event recording
       ------------------------- */

    // We'll generate "steps" describing comparisons, moves, inserts, deletes.
    // A step: {type: 'compare'|'move'|'insert'|'delete'|'replace'|'found', node: Node?, value: number, extra: {}}

    function insertValuesFromInput(){
      const vals = parseInputValues(valueInput.value);
      if(vals.length === 0){ updateStatus('No valid integers provided', 'error'); return; }
      // sequentially insert each value
      (async ()=>{
        for(const v of vals){
          if(hasValue(root, v)){
            updateStatus(`Value ${v} already exists; duplicates not allowed`, 'error');
            await sleep(700);
            continue;
          }
          await runOperationWithSteps(() => generateInsertSteps(v));
        }
      })();
    }

    function parseInputValues(text){
      if(!text) return [];
      return text.split(/[\s,]+/)
        .map(s => s.trim())
        .filter(Boolean)
        .map(Number)
        .filter(n => Number.isFinite(n));
    }

    function hasValue(node, v){
      if(!node) return false;
      if(node.value === v) return true;
      if(v < node.value) return hasValue(node.left, v);
      return hasValue(node.right, v);
    }

    function generateInsertSteps(v){
      // returns array of steps implementing insertion
      const steps = [];
      if(!root){
        steps.push({type:'insert', value:v, parent:null, attach:'root'});
        return steps;
      }
      let cur = root;
      let parent = null;
      while(cur){
        steps.push({type:'compare', node:cur, value:v});
        parent = cur;
        if(v < cur.value){
          steps.push({type:'move', from:cur, direction:'left'});
          if(!cur.left){
            steps.push({type:'insert', value:v, parent:cur, attach:'left'});
            break;
          }
          cur = cur.left;
        } else {
          steps.push({type:'move', from:cur, direction:'right'});
          if(!cur.right){
            steps.push({type:'insert', value:v, parent:cur, attach:'right'});
            break;
          }
          cur = cur.right;
        }
      }
      return steps;
    }

    function runOperationWithSteps(generator){
      // generator is a function that returns steps (array)
      if(running) {
        updateStatus('Operation in progress — wait', 'error');
        return Promise.resolve();
      }
      stepQueue = generator();
      return processSteps(stepQueue);
    }

    async function processSteps(steps){
      running = true;
      const delay = () => new Promise(res => setTimeout(res, speedRange.value));
      // Clear temporary highlights
      clearHighlights();
      render(); // ensure current drawing

      for(let i=0;i<steps.length;i++){
        const s = steps[i];
        if(s.type === 'compare'){
          highlightNode(s.node, 'compare');
          updateStatus(`Comparing ${s.node.value} with ${s.value}`);
          if(STEP_MODE){
            await waitForUserOrAuto();
          } else {
            await delay();
          }
          removeHighlight(s.node);
        } else if(s.type === 'move'){
          // highlight edge and node
          highlightNode(s.from, 'move');
          highlightEdgeToChild(s.from, s.direction);
          updateStatus(`Go ${s.direction} from ${s.from.value}`);
          if(STEP_MODE){
            await waitForUserOrAuto();
          } else {
            await delay();
          }
          clearHighlights();
        } else if(s.type === 'insert'){
          updateStatus(`Inserting ${s.value}`);
          // actually perform insertion in data model
          if(s.attach === 'root'){
            const n = new Node(s.value);
            root = n;
          } else {
            const n = new Node(s.value);
            const parent = s.parent;
            if(s.attach === 'left') parent.left = n;
            else parent.right = n;
            n.parent = parent;
          }
          render();
          // visual pulse on new node
          const newNode = findNodeByValue(root, s.value);
          if(newNode){
            highlightNode(newNode, 'new');
            if(STEP_MODE){
              await waitForUserOrAuto();
            } else {
              await delay();
            }
            removeHighlight(newNode);
          } else {
            await delay();
          }
        } else if(s.type === 'found'){
          updateStatus(`Found ${s.value}`);
          highlightNode(s.node,'found');
          if(STEP_MODE) await waitForUserOrAuto();
          else await delay();
          removeHighlight(s.node);
        } else if(s.type === 'not-found'){
          updateStatus(`${s.value} not found`);
          await delay();
        } else if(s.type === 'replace'){
          updateStatus(`Replacing ${s.target.value} with ${s.with.value}`);
          // perform replace value
          s.target.value = s.with.value;
          render();
          highlightNode(s.target,'replace');
          if(STEP_MODE) await waitForUserOrAuto();
          else await delay();
          removeHighlight(s.target);
        } else if(s.type === 'delete'){
          updateStatus(`Deleting ${s.value}`);
          // delete node from tree (physically remove)
          removeNodeByValue(s.value);
          render();
          await delay();
        }
      }
      running = false;
      updateStatus('Operation complete', 'success');
      updateTraversalDisplay();
    }

    function waitForUserOrAuto(){
      return new Promise(resolve => {
        if(AUTO_PLAY){
          const t = parseInt(speedRange.value,10);
          setTimeout(resolve, t);
        } else {
          // wait for Step Mode "Next" (here we use the autoPlayBtn click as "Next")
          // We'll reuse autoPlayBtn as a 'Next' when in step mode and not auto
          const handler = () => {
            autoPlayBtn.removeEventListener('click', handler);
            resolve();
          };
          autoPlayBtn.addEventListener('click', handler);
        }
      });
    }

    /* -------------------------
       Search operation
       ------------------------- */

    function searchValuesFromInput(){
      const vals = parseInputValues(valueInput.value);
      if(vals.length === 0){ updateStatus('No valid integers provided', 'error'); return; }
      (async ()=>{
        for(const v of vals){
          await runOperationWithSteps(() => generateSearchSteps(v));
        }
      })();
    }

    function generateSearchSteps(v){
      const steps = [];
      let cur = root;
      while(cur){
        steps.push({type:'compare', node:cur, value:v});
        if(cur.value === v){
          steps.push({type:'found', node:cur, value:v});
          return steps;
        }
        if(v < cur.value){
          steps.push({type:'move', from:cur, direction:'left'});
          cur = cur.left;
        } else {
          steps.push({type:'move', from:cur, direction:'right'});
          cur = cur.right;
        }
      }
      steps.push({type:'not-found', value:v});
      return steps;
    }

    /* -------------------------
       Delete operation
       ------------------------- */

    function deleteValuesFromInput(){
      const vals = parseInputValues(valueInput.value);
      if(vals.length === 0){ updateStatus('No valid integers provided', 'error'); return; }
      (async ()=>{
        for(const v of vals){
          if(!hasValue(root, v)){
            updateStatus(`Value ${v} not found — cannot delete`, 'error');
            await sleep(700);
            continue;
          }
          await runOperationWithSteps(() => generateDeleteSteps(v));
        }
      })();
    }

    function generateDeleteSteps(v){
      // We'll record the usual recursive deletion steps, including finding in-order successor
      const steps = [];
      function recurse(node, parent){
        if(!node) return;
        steps.push({type:'compare', node, value:v});
        if(v < node.value){
          steps.push({type:'move', from:node, direction:'left'});
          recurse(node.left, node);
        } else if(v > node.value){
          steps.push({type:'move', from:node, direction:'right'});
          recurse(node.right, node);
        } else {
          // node to delete found
          steps.push({type:'found', node, value:v});
          // three cases:
          if(!node.left && !node.right){
            // leaf
            steps.push({type:'delete', value:v});
            return;
          } else if(node.left && !node.right){
            // replace node with left subtree (by value swap or pointer rewiring)
            // For educational clarity: we'll replace node.value with leftmost/rightmost as needed.
            // Simpler: attach child to parent
            steps.push({type:'delete', value:v});
            return;
          } else if(!node.left && node.right){
            steps.push({type:'delete', value:v});
            return;
          } else {
            // two children: find in-order successor (min in right subtree)
            let succ = node.right;
            while(succ.left){
              steps.push({type:'move', from:succ, direction:'left'});
              succ = succ.left;
            }
            // replace node's value with succ's value
            steps.push({type:'replace', target:node, with:succ});
            // then delete successor node (which has at most right child)
            steps.push({type:'delete', value:succ.value});
            return;
          }
        }
      }
      recurse(root, null);
      return steps;
    }

    function removeNodeByValue(v){
      root = removeRec(root, v);
      // Clean up parent pointers
      function setParents(node, parent = null){
        if(!node) return;
        node.parent = parent;
        setParents(node.left, node);
        setParents(node.right, node);
      }
      setParents(root, null);
    }

    function removeRec(node, v){
      if(!node) return null;
      if(v < node.value){
        node.left = removeRec(node.left, v);
        return node;
      } else if(v > node.value){
        node.right = removeRec(node.right, v);
        return node;
      } else {
        // found
        if(!node.left && !node.right) return null;
        if(!node.left) return node.right;
        if(!node.right) return node.left;
        // two children: replace with in-order successor (min in right)
        let succ = node.right;
        while(succ.left) succ = succ.left;
        node.value = succ.value;
        node.right = removeRec(node.right, succ.value);
        return node;
      }
    }

    /* -------------------------
       Node lookup & highlight helpers
       ------------------------- */

    function findNodeByValue(node, v){
      if(!node) return null;
      if(node.value === v) return node;
      if(v < node.value) return findNodeByValue(node.left, v);
      return findNodeByValue(node.right, v);
    }

    function highlightNode(node, kind){
      if(!node) return;
      const g = svg.querySelector(`g.node-group[data-id="${node.id}"]`);
      if(!g) return;
      const circ = g.querySelector('circle.node-circle');
      if(kind === 'compare'){
        circ.classList.add('pulse');
        circ.style.fill = '#2b84a5';
      } else if(kind === 'move'){
        circ.classList.add('pulse');
        circ.style.fill = '#3aa8d6';
      } else if(kind === 'new'){
        circ.classList.add('pulse');
        circ.style.fill = 'var(--success)';
      } else if(kind === 'found'){
        circ.classList.add('pulse');
        circ.style.fill = 'var(--accent)';
      } else if(kind === 'replace'){
        circ.classList.add('pulse');
        circ.style.fill = '#f6c85f';
      } else {
        circ.classList.add('pulse');
      }
    }

    function removeHighlight(node){
      if(!node) return;
      const g = svg.querySelector(`g.node-group[data-id="${node.id}"]`);
      if(!g) return;
      const circ = g.querySelector('circle.node-circle');
      circ.classList.remove('pulse');
      circ.style.fill = '';
    }

    function highlightEdgeToChild(node, direction){
      if(!node) return;
      let child = direction === 'left' ? node.left : node.right;
      if(!child) return;
      // find edge with data-to = child.id
      const edge = svg.querySelector(`line.edge[data-to="${child.id}"]`);
      if(edge) edge.classList.add('highlight');
      // remove after a short time (handled by step flow)
    }

    function clearHighlights(){
      const pulses = svg.querySelectorAll('circle.node-circle.pulse');
      pulses.forEach(c => { c.classList.remove('pulse'); c.style.fill = ''; });
      const edgeHs = svg.querySelectorAll('line.edge.highlight');
      edgeHs.forEach(e => e.classList.remove('highlight'));
    }

    /* -------------------------
       Traversal display
       ------------------------- */

    function updateTraversalDisplay(){
      traversalEl.innerHTML = '';
      const seq = [];
      (function inorder(node){
        if(!node) return;
        inorder(node.left);
        seq.push(node);
        inorder(node.right);
      })(root);
      if(seq.length === 0){
        traversalEl.textContent = '—';
        return;
      }
      seq.forEach(n => {
        const el = document.createElement('div');
        el.className = 'chip';
        el.textContent = n.value;
        traversalEl.appendChild(el);
      });
    }

    function animateTraversal(){
      // highlight nodes in-order sequentially
      const seq = [];
      (function inorder(node){
        if(!node) return;
        inorder(node.left);
        seq.push(node);
        inorder(node.right);
      })(root);

      if(seq.length === 0){
        updateStatus('Tree is empty', 'error');
        return;
      }
      (async ()=>{
        for(const n of seq){
          highlightNode(n,'found');
          updateStatus(`Visited ${n.value}`);
          await sleep(Math.max(300, speedRange.value*0.5));
          removeHighlight(n);
        }
        updateStatus('In-order traversal complete', 'success');
      })();
    }

    /* -------------------------
       Utility
       ------------------------- */

    function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

    /* -------------------------
       Event wiring & UI
       ------------------------- */

    insertBtn.addEventListener('click', ()=>{
      insertValuesFromInput();
    });
    searchBtn.addEventListener('click', ()=>{ searchValuesFromInput(); });
    deleteBtn.addEventListener('click', ()=>{ deleteValuesFromInput(); });

    clearBtn.addEventListener('click', ()=>{
      root = null;
      Node._id = 1;
      render();
      updateTraversalDisplay();
      updateStatus('Tree cleared');
    });

    randomBtn.addEventListener('click', ()=>{
      // create random tree with 7 values
      root = null;
      Node._id = 1;
      const count = 7;
      const vals = [];
      while(vals.length < count){
        const n = Math.floor(Math.random() * 99) + 1;
        if(!vals.includes(n)) vals.push(n);
      }
      vals.forEach(v => {
        // plain insertion
        if(!root) root = new Node(v);
        else {
          let cur = root;
          while(true){
            if(v < cur.value){
              if(!cur.left){ cur.left = new Node(v); cur.left.parent = cur; break; }
              cur = cur.left;
            } else {
              if(!cur.right){ cur.right = new Node(v); cur.right.parent = cur; break; }
              cur = cur.right;
            }
          }
        }
      });
      render();
      updateTraversalDisplay();
      updateStatus('Random tree generated', 'success');
    });

    traverseBtn.addEventListener('click', ()=>{ animateTraversal(); });

    stepToggle.addEventListener('click', ()=>{
      STEP_MODE = !STEP_MODE;
      stepToggle.setAttribute('aria-pressed', String(STEP_MODE));
      stepToggle.style.background = STEP_MODE ? 'linear-gradient(180deg,#1b3a4a,#153243)' : '';
      updateStatus(STEP_MODE ? 'Step mode ON — use Auto Play as Next' : 'Step mode OFF');
    });

    autoPlayBtn.addEventListener('click', ()=>{
      // If in step mode and not auto, this acts as the "Next" button for step progress.
      if(STEP_MODE){
        // Toggle AUTO_PLAY for convenience
        AUTO_PLAY = !AUTO_PLAY;
        autoPlayBtn.textContent = AUTO_PLAY ? 'Auto:On' : 'Auto Play';
        autoPlayBtn.style.background = AUTO_PLAY ? 'linear-gradient(180deg,#1a7b9a,#13667c)' : '';
        updateStatus(AUTO_PLAY ? 'Auto-play enabled for step mode' : 'Auto-play disabled');
      } else {
        // If not in step mode, run a queued single "next" tick (no-op)
        updateStatus('Auto Play is meaningful only in Step Mode. Toggle Step Mode to step through operations.');
      }
    });

    speedRange.addEventListener('input', ()=>{
      speed = parseInt(speedRange.value,10);
    });

    // keyboard shortcuts
    document.addEventListener('keydown', (e)=>{
      if(e.ctrlKey && e.key === 'i'){ insertValuesFromInput(); }
      if(e.ctrlKey && e.key === 'f'){ searchValuesFromInput(); }
      if(e.ctrlKey && e.key === 'd'){ deleteValuesFromInput(); }
    });

    // On initial load, render empty
    render();
    updateTraversalDisplay();

    // Attach parent pointers when rendering initially (root may be created programmatically)
    function setParentPointers(){
      function traverse(node, parent=null){
        if(!node) return;
        node.parent = parent;
        traverse(node.left, node);
        traverse(node.right, node);
      }
      traverse(root, null);
    }

    // Whenever render called, ensure parent links are set
    const originalRender = render;
    render = function(){
      setParentPointers();
      originalRender();
      updateTraversalDisplay();
    };

    // Expose for console debugging (optional)
    window.__bst = { root, render, insertValuesFromInput };

    // final small helper to ensure the newly defined render replacement works
    render();

  </script>
</body>
</html>