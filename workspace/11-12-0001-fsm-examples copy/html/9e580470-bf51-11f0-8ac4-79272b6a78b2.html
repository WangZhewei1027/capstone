<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Binary Search Tree (BST)</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f4f4f4;
      }
      h1 {
        color: #34495e;
      }
      .container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #bstVisualization {
        width: 600px;
        height: 400px;
        border: 1px solid #ccc;
        position: relative;
        background-color: white;
      }
      .node {
        width: 50px;
        height: 50px;
        border: 2px solid #2980b9;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #ecf0f1;
        position: absolute;
        transition: background-color 0.3s;
      }
      .node:hover {
        background-color: #bdc3c7;
      }
      button {
        margin: 10px;
        padding: 10px 20px;
        background-color: #2980b9;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }
      button:hover {
        background-color: #3498db;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Interactive Binary Search Tree (BST)</h1>
      <div id="bstVisualization"></div>
      <input
        type="number"
        id="inputValue"
        placeholder="Enter a number"
        min="0"
      />
      <button id="insertButton">Insert</button>
      <button id="deleteButton">Delete</button>
      <div id="result"></div>
    </div>

    <script>
      class TreeNode {
        constructor(value) {
          this.value = value;
          this.left = null;
          this.right = null;
        }
      }

      class BST {
        constructor() {
          this.root = null;
        }

        insert(value) {
          const newNode = new TreeNode(value);
          if (!this.root) {
            this.root = newNode;
          } else {
            this.insertNode(this.root, newNode);
          }
        }

        insertNode(node, newNode) {
          if (newNode.value < node.value) {
            if (!node.left) {
              node.left = newNode;
            } else {
              this.insertNode(node.left, newNode);
            }
          } else {
            if (!node.right) {
              node.right = newNode;
            } else {
              this.insertNode(node.right, newNode);
            }
          }
        }

        delete(value) {
          this.root = this.deleteNode(this.root, value);
        }

        deleteNode(node, value) {
          if (!node) return null;
          if (value < node.value) {
            node.left = this.deleteNode(node.left, value);
            return node;
          } else if (value > node.value) {
            node.right = this.deleteNode(node.right, value);
            return node;
          } else {
            // Node to be deleted found
            if (!node.left && !node.right) return null; // No children
            if (!node.left) return node.right; // One child (right)
            if (!node.right) return node.left; // One child (left)

            // Two children: Get the inorder successor (smallest in the right subtree)
            node.value = this.minValue(node.right);
            node.right = this.deleteNode(node.right, node.value);
          }
          return node;
        }

        minValue(node) {
          let min = node.value;
          while (node.left) {
            min = node.left.value;
            node = node.left;
          }
          return min;
        }
      }

      const bst = new BST();

      function drawBST(node, x, y, gap) {
        if (!node) return;

        const nodeElement = document.createElement("div");
        nodeElement.className = "node";
        nodeElement.innerText = node.value;
        nodeElement.style.left = `${x}px`;
        nodeElement.style.top = `${y}px`;
        document.getElementById("bstVisualization").appendChild(nodeElement);

        drawBST(node.left, x - gap, y + 60, gap / 2);
        drawBST(node.right, x + gap, y + 60, gap / 2);
      }

      document.getElementById("insertButton").addEventListener("click", () => {
        const value = parseInt(document.getElementById("inputValue").value);
        if (isNaN(value)) {
          alert("Please enter a valid number.");
          return;
        }
        bst.insert(value);
        document.getElementById("result").innerText = `Inserted: ${value}`;
        document.getElementById("bstVisualization").innerHTML = "";
        drawBST(bst.root, 300, 20, 100);
      });

      document.getElementById("deleteButton").addEventListener("click", () => {
        const value = parseInt(document.getElementById("inputValue").value);
        if (isNaN(value)) {
          alert("Please enter a valid number.");
          return;
        }
        bst.delete(value);
        document.getElementById("result").innerText = `Deleted: ${value}`;
        document.getElementById("bstVisualization").innerHTML = "";
        drawBST(bst.root, 300, 20, 100);
      });
    </script>
  </body>
</html>
