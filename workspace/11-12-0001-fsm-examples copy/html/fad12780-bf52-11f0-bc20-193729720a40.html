<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Interactive Binary Search Tree (BST) Lab</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --text: #e5e7eb;
    --muted: #9ca3af;
    --accent: #60a5fa;
    --accent-2: #22c55e;
    --accent-3: #f59e0b;
    --danger: #ef4444;
    --edge: #334155;
    --node: #1f2937;
    --node-stroke: #94a3b8;
    --highlight: #f472b6;
    --visited: #a78bfa;
    --success: #16a34a;
    --warning: #f97316;
  }
  .light {
    --bg: #f8fafc;
    --panel: #ffffff;
    --text: #111827;
    --muted: #6b7280;
    --accent: #2563eb;
    --accent-2: #059669;
    --accent-3: #b45309;
    --danger: #dc2626;
    --edge: #cbd5e1;
    --node: #f1f5f9;
    --node-stroke: #475569;
    --highlight: #db2777;
    --visited: #7c3aed;
    --success: #16a34a;
    --warning: #ea580c;
  }
  html, body {
    height: 100%;
    background: var(--bg);
    color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    margin: 0;
  }
  header {
    padding: 18px 20px;
    border-bottom: 1px solid var(--edge);
    background: linear-gradient(90deg, rgba(96,165,250,0.15), rgba(34,197,94,0.15));
  }
  header h1 {
    margin: 0;
    font-size: 22px;
    letter-spacing: 0.5px;
  }
  header p {
    margin: 6px 0 0;
    color: var(--muted);
    font-size: 14px;
  }
  main {
    display: grid;
    grid-template-columns: 1.2fr 1fr;
    gap: 16px;
    padding: 16px;
  }
  .panel {
    background: var(--panel);
    border: 1px solid var(--edge);
    border-radius: 10px;
    overflow: hidden;
  }
  .panel h2 {
    margin: 0;
    padding: 12px 14px;
    border-bottom: 1px solid var(--edge);
    font-size: 16px;
    background: linear-gradient(0deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
  }
  .viz {
    display: grid;
    grid-template-rows: auto 1fr;
  }
  .toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    padding: 10px;
    background: rgba(255,255,255,0.03);
    border-bottom: 1px solid var(--edge);
  }
  .toolbar .group {
    display: flex;
    gap: 6px;
    align-items: center;
    flex-wrap: wrap;
  }
  .toolbar label {
    font-size: 12px;
    color: var(--muted);
  }
  .toolbar input[type="number"],
  .toolbar input[type="text"],
  .toolbar select {
    background: var(--bg);
    color: var(--text);
    border: 1px solid var(--edge);
    border-radius: 8px;
    padding: 8px 10px;
    height: 34px;
    font-size: 14px;
    outline: none;
  }
  .toolbar button {
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 8px 12px;
    height: 34px;
    font-size: 14px;
    cursor: pointer;
  }
  .toolbar button.secondary {
    background: transparent;
    color: var(--text);
    border: 1px solid var(--edge);
  }
  .toolbar button.warn {
    background: var(--danger);
  }
  .toolbar button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  .canvas-wrap {
    position: relative;
    min-height: 340px;
    height: calc(60vh - 80px);
  }
  #svg {
    width: 100%;
    height: 100%;
    background:
      radial-gradient(ellipse at top left, rgba(96,165,250,0.12), transparent 60%),
      radial-gradient(ellipse at bottom right, rgba(34,197,94,0.12), transparent 60%);
  }
  /* Node/edge visuals */
  .edge {
    stroke: var(--edge);
    stroke-width: 2;
    transition: stroke 0.2s, stroke-width 0.2s;
  }
  .edge.highlight {
    stroke: var(--highlight);
    stroke-width: 3.2;
  }
  .edge.delete {
    stroke: var(--danger);
  }
  .edge.visited {
    stroke: var(--visited);
  }
  .node {
    transition: transform 0.2s ease, fill 0.2s, stroke 0.2s;
    cursor: pointer;
  }
  .node circle {
    fill: var(--node);
    stroke: var(--node-stroke);
    stroke-width: 2;
  }
  .node.visited circle {
    stroke: var(--visited);
    stroke-width: 3;
  }
  .node.highlight circle {
    stroke: var(--highlight);
    stroke-width: 3.2;
  }
  .node.delete circle {
    stroke: var(--danger);
    stroke-width: 3.2;
  }
  .node text {
    fill: var(--text);
    font-weight: 600;
    font-size: 13px;
    pointer-events: none;
  }
  .node .meta {
    font-size: 10px;
    fill: var(--muted);
    transform: translateY(14px);
  }
  .legend {
    position: absolute;
    right: 10px;
    bottom: 10px;
    font-size: 12px;
    color: var(--muted);
    background: rgba(0,0,0,0.25);
    backdrop-filter: blur(6px);
    border: 1px solid var(--edge);
    border-radius: 8px;
    padding: 6px 8px;
  }
  .legend span {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    margin-right: 10px;
  }
  .dot {
    width: 14px;
    height: 14px;
    border-radius: 999px;
    display: inline-block;
    border: 2px solid var(--node-stroke);
    background: var(--node);
  }
  .dot.highlight { border-color: var(--highlight); }
  .dot.visited { border-color: var(--visited); }
  .dot.delete { border-color: var(--danger); }

  /* Right column */
  .right {
    display: grid;
    grid-template-rows: auto auto 1fr auto;
    gap: 12px;
  }
  .section {
    padding: 10px;
  }
  .controls {
    display: grid;
    gap: 8px;
  }
  .controls .row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }
  .controls input[type="number"],
  .controls input[type="text"],
  .controls select {
    background: var(--bg);
    color: var(--text);
    border: 1px solid var(--edge);
    border-radius: 8px;
    padding: 8px 10px;
    height: 34px;
    font-size: 14px;
    outline: none;
  }
  .controls button {
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 8px 12px;
    height: 34px;
    font-size: 14px;
    cursor: pointer;
  }
  .controls button.secondary {
    background: transparent;
    color: var(--text);
    border: 1px solid var(--edge);
  }
  .controls button.warn {
    background: var(--danger);
  }
  .tiny {
    font-size: 12px;
    color: var(--muted);
  }

  /* Pseudocode */
  .code {
    background: linear-gradient(0deg, rgba(255,255,255,0.02), rgba(255,255,255,0));
    border-top: 1px solid var(--edge);
    border-bottom: 1px solid var(--edge);
    max-height: 220px;
    overflow: auto;
  }
  .code-tabs {
    display: flex;
    gap: 6px;
    padding: 8px;
    border-bottom: 1px solid var(--edge);
  }
  .code-tabs button {
    background: transparent;
    color: var(--text);
    border: 1px solid var(--edge);
    border-radius: 8px;
    padding: 6px 10px;
    font-size: 13px;
    cursor: pointer;
  }
  .code-tabs button.active {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
  }
  pre {
    margin: 0;
    padding: 10px 12px 14px;
    white-space: pre-wrap;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size: 12.5px;
  }
  .code .line {
    padding: 2px 6px;
    border-radius: 6px;
  }
  .code .line.hl {
    background: rgba(96,165,250,0.15);
    outline: 1px dashed var(--accent);
  }

  /* Output */
  .output {
    background: rgba(255,255,255,0.03);
    border-top: 1px solid var(--edge);
    padding: 10px;
    min-height: 80px;
  }
  .out-row {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    align-items: center;
    margin-top: 6px;
  }
  .pill {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 999px;
    border: 1px solid var(--edge);
    background: var(--bg);
    color: var(--text);
    font-size: 12px;
  }
  .pill.ok { border-color: var(--success); color: var(--success); }
  .pill.warn { border-color: var(--warning); color: var(--warning); }
  .pill.err { border-color: var(--danger); color: var(--danger); }

  /* Challenge */
  .challenge {
    padding: 10px;
    border-top: 1px dashed var(--edge);
    background: rgba(255,255,255,0.03);
  }
  .challenge .status {
    margin-top: 6px;
    font-size: 13px;
    color: var(--muted);
  }

  /* Footer */
  footer {
    padding: 10px 16px;
    border-top: 1px solid var(--edge);
    color: var(--muted);
    font-size: 12px;
    display: flex;
    gap: 10px;
    align-items: center;
  }

  /* Toggle + sliders */
  .switch {
    position: relative;
    width: 50px;
    height: 26px;
    background: var(--edge);
    border-radius: 999px;
    cursor: pointer;
    border: 1px solid var(--node-stroke);
  }
  .knob {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 22px;
    height: 22px;
    border-radius: 999px;
    background: var(--node);
    border: 1px solid var(--node-stroke);
    transition: left 0.2s ease;
  }
  .switch.on .knob { left: 26px; }

  .range {
    display: inline-flex;
    align-items: center;
    gap: 8px;
  }
  input[type="range"] {
    width: 150px;
    accent-color: var(--accent);
  }

  /* Responsive */
  @media (max-width: 1024px) {
    main { grid-template-columns: 1fr; }
  }
</style>
</head>
<body class="light">
<header>
  <h1>Binary Search Tree (BST) Interactive Lab</h1>
  <p>Insert, search, delete, and traverse. Watch algorithms step through the tree, inspect invariants, and practice with challenges.</p>
</header>

<main>
  <section class="panel viz">
    <h2>Visualization</h2>
    <div class="toolbar">
      <div class="group">
        <label for="valInput">Value</label>
        <input id="valInput" type="number" placeholder="e.g., 42">
        <button id="btnInsert">Insert</button>
        <button id="btnSearch" class="secondary">Search</button>
        <button id="btnDelete" class="warn">Delete</button>
      </div>
      <div class="group">
        <input id="listInput" type="text" placeholder="Insert list: e.g. 50,20,70,10 30 60 80">
        <button id="btnInsertList">Insert List</button>
        <button id="btnRandom" class="secondary">Random Tree</button>
        <select id="randomCount">
          <option>5</option><option selected>8</option><option>12</option><option>16</option><option>24</option>
        </select>
        <button id="btnClear" class="secondary">Clear</button>
      </div>
      <div class="group">
        <label>Animate</label>
        <div id="animSwitch" class="switch on" title="Toggle animations"><div class="knob"></div></div>
        <span class="range">
          <label>Speed</label>
          <input id="speed" type="range" min="1" max="100" value="40">
          <span id="speedLabel" class="tiny">1x</span>
        </span>
        <label>Theme</label>
        <div id="themeSwitch" class="switch on" title="Toggle light/dark"><div class="knob"></div></div>
      </div>
      <div class="group">
        <label>Node Meta</label>
        <div id="metaSwitch" class="switch" title="Show height/size"><div class="knob"></div></div>
      </div>
    </div>

    <div class="canvas-wrap">
      <svg id="svg" viewBox="0 0 1000 600" preserveAspectRatio="xMidYMid meet"></svg>
      <div class="legend">
        <span><i class="dot visited"></i> visited</span>
        <span><i class="dot highlight"></i> compare/path</span>
        <span><i class="dot delete"></i> delete</span>
      </div>
    </div>
  </section>

  <section class="panel right">
    <div class="section">
      <h2>Inspector & Traversals</h2>
      <div class="controls">
        <div class="row">
          <button id="btnInorder">Inorder</button>
          <button id="btnPreorder">Preorder</button>
          <button id="btnPostorder">Postorder</button>
          <button id="btnLevelorder">Level Order</button>
        </div>
        <div class="row">
          <button id="btnValidate" class="secondary">Check BST Property</button>
          <button id="btnBalanced" class="secondary">Check Balanced</button>
          <button id="btnStats" class="secondary">Stats</button>
        </div>
      </div>
      <div id="output" class="output">
        <div class="tiny">Results and messages appear here.</div>
      </div>
    </div>

    <div class="code">
      <div class="code-tabs">
        <button data-tab="insert" class="active">Insert</button>
        <button data-tab="search">Search</button>
        <button data-tab="delete">Delete</button>
        <button data-tab="traverse">Traverse</button>
      </div>
      <pre id="code-block">
        <div id="code-insert">
<span class="line" data-line="1">function insert(node, x):</span>
<span class="line" data-line="2">  if node == null: return new Node(x)</span>
<span class="line" data-line="3">  if x == node.key: return node  // ignore duplicate</span>
<span class="line" data-line="4">  if x < node.key:</span>
<span class="line" data-line="5">    node.left = insert(node.left, x)</span>
<span class="line" data-line="6">  else:</span>
<span class="line" data-line="7">    node.right = insert(node.right, x)</span>
<span class="line" data-line="8">  update(node)  // height, size</span>
<span class="line" data-line="9">  return node</span>
        </div>
        <div id="code-search" style="display:none">
<span class="line" data-line="1">function search(node, x):</span>
<span class="line" data-line="2">  while node != null:</span>
<span class="line" data-line="3">    if x == node.key: return node</span>
<span class="line" data-line="4">    if x < node.key: node = node.left</span>
<span class="line" data-line="5">    else: node = node.right</span>
<span class="line" data-line="6">  return null</span>
        </div>
        <div id="code-delete" style="display:none">
<span class="line" data-line="1">function delete(node, x):</span>
<span class="line" data-line="2">  if node == null: return null</span>
<span class="line" data-line="3">  if x < node.key: node.left = delete(node.left, x)</span>
<span class="line" data-line="4">  else if x > node.key: node.right = delete(node.right, x)</span>
<span class="line" data-line="5">  else:</span>
<span class="line" data-line="6">    if node.left == null: return node.right</span>
<span class="line" data-line="7">    if node.right == null: return node.left</span>
<span class="line" data-line="8">    succ = min(node.right)</span>
<span class="line" data-line="9">    node.key = succ.key</span>
<span class="line" data-line="10">    node.right = delete(node.right, succ.key)</span>
<span class="line" data-line="11">  update(node)</span>
<span class="line" data-line="12">  return node</span>
        </div>
        <div id="code-traverse" style="display:none">
<span class="line" data-line="1">inorder(node):</span>
<span class="line" data-line="2">  if node == null: return</span>
<span class="line" data-line="3">  inorder(node.left)</span>
<span class="line" data-line="4">  visit(node)</span>
<span class="line" data-line="5">  inorder(node.right)</span>
<span class="line" data-line="6">preorder(node):</span>
<span class="line" data-line="7">  visit(node)</span>
<span class="line" data-line="8">  preorder(node.left)</span>
<span class="line" data-line="9">  preorder(node.right)</span>
<span class="line" data-line="10">postorder(node):</span>
<span class="line" data-line="11">  postorder(node.left)</span>
<span class="line" data-line="12">  postorder(node.right)</span>
<span class="line" data-line="13">  visit(node)</span>
<span class="line" data-line="14">levelorder(root):</span>
<span class="line" data-line="15">  queue = [root]</span>
<span class="line" data-line="16">  while queue not empty:</span>
<span class="line" data-line="17">    node = pop_front(queue); visit(node)</span>
<span class="line" data-line="18">    push children if not null</span>
        </div>
      </pre>
    </div>

    <div class="section">
      <h2>Guided Challenge</h2>
      <div class="challenge">
        <div class="tiny">Practice building and reasoning about BSTs.</div>
        <div class="controls">
          <div class="row">
            <button id="btnGenChallenge" class="secondary">Generate Sequence</button>
            <select id="challengeLen">
              <option>5</option><option selected>8</option><option>12</option>
            </select>
            <button id="btnStartChallenge">Start</button>
            <button id="btnResetChallenge" class="secondary">Reset</button>
          </div>
          <div id="challengeSeq" class="tiny"></div>
          <div class="row">
            <button id="btnChallengeCheck" class="secondary">Check Traversals</button>
            <button id="btnChallengeHint" class="secondary">Hint</button>
          </div>
        </div>
        <div id="challengeStatus" class="status">No challenge yet. Click Generate Sequence.</div>
      </div>
    </div>

    <div class="section">
      <h2>Notes</h2>
      <div class="tiny">
        - BST property: left subtree keys < node key < right subtree keys.<br>
        - Inorder traversal of a valid BST yields a sorted sequence.<br>
        - Average time complexity: O(log n) for search/insert/delete; worst-case O(n) when skewed.<br>
        - Delete with two children uses the inorder successor (smallest key in right subtree).
      </div>
    </div>
  </section>
</main>

<footer>
  <span>Tip: Click nodes to center and inspect. Use "Node Meta" to show height and size.</span>
  <span style="margin-left:auto">
    Built for learning. No external libraries.
  </span>
</footer>

<script>
(function() {
  // Utilities
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const uid = (() => { let i=1; return () => i++; })();
  const byId = (id) => document.getElementById(id);
  const svg = byId('svg');

  // Settings state
  let animate = true;
  let speed = 40; // slider unit
  let showMeta = false;
  let themeLight = true;

  // UI elements
  const valInput = byId('valInput');
  const btnInsert = byId('btnInsert');
  const btnSearch = byId('btnSearch');
  const btnDelete = byId('btnDelete');
  const listInput = byId('listInput');
  const btnInsertList = byId('btnInsertList');
  const btnRandom = byId('btnRandom');
  const randomCount = byId('randomCount');
  const btnClear = byId('btnClear');
  const animSwitch = byId('animSwitch');
  const themeSwitch = byId('themeSwitch');
  const metaSwitch = byId('metaSwitch');
  const speedSlider = byId('speed');
  const speedLabel = byId('speedLabel');
  const out = byId('output');

  const btnInorder = byId('btnInorder');
  const btnPreorder = byId('btnPreorder');
  const btnPostorder = byId('btnPostorder');
  const btnLevelorder = byId('btnLevelorder');
  const btnValidate = byId('btnValidate');
  const btnBalanced = byId('btnBalanced');
  const btnStats = byId('btnStats');

  const tabs = document.querySelectorAll('.code-tabs button');
  const codeBlocks = {
    insert: byId('code-insert'),
    search: byId('code-search'),
    delete: byId('code-delete'),
    traverse: byId('code-traverse')
  };

  const btnGenChallenge = byId('btnGenChallenge');
  const btnStartChallenge = byId('btnStartChallenge');
  const btnResetChallenge = byId('btnResetChallenge');
  const challengeLen = byId('challengeLen');
  const challengeSeq = byId('challengeSeq');
  const challengeStatus = byId('challengeStatus');
  const btnChallengeCheck = byId('btnChallengeCheck');
  const btnChallengeHint = byId('btnChallengeHint');

  // BST structure
  class Node {
    constructor(key) {
      this.key = key;
      this.left = null;
      this.right = null;
      this.id = uid();
      this.depth = 0;
      this.x = 0;
      this.y = 0;
      this.height = 1;
      this.size = 1;
      this.parent = null;
    }
  }
  class BST {
    constructor() { this.root = null; this.nodeCount = 0; }
    search(x) {
      let path = [];
      let curr = this.root;
      while (curr) {
        path.push(curr);
        if (x === curr.key) return { node: curr, path };
        curr = x < curr.key ? curr.left : curr.right;
      }
      return { node: null, path };
    }
    insert(x) {
      let existed = false;
      const rec = (node, parent=null) => {
        highlightPseudo('insert', [1]);
        if (!node) {
          const nn = new Node(x);
          nn.parent = parent;
          highlightPseudo('insert', [2]);
          return nn;
        }
        if (x === node.key) {
          existed = true;
          highlightPseudo('insert', [3]);
          return node;
        }
        if (x < node.key) {
          highlightPseudo('insert', [4,5]);
          node.left = rec(node.left, node);
        } else {
          highlightPseudo('insert', [6,7]);
          node.right = rec(node.right, node);
        }
        this.update(node);
        highlightPseudo('insert', [8,9]);
        return node;
      };
      this.root = rec(this.root);
      if (!existed) this.nodeCount++;
      return { existed };
    }
    delete(x) {
      let found = false;
      const rec = (node) => {
        highlightPseudo('delete', [1]);
        if (!node) { highlightPseudo('delete', [2]); return null; }
        if (x < node.key) {
          highlightPseudo('delete', [3]);
          node.left = rec(node.left);
          if (node.left) node.left.parent = node;
        } else if (x > node.key) {
          highlightPseudo('delete', [4]);
          node.right = rec(node.right);
          if (node.right) node.right.parent = node;
        } else {
          found = true;
          highlightPseudo('delete', [5]);
          if (!node.left) {
            highlightPseudo('delete', [6]);
            return node.right ? (node.right.parent = node.parent, node.right) : null;
          }
          if (!node.right) {
            highlightPseudo('delete', [7]);
            return node.left ? (node.left.parent = node.parent, node.left) : null;
          }
          // Two children: successor
          highlightPseudo('delete', [8]);
          const succ = this.min(node.right);
          node.key = succ.key;
          highlightPseudo('delete', [9,10]);
          node.right = recDeleteMin(node.right);
          if (node.right) node.right.parent = node;
        }
        highlightPseudo('delete', [11,12]);
        this.update(node);
        return node;
      };
      const recDeleteMin = (node) => {
        if (!node.left) return node.right;
        node.left = recDeleteMin(node.left);
        if (node.left) node.left.parent = node;
        this.update(node);
        return node;
      };
      this.root = rec(this.root);
      if (found) this.nodeCount = Math.max(0, this.nodeCount - 1);
      return { found };
    }
    min(node) {
      while (node && node.left) node = node.left;
      return node;
    }
    update(node) {
      const lh = node.left ? node.left.height : 0;
      const rh = node.right ? node.right.height : 0;
      node.height = Math.max(lh, rh) + 1;
      const ls = node.left ? node.left.size : 0;
      const rs = node.right ? node.right.size : 0;
      node.size = ls + rs + 1;
    }
    validate() {
      let valid = true;
      const rec = (node, lo=-Infinity, hi=Infinity) => {
        if (!node || !valid) return;
        if (!(node.key > lo && node.key < hi)) { valid = false; return; }
        rec(node.left, lo, node.key);
        rec(node.right, node.key, hi);
      };
      rec(this.root);
      return valid;
    }
    isBalanced() {
      let ok = true;
      const rec = (node) => {
        if (!node || !ok) return 0;
        const lh = rec(node.left);
        const rh = rec(node.right);
        if (Math.abs(lh - rh) > 1) ok = false;
        return Math.max(lh, rh) + 1;
      };
      rec(this.root);
      return ok;
    }
    stats() {
      const h = this.root ? this.root.height : 0;
      const n = this.nodeCount;
      const leaves = (() => {
        let c = 0;
        const rec = (node) => {
          if (!node) return;
          if (!node.left && !node.right) c++;
          rec(node.left); rec(node.right);
        };
        rec(this.root);
        return c;
      })();
      return { nodes: n, height: h, leaves };
    }

    // Traversals
    inorder() {
      const arr = [];
      const rec = (n) => { if (!n) return; rec(n.left); arr.push(n); rec(n.right); };
      rec(this.root);
      return arr;
    }
    preorder() {
      const arr = [];
      const rec = (n) => { if (!n) return; arr.push(n); rec(n.left); rec(n.right); };
      rec(this.root);
      return arr;
    }
    postorder() {
      const arr = [];
      const rec = (n) => { if (!n) return; rec(n.left); rec(n.right); arr.push(n); };
      rec(this.root);
      return arr;
    }
    levelorder() {
      const arr = [];
      const q = [];
      if (this.root) q.push(this.root);
      while (q.length) {
        const n = q.shift();
        arr.push(n);
        if (n.left) q.push(n.left);
        if (n.right) q.push(n.right);
      }
      return arr;
    }
  }

  const tree = new BST();

  // Layout and rendering
  function computeMeta(root) {
    const depths = new Map();
    const rec = (node, d) => {
      if (!node) return;
      node.depth = d;
      tree.update(node);
      rec(node.left, d+1);
      rec(node.right, d+1);
    };
    rec(root, 0);
  }

  function inorderList(root) {
    const arr = [];
    const rec = (n) => { if (!n) return; rec(n.left); arr.push(n); rec(n.right); };
    rec(root);
    return arr;
  }

  function layout() {
    const root = tree.root;
    if (!root) return { nodes: [] };
    computeMeta(root);
    const nodes = inorderList(root);
    // Compute positions based on inorder index and depth
    const width = svg.viewBox.baseVal.width || 1000;
    const height = svg.viewBox.baseVal.height || 600;
    const marginX = 40, marginY = 40;
    const n = Math.max(nodes.length, 1);
    const stepX = n > 1 ? (width - 2*marginX) / (n - 1) : 0;
    const levelGap = Math.max(60, (height - 2*marginY) / Math.max(root.height,1));

    nodes.forEach((node, i) => {
      node.x = n>1 ? marginX + i * stepX : width/2;
      node.y = marginY + node.depth * levelGap;
    });

    // For nodes not in inorder array (shouldn't happen), but ensure parent/children positions exist.
    return { nodes };
  }

  function clearSVG() {
    while (svg.firstChild) svg.removeChild(svg.firstChild);
  }

  function draw() {
    clearSVG();
    const root = tree.root;
    const radius = 18;
    if (!root) return;
    const { nodes } = layout();
    // Build map id->node
    const idMap = new Map(nodes.map(n => [n.id, n]));

    // Draw edges by traversing tree
    const drawEdges = (node) => {
      if (!node) return;
      if (node.left) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', node.x);
        line.setAttribute('y1', node.y);
        line.setAttribute('x2', node.left.x);
        line.setAttribute('y2', node.left.y);
        line.setAttribute('class', 'edge');
        line.setAttribute('data-from', node.id);
        line.setAttribute('data-to', node.left.id);
        svg.appendChild(line);
      }
      if (node.right) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', node.x);
        line.setAttribute('y1', node.y);
        line.setAttribute('x2', node.right.x);
        line.setAttribute('y2', node.right.y);
        line.setAttribute('class', 'edge');
        line.setAttribute('data-from', node.id);
        line.setAttribute('data-to', node.right.id);
        svg.appendChild(line);
      }
      drawEdges(node.left);
      drawEdges(node.right);
    };
    drawEdges(root);

    // Draw nodes
    nodes.forEach(node => {
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('class', 'node');
      g.setAttribute('data-id', node.id);
      g.setAttribute('transform', `translate(${node.x},${node.y})`);
      g.addEventListener('click', () => centerOn(node));

      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('r', radius);
      circle.setAttribute('cx', 0);
      circle.setAttribute('cy', 0);

      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('dominant-baseline', 'central');
      text.textContent = node.key;

      g.appendChild(circle);
      g.appendChild(text);

      if (showMeta) {
        const meta = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        meta.setAttribute('text-anchor', 'middle');
        meta.setAttribute('class', 'meta');
        meta.textContent = `h=${node.height} • s=${node.size}`;
        meta.setAttribute('y', radius + 14);
        g.appendChild(meta);
      }

      svg.appendChild(g);
    });
  }

  function centerOn(node) {
    // For now: flash highlight and post info
    flashNode(node, 'highlight', 600);
    print(`Node ${node.key}: depth=${node.depth}, height=${node.height}, size=${node.size}`, 'info');
  }

  function findNodeGroup(id) {
    return svg.querySelector(`.node[data-id="${id}"]`);
  }
  function findEdge(fromId, toId) {
    return svg.querySelector(`.edge[data-from="${fromId}"][data-to="${toId}"]`);
  }
  function markPath(path, klass) {
    path.forEach((node, i) => {
      const g = findNodeGroup(node.id);
      if (g) g.classList.add(klass);
      if (i > 0) {
        const prev = path[i-1];
        const edge = path[i].key < prev.key ? findEdge(prev.id, prev.left?.id) : findEdge(prev.id, prev.right?.id);
        if (edge) edge.classList.add(klass);
      }
    });
  }
  function clearMarks() {
    svg.querySelectorAll('.node').forEach(g => g.classList.remove('visited','highlight','delete'));
    svg.querySelectorAll('.edge').forEach(e => e.classList.remove('visited','highlight','delete'));
  }
  async function animatePath(path, kind='highlight') {
    if (!animate) { markPath(path, kind==='visited'?'visited':'highlight'); return; }
    clearMarks();
    for (let i = 0; i < path.length; i++) {
      const node = path[i];
      const g = findNodeGroup(node.id);
      if (g) g.classList.add(kind);
      if (i > 0) {
        const prev = path[i-1];
        const edge = node.key < prev.key ? findEdge(prev.id, prev.left?.id) : findEdge(prev.id, prev.right?.id);
        if (edge) edge.classList.add(kind);
      }
      await sleep(stepDelay());
    }
  }
  async function animateVisit(nodes) {
    clearMarks();
    for (const node of nodes) {
      const g = findNodeGroup(node.id);
      if (g) g.classList.add('visited');
      await sleep(stepDelay());
    }
  }
  function flashNode(node, klass='highlight', ms=800) {
    const g = findNodeGroup(node.id);
    if (!g) return;
    g.classList.add(klass);
    setTimeout(() => g.classList.remove(klass), ms);
  }
  function stepDelay() {
    // Map speed slider (1..100) to delay (fast->short)
    const normalized = clamp(speed, 1, 100);
    const ms = 900 - normalized*8; // 820..100 ms roughly
    return ms;
  }

  // Pseudocode highlighting
  let activeTab = 'insert';
  function highlightPseudo(tab, lines=[]) {
    if (activeTab !== tab) return;
    const block = codeBlocks[tab];
    block.querySelectorAll('.line').forEach(el => el.classList.remove('hl'));
    lines.forEach(l => {
      const el = block.querySelector(`.line[data-line="${l}"]`);
      if (el) el.classList.add('hl');
    });
  }
  function clearPseudo() {
    Object.values(codeBlocks).forEach(block => block.querySelectorAll('.line').forEach(el => el.classList.remove('hl')));
  }
  tabs.forEach(btn => {
    btn.addEventListener('click', () => {
      tabs.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const tab = btn.dataset.tab;
      activeTab = tab;
      Object.entries(codeBlocks).forEach(([k, block]) => {
        block.style.display = k === tab ? '' : 'none';
      });
      clearPseudo();
    });
  });

  // Output helpers
  function print(msg, kind='info') {
    const row = document.createElement('div');
    row.className = 'out-row';
    const label = document.createElement('span');
    label.className = 'pill ' + (kind==='ok'?'ok':kind==='warn'?'warn':kind==='err'?'err':'');
    label.textContent = kind==='ok' ? 'OK' : kind==='warn' ? 'Note' : kind==='err' ? 'Error' : 'Info';
    const text = document.createElement('span');
    text.textContent = msg;
    row.appendChild(label);
    row.appendChild(text);
    out.appendChild(row);
    out.scrollTop = out.scrollHeight;
  }
  function clearOutput() {
    out.innerHTML = '<div class="tiny">Results and messages appear here.</div>';
  }

  // Controls state management
  function setBusy(b) {
    [btnInsert, btnSearch, btnDelete, btnInsertList, btnRandom, btnClear, btnInorder, btnPreorder, btnPostorder, btnLevelorder, btnValidate, btnBalanced, btnStats, btnStartChallenge, btnChallengeCheck, btnChallengeHint].forEach(el => {
      if (!el) return;
      el.disabled = b;
    });
  }

  // Operations
  async function doInsert(x) {
    if (!isNum(x)) { print('Enter a valid number to insert.', 'warn'); return; }
    setBusy(true);
    clearPseudo();
    activeTab = 'insert';
    // Compute path for animation first
    const s = tree.search(x);
    if (s.node && s.node.key === x) {
      await animatePath(s.path, 'highlight');
      print(`Duplicate ignored: ${x} already exists in the tree.`, 'warn');
      setBusy(false);
      return;
    }
    await animatePath(s.path, 'highlight');
    const { existed } = tree.insert(x);
    draw();
    // Animate flash where it was added
    const newSearch = tree.search(x);
    if (newSearch.node) flashNode(newSearch.node, 'visited', 1000);
    print(`Inserted ${x}.`, 'ok');
    setBusy(false);
  }

  async function doSearch(x) {
    if (!isNum(x)) { print('Enter a valid number to search.', 'warn'); return; }
    setBusy(true);
    clearPseudo();
    activeTab = 'search';
    const res = tree.search(x);
    await animatePath(res.path, 'highlight');
    if (res.node) {
      flashNode(res.node, 'visited', 1200);
      print(`Found ${x}. Path length = ${res.path.length}.`, 'ok');
    } else {
      print(`Value ${x} not found. Path length = ${res.path.length}.`, 'warn');
    }
    setBusy(false);
  }

  async function doDelete(x) {
    if (!isNum(x)) { print('Enter a valid number to delete.', 'warn'); return; }
    setBusy(true);
    clearPseudo();
    activeTab = 'delete';
    const res = tree.search(x);
    await animatePath(res.path, 'delete');
    if (!res.node) {
      print(`Cannot delete ${x}: not in tree.`, 'err');
      setBusy(false);
      return;
    }
    // If two-children, pre-highlight successor
    const node = res.node;
    if (node.left && node.right) {
      const succ = tree.min(node.right);
      if (succ) {
        print(`Node ${x} has two children. Using successor ${succ.key}.`, 'info');
        flashNode(succ, 'highlight', 800);
      }
    }
    const { found } = tree.delete(x);
    draw();
    if (found) {
      print(`Deleted ${x}.`, 'ok');
    } else {
      print(`Delete failed for ${x}.`, 'err');
    }
    setBusy(false);
  }

  async function doTraversal(kind) {
    setBusy(true);
    clearPseudo();
    activeTab = 'traverse';
    let arr = [];
    if (kind === 'inorder') {
      arr = tree.inorder();
      highlightPseudo('traverse', [1,2,3,4,5]);
    } else if (kind === 'preorder') {
      arr = tree.preorder();
      highlightPseudo('traverse', [6,7,8,9]);
    } else if (kind === 'postorder') {
      arr = tree.postorder();
      highlightPseudo('traverse', [10,11,12,13]);
    } else {
      arr = tree.levelorder();
      highlightPseudo('traverse', [14,15,16,17,18]);
    }
    await animateVisit(arr);
    const seq = arr.map(n => n.key).join(' ');
    print(`${kind} traversal: ${seq}`, 'info');
    setBusy(false);
  }

  // Helpers
  function isNum(x) {
    if (x === null || x === undefined) return false;
    const n = Number(x);
    return !Number.isNaN(n);
  }

  // Random tree
  function generateSequence(len=8, min=0, max=99) {
    const set = new Set();
    while (set.size < len) {
      set.add(Math.floor(Math.random() * (max-min+1)) + min);
    }
    return Array.from(set);
  }

  async function insertList(list) {
    setBusy(true);
    for (const v of list) {
      await doInsert(v);
    }
    setBusy(false);
  }

  // Events
  btnInsert.addEventListener('click', () => {
    const x = Number(valInput.value);
    doInsert(x);
  });
  btnSearch.addEventListener('click', () => {
    const x = Number(valInput.value);
    doSearch(x);
  });
  btnDelete.addEventListener('click', () => {
    const x = Number(valInput.value);
    doDelete(x);
  });

  btnInsertList.addEventListener('click', () => {
    const raw = listInput.value.trim();
    if (!raw) { print('Enter a list like: 50,20,70,10 30 60 80', 'warn'); return; }
    const parts = raw.split(/[\s,;]+/).map(Number).filter(n => !Number.isNaN(n));
    if (!parts.length) { print('List contains no valid numbers.', 'err'); return; }
    insertList(parts);
  });

  btnRandom.addEventListener('click', async () => {
    clearTree();
    const len = Number(randomCount.value);
    const seq = generateSequence(len, 0, 99);
    print(`Random sequence: ${seq.join(' ')}`, 'info');
    await insertList(seq);
  });

  btnClear.addEventListener('click', () => {
    clearTree();
    print('Cleared tree.', 'info');
  });

  animSwitch.addEventListener('click', () => {
    animSwitch.classList.toggle('on');
    animate = animSwitch.classList.contains('on');
  });

  themeSwitch.addEventListener('click', () => {
    themeSwitch.classList.toggle('on');
    themeLight = themeSwitch.classList.contains('on');
    document.body.classList.toggle('light', themeLight);
  });

  metaSwitch.addEventListener('click', () => {
    metaSwitch.classList.toggle('on');
    showMeta = metaSwitch.classList.contains('on');
    draw();
  });

  speedSlider.addEventListener('input', () => {
    speed = Number(speedSlider.value);
    const label = speed <= 20 ? '0.5x' : speed <= 50 ? '1x' : speed <= 80 ? '2x' : '3x';
    speedLabel.textContent = label;
  });

  // Inspector buttons
  btnInorder.addEventListener('click', () => doTraversal('inorder'));
  btnPreorder.addEventListener('click', () => doTraversal('preorder'));
  btnPostorder.addEventListener('click', () => doTraversal('postorder'));
  btnLevelorder.addEventListener('click', () => doTraversal('levelorder'));

  btnValidate.addEventListener('click', () => {
    const valid = tree.validate();
    if (valid) {
      print('BST property holds. Inorder is sorted.', 'ok');
    } else {
      print('BST property violated! Check your operations.', 'err');
    }
  });
  btnBalanced.addEventListener('click', () => {
    const ok = tree.isBalanced();
    if (ok) print('Tree is height-balanced (|LH-RH| ≤ 1) at all nodes.', 'ok');
    else print('Tree is not height-balanced.', 'warn');
  });
  btnStats.addEventListener('click', () => {
    const s = tree.stats();
    print(`Stats: nodes=${s.nodes}, height=${s.height}, leaves=${s.leaves}`, 'info');
  });

  // Challenge mode
  let challSeq = [];
  let challActive = false;
  btnGenChallenge.addEventListener('click', () => {
    const len = Number(challengeLen.value);
    challSeq = generateSequence(len, 0, 99);
    challengeSeq.textContent = `Sequence: ${challSeq.join(' ')}`;
    challengeStatus.textContent = 'Click Start to build this sequence. Insert values in order.';
    challActive = false;
  });
  btnStartChallenge.addEventListener('click', async () => {
    if (!challSeq.length) {
      print('Generate a sequence first.', 'warn');
      return;
    }
    clearTree();
    challActive = true;
    challengeStatus.textContent = 'Challenge started. Insert values in order shown.';
    print('Challenge started. Follow the sequence to insert.', 'info');
  });
  btnResetChallenge.addEventListener('click', () => {
    challSeq = [];
    challengeSeq.textContent = '';
    challengeStatus.textContent = 'No challenge yet. Click Generate Sequence.';
    challActive = false;
  });
  btnChallengeCheck.addEventListener('click', () => {
    if (!tree.root) { print('Tree is empty. Start a challenge or insert values.', 'warn'); return; }
    const inorder = tree.inorder().map(n => n.key);
    const valid = tree.validate();
    print(`Inorder: ${inorder.join(' ')}`, valid ? 'ok' : 'err');
    const ok = tree.isBalanced();
    print(ok ? 'This tree is balanced.' : 'This tree is not balanced.', ok ? 'ok' : 'warn');
  });
  btnChallengeHint.addEventListener('click', () => {
    print('Hint: Inorder traversal should be sorted. Delete uses successor. For skewed sequences, tree height grows.', 'info');
  });

  // Intercept manual insert during challenge to assist
  btnInsert.addEventListener('click', () => {
    if (!challActive || !challSeq.length) return;
    const x = Number(valInput.value);
    const idx = nextChallengeIndex();
    if (idx === -1) return;
    if (x !== challSeq[idx]) {
      print(`Out of order! Expected ${challSeq[idx]} next.`, 'warn');
    } else {
      // success: after doInsert finishes, move index
      // we don't need explicit index; we check set of inserted equals prefix
      setTimeout(() => {
        const inserted = currentKeys();
        const prefix = challSeq.slice(0, inserted.length);
        if (arraysEqual(inserted, prefix)) {
          challengeStatus.textContent = inserted.length === challSeq.length
            ? 'Challenge complete! Now check traversals and stats.'
            : `Good! Next expected: ${challSeq[inserted.length]}`;
        }
      }, 700);
    }
  });

  function nextChallengeIndex() {
    if (!challSeq.length) return -1;
    const inserted = currentKeys();
    return inserted.length;
  }
  function currentKeys() {
    return tree.preorder().map(n => n.key); // track count via preorder count
  }
  function arraysEqual(a, b) {
    if (a.length !== b.length) return false;
    for (let i=0;i<a.length;i++) if (a[i] !== b[i]) return false;
    return true;
  }

  // Tree reset
  function clearTree() {
    tree.root = null;
    tree.nodeCount = 0;
    clearSVG();
  }

  // Initial demo
  function demo() {
    const seq = [50, 25, 75, 10, 40, 60, 85, 5, 15, 55, 65];
    insertList(seq);
    print('Loaded demo tree. Try traversals and delete 25.', 'info');
  }
  demo();

  // Keyboard helpers
  valInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') doInsert(Number(valInput.value));
  });
  listInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') btnInsertList.click();
  });

  // Draw on resize: ensure viewBox remains constant (SVG scales)
  window.addEventListener('resize', () => draw());

  // Ensure drawing after any operation if not already
  const observer = new MutationObserver(() => {});
  draw();

})();
</script>
</body>
</html>