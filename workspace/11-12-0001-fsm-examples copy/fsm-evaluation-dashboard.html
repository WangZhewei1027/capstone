<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FSM Comparison Dashboard with Scientific Evaluation</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
      }

      .dashboard {
        max-width: 1600px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        color: white;
        margin-bottom: 30px;
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .header p {
        font-size: 1.2em;
        opacity: 0.9;
      }

      .fsm-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .fsm-card {
        background: white;
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        padding: 20px;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        position: relative;
      }

      .fsm-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 12px 35px rgba(0, 0, 0, 0.15);
      }

      .ideal-fsm {
        border-left: 6px solid #4caf50;
        background: linear-gradient(145deg, #ffffff 0%, #f0f8f0 100%);
      }

      .extracted-fsm {
        border-left: 6px solid #2196f3;
        background: linear-gradient(145deg, #ffffff 0%, #f0f6ff 100%);
      }

      .ideal-fsm .fsm-title {
        color: #2e7d32;
      }

      .extracted-fsm .fsm-title {
        color: #1565c0;
      }

      .fsm-title {
        font-size: 1.3em;
        font-weight: bold;
        color: #333;
        margin-bottom: 10px;
        border-bottom: 2px solid #e0e0e0;
        padding-bottom: 8px;
      }

      .fsm-meta {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 15px;
        font-size: 0.9em;
      }

      .meta-item {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
      }

      .meta-label {
        font-weight: bold;
        color: #666;
      }

      .meta-value {
        color: #333;
      }

      /* Evaluation Panel Styles */
      .evaluation-panel {
        background: linear-gradient(145deg, #f8f9fa, #e9ecef);
        border-radius: 12px;
        padding: 15px;
        margin: 15px 0;
        border: 2px solid #dee2e6;
        position: relative;
      }

      .evaluation-title {
        font-size: 1.1em;
        font-weight: bold;
        color: #495057;
        margin-bottom: 12px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .score-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
        margin-bottom: 12px;
      }

      .score-item {
        text-align: center;
        padding: 8px 4px;
        background: white;
        border-radius: 8px;
        border: 1px solid #e9ecef;
        transition: all 0.3s ease;
      }

      .score-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .score-value {
        font-size: 1.2em;
        font-weight: bold;
        margin-bottom: 2px;
      }

      .score-label {
        font-size: 0.8em;
        color: #6c757d;
      }

      .total-score {
        text-align: center;
        padding: 12px;
        background: linear-gradient(135deg, #28a745, #20c997);
        color: white;
        border-radius: 8px;
        font-weight: bold;
        font-size: 1.1em;
        margin: 10px 0;
      }

      .grade-badge {
        position: absolute;
        top: -10px;
        right: 15px;
        background: linear-gradient(135deg, #ffd700, #ffed4e);
        color: #333;
        padding: 5px 12px;
        border-radius: 15px;
        font-weight: bold;
        font-size: 1.1em;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .score-excellent {
        color: #28a745;
      }
      .score-good {
        color: #17a2b8;
      }
      .score-fair {
        color: #ffc107;
      }
      .score-poor {
        color: #dc3545;
      }

      .semantic-matches {
        font-size: 0.85em;
        color: #495057;
        margin-top: 10px;
        padding: 8px;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 6px;
        border-left: 4px solid #007bff;
      }

      .match-item {
        margin: 4px 0;
        padding: 2px 0;
      }

      .reference-badge {
        background: linear-gradient(135deg, #28a745, #20c997);
        color: white;
        padding: 8px 15px;
        border-radius: 20px;
        font-weight: bold;
        text-align: center;
        margin: 10px 0;
      }

      .fsm-graph {
        width: 100%;
        height: 350px;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        background: #fafafa;
        margin-top: 15px;
      }

      .comparison-panel {
        background: white;
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        padding: 25px;
        margin-top: 30px;
      }

      .comparison-title {
        font-size: 1.5em;
        color: #333;
        margin-bottom: 20px;
        text-align: center;
      }

      .controls {
        text-align: center;
        margin-bottom: 20px;
      }

      .btn {
        background: #007bff;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 25px;
        cursor: pointer;
        margin: 0 10px;
        font-size: 1em;
        transition: background 0.3s ease;
      }

      .btn:hover {
        background: #0056b3;
      }

      .success-message {
        background: #d4edda;
        color: #155724;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        border: 1px solid #c3e6cb;
      }

      .error-message {
        background: #f8d7da;
        color: #721c24;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        border: 1px solid #f5c6cb;
      }

      /* D3 Graph Styles */
      .node {
        cursor: pointer;
        stroke-width: 2px;
      }

      .node-idle {
        fill: #4caf50;
        stroke: #2e7d32;
      }
      .node-atomic {
        fill: #2196f3;
        stroke: #1565c0;
      }
      .node-composite {
        fill: #ff9800;
        stroke: #ef6c00;
      }
      .node-error {
        fill: #f44336;
        stroke: #c62828;
      }

      .node-label {
        font-family: Arial, sans-serif;
        font-size: 10px;
        font-weight: bold;
        text-anchor: middle;
        dominant-baseline: central;
        fill: white;
        pointer-events: none;
      }

      .link {
        stroke: #666;
        stroke-width: 1.5px;
        fill: none;
        marker-end: url(#arrowhead);
      }

      .link-label {
        font-family: Arial, sans-serif;
        font-size: 8px;
        fill: #333;
        text-anchor: middle;
      }

      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        pointer-events: none;
        font-size: 12px;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.2s;
      }

      @media (max-width: 768px) {
        .fsm-grid {
          grid-template-columns: 1fr;
        }
        .score-grid {
          grid-template-columns: repeat(2, 1fr);
        }
      }
    </style>
  </head>
  <body>
    <div class="dashboard">
      <div class="header">
        <h1>üîÑ FSM Scientific Evaluation Dashboard</h1>
        <p>Advanced FSM Analysis with Semantic Coverage Scoring</p>
      </div>

      <div class="controls">
        <button class="btn" onclick="loadAllFSMs()">üîÑ Load All FSMs</button>
        <button class="btn" onclick="resetAllViews()">üéØ Reset Views</button>
        <button class="btn" onclick="exportAllGraphs()">
          üíæ Export Graphs
        </button>
        <button class="btn" onclick="refreshFSMList()">üîç Re-scan FSMs</button>
        <button class="btn" onclick="recalculateScores()">
          üìä Recalculate Scores
        </button>
      </div>

      <div
        id="loadingIndicator"
        style="display: none; text-align: center; color: white; margin: 10px 0"
      >
        <p>üîç Analyzing FSM structures and calculating evaluation scores...</p>
      </div>

      <div id="messageArea"></div>

      <div id="fsmGrid" class="fsm-grid">
        <!-- FSM cards will be dynamically populated -->
      </div>

      <div class="comparison-panel">
        <div class="comparison-title">üìä Comprehensive Evaluation Analysis</div>
        <div id="comparisonContent">
          <!-- Comparison data will be populated here -->
        </div>
      </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
      // Advanced Semantic FSM Evaluator
      class SemanticFSMEvaluator {
        constructor() {
          this.componentSemantics = {
            input: [
              "input",
              "textbox",
              "field",
              "entry",
              "value",
              "number",
              "text",
            ],
            button: [
              "button",
              "btn",
              "click",
              "submit",
              "action",
              "control",
              "press",
            ],
            visual: [
              "visual",
              "display",
              "canvas",
              "tree",
              "graph",
              "container",
              "view",
              "render",
            ],
            node: ["node", "element", "item", "vertex", "point", "circle"],
          };

          this.stateSemantics = {
            idle: ["idle", "initial", "start", "ready", "waiting", "standby"],
            validation: [
              "validation",
              "validate",
              "check",
              "verify",
              "input",
              "error",
            ],
            insert: ["insert", "add", "create", "new", "append", "place"],
            delete: ["delete", "remove", "clear", "destroy", "erase"],
            search: ["search", "find", "lookup", "query", "locate"],
            reset: ["reset", "clear", "restart", "initialize", "refresh"],
            error: ["error", "invalid", "fail", "wrong", "bad"],
            complete: ["complete", "done", "finish", "success", "end"],
          };

          this.eventSemantics = {
            click: ["click", "press", "tap", "activate", "trigger", "select"],
            fill: ["fill", "input", "enter", "type", "set", "write"],
            change: ["change", "modify", "update", "edit", "alter"],
            submit: ["submit", "confirm", "apply", "execute", "run"],
          };

          this.weights = {
            component_coverage: 0.25,
            state_coverage: 0.35,
            transition_coverage: 0.3,
            semantic_quality: 0.1,
          };
        }

        calculateSemanticSimilarity(term1, term2, semanticMap) {
          if (!term1 || !term2) return 0;

          term1 = term1.toLowerCase();
          term2 = term2.toLowerCase();

          // Direct match
          if (term1 === term2) return 1.0;

          // Substring match
          if (term1.includes(term2) || term2.includes(term1)) return 0.8;

          // Semantic category matching
          let category1 = null,
            category2 = null;
          for (const [category, terms] of Object.entries(semanticMap)) {
            if (terms.some((t) => term1.includes(t) || t.includes(term1)))
              category1 = category;
            if (terms.some((t) => term2.includes(t) || t.includes(term2)))
              category2 = category;
          }

          if (category1 && category2 && category1 === category2) return 0.6;

          // Levenshtein distance based similarity
          const distance = this.levenshteinDistance(term1, term2);
          const maxLength = Math.max(term1.length, term2.length);
          const similarity = 1 - distance / maxLength;

          return similarity > 0.5 ? similarity * 0.4 : 0;
        }

        levenshteinDistance(str1, str2) {
          const matrix = Array(str2.length + 1)
            .fill(null)
            .map(() => Array(str1.length + 1).fill(null));

          for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
          for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;

          for (let j = 1; j <= str2.length; j++) {
            for (let i = 1; i <= str1.length; i++) {
              const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
              matrix[j][i] = Math.min(
                matrix[j][i - 1] + 1,
                matrix[j - 1][i] + 1,
                matrix[j - 1][i - 1] + indicator
              );
            }
          }

          return matrix[str2.length][str1.length];
        }

        evaluateComponentCoverage(extractedFSM, idealFSM) {
          if (!idealFSM || !idealFSM.components || !extractedFSM.components) {
            return {
              score: extractedFSM.components?.length > 0 ? 0.5 : 0,
              details: { reason: "Missing component data" },
            };
          }

          const idealComponents = Array.isArray(idealFSM.components)
            ? idealFSM.components
            : [];
          const extractedComponents = Array.isArray(extractedFSM.components)
            ? extractedFSM.components
            : [];

          if (idealComponents.length === 0) {
            return {
              score: 1,
              details: { reason: "No ideal components to compare" },
            };
          }

          let totalMatches = 0;
          const matches = [];

          for (const idealComp of idealComponents) {
            let bestMatch = 0;
            let bestMatchName = null;

            for (const extractedComp of extractedComponents) {
              const similarity = this.calculateSemanticSimilarity(
                extractedComp,
                idealComp,
                this.componentSemantics
              );
              if (similarity > bestMatch) {
                bestMatch = similarity;
                bestMatchName = extractedComp;
              }
            }

            if (bestMatch > 0.3) {
              totalMatches += bestMatch;
              matches.push({
                ideal: idealComp,
                extracted: bestMatchName,
                score: bestMatch,
              });
            }
          }

          const score = totalMatches / idealComponents.length;
          return {
            score: Math.min(score, 1),
            details: {
              ideal_count: idealComponents.length,
              extracted_count: extractedComponents.length,
              matches: matches,
              coverage_ratio: `${matches.length}/${idealComponents.length}`,
            },
          };
        }

        evaluateStateCoverage(extractedFSM, idealFSM) {
          if (!idealFSM?.states || !extractedFSM?.states) {
            return {
              score: extractedFSM?.states?.length > 1 ? 0.5 : 0,
              details: { reason: "Missing state data" },
            };
          }

          const idealStates = idealFSM.states || [];
          const extractedStates = extractedFSM.states || [];

          if (idealStates.length === 0) {
            return {
              score: 1,
              details: { reason: "No ideal states to compare" },
            };
          }

          let totalMatches = 0;
          const matches = [];

          for (const idealState of idealStates) {
            let bestMatch = 0;
            let bestMatchState = null;

            for (const extractedState of extractedStates) {
              const nameSimilarity = this.calculateSemanticSimilarity(
                extractedState.label ||
                  extractedState.name ||
                  extractedState.id,
                idealState.name || idealState.label || idealState.id,
                this.stateSemantics
              );

              const typeSimilarity =
                extractedState.type === idealState.type ? 0.2 : 0;
              const totalSimilarity = nameSimilarity + typeSimilarity;

              if (totalSimilarity > bestMatch) {
                bestMatch = totalSimilarity;
                bestMatchState = extractedState;
              }
            }

            if (bestMatch > 0.3) {
              totalMatches += Math.min(bestMatch, 1);
              matches.push({
                ideal: idealState.name || idealState.label || idealState.id,
                extracted: bestMatchState?.label || bestMatchState?.id,
                score: Math.min(bestMatch, 1),
              });
            }
          }

          const score = totalMatches / idealStates.length;
          return {
            score: Math.min(score, 1),
            details: {
              ideal_count: idealStates.length,
              extracted_count: extractedStates.length,
              matches: matches,
              coverage_ratio: `${matches.length}/${idealStates.length}`,
            },
          };
        }

        evaluateTransitionCoverage(extractedFSM, idealFSM) {
          if (!idealFSM?.transitions || !extractedFSM?.transitions) {
            return {
              score: extractedFSM?.transitions?.length > 0 ? 0.5 : 0,
              details: { reason: "Missing transition data" },
            };
          }

          const idealTransitions = idealFSM.transitions || [];
          const extractedTransitions = extractedFSM.transitions || [];

          if (idealTransitions.length === 0) {
            return {
              score: 1,
              details: { reason: "No ideal transitions to compare" },
            };
          }

          let totalMatches = 0;
          const matches = [];

          for (const idealTransition of idealTransitions) {
            let bestMatch = 0;
            let bestMatchTransition = null;

            for (const extractedTransition of extractedTransitions) {
              const eventSim = this.calculateSemanticSimilarity(
                extractedTransition.event || "",
                idealTransition.event || "",
                this.eventSemantics
              );

              const fromSim = this.calculateSemanticSimilarity(
                extractedTransition.from || "",
                idealTransition.from || "",
                this.stateSemantics
              );

              const toSim = this.calculateSemanticSimilarity(
                extractedTransition.to || "",
                idealTransition.to || "",
                this.stateSemantics
              );

              const totalSim = eventSim * 0.5 + fromSim * 0.25 + toSim * 0.25;

              if (totalSim > bestMatch) {
                bestMatch = totalSim;
                bestMatchTransition = extractedTransition;
              }
            }

            if (bestMatch > 0.3) {
              totalMatches += bestMatch;
              matches.push({
                ideal: `${idealTransition.from} ‚Üí ${idealTransition.to}`,
                extracted: `${bestMatchTransition?.from} ‚Üí ${bestMatchTransition?.to}`,
                score: bestMatch,
              });
            }
          }

          const score = totalMatches / idealTransitions.length;
          return {
            score: Math.min(score, 1),
            details: {
              ideal_count: idealTransitions.length,
              extracted_count: extractedTransitions.length,
              matches: matches,
              coverage_ratio: `${matches.length}/${idealTransitions.length}`,
            },
          };
        }

        evaluateSemanticQuality(extractedFSM) {
          let qualityScore = 0.5;

          const states = extractedFSM.states || [];
          const meaningfulStateNames = states.filter(
            (s) =>
              (s.label || s.id || "").length > 2 &&
              !(s.label || s.id || "").match(/^S\d+_Unknown/)
          ).length;
          qualityScore +=
            (meaningfulStateNames / Math.max(states.length, 1)) * 0.2;

          const events = extractedFSM.events || [];
          const meaningfulEventNames = events.filter(
            (e) =>
              (e.id || "").includes("User") || e.event_type === "user_action"
          ).length;
          qualityScore +=
            (meaningfulEventNames / Math.max(events.length, 1)) * 0.2;

          const transitions = extractedFSM.transitions || [];
          const completeTransitions = transitions.filter(
            (t) => t.from && t.to && t.event
          ).length;
          qualityScore +=
            (completeTransitions / Math.max(transitions.length, 1)) * 0.1;

          return {
            score: Math.min(qualityScore, 1),
            details: {
              meaningful_states: meaningfulStateNames,
              meaningful_events: meaningfulEventNames,
              complete_transitions: completeTransitions,
            },
          };
        }

        evaluateFSM(extractedFSM, idealFSM = null) {
          const results = {
            component_coverage: { score: 0, details: {} },
            state_coverage: { score: 0, details: {} },
            transition_coverage: { score: 0, details: {} },
            semantic_quality: { score: 0, details: {} },
            total_score: 0,
            grade: "F",
            timestamp: new Date().toISOString(),
          };

          results.component_coverage = this.evaluateComponentCoverage(
            extractedFSM,
            idealFSM
          );
          results.state_coverage = this.evaluateStateCoverage(
            extractedFSM,
            idealFSM
          );
          results.transition_coverage = this.evaluateTransitionCoverage(
            extractedFSM,
            idealFSM
          );
          results.semantic_quality = this.evaluateSemanticQuality(extractedFSM);

          results.total_score =
            results.component_coverage.score * this.weights.component_coverage +
            results.state_coverage.score * this.weights.state_coverage +
            results.transition_coverage.score *
              this.weights.transition_coverage +
            results.semantic_quality.score * this.weights.semantic_quality;

          // Grade assignment
          if (results.total_score >= 0.9) results.grade = "A+";
          else if (results.total_score >= 0.85) results.grade = "A";
          else if (results.total_score >= 0.8) results.grade = "A-";
          else if (results.total_score >= 0.75) results.grade = "B+";
          else if (results.total_score >= 0.7) results.grade = "B";
          else if (results.total_score >= 0.65) results.grade = "B-";
          else if (results.total_score >= 0.6) results.grade = "C+";
          else if (results.total_score >= 0.55) results.grade = "C";
          else if (results.total_score >= 0.5) results.grade = "C-";
          else if (results.total_score >= 0.4) results.grade = "D";
          else results.grade = "F";

          return results;
        }
      }

      class FSMComparisonDashboard {
        constructor() {
          this.fsms = new Map();
          this.visualizers = new Map();
          this.tooltip = d3.select("#tooltip");
          this.fsmDefinitions = [];
          this.evaluator = new SemanticFSMEvaluator();

          this.initializeIdealFSM();
          this.scanAndLoadExtractedFSMs();
        }

        initializeIdealFSM() {
          this.fsmDefinitions = [
            {
              id: "ideal",
              title: "üìã Ideal FSM (Reference)",
              description: "Binary Search Tree - Educational Template",
              isIdeal: true,
              data: {
                meta: {
                  concept: "BinarySearchTree",
                  topic: "Binary Search Tree Visualization",
                  educational_goal: "Demonstrate BST insertion and traversal",
                  expected_interactions: [
                    "insert_value",
                    "search_value",
                    "delete_value",
                    "reset",
                  ],
                },
                states: [
                  {
                    id: "S0_Idle",
                    label: "Idle",
                    type: "idle",
                    entry_actions: ["renderPage()", "enableControls()"],
                    exit_actions: [],
                  },
                  {
                    id: "S1_InsertStart",
                    label: "InsertStart",
                    type: "atomic",
                    entry_actions: ["readInputValue()", "highlightInput()"],
                    exit_actions: ["clearHighlight()"],
                  },
                  {
                    id: "S2_InputValidation",
                    label: "InputValidation",
                    type: "atomic",
                    entry_actions: [
                      "validateInput()",
                      "showValidationFeedback()",
                    ],
                    exit_actions: [],
                  },
                  {
                    id: "S3_InputError",
                    label: "InputError",
                    type: "error",
                    entry_actions: ["showError()", "highlightError()"],
                    exit_actions: ["clearError()"],
                  },
                  {
                    id: "S4_SearchExecute",
                    label: "SearchExecute",
                    type: "atomic",
                    entry_actions: ["searchNode()", "highlightPath()"],
                    exit_actions: [],
                  },
                  {
                    id: "S5_NodeInserted",
                    label: "NodeInserted",
                    type: "atomic",
                    entry_actions: ["updateTree()", "renderNewNode()"],
                    exit_actions: ["enableControls()"],
                  },
                  {
                    id: "S6_TreeReset",
                    label: "TreeReset",
                    type: "atomic",
                    entry_actions: ["clearTree()", "resetView()"],
                    exit_actions: ["returnToIdle()"],
                  },
                ],
                events: [
                  {
                    id: "insertButtonClicked",
                    event_type: "user_action",
                    description: "User clicks the Insert button",
                  },
                  {
                    id: "inputValueEntered",
                    event_type: "user_input",
                    description: "User enters value in input field",
                  },
                  {
                    id: "searchButtonClicked",
                    event_type: "user_action",
                    description: "User clicks the Search button",
                  },
                  {
                    id: "deleteButtonClicked",
                    event_type: "user_action",
                    description: "User clicks the Delete button",
                  },
                  {
                    id: "resetButtonClicked",
                    event_type: "user_action",
                    description: "User clicks the Reset button",
                  },
                ],
                transitions: [
                  {
                    from: "S0_Idle",
                    to: "S1_InsertStart",
                    event: "insertButtonClicked",
                    guard: "true",
                    actions: ["captureInput()", "disableControls()"],
                  },
                  {
                    from: "S1_InsertStart",
                    to: "S2_InputValidation",
                    event: "inputValueEntered",
                    guard: "inputNotEmpty",
                    actions: ["validateValue()"],
                  },
                  {
                    from: "S2_InputValidation",
                    to: "S5_NodeInserted",
                    event: "insertButtonClicked",
                    guard: "validInput",
                    actions: ["insertNode()", "updateVisualization()"],
                  },
                  {
                    from: "S0_Idle",
                    to: "S6_TreeReset",
                    event: "resetButtonClicked",
                    guard: "true",
                    actions: ["clearAllNodes()"],
                  },
                ],
                components: ["input", "insert", "reset", "tree_visualization"],
              },
            },
          ];
        }

        async scanAndLoadExtractedFSMs() {
          const loadingIndicator = document.getElementById("loadingIndicator");
          const messageArea = document.getElementById("messageArea");
          loadingIndicator.style.display = "block";

          try {
            await this.loadFSMsFromKnownFolders();
            messageArea.innerHTML = `<div class="success-message">‚úÖ Successfully evaluated ${
              this.fsmDefinitions.length - 1
            } extracted FSMs</div>`;
          } catch (error) {
            console.error("Error loading FSMs:", error);
            messageArea.innerHTML = `<div class="error-message">‚ùå Failed to load FSMs: ${error.message}</div>`;
          } finally {
            loadingIndicator.style.display = "none";
          }
        }

        async loadFSMsFromKnownFolders() {
          console.log("üìÅ Loading and evaluating FSMs from known folders...");

          const knownFolders = [
            "4ca11ad0-b408-11f0-ab52-fbe7249bf639",
            "5d7c31e0-bf4e-11f0-9d64-ab1079f525e7",
            "5d8dd330-bf50-11f0-9278-a57cfa0a44e5",
            "9e580470-bf51-11f0-8ac4-79272b6a78b2",
          ];

          const idealFSM = this.fsmDefinitions.find((f) => f.isIdeal)?.data;

          for (const folderId of knownFolders) {
            try {
              const fsmPath = `./fsm/${folderId}/extracted_fsm.json`;
              console.log(`üîç Loading FSM from: ${fsmPath}`);

              const fsmResponse = await fetch(fsmPath);
              if (!fsmResponse.ok) continue;

              const extractedFSM = await fsmResponse.json();

              // Perform comprehensive evaluation
              const evaluation = this.evaluator.evaluateFSM(
                extractedFSM,
                idealFSM
              );

              const fsmDef = {
                id: folderId,
                title: `ü§ñ Extracted FSM - ${folderId.substring(0, 8)}...`,
                description: `Auto-extracted (${
                  extractedFSM.states?.length || 0
                } states, ${
                  extractedFSM.transitions?.length || 0
                } transitions)`,
                isExtracted: true,
                data: extractedFSM,
                evaluation: evaluation,
              };

              this.fsmDefinitions.push(fsmDef);
              console.log(
                `‚úÖ Evaluated FSM ${folderId}: Score ${(
                  evaluation.total_score * 100
                ).toFixed(1)}% (${evaluation.grade})`
              );
            } catch (error) {
              console.error(`‚ùå Failed to load FSM ${folderId}:`, error);
            }
          }
        }

        createFSMCard(fsmDef) {
          const meta = fsmDef.data.meta || {};
          const stats = this.calculateStats(fsmDef.data);
          const evaluation = fsmDef.evaluation;

          const cardClass = fsmDef.isIdeal
            ? "fsm-card ideal-fsm"
            : "fsm-card extracted-fsm";
          const titleIcon = fsmDef.isIdeal ? "üìã" : "ü§ñ";

          return `
            <div class="${cardClass}" id="card-${fsmDef.id}">
                ${
                  evaluation
                    ? `<div class="grade-badge">${evaluation.grade}</div>`
                    : ""
                }
                <div class="fsm-title">${titleIcon} ${fsmDef.title}</div>
                <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">${
                  fsmDef.description
                }</p>
                
                <div class="fsm-meta">
                    <div class="meta-item">
                        <span class="meta-label">Concept:</span>
                        <span class="meta-value">${meta.concept || "N/A"}</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">States:</span>
                        <span class="meta-value">${stats.states}</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">Events:</span>
                        <span class="meta-value">${stats.events}</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">Transitions:</span>
                        <span class="meta-value">${stats.transitions}</span>
                    </div>
                </div>
                
                ${this.generateEvaluationPanel(evaluation, fsmDef.isIdeal)}
                
                <svg class="fsm-graph" id="graph-${fsmDef.id}"></svg>
            </div>
          `;
        }

        generateEvaluationPanel(evaluation, isIdeal) {
          if (isIdeal) {
            return '<div class="reference-badge">üìã Reference Model</div>';
          }

          if (!evaluation) {
            return '<div class="evaluation-panel"><div class="evaluation-title">‚è≥ Evaluation Pending</div></div>';
          }

          const getScoreClass = (score) => {
            if (score >= 0.8) return "score-excellent";
            if (score >= 0.6) return "score-good";
            if (score >= 0.4) return "score-fair";
            return "score-poor";
          };

          const formatScore = (score) => `${(score * 100).toFixed(1)}%`;

          return `
            <div class="evaluation-panel">
              <div class="evaluation-title">
                üìä Scientific Evaluation
                <span style="font-size: 1.2em; margin-left: 8px;">${
                  evaluation.grade
                }</span>
              </div>
              
              <div class="score-grid">
                <div class="score-item" title="Component coverage analysis">
                  <div class="score-value ${getScoreClass(
                    evaluation.component_coverage.score
                  )}">
                    ${formatScore(evaluation.component_coverage.score)}
                  </div>
                  <div class="score-label">Components</div>
                </div>
                
                <div class="score-item" title="State coverage analysis">
                  <div class="score-value ${getScoreClass(
                    evaluation.state_coverage.score
                  )}">
                    ${formatScore(evaluation.state_coverage.score)}
                  </div>
                  <div class="score-label">States</div>
                </div>
                
                <div class="score-item" title="Transition coverage analysis">
                  <div class="score-value ${getScoreClass(
                    evaluation.transition_coverage.score
                  )}">
                    ${formatScore(evaluation.transition_coverage.score)}
                  </div>
                  <div class="score-label">Transitions</div>
                </div>
                
                <div class="score-item" title="Semantic quality assessment">
                  <div class="score-value ${getScoreClass(
                    evaluation.semantic_quality.score
                  )}">
                    ${formatScore(evaluation.semantic_quality.score)}
                  </div>
                  <div class="score-label">Quality</div>
                </div>
              </div>
              
              <div class="total-score">
                üèÜ Total Score: ${formatScore(evaluation.total_score)} (${
            evaluation.grade
          })
              </div>
              
              ${this.generateSemanticMatches(evaluation)}
            </div>
          `;
        }

        generateSemanticMatches(evaluation) {
          const matches = [];

          if (evaluation.state_coverage.details.matches?.length > 0) {
            const stateMatches =
              evaluation.state_coverage.details.matches.slice(0, 2);
            matches.push(
              `üéØ State Matches: ${stateMatches
                .map(
                  (m) =>
                    `"${m.ideal}" ‚âà "${m.extracted}" (${(m.score * 100).toFixed(
                      0
                    )}%)`
                )
                .join(", ")}`
            );
          }

          if (evaluation.component_coverage.details.matches?.length > 0) {
            const compMatches =
              evaluation.component_coverage.details.matches.slice(0, 2);
            matches.push(
              `üîß Component Matches: ${compMatches
                .map(
                  (m) =>
                    `"${m.ideal}" ‚âà "${m.extracted}" (${(m.score * 100).toFixed(
                      0
                    )}%)`
                )
                .join(", ")}`
            );
          }

          if (matches.length === 0) return "";

          return `
            <div class="semantic-matches">
              ${matches
                .map((match) => `<div class="match-item">${match}</div>`)
                .join("")}
            </div>
          `;
        }

        calculateStats(fsm) {
          return {
            states: fsm.states?.length || 0,
            events: fsm.events?.length || 0,
            transitions: fsm.transitions?.length || 0,
            components: fsm.components ? fsm.components.length : 0,
          };
        }

        visualizeFSM(fsmId, fsm) {
          const svg = d3.select(`#graph-${fsmId}`);
          const width = 580;
          const height = 350;

          svg.selectAll("*").remove();

          svg
            .append("defs")
            .append("marker")
            .attr("id", `arrowhead-${fsmId}`)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 20)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .style("fill", "#666");

          const container = svg.append("g");

          const nodes =
            fsm.states?.map((state) => ({
              id: state.id,
              label: state.label || state.id,
              type: state.type || "atomic",
              ...state,
            })) || [];

          const links =
            fsm.transitions?.map((transition) => ({
              source: transition.from,
              target: transition.to,
              event: transition.event,
              ...transition,
            })) || [];

          const simulation = d3
            .forceSimulation(nodes)
            .force(
              "link",
              d3
                .forceLink(links)
                .id((d) => d.id)
                .distance(80)
            )
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide(30));

          const link = container
            .selectAll(".link")
            .data(links)
            .join("path")
            .attr("class", "link")
            .attr("marker-end", `url(#arrowhead-${fsmId})`);

          const linkLabel = container
            .selectAll(".link-label")
            .data(links)
            .join("text")
            .attr("class", "link-label")
            .text((d) =>
              d.event
                ? d.event
                    .replace("User", "")
                    .replace("Fill", "F:")
                    .replace("Click", "C:")
                : "T"
            );

          const node = container
            .selectAll(".node")
            .data(nodes)
            .join("circle")
            .attr("class", (d) => `node node-${d.type}`)
            .attr("r", 25)
            .on("mouseover", (event, d) => this.showTooltip(event, d))
            .on("mouseout", () => this.hideTooltip());

          const nodeLabel = container
            .selectAll(".node-label")
            .data(nodes)
            .join("text")
            .attr("class", "node-label")
            .text((d) =>
              d.label.length > 10 ? d.label.substring(0, 10) + "..." : d.label
            );

          simulation.on("tick", () => {
            link.attr("d", (d) => {
              const dx = d.target.x - d.source.x;
              const dy = d.target.y - d.source.y;
              const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
              return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
            });

            linkLabel
              .attr("x", (d) => (d.source.x + d.target.x) / 2)
              .attr("y", (d) => (d.source.y + d.target.y) / 2);

            node
              .attr("cx", (d) => Math.max(25, Math.min(width - 25, d.x)))
              .attr("cy", (d) => Math.max(25, Math.min(height - 25, d.y)));

            nodeLabel
              .attr("x", (d) => Math.max(25, Math.min(width - 25, d.x)))
              .attr("y", (d) => Math.max(25, Math.min(height - 25, d.y)));
          });

          this.visualizers.set(fsmId, { svg, simulation });
        }

        showTooltip(event, state) {
          this.tooltip
            .style("opacity", 1)
            .html(
              `
              <strong>${state.label}</strong><br>
              Type: ${state.type}<br>
              ID: ${state.id}<br>
              Entry: ${(state.entry_actions || []).length} actions<br>
              Exit: ${(state.exit_actions || []).length} actions
            `
            )
            .style("left", event.pageX + 10 + "px")
            .style("top", event.pageY - 10 + "px");
        }

        hideTooltip() {
          this.tooltip.style("opacity", 0);
        }

        generateComparison() {
          const extractedFSMs = this.fsmDefinitions.filter(
            (f) => f.isExtracted && f.evaluation
          );

          if (extractedFSMs.length === 0) {
            return "<p>No evaluated FSMs available for comparison.</p>";
          }

          const avgScore =
            extractedFSMs.reduce(
              (sum, fsm) => sum + fsm.evaluation.total_score,
              0
            ) / extractedFSMs.length;
          const bestFSM = extractedFSMs.reduce((best, current) =>
            current.evaluation.total_score > best.evaluation.total_score
              ? current
              : best
          );

          return `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
              <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; text-align: center;">
                <h3>üìä Average Score</h3>
                <div style="font-size: 2em; font-weight: bold; color: #007bff;">
                  ${(avgScore * 100).toFixed(1)}%
                </div>
                <p>Across ${extractedFSMs.length} FSMs</p>
              </div>
              
              <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; text-align: center;">
                <h3>üèÜ Best Performer</h3>
                <div style="font-size: 1.5em; font-weight: bold; color: #28a745;">
                  ${bestFSM.title.substring(0, 20)}...
                </div>
                <div style="font-size: 1.2em; margin-top: 5px;">
                  ${(bestFSM.evaluation.total_score * 100).toFixed(1)}% (${
            bestFSM.evaluation.grade
          })
                </div>
              </div>
              
              <div style="background: #f8f9fa; padding: 20px; border-radius: 10px;">
                <h3>üìà Score Distribution</h3>
                ${extractedFSMs
                  .map(
                    (fsm) => `
                  <div style="margin: 5px 0;">
                    <strong>${fsm.id.substring(0, 8)}:</strong> 
                    ${(fsm.evaluation.total_score * 100).toFixed(1)}% (${
                      fsm.evaluation.grade
                    })
                  </div>
                `
                  )
                  .join("")}
              </div>
            </div>
          `;
        }

        render() {
          const fsmGrid = document.getElementById("fsmGrid");
          const comparisonContent =
            document.getElementById("comparisonContent");

          fsmGrid.innerHTML = this.fsmDefinitions
            .map((fsm) => this.createFSMCard(fsm))
            .join("");

          comparisonContent.innerHTML = this.generateComparison();

          this.fsmDefinitions.forEach((fsmDef) => {
            this.fsms.set(fsmDef.id, fsmDef.data);
            setTimeout(() => {
              this.visualizeFSM(fsmDef.id, fsmDef.data);
            }, 100);
          });
        }
      }

      // Global functions
      function loadAllFSMs() {
        if (window.dashboard) {
          window.dashboard.render();
        }
      }

      function refreshFSMList() {
        if (window.dashboard) {
          const messageArea = document.getElementById("messageArea");
          messageArea.innerHTML = `<div class="success-message">üîÑ Re-scanning and re-evaluating FSMs...</div>`;

          window.dashboard.fsmDefinitions =
            window.dashboard.fsmDefinitions.filter((fsm) => fsm.isIdeal);

          window.dashboard.scanAndLoadExtractedFSMs().then(() => {
            window.dashboard.render();
          });
        }
      }

      function resetAllViews() {
        if (window.dashboard) {
          window.dashboard.fsmDefinitions.forEach((fsmDef) => {
            const visualizer = window.dashboard.visualizers.get(fsmDef.id);
            if (visualizer && visualizer.simulation) {
              visualizer.simulation.alpha(1).restart();
            }
          });
        }
      }

      function recalculateScores() {
        if (window.dashboard) {
          const messageArea = document.getElementById("messageArea");
          messageArea.innerHTML = `<div class="success-message">üîÑ Recalculating evaluation scores...</div>`;

          const idealFSM = window.dashboard.fsmDefinitions.find(
            (f) => f.isIdeal
          )?.data;

          window.dashboard.fsmDefinitions.forEach((fsmDef) => {
            if (fsmDef.isExtracted) {
              fsmDef.evaluation = window.dashboard.evaluator.evaluateFSM(
                fsmDef.data,
                idealFSM
              );
            }
          });

          window.dashboard.render();

          setTimeout(() => {
            messageArea.innerHTML = `<div class="success-message">‚úÖ Scores recalculated successfully!</div>`;
          }, 1000);
        }
      }

      function exportAllGraphs() {
        window.dashboard.fsmDefinitions.forEach((fsmDef) => {
          const svg = document.querySelector(`#graph-${fsmDef.id}`);
          const serializer = new XMLSerializer();
          const svgString = serializer.serializeToString(svg);

          const blob = new Blob([svgString], { type: "image/svg+xml" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = `fsm-${fsmDef.id}-evaluation-${Date.now()}.svg`;
          a.click();

          URL.revokeObjectURL(url);
        });
      }

      // Initialize dashboard when DOM loads
      document.addEventListener("DOMContentLoaded", () => {
        window.dashboard = new FSMComparisonDashboard();
        window.dashboard.render();
      });
    </script>
  </body>
</html>
