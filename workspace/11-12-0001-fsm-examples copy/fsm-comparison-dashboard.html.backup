<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FSM Comparison Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
      }

      .dashboard {
        max-width: 1600px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        color: white;
        margin-bottom: 30px;
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .header p {
        font-size: 1.2em;
        opacity: 0.9;
      }

      .fsm-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .fsm-card {
        background: white;
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        padding: 20px;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }

      .fsm-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 12px 35px rgba(0, 0, 0, 0.15);
      }

      .ideal-fsm {
        border-left: 6px solid #4caf50;
        background: linear-gradient(145deg, #ffffff 0%, #f0f8f0 100%);
      }

      .extracted-fsm {
        border-left: 6px solid #2196f3;
        background: linear-gradient(145deg, #ffffff 0%, #f0f6ff 100%);
      }

      .ideal-fsm .fsm-title {
        color: #2e7d32;
      }

      .extracted-fsm .fsm-title {
        color: #1565c0;
      }

      .fsm-title {
        font-size: 1.3em;
        font-weight: bold;
        color: #333;
        margin-bottom: 10px;
        border-bottom: 2px solid #e0e0e0;
        padding-bottom: 8px;
      }

      .fsm-meta {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 15px;
        font-size: 0.9em;
      }

      .meta-item {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
      }

      .meta-label {
        font-weight: bold;
        color: #666;
      }

      .meta-value {
        color: #333;
      }

      .fsm-graph {
        width: 100%;
        height: 400px;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        background: #fafafa;
      }

      .comparison-panel {
        background: white;
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        padding: 25px;
        margin-top: 30px;
      }

      .comparison-title {
        font-size: 1.5em;
        color: #333;
        margin-bottom: 20px;
        text-align: center;
      }

      .comparison-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
      }

      .comparison-item {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #007bff;
      }

      .comparison-item h4 {
        margin: 0 0 10px 0;
        color: #333;
      }

      .comparison-stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
        text-align: center;
      }

      .stat-box {
        background: white;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
      }

      .stat-number {
        font-size: 2em;
        font-weight: bold;
        color: #007bff;
      }

      .stat-label {
        font-size: 0.9em;
        color: #666;
        margin-top: 5px;
      }

      .controls {
        text-align: center;
        margin-bottom: 20px;
      }

      .btn {
        background: #007bff;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 25px;
        cursor: pointer;
        margin: 0 10px;
        font-size: 1em;
        transition: background 0.3s ease;
      }

      .btn:hover {
        background: #0056b3;
      }

      /* D3 Graph Styles */
      .node {
        cursor: pointer;
        stroke-width: 2px;
      }

      .node-idle {
        fill: #4caf50;
        stroke: #2e7d32;
      }
      .node-atomic {
        fill: #2196f3;
        stroke: #1565c0;
      }
      .node-composite {
        fill: #ff9800;
        stroke: #ef6c00;
      }
      .node-error {
        fill: #f44336;
        stroke: #c62828;
      }

      .node-label {
        font-family: Arial, sans-serif;
        font-size: 10px;
        font-weight: bold;
        text-anchor: middle;
        dominant-baseline: central;
        fill: white;
        pointer-events: none;
      }

      .link {
        stroke: #666;
        stroke-width: 1.5px;
        fill: none;
        marker-end: url(#arrowhead);
      }

      .link-label {
        font-family: Arial, sans-serif;
        font-size: 8px;
        fill: #333;
        text-anchor: middle;
      }

      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        pointer-events: none;
        font-size: 12px;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.2s;
      }

      @media (max-width: 768px) {
        .fsm-grid {
          grid-template-columns: 1fr;
        }

        .comparison-grid {
          grid-template-columns: 1fr;
        }

        .comparison-stats {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="dashboard">
      <div class="header">
        <h1>üîÑ FSM Comparison Dashboard</h1>
        <p>Compare and Visualize Multiple Finite State Machines</p>
      </div>

      <div class="controls">
        <button class="btn" onclick="loadAllFSMs()">üîÑ Load All FSMs</button>
        <button class="btn" onclick="resetAllViews()">üéØ Reset All Views</button>
        <button class="btn" onclick="exportAllGraphs()">üíæ Export All Graphs</button>
        <button class="btn" onclick="refreshFSMList()">üîç Scan FSM Folder</button>
      </div>
      
      <div id="loadingIndicator" style="display: none; text-align: center; color: white; margin: 10px 0;">
        <p>üîç Scanning /fsm folder for extracted FSM files...</p>
      </div>

      <div id="fsmGrid" class="fsm-grid">
        <!-- FSM cards will be dynamically populated -->
      </div>

      <div class="comparison-panel">
        <div class="comparison-title">üìä Comparative Analysis</div>
        <div id="comparisonContent">
          <!-- Comparison data will be populated here -->
        </div>
      </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
      class FSMComparisonDashboard {
        constructor() {
          this.fsms = new Map();
          this.visualizers = new Map();
          this.tooltip = d3.select("#tooltip");
          this.fsmDefinitions = [];

          this.initializeIdealFSM();
          this.scanAndLoadExtractedFSMs();
        }

        initializeIdealFSM() {
          // Add the ideal FSM as the reference
          this.fsmDefinitions = [
            {
              id: "ideal",
              title: "üìã Ideal FSM (Reference)",
              description: "Binary Search Tree - Educational Template",
              isIdeal: true,
              data: {
                meta: {
                  concept: "BinarySearchTree",
                  topic: "Binary Search Tree Visualization",
                  educational_goal: "Demonstrate BST insertion and traversal",
                  expected_interactions: [
                    "insert_value",
                    "search_value", 
                    "delete_value",
                    "reset",
                  ],
                },
                states: [
                  {
                    id: "S0_Idle",
                    label: "Idle",
                    type: "idle",
                    entry_actions: ["renderPage()", "enableControls()"],
                    exit_actions: [],
                  },
                  {
                    id: "S1_InsertStart", 
                    label: "InsertStart",
                    type: "atomic",
                    entry_actions: ["readInputValue()", "highlightInput()"],
                    exit_actions: ["clearHighlight()"],
                  },
                  {
                    id: "S2_InputValidation",
                    label: "InputValidation", 
                    type: "atomic",
                    entry_actions: ["validateInput()", "showValidationFeedback()"],
                    exit_actions: [],
                  },
                  {
                    id: "S3_InputError",
                    label: "InputError",
                    type: "error", 
                    entry_actions: ["showError()", "highlightError()"],
                    exit_actions: ["clearError()"],
                  },
                  {
                    id: "S4_SearchExecute",
                    label: "SearchExecute",
                    type: "atomic",
                    entry_actions: ["searchNode()", "highlightPath()"],
                    exit_actions: [],
                  },
                  {
                    id: "S5_NodeInserted", 
                    label: "NodeInserted",
                    type: "atomic",
                    entry_actions: ["updateTree()", "renderNewNode()"],
                    exit_actions: ["enableControls()"],
                  },
                  {
                    id: "S6_TreeReset",
                    label: "TreeReset", 
                    type: "atomic",
                    entry_actions: ["clearTree()", "resetView()"],
                    exit_actions: ["returnToIdle()"],
                  },
                ],
                events: [
                  {
                    id: "insertButtonClicked",
                    event_type: "user_action",
                    description: "User clicks the Insert button",
                  },
                  {
                    id: "inputValueEntered",
                    event_type: "user_input",
                    description: "User enters value in input field",
                  },
                  {
                    id: "searchButtonClicked",
                    event_type: "user_action", 
                    description: "User clicks the Search button",
                  },
                  {
                    id: "deleteButtonClicked",
                    event_type: "user_action",
                    description: "User clicks the Delete button", 
                  },
                  {
                    id: "resetButtonClicked",
                    event_type: "user_action",
                    description: "User clicks the Reset button",
                  },
                ],
                transitions: [
                  {
                    from: "S0_Idle",
                    to: "S1_InsertStart", 
                    event: "insertButtonClicked",
                    guard: "true",
                    actions: ["captureInput()", "disableControls()"],
                  },
                  {
                    from: "S1_InsertStart",
                    to: "S2_InputValidation",
                    event: "inputValueEntered", 
                    guard: "inputNotEmpty",
                    actions: ["validateValue()"],
                  },
                  {
                    from: "S2_InputValidation", 
                    to: "S5_NodeInserted",
                    event: "insertButtonClicked",
                    guard: "validInput",
                    actions: ["insertNode()", "updateVisualization()"],
                  },
                  {
                    from: "S0_Idle",
                    to: "S6_TreeReset",
                    event: "resetButtonClicked", 
                    guard: "true",
                    actions: ["clearAllNodes()"],
                  },
                ],
                components: ["input", "insert", "reset", "tree_visualization"],
              },
            },
          ];
        }

        async scanAndLoadExtractedFSMs() {
          const loadingIndicator = document.getElementById("loadingIndicator");
          loadingIndicator.style.display = "block";

          try {
            // Try to load the overall analysis report first to get the list of analyzed files
            const overallReportResponse = await fetch('./fsm/overall_analysis_report.json');
            
            if (overallReportResponse.ok) {
              const overallReport = await overallReportResponse.json();
              await this.loadFSMsFromReport(overallReport);
            } else {
              // Fallback: try to load from known folders
              await this.loadFSMsFromKnownFolders();
            }
          } catch (error) {
            console.log("Using fallback method to load FSMs:", error);
            await this.loadFSMsFromKnownFolders();
          } finally {
            loadingIndicator.style.display = "none";
          }
        }

        async loadFSMsFromReport(overallReport) {
          console.log("üìä Loading FSMs from overall analysis report...");
          
          const successfulFiles = overallReport.file_details?.filter(
            f => f.status === "analyzed" && f.states > 0
          ) || [];

          console.log(`Found ${successfulFiles.length} analyzed FSMs`);

          for (const fileDetail of successfulFiles) {
            try {
              const htmlFileName = fileDetail.file.replace('.html', '');
              const fsmPath = `./fsm/${htmlFileName}/extracted_fsm.json`;
              const analysisPath = `./fsm/${htmlFileName}/analysis_report.json`;

              // Load the extracted FSM
              const fsmResponse = await fetch(fsmPath);
              if (!fsmResponse.ok) continue;

              const extractedFSM = await fsmResponse.json();
              
              // Try to load analysis report for additional metadata
              let analysisReport = null;
              try {
                const analysisResponse = await fetch(analysisPath);
                if (analysisResponse.ok) {
                  analysisReport = await analysisResponse.json();
                }
              } catch (e) {
                console.log(`No analysis report for ${htmlFileName}`);
              }

              // Create FSM definition
              const fsmDef = {
                id: htmlFileName,
                title: `ü§ñ Extracted FSM - ${htmlFileName.substring(0, 12)}...`,
                description: `Auto-extracted from ${fileDetail.file} (${fileDetail.states} states, ${fileDetail.transitions} transitions)`,
                isExtracted: true,
                htmlFile: fileDetail.file,
                data: extractedFSM,
                analysis: analysisReport,
                stats: {
                  states: fileDetail.states,
                  transitions: fileDetail.transitions,
                  components: fileDetail.components,
                  state_coverage: fileDetail.state_coverage,
                  transition_coverage: fileDetail.transition_coverage
                }
              };

              this.fsmDefinitions.push(fsmDef);
              console.log(`‚úÖ Loaded FSM: ${htmlFileName}`);

            } catch (error) {
              console.error(`‚ùå Failed to load FSM for ${fileDetail.file}:`, error);
            }
          }
        }

        async loadFSMsFromKnownFolders() {
          console.log("üìÅ Loading FSMs from known folders...");
          
          // Known extracted FSM folders based on the attached data
          const knownFolders = [
            '5d7c31e0-bf4e-11f0-9d64-ab1079f525e7',
            '5d8dd330-bf50-11f0-9278-a57cfa0a44e5', 
            '9e580470-bf51-11f0-8ac4-79272b6a78b2',
            'fad12780-bf52-11f0-bc20-193729720a40'
          ];

          for (const folderId of knownFolders) {
            try {
              const fsmPath = `./fsm/${folderId}/extracted_fsm.json`;
              const analysisPath = `./fsm/${folderId}/analysis_report.json`;

              const fsmResponse = await fetch(fsmPath);
              if (!fsmResponse.ok) continue;

              const extractedFSM = await fsmResponse.json();
              
              // Try to load analysis report
              let analysisReport = null;
              try {
                const analysisResponse = await fetch(analysisPath);
                if (analysisResponse.ok) {
                  analysisReport = await analysisResponse.json();
                }
              } catch (e) {
                console.log(`No analysis report for ${folderId}`);
              }

              const fsmDef = {
                id: folderId,
                title: `ü§ñ Extracted FSM - ${folderId.substring(0, 8)}...`,
                description: `Auto-extracted FSM (${extractedFSM.states?.length || 0} states, ${extractedFSM.transitions?.length || 0} transitions)`,
                isExtracted: true,
                data: extractedFSM,
                analysis: analysisReport
              };

              this.fsmDefinitions.push(fsmDef);
              console.log(`‚úÖ Loaded FSM: ${folderId}`);

            } catch (error) {
              console.error(`‚ùå Failed to load FSM ${folderId}:`, error);
            }
          }
        }

        createFSMCard(fsmDef) {
            {
              id: "ideal",
              title: "Ideal FSM (Reference)",
              description: "Binary Search Tree - Educational Template",
              data: {
                meta: {
                  concept: "BinarySearchTree",
                  topic: "Binary Search Tree Visualization",
                  educational_goal: "Demonstrate BST insertion and traversal",
                  expected_interactions: [
                    "insert",
                    "delete",
                    "search",
                    "reset",
                  ],
                },
                states: [
                  {
                    id: "S0_Idle",
                    label: "Idle",
                    type: "idle",
                    entry_actions: ["renderTree()", "enableControls()"],
                    exit_actions: [],
                  },
                  {
                    id: "S1_InsertStart",
                    label: "InsertStart",
                    type: "atomic",
                    entry_actions: ["readInputValue()", "highlightInput()"],
                    exit_actions: ["clearHighlight()"],
                  },
                  {
                    id: "S2_ValidatingInput",
                    label: "ValidatingInput",
                    type: "atomic",
                    entry_actions: [
                      "validateInput()",
                      "showValidationFeedback()",
                    ],
                    exit_actions: [],
                  },
                  {
                    id: "S3_ErrorAlert",
                    label: "ErrorAlert",
                    type: "atomic",
                    entry_actions: ["showErrorDialog()", "highlightError()"],
                    exit_actions: ["clearError()"],
                  },
                  {
                    id: "S4_InsertingNode",
                    label: "InsertingNode",
                    type: "atomic",
                    entry_actions: ["findInsertPosition()", "createNewNode()"],
                    exit_actions: [],
                  },
                  {
                    id: "S5_DrawingTree",
                    label: "DrawingTree",
                    type: "atomic",
                    entry_actions: [
                      "updateTreeVisualization()",
                      "animateInsertion()",
                    ],
                    exit_actions: ["enableControls()"],
                  },
                  {
                    id: "S6_TreeResetting",
                    label: "TreeResetting",
                    type: "atomic",
                    entry_actions: ["clearAllNodes()", "resetVisualization()"],
                    exit_actions: ["returnToIdle()"],
                  },
                ],
                events: [
                  {
                    id: "UserClicksInsert",
                    event_type: "user_action",
                    description: "User clicks the Insert button",
                  },
                  {
                    id: "UserEntersInput",
                    event_type: "user_action",
                    description: "User enters value in input field",
                  },
                  {
                    id: "UserClicksReset",
                    event_type: "user_action",
                    description: "User clicks the Reset button",
                  },
                  {
                    id: "InputValidationComplete",
                    event_type: "system_event",
                    description: "Input validation completes successfully",
                  },
                  {
                    id: "InputValidationFailed",
                    event_type: "system_event",
                    description: "Input validation fails",
                  },
                  {
                    id: "NodeInsertionComplete",
                    event_type: "system_event",
                    description: "Node insertion and tree update complete",
                  },
                  {
                    id: "TreeResetComplete",
                    event_type: "system_event",
                    description: "Tree reset operation complete",
                  },
                  {
                    id: "UserDismissesAlert",
                    event_type: "user_action",
                    description: "User dismisses error alert dialog",
                  },
                ],
                transitions: [
                  {
                    from: "S0_Idle",
                    to: "S1_InsertStart",
                    event: "UserClicksInsert",
                    guard: "inputNotEmpty",
                    actions: ["captureInput()", "disableControls()"],
                    expected_observables: [
                      "dom:readInputValue",
                      "dom:insertButtonClicked",
                    ],
                    timeout: 2000,
                  },
                  {
                    from: "S1_InsertStart",
                    to: "S2_ValidatingInput",
                    event: "InputValidationComplete",
                    guard: "inputIsValid",
                    actions: ["validateValue()", "prepareInsertion()"],
                    expected_observables: ["dom:inputValidated"],
                    timeout: 1000,
                  },
                  {
                    from: "S2_ValidatingInput",
                    to: "S4_InsertingNode",
                    event: "InputValidationComplete",
                    guard: "validNumber",
                    actions: ["parseInputValue()", "beginInsertion()"],
                    expected_observables: ["dom:nodeCreationStarted"],
                    timeout: 1500,
                  },
                  {
                    from: "S1_InsertStart",
                    to: "S3_ErrorAlert",
                    event: "InputValidationFailed",
                    guard: "inputIsEmpty",
                    actions: ["showError()", "focusInput()"],
                    expected_observables: ["dom:errorDialogShown"],
                    timeout: 1000,
                  },
                  {
                    from: "S3_ErrorAlert",
                    to: "S0_Idle",
                    event: "UserDismissesAlert",
                    guard: "true",
                    actions: ["clearErrorState()", "resetInput()"],
                    expected_observables: ["dom:errorDialogClosed"],
                    timeout: 500,
                  },
                  {
                    from: "S4_InsertingNode",
                    to: "S5_DrawingTree",
                    event: "NodeInsertionComplete",
                    guard: "nodeInsertedSuccessfully",
                    actions: [
                      "updateTreeStructure()",
                      "triggerVisualization()",
                    ],
                    expected_observables: [
                      "dom:treeStructureChanged",
                      "dom:newNodeVisible",
                    ],
                    timeout: 3000,
                  },
                  {
                    from: "S5_DrawingTree",
                    to: "S0_Idle",
                    event: "NodeInsertionComplete",
                    guard: "visualizationComplete",
                    actions: ["enableControls()", "clearInput()"],
                    expected_observables: ["dom:visualizationComplete"],
                    timeout: 1000,
                  },
                  {
                    from: "S0_Idle",
                    to: "S6_TreeResetting",
                    event: "UserClicksReset",
                    guard: "treeNotEmpty",
                    actions: ["confirmReset()", "beginClearOperation()"],
                    expected_observables: ["dom:resetButtonClicked"],
                    timeout: 500,
                  },
                  {
                    from: "S6_TreeResetting",
                    to: "S0_Idle",
                    event: "TreeResetComplete",
                    guard: "true",
                    actions: ["enableControls()", "resetInputField()"],
                    expected_observables: [
                      "dom:treeCleared",
                      "dom:visualizationReset",
                    ],
                    timeout: 1000,
                  },
                ],
                components: ["input", "insert", "reset", "tree_visualization"],
              },
            },
            {
              id: "extracted_full",
              title: "Extracted FSM (Full Features)",
              description:
                "Auto-extracted from 5d7c31e0-bf4e-11f0-9d64-ab1079f525e7.html",
              data: {
                meta: {
                  concept: "ExtractedFromActualPage",
                  extraction_method: "automated_probing",
                  timestamp: "2025-11-19T00:25:42.226Z",
                },
                states: [
                  {
                    id: "S0_Idle",
                    label: "Idle",
                    type: "idle",
                    entry_actions: ["renderPage()", "enableControls()"],
                    exit_actions: [],
                  },
                  {
                    id: "S1_InputValidation",
                    label: "InputValidation",
                    type: "atomic",
                    entry_actions: [
                      "validateInput()",
                      "showValidationFeedback()",
                    ],
                    exit_actions: [],
                  },
                  {
                    id: "S2_InputValidation",
                    label: "InputValidation",
                    type: "atomic",
                    entry_actions: [
                      "validateInput()",
                      "showValidationFeedback()",
                    ],
                    exit_actions: [],
                  },
                  {
                    id: "S3_InputValidation",
                    label: "InputValidation",
                    type: "atomic",
                    entry_actions: [
                      "validateInput()",
                      "showValidationFeedback()",
                    ],
                    exit_actions: [],
                  },
                  {
                    id: "S4_InsertStart",
                    label: "InsertStart",
                    type: "atomic",
                    entry_actions: ["readInputValue()", "highlightInput()"],
                    exit_actions: ["clearHighlight()"],
                  },
                  {
                    id: "S5_SearchStart",
                    label: "SearchStart",
                    type: "atomic",
                    entry_actions: ["logAction()"],
                    exit_actions: [],
                  },
                  {
                    id: "S6_DeleteStart",
                    label: "DeleteStart",
                    type: "atomic",
                    entry_actions: ["logAction()"],
                    exit_actions: [],
                  },
                  {
                    id: "S7_Reset",
                    label: "Reset",
                    type: "atomic",
                    entry_actions: ["clearTree()", "resetView()"],
                    exit_actions: ["returnToIdle()"],
                  },
                  {
                    id: "S8_NodeInserted",
                    label: "NodeInserted",
                    type: "atomic",
                    entry_actions: ["updateTree()", "renderNewNode()"],
                    exit_actions: ["enableControls()"],
                  },
                ],
                events: [
                  {
                    id: "UserFillvalueInput",
                    event_type: "user_action",
                    description: "User fills input valueInput",
                    component: "valueInput",
                    action: "fill",
                  },
                  {
                    id: "UserClickinsertBtn",
                    event_type: "user_action",
                    description: "User clicks button insertBtn",
                    component: "insertBtn",
                    action: "click",
                  },
                  {
                    id: "UserClicksearchBtn",
                    event_type: "user_action",
                    description: "User clicks button searchBtn",
                    component: "searchBtn",
                    action: "click",
                  },
                  {
                    id: "UserClickdeleteBtn",
                    event_type: "user_action",
                    description: "User clicks button deleteBtn",
                    component: "deleteBtn",
                    action: "click",
                  },
                  {
                    id: "UserClickclearBtn",
                    event_type: "user_action",
                    description: "User clicks button clearBtn",
                    component: "clearBtn",
                    action: "click",
                  },
                  {
                    id: "UserClickrandomBtn",
                    event_type: "user_action",
                    description: "User clicks button randomBtn",
                    component: "randomBtn",
                    action: "click",
                  },
                ],
                transitions: [
                  {
                    from: "S0_Idle",
                    to: "S1_InputValidation",
                    event: "UserFillvalueInput",
                    guard: "inputNotEmpty",
                    actions: ["validateValue()", "setErrorState()"],
                    expected_observables: ["dom:inputValueChanged"],
                    timeout: 2000,
                  },
                  {
                    from: "S0_Idle",
                    to: "S4_InsertStart",
                    event: "UserClickinsertBtn",
                    guard: "buttonEnabled",
                    actions: ["captureInput()", "disableControls()"],
                    expected_observables: [
                      "dom:insertBtnButtonClicked",
                      "dom:visualStructureChanged",
                      "dom:elementCountChanged",
                    ],
                    timeout: 2000,
                  },
                  {
                    from: "S0_Idle",
                    to: "S5_SearchStart",
                    event: "UserClicksearchBtn",
                    guard: "buttonEnabled",
                    actions: ["performAction()"],
                    expected_observables: [
                      "dom:searchBtnButtonClicked",
                      "dom:elementCountChanged",
                    ],
                    timeout: 2000,
                  },
                  {
                    from: "S0_Idle",
                    to: "S6_DeleteStart",
                    event: "UserClickdeleteBtn",
                    guard: "buttonEnabled",
                    actions: ["performAction()"],
                    expected_observables: [
                      "dom:deleteBtnButtonClicked",
                      "dom:elementCountChanged",
                    ],
                    timeout: 2000,
                  },
                  {
                    from: "S0_Idle",
                    to: "S7_Reset",
                    event: "UserClickclearBtn",
                    guard: "buttonEnabled",
                    actions: ["clearAllNodes()", "resetState()"],
                    expected_observables: [
                      "dom:clearBtnButtonClicked",
                      "dom:elementCountChanged",
                    ],
                    timeout: 2000,
                  },
                  {
                    from: "S0_Idle",
                    to: "S8_NodeInserted",
                    event: "UserClickrandomBtn",
                    guard: "buttonEnabled",
                    actions: ["insertNode()", "updateVisualization()"],
                    expected_observables: [
                      "dom:randomBtnButtonClicked",
                      "dom:visualStructureChanged",
                      "dom:elementCountChanged",
                    ],
                    timeout: 2000,
                  },
                ],
                components: ["input", "button", "visual"],
              },
            },
            {
              id: "extracted_minimal",
              title: "Extracted FSM (Minimal)",
              description:
                "Auto-extracted from 9e580470-bf51-11f0-8ac4-79272b6a78b2.html",
              data: {
                meta: {
                  concept: "ExtractedFromActualPage",
                  extraction_method: "automated_probing",
                  timestamp: "2025-11-18T23:57:39.676Z",
                },
                states: [
                  {
                    id: "S0_Idle",
                    label: "Idle",
                    type: "idle",
                    entry_actions: ["renderPage()", "enableControls()"],
                    exit_actions: [],
                  },
                  {
                    id: "S1_InputValidation",
                    label: "InputValidation",
                    type: "atomic",
                    entry_actions: [
                      "validateInput()",
                      "showValidationFeedback()",
                    ],
                    exit_actions: [],
                  },
                  {
                    id: "S2_InputValidation",
                    label: "InputValidation",
                    type: "atomic",
                    entry_actions: [
                      "validateInput()",
                      "showValidationFeedback()",
                    ],
                    exit_actions: [],
                  },
                  {
                    id: "S3_InputValidation",
                    label: "InputValidation",
                    type: "atomic",
                    entry_actions: [
                      "validateInput()",
                      "showValidationFeedback()",
                    ],
                    exit_actions: [],
                  },
                ],
                events: [
                  {
                    id: "UserFillinputValue",
                    event_type: "user_action",
                    description: "User fills input inputValue",
                    component: "inputValue",
                    action: "fill",
                  },
                ],
                transitions: [
                  {
                    from: "S0_Idle",
                    to: "S1_InputValidation",
                    event: "UserFillinputValue",
                    guard: "inputNotEmpty",
                    actions: ["validateValue()", "setErrorState()"],
                    expected_observables: ["dom:inputValueChanged"],
                    timeout: 2000,
                  },
                  {
                    from: "S0_Idle",
                    to: "S2_InputValidation",
                    event: "UserFillinputValue",
                    guard: "inputNotEmpty",
                    actions: ["validateValue()", "setErrorState()"],
                    expected_observables: ["dom:inputValueChanged"],
                    timeout: 2000,
                  },
                  {
                    from: "S0_Idle",
                    to: "S3_InputValidation",
                    event: "UserFillinputValue",
                    guard: "inputNotEmpty",
                    actions: ["validateValue()", "setErrorState()"],
                    expected_observables: ["dom:inputValueChanged"],
                    timeout: 2000,
                  },
                ],
                components: ["input", "button", "visual"],
              },
            },
          ];
        }

        createFSMCard(fsmDef) {
          const meta = fsmDef.data.meta || {};
          const stats = this.calculateStats(fsmDef.data);
          
          // Special handling for ideal vs extracted FSMs
          const cardClass = fsmDef.isIdeal ? 'fsm-card ideal-fsm' : 'fsm-card extracted-fsm';
          const titleIcon = fsmDef.isIdeal ? 'üìã' : 'ü§ñ';
          
          // Add coverage information if available
          let coverageInfo = '';
          if (fsmDef.stats && (fsmDef.stats.state_coverage || fsmDef.stats.transition_coverage)) {
            coverageInfo = `
              <div class="meta-item">
                <span class="meta-label">State Coverage:</span>
                <span class="meta-value">${((fsmDef.stats.state_coverage || 0) * 100).toFixed(1)}%</span>
              </div>
              <div class="meta-item">
                <span class="meta-label">Transition Coverage:</span>
                <span class="meta-value">${((fsmDef.stats.transition_coverage || 0) * 100).toFixed(1)}%</span>
              </div>
            `;
          }

          // Add extraction timestamp if available
          let timestampInfo = '';
          if (meta.timestamp) {
            const date = new Date(meta.timestamp);
            timestampInfo = `
              <div class="meta-item">
                <span class="meta-label">Extracted:</span>
                <span class="meta-value">${date.toLocaleDateString()} ${date.toLocaleTimeString()}</span>
              </div>
            `;
          }

          return `
                    <div class="${cardClass}" id="card-${fsmDef.id}">
                        <div class="fsm-title">${titleIcon} ${fsmDef.title}</div>
                        <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">${
                          fsmDef.description
                        }</p>
                        
                        <div class="fsm-meta">
                            <div class="meta-item">
                                <span class="meta-label">Concept:</span>
                                <span class="meta-value">${meta.concept || 'N/A'}</span>
                            </div>
                            <div class="meta-item">
                                <span class="meta-label">Method:</span>
                                <span class="meta-value">${meta.extraction_method || 'Manual'}</span>
                            </div>
                            <div class="meta-item">
                                <span class="meta-label">States:</span>
                                <span class="meta-value">${stats.states}</span>
                            </div>
                            <div class="meta-item">
                                <span class="meta-label">Events:</span>
                                <span class="meta-value">${stats.events}</span>
                            </div>
                            <div class="meta-item">
                                <span class="meta-label">Transitions:</span>
                                <span class="meta-value">${stats.transitions}</span>
                            </div>
                            <div class="meta-item">
                                <span class="meta-label">Components:</span>
                                <span class="meta-value">${stats.components}</span>
                            </div>
                            ${coverageInfo}
                            ${timestampInfo}
                        </div>
                        
                        <svg class="fsm-graph" id="graph-${fsmDef.id}"></svg>
                    </div>
                `;
        }

        calculateStats(fsm) {
          return {
            states: fsm.states.length,
            events: fsm.events.length,
            transitions: fsm.transitions.length,
            components: fsm.components ? fsm.components.length : 0,
          };
        }

        visualizeFSM(fsmId, fsm) {
          const svg = d3.select(`#graph-${fsmId}`);
          const width = 480;
          const height = 400;

          svg.selectAll("*").remove();

          // Add arrow marker
          svg
            .append("defs")
            .append("marker")
            .attr("id", `arrowhead-${fsmId}`)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 20)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .style("fill", "#666");

          const container = svg.append("g");

          // Prepare data
          const nodes = fsm.states.map((state) => ({
            id: state.id,
            label: state.label || state.id,
            type: state.type || "atomic",
            ...state,
          }));

          const links = fsm.transitions.map((transition) => ({
            source: transition.from,
            target: transition.to,
            event: transition.event,
            ...transition,
          }));

          // Create force simulation
          const simulation = d3
            .forceSimulation(nodes)
            .force(
              "link",
              d3
                .forceLink(links)
                .id((d) => d.id)
                .distance(80)
            )
            .force("charge", d3.forceManyBody().strength(-200))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide(25));

          // Create links
          const link = container
            .selectAll(".link")
            .data(links)
            .join("path")
            .attr("class", "link")
            .attr("marker-end", `url(#arrowhead-${fsmId})`);

          // Create link labels
          const linkLabel = container
            .selectAll(".link-label")
            .data(links)
            .join("text")
            .attr("class", "link-label")
            .text((d) =>
              d.event
                ? d.event
                    .replace("User", "")
                    .replace("Click", "")
                    .replace("Fill", "")
                : "T"
            );

          // Create nodes
          const node = container
            .selectAll(".node")
            .data(nodes)
            .join("circle")
            .attr("class", (d) => `node node-${d.type}`)
            .attr("r", 20)
            .on("mouseover", (event, d) => this.showTooltip(event, d))
            .on("mouseout", () => this.hideTooltip());

          // Create node labels
          const nodeLabel = container
            .selectAll(".node-label")
            .data(nodes)
            .join("text")
            .attr("class", "node-label")
            .text((d) =>
              d.label.length > 8 ? d.label.substring(0, 8) + "..." : d.label
            );

          // Update positions on simulation tick
          simulation.on("tick", () => {
            link.attr("d", (d) => {
              const dx = d.target.x - d.source.x;
              const dy = d.target.y - d.source.y;
              const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
              return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
            });

            linkLabel
              .attr("x", (d) => (d.source.x + d.target.x) / 2)
              .attr("y", (d) => (d.source.y + d.target.y) / 2);

            node
              .attr("cx", (d) => Math.max(20, Math.min(width - 20, d.x)))
              .attr("cy", (d) => Math.max(20, Math.min(height - 20, d.y)));

            nodeLabel
              .attr("x", (d) => Math.max(20, Math.min(width - 20, d.x)))
              .attr("y", (d) => Math.max(20, Math.min(height - 20, d.y)));
          });

          this.visualizers.set(fsmId, { svg, simulation });
        }

        showTooltip(event, state) {
          this.tooltip
            .style("opacity", 1)
            .html(
              `
                        <strong>${state.label}</strong><br>
                        Type: ${state.type}<br>
                        ID: ${state.id}<br>
                        Entry: ${(state.entry_actions || []).length} actions<br>
                        Exit: ${(state.exit_actions || []).length} actions
                    `
            )
            .style("left", event.pageX + 10 + "px")
            .style("top", event.pageY - 10 + "px");
        }

        hideTooltip() {
          this.tooltip.style("opacity", 0);
        }

        generateComparison() {
          const allStats = this.fsmDefinitions.map((fsm) => ({
            name: fsm.title,
            ...this.calculateStats(fsm.data),
          }));

          const totalStats = allStats.reduce(
            (acc, stats) => ({
              states: acc.states + stats.states,
              events: acc.events + stats.events,
              transitions: acc.transitions + stats.transitions,
              components: acc.components + stats.components,
            }),
            { states: 0, events: 0, transitions: 0, components: 0 }
          );

          return `
                    <div class="comparison-stats">
                        <div class="stat-box">
                            <div class="stat-number">${totalStats.states}</div>
                            <div class="stat-label">Total States</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number">${
                              totalStats.transitions
                            }</div>
                            <div class="stat-label">Total Transitions</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number">${totalStats.events}</div>
                            <div class="stat-label">Total Events</div>
                        </div>
                    </div>
                    
                    <div class="comparison-grid" style="margin-top: 20px;">
                        ${allStats
                          .map(
                            (stats) => `
                            <div class="comparison-item">
                                <h4>${stats.name}</h4>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                                    <div><strong>States:</strong> ${stats.states}</div>
                                    <div><strong>Events:</strong> ${stats.events}</div>
                                    <div><strong>Transitions:</strong> ${stats.transitions}</div>
                                    <div><strong>Components:</strong> ${stats.components}</div>
                                </div>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                `;
        }

        render() {
          const fsmGrid = document.getElementById("fsmGrid");
          const comparisonContent =
            document.getElementById("comparisonContent");

          // Render FSM cards
          fsmGrid.innerHTML = this.fsmDefinitions
            .map((fsm) => this.createFSMCard(fsm))
            .join("");

          // Render comparison
          comparisonContent.innerHTML = this.generateComparison();

          // Initialize visualizations
          this.fsmDefinitions.forEach((fsmDef) => {
            this.fsms.set(fsmDef.id, fsmDef.data);
            setTimeout(() => {
              this.visualizeFSM(fsmDef.id, fsmDef.data);
            }, 100);
          });
        }
      }

      // Global functions
      function loadAllFSMs() {
        if (window.dashboard) {
          window.dashboard.render();
        }
      }

      function refreshFSMList() {
        if (window.dashboard) {
          // Clear current extracted FSMs but keep ideal FSM
          window.dashboard.fsmDefinitions = window.dashboard.fsmDefinitions.filter(fsm => fsm.isIdeal);
          
          // Re-scan for extracted FSMs
          window.dashboard.scanAndLoadExtractedFSMs().then(() => {
            window.dashboard.render();
          });
        }
      }

      function resetAllViews() {
        if (window.dashboard) {
          window.dashboard.fsmDefinitions.forEach((fsmDef) => {
            const visualizer = window.dashboard.visualizers.get(fsmDef.id);
            if (visualizer && visualizer.simulation) {
              visualizer.simulation.alpha(1).restart();
            }
          });
        }
      }

      function exportAllGraphs() {
        window.dashboard.fsmDefinitions.forEach((fsmDef) => {
          const svg = document.querySelector(`#graph-${fsmDef.id}`);
          const serializer = new XMLSerializer();
          const svgString = serializer.serializeToString(svg);

          const blob = new Blob([svgString], { type: "image/svg+xml" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = `fsm-${fsmDef.id}-${Date.now()}.svg`;
          a.click();

          URL.revokeObjectURL(url);
        });
      }

      // Initialize dashboard when DOM loads
      document.addEventListener("DOMContentLoaded", () => {
        window.dashboard = new FSMComparisonDashboard();
        window.dashboard.render();
      });
    </script>
  </body>
</html>
