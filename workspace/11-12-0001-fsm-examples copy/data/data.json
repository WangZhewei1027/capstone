[
  {
    "id": "4ca11ad0-b408-11f0-ab52-fbe7249bf639",
    "timestamp": "2025-10-28T14:16:50.695Z",
    "model": "gpt-4o-mini",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "Below is a description of how to create a high-quality interactive HTML page that provides an in-depth, hands-on exploration of the Binary Search Tree (BST) concept.\n\n### Interactive HTML Page Design for Binary Search Tree (BST)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interactive Binary Search Tree</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 24px;\n            background-color: #f0f0f0;\n        }\n        h1 {\n            text-align: center;\n            color: #333;\n        }\n        .container {\n            max-width: 800px;\n            margin: 0 auto;\n        }\n        .tree-container {\n            border: 1px solid #ccc;\n            padding: 16px;\n            border-radius: 8px;\n            background-color: #fff;\n            position: relative;\n            height: 400px;\n            overflow: hidden;\n        }\n        .node {\n            position: absolute;\n            background: #4caf50;\n            border-radius: 50%;\n            color: white;\n            width: 30px;\n            height: 30px;\n            text-align: center;\n            line-height: 30px;\n            transition: transform 0.3s ease;\n        }\n        .controls {\n            text-align: center;\n            margin: 16px 0;\n        }\n        .input-number {\n            padding: 8px;\n            font-size: 16px;\n        }\n        .button {\n            margin-left: 8px;\n            padding: 8px 12px;\n            cursor: pointer;\n            background-color: #007bff;\n            color: white;\n            border: none;\n            border-radius: 4px;\n        }\n        .button:hover {\n            background-color: #0056b3;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Interactive Binary Search Tree (BST)</h1>\n        <p>Understand the structure and function of a Binary Search Tree through hands-on interaction.</p>\n\n        <div class=\"controls\">\n            <input type=\"number\" id=\"nodeValue\" class=\"input-number\" placeholder=\"Enter a number\">\n            <button class=\"button\" onclick=\"insertNode()\">Insert Node</button>\n            <button class=\"button\" onclick=\"resetTree()\">Reset Tree</button>\n        </div>\n\n        <div class=\"tree-container\" id=\"treeContainer\"></div>\n    </div>\n\n    <script>\n        class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }\n    </script>\n</body>\n</html>\n```\n\n### Explanation of the Design\n\n#### Concept Title:\nThe module is titled \"Interactive Binary Search Tree (BST).\"\n\n#### Learning Objective:\nUsers will understand how a Binary Search Tree works by visualizing the insertion of nodes and seeing how the tree structure evolves in real-time through interactions.\n\n#### Interaction Design:\n- Users can input a number in the text box and click the \"Insert Node\" button to insert it into the BST.\n- Upon clicking the button, the tree is drawn in the designated area (`treeContainer`), and each node appears as a visual circle with lines connecting them to their parent nodes.\n- The \"Reset Tree\" button allows users to clear the tree and start over, providing opportunities for multiple trials.\n\n#### Layout Description:\n- The **header** and **short description** are located at the top, providing context to users.\n- Below that, the **control section** with an input field and buttons facilitates user interaction and is centered for accessibility.\n- The **`treeContainer`** area is below the controls, dynamically displaying the BST visually, making it the focal point of the page.\n- Safe area margins and minimum spacing between elements have been adhered to, ensuring a clean and accessible layout that is also responsive to different viewport sizes.\n\nThis design can be further enhanced or modified based on the user's needs, but it effectively serves as a self-contained, informative, and interactive educational tool for understanding Binary Search Trees."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Binary Search Tree (BST).\n\n**Project Overview:**\nTopic: Binary Search Tree (BST)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization ‚Äî placement of text, controls, and visuals ‚Äî including how you will maintain clarity, focus, and balance.  \n    - Safe area margins: **24 px** on all sides of the viewport.  \n    - Minimum spacing: **16 px** between any two interactive elements.  \n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.  \n2. The page must include **at least one form of visual feedback or animation** responding to user input.  \n3. The implementation must be **self-contained** ‚Äî using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).  \n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.",
      "states": [
        {
          "name": "idle",
          "onEnter": "set_idle",
          "on": {
            "CLICK_INSERT": "validating_input",
            "CLICK_RESET": "tree_resetting"
          }
        },
        {
          "name": "validating_input",
          "onEnter": "parse_input_and_validate",
          "on": {
            "INPUT_INVALID": "error_alert",
            "INPUT_VALID": "inserting_node"
          }
        },
        {
          "name": "error_alert",
          "onEnter": "alert_invalid_number",
          "on": {
            "ALERT_DISMISSED": "idle"
          }
        },
        {
          "name": "inserting_node",
          "onEnter": "perform_bst_insert",
          "on": {
            "BST_INSERTED": "drawing_tree"
          }
        },
        {
          "name": "drawing_tree",
          "onEnter": "render_bst",
          "on": {
            "TREE_RENDERED": "idle"
          }
        },
        {
          "name": "tree_resetting",
          "onEnter": "reset_bst",
          "on": {
            "RESET_DONE": "idle"
          }
        }
      ],
      "events": [
        "CLICK_INSERT",
        "CLICK_RESET",
        "INPUT_VALID",
        "INPUT_INVALID",
        "ALERT_DISMISSED",
        "BST_INSERTED",
        "TREE_RENDERED",
        "RESET_DONE"
      ],
      "notes": "Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity."
    }
  },
  {
    "id": "26870d10-bf4c-11f0-9b6e-0d26b6a70282",
    "timestamp": "2025-11-11T22:21:23.685Z",
    "model": "deepseek-r1",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "# Interactive Binary Search Tree Explorer\n\nI'll create a comprehensive, interactive module that teaches Binary Search Trees (BST) with visualizations, animations, and hands-on interaction.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interactive Binary Search Tree Explorer</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n        }\n        \n        body {\n            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);\n            color: #f0f0f0;\n            min-height: 100vh;\n            padding: 24px;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n        \n        .container {\n            max-width: 1200px;\n            width: 100%;\n            background: rgba(13, 17, 41, 0.9);\n            border-radius: 16px;\n            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);\n            overflow: hidden;\n            padding: 24px;\n            margin-bottom: 24px;\n        }\n        \n        header {\n            text-align: center;\n            margin-bottom: 32px;\n            padding-bottom: 24px;\n            border-bottom: 2px solid rgba(64, 224, 208, 0.5);\n        }\n        \n        h1 {\n            font-size: 2.8rem;\n            margin-bottom: 16px;\n            background: linear-gradient(to right, #40e0d0, #ff8c00, #ff0080);\n            -webkit-background-clip: text;\n            -webkit-text-fill-color: transparent;\n            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n        }\n        \n        .subtitle {\n            font-size: 1.2rem;\n            opacity: 0.9;\n            max-width: 800px;\n            margin: 0 auto;\n            line-height: 1.6;\n        }\n        \n        .panel {\n            display: flex;\n            flex-direction: column;\n            gap: 32px;\n            margin-bottom: 32px;\n        }\n        \n        .card {\n            background: rgba(25, 30, 60, 0.8);\n            border-radius: 12px;\n            padding: 24px;\n            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);\n            border: 1px solid rgba(64, 224, 208, 0.3);\n        }\n        \n        h2 {\n            font-size: 1.8rem;\n            margin-bottom: 16px;\n            color: #40e0d0;\n            display: flex;\n            align-items: center;\n            gap: 12px;\n        }\n        \n        h2 i {\n            font-size: 1.5rem;\n        }\n        \n        .info-grid {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n            gap: 24px;\n        }\n        \n        .info-box {\n            padding: 20px;\n            background: rgba(40, 45, 80, 0.6);\n            border-radius: 10px;\n            border-left: 4px solid #40e0d0;\n        }\n        \n        h3 {\n            font-size: 1.3rem;\n            color: #ff8c00;\n            margin-bottom: 12px;\n        }\n        \n        p {\n            line-height: 1.7;\n            margin-bottom: 16px;\n            color: #e0e0ff;\n        }\n        \n        .properties {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n            gap: 16px;\n            margin-top: 16px;\n        }\n        \n        .property {\n            background: rgba(30, 35, 70, 0.7);\n            padding: 16px;\n            border-radius: 8px;\n            border: 1px solid rgba(64, 224, 208, 0.2);\n        }\n        \n        .property h4 {\n            color: #ff8c00;\n            margin-bottom: 10px;\n            font-size: 1.1rem;\n        }\n        \n        .controls {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 16px;\n            margin-top: 16px;\n        }\n        \n        input {\n            padding: 14px 20px;\n            font-size: 1.1rem;\n            border-radius: 50px;\n            border: 2px solid #40e0d0;\n            background: rgba(10, 15, 30, 0.8);\n            color: white;\n            min-width: 200px;\n            outline: none;\n            transition: all 0.3s ease;\n        }\n        \n        input:focus {\n            border-color: #ff8c00;\n            box-shadow: 0 0 15px rgba(255, 140, 0, 0.5);\n        }\n        \n        button {\n            padding: 14px 28px;\n            font-size: 1.1rem;\n            border-radius: 50px;\n            border: none;\n            cursor: pointer;\n            transition: all 0.3s ease;\n            font-weight: 600;\n            display: flex;\n            align-items: center;\n            gap: 8px;\n        }\n        \n        .primary-btn {\n            background: linear-gradient(135deg, #40e0d0, #20b2aa);\n            color: #0a1a2a;\n        }\n        \n        .primary-btn:hover {\n            background: linear-gradient(135deg, #30c0b0, #109a92);\n            transform: translateY(-2px);\n            box-shadow: 0 6px 18px rgba(64, 224, 208, 0.4);\n        }\n        \n        .secondary-btn {\n            background: linear-gradient(135deg, #ff8c00, #ff6b6b);\n            color: #0a1a2a;\n        }\n        \n        .secondary-btn:hover {\n            background: linear-gradient(135deg, #e67c00, #e55b5b);\n            transform: translateY(-2px);\n            box-shadow: 0 6px 18px rgba(255, 140, 0, 0.4);\n        }\n        \n        .tree-container {\n            display: flex;\n            justify-content: center;\n            min-height: 500px;\n            padding: 40px;\n            background: rgba(10, 15, 30, 0.6);\n            border-radius: 16px;\n            margin-top: 16px;\n            position: relative;\n            overflow: hidden;\n        }\n        \n        .tree-canvas {\n            width: 100%;\n            height: 100%;\n            position: relative;\n        }\n        \n        .node {\n            position: absolute;\n            width: 50px;\n            height: 50px;\n            border-radius: 50%;\n            background: linear-gradient(135deg, #40e0d0, #20b2aa);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-weight: bold;\n            color: #0a1a2a;\n            font-size: 1.1rem;\n            box-shadow: 0 4px 15px rgba(64, 224, 208, 0.4);\n            z-index: 2;\n            transition: all 0.5s ease;\n        }\n        \n        .node.root {\n            background: linear-gradient(135deg, #ff8c00, #ff6b6b);\n            width: 60px;\n            height: 60px;\n            font-size: 1.3rem;\n        }\n        \n        .node.highlight {\n            transform: scale(1.2);\n            box-shadow: 0 0 0 5px rgba(255, 215, 0, 0.7);\n            z-index: 3;\n        }\n        \n        .edge {\n            position: absolute;\n            height: 2px;\n            background: rgba(255, 255, 255, 0.6);\n            transform-origin: 0 0;\n            z-index: 1;\n        }\n        \n        .operation-info {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            background: rgba(25, 30, 60, 0.9);\n            padding: 15px 25px;\n            border-radius: 10px;\n            border-left: 4px solid #ff8c00;\n            font-size: 1.1rem;\n            color: #40e0d0;\n            max-width: 300px;\n            display: none;\n        }\n        \n        .legend {\n            display: flex;\n            gap: 20px;\n            justify-content: center;\n            margin-top: 20px;\n            flex-wrap: wrap;\n        }\n        \n        .legend-item {\n            display: flex;\n            align-items: center;\n            gap: 8px;\n        }\n        \n        .legend-color {\n            width: 20px;\n            height: 20px;\n            border-radius: 50%;\n        }\n        \n        .legend-root {\n            background: linear-gradient(135deg, #ff8c00, #ff6b6b);\n        }\n        \n        .legend-node {\n            background: linear-gradient(135deg, #40e0d0, #20b2aa);\n        }\n        \n        footer {\n            text-align: center;\n            padding: 24px;\n            font-size: 1rem;\n            color: #a0a0c0;\n            margin-top: auto;\n        }\n        \n        @media (max-width: 768px) {\n            .panel {\n                gap: 24px;\n            }\n            \n            .info-grid {\n                grid-template-columns: 1fr;\n            }\n            \n            .controls {\n                flex-direction: column;\n            }\n            \n            input, button {\n                width: 100%;\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>Interactive Binary Search Tree Explorer</h1>\n            <p class=\"subtitle\">Understand the structure and operations of Binary Search Trees through interactive visualization. Insert, search, and traverse nodes to see how BSTs maintain their efficient properties.</p>\n        </header>\n        \n        <div class=\"panel\">\n            <div class=\"card\">\n                <h2><span>üìö</span> Binary Search Tree Concepts</h2>\n                <div class=\"info-grid\">\n                    <div class=\"info-box\">\n                        <h3>What is a BST?</h3>\n                        <p>A Binary Search Tree (BST) is a hierarchical data structure where each node has at most two children. It maintains a sorted order, enabling efficient search, insertion, and deletion operations.</p>\n                        <p>In a BST, for every node:</p>\n                        <ul>\n                            <li>All nodes in the left subtree have values less than the node's value</li>\n                            <li>All nodes in the right subtree have values greater than the node's value</li>\n                        </ul>\n                    </div>\n                    \n                    <div class=\"info-box\">\n                        <h3>Why Use BSTs?</h3>\n                        <p>BSTs provide an efficient way to store data that needs frequent searching. Their structure allows for operations with time complexity of O(h), where h is the tree height.</p>\n                        <div class=\"properties\">\n                            <div class=\"property\">\n                                <h4>Search Efficiency</h4>\n                                <p>O(log n) on average for balanced trees</p>\n                            </div>\n                            <div class=\"property\">\n                                <h4>Insertion/Deletion</h4>\n                                <p>O(log n) average, O(n) worst-case</p>\n                            </div>\n                            <div class=\"property\">\n                                <h4>Sorted Traversal</h4>\n                                <p>In-order traversal gives sorted sequence</p>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"card\">\n                <h2><span>üéÆ</span> Interactive BST Explorer</h2>\n                <p>Use the controls below to interact with the BST. Insert nodes, search for values, and watch the tree dynamically update with animations.</p>\n                \n                <div class=\"controls\">\n                    <input type=\"number\" id=\"nodeValue\" placeholder=\"Enter a number (1-99)\" min=\"1\" max=\"99\">\n                    <button class=\"primary-btn\" id=\"insertBtn\">Insert Node</button>\n                    <button class=\"secondary-btn\" id=\"searchBtn\">Search Node</button>\n                    <button class=\"secondary-btn\" id=\"resetBtn\">Reset Tree</button>\n                </div>\n                \n                <div class=\"tree-container\">\n                    <div class=\"operation-info\" id=\"operationInfo\"></div>\n                    <div class=\"tree-canvas\" id=\"treeCanvas\"></div>\n                </div>\n                \n                <div class=\"legend\">\n                    <div class=\"legend-item\">\n                        <div class=\"legend-color legend-root\"></div>\n                        <span>Root Node</span>\n                    </div>\n                    <div class=\"legend-item\">\n                        <div class=\"legend-color legend-node\"></div>\n                        <span>Tree Node</span>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"card\">\n                <h2><span>üîç</span> BST Operations Explained</h2>\n                <div class=\"info-grid\">\n                    <div class=\"info-box\">\n                        <h3>Insertion Process</h3>\n                        <p>To insert a new value:</p>\n                        <ol>\n                            <li>Start at the root node</li>\n                            <li>Compare value with current node</li>\n                            <li>If smaller, go left; if larger, go right</li>\n                            <li>Repeat until you find an empty spot</li>\n                            <li>Insert new node at that position</li>\n                        </ol>\n                        <p>The tree automatically maintains its BST properties during insertion.</p>\n                    </div>\n                    \n                    <div class=\"info-box\">\n                        <h3>Search Operation</h3>\n                        <p>Searching in a BST:</p>\n                        <ol>\n                            <li>Start at the root node</li>\n                            <li>Compare search value with current node</li>\n                            <li>If equal, node is found!</li>\n                            <li>If smaller, search left subtree</li>\n                            <li>If larger, search right subtree</li>\n                            <li>If no node found, value doesn't exist</li>\n                        </ol>\n                        <p>This process is similar to binary search on sorted arrays.</p>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <footer>\n        <p>Interactive Binary Search Tree Explorer | Created with HTML, CSS, and JavaScript</p>\n    </footer>\n\n    <script>\n        class TreeNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n                this.x = 0;\n                this.y = 0;\n                this.parent = null;\n                this.level = 0;\n            }\n        }\n\n        class BinarySearchTree {\n            constructor() {\n                this.root = null;\n                this.nodePositions = new Map();\n                this.canvas = document.getElementById('treeCanvas');\n                this.operationInfo = document.getElementById('operationInfo');\n            }\n\n            insert(value) {\n                this.operationInfo.textContent = `Inserting ${value}...`;\n                this.operationInfo.style.display = 'block';\n                \n                const newNode = new TreeNode(value);\n                if (this.root === null) {\n                    this.root = newNode;\n                    this.root.x = this.canvas.offsetWidth / 2;\n                    this.root.y = 80;\n                    this.root.level = 1;\n                    this.nodePositions.set(this.root, {x: this.root.x, y: this.root.y});\n                    this.visualizeInsertion(newNode, null);\n                    return;\n                }\n\n                let currentNode = this.root;\n                while (currentNode) {\n                    if (value < currentNode.value) {\n                        if (!currentNode.left) {\n                            currentNode.left = newNode;\n                            newNode.parent = currentNode;\n                            newNode.level = currentNode.level + 1;\n                            this.calculatePosition(newNode, 'left');\n                            this.visualizeInsertion(newNode, currentNode);\n                            return;\n                        }\n                        currentNode = currentNode.left;\n                    } else if (value > currentNode.value) {\n                        if (!currentNode.right) {\n                            currentNode.right = newNode;\n                            newNode.parent = currentNode;\n                            newNode.level = currentNode.level + 1;\n                            this.calculatePosition(newNode, 'right');\n                            this.visualizeInsertion(newNode, currentNode);\n                            return;\n                        }\n                        currentNode = currentNode.right;\n                    } else {\n                        this.operationInfo.textContent = `Value ${value} already exists in the tree!`;\n                        return;\n                    }\n                }\n            }\n\n            calculatePosition(node, direction) {\n                if (!node.parent) return;\n                \n                // Calculate position based on parent and level\n                const verticalSpacing = 100;\n                const horizontalSpacing = 250 / Math.pow(1.8, node.level);\n                \n                node.y = node.parent.y + verticalSpacing;\n                \n                if (direction === 'left') {\n                    node.x = node.parent.x - horizontalSpacing;\n                } else {\n                    node.x = node.parent.x + horizontalSpacing;\n                }\n                \n                this.nodePositions.set(node, {x: node.x, y: node.y});\n            }\n\n            visualizeInsertion(node, parent) {\n                this.renderTree();\n                \n                // Highlight the path\n                let current = node;\n                let path = [];\n                while (current && current !== this.root) {\n                    path.unshift(current);\n                    current = current.parent;\n                }\n                if (this.root) path.unshift(this.root);\n                \n                // Animate the path\n                this.highlightPath(path, node);\n            }\n\n            search(value) {\n                this.operationInfo.textContent = `Searching for ${value}...`;\n                this.operationInfo.style.display = 'block';\n                \n                let currentNode = this.root;\n                const path = [];\n                \n                while (currentNode) {\n                    path.push(currentNode);\n                    \n                    if (value === currentNode.value) {\n                        this.highlightPath(path, currentNode, true);\n                        return true;\n                    } else"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Binary Search Tree (BST).\n\n**Project Overview:**\nTopic: Binary Search Tree (BST)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization ‚Äî placement of text, controls, and visuals ‚Äî including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** ‚Äî using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation."
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Binary Search Tree Explorer",
      "description": "Manages states for interactive BST operations including insertion, search, and reset.",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "INSERT_CLICKED": "inserting",
            "SEARCH_CLICKED": "searching",
            "RESET_CLICKED": "resetting"
          }
        },
        {
          "name": "inserting",
          "onEnter": "showInsertingInfo",
          "onExit": "noop",
          "on": {
            "ANIMATION_COMPLETE": "idle"
          }
        },
        {
          "name": "searching",
          "onEnter": "showSearchingInfo",
          "onExit": "noop",
          "on": {
            "ANIMATION_COMPLETE": "idle"
          }
        },
        {
          "name": "resetting",
          "onEnter": "resetTree",
          "onExit": "noop",
          "on": {
            "RESET_COMPLETE": "idle"
          }
        }
      ],
      "events": [
        "INSERT_CLICKED",
        "SEARCH_CLICKED",
        "RESET_CLICKED",
        "ANIMATION_COMPLETE",
        "RESET_COMPLETE"
      ],
      "notes": "Assumes ANIMATION_COMPLETE is triggered after path highlighting finishes. RESET_COMPLETE is triggered immediately after tree reset. During insertion/searching, other events are ignored."
    }
  },

  {
    "id": "5d7c31e0-bf4e-11f0-9d64-ab1079f525e7",
    "timestamp": "2025-11-11T22:34:17.002Z",
    "model": "gpt-5-mini",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Interactive BST Explorer</title>\n  <style>\n    :root{\n      --safe-margin:24px;\n      --gap:16px;\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#3b82f6;\n      --muted:#94a3b8;\n      --success:#16a34a;\n      --danger:#ef4444;\n      --node:#1e293b;\n      --node-text:#e6eef8;\n    }\n    *{box-sizing:border-box}\n    html,body{height:100%}\n    body{\n      margin:0;\n      padding:var(--safe-margin);\n      background:linear-gradient(180deg,#071025 0%, #07182a 100%);\n      color:var(--node-text);\n      font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n      line-height:1.35;\n    }\n    /* Layout */\n    .wrap{\n      display:grid;\n      grid-template-columns: 360px 1fr;\n      gap:var(--gap);\n      align-items:start;\n      min-height: calc(100vh - (2 * var(--safe-margin)));\n    }\n    @media (max-width:920px){\n      .wrap{grid-template-columns:1fr; padding-bottom:40px}\n    }\n    .panel{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.03);\n      padding:20px;\n      border-radius:12px;\n      box-shadow: 0 6px 24px rgba(2,6,23,0.6);\n    }\n\n    /* Left column */\n    .meta{\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:0.2px;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n    }\n    .section{\n      background:rgba(255,255,255,0.01);\n      border-radius:10px;\n      padding:12px;\n      font-size:14px;\n    }\n    .controls{\n      display:flex;\n      gap:var(--gap);\n      flex-wrap:wrap;\n      margin-top:8px;\n    }\n    input[type=\"number\"]{\n      -moz-appearance: textfield;\n    }\n    .row{\n      display:flex;\n      gap:var(--gap);\n      align-items:center;\n      margin-top:8px;\n    }\n    input[type=\"text\"], input[type=\"number\"]{\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.04);\n      background:rgba(255,255,255,0.02);\n      color:var(--node-text);\n      min-width:120px;\n      outline:none;\n    }\n    button{\n      padding:9px 12px;\n      border-radius:8px;\n      border: none;\n      background:var(--accent);\n      color:white;\n      cursor:pointer;\n      font-weight:600;\n      transition:transform .12s ease, box-shadow .12s ease;\n      min-width:72px;\n    }\n    button:active{transform:translateY(1px)}\n    button.secondary{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.04);\n      color:var(--node-text);\n    }\n    button.warn{ background:var(--danger) }\n    button.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.02); color:var(--muted) }\n    .small{\n      padding:7px 10px;\n      font-size:13px;\n    }\n    .toggle{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      font-size:13px;\n      color:var(--muted);\n    }\n\n    /* Right column: visualization */\n    .vis{\n      position:relative;\n      min-height:520px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    .canvas-wrap{\n      background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.006));\n      border-radius:12px;\n      padding:16px;\n      position:relative;\n      height:520px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      overflow:hidden;\n    }\n    .svg-area{\n      flex:1;\n      width:100%;\n      border-radius:8px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.008), transparent);\n      display:flex;\n      align-items:flex-start;\n      justify-content:center;\n      overflow:auto;\n    }\n    svg{ width:100%; height:100%; overflow:visible; }\n\n    /* Node styles */\n    .node-group{ cursor:pointer; transition:transform 400ms cubic-bezier(.22,.9,.36,1), opacity 300ms ease; }\n    .node-circle{\n      fill:var(--node);\n      stroke:rgba(255,255,255,0.03);\n      stroke-width:1;\n      filter: drop-shadow(0 6px 24px rgba(2,6,23,0.6));\n    }\n    .node-text{\n      font-size:12px;\n      fill:var(--node-text);\n      text-anchor:middle;\n      dominant-baseline:middle;\n      font-weight:700;\n      pointer-events:none;\n    }\n    /* highlights */\n    .visited .node-circle{ stroke: var(--accent); stroke-width:2.6; animation: pulse 1s infinite alternate; }\n    @keyframes pulse{\n      from{ box-shadow:0 0 0px rgba(59,130,246,0.0) }\n      to{ box-shadow:0 0 14px rgba(59,130,246,0.12) }\n    }\n    .found .node-circle{ fill:var(--success) }\n    .removing{ opacity:0.12; transform:scale(.8) }\n\n    /* links */\n    .link{\n      stroke:rgba(255,255,255,0.06);\n      stroke-width:2;\n      stroke-linecap:round;\n      transition:stroke 240ms ease, opacity 240ms ease;\n    }\n    .link.visited{ stroke:var(--accent); stroke-width:3.4; opacity:1; }\n\n    /* logs */\n    .log{\n      background:rgba(0,0,0,0.12);\n      padding:10px;\n      border-radius:8px;\n      font-family:monospace;\n      font-size:13px;\n      color:var(--muted);\n      height:86px;\n      overflow:auto;\n    }\n\n    /* layout description area */\n    .desc{\n      font-size:13px;\n      color:var(--muted);\n      background:rgba(255,255,255,0.01);\n      padding:10px;\n      border-radius:8px;\n    }\n\n    /* accessibility focus */\n    button:focus, input:focus{ outline: 3px solid rgba(59,130,246,0.15) }\n\n    /* spacing enforcement */\n    .controls > * { margin-bottom: var(--gap); }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\" role=\"main\">\n    <aside class=\"panel\" aria-labelledby=\"title\">\n      <div class=\"meta\">\n        <div>\n          <h1 id=\"title\">Binary Search Tree (BST) ‚Äî Interactive Explorer</h1>\n          <div class=\"muted\">One focused concept: dynamic insertion, search, and deletion in a BST with visualized traversal and animations.</div>\n        </div>\n\n        <div class=\"section\" aria-labelledby=\"objective-title\">\n          <strong id=\"objective-title\">Learning objective</strong>\n          <p class=\"muted\" style=\"margin:8px 0 0;\">\n            After interacting you'll be able to visualize how values are inserted, located, and removed in a BST;\n            observe the exact nodes visited (path), understand parent-child reassignment during delete, and feel the\n            cost (number of comparisons) through animated highlights and step-by-step controls.\n          </p>\n        </div>\n\n        <div class=\"section\" aria-labelledby=\"interaction-title\">\n          <strong id=\"interaction-title\">Interaction design (how to use)</strong>\n          <div class=\"desc\" style=\"margin-top:8px;\">\n            - Type a number and press Insert to add. The algorithm highlights each visited node, animating the path.\n            <br>- Use Step Mode to advance one comparison at a time (Next / Prev).\n            <br>- Click Search to highlight the path; found node turns green.\n            <br>- Delete removes a value; animations show node replacement (in-order successor) when needed.\n            <br>- Click nodes directly in the visualization to remove them (confirmation).\n            <br>- Use Randomize to add several nodes quickly and Clear to reset.\n          </div>\n        </div>\n\n        <div class=\"section\" aria-labelledby=\"layout-title\">\n          <strong id=\"layout-title\">Layout description</strong>\n          <div class=\"desc\" style=\"margin-top:8px;\">\n            - Safe margins: 24px around viewport. Controls spaced with at least 16px.\n            <br>- Left column: concise controls, objectives, and instructions.\n            <br>- Right column: large SVG visualization (center) with controls below and a console log.\n            <br>- Responsive: columns collapse to single column on narrow screens, SVG scales fluidly.\n          </div>\n        </div>\n\n        <div class=\"section\" aria-labelledby=\"controls-title\">\n          <strong id=\"controls-title\">Controls</strong>\n\n          <div class=\"row\" style=\"margin-top:10px;\">\n            <label for=\"valueInput\" class=\"muted\" style=\"width:80px\">Value</label>\n            <input id=\"valueInput\" type=\"number\" inputmode=\"numeric\" aria-label=\"Value to insert or delete\" placeholder=\"e.g. 42\" />\n            <button id=\"insertBtn\">Insert</button>\n            <button id=\"searchBtn\" class=\"secondary\">Search</button>\n          </div>\n\n          <div class=\"row\">\n            <button id=\"deleteBtn\" class=\"warn\">Delete</button>\n            <button id=\"clearBtn\" class=\"ghost small\">Clear</button>\n            <button id=\"randomBtn\" class=\"secondary small\">Randomize</button>\n          </div>\n\n          <div class=\"row\" style=\"justify-content:space-between; margin-top:12px;\">\n            <div class=\"toggle\">\n              <input id=\"stepToggle\" type=\"checkbox\" aria-label=\"Enable step mode\" />\n              <label for=\"stepToggle\" class=\"muted\">Step Mode</label>\n            </div>\n            <div style=\"display:flex; gap:10px;\">\n              <button id=\"prevStep\" class=\"secondary small\" title=\"Previous step\">Prev</button>\n              <button id=\"nextStep\" class=\"secondary small\" title=\"Next step\">Next</button>\n            </div>\n          </div>\n\n          <div style=\"margin-top:12px;\">\n            <div class=\"muted\" style=\"margin-bottom:6px\">Current tree (in-order):</div>\n            <div id=\"inorder\" class=\"desc\" aria-live=\"polite\">‚Äî empty ‚Äî</div>\n          </div>\n\n        </div>\n\n      </div>\n    </aside>\n\n    <main class=\"panel vis\" aria-label=\"Visualization panel\">\n      <div class=\"canvas-wrap\" role=\"region\" aria-label=\"Binary Search Tree visualization\">\n        <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n          <div style=\"display:flex; gap:12px; align-items:center;\">\n            <strong style=\"font-size:15px\">BST Visualizer</strong>\n            <div class=\"muted\" style=\"font-size:13px\">Click nodes to remove. Hover to see value.</div>\n          </div>\n          <div style=\"display:flex; gap:8px; align-items:center;\">\n            <div class=\"muted\" style=\"font-size:13px\">Comparisons:</div>\n            <div id=\"compCount\" class=\"desc\" style=\"min-width:36px; text-align:center;\">0</div>\n          </div>\n        </div>\n\n        <div class=\"svg-area\" id=\"svgArea\" tabindex=\"0\">\n          <svg id=\"svg\" viewBox=\"0 0 1200 520\" preserveAspectRatio=\"xMidYMin meet\" aria-hidden=\"false\"></svg>\n        </div>\n\n        <div style=\"display:flex; gap:12px; align-items:flex-start;\">\n          <div style=\"flex:1\">\n            <div class=\"muted\" style=\"margin-bottom:6px\">Action log</div>\n            <div id=\"log\" class=\"log\" aria-live=\"polite\"></div>\n          </div>\n          <div style=\"width:220px\">\n            <div class=\"muted\" style=\"margin-bottom:6px\">Legend</div>\n            <div class=\"desc\" style=\"display:flex;flex-direction:column; gap:8px\">\n              <div style=\"display:flex; gap:8px; align-items:center;\">\n                <svg width=\"18\" height=\"18\"><circle cx=\"9\" cy=\"9\" r=\"7\" fill=\"#1e293b\" stroke=\"rgba(255,255,255,0.03)\"/></svg>\n                <span class=\"muted\">Node</span>\n              </div>\n              <div style=\"display:flex; gap:8px; align-items:center;\">\n                <svg width=\"18\" height=\"18\"><rect width=\"18\" height=\"4\" rx=\"2\" fill=\"rgba(255,255,255,0.06)\"/></svg>\n                <span class=\"muted\">Edge</span>\n              </div>\n              <div style=\"display:flex; gap:8px; align-items:center;\">\n                <svg width=\"18\" height=\"18\"><circle cx=\"9\" cy=\"9\" r=\"7\" fill=\"#16a34a\"/></svg>\n                <span class=\"muted\">Found</span>\n              </div>\n              <div style=\"display:flex; gap:8px; align-items:center;\">\n                <svg width=\"18\" height=\"18\"><circle cx=\"9\" cy=\"9\" r=\"7\" fill=\"#3b82f6\"/></svg>\n                <span class=\"muted\">Visited</span>\n              </div>\n            </div>\n          </div>\n        </div>\n\n      </div>\n    </main>\n  </div>\n\n  <script>\n    // BST Data structure + Visualization\n    (function(){\n      // DOM elements\n      const svg = document.getElementById('svg');\n      const insertBtn = document.getElementById('insertBtn');\n      const searchBtn = document.getElementById('searchBtn');\n      const deleteBtn = document.getElementById('deleteBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const randomBtn = document.getElementById('randomBtn');\n      const valueInput = document.getElementById('valueInput');\n      const inorderEl = document.getElementById('inorder');\n      const logEl = document.getElementById('log');\n      const compCountEl = document.getElementById('compCount');\n      const stepToggle = document.getElementById('stepToggle');\n      const nextStep = document.getElementById('nextStep');\n      const prevStep = document.getElementById('prevStep');\n\n      // Visualization params\n      const viewW = 1200, viewH = 520;\n      const levelGap = 92;\n      const nodeRadius = 22;\n      const transitionMs = 400;\n\n      // State\n      let root = null;\n      let nodeIdCounter = 1;\n      let comparisons = 0;\n      let currentPath = []; // nodes visited in current operation\n      let stepIndex = -1;\n      let isStepping = false;\n      let pendingAnim = null;\n      const nodesMap = new Map(); // id => node obj\n\n      // Utility log\n      function log(...args){\n        const t = new Date().toLocaleTimeString();\n        logEl.innerText = `${t} - ${args.join(' ')}\\n` + logEl.innerText;\n      }\n\n      // Node representation\n      function createNode(val){\n        const n = { id: nodeIdCounter++, val: Number(val), left: null, right: null, x:0, y:0 };\n        nodesMap.set(n.id, n);\n        return n;\n      }\n\n      // BST operations with path tracking\n      function bstInsert(val){\n        if (root === null) { root = createNode(val); return { inserted: root, path:[root] }; }\n        let cur = root;\n        const path = [];\n        while(cur){\n          path.push(cur);\n          if (val === cur.val) { return { inserted:null, path, duplicate:true }; }\n          if (val < cur.val){\n            if (!cur.left){ cur.left = createNode(val); path.push(cur.left); return { inserted:cur.left, path }; }\n            cur = cur.left;\n          } else {\n            if (!cur.right){ cur.right = createNode(val); path.push(cur.right); return { inserted:cur.right, path }; }\n            cur = cur.right;\n          }\n        }\n        return { inserted:null, path };\n      }\n\n      function bstSearch(val){\n        let cur = root;\n        const path = [];\n        while(cur){\n          path.push(cur);\n          if (val === cur.val) return { found:cur, path };\n          if (val < cur.val) cur = cur.left; else cur = cur.right;\n        }\n        return { found:null, path };\n      }\n\n      function bstDelete(val){\n        let parent = null;\n        let cur = root;\n        const path = [];\n        while(cur && cur.val !== val){\n          path.push(cur);\n          parent = cur;\n          if (val < cur.val) cur = cur.left; else cur = cur.right;\n        }\n        if (!cur) return { deleted:null, path };\n        path.push(cur);\n        // Node with two children\n        if (cur.left && cur.right){\n          // find in-order successor\n          let succParent = cur;\n          let succ = cur.right;\n          while(succ.left){\n            succParent = succ;\n            succ = succ.left;\n          }\n          // swap values\n          const oldVal = cur.val;\n          cur.val = succ.val;\n          succ.val = oldVal;\n          // now delete successor (which has at most right child)\n          // adjust references to delete succ\n          if (succParent.left === succ) succParent.left = succ.right;\n          else succParent.right = succ.right;\n          path.push(succ); // include the replaced node in path\n          nodesMap.delete(succ.id);\n          return { deleted:cur, replaced:succ, path, swapped:true };\n        } else {\n          // node has 0 or 1 child\n          const child = cur.left ? cur.left : cur.right;\n          if (!parent){\n            // deleting root\n            root = child;\n          } else {\n            if (parent.left === cur) parent.left = child; else parent.right = child;\n          }\n          nodesMap.delete(cur.id);\n          return { deleted:cur, replaced:child, path, swapped:false };\n        }\n      }\n\n      // Layout computation: compute inorder positions for x, y by depth\n      function layoutTree(){\n        const positions = {};\n        let index = 0;\n        function inorder(n, depth){\n          if (!n) return;\n          inorder(n.left, depth+1);\n          const x = (index + 1) * (viewW / (Math.max(1, totalCount())));\n          const y = 30 + depth * levelGap;\n          positions[n.id] = { x, y, depth };\n          index++;\n          inorder(n.right, depth+1);\n        }\n        inorder(root, 0);\n        return positions;\n      }\n\n      function totalCount(){\n        let c = 0;\n        (function traverse(n){ if(!n) return; c++; traverse(n.left); traverse(n.right); })(root);\n        return Math.max(1, c);\n      }\n\n      // Render tree to SVG\n      function renderTree(highlights = { visited:[], found:null, removing:null }, animate=true){\n        // compute positions\n        const positions = layoutTree();\n\n        // Build a flat array of nodes\n        const nodeArr = [];\n        (function collect(n){\n          if(!n) return;\n          nodeArr.push(n);\n          collect(n.left); collect(n.right);\n        })(root);\n\n        // Clear svg\n        while(svg.firstChild) svg.removeChild(svg.firstChild);\n\n        // Draw links first\n        nodeArr.forEach(n=>{\n          if (n.left){\n            const p = positions[n.id];\n            const c = positions[n.left.id];\n            if (p && c){\n              const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n              line.setAttribute('x1', p.x);\n              line.setAttribute('y1', p.y + nodeRadius);\n              line.setAttribute('x2', c.x);\n              line.setAttribute('y2', c.y - nodeRadius);\n              line.setAttribute('class','link');\n              if (highlights.visited.some(v=>v && v.id === n.id && v.next && v.next.id === n.left.id)) {\n                line.classList.add('visited');\n              }\n              svg.appendChild(line);\n            }\n          }\n          if (n.right){\n            const p = positions[n.id];\n            const c = positions[n.right.id];\n            if (p && c){\n              const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n              line.setAttribute('x1', p.x);\n              line.setAttribute('y1', p.y + nodeRadius);\n              line.setAttribute('x2', c.x);\n              line.setAttribute('y2', c.y - nodeRadius);\n              line.setAttribute('class','link');\n              if (highlights.visited.some(v=>v && v.id === n.id && v.next && v.next.id === n.right.id)) {\n                line.classList.add('visited');\n              }\n              svg.appendChild(line);\n            }\n          }\n        });\n\n        // Draw nodes\n        nodeArr.forEach(n=>{\n          const pos = positions[n.id] || {x: viewW/2, y:30};\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('class','node-group');\n          g.setAttribute('data-id', n.id);\n          g.setAttribute('transform', `translate(${pos.x},${pos.y})`);\n          g.setAttribute('tabindex','0');\n          g.setAttribute('role','button');\n          g.setAttribute('aria-label', `Node ${n.val}`);\n          // circle\n          const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          circ.setAttribute('r', nodeRadius);\n          circ.setAttribute('class','node-circle');\n          g.appendChild(circ);\n          // text\n          const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n          txt.setAttribute('class','node-text');\n          txt.textContent = n.val;\n          g.appendChild(txt);\n\n          // highlight classes\n          if (highlights.visited.some(v=>v && v.id === n.id)) g.classList.add('visited');\n          if (highlights.found && highlights.found.id === n.id) g.classList.add('found');\n          if (highlights.removing && highlights.removing.id === n.id) g.classList.add('removing');\n\n          // click to delete\n          g.addEventListener('click', (evt)=>{\n            evt.stopPropagation();\n            if (confirm(`Delete node ${n.val}?`)){\n              performDelete(n.val);\n            }\n          });\n          // keyboard delete on Enter or Space\n          g.addEventListener('keydown', (evt)=>{\n            if (evt.key === 'Enter' || evt.key === ' ') {\n              evt.preventDefault();\n              if (confirm(`Delete node ${n.val}?`)){\n                performDelete(n.val);\n              }\n            }\n          });\n\n          svg.appendChild(g);\n        });\n\n        // update inorder text\n        const inorderVals = [];\n        (function inorder(n){\n          if(!n) return;\n          inorder(n.left); inorderVals.push(n.val); inorder(n.right);\n        })(root);\n        inorderEl.textContent = inorderVals.length ? inorderVals.join(', ') : '‚Äî empty ‚Äî';\n      }\n\n      // Animated insertion: highlight path nodes sequentially then place node\n      function animatePath(path, targetNode=null, cb){\n        comparisons = 0;\n        compCountEl.textContent = 0;\n        if (!isStepping){\n          // play automatically\n          let i = 0;\n          function step(){\n            if (i < path.length){\n              comparisons++;\n              compCountEl.textContent = comparisons;\n              renderTree({ visited: path.slice(0, i+1).map((n,idx)=>{\n                const obj = { id: n.id, next: path[idx+1] || null };\n                return obj;\n              }) });\n              i++;\n              pendingAnim = setTimeout(step, 520);\n            } else {\n              // final render: show found/inserted node\n              if (targetNode) {\n                renderTree({ visited: path.map((n,idx)=>({id:n.id, next:path[idx+1]||null})), found: targetNode });\n              } else {\n                renderTree({ visited: path.map((n,idx)=>({id:n.id, next:path[idx+1]||null})) });\n              }\n              pendingAnim = null;\n              if (cb) cb();\n            }\n          }\n          step();\n        } else {\n          // Step mode: initialize stepIndex and store currentPath\n          currentPath = path.slice();\n          stepIndex = -1;\n          renderTree({ visited: [], found: null });\n          if (cb) cb();\n        }\n      }\n\n      function stepNext(){\n        if (!isStepping || currentPath.length === 0) return;\n        if (stepIndex < currentPath.length - 1) stepIndex++;\n        comparisons = stepIndex + 1;\n        compCountEl.textContent = comparisons;\n        const visited = currentPath.slice(0, stepIndex+1).map((n, idx)=>({ id:n.id, next: currentPath[idx+1] || null }));\n        renderTree({ visited });\n      }\n      function stepPrev(){\n        if (!isStepping || currentPath.length === 0) return;\n        if (stepIndex > -1) stepIndex--;\n        comparisons = Math.max(0, stepIndex + 1);\n        compCountEl.textContent = comparisons;\n        const visited = currentPath.slice(0, stepIndex+1).map((n, idx)=>({ id:n.id, next: currentPath[idx+1] || null }));\n        renderTree({ visited });\n      }\n\n      // Public operations triggered by UI\n\n      function performInsert(){\n        const v = Number(valueInput.value);\n        if (!Number.isFinite(v)){ alert('Please enter a valid number.'); return; }\n        const result = bstInsert(v);\n        if (result.duplicate){\n          log(`Insert ${v} skipped (duplicate).`);\n          renderTree({ visited: result.path.map((n,idx)=>({id:n.id, next: result.path[idx+1] || null})) });\n          return;\n        }\n        log(`Insert ${v} ‚Äî visiting ${result.path.length} node(s).`);\n        animatePath(result.path, result.inserted, ()=>{\n          // finalize: re-render to place nodes in their computed positions\n          setTimeout(()=> renderTree({ visited: [], found: result.inserted }), transitionMs+40);\n        });\n      }\n\n      function performSearch(){\n        const v = Number(valueInput.value);\n        if (!Number.isFinite(v)){ alert('Please enter a valid number.'); return; }\n        const res = bstSearch(v);\n        log(`Search ${v} ‚Äî visited ${res.path.length} node(s). ${res.found ? 'Found.' : 'Not found.'}`);\n        animatePath(res.path, res.found, ()=> {\n          setTimeout(()=> renderTree({ visited: [], found: res.found }), transitionMs+40);\n        });\n      }\n\n      function performDelete(valInput){\n        const val = arguments.length ? valInput : Number(valueInput.value);\n        if (!Number.isFinite(val)){ alert('Please enter a valid number.'); return; }\n        const res = bstDelete(val);\n        if (!res.deleted){\n          log(`Delete ${val} ‚Äî not found.`);\n          renderTree({ visited: res.path.map((n,idx)=>({id:n.id, next: res.path[idx+1] || null})) });\n          return;\n        }\n        log(`Delete ${val} ‚Äî visited ${res.path.length} node(s). ${res.swapped? 'Replaced by successor.' : 'Removed.'}`);\n        // animate path highlight then structural update\n        animatePath(res.path, res.deleted, ()=>{\n          // mark removing node briefly\n          renderTree({ visited: res.path.map((n,idx)=>({id:n.id, next: res.path[idx+1] || null})), removing: res.deleted });\n          setTimeout(()=>{ renderTree({ visited: [], found: null }); }, transitionMs + 120);\n        });\n      }\n\n      // helpers\n      function randomize(n=7){\n        const set = new Set();\n        while(set.size < n){\n          const r = Math.floor(Math.random()*99) + 1;\n          set.add(r);\n        }\n        const vals = Array.from(set);\n        let i = 0;\n        function insNext(){\n          if (i >= vals.length) return;\n          valueInput.value = vals[i++];\n          performInsert();\n          setTimeout(insNext, 300);\n        }\n        insNext();\n      }\n\n      // Event wire-up\n      insertBtn.addEventListener('click', ()=>{ if (pendingAnim) clearTimeout(pendingAnim); performInsert(); });\n      searchBtn.addEventListener('click', ()=>{ if (pendingAnim) clearTimeout(pendingAnim); performSearch(); });\n      deleteBtn.addEventListener('click', ()=>{ if (pendingAnim) clearTimeout(pendingAnim); performDelete(); });\n      clearBtn.addEventListener('click', ()=>{\n        if (!confirm('Clear entire tree?')) return;\n        root = null; nodesMap.clear(); nodeIdCounter = 1;\n        log('Cleared tree.');\n        renderTree();\n        compCountEl.textContent = '0';\n      });\n      randomBtn.addEventListener('click', ()=> randomize(6));\n\n      stepToggle.addEventListener('change', (e)=>{\n        isStepping = e.target.checked;\n        if (!isStepping){\n          // reset step mode\n          currentPath = [];\n          stepIndex = -1;\n          renderTree();\n        } else {\n          log('Step mode enabled. Use Next/Prev to advance comparisons.');\n        }\n      });\n      nextStep.addEventListener('click', ()=>{ stepNext(); });\n      prevStep.addEventListener('click', ()=>{ stepPrev(); });\n\n      // keyboard shortcuts\n      document.addEventListener('keydown', (e)=>{\n        if (e.key === 'Enter' && document.activeElement === valueInput){\n          insertBtn.click();\n        }\n        if (e.key === 'f' && (e.ctrlKey || e.metaKey)){\n          e.preventDefault();\n          searchBtn.click();\n        }\n      });\n\n      // initial render\n      renderTree();\n      log('BST Explorer ready. Insert some values to begin.');\n\n      // Accessibility: resize handling - recompute viewBox maybe not necessary, but keep responsive\n      window.addEventListener('resize', ()=> setTimeout(()=> renderTree(), 120));\n\n    })();\n  </script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "Only return HTML code! You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Binary Search Tree (BST).\n\n**Project Overview:**\nTopic: Binary Search Tree (BST)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization ‚Äî placement of text, controls, and visuals ‚Äî including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** ‚Äî using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation.\nOnly return HTML code!"
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive BST Explorer",
      "description": "Models the interactive states, user actions, animations, and step-mode behavior for a BST insertion/search/delete visualizer.",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "CLICK_INSERT": "inserting_auto",
            "CLICK_INSERT_STEP": "stepping_operation",
            "CLICK_SEARCH": "searching_auto",
            "CLICK_SEARCH_STEP": "stepping_operation",
            "CLICK_DELETE": "confirming_delete",
            "NODE_CLICK": "confirming_delete",
            "CLICK_CLEAR": "confirming_clear",
            "CLICK_RANDOMIZE": "randomizing",
            "TOGGLE_STEP_ON": "step_mode_idle",
            "KEYBOARD_ENTER": "inserting_auto",
            "KEYBOARD_SEARCH_SHORTCUT": "searching_auto"
          }
        },
        {
          "name": "inserting_auto",
          "onEnter": "startInsertAnimation",
          "onExit": "cleanupAnimation",
          "on": {
            "ANIMATION_COMPLETE": "idle",
            "CLICK_INSERT": "inserting_auto",
            "CLICK_SEARCH": "searching_auto",
            "CLICK_DELETE": "confirming_delete",
            "CLICK_CLEAR": "confirming_clear",
            "CLICK_RANDOMIZE": "randomizing",
            "TOGGLE_STEP_ON": "step_mode_idle",
            "INTERRUPT": "idle"
          }
        },
        {
          "name": "searching_auto",
          "onEnter": "startSearchAnimation",
          "onExit": "cleanupAnimation",
          "on": {
            "ANIMATION_COMPLETE": "idle",
            "CLICK_INSERT": "inserting_auto",
            "CLICK_SEARCH": "searching_auto",
            "CLICK_DELETE": "confirming_delete",
            "CLICK_CLEAR": "confirming_clear",
            "CLICK_RANDOMIZE": "randomizing",
            "TOGGLE_STEP_ON": "step_mode_idle",
            "INTERRUPT": "idle"
          }
        },
        {
          "name": "deleting_auto",
          "onEnter": "startDeleteAnimation",
          "onExit": "cleanupAnimation",
          "on": {
            "ANIMATION_COMPLETE": "idle",
            "CLICK_INSERT": "inserting_auto",
            "CLICK_SEARCH": "searching_auto",
            "CLICK_DELETE": "confirming_delete",
            "CLICK_CLEAR": "confirming_clear",
            "CLICK_RANDOMIZE": "randomizing",
            "TOGGLE_STEP_ON": "step_mode_idle",
            "INTERRUPT": "idle"
          }
        },
        {
          "name": "step_mode_idle",
          "onEnter": "enableStepMode",
          "onExit": "noop",
          "on": {
            "CLICK_INSERT_STEP": "stepping_operation",
            "CLICK_SEARCH_STEP": "stepping_operation",
            "CLICK_DELETE": "confirming_delete",
            "NODE_CLICK": "confirming_delete",
            "NEXT_STEP": "step_mode_idle",
            "PREV_STEP": "step_mode_idle",
            "TOGGLE_STEP_OFF": "idle"
          }
        },
        {
          "name": "stepping_operation",
          "onEnter": "startStepOperation",
          "onExit": "finishOperation",
          "on": {
            "NEXT_STEP": "stepping_operation",
            "PREV_STEP": "stepping_operation",
            "OPERATION_FINISH": "step_mode_idle",
            "CLICK_INSERT": "inserting_auto",
            "CLICK_SEARCH": "searching_auto",
            "CLICK_DELETE": "confirming_delete",
            "CLICK_CLEAR": "confirming_clear",
            "INTERRUPT": "idle"
          }
        },
        {
          "name": "confirming_delete",
          "onEnter": "promptConfirmDelete",
          "onExit": "noop",
          "on": {
            "CONFIRM_YES": "deleting_auto",
            "CONFIRM_NO": "idle"
          }
        },
        {
          "name": "confirming_clear",
          "onEnter": "promptConfirmClear",
          "onExit": "noop",
          "on": {
            "CONFIRM_YES": "idle",
            "CONFIRM_NO": "idle"
          }
        },
        {
          "name": "randomizing",
          "onEnter": "startRandomize",
          "onExit": "stopRandomize",
          "on": {
            "RANDOMIZE_NEXT": "randomizing",
            "RANDOMIZE_COMPLETE": "idle",
            "CLICK_INSERT": "inserting_auto",
            "CLICK_SEARCH": "searching_auto",
            "CLICK_DELETE": "confirming_delete",
            "CLICK_CLEAR": "confirming_clear",
            "TOGGLE_STEP_ON": "step_mode_idle",
            "INTERRUPT": "idle"
          }
        }
      ],
      "events": [
        "CLICK_INSERT",
        "CLICK_INSERT_STEP",
        "CLICK_SEARCH",
        "CLICK_SEARCH_STEP",
        "CLICK_DELETE",
        "NODE_CLICK",
        "CLICK_CLEAR",
        "CLICK_RANDOMIZE",
        "TOGGLE_STEP_ON",
        "TOGGLE_STEP_OFF",
        "NEXT_STEP",
        "PREV_STEP",
        "ANIMATION_COMPLETE",
        "OPERATION_FINISH",
        "RANDOMIZE_NEXT",
        "RANDOMIZE_COMPLETE",
        "CONFIRM_YES",
        "CONFIRM_NO",
        "KEYBOARD_ENTER",
        "KEYBOARD_SEARCH_SHORTCUT",
        "INTERRUPT"
      ],
      "notes": "The FSM models UI-triggered operations (insert/search/delete), automatic animations (ANIMATION_COMPLETE), a step mode where comparisons advance with NEXT_STEP/PREV_STEP, confirmation dialogs for delete/clear, and a randomize sequence that performs multiple inserts. Buttons can interrupt pending animations (INTERRUPT). Confirm dialogs are implemented synchronously in the UI (promptConfirm* events)."
    }
  },
  {
    "id": "5d8dd330-bf50-11f0-9278-a57cfa0a44e5",
    "timestamp": "2025-11-11T22:47:20.826Z",
    "model": "gpt-3.5-turbo",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Binary Search Tree (BST)</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 0;\n        }\n\n        .container {\n            max-width: 800px;\n            margin: 0 auto;\n            padding: 16px;\n        }\n\n        h1 {\n            text-align: center;\n            margin-bottom: 16px;\n        }\n\n        p {\n            margin-bottom: 8px;\n        }\n\n        .input {\n            display: block;\n            margin-bottom: 16px;\n        }\n\n        button {\n            padding: 8px 16px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n\n        button:hover {\n            background-color: #45a049;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"container\">\n        <h1>Binary Search Tree (BST)</h1>\n        <p>A Binary Search Tree (BST) is a data structure that allows for fast searching, insertion, and deletion of items.</p>\n\n        <p>Interactive Demonstration:</p>\n        <input type=\"text\" class=\"input\" placeholder=\"Enter nodes (e.g., 10, 5, 15)\">\n        <button onclick=\"buildBST()\">Build BST</button>\n        <div id=\"bst\"></div>\n\n        <script>\n            function Node(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n\n            function insert(root, value) {\n                if (root === null) return new Node(value);\n                if (value < root.value) root.left = insert(root.left, value);\n                else root.right = insert(root.right, value);\n                return root;\n            }\n\n            function drawBST(root, level = 0) {\n                if (root !== null) {\n                    const bstDiv = document.getElementById(\"bst\");\n                    const nodeDiv = document.createElement(\"div\");\n                    nodeDiv.style.marginLeft = `${level * 40}px`;\n                    nodeDiv.textContent = root.value;\n                    bstDiv.appendChild(nodeDiv);\n                    drawBST(root.left, level + 1);\n                    drawBST(root.right, level + 1);\n                }\n            }\n\n            function buildBST() {\n                const nodesInput = document.querySelector(\".input\").value;\n                const nodesArray = nodesInput.split(\",\").map(el => parseInt(el.trim()));\n                let root = null;\n                nodesArray.forEach(node => {\n                    root = insert(root, node);\n                });\n\n                document.getElementById(\"bst\").innerHTML = \"\";\n                drawBST(root);\n            }\n        </script>\n    </div>\n</body>\n\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "Only return HTML code! You are an expert in interactive web design and front-end pedagogy. Please design a **high-quality interactive HTML page** that provides an in-depth, hands-on exploration of Binary Search Tree (BST).\n\n**Project Overview:**\nTopic: Binary Search Tree (BST)\n\n**Interactive Design Plan:**\n\nPlease plan the HTML interface as a **single interactive module** that teaches or demonstrates this concept.\n\nFor this module, include the following sections:\n\n*   **Concept Title:** A concise title describing the main idea.\n*   **Learning Objective:** What users should understand or experience after interacting with the module.\n*   **Interaction Design:** Describe in detail how the user interacts with the page (clicking, dragging, typing, etc.), what changes occur in response (animations, visual updates, state changes), and how these reinforce understanding of the concept.\n*   **Layout Description:** Explain the spatial organization ‚Äî placement of text, controls, and visuals ‚Äî including how you will maintain clarity, focus, and balance.\n    - Safe area margins: **24 px** on all sides of the viewport.\n    - Minimum spacing: **16 px** between any two interactive elements.\n    - Ensure accessibility and responsiveness.\n\n**Requirements:**\n1. The design should explain **only one concept** clearly and interactively.\n2. The page must include **at least one form of visual feedback or animation** responding to user input.\n3. The implementation must be **self-contained** ‚Äî using only vanilla HTML, CSS, and JavaScript (no external libraries or assets).\n4. Maintain consistent code formatting and indentation.\nOnly return HTML code!"
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Finite State Machine (FSM) for an interactive Binary Search Tree (BST) demonstration",
      "states": [
        {
          "name": "IDLE",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "BUILD_BST": "BUILDING_BST"
          }
        },
        {
          "name": "BUILDING_BST",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "BST_BUILT": "BST_DISPLAYED"
          }
        },
        {
          "name": "BST_DISPLAYED",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "BUILD_BST": "BUILDING_BST"
          }
        }
      ],
      "events": ["BUILD_BST", "BST_BUILT"],
      "notes": "The application allows users to enter nodes to build a Binary Search Tree (BST) and displays the BST interactively."
    }
  },
  {
    "id": "9e580470-bf51-11f0-8ac4-79272b6a78b2",
    "timestamp": "2025-11-11T22:56:22.220Z",
    "model": "gpt-4o-mini",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interactive Binary Search Tree (BST)</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f4f4f4;\n        }\n        h1 {\n            color: #34495e;\n        }\n        .container {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n        #bstVisualization {\n            width: 600px;\n            height: 400px;\n            border: 1px solid #ccc;\n            position: relative;\n            background-color: white;\n        }\n        .node {\n            width: 50px;\n            height: 50px;\n            border: 2px solid #2980b9;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            background-color: #ecf0f1;\n            position: absolute;\n            transition: background-color 0.3s;\n        }\n        .node:hover {\n            background-color: #bdc3c7;\n        }\n        button {\n            margin: 10px;\n            padding: 10px 20px;\n            background-color: #2980b9;\n            color: white;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #3498db;\n        }\n    </style>\n</head>\n<body>\n\n<div class=\"container\">\n    <h1>Interactive Binary Search Tree (BST)</h1>\n    <div id=\"bstVisualization\"></div>\n    <input type=\"number\" id=\"inputValue\" placeholder=\"Enter a number\" min=\"0\">\n    <button id=\"insertButton\">Insert</button>\n    <button id=\"deleteButton\">Delete</button>\n    <div id=\"result\"></div>\n</div>\n\n<script>\n    class TreeNode {\n        constructor(value) {\n            this.value = value;\n            this.left = null;\n            this.right = null;\n        }\n    }\n\n    class BST {\n        constructor() {\n            this.root = null;\n        }\n\n        insert(value) {\n            const newNode = new TreeNode(value);\n            if (!this.root) {\n                this.root = newNode;\n            } else {\n                this.insertNode(this.root, newNode);\n            }\n        }\n\n        insertNode(node, newNode) {\n            if (newNode.value < node.value) {\n                if (!node.left) {\n                    node.left = newNode;\n                } else {\n                    this.insertNode(node.left, newNode);\n                }\n            } else {\n                if (!node.right) {\n                    node.right = newNode;\n                } else {\n                    this.insertNode(node.right, newNode);\n                }\n            }\n        }\n\n        delete(value) {\n            this.root = this.deleteNode(this.root, value);\n        }\n\n        deleteNode(node, value) {\n            if (!node) return null;\n            if (value < node.value) {\n                node.left = this.deleteNode(node.left, value);\n                return node;\n            } else if (value > node.value) {\n                node.right = this.deleteNode(node.right, value);\n                return node;\n            } else {\n                // Node to be deleted found\n                if (!node.left && !node.right) return null; // No children\n                if (!node.left) return node.right; // One child (right)\n                if (!node.right) return node.left; // One child (left)\n\n                // Two children: Get the inorder successor (smallest in the right subtree)\n                node.value = this.minValue(node.right);\n                node.right = this.deleteNode(node.right, node.value);\n            }\n            return node;\n        }\n\n        minValue(node) {\n            let min = node.value;\n            while (node.left) {\n                min = node.left.value;\n                node = node.left;\n            }\n            return min;\n        }\n    }\n\n    const bst = new BST();\n\n    function drawBST(node, x, y, gap) {\n        if (!node) return;\n\n        const nodeElement = document.createElement('div');\n        nodeElement.className = 'node';\n        nodeElement.innerText = node.value;\n        nodeElement.style.left = `${x}px`;\n        nodeElement.style.top = `${y}px`;\n        document.getElementById('bstVisualization').appendChild(nodeElement);\n\n        drawBST(node.left, x - gap, y + 60, gap / 2);\n        drawBST(node.right, x + gap, y + 60, gap / 2);\n    }\n\n    document.getElementById('insertButton').addEventListener('click', () => {\n        const value = parseInt(document.getElementById('inputValue').value);\n        if (isNaN(value)) {\n            alert(\"Please enter a valid number.\");\n            return;\n        }\n        bst.insert(value);\n        document.getElementById('result').innerText = `Inserted: ${value}`;\n        document.getElementById('bstVisualization').innerHTML = '';\n        drawBST(bst.root, 300, 20, 100);\n    });\n\n    document.getElementById('deleteButton').addEventListener('click', () => {\n        const value = parseInt(document.getElementById('inputValue').value);\n        if (isNaN(value)) {\n            alert(\"Please enter a valid number.\");\n            return;\n        }\n        bst.delete(value);\n        document.getElementById('result').innerText = `Deleted: ${value}`;\n        document.getElementById('bstVisualization').innerHTML = '';\n        drawBST(bst.root, 300, 20, 100);\n    });\n</script>\n\n</body>\n</html>\n``` \n\nThis HTML snippet creates an interactive Binary Search Tree (BST) visualization tool where users can insert and delete numbers. The BST is drawn dynamically based on the nodes' values, with each node represented as a circular div. Users can input a number and see the tree update in real time."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a high-quality interactive HTML page that provides an in-depth, hands-on exploration of Binary Search Tree (BST).\nOnly return HTML code!"
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Finite state machine for an interactive binary search tree application.",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "INSERT_BUTTON_CLICKED": "inserting",
            "DELETE_BUTTON_CLICKED": "deleting"
          }
        },
        {
          "name": "inserting",
          "onEnter": "drawBST",
          "onExit": "noop",
          "on": {
            "INSERTION_COMPLETE": "idle",
            "INVALID_INPUT": "idle"
          }
        },
        {
          "name": "deleting",
          "onEnter": "drawBST",
          "onExit": "noop",
          "on": {
            "DELETION_COMPLETE": "idle",
            "INVALID_INPUT": "idle"
          }
        }
      ],
      "events": [
        "INSERT_BUTTON_CLICKED",
        "DELETE_BUTTON_CLICKED",
        "INSERTION_COMPLETE",
        "DELETION_COMPLETE",
        "INVALID_INPUT"
      ],
      "notes": "States represent the main interactions with the binary search tree. The 'inserting' and 'deleting' states handle the respective operations and transition back to 'idle' upon completion or invalid input."
    }
  },
  {
    "id": "fad12780-bf52-11f0-bc20-193729720a40",
    "timestamp": "2025-11-11T23:17:23.023Z",
    "model": "gpt-5",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Interactive Binary Search Tree (BST) Lab</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<style>\n  :root {\n    --bg: #0f172a;\n    --panel: #111827;\n    --text: #e5e7eb;\n    --muted: #9ca3af;\n    --accent: #60a5fa;\n    --accent-2: #22c55e;\n    --accent-3: #f59e0b;\n    --danger: #ef4444;\n    --edge: #334155;\n    --node: #1f2937;\n    --node-stroke: #94a3b8;\n    --highlight: #f472b6;\n    --visited: #a78bfa;\n    --success: #16a34a;\n    --warning: #f97316;\n  }\n  .light {\n    --bg: #f8fafc;\n    --panel: #ffffff;\n    --text: #111827;\n    --muted: #6b7280;\n    --accent: #2563eb;\n    --accent-2: #059669;\n    --accent-3: #b45309;\n    --danger: #dc2626;\n    --edge: #cbd5e1;\n    --node: #f1f5f9;\n    --node-stroke: #475569;\n    --highlight: #db2777;\n    --visited: #7c3aed;\n    --success: #16a34a;\n    --warning: #ea580c;\n  }\n  html, body {\n    height: 100%;\n    background: var(--bg);\n    color: var(--text);\n    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica Neue, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n    margin: 0;\n  }\n  header {\n    padding: 18px 20px;\n    border-bottom: 1px solid var(--edge);\n    background: linear-gradient(90deg, rgba(96,165,250,0.15), rgba(34,197,94,0.15));\n  }\n  header h1 {\n    margin: 0;\n    font-size: 22px;\n    letter-spacing: 0.5px;\n  }\n  header p {\n    margin: 6px 0 0;\n    color: var(--muted);\n    font-size: 14px;\n  }\n  main {\n    display: grid;\n    grid-template-columns: 1.2fr 1fr;\n    gap: 16px;\n    padding: 16px;\n  }\n  .panel {\n    background: var(--panel);\n    border: 1px solid var(--edge);\n    border-radius: 10px;\n    overflow: hidden;\n  }\n  .panel h2 {\n    margin: 0;\n    padding: 12px 14px;\n    border-bottom: 1px solid var(--edge);\n    font-size: 16px;\n    background: linear-gradient(0deg, rgba(255,255,255,0.03), rgba(255,255,255,0));\n  }\n  .viz {\n    display: grid;\n    grid-template-rows: auto 1fr;\n  }\n  .toolbar {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 8px;\n    padding: 10px;\n    background: rgba(255,255,255,0.03);\n    border-bottom: 1px solid var(--edge);\n  }\n  .toolbar .group {\n    display: flex;\n    gap: 6px;\n    align-items: center;\n    flex-wrap: wrap;\n  }\n  .toolbar label {\n    font-size: 12px;\n    color: var(--muted);\n  }\n  .toolbar input[type=\"number\"],\n  .toolbar input[type=\"text\"],\n  .toolbar select {\n    background: var(--bg);\n    color: var(--text);\n    border: 1px solid var(--edge);\n    border-radius: 8px;\n    padding: 8px 10px;\n    height: 34px;\n    font-size: 14px;\n    outline: none;\n  }\n  .toolbar button {\n    background: var(--accent);\n    color: white;\n    border: none;\n    border-radius: 8px;\n    padding: 8px 12px;\n    height: 34px;\n    font-size: 14px;\n    cursor: pointer;\n  }\n  .toolbar button.secondary {\n    background: transparent;\n    color: var(--text);\n    border: 1px solid var(--edge);\n  }\n  .toolbar button.warn {\n    background: var(--danger);\n  }\n  .toolbar button:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n  }\n  .canvas-wrap {\n    position: relative;\n    min-height: 340px;\n    height: calc(60vh - 80px);\n  }\n  #svg {\n    width: 100%;\n    height: 100%;\n    background:\n      radial-gradient(ellipse at top left, rgba(96,165,250,0.12), transparent 60%),\n      radial-gradient(ellipse at bottom right, rgba(34,197,94,0.12), transparent 60%);\n  }\n  /* Node/edge visuals */\n  .edge {\n    stroke: var(--edge);\n    stroke-width: 2;\n    transition: stroke 0.2s, stroke-width 0.2s;\n  }\n  .edge.highlight {\n    stroke: var(--highlight);\n    stroke-width: 3.2;\n  }\n  .edge.delete {\n    stroke: var(--danger);\n  }\n  .edge.visited {\n    stroke: var(--visited);\n  }\n  .node {\n    transition: transform 0.2s ease, fill 0.2s, stroke 0.2s;\n    cursor: pointer;\n  }\n  .node circle {\n    fill: var(--node);\n    stroke: var(--node-stroke);\n    stroke-width: 2;\n  }\n  .node.visited circle {\n    stroke: var(--visited);\n    stroke-width: 3;\n  }\n  .node.highlight circle {\n    stroke: var(--highlight);\n    stroke-width: 3.2;\n  }\n  .node.delete circle {\n    stroke: var(--danger);\n    stroke-width: 3.2;\n  }\n  .node text {\n    fill: var(--text);\n    font-weight: 600;\n    font-size: 13px;\n    pointer-events: none;\n  }\n  .node .meta {\n    font-size: 10px;\n    fill: var(--muted);\n    transform: translateY(14px);\n  }\n  .legend {\n    position: absolute;\n    right: 10px;\n    bottom: 10px;\n    font-size: 12px;\n    color: var(--muted);\n    background: rgba(0,0,0,0.25);\n    backdrop-filter: blur(6px);\n    border: 1px solid var(--edge);\n    border-radius: 8px;\n    padding: 6px 8px;\n  }\n  .legend span {\n    display: inline-flex;\n    align-items: center;\n    gap: 6px;\n    margin-right: 10px;\n  }\n  .dot {\n    width: 14px;\n    height: 14px;\n    border-radius: 999px;\n    display: inline-block;\n    border: 2px solid var(--node-stroke);\n    background: var(--node);\n  }\n  .dot.highlight { border-color: var(--highlight); }\n  .dot.visited { border-color: var(--visited); }\n  .dot.delete { border-color: var(--danger); }\n\n  /* Right column */\n  .right {\n    display: grid;\n    grid-template-rows: auto auto 1fr auto;\n    gap: 12px;\n  }\n  .section {\n    padding: 10px;\n  }\n  .controls {\n    display: grid;\n    gap: 8px;\n  }\n  .controls .row {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 8px;\n    align-items: center;\n  }\n  .controls input[type=\"number\"],\n  .controls input[type=\"text\"],\n  .controls select {\n    background: var(--bg);\n    color: var(--text);\n    border: 1px solid var(--edge);\n    border-radius: 8px;\n    padding: 8px 10px;\n    height: 34px;\n    font-size: 14px;\n    outline: none;\n  }\n  .controls button {\n    background: var(--accent);\n    color: white;\n    border: none;\n    border-radius: 8px;\n    padding: 8px 12px;\n    height: 34px;\n    font-size: 14px;\n    cursor: pointer;\n  }\n  .controls button.secondary {\n    background: transparent;\n    color: var(--text);\n    border: 1px solid var(--edge);\n  }\n  .controls button.warn {\n    background: var(--danger);\n  }\n  .tiny {\n    font-size: 12px;\n    color: var(--muted);\n  }\n\n  /* Pseudocode */\n  .code {\n    background: linear-gradient(0deg, rgba(255,255,255,0.02), rgba(255,255,255,0));\n    border-top: 1px solid var(--edge);\n    border-bottom: 1px solid var(--edge);\n    max-height: 220px;\n    overflow: auto;\n  }\n  .code-tabs {\n    display: flex;\n    gap: 6px;\n    padding: 8px;\n    border-bottom: 1px solid var(--edge);\n  }\n  .code-tabs button {\n    background: transparent;\n    color: var(--text);\n    border: 1px solid var(--edge);\n    border-radius: 8px;\n    padding: 6px 10px;\n    font-size: 13px;\n    cursor: pointer;\n  }\n  .code-tabs button.active {\n    background: var(--accent);\n    color: white;\n    border-color: var(--accent);\n  }\n  pre {\n    margin: 0;\n    padding: 10px 12px 14px;\n    white-space: pre-wrap;\n    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, \"Liberation Mono\", monospace;\n    font-size: 12.5px;\n  }\n  .code .line {\n    padding: 2px 6px;\n    border-radius: 6px;\n  }\n  .code .line.hl {\n    background: rgba(96,165,250,0.15);\n    outline: 1px dashed var(--accent);\n  }\n\n  /* Output */\n  .output {\n    background: rgba(255,255,255,0.03);\n    border-top: 1px solid var(--edge);\n    padding: 10px;\n    min-height: 80px;\n  }\n  .out-row {\n    display: flex;\n    gap: 6px;\n    flex-wrap: wrap;\n    align-items: center;\n    margin-top: 6px;\n  }\n  .pill {\n    display: inline-block;\n    padding: 4px 8px;\n    border-radius: 999px;\n    border: 1px solid var(--edge);\n    background: var(--bg);\n    color: var(--text);\n    font-size: 12px;\n  }\n  .pill.ok { border-color: var(--success); color: var(--success); }\n  .pill.warn { border-color: var(--warning); color: var(--warning); }\n  .pill.err { border-color: var(--danger); color: var(--danger); }\n\n  /* Challenge */\n  .challenge {\n    padding: 10px;\n    border-top: 1px dashed var(--edge);\n    background: rgba(255,255,255,0.03);\n  }\n  .challenge .status {\n    margin-top: 6px;\n    font-size: 13px;\n    color: var(--muted);\n  }\n\n  /* Footer */\n  footer {\n    padding: 10px 16px;\n    border-top: 1px solid var(--edge);\n    color: var(--muted);\n    font-size: 12px;\n    display: flex;\n    gap: 10px;\n    align-items: center;\n  }\n\n  /* Toggle + sliders */\n  .switch {\n    position: relative;\n    width: 50px;\n    height: 26px;\n    background: var(--edge);\n    border-radius: 999px;\n    cursor: pointer;\n    border: 1px solid var(--node-stroke);\n  }\n  .knob {\n    position: absolute;\n    top: 2px;\n    left: 2px;\n    width: 22px;\n    height: 22px;\n    border-radius: 999px;\n    background: var(--node);\n    border: 1px solid var(--node-stroke);\n    transition: left 0.2s ease;\n  }\n  .switch.on .knob { left: 26px; }\n\n  .range {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n  }\n  input[type=\"range\"] {\n    width: 150px;\n    accent-color: var(--accent);\n  }\n\n  /* Responsive */\n  @media (max-width: 1024px) {\n    main { grid-template-columns: 1fr; }\n  }\n</style>\n</head>\n<body class=\"light\">\n<header>\n  <h1>Binary Search Tree (BST) Interactive Lab</h1>\n  <p>Insert, search, delete, and traverse. Watch algorithms step through the tree, inspect invariants, and practice with challenges.</p>\n</header>\n\n<main>\n  <section class=\"panel viz\">\n    <h2>Visualization</h2>\n    <div class=\"toolbar\">\n      <div class=\"group\">\n        <label for=\"valInput\">Value</label>\n        <input id=\"valInput\" type=\"number\" placeholder=\"e.g., 42\">\n        <button id=\"btnInsert\">Insert</button>\n        <button id=\"btnSearch\" class=\"secondary\">Search</button>\n        <button id=\"btnDelete\" class=\"warn\">Delete</button>\n      </div>\n      <div class=\"group\">\n        <input id=\"listInput\" type=\"text\" placeholder=\"Insert list: e.g. 50,20,70,10 30 60 80\">\n        <button id=\"btnInsertList\">Insert List</button>\n        <button id=\"btnRandom\" class=\"secondary\">Random Tree</button>\n        <select id=\"randomCount\">\n          <option>5</option><option selected>8</option><option>12</option><option>16</option><option>24</option>\n        </select>\n        <button id=\"btnClear\" class=\"secondary\">Clear</button>\n      </div>\n      <div class=\"group\">\n        <label>Animate</label>\n        <div id=\"animSwitch\" class=\"switch on\" title=\"Toggle animations\"><div class=\"knob\"></div></div>\n        <span class=\"range\">\n          <label>Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"1\" max=\"100\" value=\"40\">\n          <span id=\"speedLabel\" class=\"tiny\">1x</span>\n        </span>\n        <label>Theme</label>\n        <div id=\"themeSwitch\" class=\"switch on\" title=\"Toggle light/dark\"><div class=\"knob\"></div></div>\n      </div>\n      <div class=\"group\">\n        <label>Node Meta</label>\n        <div id=\"metaSwitch\" class=\"switch\" title=\"Show height/size\"><div class=\"knob\"></div></div>\n      </div>\n    </div>\n\n    <div class=\"canvas-wrap\">\n      <svg id=\"svg\" viewBox=\"0 0 1000 600\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n      <div class=\"legend\">\n        <span><i class=\"dot visited\"></i> visited</span>\n        <span><i class=\"dot highlight\"></i> compare/path</span>\n        <span><i class=\"dot delete\"></i> delete</span>\n      </div>\n    </div>\n  </section>\n\n  <section class=\"panel right\">\n    <div class=\"section\">\n      <h2>Inspector & Traversals</h2>\n      <div class=\"controls\">\n        <div class=\"row\">\n          <button id=\"btnInorder\">Inorder</button>\n          <button id=\"btnPreorder\">Preorder</button>\n          <button id=\"btnPostorder\">Postorder</button>\n          <button id=\"btnLevelorder\">Level Order</button>\n        </div>\n        <div class=\"row\">\n          <button id=\"btnValidate\" class=\"secondary\">Check BST Property</button>\n          <button id=\"btnBalanced\" class=\"secondary\">Check Balanced</button>\n          <button id=\"btnStats\" class=\"secondary\">Stats</button>\n        </div>\n      </div>\n      <div id=\"output\" class=\"output\">\n        <div class=\"tiny\">Results and messages appear here.</div>\n      </div>\n    </div>\n\n    <div class=\"code\">\n      <div class=\"code-tabs\">\n        <button data-tab=\"insert\" class=\"active\">Insert</button>\n        <button data-tab=\"search\">Search</button>\n        <button data-tab=\"delete\">Delete</button>\n        <button data-tab=\"traverse\">Traverse</button>\n      </div>\n      <pre id=\"code-block\">\n        <div id=\"code-insert\">\n<span class=\"line\" data-line=\"1\">function insert(node, x):</span>\n<span class=\"line\" data-line=\"2\">  if node == null: return new Node(x)</span>\n<span class=\"line\" data-line=\"3\">  if x == node.key: return node  // ignore duplicate</span>\n<span class=\"line\" data-line=\"4\">  if x < node.key:</span>\n<span class=\"line\" data-line=\"5\">    node.left = insert(node.left, x)</span>\n<span class=\"line\" data-line=\"6\">  else:</span>\n<span class=\"line\" data-line=\"7\">    node.right = insert(node.right, x)</span>\n<span class=\"line\" data-line=\"8\">  update(node)  // height, size</span>\n<span class=\"line\" data-line=\"9\">  return node</span>\n        </div>\n        <div id=\"code-search\" style=\"display:none\">\n<span class=\"line\" data-line=\"1\">function search(node, x):</span>\n<span class=\"line\" data-line=\"2\">  while node != null:</span>\n<span class=\"line\" data-line=\"3\">    if x == node.key: return node</span>\n<span class=\"line\" data-line=\"4\">    if x < node.key: node = node.left</span>\n<span class=\"line\" data-line=\"5\">    else: node = node.right</span>\n<span class=\"line\" data-line=\"6\">  return null</span>\n        </div>\n        <div id=\"code-delete\" style=\"display:none\">\n<span class=\"line\" data-line=\"1\">function delete(node, x):</span>\n<span class=\"line\" data-line=\"2\">  if node == null: return null</span>\n<span class=\"line\" data-line=\"3\">  if x < node.key: node.left = delete(node.left, x)</span>\n<span class=\"line\" data-line=\"4\">  else if x > node.key: node.right = delete(node.right, x)</span>\n<span class=\"line\" data-line=\"5\">  else:</span>\n<span class=\"line\" data-line=\"6\">    if node.left == null: return node.right</span>\n<span class=\"line\" data-line=\"7\">    if node.right == null: return node.left</span>\n<span class=\"line\" data-line=\"8\">    succ = min(node.right)</span>\n<span class=\"line\" data-line=\"9\">    node.key = succ.key</span>\n<span class=\"line\" data-line=\"10\">    node.right = delete(node.right, succ.key)</span>\n<span class=\"line\" data-line=\"11\">  update(node)</span>\n<span class=\"line\" data-line=\"12\">  return node</span>\n        </div>\n        <div id=\"code-traverse\" style=\"display:none\">\n<span class=\"line\" data-line=\"1\">inorder(node):</span>\n<span class=\"line\" data-line=\"2\">  if node == null: return</span>\n<span class=\"line\" data-line=\"3\">  inorder(node.left)</span>\n<span class=\"line\" data-line=\"4\">  visit(node)</span>\n<span class=\"line\" data-line=\"5\">  inorder(node.right)</span>\n<span class=\"line\" data-line=\"6\">preorder(node):</span>\n<span class=\"line\" data-line=\"7\">  visit(node)</span>\n<span class=\"line\" data-line=\"8\">  preorder(node.left)</span>\n<span class=\"line\" data-line=\"9\">  preorder(node.right)</span>\n<span class=\"line\" data-line=\"10\">postorder(node):</span>\n<span class=\"line\" data-line=\"11\">  postorder(node.left)</span>\n<span class=\"line\" data-line=\"12\">  postorder(node.right)</span>\n<span class=\"line\" data-line=\"13\">  visit(node)</span>\n<span class=\"line\" data-line=\"14\">levelorder(root):</span>\n<span class=\"line\" data-line=\"15\">  queue = [root]</span>\n<span class=\"line\" data-line=\"16\">  while queue not empty:</span>\n<span class=\"line\" data-line=\"17\">    node = pop_front(queue); visit(node)</span>\n<span class=\"line\" data-line=\"18\">    push children if not null</span>\n        </div>\n      </pre>\n    </div>\n\n    <div class=\"section\">\n      <h2>Guided Challenge</h2>\n      <div class=\"challenge\">\n        <div class=\"tiny\">Practice building and reasoning about BSTs.</div>\n        <div class=\"controls\">\n          <div class=\"row\">\n            <button id=\"btnGenChallenge\" class=\"secondary\">Generate Sequence</button>\n            <select id=\"challengeLen\">\n              <option>5</option><option selected>8</option><option>12</option>\n            </select>\n            <button id=\"btnStartChallenge\">Start</button>\n            <button id=\"btnResetChallenge\" class=\"secondary\">Reset</button>\n          </div>\n          <div id=\"challengeSeq\" class=\"tiny\"></div>\n          <div class=\"row\">\n            <button id=\"btnChallengeCheck\" class=\"secondary\">Check Traversals</button>\n            <button id=\"btnChallengeHint\" class=\"secondary\">Hint</button>\n          </div>\n        </div>\n        <div id=\"challengeStatus\" class=\"status\">No challenge yet. Click Generate Sequence.</div>\n      </div>\n    </div>\n\n    <div class=\"section\">\n      <h2>Notes</h2>\n      <div class=\"tiny\">\n        - BST property: left subtree keys < node key < right subtree keys.<br>\n        - Inorder traversal of a valid BST yields a sorted sequence.<br>\n        - Average time complexity: O(log n) for search/insert/delete; worst-case O(n) when skewed.<br>\n        - Delete with two children uses the inorder successor (smallest key in right subtree).\n      </div>\n    </div>\n  </section>\n</main>\n\n<footer>\n  <span>Tip: Click nodes to center and inspect. Use \"Node Meta\" to show height and size.</span>\n  <span style=\"margin-left:auto\">\n    Built for learning. No external libraries.\n  </span>\n</footer>\n\n<script>\n(function() {\n  // Utilities\n  const sleep = (ms) => new Promise(res => setTimeout(res, ms));\n  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));\n  const uid = (() => { let i=1; return () => i++; })();\n  const byId = (id) => document.getElementById(id);\n  const svg = byId('svg');\n\n  // Settings state\n  let animate = true;\n  let speed = 40; // slider unit\n  let showMeta = false;\n  let themeLight = true;\n\n  // UI elements\n  const valInput = byId('valInput');\n  const btnInsert = byId('btnInsert');\n  const btnSearch = byId('btnSearch');\n  const btnDelete = byId('btnDelete');\n  const listInput = byId('listInput');\n  const btnInsertList = byId('btnInsertList');\n  const btnRandom = byId('btnRandom');\n  const randomCount = byId('randomCount');\n  const btnClear = byId('btnClear');\n  const animSwitch = byId('animSwitch');\n  const themeSwitch = byId('themeSwitch');\n  const metaSwitch = byId('metaSwitch');\n  const speedSlider = byId('speed');\n  const speedLabel = byId('speedLabel');\n  const out = byId('output');\n\n  const btnInorder = byId('btnInorder');\n  const btnPreorder = byId('btnPreorder');\n  const btnPostorder = byId('btnPostorder');\n  const btnLevelorder = byId('btnLevelorder');\n  const btnValidate = byId('btnValidate');\n  const btnBalanced = byId('btnBalanced');\n  const btnStats = byId('btnStats');\n\n  const tabs = document.querySelectorAll('.code-tabs button');\n  const codeBlocks = {\n    insert: byId('code-insert'),\n    search: byId('code-search'),\n    delete: byId('code-delete'),\n    traverse: byId('code-traverse')\n  };\n\n  const btnGenChallenge = byId('btnGenChallenge');\n  const btnStartChallenge = byId('btnStartChallenge');\n  const btnResetChallenge = byId('btnResetChallenge');\n  const challengeLen = byId('challengeLen');\n  const challengeSeq = byId('challengeSeq');\n  const challengeStatus = byId('challengeStatus');\n  const btnChallengeCheck = byId('btnChallengeCheck');\n  const btnChallengeHint = byId('btnChallengeHint');\n\n  // BST structure\n  class Node {\n    constructor(key) {\n      this.key = key;\n      this.left = null;\n      this.right = null;\n      this.id = uid();\n      this.depth = 0;\n      this.x = 0;\n      this.y = 0;\n      this.height = 1;\n      this.size = 1;\n      this.parent = null;\n    }\n  }\n  class BST {\n    constructor() { this.root = null; this.nodeCount = 0; }\n    search(x) {\n      let path = [];\n      let curr = this.root;\n      while (curr) {\n        path.push(curr);\n        if (x === curr.key) return { node: curr, path };\n        curr = x < curr.key ? curr.left : curr.right;\n      }\n      return { node: null, path };\n    }\n    insert(x) {\n      let existed = false;\n      const rec = (node, parent=null) => {\n        highlightPseudo('insert', [1]);\n        if (!node) {\n          const nn = new Node(x);\n          nn.parent = parent;\n          highlightPseudo('insert', [2]);\n          return nn;\n        }\n        if (x === node.key) {\n          existed = true;\n          highlightPseudo('insert', [3]);\n          return node;\n        }\n        if (x < node.key) {\n          highlightPseudo('insert', [4,5]);\n          node.left = rec(node.left, node);\n        } else {\n          highlightPseudo('insert', [6,7]);\n          node.right = rec(node.right, node);\n        }\n        this.update(node);\n        highlightPseudo('insert', [8,9]);\n        return node;\n      };\n      this.root = rec(this.root);\n      if (!existed) this.nodeCount++;\n      return { existed };\n    }\n    delete(x) {\n      let found = false;\n      const rec = (node) => {\n        highlightPseudo('delete', [1]);\n        if (!node) { highlightPseudo('delete', [2]); return null; }\n        if (x < node.key) {\n          highlightPseudo('delete', [3]);\n          node.left = rec(node.left);\n          if (node.left) node.left.parent = node;\n        } else if (x > node.key) {\n          highlightPseudo('delete', [4]);\n          node.right = rec(node.right);\n          if (node.right) node.right.parent = node;\n        } else {\n          found = true;\n          highlightPseudo('delete', [5]);\n          if (!node.left) {\n            highlightPseudo('delete', [6]);\n            return node.right ? (node.right.parent = node.parent, node.right) : null;\n          }\n          if (!node.right) {\n            highlightPseudo('delete', [7]);\n            return node.left ? (node.left.parent = node.parent, node.left) : null;\n          }\n          // Two children: successor\n          highlightPseudo('delete', [8]);\n          const succ = this.min(node.right);\n          node.key = succ.key;\n          highlightPseudo('delete', [9,10]);\n          node.right = recDeleteMin(node.right);\n          if (node.right) node.right.parent = node;\n        }\n        highlightPseudo('delete', [11,12]);\n        this.update(node);\n        return node;\n      };\n      const recDeleteMin = (node) => {\n        if (!node.left) return node.right;\n        node.left = recDeleteMin(node.left);\n        if (node.left) node.left.parent = node;\n        this.update(node);\n        return node;\n      };\n      this.root = rec(this.root);\n      if (found) this.nodeCount = Math.max(0, this.nodeCount - 1);\n      return { found };\n    }\n    min(node) {\n      while (node && node.left) node = node.left;\n      return node;\n    }\n    update(node) {\n      const lh = node.left ? node.left.height : 0;\n      const rh = node.right ? node.right.height : 0;\n      node.height = Math.max(lh, rh) + 1;\n      const ls = node.left ? node.left.size : 0;\n      const rs = node.right ? node.right.size : 0;\n      node.size = ls + rs + 1;\n    }\n    validate() {\n      let valid = true;\n      const rec = (node, lo=-Infinity, hi=Infinity) => {\n        if (!node || !valid) return;\n        if (!(node.key > lo && node.key < hi)) { valid = false; return; }\n        rec(node.left, lo, node.key);\n        rec(node.right, node.key, hi);\n      };\n      rec(this.root);\n      return valid;\n    }\n    isBalanced() {\n      let ok = true;\n      const rec = (node) => {\n        if (!node || !ok) return 0;\n        const lh = rec(node.left);\n        const rh = rec(node.right);\n        if (Math.abs(lh - rh) > 1) ok = false;\n        return Math.max(lh, rh) + 1;\n      };\n      rec(this.root);\n      return ok;\n    }\n    stats() {\n      const h = this.root ? this.root.height : 0;\n      const n = this.nodeCount;\n      const leaves = (() => {\n        let c = 0;\n        const rec = (node) => {\n          if (!node) return;\n          if (!node.left && !node.right) c++;\n          rec(node.left); rec(node.right);\n        };\n        rec(this.root);\n        return c;\n      })();\n      return { nodes: n, height: h, leaves };\n    }\n\n    // Traversals\n    inorder() {\n      const arr = [];\n      const rec = (n) => { if (!n) return; rec(n.left); arr.push(n); rec(n.right); };\n      rec(this.root);\n      return arr;\n    }\n    preorder() {\n      const arr = [];\n      const rec = (n) => { if (!n) return; arr.push(n); rec(n.left); rec(n.right); };\n      rec(this.root);\n      return arr;\n    }\n    postorder() {\n      const arr = [];\n      const rec = (n) => { if (!n) return; rec(n.left); rec(n.right); arr.push(n); };\n      rec(this.root);\n      return arr;\n    }\n    levelorder() {\n      const arr = [];\n      const q = [];\n      if (this.root) q.push(this.root);\n      while (q.length) {\n        const n = q.shift();\n        arr.push(n);\n        if (n.left) q.push(n.left);\n        if (n.right) q.push(n.right);\n      }\n      return arr;\n    }\n  }\n\n  const tree = new BST();\n\n  // Layout and rendering\n  function computeMeta(root) {\n    const depths = new Map();\n    const rec = (node, d) => {\n      if (!node) return;\n      node.depth = d;\n      tree.update(node);\n      rec(node.left, d+1);\n      rec(node.right, d+1);\n    };\n    rec(root, 0);\n  }\n\n  function inorderList(root) {\n    const arr = [];\n    const rec = (n) => { if (!n) return; rec(n.left); arr.push(n); rec(n.right); };\n    rec(root);\n    return arr;\n  }\n\n  function layout() {\n    const root = tree.root;\n    if (!root) return { nodes: [] };\n    computeMeta(root);\n    const nodes = inorderList(root);\n    // Compute positions based on inorder index and depth\n    const width = svg.viewBox.baseVal.width || 1000;\n    const height = svg.viewBox.baseVal.height || 600;\n    const marginX = 40, marginY = 40;\n    const n = Math.max(nodes.length, 1);\n    const stepX = n > 1 ? (width - 2*marginX) / (n - 1) : 0;\n    const levelGap = Math.max(60, (height - 2*marginY) / Math.max(root.height,1));\n\n    nodes.forEach((node, i) => {\n      node.x = n>1 ? marginX + i * stepX : width/2;\n      node.y = marginY + node.depth * levelGap;\n    });\n\n    // For nodes not in inorder array (shouldn't happen), but ensure parent/children positions exist.\n    return { nodes };\n  }\n\n  function clearSVG() {\n    while (svg.firstChild) svg.removeChild(svg.firstChild);\n  }\n\n  function draw() {\n    clearSVG();\n    const root = tree.root;\n    const radius = 18;\n    if (!root) return;\n    const { nodes } = layout();\n    // Build map id->node\n    const idMap = new Map(nodes.map(n => [n.id, n]));\n\n    // Draw edges by traversing tree\n    const drawEdges = (node) => {\n      if (!node) return;\n      if (node.left) {\n        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n        line.setAttribute('x1', node.x);\n        line.setAttribute('y1', node.y);\n        line.setAttribute('x2', node.left.x);\n        line.setAttribute('y2', node.left.y);\n        line.setAttribute('class', 'edge');\n        line.setAttribute('data-from', node.id);\n        line.setAttribute('data-to', node.left.id);\n        svg.appendChild(line);\n      }\n      if (node.right) {\n        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n        line.setAttribute('x1', node.x);\n        line.setAttribute('y1', node.y);\n        line.setAttribute('x2', node.right.x);\n        line.setAttribute('y2', node.right.y);\n        line.setAttribute('class', 'edge');\n        line.setAttribute('data-from', node.id);\n        line.setAttribute('data-to', node.right.id);\n        svg.appendChild(line);\n      }\n      drawEdges(node.left);\n      drawEdges(node.right);\n    };\n    drawEdges(root);\n\n    // Draw nodes\n    nodes.forEach(node => {\n      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      g.setAttribute('class', 'node');\n      g.setAttribute('data-id', node.id);\n      g.setAttribute('transform', `translate(${node.x},${node.y})`);\n      g.addEventListener('click', () => centerOn(node));\n\n      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n      circle.setAttribute('r', radius);\n      circle.setAttribute('cx', 0);\n      circle.setAttribute('cy', 0);\n\n      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      text.setAttribute('text-anchor', 'middle');\n      text.setAttribute('dominant-baseline', 'central');\n      text.textContent = node.key;\n\n      g.appendChild(circle);\n      g.appendChild(text);\n\n      if (showMeta) {\n        const meta = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        meta.setAttribute('text-anchor', 'middle');\n        meta.setAttribute('class', 'meta');\n        meta.textContent = `h=${node.height} ‚Ä¢ s=${node.size}`;\n        meta.setAttribute('y', radius + 14);\n        g.appendChild(meta);\n      }\n\n      svg.appendChild(g);\n    });\n  }\n\n  function centerOn(node) {\n    // For now: flash highlight and post info\n    flashNode(node, 'highlight', 600);\n    print(`Node ${node.key}: depth=${node.depth}, height=${node.height}, size=${node.size}`, 'info');\n  }\n\n  function findNodeGroup(id) {\n    return svg.querySelector(`.node[data-id=\"${id}\"]`);\n  }\n  function findEdge(fromId, toId) {\n    return svg.querySelector(`.edge[data-from=\"${fromId}\"][data-to=\"${toId}\"]`);\n  }\n  function markPath(path, klass) {\n    path.forEach((node, i) => {\n      const g = findNodeGroup(node.id);\n      if (g) g.classList.add(klass);\n      if (i > 0) {\n        const prev = path[i-1];\n        const edge = path[i].key < prev.key ? findEdge(prev.id, prev.left?.id) : findEdge(prev.id, prev.right?.id);\n        if (edge) edge.classList.add(klass);\n      }\n    });\n  }\n  function clearMarks() {\n    svg.querySelectorAll('.node').forEach(g => g.classList.remove('visited','highlight','delete'));\n    svg.querySelectorAll('.edge').forEach(e => e.classList.remove('visited','highlight','delete'));\n  }\n  async function animatePath(path, kind='highlight') {\n    if (!animate) { markPath(path, kind==='visited'?'visited':'highlight'); return; }\n    clearMarks();\n    for (let i = 0; i < path.length; i++) {\n      const node = path[i];\n      const g = findNodeGroup(node.id);\n      if (g) g.classList.add(kind);\n      if (i > 0) {\n        const prev = path[i-1];\n        const edge = node.key < prev.key ? findEdge(prev.id, prev.left?.id) : findEdge(prev.id, prev.right?.id);\n        if (edge) edge.classList.add(kind);\n      }\n      await sleep(stepDelay());\n    }\n  }\n  async function animateVisit(nodes) {\n    clearMarks();\n    for (const node of nodes) {\n      const g = findNodeGroup(node.id);\n      if (g) g.classList.add('visited');\n      await sleep(stepDelay());\n    }\n  }\n  function flashNode(node, klass='highlight', ms=800) {\n    const g = findNodeGroup(node.id);\n    if (!g) return;\n    g.classList.add(klass);\n    setTimeout(() => g.classList.remove(klass), ms);\n  }\n  function stepDelay() {\n    // Map speed slider (1..100) to delay (fast->short)\n    const normalized = clamp(speed, 1, 100);\n    const ms = 900 - normalized*8; // 820..100 ms roughly\n    return ms;\n  }\n\n  // Pseudocode highlighting\n  let activeTab = 'insert';\n  function highlightPseudo(tab, lines=[]) {\n    if (activeTab !== tab) return;\n    const block = codeBlocks[tab];\n    block.querySelectorAll('.line').forEach(el => el.classList.remove('hl'));\n    lines.forEach(l => {\n      const el = block.querySelector(`.line[data-line=\"${l}\"]`);\n      if (el) el.classList.add('hl');\n    });\n  }\n  function clearPseudo() {\n    Object.values(codeBlocks).forEach(block => block.querySelectorAll('.line').forEach(el => el.classList.remove('hl')));\n  }\n  tabs.forEach(btn => {\n    btn.addEventListener('click', () => {\n      tabs.forEach(b => b.classList.remove('active'));\n      btn.classList.add('active');\n      const tab = btn.dataset.tab;\n      activeTab = tab;\n      Object.entries(codeBlocks).forEach(([k, block]) => {\n        block.style.display = k === tab ? '' : 'none';\n      });\n      clearPseudo();\n    });\n  });\n\n  // Output helpers\n  function print(msg, kind='info') {\n    const row = document.createElement('div');\n    row.className = 'out-row';\n    const label = document.createElement('span');\n    label.className = 'pill ' + (kind==='ok'?'ok':kind==='warn'?'warn':kind==='err'?'err':'');\n    label.textContent = kind==='ok' ? 'OK' : kind==='warn' ? 'Note' : kind==='err' ? 'Error' : 'Info';\n    const text = document.createElement('span');\n    text.textContent = msg;\n    row.appendChild(label);\n    row.appendChild(text);\n    out.appendChild(row);\n    out.scrollTop = out.scrollHeight;\n  }\n  function clearOutput() {\n    out.innerHTML = '<div class=\"tiny\">Results and messages appear here.</div>';\n  }\n\n  // Controls state management\n  function setBusy(b) {\n    [btnInsert, btnSearch, btnDelete, btnInsertList, btnRandom, btnClear, btnInorder, btnPreorder, btnPostorder, btnLevelorder, btnValidate, btnBalanced, btnStats, btnStartChallenge, btnChallengeCheck, btnChallengeHint].forEach(el => {\n      if (!el) return;\n      el.disabled = b;\n    });\n  }\n\n  // Operations\n  async function doInsert(x) {\n    if (!isNum(x)) { print('Enter a valid number to insert.', 'warn'); return; }\n    setBusy(true);\n    clearPseudo();\n    activeTab = 'insert';\n    // Compute path for animation first\n    const s = tree.search(x);\n    if (s.node && s.node.key === x) {\n      await animatePath(s.path, 'highlight');\n      print(`Duplicate ignored: ${x} already exists in the tree.`, 'warn');\n      setBusy(false);\n      return;\n    }\n    await animatePath(s.path, 'highlight');\n    const { existed } = tree.insert(x);\n    draw();\n    // Animate flash where it was added\n    const newSearch = tree.search(x);\n    if (newSearch.node) flashNode(newSearch.node, 'visited', 1000);\n    print(`Inserted ${x}.`, 'ok');\n    setBusy(false);\n  }\n\n  async function doSearch(x) {\n    if (!isNum(x)) { print('Enter a valid number to search.', 'warn'); return; }\n    setBusy(true);\n    clearPseudo();\n    activeTab = 'search';\n    const res = tree.search(x);\n    await animatePath(res.path, 'highlight');\n    if (res.node) {\n      flashNode(res.node, 'visited', 1200);\n      print(`Found ${x}. Path length = ${res.path.length}.`, 'ok');\n    } else {\n      print(`Value ${x} not found. Path length = ${res.path.length}.`, 'warn');\n    }\n    setBusy(false);\n  }\n\n  async function doDelete(x) {\n    if (!isNum(x)) { print('Enter a valid number to delete.', 'warn'); return; }\n    setBusy(true);\n    clearPseudo();\n    activeTab = 'delete';\n    const res = tree.search(x);\n    await animatePath(res.path, 'delete');\n    if (!res.node) {\n      print(`Cannot delete ${x}: not in tree.`, 'err');\n      setBusy(false);\n      return;\n    }\n    // If two-children, pre-highlight successor\n    const node = res.node;\n    if (node.left && node.right) {\n      const succ = tree.min(node.right);\n      if (succ) {\n        print(`Node ${x} has two children. Using successor ${succ.key}.`, 'info');\n        flashNode(succ, 'highlight', 800);\n      }\n    }\n    const { found } = tree.delete(x);\n    draw();\n    if (found) {\n      print(`Deleted ${x}.`, 'ok');\n    } else {\n      print(`Delete failed for ${x}.`, 'err');\n    }\n    setBusy(false);\n  }\n\n  async function doTraversal(kind) {\n    setBusy(true);\n    clearPseudo();\n    activeTab = 'traverse';\n    let arr = [];\n    if (kind === 'inorder') {\n      arr = tree.inorder();\n      highlightPseudo('traverse', [1,2,3,4,5]);\n    } else if (kind === 'preorder') {\n      arr = tree.preorder();\n      highlightPseudo('traverse', [6,7,8,9]);\n    } else if (kind === 'postorder') {\n      arr = tree.postorder();\n      highlightPseudo('traverse', [10,11,12,13]);\n    } else {\n      arr = tree.levelorder();\n      highlightPseudo('traverse', [14,15,16,17,18]);\n    }\n    await animateVisit(arr);\n    const seq = arr.map(n => n.key).join(' ');\n    print(`${kind} traversal: ${seq}`, 'info');\n    setBusy(false);\n  }\n\n  // Helpers\n  function isNum(x) {\n    if (x === null || x === undefined) return false;\n    const n = Number(x);\n    return !Number.isNaN(n);\n  }\n\n  // Random tree\n  function generateSequence(len=8, min=0, max=99) {\n    const set = new Set();\n    while (set.size < len) {\n      set.add(Math.floor(Math.random() * (max-min+1)) + min);\n    }\n    return Array.from(set);\n  }\n\n  async function insertList(list) {\n    setBusy(true);\n    for (const v of list) {\n      await doInsert(v);\n    }\n    setBusy(false);\n  }\n\n  // Events\n  btnInsert.addEventListener('click', () => {\n    const x = Number(valInput.value);\n    doInsert(x);\n  });\n  btnSearch.addEventListener('click', () => {\n    const x = Number(valInput.value);\n    doSearch(x);\n  });\n  btnDelete.addEventListener('click', () => {\n    const x = Number(valInput.value);\n    doDelete(x);\n  });\n\n  btnInsertList.addEventListener('click', () => {\n    const raw = listInput.value.trim();\n    if (!raw) { print('Enter a list like: 50,20,70,10 30 60 80', 'warn'); return; }\n    const parts = raw.split(/[\\s,;]+/).map(Number).filter(n => !Number.isNaN(n));\n    if (!parts.length) { print('List contains no valid numbers.', 'err'); return; }\n    insertList(parts);\n  });\n\n  btnRandom.addEventListener('click', async () => {\n    clearTree();\n    const len = Number(randomCount.value);\n    const seq = generateSequence(len, 0, 99);\n    print(`Random sequence: ${seq.join(' ')}`, 'info');\n    await insertList(seq);\n  });\n\n  btnClear.addEventListener('click', () => {\n    clearTree();\n    print('Cleared tree.', 'info');\n  });\n\n  animSwitch.addEventListener('click', () => {\n    animSwitch.classList.toggle('on');\n    animate = animSwitch.classList.contains('on');\n  });\n\n  themeSwitch.addEventListener('click', () => {\n    themeSwitch.classList.toggle('on');\n    themeLight = themeSwitch.classList.contains('on');\n    document.body.classList.toggle('light', themeLight);\n  });\n\n  metaSwitch.addEventListener('click', () => {\n    metaSwitch.classList.toggle('on');\n    showMeta = metaSwitch.classList.contains('on');\n    draw();\n  });\n\n  speedSlider.addEventListener('input', () => {\n    speed = Number(speedSlider.value);\n    const label = speed <= 20 ? '0.5x' : speed <= 50 ? '1x' : speed <= 80 ? '2x' : '3x';\n    speedLabel.textContent = label;\n  });\n\n  // Inspector buttons\n  btnInorder.addEventListener('click', () => doTraversal('inorder'));\n  btnPreorder.addEventListener('click', () => doTraversal('preorder'));\n  btnPostorder.addEventListener('click', () => doTraversal('postorder'));\n  btnLevelorder.addEventListener('click', () => doTraversal('levelorder'));\n\n  btnValidate.addEventListener('click', () => {\n    const valid = tree.validate();\n    if (valid) {\n      print('BST property holds. Inorder is sorted.', 'ok');\n    } else {\n      print('BST property violated! Check your operations.', 'err');\n    }\n  });\n  btnBalanced.addEventListener('click', () => {\n    const ok = tree.isBalanced();\n    if (ok) print('Tree is height-balanced (|LH-RH| ‚â§ 1) at all nodes.', 'ok');\n    else print('Tree is not height-balanced.', 'warn');\n  });\n  btnStats.addEventListener('click', () => {\n    const s = tree.stats();\n    print(`Stats: nodes=${s.nodes}, height=${s.height}, leaves=${s.leaves}`, 'info');\n  });\n\n  // Challenge mode\n  let challSeq = [];\n  let challActive = false;\n  btnGenChallenge.addEventListener('click', () => {\n    const len = Number(challengeLen.value);\n    challSeq = generateSequence(len, 0, 99);\n    challengeSeq.textContent = `Sequence: ${challSeq.join(' ')}`;\n    challengeStatus.textContent = 'Click Start to build this sequence. Insert values in order.';\n    challActive = false;\n  });\n  btnStartChallenge.addEventListener('click', async () => {\n    if (!challSeq.length) {\n      print('Generate a sequence first.', 'warn');\n      return;\n    }\n    clearTree();\n    challActive = true;\n    challengeStatus.textContent = 'Challenge started. Insert values in order shown.';\n    print('Challenge started. Follow the sequence to insert.', 'info');\n  });\n  btnResetChallenge.addEventListener('click', () => {\n    challSeq = [];\n    challengeSeq.textContent = '';\n    challengeStatus.textContent = 'No challenge yet. Click Generate Sequence.';\n    challActive = false;\n  });\n  btnChallengeCheck.addEventListener('click', () => {\n    if (!tree.root) { print('Tree is empty. Start a challenge or insert values.', 'warn'); return; }\n    const inorder = tree.inorder().map(n => n.key);\n    const valid = tree.validate();\n    print(`Inorder: ${inorder.join(' ')}`, valid ? 'ok' : 'err');\n    const ok = tree.isBalanced();\n    print(ok ? 'This tree is balanced.' : 'This tree is not balanced.', ok ? 'ok' : 'warn');\n  });\n  btnChallengeHint.addEventListener('click', () => {\n    print('Hint: Inorder traversal should be sorted. Delete uses successor. For skewed sequences, tree height grows.', 'info');\n  });\n\n  // Intercept manual insert during challenge to assist\n  btnInsert.addEventListener('click', () => {\n    if (!challActive || !challSeq.length) return;\n    const x = Number(valInput.value);\n    const idx = nextChallengeIndex();\n    if (idx === -1) return;\n    if (x !== challSeq[idx]) {\n      print(`Out of order! Expected ${challSeq[idx]} next.`, 'warn');\n    } else {\n      // success: after doInsert finishes, move index\n      // we don't need explicit index; we check set of inserted equals prefix\n      setTimeout(() => {\n        const inserted = currentKeys();\n        const prefix = challSeq.slice(0, inserted.length);\n        if (arraysEqual(inserted, prefix)) {\n          challengeStatus.textContent = inserted.length === challSeq.length\n            ? 'Challenge complete! Now check traversals and stats.'\n            : `Good! Next expected: ${challSeq[inserted.length]}`;\n        }\n      }, 700);\n    }\n  });\n\n  function nextChallengeIndex() {\n    if (!challSeq.length) return -1;\n    const inserted = currentKeys();\n    return inserted.length;\n  }\n  function currentKeys() {\n    return tree.preorder().map(n => n.key); // track count via preorder count\n  }\n  function arraysEqual(a, b) {\n    if (a.length !== b.length) return false;\n    for (let i=0;i<a.length;i++) if (a[i] !== b[i]) return false;\n    return true;\n  }\n\n  // Tree reset\n  function clearTree() {\n    tree.root = null;\n    tree.nodeCount = 0;\n    clearSVG();\n  }\n\n  // Initial demo\n  function demo() {\n    const seq = [50, 25, 75, 10, 40, 60, 85, 5, 15, 55, 65];\n    insertList(seq);\n    print('Loaded demo tree. Try traversals and delete 25.', 'info');\n  }\n  demo();\n\n  // Keyboard helpers\n  valInput.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter') doInsert(Number(valInput.value));\n  });\n  listInput.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter') btnInsertList.click();\n  });\n\n  // Draw on resize: ensure viewBox remains constant (SVG scales)\n  window.addEventListener('resize', () => draw());\n\n  // Ensure drawing after any operation if not already\n  const observer = new MutationObserver(() => {});\n  draw();\n\n})();\n</script>\n</body>\n</html>"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a high-quality interactive HTML page that provides an in-depth, hands-on exploration of Binary Search Tree (BST).\nOnly return HTML code!"
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Finite state machine for the BST Interactive Lab covering user controls, animations, processing, visualization updates, and challenge mode.",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "BTN_INSERT_CLICK": "inserting",
            "ENTER_KEY_ON_VALUE": "inserting",
            "BTN_SEARCH_CLICK": "searching",
            "BTN_DELETE_CLICK": "deleting",
            "BTN_INSERT_LIST_CLICK": "batch_inserting",
            "ENTER_KEY_ON_LIST": "batch_inserting",
            "BTN_RANDOM_CLICK": "generating_random",
            "BTN_CLEAR_CLICK": "clearing",
            "BTN_INORDER_CLICK": "traversing",
            "BTN_PREORDER_CLICK": "traversing",
            "BTN_POSTORDER_CLICK": "traversing",
            "BTN_LEVELORDER_CLICK": "traversing",
            "BTN_VALIDATE_CLICK": "validating",
            "BTN_BALANCED_CLICK": "checking_balance",
            "BTN_STATS_CLICK": "showing_stats",
            "TAB_INSERT_SELECT": "code_tab_insert",
            "TAB_SEARCH_SELECT": "code_tab_search",
            "TAB_DELETE_SELECT": "code_tab_delete",
            "TAB_TRAVERSE_SELECT": "code_tab_traverse",
            "NODE_CLICK": "centering_node",
            "ANIMATE_TOGGLE_CLICK": "toggling_animate",
            "THEME_TOGGLE_CLICK": "toggling_theme",
            "META_TOGGLE_CLICK": "toggling_meta",
            "SPEED_INPUT_CHANGE": "adjusting_speed",
            "WINDOW_RESIZE": "redrawing",
            "GEN_CHALLENGE_CLICK": "challenge_ready",
            "START_CHALLENGE_CLICK": "challenge_active",
            "RESET_CHALLENGE_CLICK": "challenge_none",
            "CHALLENGE_CHECK_CLICK": "challenge_checking",
            "CHALLENGE_HINT_CLICK": "challenge_hinting"
          }
        },
        {
          "name": "inserting",
          "onEnter": "setBusyTrue",
          "onExit": "setBusyFalse",
          "on": {
            "ANIMATE_PATH_HIGHLIGHT": "animating_insert_path",
            "OP_COMPLETE": "redrawing",
            "CHALLENGE_INSERT_WRONG": "inserting",
            "CHALLENGE_INSERT_CORRECT": "inserting",
            "CHALLENGE_COMPLETE": "challenge_complete"
          }
        },
        {
          "name": "animating_insert_path",
          "onEnter": "runAnimatePathHighlight",
          "onExit": "noop",
          "on": {
            "ANIMATION_DONE": "inserting"
          }
        },
        {
          "name": "searching",
          "onEnter": "setBusyTrue",
          "onExit": "setBusyFalse",
          "on": {
            "ANIMATE_PATH_HIGHLIGHT": "animating_search_path",
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "animating_search_path",
          "onEnter": "runAnimatePathHighlight",
          "onExit": "noop",
          "on": {
            "ANIMATION_DONE": "searching"
          }
        },
        {
          "name": "deleting",
          "onEnter": "setBusyTrue",
          "onExit": "setBusyFalse",
          "on": {
            "ANIMATE_PATH_DELETE": "animating_delete_path",
            "OP_COMPLETE": "redrawing"
          }
        },
        {
          "name": "animating_delete_path",
          "onEnter": "runAnimatePathDelete",
          "onExit": "noop",
          "on": {
            "ANIMATION_DONE": "deleting"
          }
        },
        {
          "name": "traversing",
          "onEnter": "setBusyTrue",
          "onExit": "setBusyFalse",
          "on": {
            "ANIMATE_VISIT": "animating_traversal_visit",
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "animating_traversal_visit",
          "onEnter": "runAnimateVisit",
          "onExit": "noop",
          "on": {
            "ANIMATION_DONE": "traversing"
          }
        },
        {
          "name": "batch_inserting",
          "onEnter": "setBusyTrue",
          "onExit": "setBusyFalse",
          "on": {
            "ANIMATE_PATH_HIGHLIGHT": "animating_insert_path",
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "generating_random",
          "onEnter": "clearTree",
          "onExit": "noop",
          "on": {
            "GENERATION_DONE": "batch_inserting"
          }
        },
        {
          "name": "clearing",
          "onEnter": "clearTree",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "validating",
          "onEnter": "printValidation",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "checking_balance",
          "onEnter": "printBalanceCheck",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "showing_stats",
          "onEnter": "printStats",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "toggling_animate",
          "onEnter": "toggleAnimate",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "toggling_theme",
          "onEnter": "toggleTheme",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "toggling_meta",
          "onEnter": "toggleMeta",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "idle",
            "DRAW_DONE": "idle"
          }
        },
        {
          "name": "adjusting_speed",
          "onEnter": "updateSpeedLabel",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "code_tab_insert",
          "onEnter": "activateTabInsert",
          "onExit": "noop",
          "on": {
            "TAB_SEARCH_SELECT": "code_tab_search",
            "TAB_DELETE_SELECT": "code_tab_delete",
            "TAB_TRAVERSE_SELECT": "code_tab_traverse",
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "code_tab_search",
          "onEnter": "activateTabSearch",
          "onExit": "noop",
          "on": {
            "TAB_INSERT_SELECT": "code_tab_insert",
            "TAB_DELETE_SELECT": "code_tab_delete",
            "TAB_TRAVERSE_SELECT": "code_tab_traverse",
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "code_tab_delete",
          "onEnter": "activateTabDelete",
          "onExit": "noop",
          "on": {
            "TAB_INSERT_SELECT": "code_tab_insert",
            "TAB_SEARCH_SELECT": "code_tab_search",
            "TAB_TRAVERSE_SELECT": "code_tab_traverse",
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "code_tab_traverse",
          "onEnter": "activateTabTraverse",
          "onExit": "noop",
          "on": {
            "TAB_INSERT_SELECT": "code_tab_insert",
            "TAB_SEARCH_SELECT": "code_tab_search",
            "TAB_DELETE_SELECT": "code_tab_delete",
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "centering_node",
          "onEnter": "centerOnNode",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "idle"
          }
        },
        {
          "name": "redrawing",
          "onEnter": "draw",
          "onExit": "noop",
          "on": {
            "DRAW_DONE": "idle"
          }
        },
        {
          "name": "challenge_none",
          "onEnter": "setChallengeInactive",
          "onExit": "noop",
          "on": {
            "GEN_CHALLENGE_CLICK": "challenge_ready"
          }
        },
        {
          "name": "challenge_ready",
          "onEnter": "showGeneratedSequence",
          "onExit": "noop",
          "on": {
            "START_CHALLENGE_CLICK": "challenge_active",
            "RESET_CHALLENGE_CLICK": "challenge_none"
          }
        },
        {
          "name": "challenge_active",
          "onEnter": "startChallenge",
          "onExit": "noop",
          "on": {
            "BTN_INSERT_CLICK": "inserting",
            "CHALLENGE_INSERT_WRONG": "challenge_active",
            "CHALLENGE_INSERT_CORRECT": "challenge_active",
            "CHALLENGE_COMPLETE": "challenge_complete",
            "CHALLENGE_CHECK_CLICK": "challenge_checking",
            "CHALLENGE_HINT_CLICK": "challenge_hinting",
            "RESET_CHALLENGE_CLICK": "challenge_none"
          }
        },
        {
          "name": "challenge_checking",
          "onEnter": "printChallengeCheck",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "challenge_active"
          }
        },
        {
          "name": "challenge_hinting",
          "onEnter": "printChallengeHint",
          "onExit": "noop",
          "on": {
            "OP_COMPLETE": "challenge_active"
          }
        },
        {
          "name": "challenge_complete",
          "onEnter": "printChallengeComplete",
          "onExit": "noop",
          "on": {
            "RESET_CHALLENGE_CLICK": "challenge_none",
            "CHALLENGE_CHECK_CLICK": "challenge_checking",
            "CHALLENGE_HINT_CLICK": "challenge_hinting"
          }
        }
      ],
      "events": [
        "BTN_INSERT_CLICK",
        "ENTER_KEY_ON_VALUE",
        "BTN_SEARCH_CLICK",
        "BTN_DELETE_CLICK",
        "BTN_INSERT_LIST_CLICK",
        "ENTER_KEY_ON_LIST",
        "BTN_RANDOM_CLICK",
        "BTN_CLEAR_CLICK",
        "BTN_INORDER_CLICK",
        "BTN_PREORDER_CLICK",
        "BTN_POSTORDER_CLICK",
        "BTN_LEVELORDER_CLICK",
        "BTN_VALIDATE_CLICK",
        "BTN_BALANCED_CLICK",
        "BTN_STATS_CLICK",
        "TAB_INSERT_SELECT",
        "TAB_SEARCH_SELECT",
        "TAB_DELETE_SELECT",
        "TAB_TRAVERSE_SELECT",
        "NODE_CLICK",
        "ANIMATE_TOGGLE_CLICK",
        "THEME_TOGGLE_CLICK",
        "META_TOGGLE_CLICK",
        "SPEED_INPUT_CHANGE",
        "WINDOW_RESIZE",
        "GEN_CHALLENGE_CLICK",
        "START_CHALLENGE_CLICK",
        "RESET_CHALLENGE_CLICK",
        "CHALLENGE_CHECK_CLICK",
        "CHALLENGE_HINT_CLICK",
        "ANIMATE_PATH_HIGHLIGHT",
        "ANIMATE_PATH_DELETE",
        "ANIMATE_VISIT",
        "ANIMATION_DONE",
        "OP_COMPLETE",
        "GENERATION_DONE",
        "DRAW_DONE",
        "CHALLENGE_INSERT_WRONG",
        "CHALLENGE_INSERT_CORRECT",
        "CHALLENGE_COMPLETE"
      ],
      "notes": "Busy states disable most control buttons via setBusy(true) and re-enable on exit via setBusy(false). Animation states run animatePath/animateVisit which internally clear marks; toggling animate may cause animations to mark immediately without delays. Redrawing occurs after insert/delete/clear or on window resize. Code tab selection changes active pseudocode block and highlighting lines is driven by operations. Challenge mode has sequence generation (ready), a started state (active), and a terminal state (complete); incorrect order inserts still proceed but print warnings. Node clicks trigger centering/highlight and info output regardless of other states unless the node elements are absent. Theme and meta toggles update UI instantly; meta toggling re-renders nodes to show/hide meta text."
    }
  },
  {
    "id": "94f8ce00-c465-11f0-af61-192d6dbad219",
    "timestamp": "2025-11-18T10:02:09.355Z",
    "model": "gpt-4o-mini",
    "status": "success",
    "question": "Queue",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interactive Queue Exploration</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f4f4f4;\n            margin: 0;\n            padding: 20px;\n        }\n        h1 {\n            text-align: center;\n            color: #333;\n        }\n        #queue-container {\n            display: flex;\n            justify-content: center;\n            margin: 20px 0;\n        }\n        .queue {\n            border: 2px solid #007bff;\n            border-radius: 10px;\n            background-color: #fff;\n            padding: 10px;\n            width: 300px;\n            overflow: hidden;\n            position: relative;\n        }\n        .queue-item {\n            padding: 10px;\n            border: 1px solid #007bff;\n            border-radius: 5px;\n            margin: 5px 0;\n            background-color: #e0f7fa;\n            transition: all 0.3s;\n        }\n        .queue-item.removing {\n            background-color: #ffebee;\n            opacity: 0.5;\n        }\n        #queue-controls {\n            display: flex;\n            justify-content: center;\n            margin-top: 10px;\n        }\n        button {\n            padding: 10px 20px;\n            margin: 0 5px;\n            border: none;\n            border-radius: 5px;\n            background-color: #007bff;\n            color: white;\n            cursor: pointer;\n            transition: background-color 0.2s;\n        }\n        button:hover {\n            background-color: #0056b3;\n        }\n        #output {\n            margin-top: 20px;\n            text-align: center;\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n\n    <h1>Explore the Queue Data Structure</h1>\n    <div id=\"queue-container\">\n        <div class=\"queue\" id=\"queue\">\n            <h2>Queue</h2>\n        </div>\n    </div>\n    \n    <div id=\"queue-controls\">\n        <input type=\"text\" id=\"inputValue\" placeholder=\"Enter a value\" />\n        <button onclick=\"enqueue()\">Enqueue</button>\n        <button onclick=\"dequeue()\">Dequeue</button>\n    </div>\n\n    <div id=\"output\"></div>\n\n    <script>\n        const queue = [];\n        const queueElement = document.getElementById(\"queue\");\n        const outputElement = document.getElementById(\"output\");\n        const inputValue = document.getElementById(\"inputValue\");\n\n        function updateQueueDisplay() {\n            queueElement.innerHTML = \"<h2>Queue</h2>\";\n            queue.forEach((item) => {\n                const div = document.createElement(\"div\");\n                div.className = \"queue-item\";\n                div.textContent = item;\n                queueElement.appendChild(div);\n            });\n        }\n\n        function enqueue() {\n            const value = inputValue.value;\n            if (value) {\n                queue.push(value);\n                inputValue.value = '';\n                updateQueueDisplay();\n                outputElement.textContent = `Enqueued: ${value}`;\n            } else {\n                alert(\"Please enter a value to enqueue.\");\n            }\n        }\n\n        function dequeue() {\n            if (queue.length > 0) {\n                const removed = queue.shift();\n                updateQueueDisplay();\n                outputElement.textContent = `Dequeued: ${removed}`;\n            } else {\n                alert(\"Queue is empty. Nothing to dequeue.\");\n            }\n        }\n    </script>\n\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a high-quality interactive HTML page that provides an in-depth, hands-on exploration of Queue.\nOnly return HTML code!"
      },
      {
        "role": "user",
        "content": "Queue"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Models the states and transitions of an interactive queue exploration application.",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "ENQUEUE": "updating",
            "DEQUEUE": "updating"
          }
        },
        {
          "name": "updating",
          "onEnter": "updateQueueDisplay",
          "onExit": "noop",
          "on": {
            "UPDATE_COMPLETE": "idle"
          }
        }
      ],
      "events": ["ENQUEUE", "DEQUEUE", "UPDATE_COMPLETE"],
      "notes": "The application transitions to 'updating' state when enqueue or dequeue actions are performed, and returns to 'idle' once the queue display is updated."
    }
  },
  {
    "id": "a296faf0-c465-11f0-af61-192d6dbad219",
    "timestamp": "2025-11-18T10:02:19.102Z",
    "model": "gpt-4o-mini",
    "status": "success",
    "question": "Linked List",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interactive Linked List Exploration</title>\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css\">\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f4f4f4;\n        }\n        h1 {\n            text-align: center;\n            color: #333;\n        }\n        #list {\n            display: flex;\n            justify-content: center;\n            margin-top: 20px;\n        }\n        .node {\n            width: 60px;\n            padding: 10px;\n            margin: 5px;\n            background-color: #fff;\n            border: 1px solid #555;\n            border-radius: 5px;\n            position: relative;\n            text-align: center;\n        }\n        .next {\n            position: absolute;\n            right: -20px;\n            top: 20px;\n        }\n        #controls {\n            text-align: center;\n            margin-top: 20px;\n        }\n        button {\n            padding: 10px 20px;\n            margin: 0 5px;\n            background-color: #007BFF;\n            color: white;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #0056b3;\n        }\n        #output {\n            margin-top: 20px;\n            text-align: center;\n            font-size: 18px;\n            color: #333;\n        }\n    </style>\n</head>\n<body>\n\n<h1>Interactive Linked List Explorer</h1>\n<div id=\"list\"></div>\n\n<div id=\"controls\">\n    <input type=\"text\" id=\"nodeValue\" placeholder=\"Node Value\">\n    <button id=\"addNode\">Add Node</button>\n    <button id=\"removeNode\">Remove Tail Node</button>\n</div>\n\n<div id=\"output\"></div>\n\n<script>\n    class Node {\n        constructor(value) {\n            this.value = value;\n            this.next = null;\n        }\n    }\n\n    class LinkedList {\n        constructor() {\n            this.head = null;\n        }\n\n        add(value) {\n            const newNode = new Node(value);\n            if (!this.head) {\n                this.head = newNode;\n            } else {\n                let current = this.head;\n                while (current.next) {\n                    current = current.next;\n                }\n                current.next = newNode;\n            }\n        }\n\n        remove() {\n            if (!this.head) return;\n            if (!this.head.next) {\n                this.head = null;\n                return;\n            }\n            let current = this.head;\n            while (current.next.next) {\n                current = current.next;\n            }\n            current.next = null;\n        }\n\n        display() {\n            const nodes = [];\n            let current = this.head;\n            while (current) {\n                nodes.push(current);\n                current = current.next;\n            }\n            return nodes;\n        }\n    }\n\n    const linkedList = new LinkedList();\n    \n    const renderList = () => {\n        const listDiv = document.getElementById('list');\n        listDiv.innerHTML = '';\n        const nodes = linkedList.display();\n        nodes.forEach(node => {\n            const nodeDiv = document.createElement('div');\n            nodeDiv.className = 'node';\n            nodeDiv.innerHTML = `${node.value} <span class=\"next\">‚Üí</span>`;\n            listDiv.appendChild(nodeDiv);\n        });\n    };\n\n    const addNode = () => {\n        const nodeValue = document.getElementById('nodeValue').value;\n        if (nodeValue) {\n            linkedList.add(nodeValue);\n            renderList();\n            document.getElementById('nodeValue').value = '';\n        }\n    };\n\n    const removeNode = () => {\n        linkedList.remove();\n        renderList();\n    };\n\n    document.getElementById('addNode').addEventListener('click', addNode);\n    document.getElementById('removeNode').addEventListener('click', removeNode);\n</script>\n\n</body>\n</html>\n``` \n\nThis HTML page provides an interactive user interface for exploring a Linked List. Users can add nodes by entering a value into an input field and clicking the \"Add Node\" button. They can also remove the tail node by clicking the \"Remove Tail Node\" button. The linked list structure is visualized dynamically as users interact with the application."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a high-quality interactive HTML page that provides an in-depth, hands-on exploration of Linked List.\nOnly return HTML code!"
      },
      {
        "role": "user",
        "content": "Linked List"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Finite state machine for the Interactive Linked List Explorer application.",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "ADD_NODE": "addingNode",
            "REMOVE_NODE": "removingNode"
          }
        },
        {
          "name": "addingNode",
          "onEnter": "addNode",
          "onExit": "noop",
          "on": {
            "NODE_ADDED": "idle"
          }
        },
        {
          "name": "removingNode",
          "onEnter": "removeNode",
          "onExit": "noop",
          "on": {
            "NODE_REMOVED": "idle"
          }
        }
      ],
      "events": ["ADD_NODE", "REMOVE_NODE", "NODE_ADDED", "NODE_REMOVED"],
      "notes": "States represent the main actions of adding and removing nodes in the linked list."
    }
  },
  {
    "id": "a8e6e2d0-c465-11f0-af61-192d6dbad219",
    "timestamp": "2025-11-18T10:02:40.137Z",
    "model": "gpt-4o-mini",
    "status": "success",
    "question": "K-Nearest Neighbors (KNN)",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>K-Nearest Neighbors (KNN) Exploration</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f4f4f4;\n        }\n        header {\n            text-align: center;\n            margin-bottom: 30px;\n        }\n        section {\n            display: flex;\n            justify-content: space-between;\n            margin-bottom: 30px;\n        }\n        article {\n            flex-basis: 60%;\n            padding: 20px;\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        aside {\n            flex-basis: 35%;\n            padding: 20px;\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        footer {\n            text-align: center;\n            margin-top: 30px;\n            font-size: 0.8em;\n        }\n        .button {\n            padding: 10px 15px;\n            background-color: #007bff;\n            color: white;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        .button:hover {\n            background-color: #0056b3;\n        }\n        #result {\n            margin-top: 20px;\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n\n<header>\n    <h1>K-Nearest Neighbors (KNN) Exploration</h1>\n</header>\n\n<section>\n    <article>\n        <h2>What is KNN?</h2>\n        <p>K-Nearest Neighbors (KNN) is a simple, yet powerful algorithm used for classification and regression tasks. It works by finding the 'K' closest training data points in the feature space and making predictions based on them.</p>\n\n        <h3>How does it work?</h3>\n        <ol>\n            <li>Choose the number of neighbors (K).</li>\n            <li>Calculate the distance between the new data point and all training points.</li>\n            <li>Sort the distances and select the K nearest neighbors.</li>\n            <li>For classification, perform a majority vote among the K neighbors. For regression, take the average of their values.</li>\n        </ol>\n\n        <h3>Interactive Visualization</h3>\n        <canvas id=\"knnCanvas\" width=\"400\" height=\"400\" style=\"border:1px solid #d3d3d3;\"></canvas>\n        <div id=\"result\"></div>\n        <button class=\"button\" id=\"classifyButton\">Classify Point</button>\n    </article>\n\n    <aside>\n        <h2>Set Parameters</h2>\n        <label for=\"kValue\">Choose K (number of neighbors):</label>\n        <input type=\"number\" id=\"kValue\" value=\"3\" min=\"1\" max=\"10\">\n        <h3>Data Points</h3>\n        <dl>\n            <dt>Green Points:</dt>\n            <dd>Class 1</dd>\n            <dt>Red Points:</dt>\n            <dd>Class 2</dd>\n        </dl>\n        <h3>Instructions</h3>\n        <p>Click on the canvas to place a new point, and then click on \"Classify Point\". Observe the results based on your K value.</p>\n    </aside>\n</section>\n\n<footer>\n    <p>&copy; 2023 KNN Interactive Exploration. All rights reserved.</p>\n</footer>\n\n<script>\n    const canvas = document.getElementById('knnCanvas');\n    const ctx = canvas.getContext('2d');\n    const kValueInput = document.getElementById('kValue');\n    const resultDiv = document.getElementById('result');\n\n    const greenPoints = [\n        { x: 50, y: 50 },\n        { x: 60, y: 70 },\n        { x: 55, y: 80 },\n        { x: 80, y: 55 },\n    ];\n\n    const redPoints = [\n        { x: 200, y: 200 },\n        { x: 210, y: 220 },\n        { x: 220, y: 210 },\n        { x: 230, y: 230 },\n    ];\n\n    function drawPoints() {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'green';\n        greenPoints.forEach(point => {\n            ctx.beginPath();\n            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n            ctx.fill();\n        });\n\n        ctx.fillStyle = 'red';\n        redPoints.forEach(point => {\n            ctx.beginPath();\n            ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\n            ctx.fill();\n        });\n    }\n\n    function classifyPoint(x, y) {\n        const k = parseInt(kValueInput.value);\n        const distances = [];\n\n        const allPoints = greenPoints.map(p => ({...p, class: 'Green'})).concat(redPoints.map(p => ({...p, class: 'Red'})));\n\n        allPoints.forEach(point => {\n            const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));\n            distances.push({ point: point, distance: distance });\n        });\n\n        distances.sort((a, b) => a.distance - b.distance);\n        \n        const neighbors = distances.slice(0, k);\n        const classVotes = {};\n\n        neighbors.forEach(neighbor => {\n            const cls = neighbor.point.class;\n            classVotes[cls] = (classVotes[cls] || 0) + 1;\n        });\n\n        const predictedClass = Object.keys(classVotes).reduce((a, b) => classVotes[a] > classVotes[b] ? a : b);\n        return predictedClass;\n    }\n\n    canvas.addEventListener('click', (event) => {\n        const rect = canvas.getBoundingClientRect();\n        const x = event.clientX - rect.left;\n        const y = event.clientY - rect.top;\n\n        const predictedClass = classifyPoint(x, y);\n        resultDiv.textContent = `Predicted Class: ${predictedClass}`;\n        ctx.fillStyle = 'blue';\n        ctx.beginPath();\n        ctx.arc(x, y, 5, 0, Math.PI * 2);\n        ctx.fill();\n    });\n\n    document.getElementById('classifyButton').addEventListener('click', () => {\n        const lastClick = ctx.lastClick;\n        if (lastClick) {\n            const predictedClass = classifyPoint(lastClick.x, lastClick.y);\n            resultDiv.textContent = `Predicted Class: ${predictedClass}`;\n        }\n    });\n\n    drawPoints();\n</script>\n</body>\n</html>\n```\n\nThis HTML code creates a user-friendly interactive page for exploring the K-Nearest Neighbors (KNN) algorithm. It includes a description of KNN, an interactive canvas for point classification based on user input, and sections to capture K values and explain the concept visually."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a high-quality interactive HTML page that provides an in-depth, hands-on exploration of K-Nearest Neighbors (KNN).\nOnly return HTML code!"
      },
      {
        "role": "user",
        "content": "K-Nearest Neighbors (KNN)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Finite state machine for K-Nearest Neighbors (KNN) exploration application.",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "CANVAS_CLICK": "point_selected"
          }
        },
        {
          "name": "point_selected",
          "onEnter": "draw_selected_point",
          "onExit": "noop",
          "on": {
            "CLASSIFY_BUTTON_CLICK": "classifying"
          }
        },
        {
          "name": "classifying",
          "onEnter": "display_classification_result",
          "onExit": "noop",
          "on": {
            "CANVAS_CLICK": "point_selected"
          }
        }
      ],
      "events": ["CANVAS_CLICK", "CLASSIFY_BUTTON_CLICK"],
      "notes": "The FSM captures the main interactive states of the KNN application, focusing on point selection and classification."
    }
  },
  {
    "id": "b5c80150-c465-11f0-af61-192d6dbad219",
    "timestamp": "2025-11-18T10:03:14.856Z",
    "model": "gpt-4o-mini",
    "status": "success",
    "question": "Stack",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interactive Stack Exploration</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f9f9f9;\n        }\n        h1 {\n            text-align: center;\n            color: #333;\n        }\n        .container {\n            max-width: 800px;\n            margin: 0 auto;\n            background: #fff;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n        }\n        #stack-container {\n            margin-bottom: 20px;\n            display: flex;\n            align-items: flex-end;\n            justify-content: center;\n            min-height: 200px;\n            border: 1px solid #ccc;\n            background: #e9ecef;\n            border-radius: 5px;\n        }\n        .stack-element {\n            background: #007bff;\n            color: white;\n            padding: 10px 15px;\n            margin: 5px;\n            border-radius: 4px;\n            transition: transform 0.2s;\n        }\n        .stack-element:hover {\n            transform: scale(1.1);\n        }\n        .controls {\n            display: flex;\n            justify-content: space-between;\n            margin-top: 20px;\n        }\n        .controls button {\n            padding: 10px 15px;\n            border: none;\n            border-radius: 5px;\n            background-color: #28a745;\n            color: white;\n            cursor: pointer;\n        }\n        .controls button:disabled {\n            background-color: #6c757d;\n        }\n        #result {\n            margin-top: 20px;\n            padding: 10px;\n            border: 1px solid #ccc;\n            border-radius: 5px;\n            background: #f1f1f1;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Interactive Stack Exploration</h1>\n        <div id=\"stack-container\"></div>\n        <div class=\"controls\">\n            <input type=\"text\" id=\"element-input\" placeholder=\"Enter element\" />\n            <button id=\"push-button\">Push</button>\n            <button id=\"pop-button\" disabled>Pop</button>\n        </div>\n        <div id=\"result\"></div>\n    </div>\n\n    <script>\n        let stack = [];\n        const stackContainer = document.getElementById('stack-container');\n        const resultDiv = document.getElementById('result');\n        const pushButton = document.getElementById('push-button');\n        const popButton = document.getElementById('pop-button');\n        const elementInput = document.getElementById('element-input');\n\n        function updateStackDisplay() {\n            stackContainer.innerHTML = '';\n            stack.forEach((element) => {\n                const stackElement = document.createElement('div');\n                stackElement.classList.add('stack-element');\n                stackElement.textContent = element;\n                stackContainer.appendChild(stackElement);\n            });\n\n            popButton.disabled = stack.length === 0;\n        }\n\n        pushButton.addEventListener('click', () => {\n            const element = elementInput.value.trim();\n            if (element) {\n                stack.push(element);\n                elementInput.value = '';\n                updateStackDisplay();\n                resultDiv.textContent = `\"${element}\" has been pushed onto the stack.`;\n            }\n        });\n\n        popButton.addEventListener('click', () => {\n            const poppedElement = stack.pop();\n            updateStackDisplay();\n            resultDiv.textContent = `\"${poppedElement}\" has been popped from the stack.`;\n        });\n    </script>\n</body>\n</html>\n```"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a high-quality interactive HTML page that provides an in-depth, hands-on exploration of Stack.\nOnly return HTML code!"
      },
      {
        "role": "user",
        "content": "Stack"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Finite state machine for an interactive stack exploration application.",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "PUSH_BUTTON_CLICKED": "element_entered",
            "POP_BUTTON_CLICKED": "noop"
          }
        },
        {
          "name": "element_entered",
          "onEnter": "updateStackDisplay",
          "onExit": "noop",
          "on": {
            "PUSH_BUTTON_CLICKED": "element_entered",
            "POP_BUTTON_CLICKED": "popping_element"
          }
        },
        {
          "name": "popping_element",
          "onEnter": "updateStackDisplay",
          "onExit": "noop",
          "on": {
            "PUSH_BUTTON_CLICKED": "element_entered",
            "POP_BUTTON_CLICKED": "noop"
          }
        }
      ],
      "events": ["PUSH_BUTTON_CLICKED", "POP_BUTTON_CLICKED"],
      "notes": "The application allows users to push and pop elements from a stack, with visual feedback on actions."
    }
  },
  {
    "id": "99fc38b0-c465-11f0-af61-192d6dbad219",
    "timestamp": "2025-11-18T10:03:15.560Z",
    "model": "gpt-4o-mini",
    "status": "success",
    "question": "Binary Search Tree (BST)",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interactive Binary Search Tree (BST) Exploration</title>\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css\">\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f4f4f4;\n            margin: 0;\n            padding: 20px;\n        }\n        h1 {\n            text-align: center;\n            color: #333;\n        }\n        #bst-visualization {\n            text-align: center;\n            margin: 20px 0;\n        }\n        #bst-visualization svg {\n            max-width: 100%;\n            height: auto;\n        }\n        #controls {\n            text-align: center;\n            margin: 20px 0;\n        }\n        input[type=\"number\"] {\n            padding: 10px;\n            margin: 0 5px;\n            width: 60px;\n        }\n        button {\n            padding: 10px 20px;\n            margin: 0 5px;\n            cursor: pointer;\n        }\n        #explanation {\n            margin-top: 20px;\n            background-color: #fff;\n            padding: 15px;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n    </style>\n</head>\n<body>\n\n<h1>Interactive Binary Search Tree (BST) Explorer</h1>\n\n<div id=\"bst-visualization\"></div>\n\n<div id=\"controls\">\n    <input type=\"number\" id=\"value\" placeholder=\"Enter a value\" />\n    <button onclick=\"insertNode()\">Insert Node</button>\n    <button onclick=\"deleteNode()\">Delete Node</button>\n</div>\n\n<div id=\"explanation\">\n    <h3>How Binary Search Trees Work:</h3>\n    <p>A binary search tree (BST) is a data structure that maintains sorted order. Each node has a value, and nodes to the left have lesser values while nodes to the right have greater values.</p>\n    <h4>Operations:</h4>\n    <ul>\n        <li><strong>Insertion:</strong> Adds a new value to the BST.</li>\n        <li><strong>Deletion:</strong> Removes a value from the BST.</li>\n        <li><strong>Traversal:</strong> Explore nodes in sorted order.</li>\n    </ul>\n</div>\n\n<script>\n    let bst = null;\n\n    class Node {\n        constructor(data) {\n            this.data = data;\n            this.left = null;\n            this.right = null;\n        }\n    }\n\n    function insert(data) {\n        const newNode = new Node(data);\n        if (bst === null) {\n            bst = newNode;\n        } else {\n            insertNode(bst, newNode);\n        }\n        drawBST();\n    }\n\n    function insertNode(root, newNode) {\n        if (newNode.data < root.data) {\n            if (root.left === null) {\n                root.left = newNode;\n            } else {\n                insertNode(root.left, newNode);\n            }\n        } else {\n            if (root.right === null) {\n                root.right = newNode;\n            } else {\n                insertNode(root.right, newNode);\n            }\n        }\n    }\n\n    function deleteNode() {\n        const value = parseInt(document.getElementById(\"value\").value);\n        bst = deleteNodeUtil(bst, value);\n        drawBST();\n    }\n\n    function deleteNodeUtil(root, key) {\n        if (root === null) return root;\n\n        if (key < root.data) {\n            root.left = deleteNodeUtil(root.left, key);\n        } else if (key > root.data) {\n            root.right = deleteNodeUtil(root.right, key);\n        } else {\n            if (root.left === null) return root.right;\n            else if (root.right === null) return root.left;\n\n            root.data = findMin(root.right).data;\n            root.right = deleteNodeUtil(root.right, root.data);\n        }\n        return root;\n    }\n\n    function findMin(root) {\n        while (root.left !== null) root = root.left;\n        return root;\n    }\n\n    function drawBST() {\n        const svg = d3.select(\"#bst-visualization\").html(\"\").append(\"svg\")\n            .attr(\"width\", 600)\n            .attr(\"height\", 400);\n\n        drawNode(bst, svg, 300, 20, 150);\n    }\n\n    function drawNode(node, svg, x, y, offset) {\n        if (node === null) return;\n\n        svg.append(\"circle\")\n            .attr(\"cx\", x)\n            .attr(\"cy\", y)\n            .attr(\"r\", 20)\n            .attr(\"fill\", \"#7cb342\");\n\n        svg.append(\"text\")\n            .attr(\"x\", x)\n            .attr(\"y\", y + 5)\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"fill\", \"#fff\")\n            .text(node.data);\n\n        if (node.left !== null) {\n            svg.append(\"line\")\n                .attr(\"x1\", x)\n                .attr(\"y1\", y + 20)\n                .attr(\"x2\", x - offset)\n                .attr(\"y2\", y + 80)\n                .attr(\"stroke\", \"#000\");\n\n            drawNode(node.left, svg, x - offset, y + 80, offset / 2);\n        }\n\n        if (node.right !== null) {\n            svg.append(\"line\")\n                .attr(\"x1\", x)\n                .attr(\"y1\", y + 20)\n                .attr(\"x2\", x + offset)\n                .attr(\"y2\", y + 80)\n                .attr(\"stroke\", \"#000\");\n\n            drawNode(node.right, svg, x + offset, y + 80, offset / 2);\n        }\n    }\n\n    function insertNode() {\n        const value = parseInt(document.getElementById(\"value\").value);\n        insert(value);\n        document.getElementById(\"value\").value = '';\n    }\n</script>\n\n<script src=\"https://d3js.org/d3.v7.min.js\"></script>\n</body>\n</html>\n```\n"
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a high-quality interactive HTML page that provides an in-depth, hands-on exploration of Binary Search Tree (BST).\nOnly return HTML code!"
      },
      {
        "role": "user",
        "content": "Binary Search Tree (BST)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Finite state machine for an Interactive Binary Search Tree (BST) exploration application.",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "INSERT_NODE": "inserting",
            "DELETE_NODE": "deleting"
          }
        },
        {
          "name": "inserting",
          "onEnter": "drawBST",
          "onExit": "noop",
          "on": {
            "NODE_INSERTED": "idle"
          }
        },
        {
          "name": "deleting",
          "onEnter": "drawBST",
          "onExit": "noop",
          "on": {
            "NODE_DELETED": "idle"
          }
        }
      ],
      "events": ["INSERT_NODE", "DELETE_NODE", "NODE_INSERTED", "NODE_DELETED"],
      "notes": "The application allows users to insert and delete nodes in a binary search tree, with visual feedback provided through SVG rendering."
    }
  },
  {
    "id": "ba5a33a0-c465-11f0-af61-192d6dbad219",
    "timestamp": "2025-11-18T10:03:23.586Z",
    "model": "gpt-4o-mini",
    "status": "success",
    "question": "Bubble Sort",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interactive Bubble Sort Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            background-color: #f4f4f4;\n            margin: 0;\n            padding: 20px;\n        }\n\n        h1 {\n            color: #333;\n        }\n\n        #array-container {\n            display: flex;\n            justify-content: center;\n            padding: 20px;\n            margin: 20px 0;\n            border: 2px solid #008cba;\n            background-color: #fff;\n        }\n\n        .bar {\n            width: 30px;\n            margin: 0 2px;\n            background-color: #4caf50;\n            display: inline-block;\n            transition: height 0.5s;\n        }\n\n        #controls {\n            margin: 20px;\n        }\n\n        button {\n            padding: 10px 15px;\n            border: none;\n            background-color: #007bff;\n            color: white;\n            cursor: pointer;\n            font-size: 16px;\n            margin: 5px;\n        }\n\n        button:hover {\n            background-color: #0056b3;\n        }\n\n        #info {\n            margin-top: 20px;\n            font-size: 18px;\n            color: #555;\n        }\n    </style>\n</head>\n<body>\n\n    <h1>Interactive Bubble Sort Visualization</h1>\n\n    <div id=\"array-container\"></div>\n\n    <div id=\"controls\">\n        <button id=\"generate\">Generate Random Array</button>\n        <button id=\"sort\">Sort Array</button>\n        <button id=\"reset\">Reset</button>\n    </div>\n\n    <div id=\"info\">Click \"Generate Random Array\" to create a new array and then \"Sort Array\" to visualize the Bubble Sort algorithm.</div>\n\n    <script>\n        const arrayContainer = document.getElementById('array-container');\n        const generateButton = document.getElementById('generate');\n        const sortButton = document.getElementById('sort');\n        const resetButton = document.getElementById('reset');\n\n        let array = [];\n\n        function generateRandomArray(size = 10) {\n            array = Array.from({ length: size }, () => Math.floor(Math.random() * 100) + 1);\n            renderArray();\n        }\n\n        function renderArray() {\n            arrayContainer.innerHTML = '';\n            array.forEach(value => {\n                const bar = document.createElement('div');\n                bar.classList.add('bar');\n                bar.style.height = `${value * 3}px`;\n                bar.title = value;\n                arrayContainer.appendChild(bar);\n            });\n        }\n\n        async function bubbleSort() {\n            const n = array.length;\n            for (let i = 0; i < n - 1; i++) {\n                for (let j = 0; j < n - i - 1; j++) {\n                    if (array[j] > array[j + 1]) {\n                        // Swap\n                        [array[j], array[j + 1]] = [array[j + 1], array[j]];\n                        renderArray();\n                        await new Promise(resolve => setTimeout(resolve, 500));\n                    }\n                }\n            }\n            renderArray();\n        }\n\n        generateButton.addEventListener('click', () => {\n            generateRandomArray();\n        });\n\n        sortButton.addEventListener('click', () => {\n            if (array.length > 0) {\n                bubbleSort();\n            } else {\n                alert('Generate an array first!');\n            }\n        });\n\n        resetButton.addEventListener('click', () => {\n            array = [];\n            arrayContainer.innerHTML = '';\n        });\n\n        // Initial array generation\n        generateRandomArray();\n    </script>\n</body>\n</html>\n``` \n\nThis code provides a fully interactive Bubble Sort visualization page. It includes buttons to generate random arrays, sort the array using the Bubble Sort algorithm, and reset the visualization. The array elements are represented as bars, which visually demonstrate the sorting process."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a high-quality interactive HTML page that provides an in-depth, hands-on exploration of Bubble Sort.\nOnly return HTML code!"
      },
      {
        "role": "user",
        "content": "Bubble Sort"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Finite state machine for the interactive bubble sort visualization application.",
      "states": [
        {
          "name": "idle",
          "onEnter": "generateRandomArray",
          "onExit": "noop",
          "on": {
            "GENERATE_RANDOM_ARRAY": "array_generated",
            "SORT_ARRAY": "alert_no_array",
            "RESET": "idle"
          }
        },
        {
          "name": "array_generated",
          "onEnter": "renderArray",
          "onExit": "noop",
          "on": {
            "SORT_ARRAY": "sorting",
            "RESET": "idle"
          }
        },
        {
          "name": "sorting",
          "onEnter": "bubbleSort",
          "onExit": "noop",
          "on": {
            "SORT_COMPLETE": "array_sorted",
            "RESET": "idle"
          }
        },
        {
          "name": "array_sorted",
          "onEnter": "renderArray",
          "onExit": "noop",
          "on": {
            "GENERATE_RANDOM_ARRAY": "array_generated",
            "RESET": "idle"
          }
        },
        {
          "name": "alert_no_array",
          "onEnter": "alertUser",
          "onExit": "noop",
          "on": {
            "GENERATE_RANDOM_ARRAY": "array_generated",
            "RESET": "idle"
          }
        }
      ],
      "events": [
        "GENERATE_RANDOM_ARRAY",
        "SORT_ARRAY",
        "RESET",
        "SORT_COMPLETE"
      ],
      "notes": "The FSM captures the states of generating an array, sorting it, and handling user interactions."
    }
  },
  {
    "id": "cda85ef0-c465-11f0-af61-192d6dbad219",
    "timestamp": "2025-11-18T10:03:44.076Z",
    "model": "gpt-4o-mini",
    "status": "success",
    "question": "Heap (Min/Max)",
    "answer": {
      "role": "assistant",
      "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interactive Heap Exploration</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f4f4f4;\n        }\n        h1 {\n            color: #333;\n        }\n        .container {\n            max-width: 800px;\n            margin: auto;\n            background: #fff;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n        }\n        .heap {\n            margin-top: 20px;\n            padding: 10px;\n            position: relative;\n            overflow: hidden;\n            min-height: 200px;\n        }\n        .node {\n            background: #6495ED;\n            color: white;\n            border-radius: 50%;\n            width: 40px;\n            height: 40px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            position: absolute;\n            transition: all 0.3s;\n        }\n        .button {\n            margin-top: 15px;\n            padding: 10px 15px;\n            background: #28a745;\n            color: white;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n        }\n        .button:hover {\n            background: #218838;\n        }\n        .controls {\n            margin-top: 20px;\n        }\n        input[type=\"number\"] {\n            padding: 10px;\n            width: 60px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Interactive Heap (Min/Max) Exploration</h1>\n        <p>Learn about Min and Max Heaps through interactive visualizations.</p>\n\n        <div class=\"controls\">\n            <label for=\"value\">Enter a value:</label>\n            <input type=\"number\" id=\"value\" placeholder=\"Value\">\n            <button id=\"insert\" class=\"button\">Insert</button>\n            <button id=\"remove\" class=\"button\">Remove Root</button>\n        </div>\n\n        <div class=\"heap\" id=\"heapVisual\"></div>\n        \n        <div id=\"heapOutput\" style=\"margin-top: 20px;\"></div>\n    </div>\n\n    <script>\n        class MinMaxHeap {\n            constructor() {\n                this.heap = [];\n            }\n\n            insert(value) {\n                this.heap.push(value);\n                this.bubbleUp(this.heap.length - 1);\n                this.updateHeapVisual();\n            }\n\n            remove() {\n                if (this.heap.length === 0) return null;\n                const minOrMax = this.heap[0];\n                this.heap[0] = this.heap.pop();\n                this.bubbleDown(0);\n                this.updateHeapVisual();\n                return minOrMax;\n            }\n\n            bubbleUp(index) {\n                const element = this.heap[index];\n                let parentIndex = Math.floor((index - 1) / 2);\n\n                while (index > 0 && this.heap[parentIndex] > element) {\n                    this.heap[index] = this.heap[parentIndex];\n                    index = parentIndex;\n                    parentIndex = Math.floor((index - 1) / 2);\n                }\n                this.heap[index] = element;\n            }\n\n            bubbleDown(index) {\n                const length = this.heap.length;\n                const element = this.heap[index];\n                \n                while (true) {\n                    let leftChildIndex = 2 * index + 1;\n                    let rightChildIndex = 2 * index + 2;\n                    let leftChild, rightChild;\n                    let swap = null;\n\n                    if (leftChildIndex < length) {\n                        leftChild = this.heap[leftChildIndex];\n                        if (leftChild < element) swap = leftChildIndex;\n                    }\n                    if (rightChildIndex < length) {\n                        rightChild = this.heap[rightChildIndex];\n                        if ((swap === null && rightChild < element) ||\n                            (swap !== null && rightChild < leftChild)) {\n                            swap = rightChildIndex;\n                        }\n                    }\n                    if (swap === null) break;\n                    this.heap[index] = this.heap[swap];\n                    index = swap;\n                }\n                this.heap[index] = element;\n            }\n\n            updateHeapVisual() {\n                const visual = document.getElementById('heapVisual');\n                visual.innerHTML = '';\n                const height = this.getHeapHeight();\n                const levelNodes = Math.pow(2, height) - 1;\n                let nodeHeight = 40;\n\n                this.heap.forEach((value, index) => {\n                    const node = document.createElement('div');\n                    node.className = 'node';\n                    node.style.left = `${(index % levelNodes) * 50}px`;\n                    node.style.top = `${Math.floor(index / levelNodes) * nodeHeight}px`;\n                    node.innerText = value;\n                    visual.appendChild(node);\n                });\n            }\n\n            getHeapHeight() {\n                return Math.ceil(Math.log2(this.heap.length + 1)); \n            }\n        }\n\n        const heap = new MinMaxHeap();\n\n        document.getElementById('insert').addEventListener('click', () => {\n            const value = parseInt(document.getElementById('value').value);\n            if (!isNaN(value)) {\n                heap.insert(value);\n                document.getElementById('value').value = '';\n                document.getElementById('heapOutput').innerText = '';\n            }\n        });\n\n        document.getElementById('remove').addEventListener('click', () => {\n            const removedValue = heap.remove();\n            if (removedValue !== null) {\n                document.getElementById('heapOutput').innerText = `Removed: ${removedValue}`;\n            } else {\n                document.getElementById('heapOutput').innerText = \"Heap is empty.\";\n            }\n        });\n    </script>\n</body>\n</html>\n``` \n\nThis HTML code provides a simple interactive interface for exploring Min/Max Heaps. Users can insert values into the heap and remove the root, visualizing the heap structure in real-time."
    },
    "messages": [
      {
        "role": "system",
        "content": "You are an expert in interactive web design and front-end pedagogy. Please design a high-quality interactive HTML page that provides an in-depth, hands-on exploration of Heap (Min/Max).\nOnly return HTML code!"
      },
      {
        "role": "user",
        "content": "Heap (Min/Max)"
      }
    ],
    "evaluation": {
      "score": null,
      "notes": ""
    },
    "topic": null,
    "hasFSM": true,
    "hasTest": true,
    "fsm": {
      "topic": "Interactive Application",
      "description": "Finite state machine for an interactive heap exploration application.",
      "states": [
        {
          "name": "idle",
          "onEnter": "noop",
          "onExit": "noop",
          "on": {
            "INSERT_BUTTON_CLICKED": "inserting",
            "REMOVE_BUTTON_CLICKED": "removing"
          }
        },
        {
          "name": "inserting",
          "onEnter": "updateHeapVisual",
          "onExit": "noop",
          "on": {
            "INSERT_COMPLETE": "idle"
          }
        },
        {
          "name": "removing",
          "onEnter": "updateHeapVisual",
          "onExit": "noop",
          "on": {
            "REMOVE_COMPLETE": "idle"
          }
        }
      ],
      "events": [
        "INSERT_BUTTON_CLICKED",
        "REMOVE_BUTTON_CLICKED",
        "INSERT_COMPLETE",
        "REMOVE_COMPLETE"
      ],
      "notes": "States represent the main actions of inserting and removing values from the heap, with transitions based on button clicks and completion of actions."
    }
  }
]
