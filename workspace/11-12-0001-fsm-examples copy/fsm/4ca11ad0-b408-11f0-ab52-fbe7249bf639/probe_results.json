{
  "timestamp": "2025-11-19T02:42:19.346Z",
  "html_file": "4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
  "probe_results": [
    {
      "component": {
        "type": "input",
        "id": "nodeValue",
        "selector": "#nodeValue",
        "attributes": {
          "type": "number",
          "placeholder": "Enter a number",
          "value": "",
          "required": false
        },
        "position": {
          "x": 428.984375,
          "y": 137.875,
          "width": 215,
          "height": 38,
          "top": 137.875,
          "right": 643.984375,
          "bottom": 175.875,
          "left": 428.984375
        }
      },
      "action": "fill",
      "value": "",
      "beforeState": "S1_before_input_nodeValue_empty",
      "afterState": "S2_after_input_nodeValue_empty",
      "changes": {
        "hasSignificantChange": false,
        "changeTypes": [],
        "details": {}
      },
      "success": true
    },
    {
      "component": {
        "type": "input",
        "id": "nodeValue",
        "selector": "#nodeValue",
        "attributes": {
          "type": "number",
          "placeholder": "Enter a number",
          "value": "",
          "required": false
        },
        "position": {
          "x": 428.984375,
          "y": 137.875,
          "width": 215,
          "height": 38,
          "top": 137.875,
          "right": 643.984375,
          "bottom": 175.875,
          "left": 428.984375
        }
      },
      "action": "fill",
      "value": "10",
      "beforeState": "S3_before_input_nodeValue_10",
      "afterState": "S4_after_input_nodeValue_10",
      "changes": {
        "hasSignificantChange": true,
        "changeTypes": [
          "form_value_change"
        ],
        "details": {
          "formChanges": [
            {
              "id": "nodeValue",
              "before": "",
              "after": "10"
            }
          ]
        }
      },
      "success": true
    },
    {
      "component": {
        "type": "input",
        "id": "nodeValue",
        "selector": "#nodeValue",
        "attributes": {
          "type": "number",
          "placeholder": "Enter a number",
          "value": "",
          "required": false
        },
        "position": {
          "x": 428.984375,
          "y": 137.875,
          "width": 215,
          "height": 38,
          "top": 137.875,
          "right": 643.984375,
          "bottom": 175.875,
          "left": 428.984375
        }
      },
      "action": "fill",
      "value": "50",
      "beforeState": "S5_before_input_nodeValue_50",
      "afterState": "S6_after_input_nodeValue_50",
      "changes": {
        "hasSignificantChange": true,
        "changeTypes": [
          "form_value_change"
        ],
        "details": {
          "formChanges": [
            {
              "id": "nodeValue",
              "before": "10",
              "after": "50"
            }
          ]
        }
      },
      "success": true
    },
    {
      "component": {
        "type": "input",
        "id": "nodeValue",
        "selector": "#nodeValue",
        "attributes": {
          "type": "number",
          "placeholder": "Enter a number",
          "value": "",
          "required": false
        },
        "position": {
          "x": 428.984375,
          "y": 137.875,
          "width": 215,
          "height": 38,
          "top": 137.875,
          "right": 643.984375,
          "bottom": 175.875,
          "left": 428.984375
        }
      },
      "action": "fill",
      "value": "abc",
      "success": false,
      "error": "page.fill: Error: Cannot type text into input[type=number]\nCall log:\n\u001b[2m  - waiting for locator('#nodeValue')\u001b[22m\n\u001b[2m    - locator resolved to <input type=\"number\" id=\"nodeValue\" class=\"input-number\" placeholder=\"Enter a number\"/>\u001b[22m\n\u001b[2m    - fill(\"abc\")\u001b[22m\n\u001b[2m  - attempting fill action\u001b[22m\n\u001b[2m    - waiting for element to be visible, enabled and editable\u001b[22m\n"
    },
    {
      "component": {
        "type": "input",
        "id": "nodeValue",
        "selector": "#nodeValue",
        "attributes": {
          "type": "number",
          "placeholder": "Enter a number",
          "value": "",
          "required": false
        },
        "position": {
          "x": 428.984375,
          "y": 137.875,
          "width": 215,
          "height": 38,
          "top": 137.875,
          "right": 643.984375,
          "bottom": 175.875,
          "left": 428.984375
        }
      },
      "action": "fill",
      "value": "999",
      "beforeState": "S8_before_input_nodeValue_999",
      "afterState": "S9_after_input_nodeValue_999",
      "changes": {
        "hasSignificantChange": true,
        "changeTypes": [
          "form_value_change"
        ],
        "details": {
          "formChanges": [
            {
              "id": "nodeValue",
              "before": "50",
              "after": "999"
            }
          ]
        }
      },
      "success": true
    },
    {
      "component": {
        "type": "button",
        "id": "button_1",
        "selector": "button:nth-child(2)",
        "text": "Reset Tree",
        "attributes": {
          "type": "submit",
          "disabled": false
        },
        "position": {
          "x": 761.8125,
          "y": 141.875,
          "width": 89.203125,
          "height": 31,
          "top": 141.875,
          "right": 851.015625,
          "bottom": 172.875,
          "left": 761.8125
        }
      },
      "action": "click",
      "beforeState": "S10_before_click_button_1",
      "afterState": "S11_after_click_button_1",
      "changes": {
        "hasSignificantChange": false,
        "changeTypes": [],
        "details": {}
      },
      "success": true
    }
  ],
  "state_captures": [
    {
      "id": "S0_Initial",
      "timestamp": 1763520123711,
      "name": "Initial",
      "url": "file:///D:/largeProjects/CS-Capstone/capstone/workspace/11-12-0001-fsm-examples%20copy/html/4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
      "title": "Interactive Binary Search Tree",
      "elementCounts": {
        "total": 17,
        "visible": 10,
        "buttons": 2,
        "inputs": 1,
        "nodes": 0
      },
      "visualElements": [],
      "formElements": [
        {
          "id": "nodeValue",
          "type": "number",
          "value": "",
          "disabled": false,
          "focused": false
        }
      ],
      "buttonElements": [
        {
          "id": "",
          "text": "Insert Node",
          "disabled": false,
          "visible": true
        },
        {
          "id": "",
          "text": "Reset Tree",
          "disabled": false,
          "visible": true
        }
      ],
      "textContent": [
        "Interactive Binary Search Tree (BST)\n        Understand the structure and function of a Binary Search Tree through hands-on interaction.\n\n        \n            \n            Insert Node\n            Reset Tree",
        "Interactive Binary Search Tree (BST)",
        "Understand the structure and function of a Binary Search Tree through hands-on interaction.",
        "Insert Node\n            Reset Tree",
        "Insert Node",
        "Reset Tree",
        "class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }",
        "{\n  \"topic\": \"Interactive Application\",\n  \"description\": \"Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.\",\n  \"states\": [\n    {\n      \"name\": \"idle\",\n      \"onEnter\": \"set_idle\",\n      \"on\": {\n        \"CLICK_INSERT\": \"validating_input\",\n        \"CLICK_RESET\": \"tree_resetting\"\n      }\n    },\n    {\n      \"name\": \"validating_input\",\n      \"onEnter\": \"parse_input_and_validate\",\n      \"on\": {\n        \"INPUT_INVALID\": \"error_alert\",\n        \"INPUT_VALID\": \"inserting_node\"\n      }\n    },\n    {\n      \"name\": \"error_alert\",\n      \"onEnter\": \"alert_invalid_number\",\n      \"on\": {\n        \"ALERT_DISMISSED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"inserting_node\",\n      \"onEnter\": \"perform_bst_insert\",\n      \"on\": {\n        \"BST_INSERTED\": \"drawing_tree\"\n      }\n    },\n    {\n      \"name\": \"drawing_tree\",\n      \"onEnter\": \"render_bst\",\n      \"on\": {\n        \"TREE_RENDERED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"tree_resetting\",\n      \"onEnter\": \"reset_bst\",\n      \"on\": {\n        \"RESET_DONE\": \"idle\"\n      }\n    }\n  ],\n  \"events\": [\n    \"CLICK_INSERT\",\n    \"CLICK_RESET\",\n    \"INPUT_VALID\",\n    \"INPUT_INVALID\",\n    \"ALERT_DISMISSED\",\n    \"BST_INSERTED\",\n    \"TREE_RENDERED\",\n    \"RESET_DONE\"\n  ],\n  \"notes\": \"Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity.\"\n}"
      ]
    },
    {
      "id": "S1_before_input_nodeValue_empty",
      "timestamp": 1763520126008,
      "name": "before_input_nodeValue_empty",
      "url": "file:///D:/largeProjects/CS-Capstone/capstone/workspace/11-12-0001-fsm-examples%20copy/html/4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
      "title": "Interactive Binary Search Tree",
      "elementCounts": {
        "total": 17,
        "visible": 10,
        "buttons": 2,
        "inputs": 1,
        "nodes": 0
      },
      "visualElements": [],
      "formElements": [
        {
          "id": "nodeValue",
          "type": "number",
          "value": "",
          "disabled": false,
          "focused": false
        }
      ],
      "buttonElements": [
        {
          "id": "",
          "text": "Insert Node",
          "disabled": false,
          "visible": true
        },
        {
          "id": "",
          "text": "Reset Tree",
          "disabled": false,
          "visible": true
        }
      ],
      "textContent": [
        "Interactive Binary Search Tree (BST)\n        Understand the structure and function of a Binary Search Tree through hands-on interaction.\n\n        \n            \n            Insert Node\n            Reset Tree",
        "Interactive Binary Search Tree (BST)",
        "Understand the structure and function of a Binary Search Tree through hands-on interaction.",
        "Insert Node\n            Reset Tree",
        "Insert Node",
        "Reset Tree",
        "class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }",
        "{\n  \"topic\": \"Interactive Application\",\n  \"description\": \"Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.\",\n  \"states\": [\n    {\n      \"name\": \"idle\",\n      \"onEnter\": \"set_idle\",\n      \"on\": {\n        \"CLICK_INSERT\": \"validating_input\",\n        \"CLICK_RESET\": \"tree_resetting\"\n      }\n    },\n    {\n      \"name\": \"validating_input\",\n      \"onEnter\": \"parse_input_and_validate\",\n      \"on\": {\n        \"INPUT_INVALID\": \"error_alert\",\n        \"INPUT_VALID\": \"inserting_node\"\n      }\n    },\n    {\n      \"name\": \"error_alert\",\n      \"onEnter\": \"alert_invalid_number\",\n      \"on\": {\n        \"ALERT_DISMISSED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"inserting_node\",\n      \"onEnter\": \"perform_bst_insert\",\n      \"on\": {\n        \"BST_INSERTED\": \"drawing_tree\"\n      }\n    },\n    {\n      \"name\": \"drawing_tree\",\n      \"onEnter\": \"render_bst\",\n      \"on\": {\n        \"TREE_RENDERED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"tree_resetting\",\n      \"onEnter\": \"reset_bst\",\n      \"on\": {\n        \"RESET_DONE\": \"idle\"\n      }\n    }\n  ],\n  \"events\": [\n    \"CLICK_INSERT\",\n    \"CLICK_RESET\",\n    \"INPUT_VALID\",\n    \"INPUT_INVALID\",\n    \"ALERT_DISMISSED\",\n    \"BST_INSERTED\",\n    \"TREE_RENDERED\",\n    \"RESET_DONE\"\n  ],\n  \"notes\": \"Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity.\"\n}"
      ]
    },
    {
      "id": "S2_after_input_nodeValue_empty",
      "timestamp": 1763520126360,
      "name": "after_input_nodeValue_empty",
      "url": "file:///D:/largeProjects/CS-Capstone/capstone/workspace/11-12-0001-fsm-examples%20copy/html/4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
      "title": "Interactive Binary Search Tree",
      "elementCounts": {
        "total": 17,
        "visible": 10,
        "buttons": 2,
        "inputs": 1,
        "nodes": 0
      },
      "visualElements": [],
      "formElements": [
        {
          "id": "nodeValue",
          "type": "number",
          "value": "",
          "disabled": false,
          "focused": true
        }
      ],
      "buttonElements": [
        {
          "id": "",
          "text": "Insert Node",
          "disabled": false,
          "visible": true
        },
        {
          "id": "",
          "text": "Reset Tree",
          "disabled": false,
          "visible": true
        }
      ],
      "textContent": [
        "Interactive Binary Search Tree (BST)\n        Understand the structure and function of a Binary Search Tree through hands-on interaction.\n\n        \n            \n            Insert Node\n            Reset Tree",
        "Interactive Binary Search Tree (BST)",
        "Understand the structure and function of a Binary Search Tree through hands-on interaction.",
        "Insert Node\n            Reset Tree",
        "Insert Node",
        "Reset Tree",
        "class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }",
        "{\n  \"topic\": \"Interactive Application\",\n  \"description\": \"Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.\",\n  \"states\": [\n    {\n      \"name\": \"idle\",\n      \"onEnter\": \"set_idle\",\n      \"on\": {\n        \"CLICK_INSERT\": \"validating_input\",\n        \"CLICK_RESET\": \"tree_resetting\"\n      }\n    },\n    {\n      \"name\": \"validating_input\",\n      \"onEnter\": \"parse_input_and_validate\",\n      \"on\": {\n        \"INPUT_INVALID\": \"error_alert\",\n        \"INPUT_VALID\": \"inserting_node\"\n      }\n    },\n    {\n      \"name\": \"error_alert\",\n      \"onEnter\": \"alert_invalid_number\",\n      \"on\": {\n        \"ALERT_DISMISSED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"inserting_node\",\n      \"onEnter\": \"perform_bst_insert\",\n      \"on\": {\n        \"BST_INSERTED\": \"drawing_tree\"\n      }\n    },\n    {\n      \"name\": \"drawing_tree\",\n      \"onEnter\": \"render_bst\",\n      \"on\": {\n        \"TREE_RENDERED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"tree_resetting\",\n      \"onEnter\": \"reset_bst\",\n      \"on\": {\n        \"RESET_DONE\": \"idle\"\n      }\n    }\n  ],\n  \"events\": [\n    \"CLICK_INSERT\",\n    \"CLICK_RESET\",\n    \"INPUT_VALID\",\n    \"INPUT_INVALID\",\n    \"ALERT_DISMISSED\",\n    \"BST_INSERTED\",\n    \"TREE_RENDERED\",\n    \"RESET_DONE\"\n  ],\n  \"notes\": \"Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity.\"\n}"
      ]
    },
    {
      "id": "S3_before_input_nodeValue_10",
      "timestamp": 1763520126439,
      "name": "before_input_nodeValue_10",
      "url": "file:///D:/largeProjects/CS-Capstone/capstone/workspace/11-12-0001-fsm-examples%20copy/html/4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
      "title": "Interactive Binary Search Tree",
      "elementCounts": {
        "total": 17,
        "visible": 10,
        "buttons": 2,
        "inputs": 1,
        "nodes": 0
      },
      "visualElements": [],
      "formElements": [
        {
          "id": "nodeValue",
          "type": "number",
          "value": "",
          "disabled": false,
          "focused": true
        }
      ],
      "buttonElements": [
        {
          "id": "",
          "text": "Insert Node",
          "disabled": false,
          "visible": true
        },
        {
          "id": "",
          "text": "Reset Tree",
          "disabled": false,
          "visible": true
        }
      ],
      "textContent": [
        "Interactive Binary Search Tree (BST)\n        Understand the structure and function of a Binary Search Tree through hands-on interaction.\n\n        \n            \n            Insert Node\n            Reset Tree",
        "Interactive Binary Search Tree (BST)",
        "Understand the structure and function of a Binary Search Tree through hands-on interaction.",
        "Insert Node\n            Reset Tree",
        "Insert Node",
        "Reset Tree",
        "class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }",
        "{\n  \"topic\": \"Interactive Application\",\n  \"description\": \"Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.\",\n  \"states\": [\n    {\n      \"name\": \"idle\",\n      \"onEnter\": \"set_idle\",\n      \"on\": {\n        \"CLICK_INSERT\": \"validating_input\",\n        \"CLICK_RESET\": \"tree_resetting\"\n      }\n    },\n    {\n      \"name\": \"validating_input\",\n      \"onEnter\": \"parse_input_and_validate\",\n      \"on\": {\n        \"INPUT_INVALID\": \"error_alert\",\n        \"INPUT_VALID\": \"inserting_node\"\n      }\n    },\n    {\n      \"name\": \"error_alert\",\n      \"onEnter\": \"alert_invalid_number\",\n      \"on\": {\n        \"ALERT_DISMISSED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"inserting_node\",\n      \"onEnter\": \"perform_bst_insert\",\n      \"on\": {\n        \"BST_INSERTED\": \"drawing_tree\"\n      }\n    },\n    {\n      \"name\": \"drawing_tree\",\n      \"onEnter\": \"render_bst\",\n      \"on\": {\n        \"TREE_RENDERED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"tree_resetting\",\n      \"onEnter\": \"reset_bst\",\n      \"on\": {\n        \"RESET_DONE\": \"idle\"\n      }\n    }\n  ],\n  \"events\": [\n    \"CLICK_INSERT\",\n    \"CLICK_RESET\",\n    \"INPUT_VALID\",\n    \"INPUT_INVALID\",\n    \"ALERT_DISMISSED\",\n    \"BST_INSERTED\",\n    \"TREE_RENDERED\",\n    \"RESET_DONE\"\n  ],\n  \"notes\": \"Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity.\"\n}"
      ]
    },
    {
      "id": "S4_after_input_nodeValue_10",
      "timestamp": 1763520126793,
      "name": "after_input_nodeValue_10",
      "url": "file:///D:/largeProjects/CS-Capstone/capstone/workspace/11-12-0001-fsm-examples%20copy/html/4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
      "title": "Interactive Binary Search Tree",
      "elementCounts": {
        "total": 17,
        "visible": 10,
        "buttons": 2,
        "inputs": 1,
        "nodes": 0
      },
      "visualElements": [],
      "formElements": [
        {
          "id": "nodeValue",
          "type": "number",
          "value": "10",
          "disabled": false,
          "focused": true
        }
      ],
      "buttonElements": [
        {
          "id": "",
          "text": "Insert Node",
          "disabled": false,
          "visible": true
        },
        {
          "id": "",
          "text": "Reset Tree",
          "disabled": false,
          "visible": true
        }
      ],
      "textContent": [
        "Interactive Binary Search Tree (BST)\n        Understand the structure and function of a Binary Search Tree through hands-on interaction.\n\n        \n            \n            Insert Node\n            Reset Tree",
        "Interactive Binary Search Tree (BST)",
        "Understand the structure and function of a Binary Search Tree through hands-on interaction.",
        "Insert Node\n            Reset Tree",
        "Insert Node",
        "Reset Tree",
        "class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }",
        "{\n  \"topic\": \"Interactive Application\",\n  \"description\": \"Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.\",\n  \"states\": [\n    {\n      \"name\": \"idle\",\n      \"onEnter\": \"set_idle\",\n      \"on\": {\n        \"CLICK_INSERT\": \"validating_input\",\n        \"CLICK_RESET\": \"tree_resetting\"\n      }\n    },\n    {\n      \"name\": \"validating_input\",\n      \"onEnter\": \"parse_input_and_validate\",\n      \"on\": {\n        \"INPUT_INVALID\": \"error_alert\",\n        \"INPUT_VALID\": \"inserting_node\"\n      }\n    },\n    {\n      \"name\": \"error_alert\",\n      \"onEnter\": \"alert_invalid_number\",\n      \"on\": {\n        \"ALERT_DISMISSED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"inserting_node\",\n      \"onEnter\": \"perform_bst_insert\",\n      \"on\": {\n        \"BST_INSERTED\": \"drawing_tree\"\n      }\n    },\n    {\n      \"name\": \"drawing_tree\",\n      \"onEnter\": \"render_bst\",\n      \"on\": {\n        \"TREE_RENDERED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"tree_resetting\",\n      \"onEnter\": \"reset_bst\",\n      \"on\": {\n        \"RESET_DONE\": \"idle\"\n      }\n    }\n  ],\n  \"events\": [\n    \"CLICK_INSERT\",\n    \"CLICK_RESET\",\n    \"INPUT_VALID\",\n    \"INPUT_INVALID\",\n    \"ALERT_DISMISSED\",\n    \"BST_INSERTED\",\n    \"TREE_RENDERED\",\n    \"RESET_DONE\"\n  ],\n  \"notes\": \"Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity.\"\n}"
      ]
    },
    {
      "id": "S5_before_input_nodeValue_50",
      "timestamp": 1763520126868,
      "name": "before_input_nodeValue_50",
      "url": "file:///D:/largeProjects/CS-Capstone/capstone/workspace/11-12-0001-fsm-examples%20copy/html/4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
      "title": "Interactive Binary Search Tree",
      "elementCounts": {
        "total": 17,
        "visible": 10,
        "buttons": 2,
        "inputs": 1,
        "nodes": 0
      },
      "visualElements": [],
      "formElements": [
        {
          "id": "nodeValue",
          "type": "number",
          "value": "10",
          "disabled": false,
          "focused": true
        }
      ],
      "buttonElements": [
        {
          "id": "",
          "text": "Insert Node",
          "disabled": false,
          "visible": true
        },
        {
          "id": "",
          "text": "Reset Tree",
          "disabled": false,
          "visible": true
        }
      ],
      "textContent": [
        "Interactive Binary Search Tree (BST)\n        Understand the structure and function of a Binary Search Tree through hands-on interaction.\n\n        \n            \n            Insert Node\n            Reset Tree",
        "Interactive Binary Search Tree (BST)",
        "Understand the structure and function of a Binary Search Tree through hands-on interaction.",
        "Insert Node\n            Reset Tree",
        "Insert Node",
        "Reset Tree",
        "class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }",
        "{\n  \"topic\": \"Interactive Application\",\n  \"description\": \"Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.\",\n  \"states\": [\n    {\n      \"name\": \"idle\",\n      \"onEnter\": \"set_idle\",\n      \"on\": {\n        \"CLICK_INSERT\": \"validating_input\",\n        \"CLICK_RESET\": \"tree_resetting\"\n      }\n    },\n    {\n      \"name\": \"validating_input\",\n      \"onEnter\": \"parse_input_and_validate\",\n      \"on\": {\n        \"INPUT_INVALID\": \"error_alert\",\n        \"INPUT_VALID\": \"inserting_node\"\n      }\n    },\n    {\n      \"name\": \"error_alert\",\n      \"onEnter\": \"alert_invalid_number\",\n      \"on\": {\n        \"ALERT_DISMISSED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"inserting_node\",\n      \"onEnter\": \"perform_bst_insert\",\n      \"on\": {\n        \"BST_INSERTED\": \"drawing_tree\"\n      }\n    },\n    {\n      \"name\": \"drawing_tree\",\n      \"onEnter\": \"render_bst\",\n      \"on\": {\n        \"TREE_RENDERED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"tree_resetting\",\n      \"onEnter\": \"reset_bst\",\n      \"on\": {\n        \"RESET_DONE\": \"idle\"\n      }\n    }\n  ],\n  \"events\": [\n    \"CLICK_INSERT\",\n    \"CLICK_RESET\",\n    \"INPUT_VALID\",\n    \"INPUT_INVALID\",\n    \"ALERT_DISMISSED\",\n    \"BST_INSERTED\",\n    \"TREE_RENDERED\",\n    \"RESET_DONE\"\n  ],\n  \"notes\": \"Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity.\"\n}"
      ]
    },
    {
      "id": "S6_after_input_nodeValue_50",
      "timestamp": 1763520127198,
      "name": "after_input_nodeValue_50",
      "url": "file:///D:/largeProjects/CS-Capstone/capstone/workspace/11-12-0001-fsm-examples%20copy/html/4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
      "title": "Interactive Binary Search Tree",
      "elementCounts": {
        "total": 17,
        "visible": 10,
        "buttons": 2,
        "inputs": 1,
        "nodes": 0
      },
      "visualElements": [],
      "formElements": [
        {
          "id": "nodeValue",
          "type": "number",
          "value": "50",
          "disabled": false,
          "focused": true
        }
      ],
      "buttonElements": [
        {
          "id": "",
          "text": "Insert Node",
          "disabled": false,
          "visible": true
        },
        {
          "id": "",
          "text": "Reset Tree",
          "disabled": false,
          "visible": true
        }
      ],
      "textContent": [
        "Interactive Binary Search Tree (BST)\n        Understand the structure and function of a Binary Search Tree through hands-on interaction.\n\n        \n            \n            Insert Node\n            Reset Tree",
        "Interactive Binary Search Tree (BST)",
        "Understand the structure and function of a Binary Search Tree through hands-on interaction.",
        "Insert Node\n            Reset Tree",
        "Insert Node",
        "Reset Tree",
        "class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }",
        "{\n  \"topic\": \"Interactive Application\",\n  \"description\": \"Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.\",\n  \"states\": [\n    {\n      \"name\": \"idle\",\n      \"onEnter\": \"set_idle\",\n      \"on\": {\n        \"CLICK_INSERT\": \"validating_input\",\n        \"CLICK_RESET\": \"tree_resetting\"\n      }\n    },\n    {\n      \"name\": \"validating_input\",\n      \"onEnter\": \"parse_input_and_validate\",\n      \"on\": {\n        \"INPUT_INVALID\": \"error_alert\",\n        \"INPUT_VALID\": \"inserting_node\"\n      }\n    },\n    {\n      \"name\": \"error_alert\",\n      \"onEnter\": \"alert_invalid_number\",\n      \"on\": {\n        \"ALERT_DISMISSED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"inserting_node\",\n      \"onEnter\": \"perform_bst_insert\",\n      \"on\": {\n        \"BST_INSERTED\": \"drawing_tree\"\n      }\n    },\n    {\n      \"name\": \"drawing_tree\",\n      \"onEnter\": \"render_bst\",\n      \"on\": {\n        \"TREE_RENDERED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"tree_resetting\",\n      \"onEnter\": \"reset_bst\",\n      \"on\": {\n        \"RESET_DONE\": \"idle\"\n      }\n    }\n  ],\n  \"events\": [\n    \"CLICK_INSERT\",\n    \"CLICK_RESET\",\n    \"INPUT_VALID\",\n    \"INPUT_INVALID\",\n    \"ALERT_DISMISSED\",\n    \"BST_INSERTED\",\n    \"TREE_RENDERED\",\n    \"RESET_DONE\"\n  ],\n  \"notes\": \"Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity.\"\n}"
      ]
    },
    {
      "id": "S7_before_input_nodeValue_abc",
      "timestamp": 1763520127280,
      "name": "before_input_nodeValue_abc",
      "url": "file:///D:/largeProjects/CS-Capstone/capstone/workspace/11-12-0001-fsm-examples%20copy/html/4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
      "title": "Interactive Binary Search Tree",
      "elementCounts": {
        "total": 17,
        "visible": 10,
        "buttons": 2,
        "inputs": 1,
        "nodes": 0
      },
      "visualElements": [],
      "formElements": [
        {
          "id": "nodeValue",
          "type": "number",
          "value": "50",
          "disabled": false,
          "focused": true
        }
      ],
      "buttonElements": [
        {
          "id": "",
          "text": "Insert Node",
          "disabled": false,
          "visible": true
        },
        {
          "id": "",
          "text": "Reset Tree",
          "disabled": false,
          "visible": true
        }
      ],
      "textContent": [
        "Interactive Binary Search Tree (BST)\n        Understand the structure and function of a Binary Search Tree through hands-on interaction.\n\n        \n            \n            Insert Node\n            Reset Tree",
        "Interactive Binary Search Tree (BST)",
        "Understand the structure and function of a Binary Search Tree through hands-on interaction.",
        "Insert Node\n            Reset Tree",
        "Insert Node",
        "Reset Tree",
        "class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }",
        "{\n  \"topic\": \"Interactive Application\",\n  \"description\": \"Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.\",\n  \"states\": [\n    {\n      \"name\": \"idle\",\n      \"onEnter\": \"set_idle\",\n      \"on\": {\n        \"CLICK_INSERT\": \"validating_input\",\n        \"CLICK_RESET\": \"tree_resetting\"\n      }\n    },\n    {\n      \"name\": \"validating_input\",\n      \"onEnter\": \"parse_input_and_validate\",\n      \"on\": {\n        \"INPUT_INVALID\": \"error_alert\",\n        \"INPUT_VALID\": \"inserting_node\"\n      }\n    },\n    {\n      \"name\": \"error_alert\",\n      \"onEnter\": \"alert_invalid_number\",\n      \"on\": {\n        \"ALERT_DISMISSED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"inserting_node\",\n      \"onEnter\": \"perform_bst_insert\",\n      \"on\": {\n        \"BST_INSERTED\": \"drawing_tree\"\n      }\n    },\n    {\n      \"name\": \"drawing_tree\",\n      \"onEnter\": \"render_bst\",\n      \"on\": {\n        \"TREE_RENDERED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"tree_resetting\",\n      \"onEnter\": \"reset_bst\",\n      \"on\": {\n        \"RESET_DONE\": \"idle\"\n      }\n    }\n  ],\n  \"events\": [\n    \"CLICK_INSERT\",\n    \"CLICK_RESET\",\n    \"INPUT_VALID\",\n    \"INPUT_INVALID\",\n    \"ALERT_DISMISSED\",\n    \"BST_INSERTED\",\n    \"TREE_RENDERED\",\n    \"RESET_DONE\"\n  ],\n  \"notes\": \"Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity.\"\n}"
      ]
    },
    {
      "id": "S8_before_input_nodeValue_999",
      "timestamp": 1763520127413,
      "name": "before_input_nodeValue_999",
      "url": "file:///D:/largeProjects/CS-Capstone/capstone/workspace/11-12-0001-fsm-examples%20copy/html/4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
      "title": "Interactive Binary Search Tree",
      "elementCounts": {
        "total": 17,
        "visible": 10,
        "buttons": 2,
        "inputs": 1,
        "nodes": 0
      },
      "visualElements": [],
      "formElements": [
        {
          "id": "nodeValue",
          "type": "number",
          "value": "50",
          "disabled": false,
          "focused": true
        }
      ],
      "buttonElements": [
        {
          "id": "",
          "text": "Insert Node",
          "disabled": false,
          "visible": true
        },
        {
          "id": "",
          "text": "Reset Tree",
          "disabled": false,
          "visible": true
        }
      ],
      "textContent": [
        "Interactive Binary Search Tree (BST)\n        Understand the structure and function of a Binary Search Tree through hands-on interaction.\n\n        \n            \n            Insert Node\n            Reset Tree",
        "Interactive Binary Search Tree (BST)",
        "Understand the structure and function of a Binary Search Tree through hands-on interaction.",
        "Insert Node\n            Reset Tree",
        "Insert Node",
        "Reset Tree",
        "class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }",
        "{\n  \"topic\": \"Interactive Application\",\n  \"description\": \"Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.\",\n  \"states\": [\n    {\n      \"name\": \"idle\",\n      \"onEnter\": \"set_idle\",\n      \"on\": {\n        \"CLICK_INSERT\": \"validating_input\",\n        \"CLICK_RESET\": \"tree_resetting\"\n      }\n    },\n    {\n      \"name\": \"validating_input\",\n      \"onEnter\": \"parse_input_and_validate\",\n      \"on\": {\n        \"INPUT_INVALID\": \"error_alert\",\n        \"INPUT_VALID\": \"inserting_node\"\n      }\n    },\n    {\n      \"name\": \"error_alert\",\n      \"onEnter\": \"alert_invalid_number\",\n      \"on\": {\n        \"ALERT_DISMISSED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"inserting_node\",\n      \"onEnter\": \"perform_bst_insert\",\n      \"on\": {\n        \"BST_INSERTED\": \"drawing_tree\"\n      }\n    },\n    {\n      \"name\": \"drawing_tree\",\n      \"onEnter\": \"render_bst\",\n      \"on\": {\n        \"TREE_RENDERED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"tree_resetting\",\n      \"onEnter\": \"reset_bst\",\n      \"on\": {\n        \"RESET_DONE\": \"idle\"\n      }\n    }\n  ],\n  \"events\": [\n    \"CLICK_INSERT\",\n    \"CLICK_RESET\",\n    \"INPUT_VALID\",\n    \"INPUT_INVALID\",\n    \"ALERT_DISMISSED\",\n    \"BST_INSERTED\",\n    \"TREE_RENDERED\",\n    \"RESET_DONE\"\n  ],\n  \"notes\": \"Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity.\"\n}"
      ]
    },
    {
      "id": "S9_after_input_nodeValue_999",
      "timestamp": 1763520127771,
      "name": "after_input_nodeValue_999",
      "url": "file:///D:/largeProjects/CS-Capstone/capstone/workspace/11-12-0001-fsm-examples%20copy/html/4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
      "title": "Interactive Binary Search Tree",
      "elementCounts": {
        "total": 17,
        "visible": 10,
        "buttons": 2,
        "inputs": 1,
        "nodes": 0
      },
      "visualElements": [],
      "formElements": [
        {
          "id": "nodeValue",
          "type": "number",
          "value": "999",
          "disabled": false,
          "focused": true
        }
      ],
      "buttonElements": [
        {
          "id": "",
          "text": "Insert Node",
          "disabled": false,
          "visible": true
        },
        {
          "id": "",
          "text": "Reset Tree",
          "disabled": false,
          "visible": true
        }
      ],
      "textContent": [
        "Interactive Binary Search Tree (BST)\n        Understand the structure and function of a Binary Search Tree through hands-on interaction.\n\n        \n            \n            Insert Node\n            Reset Tree",
        "Interactive Binary Search Tree (BST)",
        "Understand the structure and function of a Binary Search Tree through hands-on interaction.",
        "Insert Node\n            Reset Tree",
        "Insert Node",
        "Reset Tree",
        "class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }",
        "{\n  \"topic\": \"Interactive Application\",\n  \"description\": \"Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.\",\n  \"states\": [\n    {\n      \"name\": \"idle\",\n      \"onEnter\": \"set_idle\",\n      \"on\": {\n        \"CLICK_INSERT\": \"validating_input\",\n        \"CLICK_RESET\": \"tree_resetting\"\n      }\n    },\n    {\n      \"name\": \"validating_input\",\n      \"onEnter\": \"parse_input_and_validate\",\n      \"on\": {\n        \"INPUT_INVALID\": \"error_alert\",\n        \"INPUT_VALID\": \"inserting_node\"\n      }\n    },\n    {\n      \"name\": \"error_alert\",\n      \"onEnter\": \"alert_invalid_number\",\n      \"on\": {\n        \"ALERT_DISMISSED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"inserting_node\",\n      \"onEnter\": \"perform_bst_insert\",\n      \"on\": {\n        \"BST_INSERTED\": \"drawing_tree\"\n      }\n    },\n    {\n      \"name\": \"drawing_tree\",\n      \"onEnter\": \"render_bst\",\n      \"on\": {\n        \"TREE_RENDERED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"tree_resetting\",\n      \"onEnter\": \"reset_bst\",\n      \"on\": {\n        \"RESET_DONE\": \"idle\"\n      }\n    }\n  ],\n  \"events\": [\n    \"CLICK_INSERT\",\n    \"CLICK_RESET\",\n    \"INPUT_VALID\",\n    \"INPUT_INVALID\",\n    \"ALERT_DISMISSED\",\n    \"BST_INSERTED\",\n    \"TREE_RENDERED\",\n    \"RESET_DONE\"\n  ],\n  \"notes\": \"Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity.\"\n}"
      ]
    },
    {
      "id": "S10_before_click_button_1",
      "timestamp": 1763520133184,
      "name": "before_click_button_1",
      "url": "file:///D:/largeProjects/CS-Capstone/capstone/workspace/11-12-0001-fsm-examples%20copy/html/4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
      "title": "Interactive Binary Search Tree",
      "elementCounts": {
        "total": 17,
        "visible": 10,
        "buttons": 2,
        "inputs": 1,
        "nodes": 0
      },
      "visualElements": [],
      "formElements": [
        {
          "id": "nodeValue",
          "type": "number",
          "value": "",
          "disabled": false,
          "focused": false
        }
      ],
      "buttonElements": [
        {
          "id": "",
          "text": "Insert Node",
          "disabled": false,
          "visible": true
        },
        {
          "id": "",
          "text": "Reset Tree",
          "disabled": false,
          "visible": true
        }
      ],
      "textContent": [
        "Interactive Binary Search Tree (BST)\n        Understand the structure and function of a Binary Search Tree through hands-on interaction.\n\n        \n            \n            Insert Node\n            Reset Tree",
        "Interactive Binary Search Tree (BST)",
        "Understand the structure and function of a Binary Search Tree through hands-on interaction.",
        "Insert Node\n            Reset Tree",
        "Insert Node",
        "Reset Tree",
        "class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }",
        "{\n  \"topic\": \"Interactive Application\",\n  \"description\": \"Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.\",\n  \"states\": [\n    {\n      \"name\": \"idle\",\n      \"onEnter\": \"set_idle\",\n      \"on\": {\n        \"CLICK_INSERT\": \"validating_input\",\n        \"CLICK_RESET\": \"tree_resetting\"\n      }\n    },\n    {\n      \"name\": \"validating_input\",\n      \"onEnter\": \"parse_input_and_validate\",\n      \"on\": {\n        \"INPUT_INVALID\": \"error_alert\",\n        \"INPUT_VALID\": \"inserting_node\"\n      }\n    },\n    {\n      \"name\": \"error_alert\",\n      \"onEnter\": \"alert_invalid_number\",\n      \"on\": {\n        \"ALERT_DISMISSED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"inserting_node\",\n      \"onEnter\": \"perform_bst_insert\",\n      \"on\": {\n        \"BST_INSERTED\": \"drawing_tree\"\n      }\n    },\n    {\n      \"name\": \"drawing_tree\",\n      \"onEnter\": \"render_bst\",\n      \"on\": {\n        \"TREE_RENDERED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"tree_resetting\",\n      \"onEnter\": \"reset_bst\",\n      \"on\": {\n        \"RESET_DONE\": \"idle\"\n      }\n    }\n  ],\n  \"events\": [\n    \"CLICK_INSERT\",\n    \"CLICK_RESET\",\n    \"INPUT_VALID\",\n    \"INPUT_INVALID\",\n    \"ALERT_DISMISSED\",\n    \"BST_INSERTED\",\n    \"TREE_RENDERED\",\n    \"RESET_DONE\"\n  ],\n  \"notes\": \"Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity.\"\n}"
      ]
    },
    {
      "id": "S11_after_click_button_1",
      "timestamp": 1763520133921,
      "name": "after_click_button_1",
      "url": "file:///D:/largeProjects/CS-Capstone/capstone/workspace/11-12-0001-fsm-examples%20copy/html/4ca11ad0-b408-11f0-ab52-fbe7249bf639.html",
      "title": "Interactive Binary Search Tree",
      "elementCounts": {
        "total": 17,
        "visible": 10,
        "buttons": 2,
        "inputs": 1,
        "nodes": 0
      },
      "visualElements": [],
      "formElements": [
        {
          "id": "nodeValue",
          "type": "number",
          "value": "",
          "disabled": false,
          "focused": false
        }
      ],
      "buttonElements": [
        {
          "id": "",
          "text": "Insert Node",
          "disabled": false,
          "visible": true
        },
        {
          "id": "",
          "text": "Reset Tree",
          "disabled": false,
          "visible": true
        }
      ],
      "textContent": [
        "Interactive Binary Search Tree (BST)\n        Understand the structure and function of a Binary Search Tree through hands-on interaction.\n\n        \n            \n            Insert Node\n            Reset Tree",
        "Interactive Binary Search Tree (BST)",
        "Understand the structure and function of a Binary Search Tree through hands-on interaction.",
        "Insert Node\n            Reset Tree",
        "Insert Node",
        "Reset Tree",
        "class BSTNode {\n            constructor(value) {\n                this.value = value;\n                this.left = null;\n                this.right = null;\n            }\n        }\n\n        class BST {\n            constructor() {\n                this.root = null;\n            }\n            insert(value) {\n                const newNode = new BSTNode(value);\n                if (!this.root) {\n                    this.root = newNode;\n                    return this;\n                }\n                let current = this.root;\n                while (true) {\n                    if (value < current.value) {\n                        if (!current.left) {\n                            current.left = newNode;\n                            return this;\n                        }\n                        current = current.left;\n                    } else {\n                        if (!current.right) {\n                            current.right = newNode;\n                            return this;\n                        }\n                        current = current.right;\n                    }\n                }\n            }\n        }\n\n        const bst = new BST();\n        const treeContainer = document.getElementById('treeContainer');\n\n        function insertNode() {\n            const nodeValue = parseInt(document.getElementById('nodeValue').value);\n            if (isNaN(nodeValue)) return alert(\"Please enter a valid number.\");\n\n            bst.insert(nodeValue);\n            drawTree(bst.root, treeContainer.clientWidth / 2, 30, treeContainer.clientWidth / 4);\n        }\n\n        function drawTree(node, x, y, offset) {\n            if (!node) return;\n\n            const nodeDiv = document.createElement('div');\n            nodeDiv.textContent = node.value;\n            nodeDiv.className = 'node';\n            nodeDiv.style.left = `${x}px`;\n            nodeDiv.style.top = `${y}px`;\n            treeContainer.appendChild(nodeDiv);\n\n            const nodeOffset = offset / 2;\n\n            if (node.left) {\n                drawLine(x, y, x - offset, y + 60);\n                drawTree(node.left, x - offset, y + 60, nodeOffset);\n            }\n            if (node.right) {\n                drawLine(x, y, x + offset, y + 60);\n                drawTree(node.right, x + offset, y + 60, nodeOffset);\n            }\n        }\n\n        function drawLine(x1, y1, x2, y2) {\n            const line = document.createElement('div');\n            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\n            line.style.position = 'absolute';\n            line.style.left = `${x1}px`;\n            line.style.top = `${y1}px`;\n            line.style.width = `${length}px`;\n            line.style.height = '2px';\n            line.style.backgroundColor = '#000';\n            line.style.transformOrigin = '0 0';\n            line.style.transform = `rotate(${angle}deg)`;\n            treeContainer.appendChild(line);\n        }\n\n        function resetTree() {\n            bst.root = null;\n            treeContainer.innerHTML = '';\n        }",
        "{\n  \"topic\": \"Interactive Application\",\n  \"description\": \"Finite State Machine for an interactive Binary Search Tree (BST) web app that lets users insert nodes and reset the tree, with validation and rendering states.\",\n  \"states\": [\n    {\n      \"name\": \"idle\",\n      \"onEnter\": \"set_idle\",\n      \"on\": {\n        \"CLICK_INSERT\": \"validating_input\",\n        \"CLICK_RESET\": \"tree_resetting\"\n      }\n    },\n    {\n      \"name\": \"validating_input\",\n      \"onEnter\": \"parse_input_and_validate\",\n      \"on\": {\n        \"INPUT_INVALID\": \"error_alert\",\n        \"INPUT_VALID\": \"inserting_node\"\n      }\n    },\n    {\n      \"name\": \"error_alert\",\n      \"onEnter\": \"alert_invalid_number\",\n      \"on\": {\n        \"ALERT_DISMISSED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"inserting_node\",\n      \"onEnter\": \"perform_bst_insert\",\n      \"on\": {\n        \"BST_INSERTED\": \"drawing_tree\"\n      }\n    },\n    {\n      \"name\": \"drawing_tree\",\n      \"onEnter\": \"render_bst\",\n      \"on\": {\n        \"TREE_RENDERED\": \"idle\"\n      }\n    },\n    {\n      \"name\": \"tree_resetting\",\n      \"onEnter\": \"reset_bst\",\n      \"on\": {\n        \"RESET_DONE\": \"idle\"\n      }\n    }\n  ],\n  \"events\": [\n    \"CLICK_INSERT\",\n    \"CLICK_RESET\",\n    \"INPUT_VALID\",\n    \"INPUT_INVALID\",\n    \"ALERT_DISMISSED\",\n    \"BST_INSERTED\",\n    \"TREE_RENDERED\",\n    \"RESET_DONE\"\n  ],\n  \"notes\": \"Mapping to code: CLICK_INSERT is triggered by the Insert Node button (onclick=insertNode). validating_input corresponds to reading document.getElementById('nodeValue').value, parseInt, and isNaN checks inside insertNode. INPUT_INVALID triggers error_alert, which onEnter calls alert('Please enter a valid number.') and transitions back to idle when the alert is dismissed (ALERT_DISMISSED). INPUT_VALID transitions to inserting_node, which onEnter runs bst.insert(nodeValue); BST_INSERTED fires when insertion returns. drawing_tree onEnter calls drawTree(bst.root, treeContainer.clientWidth/2, 30, treeContainer.clientWidth/4), which synchronously creates node and line elements (drawLine). TREE_RENDERED fires after drawTree finishes. CLICK_RESET triggers tree_resetting, which onEnter runs resetTree() (bst.root = null; treeContainer.innerHTML = '') and RESET_DONE then returns to idle. Rendering uses immediate DOM updates; there are no asynchronous animations, although .node has a CSS transition for transform that is not programmatically used. The FSM abstracts sequential steps inside insertNode into distinct states for clarity.\"\n}"
      ]
    }
  ],
  "alert_messages": [
    "Please enter a valid number."
  ],
  "summary": {
    "total_probes": 6,
    "successful_probes": 5,
    "significant_changes": 3
  }
}