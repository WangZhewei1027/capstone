<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bubble Sort Visualization</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#06b6d4;
    --muted:#98a2b3;
    --good:#16a34a;
    --bad:#ef4444;
    --surface:#0b1220;
    --bar:#60a5fa;
  }
  html,body{
    height:100%;
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    background:linear-gradient(180deg,var(--bg),#061022 60%);
    color:#e6eef6;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }
  .container{
    max-width:1100px;
    margin:24px auto;
    padding:20px;
    border-radius:12px;
  }
  header{
    display:flex;
    align-items:center;
    gap:16px;
    margin-bottom:12px;
  }
  h1{
    font-size:20px;
    margin:0;
  }
  .controls{
    display:flex;
    flex-wrap:wrap;
    gap:12px;
    margin-bottom:16px;
    align-items:center;
  }
  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:12px;
    border-radius:10px;
    box-shadow:0 6px 18px rgba(2,6,23,0.6);
  }
  .buttons{ display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
  button{
    background:transparent;
    color:var(--accent);
    border:1px solid rgba(6,182,212,0.12);
    padding:8px 12px;
    border-radius:8px;
    cursor:pointer;
    font-weight:600;
  }
  button:disabled { opacity:0.4; cursor:not-allowed; }
  .btn-primary{ background:linear-gradient(90deg,var(--accent),#7ee7f7); color:#012022; border:none; }
  .btn-danger{ background:var(--bad); border:none; color:white; }
  .controls-row{ display:flex; gap:8px; align-items:center; }
  label{ font-size:13px; color:var(--muted); }
  input[type=range]{ width:140px;}
  .status{
    display:flex;
    gap:14px;
    align-items:center;
    margin-left:auto;
    font-size:13px;
    color:var(--muted);
  }
  .viz{
    margin-top:18px;
    display:flex;
    gap:12px;
    align-items:end;
    justify-content:center;
    padding:18px;
    height:360px;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.06));
    border-radius:12px;
  }
  .bar{
    background:var(--bar);
    width:100%;
    border-radius:6px 6px 3px 3px;
    display:inline-block;
    transition:height 200ms ease, background-color 120ms ease, transform 200ms ease;
    box-shadow:0 4px 10px rgba(12,22,38,0.45) inset;
    position:relative;
  }
  .bar-label{
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    bottom:6px;
    font-size:11px;
    color:rgba(0,0,0,0.85);
    font-weight:700;
    text-shadow:0 1px 0 rgba(255,255,255,0.3);
    pointer-events:none;
  }
  .bar.compare{ background: #f59e0b; } /* amber */
  .bar.swap{ background: #ef4444; transform:translateY(-6px); }
  .bar.sorted{ background:var(--good); }
  .info{
    margin-top:12px;
    display:flex;
    gap:18px;
    flex-wrap:wrap;
    align-items:center;
  }
  .pseudocode{
    margin-top:12px;
    background:rgba(255,255,255,0.02);
    padding:12px;
    border-radius:10px;
    font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
    font-size:13px;
    color:var(--muted);
    line-height:1.6;
    white-space:pre;
    max-width:100%;
  }
  .line{ padding:2px 6px; border-radius:6px; display:block; }
  .line.active{ background:rgba(6,182,212,0.12); color:var(--accent); }
  .summary{ font-size:13px; color:var(--muted); }
  footer{ margin-top:18px; color:var(--muted); font-size:12px; }
  @media (max-width:720px){
    .viz{ height:260px; }
    input[type=range]{ width:110px; }
  }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>Bubble Sort — Interactive Visualization</h1>
    <div style="margin-left:12px;color:var(--muted);font-size:13px">Compare & swap adjacent items until sorted</div>
  </header>

  <div class="controls panel">
    <div class="buttons">
      <button id="startBtn" class="btn-primary">Start / Resume</button>
      <button id="pauseBtn">Pause</button>
      <button id="stepBtn">Step</button>
      <button id="shuffleBtn">Shuffle</button>
      <button id="resetBtn">Reset</button>
    </div>

    <div style="display:flex; gap:12px; margin-top:10px; align-items:center;">
      <div class="controls-row">
        <label for="size">Size</label>
        <input id="size" type="range" min="5" max="80" value="24">
        <span id="sizeVal" style="width:36px;text-align:center;color:var(--muted)">24</span>
      </div>

      <div class="controls-row">
        <label for="speed">Speed</label>
        <input id="speed" type="range" min="1" max="100" value="30">
        <span id="speedVal" style="width:48px;text-align:center;color:var(--muted)">30</span>
      </div>

      <div class="controls-row">
        <label for="order">Order</label>
        <select id="order">
          <option value="ascending">Ascending</option>
          <option value="descending">Descending</option>
        </select>
      </div>

      <div class="status">
        <div>Comparisons: <strong id="compCount">0</strong></div>
        <div>Swaps: <strong id="swapCount">0</strong></div>
        <div>Pass: <strong id="passCount">0</strong></div>
      </div>
    </div>
  </div>

  <div id="viz" class="viz panel" aria-live="polite" aria-atomic="true"></div>

  <div class="info">
    <div class="pseudocode panel" id="pcode" style="max-width:480px;">
      <div class="line" data-line="1">for i from 0 to n-2</div>
      <div class="line" data-line="2">  for j from 0 to n-2-i</div>
      <div class="line" data-line="3">    if A[j] > A[j+1]</div>
      <div class="line" data-line="4">      swap A[j] and A[j+1]</div>
      <div class="line" data-line="5">  end for</div>
      <div class="line" data-line="6">end for</div>
    </div>

    <div style="flex:1; min-width:240px;">
      <div class="panel" style="padding:14px;">
        <div class="summary"><strong>Complexity</strong></div>
        <div style="margin-top:8px;color:var(--muted)">
          Worst / Average: O(n²) — Best: O(n) if optimized with early exit.<br/>
          Stable: Yes. In-place: Yes.
        </div>
      </div>
    </div>
  </div>

  <footer>
    Controls: Start/Resume runs continuously. Pause stops. Step advances one algorithmic action (compare or swap). Shuffle resets the array. Adjust size and speed anytime.
  </footer>
</div>

<script>
(function(){
  // DOM elements
  const viz = document.getElementById('viz');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stepBtn = document.getElementById('stepBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const resetBtn = document.getElementById('resetBtn');
  const sizeInput = document.getElementById('size');
  const sizeVal = document.getElementById('sizeVal');
  const speedInput = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const compCountEl = document.getElementById('compCount');
  const swapCountEl = document.getElementById('swapCount');
  const passCountEl = document.getElementById('passCount');
  const pcode = document.getElementById('pcode');
  const orderSelect = document.getElementById('order');

  // State
  let array = [];
  let bars = [];
  let generator = null;
  let isRunning = false;
  let isPaused = true;
  let speed = Number(speedInput.value); // 1..100
  let delayMs = computeDelay(speed);
  let comparisons = 0;
  let swaps = 0;
  let passNum = 0;
  let ascending = true;
  let stepMode = false;

  // Initialize
  sizeVal.textContent = sizeInput.value;
  speedVal.textContent = speedInput.value;
  initArray(Number(sizeInput.value));
  render();

  // Event listeners
  sizeInput.addEventListener('input', (e)=>{
    sizeVal.textContent = e.target.value;
  });
  sizeInput.addEventListener('change', (e)=>{
    initArray(Number(e.target.value));
    resetStats();
    render();
    stopAlgorithm();
  });

  speedInput.addEventListener('input', (e)=>{
    speed = Number(e.target.value);
    speedVal.textContent = speed;
    delayMs = computeDelay(speed);
    updateBarTransitionDuration();
  });

  orderSelect.addEventListener('change', (e)=>{
    ascending = e.target.value === 'ascending';
    stopAlgorithm();
  });

  shuffleBtn.addEventListener('click', ()=>{
    initArray(array.length);
    resetStats();
    render();
    stopAlgorithm();
  });

  resetBtn.addEventListener('click', ()=>{
    initArray(array.length, true); // ascending reset values
    resetStats();
    render();
    stopAlgorithm();
  });

  startBtn.addEventListener('click', async ()=>{
    if (!generator || finished) {
      generator = bubbleSortGenerator(array, ascending);
      finished = false;
    }
    isPaused = false;
    isRunning = true;
    stepMode = false;
    runGenerator();
  });

  pauseBtn.addEventListener('click', ()=>{
    isPaused = true;
    isRunning = false;
  });

  stepBtn.addEventListener('click', async ()=>{
    if (!generator || finished) {
      generator = bubbleSortGenerator(array, ascending);
      finished = false;
    }
    isPaused = true;
    isRunning = false;
    stepMode = true;
    await runOneStep();
  });

  // Helpers
  function computeDelay(sp){
    // map 1..100 to 1000ms..10ms inversely
    const max = 1000;
    const min = 10;
    const t = (100 - sp) / 99; // 0..1
    return Math.round(min + t * (max - min));
  }

  function updateBarTransitionDuration(){
    // set CSS transition duration based on speed
    const ms = Math.max(30, Math.min(600, delayMs/1.8));
    bars.forEach(b => {
      if (b) b.style.transition = `height ${ms}ms ease, background-color 120ms ease, transform ${ms}ms ease`;
    });
  }

  function initArray(n, sorted=false){
    array = [];
    for (let i=0;i<n;i++){
      array.push(Math.floor(Math.random()*100)+1);
    }
    if (sorted) array.sort((a,b)=>a-b);
    bars = [];
    viz.innerHTML = '';
    // Build bar elements
    for (let i=0;i<array.length;i++){
      const barWrap = document.createElement('div');
      barWrap.className = 'bar';
      barWrap.style.width = `${100/array.length - 0.4}%`;
      barWrap.style.height = heightForValue(array[i]) + '%';
      const label = document.createElement('div');
      label.className = 'bar-label';
      label.textContent = array[i];
      barWrap.appendChild(label);
      viz.appendChild(barWrap);
      bars.push(barWrap);
    }
    updateBarTransitionDuration();
  }

  function heightForValue(v){
    // produce percentage height (20..100)
    return 12 + (v / 100) * 86;
  }

  function render(){
    for (let i=0;i<array.length;i++){
      const b = bars[i];
      if (!b) continue;
      b.style.height = heightForValue(array[i]) + '%';
      b.querySelector('.bar-label').textContent = array[i];
      b.className = 'bar';
    }
    compCountEl.textContent = comparisons;
    swapCountEl.textContent = swaps;
    passCountEl.textContent = passNum;
  }

  function resetStats(){
    comparisons = 0;
    swaps = 0;
    passNum = 0;
    compCountEl.textContent = 0;
    swapCountEl.textContent = 0;
    passCountEl.textContent = 0;
    clearPcodeHighlight();
  }

  let finished = false;

  function stopAlgorithm(){
    isRunning = false;
    isPaused = true;
    generator = null;
    finished = false;
  }

  // Pseudocode highlight helpers
  function clearPcodeHighlight(){
    const lines = pcode.querySelectorAll('.line');
    lines.forEach(l=>l.classList.remove('active'));
  }
  function highlight(lineNum){
    clearPcodeHighlight();
    const el = pcode.querySelector(`.line[data-line="${lineNum}"]`);
    if (el) el.classList.add('active');
  }

  // Generator for bubble sort. Yields action objects describing algorithm steps.
  function* bubbleSortGenerator(arr, ascending=true){
    const n = arr.length;
    for (let i=0;i<n-1;i++){
      // start of pass
      yield {type:'passStart', i};
      for (let j=0;j<n-1-i;j++){
        // compare j and j+1
        yield {type:'compare', indices:[j,j+1], i, j};
        const shouldSwap = ascending ? (arr[j] > arr[j+1]) : (arr[j] < arr[j+1]);
        if (shouldSwap){
          // do swap
          const tmp = arr[j];
          arr[j] = arr[j+1];
          arr[j+1] = tmp;
          yield {type:'swap', indices:[j,j+1], array:arr.slice(), i, j};
        }
        yield {type:'afterCompare', indices:[j,j+1], i, j};
      }
      yield {type:'passEnd', i};
    }
    yield {type:'done'};
  }

  // Runner: process generator yields. We support pause/resume and step.
  async function runGenerator(){
    if (!generator) generator = bubbleSortGenerator(array, ascending);
    while (true){
      if (isPaused) {
        // wait until resumed or step pressed
        await waitForResumeOrStep();
      }
      const res = generator.next();
      if (res.done) {
        finished = true;
        markAllSorted();
        isRunning = false;
        isPaused = true;
        break;
      }
      await handleAction(res.value);
      if (stepMode) {
        // after a single action in step mode, pause
        isPaused = true;
        stepMode = false;
        break;
      }
      if (!isRunning && !isPaused) {
        // safeguard; should not happen
        isPaused = true;
        break;
      }
    }
  }

  // Wait until user resumes or presses step: returns a promise resolved when resume or step triggers
  function waitForResumeOrStep(){
    return new Promise(resolve=>{
      const check = () => {
        if (!isPaused || stepMode) {
          resolve();
        } else {
          requestAnimationFrame(check);
        }
      };
      check();
    });
  }

  // Run exactly one generator action (one yield)
  async function runOneStep(){
    if (!generator) generator = bubbleSortGenerator(array, ascending);
    const res = generator.next();
    if (res.done) {
      finished = true;
      markAllSorted();
      isRunning = false;
      isPaused = true;
      return;
    }
    await handleAction(res.value);
    // done one action
  }

  // Handle a single action object from generator
  async function handleAction(action){
    switch(action.type){
      case 'passStart':
        passNum = action.i + 1;
        passCountEl.textContent = passNum;
        highlight(1);
        break;
      case 'compare':
        comparisons++;
        compCountEl.textContent = comparisons;
        highlight(2);
        markCompare(action.indices);
        await waitDelay();
        highlight(3);
        break;
      case 'swap':
        swaps++;
        swapCountEl.textContent = swaps;
        highlight(4);
        await animateSwap(action.indices, action.array);
        break;
      case 'afterCompare':
        unmarkPair(action.indices);
        highlight(2);
        break;
      case 'passEnd':
        // mark the last sorted element for this pass
        const idx = array.length - 1 - action.i;
        if (bars[idx]) bars[idx].classList.add('sorted');
        highlight(5);
        break;
      case 'done':
        finished = true;
        highlight(6);
        markAllSorted();
        break;
    }
    render();
  }

  // Visual helpers
  function markCompare([a,b]){
    unmarkAll();
    if (bars[a]) bars[a].classList.add('compare');
    if (bars[b]) bars[b].classList.add('compare');
  }

  function unmarkPair([a,b]){
    if (bars[a]) bars[a].classList.remove('compare', 'swap');
    if (bars[b]) bars[b].classList.remove('compare', 'swap');
  }

  function unmarkAll(){
    bars.forEach(b => b.classList.remove('compare','swap'));
  }

  function markAllSorted(){
    bars.forEach(b => {
      b.classList.remove('compare','swap');
      b.classList.add('sorted');
    });
  }

  async function animateSwap([i,j], newArray){
    // Visual swap: we will update heights and show swap class
    if (bars[i]) bars[i].classList.add('swap');
    if (bars[j]) bars[j].classList.add('swap');
    // Update array values and bar heights to reflect new array
    // We assume generator already updated the array (we passed newArray)
    array = newArray.slice();
    // animate by changing heights; transition handles smoothness
    for (let k=0;k<array.length;k++){
      if (bars[k]) {
        bars[k].style.height = heightForValue(array[k]) + '%';
        bars[k].querySelector('.bar-label').textContent = array[k];
      }
    }
    // wait for animation
    await wait(delayMs);
    if (bars[i]) bars[i].classList.remove('swap','compare');
    if (bars[j]) bars[j].classList.remove('swap','compare');
  }

  function wait(ms){
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  function waitDelay(){
    // short pause for compare visualization
    return wait(Math.max(40, Math.min(600, delayMs/3)));
  }

  // small utility
  function finishedFlag(){ return finished; }

  // Small paranoia: if user changes size rapidly, ensure bars array exists
  window.addEventListener('resize', ()=> {
    bars.forEach(b => b.style.width = `${100/array.length - 0.4}%`);
  });

  // Initialize transitions based on speed
  updateBarTransitionDuration();

  // Expose nothing global
})();
</script>
</body>
</html>