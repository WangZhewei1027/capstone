<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Longest Common Subsequence (LCS) Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#0ea5ff;
      --muted:#94a3b8;
      --card:#071022;
      --good:#16a34a;
      --warn:#f59e0b;
    }
    html,body{
      margin:0;
      padding:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #041025 0%, #07172b 100%);
      color:#e6eef8;
      min-height:100vh;
      box-sizing:border-box;
    }
    .container{
      max-width:1100px;
      margin:30px auto;
      padding:24px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
    }
    h1{
      margin:0 0 6px 0;
      font-size:20px;
      color:var(--accent);
    }
    p.lead{
      margin:0 0 18px 0;
      color:var(--muted);
      font-size:13px;
    }
    .row{
      display:flex;
      gap:18px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .col{
      background:var(--card);
      padding:14px;
      border-radius:10px;
      flex:1 1 320px;
      min-width:260px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    }
    label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
    }
    input[type="text"], textarea, select{
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:transparent;
      color:inherit;
      resize:none;
      box-sizing:border-box;
      font-size:14px;
    }
    textarea { min-height:60px; }
    .controls{
      display:flex;
      gap:8px;
      margin-top:10px;
      flex-wrap:wrap;
    }
    button{
      background:linear-gradient(180deg,var(--accent),#0090e6);
      color:#021228;
      border:none;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      box-shadow: 0 6px 18px rgba(12,56,88,0.25);
    }
    button.ghost{
      background:transparent;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.03);
      box-shadow:none;
    }
    .small{
      padding:6px 8px;
      font-size:13px;
    }
    .panel-title{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .result{
      margin-top:12px;
      padding:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:8px;
      font-size:14px;
      color:var(--muted);
    }
    .badge{
      display:inline-block;
      background:rgba(255,255,255,0.02);
      color:var(--accent);
      padding:6px 8px;
      border-radius:8px;
      font-weight:700;
      font-size:13px;
      margin-left:8px;
    }
    .matrix-wrap{
      overflow:auto;
      max-width:100%;
      margin-top:12px;
    }
    table.matrix{
      border-collapse:collapse;
      font-family:monospace;
      background:transparent;
      margin-bottom:8px;
    }
    table.matrix th, table.matrix td{
      border:1px solid rgba(255,255,255,0.03);
      padding:6px 8px;
      text-align:center;
      min-width:34px;
      position:relative;
      color:var(--muted);
      font-size:13px;
    }
    table.matrix th.header{
      background:rgba(255,255,255,0.02);
      color:var(--accent);
      font-weight:700;
    }
    table.matrix td.match{
      background:linear-gradient(180deg, rgba(16,185,129,0.08), rgba(16,185,129,0.03));
      color:#a7f3d0;
      font-weight:700;
    }
    table.matrix td.path{
      outline:3px solid rgba(14,165,255,0.12);
      box-shadow: inset 0 0 0 1px rgba(14,165,255,0.06);
    }
    .cell-arrows{
      font-size:10px;
      color:var(--muted);
      position:absolute;
      bottom:3px;
      right:4px;
    }
    .meta{
      font-size:13px;
      color:var(--muted);
      margin-top:10px;
    }
    .lcs-list{
      margin-top:10px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .chip{
      background:rgba(255,255,255,0.02);
      color:var(--accent);
      padding:8px 10px;
      border-radius:999px;
      font-weight:600;
      font-size:13px;
      cursor:pointer;
      border:1px solid rgba(255,255,255,0.02);
    }
    .chip.selected{
      background:linear-gradient(90deg,var(--accent),#0090e6);
      color:#021228;
      box-shadow:0 6px 18px rgba(3,40,62,0.45);
    }
    .explain{
      margin-top:12px;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }
    .footnote{
      margin-top:14px;
      font-size:12px;
      color:var(--muted);
    }
    .controls .option{
      display:flex;
      gap:8px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .danger{
      color:#ffb4b4;
      background:rgba(255,50,50,0.06);
      padding:6px 8px;
      border-radius:8px;
    }

    @media (max-width:820px){
      .row{ flex-direction:column; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Longest Common Subsequence (LCS) Visualizer</h1>
    <p class="lead">Enter two strings to compute their longest common subsequence using dynamic programming. Visualize the DP table, reconstruct one or all LCSs (within limits), and step through the backtracking path.</p>

    <div class="row">
      <div class="col" style="flex:0 0 420px;">
        <div class="panel-title">
          <div>
            <label for="strA">String A</label>
            <textarea id="strA" placeholder="Type first string (max 120 characters)">AGGTAB</textarea>
          </div>
        </div>

        <div style="margin-top:12px;">
          <label for="strB">String B</label>
          <textarea id="strB" placeholder="Type second string (max 120 characters)">GXTXAYB</textarea>
        </div>

        <div class="controls">
          <button id="computeBtn">Compute LCS</button>
          <button id="randomBtn" class="ghost small">Random example</button>
          <div class="option" style="margin-left:auto">
            <label title="Show all distinct LCS (may be many)">Show all</label>
            <input type="checkbox" id="showAll" />
          </div>
          <div class="option">
            <label title="Max number of sequences to list">Limit</label>
            <input id="limit" type="number" min="1" max="1000" value="50" style="width:80px;padding:6px 8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:var(--muted)"/>
          </div>
        </div>

        <div class="result" id="summary">
          Click "Compute LCS" to begin. You can use the random example button for sample input.
        </div>

        <div class="explain">
          Notes:
          <ul style="margin-top:8px;color:var(--muted)">
            <li>DP computes dp[i][j] = length of LCS of A[0..i-1] and B[0..j-1].</li>
            <li>Backtracking follows choices: if A[i-1]==B[j-1] take diagonal; else follow larger neighbor (up or left).</li>
            <li>Number of distinct LCS can grow exponentially — use the <span style="color:var(--warn)">Limit</span> to avoid huge output.</li>
          </ul>
        </div>
      </div>

      <div class="col" style="flex:1 1 620px;">
        <div class="panel-title">
          <div>
            <label>DP Matrix & Reconstruction</label>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="stepBtn" class="ghost small">Step backtracking</button>
            <button id="resetStep" class="ghost small">Reset</button>
            <button id="highlightBtn" class="small">Highlight greedy LCS path</button>
          </div>
        </div>

        <div id="matrixContainer" class="matrix-wrap" aria-live="polite" style="min-height:180px;">
          <!-- Matrix will be injected here -->
        </div>

        <div class="meta" id="metaInfo"></div>

        <div id="lcsList" class="lcs-list"></div>
        <div id="foot" class="footnote"></div>
      </div>
    </div>
  </div>

  <script>
    // LCS Visualizer JavaScript. All in one file.

    // DOM references
    const strAInput = document.getElementById('strA');
    const strBInput = document.getElementById('strB');
    const computeBtn = document.getElementById('computeBtn');
    const randomBtn = document.getElementById('randomBtn');
    const matrixContainer = document.getElementById('matrixContainer');
    const summary = document.getElementById('summary');
    const metaInfo = document.getElementById('metaInfo');
    const lcsList = document.getElementById('lcsList');
    const showAllCb = document.getElementById('showAll');
    const limitInput = document.getElementById('limit');
    const stepBtn = document.getElementById('stepBtn');
    const resetStep = document.getElementById('resetStep');
    const highlightBtn = document.getElementById('highlightBtn');
    const foot = document.getElementById('foot');

    // State
    let A = "", B = "";
    let dp = []; // dp matrix (m+1) x (n+1)
    let m = 0, n = 0;
    let allLCS = [];
    let greedyPath = []; // array of [i,j] positions
    let stepIndex = 0; // for stepping
    let highlighted = false;

    function clampInputLength(s) {
      // Keep strings reasonable for UI
      const max = 120;
      return s.length > max ? s.slice(0, max) : s;
    }

    function computeDP(a, b) {
      m = a.length; n = b.length;
      // dp as (m+1)x(n+1) with zeros
      dp = Array.from({length: m+1}, () => new Array(n+1).fill(0));
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (a[i-1] === b[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
          else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
        }
      }
      return dp;
    }

    function buildMatrixHtml(a, b, dp) {
      // Build an HTML table representation of dp with headers showing chars.
      // Rows correspond to A (i from 0..m), cols correspond to B (j from 0..n)
      const table = document.createElement('table');
      table.className = 'matrix';
      const thead = document.createElement('thead');
      const hdrRow = document.createElement('tr');

      // top-left empty corner
      const empty = document.createElement('th');
      empty.className = 'header';
      empty.textContent = '';
      hdrRow.appendChild(empty);

      // header for B chars (with initial blank)
      const blank = document.createElement('th');
      blank.className = 'header';
      blank.textContent = '∅';
      hdrRow.appendChild(blank);

      for (let j = 0; j < b.length; j++) {
        const th = document.createElement('th');
        th.className = 'header';
        th.textContent = b[j];
        hdrRow.appendChild(th);
      }
      thead.appendChild(hdrRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');

      // For each row i: header char for A (including blank row), then dp values
      for (let i = 0; i <= a.length; i++) {
        const tr = document.createElement('tr');

        // header cell for A (first is ∅)
        const thRow = document.createElement('th');
        thRow.className = 'header';
        thRow.textContent = i === 0 ? '∅' : a[i-1];
        tr.appendChild(thRow);

        for (let j = 0; j <= b.length; j++) {
          const td = document.createElement('td');
          td.dataset.i = i;
          td.dataset.j = j;
          td.textContent = dp[i][j];
          // mark matches (if i>0 && j>0 && a[i-1]==b[j-1])
          if (i > 0 && j > 0 && a[i-1] === b[j-1]) {
            td.classList.add('match');
          }
          // compute arrows: diagonal if from dp[i-1][j-1] +1 equals; up if dp[i-1][j] == dp[i][j]; left if dp[i][j-1] == dp[i][j]
          let arrows = [];
          if (i > 0 && j > 0 && a[i-1] === b[j-1] && dp[i][j] === dp[i-1][j-1] + 1) {
            arrows.push('↖');
          }
          if (i > 0 && dp[i][j] === dp[i-1][j]) arrows.push('↑');
          if (j > 0 && dp[i][j] === dp[i][j-1]) arrows.push('←');

          if (arrows.length) {
            const span = document.createElement('span');
            span.className = 'cell-arrows';
            span.title = arrows.join(' ');
            span.textContent = arrows.join('');
            td.appendChild(span);
          }

          // click to reconstruct LCS from this cell
          td.addEventListener('click', () => {
            // reconstruct one LCS starting from (i,j) greedily
            const i0 = parseInt(td.dataset.i,10);
            const j0 = parseInt(td.dataset.j,10);
            const greedy = reconstructGreedy(a,b,dp,i0,j0);
            if (greedy === '') {
              summary.textContent = `Greedy from (${i0},${j0}) => empty LCS (length 0)`;
            } else {
              summary.textContent = `Greedy from (${i0},${j0}) => "${greedy}" (length ${greedy.length})`;
            }
            highlightGreedyPathFor(greedy ? [i0,j0] : null, greedy);
          });

          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }

      table.appendChild(tbody);
      return table;
    }

    function reconstructGreedy(a,b,dp, i0=null, j0=null) {
      // Backtracking choosing one path (prefer diagonal when match, else prefer up when dp[i-1][j] >= dp[i][j-1])
      let i = i0 ?? a.length;
      let j = j0 ?? b.length;
      let res = [];
      greedyPath = [];
      while (i > 0 && j > 0) {
        greedyPath.push([i,j]);
        if (a[i-1] === b[j-1] && dp[i][j] === dp[i-1][j-1] + 1) {
          res.push(a[i-1]);
          i--; j--;
        } else {
          if (dp[i-1][j] >= dp[i][j-1]) {
            i--;
          } else {
            j--;
          }
        }
      }
      // include last position (0,0) optionally
      greedyPath.push([i,j]);
      return res.reverse().join('');
    }

    function backtrackAll(a,b,dp, limit = 200) {
      // Return sorted array of distinct LCS strings.
      // Use memoization on (i,j).
      const memo = new Map();
      function key(i,j){ return i + ',' + j; }
      function rec(i,j) {
        const k = key(i,j);
        if (memo.has(k)) return memo.get(k);
        let res = new Set();
        if (i === 0 || j === 0) {
          res.add('');
          memo.set(k,res);
          return res;
        }
        if (a[i-1] === b[j-1]) {
          const prev = rec(i-1,j-1);
          for (const s of prev) {
            res.add(s + a[i-1]);
            if (res.size > limit) break;
          }
          memo.set(k,res);
          return res;
        } else {
          if (dp[i-1][j] >= dp[i][j-1]) {
            const up = rec(i-1,j);
            for (const s of up) {
              res.add(s);
              if (res.size > limit) break;
            }
          }
          if (dp[i][j-1] >= dp[i-1][j]) {
            const left = rec(i,j-1);
            for (const s of left) {
              res.add(s);
              if (res.size > limit) break;
            }
          }
          memo.set(k,res);
          return res;
        }
      }
      const out = Array.from(rec(a.length,b.length));
      // They are built reversed (because we appended from left?), check ordering:
      // In our construction for the matching case we did s + a[i-1] where prev s is LCS of prefixes up to i-1,j-1.
      // That means resulting strings are in correct left-to-right order.
      out.sort();
      return out;
    }

    function renderAll() {
      // read inputs
      A = clampInputLength(strAInput.value || '');
      B = clampInputLength(strBInput.value || '');
      strAInput.value = A;
      strBInput.value = B;
      if (A.length === 0 || B.length === 0) {
        summary.innerHTML = '<span class="danger">Both strings must be non-empty to compute LCS.</span>';
        matrixContainer.innerHTML = '';
        metaInfo.textContent = '';
        lcsList.innerHTML = '';
        foot.textContent = '';
        return;
      }
      computeDP(A,B);
      // Build table
      const table = buildMatrixHtml(A,B,dp);
      matrixContainer.innerHTML = '';
      matrixContainer.appendChild(table);

      const lcsLen = dp[m][n];
      const greedy = reconstructGreedy(A,B,dp); // will set greedyPath
      // Note: reconstructGreedy set greedyPath for the full (m,n) cell
      greedyPath = greedyPath.slice(); // snapshot
      summary.innerHTML = `LCS length = <span class="badge">${lcsLen}</span> &nbsp; Greedy example: <span class="badge">${greedy || '∅'}</span>`;
      metaInfo.textContent = `Strings: A length=${A.length}, B length=${B.length}. DP table size ${(m+1)}x${(n+1)}.`;

      lcsList.innerHTML = '';
      const showAll = showAllCb.checked;
      const limit = Math.max(1, Math.min(10000, parseInt(limitInput.value || '50',10)));
      if (showAll) {
        // compute all distinct LCS up to limit
        const start = performance.now();
        let all = [];
        try {
          all = backtrackAll(A,B,dp, limit+1); // get up to limit+1 to detect truncation
        } catch (e) {
          all = [];
        }
        const dur = (performance.now() - start).toFixed(1);
        const truncated = all.length > limit;
        if (truncated) {
          all = all.slice(0, limit);
        }
        allLCS = all;
        if (all.length === 0) {
          lcsList.textContent = 'No subsequence (length 0).';
        } else {
          all.forEach((s, idx) => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = s === '' ? '∅' : s;
            chip.title = 'Click to highlight the greedy path corresponding to this subsequence (if possible)';
            chip.addEventListener('click', () => {
              // When clicking a specific LCS, attempt to highlight one path that realizes it.
              highlightPathForSequence(s);
              // mark selection
              document.querySelectorAll('.chip').forEach(c => c.classList.remove('selected'));
              chip.classList.add('selected');
            });
            lcsList.appendChild(chip);
          });
        }
        foot.textContent = `Computed ${all.length}${truncated? ' (truncated)':''} distinct LCS in ${dur} ms. Limited to ${limit}.`;
      } else {
        // show just the greedy one
        allLCS = [greedy];
        lcsList.innerHTML = '';
        const chip = document.createElement('div');
        chip.className = 'chip selected';
        chip.textContent = greedy || '∅';
        chip.title = 'Greedy LCS example';
        chip.addEventListener('click', () => {
          highlightGreedyPath();
        });
        lcsList.appendChild(chip);
        foot.textContent = 'Showing a single greedy example (not necessarily the lexicographically smallest). Toggle "Show all" to list distinct LCS strings (may be many).';
      }

      // clear any highlighting
      clearHighlighting();
      highlighted = false;
      stepIndex = 0;
    }

    function clearHighlighting() {
      // remove 'path' class
      document.querySelectorAll('td.path').forEach(td => td.classList.remove('path'));
    }

    function highlightGreedyPath() {
      // highlight greedyPath computed from full (m,n)
      clearHighlighting();
      if (!greedyPath || greedyPath.length === 0) return;
      greedyPath.forEach(([i,j]) => {
        // find the td with data-i and data-j
        const td = matrixContainer.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
        if (td) td.classList.add('path');
      });
      highlighted = true;
    }

    function highlightGreedyPathFor(start, seq=null) {
      // Recompute greedy from start pos if provided. Otherwise use global greedyPath.
      clearHighlighting();
      let path = [];
      if (start) {
        const seqG = reconstructGreedy(A,B,dp, start[0],start[1]);
        path = greedyPath.slice();
      } else {
        path = greedyPath.slice();
      }
      path.forEach(([i,j]) => {
        const td = matrixContainer.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
        if (td) td.classList.add('path');
      });
      highlighted = true;
    }

    function highlightPathForSequence(seqStr) {
      // We know seqStr is an LCS string (one of allLCS). We want to find one path (i,j) sequence in dp that yields it.
      // We'll backtrack while matching seq characters from end to start.
      // Approach: walk from (m,n) down while building indexes where matches happen correspond to seq characters.
      clearHighlighting();
      if (seqStr === '') return;
      const L = seqStr.length;
      let i = m, j = n;
      const coords = [];
      let k = L - 1; // index into seqStr from end
      while (i > 0 && j > 0 && k >= 0) {
        if (A[i-1] === B[j-1] && A[i-1] === seqStr[k] && dp[i][j] === dp[i-1][j-1] + 1) {
          coords.push([i,j]);
          i--; j--; k--;
        } else {
          // prefer up if dp[i-1][j] >= dp[i][j-1]
          if (dp[i-1][j] >= dp[i][j-1]) i--;
          else j--;
        }
      }
      if (k >= 0) {
        // failed to find sequence along greedy choices; do a more exhaustive search to find any path that produces seqStr
        // We'll perform DFS that matches seqStr from start to finish.
        const target = seqStr;
        const memo = new Set();
        let foundPath = null;
        function dfs(i0,j0, pos, path) {
          if (foundPath) return true;
          const key = `${i0},${j0},${pos}`;
          if (memo.has(key)) return false;
          memo.add(key);
          if (pos === target.length) {
            // must have dp[i0][j0] === dp[0][0] ??? but we want to collect remaining zeros
            foundPath = path.slice();
            return true;
          }
          if (i0 === 0 || j0 === 0) return false;
          // try match going backward: look for a match at some (p,q) where A[p-1] == B[q-1] == target[pos]
          // But pos increases from 0..L-1; we are going forward in sequence; we need to walk forward through indices increasing.
          // To simplify, we'll search forward from (0,0).
          return false;
        }
        // fallback: highlight nothing
        foot.textContent = 'Could not locate a simple path for that sequence using greedy backtracking. (This can happen when multiple choices exist.)';
        return;
      } else {
        // coords are match positions in reverse order; highlight them plus intermediate steps optionally
        coords.forEach(([ii,jj]) => {
          const td = matrixContainer.querySelector(`td[data-i="${ii}"][data-j="${jj}"]`);
          if (td) td.classList.add('path');
        });
      }
    }

    // Step backtracking: step through greedyPath showing current cell
    function stepBacktracking() {
      if (!greedyPath || greedyPath.length === 0) return;
      // show next step by toggling 'path' for first stepIndex positions
      clearHighlighting();
      stepIndex = (stepIndex + 1) % (greedyPath.length + 1);
      for (let s = 0; s < stepIndex; s++) {
        const [i,j] = greedyPath[s];
        const td = matrixContainer.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
        if (td) td.classList.add('path');
      }
      metaInfo.textContent = `Backtracking step ${stepIndex}/${greedyPath.length}. Click "Step" to advance.`;
    }

    computeBtn.addEventListener('click', () => {
      try {
        renderAll();
      } catch (e) {
        summary.innerHTML = '<span class="danger">Error computing LCS: ' + (e && e.message ? e.message : String(e)) + '</span>';
        console.error(e);
      }
    });

    randomBtn.addEventListener('click', () => {
      // generate two random strings using uppercase letters of modest length
      const letters = "ABCDEFGHJKLMNPQRSTUVWXYZ"; // avoid some ambiguous letters
      const lenA = 6 + Math.floor(Math.random()*5);
      const lenB = 6 + Math.floor(Math.random()*5);
      let s1 = '', s2 = '';
      for (let i=0;i<lenA;i++) s1 += letters[Math.floor(Math.random()*letters.length)];
      for (let i=0;i<lenB;i++) s2 += letters[Math.floor(Math.random()*letters.length)];
      strAInput.value = s1;
      strBInput.value = s2;
      renderAll();
    });

    showAllCb.addEventListener('change', () => {
      // recompute when toggling
      if (A && B) renderAll();
    });

    limitInput.addEventListener('change', () => {
      if (A && B && showAllCb.checked) renderAll();
    });

    stepBtn.addEventListener('click', () => {
      if (!greedyPath || greedyPath.length === 0) {
        metaInfo.textContent = 'No path available. Compute LCS first.';
        return;
      }
      stepBacktracking();
    });

    resetStep.addEventListener('click', () => {
      stepIndex = 0;
      clearHighlighting();
      metaInfo.textContent = 'Backtracking reset.';
    });

    highlightBtn.addEventListener('click', () => {
      if (!greedyPath || greedyPath.length === 0) {
        metaInfo.textContent = 'No path available. Compute LCS first.';
        return;
      }
      if (highlighted) {
        clearHighlighting();
        highlighted = false;
      } else {
        highlightGreedyPath();
        highlighted = true;
      }
    });

    // Initial compute for defaults
    renderAll();

    // Explanatory helper in console
    console.log('LCS Visualizer ready. Use the UI to compute and explore DP table and backtracking.');
  </script>
</body>
</html>