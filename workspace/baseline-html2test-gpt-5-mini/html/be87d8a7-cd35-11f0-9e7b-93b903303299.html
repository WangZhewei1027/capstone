<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>K-Means Clustering Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 0; display: flex; height: 100vh; }
    #controls { width: 330px; padding: 14px; box-sizing: border-box; border-right: 1px solid #e0e0e0; background: #fafafa; overflow: auto; }
    #canvasWrap { flex: 1; display: flex; flex-direction: column; align-items: center; padding: 10px; box-sizing: border-box; }
    canvas { background: #fff; border: 1px solid #ddd; box-shadow: 0 1px 4px rgba(0,0,0,0.04); }
    h1 { font-size: 18px; margin: 6px 0 12px; }
    label { display: block; margin-top: 10px; font-size: 13px; color: #333; }
    input[type="number"], select, input[type="range"] { width: 100%; padding: 6px 8px; box-sizing: border-box; margin-top: 6px; }
    button { margin-top: 8px; padding: 8px 10px; width: 48%; }
    .row { display:flex; gap:6px; }
    .small { width: 48%; }
    .info { margin-top: 12px; font-size: 13px; color: #444; background: #fff; padding: 10px; border-radius: 6px; border: 1px solid #f0f0f0; }
    .legend { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
    .legendItem { display:flex; align-items:center; gap:6px; font-size:12px; }
    .dot { width:16px; height:12px; border-radius:3px; display:inline-block; border:1px solid rgba(0,0,0,0.08); }
    #chart { width:100%; height:80px; background:#fff; border:1px solid #eee; margin-top:8px; }
    footer { margin-top:8px; font-size:12px; color:#666; }
    .muted { color:#666; font-size:13px; }
    small { color:#666; }
  </style>
</head>
<body>
  <div id="controls">
    <h1>K-Means Clustering — Interactive Demo</h1>
    <div class="muted">Click on the canvas to add points. Use controls to generate data, choose K and initialization, then run step-by-step or autoplay.</div>

    <label>Number of points (when generating)</label>
    <input id="numPoints" type="number" min="1" max="5000" value="200">

    <label>Number of clusters (K)</label>
    <input id="kValue" type="number" min="1" max="20" value="4">

    <label>Initialization</label>
    <select id="initMethod">
      <option value="random">Random (pick K random points)</option>
      <option value="kmeans++">K-Means++</option>
    </select>

    <label>Generate pattern</label>
    <select id="pattern">
      <option value="blobs">Gaussian blobs</option>
      <option value="uniform">Uniform random</option>
      <option value="circles">Concentric circles</option>
      <option value="gaussian_mixture">Mixture (variable)</option>
    </select>

    <div class="row">
      <button id="generate">Generate Data</button>
      <button id="clear">Clear Points</button>
    </div>

    <label>Iterations / autoplay</label>
    <div class="row">
      <button id="initButton">Initialize Centroids</button>
      <button id="stepButton">Step</button>
    </div>
    <div class="row">
      <button id="startButton">Start</button>
      <button id="pauseButton">Pause</button>
    </div>

    <label>Auto speed (ms per iteration)</label>
    <input id="speedRange" type="range" min="50" max="2000" value="400">

    <div class="info">
      <div><strong>Iteration:</strong> <span id="iter">0</span></div>
      <div><strong>SSE (sum squared error):</strong> <span id="sse">—</span></div>
      <div><strong>Centroids:</strong> <span id="centroidsCount">0</span></div>
      <div><strong>Empty clusters handled:</strong> <span id="empties">0</span></div>
    </div>

    <label>Legend (clusters)</label>
    <div class="legend" id="legend"></div>

    <label>Loss history</label>
    <canvas id="chart" width="290" height="80"></canvas>

    <footer>
      <small>Tips: After initialization, press Step to see assignment and centroid updates. Click canvas to add single points. When an empty cluster appears it's reinitialized to a random point.</small>
    </footer>
  </div>

  <div id="canvasWrap">
    <canvas id="canvas" width="900" height="600"></canvas>
  </div>

<script>
(() => {
  // Colors for clusters
  const COLORS = ['#e6194b','#3cb44b','#ffe119','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6','#bcf60c','#fabebe','#008080','#e6beff','#9a6324','#fffac8','#800000'];
  // State
  let points = []; // {x,y,cluster}
  let centroids = []; // {x,y}
  let k = 4;
  let iter = 0;
  let sseHistory = [];
  let running = false;
  let empties = 0;
  let assignmentsChanged = true;
  let speed = 400;
  let initMethod = 'random';
  // Canvas
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const chart = document.getElementById('chart');
  const cctx = chart.getContext('2d');

  // Controls
  const numPointsInput = document.getElementById('numPoints');
  const kInput = document.getElementById('kValue');
  const initSelect = document.getElementById('initMethod');
  const patternSelect = document.getElementById('pattern');
  const generateBtn = document.getElementById('generate');
  const clearBtn = document.getElementById('clear');
  const initBtn = document.getElementById('initButton');
  const stepBtn = document.getElementById('stepButton');
  const startBtn = document.getElementById('startButton');
  const pauseBtn = document.getElementById('pauseButton');
  const iterEl = document.getElementById('iter');
  const sseEl = document.getElementById('sse');
  const centroidsCountEl = document.getElementById('centroidsCount');
  const legendEl = document.getElementById('legend');
  const emptiesEl = document.getElementById('empties');
  const speedRange = document.getElementById('speedRange');

  // Helpers: map mouse coords
  function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left),
      y: (evt.clientY - rect.top)
    };
  }

  // Generate synthetic data
  function generateData() {
    const n = Math.max(1, Math.min(5000, parseInt(numPointsInput.value||200)));
    const pattern = patternSelect.value;
    points = [];
    const W = canvas.width, H = canvas.height;
    if (pattern === 'uniform') {
      for (let i=0;i<n;i++) points.push({x: Math.random()*W, y: Math.random()*H, cluster: -1});
    } else if (pattern === 'blobs') {
      const centers = [];
      const ccount = Math.max(2, Math.min(8, Math.round(kInput.value) || 4));
      for (let i=0;i<ccount;i++) centers.push({x: 60 + Math.random()*(W-120), y: 60 + Math.random()*(H-120)});
      for (let i=0;i<n;i++){
        const c = centers[Math.floor(Math.random()*centers.length)];
        const r = Math.random()*40;
        const a = Math.random()*Math.PI*2;
        points.push({x: c.x + r*Math.cos(a) + randn()*6, y: c.y + r*Math.sin(a) + randn()*6, cluster: -1});
      }
    } else if (pattern === 'circles') {
      for (let i=0;i<n;i++){
        const r = (Math.random()*0.9+0.05) * Math.min(W,H)/2 * (Math.random()<0.5?0.4:1.0);
        const a = Math.random()*Math.PI*2;
        const cx = W/2 + randn()*10, cy = H/2 + randn()*10;
        points.push({x: cx + r*Math.cos(a), y: cy + r*Math.sin(a), cluster: -1});
      }
    } else if (pattern === 'gaussian_mixture') {
      const comps = Math.max(2, Math.min(8, Math.round(kInput.value) || 4));
      for (let i=0;i<comps;i++){
        const cx = 40 + Math.random()*(W-80), cy = 40 + Math.random()*(H-80);
        const sigma = 10 + Math.random()*40;
        for (let j=0;j<Math.floor(n/comps);j++){
          points.push({x: cx + randn()*sigma, y: cy + randn()*sigma, cluster: -1});
        }
      }
      while(points.length < n) points.push({x: Math.random()*W, y: Math.random()*H, cluster: -1});
    }
    iter = 0;
    sseHistory = [];
    centroids = [];
    empties = 0;
    updateInfo();
    redraw();
  }

  // Random normal helper (Box-Muller)
  function randn() {
    let u=0,v=0;
    while(u===0) u=Math.random();
    while(v===0) v=Math.random();
    return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
  }

  // Initialize centroids
  function initializeCentroids() {
    k = Math.max(1, Math.min(20, parseInt(kInput.value||4)));
    initMethod = initSelect.value;
    centroids = [];
    if (points.length === 0) {
      // place random centroids if no points
      for (let i=0;i<k;i++) centroids.push({x: Math.random()*canvas.width, y: Math.random()*canvas.height});
    } else {
      if (initMethod === 'random') {
        const idx = [];
        for (let i=0;i<points.length;i++) idx.push(i);
        // shuffle and pick first k
        for (let i=idx.length-1;i>0;i--) { const j=Math.floor(Math.random()*(i+1)); [idx[i],idx[j]]=[idx[j],idx[i]]; }
        for (let i=0;i<k;i++){
          const p = points[idx[i % idx.length]];
          centroids.push({x: p.x, y: p.y});
        }
      } else if (initMethod === 'kmeans++') {
        // k-means++ initialization
        const pts = points;
        // pick first uniformly
        const first = pts[Math.floor(Math.random()*pts.length)];
        centroids.push({x:first.x, y:first.y});
        while (centroids.length < k) {
          // compute squared distances to nearest existing centroid
          const d2 = pts.map(p => {
            let best = Infinity;
            for (const c of centroids) {
              const dx = p.x-c.x, dy = p.y-c.y;
              const dist2 = dx*dx + dy*dy;
              if (dist2 < best) best = dist2;
            }
            return best;
          });
          const sum = d2.reduce((a,b)=>a+b,0);
          if (sum === 0) { // all points identical
            // pick random
            const p = pts[Math.floor(Math.random()*pts.length)];
            centroids.push({x:p.x,y:p.y});
            continue;
          }
          // choose next with probability proportional to d2
          let r = Math.random()*sum;
          let chosen = 0;
          for (let i=0;i<d2.length;i++){
            r -= d2[i];
            if (r <= 0) { chosen = i; break; }
          }
          const p = pts[chosen];
          centroids.push({x:p.x,y:p.y});
        }
      }
    }
    // reset assignments
    for (const p of points) p.cluster = -1;
    iter = 0;
    empties = 0;
    sseHistory = [];
    updateInfo();
    redraw();
  }

  // Assignment step: assign each point to nearest centroid
  function assignPoints() {
    if (centroids.length === 0) return false;
    let changed = false;
    for (const p of points) {
      let best = -1, bestd = Infinity;
      for (let i=0;i<centroids.length;i++){
        const c = centroids[i];
        const dx = p.x - c.x, dy = p.y - c.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestd) { bestd = d2; best = i; }
      }
      if (p.cluster !== best) { p.cluster = best; changed = true; }
    }
    return changed;
  }

  // Update centroids: recompute as mean of assigned points
  function updateCentroids() {
    const sums = [];
    for (let i=0;i<centroids.length;i++) sums.push({x:0,y:0,c:0});
    for (const p of points) {
      const ci = p.cluster;
      if (ci >= 0 && ci < sums.length) {
        sums[ci].x += p.x; sums[ci].y += p.y; sums[ci].c += 1;
      }
    }
    let reinitCount = 0;
    for (let i=0;i<centroids.length;i++){
      if (sums[i].c === 0) {
        // empty cluster: reinitialize centroid to a random point
        const rp = points[Math.floor(Math.random()*points.length)];
        centroids[i] = {x: rp.x + (Math.random()-0.5)*20, y: rp.y + (Math.random()-0.5)*20};
        reinitCount++;
      } else {
        centroids[i] = {x: sums[i].x / sums[i].c, y: sums[i].y / sums[i].c};
      }
    }
    empties += reinitCount;
    return reinitCount;
  }

  // Compute SSE
  function computeSSE() {
    if (centroids.length === 0) return 0;
    let sse = 0;
    for (const p of points) {
      const c = centroids[p.cluster] || {x:0,y:0};
      const dx = p.x - c.x, dy = p.y - c.y;
      sse += dx*dx + dy*dy;
    }
    return sse;
  }

  // Perform one k-means iteration: assign then update
  function iterate() {
    if (centroids.length === 0 || points.length === 0) return;
    const changed = assignPoints();
    const reinit = updateCentroids();
    iter++;
    const sse = computeSSE();
    sseHistory.push(sse);
    updateInfo();
    redraw();
    // if no changes, we can stop
    if (!changed) {
      running = false;
      updateInfo();
    }
    return changed;
  }

  // Redraw canvas
  function redraw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // draw points
    ctx.save();
    for (const p of points) {
      const color = p.cluster >= 0 ? COLORS[p.cluster % COLORS.length] : '#888';
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.9;
      ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.stroke();
    }
    // draw centroids
    for (let i=0;i<centroids.length;i++){
      const c = centroids[i];
      const color = COLORS[i % COLORS.length];
      // draw cross
      ctx.beginPath();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.moveTo(c.x-10, c.y);
      ctx.lineTo(c.x+10, c.y);
      ctx.moveTo(c.x, c.y-10);
      ctx.lineTo(c.x, c.y+10);
      ctx.stroke();
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.9;
      ctx.arc(c.x, c.y, 7, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#fff';
      ctx.font = '11px sans-serif';
      ctx.fillText(i+1, c.x-6, c.y+4);
    }
    ctx.restore();
    drawLegend();
    drawChart();
  }

  // Update info panel
  function updateInfo() {
    iterEl.textContent = iter;
    sseEl.textContent = sseHistory.length ? sseHistory[sseHistory.length-1].toFixed(1) : '—';
    centroidsCountEl.textContent = centroids.length;
    emptiesEl.textContent = empties;
  }

  // Draw legend
  function drawLegend() {
    legendEl.innerHTML = '';
    for (let i=0;i<centroids.length;i++){
      const div = document.createElement('div');
      div.className = 'legendItem';
      const color = COLORS[i % COLORS.length];
      const box = document.createElement('span');
      box.className = 'dot';
      box.style.background = color;
      div.appendChild(box);
      const txt = document.createElement('span');
      // count points in cluster
      const count = points.filter(p=>p.cluster===i).length;
      txt.textContent = `#${i+1} (${count})`;
      div.appendChild(txt);
      legendEl.appendChild(div);
    }
    if (centroids.length === 0) {
      const div = document.createElement('div');
      div.className = 'muted';
      div.textContent = 'No centroids yet';
      legendEl.appendChild(div);
    }
  }

  // Draw SSE history chart
  function drawChart() {
    cctx.clearRect(0,0,chart.width,chart.height);
    cctx.fillStyle = '#fafafa';
    cctx.fillRect(0,0,chart.width,chart.height);
    if (sseHistory.length === 0) return;
    const w = chart.width, h = chart.height;
    const maxSSE = Math.max(...sseHistory);
    const minSSE = Math.min(...sseHistory);
    // small padding
    const pad = 6;
    cctx.beginPath();
    cctx.strokeStyle = '#3b82f6';
    cctx.lineWidth = 2;
    for (let i=0;i<sseHistory.length;i++){
      const x = pad + (w-2*pad) * (i/(sseHistory.length-1 || 1));
      const y = pad + (h-2*pad) * (1 - (sseHistory[i]-minSSE) / (maxSSE-minSSE || 1));
      if (i===0) cctx.moveTo(x,y); else cctx.lineTo(x,y);
    }
    cctx.stroke();
    // labels
    cctx.fillStyle = '#666';
    cctx.font = '10px sans-serif';
    cctx.fillText('SSE history', 6, 12);
    cctx.fillText((maxSSE||0).toFixed(0), w-40, 12);
    cctx.fillText((minSSE||0).toFixed(0), w-40, h-4);
  }

  // Control handlers
  generateBtn.addEventListener('click', ()=>{ generateData(); });
  clearBtn.addEventListener('click', ()=>{ points = []; centroids = []; iter = 0; sseHistory = []; empties = 0; updateInfo(); redraw(); });
  initBtn.addEventListener('click', ()=>{ initializeCentroids(); });
  stepBtn.addEventListener('click', ()=>{ iterate(); });
  startBtn.addEventListener('click', ()=>{ if (!running) { running = true; autoLoop(); } });
  pauseBtn.addEventListener('click', ()=>{ running = false; });
  kInput.addEventListener('change', ()=>{ /* nothing automatic */ });
  speedRange.addEventListener('input', ()=>{ speed = parseInt(speedRange.value); });

  // Canvas click to add points
  canvas.addEventListener('click', (e)=>{
    const pos = getMousePos(e);
    points.push({x: pos.x, y: pos.y, cluster: -1});
    iter = 0;
    sseHistory = [];
    redraw();
  });

  // Auto loop
  let lastTime=0;
  function autoLoop(ts) {
    if (!running) return;
    const now = Date.now();
    if (!lastTime || now - lastTime >= speed) {
      const changed = iterate();
      lastTime = now;
      if (!changed) running = false;
    }
    if (running) requestAnimationFrame(autoLoop);
  }

  // Initialize small demo
  function initDemo() {
    generateData();
  }

  // Handle empty cluster prevention: if user reduces K below current centroids, trim
  kInput.addEventListener('change', ()=> {
    const newK = Math.max(1, Math.min(20, parseInt(kInput.value||4)));
    if (centroids.length > newK) {
      centroids = centroids.slice(0,newK);
      for (const p of points) {
        if (p.cluster >= newK) p.cluster = -1;
      }
    }
    redraw();
  });

  // Responsive: adjust canvas size to available area (optional)
  function fitCanvas() {
    // keep fixed size for simplicity; we could adapt
    redraw();
  }
  window.addEventListener('resize', fitCanvas);

  // keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (e.key === ' ') { e.preventDefault(); running = !running; if (running) autoLoop(); }
    if (e.key === 's') iterate();
    if (e.key === 'i') initializeCentroids();
  });

  // Kick off
  initDemo();
})();
</script>
</body>
</html>