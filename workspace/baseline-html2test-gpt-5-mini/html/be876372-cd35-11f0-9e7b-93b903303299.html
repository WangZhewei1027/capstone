<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Binary Search Tree (BST) Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 0; padding: 0; display:flex; flex-direction:column; min-height:100vh; }
    header { background:#0b5; padding:12px 18px; color:#003; }
    header h1 { margin:0; font-size:18px; }
    .container { display:flex; gap:12px; padding:12px; flex:1; }
    .controls { width:320px; background:#fafafa; border-right:1px solid #eee; padding:12px; box-sizing:border-box; }
    .controls label { display:block; margin-top:8px; font-weight:600; }
    .controls input[type="number"], .controls input[type="text"] { width:100%; padding:8px; box-sizing:border-box; margin-top:6px; }
    .controls button { margin-top:8px; padding:8px 10px; width:100%; border:0; background:#0366d6; color:white; cursor:pointer; border-radius:6px; }
    .controls button.secondary { background:#6c757d; }
    .controls .row { display:flex; gap:8px; }
    .controls .row button { flex:1; margin-top:6px; }
    .info { margin-top:12px; font-size:13px; color:#333; background:#fff; padding:8px; border-radius:6px; border:1px solid #eee; max-height:180px; overflow:auto; }
    .visual { flex:1; padding:12px; display:flex; flex-direction:column; gap:8px; }
    #stageWrap { background:linear-gradient(#fff,#f8fafc); border:1px solid #e6eef8; border-radius:8px; padding:8px; flex:1; overflow:auto; }
    svg { width:100%; height:520px; }
    .log { font-family: monospace; font-size:13px; background:#111; color:#bfffbf; padding:8px; border-radius:6px; max-height:120px; overflow:auto; }
    footer { padding:8px 12px; font-size:12px; color:#666; border-top:1px solid #eee; }
    .small { font-size:13px; color:#444; margin-top:8px; }
  </style>
</head>
<body>
  <header>
    <h1>Binary Search Tree (BST) Visualizer</h1>
  </header>

  <div class="container">
    <div class="controls">
      <label for="valueInput">Value (number)</label>
      <input id="valueInput" type="number" placeholder="e.g. 42" />

      <div class="row">
        <button id="insertBtn">Insert</button>
        <button id="deleteBtn" class="secondary">Delete</button>
      </div>

      <label for="searchInput" style="margin-top:10px">Search</label>
      <input id="searchInput" type="number" placeholder="e.g. 42" />
      <div class="row">
        <button id="searchBtn">Search</button>
        <button id="clearBtn" class="secondary">Clear Tree</button>
      </div>

      <label style="margin-top:10px">Utilities</label>
      <div class="row">
        <button id="randomBtn">Randomize (10)</button>
        <button id="balancedBtn" class="secondary">Make Balanced</button>
      </div>

      <label style="margin-top:10px">Traversals</label>
      <div class="row">
        <button id="inorderBtn">In-order</button>
        <button id="preorderBtn" class="secondary">Pre-order</button>
      </div>
      <div class="row">
        <button id="postorderBtn">Post-order</button>
        <button id="levelBtn" class="secondary">Level-order</button>
      </div>

      <div class="small">Click a node to delete it. Search animates visited nodes. Duplicates are ignored.</div>

      <div class="info" id="info">Tree is empty.</div>
    </div>

    <div class="visual">
      <div id="stageWrap">
        <svg id="svgStage" xmlns="http://www.w3.org/2000/svg"></svg>
      </div>
      <div style="display:flex; gap:8px;">
        <div style="flex:1">
          <div class="log" id="log">Ready.</div>
        </div>
        <div style="width:260px">
          <div style="margin-bottom:6px; font-weight:600">Traversal Output</div>
          <div class="info" id="traversal">—</div>
        </div>
      </div>
    </div>
  </div>

  <footer>BST demo • Insert, Search, Delete, Traversals, Randomize, and simple layout/animation</footer>

  <script>
    // BST Implementation + Visualization
    (function () {
      // Data structure
      function Node(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        // visualization props
        this.x = 0;
        this.y = 0;
        this.id = 'n' + (++Node.counter);
      }
      Node.counter = 0;

      let root = null;

      // DOM
      const svg = document.getElementById('svgStage');
      const info = document.getElementById('info');
      const log = document.getElementById('log');
      const traversalEl = document.getElementById('traversal');

      // UI
      const valInput = document.getElementById('valueInput');
      const insertBtn = document.getElementById('insertBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const clearBtn = document.getElementById('clearBtn');
      const randomBtn = document.getElementById('randomBtn');
      const balancedBtn = document.getElementById('balancedBtn');
      const searchInput = document.getElementById('searchInput');
      const searchBtn = document.getElementById('searchBtn');
      const inorderBtn = document.getElementById('inorderBtn');
      const preorderBtn = document.getElementById('preorderBtn');
      const postorderBtn = document.getElementById('postorderBtn');
      const levelBtn = document.getElementById('levelBtn');

      // Insert value
      function insert(value) {
        if (root === null) {
          root = new Node(value);
          logMsg('Inserted root: ' + value);
          update();
          return true;
        }
        let cur = root;
        while (true) {
          if (value === cur.value) {
            logMsg('Value exists: ' + value + ' (duplicates ignored)');
            return false;
          } else if (value < cur.value) {
            if (cur.left === null) {
              cur.left = new Node(value);
              logMsg('Inserted ' + value + ' (left of ' + cur.value + ')');
              update();
              return true;
            }
            cur = cur.left;
          } else {
            if (cur.right === null) {
              cur.right = new Node(value);
              logMsg('Inserted ' + value + ' (right of ' + cur.value + ')');
              update();
              return true;
            }
            cur = cur.right;
          }
        }
      }

      // Search returning path
      function search(value) {
        let path = [];
        let cur = root;
        while (cur) {
          path.push(cur);
          if (value === cur.value) {
            return { found: true, path: path, node: cur };
          } else if (value < cur.value) {
            cur = cur.left;
          } else {
            cur = cur.right;
          }
        }
        return { found: false, path: path, node: null };
      }

      // Find minimum node and its parent in subtree
      function findMinNodeWithParent(node) {
        let parent = null;
        let cur = node;
        while (cur.left) {
          parent = cur;
          cur = cur.left;
        }
        return { min: cur, parent: parent };
      }

      // Delete value
      function deleteValue(value) {
        let deleted = false;

        function remove(node, value) {
          if (!node) return null;
          if (value < node.value) {
            node.left = remove(node.left, value);
            return node;
          } else if (value > node.value) {
            node.right = remove(node.right, value);
            return node;
          } else {
            // node to delete
            deleted = true;
            // case: no child
            if (!node.left && !node.right) return null;
            // case: one child
            if (!node.left) return node.right;
            if (!node.right) return node.left;
            // case: two children -> replace with inorder successor
            let { min } = findMinNodeWithParent(node.right);
            node.value = min.value;
            node.right = remove(node.right, min.value);
            return node;
          }
        }

        root = remove(root, value);
        if (deleted) {
          logMsg('Deleted ' + value);
        } else {
          logMsg('Value not found: ' + value);
        }
        update();
        return deleted;
      }

      // Traversals
      function inorder(node, arr) {
        if (!node) return;
        inorder(node.left, arr);
        arr.push(node.value);
        inorder(node.right, arr);
      }
      function preorder(node, arr) {
        if (!node) return;
        arr.push(node.value);
        preorder(node.left, arr);
        preorder(node.right, arr);
      }
      function postorder(node, arr) {
        if (!node) return;
        postorder(node.left, arr);
        postorder(node.right, arr);
        arr.push(node.value);
      }
      function levelOrder(node, arr) {
        if (!node) return;
        const q = [node];
        while (q.length) {
          const n = q.shift();
          arr.push(n.value);
          if (n.left) q.push(n.left);
          if (n.right) q.push(n.right);
        }
      }

      // Balanced tree creation from sorted array
      function buildBalancedFromSorted(arr, l = 0, r = arr.length - 1) {
        if (l > r) return null;
        const m = Math.floor((l + r) / 2);
        const n = new Node(arr[m]);
        n.left = buildBalancedFromSorted(arr, l, m - 1);
        n.right = buildBalancedFromSorted(arr, m + 1, r);
        return n;
      }

      // Utility log
      function logMsg(msg) {
        const t = new Date().toLocaleTimeString();
        log.textContent = '[' + t + '] ' + msg + '\n' + log.textContent;
      }

      // Visualization layout: in-order x assignment
      function assignPositions() {
        let spacingX = 60;
        let spacingY = 84;
        let nextX = 0;
        function dfs(node, depth) {
          if (!node) return;
          dfs(node.left, depth + 1);
          node.x = nextX++ * spacingX + 40;
          node.y = depth * spacingY + 40;
          dfs(node.right, depth + 1);
        }
        nextX = 0;
        dfs(root, 0);
      }

      // Draw the tree in SVG
      function draw() {
        // clear
        while (svg.firstChild) svg.removeChild(svg.firstChild);

        if (!root) {
          info.textContent = 'Tree is empty.';
          return;
        }
        assignPositions();

        // draw edges first
        function drawEdges(node) {
          if (!node) return;
          if (node.left) {
            let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', node.x);
            line.setAttribute('y1', node.y);
            line.setAttribute('x2', node.left.x);
            line.setAttribute('y2', node.left.y);
            line.setAttribute('stroke', '#999');
            line.setAttribute('stroke-width', '2');
            svg.appendChild(line);
          }
          if (node.right) {
            let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', node.x);
            line.setAttribute('y1', node.y);
            line.setAttribute('x2', node.right.x);
            line.setAttribute('y2', node.right.y);
            line.setAttribute('stroke', '#999');
            line.setAttribute('stroke-width', '2');
            svg.appendChild(line);
          }
          drawEdges(node.left);
          drawEdges(node.right);
        }
        drawEdges(root);

        // draw nodes (circles + text), clickable
        function drawNodes(node) {
          if (!node) return;
          // group
          const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          g.setAttribute('transform', 'translate(' + node.x + ',' + node.y + ')');
          g.setAttribute('data-id', node.id);
          g.style.cursor = 'pointer';

          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('r', 20);
          circle.setAttribute('fill', '#fff');
          circle.setAttribute('stroke', '#0366d6');
          circle.setAttribute('stroke-width', '2');
          circle.setAttribute('class', 'bst-node');
          g.appendChild(circle);

          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', 0);
          text.setAttribute('y', 6);
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('font-size', '12');
          text.setAttribute('fill', '#0366d6');
          text.textContent = node.value;
          g.appendChild(text);

          // click events: delete node on click
          g.addEventListener('click', function (ev) {
            ev.stopPropagation();
            if (confirm('Delete node ' + node.value + '?')) {
              deleteValue(node.value);
            }
          });

          // attach to svg
          svg.appendChild(g);

          // annotate data-id mapping (so we can highlight by node object later)
          g._nodeRef = node;

          drawNodes(node.left);
          drawNodes(node.right);
        }
        drawNodes(root);

        info.textContent = 'Root: ' + root.value;
      }

      // Highlight path (array of node objects) sequentially
      function animatePath(path, found) {
        if (!path || path.length === 0) {
          logMsg('No nodes visited.');
          return;
        }
        let i = 0;
        function step() {
          // clear all highlights
          const allCircles = svg.querySelectorAll('g > circle');
          allCircles.forEach(c => c.setAttribute('fill', '#fff'));
          const allTexts = svg.querySelectorAll('g > text');
          allTexts.forEach(t => t.setAttribute('fill', '#0366d6'));

          // highlight visited up to i
          for (let j = 0; j <= i && j < path.length; j++) {
            // find group for this node
            const groups = svg.querySelectorAll('g');
            for (const g of groups) {
              if (g._nodeRef === path[j]) {
                const c = g.querySelector('circle');
                const t = g.querySelector('text');
                if (j === i) {
                  c.setAttribute('fill', found && j === path.length - 1 ? '#7ee787' : '#ffe08a'); // green if found at last
                  t.setAttribute('fill', '#000');
                } else {
                  c.setAttribute('fill', '#fff3cd');
                  t.setAttribute('fill', '#000');
                }
                break;
              }
            }
          }
          i++;
          if (i < path.length) {
            setTimeout(step, 450);
          } else {
            // final highlight for result remains for a short time, then clear
            setTimeout(() => {
              const allCircles2 = svg.querySelectorAll('g > circle');
              allCircles2.forEach(c => c.setAttribute('fill', '#fff'));
              const allTexts2 = svg.querySelectorAll('g > text');
              allTexts2.forEach(t => t.setAttribute('fill', '#0366d6'));
            }, 800);
          }
        }
        step();
      }

      // Update UI and redraw
      function update() {
        draw();
        updateInfo();
      }

      function updateInfo() {
        if (!root) {
          info.textContent = 'Tree is empty.';
          document.title = 'BST: empty';
          traversalEl.textContent = '—';
          return;
        }
        document.title = 'BST: root=' + root.value;
        // show some stats
        let count = 0, height = 0;
        function dfs(n, d) {
          if (!n) return;
          count++;
          height = Math.max(height, d);
          dfs(n.left, d + 1);
          dfs(n.right, d + 1);
        }
        dfs(root, 1);
        info.textContent = 'Nodes: ' + count + ' • Height: ' + height + ' • Root: ' + root.value;
      }

      // Wire controls
      insertBtn.addEventListener('click', () => {
        const v = Number(valInput.value);
        if (Number.isNaN(v)) { alert('Enter a number'); return; }
        insert(v);
        valInput.value = '';
      });
      deleteBtn.addEventListener('click', () => {
        const v = Number(valInput.value);
        if (Number.isNaN(v)) { alert('Enter a number to delete (or click a node)'); return; }
        deleteValue(v);
        valInput.value = '';
      });
      clearBtn.addEventListener('click', () => {
        if (!root) return;
        if (!confirm('Clear the entire tree?')) return;
        root = null;
        logMsg('Tree cleared.');
        update();
      });

      randomBtn.addEventListener('click', () => {
        // generate 10 distinct random integers between 1 and 99
        const arr = [];
        while (arr.length < 10) {
          const n = Math.floor(Math.random() * 99) + 1;
          if (!arr.includes(n)) arr.push(n);
        }
        root = null;
        Node.counter = 0;
        arr.forEach(n => insert(n));
        logMsg('Random tree generated: ' + arr.join(', '));
        update();
      });

      balancedBtn.addEventListener('click', () => {
        // create balanced tree from current nodes
        const arr = [];
        inorder(root, arr);
        if (arr.length === 0) { alert('Tree is empty.'); return; }
        Node.counter = 0;
        root = buildBalancedFromSorted(arr);
        logMsg('Balanced tree created from sorted values.');
        update();
      });

      searchBtn.addEventListener('click', () => {
        const v = Number(searchInput.value);
        if (Number.isNaN(v)) { alert('Enter a number to search'); return; }
        const res = search(v);
        if (res.path.length === 0) {
          logMsg('Search visited 0 nodes.');
        } else {
          logMsg('Search visited: ' + res.path.map(n => n.value).join(' -> '));
        }
        animatePath(res.path, res.found);
        if (res.found) {
          logMsg('Found: ' + v);
        } else {
          logMsg('Not found: ' + v);
        }
      });

      inorderBtn.addEventListener('click', () => {
        const arr = [];
        inorder(root, arr);
        traversalEl.textContent = arr.length ? arr.join(', ') : '—';
        logMsg('In-order: ' + (arr.length ? arr.join(', ') : 'empty'));
      });
      preorderBtn.addEventListener('click', () => {
        const arr = [];
        preorder(root, arr);
        traversalEl.textContent = arr.length ? arr.join(', ') : '—';
        logMsg('Pre-order: ' + (arr.length ? arr.join(', ') : 'empty'));
      });
      postorderBtn.addEventListener('click', () => {
        const arr = [];
        postorder(root, arr);
        traversalEl.textContent = arr.length ? arr.join(', ') : '—';
        logMsg('Post-order: ' + (arr.length ? arr.join(', ') : 'empty'));
      });
      levelBtn.addEventListener('click', () => {
        const arr = [];
        levelOrder(root, arr);
        traversalEl.textContent = arr.length ? arr.join(', ') : '—';
        logMsg('Level-order: ' + (arr.length ? arr.join(', ') : 'empty'));
      });

      // click on blank SVG to focus inputs / clear highlight
      svg.addEventListener('click', () => {
        // clear highlight
        const allCircles = svg.querySelectorAll('g > circle');
        allCircles.forEach(c => c.setAttribute('fill', '#fff'));
        const allTexts = svg.querySelectorAll('g > text');
        allTexts.forEach(t => t.setAttribute('fill', '#0366d6'));
      });

      // initialize with a sample tree
      (function seed() {
        const sample = [50, 30, 70, 20, 40, 60, 80];
        root = null;
        Node.counter = 0;
        sample.forEach(n => insert(n));
        logMsg('Sample tree loaded: ' + sample.join(', '));
        update();
      })();

      // expose some functions to console for experimentation (optional)
      window._bst = {
        insert: (v) => insert(Number(v)),
        delete: (v) => deleteValue(Number(v)),
        search: (v) => search(Number(v)),
        root: () => root
      };
    })();
  </script>
</body>
</html>