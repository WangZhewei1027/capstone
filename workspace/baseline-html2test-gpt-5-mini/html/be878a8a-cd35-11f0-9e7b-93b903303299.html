<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Heap Sort Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#4f46e5;
      --muted:#9aa4bf;
      --good:#16a34a;
      --bad:#ef4444;
      --compare:#f59e0b;
      --swap:#ef4444;
      --bar:#60a5fa;
      --sorted:#10b981;
      --text:#e6eef8;
      --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box;font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    html,body{height:100%;margin:0;background:linear-gradient(180deg, #071025 0%, #081028 60%); color:var(--text);}
    .container{max-width:1200px;margin:18px auto;padding:18px;}
    header{display:flex;align-items:center;gap:16px;margin-bottom:16px}
    h1{font-size:20px;margin:0}
    .controls{display:flex;flex-wrap:wrap;gap:12px;align-items:center;background:var(--panel);padding:12px;border-radius:10px;box-shadow: 0 6px 18px rgba(6,8,12,0.6)}
    .control-group{display:flex;gap:8px;align-items:center}
    label{font-size:13px;color:var(--muted)}
    input[type=range]{width:160px}
    button{background:linear-gradient(180deg,var(--accent),#3730a3);color:white;padding:8px 12px;border-radius:8px;border:0;cursor:pointer;box-shadow: 0 6px 14px rgba(79,70,229,0.18)}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);box-shadow:none}
    input[type=text]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);min-width:220px}
    .main{display:grid;grid-template-columns:1fr 360px;gap:16px;margin-top:16px}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.012));padding:12px;border-radius:10px;box-shadow: 0 6px 18px rgba(2,6,23,0.6)}
    #visual{height:420px;display:flex;flex-direction:column;gap:8px;align-items:center;justify-content:center}
    #arrayCanvas{width:100%;height:180px;display:block}
    #treeSVG{width:100%;height:200px;display:block}
    .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .legend span{font-size:13px;padding:6px 8px;border-radius:6px;background:var(--glass);display:inline-flex;gap:8px;align-items:center}
    .dot{width:12px;height:12px;border-radius:3px;display:inline-block}
    .info{font-size:13px;color:var(--muted);margin-top:8px}
    pre{background:transparent;padding:8px;border-radius:8px;overflow:auto;color:var(--muted);font-size:13px}
    .pseudocode{line-height:1.6;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);font-family:monospace;margin-top:8px}
    .pseudocode div{padding:4px 6px;border-radius:6px}
    .pseudocode .active{background:linear-gradient(90deg, rgba(79,70,229,0.12), rgba(79,70,229,0.04));color:var(--text)}
    footer{margin-top:12px;font-size:13px;color:var(--muted)}
    .small{font-size:12px;color:var(--muted)}
    .big-button{padding:10px 14px;font-weight:600}
    .center{display:flex;align-items:center;gap:8px}
    .stats{display:flex;flex-direction:column;gap:6px;padding:8px}
    .stat{display:flex;justify-content:space-between;color:var(--muted);font-size:14px;padding:4px 6px;border-radius:6px}
    .array-controls{display:flex;gap:8px;flex-wrap:wrap}
    @media(max-width:980px){
      .main{grid-template-columns:1fr}
      #visual{height:520px}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Heap Sort — Visualizer & Interactive Demo</h1>
      <div class="small" style="margin-left:auto">Algorithm: In-place, comparison-based, O(n log n) average/worst</div>
    </header>

    <div class="controls">
      <div class="control-group">
        <label>Array size</label>
        <input id="sizeRange" type="range" min="5" max="32" value="12" />
        <div id="sizeLabel" class="small">12</div>
      </div>

      <div class="control-group">
        <label>Speed</label>
        <input id="speedRange" type="range" min="50" max="2000" value="450" />
        <div id="speedLabel" class="small">450 ms</div>
      </div>

      <div class="control-group array-controls">
        <button id="randomBtn">Randomize</button>
        <button id="ascBtn" class="ghost">Ascending</button>
        <button id="descBtn" class="ghost">Descending</button>
      </div>

      <div style="margin-left:auto;display:flex;gap:8px">
        <button id="playBtn" class="big-button">Play</button>
        <button id="stepBackBtn" class="ghost">Step ◀</button>
        <button id="stepFwdBtn" class="ghost">Step ▶</button>
        <button id="recordBtn" class="ghost">Record</button>
      </div>
    </div>

    <div class="main">
      <div class="panel" id="visual">
        <svg id="treeSVG" viewBox="0 0 1000 360" preserveAspectRatio="xMidYMid meet"></svg>
        <canvas id="arrayCanvas"></canvas>

        <div class="legend">
          <span><span class="dot" style="background:var(--compare)"></span> Comparing</span>
          <span><span class="dot" style="background:var(--swap)"></span> Swapping</span>
          <span><span class="dot" style="background:var(--sorted)"></span> Sorted</span>
          <span><span class="dot" style="background:var(--bar)"></span> Unsorted</span>
        </div>

        <div class="info" id="actionText">Press Record to generate the step list, then Play or Step through actions.</div>
      </div>

      <div class="panel">
        <div class="stats">
          <div class="stat"><strong>Action</strong><span id="statAction">—</span></div>
          <div class="stat"><strong>Comparisons</strong><span id="statCompares">0</span></div>
          <div class="stat"><strong>Swaps</strong><span id="statSwaps">0</span></div>
          <div class="stat"><strong>Heap size</strong><span id="statHeapSize">—</span></div>
          <div class="stat"><strong>Step</strong><span id="statStep">0 / 0</span></div>
        </div>

        <div style="margin-top:10px">
          <label>Custom array (comma separated)</label>
          <div style="display:flex;gap:8px;margin-top:6px">
            <input id="customInput" type="text" placeholder="e.g. 5,3,8,1,7" />
            <button id="applyCustom" class="ghost">Apply</button>
          </div>
        </div>

        <div class="pseudocode" id="pseudocode">
          <!-- pseudocode lines will be inserted by JS -->
        </div>

        <footer>
          <div style="margin-top:10px" class="small">
            How it works: First build a max-heap (sift-down from middle to root). Then repeatedly swap the root (max) with the last element of the heap, reduce heap size, and sift-down the new root. This demo records comparisons and swaps and replays them for step-by-step visualization.
          </div>
        </footer>
      </div>
    </div>
  </div>

  <script>
/*
  Heap Sort Visualizer
  - Records actions (compare, swap, changeHeapSize, markSorted) while performing heap sort on a copy.
  - Replay engine rebuilds the array at any step by re-applying actions from the initial array.
  - Visualizes array as bars and as a binary tree (SVG). Highlights indices involved in current action.
*/

(function(){
  // UI references
  const sizeRange = document.getElementById('sizeRange');
  const sizeLabel = document.getElementById('sizeLabel');
  const speedRange = document.getElementById('speedRange');
  const speedLabel = document.getElementById('speedLabel');
  const randomBtn = document.getElementById('randomBtn');
  const ascBtn = document.getElementById('ascBtn');
  const descBtn = document.getElementById('descBtn');
  const playBtn = document.getElementById('playBtn');
  const stepBackBtn = document.getElementById('stepBackBtn');
  const stepFwdBtn = document.getElementById('stepFwdBtn');
  const recordBtn = document.getElementById('recordBtn');
  const arrayCanvas = document.getElementById('arrayCanvas');
  const treeSVG = document.getElementById('treeSVG');
  const actionText = document.getElementById('actionText');
  const statCompares = document.getElementById('statCompares');
  const statSwaps = document.getElementById('statSwaps');
  const statHeapSize = document.getElementById('statHeapSize');
  const statAction = document.getElementById('statAction');
  const statStep = document.getElementById('statStep');
  const customInput = document.getElementById('customInput');
  const applyCustom = document.getElementById('applyCustom');
  const pseudocodeDiv = document.getElementById('pseudocode');

  const ctx = arrayCanvas.getContext('2d');

  // State
  let array = [];
  let initialArray = [];
  let actions = []; // recorded actions
  let stepIndex = 0; // how many actions applied (0..actions.length)
  let playing = false;
  let timer = null;
  let compares = 0, swaps = 0;
  let currentMarkers = {}; // for highlighting current indices in visualization
  let heapSize = 0;

  // pseudocode lines for highlighting
  const pseudocodeLines = [
    "function heapSort(A):",
    "  n = A.length",
    "  // Build max heap",
    "  for i = floor(n/2)-1 down to 0:",
    "    siftDown(A, i, n)",
    "  // Extract elements",
    "  for end = n-1 down to 1:",
    "    swap(A[0], A[end])",
    "    heapSize = end",
    "    siftDown(A, 0, heapSize)",
    "",
    "function siftDown(A, i, heapSize):",
    "  while true:",
    "    left = 2*i + 1",
    "    right = left + 1",
    "    largest = i",
    "    if left < heapSize and A[left] > A[largest]: largest = left",
    "    if right < heapSize and A[right] > A[largest]: largest = right",
    "    if largest == i: break",
    "    swap(A[i], A[largest])",
    "    i = largest"
  ];

  function renderPseudocode(activeIndex){
    pseudocodeDiv.innerHTML = '';
    pseudocodeLines.forEach((line, i) => {
      const el = document.createElement('div');
      el.textContent = (i+1).toString().padStart(2,' ') + "  " + line;
      if(activeIndex === i+1) el.classList.add('active');
      pseudocodeDiv.appendChild(el);
    });
  }

  // Initialize pseudocode
  renderPseudocode(null);

  // Helpers: random array
  function generateRandom(n){
    const arr=[];
    for(let i=0;i<n;i++){
      arr.push(Math.floor(Math.random()*100)+1);
    }
    return arr;
  }

  function setArray(arr){
    array = arr.slice();
    initialArray = arr.slice();
    actions = [];
    stepIndex = 0;
    compares = 0;
    swaps = 0;
    heapSize = arr.length;
    updateStats();
    draw();
    treeDraw();
    actionText.textContent = "Array ready. Press Record to produce the action list for Heap Sort.";
  }

  // Resize canvas to device pixel ratio for crispness
  function fitCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const rect = arrayCanvas.getBoundingClientRect();
    arrayCanvas.width = Math.max(300, rect.width) * dpr;
    arrayCanvas.height = rect.height * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize',()=>{
    fitCanvas();
    draw();
    treeDraw();
  });

  // Drawing array as bars
  function draw(stateArray = array, markers = currentMarkers){
    fitCanvas();
    const w = arrayCanvas.width / (window.devicePixelRatio || 1);
    const h = arrayCanvas.height / (window.devicePixelRatio || 1);
    ctx.clearRect(0,0,w,h);
    const n = stateArray.length;
    if(n===0) return;
    const padding = 10;
    const usableW = w - padding*2;
    const gap = Math.max(2, Math.floor(usableW / (n*15)));
    const barW = Math.max(8, (usableW - (n-1)*gap)/n);
    const maxVal = Math.max(...stateArray);
    for(let i=0;i<n;i++){
      const val = stateArray[i];
      const x = padding + i*(barW+gap);
      const barH = (h-40) * (val / (maxVal || 1));
      const y = h - barH - 20;
      // decide color
      let color = getComputedStyle(document.documentElement).getPropertyValue('--bar').trim();
      if(markers.swap && (markers.swap[0]===i || markers.swap[1]===i)) color = getComputedStyle(document.documentElement).getPropertyValue('--swap').trim();
      else if(markers.compare && (markers.compare[0]===i || markers.compare[1]===i)) color = getComputedStyle(document.documentElement).getPropertyValue('--compare').trim();
      else if(markers.sorted && markers.sorted.includes(i)) color = getComputedStyle(document.documentElement).getPropertyValue('--sorted').trim();
      // draw bar
      ctx.fillStyle = color;
      roundRect(ctx, x, y, barW, barH, 4, true, false);
      // index label
      ctx.fillStyle = "#dbeafe";
      ctx.font = "11px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(String(val), x+barW/2, h-6);
    }
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof stroke == 'undefined') stroke = true;
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y,   x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x,   y + h, r);
    ctx.arcTo(x,   y + h, x,   y,   r);
    ctx.arcTo(x,   y,   x + w, y,   r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Tree drawing using indexed positions
  function treeDraw(stateArray = array, markers = currentMarkers){
    // clear
    while(treeSVG.firstChild) treeSVG.removeChild(treeSVG.firstChild);
    const n = stateArray.length;
    if(n===0) return;
    const svgW = 1000;
    const svgH = 360;
    // compute positions: per level, nodes spread evenly
    const positions = [];
    const levels = Math.floor(Math.log2(n))+1;
    for(let i=0;i<n;i++){
      const level = Math.floor(Math.log2(i+1));
      const indexInLevel = i - (Math.pow(2,level)-1);
      const nodesThisLevel = Math.pow(2,level);
      const margin = 40;
      const availW = svgW - margin*2;
      const x = margin + (indexInLevel + 0.5) * (availW / nodesThisLevel);
      const y = 30 + level * (svgH - 60) / Math.max(1, levels-1);
      positions.push({x,y});
    }
    // draw connections
    for(let i=1;i<n;i++){
      const parent = Math.floor((i-1)/2);
      const p = positions[parent];
      const c = positions[i];
      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute('x1', p.x);
      line.setAttribute('y1', p.y + 16);
      line.setAttribute('x2', c.x);
      line.setAttribute('y2', c.y - 16);
      line.setAttribute('stroke', 'rgba(255,255,255,0.06)');
      line.setAttribute('stroke-width','2');
      treeSVG.appendChild(line);
    }
    // draw nodes
    for(let i=0;i<n;i++){
      const pos = positions[i];
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);
      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute('x', -18);
      rect.setAttribute('y', -18);
      rect.setAttribute('rx', 6);
      rect.setAttribute('ry', 6);
      rect.setAttribute('width', 36);
      rect.setAttribute('height', 36);
      // choose fill based on markers
      let fill = getComputedStyle(document.documentElement).getPropertyValue('--glass').trim();
      if(markers.swap && (markers.swap[0]===i || markers.swap[1]===i)) fill = getComputedStyle(document.documentElement).getPropertyValue('--swap').trim();
      else if(markers.compare && (markers.compare[0]===i || markers.compare[1]===i)) fill = getComputedStyle(document.documentElement).getPropertyValue('--compare').trim();
      else if(markers.sorted && markers.sorted.includes(i)) fill = getComputedStyle(document.documentElement).getPropertyValue('--sorted').trim();
      rect.setAttribute('fill', fill);
      rect.setAttribute('stroke', 'rgba(255,255,255,0.06)');
      g.appendChild(rect);
      const text = document.createElementNS("http://www.w3.org/2000/svg","text");
      text.setAttribute('x', 0);
      text.setAttribute('y', 5);
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('font-size', '13');
      text.setAttribute('fill', '#e6eef8');
      text.textContent = String(stateArray[i]);
      g.appendChild(text);
      const idxText = document.createElementNS("http://www.w3.org/2000/svg","text");
      idxText.setAttribute('x', 0);
      idxText.setAttribute('y', 26);
      idxText.setAttribute('text-anchor', 'middle');
      idxText.setAttribute('fill', '#9aa4bf');
      idxText.setAttribute('font-size', '11');
      idxText.textContent = i;
      g.appendChild(idxText);
      treeSVG.appendChild(g);
    }
  }

  // Recording actions during heap sort
  function record(actionType, ...args){
    actions.push({type:actionType, args:args});
  }

  // Implement heap sort on a copy while recording actions. We mutate arr internally to simulate behavior and record.
  function recordHeapSort(arrInput){
    const arr = arrInput.slice();
    actions = [];
    compares = 0;
    swaps = 0;
    const n = arr.length;
    let heapSz = n;

    function recCompare(i,j){
      if(i<0||j<0||i>=heapSz||j>=heapSz) return;
      record('compare', i, j);
      compares++;
      // no return value recorded; actual comparison done in code below
    }
    function recSwap(i,j){
      record('swap', i, j);
      const t=arr[i]; arr[i]=arr[j]; arr[j]=t;
      swaps++;
    }
    function siftDown(i){
      record('siftStart', i); // highlight sifting root
      while(true){
        let left = 2*i+1, right = left+1;
        let largest = i;
        if(left < heapSz){
          recCompare(left, largest);
          if(arr[left] > arr[largest]) largest = left;
        }
        if(right < heapSz){
          recCompare(right, largest);
          if(arr[right] > arr[largest]) largest = right;
        }
        if(largest === i){
          record('siftEnd', i);
          break;
        }
        recSwap(i, largest);
        i = largest;
      }
    }

    // Build heap
    for(let i = Math.floor(n/2)-1; i>=0; i--){
      record('buildStep', i);
      siftDown(i);
    }

    // Extract
    for(let end = n-1; end>0; end--){
      recSwap(0,end);
      heapSz = end;
      record('heapSize', heapSz);
      record('markSorted', end);
      siftDown(0);
    }
    record('markSorted', 0);
    record('done');
    return {actions, compares, swaps};
  }

  // Apply first k actions to reconstruct state. This allows stepping backwards by resetting and replaying.
  function applyActions(k){
    // reset
    array = initialArray.slice();
    compares = 0;
    swaps = 0;
    heapSize = array.length;
    currentMarkers = {compare:null, swap:null, sorted:[]};
    // apply actions in sequence
    for(let i=0;i<k && i<actions.length;i++){
      const a = actions[i];
      if(a.type==='compare'){
        compares++;
        currentMarkers.compare = a.args.slice();
        currentMarkers.swap = null;
      } else if(a.type==='swap'){
        swaps++;
        const [p,q] = a.args;
        const t = array[p]; array[p] = array[q]; array[q] = t;
        currentMarkers.swap = a.args.slice();
        currentMarkers.compare = null;
      } else if(a.type==='heapSize'){
        heapSize = a.args[0];
      } else if(a.type==='markSorted'){
        const idx = a.args[0];
        if(!currentMarkers.sorted.includes(idx)) currentMarkers.sorted.push(idx);
      } else if(a.type==='siftStart'){
        currentMarkers.compare = null;
        currentMarkers.swap = null;
      } else if(a.type==='siftEnd'){
        // no op
      } else if(a.type==='buildStep'){
        // no op
      } else if(a.type==='done'){
        // done
      }
    }
    // After replaying up to k, ensure sorted mark includes elements with index >= heapSize
    for(let i=heapSize;i<array.length;i++){
      if(!currentMarkers.sorted.includes(i)) currentMarkers.sorted.push(i);
    }
    // update UI
    draw(array, currentMarkers);
    treeDraw(array, currentMarkers);
    updateStats();
  }

  // Progress control
  function play(){
    if(playing) return;
    if(actions.length===0){
      actionText.textContent = "No recorded actions. Press Record first.";
      return;
    }
    playing = true;
    playBtn.textContent = "Pause";
    runLoop();
  }
  function pause(){
    playing = false;
    playBtn.textContent = "Play";
    if(timer) { clearTimeout(timer); timer=null; }
  }
  function togglePlay(){
    if(playing) pause(); else play();
  }
  function runLoop(){
    const delay = Math.max(50, parseInt(speedRange.value,10));
    if(stepIndex >= actions.length){
      pause();
      return;
    }
    stepIndex++;
    applyActions(stepIndex);
    // highlight relevant pseudocode line
    highlightForAction(actions[Math.max(0,stepIndex-1)]);
    timer = setTimeout(()=>{
      if(playing) runLoop();
    }, delay);
  }

  // Step functions
  function stepForward(){
    if(actions.length===0) { actionText.textContent = "No recorded actions. Press Record."; return; }
    if(stepIndex < actions.length) stepIndex++;
    applyActions(stepIndex);
    highlightForAction(actions[Math.max(0,stepIndex-1)]);
    pause();
  }
  function stepBack(){
    if(stepIndex>0) stepIndex--;
    applyActions(stepIndex);
    if(stepIndex>0) highlightForAction(actions[stepIndex-1]);
    else { renderPseudocode(null); actionText.textContent = "At start."; }
    pause();
  }

  // Map actions to pseudocode lines and action text
  function highlightForAction(action){
    if(!action) return;
    let actionDesc = "";
    let line = null;
    switch(action.type){
      case 'compare':
        actionDesc = `Compare indices ${action.args[0]} and ${action.args[1]}`;
        line = 14; // comparisons in siftDown (line numbers correspond to pseudocodeLines index +1)
        break;
      case 'swap':
        actionDesc = `Swap indices ${action.args[0]} and ${action.args[1]}`;
        line = 18;
        break;
      case 'heapSize':
        actionDesc = `Heap size reduced to ${action.args[0]}`;
        line = 7;
        break;
      case 'markSorted':
        actionDesc = `Mark index ${action.args[0]} as sorted`;
        line = 6;
        break;
      case 'siftStart':
        actionDesc = `Sift down from index ${action.args[0]}`;
        line = 11;
        break;
      case 'siftEnd':
        actionDesc = `Sift finished`;
        line = 16;
        break;
      case 'buildStep':
        actionDesc = `Build-heap: sift index ${action.args[0]}`;
        line = 4;
        break;
      case 'done':
        actionDesc = `Sorting complete`;
        line = 6;
        break;
      default:
        actionDesc = action.type;
    }
    actionText.textContent = actionDesc;
    renderPseudocode(line);
  }

  // Update stat displays
  function updateStats(){
    statCompares.textContent = compares;
    statSwaps.textContent = swaps;
    statHeapSize.textContent = heapSize;
    statStep.textContent = `${stepIndex} / ${Math.max(0, actions.length)}`;
    // action text updated elsewhere
  }

  // Event handlers
  sizeRange.addEventListener('input',()=>{
    const n = parseInt(sizeRange.value,10);
    sizeLabel.textContent = n;
    // regenerate random array of size n
    setArray(generateRandom(n));
  });

  speedRange.addEventListener('input',()=>{
    speedLabel.textContent = speedRange.value + " ms";
  });

  randomBtn.addEventListener('click',()=>{
    setArray(generateRandom(parseInt(sizeRange.value,10)));
  });

  ascBtn.addEventListener('click',()=>{
    const n = parseInt(sizeRange.value,10);
    const arr = [];
    for(let i=1;i<=n;i++) arr.push(i);
    setArray(arr);
  });

  descBtn.addEventListener('click',()=>{
    const n = parseInt(sizeRange.value,10);
    const arr = [];
    for(let i=n;i>=1;i--) arr.push(i);
    setArray(arr);
  });

  applyCustom.addEventListener('click',()=>{
    const text = customInput.value.trim();
    if(!text) return;
    const parts = text.split(',').map(s=>s.trim()).filter(s=>s.length);
    const nums = [];
    for(const p of parts){
      const v = Number(p);
      if(Number.isNaN(v)){ alert('Invalid number: ' + p); return; }
      nums.push(v);
    }
    setArray(nums);
    sizeRange.value = Math.min(32, Math.max(5, nums.length));
    sizeLabel.textContent = nums.length;
  });

  recordBtn.addEventListener('click',()=>{
    // record actions based on initialArray
    if(initialArray.length===0) {
      actionText.textContent = "No array to record.";
      return;
    }
    const res = recordHeapSort(initialArray);
    compares = res.compares;
    swaps = res.swaps;
    // reset counters for replay; we'll show final counts via stats as we step
    stepIndex = 0;
    currentMarkers = {compare:null, swap:null, sorted:[]};
    heapSize = initialArray.length;
    updateStats();
    actionText.textContent = `Recorded ${actions.length} actions (approx). Comparisons: ${compares}, Swaps: ${swaps}. Use Play or Step to replay.`;
    // reset counters displayed to zero until replay
    statCompares.textContent = 0;
    statSwaps.textContent = 0;
    statStep.textContent = `0 / ${actions.length}`;
    renderPseudocode(null);
  });

  playBtn.addEventListener('click', ()=>{ togglePlay(); });

  stepFwdBtn.addEventListener('click', ()=>{ stepForward(); });

  stepBackBtn.addEventListener('click', ()=>{ stepBack(); });

  // Initialize with random array
  setArray(generateRandom(parseInt(sizeRange.value,10)));

  // initial drawing
  draw();
  treeDraw();

  // Keyboard shortcuts
  window.addEventListener('keydown',(e)=>{
    if(e.key === " "){ e.preventDefault(); togglePlay(); }
    if(e.key === "ArrowRight"){ stepForward(); }
    if(e.key === "ArrowLeft"){ stepBack(); }
  });

  // Make sure initial canvas height set
  function setCanvasHeight(){
    arrayCanvas.style.height = '180px';
    fitCanvas();
    draw();
  }
  setCanvasHeight();

})();
  </script>
</body>
</html>