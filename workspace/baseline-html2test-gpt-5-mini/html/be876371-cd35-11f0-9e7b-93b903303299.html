<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Interactive Binary Tree (BST) Demonstration</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root {
      --bg: #f7f9fc;
      --panel: #ffffff;
      --accent: #2b7cff;
      --muted: #6b7280;
      --success: #16a34a;
      --danger: #ef4444;
      --node-fill: #ffffff;
      --node-stroke: #1f2937;
    }
    html,body { height:100%; margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:#111827; }
    .wrap { display:flex; gap:16px; padding:18px; box-sizing:border-box; height:100%; }
    .left {
      flex:1 1 0;
      display:flex;
      flex-direction:column;
      background:var(--panel);
      border-radius:12px;
      padding:14px;
      box-shadow:0 2px 8px rgba(15,23,42,0.06);
    }
    .right {
      width:360px;
      min-width:260px;
      max-width:420px;
      background:var(--panel);
      border-radius:12px;
      padding:14px;
      box-shadow:0 2px 8px rgba(15,23,42,0.06);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    h2 { margin:4px 0 8px 0; font-size:16px; }
    .canvas-wrap {
      position:relative;
      border-radius:10px;
      background:linear-gradient(180deg,#fff,#fbfdff);
      flex:1 1 0;
      overflow:auto;
      padding:8px;
      border:1px solid rgba(15,23,42,0.04);
    }
    svg { width:100%; height:600px; display:block; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .controls input[type="number"] { width:110px; padding:8px 10px; border-radius:8px; border:1px solid #e6e9ef; }
    button {
      background:var(--accent);
      color:white;
      border:0;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      box-shadow:0 2px 6px rgba(43,124,255,0.18);
    }
    button.secondary {
      background:#f3f4f6; color:#111827; box-shadow:none; border:1px solid rgba(15,23,42,0.06);
    }
    button.danger { background:var(--danger); box-shadow:none; }
    .muted { color:var(--muted); font-size:13px; }
    .panel-section { background: #fbfdff; border-radius:8px; padding:10px; border:1px dashed rgba(15,23,42,0.04); }
    .stats { display:flex; gap:10px; flex-wrap:wrap; }
    .stat { background:linear-gradient(180deg,#ffffff,#f8fafc); padding:8px 10px; border-radius:8px; border:1px solid rgba(15,23,42,0.04); min-width:90px; text-align:center; }
    .traversal-buttons { display:flex; gap:8px; flex-wrap:wrap; }
    .log { background:#0b1220; color:#dbeafe; padding:8px; border-radius:8px; font-family: monospace; font-size:13px; max-height:120px; overflow:auto; }
    .hint { font-size:13px; color:var(--muted); }
    .small { font-size:13px; color:var(--muted); }
    .legend { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .legend .item { display:flex; gap:6px; align-items:center; }
    .circle-key { width:16px; height:16px; border-radius:50%; display:inline-block; border:1px solid rgba(0,0,0,0.06); }
    .footer { font-size:13px; color:var(--muted); margin-top:8px; }
    a { color:var(--accent); text-decoration:none; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="left">
      <h2>Binary Tree (Binary Search Tree) Visualizer</h2>
      <div class="canvas-wrap">
        <!-- SVG will be inserted here by JS -->
        <svg id="svgCanvas" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid meet"></svg>
      </div>
      <div style="display:flex; justify-content:space-between; margin-top:10px; gap:8px; align-items:center;">
        <div class="hint">Click a node to fill its value in the input. The layout uses the inorder-based placement to show tree structure clearly.</div>
        <div class="legend">
          <div class="item"><span class="circle-key" style="background:var(--node-fill); border:2px solid var(--node-stroke)"></span> Node</div>
          <div class="item"><span class="circle-key" style="background:var(--accent)"></span> Visiting</div>
          <div class="item"><span class="circle-key" style="background:var(--success)"></span> Found / Active</div>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="panel-section">
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
          <input id="valueInput" type="number" placeholder="Value (integer)" />
          <button id="insertBtn">Insert</button>
          <button id="deleteBtn" class="secondary">Delete</button>
          <button id="searchBtn" class="secondary">Search</button>
        </div>
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px;">
          <button id="randomBtn" class="secondary">Random tree</button>
          <button id="clearBtn" class="danger">Clear</button>
        </div>
        <div class="small">Click nodes to pick value. Duplicates are not allowed in this demo (simple BST).</div>
      </div>

      <div class="panel-section">
        <h3 style="margin:6px 0 8px 0; font-size:14px;">Traversals & Animation</h3>
        <div class="traversal-buttons">
          <button data-tr="inorder" class="secondary">Inorder</button>
          <button data-tr="preorder" class="secondary">Preorder</button>
          <button data-tr="postorder" class="secondary">Postorder</button>
          <button data-tr="levelorder" class="secondary">Level-order</button>
        </div>
        <div style="display:flex; gap:8px; margin-top:8px;">
          <button id="playBtn">Play</button>
          <button id="stepBtn" class="secondary">Step</button>
          <button id="stopBtn" class="secondary">Stop</button>
        </div>
        <div style="margin-top:8px;">
          <div class="muted">Traversal output:</div>
          <div id="traversalOutput" class="log" aria-live="polite"></div>
        </div>
      </div>

      <div class="panel-section">
        <h3 style="margin:6px 0 8px 0; font-size:14px;">Tree Info</h3>
        <div class="stats">
          <div class="stat">
            <div class="muted">Nodes</div>
            <div id="nodeCount">0</div>
          </div>
          <div class="stat">
            <div class="muted">Height</div>
            <div id="treeHeight">0</div>
          </div>
          <div class="stat">
            <div class="muted">Root</div>
            <div id="rootVal">—</div>
          </div>
        </div>
        <div style="margin-top:8px;">
          <div class="muted">Search result:</div>
          <div id="searchResult" class="small">No query</div>
        </div>
      </div>

      <div class="panel-section">
        <div class="muted">Instructions</div>
        <ul style="margin:6px 0 0 16px; padding:0;">
          <li>Insert integers; the tree is organized as a Binary Search Tree (left < value < right).</li>
          <li>Use traversal buttons to prepare a traversal, then Play to animate node visits.</li>
          <li>Click a node in the drawing to auto-fill its value into the input for quick delete/search.</li>
        </ul>
      </div>

      <div class="footer small">Built for demonstration. Source is in the page. Enjoy exploring binary tree operations.</div>
    </div>
  </div>

<script>
/*
 Interactive Binary Search Tree visualizer
 - Insert, Delete, Search
 - Traversals: inorder, preorder, postorder, level-order
 - Animated visiting with Play / Step / Stop
 - Clicking nodes fills the input with its value
 - Layout: positions assigned using inorder index for clean structure
*/

(function(){
  // Basic BST Node
  class Node {
    constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
      this.parent = null;
      // layout
      this.x = 0;
      this.y = 0;
      this.depth = 0;
      this._id = Node._idCounter++;
    }
  }
  Node._idCounter = 1;

  // BST class
  class BST {
    constructor() {
      this.root = null;
      this._count = 0;
    }
    insert(value) {
      if (this.root == null) {
        this.root = new Node(value);
        this._count = 1;
        return this.root;
      }
      let cur = this.root;
      while (true) {
        if (value === cur.value) return null; // no duplicates in this demo
        if (value < cur.value) {
          if (cur.left) cur = cur.left;
          else {
            let n = new Node(value);
            cur.left = n; n.parent = cur;
            this._count++;
            return n;
          }
        } else {
          if (cur.right) cur = cur.right;
          else {
            let n = new Node(value);
            cur.right = n; n.parent = cur;
            this._count++;
            return n;
          }
        }
      }
    }
    search(value) {
      let cur = this.root;
      const path = [];
      while (cur) {
        path.push(cur);
        if (value === cur.value) return { node:cur, path };
        cur = (value < cur.value) ? cur.left : cur.right;
      }
      return { node:null, path };
    }
    delete(value) {
      const res = this.search(value);
      const node = res.node;
      if (!node) return false;
      this._deleteNode(node);
      this._count--;
      return true;
    }
    _transplant(u,v) {
      if (!u.parent) this.root = v;
      else if (u === u.parent.left) u.parent.left = v;
      else u.parent.right = v;
      if (v) v.parent = u.parent;
    }
    _minimum(n) {
      while (n.left) n = n.left;
      return n;
    }
    _deleteNode(z) {
      // standard BST delete
      if (!z.left) {
        this._transplant(z, z.right);
      } else if (!z.right) {
        this._transplant(z, z.left);
      } else {
        const y = this._minimum(z.right);
        if (y.parent !== z) {
          this._transplant(y, y.right);
          y.right = z.right;
          if (y.right) y.right.parent = y;
        }
        this._transplant(z, y);
        y.left = z.left;
        if (y.left) y.left.parent = y;
      }
    }
    size() { return this._count; }
    height() {
      function h(node) {
        if (!node) return 0;
        return 1 + Math.max(h(node.left), h(node.right));
      }
      return h(this.root);
    }
    // Traversals returning arrays of nodes
    inorder() {
      const out = [];
      (function dfs(n){ if(!n) return; dfs(n.left); out.push(n); dfs(n.right);} )(this.root);
      return out;
    }
    preorder() {
      const out = [];
      (function dfs(n){ if(!n) return; out.push(n); dfs(n.left); dfs(n.right);} )(this.root);
      return out;
    }
    postorder() {
      const out = [];
      (function dfs(n){ if(!n) return; dfs(n.left); dfs(n.right); out.push(n);} )(this.root);
      return out;
    }
    levelorder() {
      const out = [];
      if (!this.root) return out;
      const q = [this.root];
      while (q.length) {
        const n = q.shift();
        out.push(n);
        if (n.left) q.push(n.left);
        if (n.right) q.push(n.right);
      }
      return out;
    }
  }

  // Global tree instance
  const tree = new BST();

  // DOM references
  const svg = document.getElementById('svgCanvas');
  const insertBtn = document.getElementById('insertBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const searchBtn = document.getElementById('searchBtn');
  const randomBtn = document.getElementById('randomBtn');
  const clearBtn = document.getElementById('clearBtn');
  const valueInput = document.getElementById('valueInput');

  const nodeCountEl = document.getElementById('nodeCount');
  const treeHeightEl = document.getElementById('treeHeight');
  const rootValEl = document.getElementById('rootVal');

  const traversalOutput = document.getElementById('traversalOutput');
  const traversalButtons = document.querySelectorAll('[data-tr]');
  const playBtn = document.getElementById('playBtn');
  const stepBtn = document.getElementById('stepBtn');
  const stopBtn = document.getElementById('stopBtn');

  const searchResult = document.getElementById('searchResult');

  // Visualization parameters
  const NODE_RADIUS = 22;
  const V_SPACING = 90; // vertical spacing per depth
  const H_SPACING = 70; // horizontal multiplier for inorder positions

  // State for animation
  let currentTraversal = []; // array of nodes
  let travIndex = 0;
  let travTimer = null;
  let travSpeed = 700; // ms per node

  // Helper: clear svg
  function clearSVG() {
    while (svg.firstChild) svg.removeChild(svg.firstChild);
  }

  // Layout assignment using inorder index (gives tidy BST layout)
  function assignLayout() {
    let xCounter = 0;
    function assign(node, depth=0) {
      if (!node) return;
      assign(node.left, depth+1);
      node.depth = depth;
      node.x = ++xCounter * H_SPACING;
      node.y = (depth+1) * V_SPACING;
      assign(node.right, depth+1);
    }
    assign(tree.root, 0);
    // If tree is not empty, adjust svg viewBox width to fit
    const totalWidth = Math.max(1200, (xCounter+2) * H_SPACING);
    svg.setAttribute('viewBox', `0 0 ${Math.max(1200,totalWidth)} 700`);
  }

  // Draw tree: lines then nodes
  function render() {
    clearSVG();
    assignLayout();
    if (!tree.root) {
      drawEmptyHint();
      updateStats();
      return;
    }
    // Prepare connectors
    function drawEdges(node) {
      if (!node) return;
      if (node.left) drawLine(node, node.left);
      if (node.right) drawLine(node, node.right);
      drawEdges(node.left);
      drawEdges(node.right);
    }
    drawEdges(tree.root);

    // Draw nodes (so they appear above lines)
    function drawNodes(node) {
      if (!node) return;
      drawNode(node);
      drawNodes(node.left);
      drawNodes(node.right);
    }
    drawNodes(tree.root);
    updateStats();
  }

  function drawEmptyHint() {
    const g = createSVG('g');
    g.setAttribute('transform','translate(260,220)');
    const rect = createSVG('rect');
    rect.setAttribute('x','0'); rect.setAttribute('y','0'); rect.setAttribute('width','680'); rect.setAttribute('height','160');
    rect.setAttribute('fill','transparent');
    g.appendChild(rect);
    const text = createSVG('text');
    text.setAttribute('x','20'); text.setAttribute('y','30'); text.setAttribute('fill','#374151'); text.setAttribute('font-size','16');
    text.textContent = 'The tree is empty. Insert some integers to begin.';
    g.appendChild(text);
    svg.appendChild(g);
  }

  function drawLine(a,b) {
    const line = createSVG('line');
    line.setAttribute('x1', a.x);
    line.setAttribute('y1', a.y);
    line.setAttribute('x2', b.x);
    line.setAttribute('y2', b.y);
    line.setAttribute('stroke','#94a3b8');
    line.setAttribute('stroke-width','2');
    svg.appendChild(line);
  }

  // Create node group: circle + text, with id linking to node._id
  function drawNode(node) {
    const g = createSVG('g');
    g.setAttribute('data-id', node._id);
    g.setAttribute('transform', `translate(${node.x},${node.y})`);
    g.style.cursor = 'pointer';
    const circle = createSVG('circle');
    circle.setAttribute('cx','0'); circle.setAttribute('cy','0'); circle.setAttribute('r', NODE_RADIUS);
    circle.setAttribute('fill', 'var(--node-fill)');
    circle.setAttribute('stroke', 'var(--node-stroke)');
    circle.setAttribute('stroke-width','2');
    circle.setAttribute('data-role','circle');
    g.appendChild(circle);

    const text = createSVG('text');
    text.setAttribute('x','0'); text.setAttribute('y','6');
    text.setAttribute('fill','#0b1220'); text.setAttribute('font-size','13'); text.setAttribute('text-anchor','middle');
    text.setAttribute('font-weight','700');
    text.textContent = node.value;
    g.appendChild(text);

    // Attach click to pick value
    g.addEventListener('click', (ev) => {
      ev.stopPropagation();
      valueInput.value = node.value;
      highlightNode(node, '#16a34a', 800); // briefly highlight as selected
    });

    svg.appendChild(g);
  }

  // Utility: create SVG element
  function createSVG(tag) {
    return document.createElementNS('http://www.w3.org/2000/svg', tag);
  }

  // Highlight node (by node object) with color and optional duration
  function highlightNode(node, color='#2b7cff', duration=500) {
    // find element with data-id
    const g = svg.querySelector(`g[data-id="${node._id}"]`);
    if (!g) return;
    const circle = g.querySelector('circle[data-role="circle"]');
    if (!circle) return;
    const prevFill = circle.getAttribute('fill');
    circle.setAttribute('fill', color);
    circle.setAttribute('stroke','#0b1220');
    if (duration) {
      setTimeout(()=> {
        circle.setAttribute('fill', prevFill);
        circle.setAttribute('stroke','var(--node-stroke)');
      }, duration);
    }
  }

  // Update stats panel
  function updateStats() {
    nodeCountEl.textContent = tree.size();
    treeHeightEl.textContent = tree.height();
    rootValEl.textContent = tree.root ? tree.root.value : '—';
  }

  // Traversal selection logic
  let selectedTraversal = 'inorder';
  traversalButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      selectedTraversal = btn.getAttribute('data-tr');
      traversalButtons.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      prepareTraversal();
    });
  });

  function prepareTraversal() {
    if (!tree.root) {
      traversalOutput.textContent = '';
      currentTraversal = [];
      travIndex = 0;
      return;
    }
    switch (selectedTraversal) {
      case 'inorder': currentTraversal = tree.inorder(); break;
      case 'preorder': currentTraversal = tree.preorder(); break;
      case 'postorder': currentTraversal = tree.postorder(); break;
      case 'levelorder': currentTraversal = tree.levelorder(); break;
      default: currentTraversal = [];
    }
    travIndex = 0;
    renderTraversalOutput();
    // reset node visuals
    render();
  }

  function renderTraversalOutput() {
    const values = currentTraversal.map(n => n.value);
    traversalOutput.textContent = values.length ? values.join(' → ') : '(empty)';
  }

  // Play animation
  function playTraversal() {
    if (!currentTraversal || currentTraversal.length === 0) return;
    stopTraversal();
    travTimer = setInterval(()=> {
      if (travIndex >= currentTraversal.length) {
        stopTraversal();
        return;
      }
      const node = currentTraversal[travIndex++];
      highlightNode(node, getVisitColor(node), travSpeed * 0.9);
      flashOutput(node.value);
    }, travSpeed);
  }
  function stepTraversal() {
    if (!currentTraversal || currentTraversal.length === 0) return;
    if (travIndex >= currentTraversal.length) return;
    const node = currentTraversal[travIndex++];
    highlightNode(node, getVisitColor(node), travSpeed * 0.9);
    flashOutput(node.value);
  }
  function stopTraversal() {
    if (travTimer) clearInterval(travTimer);
    travTimer = null;
  }

  // Color selection for visit (special-case: if search active and found, green)
  function getVisitColor(node) {
    if (searchTarget !== null && node.value === searchTarget) return '#16a34a';
    return 'var(--accent)';
  }

  // Flash the traversal output region to show visiting
  function flashOutput(val) {
    traversalOutput.textContent = `[visiting] ${val}   —  sequence: ${currentTraversal.map(n=>n.value).join(' → ')}`;
    // revert after short delay (non-blocking)
    setTimeout(()=> {
      renderTraversalOutput();
    }, travSpeed * 0.9);
  }

  // Event bindings
  insertBtn.addEventListener('click', () => {
    const v = parseInt(valueInput.value);
    if (Number.isNaN(v)) { alert('Enter an integer value.'); return; }
    const inserted = tree.insert(v);
    if (!inserted) {
      alert('Value already exists in this BST (duplicates not allowed).');
      return;
    }
    prepareTraversal();
    render();
    valueInput.focus();
  });

  deleteBtn.addEventListener('click', () => {
    const v = parseInt(valueInput.value);
    if (Number.isNaN(v)) { alert('Enter an integer to delete.'); return; }
    const ok = tree.delete(v);
    if (!ok) {
      alert('Value not found.');
      return;
    }
    prepareTraversal();
    render();
  });

  let searchTarget = null;
  searchBtn.addEventListener('click', () => {
    const v = parseInt(valueInput.value);
    if (Number.isNaN(v)) { alert('Enter an integer to search.'); return; }
    searchTarget = v;
    const res = tree.search(v);
    if (res.node) {
      // highlight path and found node
      render();
      // show path highlights progressively
      res.path.forEach((n, i) => {
        setTimeout(()=> {
          highlightNode(n, i === res.path.length-1 ? '#16a34a' : '#f59e0b', 700);
        }, i * 250);
      });
      searchResult.textContent = `Found. Visited ${res.path.map(n=>n.value).join(' → ')}`;
    } else {
      render();
      // highlight path only
      res.path.forEach((n, i) => {
        setTimeout(()=> {
          highlightNode(n, '#f97316', 700);
        }, i * 250);
      });
      searchResult.textContent = `Not found. Path: ${res.path.map(n=>n.value).join(' → ')}`;
    }
  });

  randomBtn.addEventListener('click', () => {
    const count = Math.floor(Math.random() * 8) + 4; // 4..11 nodes
    tree.root = null;
    tree._count = 0;
    Node._idCounter = 1;
    const values = [];
    while (values.length < count) {
      const v = Math.floor(Math.random() * 99) + 1;
      if (!values.includes(v)) values.push(v);
    }
    values.forEach(v => tree.insert(v));
    prepareTraversal();
    render();
  });

  clearBtn.addEventListener('click', () => {
    if (!confirm('Clear the entire tree?')) return;
    tree.root = null;
    tree._count = 0;
    Node._idCounter = 1;
    prepareTraversal();
    render();
  });

  playBtn.addEventListener('click', () => {
    if (!currentTraversal || currentTraversal.length === 0) prepareTraversal();
    playTraversal();
  });
  stepBtn.addEventListener('click', () => {
    if (!currentTraversal || currentTraversal.length === 0) prepareTraversal();
    stepTraversal();
  });
  stopBtn.addEventListener('click', () => {
    stopTraversal();
  });

  // Clicking background clears input and selection
  svg.addEventListener('click', (ev) => {
    valueInput.value = '';
    searchTarget = null;
    searchResult.textContent = 'No query';
  });

  // Initialize with some sample values
  (function initDemo(){
    const initial = [50, 30, 70, 20, 40, 60, 80];
    initial.forEach(v => tree.insert(v));
    prepareTraversal();
    render();
  })();

  // Expose some keyboard shortcuts for convenience
  document.addEventListener('keydown', (ev) => {
    if (ev.key === 'Enter') {
      // Enter triggers Insert
      insertBtn.click();
    }
  });

  // Make the nodes slightly more responsive on resize: recompute layout on window resize
  let resizeTimer = null;
  window.addEventListener('resize', ()=> {
    if (resizeTimer) clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=> {
      render();
    }, 120);
  });

  // Initial stats update
  updateStats();

})();
</script>
</body>
</html>