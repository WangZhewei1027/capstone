<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hash Map (Hash Table) Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#2dd4bf;
      --muted:#94a3b8;
      --card:#071022;
      --danger:#fb7185;
      --success:#86efac;
      --glass: rgba(255,255,255,0.02);
    }
    html,body{height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue","Noto Sans",Arial,"Apple Color Emoji","Segoe UI Emoji"; background:linear-gradient(180deg,#071024 0%, #071129 50%, #041420 100%); color:#e6eef6;}
    .app{display:flex; gap:16px; padding:20px; box-sizing:border-box; min-height:100vh;}
    .side{
      width:340px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border:1px solid rgba(255,255,255,0.03);
      padding:18px;
      border-radius:10px;
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
    }
    h1{font-size:18px; margin:0 0 8px 0; color:var(--accent);}
    p.lead{margin:0 0 14px 0; color:var(--muted); font-size:13px;}
    label{display:block; font-size:13px; color:var(--muted); margin-top:10px;}
    input[type="text"], input[type="number"], select{
      width:100%; padding:8px 10px; margin-top:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:var(--glass); color:#dff9f0; box-sizing:border-box;
    }
    button, .btn{
      margin-top:8px; padding:8px 10px; border-radius:6px; border:0; background:var(--accent); color:#032025; cursor:pointer; font-weight:600;
    }
    .btn.secondary{background:#1f2937; color:#cbd5e1;}
    .btn.warn{background:var(--danger); color:white;}
    .row{display:flex; gap:8px;}
    .controls{margin-top:12px;}
    .vis{
      flex:1; padding:18px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border:1px solid rgba(255,255,255,0.03); box-shadow: 0 6px 30px rgba(2,6,23,0.6);
      display:flex; flex-direction:column; height:calc(100vh - 80px); overflow:hidden;
    }
    .stats{display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap;}
    .stat{
      background:rgba(255,255,255,0.02); padding:8px 10px; border-radius:8px; color:var(--muted); font-size:13px; min-width:120px;
    }
    .buckets{flex:1; overflow:auto; padding:12px; display:flex; gap:8px; align-items:flex-start;}
    .bucket{
      min-width:120px; max-width:160px; background:rgba(255,255,255,0.02); padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.02);
      box-sizing:border-box; position:relative;
    }
    .bucketIndex{font-size:12px; color:var(--muted); margin-bottom:6px;}
    .items{display:flex; flex-direction:column; gap:6px;}
    .item{
      background:#04222a; color:#bcefe2; padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.02); font-size:13px; display:flex; justify-content:space-between; align-items:center;
    }
    .item .k{color:#9fead5; font-weight:700; margin-right:8px;}
    .item .v{color:#d4fbe8; opacity:0.9;}
    .bucket .len{position:absolute; top:10px; right:8px; background:rgba(255,255,255,0.03); padding:2px 6px; border-radius:999px; font-size:12px; color:var(--muted);}
    .highlight{box-shadow:0 0 0 3px rgba(45,212,191,0.08) inset, 0 8px 30px rgba(2,6,23,0.6); transform:translateY(-2px); transition:all 200ms;}
    .found{box-shadow:0 0 10px rgba(134,239,172,0.25); border:1px solid rgba(134,239,172,0.2);}
    .log{height:140px; margin-top:12px; overflow:auto; background:rgba(1,6,11,0.4); border-radius:8px; padding:8px; font-size:13px; color:var(--muted);}
    .logEntry{margin-bottom:6px;}
    .small{font-size:12px; color:var(--muted);}
    .controls .hint{margin-top:6px; font-size:12px; color:var(--muted);}
    .footer{margin-top:10px; font-size:12px; color:var(--muted);}
    .toggle{display:flex; align-items:center; gap:8px; margin-top:10px; font-size:13px;}
    .mini{font-size:11px; padding:6px 8px;}
    .danger{color:var(--danger);}
    .success{color:var(--success);}
    .kbd{background:rgba(255,255,255,0.02); padding:2px 6px; border-radius:4px; font-weight:700; font-size:12px; color:#dff9f0;}
    .progress{height:8px; background:rgba(255,255,255,0.02); border-radius:999px; overflow:hidden; margin-top:6px;}
    .progress > i{display:block; height:100%; background:linear-gradient(90deg,var(--accent),#86efac); width:0%;}
    /* small screens */
    @media (max-width:900px){
      .app{flex-direction:column;}
      .side{width:100%;}
      .vis{height:auto; min-height:60vh;}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="side">
      <h1>Hash Map (Hash Table) â€” Demo</h1>
      <p class="lead">Interactive visualization of a hash map implemented with separate chaining. Try put/get/delete, inspect buckets, and see collisions & resizing.</p>

      <label>Key</label>
      <input id="keyInput" type="text" placeholder="e.g. username or 42" />

      <label>Value</label>
      <input id="valueInput" type="text" placeholder="e.g. Alice" />

      <div class="controls">
        <div class="row">
          <button id="putBtn" class="btn">Put</button>
          <button id="getBtn" class="btn secondary">Get</button>
          <button id="delBtn" class="btn warn">Delete</button>
        </div>

        <div class="row" style="margin-top:8px;">
          <button id="containsBtn" class="btn secondary mini">Contains?</button>
          <button id="clearBtn" class="btn secondary mini">Clear</button>
          <button id="randomBtn" class="btn mini">Insert 8 Random</button>
        </div>

        <label style="margin-top:12px;">Initial Capacity</label>
        <input id="capacityInput" type="number" min="2" value="8" />
        <div class="row">
          <button id="setCapacityBtn" class="btn secondary mini">Set Capacity</button>
          <button id="rebuildBtn" class="btn mini">Rehash (rehash items)</button>
        </div>

        <label>Auto-resize</label>
        <div class="toggle">
          <input id="autoResize" type="checkbox" checked />
          <span class="small">Enable automatic resizing (when load factor exceeds threshold)</span>
        </div>

        <label style="margin-top:8px;">Load factor threshold: <span id="thresholdLabel">0.75</span></label>
        <input id="thresholdInput" type="number" min="0.1" max="0.95" step="0.05" value="0.75" />

        <label style="margin-top:8px;">Find collisions for key</label>
        <div class="row">
          <button id="findCollisionsBtn" class="btn mini">Find 1 collision</button>
          <button id="findManyBtn" class="btn secondary mini">Find 5 collisions</button>
        </div>
        <div class="hint small">Collision search tests small strings; it searches deterministically (a..z) and won't freeze the UI.</div>
      </div>

      <div class="footer">
        <div style="margin-top:12px;"><span class="kbd">Hash:</span> djb2 (string -> integer) mod capacity</div>
        <div class="small" style="margin-top:6px;">Implementation: separate chaining (each bucket holds an array of entries)</div>
      </div>
    </div>

    <div class="vis">
      <div class="stats">
        <div class="stat">Capacity: <span id="cap">8</span></div>
        <div class="stat">Size: <span id="size">0</span></div>
        <div class="stat">Load factor: <span id="lf">0.00</span></div>
        <div class="stat">Resizing: <span id="resizing">on</span></div>
        <div class="stat">Threshold: <span id="thresh">0.75</span></div>
      </div>

      <div id="progressBar" class="progress" title="Load">
        <i id="progressFill"></i>
      </div>

      <div id="buckets" class="buckets" aria-live="polite" style="margin-top:12px;"></div>

      <div class="log" id="log"></div>
    </div>
  </div>

  <script>
    // Simple djb2 hash for strings
    function djb2(str) {
      // Accept non-string keys by converting to string
      str = String(str);
      var hash = 5381;
      for (var i = 0; i < str.length; i++) {
        hash = ((hash << 5) + hash) + str.charCodeAt(i); // hash * 33 + c
        hash = hash & 0xFFFFFFFF;
      }
      return Math.abs(hash);
    }

    // HashMap with separate chaining (buckets are arrays of {k,v})
    class HashMap {
      constructor(capacity=8, loadFactor=0.75, enableResize=true) {
        this.capacity = Math.max(2, Math.floor(capacity));
        this.loadFactor = loadFactor;
        this.enableResize = enableResize;
        this.size = 0;
        this.buckets = [];
        for (let i = 0; i < this.capacity; i++) this.buckets.push([]);
      }

      _index(key) {
        const h = djb2(key);
        return {hash: h, index: h % this.capacity};
      }

      put(key, value) {
        const {hash, index} = this._index(key);
        const bucket = this.buckets[index];
        for (let e of bucket) {
          if (this._equals(e.k, key)) {
            e.v = value;
            return {action: 'updated', index, hash};
          }
        }
        bucket.push({k: key, v: value});
        this.size++;
        const shouldResize = this.enableResize && (this.size / this.capacity > this.loadFactor);
        return {action: 'inserted', index, hash, shouldResize};
      }

      get(key) {
        const {hash, index} = this._index(key);
        const bucket = this.buckets[index];
        for (let e of bucket) {
          if (this._equals(e.k, key)) return {found: true, value: e.v, index, hash};
        }
        return {found: false, index, hash};
      }

      delete(key) {
        const {hash, index} = this._index(key);
        const bucket = this.buckets[index];
        for (let i = 0; i < bucket.length; i++) {
          if (this._equals(bucket[i].k, key)) {
            const val = bucket[i].v;
            bucket.splice(i, 1);
            this.size--;
            return {deleted: true, value: val, index, hash};
          }
        }
        return {deleted: false, index, hash};
      }

      containsKey(key) {
        return this.get(key).found;
      }

      clear() {
        this.capacity = Math.max(2, this.capacity);
        this.buckets = [];
        for (let i = 0; i < this.capacity; i++) this.buckets.push([]);
        this.size = 0;
      }

      // Rehash: change capacity and reinsert all items
      rehash(newCapacity) {
        const oldEntries = [];
        for (let b of this.buckets) {
          for (let e of b) oldEntries.push(e);
        }
        this.capacity = Math.max(2, Math.floor(newCapacity));
        this.buckets = [];
        for (let i = 0; i < this.capacity; i++) this.buckets.push([]);
        this.size = 0;
        for (let e of oldEntries) {
          const {index} = this._index(e.k);
          this.buckets[index].push({k: e.k, v: e.v});
          this.size++;
        }
      }

      entries() {
        const arr = [];
        for (let b of this.buckets) for (let e of b) arr.push(e);
        return arr;
      }

      _equals(a,b) {
        // using strict equality for this demo; transforming both to string would treat numbers and strings same
        return a === b;
      }
    }

    // UI / App logic
    const keyInput = document.getElementById('keyInput');
    const valueInput = document.getElementById('valueInput');
    const putBtn = document.getElementById('putBtn');
    const getBtn = document.getElementById('getBtn');
    const delBtn = document.getElementById('delBtn');
    const containsBtn = document.getElementById('containsBtn');
    const clearBtn = document.getElementById('clearBtn');
    const randomBtn = document.getElementById('randomBtn');
    const capacityInput = document.getElementById('capacityInput');
    const setCapacityBtn = document.getElementById('setCapacityBtn');
    const rehashBtn = document.getElementById('rebuildBtn');
    const autoResize = document.getElementById('autoResize');
    const thresholdInput = document.getElementById('thresholdInput');
    const thresholdLabel = document.getElementById('thresholdLabel');
    const findCollisionsBtn = document.getElementById('findCollisionsBtn');
    const findManyBtn = document.getElementById('findManyBtn');

    const capEl = document.getElementById('cap');
    const sizeEl = document.getElementById('size');
    const lfEl = document.getElementById('lf');
    const resizingEl = document.getElementById('resizing');
    const threshEl = document.getElementById('thresh');

    const bucketsEl = document.getElementById('buckets');
    const logEl = document.getElementById('log');
    const progressFill = document.getElementById('progressFill');
    const progressBar = document.getElementById('progressBar');

    let map = new HashMap(8, parseFloat(thresholdInput.value), autoResize.checked);

    function log(msg, cls) {
      const div = document.createElement('div');
      div.className = 'logEntry';
      if (cls) div.style.color = cls;
      div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logEl.prepend(div);
    }

    function render() {
      // update stats
      capEl.textContent = map.capacity;
      sizeEl.textContent = map.size;
      const lf = (map.size / map.capacity) || 0;
      lfEl.textContent = lf.toFixed(2);
      threshEl.textContent = map.loadFactor.toFixed(2);
      resizingEl.textContent = map.enableResize ? 'on' : 'off';
      thresholdLabel.textContent = map.loadFactor.toFixed(2);

      // progress bar
      const pct = Math.min(100, Math.round(lf * 100));
      progressFill.style.width = pct + '%';

      // show buckets
      bucketsEl.innerHTML = '';
      for (let i = 0; i < map.capacity; i++) {
        const bdiv = document.createElement('div');
        bdiv.className = 'bucket';
        bdiv.dataset.index = i;

        const idx = document.createElement('div');
        idx.className = 'bucketIndex';
        idx.textContent = `Bucket ${i}`;
        bdiv.appendChild(idx);

        const len = document.createElement('div');
        len.className = 'len';
        len.textContent = map.buckets[i].length;
        bdiv.appendChild(len);

        const items = document.createElement('div');
        items.className = 'items';

        for (let e of map.buckets[i]) {
          const it = document.createElement('div');
          it.className = 'item';
          it.dataset.key = String(e.k);
          const left = document.createElement('div');
          left.style.display = 'flex';
          left.style.alignItems = 'center';
          const kspan = document.createElement('div');
          kspan.className = 'k';
          kspan.textContent = String(e.k);
          const vspan = document.createElement('div');
          vspan.className = 'v';
          vspan.textContent = String(e.v);
          left.appendChild(kspan);
          left.appendChild(vspan);

          const right = document.createElement('div');
          right.style.fontSize = '11px';
          right.style.opacity = '0.7';
          right.textContent = ''; // could put small hex hash or arrow
          it.appendChild(left);
          it.appendChild(right);

          items.appendChild(it);
        }

        bdiv.appendChild(items);
        bucketsEl.appendChild(bdiv);
      }
    }

    function highlightBucket(index, ms=700) {
      const el = bucketsEl.querySelector('.bucket[data-index="'+index+'"]');
      if (!el) return;
      el.classList.add('highlight');
      setTimeout(()=> el.classList.remove('highlight'), ms);
      // scroll into view if overflowing
      el.scrollIntoView({behavior:'smooth', inline:'center', block:'nearest'});
    }

    function brieflyMarkItem(key, colorClass='found', ms=1000) {
      const sel = bucketsEl.querySelector('.item[data-key="'+String(key)+'"]');
      if (!sel) return;
      sel.classList.add(colorClass);
      setTimeout(()=> sel.classList.remove(colorClass), ms);
    }

    putBtn.addEventListener('click', () => {
      const k = keyInput.value;
      const v = valueInput.value;
      if (k === '') { alert('Please provide a key'); return; }
      const res = map.put(k, v);
      log(`PUT key='${k}' value='${v}' -> ${res.action}. index=${res.index} hash=${res.hash}`);
      if (res.shouldResize) {
        log(`Load factor ${(map.size/map.capacity).toFixed(2)} > ${map.loadFactor}. Resizing to ${map.capacity*2}...`, '#ffd580');
        map.rehash(map.capacity*2);
        log('Resize complete.');
      }
      render();
      highlightBucket(res.index);
      brieflyMarkItem(k);
    });

    getBtn.addEventListener('click', () => {
      const k = keyInput.value;
      if (k === '') { alert('Please provide a key'); return; }
      const res = map.get(k);
      if (res.found) {
        log(`GET key='${k}' -> found value='${res.value}'. index=${res.index} hash=${res.hash}`, '#86efac');
        highlightBucket(res.index);
        brieflyMarkItem(k);
      } else {
        log(`GET key='${k}' -> NOT FOUND. index=${res.index} hash=${res.hash}`, '#fb7185');
        highlightBucket(res.index);
      }
      render();
    });

    delBtn.addEventListener('click', () => {
      const k = keyInput.value;
      if (k === '') { alert('Please provide a key'); return; }
      const res = map.delete(k);
      if (res.deleted) {
        log(`DELETE key='${k}' -> deleted value='${res.value}'. index=${res.index} hash=${res.hash}`, '#ffd580');
      } else {
        log(`DELETE key='${k}' -> NOT FOUND. index=${res.index} hash=${res.hash}`, '#fb7185');
      }
      render();
    });

    containsBtn.addEventListener('click', () => {
      const k = keyInput.value;
      if (k === '') { alert('Please provide a key'); return; }
      const has = map.containsKey(k);
      log(`CONTAINS key='${k}' -> ${has}`, has ? '#86efac' : '#fb7185');
      if (has) {
        const {index} = map._index(k);
        highlightBucket(index);
        brieflyMarkItem(k);
      }
    });

    clearBtn.addEventListener('click', () => {
      if (!confirm('Clear all items from the hash map?')) return;
      map.clear();
      log('Cleared hash map.');
      render();
    });

    randomBtn.addEventListener('click', () => {
      const n = 8;
      for (let i = 0; i < n; i++) {
        const k = 'k' + Math.random().toString(36).slice(2,8);
        const v = Math.random().toString(36).slice(2,8);
        const r = map.put(k, v);
        if (r.shouldResize) {
          log(`Auto-resize triggered. Rehashing to ${map.capacity*2}...`, '#ffd580');
          map.rehash(map.capacity*2);
          log('Resize complete.');
        }
        log(`PUT '${k}' -> bucket ${r.index}`);
      }
      render();
    });

    setCapacityBtn.addEventListener('click', () => {
      const val = Number(capacityInput.value);
      if (!Number.isFinite(val) || val < 2) { alert('Capacity must be a number >= 2'); return; }
      // rehash to new capacity (preserve items)
      map.rehash(Math.floor(val));
      log(`Capacity set to ${map.capacity} and items rehashed.`);
      render();
    });

    rehashBtn.addEventListener('click', () => {
      map.rehash(map.capacity);
      log('Rehash complete (same capacity).');
      render();
    });

    autoResize.addEventListener('change', () => {
      map.enableResize = autoResize.checked;
      render();
      log(`Auto-resize ${map.enableResize ? 'enabled' : 'disabled'}.`);
    });

    thresholdInput.addEventListener('change', () => {
      let lf = parseFloat(thresholdInput.value);
      if (!Number.isFinite(lf) || lf <= 0 || lf >= 1) { alert('Load factor must be between 0 and 1'); return; }
      map.loadFactor = lf;
      thresholdLabel.textContent = lf.toFixed(2);
      render();
      log(`Load factor threshold set to ${lf.toFixed(2)}.`);
    });

    // Collision finder: search small lowercase strings deterministically until collisions found.
    function findCollisionsForKey(targetKey, count=1) {
      return new Promise((resolve) => {
        const targetIdx = map._index(targetKey).index;
        const results = [];
        const charset = 'abcdefghijklmnopqrstuvwxyz';
        let length = 1;
        let stopped = false;
        const chunk = 2000; // how many candidates to check per tick (keeps UI responsive)
        function nextBatch() {
          // generate strings of current length using iterative counters
          let maxComb = Math.pow(charset.length, length);
          // iterate with an index across all combinations
          for (let start = 0; start < maxComb && !stopped; start += chunk) {
            const end = Math.min(maxComb, start + chunk);
            for (let i = start; i < end; i++) {
              // convert i to base-N representation
              let tmp = i;
              let s = '';
              for (let p = 0; p < length; p++) {
                s = charset[tmp % charset.length] + s;
                tmp = Math.floor(tmp / charset.length);
              }
              if (s === String(targetKey)) continue; // skip identical
              if (map._index(s).index === targetIdx) {
                results.push(s);
                if (results.length >= count) { stopped = true; break; }
              }
            }
            if (stopped) break;
            // yield control for UI
            // schedule next inner chunk
            if (end < maxComb) {
              setTimeout(nextBatch, 0);
              return;
            }
          }
          if (!stopped) {
            length++;
            // cap length to avoid infinite loops
            if (length > 6) stopped = true;
            if (!stopped) setTimeout(nextBatch, 0); else resolve(results);
          } else {
            resolve(results);
          }
        }
        nextBatch();
      });
    }

    findCollisionsBtn.addEventListener('click', async () => {
      const k = keyInput.value;
      if (k === '') { alert('Please provide a key to find collisions for'); return; }
      log(`Searching for 1 collision for key='${k}' in current capacity ${map.capacity}...`);
      const t0 = performance.now();
      const found = await findCollisionsForKey(k, 1);
      const t1 = performance.now();
      if (found.length) {
        log(`Found collision: '${found[0]}' -> same bucket as '${k}' (took ${(t1-t0).toFixed(1)} ms)`, '#86efac');
        // Show where it would go
        const idx = map._index(found[0]).index;
        highlightBucket(idx, 1500);
        // temporarily insert colliding key to show visually (not altering map)
        const b = bucketsEl.querySelector('.bucket[data-index="'+idx+'"] .items');
        if (b) {
          const placeholder = document.createElement('div');
          placeholder.className = 'item';
          placeholder.style.opacity = '0.6';
          placeholder.textContent = `'${found[0]}' (collision)`;
          b.appendChild(placeholder);
          setTimeout(()=> placeholder.remove(), 3000);
        }
      } else {
        log('No collisions found in search limit (strings up to length 6)', '#ffd580');
      }
    });

    findManyBtn.addEventListener('click', async () => {
      const k = keyInput.value;
      if (k === '') { alert('Please provide a key to find collisions for'); return; }
      log(`Searching for up to 5 collisions for key='${k}'...`);
      const t0 = performance.now();
      const found = await findCollisionsForKey(k, 5);
      const t1 = performance.now();
      if (found.length) {
        log(`Found ${found.length} collisions (took ${(t1-t0).toFixed(1)} ms): ${found.join(', ')}`, '#86efac');
      } else {
        log('No collisions found in search limit.', '#ffd580');
      }
    });

    // initial render and some sample data
    function seed() {
      const samples = [
        ['Alice','id:1'],
        ['Bob','id:2'],
        ['Carol','id:3'],
        ['Dave','id:4'],
        ['Eve','id:5'],
      ];
      for (let [k,v] of samples) map.put(k,v);
      render();
      log('Seeded with sample entries: Alice, Bob, Carol, Dave, Eve');
    }

    seed();
    render();
  </script>
</body>
</html>