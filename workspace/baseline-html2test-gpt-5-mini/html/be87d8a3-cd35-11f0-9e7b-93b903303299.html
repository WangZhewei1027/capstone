<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sliding Window — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#06b6d4;
      --muted:#94a3b8;
      --glass: rgba(255,255,255,0.03);
      --good:#16a34a;
      --bad:#ef4444;
      --panel:#071025;
      --text:#e6eef6;
    }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{
      margin:0;
      background:linear-gradient(180deg,#071028 0%, #0b1220 50%, #061226 100%);
      color:var(--text);
      min-height:100vh;
      padding:18px;
    }
    header{display:flex;gap:12px;align-items:center;margin-bottom:12px;}
    h1{font-size:20px;margin:0}
    p.lead{margin:0;color:var(--muted);font-size:13px;}
    .container{display:grid;grid-template-columns: 1fr 420px; gap:18px;align-items:start;}
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      padding:14px;border-radius:10px;box-shadow: 0 6px 18px rgba(2,6,23,0.55);
    }
    .controls{display:flex;flex-direction:column;gap:10px;}
    label{font-size:12px;color:var(--muted);display:flex;justify-content:space-between;align-items:center;gap:10px;}
    .row{display:flex;gap:8px;align-items:center;}
    .btn{
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      color:var(--text);padding:8px 10px;border-radius:8px;cursor:pointer;font-size:13px;
    }
    .btn.primary{background:linear-gradient(180deg,var(--accent),#0497a8);color:#042028;border:none;}
    .btn.ghost{background:transparent;border:1px dashed rgba(255,255,255,0.04);}
    input[type="range"]{width:100%;}
    .visual{
      height:260px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border-radius:8px;padding:12px;display:flex;flex-direction:column;gap:8px;
    }
    .bars{
      display:flex;gap:8px;align-items:end;height:180px;padding:6px;border-radius:6px;background:var(--panel);
    }
    .bar{
      flex:1 0 28px;background:linear-gradient(180deg,#2a6b78,#07464f);border-radius:6px;display:flex;align-items:flex-end;justify-content:center;color:rgba(255,255,255,0.95);font-size:12px;
      position:relative;transition:all 300ms ease;
    }
    .bar .val{transform:translateY(-6px);}
    .bar.range{outline:4px solid rgba(6,182,212,0.15);box-shadow: 0 6px 20px rgba(6,182,212,0.06);}
    .bar.left{outline:4px dashed rgba(99,102,241,0.12);box-shadow: 0 8px 26px rgba(99,102,241,0.03);}
    .bar.right{outline:4px solid rgba(16,185,129,0.12);box-shadow: 0 8px 26px rgba(16,185,129,0.03);}
    .bar.current{outline:4px solid rgba(234,88,12,0.14);}
    .stats{display:flex;gap:8px;flex-wrap:wrap;}
    .stat{background:var(--glass);padding:8px;border-radius:8px;min-width:120px;font-size:13px;color:var(--muted);}
    pre{background:#02101a;color:#bfeefc;padding:10px;border-radius:8px;font-size:12px;overflow:auto;}
    .small{font-size:12px;color:var(--muted);}
    .footer-info{margin-top:8px;color:var(--muted);font-size:13px;line-height:1.3;}
    .controls .group{background:transparent;padding:8px;border-radius:8px;display:flex;flex-direction:column;gap:8px;}
    .flex-between{display:flex;justify-content:space-between;align-items:center;gap:8px;}
    .code-block{max-height:220px;overflow:auto;}
    .legend{display:flex;gap:8px;flex-wrap:wrap;font-size:12px;margin-top:6px;}
    .legend .item{display:flex;gap:6px;align-items:center;padding-right:8px;}
    .dot{width:14px;height:12px;border-radius:3px;display:inline-block;}
    .dot.window{background:linear-gradient(180deg,#06b6d4,#0497a8);}
    .dot.left{background:linear-gradient(180deg,#6366f1,#4f46e5);}
    .dot.right{background:linear-gradient(180deg,#10b981,#059669);}
    .dot.curr{background:linear-gradient(180deg,#f97316,#ea580c);}
    footer{margin-top:12px;color:var(--muted);font-size:13px;}
    /* responsive */
    @media (max-width:940px){
      .container{grid-template-columns:1fr;gap:12px;}
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Sliding Window — Interactive Demo</h1>
      <p class="lead">Explore fixed-size and variable-size sliding window techniques with step-by-step animation and explanations.</p>
    </div>
  </header>

  <div class="container">
    <div class="panel">
      <div class="controls">
        <div class="group">
          <div class="flex-between">
            <strong>Array</strong>
            <div class="small">Length: <span id="lenDisplay">12</span></div>
          </div>
          <div style="display:flex;gap:8px;margin-top:6px;">
            <button class="btn" id="randBtn">Randomize</button>
            <button class="btn ghost" id="addBtn">+ Add</button>
            <button class="btn ghost" id="remBtn">- Remove</button>
            <button class="btn" id="presetBtn">Preset</button>
          </div>
          <div class="small" style="margin-top:8px;">Click a bar to edit value.</div>
        </div>

        <div class="group">
          <strong>Fixed-size Sliding Window</strong>
          <label>Window size k: <span id="kDisplay">3</span></label>
          <input type="range" id="kRange" min="1" max="12" value="3" />
          <div style="display:flex;gap:8px;">
            <button class="btn primary" id="playFixed">Play</button>
            <button class="btn" id="stepFixed">Step</button>
            <button class="btn" id="resetFixed">Reset</button>
            <div style="flex:1"></div>
            <label class="small">speed
              <input id="speedFixed" type="range" min="100" max="2000" step="50" value="700" />
            </label>
          </div>
        </div>

        <div class="group">
          <strong>Variable-size Sliding Window (min length with sum ≥ target)</strong>
          <label>Target sum: <span id="targetDisplay">15</span></label>
          <input type="range" id="targetRange" min="1" max="100" value="15" />
          <div style="display:flex;gap:8px;">
            <button class="btn primary" id="playVar">Play</button>
            <button class="btn" id="stepVar">Step</button>
            <button class="btn" id="resetVar">Reset</button>
            <div style="flex:1"></div>
            <label class="small">speed
              <input id="speedVar" type="range" min="100" max="2000" step="50" value="500" />
            </label>
          </div>
        </div>

        <div class="group">
          <div class="flex-between"><strong>Legend</strong></div>
          <div class="legend">
            <div class="item"><span class="dot window"></span> Current fixed window</div>
            <div class="item"><span class="dot left"></span> Variable left pointer</div>
            <div class="item"><span class="dot right"></span> Variable right pointer</div>
            <div class="item"><span class="dot curr"></span> Current focus</div>
          </div>
        </div>

      </div>
    </div>

    <div class="panel">
      <div class="visual">
        <div class="bars" id="bars"></div>
        <div style="display:flex;gap:10px;align-items:center;justify-content:space-between;">
          <div class="stats" id="stats">
            <div class="stat">Sum: <strong id="sumVal">—</strong></div>
            <div class="stat">Average: <strong id="avgVal">—</strong></div>
            <div class="stat">Max: <strong id="maxVal">—</strong></div>
            <div class="stat">Min: <strong id="minVal">—</strong></div>
            <div class="stat">Best (fixed): <strong id="bestFixed">—</strong></div>
            <div class="stat">Best (variable): <strong id="bestVar">—</strong></div>
          </div>

          <div style="width:220px;">
            <div style="font-size:13px;color:var(--muted);margin-bottom:6px;">Current operation</div>
            <div style="background:var(--glass);padding:10px;border-radius:8px;font-size:13px;color:var(--muted);" id="operation">
              Idle — no animation running.
            </div>
          </div>
        </div>

        <div class="footer-info">
          Tip: Use the fixed window to see how sums can be updated in O(1) per shift. Use variable window to find the shortest subarray with sum >= target in O(n).
        </div>
      </div>

      <div style="margin-top:12px;">
        <strong>Algorithm Summaries</strong>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px;">
          <div style="background:var(--panel);padding:10px;border-radius:8px;">
            <div style="font-weight:600;margin-bottom:6px;">Fixed-size window (sum of every k)</div>
            <div class="small" style="margin-bottom:8px;">
              Compute sum of first k elements. For each shift, subtract the element that leaves and add the new entering element. O(n).
            </div>
            <pre class="code-block">let sum = sum(arr[0..k-1]);
for i from 1 to n-k:
  sum = sum - arr[i-1] + arr[i+k-1]
  // record/use sum</pre>
          </div>
          <div style="background:var(--panel);padding:10px;border-radius:8px;">
            <div style="font-weight:600;margin-bottom:6px;">Variable-size window (min length ≥ target)</div>
            <div class="small" style="margin-bottom:8px;">
              Expand right pointer until sum ≥ target, then shrink left pointer while sum still ≥ target to minimize length. O(n).
            </div>
            <pre class="code-block">let left=0, sum=0, minLen=∞;
for right from 0 to n-1:
  sum += arr[right]
  while sum ≥ target:
    minLen = min(minLen, right-left+1)
    sum -= arr[left]
    left++</pre>
          </div>
        </div>
      </div>

    </div>
  </div>

  <footer>
    Built for learning — click, edit, and step through to see how sliding windows work.
  </footer>

<script>
(() => {
  // DATA & UI ELEMENTS
  const defaultArr = [5,1,3,7,2,8,6,4,9,2,5,3];
  let arr = defaultArr.slice();
  const barsEl = document.getElementById('bars');
  const lenDisplay = document.getElementById('lenDisplay');
  const kRange = document.getElementById('kRange');
  const kDisplay = document.getElementById('kDisplay');
  const targetRange = document.getElementById('targetRange');
  const targetDisplay = document.getElementById('targetDisplay');
  const sumVal = document.getElementById('sumVal');
  const avgVal = document.getElementById('avgVal');
  const maxVal = document.getElementById('maxVal');
  const minVal = document.getElementById('minVal');
  const bestFixed = document.getElementById('bestFixed');
  const bestVar = document.getElementById('bestVar');
  const operation = document.getElementById('operation');
  const randBtn = document.getElementById('randBtn');
  const addBtn = document.getElementById('addBtn');
  const remBtn = document.getElementById('remBtn');
  const presetBtn = document.getElementById('presetBtn');

  // Fixed window controls
  const playFixed = document.getElementById('playFixed');
  const stepFixed = document.getElementById('stepFixed');
  const resetFixed = document.getElementById('resetFixed');
  const speedFixed = document.getElementById('speedFixed');

  // Variable window controls
  const playVar = document.getElementById('playVar');
  const stepVar = document.getElementById('stepVar');
  const resetVar = document.getElementById('resetVar');
  const speedVar = document.getElementById('speedVar');

  // State for animations
  let fixedTimer = null;
  let varTimer = null;

  // FIXED WINDOW STATE
  let K = parseInt(kRange.value,10);
  let fixedPos = 0;
  let fixedSum = 0;
  let fixedBest = {sum: -Infinity, pos: 0};
  let fixedStarted = false;

  // VAR WINDOW STATE
  let target = parseInt(targetRange.value,10);
  let left = 0, right = -1, varSum = 0;
  let varBest = {len: Infinity, l: -1, r: -1};
  let varStarted = false;

  // Initialize UI & events
  function renderBars(){
    barsEl.innerHTML = '';
    const maxValInArr = Math.max(...arr, 1);
    arr.forEach((v,i) => {
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.height = Math.max(24, Math.round((v / maxValInArr) * 160)) + 'px';
      bar.dataset.index = i;
      bar.innerHTML = '<div class="val">' + v + '</div>';
      bar.title = 'Index ' + i + ' value ' + v;
      bar.addEventListener('click', onBarClick);
      barsEl.appendChild(bar);
    });
    lenDisplay.textContent = arr.length;
    // adjust kRange max
    kRange.max = Math.max(1, arr.length);
    if (K > arr.length) { K = arr.length; kRange.value = K; kDisplay.textContent = K; }
    targetRange.max = Math.max(10, arr.reduce((a,b)=>a+b,0)+5);
    targetDisplay.textContent = target;
    updateSummary();
    refreshHighlights();
  }

  function onBarClick(e){
    const idx = parseInt(e.currentTarget.dataset.index,10);
    const newVal = prompt('Enter new integer value at index ' + idx + ' (current ' + arr[idx] + '):', String(arr[idx]));
    if(newVal === null) return;
    const num = parseInt(newVal,10);
    if(Number.isFinite(num)){
      arr[idx] = num;
      resetAll();
      renderBars();
    } else alert('Invalid number');
  }

  function randize(length = arr.length){
    arr = Array.from({length}, ()=> Math.floor(Math.random()*18)+1);
    resetAll();
    renderBars();
  }

  function preset(){
    arr = [2,1,5,2,8,1,3,6,4,2,1,7];
    resetAll();
    renderBars();
  }

  randBtn.addEventListener('click', ()=> randize(arr.length));
  addBtn.addEventListener('click', ()=> { if(arr.length < 30) { arr.push(Math.floor(Math.random()*18)+1); resetAll(); renderBars(); }});
  remBtn.addEventListener('click', ()=> { if(arr.length>1) { arr.pop(); resetAll(); renderBars(); }});
  presetBtn.addEventListener('click', preset);

  // Controls for K and target
  kRange.addEventListener('input', (e)=> {
    K = parseInt(e.target.value,10);
    kDisplay.textContent = K;
    resetFixed();
    renderBars();
  });
  targetRange.addEventListener('input', (e)=> {
    target = parseInt(e.target.value,10);
    targetDisplay.textContent = target;
    resetVar();
    renderBars();
  });

  // Summary stats
  function updateSummary(){
    const s = arr.reduce((a,b)=>a+b,0);
    sumVal.textContent = s;
    avgVal.textContent = (s/arr.length).toFixed(2);
    maxVal.textContent = Math.max(...arr);
    minVal.textContent = Math.min(...arr);
    bestFixed.textContent = fixedBest.sum === -Infinity ? '—' : `${fixedBest.sum} (pos ${fixedBest.pos})`;
    bestVar.textContent = varBest.len === Infinity ? '—' : `${varBest.len} (${varBest.l}-${varBest.r})`;
  }

  // Highlighting function
  function refreshHighlights(){
    const bars = [...barsEl.children];
    bars.forEach(b => b.className = 'bar'); // reset
    // Fixed window highlight
    if(fixedStarted && K <= arr.length){
      for(let i=fixedPos;i<Math.min(fixedPos+K, arr.length); i++){
        const el = bars[i];
        if(el) el.classList.add('range');
      }
      // current focus (the newly added element)
      const focusIdx = Math.min(fixedPos+K-1, arr.length-1);
      if(bars[focusIdx]) bars[focusIdx].classList.add('current');
    }
    // Variable pointers highlight
    if(varStarted){
      if(left>=0 && left < bars.length) bars[left].classList.add('left');
      if(right>=0 && right < bars.length) bars[right].classList.add('right');
    }
  }

  // FIXED WINDOW LOGIC
  function computeInitialFixed(){
    fixedPos = 0;
    fixedSum = 0;
    if(K <= arr.length){
      fixedSum = arr.slice(0,K).reduce((a,b)=>a+b,0);
      fixedBest = {sum: fixedSum, pos: 0};
    } else {
      fixedSum = 0; fixedBest = {sum:-Infinity,pos:0};
    }
    updateSummary();
    operation.textContent = 'Fixed window initialized. sum(arr[0..' + (K-1) + ']) = ' + fixedSum;
    fixedStarted = false;
    refreshHighlights();
  }

  function stepFixedOnce(){
    if(K > arr.length) {
      operation.textContent = 'Window size K is larger than array length.';
      return;
    }
    // On first call, if not started, just compute initial
    if(!fixedStarted){
      fixedStarted = true;
      computeInitialFixed();
      refreshHighlights();
      return;
    }
    // move window by 1
    if(fixedPos + K >= arr.length){
      operation.textContent = 'Reached end of array.';
      stopFixed();
      return;
    }
    const leaving = arr[fixedPos];
    const entering = arr[fixedPos + K];
    const prevSum = fixedSum;
    fixedSum = fixedSum - leaving + entering;
    fixedPos++;
    operation.innerHTML = `Shift window: subtract ${leaving}, add ${entering} → new sum = ${fixedSum}`;
    if(fixedSum > fixedBest.sum){
      fixedBest = {sum: fixedSum, pos: fixedPos};
      operation.innerHTML += ` — new best! (sum=${fixedBest.sum} at pos ${fixedBest.pos})`;
    }
    updateSummary();
    refreshHighlights();
  }

  function playFixedLoop(){
    if(fixedTimer) return;
    if(K > arr.length){ operation.textContent = 'Window size too big for play.'; return; }
    if(!fixedStarted){
      computeInitialFixed();
      fixedStarted = true;
      refreshHighlights();
    }
    operation.textContent = 'Playing fixed window animation...';
    fixedTimer = setInterval(() => {
      stepFixedOnce();
      if(fixedPos + K >= arr.length){
        stopFixed();
      }
    }, parseInt(speedFixed.value,10));
  }
  function stopFixed(){
    if(fixedTimer){
      clearInterval(fixedTimer); fixedTimer = null;
      operation.textContent = 'Paused (fixed window reached end or stopped).';
    }
  }
  playFixed.addEventListener('click', ()=> {
    if(fixedTimer) { stopFixed(); playFixed.textContent = 'Play'; playFixed.classList.remove('primary'); }
    else { playFixedLoop(); playFixed.textContent = 'Pause'; playFixed.classList.add('primary'); }
  });
  stepFixed.addEventListener('click', ()=> { stepFixedOnce(); });
  resetFixed.addEventListener('click', ()=> { resetFixed(); renderBars(); });

  function resetFixed(){
    stopFixed();
    fixedPos = 0; fixedSum = 0; fixedBest = {sum:-Infinity,pos:0}; fixedStarted = false;
    playFixed.textContent = 'Play'; playFixed.classList.remove('primary');
    operation.textContent = 'Fixed window reset.';
    updateSummary(); refreshHighlights();
  }

  // VARIABLE WINDOW LOGIC
  function computeInitialVar(){
    left = 0; right = -1; varSum = 0; varBest = {len: Infinity, l:-1, r:-1};
    varStarted = false;
    operation.textContent = 'Variable window initialized (finding min length with sum ≥ ' + target + ').';
    updateSummary(); refreshHighlights();
  }

  function stepVarOnce(){
    // staged stepping: if not started, start by moving right once
    if(!varStarted){
      varStarted = true;
      left = 0; right = -1; varSum = 0; varBest = {len: Infinity, l:-1, r:-1};
      operation.textContent = 'Start variable sliding. Expand right.';
      refreshHighlights();
      return;
    }
    // If sum < target, expand right
    if(varSum < target){
      if(right+1 >= arr.length){
        operation.textContent = 'Cannot expand: reached end. Algorithm finished.';
        stopVar();
        return;
      }
      right++;
      varSum += arr[right];
      operation.innerHTML = `Expanded right → index ${right}, add ${arr[right]}, sum=${varSum}`;
      if(varSum >= target){
        operation.innerHTML += ` (sum ≥ target) — try shrinking from left.`;
      }
      refreshHighlights();
      // Record potential candidate in later step when shrink occurs
      return;
    } else {
      // sum >= target, try to shrink from left
      const currLen = right - left + 1;
      if(currLen < varBest.len){
        varBest = {len: currLen, l:left, r:right};
        operation.innerHTML = `Found candidate length ${currLen} (indexes ${left}-${right}). Shrink left to try shorter.`;
      } else {
        operation.innerHTML = `Current window length ${currLen} >= best ${varBest.len || '∞'}. Shrink left.`;
      }
      // shrink
      varSum -= arr[left];
      operation.innerHTML += ` Subtract arr[${left}]=${arr[left]} => sum=${varSum}`;
      left++;
      refreshHighlights();
      // If after shrinking still >= target, further shrinking will be handled by subsequent steps.
    }
  }

  function playVarLoop(){
    if(varTimer) return;
    computeInitialVar();
    varStarted = true;
    operation.textContent = 'Playing variable window animation...';
    varTimer = setInterval(() => {
      // follow algorithm: expand until sum >= target, then shrink until sum < target, repeat
      if(varSum < target){
        if(right+1 >= arr.length){
          operation.textContent = 'Reached end and cannot expand further. Done.';
          stopVar();
          return;
        }
        right++;
        varSum += arr[right];
        operation.innerHTML = `Expanded right → index ${right}, add ${arr[right]}, sum=${varSum}`;
        refreshHighlights();
      } else {
        // shrink while possible (but in animation we shrink one step per tick to be visual)
        const currLen = right - left + 1;
        if(currLen < varBest.len){
          varBest = {len: currLen, l:left, r:right};
          operation.innerHTML = `Found candidate length ${currLen} (indexes ${left}-${right}). Shrinking left.`;
        } else {
          operation.innerHTML = `Shrinking left (current length ${currLen}).`;
        }
        varSum -= arr[left];
        operation.innerHTML += ` Subtract arr[${left}]=${arr[left]} => sum=${varSum}`;
        left++;
        refreshHighlights();
        // If after shrink sum < target and right at end, we may end soon
        if(varSum < target && right >= arr.length-1){
          // if cannot expand further and sum < target, done
          if(right >= arr.length-1){
            operation.innerHTML += ' Cannot expand further. Done.';
            stopVar();
          }
        }
      }
      updateSummary();
      // termination condition: when right==n-1 and varSum < target and no more shrinking possible or we've inspected all states
      if(right >= arr.length-1 && varSum < target && (left > right || right >= arr.length-1 && left >= arr.length)){
        stopVar();
      }
      // extra termination: if left > right and right at end
      if(right >= arr.length-1 && left > right){
        stopVar();
      }
    }, parseInt(speedVar.value,10));
  }

  function stopVar(){
    if(varTimer){
      clearInterval(varTimer); varTimer = null;
      operation.textContent = 'Paused (variable window paused or finished).';
    }
    updateSummary();
  }

  playVar.addEventListener('click', ()=> {
    if(varTimer) { stopVar(); playVar.textContent = 'Play'; playVar.classList.remove('primary'); }
    else { playVarLoop(); playVar.textContent = 'Pause'; playVar.classList.add('primary'); }
  });
  stepVar.addEventListener('click', ()=> { stepVarOnce(); updateSummary(); });
  resetVar.addEventListener('click', ()=> { resetVar(); renderBars(); });

  function resetVar(){
    stopVar();
    left = 0; right = -1; varSum = 0; varBest = {len:Infinity,l:-1,r:-1}; varStarted = false;
    playVar.textContent = 'Play'; playVar.classList.remove('primary');
    operation.textContent = 'Variable window reset.';
    updateSummary(); refreshHighlights();
  }

  function resetAll(){
    resetFixed(); resetVar();
  }

  // init
  function init(){
    arr = defaultArr.slice();
    K = parseInt(kRange.value,10);
    target = parseInt(targetRange.value,10);
    kDisplay.textContent = K;
    targetDisplay.textContent = target;
    renderBars();
    computeInitialFixed();
    computeInitialVar();
  }

  init();

  // Make sure we update UI when timers stop externally
  window.addEventListener('beforeunload', ()=>{ stopFixed(); stopVar(); });
})();
</script>
</body>
</html>