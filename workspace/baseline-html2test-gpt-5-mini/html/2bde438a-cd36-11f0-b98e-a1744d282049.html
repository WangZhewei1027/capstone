<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Radix Sort Visualizer (LSD)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#60a5fa;
      --muted:#94a3b8;
      --card:#0b1226;
      --good:#16a34a;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{
      background:linear-gradient(180deg,#071027 0%, #081524 55%, #04111b 100%);
      color:#e6eef8;
      padding:20px;
      box-sizing:border-box;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      max-width:1100px;margin:0 auto;
      display:grid;grid-template-columns: 360px 1fr;gap:20px;
    }
    .panel{
      background:var(--panel);
      border-radius:12px;padding:16px;box-shadow:0 6px 20px rgba(2,6,23,0.6);
    }
    h1{margin:0 0 8px 0;font-size:18px;}
    p.lead{margin:0 0 12px 0;color:var(--muted);font-size:13px;line-height:1.4;}
    .controls{display:flex;flex-direction:column;gap:12px;}
    label{font-size:12px;color:var(--muted);}
    input[type="text"]{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;}
    .row{display:flex;gap:8px;align-items:center;}
    .row .btn{padding:8px 10px;border-radius:8px;background:var(--glass);border:1px solid rgba(255,255,255,0.03);color:var(--accent);cursor:pointer;}
    .btn.primary{background:linear-gradient(90deg,var(--accent),#7dd3fc);color:#03203a;font-weight:700;border:0;}
    .btn.warn{background:linear-gradient(90deg,#f97316,#fca34b);color:#111;}
    .small{font-size:12px;padding:6px 8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);}
    .visual{
      padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;
      min-height:420px;display:flex;flex-direction:column;gap:12px;
    }
    .array-row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
    .cell{
      min-width:48px;height:48px;border-radius:8px;background:var(--card);display:flex;align-items:center;justify-content:center;
      box-shadow:inset 0 -10px 30px rgba(0,0,0,0.45);
      font-weight:700;font-size:15px;color:#e6f2ff;position:relative;
      transition:transform .25s ease, box-shadow .15s ease;
    }
    .cell .digit{position:absolute;right:6px;top:4px;font-size:11px;color:var(--muted);opacity:0.9;}
    .cell.highlight{box-shadow:0 8px 30px rgba(96,165,250,0.15);transform:translateY(-6px);}
    .cell.moved{background:linear-gradient(90deg,#34d399,#60a5fa);}
    .buckets{display:flex;gap:8px;align-items:flex-start;overflow:auto;padding-bottom:6px;}
    .bucket{
      min-width:70px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px dashed rgba(255,255,255,0.03);
      display:flex;flex-direction:column;gap:8px;align-items:center;
    }
    .bucket .label{font-size:12px;color:var(--muted);margin-bottom:4px;}
    .bucket .stack{display:flex;flex-direction:column;gap:6px;width:100%;align-items:center;}
    .bucket .stack .cell{min-width:52px;height:36px;font-size:13px;}
    .status{display:flex;justify-content:space-between;align-items:center;font-size:13px;color:var(--muted);}
    .controls-row{display:flex;gap:8px;align-items:center;}
    .slider{width:140px;}
    .footer-note{font-size:12px;color:var(--muted);margin-top:10px;}
    .error{color:var(--danger);font-size:13px;}
    .kbd{background:rgba(255,255,255,0.03);padding:4px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);font-size:12px;}
    .legend{display:flex;gap:8px;align-items:center;font-size:13px;}
    .dot{width:12px;height:12px;border-radius:3px;}
    .dot.dist{background:#60a5fa;}
    .dot.collect{background:#34d399;}
    .note{font-size:13px;color:var(--muted);}
    @media (max-width:880px){
      .app{grid-template-columns:1fr; padding-bottom:80px;}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h1>Radix Sort (LSD) Visualizer</h1>
      <p class="lead">
        Visual demonstration of Least Significant Digit (LSD) Radix Sort. Works with non-negative integers.
        Use the controls to input numbers, change base (radix), step through distribution and collection phases, or autoplay.
      </p>

      <div class="controls">
        <div>
          <label>Array (comma separated integers, non-negative)</label>
          <input id="arrayInput" type="text" value="170,45,75,90,802,24,2,66" />
        </div>

        <div class="row">
          <div style="flex:1">
            <label>Base (radix)</label>
            <input id="baseInput" type="number" min="2" max="16" value="10" class="small" />
          </div>
          <div style="width:120px">
            <label>Animation speed</label>
            <input id="speed" type="range" min="100" max="1500" value="600" class="slider" />
          </div>
        </div>

        <div class="row">
          <button id="loadBtn" class="btn primary">Load Array</button>
          <button id="randomBtn" class="btn">Random</button>
          <button id="clearBtn" class="btn">Clear</button>
        </div>

        <div class="row">
          <button id="stepBack" class="btn">Step ◀</button>
          <button id="playPause" class="btn primary">Play ▶</button>
          <button id="stepForward" class="btn">Step ▶</button>
          <button id="resetBtn" class="btn warn">Reset</button>
        </div>

        <div class="row">
          <div style="flex:1">
            <label>Predefined sets</label>
            <select id="preset" class="small" style="width:100%">
              <option value="170,45,75,90,802,24,2,66">Classic</option>
              <option value="3,1,4,1,5,9,2,6,5,3,5">Pi digits</option>
              <option value="0,0,0,0">Zeros</option>
              <option value="12,123,1234,12345,1,0">Varying lengths</option>
              <option value="">Empty</option>
            </select>
          </div>
          <div style="width:120px">
            <label>Count random</label>
            <input id="randCount" type="number" min="1" max="40" value="10" class="small" />
          </div>
        </div>

        <div class="footer-note">
          Tip: Radix sort processes digits from least to most significant. This demo performs distribution (to buckets) then collection for each digit.
        </div>
      </div>
    </div>

    <div class="panel visual">
      <div class="status">
        <div>
          <span class="legend"><span class="dot dist"></span>&nbsp;Distribution</span>
          &nbsp;&nbsp;&nbsp;
          <span class="legend"><span class="dot collect"></span>&nbsp;Collection</span>
        </div>
        <div class="note">
          Base: <span id="curBase">10</span> &nbsp;|&nbsp; Digit position: <span id="digitPos">-</span> &nbsp;|&nbsp; Phase: <span id="phase">idle</span>
        </div>
      </div>

      <div>
        <label style="font-size:13px;color:var(--muted)">Working array</label>
        <div id="arrayRow" class="array-row" style="margin-top:8px"></div>
      </div>

      <div>
        <label style="font-size:13px;color:var(--muted)">Buckets</label>
        <div id="buckets" class="buckets" style="margin-top:8px"></div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px">
        <div id="message" class="note"></div>
        <div id="controlsTiny" style="display:flex;gap:8px;align-items:center">
          <span class="note">Click cells to toggle highlight</span>
          <span class="note" style="margin-left:8px;color:var(--muted)">Sorted result appears in array after full passes</span>
        </div>
      </div>

      <div style="margin-top:6px">
        <div id="error" class="error" style="display:none"></div>
      </div>
    </div>
  </div>

  <script>
  // Radix Sort Visualizer (LSD) - Single-file demo
  (function(){
    // DOM refs
    const arrayInput = document.getElementById('arrayInput');
    const loadBtn = document.getElementById('loadBtn');
    const randomBtn = document.getElementById('randomBtn');
    const clearBtn = document.getElementById('clearBtn');
    const baseInput = document.getElementById('baseInput');
    const speedInput = document.getElementById('speed');
    const stepForward = document.getElementById('stepForward');
    const stepBack = document.getElementById('stepBack');
    const playPause = document.getElementById('playPause');
    const resetBtn = document.getElementById('resetBtn');
    const arrayRow = document.getElementById('arrayRow');
    const bucketsEl = document.getElementById('buckets');
    const digitPosEl = document.getElementById('digitPos');
    const phaseEl = document.getElementById('phase');
    const curBaseEl = document.getElementById('curBase');
    const messageEl = document.getElementById('message');
    const errorEl = document.getElementById('error');
    const preset = document.getElementById('preset');
    const randCount = document.getElementById('randCount');

    // internal state
    let initialArray = [];
    let workingArray = [];
    let buckets = [];
    let base = 10;
    let timer = null;
    let speed = 600;
    let phase = 'idle'; // 'idle'|'distribute'|'collect'|'done'
    let digitPos = -1;
    let maxDigits = 0;
    let distIndex = 0; // index in workingArray for distribution step
    let collectBucket = 0; // which bucket we're collecting
    let playing = false;
    let highlighted = new Set();

    // Utility helpers
    function showError(msg){
      errorEl.textContent = msg;
      errorEl.style.display = msg ? 'block' : 'none';
    }
    function parseArrayInput(text){
      if (!text.trim()) return [];
      const parts = text.split(',').map(s=>s.trim()).filter(s=>s.length);
      const nums = [];
      for (const p of parts){
        if (!/^-?\d+$/.test(p)){
          throw new Error("Only integers allowed.");
        }
        const n = parseInt(p,10);
        if (n < 0) throw new Error("Negative numbers not supported in this demo.");
        nums.push(n);
      }
      return nums;
    }
    function digitsCount(n, b){
      if (n === 0) return 1;
      let c = 0;
      while (n > 0) { c++; n = Math.floor(n / b); }
      return c;
    }
    function getDigit(n, pos, b){
      // least significant digit pos=0
      return Math.floor(n / Math.pow(b, pos)) % b;
    }

    // Render functions
    function render(){
      // Working array
      arrayRow.innerHTML = '';
      workingArray.forEach((val, idx) => {
        const c = document.createElement('div');
        c.className = 'cell' + (highlighted.has(val + '::' + idx) ? ' highlight' : '');
        c.textContent = val;
        const d = document.createElement('div');
        d.className = 'digit';
        d.textContent = (digitPos >= 0 && val != null) ? String(getDigit(val, digitPos, base)) : '';
        c.appendChild(d);
        c.onclick = () => {
          const key = val + '::' + idx;
          if (highlighted.has(key)) highlighted.delete(key); else highlighted.add(key);
          render();
        };
        arrayRow.appendChild(c);
      });

      // Buckets
      bucketsEl.innerHTML = '';
      for (let b = 0; b < base; b++){
        const bucket = document.createElement('div');
        bucket.className = 'bucket';
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = b;
        bucket.appendChild(label);
        const stack = document.createElement('div');
        stack.className = 'stack';
        buckets[b].forEach((val, idx) => {
          const c = document.createElement('div');
          c.className = 'cell' + (highlighted.has(val + '::bucket::' + b + '::' + idx) ? ' highlight' : '');
          c.textContent = val;
          const d = document.createElement('div');
          d.className = 'digit';
          d.textContent = (digitPos >= 0 && val != null) ? String(getDigit(val, digitPos, base)) : '';
          c.appendChild(d);
          c.onclick = () => {
            const key = val + '::bucket::' + b + '::' + idx;
            if (highlighted.has(key)) highlighted.delete(key); else highlighted.add(key);
            render();
          };
          stack.appendChild(c);
        });
        bucket.appendChild(stack);
        bucketsEl.appendChild(bucket);
      }

      curBaseEl.textContent = base;
      digitPosEl.textContent = digitPos >=0 ? digitPos : '-';
      phaseEl.textContent = phase;
      messageEl.textContent = `Array size: ${workingArray.length}  | Max digits: ${maxDigits}`;
    }

    function resetState(keepArray){
      clearInterval(timer); timer = null; playing = false; playPause.textContent = 'Play ▶';
      speed = parseInt(speedInput.value,10) || 600;
      base = Math.max(2, Math.min(16, parseInt(baseInput.value,10) || 10));
      curBaseEl.textContent = base;
      if (!keepArray) highlighted.clear();
      if (!keepArray) errorEl.style.display = 'none';
      // initialize buckets
      buckets = Array.from({length: base}, ()=>[]);
      if (!keepArray){
        workingArray = initialArray.slice();
      }
      // compute digits
      maxDigits = 0;
      for (const v of workingArray) maxDigits = Math.max(maxDigits, digitsCount(v, base));
      if (workingArray.length === 0) {
        phase = 'idle';
        digitPos = -1;
      } else {
        phase = 'distribute';
        digitPos = 0;
      }
      distIndex = 0;
      collectBucket = 0;
      render();
    }

    // Step behavior
    function stepForwardAction(){
      if (workingArray.length === 0) {
        phase = 'idle'; render(); return;
      }
      if (phase === 'idle') { phase = 'distribute'; digitPos = 0; distIndex = 0; render(); return; }
      if (phase === 'done') { render(); return; }

      // Distribution phase: move next element from workingArray to corresponding bucket
      if (phase === 'distribute'){
        if (distIndex < workingArray.length){
          const val = workingArray[distIndex];
          const bucketIdx = getDigit(val, digitPos, base);
          // move element from array to bucket visually: we'll mark as removed in workingArray by null placeholder but keep order
          // To keep stable ordering, we'll remove it physically and push to buckets
          workingArray.splice(distIndex,1);
          buckets[bucketIdx].push(val);
          // do not increment distIndex because the array shifted; we keep same distIndex to process next element at same index
        } else {
          // finished distribution for this digit
          phase = 'collect';
          collectBucket = 0;
        }
        // If we just finished distribution (no elements), switch to collect
        if (phase === 'distribute') {
          // if no more to process and we didn't switch earlier:
          if (workingArray.length === 0 && distIndex >= workingArray.length) {
            phase = 'collect';
            collectBucket = 0;
          }
        }
        render();
        return;
      }

      // Collection phase: take from buckets starting at bucket 0..base-1 in order and append back to workingArray
      if (phase === 'collect'){
        // find next non-empty bucket
        while (collectBucket < base && buckets[collectBucket].length === 0) collectBucket++;
        if (collectBucket >= base){
          // finished collecting for this digit -> prepare next digit or finish
          digitPos++;
          if (digitPos >= maxDigits){
            phase = 'done';
            // ensure workingArray is fully assembled (should be)
            render();
            return;
          } else {
            // prepare for next distribution: reset distIndex, but array currently contains collected values.
            phase = 'distribute';
            distIndex = 0;
            // clear buckets (should be empty already)
            for (let i=0;i<base;i++) buckets[i] = [];
            render();
            return;
          }
        } else {
          // pop first element from bucket and push to workingArray
          const val = buckets[collectBucket].shift();
          workingArray.push(val);
          // stay on same bucket (maybe still has more)
        }
        render();
        return;
      }
    }

    function stepBackAction(){
      // For simplicity, stepping back rewinds to initial and plays forward to desired step-1.
      // Implementing true backward micro-step is complex; this approach is acceptable for visualization.
      // We'll rewind and then simulate up to (current step - 1).
      // Compute number of micro-steps that have been executed so far:
      // Let's create a deterministic simulation from initialArray through actions until we reach current state and then stop one step earlier.
      if (initialArray.length === 0) return;

      // Build action log forward until 'done' using a simulated copy
      const simBase = base;
      const simInitial = initialArray.slice();
      let simBuckets = Array.from({length: simBase}, ()=>[]);
      let simWorking = simInitial.slice();
      let simDigit = 0;
      const simMaxDigits = Math.max(...simInitial.map(n=>digitsCount(n, simBase)));
      const actions = []; // each action: {type:'dist'|'collect', value, fromIndex?, bucket?}
      while (true){
        if (simDigit >= simMaxDigits) break;
        // distribution
        for (let i=0;i<simWorking.length;){
          const val = simWorking[i];
          const bidx = getDigit(val, simDigit, simBase);
          // dist action removes simWorking[i] and pushes to bucket
          actions.push({type:'dist', value:val, bucket:bidx});
          simWorking.splice(i,1);
          simBuckets[bidx].push(val);
          // i stays (next element shifts into this index)
        }
        // collection
        for (let b=0;b<simBase;b++){
          while(simBuckets[b].length>0){
            const val = simBuckets[b].shift();
            actions.push({type:'collect', value:val, bucket:b});
            simWorking.push(val);
          }
        }
        simDigit++;
      }
      // Now actions describes the entire micro-step sequence from initial to sorted final.
      // Find current micro-step index by comparing current state to simulated progressive states.
      // We'll simulate again and stop when we first match the current state; then step back one action.
      let simWorking2 = initialArray.slice();
      let simBuckets2 = Array.from({length: simBase}, ()=>[]);
      let matchedIndex = -1;
      function stateEquals(){
        if (simWorking2.length !== workingArray.length) return false;
        for (let i=0;i<simWorking2.length;i++){
          if (simWorking2[i] !== workingArray[i]) return false;
        }
        // check buckets
        for (let b=0;b<simBase;b++){
          if ((simBuckets2[b]||[]).length !== (buckets[b]||[]).length) return false;
          for (let k=0;k<(simBuckets2[b]||[]).length;k++){
            if ((simBuckets2[b]||[])[k] !== (buckets[b]||[])[k]) return false;
          }
        }
        return true;
      }
      // iterate through actions; at step start (0) we compare too.
      if (stateEquals()){
        // we're at start -> nothing to go back to
        return;
      }
      for (let ai=0; ai<actions.length; ai++){
        const a = actions[ai];
        if (a.type === 'dist'){
          // remove first occurrence of a.value from simWorking2 at index where it's expected per simulation
          // In our deterministic simulation, it will be found at some index; find index by matching digit at current simDigit (hard).
          // But above actions are from a simulation; applying them sequentially will match.
          // So we need to apply sequentially:
          const idx = simWorking2.findIndex(x=>x===a.value);
          if (idx >= 0) simWorking2.splice(idx,1);
          simBuckets2[a.bucket].push(a.value);
        } else {
          const val = a.value;
          simBuckets2[a.bucket].shift();
          simWorking2.push(val);
        }
        if (stateEquals()){
          matchedIndex = ai; break;
        }
      }
      if (matchedIndex === -1){
        // No match, just reset to initial
        initialLoad();
        return;
      }
      // We want to step back one action: rebuild state by applying actions up to matchedIndex-1
      let targetWorking = initialArray.slice();
      let targetBuckets = Array.from({length: base}, ()=>[]);
      for (let ai=0; ai<=matchedIndex-1; ai++){
        const a = actions[ai];
        if (a.type === 'dist'){
          // find first occurrence in targetWorking (deterministic)
          const idx = targetWorking.findIndex(x=>x===a.value);
          if (idx>=0) targetWorking.splice(idx,1);
          targetBuckets[a.bucket].push(a.value);
        } else {
          targetBuckets[a.bucket].shift();
          targetWorking.push(a.value);
        }
      }
      // set state to target
      workingArray = targetWorking;
      buckets = targetBuckets;
      // set appropriate digitPos and phase by approximating where we are in action sequence
      // Count how many full distribution/collection passes have completed
      // Quick heuristic: find how many digits fully processed by scanning how many collects occurred for full base
      // We'll compute digitPos by simulating actions until ai <= matchedIndex-1 and tracking digit position.
      let simW = initialArray.slice();
      let simB = Array.from({length: base}, ()=>[]);
      let simD = 0;
      let idxAct = 0;
      while (simD < 32 && idxAct <= matchedIndex-1){
        // distribution
        while (simW.length > 0 && idxAct <= matchedIndex-1){
          // In actions list, we can inspect actions[idxAct] to know if next is dist or collect
          const a = actions[idxAct];
          if (a.type !== 'dist') break;
          // apply
          const idxx = simW.findIndex(x=>x===a.value);
          if (idxx>=0) simW.splice(idxx,1);
          simB[a.bucket].push(a.value);
          idxAct++;
        }
        // check if we've already passed all distributes in this digit (depending on idxAct)
        // if next action is collect, apply collects as long as idxAct <= matched
        while (idxAct <= matchedIndex-1 && idxAct < actions.length && actions[idxAct].type === 'collect'){
          const a = actions[idxAct];
          simB[a.bucket].shift();
          simW.push(a.value);
          idxAct++;
        }
        // finished gather for this digit
        simD++;
      }
      // set digitPos to simD (current next digit to process) but clamp
      digitPos = Math.min(simD, maxDigits-1);
      phase = (idxAct <= matchedIndex-1) ? 'collect' : 'distribute';
      render();
    }

    function play(){
      if (playing){
        clearInterval(timer); timer = null; playing = false; playPause.textContent = 'Play ▶';
      } else {
        playing = true; playPause.textContent = 'Pause ❚❚';
        timer = setInterval(()=>{
          // stop when done
          if (phase === 'done'){ play(); return; }
          stepForwardAction();
        }, Math.max(80, speedInput.value|0));
      }
    }

    // Event handlers
    function initialLoad(){
      try{
        showError('');
        initialArray = parseArrayInput(arrayInput.value);
        if (initialArray.some(v=>v < 0)) { showError("Negative numbers not supported."); return; }
        if (initialArray.length > 80) { showError("Array too large for visualization (max 80)."); return; }
        resetState(false);
      }catch(e){
        showError(e.message);
      }
    }
    loadBtn.addEventListener('click', initialLoad);
    preset.addEventListener('change', ()=>{ arrayInput.value = preset.value; });
    clearBtn.addEventListener('click', ()=>{
      arrayInput.value = '';
      initialLoad();
    });
    randomBtn.addEventListener('click', ()=>{
      const count = Math.max(1, Math.min(40, parseInt(randCount.value,10) || 10));
      const maxVal = Math.pow(10, Math.min(6, Math.max(1, Math.floor(Math.random()*4)+2))); // random vary
      const arr = [];
      for (let i=0;i<count;i++) arr.push(Math.floor(Math.random()*maxVal));
      arrayInput.value = arr.join(',');
      initialLoad();
    });
    baseInput.addEventListener('change', ()=>{ resetState(false); });
    speedInput.addEventListener('input', ()=>{ /* live */ });
    stepForward.addEventListener('click', ()=>{ stepForwardAction(); });
    stepBack.addEventListener('click', ()=>{ stepBackAction(); });
    playPause.addEventListener('click', ()=>{ play(); });
    resetBtn.addEventListener('click', ()=>{ resetState(true); });

    // initial render
    initialLoad();

    // Make sure we update UI on window focus if playing
    window.addEventListener('blur', ()=>{ /* optionally pause on blur */ });

    // Additional feature: keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if (e.key === ' ') { e.preventDefault(); play(); }
      if (e.key === 'ArrowRight') stepForwardAction();
      if (e.key === 'ArrowLeft') stepBackAction();
    });

    // Explanatory console output (for those who open devtools)
    console.log("Radix Sort (LSD) Visualizer loaded. Use the UI to interact.");
  })();
  </script>
</body>
</html>