<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Two Pointers — Interactive Visualizations</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root{
      --bg: #0f1724;
      --card: #0b1220;
      --muted: #94a3b8;
      --accent: #06b6d4;
      --accent-2: #7c3aed;
      --good: #16a34a;
      --bad: #ef4444;
      --glass: rgba(255,255,255,0.03);
      --panel-padding: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Helvetica Neue", monospace;
    }
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,var(--bg), #071027);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .wrap{
      max-width:1100px;
      margin:28px auto;
      padding:20px;
    }
    header{
      display:flex;
      align-items:center;
      gap:16px;
      margin-bottom:18px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    p.lead{
      margin:8px 0 0 0;
      color:var(--muted);
      font-size:13px;
    }
    .grid{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:18px;
      align-items:start;
    }
    .panel{
      background:linear-gradient(180deg,var(--card), rgba(9,15,25,0.9));
      border:1px solid rgba(255,255,255,0.03);
      padding:var(--panel-padding);
      border-radius:12px;
      box-shadow: 0 6px 24px rgba(3,7,18,0.6);
    }
    label{display:block; font-size:13px; color:var(--muted); margin-bottom:6px;}
    .controls > * {margin-bottom:12px;}
    input[type="text"], input[type="number"], select{
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:var(--glass);
      color:inherit;
      font-size:14px;
      outline:none;
    }
    .btn{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      background:linear-gradient(180deg,var(--accent), #0891b2);
      color:#042027;
      font-weight:600;
      border:none;
      box-shadow: 0 6px 18px rgba(6,182,212,0.12);
    }
    .btn.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      font-weight:600;
      box-shadow:none;
    }
    .row{display:flex; gap:8px;}
    .small{font-size:13px; padding:8px 10px;}
    .visual{
      min-height:320px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .array-vis{
      display:flex;
      align-items:end;
      gap:8px;
      height:200px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      padding:16px;
      border-radius:10px;
      border:1px dashed rgba(255,255,255,0.02);
      position:relative;
      overflow:hidden;
    }
    .bar{
      width:34px;
      background:linear-gradient(180deg,#60a5fa33,#60a5fa22);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-end;
      border-radius:6px;
      position:relative;
      transition: all 200ms ease;
      box-shadow: 0 6px 14px rgba(2,6,23,0.45) inset;
      color:#dbeafe;
      font-weight:700;
      font-family:var(--mono);
      user-select:none;
    }
    .bar .val{
      padding:6px 4px;
      font-size:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:4px;
      margin-bottom:6px;
      width:100%;
      text-align:center;
    }
    .bar.index{
      font-size:11px;
      color:var(--muted);
      margin-top:6px;
      padding-bottom:6px;
    }
    .pointer{
      position:absolute;
      top:6px;
      padding:4px 8px;
      border-radius:6px;
      font-size:12px;
      color:#021025;
      font-weight:700;
      transform:translateX(-50%);
      pointer-events:none;
    }
    .pointer.left{ background:linear-gradient(180deg, #34d399, #10b981); left:0;}
    .pointer.right{ background:linear-gradient(180deg, #fb7185, #ef4444); left:100%;}
    .pointer.center{ background:linear-gradient(180deg, #7c3aed, #6d28d9); left:50%;}
    .status{
      font-size:13px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .log{
      margin-top:8px;
      background:rgba(255,255,255,0.02);
      border-radius:8px;
      padding:10px;
      max-height:160px;
      overflow:auto;
      font-family:var(--mono);
      font-size:13px;
      color:var(--muted);
    }
    .pseudocode{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:8px;
      padding:10px;
      font-family:var(--mono);
      font-size:13px;
      color:#c4d6ea;
      margin-top:10px;
      white-space:pre;
    }
    .small-muted{font-size:13px; color:var(--muted);}
    .footer{
      margin-top:18px;
      font-size:13px;
      color:var(--muted);
    }
    .help{
      margin-top:12px;
      font-size:13px;
      color:var(--muted);
      line-height:1.5;
    }
    .found{
      outline: 3px solid rgba(16,185,129,0.14);
      box-shadow: 0 8px 30px rgba(16,185,129,0.06) inset;
    }
    .muted-pill{
      padding:6px 8px;
      border-radius:999px;
      background:rgba(255,255,255,0.02);
      color:var(--muted);
      font-size:12px;
    }
    .note{
      font-size:12px;
      color:var(--muted);
      margin-top:8px;
    }

    /* responsive */
    @media (max-width:980px){
      .grid{grid-template-columns: 1fr; }
      header{flex-direction:column; align-items:flex-start; gap:6px;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Two Pointers — Interactive Visualizations</h1>
        <p class="lead">Explore common two-pointer patterns: pair-sum in a sorted array, in-place remove duplicates, and maximizing water container. Step through the pointer movements to build intuition.</p>
      </div>
    </header>

    <div class="grid">
      <div class="panel controls">
        <label for="problem">Choose problem</label>
        <select id="problem">
          <option value="pair">Pair Sum (sorted array)</option>
          <option value="remove">Remove Duplicates (in-place)</option>
          <option value="container">Container With Most Water</option>
        </select>

        <div id="inputs">
          <div id="arr-input" style="margin-top:10px;">
            <label for="array">Array (comma or space separated numbers)</label>
            <input id="array" type="text" placeholder="e.g. 1 2 2 3 4 5">
            <div style="margin-top:8px; display:flex; gap:8px;">
              <button class="btn small" id="random">Random</button>
              <button class="btn secondary small" id="clear-array">Clear</button>
            </div>
          </div>

          <div id="target-input" style="margin-top:12px;">
            <label for="target">Target (for Pair Sum)</label>
            <input id="target" type="number" placeholder="e.g. 7">
            <div class="note">Pair Sum assumes a sorted array. Use the "Sort" button or provide a sorted array.</div>
            <div style="margin-top:8px; display:flex; gap:8px;">
              <button class="btn small" id="sort-array">Sort</button>
              <button class="btn secondary small" id="shuffle-array">Shuffle</button>
            </div>
          </div>
        </div>

        <div style="margin-top:12px;">
          <label>Animation speed</label>
          <input type="range" id="speed" min="50" max="1500" value="450">
          <div class="small-muted" style="margin-top:6px;">Step delay: <span id="speed-label">450ms</span></div>
        </div>

        <div style="margin-top:12px;">
          <label>Controls</label>
          <div class="row">
            <button class="btn" id="start">Start</button>
            <button class="btn secondary" id="pause">Pause</button>
            <button class="btn secondary" id="step">Step</button>
            <button class="btn secondary" id="reset">Reset</button>
          </div>
        </div>

        <div style="margin-top:12px;">
          <label>Quick examples</label>
          <div class="row">
            <button class="btn small" id="ex1">Sorted with duplicates</button>
            <button class="btn small" id="ex2">Heights (container)</button>
            <button class="btn small" id="ex3">Pair-sum example</button>
          </div>
        </div>

        <div class="help">
          <strong>Two pointers patterns:</strong>
          <ul style="margin-top:8px; padding-left:18px; color:var(--muted);">
            <li>Opposite ends: left/right moving toward each other (pair-sum, max area).</li>
            <li>Fast/slow: one pointer moves faster (find middle or detect cycles).</li>
            <li>Sliding window: expand/contract window using two indices (subarray sums).</li>
          </ul>
        </div>

        <div class="footer">
          Tip: enter small arrays (6–12 elements) for clearer visuals. Use the Step button to walk the algorithm manually.
        </div>
      </div>

      <div class="panel visual">
        <div class="status">
          <div>
            <span class="muted-pill" id="problem-title">Pair Sum (sorted array)</span>
            <span style="margin-left:10px;" id="info-extra"></span>
          </div>
          <div class="small-muted" id="complexity">Time: O(n) • Space: O(1)</div>
        </div>

        <div id="vis-area" style="position:relative;">
          <div class="array-vis" id="array-vis">
            <!-- bars rendered here -->
          </div>
          <!-- pointers -->
        </div>

        <div class="log" id="log">Ready. Configure inputs and press Start.</div>

        <div id="pseudocode" class="pseudocode"></div>
      </div>
    </div>
  </div>

  <script>
    // Two Pointers interactive visualizer
    (function(){
      // UI elements
      const problemEl = document.getElementById('problem');
      const arrayEl = document.getElementById('array');
      const targetEl = document.getElementById('target');
      const startBtn = document.getElementById('start');
      const pauseBtn = document.getElementById('pause');
      const stepBtn = document.getElementById('step');
      const resetBtn = document.getElementById('reset');
      const randomBtn = document.getElementById('random');
      const clearBtn = document.getElementById('clear-array');
      const ex1Btn = document.getElementById('ex1');
      const ex2Btn = document.getElementById('ex2');
      const ex3Btn = document.getElementById('ex3');
      const sortBtn = document.getElementById('sort-array');
      const shuffleBtn = document.getElementById('shuffle-array');
      const vis = document.getElementById('array-vis');
      const logEl = document.getElementById('log');
      const pcEl = document.getElementById('pseudocode');
      const speedEl = document.getElementById('speed');
      const speedLabel = document.getElementById('speed-label');
      const titleEl = document.getElementById('problem-title');
      const complexityEl = document.getElementById('complexity');
      const infoExtra = document.getElementById('info-extra');

      let state = {
        arr: [],
        steps: [],
        stepIndex: 0,
        playing: false,
        timer: null,
        currentProblem: 'pair'
      };

      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      function log(msg){
        const p = document.createElement('div');
        p.textContent = msg;
        logEl.appendChild(p);
        logEl.scrollTop = logEl.scrollHeight;
      }

      function parseArrayInput(text){
        if(!text) return [];
        // split by comma or space
        const toks = text.trim().split(/[\s,]+/).filter(Boolean);
        const nums = toks.map(t => {
          const n = Number(t);
          return Number.isFinite(n) ? n : NaN;
        });
        if(nums.some(Number.isNaN)) return null;
        return nums;
      }

      // rendering
      function renderArray(arr, highlight = {}) {
        vis.innerHTML = '';
        if(!arr || arr.length === 0){
          vis.innerHTML = '<div style="color:var(--muted); padding:12px;">Array is empty — enter numbers and press Start.</div>';
          return;
        }
        const maxVal = Math.max(1, ...arr.map(Math.abs));
        const scale = (val) => {
          // map to 20..160 px height
          const h = Math.max(18, Math.round((Math.abs(val) / maxVal) * 140) + 18);
          return h;
        };
        arr.forEach((v, i) => {
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.style.height = scale(v) + 'px';
          bar.style.width = (34) + 'px';
          bar.dataset.index = i;
          // color variations
          bar.style.background = 'linear-gradient(180deg, rgba(99,102,241,0.18), rgba(99,102,241,0.06))';
          // make found/unique markers
          if(highlight.found && highlight.found.includes(i)) {
            bar.classList.add('found');
            bar.style.background = 'linear-gradient(180deg, rgba(16,185,129,0.18), rgba(16,185,129,0.06))';
          } else if(highlight.unique && highlight.unique.includes(i)) {
            bar.style.background = 'linear-gradient(180deg, rgba(99,102,241,0.18), rgba(124,58,237,0.06))';
          } else if(highlight.left === i) {
            bar.style.background = 'linear-gradient(180deg, rgba(34,197,94,0.18), rgba(16,185,129,0.06))';
          } else if(highlight.right === i) {
            bar.style.background = 'linear-gradient(180deg, rgba(251,113,133,0.18), rgba(239,68,68,0.06))';
          } else if(highlight.moving === i) {
            bar.style.background = 'linear-gradient(180deg, rgba(124,58,237,0.18), rgba(99,102,241,0.06))';
          }
          const val = document.createElement('div');
          val.className = 'val';
          val.textContent = v;
          const idx = document.createElement('div');
          idx.className = 'index';
          idx.textContent = i;
          bar.appendChild(val);
          bar.appendChild(idx);
          vis.appendChild(bar);
        });

        // pointer markers: create absolute positioned elements above the bars
        const bars = Array.from(vis.querySelectorAll('.bar'));
        function placePointer(kind, index, text){
          if(index == null) return;
          const bar = bars[index];
          if(!bar) return;
          const rect = bar.getBoundingClientRect();
          const parentRect = vis.getBoundingClientRect();
          const left = (rect.left - parentRect.left) + rect.width/2;
          const ptr = document.createElement('div');
          ptr.className = 'pointer ' + kind;
          ptr.style.left = left + 'px';
          ptr.textContent = text||kind;
          vis.appendChild(ptr);
        }
        // highlight left/right pointers if provided
        if(highlight.left != null) placePointer('left', highlight.left, 'L');
        if(highlight.right != null) placePointer('right', highlight.right, 'R');
        if(highlight.center != null) placePointer('center', highlight.center, 'mid');
      }

      // algorithms: produce an array of steps representing pointer states & messages
      function generateStepsPairSum(arr, target){
        const steps = [];
        const a = arr.slice();
        let l = 0, r = a.length-1;
        steps.push({l,r, msg:`start left=${l}, right=${r}`});
        while(l < r){
          const s = a[l] + a[r];
          if(s === target){
            steps.push({l,r, found:[l,r], msg:`found a[${l}] + a[${r}] = ${a[l]} + ${a[r]} = ${target}`});
            return steps;
          } else if(s < target){
            steps.push({l,r, msg:`sum=${s} < ${target}, move left`});
            l++;
            steps.push({l,r, msg:`moved left -> ${l}`});
          } else {
            steps.push({l,r, msg:`sum=${s} > ${target}, move right`});
            r--;
            steps.push({l,r, msg:`moved right -> ${r}`});
          }
        }
        steps.push({l,r, msg:`no pair found`});
        return steps;
      }

      function generateStepsRemoveDuplicates(arr){
        // "remove duplicates in sorted array" — returns steps showing slow/fast pointers and state of array
        const steps = [];
        const a = arr.slice();
        if(a.length === 0){
          steps.push({i:null, j:null, arr:a.slice(), msg:'empty array'});
          return steps;
        }
        let i = 0;
        steps.push({i, j:0, arr:a.slice(), msg:`start i=${i}`});
        for(let j=1;j<a.length;j++){
          steps.push({i, j, arr:a.slice(), msg:`compare a[${j}]=${a[j]} with a[${i}]=${a[i]}`});
          if(a[j] !== a[i]){
            i++;
            a[i] = a[j];
            steps.push({i, j, arr:a.slice(), uniqueIndex:i, msg:`unique found, placed at i=${i}`});
          } else {
            steps.push({i, j, arr:a.slice(), msg:`duplicate -> skip`});
          }
        }
        steps.push({i, j:null, arr:a.slice(), length:i+1, msg:`done. new length = ${i+1}`});
        return steps;
      }

      function generateStepsContainer(arr){
        const steps = [];
        const a = arr.slice();
        let l = 0, r = a.length-1;
        let best = 0;
        let bestPair = null;
        steps.push({l,r,best, msg:`start l=${l}, r=${r}`});
        while(l < r){
          const height = Math.min(a[l], a[r]);
          const width = r-l;
          const area = height * width;
          steps.push({l,r,curArea:area, msg:`compute area = min(${a[l]},${a[r]})*${width} = ${area}`});
          if(area > best){
            best = area; bestPair = [l,r];
            steps.push({l,r,best,found:bestPair, msg:`new best=${best} at (${l},${r})`});
          }
          // move pointer from smaller height
          if(a[l] < a[r]){
            steps.push({l,r, msg:`a[${l}] < a[${r}] -> move left`});
            l++;
            steps.push({l,r, msg:`moved left -> ${l}`});
          } else {
            steps.push({l,r, msg:`a[${r}] <= a[${l}] -> move right`});
            r--;
            steps.push({l,r, msg:`moved right -> ${r}`});
          }
        }
        steps.push({l,r,best, bestPair, msg:`done. max area = ${best} at ${bestPair ? `(${bestPair[0]},${bestPair[1]})` : 'none'}`});
        return steps;
      }

      // prepare steps depending on problem
      function prepare(){
        const arr = parseArrayInput(arrayEl.value);
        if(arr === null){
          alert('Invalid array input — use only numbers separated by spaces or commas.');
          return false;
        }
        if(arr.length === 0){
          alert('Enter an array of numbers (at least 1).');
          return false;
        }
        state.arr = arr;
        state.steps = [];
        state.stepIndex = 0;
        const prob = problemEl.value;
        state.currentProblem = prob;
        if(prob === 'pair'){
          titleEl.textContent = 'Pair Sum (sorted array)';
          complexityEl.textContent = 'Time: O(n) • Space: O(1)';
          const target = Number(targetEl.value);
          if(!Number.isFinite(target)) {
            alert('Enter a numeric target for Pair Sum.');
            return false;
          }
          state.target = target;
          // ideally sorted. If not sorted, we warn but still run on provided array or we can sort if user clicked Sort.
          const isSorted = state.arr.every((v,i,a) => i===0 || a[i] >= a[i-1]);
          if(!isSorted){
            // allow but warn
            if(!confirm('Array is not sorted. Pair Sum technique assumes a sorted array. Do you want to sort it automatically? (OK = sort, Cancel = continue anyway)')){
              // continue with as-is
              log('Warning: running on unsorted array (results may be incorrect).');
            } else {
              state.arr.sort((x,y)=>x-y);
              arrayEl.value = state.arr.join(' ');
              log('Array auto-sorted for Pair Sum.');
            }
          }
          state.steps = generateStepsPairSum(state.arr, target);
          pcEl.textContent = `# Pair Sum (Two pointers from ends)\nleft = 0\nright = n-1\nwhile left < right:\n  s = a[left] + a[right]\n  if s == target: return (left,right)\n  if s < target: left++\n  else: right--\nreturn not found`;
        } else if(prob === 'remove'){
          titleEl.textContent = 'Remove Duplicates (in-place)';
          complexityEl.textContent = 'Time: O(n) • Space: O(1)';
          state.steps = generateStepsRemoveDuplicates(state.arr);
          pcEl.textContent = `# Remove duplicates (sorted array)\ni = 0\nfor j in 1..n-1:\n  if a[j] != a[i]:\n    i += 1\n    a[i] = a[j]\n# new length = i+1`;
        } else if(prob === 'container'){
          titleEl.textContent = 'Container With Most Water';
          complexityEl.textContent = 'Time: O(n) • Space: O(1)';
          state.steps = generateStepsContainer(state.arr);
          pcEl.textContent = `# Container With Most Water\nleft=0; right=n-1; best=0\nwhile left < right:\n  area = min(a[left],a[right])*(right-left)\n  best = max(best, area)\n  if a[left] < a[right]: left++\n  else: right--\nreturn best`;
        }
        // initial render
        renderArray(state.arr);
        logEl.innerHTML = 'Prepared. Press Start to play steps.';
        return true;
      }

      // advance one step
      function applyStep(step){
        // render according to current problem
        const prob = state.currentProblem;
        if(prob === 'pair'){
          const highlight = {};
          if(step.l!=null) highlight.left = step.l;
          if(step.r!=null) highlight.right = step.r;
          if(step.found) highlight.found = step.found.slice();
          renderArray(state.arr, highlight);
          if(step.msg) log(`${step.msg}`);
        } else if(prob === 'remove'){
          // display array as step.arr and mark unique zone (0..i) and pointers
          const highlight = {};
          highlight.left = step.i;
          if(step.j!=null) highlight.right = step.j;
          // mark unique region
          if(step.uniqueIndex!=null){
            const uniq = [];
            for(let k=0;k<=step.uniqueIndex;k++) uniq.push(k);
            highlight.unique = uniq;
          } else if(step.arr && step.length!=null){
            const uniq = [];
            for(let k=0;k<step.length;k++) uniq.push(k);
            highlight.unique = uniq;
          }
          renderArray(step.arr, highlight);
          if(step.msg) log(step.msg);
        } else if(prob === 'container'){
          const highlight = {};
          if(step.l!=null) highlight.left = step.l;
          if(step.r!=null) highlight.right = step.r;
          if(step.found) highlight.found = step.found.slice();
          if(step.curArea!=null) highlight.moving = (step.l+step.r)/2 | 0;
          renderArray(state.arr, highlight);
          if(step.msg) log(step.msg + (step.curArea!=null ? ` (area=${step.curArea})` : ''));
        }
      }

      // playback
      function play(){
        if(state.playing) return;
        state.playing = true;
        startTimer();
      }
      function pause(){
        state.playing = false;
        if(state.timer) { clearTimeout(state.timer); state.timer = null; }
      }
      function startTimer(){
        const delay = Number(speedEl.value);
        speedLabel.textContent = delay + 'ms';
        if(state.stepIndex >= state.steps.length){
          state.playing = false;
          return;
        }
        state.timer = setTimeout(() => {
          const step = state.steps[state.stepIndex];
          applyStep(step);
          state.stepIndex++;
          if(state.stepIndex < state.steps.length && state.playing){
            startTimer();
          } else {
            state.playing = false;
            log('Playback finished.');
          }
        }, delay);
      }

      // step forward manually
      function stepOnce(){
        if(state.stepIndex >= state.steps.length) {
          log('No more steps.');
          return;
        }
        const step = state.steps[state.stepIndex];
        applyStep(step);
        state.stepIndex++;
        if(state.stepIndex >= state.steps.length){
          log('Done.');
        }
      }

      // reset
      function reset(){
        pause();
        state.stepIndex = 0;
        renderArray(state.arr);
        logEl.innerHTML = 'Reset. Steps cleared. Press Start to run again.';
      }

      // attach events
      startBtn.addEventListener('click', ()=> {
        // if not prepared, prepare
        if(state.steps.length === 0 || state.arr.length === 0 || state.currentProblem !== problemEl.value){
          const ok = prepare();
          if(!ok) return;
        }
        // resume from current step index
        state.playing = true;
        log('Starting playback...');
        startTimer();
      });

      pauseBtn.addEventListener('click', ()=> {
        pause();
        log('Paused.');
      });

      stepBtn.addEventListener('click', ()=>{
        if(state.steps.length === 0 || state.arr.length === 0 || state.currentProblem !== problemEl.value){
          const ok = prepare();
          if(!ok) return;
        }
        pause();
        stepOnce();
      });

      resetBtn.addEventListener('click', ()=>{
        const ok = prepare();
        if(!ok) return;
        reset();
      });

      // quick helpers
      randomBtn.addEventListener('click', ()=>{
        const prob = problemEl.value;
        if(prob === 'container'){
          // random heights 6-10 elements
          const n = 6 + Math.floor(Math.random()*6);
          const arr = Array.from({length:n}, ()=>Math.floor(Math.random()*9)+1);
          arrayEl.value = arr.join(' ');
        } else if(prob === 'remove'){
          // generate sorted with duplicates
          const n = 7 + Math.floor(Math.random()*6);
          let v = 1;
          const arr = [];
          for(let i=0;i<n;i++){
            if(Math.random() < 0.4) v += Math.floor(Math.random()*2);
            arr.push(v);
          }
          arrayEl.value = arr.join(' ');
        } else {
          const n = 6 + Math.floor(Math.random()*6);
          const arr = Array.from({length:n}, ()=>Math.floor(Math.random()*20)-5);
          arr.sort((a,b)=>a-b);
          arrayEl.value = arr.join(' ');
        }
        log('Random array created.');
      });

      clearBtn.addEventListener('click', ()=> {
        arrayEl.value = '';
        targetEl.value = '';
        renderArray([]);
        log('Cleared array.');
      });

      ex1Btn.addEventListener('click', ()=>{
        // sorted with duplicates for remove duplicates
        arrayEl.value = '1 1 2 2 2 3 4 4 5';
        problemEl.value = 'remove';
        problemEl.dispatchEvent(new Event('change'));
      });
      ex2Btn.addEventListener('click', ()=>{
        arrayEl.value = '4 3 2 1 4 3 2';
        problemEl.value = 'container';
        problemEl.dispatchEvent(new Event('change'));
      });
      ex3Btn.addEventListener('click', ()=>{
        arrayEl.value = '1 2 3 4 5 6 7 8';
        targetEl.value = '11';
        problemEl.value = 'pair';
        problemEl.dispatchEvent(new Event('change'));
      });

      sortBtn.addEventListener('click', ()=>{
        const arr = parseArrayInput(arrayEl.value);
        if(arr === null){ alert('Invalid array'); return; }
        arr.sort((a,b)=>a-b);
        arrayEl.value = arr.join(' ');
        log('Array sorted.');
      });
      shuffleBtn.addEventListener('click', ()=>{
        const arr = parseArrayInput(arrayEl.value);
        if(arr === null){ alert('Invalid array'); return; }
        for(let i=arr.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [arr[i],arr[j]] = [arr[j],arr[i]];
        }
        arrayEl.value = arr.join(' ');
        log('Array shuffled.');
      });

      problemEl.addEventListener('change', ()=>{
        const p = problemEl.value;
        // adjust UI visibility
        if(p === 'pair'){
          document.getElementById('target-input').style.display = '';
          document.getElementById('arr-input').style.display = '';
          infoExtra.textContent = '';
        } else if(p === 'remove'){
          document.getElementById('target-input').style.display = 'none';
          document.getElementById('arr-input').style.display = '';
          infoExtra.textContent = 'Requires sorted array';
        } else if(p === 'container'){
          document.getElementById('target-input').style.display = 'none';
          document.getElementById('arr-input').style.display = '';
          infoExtra.textContent = '';
        }
        // reset previous prepared steps
        state.steps = [];
        state.arr = [];
        state.stepIndex = 0;
        pcEl.textContent = '';
        renderArray([]);
        logEl.innerHTML = 'Problem changed. Enter inputs and press Start.';
      });

      speedEl.addEventListener('input', ()=>{
        speedLabel.textContent = speedEl.value + 'ms';
      });

      // initial render
      renderArray([]);
      problemEl.dispatchEvent(new Event('change'));

      // helpers: prepare before unload?
      // nothing else
    })();
  </script>
</body>
</html>