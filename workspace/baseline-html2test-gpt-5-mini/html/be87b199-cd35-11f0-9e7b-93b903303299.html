<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Longest Common Subsequence (LCS) Visualizer</title>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --accent:#7dd3fc;
    --muted:#9aa6b2;
    --cell:#0b1624;
    --highlight:#1f6feb;
    --match:#16a34a;
    --danger:#ef4444;
    color-scheme: dark;
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{background:linear-gradient(180deg,#071021 0%, #071427 100%);padding:24px;color:#eef2f7;}
  .container{max-width:1100px;margin:0 auto;}
  header{display:flex;align-items:center;gap:16px;margin-bottom:18px;}
  h1{font-size:20px;margin:0;}
  p.lead{margin:4px 0 0;color:var(--muted);font-size:13px;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));border-radius:10px;padding:14px;margin-bottom:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03);}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;}
  label{font-size:13px;color:var(--muted);}
  input[type="text"]{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:#eef2f7;font-size:14px;min-width:220px;}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;}
  button{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;color:#eef2f7;cursor:pointer;}
  button.primary{background:linear-gradient(90deg,var(--accent),#60a5fa);color:#041022;border:none;}
  button.warn{background:linear-gradient(90deg,var(--danger),#fb7185);color:white;border:none;}
  button.small{padding:6px 8px;font-size:13px;}
  .controls .note{color:var(--muted);font-size:13px;align-self:center;}
  .grid-area{display:flex;gap:14px;flex-wrap:wrap;margin-top:12px;}
  .table-wrap{overflow:auto;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.01));padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);}
  table.dp{border-collapse:collapse;min-width:320px;}
  table.dp th, table.dp td{border:1px solid rgba(255,255,255,0.03);padding:6px 8px;text-align:center;min-width:36px;height:36px;background:var(--cell);color:#dbeafe;position:relative;}
  table.dp th.top{background:transparent;color:var(--muted);min-width:36px;}
  .charcell{font-weight:600;color:#e6edf3;background:transparent;}
  .indexcell{color:var(--muted);font-size:12px}
  .cell-current{outline:3px solid rgba(125,211,252,0.14);box-shadow:inset 0 0 0 2px rgba(125,211,252,0.06);}
  .cell-match{background:linear-gradient(180deg, rgba(22,163,74,0.12), rgba(22,163,74,0.06));border-color:rgba(16,185,129,0.12);}
  .cell-backtrack{background:linear-gradient(180deg, rgba(31,111,235,0.12), rgba(31,111,235,0.06));border-color:rgba(59,130,246,0.12);}
  .result{font-weight:700;color:var(--accent);font-size:16px;}
  .small-muted{color:var(--muted);font-size:13px;}
  .footer{margin-top:10px;color:var(--muted);font-size:13px;}
  .example-list{display:flex;gap:8px;flex-wrap:wrap;}
  .example{background:transparent;border:1px dashed rgba(255,255,255,0.04);padding:6px 8px;border-radius:8px;color:var(--muted);cursor:pointer;}
  .legend{display:flex;gap:8px;align-items:center;margin-top:8px;}
  .legend .box{width:14px;height:14px;border-radius:4px;}
  .box.match{background:var(--match)}
  .box.bt{background:var(--highlight)}
  .box.curr{background:linear-gradient(90deg,#7dd3fc,#60a5fa)}
  .limit-warning{color:var(--danger);font-size:13px;margin-top:8px;}
  @media (max-width:720px){
    table.dp th, table.dp td{min-width:30px;padding:6px;}
  }
</style>
</head>
<body>
<div class="container">
  <header>
    <div>
      <h1>Longest Common Subsequence (LCS) Visualizer</h1>
      <p class="lead">Interactive demo of dynamic programming for LCS. Type two strings, step through the DP table, and reconstruct the LCS.</p>
    </div>
  </header>

  <div class="card">
    <div class="row" style="justify-content:space-between;">
      <div>
        <label>String A (columns)</label><br/>
        <input id="strA" type="text" value="ABCBDAB" maxlength="120"/>
      </div>
      <div>
        <label>String B (rows)</label><br/>
        <input id="strB" type="text" value="BDCABA" maxlength="120"/>
      </div>
      <div style="min-width:260px;">
        <label>Options</label>
        <div class="controls">
          <button id="computeBtn" class="primary">Compute DP</button>
          <button id="stepBtn" class="small">Step</button>
          <button id="playBtn" class="small">Play</button>
          <button id="pauseBtn" class="small">Pause</button>
          <button id="reconstructBtn">Reconstruct LCS</button>
          <button id="allBtn">Find all LCS (limited)</button>
          <div style="flex:1"></div>
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:12px;align-items:center;">
      <div class="example-list" aria-hidden="true">
        <button class="example" data-a="AGGTAB" data-b="GXTXAYB">AGGTAB / GXTXAYB</button>
        <button class="example" data-a="ABCDGH" data-b="AEDFHR">ABCDGH / AEDFHR</button>
        <button class="example" data-a="AXYT" data-b="AYZX">AXYT / AYZX</button>
        <button class="example" data-a="ABCBDAB" data-b="BDCABA">ABCBDAB / BDCABA</button>
        <button class="example" data-a="XMJYAUZ" data-b="MZJAWXU">XMJYAUZ / MZJAWXU</button>
      </div>
      <div style="margin-left:auto;" class="small-muted">
        DP size: <span id="dpSize">0×0</span> • Complexity: O(n×m)
      </div>
    </div>
  </div>

  <div class="grid-area">
    <div style="flex:1;min-width:320px" class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div>
          <strong>DP Table</strong>
          <div class="small-muted">Rows = string B, Columns = string A</div>
        </div>
        <div class="legend">
          <div style="display:flex;gap:6px;align-items:center;">
            <div class="box curr"></div><div class="small-muted">current cell</div>
          </div>
          <div style="display:flex;gap:6px;align-items:center;">
            <div class="box match"></div><div class="small-muted">match (diagonal taken)</div>
          </div>
          <div style="display:flex;gap:6px;align-items:center;">
            <div class="box bt"></div><div class="small-muted">backtrack path</div>
          </div>
        </div>
      </div>

      <div style="margin-top:10px;" class="table-wrap" id="tableWrap">
        <!-- Table will be injected here -->
        <div class="small-muted" id="hint">Press "Compute DP" to generate the table.</div>
      </div>

      <div style="display:flex;gap:8px;align-items:center;margin-top:10px;">
        <div class="small-muted">Animation speed</div>
        <input id="speed" type="range" min="50" max="2000" value="300"/>
        <div class="small-muted" id="speedVal">300ms</div>
      </div>
    </div>

    <div style="width:340px;min-width:260px" class="card">
      <div>
        <strong>Results</strong>
        <div class="small-muted">Length and one LCS (or all if requested).</div>
      </div>

      <div style="margin-top:12px;">
        <div>LCS length: <span id="lcsLen" class="result">-</span></div>
        <div style="margin-top:8px;">One LCS: <span id="oneLCS" class="result">-</span></div>
        <div style="margin-top:8px;">All LCS (limited):</div>
        <div id="allList" style="margin-top:8px;max-height:180px;overflow:auto;border-radius:6px;padding:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)"></div>
        <div id="limitWarn" class="limit-warning" style="display:none;"></div>
      </div>

      <div style="margin-top:12px;">
        <strong>About</strong>
        <p class="small-muted" style="margin-top:6px;">
          The DP table stores lengths of LCS for prefixes. dp[i][j] is LCS length of B[0..i-1] and A[0..j-1].
          If characters match, dp[i][j] = dp[i-1][j-1]+1; otherwise max(dp[i-1][j], dp[i][j-1]).
        </p>
      </div>
    </div>
  </div>

  <div class="footer">
    Tip: Use short strings to see detailed steps. Finding all LCS can grow exponentially; the "Find all LCS" button caps results to avoid heavy computation.
  </div>
</div>

<script>
(function(){
  // Elements
  const strAInput = document.getElementById('strA');
  const strBInput = document.getElementById('strB');
  const computeBtn = document.getElementById('computeBtn');
  const stepBtn = document.getElementById('stepBtn');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const reconstructBtn = document.getElementById('reconstructBtn');
  const allBtn = document.getElementById('allBtn');
  const tableWrap = document.getElementById('tableWrap');
  const dpSizeEl = document.getElementById('dpSize');
  const lcsLenEl = document.getElementById('lcsLen');
  const oneLCSEl = document.getElementById('oneLCS');
  const allListEl = document.getElementById('allList');
  const hintEl = document.getElementById('hint');
  const speed = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const limitWarn = document.getElementById('limitWarn');

  const examples = document.querySelectorAll('.example');
  examples.forEach(btn=>{
    btn.addEventListener('click', ()=> {
      strAInput.value = btn.dataset.a;
      strBInput.value = btn.dataset.b;
    });
  });

  let dp = []; // 2D array dp[i][j]
  let sA = '';
  let sB = '';
  let rows=0, cols=0;
  let running = false;
  let autoplay = false;
  let playTimer = null;
  let currentCell = {i:0,j:0};
  let tableEl = null;
  const ALL_LIMIT = 400; // maximum number of distinct LCS to show

  speed.addEventListener('input', ()=> speedVal.textContent = speed.value+'ms');

  function createTable(){
    // build HTML table: top row headers with A chars, left column headers with B chars
    tableWrap.innerHTML = '';
    hintEl.style.display='none';

    const tbl = document.createElement('table');
    tbl.className = 'dp';
    const thead = document.createElement('thead');
    const thr = document.createElement('tr');

    // top-left empty corner
    const corner = document.createElement('th'); corner.className='top'; corner.textContent='';
    thr.appendChild(corner);

    // top row: j from 0..cols-1, with column indices and characters (we add an extra top header row for chars)
    // Add header for j=0 (empty prefix)
    const th0 = document.createElement('th'); th0.className='top'; th0.innerHTML = '<div class="indexcell">j=0</div><div class="charcell"></div>';
    thr.appendChild(th0);

    for(let j=1;j<=cols;j++){
      const th = document.createElement('th');
      th.className='top';
      th.innerHTML = '<div class="indexcell">j='+j+'</div><div class="charcell">'+escapeHtml(sA[j-1])+'</div>';
      thr.appendChild(th);
    }
    thead.appendChild(thr);
    tbl.appendChild(thead);

    const tbody = document.createElement('tbody');

    // row 0: B index 0 header handled in thead's first header cell? We'll show row index and char in left column of each row.
    for(let i=0;i<=rows;i++){
      const tr = document.createElement('tr');
      for(let j=0;j<=cols;j++){
        const td = document.createElement('td');
        td.dataset.i = i;
        td.dataset.j = j;
        if(j===0){
          // left-most header for each row: show index and char
          if(i===0){
            td.innerHTML = '<div class="indexcell">i=0</div><div class="charcell"></div>';
            td.classList.add('indexcell');
          } else {
            td.innerHTML = '<div class="indexcell">i='+i+'</div><div class="charcell">'+escapeHtml(sB[i-1])+'</div>';
            td.classList.add('indexcell');
          }
        } else {
          // normal dp cell (j>0). For i=0 these are dp[0][j] zeros
          td.textContent = '0';
        }
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    tbl.appendChild(tbody);
    tableWrap.appendChild(tbl);
    tableEl = tbl;
  }

  function escapeHtml(s){
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  function initDP(){
    dp = [];
    for(let i=0;i<=rows;i++){
      const row = new Array(cols+1).fill(0);
      dp.push(row);
    }
    // update dp size display
    dpSizeEl.textContent = (rows+1)+'×'+(cols+1);
    lcsLenEl.textContent='-';
    oneLCSEl.textContent='-';
    allListEl.innerHTML='';
    limitWarn.style.display='none';
  }

  function computeStep(i,j){
    // compute dp[i][j], assuming dp previous cells are computed
    const cellEl = tableEl.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
    highlightCurrent(cellEl);
    if(i===0 || j===0){
      dp[i][j]=0;
      cellEl.textContent = '0';
      return;
    }
    if(sB[i-1] === sA[j-1]){
      dp[i][j] = dp[i-1][j-1] + 1;
      cellEl.textContent = dp[i][j];
      cellEl.classList.add('cell-match');
    } else {
      const up = dp[i-1][j];
      const left = dp[i][j-1];
      dp[i][j] = Math.max(up,left);
      cellEl.textContent = dp[i][j];
    }
  }

  function highlightCurrent(el){
    // clear previous current
    tableEl.querySelectorAll('.cell-current').forEach(n=>n.classList.remove('cell-current'));
    if(el) el.classList.add('cell-current');
  }

  function clearHighlights(){
    tableEl.querySelectorAll('.cell-match').forEach(n=>n.classList.remove('cell-match'));
    tableEl.querySelectorAll('.cell-backtrack').forEach(n=>n.classList.remove('cell-backtrack'));
    tableEl.querySelectorAll('.cell-current').forEach(n=>n.classList.remove('cell-current'));
  }

  function computeAllAnimated(){
    // step across i=0..rows, j=0..cols in row-major for visualization
    currentCell = {i:0,j:0};
    running = true;
    autoplay = true;
    stepNext();
  }

  function stepNext(){
    if(!running) return;
    const i = currentCell.i;
    const j = currentCell.j;
    computeStep(i,j);
    // move to next cell
    if(j < cols){
      currentCell.j++;
    } else {
      if(i < rows){
        currentCell.i++;
        currentCell.j = 0;
      } else {
        // finished
        running = false;
        autoplay = false;
        highlightCurrent(null);
        finishCompute();
        return;
      }
    }
    if(autoplay){
      playTimer = setTimeout(stepNext, Number(speed.value));
    }
  }

  function finishCompute(){
    // show final LCS length
    lcsLenEl.textContent = String(dp[rows][cols]);
    // show one LCS via backtracking
    const one = backtrackOne();
    oneLCSEl.textContent = one || '""';
    // mark final dp table cell
    const finalCell = tableEl.querySelector(`td[data-i="${rows}"][data-j="${cols}"]`);
    if(finalCell) finalCell.classList.add('cell-backtrack');
  }

  function backtrackOne(){
    // backtrack to get one LCS (greedy when equal)
    let i = rows, j = cols;
    const seq = [];
    // clear previous bt highlights
    tableEl.querySelectorAll('.cell-backtrack').forEach(n=>n.classList.remove('cell-backtrack'));
    while(i>0 && j>0){
      const cell = tableEl.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
      if(sB[i-1] === sA[j-1]){
        seq.push(sA[j-1]);
        if(cell) cell.classList.add('cell-backtrack','cell-match');
        i--; j--;
      } else {
        if(dp[i-1][j] >= dp[i][j-1]){ // move up if >= left (prefer up)
          if(cell) cell.classList.add('cell-backtrack');
          i--;
        } else {
          if(cell) cell.classList.add('cell-backtrack');
          j--;
        }
      }
    }
    return seq.reverse().join('');
  }

  function findAllLCS(){
    // use memoized recursion to build all LCS up to limit
    allListEl.innerHTML='';
    limitWarn.style.display='none';

    // guard: lengths too big may explode
    if(rows*cols > 2500 && dp[rows][cols] > 20){
      limitWarn.textContent = 'Warning: table is large and LCS combinatorics may explode. Results are limited.';
      limitWarn.style.display='block';
    }
    const memo = new Map();
    let count = 0;
    function key(i,j){return i+','+j;}
    function rec(i,j){
      const k = key(i,j);
      if(memo.has(k)) return memo.get(k);
      let res = new Set();
      if(i===0 || j===0){
        res.add('');
      } else if(sB[i-1] === sA[j-1]){
        const next = rec(i-1,j-1);
        for(const s of next){
          if(count >= ALL_LIMIT) break;
          res.add(s + sA[j-1]);
        }
      } else {
        if(dp[i-1][j] > dp[i][j-1]){
          res = rec(i-1,j);
        } else if(dp[i][j-1] > dp[i-1][j]){
          res = rec(i,j-1);
        } else {
          // equal: union
          const a = rec(i-1,j);
          const b = rec(i,j-1);
          for(const s of a){ if(res.size < ALL_LIMIT) res.add(s); }
          for(const s of b){ if(res.size < ALL_LIMIT) res.add(s); }
        }
      }
      // If building from above appended chars yield strings in correct order? Note: when char equal we appended char at end; that's correct since rec produced prefixes.
      memo.set(k,res);
      return res;
    }

    const results = rec(rows,cols);
    const arr = Array.from(results);
    if(arr.length > ALL_LIMIT){
      limitWarn.textContent = 'Displaying first '+ALL_LIMIT+' results (limit reached).';
      limitWarn.style.display='block';
    }
    const showArr = arr.slice(0, ALL_LIMIT);
    if(showArr.length===0){
      allListEl.innerHTML = '<div class="small-muted">No LCS (maybe empty strings).</div>';
    } else {
      allListEl.innerHTML = '';
      showArr.sort(); // lexicographic for stability
      for(const s of showArr){
        const el = document.createElement('div');
        el.textContent = s === '' ? '"" (empty)' : s;
        el.style.padding='4px 6px';
        el.style.borderBottom='1px dashed rgba(255,255,255,0.02)';
        el.style.color='#dfeefe';
        allListEl.appendChild(el);
      }
    }
  }

  // Button handlers
  computeBtn.addEventListener('click', ()=>{
    reset();
    sA = strAInput.value || '';
    sB = strBInput.value || '';
    cols = sA.length;
    rows = sB.length;
    if(cols > 80 || rows > 80){
      if(!confirm('Strings are long. Visualization will be slow/large. Continue?')) return;
    }
    createTable();
    initDP();
    // ready to step
    running = false;
    autoplay = false;
    currentCell = {i:0,j:0};
    hintEl.style.display='none';
    // If user wants auto-play, start
    // Option: start at step 0 only; require pressing Play to animate.
  });

  stepBtn.addEventListener('click', ()=>{
    if(!tableEl){
      alert('Please press "Compute DP" first.');
      return;
    }
    if(!running){
      running = true;
      autoplay = false;
      // If we've finished previously, reset to start
      if(currentCell.i===rows && currentCell.j===cols){
        currentCell = {i:0,j:0};
        initDP();
        // ensure table numeric zeros displayed
        for(let i=0;i<=rows;i++){
          for(let j=0;j<=cols;j++){
            const cell = tableEl.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
            if(cell && j>0) cell.textContent = '0';
          }
        }
      }
    }
    // execute single step
    computeStep(currentCell.i,currentCell.j);
    // advance pointer
    if(currentCell.j < cols) currentCell.j++;
    else {
      if(currentCell.i < rows){ currentCell.i++; currentCell.j = 0; }
      else { running = false; finishCompute(); return; }
    }
    running = false; // step only one
  });

  playBtn.addEventListener('click', ()=>{
    if(!tableEl){
      alert('Please press "Compute DP" first.');
      return;
    }
    if(!running || !autoplay){
      running = true;
      autoplay = true;
      // If finished previously, restart
      if(currentCell.i===rows && currentCell.j===cols){
        currentCell = {i:0,j:0};
        initDP();
        for(let i=0;i<=rows;i++){
          for(let j=0;j<=cols;j++){
            const cell = tableEl.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
            if(cell && j>0) cell.textContent = '0';
          }
        }
      }
      stepNext();
    }
  });

  pauseBtn.addEventListener('click', ()=>{
    autoplay = false;
    running = false;
    if(playTimer) clearTimeout(playTimer);
    highlightCurrent(null);
  });

  reconstructBtn.addEventListener('click', ()=>{
    if(!tableEl){
      alert('Please press "Compute DP" first.');
      return;
    }
    // If dp not fully computed, compute fully (fast) without animation
    computeDPFull();
    clearHighlights();
    const one = backtrackOne();
    lcsLenEl.textContent = String(dp[rows][cols]);
    oneLCSEl.textContent = one || '""';
  });

  allBtn.addEventListener('click', ()=>{
    if(!tableEl){
      alert('Please press "Compute DP" first.');
      return;
    }
    computeDPFull();
    findAllLCS();
  });

  function reset(){
    if(playTimer) clearTimeout(playTimer);
    autoplay = false;
    running = false;
    tableWrap.innerHTML = '';
    hintEl.style.display='block';
    tableEl = null;
    dp = [];
    lcsLenEl.textContent='-';
    oneLCSEl.textContent='-';
    allListEl.innerHTML='';
    limitWarn.style.display='none';
    dpSizeEl.textContent='0×0';
  }

  function computeDPFull(){
    // fast compute without animation to fill dp fully and update table values
    if(!tableEl) return;
    initDP();
    for(let i=0;i<=rows;i++){
      for(let j=0;j<=cols;j++){
        if(i===0 || j===0){
          dp[i][j]=0;
        } else if(sB[i-1] === sA[j-1]){
          dp[i][j] = dp[i-1][j-1] + 1;
        } else {
          dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
        }
        const cell = tableEl.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
        if(cell && j>0){
          cell.textContent = dp[i][j];
        }
      }
    }
    lcsLenEl.textContent = String(dp[rows][cols]);
  }

  // Initialize with default compute for demo
  computeBtn.click();

})(); 
</script>
</body>
</html>