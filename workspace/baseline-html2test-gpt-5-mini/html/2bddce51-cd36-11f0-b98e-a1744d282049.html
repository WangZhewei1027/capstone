<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Stack Data Structure â€” Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#06b6d4;
      --muted:#94a3b8;
      --light:#e6eef6;
      --danger:#ef4444;
      --success:#10b981;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071025 0%,var(--bg) 100%);color:var(--light)}
    .app{
      max-width:1100px;margin:28px auto;padding:22px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 6px 30px rgba(2,6,23,0.65), inset 0 1px 0 rgba(255,255,255,0.02);
      display:grid;grid-template-columns:360px 1fr;gap:20px;
    }
    header{grid-column:1/-1;display:flex;align-items:center;gap:16px;margin-bottom:6px}
    header h1{font-size:18px;margin:0}
    header p{margin:0;color:var(--muted);font-size:13px}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
    .controls{display:flex;flex-direction:column;gap:12px}
    label.small{font-size:12px;color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    input[type="text"], input[type="number"], select{
      padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--light);outline:none;
      box-shadow:inset 0 -4px 10px rgba(0,0,0,0.25);
    }
    button{
      background:linear-gradient(180deg,var(--accent),#0198a9);border:none;color:#022; padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600;
      box-shadow:0 4px 10px rgba(3,105,129,0.18);
    }
    button.ghost{
      background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--light);box-shadow:none;font-weight:600;
    }
    .muted{color:var(--muted);font-size:13px}
    .vis{
      display:flex;gap:20px;align-items:flex-start;min-height:360px;
    }
    /* Stack canvas */
    .canvas{
      flex:1;display:flex;flex-direction:column;gap:14px;
    }
    .stack-area{
      flex:1;border-radius:10px;border:1px dashed rgba(255,255,255,0.03);padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      display:flex;align-items:center;justify-content:center;position:relative;overflow:auto;
    }
    .stack-visual{
      display:flex;flex-direction:column-reverse;align-items:center;gap:8px;min-width:160px;
      transition:all .25s ease;
    }
    .stack-item{
      min-width:180px;max-width:240px;padding:12px 14px;border-radius:8px;background:linear-gradient(180deg,#092032, #07242f);
      border:1px solid rgba(255,255,255,0.03);color:var(--light);display:flex;justify-content:space-between;align-items:center;
      box-shadow: 0 6px 18px rgba(2,6,23,0.5);
      transform-origin:center; transition:transform .22s cubic-bezier(.2,.8,.2,1),opacity .22s;
    }
    .stack-item.top{
      border:1px solid rgba(6,182,212,0.22);
      box-shadow:0 10px 30px rgba(6,182,212,0.07), 0 2px 6px rgba(0,0,0,0.4);
      transform:translateY(-6px) scale(1.02);
    }
    .stack-item .val{font-weight:700}
    .meta{
      display:flex;flex-direction:column;gap:8px;min-width:220px;
    }
    .stats{display:flex;gap:12px;justify-content:space-between;margin-top:8px}
    .chip{padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02);min-width:90px;text-align:center}
    .log{height:120px;overflow:auto;padding:10px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);font-size:13px;color:var(--muted)}
    .tiny{font-size:12px;color:var(--muted)}
    .controls .actions{display:flex;gap:8px;flex-wrap:wrap}
    .btn-danger{background:linear-gradient(180deg,var(--danger),#c02626);color:white}
    .btn-success{background:linear-gradient(180deg,var(--success),#0a8a66);color:white}
    .code{
      background:rgba(0,0,0,0.15);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px;color:#dff3fb;
      max-height:220px;overflow:auto;
    }
    footer{grid-column:1/-1;margin-top:6px;color:var(--muted);font-size:12px;display:flex;justify-content:space-between;align-items:center}
    .impl-select{display:flex;gap:10px;align-items:center}
    /* linked list style */
    .linked-list{
      display:flex;flex-direction:column-reverse;gap:12px;align-items:flex-start;
    }
    .node{
      display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:linear-gradient(180deg,#08171f,#072027);
      border:1px solid rgba(255,255,255,0.03);
      min-width:240px;box-shadow:0 6px 18px rgba(0,0,0,0.45);
    }
    .node .box{padding:8px 10px;border-radius:6px;background:rgba(255,255,255,0.02);min-width:50px;text-align:center}
    .arrow{width:36px;height:10px;display:flex;align-items:center;justify-content:center}
    .arrow:after{content:"â†’";color:var(--muted)}
    .small-muted{font-size:12px;color:var(--muted)}
    .kbd{background:rgba(255,255,255,0.03);padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);font-weight:700}
    @media (max-width:880px){
      .app{grid-template-columns:1fr;max-width:920px;padding:14px}
      .meta{min-width:unset}
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Stack Data Structure Demo">
    <header>
      <div>
        <h1>Stack â€” Interactive Visualizer</h1>
        <p>Push, pop and peek values. Toggle implementations and watch a live visual representation and operation log.</p>
      </div>
    </header>

    <section class="panel controls" aria-label="Controls">
      <div class="row impl-select">
        <label class="small" for="impl">Implementation:</label>
        <select id="impl" title="Choose stack implementation">
          <option value="array">Array-backed Stack (simple)</option>
          <option value="linked">Linked-list Stack (nodes & pointers)</option>
        </select>
      </div>

      <div>
        <label class="small">Value to push</label>
        <div class="row" style="margin-top:6px">
          <input id="value" type="text" placeholder="e.g. 42 or hello" />
          <button id="pushBtn">Push</button>
          <button id="pushRandom" class="ghost">Push Random</button>
        </div>
        <div class="tiny" style="margin-top:6px">Press Enter in the input to push. Empty strings are allowed as values.</div>
      </div>

      <div>
        <label class="small">Batch / Quantity</label>
        <div class="row" style="margin-top:6px">
          <input id="count" type="number" min="1" max="50" value="1" style="width:86px" />
          <button id="bulkPush" class="ghost">Bulk Push</button>
          <button id="clearBtn" class="ghost">Clear</button>
        </div>
      </div>

      <div class="actions">
        <button id="popBtn" class="ghost">Pop</button>
        <button id="peekBtn" class="ghost">Peek</button>
        <button id="sampleBtn" class="ghost">Run Sample Ops</button>
        <button id="reverseBtn" class="ghost">Reverse Stack</button>
      </div>

      <div style="margin-top:8px" class="tiny">
        <strong>Complexities:</strong> Push: O(1) | Pop: O(1) | Peek: O(1) (amortized for array-backed)
      </div>

      <div style="margin-top:10px">
        <label class="small">Code (implementation)</label>
        <div id="codeArea" class="code" aria-hidden="false"></div>
      </div>

      <div style="margin-top:10px">
        <label class="small">Operation Log</label>
        <div id="log" class="log" aria-live="polite"></div>
      </div>
    </section>

    <section class="panel canvas" aria-label="Visualization">
      <div class="meta">
        <div class="stats">
          <div class="chip">Size: <span id="size">0</span></div>
          <div class="chip">Top: <span id="topVal">â€”</span></div>
          <div class="chip">Empty: <span id="isEmpty">true</span></div>
        </div>
        <div class="tiny" style="margin-top:6px">Implementation: <span id="implLabel" class="small-muted">Array-backed</span></div>

        <div style="margin-top:12px">
          <label class="small">Notes</label>
          <div class="tiny" style="margin-top:6px">This demo supports two implementations. Choose "linked" to see nodes and pointers. Use Reverse to invert the stack order.</div>
        </div>
      </div>

      <div class="stack-area" id="stackArea" aria-live="polite">
        <div id="stackVisual" class="stack-visual" aria-label="Stack contents" title="Stack (top at top)">
          <!-- Items will be injected here -->
        </div>
        <div style="position:absolute; left:12px; top:12px; font-size:12px; color:var(--muted)">Top â†‘</div>
      </div>

      <div style="margin-top:10px;display:flex;gap:10px;align-items:center">
        <div class="tiny">Tip: Try pushing many items then pop to see transitions.</div>
        <div style="flex:1"></div>
      </div>

    </section>

    <footer>
      <div>Built-in implementations: Array-backed & Linked-list. Visual & interactive.</div>
      <div><span class="kbd">Enter</span> to push â€¢ <span class="kbd">Ctrl+R</span> runs sample</div>
    </footer>
  </div>

  <script>
    // Stack demo JavaScript
    (function(){
      // Utilities
      function el(id){return document.getElementById(id)}
      function log(msg, kind='info'){
        const logEl = el('log');
        const time = new Date().toLocaleTimeString();
        const row = document.createElement('div');
        row.style.padding = '6px 4px';
        row.style.borderBottom = '1px dashed rgba(255,255,255,0.02)';
        row.innerHTML = '<strong style="color:var(--muted)">'+time+'</strong> â€” ' + msg;
        logEl.prepend(row);
      }

      // Array-backed stack
      class ArrayStack {
        constructor(){
          this._arr = [];
        }
        push(v){ this._arr.push(v); return this.size(); }
        pop(){ return this._arr.length? this._arr.pop() : null; }
        peek(){ return this._arr.length? this._arr[this._arr.length-1] : null; }
        size(){ return this._arr.length; }
        isEmpty(){ return this._arr.length === 0; }
        clear(){ this._arr.length = 0; }
        toArray(){ return this._arr.slice(); } // bottom->top
      }

      // Linked-list stack (singly linked, top pointer)
      class LinkedStack {
        constructor(){
          this.top = null;
          this._size = 0;
        }
        push(v){
          const node = { value: v, next: this.top };
          this.top = node;
          this._size++;
          return this.size();
        }
        pop(){
          if(!this.top) return null;
          const v = this.top.value;
          this.top = this.top.next;
          this._size--;
          return v;
        }
        peek(){ return this.top ? this.top.value : null; }
        size(){ return this._size; }
        isEmpty(){ return this._size === 0; }
        clear(){ this.top = null; this._size = 0; }
        toArray(){
          const a=[];
          let cur = this.top;
          while(cur){ a.push(cur.value); cur = cur.next; }
          return a.reverse(); // want bottom->top like array
        }
      }

      // DOM refs
      const implSelect = el('impl');
      const valueInput = el('value');
      const pushBtn = el('pushBtn');
      const pushRandom = el('pushRandom');
      const popBtn = el('popBtn');
      const peekBtn = el('peekBtn');
      const clearBtn = el('clearBtn');
      const stackVisual = el('stackVisual');
      const sizeEl = el('size');
      const topValEl = el('topVal');
      const isEmptyEl = el('isEmpty');
      const codeArea = el('codeArea');
      const bulkPush = el('bulkPush');
      const countInput = el('count');
      const sampleBtn = el('sampleBtn');
      const reverseBtn = el('reverseBtn');
      const implLabel = el('implLabel');

      // Current implementation instance
      let stack = new ArrayStack();
      let impl = 'array'; // 'array' or 'linked'
      updateCodeArea();

      // Helpers for UI
      function updateMeta(){
        sizeEl.textContent = String(stack.size());
        const pv = stack.peek();
        topValEl.textContent = (pv === null || pv === undefined) ? 'â€”' : String(pv);
        isEmptyEl.textContent = stack.isEmpty() ? 'true' : 'false';
        implLabel.textContent = impl === 'array' ? 'Array-backed' : 'Linked-list';
      }

      function render(){
        // Clear current
        stackVisual.innerHTML = '';
        // Obtain bottom->top array for consistent rendering (we render in column-reverse so last item is top)
        const arr = stack.toArray(); // bottom->top
        // If using linked implementation, render nodes + arrows
        if(impl === 'linked'){
          const container = document.createElement('div');
          container.className = 'linked-list';
          // We want to render nodes bottom->top; but linked-list top->bottom; we used reverse above to get bottom->top
          for(let i=0;i<arr.length;i++){
            const nodeWrap = document.createElement('div');
            nodeWrap.style.display='flex'; nodeWrap.style.flexDirection='row-reverse';
            const node = document.createElement('div');
            node.className='node';
            const box = document.createElement('div'); box.className='box'; box.textContent=arr[i];
            const txt = document.createElement('div'); txt.style.color='var(--light)'; txt.style.fontWeight='700'; txt.textContent='val';
            node.appendChild(box);
            // Attach pointer label to indicate next (for visualization)
            const idx = i;
            const meta = document.createElement('div');
            meta.style.fontSize='12px'; meta.style.color='var(--muted)'; meta.style.marginLeft='8px';
            // Determine if this node is the top node
            const isTop = (i === arr.length-1);
            meta.innerHTML = isTop ? '<div style="color:var(--accent);font-weight:700">TOP</div>' : '<div class="small-muted">next â†’</div>';
            node.appendChild(meta);

            // Wrap with arrow except bottom-most (since we render bottom->top, arrows point up)
            const wrapper = document.createElement('div');
            wrapper.style.display='flex'; wrapper.style.flexDirection='column'; wrapper.style.alignItems='flex-start';
            wrapper.appendChild(node);
            if(i < arr.length - 1){
              const arrow = document.createElement('div'); arrow.className='arrow'; arrow.style.marginLeft='8px';
              wrapper.appendChild(arrow);
            }
            container.appendChild(wrapper);
          }
          stackVisual.appendChild(container);
        } else {
          // array-backed: render simple blocks with index to the right
          // We render bottom->top, but our container has column-reverse, so simply render arr in order
          arr.forEach((v, idx) => {
            const item = document.createElement('div');
            item.className='stack-item';
            const valSpan = document.createElement('div'); valSpan.className='val'; valSpan.textContent = String(v);
            const idxSpan = document.createElement('div'); idxSpan.style.color='var(--muted)'; idxSpan.textContent = idx;
            item.appendChild(valSpan);
            item.appendChild(idxSpan);
            // highlight top
            if(idx === arr.length - 1){
              item.classList.add('top');
            }
            stackVisual.appendChild(item);
          });
        }

        updateMeta();
      }

      function pushAction(value){
        // Accept any JS value but store as string for rendering
        const beforeSize = stack.size();
        const newSize = stack.push(value);
        log('PUSH: "' + String(value) + '" â†’ size ' + beforeSize + ' â†’ ' + newSize);
        render();
      }

      function popAction(){
        const beforeSize = stack.size();
        const v = stack.pop();
        if(v === null || v === undefined){
          log('POP: stack empty', 'warn');
          return null;
        }
        log('POP: "' + String(v) + '" â†’ size ' + beforeSize + ' â†’ ' + stack.size());
        render();
        return v;
      }

      function peekAction(){
        const v = stack.peek();
        if(v === null || v === undefined){
          log('PEEK: stack empty', 'warn');
        } else {
          log('PEEK: "' + String(v) + '"');
        }
        updateMeta();
        return v;
      }

      function clearAction(){
        stack.clear();
        log('CLEAR: stack emptied');
        render();
      }

      function bulkPushAction(count){
        const c = Math.max(1, Math.min(200, Number(count) || 1));
        for(let i=0;i<c;i++){
          const val = valueInput.value !== '' ? valueInput.value + (c>1? ' #'+(i+1):'') : ('val-'+Math.random().toString(36).slice(2,7));
          stack.push(val);
        }
        log('BULK PUSH: ' + c + ' items');
        render();
      }

      function pushRandomAction(){
        const sample = ['ðŸŽ','42','hello','obj','true','null','âš¡','js','123','node','A','B','C','Ï€','âˆž'];
        const val = sample[Math.floor(Math.random()*sample.length)] + '-' + Math.random().toString(36).slice(2,5);
        pushAction(val);
      }

      function reverseStack(){
        // Reverse the stack order in-place by rebuilding
        const arr = stack.toArray(); // bottom->top
        arr.reverse(); // now top->bottom
        // Recreate based on implementation
        if(impl === 'array'){
          stack.clear();
          arr.forEach(v => stack.push(v));
        } else {
          // for linked, arr currently top->bottom, but LinkedStack expects top as last pushed value
          stack.clear();
          // arr is top->bottom, but to produce same order we push bottom->top
          arr.reverse(); // becomes bottom->top
          arr.forEach(v => stack.push(v));
        }
        log('REVERSE: stack order reversed');
        render();
      }

      // Implementation switch
      function switchImpl(to){
        // capture current data
        const a = stack.toArray(); // bottom->top
        impl = to;
        stack = impl === 'array' ? new ArrayStack() : new LinkedStack();
        // populate with same items
        a.forEach(v => stack.push(v));
        log('SWITCH: implementation -> ' + (impl === 'array' ? 'Array-backed' : 'Linked-list'));
        updateCodeArea();
        render();
      }

      // Update code snippet area with brief implementation code
      function updateCodeArea(){
        if(impl === 'array'){
          codeArea.textContent = [
            'class ArrayStack {',
            '  constructor(){ this._arr = []; }',
            '  push(v){ this._arr.push(v); }',
            '  pop(){ return this._arr.length ? this._arr.pop() : null; }',
            '  peek(){ return this._arr.length ? this._arr[this._arr.length-1] : null; }',
            '  size(){ return this._arr.length; }',
            '  clear(){ this._arr.length = 0 }',
            '}'
          ].join('\n');
        } else {
          codeArea.textContent = [
            'class LinkedStack {',
            '  constructor(){ this.top = null; this._size = 0; }',
            '  push(v){ const node = {value: v, next: this.top}; this.top = node; this._size++; }',
            '  pop(){ if(!this.top) return null; const v = this.top.value; this.top = this.top.next; this._size--; return v; }',
            '  peek(){ return this.top ? this.top.value : null }',
            '  size(){ return this._size }',
            '  clear(){ this.top = null; this._size = 0 }',
            '}'
          ].join('\n');
        }
      }

      // Wire UI events
      pushBtn.addEventListener('click', () => {
        const v = valueInput.value;
        pushAction(v === '' ? '' : v);
        valueInput.focus();
        valueInput.select();
      });

      valueInput.addEventListener('keydown', (e) => {
        if(e.key === 'Enter'){
          e.preventDefault();
          pushBtn.click();
        }
      });

      pushRandom.addEventListener('click', pushRandomAction);

      popBtn.addEventListener('click', popAction);
      peekBtn.addEventListener('click', peekAction);
      clearBtn.addEventListener('click', clearAction);

      implSelect.addEventListener('change', (e) => {
        switchImpl(e.target.value);
      });

      bulkPush.addEventListener('click', () => {
        bulkPushAction(countInput.value);
      });

      sampleBtn.addEventListener('click', async () => {
        // sample sequence: push 3, peek, pop, push 2, reverse
        const seq = ['push:Alice','push:Bob','push:Charlie','peek','pop','push:Delta','push:Echo','reverse','peek'];
        log('SAMPLE: running demo sequence (Ctrl+R also triggers)');
        for(const step of seq){
          await new Promise(r => setTimeout(r, 480));
          if(step.startsWith('push:')) pushAction(step.split(':')[1]);
          else if(step === 'pop') popAction();
          else if(step === 'peek') peekAction();
          else if(step === 'reverse') reverseStack();
        }
        log('SAMPLE: done');
      });

      reverseBtn.addEventListener('click', reverseStack);

      // keyboard shortcut for sample: Ctrl+R
      window.addEventListener('keydown', (e) => {
        if(e.ctrlKey && (e.key === 'r' || e.key === 'R')){
          e.preventDefault();
          sampleBtn.click();
        }
      });

      // Initialize with a few items
      ['A','B','C'].forEach(v => stack.push(v));
      render();
      log('Initialized with A, B, C');

      // Expose some debug on window for interactive consoles (optional)
      window.__stack_demo = {
        get stack(){ return stack; },
        push: (v)=>{ pushAction(v); },
        pop: ()=>popAction(),
        peek: ()=>peekAction(),
        switchImpl: (s) => switchImpl(s)
      };

    })();
  </script>
</body>
</html>