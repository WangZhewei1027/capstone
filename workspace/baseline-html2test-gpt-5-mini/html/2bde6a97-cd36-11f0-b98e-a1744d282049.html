<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Recursion Explorer — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --accent:#60a5fa; --muted:#94a3b8; --panel:#071226;
      --good:#34d399; --bad:#fb7185;
    }
    body{
      margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      background:linear-gradient(180deg,#071029 0%,#071127 50%, #071122 100%);
      color:#e6eef8; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    header{
      padding:18px 20px; display:flex; gap:16px; align-items:center; background:linear-gradient(90deg,#07102988,#07112522);
      border-bottom:1px solid rgba(255,255,255,0.03);
    }
    h1{ font-size:18px; margin:0; letter-spacing:0.2px; color:var(--accent) }
    .subtitle{ color:var(--muted); font-size:13px; margin-left:8px }
    main{ display:grid; grid-template-columns:380px 1fr 420px; gap:18px; padding:18px; height:calc(100vh - 72px); box-sizing:border-box; }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px; padding:14px; box-shadow: 0 6px 24px rgba(2,6,23,0.5); border:1px solid rgba(255,255,255,0.02);
      height:100%; overflow:auto;
    }
    label{ display:block; font-size:13px; color:var(--muted); margin-bottom:6px }
    input[type=number], select, button{
      background:transparent; border:1px solid rgba(255,255,255,0.06); color:inherit; padding:8px 10px; border-radius:8px;
      outline:none; font-size:14px;
    }
    .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .controls > *{ flex-shrink:0 }
    button.primary{ background:linear-gradient(90deg,var(--accent),#7dd3fc); color:#04202f; border:none; font-weight:600; cursor:pointer }
    button.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted); cursor:pointer }
    .muted{ color:var(--muted); font-size:13px }
    .stack{
      margin-top:12px; display:flex; flex-direction:column; gap:8px; min-height:280px;
    }
    .frame{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:8px; padding:8px 10px; border:1px solid rgba(255,255,255,0.03); display:flex; justify-content:space-between; align-items:center;
      font-family:Menlo,monospace; font-size:13px;
    }
    .frame.return{ border-left:4px solid var(--good) }
    .frame.call{ border-left:4px solid var(--accent) }
    .frame .info{ display:flex; gap:8px; align-items:center }
    .small{ font-size:12px; color:var(--muted) }
    .panel-title{ font-weight:700; margin-bottom:8px }
    /* Canvas area */
    #canvasWrap{ display:flex; flex-direction:column; height:100%; }
    canvas{ background:linear-gradient(180deg,#051122,#021018); border-radius:10px; width:100%; height:100%; display:block }
    .row{ display:flex; gap:8px; align-items:center; margin-top:10px; flex-wrap:wrap }
    .stats{ font-size:13px; color:var(--muted) }
    footer{ padding:12px 18px; color:var(--muted); text-align:center; font-size:13px }
    a{ color:var(--accent) }
    .danger{ color:var(--bad) }
    .good{ color:var(--good) }
    .explain{ font-size:13px; color:var(--muted); line-height:1.45; margin-top:8px }
    .slider{ appearance:none; width:160px; height:8px; background:linear-gradient(90deg,#164e8a,#173956); border-radius:999px; }
    .cta-row{ display:flex; gap:8px; margin-top:10px; align-items:center }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Recursion Explorer</h1>
      <div class="subtitle">Visualize and step through recursive calls</div>
    </div>
  </header>

  <main>
    <!-- Left: Controls & Examples -->
    <section class="card" style="min-width:300px;">
      <div class="panel-title">Choose Example</div>
      <div style="display:flex; gap:8px; margin-bottom:12px;">
        <select id="exampleSelect" style="flex:1">
          <option value="factorial">Factorial (n!) — classic recursion</option>
          <option value="fibonacci">Fibonacci (naive) — exponential calls</option>
          <option value="fibonacciMemo">Fibonacci (memoized) — optimized recursion</option>
          <option value="tree">Simulated Tree Traversal (preorder)</option>
          <option value="fractal">Fractal Tree (visual)</option>
        </select>
      </div>

      <div id="controlsArea">
        <label>Input / Depth</label>
        <div class="controls">
          <input id="inputN" type="number" value="5" min="0" max="20" />
          <button id="runBtn" class="primary">Run</button>
          <button id="traceBtn" class="ghost">Generate Trace</button>
        </div>

        <div class="cta-row">
          <button id="stepPrev" class="ghost">◀ Step</button>
          <button id="stepNext" class="ghost">Step ▶</button>
          <button id="playPause" class="ghost">Play ▶</button>
          <div class="muted" id="stepInfo">Step 0 / 0</div>
        </div>

        <div style="margin-top:12px;">
          <div class="muted">Short explanation</div>
          <div class="explain" id="explainText">
            Recursion is when a function calls itself. Each call gets its own "frame" (local variables and state). Visualizing the call stack helps understand execution order and returns.
          </div>
        </div>

        <div style="margin-top:12px;">
          <div class="muted">Notes</div>
          <ul class="small" style="margin:8px 0 0 16px; color:var(--muted)">
            <li>Naive Fibonacci grows fast; limits are enforced to avoid freezing.</li>
            <li>Use memoization to drastically reduce calls.</li>
            <li>Fractal drawing uses canvas and recursion to draw branches.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Middle: Stack Visualization -->
    <section class="card" id="stackCard">
      <div class="panel-title">Call Stack Visualization</div>
      <div class="muted">Frames are pushed on call and popped on return. A return frame shows the resolved value.</div>

      <div class="stack" id="stackArea" style="margin-top:12px;">
        <!-- frames appear here -->
      </div>

      <div style="margin-top:12px; display:flex; gap:8px; align-items:center; justify-content:space-between;">
        <div class="stats" id="statsArea">Calls: 0 &nbsp; • &nbsp; Max depth: 0</div>
        <div style="display:flex; gap:8px;">
          <button id="resetBtn" class="ghost">Reset</button>
          <button id="explainBtn" class="ghost">Show explanation</button>
        </div>
      </div>

      <div style="margin-top:12px;">
        <div class="muted">Trace (events)</div>
        <pre id="traceOutput" style="background:transparent; border-radius:8px; padding:8px; height:120px; overflow:auto; color:var(--muted); font-size:13px"></pre>
      </div>
    </section>

    <!-- Right: Canvas / Fractal / Info -->
    <section class="card" id="canvasCard">
      <div class="panel-title" id="canvasTitle">Visualization</div>

      <div id="canvasWrap">
        <canvas id="canvas" width="800" height="600"></canvas>

        <div class="row" style="justify-content:space-between;">
          <div>
            <label class="small">Depth / Size</label>
            <input id="depthSlider" type="range" class="slider" min="0" max="12" value="5" />
            <span class="muted" id="depthLabel">5</span>
          </div>

          <div style="text-align:right">
            <div class="small muted">Performance</div>
            <div id="perf" class="muted">—</div>
          </div>
        </div>

        <div style="margin-top:8px; display:flex; gap:8px;">
          <button id="drawBtn" class="primary">Redraw</button>
          <button id="clearBtn" class="ghost">Clear</button>
        </div>
      </div>
    </section>
  </main>

  <footer>
    Built to demonstrate recursion: call stacks, exponential vs memoized recursion, and a visual fractal tree. Source is client-side in this page.
  </footer>

  <script>
    // Recursion Explorer JS
    (function(){
      // Utilities
      function el(id){ return document.getElementById(id); }
      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
      const maxNaiveFib = 11; // safe limit for naive fib (exponential)
      const maxFactorial = 12; // avoid huge numbers and deep stacks
      const canvas = el('canvas');
      const ctx = canvas.getContext('2d');
      let trace = []; // sequence of events for stepping
      let currentStep = 0;
      let playTimer = null;

      // UI elements
      const exampleSelect = el('exampleSelect');
      const inputN = el('inputN');
      const runBtn = el('runBtn');
      const traceBtn = el('traceBtn');
      const stepPrev = el('stepPrev');
      const stepNext = el('stepNext');
      const playPause = el('playPause');
      const resetBtn = el('resetBtn');
      const traceOutput = el('traceOutput');
      const stackArea = el('stackArea');
      const statsArea = el('statsArea');
      const explainBtn = el('explainBtn');
      const explainText = el('explainText');
      const depthSlider = el('depthSlider');
      const depthLabel = el('depthLabel');
      const drawBtn = el('drawBtn');
      const clearBtn = el('clearBtn');
      const canvasTitle = el('canvasTitle');
      const perf = el('perf');

      // Event helpers
      function setExplain(text){
        explainText.textContent = text;
      }
      function setStats(calls, maxDepth){
        statsArea.textContent = `Calls: ${calls} • Max depth: ${maxDepth}`;
      }

      // Trace event model:
      // events: {type:'call'|'return', id, fn, args, depth, value?}
      let idCounter = 1;

      function newId(){ return idCounter++; }

      // Generate trace for factorial
      function generateFactorialTrace(n){
        trace = []; idCounter = 1;
        let maxDepth = 0, callCount = 0;
        function fact(k, depth){
          callCount++;
          maxDepth = Math.max(maxDepth, depth);
          const id = newId();
          trace.push({type:'call', id, fn:'fact', args:[k], depth});
          if(k === 0 || k === 1){
            trace.push({type:'return', id, fn:'fact', args:[k], depth, value:1});
            return 1;
          }
          const r = fact(k-1, depth+1) * k;
          trace.push({type:'return', id, fn:'fact', args:[k], depth, value:r});
          return r;
        }
        const value = fact(n, 0);
        return {trace, callCount, maxDepth, value};
      }

      // Generate naive fibonacci trace (exponential)
      function generateFibonacciTrace(n, memoized=false){
        trace = []; idCounter = 1;
        let maxDepth = 0, callCount = 0;
        const memo = {};
        function fib(k, depth){
          callCount++;
          maxDepth = Math.max(maxDepth, depth);
          const id = newId();
          trace.push({type:'call', id, fn:'fib', args:[k], depth});
          if(memoized && memo[k] !== undefined){
            const v = memo[k];
            trace.push({type:'return', id, fn:'fib', args:[k], depth, value:v, memoHit:true});
            return v;
          }
          if(k < 2){
            trace.push({type:'return', id, fn:'fib', args:[k], depth, value:k});
            memo[k] = k;
            return k;
          }
          const a = fib(k-1, depth+1);
          const b = fib(k-2, depth+1);
          const v = a + b;
          memo[k] = v;
          trace.push({type:'return', id, fn:'fib', args:[k], depth, value:v});
          return v;
        }
        const value = fib(n, 0);
        return {trace, callCount, maxDepth, value};
      }

      // Simulated tree traversal trace (preorder)
      function generateTreeTrace(depth, children=3){
        trace = []; idCounter = 1;
        let callCount = 0, maxDepth = 0;
        function visit(nodeId, d, depthLeft){
          callCount++;
          maxDepth = Math.max(maxDepth, d);
          const id = newId();
          trace.push({type:'call', id, fn:'visit', args:[nodeId], depth:d});
          // simulate work
          trace.push({type:'return', id, fn:'visit', args:[nodeId], depth:d, value:`visited ${nodeId}`});
          if(depthLeft <= 0) return;
          for(let i=0;i<children;i++){
            visit(nodeId + '.' + i, d+1, depthLeft-1);
          }
        }
        visit('root', 0, depth);
        return {trace, callCount, maxDepth, value: 'done'};
      }

      // UI: prepare the trace for stepping and visualization
      function prepareTraceForExample(example, n){
        if(example === 'factorial'){
          n = clamp(n, 0, maxFactorial);
          setExplain('Factorial: fact(n) calls fact(n-1) until 0 or 1. Observe call stack depth and returns.');
          return generateFactorialTrace(n);
        }
        if(example === 'fibonacci'){
          n = clamp(n, 0, maxNaiveFib);
          setExplain('Naive Fibonacci: fib(n) calls fib(n-1) and fib(n-2). Number of calls grows exponentially with n.');
          return generateFibonacciTrace(n, false);
        }
        if(example === 'fibonacciMemo'){
          n = clamp(n, 0, 40);
          setExplain('Memoized Fibonacci: results cached to avoid repeating work — drastically fewer calls.');
          return generateFibonacciTrace(n, true);
        }
        if(example === 'tree'){
          const depth = clamp(n, 0, 6);
          setExplain('Simulated tree traversal: visit a node and recursively visit children (preorder).');
          return generateTreeTrace(depth, 3);
        }
        if(example === 'fractal'){
          setExplain('Fractal Tree: draws branches recursively. Use the depth slider and redraw.');
          return {trace:[], callCount:0, maxDepth:0, value:null};
        }
        return {trace:[], callCount:0, maxDepth:0, value:null};
      }

      // Rendering stack for a given step index
      function renderStep(stepIndex){
        stackArea.innerHTML = '';
        if(!trace || trace.length === 0){
          traceOutput.textContent = '(no trace)';
          currentStep = 0;
          el('stepInfo').textContent = 'Step 0 / 0';
          setStats(0,0);
          return;
        }
        // Build the stack by processing events up to stepIndex (inclusive)
        const stack = [];
        let calls = 0;
        let maxDepth = 0;
        for(let i=0;i<=stepIndex && i<trace.length;i++){
          const ev = trace[i];
          if(ev.type === 'call'){
            stack.push({id:ev.id, fn:ev.fn, args:ev.args, depth:ev.depth, status:'call'});
            calls++;
            maxDepth = Math.max(maxDepth, stack.length);
          } else if(ev.type === 'return'){
            // find top matching call by id and mark it returned with value
            // it's possible multiple return events happen for same id in our model; handle gracefully
            let idx = -1;
            for(let j=stack.length-1;j>=0;j--){
              if(stack[j].id === ev.id && stack[j].status === 'call'){ idx = j; break; }
            }
            if(idx !== -1){
              stack[idx].status = 'return';
              stack[idx].value = ev.value;
            } else {
              // If not found, the return pertains to something popped earlier; ignore
            }
          }
        }
        // Render stack top at the top of the column (like real stack)
        for(let i=stack.length-1;i>=0;i--){
          const s = stack[i];
          const d = document.createElement('div');
          d.className = 'frame ' + (s.status === 'return' ? 'return' : 'call');
          const info = document.createElement('div');
          info.className = 'info';
          const fnSpan = document.createElement('div');
          fnSpan.textContent = s.fn + '(' + s.args.join(',') + ')';
          const depthSpan = document.createElement('div');
          depthSpan.className = 'small';
          depthSpan.textContent = 'depth ' + s.depth;
          info.appendChild(fnSpan);
          info.appendChild(depthSpan);
          const right = document.createElement('div');
          right.style.textAlign = 'right';
          if(s.status === 'return'){
            const val = document.createElement('div');
            val.style.fontFamily = 'Menlo,monospace';
            val.textContent = '→ ' + s.value;
            val.className = 'small';
            right.appendChild(val);
          } else {
            const wait = document.createElement('div');
            wait.className = 'small muted';
            wait.textContent = 'running';
            right.appendChild(wait);
          }
          d.appendChild(info);
          d.appendChild(right);
          stackArea.appendChild(d);
        }

        // Trace output: show events up to step
        traceOutput.textContent = trace.slice(0, stepIndex+1).map((e,i)=> {
          if(e.type==='call') return `${i}: CALL  id=${e.id} ${e.fn}(${e.args.join(',')}) depth=${e.depth}`;
          else return `${i}: RETURN id=${e.id} ${e.fn}(${e.args.join(',')}) depth=${e.depth} => ${JSON.stringify(e.value)}` + (e.memoHit ? ' (memo)' : '');
        }).join('\n');

        currentStep = stepIndex;
        el('stepInfo').textContent = `Step ${currentStep+1} / ${trace.length}`;
        setStats(trace.length/2 | 0, maxDepth); // rough calls; not exact for all traces
      }

      // Step controls
      function stepNextFunc(){
        if(!trace || trace.length===0) return;
        const next = Math.min(trace.length-1, currentStep+1);
        renderStep(next);
      }
      function stepPrevFunc(){
        if(!trace || trace.length===0) return;
        const prev = Math.max(0, currentStep-1);
        renderStep(prev);
      }
      function playToggle(){
        if(playTimer){
          clearInterval(playTimer); playTimer = null; playPause.textContent = 'Play ▶';
        } else {
          playPause.textContent = 'Pause ⏸';
          playTimer = setInterval(()=>{
            if(!trace || currentStep >= trace.length-1){
              clearInterval(playTimer); playTimer = null; playPause.textContent = 'Play ▶'; return;
            }
            stepNextFunc();
          }, 250);
        }
      }

      // Run the selected example and generate trace + show final result
      function runExample(){
        stopPlay();
        const ex = exampleSelect.value;
        const n = parseInt(inputN.value,10) || 0;

        if(ex === 'fractal'){
          // just draw fractal
          canvasTitle.textContent = 'Fractal Tree';
          drawFractal(parseInt(depthSlider.value,10));
          trace = [];
          renderStep(0);
          return;
        }

        const result = prepareTraceForExample(ex, n);
        trace = result.trace || [];
        // show stats
        maintainLimits(ex, n);
        renderStep(0);
      }

      function stopPlay(){
        if(playTimer){ clearInterval(playTimer); playTimer = null; playPause.textContent = 'Play ▶'; }
      }

      function maintainLimits(example, n){
        if(example === 'fibonacci' && n > maxNaiveFib){
          alert('Naive Fibonacci is limited to n ≤ ' + maxNaiveFib + ' to avoid freezing. Using ' + maxNaiveFib + '.');
          inputN.value = maxNaiveFib;
        }
        if(example === 'factorial' && n > maxFactorial){
          alert('Factorial depth limited to ' + maxFactorial + '. Using ' + maxFactorial + '.');
          inputN.value = maxFactorial;
        }
      }

      // Trace generation button (just regenerates and shows)
      traceBtn.addEventListener('click', ()=>{
        runExample();
      });

      runBtn.addEventListener('click', ()=>{
        runExample();
      });

      stepNext.addEventListener('click', stepNextFunc);
      stepPrev.addEventListener('click', stepPrevFunc);
      playPause.addEventListener('click', playToggle);
      resetBtn.addEventListener('click', ()=>{
        stopPlay();
        trace = []; currentStep = 0;
        stackArea.innerHTML = '';
        traceOutput.textContent = '';
        el('stepInfo').textContent = 'Step 0 / 0';
        setStats(0,0);
      });

      // Switch UI for example changes
      exampleSelect.addEventListener('change', ()=>{
        const ex = exampleSelect.value;
        if(ex === 'fractal'){
          inputN.disabled = true;
          depthSlider.disabled = false;
          canvasTitle.textContent = 'Fractal Tree';
          setExplain('Fractal Tree drawing: recursive branching using angle & length multiplier.');
        } else if(ex === 'tree'){
          inputN.disabled = false;
          inputN.value = 3;
          depthSlider.disabled = true;
          canvasTitle.textContent = 'Call Stack';
        } else {
          depthSlider.disabled = true;
          inputN.disabled = false;
          canvasTitle.textContent = 'Call Stack';
        }
      });

      explainBtn.addEventListener('click', ()=>{
        alert(explainText.textContent);
      });

      // Depth slider for fractal
      depthSlider.addEventListener('input', ()=>{
        depthLabel.textContent = depthSlider.value;
      });

      // Canvas drawing: fractal tree
      function clearCanvas(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = 'rgba(5,12,20,0.0)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        perf.textContent = 'cleared';
      }

      function drawFractal(depth){
        clearCanvas();
        const t0 = performance.now();
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height-20);
        ctx.strokeStyle = '#8ed0ff';
        ctx.lineWidth = 2;
        // recursive draw function
        function branch(len, angle, depthLeft){
          ctx.save();
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.moveTo(0,0);
          ctx.lineTo(0,-len);
          ctx.stroke();
          ctx.translate(0,-len);
          if(depthLeft <= 0){
            // draw leaf
            ctx.fillStyle = '#60a5fa33';
            ctx.beginPath();
            ctx.arc(0,0,2.5,0,Math.PI*2);
            ctx.fill();
          } else {
            const factor = 0.72 - (depthLeft*0.02);
            const spread = 0.6;
            branch(len * factor, -spread, depthLeft-1);
            branch(len * factor, spread, depthLeft-1);
            // optional middle branch
            if(depthLeft > 2) branch(len * factor*0.75, 0, depthLeft-1);
          }
          ctx.restore();
        }
        branch(Math.min(160, canvas.height/3), 0, depth|0);
        ctx.restore();
        const t1 = performance.now();
        perf.textContent = `drawn in ${(t1-t0).toFixed(1)} ms`;
      }

      drawBtn.addEventListener('click', ()=> {
        drawFractal(parseInt(depthSlider.value,10));
      });
      clearBtn.addEventListener('click', clearCanvas);

      // Initialize canvas size to element size for crispness
      function resizeCanvas(){
        // Keep devicePixelRatio for sharper drawing
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(300, Math.round(rect.width * dpr));
        canvas.height = Math.max(200, Math.round(rect.height * dpr));
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        ctx.setTransform(dpr,0,0,dpr,0,0);
        clearCanvas();
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      // Initialize default state
      exampleSelect.dispatchEvent(new Event('change'));
      drawFractal(parseInt(depthSlider.value,10));

      // Keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if(e.key === 'ArrowRight') stepNextFunc();
        if(e.key === 'ArrowLeft') stepPrevFunc();
        if(e.key === ' ') { e.preventDefault(); playToggle(); }
      });

      // Basic palette explanation
      setExplain('Recursion is when a function calls itself. Use the examples to see how calls are stacked and how values are returned.');

      // Ensure initial trace area shows nothing
      traceOutput.textContent = '(no trace)';

      // Accessibility: hint
      console.log('Recursion Explorer ready. Use the UI to generate and step through traces.');
    })();
  </script>
</body>
</html>