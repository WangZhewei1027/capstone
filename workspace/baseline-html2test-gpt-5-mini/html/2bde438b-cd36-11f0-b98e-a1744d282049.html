<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Linear Search Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --muted:#9aa7c0;
      --accent:#3b82f6;
      --success:#10b981;
      --danger:#ef4444;
      --card:#0f1724;
      --glass: rgba(255,255,255,0.03);
      --glass-2: rgba(255,255,255,0.02);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071127 0%, #071323 60%, #05131f 100%);
      color:#dbe7fb;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .wrap{
      max-width:1100px;
      margin:28px auto;
      padding:20px;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:20px;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
      border: 1px solid rgba(255,255,255,0.03);
    }
    h1{
      margin:6px 0 12px;
      font-size:20px;
      letter-spacing:0.2px;
      color:#e6f0ff;
    }
    .controls label{display:block; font-size:13px; color:var(--muted); margin-bottom:8px;}
    .control-row{display:flex; gap:8px; align-items:center; margin-bottom:12px;}
    input[type="range"]{width:100%;}
    input[type="text"], input[type="number"], select{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      padding:8px 10px;
      color:inherit;
      border-radius:8px;
      outline:none;
    }
    .buttons{display:flex; gap:8px; flex-wrap:wrap;}
    button{
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.04);
      color:inherit;
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
    }
    button.primary{
      background:linear-gradient(90deg,var(--accent),#60a5fa);
      color: #04203b;
      font-weight:600;
      border: none;
    }
    .array-area{
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:220px;
      padding:18px;
      gap:12px;
      overflow:auto;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008));
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .cell{
      min-width:56px;
      height:56px;
      display:flex;
      align-items:center;
      justify-content:center;
      background:var(--glass-2);
      border-radius:8px;
      font-weight:700;
      font-size:16px;
      position:relative;
      border: 1px solid rgba(255,255,255,0.03);
      transition:transform 180ms ease, box-shadow 180ms ease, background 180ms ease;
      color:#dff4ff;
    }
    .cell.index::after{
      content: attr(data-index);
      position:absolute;
      bottom:-18px;
      left:50%;
      transform:translateX(-50%);
      font-size:12px;
      color:var(--muted);
    }
    .cell.checking{
      background: linear-gradient(180deg, rgba(59,130,246,0.12), rgba(59,130,246,0.06));
      box-shadow: 0 6px 18px rgba(59,130,246,0.08);
      transform:translateY(-6px) scale(1.03);
      color: #cfe9ff;
    }
    .cell.found{
      background: linear-gradient(180deg, rgba(16,185,129,0.12), rgba(16,185,129,0.06));
      box-shadow: 0 8px 26px rgba(16,185,129,0.08);
      transform:translateY(-6px) scale(1.04);
      color:#e9fff2;
    }
    .cell.miss{
      background: linear-gradient(180deg, rgba(239,68,68,0.06), rgba(239,68,68,0.02));
      color:#ffdfe0;
    }
    .status{
      margin-top:12px;
      font-size:14px;
      color:var(--muted);
    }
    .stats{display:flex; gap:12px; margin-top:10px; flex-wrap:wrap;}
    .stat{
      background:rgba(255,255,255,0.02);
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.01);
    }
    .pseudocode{
      margin-top:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008));
      padding:12px;
      border-radius:8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
      font-size:13px;
      color:#cfe8ff;
      border:1px solid rgba(255,255,255,0.02);
    }
    .line{padding:6px; border-radius:6px;}
    .line.active{ background: rgba(255,255,255,0.02); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);}
    .explain{font-size:13px; color:var(--muted); margin-top:8px;}
    footer{grid-column:1/-1; text-align:center; margin-top:18px; color:var(--muted); font-size:13px;}
    @media (max-width:980px){
      .wrap{grid-template-columns: 1fr; padding:12px;}
    }
  </style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Linear search visualizer">
    <div class="panel controls" aria-labelledby="title">
      <h1 id="title">Linear Search Visualizer</h1>
      <p class="explain">Linear search checks each element in order until it finds the target or reaches the end. Use the controls below to create an array and step through the algorithm.</p>

      <div style="margin-top:10px;">
        <label for="size">Array size: <span id="sizeVal">8</span></label>
        <input id="size" type="range" min="3" max="20" value="8" />
      </div>

      <div style="margin-top:10px;">
        <label for="range">Random values range</label>
        <div class="control-row">
          <input id="minVal" type="number" value="0" style="width:76px" aria-label="minimum value" />
          <input id="maxVal" type="number" value="20" style="width:76px" aria-label="maximum value" />
          <button id="genRandom">Generate Random</button>
          <button id="shuffle">Shuffle</button>
        </div>
      </div>

      <div style="margin-top:10px;">
        <label for="custom">Or enter custom array (comma separated)</label>
        <div class="control-row">
          <input id="custom" type="text" placeholder="e.g. 5,3,8,1" aria-label="custom array input" />
          <button id="applyCustom">Apply</button>
        </div>
      </div>

      <div style="margin-top:10px;">
        <label for="target">Target value</label>
        <div class="control-row">
          <input id="target" type="text" value="10" aria-label="target value" />
          <button id="start" class="primary" aria-pressed="false">Start Search</button>
        </div>
      </div>

      <div style="margin-top:10px;">
        <label>Playback</label>
        <div class="control-row">
          <div class="buttons" role="group" aria-label="playback controls">
            <button id="prev" title="Previous step">◀ Prev</button>
            <button id="play" title="Play/Pause">▶ Play</button>
            <button id="next" title="Next step">Next ▶</button>
            <button id="reset">Reset</button>
          </div>
        </div>
        <label for="speed">Speed (ms per step): <span id="speedVal">600</span></label>
        <input id="speed" type="range" min="100" max="1500" step="50" value="600" />
      </div>

      <div class="stats" aria-hidden="false" style="margin-top:12px;">
        <div class="stat">Comparisons: <span id="comparisons">0</span></div>
        <div class="stat">Current index: <span id="currentIdx">-</span></div>
        <div class="stat">Result: <span id="result">Not started</span></div>
      </div>

      <div class="pseudocode" aria-hidden="false">
        <div class="line" data-line="0">function linearSearch(arr, target):</div>
        <div class="line" data-line="1">  for i from 0 to arr.length - 1:</div>
        <div class="line" data-line="2">    if arr[i] == target:</div>
        <div class="line" data-line="3">      return i  // found</div>
        <div class="line" data-line="4">  return -1  // not found</div>
      </div>

      <div class="status" aria-live="polite" id="status">Ready. Generate an array and press "Start Search".</div>
    </div>

    <div class="panel" aria-hidden="false">
      <h1 style="font-size:16px; margin-bottom:10px;">Array</h1>
      <div class="array-area" id="arrayArea" aria-live="polite" aria-atomic="true"></div>

      <div class="status" id="explain" style="margin-top:8px;">
        This visual shows which element is checked each step. Green means found, blue means currently checking, red shows a checked element that didn't match.
      </div>
    </div>

    <footer>
      Tip: Linear search is simple and works on unsorted data but is O(n) time complexity. Try searching for a value that is not present to see worst-case behavior.
    </footer>
  </div>

  <script>
    (function(){
      // Elements
      const sizeSlider = document.getElementById('size');
      const sizeVal = document.getElementById('sizeVal');
      const genRandom = document.getElementById('genRandom');
      const shuffleBtn = document.getElementById('shuffle');
      const minValInput = document.getElementById('minVal');
      const maxValInput = document.getElementById('maxVal');
      const customInput = document.getElementById('custom');
      const applyCustom = document.getElementById('applyCustom');
      const targetInput = document.getElementById('target');
      const startBtn = document.getElementById('start');
      const arrayArea = document.getElementById('arrayArea');
      const comparisonsEl = document.getElementById('comparisons');
      const currentIdxEl = document.getElementById('currentIdx');
      const resultEl = document.getElementById('result');
      const statusEl = document.getElementById('status');
      const prevBtn = document.getElementById('prev');
      const nextBtn = document.getElementById('next');
      const playBtn = document.getElementById('play');
      const resetBtn = document.getElementById('reset');
      const speed = document.getElementById('speed');
      const speedVal = document.getElementById('speedVal');
      const pseudocodeLines = document.querySelectorAll('.pseudocode .line');

      // State
      let arr = [];
      let snapshots = []; // history of states for stepping backward
      let stepPointer = -1; // index into snapshots
      let playing = false;
      let timer = null;

      // Helpers
      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
      function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
      function parseCustom(str){
        if(!str.trim()) return null;
        const items = str.split(',').map(s=>s.trim());
        const parsed = [];
        for(const it of items){
          if(it === '') continue;
          const n = Number(it);
          parsed.push(isNaN(n) ? it : n);
        }
        return parsed.length ? parsed : null;
      }

      function renderArray(stateIndex = null){
        // if stateIndex provided, render snapshot
        arrayArea.innerHTML = '';
        let toRender;
        if(stateIndex === null || stepPointer < 0) {
          toRender = {arr: arr.slice(), current: null, checked: [], foundIndex: null, comparisons:0};
        } else {
          toRender = snapshots[stateIndex];
        }

        toRender.arr.forEach((v,i)=>{
          const div = document.createElement('div');
          div.className = 'cell index';
          div.setAttribute('data-index', i);
          div.textContent = v;
          // apply classes
          if(toRender.foundIndex === i){
            div.classList.add('found');
          } else if(toRender.current === i){
            div.classList.add('checking');
          } else if(toRender.checked && toRender.checked.includes(i)){
            div.classList.add('miss');
          }
          arrayArea.appendChild(div);
        });

        comparisonsEl.textContent = toRender.comparisons;
        currentIdxEl.textContent = (toRender.current === null ? '-' : toRender.current);
        if(toRender.foundIndex !== null){
          resultEl.textContent = `Found at index ${toRender.foundIndex}`;
        } else if (stepPointer >= 0 && toRender.current === null && toRender.checked && toRender.checked.length === toRender.arr.length){
          resultEl.textContent = 'Not found';
        } else {
          resultEl.textContent = (stepPointer === -1 ? 'Not started' : 'Searching...');
        }
      }

      function setStatus(text){
        statusEl.textContent = text;
      }

      function highlightPseudocode(lineIndex){
        pseudocodeLines.forEach(el=>el.classList.remove('active'));
        if(lineIndex !== null && pseudocodeLines[lineIndex]){
          pseudocodeLines[lineIndex].classList.add('active');
        }
      }

      function resetSnapshots(){
        snapshots = [];
        stepPointer = -1;
        playing = false;
        clearInterval(timer);
        timer = null;
        playBtn.textContent = '▶ Play';
        playBtn.setAttribute('aria-pressed','false');
      }

      function recordSnapshot(snapshot){
        // push snapshot and move pointer to end
        snapshots.push(JSON.parse(JSON.stringify(snapshot)));
        stepPointer = snapshots.length - 1;
      }

      // Core linear search stepping generator
      function startSearch(){
        resetSnapshots();
        const targetRaw = targetInput.value.trim();
        if(targetRaw === ''){
          setStatus('Enter a target value first.');
          return;
        }
        const targetNum = Number(targetRaw);
        const target = isNaN(targetNum) ? targetRaw : targetNum;

        // initial snapshot
        const base = {arr: arr.slice(), current: null, checked: [], foundIndex: null, comparisons: 0, target: target};
        recordSnapshot(base);
        renderArray(stepPointer);
        setStatus('Starting linear search for "'+target+'".');
        highlightPseudocode(0);
      }

      function stepNext(){
        if(stepPointer === -1) {
          // not started
          setStatus('Press "Start Search" first.');
          return;
        }
        const current = snapshots[stepPointer];
        // if already found or finished, nothing to do
        if(current.foundIndex !== null){
          setStatus('Search already found the target.');
          return;
        }
        if(current.checked.length === current.arr.length){
          // finished not found
          const done = {arr: current.arr.slice(), current: null, checked: current.checked.slice(), foundIndex: null, comparisons: current.comparisons, target: current.target};
          recordSnapshot(done);
          renderArray(stepPointer);
          highlightPseudocode(4);
          setStatus('Target not found after checking all elements.');
          return;
        }

        // next index to check
        let nextIdx = 0;
        while(current.checked.includes(nextIdx)) nextIdx++;
        // create snapshot for "checking this index"
        const checking = {
          arr: current.arr.slice(),
          current: nextIdx,
          checked: current.checked.slice(),
          foundIndex: null,
          comparisons: current.comparisons,
          target: current.target
        };
        recordSnapshot(checking);
        renderArray(stepPointer);
        highlightPseudocode(1);
        setStatus(`Checking index ${nextIdx}...`);

        // perform comparison after a tiny delay to allow UI to show "checking" state
        // Instead of setTimeout, we'll create the next snapshot immediately on the next call or via automatic play flow.
        // For the stepNext function, create the result snapshot immediately:
        const value = checking.arr[nextIdx];
        const match = (value === checking.target) || (String(value) === String(checking.target));
        const after = {
          arr: checking.arr.slice(),
          current: null,
          checked: checking.checked.slice().concat([nextIdx]),
          foundIndex: match ? nextIdx : null,
          comparisons: checking.comparisons + 1,
          target: checking.target
        };
        recordSnapshot(after);
        renderArray(stepPointer);
        if(match){
          highlightPseudocode(2);
          setStatus(`Found target at index ${nextIdx} after ${after.comparisons} comparisons.`);
        } else {
          highlightPseudocode(2);
          setStatus(`No match at index ${nextIdx}. Comparisons: ${after.comparisons}.`);
        }
      }

      function stepPrev(){
        if(stepPointer <= 0){
          setStatus('At the beginning; cannot step back further.');
          return;
        }
        stepPointer--;
        renderArray(stepPointer);
        // update pseudocode highlight based on snapshot
        const snap = snapshots[stepPointer];
        if(snap.current !== null){
          highlightPseudocode(1);
          setStatus(`Checking index ${snap.current}...`);
        } else if (snap.foundIndex !== null){
          highlightPseudocode(3);
          setStatus(`Found at index ${snap.foundIndex}.`);
        } else if (snap.checked && snap.checked.length === snap.arr.length){
          highlightPseudocode(4);
          setStatus('Search finished (not found).');
        } else {
          highlightPseudocode(0);
          setStatus('Starting state.');
        }
      }

      function autoPlayToggle(){
        if(playing){
          // stop
          playing = false;
          clearInterval(timer);
          timer = null;
          playBtn.textContent = '▶ Play';
          playBtn.setAttribute('aria-pressed','false');
        } else {
          // start playing
          if(stepPointer === -1){
            setStatus('Press Start Search first.');
            return;
          }
          playing = true;
          playBtn.textContent = '⏸ Pause';
          playBtn.setAttribute('aria-pressed','true');
          timer = setInterval(()=>{
            // if at last snapshot and finished, stop
            const snap = snapshots[stepPointer];
            if(snap.foundIndex !== null || (snap.checked && snap.checked.length === snap.arr.length && snap.current === null && snap.foundIndex === null)){
              // finished
              playing = false;
              clearInterval(timer);
              timer = null;
              playBtn.textContent = '▶ Play';
              playBtn.setAttribute('aria-pressed','false');
              return;
            }
            // if the snapshot has current (a checking state) and the next snapshot is the after state, advance twice
            // Our stepping logic already records both checking and after states as sequential snapshots.
            if(stepPointer < snapshots.length - 1){
              // there is a prepared snapshot (should only happen if stepping manually created many)
              stepPointer++;
              renderArray(stepPointer);
            } else {
              // advance by performing next step
              stepNext();
            }
          }, Number(speed.value));
        }
      }

      // UI wiring
      sizeSlider.addEventListener('input',()=>{
        sizeVal.textContent = sizeSlider.value;
      });

      genRandom.addEventListener('click', ()=>{
        const n = Number(sizeSlider.value);
        const min = Number(minValInput.value);
        const max = Number(maxValInput.value);
        if(min > max){
          setStatus('Minimum cannot be greater than maximum.');
          return;
        }
        arr = [];
        for(let i=0;i<n;i++){
          arr.push(randInt(min,max));
        }
        resetSnapshots();
        renderArray(null);
        setStatus('Generated random array.');
        highlightPseudocode(0);
      });

      shuffleBtn.addEventListener('click', ()=>{
        for(let i=arr.length-1;i>0;i--){
          const j = randInt(0,i);
          [arr[i],arr[j]] = [arr[j],arr[i]];
        }
        resetSnapshots();
        renderArray(null);
        setStatus('Shuffled array.');
      });

      applyCustom.addEventListener('click', ()=>{
        const parsed = parseCustom(customInput.value);
        if(!parsed){
          setStatus('Invalid custom array. Use comma-separated values.');
          return;
        }
        arr = parsed;
        sizeSlider.value = arr.length;
        sizeVal.textContent = arr.length;
        resetSnapshots();
        renderArray(null);
        setStatus('Applied custom array.');
      });

      startBtn.addEventListener('click', ()=>{
        // ensure array exists
        if(!arr || arr.length === 0){
          // auto-generate if needed
          genRandom.click();
        }
        startSearch();
      });

      nextBtn.addEventListener('click', ()=>{
        // if not started, start first
        if(stepPointer === -1){
          startBtn.click();
          // if still -1 (no array), exit
          if(stepPointer === -1) return;
        }
        stepNext();
      });

      prevBtn.addEventListener('click', ()=>{
        stepPrev();
      });

      playBtn.addEventListener('click', ()=>{
        autoPlayToggle();
      });

      resetBtn.addEventListener('click', ()=>{
        resetSnapshots();
        renderArray(null);
        setStatus('Reset to initial array.');
        highlightPseudocode(0);
        comparisonsEl.textContent = '0';
        currentIdxEl.textContent = '-';
        resultEl.textContent = 'Not started';
      });

      speed.addEventListener('input', ()=>{
        speedVal.textContent = speed.value;
        if(playing){
          autoPlayToggle();
          autoPlayToggle();
        }
      });

      // initial array
      (function init(){
        sizeVal.textContent = sizeSlider.value;
        const n = Number(sizeSlider.value);
        for(let i=0;i<n;i++) arr.push(randInt(0,20));
        renderArray(null);
        highlightPseudocode(0);
      })();

      // keyboard accessibility for playback
      document.addEventListener('keydown', (e)=>{
        if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        if(e.key === ' '){
          e.preventDefault();
          autoPlayToggle();
        } else if(e.key === 'ArrowRight'){
          nextBtn.click();
        } else if(e.key === 'ArrowLeft'){
          prevBtn.click();
        } else if(e.key === 'r'){
          resetBtn.click();
        }
      });

      // ensure UI updates when rendering snapshots: highlight pseudocode according to state
      const originalRenderArray = renderArray;
      renderArray = function(stateIndex = null){
        originalRenderArray(stateIndex);
        // extra pseudocode mapping
        if(stepPointer === -1){
          highlightPseudocode(0);
        } else {
          const s = snapshots[stepPointer];
          if(s.current !== null){
            // when checking, show "for" and "if"
            highlightPseudocode(1);
          } else if(s.foundIndex !== null){
            highlightPseudocode(3);
          } else if(s.checked && s.checked.length === s.arr.length){
            highlightPseudocode(4);
          } else {
            highlightPseudocode(0);
          }
        }
      };

    })();
  </script>
</body>
</html>