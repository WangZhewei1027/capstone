<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Binary Search Tree (BST) Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#3b82f6;
      --muted:#94a3b8;
      --good:#10b981;
      --danger:#f43f5e;
      --card:#071025;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #071022 0%, #001528 100%);
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      max-width:1100px;
      margin:24px auto;
      padding:20px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:20px;
      align-items:start;
    }
    h1{
      font-size:20px;
      margin:0 0 8px 0;
      color:#d9f0ff;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:10px;
      padding:14px;
      border:1px solid rgba(255,255,255,0.03);
    }
    .controls label{
      font-size:13px;
      color:var(--muted);
      display:block;
      margin-bottom:6px;
    }
    .row{
      display:flex;
      gap:8px;
      margin-bottom:10px;
      align-items:center;
    }
    input[type="number"], input[type="text"]{
      width:100%;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:transparent;
      color:inherit;
      outline:none;
      box-sizing:border-box;
    }
    button{
      cursor:pointer;
      border:0;
      padding:8px 10px;
      border-radius:8px;
      background:var(--accent);
      color:white;
      font-weight:600;
      box-shadow: 0 6px 16px rgba(59,130,246,0.12);
    }
    button.ghost{
      background:transparent;
      border:1px solid rgba(255,255,255,0.05);
      color:var(--muted);
      box-shadow:none;
    }
    .small{
      padding:6px 8px;
      font-size:13px;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
    }
    .stats{
      display:flex;
      gap:8px;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .stat{
      background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent);
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.02);
    }
    .svg-wrap{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:10px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.03);
      min-height:520px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .canvas{
      flex:1;
      background:linear-gradient(180deg, rgba(2,6,23,0.4), rgba(2,6,23,0.2));
      border-radius:8px;
      overflow:auto;
      padding:12px;
    }
    svg{
      width:100%;
      height:520px;
    }
    .legend{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }
    .dot{
      width:12px;height:12px;border-radius:50%;
      display:inline-block;margin-right:6px;
    }
    .info{
      margin-top:8px;
      font-size:13px;
      color:var(--muted);
    }
    .traversal-output{
      margin-top:10px;
      padding:8px;
      background:rgba(255,255,255,0.02);
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
      font-family:monospace;
      color:#dbeafe;
      max-height:120px;
      overflow:auto;
      font-size:13px;
    }
    .small-muted{
      color:var(--muted);
      font-size:12px;
    }

    /* node visuals (we'll override fill/stroke from JS for highlights) */
    .node-circle{
      fill:#0b1220;
      stroke:#9fb8ff33;
      stroke-width:2;
    }
    .node-text{
      font-size:13px;
      fill:#dbeafe;
      pointer-events:none;
      font-weight:700;
    }
    .edge{
      stroke:#203a66;
      stroke-width:2;
    }

    @media (max-width:880px){
      .app{ grid-template-columns: 1fr; padding:12px; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Binary Search Tree Visualizer">
    <div class="panel controls" aria-hidden="false">
      <h1>Binary Search Tree (BST)</h1>
      <div class="muted">Insert, delete, search and visualize the BST. Duplicates are not allowed.</div>

      <div style="height:12px"></div>

      <div>
        <label for="valueInput">Value (integer)</label>
        <div class="row">
          <input id="valueInput" type="number" placeholder="e.g. 42" />
          <button id="insertBtn" class="small">Insert</button>
          <button id="deleteBtn" class="small ghost">Delete</button>
        </div>
      </div>

      <div style="height:6px"></div>

      <div>
        <label for="searchInput">Search</label>
        <div class="row">
          <input id="searchInput" type="number" placeholder="Find value..." />
          <button id="searchBtn" class="small">Find</button>
          <button id="clearBtn" class="small ghost">Reset</button>
        </div>
      </div>

      <div style="height:12px"></div>

      <div>
        <label>Traversals & Animation</label>
        <div class="row">
          <button id="inorderBtn" class="small ghost">In-order</button>
          <button id="preorderBtn" class="small ghost">Pre-order</button>
          <button id="postorderBtn" class="small ghost">Post-order</button>
          <button id="levelBtn" class="small ghost">Level-order</button>
        </div>
      </div>

      <div style="height:12px"></div>

      <div>
        <label>Quick actions</label>
        <div class="row">
          <button id="randomBtn" class="small">Random 8</button>
          <button id="balancedBtn" class="small">Make Balanced (rebuild)</button>
          <button id="fillBtn" class="small ghost">Clear & Fill (1..10)</button>
        </div>
      </div>

      <div class="stats" aria-hidden="false" style="margin-top:12px">
        <div class="stat">Nodes: <span id="statNodes">0</span></div>
        <div class="stat">Height: <span id="statHeight">0</span></div>
        <div class="stat">Min: <span id="statMin">—</span></div>
        <div class="stat">Max: <span id="statMax">—</span></div>
      </div>

      <div class="info">
        Click any node in the SVG to search for it. Visited nodes are highlighted during operations.
      </div>

      <div class="traversal-output" id="traceOutput" aria-live="polite"></div>
    </div>

    <div class="panel svg-wrap">
      <div class="legend">
        <div style="display:flex;gap:8px;align-items:center">
          <div class="dot" style="background:var(--accent)"></div> Active / found
          <div style="width:12px"></div>
          <div class="dot" style="background:#ffd166"></div> Visited
          <div style="width:12px"></div>
          <div class="dot" style="background:#94a3b8"></div> Node
        </div>
        <div style="flex:1"></div>
        <div class="small-muted">SVG Canvas</div>
      </div>

      <div class="canvas" id="canvas">
        <svg id="svg" viewBox="0 0 1200 520" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Binary search tree visualization"></svg>
      </div>
    </div>
  </div>

  <script>
    // BST Visualizer
    // Node structure: {value, left, right}
    (function(){
      // Utilities
      const $ = (id)=>document.getElementById(id);
      const svg = $('svg');
      const valueInput = $('valueInput');
      const insertBtn = $('insertBtn');
      const deleteBtn = $('deleteBtn');
      const searchInput = $('searchInput');
      const searchBtn = $('searchBtn');
      const clearBtn = $('clearBtn');
      const inorderBtn = $('inorderBtn');
      const preorderBtn = $('preorderBtn');
      const postorderBtn = $('postorderBtn');
      const levelBtn = $('levelBtn');
      const randomBtn = $('randomBtn');
      const balancedBtn = $('balancedBtn');
      const fillBtn = $('fillBtn');
      const traceOutput = $('traceOutput');
      const statNodes = $('statNodes');
      const statHeight = $('statHeight');
      const statMin = $('statMin');
      const statMax = $('statMax');

      let root = null;
      let nodeCount = 0;
      let animationRunning = false;

      // Insert (records visited values)
      function insert(value){
        if (root === null){
          root = {value, left:null, right:null};
          nodeCount=1;
          return {inserted:true, steps:[value]};
        }
        const steps = [];
        let cur = root;
        while(true){
          steps.push(cur.value);
          if (value === cur.value) {
            // duplicate
            return {inserted:false, steps, msg:'duplicate'};
          } else if (value < cur.value){
            if (cur.left === null){
              cur.left = {value, left:null, right:null};
              nodeCount++;
              steps.push(value);
              return {inserted:true, steps};
            } else {
              cur = cur.left;
            }
          } else {
            if (cur.right === null){
              cur.right = {value, left:null, right:null};
              nodeCount++;
              steps.push(value);
              return {inserted:true, steps};
            } else {
              cur = cur.right;
            }
          }
        }
      }

      // Search (records visited values)
      function search(value){
        const steps = [];
        let cur = root;
        while(cur){
          steps.push(cur.value);
          if (value === cur.value) return {found:true, steps};
          cur = value < cur.value ? cur.left : cur.right;
        }
        return {found:false, steps};
      }

      // Find min node in subtree
      function findMinNode(node){
        let cur = node;
        while(cur && cur.left) cur = cur.left;
        return cur;
      }

      // Delete value from BST. Returns steps of visited node values.
      function deleteValue(value){
        const steps = [];
        let deleted = false;
        function deleteRec(node){
          if (!node) return null;
          steps.push(node.value);
          if (value < node.value){
            node.left = deleteRec(node.left);
            return node;
          } else if (value > node.value){
            node.right = deleteRec(node.right);
            return node;
          } else {
            // found node to delete
            deleted = true;
            // case 1: no children
            if (!node.left && !node.right) return null;
            // case 2: one child
            if (!node.left) return node.right;
            if (!node.right) return node.left;
            // case 3: two children -> replace with inorder successor
            const succ = findMinNode(node.right);
            // record successor visited (value)
            if (succ) steps.push(succ.value);
            node.value = succ.value;
            // delete successor from right subtree
            node.right = deleteRec(node.right);
            return node;
          }
        }
        root = deleteRec(root);
        if (deleted) nodeCount = countNodes(root);
        return {deleted, steps};
      }

      function countNodes(node){
        if (!node) return 0;
        return 1 + countNodes(node.left) + countNodes(node.right);
      }

      function treeHeight(node){
        if (!node) return 0;
        return 1 + Math.max(treeHeight(node.left), treeHeight(node.right));
      }

      function findMin(node){
        if (!node) return null;
        let cur = node;
        while(cur.left) cur = cur.left;
        return cur.value;
      }
      function findMax(node){
        if (!node) return null;
        let cur = node;
        while(cur.right) cur = cur.right;
        return cur.value;
      }

      // Traversals
      function inorder(node, out=[]){ if(!node) return out; inorder(node.left,out); out.push(node.value); inorder(node.right,out); return out; }
      function preorder(node, out=[]){ if(!node) return out; out.push(node.value); preorder(node.left,out); preorder(node.right,out); return out; }
      function postorder(node, out=[]){ if(!node) return out; postorder(node.left,out); postorder(node.right,out); out.push(node.value); return out; }
      function levelOrder(node){
        const out=[]; if(!node) return out;
        const q=[node];
        while(q.length){
          const n=q.shift();
          out.push(n.value);
          if(n.left) q.push(n.left);
          if(n.right) q.push(n.right);
        }
        return out;
      }

      // Layout: assign x by inorder index, y by depth.
      function computePositions(rootNode){
        const positions = new Map(); // value -> {x,y,depth}
        let index = 0;
        function dfs(node, depth){
          if(!node) return;
          dfs(node.left, depth+1);
          const x = index++;
          positions.set(node.value, {x, depth});
          dfs(node.right, depth+1);
        }
        dfs(rootNode, 0);
        return {positions, total:index};
      }

      // Draw tree into SVG
      function draw(){
        // clear
        while(svg.firstChild) svg.removeChild(svg.firstChild);
        if(!root) return;
        const padding = 40;
        const {positions, total} = computePositions(root);
        const levelH = 80;
        const width = 1200;
        const height = 520;
        const availableWidth = Math.max(600, width - padding*2);
        const step = total>1 ? (availableWidth / (total-1)) : 0;
        // helper to get coordinates by value
        function coordFor(val){
          const p = positions.get(val);
          const x = padding + (p.x * step);
          const y = padding + p.depth * levelH;
          return {x,y,depth:p.depth};
        }

        // draw edges by traversing nodes
        function drawEdges(node){
          if(!node) return;
          if(node.left){
            const a = coordFor(node.value), b = coordFor(node.left.value);
            const line = document.createElementNS('http://www.w3.org/2000/svg','line');
            line.setAttribute('x1', a.x); line.setAttribute('y1', a.y+18);
            line.setAttribute('x2', b.x); line.setAttribute('y2', b.y-18);
            line.setAttribute('class','edge');
            svg.appendChild(line);
          }
          if(node.right){
            const a = coordFor(node.value), b = coordFor(node.right.value);
            const line = document.createElementNS('http://www.w3.org/2000/svg','line');
            line.setAttribute('x1', a.x); line.setAttribute('y1', a.y+18);
            line.setAttribute('x2', b.x); line.setAttribute('y2', b.y-18);
            line.setAttribute('class','edge');
            svg.appendChild(line);
          }
          drawEdges(node.left);
          drawEdges(node.right);
        }
        drawEdges(root);

        // draw nodes
        function drawNodes(node){
          if(!node) return;
          const {x,y} = coordFor(node.value);
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('transform', `translate(${x},${y})`);
          g.setAttribute('data-value', node.value);
          g.setAttribute('role','button');
          // circle
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('r', 18);
          c.setAttribute('class','node-circle');
          c.setAttribute('id', 'node-'+node.value);
          // text
          const t = document.createElementNS('http://www.w3.org/2000/svg','text');
          t.setAttribute('class','node-text');
          t.setAttribute('text-anchor','middle');
          t.setAttribute('dy','5');
          t.textContent = node.value;
          g.appendChild(c);
          g.appendChild(t);
          // click search
          g.addEventListener('click', ()=> {
            if (animationRunning) return;
            searchInput.value = node.value;
            handleSearch();
          });
          svg.appendChild(g);
          drawNodes(node.left);
          drawNodes(node.right);
        }
        drawNodes(root);
      }

      // Highlight utilities (value-based)
      function highlightSequence(values, {visitColor='#ffd166', foundColor='var(--accent)', delay=450, keep=false} = {}){
        if (!values || values.length===0) return Promise.resolve();
        animationRunning = true;
        traceOutput.textContent = '';
        let p = Promise.resolve();
        values.forEach((val, idx)=>{
          p = p.then(()=> new Promise(resolve=>{
            // highlight visited
            const el = document.getElementById('node-'+val);
            if (el){
              const circle = el;
              const nodeParent = circle.parentNode;
              // visited highlight
              circle.style.transition = 'fill 180ms, stroke 180ms';
              circle.setAttribute('fill', visitColor);
              circle.setAttribute('stroke', '#7a4f05');
              // append trace
              traceOutput.textContent += (idx? ' ➜ ' : '') + val;
            }
            setTimeout(()=> {
              // after delay, if final and keep, set final color
              if (idx === values.length-1 && keep){
                const el2 = document.getElementById('node-'+values[values.length-1]);
                if (el2){
                  el2.setAttribute('fill', foundColor);
                  el2.setAttribute('stroke', '#1e40af');
                }
              } else {
                // revert visited color to default
                const el3 = document.getElementById('node-'+val);
                if (el3){
                  el3.setAttribute('fill', '#0b1220');
                  el3.setAttribute('stroke', '#9fb8ff33');
                }
              }
              resolve();
            }, delay);
          }));
        });
        return p.then(()=>{ animationRunning = false; });
      }

      // For searches we want to keep last node highlighted
      function animateSearch(steps, found){
        const colorVisited = '#ffd166';
        const colorFound = 'var(--accent)';
        return highlightSequence(steps, {visitColor:colorVisited, foundColor:colorFound, delay:420, keep:found});
      }

      // For traversals: highlight nodes in traversal order
      function animateTraversal(list){
        const colorVisited = '#ffd166';
        animationRunning = true;
        traceOutput.textContent = '';
        let p = Promise.resolve();
        list.forEach((val, idx) => {
          p = p.then(()=> new Promise(resolve=>{
            const el = document.getElementById('node-'+val);
            if(el){
              el.setAttribute('fill', colorVisited);
              el.setAttribute('stroke', '#7a4f05');
            }
            traceOutput.textContent += (idx? ' ➜ ' : '') + val;
            setTimeout(()=> {
              const el2 = document.getElementById('node-'+val);
              if(el2){
                el2.setAttribute('fill', '#0b1220');
                el2.setAttribute('stroke', '#9fb8ff33');
              }
              resolve();
            }, 300);
          }));
        });
        return p.then(()=> { animationRunning = false; });
      }

      // UI Handlers
      function updateStats(){
        statNodes.textContent = nodeCount;
        statHeight.textContent = treeHeight(root);
        const min = findMin(root), max = findMax(root);
        statMin.textContent = min===null? '—':min;
        statMax.textContent = max===null? '—':max;
      }

      function handleInsert(){
        if (animationRunning) return;
        const v = parseInt(valueInput.value);
        if (Number.isNaN(v)) return alert('Enter an integer value to insert.');
        const res = insert(v);
        draw();
        updateStats();
        if(!res.inserted){
          alert('Duplicate values are not allowed in this BST (ignored).');
        } else {
          // animate insertion path
          animateSearch(res.steps, true).then(()=> {});
        }
      }
      function handleDelete(){
        if (animationRunning) return;
        const v = parseInt(valueInput.value);
        if (Number.isNaN(v)) return alert('Enter an integer value to delete.');
        const res = deleteValue(v);
        draw();
        updateStats();
        if (!res.deleted){
          // animate visited path showing not found
          animateSearch(res.steps, false).then(()=> {
            if (res.steps.length===0) alert('Tree is empty.');
            else alert('Value not found.');
          });
        } else {
          animateSearch(res.steps, false).then(()=> {});
        }
      }
      function handleSearch(){
        if (animationRunning) return;
        const v = parseInt(searchInput.value);
        if (Number.isNaN(v)) return alert('Enter an integer to search.');
        const res = search(v);
        if (res.steps.length===0){
          alert('Tree is empty.');
          return;
        }
        animateSearch(res.steps, res.found).then(()=> {
          if (!res.found) alert('Not found.');
        });
      }

      // Utility to create random unique integers
      function randomUnique(count, min=1, max=99){
        const s = new Set();
        while(s.size < count){
          const r = Math.floor(Math.random()*(max-min+1))+min;
          s.add(r);
          if (s.size > (max-min+1)) break;
        }
        return Array.from(s);
      }

      // Build balanced tree from sorted array
      function buildBalanced(sorted){
        function build(l,r){
          if (l>r) return null;
          const m = Math.floor((l+r)/2);
          return {value: sorted[m], left: build(l,m-1), right: build(m+1,r)};
        }
        return build(0, sorted.length-1);
      }

      // Event Listeners
      insertBtn.addEventListener('click', handleInsert);
      deleteBtn.addEventListener('click', handleDelete);
      searchBtn.addEventListener('click', handleSearch);
      clearBtn.addEventListener('click', ()=> {
        if (animationRunning) return;
        if (!confirm('Clear the entire tree?')) return;
        root = null; nodeCount=0; draw(); updateStats();
        traceOutput.textContent = '';
      });

      inorderBtn.addEventListener('click', ()=> {
        if (animationRunning) return;
        const list = inorder(root,[]);
        if(list.length===0) return alert('Tree is empty.');
        // animate traversal
        animateTraversal(list);
      });
      preorderBtn.addEventListener('click', ()=> {
        if (animationRunning) return;
        const list = preorder(root,[]);
        if(list.length===0) return alert('Tree is empty.');
        animateTraversal(list);
      });
      postorderBtn.addEventListener('click', ()=> {
        if (animationRunning) return;
        const list = postorder(root,[]);
        if(list.length===0) return alert('Tree is empty.');
        animateTraversal(list);
      });
      levelBtn.addEventListener('click', ()=> {
        if (animationRunning) return;
        const list = levelOrder(root);
        if(list.length===0) return alert('Tree is empty.');
        animateTraversal(list);
      });

      randomBtn.addEventListener('click', ()=> {
        if (animationRunning) return;
        root = null; nodeCount=0;
        const vals = randomUnique(8,1,99);
        vals.forEach(v=> insert(v));
        draw(); updateStats();
      });

      fillBtn.addEventListener('click', ()=> {
        if (animationRunning) return;
        if (!confirm('Clear and insert values 1..10?')) return;
        root = null; nodeCount=0;
        for(let i=1;i<=10;i++) insert(i);
        draw(); updateStats();
      });

      balancedBtn.addEventListener('click', ()=> {
        if (animationRunning) return;
        // rebuild tree as balanced tree using current values
        const vals = inorder(root,[]);
        if (vals.length===0) return;
        root = buildBalanced(vals);
        nodeCount = vals.length;
        draw(); updateStats();
      });

      // Initialize with a small example
      (function seed(){
        const seeds = [60,40,80,30,50,70,90,20,35,45,55];
        root = null; nodeCount=0;
        seeds.forEach(v=> insert(v));
        draw(); updateStats();
      })();

      // Make SVG responsive to resizing
      window.addEventListener('resize', ()=> draw());

      // Keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter'){
          if (document.activeElement === valueInput) handleInsert();
          else if (document.activeElement === searchInput) handleSearch();
        }
      });

      // Accessibility: announce when animation running
      const obs = new MutationObserver(()=>{});
      updateStats();
    })();
  </script>
</body>
</html>