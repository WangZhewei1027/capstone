<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Merge Sort Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#60a5fa;
      --muted:#94a3b8;
      --good:#34d399;
      --bad:#fb7185;
      --bar:#60a5fa;
      --bar-alt:#60e0a5;
      --text:#e6eef8;
    }
    *{box-sizing:border-box;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{margin:0;min-height:100vh;background:linear-gradient(180deg,#071029 0%, #071824 60%);color:var(--text); display:flex;flex-direction:column;align-items:center;padding:18px;}
    h1{margin:8px 0 12px;font-size:20px;}
    .container{width:100%;max-width:1100px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));border:1px solid rgba(255,255,255,0.04);padding:14px;border-radius:10px;box-shadow:0 10px 30px rgba(2,6,23,0.6);}
    .top{display:flex;gap:16px;align-items:center;flex-wrap:wrap;margin-bottom:12px;}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    button{background:var(--panel);border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;color:var(--text);cursor:pointer;}
    button.primary{background:linear-gradient(90deg,var(--accent), #3b82f6);border:none;color:#02203a;font-weight:600;}
    .small{padding:6px 8px;font-size:14px;}
    .sliderRow{display:flex;gap:8px;align-items:center;}
    input[type=range]{appearance:none;height:8px;background:linear-gradient(90deg,#263544,#12202c);border-radius:6px;outline:none;}
    input[type=range]::-webkit-slider-thumb{appearance:none;width:14px;height:14px;border-radius:50%;background:var(--accent);box-shadow:0 2px 6px rgba(0,0,0,0.4);}
    .info{margin-left:auto;color:var(--muted);display:flex;gap:16px;align-items:center;font-size:14px;}
    .visual{height:340px;background:linear-gradient(180deg,#021027 0%, #041427 100%);border-radius:8px;padding:12px;margin-top:6px;display:flex;flex-direction:column;gap:12px;border:1px solid rgba(255,255,255,0.03);}
    .bars{flex:1;display:flex;align-items:end;gap:2px;height:100%;width:100%;padding:4px;overflow:hidden;border-radius:6px;position:relative;}
    .bar{background:var(--bar);flex:1 1 auto;border-radius:4px 4px 0 0;display:flex;align-items:flex-end;justify-content:center;color:rgba(0,0,0,0.7);font-size:11px;font-weight:700;user-select:none;transition:height 120ms linear, background 120ms;}
    .bar.smallText{font-size:10px;padding-bottom:3px;}
    .legend{display:flex;gap:6px;align-items:center;flex-wrap:wrap;font-size:13px;color:var(--muted);}
    .dot{width:12px;height:12px;border-radius:3px;}
    .dot.compare{background:#facc15;}
    .dot.write{background:#f97316;}
    .dot.sorted{background:var(--good);}
    .panel{display:flex;gap:12px;align-items:center;}
    .pseudocode{width:320px;background:#021826;border-radius:8px;padding:10px;color:var(--muted);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;font-size:13px;}
    .code-line{padding:4px 6px;border-radius:6px;}
    .code-line.active{background:linear-gradient(90deg, rgba(96,165,250,0.12), rgba(96,165,250,0.04));color:var(--accent);font-weight:600;}
    .stats{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:13px;}
    .stat{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:6px;}
    .footer{margin-top:12px;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;color:var(--muted);font-size:13px;}
    .rangeLabel{min-width:68px;text-align:center;}
    .controls .input{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px 8px;border-radius:8px;color:var(--text);}
    @media(max-width:900px){ .pseudocode{display:none;} .info{display:none;} }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Merge Sort Visualizer">
    <h1>Merge Sort Visualizer</h1>
    <div class="top">
      <div class="controls" role="toolbar">
        <button id="generate" class="small">Generate</button>
        <button id="shuffle" class="small">Shuffle</button>
        <button id="start" class="primary small">Start</button>
        <button id="pause" class="small" disabled>Pause</button>
        <button id="step" class="small">Step</button>
        <button id="reset" class="small">Reset</button>

        <div class="sliderRow">
          <label for="size" class="rangeLabel">Size</label>
          <input id="size" type="range" min="8" max="160" value="48" />
        </div>

        <div class="sliderRow">
          <label for="speed" class="rangeLabel">Speed</label>
          <input id="speed" type="range" min="1" max="100" value="48" />
        </div>

        <div>
          <label style="display:flex;gap:6px;align-items:center;">
            <input id="order" type="checkbox" />
            <span style="color:var(--muted);font-size:13px;">Descending</span>
          </label>
        </div>
      </div>

      <div class="info" aria-hidden="true">
        <div class="legend">
          <div style="display:flex;gap:6px;align-items:center;"><div class="dot compare"></div><div>Compare</div></div>
          <div style="display:flex;gap:6px;align-items:center;"><div class="dot write"></div><div>Write</div></div>
          <div style="display:flex;gap:6px;align-items:center;"><div class="dot sorted"></div><div>Sorted Range</div></div>
        </div>
      </div>
    </div>

    <div class="visual" role="region" aria-label="Sort visualization">
      <div class="bars" id="bars" aria-hidden="false"></div>

      <div style="display:flex;gap:12px;align-items:flex-start">
        <div class="panel" style="gap:18px;align-items:center">
          <div class="stats">
            <div class="stat">Comparisons: <span id="comp">0</span></div>
            <div class="stat">Writes: <span id="writes">0</span></div>
            <div class="stat">Actions queued: <span id="actionsCount">0</span></div>
          </div>
          <div style="color:var(--muted);font-size:13px;">
            Tip: Use Step to advance one recorded action while paused. Increase Speed to animate faster.
          </div>
        </div>

        <div class="pseudocode" aria-hidden="true">
          <div style="font-weight:700;margin-bottom:6px;color:var(--text)">Pseudocode (merge sort)</div>
          <div id="code">
            <div class="code-line" data-line="1">1  function mergeSort(arr, l, r):</div>
            <div class="code-line" data-line="2">2    if l >= r: return</div>
            <div class="code-line" data-line="3">3    mid = (l + r) // 2</div>
            <div class="code-line" data-line="4">4    mergeSort(arr, l, mid)</div>
            <div class="code-line" data-line="5">5    mergeSort(arr, mid+1, r)</div>
            <div class="code-line" data-line="6">6    merge(arr, l, mid, r)</div>
            <div class="code-line" data-line="7">7  function merge(arr, l, mid, r):</div>
            <div class="code-line" data-line="8">8    i = l; j = mid+1; k = l</div>
            <div class="code-line" data-line="9">9    while i <= mid and j <= r:</div>
            <div class="code-line" data-line="10">10     if arr[i] <= arr[j]: temp[k++] = arr[i++]</div>
            <div class="code-line" data-line="11">11     else: temp[k++] = arr[j++]</div>
            <div class="code-line" data-line="12">12    while i <= mid: temp[k++] = arr[i++]</div>
            <div class="code-line" data-line="13">13    while j <= r: temp[k++] = arr[j++]</div>
            <div class="code-line" data-line="14">14    copy temp[l..r] back into arr[l..r]</div>
          </div>
        </div>
      </div>
    </div>

    <div class="footer">
      <div>Stable sort • Time: O(n log n) average/worst • Space: O(n)</div>
      <div style="color:var(--muted)">Visualization by Merge Sort algorithm — interactive and step-through</div>
    </div>
  </div>

  <script>
    // Merge Sort Visualizer
    (function(){
      const barsEl = document.getElementById('bars');
      const sizeInput = document.getElementById('size');
      const speedInput = document.getElementById('speed');
      const generateBtn = document.getElementById('generate');
      const shuffleBtn = document.getElementById('shuffle');
      const startBtn = document.getElementById('start');
      const pauseBtn = document.getElementById('pause');
      const stepBtn = document.getElementById('step');
      const resetBtn = document.getElementById('reset');
      const orderCheck = document.getElementById('order');
      const compsEl = document.getElementById('comp');
      const writesEl = document.getElementById('writes');
      const actionsCountEl = document.getElementById('actionsCount');
      const codeLines = Array.from(document.querySelectorAll('.code-line'));

      let array = [];
      let initialArray = [];
      let actions = []; // queued actions describing the sort
      let actionIndex = 0;
      let timer = null;
      let running = false;
      let paused = false;
      let comparisons = 0;
      let writes = 0;

      // Colors
      const COLOR_DEFAULT = 'var(--bar)';
      const COLOR_COMPARE = '#facc15'; // yellow
      const COLOR_WRITE = '#f97316'; // orange
      const COLOR_RANGE = 'rgba(96,165,250,0.18)';
      const COLOR_SORTED = 'var(--good)';

      function rand(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

      function createArray(n){
        array = [];
        for(let i=0;i<n;i++) array.push(rand(5, 100));
        initialArray = array.slice();
      }

      function renderBars(){
        barsEl.innerHTML = '';
        const n = array.length;
        for(let i=0;i<n;i++){
          const v = array[i];
          const bar = document.createElement('div');
          bar.className = 'bar' + (n>80 ? ' smallText' : '');
          bar.style.height = (v) + '%';
          bar.style.flexBasis = (100/n) + '%';
          bar.style.background = COLOR_DEFAULT;
          bar.dataset.index = i;
          bar.title = v;
          bar.textContent = n <= 60 ? v : '';
          barsEl.appendChild(bar);
        }
      }

      function updateStats(){
        compsEl.textContent = comparisons;
        writesEl.textContent = writes;
        actionsCountEl.textContent = Math.max(0, actions.length - actionIndex);
      }

      // Recording actions: we'll operate on a scratch array and push actions
      function recordMergeSort(arr){
        actions = [];
        comparisons = 0;
        writes = 0;
        // We'll copy the array to a working array to generate writes precisely
        const work = arr.slice();
        function push(a){ actions.push(a); }
        function mergeSort(l, r){
          push({type:'range', start:l, end:r, line:1});
          if(l >= r){
            push({type:'rangeEnd', start:l, end:r}); // no-op marker
            return;
          }
          push({type:'code', line:3});
          const mid = Math.floor((l + r)/2);
          push({type:'code', line:4});
          mergeSort(l, mid);
          push({type:'code', line:5});
          mergeSort(mid+1, r);
          push({type:'code', line:6});
          // merge
          push({type:'mergeStart', start:l, mid:mid, end:r});
          const temp = [];
          let i = l, j = mid+1, k = 0;
          push({type:'code', line:7});
          while(i <= mid && j <= r){
            push({type:'code', line:9});
            // compare
            push({type:'compare', i:i, j:j});
            comparisons++;
            if(work[i] <= work[j]){
              push({type:'code', line:10});
              temp[k++] = work[i];
              push({type:'writeTemp', index: (l + k - 1), value: work[i]});
              // not counting writes to temp into 'writes' below; we'll count writes when copying back
              i++;
            } else {
              push({type:'code', line:11});
              temp[k++] = work[j];
              push({type:'writeTemp', index: (l + k - 1), value: work[j]});
              j++;
            }
          }
          while(i <= mid){
            push({type:'code', line:12});
            temp[k++] = work[i];
            push({type:'writeTemp', index: (l + k - 1), value: work[i]});
            i++;
          }
          while(j <= r){
            push({type:'code', line:13});
            temp[k++] = work[j];
            push({type:'writeTemp', index: (l + k - 1), value: work[j]});
            j++;
          }
          // copy back
          for(let t=0;t<temp.length;t++){
            work[l + t] = temp[t];
            push({type:'overwrite', index: l + t, value: temp[t]});
            writes++;
          }
          push({type:'rangeSorted', start:l, end:r});
          push({type:'mergeEnd', start:l, end:r});
        }
        if(arr.length > 0) mergeSort(0, arr.length-1);
        push({type:'done'});
      }

      // Animation: apply next action
      function applyAction(act){
        // clear highlights first in most cases
        const bars = barsEl.children;
        function resetBars(){
          for(let b of bars) b.style.background = COLOR_DEFAULT;
        }
        // helper to color range
        function colorRange(start,end,color){
          for(let i=start;i<=end && i<bars.length;i++){
            if(i<0) continue;
            bars[i].style.background = color;
          }
        }

        switch(act.type){
          case 'range':
            resetBars();
            colorRange(act.start, act.end, COLOR_RANGE);
            highlightCode(1);
            break;
          case 'code':
            resetBars();
            highlightCode(act.line);
            break;
          case 'compare':
            resetBars();
            if(bars[act.i]) bars[act.i].style.background = COLOR_COMPARE;
            if(bars[act.j]) bars[act.j].style.background = COLOR_COMPARE;
            highlightCode(9);
            comparisons = Math.max(0, comparisons); // already incremented during recording
            break;
          case 'writeTemp':
            // show write visual on the target index (like writing into temp position within array)
            resetBars();
            if(bars[act.index]){
              bars[act.index].style.background = COLOR_WRITE;
              bars[act.index].style.height = (act.value) + '%';
              bars[act.index].textContent = bars.length <= 60 ? act.value : '';
            }
            highlightCode(10); // approximate
            break;
          case 'overwrite':
            // write back into the main array (count as write)
            resetBars();
            if(bars[act.index]){
              bars[act.index].style.background = COLOR_WRITE;
              bars[act.index].style.height = (act.value) + '%';
              bars[act.index].textContent = bars.length <= 60 ? act.value : '';
            }
            highlightCode(14);
            break;
          case 'rangeSorted':
            resetBars();
            colorRange(act.start, act.end, COLOR_SORTED);
            highlightCode(14);
            break;
          case 'mergeStart':
            resetBars();
            colorRange(act.start, act.end, COLOR_RANGE);
            highlightCode(7);
            break;
          case 'mergeEnd':
            resetBars();
            colorRange(act.start, act.end, COLOR_SORTED);
            highlightCode(6);
            break;
          case 'rangeEnd':
            // nothing
            resetBars();
            break;
          case 'done':
            resetBars();
            for(let i=0;i<bars.length;i++) bars[i].style.background = COLOR_SORTED;
            highlightCode(null);
            running = false;
            paused = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            break;
        }
        updateStats();
      }

      function highlightCode(line){
        codeLines.forEach(cl=>{
          const ln = cl.dataset.line ? Number(cl.dataset.line) : null;
          if(line && ln === Number(line)) cl.classList.add('active'); else cl.classList.remove('active');
        });
      }

      function play(){
        if(actions.length === 0) return;
        running = true;
        paused = false;
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        stepBtn.disabled = false;
        resetBtn.disabled = true;
        generateBtn.disabled = true;
        shuffleBtn.disabled = true;
        sizeInput.disabled = true;
        orderCheck.disabled = true;

        const speedVal = Number(speedInput.value); // 1..100, higher = faster
        // map speed to delay ms: speed 1 -> 800ms, 100 -> 5ms (non-linear)
        const delay = Math.max(5, Math.floor(800 * (1 - (speedVal-1)/99)));

        function step(){
          if(paused || !running) return;
          if(actionIndex >= actions.length){
            running = false;
            clearInterval(timer);
            applyAction({type:'done'});
            updateStats();
            return;
          }
          const act = actions[actionIndex++];
          applyAction(act);
          updateStats();
        }

        // run first immediately so UI responds quickly
        step();
        timer = setInterval(()=>{
          if(paused || !running) return;
          if(actionIndex >= actions.length){
            clearInterval(timer);
            running = false;
            applyAction({type:'done'});
            updateStats();
            return;
          }
          const act = actions[actionIndex++];
          applyAction(act);
          updateStats();
        }, delay);
      }

      function pause(){
        paused = true;
        running = false;
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        resetBtn.disabled = false;
        generateBtn.disabled = false;
        shuffleBtn.disabled = false;
        sizeInput.disabled = false;
        orderCheck.disabled = false;
        if(timer) clearInterval(timer);
      }

      function doStep(){
        if(actionIndex >= actions.length) return;
        const act = actions[actionIndex++];
        applyAction(act);
        updateStats();
      }

      // Build actions and then animate them on Start
      function startSort(){
        // if already running, do nothing
        if(running && !paused) return;
        // prepare array snapshot
        const snapshot = Array.from(barsEl.children).map(b => parseInt(b.title || b.textContent) || 0);
        // choose order
        const descending = orderCheck.checked;
        let arrCopy = snapshot.slice();
        if(descending){
          // to get descending, sort by ascending then reverse comparisons: easier to invert values
          // We'll transform values by negating so that the recorded ascending merges produce descending final
          arrCopy = arrCopy.map(v => 100 - v); // invert relative order
        }
        recordMergeSort(arrCopy);
        actionIndex = 0;
        comparisons = 0; writes = 0;
        updateStats();
        play();
      }

      // Utilities for buttons
      function stopAnimation(){
        running = false;
        paused = false;
        if(timer) clearInterval(timer);
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        resetBtn.disabled = false;
        generateBtn.disabled = false;
        shuffleBtn.disabled = false;
        sizeInput.disabled = false;
        orderCheck.disabled = false;
      }

      // initial setup
      function initialize(){
        createArray(Number(sizeInput.value));
        renderBars();
        updateStats();
      }

      // button handlers
      generateBtn.addEventListener('click', ()=>{
        stopAnimation();
        createArray(Number(sizeInput.value));
        renderBars();
        actions = [];
        actionIndex = 0;
        comparisons = 0;
        writes = 0;
        updateStats();
        highlightCode(null);
      });

      shuffleBtn.addEventListener('click', ()=>{
        stopAnimation();
        // Fisher-Yates shuffle
        for(let i=array.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        initialArray = array.slice();
        renderBars();
        actions = [];
        actionIndex = 0;
        comparisons = 0;
        writes = 0;
        updateStats();
        highlightCode(null);
      });

      startBtn.addEventListener('click', ()=>{
        startSort();
      });

      pauseBtn.addEventListener('click', ()=>{
        pause();
      });

      stepBtn.addEventListener('click', ()=>{
        if(running && !paused){
          // if running, pause then step
          pause();
        }
        if(actions.length === 0){
          // record actions for current array to enable stepping
          const snapshot = Array.from(barsEl.children).map(b => parseInt(b.title || b.textContent) || 0);
          let arrCopy = snapshot.slice();
          if(orderCheck.checked) arrCopy = arrCopy.map(v => 100 - v);
          recordMergeSort(arrCopy);
          actionIndex = 0;
          comparisons = 0; writes = 0;
        }
        doStep();
      });

      resetBtn.addEventListener('click', ()=>{
        stopAnimation();
        array = initialArray.slice();
        renderBars();
        actions = [];
        actionIndex = 0;
        comparisons = 0;
        writes = 0;
        updateStats();
        highlightCode(null);
      });

      sizeInput.addEventListener('input', ()=>{
        // update but don't start heavy re-render until user clicks generate
        // show a quick preview by generating small random array of new size
        createArray(Number(sizeInput.value));
        renderBars();
        actions = [];
        actionIndex = 0;
        comparisons = 0;
        writes = 0;
        updateStats();
      });

      // assist: when speed changes while running, restart timer with new delay
      speedInput.addEventListener('input', ()=>{
        if(running && !paused){
          if(timer) clearInterval(timer);
          play();
        }
      });

      // keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.key === ' '){ e.preventDefault(); if(running && !paused) pause(); else startSort(); }
        if(e.key === 's'){ stepBtn.click(); }
        if(e.key === 'r'){ generateBtn.click(); }
      });

      // initial call
      initialize();

      // Make sure bars update their title on write actions: since writes update elements directly in applyAction,
      // but at the start we also need titles to reflect numbers for proper Step recording later.
      // Ensure that after finishing recording, the actual DOM isn't left in inverted state for descending sorting:
      // We recorded using inverted values if descending; but we showed the original array. During applyAction overwrite actions
      // set heights to recorded values; to produce descending sort for the user we inverted values at recording time.
      // To keep UI consistent, we will, upon every overwrite, show the final visible value by inverting back when order checked.
      // To implement this, when applyAction sees overwrite or writeTemp and orderCheck.checked, it should invert displayed value.
      // That logic is implemented below by reading orderCheck.checked.

      // Update applyAction to account for descending visualization: we override it here with additional logic.
      // (We patch applyAction with closure capturing orderCheck)
      (function patchApplyActionForOrder(){
        const originalApply = applyAction;
        applyAction = function(act){
          // For overwrite/writeTemp, if orderCheck.checked, display inverted value so the user sees descending final order.
          const isDesc = orderCheck.checked;
          if((act.type === 'overwrite' || act.type === 'writeTemp') && isDesc){
            // act.value is in inverted domain (100 - original), so invert back for display:
            const displayVal = 100 - act.value;
            const patched = Object.assign({}, act, {value: displayVal});
            originalApply(patched);
          } else {
            originalApply(act);
          }
        };
      })();

    })();
  </script>
</body>
</html>