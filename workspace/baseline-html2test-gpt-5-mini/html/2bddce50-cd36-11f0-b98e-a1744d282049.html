<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive Singly Linked List Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#06b6d4;
      --muted:#94a3b8;
      --node:#0ea5a3;
      --node-ink:#042029;
      --danger:#ef4444;
      --success:#10b981;
    }
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#071026 0%, #071921 100%);
      color:#e6eef6;
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      max-width:1100px;
      margin:28px auto;
      padding:20px;
      border-radius:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
      min-height:540px;
      display:grid;
      grid-template-columns:1fr 360px;
      gap:18px;
    }

    header{
      grid-column:1 / -1;
      display:flex;
      gap:12px;
      align-items:center;
      margin-bottom:4px;
    }
    header h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
      color:var(--accent);
    }
    header p{ margin:0; color:var(--muted); font-size:13px;}

    .canvas{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:10px;
      padding:18px;
      min-height:420px;
      overflow:auto;
      position:relative;
      border:1px solid rgba(255,255,255,0.03);
    }

    .controls{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:10px;
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
      border:1px solid rgba(255,255,255,0.03);
      height:fit-content;
    }
    .controls label{ font-size:13px; color:var(--muted); }
    .row{ display:flex; gap:8px; align-items:center; }
    input[type="text"], input[type="number"], select{
      background:#06121a;
      border:1px solid rgba(255,255,255,0.03);
      color:#e6eef6;
      padding:8px 10px;
      border-radius:8px;
      outline:none;
      min-width:0;
    }
    input[type="text"]::placeholder{ color: #475569; }
    button{
      background:linear-gradient(180deg, #075b63, #04707a);
      color:white;
      border:none;
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      transition:transform 120ms ease, box-shadow 120ms;
      font-weight:600;
    }
    button.ghost{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      font-weight:600;
    }
    button.danger{
      background:linear-gradient(180deg,#ef4444,#dc2626);
    }
    .btn-row{ display:flex; gap:8px; flex-wrap:wrap; }

    /* Linked list nodes */
    .nodes{
      display:flex;
      gap:18px;
      align-items:center;
      padding:14px;
      flex-wrap:wrap;
      min-height:120px;
    }
    .node{
      width:110px;
      min-width:110px;
      height:64px;
      border-radius:10px;
      background:linear-gradient(180deg,var(--node), #0c9b9a);
      color:var(--node-ink);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      box-shadow: 0 6px 20px rgba(2,6,23,0.45);
      font-weight:700;
      font-size:18px;
    }
    .node .value{ z-index:2; }
    .node .meta{
      position:absolute; left:8px; top:6px;
      font-size:11px; color:rgba(0,0,0,0.25); font-weight:700;
    }
    .node.head{ box-shadow: 0 8px 28px rgba(3,166,166,0.12); outline:2px solid rgba(6,182,212,0.06); }
    .node.tail{ outline:2px solid rgba(16,185,129,0.06); }
    .node.highlight{ transform:scale(1.04); box-shadow:0 10px 30px rgba(6,182,212,0.12); }
    .node.found{ outline:3px solid rgba(253,224,71,0.16); box-shadow:0 12px 34px rgba(245,158,11,0.08); }

    .label{
      display:inline-block;
      padding:6px 10px;
      background:rgba(255,255,255,0.02);
      border-radius:8px;
      color:var(--muted);
      font-size:13px;
      margin-right:8px;
    }

    .status{
      margin-top:8px;
      color:var(--muted);
      font-size:13px;
    }

    svg.connectors{
      position:absolute;
      left:0; top:0;
      pointer-events:none;
      overflow:visible;
    }

    .info{
      font-size:13px;
      color:var(--muted);
      background:rgba(255,255,255,0.01);
      padding:8px;
      border-radius:8px;
    }

    .repr{
      margin-top:12px;
      color:#d7eef7;
      font-weight:600;
      font-size:14px;
      word-break:break-all;
    }

    footer{
      grid-column:1 / -1;
      margin-top:12px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      align-items:center;
    }

    .small{ font-size:12px; color:var(--muted); }
    .hint{ color:var(--muted); font-size:12px; margin-top:6px; }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Linked List Visualizer">
    <header>
      <div>
        <h1>Interactive Singly Linked List</h1>
        <p>Visually build and manipulate a singly linked list. Add, insert, delete, search, reverse, and step through nodes.</p>
      </div>
    </header>

    <main class="canvas" id="canvas" aria-live="polite">
      <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px;flex-wrap:wrap;">
        <span class="label">Head: <span id="head-label">null</span></span>
        <span class="label">Tail: <span id="tail-label">null</span></span>
        <span class="label">Size: <span id="size-label">0</span></span>
      </div>

      <div id="nodes-wrap" class="nodes" aria-hidden="false" tabindex="0"></div>

      <!-- SVG connectors overlay -->
      <svg id="svg" class="connectors" width="2000" height="800" aria-hidden="true"></svg>

      <div class="repr" id="repr">Empty list</div>
      <div class="status" id="status">Use the controls on the right to manipulate the list.</div>
    </main>

    <aside class="controls">
      <div>
        <label for="value-input">Node value</label>
        <div class="row">
          <input id="value-input" type="text" placeholder="e.g., 42 or hello" />
          <button id="add-tail">Push (tail)</button>
          <button id="add-head" class="ghost">Unshift (head)</button>
        </div>
      </div>

      <div>
        <label>Insert / Remove</label>
        <div class="row">
          <input id="index-input" type="number" placeholder="index" min="0" style="width:86px;" />
          <button id="insert-index" class="ghost">Insert at index</button>
          <button id="remove-index" class="danger">Remove at index</button>
        </div>
        <div class="row" style="margin-top:8px;">
          <input id="value-remove" type="text" placeholder="value to remove" />
          <button id="remove-value" class="danger">Remove value</button>
        </div>
      </div>

      <div>
        <label>Operations</label>
        <div class="btn-row">
          <button id="find" class="ghost">Find value</button>
          <button id="traverse" class="ghost">Traverse (step)</button>
          <button id="auto-traverse" class="ghost">Auto-play</button>
          <button id="reverse">Reverse</button>
        </div>
      </div>

      <div>
        <label>List actions</label>
        <div class="row">
          <button id="clear" class="danger">Clear list</button>
          <button id="fill-sample" class="ghost">Sample data</button>
        </div>
      </div>

      <div class="info">
        Tip: Use small lists for clarity. Indexing is zero-based. "Push" adds to tail; "Unshift" adds to head.
      </div>
    </aside>

    <footer>
      <div class="small">Singly Linked List demo â€” interactive learning</div>
      <div class="small">Visualization updates animate traversal and operations</div>
    </footer>
  </div>

<script>
/*
  Singly Linked List Visualizer
  - Single HTML file with inline JS that implements a simple singly linked list and renders nodes.
  - Supports push (tail), unshift (head), insert at index, remove at index, remove by value, find (search), traverse (step/auto-play), reverse, clear, fill sample.
  - Visualization uses DOM elements for nodes and an overlaid SVG for arrows.
*/

(function(){
  // Basic linked list implementation
  class ListNode {
    constructor(value){
      this.value = value;
      this.next = null;
    }
  }

  class SinglyLinkedList {
    constructor(){
      this.head = null;
      this.tail = null;
      this.length = 0;
    }

    push(value){
      const node = new ListNode(value);
      if(!this.head){
        this.head = this.tail = node;
      } else {
        this.tail.next = node;
        this.tail = node;
      }
      this.length++;
      return this;
    }

    unshift(value){
      const node = new ListNode(value);
      if(!this.head){
        this.head = this.tail = node;
      } else {
        node.next = this.head;
        this.head = node;
      }
      this.length++;
      return this;
    }

    insertAt(index, value){
      if(index < 0 || index > this.length) return false;
      if(index === 0) { this.unshift(value); return true; }
      if(index === this.length){ this.push(value); return true; }
      const node = new ListNode(value);
      let prev = this.head;
      for(let i=1;i<index;i++) prev = prev.next;
      node.next = prev.next;
      prev.next = node;
      this.length++;
      return true;
    }

    removeAt(index){
      if(index < 0 || index >= this.length || !this.head) return null;
      let removed;
      if(index === 0){
        removed = this.head;
        this.head = this.head.next;
        if(this.length === 1) this.tail = null;
      } else {
        let prev = this.head;
        for(let i=1;i<index;i++) prev = prev.next;
        removed = prev.next;
        prev.next = removed.next;
        if(index === this.length - 1) this.tail = prev;
      }
      this.length--;
      removed.next = null;
      return removed;
    }

    removeValue(value){
      if(!this.head) return null;
      if(this.head.value === value){
        const node = this.head;
        this.head = this.head.next;
        this.length--;
        if(this.length === 0) this.tail = null;
        node.next = null;
        return node;
      }
      let prev = this.head;
      while(prev.next && prev.next.value !== value) prev = prev.next;
      if(!prev.next) return null;
      const node = prev.next;
      prev.next = node.next;
      if(node === this.tail) this.tail = prev;
      this.length--;
      node.next = null;
      return node;
    }

    find(value){
      let idx = 0;
      let cur = this.head;
      while(cur){
        if(cur.value === value) return {node:cur, index:idx};
        cur = cur.next; idx++;
      }
      return null;
    }

    reverse(){
      let prev = null;
      let cur = this.head;
      this.tail = this.head;
      while(cur){
        const nxt = cur.next;
        cur.next = prev;
        prev = cur;
        cur = nxt;
      }
      this.head = prev;
    }

    toArray(){
      const arr = [];
      let cur = this.head;
      while(cur){ arr.push(cur.value); cur = cur.next; }
      return arr;
    }

    clear(){
      this.head = this.tail = null;
      this.length = 0;
    }
  }

  // DOM references
  const nodesWrap = document.getElementById('nodes-wrap');
  const svg = document.getElementById('svg');
  const headLabel = document.getElementById('head-label');
  const tailLabel = document.getElementById('tail-label');
  const sizeLabel = document.getElementById('size-label');
  const repr = document.getElementById('repr');
  const status = document.getElementById('status');

  const valueInput = document.getElementById('value-input');
  const indexInput = document.getElementById('index-input');
  const valueRemove = document.getElementById('value-remove');

  const addTailBtn = document.getElementById('add-tail');
  const addHeadBtn = document.getElementById('add-head');
  const insertIndexBtn = document.getElementById('insert-index');
  const removeIndexBtn = document.getElementById('remove-index');
  const removeValueBtn = document.getElementById('remove-value');
  const findBtn = document.getElementById('find');
  const traverseBtn = document.getElementById('traverse');
  const autoTraverseBtn = document.getElementById('auto-traverse');
  const reverseBtn = document.getElementById('reverse');
  const clearBtn = document.getElementById('clear');
  const sampleBtn = document.getElementById('fill-sample');

  // App state
  const list = new SinglyLinkedList();
  let traversalIndex = -1;
  let autoTraverseTimer = null;
  let traversalNodes = []; // cached DOM nodes during traversal

  // Utilities for rendering
  function setStatus(text, type){
    status.textContent = text;
    if(type === 'ok') status.style.color = 'var(--success)';
    else if(type === 'err') status.style.color = 'var(--danger)';
    else status.style.color = 'var(--muted)';
  }

  function clearSVG(){
    while(svg.firstChild) svg.removeChild(svg.firstChild);
  }

  function updateLabels(){
    headLabel.textContent = list.head ? String(list.head.value) : 'null';
    tailLabel.textContent = list.tail ? String(list.tail.value) : 'null';
    sizeLabel.textContent = list.length;
    const arr = list.toArray();
    repr.textContent = arr.length ? arr.join('  ->  ') : 'Empty list';
  }

  function render(){
    // Clear traversal state
    stopAutoTraverse();
    traversalIndex = -1;
    traversalNodes = [];

    // Clear existing node elements
    nodesWrap.innerHTML = '';
    clearSVG();

    // Create node DOM elements
    let cur = list.head;
    let idx = 0;
    while(cur){
      const el = document.createElement('div');
      el.className = 'node';
      el.dataset.index = idx;
      if(idx === 0) el.classList.add('head');
      if(idx === list.length - 1) el.classList.add('tail');

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.textContent = '#' + idx;

      const val = document.createElement('div');
      val.className = 'value';
      val.textContent = String(cur.value);

      el.appendChild(meta);
      el.appendChild(val);
      nodesWrap.appendChild(el);

      // Store a reference of the node for traversal animations
      el._listNode = cur;

      cur = cur.next;
      idx++;
    }

    updateLabels();
    layoutConnectors();
  }

  // Draw arrows between nodes using SVG paths
  function layoutConnectors(){
    clearSVG();
    const nodeEls = Array.from(nodesWrap.children);
    if(nodeEls.length === 0) return;

    // Resize svg to encompass nodesWrap bounding box
    const wrapRect = nodesWrap.getBoundingClientRect();
    svg.style.width = Math.max(wrapRect.width + 200, 1000) + 'px';
    svg.style.height = Math.max(wrapRect.height + 200, 300) + 'px';
    svg.setAttribute('width', wrapRect.width + 200);
    svg.setAttribute('height', wrapRect.height + 200);

    // For each consecutive pair, draw a curved arrow
    nodeEls.forEach((el, i) => {
      if(i === nodeEls.length - 1) return;
      const a = el.getBoundingClientRect();
      const b = nodeEls[i+1].getBoundingClientRect();

      // Coordinates relative to svg (which is positioned at top-left of document)
      const svgRect = svg.getBoundingClientRect();
      const startX = a.right - svgRect.left - 6;
      const startY = a.top + a.height / 2 - svgRect.top;
      const endX = b.left - svgRect.left + 6;
      const endY = b.top + b.height / 2 - svgRect.top;

      // Create a path with a gentle cubic curve
      const dx = Math.max(36, (endX - startX) / 2);
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      const d = `M ${startX} ${startY} C ${startX + dx} ${startY} ${endX - dx} ${endY} ${endX} ${endY}`;
      path.setAttribute('d', d);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'rgba(255,255,255,0.08)');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('stroke-linecap', 'round');

      // Arrowhead marker
      const markerId = 'arrowhead';
      if(!document.getElementById(markerId)){
        const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
        marker.setAttribute('id', markerId);
        marker.setAttribute('markerWidth', '6');
        marker.setAttribute('markerHeight', '6');
        marker.setAttribute('refX', '6');
        marker.setAttribute('refY', '3');
        marker.setAttribute('orient', 'auto');
        marker.setAttribute('markerUnits', 'strokeWidth');
        const polygon = document.createElementNS('http://www.w3.org/2000/svg','path');
        polygon.setAttribute('d','M 0 0 L 6 3 L 0 6 z');
        polygon.setAttribute('fill','rgba(255,255,255,0.12)');
        marker.appendChild(polygon);
        // Append to defs
        let defs = svg.querySelector('defs');
        if(!defs){ defs = document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.appendChild(defs); }
        defs.appendChild(marker);
      }
      path.setAttribute('marker-end','url(#arrowhead)');

      svg.appendChild(path);
    });
  }

  // Helper to animate a node (highlight briefly)
  function pulseNodeByIndex(ix, klass='highlight', ms=700){
    const el = nodesWrap.querySelector('.node[data-index="'+ix+'"]');
    if(!el) return;
    el.classList.add(klass);
    setTimeout(()=> el.classList.remove(klass), ms);
  }

  // Find node DOM by index and scroll into view a bit
  function focusNode(ix){
    const el = nodesWrap.querySelector('.node[data-index="'+ix+'"]');
    if(!el) return;
    el.scrollIntoView({behavior:'smooth', inline:'center', block:'nearest'});
  }

  // Operation implementations with UI feedback and rendering
  function pushValue(val){
    if(val === ''){ setStatus('Provide a value to push.', 'err'); return; }
    list.push(val);
    render();
    setStatus('Pushed "'+val+'" to tail.', 'ok');
  }
  function unshiftValue(val){
    if(val === ''){ setStatus('Provide a value to unshift.', 'err'); return; }
    list.unshift(val);
    render();
    setStatus('Unshifted "'+val+'" to head.', 'ok');
  }
  function insertAtIndex(idx, val){
    if(!Number.isFinite(idx) || idx < 0){ setStatus('Provide a valid index.', 'err'); return; }
    if(val === ''){ setStatus('Provide a value to insert.', 'err'); return; }
    const success = list.insertAt(idx, val);
    if(!success){ setStatus('Index out of bounds.', 'err'); return; }
    render();
    setStatus('Inserted "'+val+'" at index ' + idx + '.', 'ok');
    pulseNodeByIndex(idx);
    focusNode(idx);
  }
  function removeAtIndex(ix){
    if(!Number.isFinite(ix) || ix < 0 || ix >= list.length){ setStatus('Invalid index to remove.', 'err'); return; }
    const node = list.removeAt(ix);
    render();
    setStatus('Removed "'+node.value+'" at index ' + ix + '.', 'ok');
  }
  function removeByValue(v){
    if(v === ''){ setStatus('Provide a value to remove.', 'err'); return; }
    const node = list.removeValue(v);
    if(!node){ setStatus('Value "'+v+'" not found.', 'err'); return; }
    render();
    setStatus('Removed first occurrence of "'+v+'".', 'ok');
  }

  function findValue(v){
    if(v === ''){ setStatus('Enter a value to find.', 'err'); return; }
    const res = list.find(v);
    if(!res){ setStatus('Value "'+v+'" not found.', 'err'); return; }
    // visually highlight found node
    render();
    const el = nodesWrap.querySelector('.node[data-index="'+res.index+'"]');
    if(el){
      el.classList.add('found');
      focusNode(res.index);
      setTimeout(()=> el.classList.remove('found'), 1400);
    }
    setStatus('Found "'+v+'" at index ' + res.index + '.', 'ok');
  }

  // Traversal stepper
  function startTraverse(){
    if(list.length === 0){ setStatus('List is empty.', 'err'); return; }
    traversalIndex = -1;
    traversalNodes = Array.from(nodesWrap.querySelectorAll('.node'));
    setStatus('Traversal started. Click "Traverse (step)" to move next or Auto-play.', 'ok');
    // Clear previous highlights
    traversalNodes.forEach(n => n.classList.remove('highlight'));
  }

  function stepTraverse(){
    if(!traversalNodes || traversalNodes.length === 0){
      setStatus('Start traversal first.', 'err'); return;
    }
    traversalIndex++;
    if(traversalIndex >= traversalNodes.length){
      setStatus('Traversal finished.', 'ok');
      traversalIndex = traversalNodes.length - 1;
      return;
    }
    traversalNodes.forEach(n => n.classList.remove('highlight'));
    const current = traversalNodes[traversalIndex];
    current.classList.add('highlight');
    focusNode(traversalIndex);
    setStatus('Visiting index ' + traversalIndex + ' (value: ' + current.querySelector('.value').textContent + ')', 'ok');
  }

  function autoTraverse(){
    if(list.length === 0){ setStatus('List is empty.', 'err'); return; }
    if(autoTraverseTimer){ stopAutoTraverse(); return; }
    startTraverse();
    autoTraverseTimer = setInterval(()=>{
      stepTraverse();
      if(traversalIndex >= traversalNodes.length - 1){
        stopAutoTraverse();
        setStatus('Auto-traversal finished.', 'ok');
      }
    }, 700);
    autoTraverseBtn.textContent = 'Stop auto';
    setStatus('Auto-traversal started.', 'ok');
  }

  function stopAutoTraverse(){
    if(autoTraverseTimer){
      clearInterval(autoTraverseTimer);
      autoTraverseTimer = null;
    }
    autoTraverseBtn.textContent = 'Auto-play';
    traversalIndex = -1;
  }

  // Reverse
  function reverseList(){
    if(list.length <= 1){ setStatus('List too small to reverse.', 'err'); return; }
    // animate: highlight then reverse
    const nodeEls = Array.from(nodesWrap.children);
    nodeEls.forEach((n,i)=> setTimeout(()=> n.classList.add('highlight'), i*80));
    setTimeout(()=>{
      list.reverse();
      render();
      setStatus('List reversed.', 'ok');
    }, nodeEls.length * 80 + 220);
  }

  function clearList(){
    list.clear();
    render();
    setStatus('List cleared.', 'ok');
  }

  function fillSample(){
    list.clear();
    const samples = ['A','B','C','D','E'];
    samples.forEach(s => list.push(s));
    render();
    setStatus('Sample data filled.', 'ok');
  }

  // Event wiring
  addTailBtn.addEventListener('click', ()=> {
    pushValue(valueInput.value.trim());
    valueInput.focus();
  });

  addHeadBtn.addEventListener('click', ()=> {
    unshiftValue(valueInput.value.trim());
    valueInput.focus();
  });

  insertIndexBtn.addEventListener('click', ()=> {
    const idx = Number(indexInput.value);
    insertAtIndex(idx, valueInput.value.trim());
    indexInput.value = '';
    valueInput.focus();
  });

  removeIndexBtn.addEventListener('click', ()=> {
    const ix = Number(indexInput.value);
    if(Number.isNaN(ix)){ setStatus('Enter index to remove.', 'err'); return; }
    removeAtIndex(ix);
    indexInput.value = '';
  });

  removeValueBtn.addEventListener('click', ()=> {
    removeByValue(valueRemove.value.trim());
    valueRemove.value = '';
  });

  findBtn.addEventListener('click', ()=> {
    const v = valueInput.value.trim();
    if(v === '') setStatus('Enter a value to find in the top input.', 'err');
    findValue(v);
  });

  traverseBtn.addEventListener('click', ()=> {
    // Start traversal if not started
    if(traversalIndex === -1 || traversalNodes.length === 0){
      startTraverse();
    }
    stepTraverse();
  });

  autoTraverseBtn.addEventListener('click', ()=> {
    autoTraverse();
  });

  reverseBtn.addEventListener('click', ()=> {
    reverseList();
  });

  clearBtn.addEventListener('click', ()=> {
    clearList();
  });

  sampleBtn.addEventListener('click', ()=> {
    fillSample();
  });

  // Re-layout connectors on window resize to keep arrows consistent
  let resizeTimer = null;
  window.addEventListener('resize', ()=> {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(layoutConnectors, 120);
  });

  // Initial render
  render();
  setStatus('Ready. Try pushing some nodes!', 'ok');

  // Accessibility: allow Enter key to push
  valueInput.addEventListener('keydown', (e)=> {
    if(e.key === 'Enter'){
      pushValue(valueInput.value.trim());
      e.preventDefault();
    }
  });

  // Small helper: animate connector layout whenever DOM changes (MutationObserver)
  const observer = new MutationObserver(()=> {
    layoutConnectors();
  });
  observer.observe(nodesWrap, {childList:true, subtree:true});

})();
</script>
</body>
</html>