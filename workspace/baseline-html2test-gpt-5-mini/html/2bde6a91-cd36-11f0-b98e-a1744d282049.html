<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Prim's Algorithm Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --muted:#95a0b5;
      --accent:#3b82f6;
      --good:#10b981;
      --warn:#f59e0b;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.04);
      --card-radius:10px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#041028 0%,#061530 60%);color:#e6eef8;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    .wrap{display:flex;gap:16px;padding:18px;box-sizing:border-box;height:100%;}
    .left{flex:1;display:flex;flex-direction:column;gap:12px;}
    .canvasCard{background:var(--panel);border-radius:var(--card-radius);padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);display:flex;flex-direction:column;gap:8px;}
    #svgCanvas{width:100%;height:640px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02) 0%, rgba(255,255,255,0.01) 100%);touch-action:none;}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
    .controls > *{background:var(--glass);border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:8px;color:var(--muted);font-weight:600;}
    button.controlBtn{cursor:pointer;color:#e6eef8;background:linear-gradient(180deg,rgba(255,255,255,0.02), rgba(255,255,255,0));border:none;padding:8px 12px;border-radius:8px;}
    button.controlBtn:active{transform:translateY(1px);}
    .small{font-size:13px;padding:6px 10px;}
    .sliders{display:flex;gap:8px;align-items:center;}
    .panelRight{width:360px;display:flex;flex-direction:column;gap:12px;}
    .card{background:var(--panel);border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.55);}
    .title{font-size:14px;color:#d7e3f4;font-weight:700;margin-bottom:8px;}
    .muted{color:var(--muted);font-size:13px;}
    .table{display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;}
    .cell{padding:6px;border-radius:6px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted);display:flex;justify-content:space-between;align-items:center;}
    .key{font-family:var(--mono);font-weight:700;color:#eaf2ff;}
    .legend{display:flex;gap:8px;flex-wrap:wrap;}
    .legendItem{display:flex;gap:6px;align-items:center;font-size:13px;color:var(--muted);}
    .dot{width:16px;height:10px;border-radius:4px;}
    footer{opacity:0.7;font-size:12px;color:var(--muted);margin-top:6px;}
    .weightTag{font-family:var(--mono);font-size:12px;fill:#d6e9ff;stroke:#001;stroke-width:0.2;}
    .nodeLabel{font-family:var(--mono);font-size:12px;fill:#eaf2ff;text-anchor:middle;dominant-baseline:central;pointer-events:none;}
    .edgeLine{stroke:#7b8da6;stroke-opacity:0.35;stroke-width:2;}
    .edgeLabelBG{fill:#091226;opacity:0.85;rx:4;ry:4;}
    .buttonRow{display:flex;gap:8px;flex-wrap:wrap;}
    .infoRow{display:flex;justify-content:space-between;align-items:center;}
    input[type=range]{accent-color:var(--accent);width:140px;}
    .smallmuted{font-size:12px;color:var(--muted);}
    .highlight{outline:2px solid rgba(59,130,246,0.18);border-radius:8px;padding:6px;}
    @media (max-width:980px){.wrap{flex-direction:column}.panelRight{width:100%}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="left">
      <div class="canvasCard">
        <div class="controls">
          <div style="display:flex;gap:8px;align-items:center;">
            <label class="muted">Nodes</label>
            <input id="nodeCount" type="range" min="4" max="20" value="10" />
            <span id="nodeCountVal" class="smallmuted">10</span>
          </div>
          <div style="display:flex;gap:8px;align-items:center;">
            <label class="muted">Density</label>
            <input id="density" type="range" min="0" max="100" value="45" />
            <span id="densityVal" class="smallmuted">45%</span>
          </div>
          <div class="sliders">
            <label class="muted">Weight</label>
            <input id="minW" type="number" value="1" style="width:64px;border-radius:6px;padding:6px;background:var(--glass);border:none;color:var(--muted)"/>
            <input id="maxW" type="number" value="20" style="width:64px;border-radius:6px;padding:6px;background:var(--glass);border:none;color:var(--muted)"/>
          </div>
          <button id="genBtn" class="controlBtn small">Generate Graph</button>
          <button id="resetBtn" class="controlBtn small">Reset</button>
        </div>

        <svg id="svgCanvas" viewBox="0 0 1000 640" preserveAspectRatio="xMidYMid meet"></svg>

        <div class="controls" style="justify-content:space-between;">
          <div class="buttonRow">
            <button id="startBtn" class="controlBtn small">Start Prim</button>
            <button id="stepBtn" class="controlBtn small">Step</button>
            <button id="playBtn" class="controlBtn small">Play</button>
            <button id="pauseBtn" class="controlBtn small" disabled>Pause</button>
            <label class="muted">Speed</label>
            <input id="speed" type="range" min="100" max="2000" value="700"/>
            <span id="status" class="muted">Click a node to choose start (or press Start to pick random)</span>
          </div>
          <div class="muted smallmuted">Click a node to set start. Hover edges to view weight.</div>
        </div>
      </div>

      <div class="card" style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
        <div>
          <div class="title">Current MST</div>
          <div class="muted">Total Weight: <span id="totalWeight" class="key">0</span></div>
        </div>
        <div>
          <div class="title">Algorithm</div>
          <div class="muted">Selected: <span id="selectedCount" class="key">0</span> / <span id="needCount" class="key">0</span></div>
        </div>
      </div>

      <div class="card">
        <div class="title">Legend</div>
        <div class="legend">
          <div class="legendItem"><div class="dot" style="background:#e6eef8;"></div>Node (unvisited)</div>
          <div class="legendItem"><div class="dot" style="background:#10b981;"></div>In MST</div>
          <div class="legendItem"><div class="dot" style="background:#f59e0b;"></div>Currently chosen</div>
          <div class="legendItem"><div class="dot" style="background:#60a5fa;"></div>Candidate edge (best for a node)</div>
          <div class="legendItem"><div class="dot" style="background:#a0aec0;"></div>Normal edge</div>
        </div>
        <footer>Prim's algorithm grows a tree by always attaching the minimum-weight edge crossing the cut.</footer>
      </div>
    </div>

    <div class="panelRight">
      <div class="card">
        <div class="title">Vertex Keys (key = best edge weight to MST)</div>
        <div id="vertexTable" class="table" style="margin-top:8px;"></div>
      </div>

      <div class="card">
        <div class="title">Edges in MST</div>
        <div id="mstList" class="muted" style="max-height:240px;overflow:auto;padding-top:6px;"></div>
      </div>

      <div class="card">
        <div class="title">How to use</div>
        <div class="muted" style="line-height:1.4;">
          - Generate a random weighted graph. Click any node to pick starting node before starting.<br/>
          - Press "Start Prim" to initialize. Use "Step" to advance one vertex, or "Play" to animate.<br/>
          - Watch the keys (best candidate edge for each non-MST node) and the MST edges update live.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // Canvas and graph data
  const svg = document.getElementById('svgCanvas');
  const nodeCountSlider = document.getElementById('nodeCount');
  const nodeCountVal = document.getElementById('nodeCountVal');
  const densitySlider = document.getElementById('density');
  const densityVal = document.getElementById('densityVal');
  const genBtn = document.getElementById('genBtn');
  const resetBtn = document.getElementById('resetBtn');
  const startBtn = document.getElementById('startBtn');
  const stepBtn = document.getElementById('stepBtn');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const speedSlider = document.getElementById('speed');
  const status = document.getElementById('status');
  const totalWeightEl = document.getElementById('totalWeight');
  const selectedCountEl = document.getElementById('selectedCount');
  const needCountEl = document.getElementById('needCount');
  const vertexTable = document.getElementById('vertexTable');
  const mstList = document.getElementById('mstList');
  const minWInput = document.getElementById('minW');
  const maxWInput = document.getElementById('maxW');

  nodeCountVal.textContent = nodeCountSlider.value;
  densityVal.textContent = densitySlider.value + '%';

  // Graph storage
  let W = []; // adjacency weight matrix, Infinity means no edge
  let nodes = []; // {id,x,y,svgGroup}
  let edges = {}; // key "u-v" -> {u,v,w,svgLine,svgLabel,svgLabelBG}
  let nodeCount = parseInt(nodeCountSlider.value);

  // Prim state
  let inMST = [];
  let key = [];
  let parent = [];
  let started = false;
  let startNode = null;
  let selectedCount = 0;
  let intervalHandle = null;
  let animLock = false; // prevent overlapping animations

  // Responsive scaling
  const viewW = 1000, viewH = 640;

  function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function clearSVG(){
    while(svg.firstChild) svg.removeChild(svg.firstChild);
  }

  function makeGraph(n, densityPercent, wmin, wmax){
    clearSVG();
    nodes = [];
    W = Array.from({length:n},()=>Array(n).fill(Infinity));
    edges = {};
    // random positions with padding
    const pad = 60;
    const cols = Math.ceil(Math.sqrt(n));
    for(let i=0;i<n;i++){
      const cx = rand(pad, viewW-pad);
      const cy = rand(pad, viewH-pad);
      nodes.push({id:i,x:cx,y:cy});
    }
    // ensure connected: generate random spanning tree first
    const order = nodes.map((_,i)=>i).sort(()=>Math.random()-0.5);
    for(let i=1;i<n;i++){
      const a = order[i];
      const b = order[rand(0,i-1)];
      const w = rand(wmin,wmax);
      addEdge(a,b,w);
    }
    // add extra edges per density
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        if(W[i][j]<Infinity) continue; // already edge from spanning tree
        if(Math.random()*100 < densityPercent){
          addEdge(i,j, rand(wmin,wmax));
        }
      }
    }
    // draw edges then nodes
    drawEdges();
    drawNodes();
    nodeCount = n;
    resetState();
  }

  function addEdge(u,v,w){
    W[u][v]=W[v][u]=w;
    const key = edgeKey(u,v);
    edges[key] = {u,v,w};
  }

  function edgeKey(a,b){ return (a<b)? a+'-'+b : b+'-'+a; }

  function drawEdges(){
    // draw straight lines and weight labels
    Object.values(edges).forEach(e=>{
      const {u,v,w} = e;
      const nu = nodes[u], nv = nodes[v];
      // line
      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute('x1',nu.x); line.setAttribute('y1',nu.y);
      line.setAttribute('x2',nv.x); line.setAttribute('y2',nv.y);
      line.setAttribute('class','edgeLine');
      line.setAttribute('data-key',edgeKey(u,v));
      svg.appendChild(line);
      // midpoint label group
      const mx = (nu.x+nv.x)/2, my = (nu.y+nv.y)/2;
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute('transform',`translate(${mx},${my})`);
      // background rect
      const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
      bg.setAttribute('x',-18); bg.setAttribute('y',-12); bg.setAttribute('width',36); bg.setAttribute('height',20);
      bg.setAttribute('class','edgeLabelBG');
      bg.setAttribute('rx',4);
      g.appendChild(bg);
      // text
      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute('class','weightTag');
      t.textContent = w;
      g.appendChild(t);
      svg.appendChild(g);
      e.svgLine = line; e.svgLabel = t; e.svgLabelBG = bg;
      // hover interaction
      line.addEventListener('mouseenter', ()=> {
        e.svgLine.style.strokeOpacity = 1; e.svgLine.style.strokeWidth = 3.2;
      });
      line.addEventListener('mouseleave', ()=> {
        e.svgLine.style.strokeOpacity = 0.35; e.svgLine.style.strokeWidth = 2;
      });
    });
  }

  function drawNodes(){
    nodes.forEach(n=>{
      // group for circle + label
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute('transform', `translate(${n.x},${n.y})`);
      g.style.cursor = 'pointer';
      // circle
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute('r',12);
      c.setAttribute('fill','#e6eef8');
      c.setAttribute('stroke','#021428');
      c.setAttribute('stroke-width',2);
      g.appendChild(c);
      // label
      const l = document.createElementNS("http://www.w3.org/2000/svg","text");
      l.setAttribute('class','nodeLabel');
      l.textContent = n.id;
      g.appendChild(l);
      svg.appendChild(g);
      n.svgGroup = g;
      n.svgCircle = c;
      n.svgLabel = l;
      g.addEventListener('click',(ev)=>{
        if(started) return;
        setStartNode(n.id);
      });
      // drag support (optional)
      let dragging=false, ox=0,oy=0;
      g.addEventListener('pointerdown',(e)=>{
        dragging=true; ox=e.clientX; oy=e.clientY;
        g.setPointerCapture(e.pointerId);
      });
      window.addEventListener('pointerup', (e)=>{ if(dragging){ dragging=false; }});
      window.addEventListener('pointermove', (e)=>{
        if(!dragging) return;
        const dx = e.clientX - ox, dy = e.clientY - oy;
        ox = e.clientX; oy = e.clientY;
        // translate relative to viewbox scale: we used fixed viewBox so screen pixels map to viewBox 1000x640 proportionally
        const bbox = svg.getBoundingClientRect();
        const scaleX = viewW / bbox.width;
        const scaleY = viewH / bbox.height;
        n.x += dx*scaleX; n.y += dy*scaleY;
        // limit to padding
        n.x = Math.max(40, Math.min(viewW-40, n.x));
        n.y = Math.max(40, Math.min(viewH-40, n.y));
        // update rendering
        updateAllPositions();
      });
    });
    updateAllPositions();
  }

  function updateAllPositions(){
    // update edges and node groups
    Object.values(edges).forEach(e=>{
      const nu = nodes[e.u], nv = nodes[e.v];
      e.svgLine.setAttribute('x1',nu.x); e.svgLine.setAttribute('y1',nu.y);
      e.svgLine.setAttribute('x2',nv.x); e.svgLine.setAttribute('y2',nv.y);
      const mx = (nu.x+nv.x)/2, my = (nu.y+nv.y)/2;
      const g = e.svgLabel.parentNode;
      g.setAttribute('transform',`translate(${mx},${my})`);
    });
    nodes.forEach(n=>{
      n.svgGroup.setAttribute('transform',`translate(${n.x},${n.y})`);
    });
  }

  function resetState(){
    inMST = Array(nodeCount).fill(false);
    key = Array(nodeCount).fill(Infinity);
    parent = Array(nodeCount).fill(-1);
    started = false;
    startNode = null;
    selectedCount = 0;
    totalWeightEl.textContent = '0';
    selectedCountEl.textContent = '0';
    needCountEl.textContent = (nodeCount-1).toString();
    vertexTable.innerHTML = '';
    mstList.innerHTML = '';
    status.textContent = 'Click a node to choose start (or press Start to pick random)';
    // reset visuals
    Object.values(edges).forEach(e=>{
      e.svgLine.style.stroke = '#7b8da6'; e.svgLine.style.strokeOpacity = 0.35; e.svgLine.style.strokeWidth = 2;
    });
    nodes.forEach(n=>{
      n.svgCircle.setAttribute('fill','#e6eef8');
      n.svgLabel.style.fill = '#001826';
    });
    if(intervalHandle){ clearInterval(intervalHandle); intervalHandle = null; }
    pauseBtn.disabled = true; playBtn.disabled = false;
  }

  function setStartNode(i){
    startNode = i;
    status.textContent = 'Chosen start node: ' + i;
    // highlight
    nodes.forEach(n=> n.svgCircle.setAttribute('stroke','#021428'));
    nodes[i].svgCircle.setAttribute('stroke','#ffd166');
    nodes[i].svgCircle.setAttribute('stroke-width','3');
  }

  // UI bindings
  nodeCountSlider.addEventListener('input', ()=> { nodeCountVal.textContent = nodeCountSlider.value; });
  densitySlider.addEventListener('input', ()=> { densityVal.textContent = densitySlider.value + '%'; });
  genBtn.addEventListener('click', ()=> {
    const n = parseInt(nodeCountSlider.value);
    const den = parseInt(densitySlider.value);
    const wmin = parseInt(minWInput.value)||1;
    const wmax = parseInt(maxWInput.value)||20;
    makeGraph(n, den, wmin, wmax);
  });
  resetBtn.addEventListener('click', ()=> { resetState(); });

  startBtn.addEventListener('click', ()=> {
    if(Object.keys(edges).length === 0){ status.textContent = 'Generate a graph first.'; return; }
    if(started){ status.textContent = 'Prim already started.'; return; }
    if(startNode===null) startNode = rand(0,nodeCount-1);
    initPrim(startNode);
  });

  stepBtn.addEventListener('click', async ()=> {
    if(!started){ status.textContent = 'Start Prim first.'; return; }
    if(animLock){ return; }
    await primStep();
  });

  playBtn.addEventListener('click', ()=> {
    if(!started){ status.textContent = 'Start Prim first.'; return; }
    if(intervalHandle) return;
    playBtn.disabled = true; pauseBtn.disabled = false;
    intervalHandle = setInterval(async ()=>{
      if(animLock) return;
      if(selectedCount >= nodeCount-1){
        clearInterval(intervalHandle); intervalHandle=null; playBtn.disabled=false; pauseBtn.disabled=true;
        status.textContent = 'Done. MST complete.';
        return;
      }
      await primStep();
    }, Math.max(100, parseInt(speedSlider.value)));
  });

  pauseBtn.addEventListener('click', ()=> {
    if(intervalHandle){ clearInterval(intervalHandle); intervalHandle=null; }
    playBtn.disabled=false; pauseBtn.disabled=true;
  });

  // Initialize prim
  function initPrim(s){
    started = true;
    inMST = Array(nodeCount).fill(false);
    key = Array(nodeCount).fill(Infinity);
    parent = Array(nodeCount).fill(-1);
    key[s]=0;
    parent[s]=-1;
    selectedCount = 0;
    totalWeightEl.textContent = '0';
    selectedCountEl.textContent = '0';
    needCountEl.textContent = (nodeCount-1).toString();
    status.textContent = 'Prim initialized. Start at node ' + s + '. Use Step/Play.';
    // visual
    nodes.forEach(n=> {
      n.svgCircle.setAttribute('fill','#e6eef8');
      n.svgCircle.setAttribute('stroke','#021428');
      n.svgCircle.setAttribute('stroke-width','2');
      n.svgLabel.style.fill = '#001826';
    });
    nodes[s].svgCircle.setAttribute('fill','#e6eef8');
    nodes[s].svgCircle.setAttribute('stroke','#ffd166');
    nodes[s].svgCircle.setAttribute('stroke-width','3');
    updateVertexTable();
    updateEdgeStyles();
  }

  // find minimum key vertex not in MST
  function extractMinIndex(){
    let min = Infinity, idx = -1;
    for(let v=0;v<nodeCount;v++){
      if(!inMST[v] && key[v] < min){
        min = key[v]; idx = v;
      }
    }
    return idx;
  }

  // update candidate edges style: for each v not inMST if parent[v]!=-1 highlight edge parent->v as candidate
  function updateEdgeStyles(){
    // reset
    Object.values(edges).forEach(e=>{
      e.svgLine.style.stroke = '#7b8da6';
      e.svgLine.style.strokeOpacity = 0.35;
      e.svgLine.style.strokeWidth = 2;
    });
    // candidate edges
    for(let v=0; v<nodeCount; v++){
      if(inMST[v]) continue;
      const p = parent[v];
      if(p>=0){
        const k = edgeKey(p,v);
        const e = edges[k];
        if(e){
          e.svgLine.style.stroke = '#60a5fa';
          e.svgLine.style.strokeOpacity = 1;
          e.svgLine.style.strokeWidth = 3;
        }
      }
    }
    // MST edges green
    Array.from(mstList.children).forEach(li=>{
      const pair = li.getAttribute('data-edge');
      if(pair){
        const [u,v] = pair.split('-').map(x=>parseInt(x));
        const e = edges[edgeKey(u,v)];
        if(e){ e.svgLine.style.stroke = '#10b981'; e.svgLine.style.strokeOpacity = 1; e.svgLine.style.strokeWidth = 3.6; }
      }
    });
  }

  // single Prim step
  async function primStep(){
    animLock = true;
    // pick min key
    const u = extractMinIndex();
    if(u === -1){
      status.textContent = 'No reachable vertex remained. MST complete or graph disconnected.';
      animLock = false;
      return;
    }
    // visually mark selected node as current
    status.textContent = 'Selecting vertex ' + u + ' with key=' + (key[u]===Infinity?'∞':key[u]);
    const prevStroke = nodes[u].svgCircle.getAttribute('stroke');
    nodes[u].svgCircle.setAttribute('stroke','#f59e0b'); nodes[u].svgCircle.setAttribute('stroke-width','3.5');
    // if it has a parent, highlight the edge chosen
    if(parent[u] !== -1){
      const e = edges[edgeKey(parent[u], u)];
      if(e){
        // highlight chosen edge (orange) briefly
        e.svgLine.style.stroke = '#f59e0b';
        e.svgLine.style.strokeOpacity = 1; e.svgLine.style.strokeWidth = 4;
        await sleep( Math.max(120, parseInt(speedSlider.value)/3) );
        // finalize as MST edge (green)
        const li = document.createElement('div');
        li.textContent = `${parent[u]} — ${u}  (w=${e.w})`;
        li.setAttribute('data-edge', `${parent[u]}-${u}`);
        li.style.padding = '6px';
        li.style.background = 'rgba(255,255,255,0.02)';
        li.style.borderRadius = '6px';
        li.style.fontSize = '13px';
        mstList.appendChild(li);
        // update visuals
        e.svgLine.style.stroke = '#10b981'; e.svgLine.style.strokeWidth = 3.6; e.svgLine.style.strokeOpacity = 1;
        totalWeightEl.textContent = (parseInt(totalWeightEl.textContent)+e.w).toString();
        selectedCount++;
        selectedCountEl.textContent = selectedCount.toString();
      }
    } else {
      // starting node
      await sleep( Math.max(100, parseInt(speedSlider.value)/6) );
    }

    // include u in MST
    inMST[u] = true;
    nodes[u].svgCircle.setAttribute('fill','#10b981');
    nodes[u].svgLabel.style.fill = '#021428';
    nodes[u].svgCircle.setAttribute('stroke','#025a3e');
    nodes[u].svgCircle.setAttribute('stroke-width','2');

    // relax edges from u
    // for each neighbor v
    for(let v=0; v<nodeCount; v++){
      if(W[u][v] < Infinity && !inMST[v]){
        if(W[u][v] < key[v]){
          key[v] = W[u][v];
          parent[v] = u;
          // small visual update: highlight the updating edge
          const e = edges[edgeKey(u,v)];
          if(e){
            e.svgLine.style.stroke = '#60a5fa'; e.svgLine.style.strokeOpacity = 1; e.svgLine.style.strokeWidth = 3.2;
            await sleep( Math.max(50, parseInt(speedSlider.value)/6) );
          }
        }
      }
    }

    updateVertexTable();
    updateEdgeStyles();

    // check finish
    if(selectedCount >= nodeCount-1){
      status.textContent = 'MST complete!';
      animLock = false;
      if(intervalHandle){ clearInterval(intervalHandle); intervalHandle=null; playBtn.disabled=false; pauseBtn.disabled=true; }
      return;
    }
    status.textContent = `Added ${u} to MST. ${selectedCount} edges chosen so far.`;
    animLock = false;
  }

  function sleep(ms){ return new Promise(res=>setTimeout(res,ms)); }

  function updateVertexTable(){
    vertexTable.innerHTML = '';
    // headers
    for(let i=0;i<nodeCount;i++){
      const div = document.createElement('div');
      div.className='cell'; div.style.fontWeight='700';
      div.textContent = i;
      vertexTable.appendChild(div);
    }
    for(let i=0;i<nodeCount;i++){
      const div = document.createElement('div'); div.className='cell';
      div.textContent = inMST[i] ? 'in MST' : (key[i]===Infinity ? '∞' : key[i]);
      if(!inMST[i] && key[i]!==Infinity) div.style.color = '#eaf2ff';
      vertexTable.appendChild(div);
    }
    for(let i=0;i<nodeCount;i++){
      const div = document.createElement('div'); div.className='cell';
      div.textContent = parent[i]===-1 ? '-' : parent[i];
      vertexTable.appendChild(div);
    }
  }

  // initial random graph
  makeGraph(nodeCount, parseInt(densitySlider.value), parseInt(minWInput.value), parseInt(maxWInput.value));

  // convenience: space to start step
  window.addEventListener('keydown', (e)=>{
    if(e.key === ' '){ e.preventDefault(); if(!started) startBtn.click(); else stepBtn.click(); }
    if(e.key === 'p'){ playBtn.click(); }
    if(e.key === 'o'){ pauseBtn.click(); }
  });

  // Small touch: show disconnected nodes if any (not necessary because we ensured connectivity)
})();
</script>
</body>
</html>