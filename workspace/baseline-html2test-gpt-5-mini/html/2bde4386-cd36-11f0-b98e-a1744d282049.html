<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Merge Sort Visualizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --muted:#94a3b8;
    --accent:#06b6d4;
    --bar:#3b82f6;
    --compare:#f97316;
    --write:#ef4444;
    --merged:#10b981;
    --text:#e6eef8;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071027);font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  .container{max-width:1100px;margin:20px auto;padding:18px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 6px 30px rgba(2,6,23,0.6);}
  h1{color:var(--text);margin:0 0 10px;font-size:20px;}
  .top{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:12px;}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
  .btn{background:var(--panel);color:var(--text);border:1px solid rgba(255,255,255,0.03);padding:8px 12px;border-radius:8px;cursor:pointer;}
  .btn:hover{filter:brightness(1.05)}
  .btn:active{transform:translateY(1px)}
  .sliderRow{display:flex;align-items:center;gap:8px;color:var(--muted);font-size:13px;}
  input[type=range]{accent-color:var(--accent);cursor:pointer}
  .stats{margin-left:auto;color:var(--muted);font-size:13px;display:flex;gap:12px;align-items:center;}
  .visualArea{height:320px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.007),rgba(255,255,255,0.003));padding:12px;margin-top:12px;display:flex;align-items:flex-end;overflow:hidden;position:relative;}
  .bar{flex:1 1 auto;margin:0 2px;background:var(--bar);height:40px;border-radius:4px;display:flex;align-items:flex-end;justify-content:center;color:transparent;font-size:11px;transition:height 200ms ease, background 120ms;}
  .barValue{font-size:11px;color:transparent;}
  .bar.compare{background:var(--compare);color:#000;}
  .bar.write{background:var(--write);color:#000;}
  .bar.merged{background:var(--merged);color:#000;}
  .rangeOverlay{position:absolute;left:0;top:0;height:100%;border-radius:6px;pointer-events:none;mix-blend-mode:overlay;opacity:0.08;}
  .infoRow{display:flex;gap:18px;align-items:center;margin-top:12px;flex-wrap:wrap;}
  .panel{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;color:var(--muted);flex:1;min-width:260px}
  .panel h3{color:var(--text);margin:0 0 8px;font-size:14px}
  .pcode{background:#061225;padding:12px;border-radius:8px;color:#cfe8ff;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:13px;line-height:1.45;overflow:auto;max-height:220px}
  .line{padding:2px 6px;border-radius:4px}
  .line.active{background:linear-gradient(90deg,rgba(6,182,212,0.12),rgba(16,185,129,0.06));color:#eaffff}
  .legend{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:13px;margin-top:8px}
  .legendItem{display:flex;gap:6px;align-items:center}
  .swatch{width:14px;height:14px;border-radius:3px;}
  .footer{color:var(--muted);font-size:13px;margin-top:12px}
  .small{font-size:12px;color:var(--muted)}
  @media (max-width:700px){.visualArea{height:220px}}
</style>
</head>
<body>
<div class="container">
  <div style="display:flex;align-items:flex-start;gap:12px;">
    <div style="flex:1">
      <h1>Merge Sort â€” Interactive Visualizer</h1>
      <div class="small">Watch how Merge Sort divides the array, compares elements, and merges sorted subarrays. Use controls to step, play/pause, and adjust speed/size.</div>
    </div>
    <div style="width:220px;text-align:right;">
      <div class="small" style="color:var(--muted)">Time Complexity: O(n log n)</div>
      <div class="small" style="color:var(--muted)">Space Complexity: O(n)</div>
    </div>
  </div>

  <div class="top">
    <div class="controls">
      <button class="btn" id="newArrayBtn">New Array</button>
      <button class="btn" id="startPauseBtn">Start</button>
      <button class="btn" id="stepBtn">Step</button>
      <button class="btn" id="resetBtn">Reset</button>
      <div style="width:1px;background:rgba(255,255,255,0.04);height:28px;margin:0 8px"></div>
      <div class="sliderRow"><label class="small">Size</label><input id="sizeRange" type="range" min="8" max="120" value="40"></div>
      <div class="sliderRow"><label class="small">Speed</label><input id="speedRange" type="range" min="1" max="1000" value="200"></div>
    </div>

    <div class="stats">
      <div id="compCount">Comparisons: 0</div>
      <div id="writeCount">Writes: 0</div>
      <div id="actionCount">Steps: 0</div>
    </div>
  </div>

  <div class="visualArea" id="visualArea" aria-hidden="false"></div>

  <div class="infoRow">
    <div class="panel" style="flex:1.5">
      <h3>Controls & Stats</h3>
      <div class="small" style="margin-bottom:8px">Use "Step" to advance one algorithm action. "Start" runs continuously. You can change size or regenerate array anytime (it will stop the current run).</div>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <div class="small">Array Size: <strong id="sizeLabel">40</strong></div>
        <div class="small">Speed (ms per step): <strong id="speedLabel">200</strong></div>
        <div class="small">Status: <strong id="statusLabel">Ready</strong></div>
      </div>

      <div class="legend">
        <div class="legendItem"><div class="swatch" style="background:var(--bar)"></div><div class="small">Unsorted</div></div>
        <div class="legendItem"><div class="swatch" style="background:var(--compare)"></div><div class="small">Comparing</div></div>
        <div class="legendItem"><div class="swatch" style="background:var(--write)"></div><div class="small">Writing / Overwriting</div></div>
        <div class="legendItem"><div class="swatch" style="background:var(--merged)"></div><div class="small">Merged (finalized)</div></div>
      </div>
    </div>

    <div class="panel" style="flex:1.6">
      <h3>Pseudo-code (Merge Sort)</h3>
      <div class="pcode" id="pseudocode">
        <div class="line" id="line1">1. mergeSort(A, left, right):</div>
        <div class="line" id="line2">2. &nbsp;&nbsp;if left >= right: return</div>
        <div class="line" id="line3">3. &nbsp;&nbsp;mid = (left + right) // 2</div>
        <div class="line" id="line4">4. &nbsp;&nbsp;mergeSort(A, left, mid)</div>
        <div class="line" id="line5">5. &nbsp;&nbsp;mergeSort(A, mid+1, right)</div>
        <div class="line" id="line6">6. &nbsp;&nbsp;merge the two sorted halves into A[left..right]</div>
        <div class="line" id="line7">7. &nbsp;&nbsp;-- Use temporary array, compare heads and copy smaller into A</div>
      </div>
    </div>
  </div>

  <div class="footer">
    Tip: Try small array sizes and slow speeds when stepping to see the division/merge boundaries clearly.
  </div>
</div>

<script>
(() => {
  // DOM elements
  const visualArea = document.getElementById('visualArea');
  const newArrayBtn = document.getElementById('newArrayBtn');
  const startPauseBtn = document.getElementById('startPauseBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');
  const sizeRange = document.getElementById('sizeRange');
  const speedRange = document.getElementById('speedRange');
  const compCountEl = document.getElementById('compCount');
  const writeCountEl = document.getElementById('writeCount');
  const actionCountEl = document.getElementById('actionCount');
  const sizeLabel = document.getElementById('sizeLabel');
  const speedLabel = document.getElementById('speedLabel');
  const statusLabel = document.getElementById('statusLabel');
  const pseudocode = {
    1: document.getElementById('line1'),
    2: document.getElementById('line2'),
    3: document.getElementById('line3'),
    4: document.getElementById('line4'),
    5: document.getElementById('line5'),
    6: document.getElementById('line6'),
    7: document.getElementById('line7'),
  };

  // App state
  let SIZE = parseInt(sizeRange.value,10);
  let SPEED = parseInt(speedRange.value,10);
  let array = [];
  let bars = [];
  let gen = null;
  let timer = null;
  let running = false;
  let counts = {comparisons:0, writes:0, actions:0};
  let mergedRanges = []; // list of [l,r] ranges currently finalized

  // Initialize
  sizeLabel.textContent = SIZE;
  speedLabel.textContent = SPEED;
  createArray();

  // Utility: random array
  function createArray() {
    stop();
    mergedRanges = [];
    counts = {comparisons:0,writes:0,actions:0};
    updateCounts();
    statusLabel.textContent = 'Ready';
    array = [];
    const maxVal = 300;
    for (let i=0;i<SIZE;i++){
      array.push( Math.floor(10 + Math.random()*(maxVal-10)) );
    }
    renderArray();
    gen = null;
    startPauseBtn.textContent = 'Start';
    clearCodeHighlight();
  }

  function renderArray(){
    visualArea.innerHTML = '';
    bars = [];
    // create bars with proportional widths
    const gap = 4;
    const areaWidth = visualArea.clientWidth;
    const barWidth = Math.max(4, Math.floor((areaWidth - SIZE*gap) / SIZE));
    const maxVal = Math.max(...array, 1);
    for (let i=0;i<array.length;i++){
      const b = document.createElement('div');
      b.className = 'bar';
      b.style.width = (barWidth) + 'px';
      b.style.marginLeft = (i===0?0:gap/2+'px');
      b.style.marginRight = (i===array.length-1?0:gap/2+'px');
      b.dataset.index = i;
      b.style.height = Math.round((array[i] / maxVal) * (visualArea.clientHeight - 24)) + 24 + 'px';
      b.title = String(array[i]);
      visualArea.appendChild(b);
      bars.push(b);
    }
  }

  // Generator that yields actions describing Merge Sort steps.
  // Action types:
  // {type:'enter', left, right} - entering recursion on range
  // {type:'exit', left, right} - finishing recursion (range merged)
  // {type:'compare', i, j} - comparison between indices
  // {type:'overwrite', index, value} - write value into index (overwriting original)
  // This generator works on a copy of the array to compute decisions.
  function* mergeSortGenerator(arrCopy, left=0, right=arrCopy.length-1) {
    yield {type:'enter', left, right};
    if (left >= right) {
      // Single element, trivially sorted
      yield {type:'exit', left, right};
      return;
    }
    const mid = Math.floor((left+right)/2);
    yield* mergeSortGenerator(arrCopy, left, mid);
    yield* mergeSortGenerator(arrCopy, mid+1, right);

    // Merge step: standard merge using temp array
    let i = left, j = mid+1;
    const temp = [];
    while (i <= mid && j <= right) {
      yield {type:'compare', i, j};
      if (arrCopy[i] <= arrCopy[j]) {
        temp.push(arrCopy[i]);
        i++;
      } else {
        temp.push(arrCopy[j]);
        j++;
      }
    }
    while (i <= mid) {
      temp.push(arrCopy[i]);
      i++;
    }
    while (j <= right) {
      temp.push(arrCopy[j]);
      j++;
    }
    // Overwrite back into arrCopy and yield overwrites for animation
    for (let k=0;k<temp.length;k++){
      yield {type:'overwrite', index: left + k, value: temp[k]};
      arrCopy[left + k] = temp[k];
    }
    yield {type:'exit', left, right};
  }

  // Apply one action to the visualization
  function applyAction(action){
    counts.actions++;
    actionCountEl.textContent = 'Steps: ' + counts.actions;
    clearCodeHighlight();
    switch(action.type){
      case 'enter':
        statusLabel.textContent = `Descending: [${action.left}, ${action.right}]`;
        highlightCodeLine(3); // mid line
        // mark this range subtly by opacity overlay
        // We'll not create overlay per-enter to avoid clutter.
        break;
      case 'exit':
        statusLabel.textContent = `Merged: [${action.left}, ${action.right}]`;
        highlightCodeLine(6);
        // mark bars in this range as merged (green)
        mergedRanges.push([action.left, action.right]);
        for (let idx = action.left; idx <= action.right; idx++){
          const b = bars[idx];
          if (b) {
            b.classList.remove('compare','write');
            b.classList.add('merged');
            b.title = b.dataset.value || b.title;
          }
        }
        break;
      case 'compare':
        counts.comparisons++;
        compCountEl.textContent = 'Comparisons: ' + counts.comparisons;
        highlightCodeLine(7);
        // highlight the two bars being compared
        markCompare(action.i, action.j);
        break;
      case 'overwrite':
        counts.writes++;
        writeCountEl.textContent = 'Writes: ' + counts.writes;
        highlightCodeLine(6);
        // visually overwrite the bar at index with new value
        animateWrite(action.index, action.value);
        break;
      default:
        break;
    }
  }

  function markCompare(i, j){
    // remove previous compare classes
    bars.forEach(b=>b.classList.remove('compare'));
    if (bars[i]) bars[i].classList.add('compare');
    if (bars[j]) bars[j].classList.add('compare');
  }

  function animateWrite(index, value){
    // remove compare classes on that bar
    const b = bars[index];
    if (!b) return;
    // set height accordingly
    const maxVal =  Math.max(...array, value, 1);
    // Update underlying displayed array so subsequent height scaling is coherent
    // But we keep original 'array' for display only; generator supplies final values.
    array[index] = value;
    const targetH = Math.round((array[index] / maxVal) * (visualArea.clientHeight - 24)) + 24;
    b.style.height = targetH + 'px';
    b.classList.remove('compare');
    b.classList.add('write');
    b.title = String(value);
    // After a short while, if index is within a merged range, mark merged, else revert
    setTimeout(()=>{
      // determine if this index lies in any merged range
      let inMerged = false;
      for (const [L,R] of mergedRanges){
        if (index >= L && index <= R){ inMerged = true; break; }
      }
      b.classList.remove('write');
      if (inMerged) b.classList.add('merged');
      else b.classList.remove('merged');
    }, Math.max(60, SPEED/2));
  }

  function updateCounts(){
    compCountEl.textContent = 'Comparisons: ' + counts.comparisons;
    writeCountEl.textContent = 'Writes: ' + counts.writes;
    actionCountEl.textContent = 'Steps: ' + counts.actions;
  }

  function stopTimer(){
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
    running = false;
    startPauseBtn.textContent = 'Start';
  }

  function stop(){
    stopTimer();
    statusLabel.textContent = 'Stopped';
  }

  function start(){
    if (!gen) {
      // Prepare generator working on a copy of current displayed array
      const copy = array.slice();
      gen = mergeSortGenerator(copy, 0, copy.length - 1);
      mergedRanges = [];
      counts = {comparisons:0,writes:0,actions:0};
      updateCounts();
    }
    if (running) return;
    running = true;
    startPauseBtn.textContent = 'Pause';
    statusLabel.textContent = 'Running';
    timer = setInterval(()=> {
      step();
    }, Math.max(1, SPEED));
  }

  function pause(){
    stopTimer();
    statusLabel.textContent = 'Paused';
  }

  function step(){
    if (!gen) {
      // initialize generator but do not start timer
      const copy = array.slice();
      gen = mergeSortGenerator(copy, 0, copy.length - 1);
    }
    const res = gen.next();
    if (res.done) {
      // finish
      // After finished, mark all as merged
      for (let i=0;i<bars.length;i++){
        bars[i].classList.remove('compare','write');
        bars[i].classList.add('merged');
      }
      statusLabel.textContent = 'Finished';
      stopTimer();
      highlightCodeLine(null);
      return;
    }
    applyAction(res.value);
  }

  // Hook up UI events
  newArrayBtn.addEventListener('click', () => {
    SIZE = parseInt(sizeRange.value,10);
    sizeLabel.textContent = SIZE;
    createArray();
  });

  startPauseBtn.addEventListener('click', () => {
    if (running){
      pause();
    } else {
      start();
    }
  });

  stepBtn.addEventListener('click', () => {
    if (running){
      // if running, stepping should pause first
      pause();
    }
    step();
  });

  resetBtn.addEventListener('click', () => {
    stop();
    gen = null;
    createArray();
  });

  sizeRange.addEventListener('input', (e) => {
    SIZE = parseInt(e.target.value,10);
    sizeLabel.textContent = SIZE;
  });

  speedRange.addEventListener('input', (e) => {
    SPEED = parseInt(e.target.value,10);
    speedLabel.textContent = SPEED;
    if (running) {
      // restart interval with new speed
      stopTimer();
      timer = setInterval(()=> step(), Math.max(1, SPEED));
      running = true;
      startPauseBtn.textContent = 'Pause';
    }
  });

  // Pseudocode highlighting helpers
  function highlightCodeLine(num){
    Object.values(pseudocode).forEach(el=>el.classList.remove('active'));
    if (!num) return;
    const el = pseudocode[num];
    if (el) el.classList.add('active');
  }
  function clearCodeHighlight(){ Object.values(pseudocode).forEach(el=>el.classList.remove('active')); }

  // Resize handling - re-render bars to fit
  let resizeTimeout = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      renderArray();
    }, 120);
  });

  // Initialize first render on load: create array with default size
  createArray();

  // Accessibility: keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (e.key === ' ') {
      e.preventDefault();
      if (running) pause(); else start();
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      if (running) pause();
      step();
    } else if (e.key === 'n') {
      createArray();
    }
  });

  // Small note: If the generator yields comparisons and there are many steps per second,
  // the visual highlight can be very quick. Slowing speed or stepping gives clearer view.

})();
</script>
</body>
</html>