<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Binary Search Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#4f46e5;
      --good:#10b981;
      --bad:#ef4444;
      --muted:#94a3b8;
      --box:#0b1228;
    }
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{background:linear-gradient(180deg,#071023 0%, var(--bg) 100%);color:#e6eef8;display:flex;align-items:flex-start;justify-content:center;padding:28px;}
    .container{width:980px;max-width:96%;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);padding:18px;border-radius:12px;box-shadow: 0 6px 30px rgba(2,6,23,0.6);}
    h1{margin:0 0 8px 0;font-size:20px;}
    .top{display:flex;gap:16px;align-items:center;flex-wrap:wrap;}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    input[type="number"], input[type="text"], select {padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit;min-width:90px;}
    button{background:var(--accent);color:white;padding:8px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:600;}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);}
    .row{margin-top:14px;display:flex;gap:14px;align-items:flex-start;}
    .visual{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);min-height:240px;}
    .info{width:320px;max-width:36%;}
    .arrayRow{display:flex;gap:8px;flex-wrap:wrap;margin-top:16px;align-items:center;}
    .cell{width:54px;height:54px;border-radius:8px;background:var(--box);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:16px;border:1px solid rgba(255,255,255,0.03);position:relative;box-shadow: 0 4px 14px rgba(2,6,23,0.5);}
    .cell.small{width:44px;height:44px;font-size:14px;}
    .cell.dim{opacity:0.28;filter:grayscale(40%);}
    .label{font-size:12px;color:var(--muted);position:absolute;top:-18px;left:6px;}
    .status{margin-top:12px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02);font-size:14px;}
    .log{margin-top:12px;height:180px;overflow:auto;background:rgba(255,255,255,0.01);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-family:monospace;font-size:13px;}
    .small{font-size:13px;color:var(--muted);}
    .controlsColumn{display:flex;flex-direction:column;gap:8px;}
    .pseudocode{font-family:monospace;background:rgba(255,255,255,0.01);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-size:13px;}
    .meta{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
    .badge{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-size:13px;}
    .mid{box-shadow:0 6px 20px rgba(79,70,229,0.18);border:1px solid rgba(79,70,229,0.9);background:linear-gradient(180deg, rgba(79,70,229,0.12), rgba(79,70,229,0.04));}
    .low{box-shadow:0 6px 20px rgba(16,185,129,0.12);border:1px solid rgba(16,185,129,0.9);background:linear-gradient(180deg, rgba(16,185,129,0.08), rgba(16,185,129,0.02));}
    .high{box-shadow:0 6px 20px rgba(239,68,68,0.12);border:1px solid rgba(239,68,68,0.9);background:linear-gradient(180deg, rgba(239,68,68,0.08), rgba(239,68,68,0.02));}
    .found{box-shadow:0 6px 30px rgba(16,185,129,0.22);border:1px solid rgba(16,185,129,0.95);background:linear-gradient(180deg, rgba(16,185,129,0.12), rgba(16,185,129,0.04));}
    .notice{font-size:13px;color:var(--muted);margin-top:8px;}
    footer{margin-top:12px;color:var(--muted);font-size:13px;}
    .help{font-size:13px;color:var(--muted);margin-top:8px;}
    .inputRow{display:flex;gap:8px;align-items:center;}
    .rangeInput{width:160px;}
    .toggle{display:flex;gap:6px;align-items:center;}
    .speed{width:120px;}
  </style>
</head>
<body>
  <div class="container" role="main">
    <h1>Binary Search Visualizer</h1>
    <div class="top">
      <div class="controls">
        <div class="inputRow">
          <label class="small" for="size">Array size</label>
          <input id="size" type="number" min="5" max="30" value="15" />
        </div>
        <div class="inputRow">
          <label class="small" for="minVal">Min</label>
          <input id="minVal" type="number" value="1" />
          <label class="small" for="maxVal">Max</label>
          <input id="maxVal" type="number" value="99" />
        </div>
        <button id="genBtn">Generate Sorted Array</button>
        <button id="shuffleBtn" class="secondary">Shuffle (and sort)</button>
        <button id="customBtn" class="secondary">Use custom array</button>
      </div>

      <div style="margin-left:auto;display:flex;gap:8px;align-items:center;">
        <div class="inputRow">
          <label class="small" for="target">Target</label>
          <input id="target" type="number" placeholder="value" />
        </div>
        <div class="toggle">
          <label class="small" for="mode">Mode</label>
          <select id="mode" title="Iterative or Recursive">
            <option value="iter">Iterative</option>
            <option value="rec">Recursive</option>
          </select>
        </div>
        <div class="toggle">
          <label class="small" for="auto">Auto</label>
          <select id="speed" class="speed">
            <option value="700">Slow</option>
            <option value="350" selected>Normal</option>
            <option value="120">Fast</option>
          </select>
        </div>
        <button id="startBtn">Start Search</button>
      </div>
    </div>

    <div class="row">
      <div class="visual" aria-live="polite">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <div class="small">Array (sorted ascending)</div>
          <div class="small">Comparisons: <span id="compCount">0</span></div>
        </div>
        <div id="array" class="arrayRow" aria-hidden="false"></div>

        <div class="status" id="status">Status: Ready — generate an array and enter a target, then click "Start Search"</div>

        <div class="help">Notes: Binary Search repeatedly halves the search interval by comparing the target to the middle element. It runs in O(log n) time for sorted arrays.</div>

        <div style="margin-top:12px" class="small">Pseudocode (iterative):</div>
        <div class="pseudocode">
          left = 0; right = n - 1
          while left <= right:
            mid = (left + right) // 2
            if a[mid] == target: return mid
            if a[mid] < target: left = mid + 1
            else: right = mid - 1
        </div>
      </div>

      <div class="info">
        <div class="controlsColumn">
          <div>
            <button id="stepBtn" class="secondary">Step</button>
            <button id="autoBtn">Auto Play</button>
            <button id="resetBtn" class="secondary">Reset</button>
          </div>

          <div class="meta">
            <div class="badge">Low: <span id="lowIdx">-</span></div>
            <div class="badge">Mid: <span id="midIdx">-</span></div>
            <div class="badge">High: <span id="highIdx">-</span></div>
          </div>

          <div class="status" id="explain">Explanation: —</div>
          <div class="log" id="log" aria-live="polite"></div>
        </div>

        <footer>
          Tip: You can click "Step" to execute one comparison at a time or "Auto Play" to run automatically. Try targets that are present and not present to see different outcomes.
        </footer>
      </div>
    </div>
  </div>

  <script>
    // Binary Search Visualizer
    (function(){
      const arrayEl = document.getElementById('array');
      const genBtn = document.getElementById('genBtn');
      const shuffleBtn = document.getElementById('shuffleBtn');
      const customBtn = document.getElementById('customBtn');
      const startBtn = document.getElementById('startBtn');
      const stepBtn = document.getElementById('stepBtn');
      const autoBtn = document.getElementById('autoBtn');
      const resetBtn = document.getElementById('resetBtn');
      const sizeInput = document.getElementById('size');
      const minValInput = document.getElementById('minVal');
      const maxValInput = document.getElementById('maxVal');
      const targetInput = document.getElementById('target');
      const compCountEl = document.getElementById('compCount');
      const statusEl = document.getElementById('status');
      const logEl = document.getElementById('log');
      const lowEl = document.getElementById('lowIdx');
      const midEl = document.getElementById('midIdx');
      const highEl = document.getElementById('highIdx');
      const modeSel = document.getElementById('mode');
      const speedSel = document.getElementById('speed');

      let arr = [];
      let n = 0;
      let left = 0, right = -1, mid = -1;
      let comparisons = 0;
      let running = false;
      let autoTimer = null;
      let state = null; // for recursive mode: stack simulation
      let foundIndex = -1;

      function log(msg){
        const at = new Date().toLocaleTimeString();
        logEl.innerHTML = `<div style="margin-bottom:6px">[${at}] ${escapeHtml(msg)}</div>` + logEl.innerHTML;
      }

      function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

      function generateArray(){
        n = Math.max(5, Math.min(30, parseInt(sizeInput.value)||15));
        const minV = parseInt(minValInput.value) || 1;
        const maxV = parseInt(maxValInput.value) || 100;
        const set = new Set();
        while(set.size < n){
          const v = Math.floor(Math.random()*(maxV-minV+1)) + minV;
          set.add(v);
        }
        arr = Array.from(set).sort((a,b)=>a-b);
        resetState();
        renderArray();
        statusEl.textContent = `Status: Generated sorted array of ${n} unique values.`;
        log(`Generated array: [${arr.join(', ')}]`);
      }

      function shuffleAndSort(){
        // small shuffle then sort to show effect (keeps values same)
        for(let i=arr.length-1;i>0;i--){
          const j=Math.floor(Math.random()*(i+1));
          [arr[i],arr[j]]=[arr[j],arr[i]];
        }
        arr.sort((a,b)=>a-b);
        resetState();
        renderArray();
        log('Shuffled then sorted the existing array.');
        statusEl.textContent = 'Status: Array reshuffled and sorted.';
      }

      function useCustomArray(){
        const input = prompt('Enter numbers separated by commas (they will be sorted ascending):', arr.join(', '));
        if(!input) return;
        const parts = input.split(',').map(s=>s.trim()).filter(s=>s.length);
        const nums = parts.map(s=>Number(s)).filter(x=>!isNaN(x));
        if(nums.length===0){ alert('No valid numbers provided.'); return; }
        arr = Array.from(new Set(nums)).sort((a,b)=>a-b);
        n = arr.length;
        sizeInput.value = n;
        resetState();
        renderArray();
        log(`Custom array used: [${arr.join(', ')}]`);
        statusEl.textContent = `Status: Custom array set (${n} unique sorted values).`;
      }

      function renderArray(){
        arrayEl.innerHTML = '';
        arr.forEach((v,i)=>{
          const d = document.createElement('div');
          d.className = 'cell';
          d.dataset.index = i;
          d.textContent = v;
          const lb = document.createElement('div');
          lb.className='label';
          lb.textContent = i;
          d.appendChild(lb);
          arrayEl.appendChild(d);
        });
        updateMarkers();
      }

      function updateMarkers(){
        const cells = arrayEl.querySelectorAll('.cell');
        cells.forEach((cell, i)=>{
          cell.classList.remove('mid','low','high','dim','found');
          if(i < left || i > right) cell.classList.add('dim');
          if(i === mid) cell.classList.add('mid');
          if(i === left) cell.classList.add('low');
          if(i === right) cell.classList.add('high');
          if(i === foundIndex) cell.classList.add('found');
        });
        lowEl.textContent = left;
        midEl.textContent = mid>=0?mid:'-';
        highEl.textContent = right;
        compCountEl.textContent = comparisons;
      }

      function resetState(){
        left=0; right=arr.length-1; mid=-1; comparisons=0; running=false; foundIndex=-1;
        clearInterval(autoTimer); autoTimer=null; autoBtn.textContent='Auto Play';
        logEl.innerHTML = '';
        state = null;
        updateMarkers();
        compCountEl.textContent = comparisons;
        statusEl.textContent = 'Status: Ready.';
      }

      function startSearch(){
        const tval = targetInput.value.trim();
        if(!tval){ alert('Please enter a target value to search for.'); return; }
        if(arr.length===0){ alert('Array is empty. Generate or enter a custom array first.'); return; }
        resetState();
        // parse target as number
        const target = Number(tval);
        if(isNaN(target)){ alert('Target must be a number.'); return; }
        // initialize
        left = 0; right = arr.length-1; mid=-1; comparisons=0; foundIndex=-1;
        updateMarkers();
        statusEl.textContent = `Status: Searching for ${target}`;
        log(`Search started for target ${target} (mode: ${modeSel.value === 'iter' ? 'iterative' : 'recursive'})`);
        if(modeSel.value === 'iter'){
          running = true;
        }else{
          // prepare recursive stack as manual simulation: push initial segment
          state = [{l:0, r: arr.length-1, stage:'enter'}];
          running = true;
        }
      }

      function stepOnce(){
        if(!running){
          statusEl.textContent = 'Status: Not running. Click Start Search first.';
          return;
        }
        const target = Number(targetInput.value);
        if(isNaN(target)){ alert('Target must be a number.'); running=false; return; }
        if(modeSel.value === 'iter') return iterativeStep(target);
        else return recursiveStep(target);
      }

      function iterativeStep(target){
        if(left > right){
          statusEl.textContent = `Status: Target ${target} NOT found after ${comparisons} comparisons.`;
          log(`Exhausted search interval. ${target} not found.`);
          running = false;
          updateMarkers();
          return;
        }
        mid = Math.floor((left + right)/2);
        comparisons++;
        updateMarkers();
        const val = arr[mid];
        statusEl.textContent = `Comparing target ${target} with a[mid]=${val} (index ${mid})`;
        log(`Compare #${comparisons}: a[${mid}] = ${val} ${val === target ? '==' : (val < target ? '<' : '>')} target ${target}`);
        if(val === target){
          foundIndex = mid;
          updateMarkers();
          statusEl.textContent = `Status: Found target ${target} at index ${mid} in ${comparisons} comparisons.`;
          log(`Found at index ${mid}.`);
          running = false;
          return;
        }
        if(val < target){
          // move right
          left = mid + 1;
          log(`Target greater than a[${mid}]; narrowing to [${left}, ${right}]`);
        }else{
          right = mid - 1;
          log(`Target less than a[${mid}]; narrowing to [${left}, ${right}]`);
        }
        updateMarkers();
      }

      function recursiveStep(target){
        // we simulate recursion with a stack of frames: {l,r,stage,mid}
        if(!state || state.length===0){
          statusEl.textContent = `Status: Target ${target} NOT found after ${comparisons} comparisons.`;
          log(`Recursive stack empty. ${target} not found.`);
          running = false;
          return;
        }
        const frame = state.pop();
        if(!frame) return;
        const l = frame.l, r = frame.r;
        if(l > r){
          log(`Frame [${l},${r}] is empty; backtrack.`);
          // continue to next frame
          if(state.length===0){
            statusEl.textContent = `Status: Target ${target} NOT found after ${comparisons} comparisons.`;
            running = false;
          }
          updateMarkers();
          return;
        }
        mid = Math.floor((l + r)/2);
        comparisons++;
        updateMarkers();
        const val = arr[mid];
        statusEl.textContent = `Recursive call on [${l}, ${r}] — compare a[${mid}] = ${val} with target ${target}`;
        log(`Compare #${comparisons}: a[${mid}] = ${val} ${val === target ? '==' : (val < target ? '<' : '>')} target ${target}`);
        if(val === target){
          foundIndex = mid;
          updateMarkers();
          statusEl.textContent = `Status: Found target ${target} at index ${mid} in ${comparisons} comparisons (recursive).`;
          log(`Found at index ${mid} (recursive).`);
          running = false;
          return;
        }
        if(val < target){
          log(`Target > a[${mid}]; recurse on [${mid+1}, ${r}]`);
          // push the right interval to process next
          state.push({l: mid+1, r:r});
        }else{
          log(`Target < a[${mid}]; recurse on [${l}, ${mid-1}]`);
          state.push({l: l, r: mid-1});
        }
        updateMarkers();
      }

      function toggleAuto(){
        if(autoTimer){
          clearInterval(autoTimer);
          autoTimer = null;
          autoBtn.textContent = 'Auto Play';
          return;
        }
        if(!running){
          alert('Start the search first.');
          return;
        }
        autoBtn.textContent = 'Stop';
        const delay = parseInt(speedSel.value) || 350;
        autoTimer = setInterval(()=>{
          if(!running){
            clearInterval(autoTimer); autoTimer=null; autoBtn.textContent='Auto Play';
            return;
          }
          stepOnce();
        }, delay);
      }

      // Event listeners
      genBtn.addEventListener('click', generateArray);
      shuffleBtn.addEventListener('click', shuffleAndSort);
      customBtn.addEventListener('click', useCustomArray);
      startBtn.addEventListener('click', ()=>{
        startSearch();
      });
      stepBtn.addEventListener('click', ()=>{ stepOnce(); });
      autoBtn.addEventListener('click', ()=>{ toggleAuto(); });
      resetBtn.addEventListener('click', ()=>{ resetState(); renderArray(); });

      // keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if(e.key === ' ' && !/INPUT|SELECT|TEXTAREA/.test(document.activeElement.tagName)){
          e.preventDefault();
          stepOnce();
        }
        if(e.key === 'a' && !/INPUT|SELECT|TEXTAREA/.test(document.activeElement.tagName)){
          toggleAuto();
        }
      });

      // initialize
      generateArray();

      // small accessibility: clicking cells shows index/value
      arrayEl.addEventListener('click', (e)=>{
        const c = e.target.closest('.cell');
        if(!c) return;
        const i = parseInt(c.dataset.index);
        alert(`Index: ${i}\nValue: ${arr[i]}`);
      });

      // provide helpful initial examples by setting target suggestions when clicking cells
      arrayEl.addEventListener('contextmenu', (e)=>{
        const c = e.target.closest('.cell');
        if(!c) return;
        e.preventDefault();
        const i = parseInt(c.dataset.index);
        targetInput.value = arr[i];
        log(`Target input set to a[${i}] = ${arr[i]} (via right-click)`);
      });

      // simple responsiveness: regenerate if size changed with quick button
      sizeInput.addEventListener('change', ()=>{ /* do nothing until user clicks generate */ });

      // small safety: stop auto if window hidden
      document.addEventListener('visibilitychange', ()=>{
        if(document.hidden && autoTimer){ clearInterval(autoTimer); autoTimer=null; autoBtn.textContent='Auto Play'; }
      });

    })();
  </script>
</body>
</html>