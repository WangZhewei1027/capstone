<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Huffman Coding Visualizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#6ee7b7;
    --muted:#9aa4b2;
    --card:#0d1522;
    --danger:#ff6b6b;
  }
  body{
    margin:0;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg, #071025 0%, #041327 100%);
    color:#e6eef6;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    line-height:1.4;
  }
  header{
    padding:18px 24px;
    display:flex;
    align-items:center;
    gap:18px;
    border-bottom: 1px solid rgba(255,255,255,0.03);
  }
  header h1{
    font-size:18px;
    margin:0;
    letter-spacing:0.2px;
  }
  .container{
    display:grid;
    grid-template-columns: 360px 1fr 360px;
    gap:18px;
    padding:18px;
  }
  .panel{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.03);
    padding:14px;
    border-radius:10px;
  }
  .panel h2{
    font-size:14px;
    margin:0 0 8px 0;
    color:var(--accent);
  }
  textarea{
    width:100%;
    height:140px;
    resize:vertical;
    background:transparent;
    color:inherit;
    border:1px dashed rgba(255,255,255,0.04);
    padding:8px;
    border-radius:8px;
    font-family:monospace;
    font-size:13px;
  }
  button, .btn{
    appearance:none;
    border:0;
    background:linear-gradient(180deg,#165f46,#0f5139);
    color:white;
    padding:8px 12px;
    border-radius:8px;
    cursor:pointer;
    font-weight:600;
    font-size:13px;
  }
  .btn.secondary{
    background:transparent;
    border:1px solid rgba(255,255,255,0.04);
    color:var(--accent);
  }
  .small{
    font-size:12px;
    padding:6px 8px;
  }
  .freq-list{
    max-height:240px;
    overflow:auto;
    margin-top:8px;
    border-radius:8px;
    padding:6px;
    background:rgba(255,255,255,0.01);
    border:1px solid rgba(255,255,255,0.02);
  }
  .freq-row{
    display:flex;
    justify-content:space-between;
    padding:6px 8px;
    border-radius:6px;
    margin:4px 0;
    align-items:center;
    gap:8px;
    font-size:13px;
  }
  .freq-row .char{
    min-width:24px;
    text-align:center;
    padding:4px 6px;
    border-radius:6px;
    background:rgba(255,255,255,0.02);
    font-family:monospace;
  }
  .freq-row .meta{
    color:var(--muted);
    font-size:12px;
  }
  .controls{
    display:flex;
    gap:8px;
    margin-top:8px;
    flex-wrap:wrap;
  }
  .svg-wrap{
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
    border-radius:10px;
    padding:8px;
    height:560px;
    overflow:auto;
    border:1px solid rgba(255,255,255,0.03);
  }
  #treeSVG{
    width:100%;
    height:520px;
  }
  .right-col .card{
    margin-bottom:12px;
  }
  .codes{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin-top:8px;
  }
  .code-row{
    background:rgba(255,255,255,0.02);
    padding:8px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.02);
    font-family:monospace;
    font-size:13px;
    min-width:110px;
  }
  .stats{
    display:flex;
    gap:12px;
    margin-top:8px;
    flex-wrap:wrap;
  }
  .stat{
    background:rgba(255,255,255,0.01);
    border-radius:8px;
    padding:8px;
    font-size:13px;
    border:1px solid rgba(255,255,255,0.02);
  }
  .controls-row{
    display:flex;
    gap:8px;
    align-items:center;
    margin-top:8px;
  }
  .queue{
    display:flex;
    gap:6px;
    flex-wrap:wrap;
    margin-top:8px;
  }
  .q-item{
    background:rgba(255,255,255,0.02);
    padding:6px 8px;
    border-radius:8px;
    font-family:monospace;
    font-size:13px;
  }
  .play{
    display:flex;
    gap:8px;
    align-items:center;
  }
  .footer{
    padding:14px 18px;
    font-size:13px;
    color:var(--muted);
    border-top:1px solid rgba(255,255,255,0.02);
  }
  .legend{
    display:flex;
    gap:10px;
    align-items:center;
    margin-top:8px;
    flex-wrap:wrap;
  }
  .legend .item{
    display:flex;
    gap:6px;
    align-items:center;
    font-size:13px;
    color:var(--muted);
  }
  .dot{
    width:14px;
    height:14px;
    border-radius:50%;
    background:var(--accent);
    display:inline-block;
  }
  .small-muted{
    color:var(--muted);
    font-size:13px;
  }
  a.link{
    color:var(--accent);
    text-decoration:none;
  }
  input[type="text"], input[type="number"]{
    background:transparent;
    border:1px dashed rgba(255,255,255,0.03);
    color:inherit;
    padding:6px 8px;
    border-radius:6px;
    font-family:monospace;
    font-size:13px;
  }
  .controls-row label{ font-size:13px; color:var(--muted); margin-right:6px; }
  .code-bit{
    font-family:monospace;
    background:rgba(255,255,255,0.02);
    padding:6px 8px;
    border-radius:6px;
    border:1px solid rgba(255,255,255,0.02);
  }
  .danger{
    background:linear-gradient(180deg,#b02a2a,#8a1f1f);
  }
  footer small{ color:var(--muted); }
  @media (max-width:1100px){
    .container{ grid-template-columns: 1fr; padding:12px; }
    .svg-wrap{ height:420px; }
  }
</style>
</head>
<body>
<header>
  <h1>Huffman Coding Visualizer</h1>
  <div style="color:var(--muted);font-size:13px">Enter text, build a Huffman tree, watch merging steps, see codes and encoded bits.</div>
</header>

<div class="container">
  <div class="panel">
    <h2>Input</h2>
    <textarea id="inputText" placeholder="Type or paste any text here...">this is an example for huffman encoding</textarea>
    <div class="controls">
      <button id="buildBtn" class="btn small">Build Huffman Tree</button>
      <button id="randomBtn" class="btn small secondary">Sample Text</button>
      <button id="clearBtn" class="btn small secondary">Clear</button>
    </div>

    <h2 style="margin-top:12px">Frequencies</h2>
    <div class="freq-list" id="freqList"></div>

    <div class="controls-row" style="margin-top:10px;">
      <label>Min frequency filter:</label>
      <input id="minFreq" type="number" value="1" min="1" style="width:70px" />
      <label style="margin-left:8px">Show only top</label>
      <input id="topK" type="number" value="" placeholder="all" style="width:70px" />
    </div>

    <div class="legend">
      <div class="item"><span class="dot"></span> Leaf node (char + frequency)</div>
      <div class="item"><div style="width:14px;height:14px;border-radius:4px;background:#5b8cff"></div> Internal node (sum of freq)</div>
    </div>
  </div>

  <div class="panel svg-wrap right-col">
    <h2>Tree & Steps</h2>
    <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
      <div class="controls-row">
        <button id="playBtn" class="btn small">Play</button>
        <button id="stepPrev" class="btn small secondary">Prev</button>
        <button id="stepNext" class="btn small secondary">Next</button>
        <button id="resetStep" class="btn small secondary">Reset</button>
      </div>
      <div style="margin-left:auto" class="small-muted">Step <span id="stepIndex">0</span> / <span id="stepCount">0</span></div>
    </div>

    <div style="margin-top:8px;">
      <div class="small-muted">Priority Queue (left = smallest)</div>
      <div class="queue" id="queueView"></div>
    </div>

    <svg id="treeSVG" viewBox="0 0 1200 520" preserveAspectRatio="xMidYMid meet"></svg>
  </div>

  <div class="panel">
    <h2>Codes & Compression</h2>

    <div class="card">
      <div class="small-muted">Generated codes</div>
      <div class="codes" id="codesView" style="margin-top:8px"></div>
    </div>

    <div class="card" style="margin-top:10px">
      <div class="small-muted">Encode / Decode</div>
      <div style="margin-top:8px; display:flex; gap:8px;">
        <input id="encodeBits" class="code-bit" type="text" placeholder="Encoded bits (auto)"/>
        <button id="decodeBtn" class="btn small secondary">Decode</button>
        <button id="copyBits" class="btn small">Copy Bits</button>
      </div>
      <div style="margin-top:8px">
        <div class="small-muted">Encoded bit string</div>
        <div id="encodedView" class="code-bit" style="margin-top:6px; white-space:pre-wrap;max-height:120px;overflow:auto"></div>
      </div>
    </div>

    <div class="card" style="margin-top:10px">
      <div class="small-muted">Statistics</div>
      <div class="stats">
        <div class="stat">Original size: <div id="origSize" style="font-weight:700">0 bits</div></div>
        <div class="stat">Huffman size: <div id="huffSize" style="font-weight:700">0 bits</div></div>
        <div class="stat">Compression: <div id="compression" style="font-weight:700">0%</div></div>
      </div>
    </div>

    <div class="card" style="margin-top:10px">
      <div style="display:flex;gap:8px;align-items:center">
        <div class="small-muted">Decoded text</div>
        <button id="showDecoded" class="btn small secondary" style="margin-left:auto">Show Decoded</button>
      </div>
      <div id="decodedView" style="margin-top:8px; white-space:pre-wrap; background:rgba(255,255,255,0.01); padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.02); max-height:140px; overflow:auto;"></div>
    </div>
  </div>
</div>

<div class="footer">
  <small>Huffman coding builds an optimal prefix code (for a given frequency distribution). This demo shows step-by-step merges and assigns 0/1 codes by traversing left/right. For a single distinct symbol, code '0' is assigned.</small>
</div>

<script>
/*
  Huffman Coding Visualizer
  - Build frequency table from input text
  - Build Huffman tree step-by-step (recording merges)
  - Assign codes by traversing final tree
  - Visualize tree with SVG
  - Animate merge steps and show priority queue
  - Encode and decode text
*/

const inputText = document.getElementById('inputText');
const buildBtn = document.getElementById('buildBtn');
const randomBtn = document.getElementById('randomBtn');
const clearBtn = document.getElementById('clearBtn');
const freqList = document.getElementById('freqList');
const minFreq = document.getElementById('minFreq');
const topK = document.getElementById('topK');

const treeSVG = document.getElementById('treeSVG');
const queueView = document.getElementById('queueView');
const codesView = document.getElementById('codesView');
const encodedView = document.getElementById('encodedView');
const encodeBits = document.getElementById('encodeBits');
const decodeBtn = document.getElementById('decodeBtn');
const copyBits = document.getElementById('copyBits');
const showDecoded = document.getElementById('showDecoded');
const decodedView = document.getElementById('decodedView');

const origSize = document.getElementById('origSize');
const huffSize = document.getElementById('huffSize');
const compression = document.getElementById('compression');

const playBtn = document.getElementById('playBtn');
const stepPrev = document.getElementById('stepPrev');
const stepNext = document.getElementById('stepNext');
const resetStep = document.getElementById('resetStep');
const stepIndex = document.getElementById('stepIndex');
const stepCount = document.getElementById('stepCount');

const sampleTexts = [
  "this is an example for huffman encoding",
  "beep boop beep boop beep boop",
  "AAAAAAABBBCCD",
  "the quick brown fox jumps over the lazy dog",
  "to be or not to be that is the question"
];

let state = {
  frequencies: {},
  nodes: [],      // initial leaf nodes
  steps: [],      // snapshots of queue at each merge
  root: null,
  codes: {},
  encoded: "",
  decoded: "",
  playTimer: null,
  playSpeed: 800,
  step: 0
};

function computeFrequencies(text){
  const freq = {};
  for (const ch of text){
    freq[ch] = (freq[ch] || 0) + 1;
  }
  return freq;
}

let nextNodeId = 1;
function makeNode({char=null, freq=0, left=null, right=null, isInternal=false}){
  return { id: nextNodeId++, char, freq, left, right, isInternal };
}

/* Build Huffman tree and record steps
   We'll use a stable sort priority queue implemented as array sorted by freq then id
   Steps: queue snapshots before each merge, with indices of two chosen nodes and new node appended
*/
function buildHuffmanFromFreq(freqMap){
  nextNodeId = 1;
  const nodes = [];
  for(const [ch, f] of Object.entries(freqMap)){
    nodes.push(makeNode({char: ch, freq: f, isInternal:false}));
  }
  // Edge: no symbols
  if(nodes.length === 0){
    return { root: null, steps: [], initialQueue: [], finalQueue: [] };
  }
  // sort ascending by freq then by id (stable)
  const queue = nodes.slice();
  queue.sort((a,b)=> a.freq - b.freq || a.id - b.id);
  const steps = [];
  // record initial queue
  steps.push(snapshotQueue(queue));
  // Special: if only one node, we still need a root (assign code '0')
  if(queue.length === 1){
    const root = makeNode({left: queue[0], right: null, freq: queue[0].freq, isInternal:true});
    steps.push(snapshotQueue([root]));
    return { root, steps, initialQueue: queue };
  }

  while(queue.length > 1){
    // pick two smallest
    const a = queue.shift();
    const b = queue.shift();
    const parent = makeNode({left: a, right: b, freq: a.freq + b.freq, isInternal:true});
    // insert parent back keeping sorted order
    let inserted = false;
    for(let i=0;i<queue.length;i++){
      if(parent.freq < queue[i].freq || (parent.freq === queue[i].freq && parent.id < queue[i].id)){
        queue.splice(i,0,parent);
        inserted = true;
        break;
      }
    }
    if(!inserted) queue.push(parent);
    steps.push({ queue: snapshotQueue(queue), merged: {aId: a.id, bId: b.id, parentId: parent.id} });
  }
  const root = queue[0];
  return { root, steps, initialQueue: nodes };
}

function snapshotQueue(queue){
  // shallow copy with essential fields for display
  return queue.map(n => ({ id: n.id, char: n.char, freq: n.freq, isInternal: !!n.isInternal }));
}

/* Assign binary codes to leaves (0 left, 1 right). For single-child internal nodes, follow left as 0.
   For a tree with single distinct symbol, assign code '0'.
*/
function assignCodes(root){
  const codes = {};
  if(!root) return codes;
  if(!root.left && !root.right && root.char !== null){
    codes[root.char] = '0';
    return codes;
  }
  function dfs(node, prefix){
    if(!node) return;
    if(node.char !== null && !node.isInternal){
      codes[node.char] = prefix.length ? prefix : '0';
      return;
    }
    // left -> 0, right -> 1
    dfs(node.left, prefix + '0');
    dfs(node.right, prefix + '1');
  }
  dfs(root, '');
  return codes;
}

/* Encoding and decoding */
function encodeText(text, codes){
  let bits = '';
  for(const ch of text){
    const c = codes[ch];
    if(!c) return null;
    bits += c;
  }
  return bits;
}
function decodeBits(bits, root){
  if(!root) return '';
  // special case: single symbol tree where only root -> leaf
  if(!root.left && !root.right && root.char !== null){
    // bits length should be multiple of 1; each code '0'
    let out = '';
    for(let i=0;i<bits.length;i++){
      out += root.char;
    }
    return out;
  }
  let res = '';
  let node = root;
  for(let i=0;i<bits.length;i++){
    const b = bits[i];
    node = (b === '0') ? node.left : node.right;
    if(!node) return null; // invalid bits
    if(node.char !== null && !node.isInternal){
      res += node.char;
      node = root;
    }
  }
  // If ended not at root, bits incomplete
  if(node !== root) return null;
  return res;
}

/* UI: render frequency list */
function renderFrequencies(freqMap){
  freqList.innerHTML = '';
  const arr = Object.keys(freqMap).map(ch => ({ch, f: freqMap[ch]}));
  arr.sort((a,b)=> b.f - a.f || (a.ch > b.ch ? 1:-1));
  const minF = Number(minFreq.value) || 1;
  const k = Number(topK.value) || arr.length;
  let shown = 0;
  for(const item of arr){
    if(item.f < minF) continue;
    if(shown >= k) break;
    const row = document.createElement('div');
    row.className = 'freq-row';
    row.innerHTML = `<div style="display:flex;gap:8px;align-items:center">
      <div class="char">${escapeVisible(item.ch)}</div>
      <div style="font-weight:700">${item.f}</div>
    </div>
    <div class="meta">${describeChar(item.ch)}</div>`;
    freqList.appendChild(row);
    shown++;
  }
  if(shown === 0){
    freqList.innerHTML = '<div class="small-muted">No symbols to show (adjust filters or enter text).</div>';
  }
}

function escapeVisible(ch){
  if(ch === ' ') return 'â£';
  if(ch === '\n') return '\\n';
  if(ch === '\t') return '\\t';
  return ch;
}
function describeChar(ch){
  if(ch === ' ') return 'space';
  if(ch === '\n') return 'newline';
  if(ch === '\t') return 'tab';
  if(ch.length > 1) return ch;
  return `code ${ch.charCodeAt(0)}`;
}

/* Render queue snapshot */
function renderQueue(snapshot){
  queueView.innerHTML = '';
  if(!snapshot || snapshot.length === 0){
    queueView.innerHTML = '<div class="small-muted">empty</div>';
    return;
  }
  for(const item of snapshot){
    const div = document.createElement('div');
    div.className = 'q-item';
    if(item.isInternal){
      div.style.background = 'linear-gradient(180deg,#153a76,#0f2956)';
    }
    div.textContent = `${item.char !== null ? escapeVisible(item.char) + ' ' : ''}[${item.freq}]`;
    queueView.appendChild(div);
  }
}

/* Draw final tree as SVG */
function renderTreeSVG(root, codes){
  // clear
  while(treeSVG.firstChild) treeSVG.removeChild(treeSVG.firstChild);

  if(!root){
    const t = makeText(20,20,'No tree built');
    treeSVG.appendChild(t);
    return;
  }
  // compute layout positions: recursively compute subtree widths, then assign x positions
  function measure(node){
    if(!node) return {w:0, h:0, leaves:0};
    if(node.char !== null && !node.isInternal){
      return {w:1, h:1, leaves:1};
    }
    const L = measure(node.left || null);
    const R = measure(node.right || null);
    return { w: Math.max(1, L.w + R.w), h: Math.max(L.h, R.h)+1, leaves: L.leaves + R.leaves };
  }
  const m = measure(root);
  const nodePositions = new Map();

  const paddingX = 20;
  const paddingY = 40;
  const viewW = 1100;
  const viewH = 480;
  const startX = 40;
  const endX = viewW - 40;
  const totalWidthUnits = Math.max(1, m.w);

  // assign x recursively
  function assign(node, xMin, xMax, depth){
    if(!node) return;
    const x = (xMin + xMax) / 2;
    const y = 40 + depth * paddingY;
    nodePositions.set(node.id, {x,y,node});
    if(node.left) assign(node.left, xMin, x, depth+1);
    if(node.right) assign(node.right, x, xMax, depth+1);
  }
  assign(root, startX, endX, 0);

  // draw links first
  for(const [id,pos] of nodePositions){
    const node = pos.node;
    if(node.left){
      const cPos = nodePositions.get(node.left.id);
      const line = makeLine(pos.x,pos.y+16,cPos.x,cPos.y-16);
      treeSVG.appendChild(line);
      const lbl = makeText((pos.x + cPos.x)/2 - 8, (pos.y + cPos.y)/2 - 6, '0');
      treeSVG.appendChild(lbl);
    }
    if(node.right){
      const cPos = nodePositions.get(node.right.id);
      const line = makeLine(pos.x,pos.y+16,cPos.x,cPos.y-16);
      treeSVG.appendChild(line);
      const lbl = makeText((pos.x + cPos.x)/2 + 6, (pos.y + cPos.y)/2 - 6, '1');
      treeSVG.appendChild(lbl);
    }
  }

  // draw nodes top-down
  for(const [id,pos] of nodePositions){
    const node = pos.node;
    if(node.isInternal){
      const g = makeGroupCircle(pos.x,pos.y,node.freq, '#5b8cff');
      treeSVG.appendChild(g);
    } else {
      const g = makeGroupLeaf(pos.x,pos.y,node.char,node.freq);
      treeSVG.appendChild(g);
    }
  }

  // show codes near leaves
  for(const [ch,code] of Object.entries(codes)){
    // find leaf with char
    let leafNode = null;
    for(const [id,pos] of nodePositions){
      if(pos.node.char === ch && !pos.node.isInternal){
        leafNode = pos;
        break;
      }
    }
    if(leafNode){
      const x = leafNode.x + 30;
      const y = leafNode.y - 6;
      const t = makeText(x,y, code, '#a7ffd8');
      treeSVG.appendChild(t);
    }
  }

  // adjust viewBox to fit
  treeSVG.setAttribute('viewBox', `0 0 ${viewW} ${viewH}`);
}

function makeLine(x1,y1,x2,y2){
  const line = document.createElementNS('http://www.w3.org/2000/svg','line');
  line.setAttribute('x1', x1);
  line.setAttribute('y1', y1);
  line.setAttribute('x2', x2);
  line.setAttribute('y2', y2);
  line.setAttribute('stroke', 'rgba(255,255,255,0.06)');
  line.setAttribute('stroke-width', '1.6');
  return line;
}
function makeText(x,y,text,color='#dff7ee'){
  const t = document.createElementNS('http://www.w3.org/2000/svg','text');
  t.setAttribute('x', x);
  t.setAttribute('y', y);
  t.setAttribute('fill', color);
  t.setAttribute('font-size', 13);
  t.setAttribute('font-family', 'monospace');
  t.textContent = text;
  return t;
}
function makeGroupCircle(x,y,label,color){
  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
  circ.setAttribute('cx', x);
  circ.setAttribute('cy', y);
  circ.setAttribute('r', 18);
  circ.setAttribute('fill', color);
  circ.setAttribute('opacity', 0.95);
  const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
  txt.setAttribute('x', x);
  txt.setAttribute('y', y+5);
  txt.setAttribute('text-anchor','middle');
  txt.setAttribute('fill','#071127');
  txt.setAttribute('font-weight','700');
  txt.setAttribute('font-size', 13);
  txt.setAttribute('font-family','monospace');
  txt.textContent = label;
  g.appendChild(circ);
  g.appendChild(txt);
  return g;
}
function makeGroupLeaf(x,y,ch,label){
  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
  rect.setAttribute('x', x-22);
  rect.setAttribute('y', y-16);
  rect.setAttribute('width', 44);
  rect.setAttribute('height', 32);
  rect.setAttribute('rx', 8);
  rect.setAttribute('fill', 'rgba(255,255,255,0.03)');
  rect.setAttribute('stroke', 'rgba(255,255,255,0.05)');
  const txt1 = document.createElementNS('http://www.w3.org/2000/svg','text');
  txt1.setAttribute('x', x-6);
  txt1.setAttribute('y', y+5);
  txt1.setAttribute('fill','#c5f6df');
  txt1.setAttribute('font-size', 14);
  txt1.setAttribute('font-family', 'monospace');
  txt1.textContent = escapeVisible(ch);
  const txt2 = document.createElementNS('http://www.w3.org/2000/svg','text');
  txt2.setAttribute('x', x+10);
  txt2.setAttribute('y', y+5);
  txt2.setAttribute('fill','#9fb9c9');
  txt2.setAttribute('font-size', 12);
  txt2.setAttribute('font-family', 'monospace');
  txt2.textContent = '[' + label + ']';
  g.appendChild(rect);
  g.appendChild(txt1);
  g.appendChild(txt2);
  return g;
}

/* Steps playback controls */
function setStateFromBuild(result){
  state.frequencies = Object.assign({}, result.initialFreq || {});
  state.nodes = result.initialQueue || [];
  state.steps = result.steps || [];
  state.root = result.root || null;
  state.codes = assignCodes(state.root);
  state.encoded = encodeText(inputText.value, state.codes) || '';
  state.decoded = decodeBits(state.encoded, state.root) || '';
  state.step = 0;
  updateUIAfterBuild();
}

function updateUIAfterBuild(){
  renderFrequencies(state.frequencies);
  // render initial queue and step info
  stepCount.textContent = state.steps.length - 1 >= 0 ? state.steps.length - 1 : 0;
  stepIndex.textContent = state.step;
  if(state.steps.length > 0){
    const snap = state.steps[state.step] && state.steps[state.step].queue ? state.steps[state.step].queue : state.steps[state.step];
    renderQueue(snap);
  } else {
    renderQueue([]);
  }
  renderTreeSVG(state.root, state.codes);
  renderCodes();
  updateEncodedDecoded();
}

/* Build process that also stores initialFreq in result for UI */
function buildAll(){
  const text = inputText.value;
  const freq = computeFrequencies(text);
  state.frequencies = freq;
  const result = buildHuffmanFromFreq(freq);
  result.initialFreq = freq;
  setStateFromBuild(result);
}

/* Render codes list */
function renderCodes(){
  codesView.innerHTML = '';
  const entries = Object.keys(state.codes).map(ch=> ({ch, code: state.codes[ch], freq: state.frequencies[ch] || 0}));
  entries.sort((a,b) => (b.freq - a.freq) || a.code.length - b.code.length || (a.ch > b.ch?1:-1));
  for(const e of entries){
    const div = document.createElement('div');
    div.className = 'code-row';
    div.innerHTML = `<div style="font-weight:700">${escapeVisible(e.ch)}</div>
      <div style="color:var(--muted);font-size:12px">${describeChar(e.ch)}</div>
      <div style="margin-top:6px; font-family:monospace">${e.code}</div>
      <div style="margin-top:6px;color:var(--muted);font-size:12px">freq: ${e.freq}</div>`;
    codesView.appendChild(div);
  }
  if(entries.length === 0){
    codesView.innerHTML = '<div class="small-muted">No codes (build a tree first)</div>';
  }
}

/* Update encoded/decoded displays and stats */
function updateEncodedDecoded(){
  encodedView.textContent = state.encoded || '';
  encodeBits.value = state.encoded || '';
  decodedView.textContent = state.decoded || '';
  // stats
  const textLen = inputText.value.length;
  const origBits = textLen * 8;
  const huffBits = state.encoded.length || 0;
  origSize.textContent = origBits + ' bits';
  huffSize.textContent = huffBits + ' bits';
  const compr = origBits ? Math.round((1 - (huffBits / origBits)) * 100) : 0;
  compression.textContent = (isFinite(compr) ? compr : 0) + '%';
}

/* Controls: play, step, decode, copy, sample */
playBtn.addEventListener('click', ()=>{
  if(state.playTimer){
    stopPlay();
  } else {
    startPlay();
  }
});
function startPlay(){
  if(!state.steps || state.steps.length <= 1) return;
  playBtn.textContent = 'Pause';
  state.playTimer = setInterval(()=>{
    if(state.step < state.steps.length - 1){
      state.step++;
      renderStep(state.step);
    } else {
      stopPlay();
    }
  }, state.playSpeed);
}
function stopPlay(){
  playBtn.textContent = 'Play';
  clearInterval(state.playTimer);
  state.playTimer = null;
}

stepNext.addEventListener('click', ()=>{
  if(!state.steps || state.steps.length <= 1) return;
  if(state.step < state.steps.length - 1){
    state.step++;
    renderStep(state.step);
  }
});
stepPrev.addEventListener('click', ()=>{
  if(!state.steps || state.steps.length <= 1) return;
  if(state.step > 0){
    state.step--;
    renderStep(state.step);
  }
});
resetStep.addEventListener('click', ()=>{
  state.step = 0;
  renderStep(state.step);
});

function renderStep(idx){
  stepIndex.textContent = idx;
  const s = state.steps[idx];
  const snap = s && s.queue ? s.queue : s;
  renderQueue(snap);
  // small highlight of merged nodes if available
  if(s && s.merged){
    // show an annotation in the queue (we'll just reflect by appending info line)
    const info = document.createElement('div');
    info.className = 'small-muted';
    info.style.marginTop = '6px';
    info.textContent = `Merged nodes ${s.merged.aId} + ${s.merged.bId} -> ${s.merged.parentId}`;
    queueView.appendChild(info);
  }
  // only render final tree when at last step
  if(idx === state.steps.length - 1){
    renderTreeSVG(state.root, state.codes);
  } else {
    // render partial tree? For simplicity show final tree always but we can fade
    renderTreeSVG(state.root, state.codes);
  }
}

/* decode button - decode bits in encodeBits input */
decodeBtn.addEventListener('click', ()=>{
  const bits = encodeBits.value.trim();
  if(!state.root){
    alert('Build a Huffman tree first.');
    return;
  }
  const dec = decodeBits(bits, state.root);
  if(dec === null){
    alert('Invalid or incomplete bit string for the current Huffman tree.');
    return;
  }
  decodedView.textContent = dec;
});

copyBits.addEventListener('click', ()=>{
  const bits = encodeBits.value;
  if(!bits) return;
  navigator.clipboard && navigator.clipboard.writeText(bits).then(()=> {
    copyBits.textContent = 'Copied';
    setTimeout(()=> copyBits.textContent = 'Copy Bits', 800);
  });
});

showDecoded.addEventListener('click', ()=>{
  if(!state.encoded){
    alert('No encoded bits available (build first).');
    return;
  }
  const dec = decodeBits(state.encoded, state.root);
  if(dec === null){
    decodedView.textContent = 'Decoding failed';
  } else {
    decodedView.textContent = dec;
  }
});

/* Build button and helpers */
buildBtn.addEventListener('click', ()=>{
  buildAll();
  stopPlay();
});
randomBtn.addEventListener('click', ()=>{
  inputText.value = sampleTexts[Math.floor(Math.random()*sampleTexts.length)];
});
clearBtn.addEventListener('click', ()=>{
  inputText.value = '';
  freqList.innerHTML = '';
  queueView.innerHTML = '';
  codesView.innerHTML = '';
  encodedView.textContent = '';
  decodedView.textContent = '';
  treeSVG.innerHTML = '';
  origSize.textContent = '0 bits';
  huffSize.textContent = '0 bits';
  compression.textContent = '0%';
  state = { frequencies: {}, nodes: [], steps: [], root: null, codes: {}, encoded: '', decoded: '', playTimer: null, playSpeed:800, step: 0};
  stepIndex.textContent = '0';
  stepCount.textContent = '0';
});

/* When filters change, re-render frequencies */
minFreq.addEventListener('input', ()=> renderFrequencies(state.frequencies));
topK.addEventListener('input', ()=> renderFrequencies(state.frequencies));

/* On load, build initial sample */
(function init(){
  // build initial
  buildAll();
  // keep stepCount updated
  stepCount.textContent = state.steps.length - 1 >= 0 ? state.steps.length - 1 : 0;
})();

/* Extend build function to set initialFreq and other state fields */
function buildHuffmanFromFreqWithState(freqMap){
  const ret = buildHuffmanFromFreq(freqMap);
  ret.initialFreq = freqMap;
  return ret;
}

/* Replace earlier build usage with one that sets state properly */
function buildAll(){
  const text = inputText.value;
  const freq = computeFrequencies(text);
  state.frequencies = freq;
  const result = buildHuffmanFromFreq(freq);
  result.initialFreq = freq;
  // set internal state
  state.nodes = result.initialQueue || [];
  state.root = result.root || null;
  state.steps = result.steps || [];
  state.codes = assignCodes(state.root);
  state.encoded = encodeText(text, state.codes) || '';
  state.decoded = decodeBits(state.encoded, state.root) || '';
  state.step = 0;
  stepCount.textContent = state.steps.length - 1 >= 0 ? state.steps.length - 1 : 0;
  updateUIAfterBuild();
}

/* Small helper to expose tree structure in console for debugging (disabled in production) */
function debugDump(){
  console.log('freq', state.frequencies);
  console.log('codes', state.codes);
  console.log('root', state.root);
}

/* Keyboard shortcuts for playing and stepping */
document.addEventListener('keydown', (e)=>{
  if(e.key === ' ') { e.preventDefault(); playBtn.click(); }
  if(e.key === 'ArrowRight') stepNext.click();
  if(e.key === 'ArrowLeft') stepPrev.click();
});
</script>
</body>
</html>