<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Adjacency List — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#56b6f7;
      --muted:#94a3b8;
      --card:#081023;
      --good:#16a34a;
      --danger:#ef4444;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{background:linear-gradient(180deg,#041028 0%, #071428 60%, #07172a 100%);color:#e6eef8;}
    .container{display:flex;gap:18px;padding:18px;height:100vh;box-sizing:border-box;}
    .left{width:360px;display:flex;flex-direction:column;gap:12px;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03);}
    h1{margin:0;font-size:18px;color:var(--accent);}
    p.small{margin:6px 0 0 0;color:var(--muted);font-size:12px;}
    .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;}
    input[type="text"], input[type="number"], select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:inherit;}
    button{background:var(--accent);border:none;color:#021027;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);}
    .smallbtn{padding:6px 8px;font-size:13px;border-radius:8px;}
    .muted{color:var(--muted);font-size:13px;}
    .adj-list{max-height:260px;overflow:auto;margin-top:8px;padding:8px;background:rgba(255,255,255,0.01);border-radius:6px;font-family:monospace;font-size:13px;}
    .row{display:flex;gap:8px;align-items:center;}
    label{font-size:13px;color:var(--muted);}
    .canvas-wrap{flex:1;display:flex;flex-direction:column;gap:12px;}
    #canvas{background:linear-gradient(180deg,rgba(5,12,24,0.6),rgba(6,14,28,0.3));border-radius:12px;flex:1;box-shadow: inset 0 2px 18px rgba(0,0,0,0.35);cursor:grab;}
    .legend{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:13px;}
    .dot{width:12px;height:12px;border-radius:50%;}
    .node-default{background:#0ea5e9;border:2px solid rgba(255,255,255,0.06);}
    .node-visited{background:var(--good);}
    .node-front{background:#f59e0b;}
    .node-target{background:#ef4444;}
    .footer-actions{display:flex;gap:8px;align-items:center;}
    .traversal-controls{display:flex;gap:8px;align-items:center;margin-top:8px;}
    .smallmuted{font-size:12px;color:var(--muted);}
    textarea{width:100%;height:80px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);color:inherit;padding:8px;font-family:monospace;}
    .help{font-size:13px;color:var(--muted);line-height:1.35;}
    footer{color:var(--muted);font-size:12px;text-align:center;margin-top:6px;}
    .edge-label{font-size:11px;color:var(--muted);background:rgba(255,255,255,0.02);padding:4px;border-radius:6px;}
  </style>
</head>
<body>
  <div class="container">
    <div class="left">
      <div class="card">
        <h1>Adjacency List — Interactive Demo</h1>
        <p class="small">An adjacency list represents a graph as a mapping from each node to a list of its neighbors. It's memory-efficient for sparse graphs.</p>

        <div style="margin-top:10px" class="row">
          <div style="flex:1">
            <label>Graph type</label><br>
            <select id="directedSelect">
              <option value="false">Undirected</option>
              <option value="true">Directed</option>
            </select>
          </div>
          <div style="width:120px">
            <label>Max nodes</label><br>
            <input id="maxNodes" type="number" value="12" min="2" max="24" />
          </div>
        </div>

        <div class="controls">
          <button id="addNodeBtn">Add Node</button>
          <button id="randBtn" class="ghost smallbtn">Random Graph</button>
          <button id="clearBtn" class="ghost smallbtn">Clear</button>
          <button id="exportBtn" class="ghost smallbtn">Export JSON</button>
          <button id="importBtn" class="ghost smallbtn">Import JSON</button>
        </div>

        <div style="margin-top:8px" class="row">
          <div style="flex:1">
            <label>Add edge</label><br>
            <input id="fromNode" type="text" placeholder="from (e.g., A)" />
          </div>
          <div style="flex:1">
            <label>&nbsp;</label><br>
            <input id="toNode" type="text" placeholder="to (e.g., B)" />
          </div>
          <div style="width:80px;display:flex;align-items:end;">
            <button id="addEdgeBtn" style="width:100%;">Add</button>
          </div>
        </div>

        <div style="margin-top:8px" class="row">
          <div style="flex:1">
            <label>Remove node</label><br>
            <input id="removeNodeInput" type="text" placeholder="Node id" />
          </div>
          <div style="width:120px;display:flex;align-items:end;">
            <button id="removeNodeBtn" class="ghost" style="width:100%;">Remove</button>
          </div>
        </div>

        <div class="adj-list" id="adjView" aria-live="polite"></div>

        <div style="margin-top:8px" class="traversal-controls">
          <div style="flex:1">
            <label>Traversal start</label><br>
            <input id="startNode" type="text" placeholder="Start node (e.g., A)" />
          </div>
          <div>
            <label>&nbsp;</label><br>
            <select id="traversalType">
              <option value="bfs">BFS (queue)</option>
              <option value="dfs">DFS (stack)</option>
            </select>
          </div>
          <div style="width:90px;display:flex;align-items:end;">
            <button id="runTraversal" class="smallbtn">Run</button>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div style="flex:1;">
            <label>Animation speed (ms)</label><br>
            <input id="speed" type="number" value="600" min="50" max="2000" />
          </div>
          <div style="width:120px;">
            <label>Highlight target</label><br>
            <input id="targetNode" type="text" placeholder="optional" />
          </div>
        </div>

        <div style="margin-top:8px;" class="smallmuted">
          Tip: Drag nodes on the canvas. Click a node to toggle selection and see its neighbors highlighted.
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <div class="legend">
            <div style="display:flex;gap:6px;align-items:center;">
              <div class="dot node-default"></div><div class="smallmuted">Default</div>
            </div>
            <div style="display:flex;gap:6px;align-items:center;">
              <div class="dot node-front"></div><div class="smallmuted">Frontier</div>
            </div>
            <div style="display:flex;gap:6px;align-items:center;">
              <div class="dot node-visited"></div><div class="smallmuted">Visited</div>
            </div>
            <div style="display:flex;gap:6px;align-items:center;">
              <div class="dot node-target"></div><div class="smallmuted">Target</div>
            </div>
          </div>
          <div class="edge-label">Adjacency List — Map(node -> [neighbors])</div>
        </div>
        <p class="help" style="margin-top:8px;">
          In code an adjacency list is usually represented as: { A: ['B', 'C'], B: ['A'], C: [] }.
          It's efficient for iterating neighbors and uses O(V + E) memory/time for typical traversals.
        </p>
      </div>

      <footer>
        Built for learning • Click nodes to interact • Export/import graph JSON
      </footer>
    </div>

    <div class="canvas-wrap">
      <div class="card" style="flex:1;display:flex;flex-direction:column;padding:10px;">
        <canvas id="canvas" width="1000" height="700"></canvas>
      </div>

      <div class="card" style="display:flex;gap:8px;align-items:flex-start;flex-wrap:wrap;">
        <div style="flex:1;">
          <label>Raw JSON</label>
          <textarea id="jsonArea" placeholder='{"directed":false,"nodes":["A"],"adj":{"A":["B"]}}'></textarea>
        </div>
        <div style="width:160px;display:flex;flex-direction:column;gap:8px;">
          <button id="loadJsonBtn">Load JSON to Graph</button>
          <button id="copyJsonBtn" class="ghost">Copy JSON</button>
          <div style="font-size:12px;color:var(--muted);">Edge weight demo: edges are unweighted here; you can extend adjacency lists to store objects (neighbor, weight).</div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // Simple interactive adjacency list demo
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const adjView = document.getElementById('adjView');
  const jsonArea = document.getElementById('jsonArea');

  let directed = false;
  let maxNodes = parseInt(document.getElementById('maxNodes').value,10) || 12;
  const nodes = []; // {id,x,y}
  const adj = {}; // id -> [neighborId,...]
  let dragging = null;
  let offset = {x:0,y:0};
  const radius = 22;

  // UI elements
  const directedSelect = document.getElementById('directedSelect');
  const addNodeBtn = document.getElementById('addNodeBtn');
  const randBtn = document.getElementById('randBtn');
  const clearBtn = document.getElementById('clearBtn');
  const addEdgeBtn = document.getElementById('addEdgeBtn');
  const fromNodeInput = document.getElementById('fromNode');
  const toNodeInput = document.getElementById('toNode');
  const removeNodeBtn = document.getElementById('removeNodeBtn');
  const removeNodeInput = document.getElementById('removeNodeInput');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const startNodeInput = document.getElementById('startNode');
  const runTraversalBtn = document.getElementById('runTraversal');
  const traversalType = document.getElementById('traversalType');
  const speedInput = document.getElementById('speed');
  const targetNodeInput = document.getElementById('targetNode');
  const jsonLoadBtn = document.getElementById('loadJsonBtn');
  const copyJsonBtn = document.getElementById('copyJsonBtn');
  const maxNodesInput = document.getElementById('maxNodes');

  function randId() {
    // returns next letter A,B,...Z,AA,AB...
    const existing = new Set(nodes.map(n=>n.id));
    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for (let len=1; len<=3; len++){
      const total = Math.pow(26,len);
      for (let i=0;i<total;i++){
        let x = i;
        let s = '';
        for (let j=0;j<len;j++){
          s = letters[x%26] + s;
          x = Math.floor(x/26);
        }
        if (!existing.has(s)) return s;
      }
    }
    return `N${nodes.length+1}`;
  }

  function addNode(id, x, y) {
    if (!id) id = randId();
    if (Object.keys(adj).length >= maxNodes) { alert('Reached max nodes'); return null; }
    if (adj[id]) { alert('Node exists: ' + id); return null; }
    if (typeof x !== 'number') {
      x = 80 + Math.random()*(canvas.width-160);
      y = 80 + Math.random()*(canvas.height-160);
    }
    nodes.push({id,x,y});
    adj[id] = [];
    render();
    return id;
  }

  function removeNode(id) {
    if (!adj[id]) { alert('No such node: ' + id); return; }
    // remove from nodes array
    const idx = nodes.findIndex(n=>n.id===id);
    if (idx>=0) nodes.splice(idx,1);
    delete adj[id];
    // remove references
    for (const k of Object.keys(adj)) {
      adj[k] = adj[k].filter(n => n !== id);
    }
    render();
  }

  function addEdge(a,b) {
    if (!adj[a] || !adj[b]) { alert('Both nodes must exist'); return; }
    if (!adj[a].includes(b)) adj[a].push(b);
    if (!directed) {
      if (!adj[b].includes(a)) adj[b].push(a);
    }
    render();
  }

  function removeEdge(a,b) {
    if (adj[a]) adj[a] = adj[a].filter(x=>x!==b);
    if (!directed && adj[b]) adj[b] = adj[b].filter(x=>x!==a);
    render();
  }

  function adjacencyText() {
    const keys = Object.keys(adj).sort();
    if (keys.length===0) return '(empty graph)';
    return keys.map(k => `${k}: [${adj[k].join(', ')}]`).join('\n');
  }

  function updateAdjView() {
    adjView.textContent = adjacencyText();
    // set json area also
    const exportObj = {directed: directed, nodes: nodes.map(n=>n.id), adj: adj};
    jsonArea.value = JSON.stringify(exportObj, null, 2);
  }

  function render() {
    updateAdjView();
    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // draw edges
    ctx.lineWidth = 2;
    ctx.font = '12px Inter, Arial';
    for (const u of nodes) {
      const neigh = adj[u.id] || [];
      for (const vId of neigh) {
        const v = nodes.find(n=>n.id===vId);
        if (!v) continue;
        drawEdge(u, v);
      }
    }
    // draw nodes
    for (const n of nodes) drawNode(n);
  }

  function drawEdge(a,b,opts={color:'rgba(200,200,220,0.14)'}) {
    const ax = a.x, ay = a.y, bx = b.x, by = b.y;
    const dx = bx - ax, dy = by - ay;
    const dist = Math.hypot(dx,dy);
    const ux = dx/dist, uy = dy/dist;
    const startX = ax + ux*radius*0.8;
    const startY = ay + uy*radius*0.8;
    const endX = bx - ux*radius*0.8;
    const endY = by - uy*radius*0.8;

    ctx.strokeStyle = opts.color;
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    // slight curve for readability when undirected and two-way edges exist
    const mx = (startX + endX)/2 + (-uy)*10;
    const my = (startY + endY)/2 + (ux)*10;
    ctx.quadraticCurveTo(mx,my,endX,endY);
    ctx.stroke();

    if (directed) {
      // arrowhead at end
      const angle = Math.atan2(endY - my, endX - mx);
      const arrowSize = 8;
      ctx.fillStyle = opts.color;
      ctx.beginPath();
      ctx.moveTo(endX, endY);
      ctx.lineTo(endX - arrowSize*Math.cos(angle - Math.PI/6), endY - arrowSize*Math.sin(angle - Math.PI/6));
      ctx.lineTo(endX - arrowSize*Math.cos(angle + Math.PI/6), endY - arrowSize*Math.sin(angle + Math.PI/6));
      ctx.closePath();
      ctx.fill();
    }
  }

  function drawNode(n, opts={color:'#0ea5e9', labelColor:'#021027'}) {
    ctx.beginPath();
    ctx.fillStyle = opts.color || '#0ea5e9';
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 2;
    roundRect(ctx, n.x - radius, n.y - radius, radius*2, radius*2, 100);
    ctx.fill();
    ctx.stroke();

    // label
    ctx.fillStyle = '#021027';
    ctx.font = 'bold 14px Inter, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(n.id, n.x, n.y);
  }

  function roundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Interactions
  canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const node = nodes.find(n => Math.hypot(n.x-mx, n.y-my) <= radius);
    if (node) {
      dragging = node;
      offset.x = mx - node.x;
      offset.y = my - node.y;
      canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    dragging.x = Math.max(40, Math.min(canvas.width-40, mx - offset.x));
    dragging.y = Math.max(40, Math.min(canvas.height-40, my - offset.y));
    render();
  });

  canvas.addEventListener('mouseup', e => {
    dragging = null;
    canvas.style.cursor = 'grab';
  });
  canvas.addEventListener('mouseleave', e => { dragging = null; canvas.style.cursor = 'grab'; });

  canvas.addEventListener('click', e => {
    // click to highlight neighbors
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const node = nodes.find(n => Math.hypot(n.x-mx, n.y-my) <= radius);
    if (!node) return;
    // temporarily paint selected node and its neighbors
    flashNeighbors(node.id);
  });

  let flashTimer;
  function flashNeighbors(id) {
    clearTimeout(flashTimer);
    // draw custom overlay
    render();
    // draw neighbors highlight
    const center = nodes.find(n=>n.id===id);
    if (!center) return;
    // draw center
    drawNode(center, {color:'#ef4444'});
    // draw neighbors
    const neigh = adj[id] || [];
    for (const nid of neigh) {
      const n = nodes.find(x=>x.id===nid);
      if (n) drawNode(n, {color:'#f59e0b'});
      // emphasize edge
      if (n) drawEdge(center, n, {color:'#f59e0b'});
    }
    flashTimer = setTimeout(render, 700);
  }

  // Controls
  directedSelect.addEventListener('change', e => {
    directed = (e.target.value === 'true');
    render();
  });

  addNodeBtn.addEventListener('click', () => {
    const id = addNode();
    if (id) {
      // center new node label in json
      render();
    }
  });

  randBtn.addEventListener('click', () => {
    // random small graph
    clearGraph();
    maxNodes = parseInt(maxNodesInput.value,10) || 12;
    const n = Math.min(maxNodes, 3 + Math.floor(Math.random()*6));
    for (let i=0;i<n;i++) addNode();
    const ids = nodes.map(n=>n.id);
    // random edges
    for (let i=0;i<ids.length;i++){
      for (let j=i+1;j<ids.length;j++){
        if (Math.random()<0.35) {
          addEdge(ids[i], ids[j]);
        }
      }
    }
    render();
  });

  clearBtn.addEventListener('click', clearGraph);

  function clearGraph() {
    nodes.length = 0;
    for (const k of Object.keys(adj)) delete adj[k];
    render();
  }

  addEdgeBtn.addEventListener('click', () => {
    const a = fromNodeInput.value.trim().toUpperCase();
    const b = toNodeInput.value.trim().toUpperCase();
    if (!a || !b) { alert('Enter both node ids'); return; }
    if (!adj[a] || !adj[b]) {
      const ok = confirm('One or both nodes do not exist. Create missing nodes?');
      if (!ok) return;
      if (!adj[a]) addNode(a);
      if (!adj[b]) addNode(b);
    }
    addEdge(a,b);
  });

  removeNodeBtn.addEventListener('click', () => {
    const n = removeNodeInput.value.trim().toUpperCase();
    if (!n) return alert('Provide node id');
    removeNode(n);
  });

  exportBtn.addEventListener('click', () => {
    const obj = {directed, nodes: nodes.map(n=>n.id), adj};
    const txt = JSON.stringify(obj, null, 2);
    navigator.clipboard?.writeText(txt).then(()=> alert('Copied JSON to clipboard')).catch(()=> {
      jsonArea.value = txt;
      alert('JSON placed in text area');
    });
  });

  importBtn.addEventListener('click', () => {
    const s = jsonArea.value.trim();
    if (!s) return alert('Paste JSON into the Raw JSON box first.');
    try {
      const obj = JSON.parse(s);
      loadFromObject(obj);
    } catch (err) {
      alert('Invalid JSON: ' + err.message);
    }
  });

  jsonLoadBtn.addEventListener('click', () => {
    const s = jsonArea.value.trim();
    if (!s) return alert('Paste JSON into the Raw JSON box first.');
    try {
      const obj = JSON.parse(s);
      loadFromObject(obj);
    } catch (err) {
      alert('Invalid JSON: ' + err.message);
    }
  });

  copyJsonBtn.addEventListener('click', () => {
    navigator.clipboard?.writeText(jsonArea.value).then(()=>alert('Copied')).catch(()=>alert('Unable to copy'));
  });

  function loadFromObject(obj) {
    if (!obj || typeof obj !== 'object') return alert('Invalid object');
    directed = !!obj.directed;
    directedSelect.value = directed ? 'true' : 'false';
    clearGraph();
    if (Array.isArray(obj.nodes)) {
      for (const id of obj.nodes) {
        addNode(id);
      }
    }
    if (obj.adj && typeof obj.adj === 'object') {
      for (const k of Object.keys(obj.adj)) {
        if (!adj[k]) addNode(k);
      }
      for (const k of Object.keys(obj.adj)) {
        adj[k] = obj.adj[k].slice();
      }
    }
    render();
  }

  // Traversal with visualization
  async function visualizeTraversal(startId, type='bfs', target=null) {
    if (!adj[startId]) { alert('Start node does not exist'); return; }
    const delay = ms => new Promise(res => setTimeout(res, ms));
    const speed = Number(speedInput.value) || 600;
    const visited = new Set();
    const order = [];
    const highlightState = {}; // id -> 'default'|'front'|'visited'|'target'
    for (const n of nodes) highlightState[n.id] = 'default';
    if (target && adj[target]) highlightState[target] = 'target';

    // helper to redraw with states
    function drawWithState() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // edges: if both ends visited, tint green, if frontier tint orange
      for (const u of nodes) {
        for (const vId of adj[u.id]||[]) {
          const v = nodes.find(x=>x.id===vId);
          if (!v) continue;
          let color = 'rgba(200,200,220,0.14)';
          if (highlightState[u.id] === 'front' || highlightState[vId]==='front') color = '#f59e0b';
          if (highlightState[u.id] === 'visited' && highlightState[vId] === 'visited') color = '#16a34a88';
          if (highlightState[vId] === 'target' || highlightState[u.id]==='target') color = '#ef4444';
          drawEdge(u,v,{color});
        }
      }
      for (const n of nodes) {
        let col = '#0ea5e9';
        if (highlightState[n.id]==='visited') col = '#16a34a';
        if (highlightState[n.id]==='front') col = '#f59e0b';
        if (highlightState[n.id]==='target') col = '#ef4444';
        drawNode(n,{color:col});
      }
    }

    if (type === 'bfs') {
      const q = [startId];
      highlightState[startId] = 'front';
      drawWithState();
      await delay(speed);
      while (q.length) {
        const cur = q.shift();
        highlightState[cur] = 'visited';
        visited.add(cur);
        order.push(cur);
        drawWithState();
        if (cur === target) break;
        await delay(speed);
        for (const nb of adj[cur]||[]) {
          if (!visited.has(nb) && !q.includes(nb)) {
            q.push(nb);
            highlightState[nb] = 'front';
          }
        }
        drawWithState();
        await delay(speed/1.6);
      }
    } else { // dfs iterative
      const stack = [startId];
      highlightState[startId] = 'front';
      drawWithState();
      await delay(speed);
      while (stack.length) {
        const cur = stack.pop();
        if (visited.has(cur)) continue;
        visited.add(cur);
        highlightState[cur] = 'visited';
        order.push(cur);
        drawWithState();
        if (cur === target) break;
        await delay(speed);
        // push neighbors in reverse so the order is natural
        const neigh = (adj[cur]||[]).slice().reverse();
        for (const nb of neigh) {
          if (!visited.has(nb)) {
            stack.push(nb);
            highlightState[nb] = 'front';
          }
        }
        drawWithState();
        await delay(speed/1.6);
      }
    }

    // show final order
    alert(`${type.toUpperCase()} traversal order:\n` + order.join(' → '));
    render();
  }

  runTraversalBtn.addEventListener('click', () => {
    const start = startNodeInput.value.trim().toUpperCase();
    const target = targetNodeInput.value.trim().toUpperCase() || null;
    if (!start) { alert('Enter start node'); return; }
    visualizeTraversal(start, traversalType.value, target);
  });

  // initialize canvas size responsively
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    render();
  }

  // watch for container resize
  const ro = new ResizeObserver(resizeCanvas);
  ro.observe(canvas.parentElement);

  // initial demo graph
  directed = false;
  directedSelect.value = 'false';
  addNode('A', 160, 140);
  addNode('B', 320, 100);
  addNode('C', 260, 260);
  addNode('D', 480, 200);
  addNode('E', 420, 80);
  addEdge('A','B');
  addEdge('A','C');
  addEdge('B','C');
  addEdge('C','D');
  addEdge('E','B');
  render();
})();
</script>
</body>
</html>