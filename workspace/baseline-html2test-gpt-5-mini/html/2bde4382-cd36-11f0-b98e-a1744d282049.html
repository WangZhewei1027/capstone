<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Priority Queue (Binary Heap) Demo</title>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --accent:#06b6d4;
    --muted:#94a3b8;
    --light:#e6eef6;
    --node:#1f2937;
    --node-border:#334155;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071025);font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  .container{max-width:1200px;margin:20px auto;padding:20px;color:var(--light);}
  header{display:flex;align-items:center;gap:16px;margin-bottom:12px}
  h1{font-size:20px;margin:0}
  .controls{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:12px}
  .panel{background:linear-gradient(180deg,var(--card),#07122a);border:1px solid rgba(255,255,255,0.03);padding:12px;border-radius:8px;}
  label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
  input[type=text],input[type=number],select{width:100%;padding:8px;border-radius:6px;border:1px solid var(--node-border);background:transparent;color:var(--light)}
  .row{display:flex;gap:8px}
  button{padding:8px 10px;border-radius:6px;border:0;background:var(--accent);color:#042;cursor:pointer;font-weight:600}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--light)}
  .small{padding:6px 8px;font-size:13px}
  .layout{display:grid;grid-template-columns:1fr 420px;gap:12px;margin-top:12px}
  .visual{min-height:420px;padding:12px}
  .heap-array{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .cell{min-width:80px;background:linear-gradient(180deg,#0b1220,#071128);border:1px solid var(--node-border);padding:8px;border-radius:8px;text-align:center;color:var(--light)}
  .cell .idx{font-size:11px;color:var(--muted)}
  .cell.highlight{box-shadow:0 6px 20px rgba(6,182,212,0.12);border-color:var(--accent);transform:translateY(-4px)}
  .svg-wrap{position:relative;height:360px;background:linear-gradient(180deg,transparent,rgba(255,255,255,0.01));border-radius:8px;border:1px dashed rgba(255,255,255,0.03);overflow:hidden}
  svg{width:100%;height:100%}
  .node{fill:var(--node);stroke:var(--node-border);stroke-width:1.5}
  .node-text{fill:var(--light);font-size:12px;font-weight:700}
  .node-sub{fill:var(--muted);font-size:11px}
  .log{max-height:220px;overflow:auto;background:linear-gradient(180deg,#071022,transparent);padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.02)}
  .muted{color:var(--muted);font-size:13px}
  footer{margin-top:12px;color:var(--muted);font-size:13px}
  .controls .panel{padding:10px}
  .flex{display:flex;gap:8px;align-items:center}
  .note{font-size:13px;color:var(--muted);margin-top:8px}
  .badge{background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:6px;font-weight:600;color:var(--muted);font-size:12px}
  .toggle{display:flex;gap:6px;align-items:center}
  .speed{width:120px}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>Priority Queue — Binary Heap Visualization</h1>
    <div class="badge">Array-backed binary heap (min/max)</div>
  </header>

  <div class="controls">
    <div class="panel">
      <label>Mode</label>
      <div class="row">
        <select id="mode">
          <option value="min">Min-Heap (smallest priority first)</option>
          <option value="max">Max-Heap (largest priority first)</option>
        </select>
        <div style="min-width:120px">
          <label>Animation speed</label>
          <select id="speed" class="speed">
            <option value="400">Slow</option>
            <option value="200" selected>Normal</option>
            <option value="60">Fast</option>
            <option value="0">Instant</option>
          </select>
        </div>
      </div>
      <div class="note">Use Min-Heap for Dijkstra-like semantics (smallest priority removed first).</div>
    </div>

    <div class="panel">
      <label>Insert element</label>
      <input type="text" id="item" placeholder="Label (optional)" />
      <div style="display:flex;gap:8px;margin-top:8px">
        <input type="number" id="priority" placeholder="Priority (number)" />
        <button id="insertBtn">Insert</button>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="insertRandom" class="secondary small">Insert Random</button>
        <button id="bulkRandom" class="secondary small">Bulk Random (5)</button>
      </div>
    </div>

    <div class="panel">
      <label>Operations</label>
      <div class="row">
        <button id="peekBtn" class="secondary small">Peek</button>
        <button id="popBtn" class="secondary small">Pop</button>
        <button id="clearBtn" class="secondary small">Clear</button>
      </div>
      <div style="margin-top:8px;">
        <label>Remove / Change priority by id</label>
        <div class="row">
          <input type="text" id="targetId" placeholder="id" />
          <input type="number" id="newPriority" placeholder="new priority" />
        </div>
        <div class="row" style="margin-top:8px">
          <button id="changeBtn" class="small">Change Priority</button>
          <button id="removeBtn" class="small secondary">Remove</button>
        </div>
      </div>
    </div>
  </div>

  <div class="layout">
    <div class="panel visual">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div class="muted">Heap as array (index → id:priority)</div>
        <div class="muted">Size: <span id="size">0</span></div>
      </div>
      <div id="array" class="heap-array"></div>

      <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center">
        <div class="muted">Tree view (binary heap)</div>
        <div class="muted">Comparisons: <span id="comps">0</span></div>
      </div>
      <div class="svg-wrap" id="treeWrap">
        <svg id="tree"></svg>
      </div>

      <div style="margin-top:10px" class="note">Click any array cell to mark it as selected (fills the id input for remove/change).</div>
    </div>

    <div>
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div class="muted">Operation log</div>
          <div class="muted">Time: <span id="time">0 ms</span></div>
        </div>
        <div id="log" class="log"></div>
        <div style="margin-top:8px" class="note">This demo shows per-step swaps when inserting/removing so you can follow heapify (bubble-up / sink-down).</div>
      </div>

      <div class="panel" style="margin-top:12px">
        <div class="muted">Quick explanation</div>
        <ul style="margin-top:8px;color:var(--muted);font-size:13px">
          <li>Heap stored as array; children of i are 2i+1 and 2i+2.</li>
          <li>Insert: push then bubble-up (swap toward root while out of order).</li>
          <li>Pop: replace root with last element then sink-down (swap toward leaves).</li>
          <li>Operations: insert/pop are O(log n), peek O(1), build-heap O(n).</li>
        </ul>
      </div>
    </div>
  </div>

  <footer>
    Tip: insert multiple items and press Pop repeatedly to see order. You can change between min/max to invert priority behavior.
  </footer>
</div>

<script>
/*
  Priority Queue (binary heap) demo:
  - Provides Min or Max heap behavior.
  - Visualizes array and tree and animates swaps.
  - Supports insert, pop, peek, remove by id, change priority.
*/

(function(){
  // Utilities
  function $(id){return document.getElementById(id);}
  function sleep(ms){ return new Promise(resolve=>setTimeout(resolve,ms)); }
  function now(){ return performance.now(); }

  // Priority item factory (auto id if not provided)
  let uniqueIdCounter = 1;
  function makeItem(label, priority){
    const id = label ? label.toString() : ("item"+(uniqueIdCounter++));
    return {id, priority: Number(priority)};
  }

  // Heap class with animation hooks
  class BinaryHeap {
    constructor(isMin=true, onStep){
      this._arr = [];
      this.isMin = !!isMin;
      this.onStep = onStep || (()=>{}); // onStep({type, i, j, arr})
      this.comparisons = 0;
    }
    size(){ return this._arr.length; }
    peek(){ return this._arr[0] ?? null; }
    toArray(){ return this._arr.slice(); }
    comparator(a,b){
      // returns true if a has higher priority than b (should be above)
      this.comparisons++;
      if(this.isMin) return a.priority < b.priority;
      return a.priority > b.priority;
    }

    async insert(item){
      const i = this._arr.length;
      this._arr.push(item);
      await this.onStep({type:'push', i, arr:this.toArray()});
      await this._bubbleUp(i);
    }

    async pop(){
      if(this._arr.length === 0) return null;
      const root = this._arr[0];
      const last = this._arr.pop();
      await this.onStep({type:'popRoot', arr:this.toArray(), popped:root});
      if(this._arr.length>0){
        this._arr[0] = last;
        await this.onStep({type:'replaceRoot', arr:this.toArray()});
        await this._sinkDown(0);
      }
      return root;
    }

    async _bubbleUp(i){
      while(i>0){
        const parent = Math.floor((i-1)/2);
        if(this.comparator(this._arr[i], this._arr[parent])){
          await this._swap(i,parent);
          i = parent;
        } else break;
      }
    }

    async _sinkDown(i){
      const n = this._arr.length;
      while(true){
        const left = 2*i+1, right = 2*i+2;
        let target = i;
        if(left < n && this.comparator(this._arr[left], this._arr[target])) target = left;
        if(right < n && this.comparator(this._arr[right], this._arr[target])) target = right;
        if(target === i) break;
        await this._swap(i,target);
        i = target;
      }
    }

    async _swap(i,j){
      const tmp = this._arr[i]; this._arr[i] = this._arr[j]; this._arr[j] = tmp;
      await this.onStep({type:'swap', i, j, arr:this.toArray()});
    }

    // Remove first element matching id
    async removeById(id){
      const idx = this._arr.findIndex(x=>x.id === id);
      if(idx === -1) return null;
      const removed = this._arr[idx];
      const last = this._arr.pop();
      await this.onStep({type:'removeAt', idx, arr:this.toArray(), removed});
      if(idx < this._arr.length){
        this._arr[idx] = last;
        await this.onStep({type:'replaceAt', idx, arr:this.toArray()});
        // Try both directions
        await this._bubbleUp(idx);
        await this._sinkDown(idx);
      }
      return removed;
    }

    // Change priority by id (first match)
    async changePriority(id, newPriority){
      const idx = this._arr.findIndex(x=>x.id === id);
      if(idx === -1) return null;
      const old = this._arr[idx].priority;
      this._arr[idx].priority = Number(newPriority);
      await this.onStep({type:'change', idx, arr:this.toArray(), old, newPriority});
      // Rebalance
      await this._bubbleUp(idx);
      await this._sinkDown(idx);
      return this._arr[idx];
    }

    // Build heap from array in O(n)
    async buildFrom(items){
      this._arr = items.slice();
      await this.onStep({type:'buildStart', arr:this.toArray()});
      const n = this._arr.length;
      for(let i=Math.floor(n/2)-1;i>=0;i--){
        await this._sinkDown(i);
      }
      await this.onStep({type:'buildEnd', arr:this.toArray()});
    }

    clear(){
      this._arr = [];
      this.comparisons = 0;
    }
  }

  // UI & Visualization
  const modeEl = $('mode');
  const speedEl = $('speed');
  const itemEl = $('item');
  const prioEl = $('priority');
  const insertBtn = $('insertBtn');
  const insertRandom = $('insertRandom');
  const bulkRandom = $('bulkRandom');
  const peekBtn = $('peekBtn');
  const popBtn = $('popBtn');
  const clearBtn = $('clearBtn');
  const arrayEl = $('array');
  const treeSvg = $('tree');
  const treeWrap = $('treeWrap');
  const logEl = $('log');
  const sizeEl = $('size');
  const compsEl = $('comps');
  const timeEl = $('time');
  const targetIdEl = $('targetId');
  const newPrioEl = $('newPriority');
  const changeBtn = $('changeBtn');
  const removeBtn = $('removeBtn');

  let animDelay = Number(speedEl.value);
  speedEl.addEventListener('change', ()=> animDelay = Number(speedEl.value));

  // onStep hook will display changes and animate
  let heap = null;

  function resetHeap(){
    heap = new BinaryHeap(modeEl.value === 'min', onStepAsync);
    uniqueIdCounter = 1;
    updateUI();
  }

  // Logging & UI helpers
  function log(msg){
    const at = new Date().toLocaleTimeString();
    logEl.insertAdjacentHTML('afterbegin', `<div style="padding:6px 0;border-bottom:1px dashed rgba(255,255,255,0.02)"><strong style="color:var(--light)">${at}</strong> <span style="color:var(--muted)">${msg}</span></div>`);
  }

  function clearLog(){ logEl.innerHTML=''; }

  function updateUI(highlightIndices=[]){
    const arr = heap.toArray();
    arrayEl.innerHTML='';
    arr.forEach((it,i)=>{
      const cell = document.createElement('div');
      cell.className = 'cell' + (highlightIndices.includes(i)?' highlight':'');
      cell.innerHTML = `<div class="idx">[${i}]</div><div style="font-size:13px">${it.id}</div><div class="muted" style="margin-top:6px">${it.priority}</div>`;
      cell.title = `Click to select id="${it.id}" index=${i}`;
      cell.addEventListener('click', ()=> { targetIdEl.value = it.id; });
      arrayEl.appendChild(cell);
    });
    sizeEl.textContent = arr.length;
    compsEl.textContent = heap.comparisons;
    drawTree(arr, highlightIndices);
  }

  function drawTree(arr, highlightIndices=[]){
    const svg = treeSvg;
    while(svg.firstChild) svg.removeChild(svg.firstChild);
    const w = treeWrap.clientWidth, h = treeWrap.clientHeight;
    svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
    if(arr.length===0) return;
    // Compute positions by levels
    const levels = [];
    let level = 0, i = 0;
    while(i < arr.length){
      const count = Math.pow(2, level);
      levels.push(arr.slice(i, i+count));
      i += count;
      level++;
    }
    // Node positions
    const positions = [];
    const levelHeight = h / (levels.length + 1);
    for(let d=0, index=0; d<levels.length; d++){
      const row = levels[d];
      const spacing = w / (row.length + 1);
      const y = (d+1) * levelHeight;
      for(let j=0;j<row.length && index<arr.length;j++, index++){
        const x = (j+1) * spacing;
        positions.push({x,y,index});
      }
    }
    // Draw edges
    positions.forEach(pos=>{
      const left = 2*pos.index+1, right = 2*pos.index+2;
      [left,right].forEach(childIdx=>{
        if(childIdx < positions.length){
          const child = positions[childIdx];
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', pos.x);
          line.setAttribute('y1', pos.y + 18);
          line.setAttribute('x2', child.x);
          line.setAttribute('y2', child.y - 16);
          line.setAttribute('stroke', 'rgba(255,255,255,0.04)');
          line.setAttribute('stroke-width','1.2');
          svg.appendChild(line);
        }
      });
    });
    // Draw nodes
    positions.forEach(p=>{
      const group = document.createElementNS('http://www.w3.org/2000/svg','g');
      const isHighlighted = highlightIndices.includes(p.index);
      const color = isHighlighted ? '#08363a' : null;
      const circle = document.createElementNS('http://www.w3.org/2000/svg','rect');
      circle.setAttribute('x', p.x - 44/2);
      circle.setAttribute('y', p.y - 22);
      circle.setAttribute('rx', 8);
      circle.setAttribute('ry', 8);
      circle.setAttribute('width', 44);
      circle.setAttribute('height', 44);
      circle.setAttribute('class','node');
      circle.setAttribute('fill', isHighlighted ? 'linear-gradient(0deg,#08363a,#044b4f)' : null);
      circle.setAttribute('style', isHighlighted ? 'fill:#062c31;stroke:#06b6d4;stroke-width:1.8' : '');
      group.appendChild(circle);
      const idText = document.createElementNS('http://www.w3.org/2000/svg','text');
      idText.setAttribute('x', p.x);
      idText.setAttribute('y', p.y - 2);
      idText.setAttribute('text-anchor','middle');
      idText.setAttribute('class','node-text');
      idText.textContent = `${arr[p.index].id}`;
      group.appendChild(idText);
      const subText = document.createElementNS('http://www.w3.org/2000/svg','text');
      subText.setAttribute('x', p.x);
      subText.setAttribute('y', p.y + 14);
      subText.setAttribute('text-anchor','middle');
      subText.setAttribute('class','node-sub');
      subText.textContent = `${arr[p.index].priority}`;
      group.appendChild(subText);
      svg.appendChild(group);
    });
  }

  // onStep hook handles animation and logs
  let lastStepTime = 0;
  async function onStepAsync(event){
    const t0 = now();
    // Update comparisons display
    compsEl.textContent = heap.comparisons;
    // If event contains indices, highlight them
    let highlights = [];
    if(event.type === 'swap'){
      log(`swap indices ${event.i} ↔ ${event.j}`);
      highlights = [event.i, event.j];
      updateUI(highlights);
      await sleep(animDelay);
    } else if(event.type === 'push'){
      log(`pushed at index ${event.i} (${event.arr[event.i]?.id}:${event.arr[event.i]?.priority})`);
      highlights = [event.i];
      updateUI(highlights);
      await sleep(animDelay);
    } else if(event.type === 'popRoot'){
      log(`popped root ${event.popped.id}:${event.popped.priority}`);
      updateUI([]);
      await sleep(animDelay);
    } else if(event.type === 'replaceRoot'){
      log(`replaced root with last element`);
      updateUI([0]);
      await sleep(animDelay);
    } else if(event.type === 'removeAt'){
      log(`removed ${event.removed.id} at index ${event.idx}`);
      updateUI([]);
      await sleep(animDelay);
    } else if(event.type === 'replaceAt'){
      log(`moved last element to index ${event.idx}`);
      updateUI([event.idx]);
      await sleep(animDelay);
    } else if(event.type === 'change'){
      log(`changed priority at index ${event.idx} from ${event.old} to ${event.newPriority}`);
      updateUI([event.idx]);
      await sleep(animDelay);
    } else if(event.type === 'buildStart'){
      log(`building heap from array (${event.arr.length} items)`);
      updateUI([]);
      await sleep(animDelay);
    } else if(event.type === 'buildEnd'){
      log(`heap build complete`);
      updateUI([]);
      await sleep(animDelay);
    } else {
      updateUI([]);
      await sleep(animDelay);
    }
    const t1 = now();
    lastStepTime = t1 - t0;
    timeEl.textContent = `${Math.round(lastStepTime)} ms`;
  }

  // Wire up UI events
  insertBtn.addEventListener('click', async ()=>{
    let label = itemEl.value.trim();
    let p = prioEl.value;
    if(p === '') { alert('Please enter a numeric priority'); return; }
    if(label === '') label = null;
    const item = makeItem(label, Number(p));
    const t0 = now();
    await heap.insert(item);
    const t1 = now();
    log(`inserted ${item.id}:${item.priority} (${Math.round(t1-t0)} ms)`);
    updateUI();
    itemEl.value=''; prioEl.value='';
  });

  insertRandom.addEventListener('click', async ()=>{
    const item = makeItem(null, Math.floor(Math.random()*100));
    await heap.insert(item);
    log(`inserted ${item.id}:${item.priority}`);
    updateUI();
  });

  bulkRandom.addEventListener('click', async ()=>{
    const arr = [];
    for(let i=0;i<5;i++) arr.push(makeItem(null, Math.floor(Math.random()*100)));
    const t0 = now();
    // Build by inserting one-by-one with animation, or fast build if speed=0
    for(let it of arr){
      await heap.insert(it);
    }
    const t1 = now();
    log(`bulk inserted 5 items (${Math.round(t1-t0)} ms)`);
    updateUI();
  });

  peekBtn.addEventListener('click', ()=>{
    const top = heap.peek();
    if(!top) { log('peek: heap is empty'); alert('Heap is empty'); return; }
    log(`peek: ${top.id}:${top.priority}`);
    alert(`Peek: ${top.id} — priority ${top.priority}`);
  });

  popBtn.addEventListener('click', async ()=>{
    const t0 = now();
    const popped = await heap.pop();
    const t1 = now();
    if(popped) log(`popped ${popped.id}:${popped.priority} (${Math.round(t1-t0)} ms)`);
    else log('pop attempted on empty heap');
    updateUI();
  });

  clearBtn.addEventListener('click', ()=>{
    heap.clear();
    clearLog();
    uniqueIdCounter = 1;
    updateUI();
    log('heap cleared');
  });

  changeBtn.addEventListener('click', async ()=>{
    const id = targetIdEl.value.trim();
    const np = newPrioEl.value;
    if(!id){ alert('Enter id to change'); return; }
    if(np === '') { alert('Enter new priority'); return; }
    const res = await heap.changePriority(id, Number(np));
    if(res) log(`changed ${id} to priority ${np}`);
    else log(`id "${id}" not found`);
    updateUI();
  });

  removeBtn.addEventListener('click', async ()=>{
    const id = targetIdEl.value.trim();
    if(!id){ alert('Enter id to remove'); return; }
    const res = await heap.removeById(id);
    if(res) log(`removed ${id}:${res.priority}`);
    else log(`id "${id}" not found`);
    updateUI();
  });

  modeEl.addEventListener('change', ()=>{
    resetHeap();
    log('mode switched to ' + modeEl.value);
  });

  // Initialize
  resetHeap();
  updateUI();

  // Populate demo items
  (async function seed(){
    const demo = [
      makeItem('A', 15),
      makeItem('B', 10),
      makeItem('C', 30),
      makeItem('D', 5),
      makeItem('E', 20)
    ];
    for(const it of demo){
      await heap.insert(it);
    }
    log('seeded demo items: A,B,C,D,E');
    updateUI();
  })();

  // Responsiveness: redraw on resize
  window.addEventListener('resize', ()=> updateUI());

})();
</script>
</body>
</html>