<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Deque (Double-Ended Queue) — Interactive Demo</title>
<style>
  :root {
    --bg: #0f1724;
    --panel: #0b1220;
    --accent: #7dd3fc;
    --muted: #94a3b8;
    --good: #bbf7d0;
    --danger: #fecaca;
    --slot: #071022;
    --slot-border: #1f2937;
  }
  html,body { height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; background: linear-gradient(180deg,#071226 0%, #071530 60%); color:#e6eef8; }
  .wrap { max-width:1000px; margin:28px auto; padding:20px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 6px 30px rgba(2,6,23,0.6); }
  h1 { margin:6px 0 12px 0; font-size:20px; color:var(--accent); }
  p.lead { margin:0 0 12px 0; color:var(--muted); font-size:13px; }
  .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:16px; }
  .input-row { display:flex; gap:8px; align-items:center; }
  input[type="text"] { padding:8px 10px; border-radius:8px; border:1px solid var(--slot-border); background:#031022; color:#dff3ff; outline:none; width:160px; }
  button { padding:8px 12px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); color:var(--accent); cursor:pointer; }
  button.secondary { color:var(--muted); border-color:rgba(255,255,255,0.02); }
  button.danger { color:#ffb4b4; }
  .panel { display:flex; gap:16px; align-items:flex-start; }
  .vis { flex:1 1 60%; min-width:300px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); padding:14px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); }
  .info { flex:1 1 36%; min-width:220px; padding:12px; border-radius:10px; background:linear-gradient(180deg, rgba(125,211,252,0.03), rgba(255,255,255,0.00)); border:1px solid rgba(125,211,252,0.06); }
  .buffer { display:flex; gap:8px; padding:18px 12px; justify-content:center; align-items:end; overflow:auto; }
  .slot { width:72px; height:72px; background:var(--slot); border:1px solid var(--slot-border); border-radius:8px; display:flex; align-items:center; justify-content:center; color:#bfe9ff; font-weight:600; position:relative; transition:transform 300ms ease, box-shadow 200ms ease; }
  .slot.empty { color:#243241; opacity:0.6; font-weight:400; }
  .slot .index { position:absolute; left:6px; top:6px; font-size:11px; color:var(--muted); }
  .pointer { text-align:center; font-size:12px; color:var(--muted); margin-top:6px; min-width:72px; }
  .pointers { display:flex; gap:8px; justify-content:center; margin-top:6px; }
  .slot.head { box-shadow: 0 6px 20px rgba(29,78,216,0.18); border-color:rgba(125,211,252,0.5); transform:translateY(-6px); }
  .slot.tail { box-shadow: 0 6px 20px rgba(16,185,129,0.12); border-color:rgba(34,197,94,0.4); transform:translateY(-6px); }
  .meta { font-size:13px; color:var(--muted); display:flex; gap:10px; flex-wrap:wrap; margin-bottom:8px; }
  .log { background: rgba(255,255,255,0.01); padding:8px; border-radius:8px; font-size:13px; color:var(--muted); max-height:220px; overflow:auto; border:1px solid rgba(255,255,255,0.02); }
  .complex { font-size:13px; color:var(--muted); margin-top:10px; }
  .complex b { color:var(--accent); }
  .small { font-size:12px; color:var(--muted); margin-top:8px; }
  .row { display:flex; gap:8px; flex-wrap:wrap; }
  footer { margin-top:14px; font-size:12px; color:var(--muted); }
  .badge { background:rgba(255,255,255,0.02); padding:6px 10px; border-radius:999px; color:var(--muted); border:1px solid rgba(255,255,255,0.02); }
  .muted { color:var(--muted); font-size:13px; }
  @media (max-width:760px) {
    .panel { flex-direction:column; }
    .buffer { padding:12px; }
    .slot { width:56px; height:56px; }
    .pointer, .pointers { min-width:56px; }
  }
</style>
</head>
<body>
<div class="wrap" role="application" aria-label="Deque demo">
  <h1>Deque (Double-Ended Queue) — Interactive Demo</h1>
  <p class="lead">A deque supports insertion and removal at both ends. This demo implements a circular-buffer-backed Deque with dynamic resizing. Try pushing/popping from either end and watch the internal buffer change.</p>

  <div class="controls">
    <div class="input-row">
      <input id="valueInput" type="text" placeholder="value (text or number)" aria-label="Value to insert">
      <button id="pushFrontBtn">Push Front</button>
      <button id="pushBackBtn">Push Back</button>
    </div>
    <div class="row">
      <button id="popFrontBtn" class="secondary">Pop Front</button>
      <button id="popBackBtn" class="secondary">Pop Back</button>
      <button id="peekFrontBtn" class="secondary">Peek Front</button>
      <button id="peekBackBtn" class="secondary">Peek Back</button>
      <button id="clearBtn" class="danger">Clear</button>
    </div>
    <div class="row">
      <button id="randomFillBtn" class="secondary">Random Fill</button>
      <button id="rotateLeftBtn" class="secondary">Rotate Left</button>
      <button id="rotateRightBtn" class="secondary">Rotate Right</button>
    </div>
  </div>

  <div class="panel">
    <div class="vis" aria-live="polite">
      <div class="meta">
        <div class="badge">Capacity: <span id="capSpan">—</span></div>
        <div class="badge">Size: <span id="sizeSpan">0</span></div>
        <div class="badge">Head index: <span id="headSpan">0</span></div>
      </div>

      <div class="buffer" id="buffer"></div>
      <div class="pointers" id="pointers"></div>
      <div class="small muted">Array-level view: empty slots show as faded. Highlights show logical head and tail.</div>
    </div>

    <div class="info">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <strong style="color:var(--accent)">Operations Log</strong>
        <button id="clearLogBtn" class="secondary">Clear Log</button>
      </div>
      <div class="log" id="log" aria-live="polite"></div>

      <div class="complex">
        Complexity (amortized):
        <ul style="margin:6px 0 0 18px; padding:0; color:var(--muted)">
          <li><b>pushFront / pushBack / popFront / popBack:</b> O(1)</li>
          <li><b>peekFront / peekBack / size / clear:</b> O(1)</li>
          <li><b>resize (internal):</b> O(n) but happens rarely; overall amortized O(1).</li>
        </ul>
      </div>
      <div class="small muted">Tip: Try alternating push/pop at different ends to see head/tail wrap inside the circular buffer.</div>
    </div>
  </div>

  <footer>
    Implementation note: This demo uses a circular array with a head index and a length. When capacity is reached it doubles the buffer and realigns items starting at index 0.
  </footer>
</div>

<script>
/*
  Deque implementation using a circular buffer with dynamic resizing.
  Methods: pushFront, pushBack, popFront, popBack, peekFront, peekBack, size, clear, toArray, rotate.
*/
class Deque {
  constructor(initialCapacity = 8) {
    this._capacity = Math.max(1, initialCapacity >>> 0);
    this._buffer = new Array(this._capacity);
    this._head = 0;   // index of first element
    this._length = 0; // number of elements
  }

  size() { return this._length; }

  _idx(i) {
    // logical index i (0..length-1) -> physical index in buffer
    return (this._head + i) % this._capacity;
  }

  _ensureCapacity(minCapacity) {
    if (this._capacity >= minCapacity) return;
    let newCap = this._capacity;
    while (newCap < minCapacity) newCap *= 2;
    const nb = new Array(newCap);
    // copy elements in order starting at head
    for (let i = 0; i < this._length; i++) nb[i] = this._buffer[this._idx(i)];
    this._buffer = nb;
    this._capacity = newCap;
    this._head = 0;
  }

  pushBack(value) {
    this._ensureCapacity(this._length + 1);
    this._buffer[this._idx(this._length)] = value;
    this._length++;
  }

  pushFront(value) {
    this._ensureCapacity(this._length + 1);
    this._head = (this._head - 1 + this._capacity) % this._capacity;
    this._buffer[this._head] = value;
    this._length++;
  }

  popFront() {
    if (this._length === 0) return undefined;
    const v = this._buffer[this._head];
    this._buffer[this._head] = undefined;
    this._head = (this._head + 1) % this._capacity;
    this._length--;
    return v;
  }

  popBack() {
    if (this._length === 0) return undefined;
    const idx = this._idx(this._length - 1);
    const v = this._buffer[idx];
    this._buffer[idx] = undefined;
    this._length--;
    return v;
  }

  peekFront() {
    if (this._length === 0) return undefined;
    return this._buffer[this._head];
  }

  peekBack() {
    if (this._length === 0) return undefined;
    return this._buffer[this._idx(this._length - 1)];
  }

  clear() {
    this._buffer = new Array(this._capacity);
    this._head = 0;
    this._length = 0;
  }

  toArray() {
    const a = new Array(this._length);
    for (let i = 0; i < this._length; i++) a[i] = this._buffer[this._idx(i)];
    return a;
  }

  // rotate by k steps to the left (positive k) or right (negative)
  rotate(k) {
    if (this._length === 0) return;
    // normalize k to [-length,length]
    k = ((k % this._length) + this._length) % this._length;
    this._head = (this._head + k) % this._capacity;
  }

  // Expose internal snapshot for visualization (do not mutate)
  _snapshot() {
    return {
      buffer: this._buffer.slice(),
      capacity: this._capacity,
      head: this._head,
      length: this._length
    };
  }
}

/* ---------- UI Code ---------- */

const deque = new Deque(8);

const bufferEl = document.getElementById('buffer');
const pointersEl = document.getElementById('pointers');
const capSpan = document.getElementById('capSpan');
const sizeSpan = document.getElementById('sizeSpan');
const headSpan = document.getElementById('headSpan');
const logEl = document.getElementById('log');

const valueInput = document.getElementById('valueInput');
const pushFrontBtn = document.getElementById('pushFrontBtn');
const pushBackBtn = document.getElementById('pushBackBtn');
const popFrontBtn = document.getElementById('popFrontBtn');
const popBackBtn = document.getElementById('popBackBtn');
const peekFrontBtn = document.getElementById('peekFrontBtn');
const peekBackBtn = document.getElementById('peekBackBtn');
const clearBtn = document.getElementById('clearBtn');
const randomFillBtn = document.getElementById('randomFillBtn');
const rotateLeftBtn = document.getElementById('rotateLeftBtn');
const rotateRightBtn = document.getElementById('rotateRightBtn');
const clearLogBtn = document.getElementById('clearLogBtn');

function log(msg, kind = 'info') {
  const p = document.createElement('div');
  p.textContent = msg;
  p.style.padding = '6px 4px';
  p.style.borderBottom = '1px dashed rgba(255,255,255,0.02)';
  if (kind === 'err') p.style.color = '#ffc2c2';
  logEl.prepend(p);
}

function render() {
  const snap = deque._snapshot();
  bufferEl.innerHTML = '';
  pointersEl.innerHTML = '';

  capSpan.textContent = snap.capacity;
  sizeSpan.textContent = snap.length;
  headSpan.textContent = snap.head;

  // create slot elements for each buffer cell
  for (let i = 0; i < snap.capacity; i++) {
    const slot = document.createElement('div');
    slot.className = 'slot';
    const idxLabel = document.createElement('div');
    idxLabel.className = 'index';
    idxLabel.textContent = i;
    slot.appendChild(idxLabel);

    const cell = snap.buffer[i];
    if (cell === undefined) {
      slot.classList.add('empty');
      slot.appendChild(document.createTextNode('•'));
    } else {
      slot.appendChild(document.createTextNode(String(cell)));
    }

    // highlight head/tail if inside logical region
    const inLogical = (() => {
      if (snap.length === 0) return false;
      const first = snap.head;
      const last = (snap.head + snap.length - 1) % snap.capacity;
      if (first <= last) {
        return i >= first && i <= last;
      } else {
        return i >= first || i <= last;
      }
    })();

    if (!inLogical) slot.style.opacity = '0.5';

    if (snap.length > 0) {
      if (i === snap.head) slot.classList.add('head');
      if (i === ((snap.head + snap.length - 1) % snap.capacity)) slot.classList.add('tail');
    }

    bufferEl.appendChild(slot);
  }

  // pointers (labels below)
  const headPtr = document.createElement('div');
  headPtr.className = 'pointer';
  headPtr.textContent = 'head → ' + (snap.length > 0 ? snap._head : snap.head); // fallback if empty
  // For correct displayed head, we use snap.head
  headPtr.textContent = 'head → ' + snap.head;
  pointersEl.appendChild(headPtr);

  const tailPtr = document.createElement('div');
  tailPtr.className = 'pointer';
  tailPtr.textContent = 'tail → ' + (snap.length > 0 ? ((snap.head + snap.length - 1) % snap.capacity) : '—');
  pointersEl.appendChild(tailPtr);
}

// wire up buttons
pushFrontBtn.addEventListener('click', () => {
  const v = valueInput.value.trim();
  if (v === '') {
    log('Enter a value before pushing.', 'err');
    return;
  }
  deque.pushFront(v);
  log(`pushFront(${v})`);
  valueInput.value = '';
  render();
});

pushBackBtn.addEventListener('click', () => {
  const v = valueInput.value.trim();
  if (v === '') {
    log('Enter a value before pushing.', 'err');
    return;
  }
  deque.pushBack(v);
  log(`pushBack(${v})`);
  valueInput.value = '';
  render();
});

popFrontBtn.addEventListener('click', () => {
  const v = deque.popFront();
  if (v === undefined) {
    log('popFront() → undefined (empty)', 'err');
  } else {
    log(`popFront() → ${v}`);
  }
  render();
});

popBackBtn.addEventListener('click', () => {
  const v = deque.popBack();
  if (v === undefined) {
    log('popBack() → undefined (empty)', 'err');
  } else {
    log(`popBack() → ${v}`);
  }
  render();
});

peekFrontBtn.addEventListener('click', () => {
  const v = deque.peekFront();
  log(`peekFront() → ${v === undefined ? 'undefined (empty)' : v}`);
});

peekBackBtn.addEventListener('click', () => {
  const v = deque.peekBack();
  log(`peekBack() → ${v === undefined ? 'undefined (empty)' : v}`);
});

clearBtn.addEventListener('click', () => {
  deque.clear();
  log('clear() — deque emptied');
  render();
});

randomFillBtn.addEventListener('click', () => {
  const count = Math.floor(Math.random() * 6) + 1;
  for (let i = 0; i < count; i++) {
    const v = Math.random().toString(36).substring(2, 7);
    // randomly push front or back
    if (Math.random() < 0.5) deque.pushBack(v);
    else deque.pushFront(v);
  }
  log(`random fill of ${count} elements`);
  render();
});

rotateLeftBtn.addEventListener('click', () => {
  if (deque.size() === 0) {
    log('rotateLeft() — deque empty', 'err'); return;
  }
  deque.rotate(1);
  log('rotate(1) — rotated left by 1');
  render();
});

rotateRightBtn.addEventListener('click', () => {
  if (deque.size() === 0) {
    log('rotateRight() — deque empty', 'err'); return;
  }
  deque.rotate(-1);
  log('rotate(-1) — rotated right by 1');
  render();
});

clearLogBtn.addEventListener('click', () => {
  logEl.innerHTML = '';
});

// allow Enter to push back by default
valueInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    pushBackBtn.click();
  }
});

// initial state
render();
log('Deque initialized (capacity 8). Try pushFront/pushBack, then popFront/popBack.');
</script>
</body>
</html>