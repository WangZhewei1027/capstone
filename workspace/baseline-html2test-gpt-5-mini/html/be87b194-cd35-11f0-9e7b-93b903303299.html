<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Kruskal's Algorithm — Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    html,body { height:100%; margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: #f6f8fa; color: #222; }
    .app { display:flex; height:100vh; }
    .left { width:72%; min-width:520px; background: #fff; border-right: 1px solid #e2e6ea; display:flex; flex-direction:column; }
    .canvas-wrap { flex:1; position:relative; overflow:hidden; }
    svg { width:100%; height:100%; background: linear-gradient(180deg,#ffffff,#fbfdff); cursor:crosshair; }
    .right { width:28%; min-width:320px; padding:12px; box-sizing:border-box; overflow:auto; }
    h1 { font-size:18px; margin:6px 0 12px 0; }
    .controls { display:flex; flex-wrap:wrap; gap:6px; align-items:center; margin-bottom:10px; }
    button, input[type=range], select { padding:6px 8px; border-radius:6px; border:1px solid #cbd5db; background:#fff; cursor:pointer; }
    button:active { transform:translateY(1px); }
    .small { font-size:13px; padding:5px 8px; }
    label { font-size:13px; display:flex; gap:6px; align-items:center; }
    .info { font-size:13px; color:#444; margin-top:8px; line-height:1.4; }
    .panel { background:#f8fafc; border:1px solid #e6edf3; padding:8px; border-radius:8px; margin-bottom:10px; }
    .list { font-family: monospace; font-size:13px; max-height:220px; overflow:auto; padding:6px; background:#fff; border-radius:6px; border:1px dashed #e2e6ea; }
    .edge-item { display:flex; justify-content:space-between; gap:6px; padding:4px 2px; align-items:center; }
    .sets { font-size:13px; }
    .legend { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
    .legend .box { display:flex; gap:6px; align-items:center; font-size:13px; }
    .swatch { width:14px; height:12px; border-radius:3px; border:1px solid rgba(0,0,0,0.08); }
    .footer { font-size:12px; color:#666; margin-top:8px; }
    .btn-danger { background:#fff; border:1px solid #ff6b6b; color:#c0392b }
    .btn-primary { background:#0b84ff; color:#fff; border:1px solid #0776e6 }
    .btn-ghost { background:#fff; border:1px solid #cbd5db; color:#222; }
    .weight-badge { background:#fff; border-radius:6px; padding:2px 6px; border:1px solid #e2e6ea; font-size:12px; }
    .controls-row { display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
    .status { font-weight:600; margin-top:8px; font-size:14px; }
    .muted { color:#666; font-size:13px; }
    .node { cursor:grab; }
    .node:active { cursor:grabbing; }
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div style="display:flex;gap:10px;align-items:center;padding:10px;border-bottom:1px solid #eef2f6;">
        <div style="display:flex;flex-direction:column">
          <strong style="font-size:16px">Kruskal's Algorithm — Interactive Visualization</strong>
          <span class="muted" style="font-size:13px">Build a graph, run Kruskal step-by-step to get a Minimum Spanning Tree (MST)</span>
        </div>
        <div style="margin-left:auto" class="muted">Click canvas to add node. Drag from a node to create an edge. Double-click an edge to edit weight.</div>
      </div>

      <div class="canvas-wrap" id="canvasWrap">
        <svg id="svgCanvas" xmlns="http://www.w3.org/2000/svg"></svg>
      </div>

      <div style="padding:8px;border-top:1px solid #eef2f6; display:flex; gap:8px; align-items:center;">
        <div class="muted">Mode:</div>
        <select id="modeSelect" style="padding:6px;border-radius:6px;">
          <option value="add">Add nodes + edges (default)</option>
          <option value="move">Move nodes</option>
          <option value="delete">Delete nodes/edges</option>
        </select>
        <div style="margin-left:8px" class="muted">Actions: Click empty → add node. Drag node → create edge. Click node → select for edge.</div>
      </div>
    </div>

    <div class="right">
      <h1>Controls</h1>

      <div class="panel">
        <div class="controls">
          <button id="randomGraph" class="small btn-ghost">Generate Random Graph</button>
          <button id="clearBtn" class="small btn-danger">Clear Graph</button>
          <button id="resetAlgo" class="small">Reset Algorithm</button>
        </div>

        <div class="controls-row" style="margin-top:8px">
          <button id="stepBtn" class="small btn-primary">Step</button>
          <button id="runBtn" class="small">Run</button>
          <button id="stopBtn" class="small btn-ghost" disabled>Stop</button>
          <label style="margin-left:6px">Speed:
            <input id="speed" type="range" min="100" max="1500" value="600" style="width:120px;margin-left:6px;">
          </label>
        </div>

        <div class="info">
          <strong>Current edge:</strong> <span id="currentEdge">—</span><br>
          <strong>MST total weight:</strong> <span id="mstWeight">0</span>
        </div>

        <div class="legend">
          <div class="box"><div class="swatch" style="background:#28a745"></div><div>Accepted (MST)</div></div>
          <div class="box"><div class="swatch" style="background:#9aa0a6"></div><div>Rejected (would form cycle)</div></div>
          <div class="box"><div class="swatch" style="background:#0b84ff"></div><div>Candidate</div></div>
          <div class="box"><div class="swatch" style="background:#ddd"></div><div>Normal edge</div></div>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Edges (sorted by weight)</strong>
          <div class="muted">Count: <span id="edgeCount">0</span></div>
        </div>
        <div class="list" id="edgeList" aria-live="polite"></div>
      </div>

      <div class="panel">
        <strong>Disjoint Set (Union-Find)</strong>
        <div class="sets" id="setsView"></div>
      </div>

      <div class="panel">
        <strong>Tips & Interaction</strong>
        <div class="info">
          - Add nodes by clicking empty space. Drag from a node (press and move) to another node to create an edge.<br>
          - Double-click an edge weight to edit it. In Delete mode, click nodes or edges to remove them.<br>
          - Use Step to advance one edge; Run to autoplay. The algorithm sorts edges by weight (ascending) then examines each.
        </div>
      </div>

      <div class="footer">Built for learning Kruskal's algorithm • Visualizes sorting, union-find, and MST selection</div>
    </div>
  </div>

<script>
/*
  Kruskal's Algorithm Interactive Demo
  - SVG canvas for nodes and edges
  - Add nodes by clicking empty space
  - Drag from a node to another to create an edge
  - Step through Kruskal: edges sorted by weight, union-find to detect cycles
  - Visual feedback: accepted edges (green), rejected edges (gray), candidate (blue)
*/

(function(){
  // Utilities
  const svg = document.getElementById('svgCanvas');
  const canvasWrap = document.getElementById('canvasWrap');
  const modeSelect = document.getElementById('modeSelect');
  const randomGraphBtn = document.getElementById('randomGraph');
  const clearBtn = document.getElementById('clearBtn');
  const resetAlgoBtn = document.getElementById('resetAlgo');
  const stepBtn = document.getElementById('stepBtn');
  const runBtn = document.getElementById('runBtn');
  const stopBtn = document.getElementById('stopBtn');
  const speedInput = document.getElementById('speed');
  const edgeListDiv = document.getElementById('edgeList');
  const edgeCountSpan = document.getElementById('edgeCount');
  const currentEdgeSpan = document.getElementById('currentEdge');
  const setsView = document.getElementById('setsView');
  const mstWeightSpan = document.getElementById('mstWeight');

  let nodes = []; // {id, x, y, g} where g is group element
  let edges = []; // {id, a, b, w, g, state} state: normal/candidate/accepted/rejected
  let nodeIdCounter = 0;
  let edgeIdCounter = 0;

  // Algorithm state
  let algo = {
    sortedEdges: [],
    index: 0,
    running: false,
    timer: null,
    mstWeight: 0,
    uf: null
  };

  const COLORS = {
    accepted: '#28a745',
    rejected: '#9aa0a6',
    candidate: '#0b84ff',
    normal: '#ddd',
    edgeStroke: '#bfcbd6',
    nodeFill: '#fff',
    nodeStroke: '#2b7cff'
  };

  // Create defs for arrowheads? Not needed.

  // SVG helpers
  function createSVG(tag, attrs) {
    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    for (const k in attrs) el.setAttribute(k, attrs[k]);
    return el;
  }

  function redrawAll() {
    // set sizes and re-render edges and nodes positions
    nodes.forEach(n => {
      n.circle.setAttribute('cx', n.x);
      n.circle.setAttribute('cy', n.y);
      n.label.setAttribute('x', n.x);
      n.label.setAttribute('y', n.y + 4);
    });
    edges.forEach(e => {
      const a = getNodeById(e.a);
      const b = getNodeById(e.b);
      if (!a || !b) return;
      e.line.setAttribute('x1', a.x);
      e.line.setAttribute('y1', a.y);
      e.line.setAttribute('x2', b.x);
      e.line.setAttribute('y2', b.y);

      // position weight label at midpoint, offset a bit
      const mx = (a.x + b.x) / 2;
      const my = (a.y + b.y) / 2;
      e.weightLabel.setAttribute('x', mx);
      e.weightLabel.setAttribute('y', my - 6);
    });
  }

  // Node management
  function addNode(x, y, id=null) {
    const nid = id !== null ? id : (++nodeIdCounter);
    const g = createSVG('g', { class: 'node', cursor: 'grab' });
    const circle = createSVG('circle', { cx:x, cy:y, r:18, fill:COLORS.nodeFill, stroke:COLORS.nodeStroke, 'stroke-width':2 });
    const label = createSVG('text', { x:x, y:y+4, 'text-anchor':'middle', 'font-size':12, 'font-family':'monospace', fill:'#112', style:'pointer-events:none' });
    label.textContent = nid;
    g.appendChild(circle);
    g.appendChild(label);
    svg.appendChild(g);

    const node = { id:nid, x, y, g, circle, label };
    nodes.push(node);

    // attach pointer handlers for drag to create edges or move
    attachNodeHandlers(node);
    return node;
  }

  function removeNode(id) {
    // remove connected edges first
    const toRemove = edges.filter(e => e.a === id || e.b === id).map(e=>e.id);
    toRemove.forEach(removeEdgeById);
    // remove node
    const idx = nodes.findIndex(n=>n.id===id);
    if (idx>=0) {
      const n = nodes[idx];
      svg.removeChild(n.g);
      nodes.splice(idx,1);
    }
  }

  function getNodeById(id) { return nodes.find(n=>n.id===id); }

  // Edge management
  function addEdge(aId, bId, w, id=null) {
    if (aId === bId) return null; // no self-loop
    // check if edge exists (undirected)
    const existing = edges.find(e => (e.a===aId && e.b===bId) || (e.a===bId && e.b===aId));
    if (existing) return null;
    const eid = id !== null ? id : (++edgeIdCounter);

    const a = getNodeById(aId);
    const b = getNodeById(bId);
    if (!a || !b) return null;

    // create svg group
    const g = createSVG('g', { 'data-eid': eid });
    const line = createSVG('line', { x1:a.x, y1:a.y, x2:b.x, y2:b.y, stroke:COLORS.edgeStroke, 'stroke-width':6, 'stroke-linecap':'round', opacity:1 });
    const weightLabel = createSVG('text', { x:(a.x+b.x)/2, y:(a.y+b.y)/2 - 6, 'text-anchor':'middle', 'font-size':12, 'font-family':'monospace', fill:'#111', 'pointer-events':'visible', cursor:'pointer' });
    weightLabel.textContent = w;
    // add thin overlay for better clicking
    const lineOverlay = createSVG('line', { x1:a.x, y1:a.y, x2:b.x, y2:b.y, stroke:'transparent', 'stroke-width':20, cursor:'pointer' });
    g.appendChild(line);
    g.appendChild(lineOverlay);
    g.appendChild(weightLabel);
    // insert under nodes
    svg.insertBefore(g, svg.querySelector('g.node') || null);

    const edge = { id:eid, a:aId, b:bId, w: Number(w), g, line, lineOverlay, weightLabel, state:'normal' };
    edges.push(edge);

    // handlers
    lineOverlay.addEventListener('dblclick', (ev)=> {
      ev.stopPropagation();
      const newW = prompt('Edit edge weight (numeric):', edge.w);
      if (newW !== null && newW.trim() !== '' && !isNaN(Number(newW))) {
        edge.w = Number(newW);
        edge.weightLabel.textContent = edge.w;
        resetAlgorithm();
        renderEdgeList();
      }
    });
    lineOverlay.addEventListener('click', (ev)=> {
      ev.stopPropagation();
      if (modeSelect.value === 'delete') {
        removeEdgeById(edge.id);
      }
    });

    return edge;
  }

  function removeEdgeById(id) {
    const idx = edges.findIndex(e=>e.id===id);
    if (idx>=0) {
      const e = edges[idx];
      svg.removeChild(e.g);
      edges.splice(idx,1);
      resetAlgorithm();
      renderEdgeList();
    }
  }

  function setEdgeState(edge, state) {
    edge.state = state;
    const strokeWidth = (state==='candidate' ? 6 : (state==='accepted' ? 6 : 6));
    let color = COLORS.normal;
    let opacity = 1;
    if (state==='accepted') color = COLORS.accepted;
    else if (state==='rejected') color = COLORS.rejected;
    else if (state==='candidate') color = COLORS.candidate;
    edge.line.setAttribute('stroke', color);
    edge.line.setAttribute('stroke-width', strokeWidth);
    // dims weight label accordingly
    edge.weightLabel.setAttribute('fill', (state==='rejected' ? '#666' : '#111'));
    renderEdgeList();
  }

  // Node handlers: drag to move or create edge
  function attachNodeHandlers(node) {
    let isPointerDown = false;
    let startX=0, startY=0;
    let draggingNode = false;
    let creatingEdge = false;
    let tempLine = null;
    let pressTimeout = null;

    const pointerdown = (ev) => {
      ev.preventDefault();
      const mode = modeSelect.value;
      const p = getEventPoint(ev);
      isPointerDown = true;
      startX = p.x; startY = p.y;

      if (mode === 'move') {
        draggingNode = true;
      } else if (mode === 'add') {
        // start a drag to create an edge (we'll detect move distance)
        pressTimeout = setTimeout(()=>{ /* no-op */ }, 300);
      } else if (mode === 'delete') {
        // delete node
        removeNode(node.id);
      }
      node.g.setPointerCapture(ev.pointerId);
    };

    const pointermove = (ev) => {
      if (!isPointerDown) return;
      const p = getEventPoint(ev);
      const dx = p.x - startX;
      const dy = p.y - startY;
      if (modeSelect.value === 'move' && Math.hypot(dx,dy) > 0) {
        // move node
        draggingNode = true;
        node.x = p.x; node.y = p.y;
        node.circle.setAttribute('cx', node.x);
        node.circle.setAttribute('cy', node.y);
        node.label.setAttribute('x', node.x);
        node.label.setAttribute('y', node.y+4);
        // update connected edges
        edges.filter(e=>e.a===node.id || e.b===node.id).forEach(e=>{
          const a = getNodeById(e.a), b = getNodeById(e.b);
          e.line.setAttribute('x1', a.x); e.line.setAttribute('y1', a.y);
          e.line.setAttribute('x2', b.x); e.line.setAttribute('y2', b.y);
          e.lineOverlay.setAttribute('x1', a.x); e.lineOverlay.setAttribute('y1', a.y);
          e.lineOverlay.setAttribute('x2', b.x); e.lineOverlay.setAttribute('y2', b.y);
          e.weightLabel.setAttribute('x', (a.x+b.x)/2); e.weightLabel.setAttribute('y', (a.y+b.y)/2 - 6);
        });
      } else if (modeSelect.value === 'add') {
        if (!creatingEdge && Math.hypot(dx,dy) > 8) {
          creatingEdge = true;
          // create temp line
          tempLine = createSVG('line', { x1:node.x, y1:node.y, x2:p.x, y2:p.y, stroke:COLORS.candidate, 'stroke-width':4, 'stroke-linecap':'round', 'stroke-dasharray':'6,6' });
          svg.insertBefore(tempLine, svg.querySelector('g.node') || null);
        }
        if (creatingEdge && tempLine) {
          tempLine.setAttribute('x2', p.x);
          tempLine.setAttribute('y2', p.y);
        }
      }
    };

    const pointerup = (ev) => {
      isPointerDown = false;
      node.g.releasePointerCapture(ev.pointerId);
      const p = getEventPoint(ev);
      if (creatingEdge) {
        // detect target node under pointer
        const target = findNodeNear(p.x, p.y);
        if (target && target.id !== node.id) {
          const w = Math.round(Math.random()*20 + 1); // default random weight
          const edge = addEdge(node.id, target.id, w);
          if (edge) {
            edge.weightLabel.textContent = edge.w;
            resetAlgorithm();
            renderEdgeList();
          }
        }
      } else if (!draggingNode && modeSelect.value === 'add') {
        // maybe a click (no drag) — select node for edge creation? For simplicity, nothing
      }
      // cleanup
      draggingNode = false;
      creatingEdge = false;
      if (tempLine && svg.contains(tempLine)) svg.removeChild(tempLine);
      tempLine = null;
      if (pressTimeout) { clearTimeout(pressTimeout); pressTimeout = null; }
      redrawAll();
    };

    node.g.addEventListener('pointerdown', pointerdown);
    node.g.addEventListener('pointermove', pointermove);
    node.g.addEventListener('pointerup', pointerup);
    node.g.addEventListener('pointerleave', (ev)=> { if (isPointerDown) pointerup(ev); });
  }

  // Canvas handlers for adding nodes by clicking empty space
  svg.addEventListener('click', (ev)=>{
    if (modeSelect.value !== 'add') return;
    const p = getEventPoint(ev);
    // check if clicked on empty space (not on node)
    const near = findNodeNear(p.x, p.y, 22);
    if (near) return;
    addNode(p.x, p.y);
    resetAlgorithm();
    renderEdgeList();
  });

  function findNodeNear(x,y, radius=20) {
    return nodes.find(n => (Math.hypot(n.x - x, n.y - y) <= radius));
  }

  function getEventPoint(ev) {
    const rect = svg.getBoundingClientRect();
    return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
  }

  // Algorithm: Disjoint set (union-find)
  class UnionFind {
    constructor(elements) {
      this.parent = {};
      this.rank = {};
      elements.forEach(e => { this.parent[e] = e; this.rank[e] = 0; });
    }
    find(x) {
      if (this.parent[x] !== x) this.parent[x] = this.find(this.parent[x]);
      return this.parent[x];
    }
    union(x, y) {
      let rx = this.find(x), ry = this.find(y);
      if (rx === ry) return false;
      if (this.rank[rx] < this.rank[ry]) this.parent[rx] = ry;
      else if (this.rank[ry] < this.rank[rx]) this.parent[ry] = rx;
      else { this.parent[ry] = rx; this.rank[rx]++; }
      return true;
    }
    sets() {
      const m = {};
      for (const k in this.parent) {
        const r = this.find(k);
        if (!m[r]) m[r] = [];
        m[r].push(k);
      }
      return m;
    }
  }

  // Kruskal algorithm functions
  function prepareAlgorithm() {
    // reset states
    algo.sortedEdges = [...edges].sort((e1,e2)=> e1.w - e2.w || e1.id - e2.id);
    algo.index = 0;
    algo.mstWeight = 0;
    algo.uf = new UnionFind(nodes.map(n=>n.id));
    algo.running = false;
    // mark all edges normal visually
    edges.forEach(e => setEdgeState(e, 'normal'));
    renderEdgeList();
    updateSetsView();
    updateMSTWeight();
    updateCurrentEdgeDisplay();
  }

  function resetAlgorithm() {
    // called whenever graph changes
    if (algo.timer) { clearInterval(algo.timer); algo.timer = null; algo.running=false; stopBtn.disabled=true; runBtn.disabled=false; }
    prepareAlgorithm();
  }

  // one step: consider next edge
  function stepAlgorithm() {
    if (algo.index >= algo.sortedEdges.length) {
      algo.running = false;
      updateCurrentEdgeDisplay();
      stopRun();
      return;
    }
    // reset previous candidate edges back to normal if they weren't accepted/rejected
    algo.sortedEdges.forEach((ed, idx) => {
      // keep accepted/rejected states, candidate only for current index
      const e = edges.find(x=>x.id===ed.id);
      if (e && e.state === 'candidate') setEdgeState(e, 'normal');
    });

    const edge = algo.sortedEdges[algo.index];
    const e = edges.find(x=>x.id===edge.id);
    if (!e) { algo.index++; return stepAlgorithm(); } // if edge removed meanwhile
    setEdgeState(e, 'candidate');
    updateCurrentEdgeDisplay(e);

    // decide accept/reject based on union-find
    const aRoot = algo.uf.find(String(e.a));
    const bRoot = algo.uf.find(String(e.b));
    // small timeout is left to UI; but stepAlgorithm is synchronous for single step
    if (aRoot !== bRoot) {
      // accept
      algo.uf.union(String(e.a), String(e.b));
      setEdgeState(e, 'accepted');
      algo.mstWeight += e.w;
    } else {
      // reject
      setEdgeState(e, 'rejected');
    }
    algo.index++;
    updateSetsView();
    updateMSTWeight();
    renderEdgeList();

    // if finished
    if (algo.index >= algo.sortedEdges.length) {
      updateCurrentEdgeDisplay();
      stopRun();
      algo.running = false;
    }
  }

  function runAlgorithmAutoplay() {
    if (algo.running) return;
    algo.running = true;
    runBtn.disabled = true; stopBtn.disabled = false;
    const speed = Number(speedInput.value);
    algo.timer = setInterval(()=> {
      if (algo.index >= algo.sortedEdges.length) {
        stopRun();
        return;
      }
      stepAlgorithm();
    }, speed);
  }

  function stopRun() {
    if (algo.timer) clearInterval(algo.timer);
    algo.timer = null;
    algo.running = false;
    runBtn.disabled = false;
    stopBtn.disabled = true;
  }

  // UI rendering
  function renderEdgeList() {
    // show edges sorted by weight
    edgeListDiv.innerHTML = '';
    const arr = [...edges].sort((a,b) => a.w - b.w || a.id - b.id);
    edgeCountSpan.textContent = arr.length;
    arr.forEach(e => {
      const div = document.createElement('div');
      div.className = 'edge-item';
      div.style.borderBottom = '1px dashed #eef4f8';
      div.style.paddingBottom = '6px';
      div.style.marginBottom = '6px';
      const left = document.createElement('div');
      left.textContent = `${e.a} — ${e.b}`;
      left.style.fontFamily = 'monospace';
      left.style.fontSize = '13px';
      const right = document.createElement('div');
      const wspan = document.createElement('span');
      wspan.className = 'weight-badge';
      wspan.textContent = e.w;
      right.appendChild(wspan);
      // state color dot
      const dot = document.createElement('span');
      dot.style.display='inline-block';
      dot.style.width='10px';
      dot.style.height='10px';
      dot.style.borderRadius='3px';
      dot.style.marginLeft='8px';
      dot.style.verticalAlign='middle';
      let color = '#ddd';
      if (e.state==='accepted') color = COLORS.accepted;
      else if (e.state==='rejected') color = COLORS.rejected;
      else if (e.state==='candidate') color = COLORS.candidate;
      dot.style.background = color;
      right.appendChild(dot);
      div.appendChild(left);
      div.appendChild(right);
      // clicking edge in list highlights it on canvas momentarily
      div.addEventListener('click', ()=> {
        // flash candidate
        edges.forEach(ee => { if (ee.id !== e.id && ee.state === 'candidate') setEdgeState(ee,'normal'); });
        setEdgeState(e, 'candidate');
        setTimeout(()=> { if (e.state === 'candidate') setEdgeState(e,'normal'); }, 800);
      });
      edgeListDiv.appendChild(div);
    });
  }

  function updateSetsView() {
    if (!algo.uf) {
      setsView.innerHTML = '<div class="muted">—</div>';
      return;
    }
    const sets = algo.uf.sets();
    const keys = Object.keys(sets).sort((a,b)=>Number(a)-Number(b));
    setsView.innerHTML = '';
    keys.forEach(k => {
      const div = document.createElement('div');
      div.style.marginBottom = '6px';
      div.textContent = `${k}: [ ${sets[k].join(', ')} ]`;
      setsView.appendChild(div);
    });
  }

  function updateMSTWeight() {
    mstWeightSpan.textContent = algo.mstWeight;
  }

  function updateCurrentEdgeDisplay(e=null) {
    if (!e) {
      currentEdgeSpan.textContent = (algo.index >= algo.sortedEdges.length ? '— finished' : '—');
    } else {
      currentEdgeSpan.textContent = `${e.a} — ${e.b} (w=${e.w})`;
    }
  }

  // Buttons
  randomGraphBtn.addEventListener('click', ()=> {
    clearGraph();
    generateRandomGraph();
  });

  clearBtn.addEventListener('click', ()=> {
    if (!confirm('Clear entire graph?')) return;
    clearGraph();
  });

  resetAlgoBtn.addEventListener('click', ()=> {
    resetAlgorithm();
  });

  stepBtn.addEventListener('click', ()=> {
    if (!algo.uf) prepareAlgorithm();
    stepAlgorithm();
  });

  runBtn.addEventListener('click', ()=> {
    if (!algo.uf) prepareAlgorithm();
    runAlgorithmAutoplay();
  });

  stopBtn.addEventListener('click', ()=> {
    stopRun();
  });

  // clear graph
  function clearGraph() {
    // remove all svg children
    nodes.forEach(n => { if (svg.contains(n.g)) svg.removeChild(n.g); });
    edges.forEach(e => { if (svg.contains(e.g)) svg.removeChild(e.g); });
    nodes = []; edges = []; nodeIdCounter = 0; edgeIdCounter = 0;
    resetAlgorithm();
    renderEdgeList();
  }

  // Random graph generation
  function generateRandomGraph() {
    const W = svg.clientWidth, H = svg.clientHeight;
    const N = Math.max(4, Math.floor(Math.random()*4) + 5); // 5-8 nodes
    for (let i=0;i<N;i++){
      const x = Math.round(40 + Math.random()*(W-80));
      const y = Math.round(40 + Math.random()*(H-120));
      addNode(x,y);
    }
    // create random edges: connect a few
    const nodeIds = nodes.map(n=>n.id);
    // ensure connectivity: random tree first
    for (let i=1;i<nodeIds.length;i++){
      const a = nodeIds[i];
      const b = nodeIds[Math.floor(Math.random()*i)];
      addEdge(a,b, Math.round(Math.random()*20 + 1));
    }
    // add extra random edges
    const extra = Math.floor(Math.random()* (nodeIds.length));
    for (let k=0;k<extra;k++){
      const a = nodeIds[Math.floor(Math.random()*nodeIds.length)];
      const b = nodeIds[Math.floor(Math.random()*nodeIds.length)];
      if (a!==b) addEdge(a,b, Math.round(Math.random()*20 + 1));
    }
    resetAlgorithm();
    renderEdgeList();
  }

  // initial setup
  prepareAlgorithm();
  renderEdgeList();

  // keyboard shortcuts
  window.addEventListener('keydown', (ev)=> {
    if (ev.key === 'r') { generateRandomGraph(); }
    if (ev.key === 'c') { clearGraph(); }
    if (ev.key === ' ') { ev.preventDefault(); stepAlgorithm(); }
  });

  // helpers: on window resize recalc positions? just redraw
  window.addEventListener('resize', redrawAll);

  // initial sample graph for demonstration
  function seedSample() {
    clearGraph();
    const w = svg.clientWidth, h = svg.clientHeight;
    const centerX = w/2;
    const centerY = h/2;
    const r = Math.min(w,h)/3.5;
    // place 6 nodes in circle
    const ids = [];
    for (let i=0;i<6;i++){
      const ang = i * (Math.PI*2/6) - Math.PI/6;
      const x = Math.round(centerX + r * Math.cos(ang));
      const y = Math.round(centerY + r * Math.sin(ang));
      const n = addNode(x,y);
      ids.push(n.id);
    }
    // add some edges with weights
    addEdge(ids[0], ids[1], 7);
    addEdge(ids[0], ids[2], 9);
    addEdge(ids[0], ids[5], 14);
    addEdge(ids[1], ids[2], 10);
    addEdge(ids[1], ids[3], 15);
    addEdge(ids[2], ids[3], 11);
    addEdge(ids[2], ids[5], 2);
    addEdge(ids[3], ids[4], 6);
    addEdge(ids[4], ids[5], 9);
    resetAlgorithm();
    renderEdgeList();
  }

  seedSample();

  // Expose some helpers to window for debugging (optional)
  window._kruskaldemo = {
    nodes, edges, resetAlgorithm, prepareAlgorithm, stepAlgorithm, runAlgorithmAutoplay, stopRun
  };

})();
</script>
</body>
</html>