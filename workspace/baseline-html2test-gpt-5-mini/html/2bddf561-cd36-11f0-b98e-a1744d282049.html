<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Deque (Double-Ended Queue) Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --card: #0b1220;
      --ok: #10b981;
      --warn: #f59e0b;
      --bad: #ef4444;
    }
    html,body { height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; background:linear-gradient(180deg,#071025 0%, #071426 100%); color:#e6eef8; }
    .container { max-width:1100px; margin:28px auto; padding:22px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 6px 30px rgba(2,6,23,0.6); }
    h1 { margin:0 0 6px 0; font-size:20px; color:var(--accent); }
    p.desc { margin:0 0 18px 0; color:var(--muted); font-size:13px; }
    .layout { display:flex; gap:18px; align-items:flex-start; }
    .panel { background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); padding:14px; border-radius:10px; }
    .controls { width:320px; flex-shrink:0; }
    .visual { flex:1; }
    .row { display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap; }
    input[type="text"] { padding:8px 10px; background:#071826; border:1px solid rgba(255,255,255,0.04); color:#e6eef8; border-radius:8px; outline:none; min-width:120px; }
    button { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); color:#e6eef8; padding:8px 10px; border-radius:8px; cursor:pointer; }
    button.primary { background:linear-gradient(180deg,var(--accent), #0aa2b5); color:#002028; font-weight:600; border:none; }
    button.warn { background:linear-gradient(180deg,var(--warn), #d9820b); color:#08140b; border:none; }
    button.danger { background:linear-gradient(180deg,var(--bad), #d32f2f); color:#2b0505; border:none; }
    .small { font-size:12px; padding:6px 8px; border-radius:6px; }
    .vis-area { padding:12px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015)); border-radius:8px; border:1px solid rgba(255,255,255,0.03); }
    .deque-line { display:flex; gap:8px; align-items:center; flex-wrap:nowrap; min-height:72px; margin-bottom:14px; overflow:auto; padding-bottom:6px; }
    .elem { min-width:54px; height:48px; border-radius:8px; background:#031526; border:1px solid rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center; color:#dff7fb; font-weight:600; box-shadow: 0 4px 18px rgba(0,0,0,0.6); }
    .tag { font-size:12px; color:var(--muted); margin-right:8px; }
    .idx-grid { display:flex; gap:8px; overflow:auto; padding:10px 2px; align-items:end; }
    .cell { min-width:64px; min-height:56px; border-radius:6px; background:rgba(255,255,255,0.01); border:1px dashed rgba(255,255,255,0.02); display:flex; flex-direction:column; align-items:center; justify-content:center; color:var(--muted); font-size:13px; position:relative; }
    .cell .val { margin-top:6px; font-weight:700; color:#dff7fb; }
    .marker { position:absolute; top:6px; left:6px; background:var(--accent); color:#022; padding:2px 6px; border-radius:6px; font-size:11px; font-weight:700; }
    .marker.tail { right:6px; left:auto; background:#fab005; color:#2b1502; }
    .log { max-height:180px; overflow:auto; background:#031026; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.02); color:var(--muted); font-family:monospace; font-size:13px; }
    .info { font-size:13px; color:var(--muted); margin-top:8px; }
    .stat { display:flex; gap:12px; color:var(--muted); margin-top:8px; font-size:13px; }
    .stat .s { background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:8px; }
    footer { margin-top:14px; color:var(--muted); font-size:13px; }
    a { color:var(--accent); text-decoration:none; }
    .controls .group { margin-bottom:12px; }
    .ops { display:flex; gap:8px; flex-wrap:wrap; }
    .hint { font-size:12px; color:var(--muted); margin-top:6px;}
  </style>
</head>
<body>
  <div class="container panel">
    <h1>Deque (Double-Ended Queue) — Interactive Demo</h1>
    <p class="desc">A deque supports adding and removing items from both front and back. This demo includes an efficient circular-buffer implementation with automatic resizing and a visualizer of the logical deque plus the internal buffer.</p>

    <div class="layout">
      <div class="controls panel">
        <div class="group">
          <input id="valueInput" type="text" placeholder="Value (string/number)" />
          <div class="row" style="margin-top:10px;">
            <button id="pushFront" class="small primary">pushFront</button>
            <button id="pushBack" class="small primary">pushBack</button>
          </div>
          <div class="row">
            <button id="popFront" class="small warn">popFront</button>
            <button id="popBack" class="small warn">popBack</button>
          </div>
          <div class="row">
            <button id="peekFront" class="small">peekFront</button>
            <button id="peekBack" class="small">peekBack</button>
          </div>
          <div class="row" style="margin-top:6px;">
            <button id="clearBtn" class="small danger">clear</button>
            <button id="fillRandom" class="small">fill random (5)</button>
          </div>
        </div>

        <div class="group">
          <div class="row">
            <button id="stepRand" class="small">step random op</button>
            <button id="runRandom" class="small">run 20 random ops</button>
            <button id="stopRandom" class="small">stop</button>
          </div>
          <div class="hint">Random ops: push/pop front/back with random integers. Useful to exercise resize/shrink.</div>
        </div>

        <div class="group">
          <div class="stat">
            <div class="s">size: <span id="statSize">0</span></div>
            <div class="s">capacity: <span id="statCap">8</span></div>
            <div class="s">head: <span id="statHead">0</span></div>
            <div class="s">tail: <span id="statTail">0</span></div>
          </div>
        </div>

        <div class="group">
          <div style="font-size:13px; font-weight:600; color:var(--muted); margin-bottom:6px;">Operation log</div>
          <div id="log" class="log" aria-live="polite"></div>
        </div>

        <footer>
          Note: This Deque uses a circular buffer with doubling/shrinking — push/pop are O(1) amortized.
        </footer>
      </div>

      <div class="visual panel">
        <div class="vis-area">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
            <div style="display:flex; align-items:center; gap:8px;">
              <div class="tag">Logical deque (front → back)</div>
              <div class="hint" style="margin-left:8px;">Shows elements in their deque order</div>
            </div>
            <div style="font-size:13px; color:var(--muted);">Underlying buffer visualized below</div>
          </div>

          <div class="deque-line" id="dequeLine" aria-hidden="false">
            <!-- elements inserted here -->
          </div>

          <div style="margin-top:6px; color:var(--muted); font-size:13px;">Internal buffer (indexes 0..capacity-1). Head points to first element; tail points to the slot after last element.</div>
          <div class="idx-grid" id="bufferGrid" style="margin-top:8px;">
            <!-- buffer cells -->
          </div>

          <div class="info" id="infoText"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Deque implementation using circular buffer with dynamic resizing
    class Deque {
      constructor(initialCapacity = 8) {
        if (initialCapacity < 1) initialCapacity = 1;
        // normalize to power of two for nicer wrap (not required but convenient)
        this._cap = 1;
        while (this._cap < initialCapacity) this._cap <<= 1;
        this._buf = new Array(this._cap);
        this._head = 0; // index of first element
        this._tail = 0; // index one past last element
        this._size = 0;
        this._minCap = this._cap;
      }

      size() { return this._size; }
      isEmpty() { return this._size === 0; }
      capacity() { return this._cap; }
      headIndex() { return this._head; }
      tailIndex() { return this._tail; }

      _grow() {
        const newCap = this._cap * 2;
        this._resizeBuffer(newCap);
      }

      _shrink() {
        // shrink when size <= cap/4 (amortized)
        let newCap = this._cap >> 1;
        if (newCap < this._minCap) newCap = this._minCap;
        if (newCap < this._cap && this._size <= newCap) {
          this._resizeBuffer(newCap);
        }
      }

      _resizeBuffer(newCap) {
        const newBuf = new Array(newCap);
        for (let i = 0; i < this._size; i++) {
          newBuf[i] = this._buf[(this._head + i) & (this._cap - 1)];
        }
        this._buf = newBuf;
        this._cap = newCap;
        this._head = 0;
        this._tail = this._size % this._cap;
      }

      pushBack(val) {
        if (this._size === this._cap) this._grow();
        this._buf[this._tail] = val;
        this._tail = (this._tail + 1) & (this._cap - 1);
        this._size++;
      }

      pushFront(val) {
        if (this._size === this._cap) this._grow();
        this._head = (this._head - 1) & (this._cap - 1);
        this._buf[this._head] = val;
        this._size++;
      }

      popFront() {
        if (this._size === 0) return undefined;
        const val = this._buf[this._head];
        this._buf[this._head] = undefined;
        this._head = (this._head + 1) & (this._cap - 1);
        this._size--;
        if (this._size > 0) this._shrink();
        return val;
      }

      popBack() {
        if (this._size === 0) return undefined;
        this._tail = (this._tail - 1) & (this._cap - 1);
        const val = this._buf[this._tail];
        this._buf[this._tail] = undefined;
        this._size--;
        if (this._size > 0) this._shrink();
        return val;
      }

      peekFront() {
        if (this._size === 0) return undefined;
        return this._buf[this._head];
      }

      peekBack() {
        if (this._size === 0) return undefined;
        const idx = (this._tail - 1) & (this._cap - 1);
        return this._buf[idx];
      }

      clear() {
        this._buf = new Array(this._minCap);
        this._cap = this._minCap;
        this._head = 0;
        this._tail = 0;
        this._size = 0;
      }

      toArray() {
        const arr = [];
        for (let i = 0; i < this._size; i++) {
          arr.push(this._buf[(this._head + i) & (this._cap - 1)]);
        }
        return arr;
      }

      bufferSnapshot() {
        // returns array of buffer contents and marks positions
        return {
          buf: this._buf.slice(),
          head: this._head,
          tail: this._tail,
          cap: this._cap,
          size: this._size
        };
      }
    }

    // UI wiring
    const dq = new Deque(8);
    const dequeLine = document.getElementById('dequeLine');
    const bufferGrid = document.getElementById('bufferGrid');
    const logEl = document.getElementById('log');
    const statSize = document.getElementById('statSize');
    const statCap = document.getElementById('statCap');
    const statHead = document.getElementById('statHead');
    const statTail = document.getElementById('statTail');
    const infoText = document.getElementById('infoText');

    function log(msg, type = 'info') {
      const time = new Date().toLocaleTimeString();
      const line = document.createElement('div');
      line.textContent = `[${time}] ${msg}`;
      if (type === 'err') line.style.color = 'var(--warn)';
      logEl.prepend(line);
    }

    function render() {
      // logical deque
      dequeLine.innerHTML = '';
      const arr = dq.toArray();
      if (arr.length === 0) {
        const hint = document.createElement('div');
        hint.className = 'elem';
        hint.style.opacity = '0.45';
        hint.textContent = '(empty)';
        dequeLine.appendChild(hint);
      } else {
        for (let i = 0; i < arr.length; i++) {
          const el = document.createElement('div');
          el.className = 'elem';
          el.textContent = String(arr[i]);
          dequeLine.appendChild(el);
        }
      }

      // buffer visualization
      const snap = dq.bufferSnapshot();
      bufferGrid.innerHTML = '';
      for (let i = 0; i < snap.cap; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        const idxLabel = document.createElement('div');
        idxLabel.style.fontSize = '12px';
        idxLabel.style.color = 'var(--muted)';
        idxLabel.textContent = i;
        const val = document.createElement('div');
        val.className = 'val';
        val.textContent = snap.buf[i] === undefined ? '' : String(snap.buf[i]);
        cell.appendChild(idxLabel);
        cell.appendChild(val);

        if (i === snap.head && snap.size > 0) {
          const m = document.createElement('div');
          m.className = 'marker';
          m.textContent = 'HEAD';
          cell.appendChild(m);
        } else if (i === snap.head && snap.size === 0) {
          // when empty head===tail, mark both?
          const m = document.createElement('div');
          m.className = 'marker';
          m.textContent = 'HEAD';
          cell.appendChild(m);
        }

        if (i === snap.tail) {
          const m2 = document.createElement('div');
          m2.className = 'marker tail';
          m2.textContent = 'TAIL';
          cell.appendChild(m2);
        }

        // highlight occupied slots
        // occupied indices are head .. head+size-1 modulo cap
        let occupied = false;
        if (snap.size > 0) {
          const rel = (i - snap.head + snap.cap) & (snap.cap - 1);
          if (rel >= 0 && rel < snap.size) occupied = true;
        }
        if (occupied) {
          cell.style.background = 'linear-gradient(180deg, rgba(6,182,212,0.06), rgba(6,182,212,0.03))';
          cell.style.border = '1px solid rgba(6,182,212,0.12)';
        }

        bufferGrid.appendChild(cell);
      }

      // stats
      statSize.textContent = dq.size();
      statCap.textContent = dq.capacity();
      statHead.textContent = dq.headIndex();
      statTail.textContent = dq.tailIndex();

      infoText.textContent = `Logical order: [${dq.toArray().map(x=>String(x)).join(', ')}]`;
    }

    // wired controls
    const valueInput = document.getElementById('valueInput');
    document.getElementById('pushFront').addEventListener('click', () => {
      const v = parseInput(valueInput.value);
      dq.pushFront(v);
      log(`pushFront(${formatForLog(v)})`);
      render();
    });
    document.getElementById('pushBack').addEventListener('click', () => {
      const v = parseInput(valueInput.value);
      dq.pushBack(v);
      log(`pushBack(${formatForLog(v)})`);
      render();
    });
    document.getElementById('popFront').addEventListener('click', () => {
      const v = dq.popFront();
      if (v === undefined) log('popFront() -> undefined (empty)', 'err'); else log(`popFront() -> ${formatForLog(v)}`);
      render();
    });
    document.getElementById('popBack').addEventListener('click', () => {
      const v = dq.popBack();
      if (v === undefined) log('popBack() -> undefined (empty)', 'err'); else log(`popBack() -> ${formatForLog(v)}`);
      render();
    });
    document.getElementById('peekFront').addEventListener('click', () => {
      const v = dq.peekFront();
      if (v === undefined) log('peekFront() -> undefined (empty)', 'err'); else log(`peekFront() -> ${formatForLog(v)}`);
    });
    document.getElementById('peekBack').addEventListener('click', () => {
      const v = dq.peekBack();
      if (v === undefined) log('peekBack() -> undefined (empty)', 'err'); else log(`peekBack() -> ${formatForLog(v)}`);
    });
    document.getElementById('clearBtn').addEventListener('click', () => {
      dq.clear();
      log('clear() — deque reset');
      render();
    });
    document.getElementById('fillRandom').addEventListener('click', () => {
      for (let i=0;i<5;i++) dq.pushBack(randInt(1,99));
      log('Filled 5 random values to back');
      render();
    });

    function parseInput(s) {
      s = String(s).trim();
      if (s === '') return '';
      // try to parse number
      if (!isNaN(s) && s !== '') {
        // interpret as number if it's a numeric literal
        const n = Number(s);
        return n;
      }
      return s;
    }
    function formatForLog(v) {
      if (v === '') return "''";
      if (v === undefined) return 'undefined';
      return JSON.stringify(v);
    }

    function randInt(a,b) { return Math.floor(Math.random()*(b-a+1))+a; }

    // random op runner
    let runner = null;
    document.getElementById('stepRand').addEventListener('click', () => {
      randomOpStep();
    });
    document.getElementById('runRandom').addEventListener('click', () => {
      if (runner) return;
      let steps = 20;
      runner = setInterval(() => {
        randomOpStep();
        steps--;
        if (steps <= 0) { clearInterval(runner); runner = null; }
      }, 220);
    });
    document.getElementById('stopRandom').addEventListener('click', () => {
      if (runner) { clearInterval(runner); runner = null; log('Stopped random runner'); }
    });

    function randomOpStep() {
      const op = randInt(0,3);
      const val = randInt(1,99);
      switch(op) {
        case 0:
          dq.pushFront(val);
          log(`pushFront(${val})`);
          break;
        case 1:
          dq.pushBack(val);
          log(`pushBack(${val})`);
          break;
        case 2:
          const a = dq.popFront();
          log(a === undefined ? 'popFront() -> undefined' : `popFront() -> ${a}`);
          break;
        case 3:
          const b = dq.popBack();
          log(b === undefined ? 'popBack() -> undefined' : `popBack() -> ${b}`);
          break;
      }
      render();
    }

    // initial render
    render();
    log('Deque initialized');

    // Accessibility: allow Enter to pushBack in input
    valueInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        document.getElementById('pushBack').click();
        valueInput.value = '';
      }
    });
  </script>
</body>
</html>