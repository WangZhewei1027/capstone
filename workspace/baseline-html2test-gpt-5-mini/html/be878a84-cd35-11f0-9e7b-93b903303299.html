<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Priority Queue Visualizer (Binary Heap)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#3b82f6;
      --muted:#9ca3af;
      --text:#e6eef8;
      --success:#10b981;
      --danger:#fb7185;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #071226 0%, #07162a 50%, #071226 100%);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app {
      max-width:1100px;
      margin:24px auto;
      padding:20px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 6px 30px rgba(2,6,23,0.7);
      border: 1px solid rgba(255,255,255,0.03);
    }
    header {
      display:flex;
      gap:16px;
      align-items:center;
      margin-bottom:18px;
    }
    h1{
      font-size:20px;
      margin:0;
      letter-spacing:0.2px;
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }
    .controls {
      display:flex;
      gap:12px;
      margin-top:14px;
      flex-wrap:wrap;
      align-items:center;
    }
    .card {
      background:var(--card);
      padding:12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .form-row {
      display:flex;
      gap:8px;
      align-items:center;
    }
    input[type="text"], input[type="number"], select {
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.03);
      color:var(--text);
      padding:8px 10px;
      border-radius:8px;
      outline:none;
      min-width:120px;
    }
    button {
      background:linear-gradient(90deg,var(--accent),#60a5fa);
      border:none;
      color:white;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
    }
    button.ghost {
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--text);
    }
    .secondary {
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      padding:6px 10px;
    }
    .toggle {
      display:flex;
      gap:6px;
      align-items:center;
    }
    .main-grid{
      display:grid;
      grid-template-columns: 1fr 420px;
      gap:14px;
      margin-top:16px;
    }
    .vis {
      min-height:420px;
      padding:12px;
      border-radius:10px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.02);
    }
    .heap-array {
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .cell {
      min-width:70px;
      text-align:center;
      padding:8px;
      border-radius:8px;
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      font-size:13px;
    }
    .cell .idx {
      display:block;
      font-size:11px;
      color:var(--muted);
    }
    .cell.highlight {
      background:linear-gradient(90deg,#0ea5e922,#7c3aed22);
      border:1px solid rgba(99,102,241,0.55);
      box-shadow:0 6px 18px rgba(99,102,241,0.06);
    }
    svg {
      width:100%;
      height:340px;
      overflow:visible;
    }
    .node {
      cursor:default;
      transition:transform 200ms ease;
    }
    .node circle {
      fill:linear-gradient(#111827,#0f1724);
      stroke:rgba(255,255,255,0.04);
    }
    .log {
      margin-top:10px;
      max-height:160px;
      overflow:auto;
      font-size:13px;
      color:var(--muted);
      padding:8px;
      border-radius:8px;
      background:rgba(255,255,255,0.02);
    }
    .meta {
      display:flex;
      gap:10px;
      margin-top:8px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .badge {
      background:rgba(255,255,255,0.03);
      padding:6px 8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
      display:inline-flex;
      gap:8px;
      align-items:center;
      font-weight:600;
    }
    .small {
      font-size:12px;
      color:var(--muted);
      margin-left:8px;
    }
    .footer {
      margin-top:14px;
      font-size:13px;
      color:var(--muted);
    }
    a { color: #60a5fa; text-decoration:none }
    .hint { color:var(--muted); font-size:13px; margin-top:8px; }
    .op-btn { padding:7px 10px; border-radius:8px; background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--text); cursor:pointer }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Priority Queue Visualizer">
    <header>
      <div>
        <h1>Priority Queue Visualizer</h1>
        <p class="lead">Binary-heap based priority queue with animated sift-up / sift-down. Supports min/max and stable insertion order.</p>
        <div class="hint">Push and pop items with a numeric priority. Lower priority = higher priority in "Min" mode.</div>
      </div>
    </header>

    <div class="controls">
      <div class="card">
        <div class="form-row">
          <input id="valueInput" type="text" placeholder="Value (optional)" />
          <input id="priorityInput" type="number" placeholder="Priority (number)" />
          <button id="addBtn">Add</button>
        </div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
          <button id="addRandBtn" class="ghost">Add Random</button>
          <button id="bulkRandBtn" class="ghost">Add 10 Random</button>
          <button id="popBtn" class="secondary">Pop</button>
          <button id="peekBtn" class="secondary">Peek</button>
          <button id="clearBtn" class="ghost">Clear</button>
        </div>
      </div>

      <div class="card" style="display:flex; gap:10px; align-items:center;">
        <div class="toggle">
          <label style="font-size:13px; color:var(--muted);">Mode:</label>
          <select id="modeSelect">
            <option value="min">Min-Heap (smallest priority first)</option>
            <option value="max">Max-Heap (largest priority first)</option>
          </select>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="rebuildBtn" class="op-btn">Rebuild</button>
          <button id="demoSeqBtn" class="op-btn">Demo Sequence</button>
        </div>
      </div>

      <div class="card" style="padding:10px 12px;">
        <div style="font-size:13px; margin-bottom:6px">Stats</div>
        <div class="meta">
          <div class="badge">Size: <span id="sizeBadge">0</span></div>
          <div class="badge">Peek: <span id="peekBadge">—</span></div>
        </div>
      </div>
    </div>

    <div class="main-grid">
      <div class="vis card">
        <div style="display:flex; align-items:center; justify-content:space-between;">
          <div style="font-weight:700">Heap Visualization</div>
          <div style="font-size:13px; color:var(--muted)">Array-backed binary heap</div>
        </div>

        <div id="svgWrap" style="margin-top:8px;">
          <svg id="heapSvg" viewBox="0 0 1000 400" preserveAspectRatio="xMidYMin meet"></svg>
        </div>

        <div style="margin-top:12px; font-size:13px; color:var(--muted)">Array representation (index 0 = root):</div>
        <div id="arrayWrap" class="heap-array" aria-live="polite"></div>

        <div class="log" id="logArea" aria-live="polite"></div>
      </div>

      <div class="card">
        <div style="font-weight:700">Inspector & Actions</div>
        <div style="margin-top:8px; font-size:13px; color:var(--muted)">Click "Pop" to remove the top priority item. Use "Demo Sequence" to see example operations animated.</div>

        <div style="margin-top:12px; display:flex; gap:8px; align-items:center;">
          <button id="stepBackBtn" class="ghost">Step Back</button>
          <button id="playAnimBtn" class="ghost">Play Animation</button>
          <button id="fastToggleBtn" class="ghost">Speed: 300ms</button>
        </div>

        <div style="margin-top:12px;">
          <div style="font-size:13px; color:var(--muted)">Operation Log:</div>
          <div id="shortLog" style="margin-top:6px; font-size:13px; color:var(--muted)">(most recent actions shown above)</div>
        </div>

        <div style="margin-top:12px;">
          <div style="font-weight:700; font-size:14px">Notes</div>
          <ul style="color:var(--muted); font-size:13px; margin-top:6px; padding-left:16px;">
            <li>Push / Pop cost: O(log n) — swapping along heap height.</li>
            <li>Peek returns current top in O(1).</li>
            <li>Stable insertion order is preserved for equal priorities.</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="footer">
      Built-in demo of a priority queue implemented as a binary heap. Source code is client-side and interactive.
    </div>
  </div>

  <script>
    // Priority Queue (binary heap) with stability (insertionIndex used to break ties)
    class PriorityQueue {
      constructor(mode = 'min') {
        // items stored as {value, priority, idx} ; comparator uses priority and idx
        this.data = [];
        this._insertion = 0;
        this.setMode(mode);
      }
      setMode(mode) {
        this.mode = mode === 'max' ? 'max' : 'min';
        // comparator returns true if a has higher priority than b
        if (this.mode === 'min') {
          this._cmp = (a,b) => (a.priority < b.priority) || (a.priority === b.priority && a.idx < b.idx);
        } else {
          this._cmp = (a,b) => (a.priority > b.priority) || (a.priority === b.priority && a.idx < b.idx);
        }
      }
      size(){ return this.data.length; }
      peek(){ return this.data[0] || null; }
      push(value, priority){
        const node = { value: value==="" ? null : (value===undefined?String(priority):String(value)), priority: Number(priority), idx: this._insertion++ };
        this.data.push(node);
        const swaps = this._siftUp(this.data.length - 1);
        return { node, swaps };
      }
      pop(){
        if (this.size() === 0) return null;
        const top = this.data[0];
        const last = this.data.pop();
        if (this.size() > 0) {
          this.data[0] = last;
          const swaps = this._siftDown(0);
          return { node: top, swaps };
        }
        return { node: top, swaps: [] };
      }
      clear(){
        this.data = [];
        this._insertion = 0;
      }
      toArray(){ return this.data.slice(); }
      // internal siftUp and siftDown capture sequence of swaps (pairs of indices)
      _siftUp(i){
        const swaps = [];
        let cur = i;
        while (cur > 0) {
          const parent = Math.floor((cur - 1) / 2);
          if (this._cmp(this.data[cur], this.data[parent])) {
            swaps.push([parent, cur]);
            [this.data[parent], this.data[cur]] = [this.data[cur], this.data[parent]];
            cur = parent;
          } else break;
        }
        return swaps;
      }
      _siftDown(i){
        const swaps = [];
        const n = this.data.length;
        let cur = i;
        while (true) {
          const left = 2*cur + 1;
          const right = 2*cur + 2;
          let best = cur;
          if (left < n && this._cmp(this.data[left], this.data[best])) best = left;
          if (right < n && this._cmp(this.data[right], this.data[best])) best = right;
          if (best !== cur) {
            swaps.push([cur, best]);
            [this.data[cur], this.data[best]] = [this.data[best], this.data[cur]];
            cur = best;
          } else break;
        }
        return swaps;
      }
      // Rebuild using current comparator (useful when switching min/max)
      rebuildFromArray(arr){
        // arr: array of plain items {value,priority,idx}
        this.data = arr.slice();
        // heapify in-place bottom-up; capture no swaps here
        const swaps = [];
        for (let i = Math.floor(this.size()/2); i >= 0; i--) {
          this._siftDown(i);
        }
        return swaps;
      }
    }

    // UI and visualization
    const pq = new PriorityQueue('min');
    const svg = document.getElementById('heapSvg');
    const arrayWrap = document.getElementById('arrayWrap');
    const logArea = document.getElementById('logArea');
    const sizeBadge = document.getElementById('sizeBadge');
    const peekBadge = document.getElementById('peekBadge');
    const valueInput = document.getElementById('valueInput');
    const priorityInput = document.getElementById('priorityInput');
    const addBtn = document.getElementById('addBtn');
    const addRandBtn = document.getElementById('addRandBtn');
    const bulkRandBtn = document.getElementById('bulkRandBtn');
    const popBtn = document.getElementById('popBtn');
    const peekBtn = document.getElementById('peekBtn');
    const clearBtn = document.getElementById('clearBtn');
    const modeSelect = document.getElementById('modeSelect');
    const rebuildBtn = document.getElementById('rebuildBtn');
    const demoSeqBtn = document.getElementById('demoSeqBtn');
    const logShort = document.getElementById('shortLog');
    const playAnimBtn = document.getElementById('playAnimBtn');
    const stepBackBtn = document.getElementById('stepBackBtn');
    const fastToggleBtn = document.getElementById('fastToggleBtn');

    let animSpeed = 300; // ms per swap
    let animPlaying = false;
    let animSteps = []; // queued steps as {type:'swap'|'push'|'pop', swaps:[], before, after, node}
    let animIndex = 0;

    function writeLog(msg){
      const t = new Date().toLocaleTimeString();
      const el = document.createElement('div');
      el.textContent = `[${t}] ${msg}`;
      logArea.prepend(el);
      // truncate
      while (logArea.childNodes.length > 200) logArea.removeChild(logArea.lastChild);
      logShort.textContent = msg;
    }

    function render(){
      // render array
      arrayWrap.innerHTML = '';
      const arr = pq.toArray();
      arr.forEach((node, i) => {
        const el = document.createElement('div');
        el.className = 'cell';
        el.title = `Index ${i}`;
        el.innerHTML = `<span class="idx">[${i}]</span><div style="font-weight:700">${node.value!==null?node.value:'(nil)'}</div><div class="small">p=${node.priority}</div>`;
        arrayWrap.appendChild(el);
      });
      if (arr.length === 0) {
        const el = document.createElement('div');
        el.className = 'cell';
        el.textContent = '(empty)';
        arrayWrap.appendChild(el);
      }
      sizeBadge.textContent = pq.size();
      const top = pq.peek();
      peekBadge.textContent = top ? `${top.value} (p=${top.priority})` : '—';

      renderTree(arr);
    }

    // Basic tree layout to position nodes for binary heap
    function renderTree(arr){
      // svg coordinate system: width 1000, height 380
      const W = 1000, H = 380;
      svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
      svg.innerHTML = '';
      if (arr.length === 0) {
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('x',W/2);
        t.setAttribute('y',H/2);
        t.setAttribute('fill','rgba(255,255,255,0.12)');
        t.setAttribute('text-anchor','middle');
        t.setAttribute('font-size','18');
        t.textContent = 'Heap is empty';
        svg.appendChild(t);
        return;
      }
      // compute positions by level
      const levels = [];
      let i = 0;
      let level = 0;
      while (i < arr.length) {
        const count = Math.min(arr.length - i, Math.pow(2, level));
        const row = [];
        for (let j=0;j<count;j++){
          row.push(i++);
        }
        levels.push(row);
        level++;
      }
      // calculate coordinates
      const coords = {};
      const topMargin = 40;
      const levelHeight = Math.min(80, (H - topMargin - 40) / (levels.length));
      levels.forEach((row, li) => {
        const y = topMargin + li * levelHeight;
        // spread horizontally across width; at level li, place nodes evenly among slots 2^li
        const slots = Math.pow(2, li);
        row.forEach((idx, k) => {
          const x = W * ( (k+0.5) / slots );
          coords[idx] = {x,y};
        });
      });

      // draw edges
      arr.forEach((node, idx) => {
        const left = 2*idx+1, right = 2*idx+2;
        const p = coords[idx];
        if (left < arr.length) {
          const c = coords[left];
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1',p.x);
          line.setAttribute('y1',p.y+18);
          line.setAttribute('x2',c.x);
          line.setAttribute('y2',c.y-18);
          line.setAttribute('stroke','rgba(255,255,255,0.04)');
          line.setAttribute('stroke-width','1.5');
          svg.appendChild(line);
        }
        if (right < arr.length) {
          const c = coords[right];
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1',p.x);
          line.setAttribute('y1',p.y+18);
          line.setAttribute('x2',c.x);
          line.setAttribute('y2',c.y-18);
          line.setAttribute('stroke','rgba(255,255,255,0.04)');
          line.setAttribute('stroke-width','1.5');
          svg.appendChild(line);
        }
      });

      // draw nodes
      arr.forEach((node, idx) => {
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('class','node');
        g.setAttribute('data-idx',idx);
        const {x,y} = coords[idx];
        g.setAttribute('transform', `translate(${x},${y})`);
        // circle
        const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circ.setAttribute('r', 26);
        circ.setAttribute('fill', 'url(#grad'+idx+')');
        circ.setAttribute('stroke','rgba(255,255,255,0.03)');
        circ.setAttribute('stroke-width','1.5');
        // gradient
        const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
        const grad = document.createElementNS('http://www.w3.org/2000/svg','radialGradient');
        grad.setAttribute('id','grad'+idx);
        const stop1 = document.createElementNS('http://www.w3.org/2000/svg','stop');
        stop1.setAttribute('offset','0%'); stop1.setAttribute('stop-color','#0ea5e9'); stop1.setAttribute('stop-opacity','0.06');
        const stop2 = document.createElementNS('http://www.w3.org/2000/svg','stop');
        stop2.setAttribute('offset','100%'); stop2.setAttribute('stop-color','#111827'); stop2.setAttribute('stop-opacity','0.8');
        grad.appendChild(stop1); grad.appendChild(stop2); defs.appendChild(grad);
        g.appendChild(defs);
        g.appendChild(circ);
        // text value
        const t1 = document.createElementNS('http://www.w3.org/2000/svg','text');
        t1.setAttribute('x',0); t1.setAttribute('y',-4);
        t1.setAttribute('text-anchor','middle');
        t1.setAttribute('fill','white');
        t1.setAttribute('font-size','11');
        t1.setAttribute('font-weight','700');
        t1.textContent = node.value!==null?node.value:'(nil)';
        g.appendChild(t1);
        const t2 = document.createElementNS('http://www.w3.org/2000/svg','text');
        t2.setAttribute('x',0); t2.setAttribute('y',14);
        t2.setAttribute('text-anchor','middle');
        t2.setAttribute('fill','rgba(255,255,255,0.7)');
        t2.setAttribute('font-size','11');
        t2.textContent = `p=${node.priority}`;
        g.appendChild(t2);

        svg.appendChild(g);
      });
    }

    // animate swap sequence (array indices) and update DOM highlighting
    async function animateSwaps(swaps, description){
      if (!swaps || swaps.length === 0) {
        if (description) writeLog(description + ' (no swaps)');
        render();
        return;
      }
      writeLog(description + ` (swaps: ${swaps.length})`);
      animPlaying = true;
      for (let k=0;k<swaps.length;k++){
        const [i,j] = swaps[k];
        // highlight array cells
        highlightArrayCells(i,j);
        // animate svg nodes by swapping their positions (we will visually swap by updating transform)
        const nodes = document.querySelectorAll('#heapSvg .node');
        const nodeI = [...nodes].find(n => Number(n.getAttribute('data-idx')) === i);
        const nodeJ = [...nodes].find(n => Number(n.getAttribute('data-idx')) === j);
        // if nodes not found (maybe re-render won't match indices), fall back to re-render then pause.
        if (!nodeI || !nodeJ) {
          render();
          await pause(animSpeed);
          continue;
        }
        // extract transforms
        const t1 = nodeI.getAttribute('transform');
        const t2 = nodeJ.getAttribute('transform');
        // animate quick scale then swap positions
        nodeI.style.transition = `transform ${animSpeed/1.8}ms ease`;
        nodeJ.style.transition = `transform ${animSpeed/1.8}ms ease`;
        // swap transforms
        nodeI.setAttribute('transform', t2);
        nodeJ.setAttribute('transform', t1);
        await pause(animSpeed);
        // after animation, update actual data positions for subsequent transforms by re-rendering
        render();
      }
      clearHighlights();
      animPlaying = false;
    }

    function highlightArrayCells(i,j){
      const cells = arrayWrap.querySelectorAll('.cell');
      cells.forEach((c,idx) => {
        c.classList.toggle('highlight', idx===i || idx===j);
      });
    }
    function clearHighlights(){
      const cells = arrayWrap.querySelectorAll('.cell');
      cells.forEach(c => c.classList.remove('highlight'));
    }
    function pause(ms){ return new Promise(r => setTimeout(r, ms)); }

    // UI event handlers
    addBtn.addEventListener('click', () => {
      const v = valueInput.value.trim();
      const p = priorityInput.value;
      if (p === '') { alert('Please enter a numeric priority'); return; }
      const res = pq.push(v, Number(p));
      animSteps = []; // reset queued animations
      // animate the swaps for push
      (async ()=>{
        await animateSwaps(res.swaps, `Push ${v || String(p)} (p=${p})`);
      })();
      writeLog(`push value="${v || '(nil)'}" priority=${p}`);
      render();
      valueInput.value = '';
      priorityInput.value = '';
    });

    addRandBtn.addEventListener('click', () => {
      const val = randomValue();
      const pr = Math.floor(Math.random()*100);
      const res = pq.push(val, pr);
      (async ()=> {
        await animateSwaps(res.swaps, `Push ${val} (p=${pr})`);
      })();
      writeLog(`push value="${val}" priority=${pr}`);
      render();
    });

    bulkRandBtn.addEventListener('click', async () => {
      const ops = [];
      for (let i=0;i<10;i++){
        const val = randomValue();
        const pr = Math.floor(Math.random()*100);
        ops.push({val,pr});
      }
      // push one by one with animation
      for (const op of ops){
        const res = pq.push(op.val, op.pr);
        await animateSwaps(res.swaps, `Push ${op.val} (p=${op.pr})`);
        writeLog(`push value="${op.val}" priority=${op.pr}`);
      }
      render();
    });

    popBtn.addEventListener('click', async () => {
      if (pq.size() === 0) { writeLog('pop attempted on empty heap'); return; }
      const beforeTop = pq.peek();
      const res = pq.pop();
      await animateSwaps(res.swaps, `Pop -> removed ${res.node.value} (p=${res.node.priority})`);
      writeLog(`pop removed value="${res.node.value}" priority=${res.node.priority}`);
      render();
    });

    peekBtn.addEventListener('click', () => {
      const t = pq.peek();
      if (!t) {
        writeLog('peek: heap empty');
        alert('Heap is empty');
      } else {
        writeLog(`peek: ${t.value} (p=${t.priority})`);
        alert(`Top: ${t.value} (priority=${t.priority})`);
      }
      render();
    });

    clearBtn.addEventListener('click', () => {
      pq.clear();
      writeLog('cleared heap');
      render();
    });

    modeSelect.addEventListener('change', () => {
      const m = modeSelect.value;
      pq.setMode(m);
      // Rebuild to restore heap order under new comparator
      pq.rebuildFromArray(pq.toArray());
      writeLog(`mode set to ${m}`);
      render();
    });

    rebuildBtn.addEventListener('click', () => {
      pq.rebuildFromArray(pq.toArray());
      writeLog('heap rebuilt');
      render();
    });

    demoSeqBtn.addEventListener('click', async () => {
      // demo sequence: add few items, pop some, add more
      const seq = [
        {op:'push',v:'A',p:20},
        {op:'push',v:'B',p:5},
        {op:'push',v:'C',p:14},
        {op:'push',v:'D',p:5},
        {op:'pop'},
        {op:'push',v:'E',p:2},
        {op:'pop'},
        {op:'pop'}
      ];
      for (const s of seq){
        if (s.op === 'push'){
          const res = pq.push(s.v, s.p);
          await animateSwaps(res.swaps, `Push ${s.v} (p=${s.p})`);
          writeLog(`push ${s.v} p=${s.p}`);
        } else if (s.op === 'pop'){
          if (pq.size() === 0) { writeLog('pop attempted on empty during demo'); continue; }
          const res = pq.pop();
          await animateSwaps(res.swaps, `Pop -> removed ${res.node.value}`);
          writeLog(`pop -> ${res.node.value}`);
        }
      }
      render();
    });

    // Play/pause and speed controls (for potential queued animations)
    fastToggleBtn.addEventListener('click', () => {
      if (animSpeed === 300) { animSpeed = 120; fastToggleBtn.textContent = 'Speed: 120ms'; }
      else if (animSpeed === 120) { animSpeed = 50; fastToggleBtn.textContent = 'Speed: 50ms'; }
      else { animSpeed = 300; fastToggleBtn.textContent = 'Speed: 300ms'; }
    });
    playAnimBtn.addEventListener('click', () => {
      // not bound to specialized queued animations in this simple demo
      alert('Animations play automatically for each operation. Use Demo Sequence to see multiple steps.');
    });
    stepBackBtn.addEventListener('click', () => {
      alert('Step back is not implemented. You can clear and replay actions to simulate stepping.');
    });

    // helper utilities
    function randomValue(){
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      return letters[Math.floor(Math.random()*letters.length)];
    }

    // initialize with some random items
    (async ()=>{
      for (let i=0;i<5;i++){
        const v = randomValue();
        const p = Math.floor(Math.random()*60);
        const res = pq.push(v,p);
        // we await but with short pause
        await animateSwaps(res.swaps, `Initial push ${v} (p=${p})`);
      }
      writeLog('initialized with random items');
      render();
    })();

    // Ensure initial rendering
    render();

    // Expose pq to window for debugging in browser console
    window._pq = pq;
    window._render = render;
  </script>
</body>
</html>