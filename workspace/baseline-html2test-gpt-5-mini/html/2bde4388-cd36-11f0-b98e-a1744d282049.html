<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Heap Sort Visualization</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --muted:#9aa6bf;
    --accent:#3b82f6;
    --good:#10b981;
    --danger:#ef4444;
    --heap:#f59e0b;
    --bar-gap:4px;
  }
  html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;color:var(--muted);background:linear-gradient(180deg,#071022,var(--bg));}
  .app{display:flex;flex-direction:column;gap:16px;padding:18px;max-width:1200px;margin:0 auto;}
  header{display:flex;align-items:center;gap:12px;}
  header h1{margin:0;color:#fff;font-size:20px;}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
  button{background:linear-gradient(180deg,#111827,#0b1220);color:var(--muted);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;cursor:pointer;}
  button.primary{background:linear-gradient(180deg,var(--accent),#1558d6);color:white;border:none;box-shadow:0 6px 20px rgba(59,130,246,0.18);}
  button:active{transform:translateY(1px);}
  .small{padding:6px 8px;font-size:13px;}
  .row{display:flex;gap:12px;align-items:center;}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);}
  .visual{display:flex;gap:12px;}
  .barsPanel{flex:1;min-height:280px;display:flex;flex-direction:column;gap:8px;}
  .barsArea{background:rgba(255,255,255,0.01);border-radius:8px;padding:12px;flex:1;display:flex;align-items:end;overflow:hidden;}
  .bars{display:flex;align-items:end;gap:var(--bar-gap);width:100%;height:100%;}
  .bar{flex:1 1 auto;background:linear-gradient(180deg,#4b5563,#111827);border-radius:6px 6px 4px 4px;display:flex;align-items:flex-end;justify-content:center;transition:height 0.25s ease, background-color .15s;position:relative;}
  .barIndex{position:absolute;left:4px;bottom:4px;font-size:11px;color:rgba(255,255,255,0.6);}
  .barLabel{position:absolute;right:6px;top:4px;font-size:11px;color:rgba(255,255,255,0.6);}
  .bar.compare{background:linear-gradient(180deg,#f97316,#ea580c);box-shadow:0 4px 16px rgba(249,115,22,0.12);}
  .bar.swap{background:linear-gradient(180deg,#ef4444,#dc2626);box-shadow:0 6px 20px rgba(239,68,68,0.12);}
  .bar.heap{background:linear-gradient(180deg,#f59e0b,#b45309);}
  .bar.sorted{background:linear-gradient(180deg,#10b981,#059669);}
  .stats{min-width:220px;display:flex;flex-direction:column;gap:8px;}
  .statRow{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);}
  .legend{display:flex;gap:8px;flex-wrap:wrap;}
  .legendItem{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted);}
  .swatch{width:16px;height:12px;border-radius:4px;background:#ccc;box-shadow:inset 0 -2px 0 rgba(0,0,0,0.12);}
  .codePanel{width:420px;max-height:520px;overflow:auto;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:12px;border:1px solid rgba(255,255,255,0.02);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;font-size:13px;color:var(--muted);}
  pre{margin:0;white-space:pre-wrap;}
  .codeLine{display:block;padding:4px 6px;border-radius:6px;}
  .lineActive{background:rgba(99,102,241,0.12);color:#e6eefc;}
  .smallMuted{font-size:13px;color:var(--muted);}
  .controlsGroup{display:flex;gap:8px;align-items:center;}
  input[type=range]{width:140px;}
  footer{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px;margin-top:6px;}
  .toggle{display:inline-flex;align-items:center;gap:8px;}
  .btnIcon{display:inline-flex;align-items:center;justify-content:center;width:28px;height:28px;border-radius:6px;background:rgba(255,255,255,0.02);}
  .smallControl{font-size:13px;color:var(--muted);}
  @media (max-width:980px){
    .visual{flex-direction:column;}
    .codePanel{width:100%;}
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Heap Sort — step-by-step visualization</h1>
    <div class="smallMuted">Learn how Heap Sort builds a max-heap and repeatedly extracts the max.</div>
  </header>

  <div class="controls panel">
    <div class="row" style="justify-content:space-between;">
      <div class="controlsGroup">
        <button id="shuffleBtn" class="small">Shuffle / New array</button>
        <button id="startBtn" class="primary small">Start</button>
        <button id="stepBtn" class="small">Step</button>
        <button id="playPauseBtn" class="small">Play</button>
        <button id="resetBtn" class="small">Reset</button>
      </div>
      <div style="display:flex;gap:12px;align-items:center;">
        <label class="smallMuted">Speed</label>
        <input id="speedRange" type="range" min="10" max="1000" value="300">
        <div id="speedLabel" class="smallMuted">300 ms</div>
      </div>
    </div>
  </div>

  <div class="visual">
    <div class="barsPanel panel">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div class="smallMuted">Array (size: <span id="sizeLabel">30</span>)</div>
        <div class="legend">
          <div class="legendItem"><div class="swatch" style="background:linear-gradient(180deg,#4b5563,#111827)"></div> Unseen</div>
          <div class="legendItem"><div class="swatch" style="background:linear-gradient(180deg,#f59e0b,#b45309)"></div> In heap</div>
          <div class="legendItem"><div class="swatch" style="background:linear-gradient(180deg,#f97316,#ea580c)"></div> Comparing</div>
          <div class="legendItem"><div class="swatch" style="background:linear-gradient(180deg,#ef4444,#dc2626)"></div> Swapping</div>
          <div class="legendItem"><div class="swatch" style="background:linear-gradient(180deg,#10b981,#059669)"></div> Sorted</div>
        </div>
      </div>

      <div class="barsArea" id="barsArea">
        <div class="bars" id="bars"></div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px;">
        <div class="smallMuted">Stage: <strong id="stageLabel">idle</strong></div>
        <div class="smallMuted">Comparisons: <strong id="compCount">0</strong> &nbsp;|&nbsp; Swaps: <strong id="swapCount">0</strong></div>
      </div>
    </div>

    <div class="codePanel panel" id="codePanel">
      <div style="font-weight:600;color:#fff;margin-bottom:8px;">Pseudocode (highlighted as algorithm runs)</div>
      <pre id="code">
<span class="codeLine" data-line="1">1  function heapSort(A):</span>
<span class="codeLine" data-line="2">2      n = A.length</span>
<span class="codeLine" data-line="3">3      # Build max-heap</span>
<span class="codeLine" data-line="4">4      for i = floor(n/2) - 1 downto 0:</span>
<span class="codeLine" data-line="5">5          siftDown(A, i, n)</span>
<span class="codeLine" data-line="6">6      # Extract elements</span>
<span class="codeLine" data-line="7">7      for end = n - 1 downto 1:</span>
<span class="codeLine" data-line="8">8          swap(A[0], A[end])</span>
<span class="codeLine" data-line="9">9          siftDown(A, 0, end)</span>
<span class="codeLine" data-line="10">10     return A</span>

<span class="codeLine" data-line="11"></span>
<span class="codeLine" data-line="12">11 function siftDown(A, root, n):</span>
<span class="codeLine" data-line="13">12     while true:</span>
<span class="codeLine" data-line="14">13         child = 2 * root + 1</span>
<span class="codeLine" data-line="15">14         if child >= n: break</span>
<span class="codeLine" data-line="16">15         swapIdx = root</span>
<span class="codeLine" data-line="17">16         if A[swapIdx] < A[child]: swapIdx = child</span>
<span class="codeLine" data-line="18">17         if child + 1 < n and A[swapIdx] < A[child + 1]: swapIdx = child + 1</span>
<span class="codeLine" data-line="19">18         if swapIdx == root: return</span>
<span class="codeLine" data-line="20">19         swap(A[root], A[swapIdx])</span>
<span class="codeLine" data-line="21">20         root = swapIdx</span>
      </pre>
    </div>
  </div>

  <footer>
    <div class="smallMuted">This demo uses a max-heap (0-based array). Building the heap is O(n), full sort is O(n log n).</div>
    <div class="smallMuted">Data mutated in-place.</div>
  </footer>
</div>

<script>
(function(){
  // Configuration
  const DEFAULT_SIZE = 30;
  const MIN_VAL = 5;
  const MAX_VAL = 100;

  // DOM elements
  const barsEl = document.getElementById('bars');
  const sizeLabel = document.getElementById('sizeLabel');
  const stageLabel = document.getElementById('stageLabel');
  const compCountEl = document.getElementById('compCount');
  const swapCountEl = document.getElementById('swapCount');
  const startBtn = document.getElementById('startBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const stepBtn = document.getElementById('stepBtn');
  const playPauseBtn = document.getElementById('playPauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const speedRange = document.getElementById('speedRange');
  const speedLabel = document.getElementById('speedLabel');
  const codePanel = document.getElementById('codePanel');
  const codeLines = Array.from(document.querySelectorAll('.codeLine'));
  const barsArea = document.getElementById('barsArea');

  // State
  let values = [];
  let bars = [];
  let generator = null;
  let running = false;
  let playing = false;
  let compCount = 0;
  let swapCount = 0;
  let heapSize = 0;
  let delay = parseInt(speedRange.value); // ms
  let lastAction = null;

  // Utilities
  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function createArray(n){
    const arr = [];
    for(let i=0;i<n;i++) arr.push(randInt(MIN_VAL, MAX_VAL));
    return arr;
  }

  function renderBars(){
    barsEl.innerHTML = '';
    bars = [];
    const maxV = Math.max(...values);
    for(let i=0;i<values.length;i++){
      const v = values[i];
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.height = (v/maxV*100) + '%';
      bar.style.transitionDuration = (delay/1000) + 's';
      bar.dataset.index = i;
      const idx = document.createElement('div');
      idx.className = 'barIndex';
      idx.textContent = i;
      const lbl = document.createElement('div');
      lbl.className = 'barLabel';
      lbl.textContent = v;
      bar.appendChild(idx);
      bar.appendChild(lbl);
      barsEl.appendChild(bar);
      bars.push(bar);
    }
    sizeLabel.textContent = values.length;
  }

  function updateLabels(){
    compCountEl.textContent = compCount;
    swapCountEl.textContent = swapCount;
  }

  function highlightLine(n){
    codeLines.forEach(line => {
      if(parseInt(line.dataset.line) === n) line.classList.add('lineActive');
      else line.classList.remove('lineActive');
    });
  }
  function clearHighlights(){ codeLines.forEach(l=>l.classList.remove('lineActive')); }

  function markHeapRange(n){
    heapSize = n;
    // mark bars in heap range
    for(let i=0;i<bars.length;i++){
      bars[i].classList.remove('heap');
      if(i < n && !bars[i].classList.contains('sorted')){
        bars[i].classList.add('heap');
      }
    }
  }

  function markSorted(index){
    bars[index].classList.remove('heap','compare','swap');
    bars[index].classList.add('sorted');
  }

  function setCompare(i,j){
    clearActionMarks();
    if (bars[i]) bars[i].classList.add('compare');
    if (bars[j]) bars[j].classList.add('compare');
  }

  function setSwap(i,j){
    clearActionMarks();
    if (bars[i]) bars[i].classList.add('swap');
    if (bars[j]) bars[j].classList.add('swap');
  }

  function clearActionMarks(){
    bars.forEach(b => {
      b.classList.remove('compare','swap');
    });
  }

  function swapValues(i,j){
    // swap values array
    const t = values[i]; values[i] = values[j]; values[j] = t;
    // swap heights and labels (animate via CSS transition)
    const maxV = Math.max(...values);
    bars.forEach((bar, idx) => {
      const v = values[idx];
      bar.style.height = (v/maxV*100) + '%';
      const lbl = bar.querySelector('.barLabel');
      if(lbl) lbl.textContent = v;
    });
    // swap DOM order of indices is not necessary; we keep index labels updated.
  }

  // Heap sort generator: yields descriptive actions
  function* heapSortSteps(A){
    const n = A.length;
    compCount = 0; swapCount = 0;
    // Build max-heap
    for(let i=Math.floor(n/2)-1;i>=0;i--){
      yield {type:'siftStart', root:i, heapSize:n};
      yield* siftDown(A, i, n);
    }
    yield {type:'setHeapRange', heapSize:n};

    // Extract elements
    for(let end=n-1; end>0; end--){
      yield {type:'compare', indices:[0,end], line:8};
      yield {type:'swap', indices:[0,end], line:8};
      // perform swap
      [A[0], A[end]] = [A[end], A[0]];
      yield {type:'afterSwap', indices:[0,end]}; // update UI
      yield {type:'markSorted', index:end};
      // sift down root within reduced heap
      yield {type:'siftStart', root:0, heapSize:end};
      yield* siftDown(A, 0, end);
      yield {type:'setHeapRange', heapSize:end};
    }
    yield {type:'markSorted', index:0};
    yield {type:'done'};
  }

  function* siftDown(A, root, n){
    // Corresponds to pseudocode lines 11-20
    while(true){
      yield {type:'line', line:12};
      let child = 2*root + 1;
      yield {type:'line', line:13};
      if(child >= n) {
        yield {type:'siftEnd', root, heapSize:n};
        return;
      }
      yield {type:'line', line:15};
      let swapIdx = root;
      // compare root and left child
      yield {type:'compare', indices:[swapIdx, child], line:16};
      if(A[swapIdx] < A[child]){
        swapIdx = child;
      }
      // maybe right child
      if(child + 1 < n){
        yield {type:'compare', indices:[swapIdx, child+1], line:17};
        if(A[swapIdx] < A[child+1]){
          swapIdx = child + 1;
        }
      }
      yield {type:'line', line:18};
      if(swapIdx === root){
        yield {type:'siftEnd', root, heapSize:n};
        return;
      }
      // perform swap
      yield {type:'swap', indices:[root, swapIdx], line:19};
      [A[root], A[swapIdx]] = [A[swapIdx], A[root]];
      yield {type:'afterSwap', indices:[root, swapIdx], line:19};
      root = swapIdx;
      yield {type:'line', line:20};
    }
  }

  // Action processor
  async function processAction(action){
    lastAction = action;
    // ensure delays / transition durations are updated
    bars.forEach(b => b.style.transitionDuration = (delay/1000) + 's');

    switch(action.type){
      case 'siftStart':
        stageLabel.textContent = 'sift-down (root='+action.root+')';
        highlightLine(12);
        markHeapRange(action.heapSize);
        break;
      case 'siftEnd':
        stageLabel.textContent = 'sift-down complete';
        clearHighlights();
        markHeapRange(action.heapSize);
        clearActionMarks();
        break;
      case 'setHeapRange':
        markHeapRange(action.heapSize);
        stageLabel.textContent = 'heap size = ' + action.heapSize;
        clearHighlights();
        break;
      case 'compare':
        compCount++;
        updateLabels();
        setCompare(action.indices[0], action.indices[1]);
        if(action.line) highlightLine(action.line);
        stageLabel.textContent = 'comparing indices ' + action.indices[0] + ' & ' + action.indices[1];
        break;
      case 'swap':
        swapCount++;
        updateLabels();
        setSwap(action.indices[0], action.indices[1]);
        if(action.line) highlightLine(action.line);
        stageLabel.textContent = 'swapping ' + action.indices[0] + ' & ' + action.indices[1];
        break;
      case 'afterSwap':
        // apply UI swap (values array should have been swapped by generator)
        swapValues(action.indices[0], action.indices[1]);
        clearActionMarks();
        break;
      case 'markSorted':
        markSorted(action.index);
        stageLabel.textContent = 'marked sorted index ' + action.index;
        clearHighlights();
        break;
      case 'done':
        stageLabel.textContent = 'done — array sorted';
        clearHighlights();
        playing = false;
        updatePlayPauseButton();
        break;
      case 'line':
        highlightLine(action.line);
        break;
      default:
        console.log('unknown action', action);
    }

    // Wait a bit after action (except for afterSwap and setHeapRange maybe short)
    await pauseFor(action);
  }

  function pauseFor(action){
    let base = delay;
    if(action.type === 'afterSwap') base = Math.max(40, delay/1.2);
    if(action.type === 'setHeapRange' || action.type === 'siftEnd') base = Math.max(40, delay/2);
    // use promise
    return new Promise(resolve => setTimeout(resolve, base));
  }

  // Driver: step once
  async function stepOnce(){
    if(!generator) return;
    const res = generator.next();
    if(res.done){
      // finished
      stageLabel.textContent = 'done';
      playing = false;
      updatePlayPauseButton();
      return;
    }
    await processAction(res.value);
  }

  // Play loop
  async function playLoop(){
    while(playing){
      const res = generator.next();
      if(res.done){
        stageLabel.textContent = 'done';
        playing = false;
        updatePlayPauseButton();
        return;
      }
      await processAction(res.value);
      // allow UI to break if play ended mid-wait
      await new Promise(r => setTimeout(r, 0));
    }
  }

  // Controls
  function resetState(newValues){
    values = newValues.slice();
    compCount = 0; swapCount = 0;
    heapSize = values.length;
    updateLabels();
    renderBars();
    clearHighlights();
    stageLabel.textContent = 'idle';
    generator = null;
    playing = false;
    updatePlayPauseButton();
  }

  function startSort(){
    if(generator) return;
    // Defensive clone; generator will mutate its own internal array; we want UI to reflect operations.
    const arrCopy = values.slice();
    generator = heapSortSteps(arrCopy);
    // Start first step automatically if play toggled
    stageLabel.textContent = 'started';
  }

  function updatePlayPauseButton(){
    playPauseBtn.textContent = playing ? 'Pause' : 'Play';
    if(playing) playPauseBtn.classList.add('primary'); else playPauseBtn.classList.remove('primary');
  }

  // Event listeners
  shuffleBtn.addEventListener('click', ()=>{
    const size = values.length;
    const newArr = createArray(size);
    resetState(newArr);
  });

  startBtn.addEventListener('click', ()=>{
    if(!generator){
      startSort();
      // do not auto-run; user chooses Step or Play
    } else {
      alert('Sorting already started. Use Step / Play / Reset.');
    }
  });

  stepBtn.addEventListener('click', async ()=>{
    if(!generator) startSort();
    await stepOnce();
  });

  playPauseBtn.addEventListener('click', async ()=>{
    if(!generator) startSort();
    playing = !playing;
    updatePlayPauseButton();
    if(playing){
      await playLoop();
    }
  });

  resetBtn.addEventListener('click', ()=>{
    // reset to initial random array
    const newArr = createArray(values.length);
    resetState(newArr);
  });

  speedRange.addEventListener('input', ()=>{
    delay = parseInt(speedRange.value);
    speedLabel.textContent = delay + ' ms';
    bars.forEach(b => b.style.transitionDuration = (delay/1000) + 's');
  });

  // Initialize UI with default array
  resetState(createArray(DEFAULT_SIZE));

  // Helpful tips on first run (no alert, but instructions in console to keep file compact)
  console.log('Heap Sort visualizer ready. Use "Start" then "Step" or "Play" to see the algorithm.');
})();
</script>
</body>
</html>