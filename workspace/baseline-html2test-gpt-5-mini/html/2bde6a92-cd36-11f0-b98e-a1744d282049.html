<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Topological Sort — Interactive Demo</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#2dd4bf;
    --muted:#94a3b8;
    --danger:#fb7185;
    --node:#60a5fa;
    --node-processed:#34d399;
    --node-zero:#fbbf24;
    --edge:#cbd5e1;
    --selected:#a78bfa;
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(180deg,#071028 0%,#041022 100%);color:#e6eef8}
  .container{display:flex;gap:16px;padding:18px;box-sizing:border-box;height:100%}
  .sidebar{width:340px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:14px;box-sizing:border-box;overflow:auto;box-shadow:0 6px 20px rgba(2,6,23,0.6)}
  h1{font-size:20px;margin:6px 0 12px 0;color:var(--accent)}
  .controls{display:flex;flex-direction:column;gap:8px}
  .row{display:flex;gap:8px;align-items:center}
  button, input[type="number"], select {background:#07142a;border:1px solid rgba(255,255,255,0.04);color:#e6eef8;padding:8px;border-radius:8px}
  button:hover{opacity:0.95;cursor:pointer}
  input[type="text"]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}
  label{font-size:13px;color:var(--muted)}
  small{color:var(--muted);display:block;margin-top:6px}
  .canvas-wrap{flex:1;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:10px}
  svg{width:100%;height:100%;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);overflow:visible}
  .legend{display:flex;gap:10px;flex-wrap:wrap;font-size:13px;color:var(--muted)}
  .legend .item{display:flex;gap:6px;align-items:center}
  .badge{width:14px;height:14px;border-radius:3px}
  .panel{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-top:8px}
  .adj-list{font-family:monospace;font-size:13px;color:var(--muted);white-space:pre}
  .log{font-family:monospace;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;max-height:160px;overflow:auto;color:var(--muted);font-size:13px}
  .small-btn{padding:6px 8px;border-radius:8px;font-size:13px}
  .controls .hint{font-size:12px;color:var(--muted);margin-top:4px}
  .footer{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-top:8px}
  .order-output{font-weight:600;color:var(--accent);font-family:monospace}
</style>
</head>
<body>
<div class="container">
  <div class="sidebar">
    <h1>Topological Sort — Interactive Demo</h1>
    <div class="controls">
      <div>
        <label>Graph construction</label>
        <div class="row" style="margin-top:8px">
          <button id="btnAddNode">Add Node</button>
          <button id="btnEdgeMode" class="small-btn">Create Edge</button>
          <button id="btnDeleteMode" class="small-btn">Delete</button>
        </div>
        <small>Click on canvas to add nodes. Use Create Edge then click source → target. Delete mode: click node/edge to remove. Drag nodes to reposition.</small>
      </div>

      <div class="panel">
        <div class="row">
          <label style="flex:1">Random DAG generator</label>
        </div>
        <div class="row" style="margin-top:8px">
          <input id="randN" type="number" min="1" max="26" value="7" style="width:80px">
          <input id="randM" type="number" min="0" max="200" value="10" style="width:80px">
          <button id="btnRandom" class="small-btn">Generate</button>
          <button id="btnClear" class="small-btn">Clear</button>
        </div>
        <small>Random generator ensures edges point forward by node index if "DAG guaranteed" checked.</small>
        <div class="row" style="margin-top:8px">
          <label><input id="guaranteeDAG" type="checkbox" checked> DAG guaranteed</label>
        </div>
      </div>

      <div style="margin-top:8px">
        <label>Algorithms</label>
        <div class="row" style="margin-top:8px">
          <button id="runKahn">Run Kahn (step)</button>
          <button id="stepKahn" class="small-btn">Next Step</button>
          <button id="resetKahn" class="small-btn">Reset Kahn</button>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="runDFS">Run DFS topo (animate)</button>
          <button id="stopDFS" class="small-btn">Stop</button>
        </div>
        <small class="hint">Kahn's algorithm is iterative and uses in-degree / zero queue. DFS-based uses post-order (finish times).</small>
      </div>

      <div class="panel" style="margin-top:8px">
        <label>State</label>
        <div style="margin-top:8px">
          <div>In-degrees: <span id="degrees" class="order-output">—</span></div>
          <div style="margin-top:6px">Kahn queue: <span id="kahnQueue" class="order-output">[]</span></div>
          <div style="margin-top:6px">Topological order: <span id="topoOrder" class="order-output">[]</span></div>
        </div>
      </div>

      <div class="panel">
        <label>Adjacency</label>
        <div class="adj-list" id="adjList">[]</div>
      </div>

      <div class="panel">
        <label>Execution Log</label>
        <div class="log" id="log"></div>
      </div>

      <div class="footer">
        <div class="legend">
          <div class="item"><div class="badge" style="background:var(--node)"></div><div>Unvisited</div></div>
          <div class="item"><div class="badge" style="background:var(--node-zero)"></div><div>Zero indegree</div></div>
          <div class="item"><div class="badge" style="background:var(--node-processed)"></div><div>Processed</div></div>
          <div class="item"><div class="badge" style="background:var(--danger)"></div><div>Cycle / Back edge</div></div>
        </div>
      </div>

    </div>
  </div>

  <div class="canvas-wrap">
    <svg id="svgCanvas" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet">
      <defs>
        <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--edge)"></path>
        </marker>
        <marker id="arrow-red" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="8" orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--danger)"></path>
        </marker>
      </defs>
      <!-- edges and nodes will be drawn here -->
    </svg>
    <small style="color:var(--muted)">Canvas: click to add nodes; drag nodes; use modes for edges/deleting. Nodes are labeled A, B, C ...</small>
  </div>
</div>

<script>
/* Topological Sort interactive demo
   - Build directed graph by clicking or generating random graphs
   - Create edges by selecting source then target
   - Run Kahn's algorithm step-by-step
   - Run DFS-based topological sort with animation
   - Detect cycles and display them
*/

const svg = document.getElementById('svgCanvas');
const NS = "http://www.w3.org/2000/svg";
let nodes = []; // {id:int,label:str,x,y}
let edges = []; // {from:int,to:int,svgElement,svgPath}
// mapping from id to indegree etc computed as needed
let nextId = 0;

let mode = 'none'; // 'addEdge' or 'delete' or 'none'
let edgeSource = null;
let selectedElement = null;
let dragging = null;
let dragOffset = {x:0,y:0};

// Kahn state
let kahnState = null; // {inDeg:Map,idToNode,result:[],queue:[],processed:Set,stepLog:[]}
let dfsTimer = null;
let dfsEvents = [];

// UI elements
const btnAddNode = document.getElementById('btnAddNode');
const btnEdgeMode = document.getElementById('btnEdgeMode');
const btnDeleteMode = document.getElementById('btnDeleteMode');
const btnRandom = document.getElementById('btnRandom');
const btnClear = document.getElementById('btnClear');
const randN = document.getElementById('randN');
const randM = document.getElementById('randM');
const guaranteeDAG = document.getElementById('guaranteeDAG');

const runKahn = document.getElementById('runKahn');
const stepKahn = document.getElementById('stepKahn');
const resetKahn = document.getElementById('resetKahn');
const runDFS = document.getElementById('runDFS');
const stopDFS = document.getElementById('stopDFS');

const degreesEl = document.getElementById('degrees');
const kahnQueueEl = document.getElementById('kahnQueue');
const topoOrderEl = document.getElementById('topoOrder');
const adjListEl = document.getElementById('adjList');
const logEl = document.getElementById('log');

// helper: create svg elements
function svgElem(name, attrs={}) {
  const el = document.createElementNS(NS,name);
  for (let k in attrs) el.setAttribute(k, attrs[k]);
  return el;
}

function log(msg){
  const time = new Date().toLocaleTimeString();
  logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
}

// Graph operations
function addNodeAt(x,y){
  const id = nextId++;
  const label = String.fromCharCode(65 + (id % 26)) + (Math.floor(id/26) || '');
  const node = {id,label,x,y};
  nodes.push(node);
  drawGraph();
  return node;
}

function removeNode(id){
  nodes = nodes.filter(n=>n.id!==id);
  edges = edges.filter(e=>{
    if (e.from===id || e.to===id){
      if (e.svgPath) e.svgPath.remove();
      return false;
    }
    return true;
  });
  drawGraph();
}

function addEdge(from,to){
  // prevent duplicate
  if (edges.some(e=>e.from===from && e.to===to)) return;
  edges.push({from,to});
  drawGraph();
}

function removeEdge(from,to){
  edges = edges.filter(e=> !(e.from===from && e.to===to));
  drawGraph();
}

function clearGraph(){
  nodes = []; edges = []; nextId = 0;
  drawGraph();
  resetKahnState();
  stopDFSAnimation();
  logEl.textContent = '';
}

function randomGraph(n,m,dag=true){
  clearGraph();
  // create nodes arranged in circle
  const cx = 500, cy = 350, r = Math.min(280, 40*n);
  for (let i=0;i<n;i++){
    const angle = (i / n) * Math.PI*2;
    addNodeAt(cx + r*Math.cos(angle), cy + r*Math.sin(angle));
  }
  const ids = nodes.map(n=>n.id);
  let attempts=0;
  while (edges.length < m && attempts < m*8){
    attempts++;
    if (dag){
      // ensure edges go from lower to higher index to avoid cycles
      const i = Math.floor(Math.random()*(n-1));
      const j = i+1 + Math.floor(Math.random()*(n-1-i+1));
      addEdge(ids[i], ids[j]);
    } else {
      const a = ids[Math.floor(Math.random()*n)];
      const b = ids[Math.floor(Math.random()*n)];
      if (a!==b) addEdge(a,b);
    }
  }
  drawGraph();
}

function adjacencyList(){
  const adj = {};
  nodes.forEach(n=>adj[n.id]=[]);
  edges.forEach(e=>adj[e.from].push(e.to));
  return adj;
}

function drawGraph(){
  // clear svg children except defs
  [...svg.children].forEach(ch=>{
    if (ch.tagName.toLowerCase() === 'defs') return;
    ch.remove();
  });

  // draw edges first (so they are below nodes)
  const idToNode = Object.fromEntries(nodes.map(n=>[n.id,n]));
  edges.forEach((e,idx)=>{
    const a = idToNode[e.from];
    const b = idToNode[e.to];
    if (!a || !b) return;
    // compute path with slight curvature to avoid overlapping
    const dx = b.x - a.x, dy = b.y - a.y;
    const dist = Math.hypot(dx,dy);
    const normX = dx/dist, normY = dy/dist;
    const startX = a.x + normX*20, startY = a.y + normY*20;
    const endX = b.x - normX*20, endY = b.y - normY*20;
    const mx = (startX + endX)/2, my = (startY + endY)/2;
    // perpendicular offset for curve
    const px = -normY*(10 + ( ( (e.from + e.to) % 3) * 6 ));
    const py = normX*(10 + ( ( (e.from + e.to) % 3) * 6 ));
    const path = svgElem('path',{d:`M ${startX} ${startY} Q ${mx+px} ${my+py} ${endX} ${endY}`, stroke: 'var(--edge)', 'stroke-width':2, fill:'none', 'marker-end':'url(#arrow)', 'data-from':e.from, 'data-to':e.to});
    path.style.transition = 'stroke 160ms, opacity 120ms';
    path.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      if (mode==='delete'){
        removeEdge(e.from,e.to);
        log(`Edge removed: ${labelFor(e.from)} → ${labelFor(e.to)}`);
      }
    });
    svg.appendChild(path);
    e.svgPath = path;
  });

  // draw nodes
  nodes.forEach(n=>{
    const g = svgElem('g',{cursor:'pointer', 'data-id':n.id});
    const circle = svgElem('circle',{cx:n.x, cy:n.y, r:20, fill:'var(--node)', stroke:'rgba(255,255,255,0.04)', 'stroke-width':1});
    circle.style.transition = 'fill 160ms, transform 120ms';
    const text = svgElem('text',{x:n.x, y:n.y+5, 'text-anchor':'middle', 'font-size':14, fill:'#072033', 'font-weight':700});
    text.textContent = n.label;
    g.appendChild(circle);
    g.appendChild(text);
    svg.appendChild(g);

    // events
    g.addEventListener('mousedown', (ev)=>{
      ev.stopPropagation();
      if (mode==='delete'){
        removeNode(n.id);
        log(`Node ${n.label} removed`);
        return;
      }
      if (mode==='addEdge'){
        if (edgeSource==null){
          edgeSource = n.id;
          highlightNode(n.id,true);
        } else {
          const from = edgeSource, to = n.id;
          edgeSource = null;
          highlightAllNodes(false);
          if (from===to){
            log('No self-loops allowed.');
          } else {
            addEdge(from,to);
            log(`Edge added: ${labelFor(from)} → ${labelFor(to)}`);
          }
        }
        return;
      }
      // otherwise start dragging
      dragging = n.id;
      const pt = svg.createSVGPoint();
      pt.x = ev.clientX; pt.y = ev.clientY;
      const ctm = svg.getScreenCTM();
      const loc = pt.matrixTransform(ctm.inverse());
      dragOffset.x = loc.x - n.x;
      dragOffset.y = loc.y - n.y;
    });

    g.addEventListener('dblclick', (ev)=>{
      ev.stopPropagation();
      // double-click to select for quick-edge creation (alternate behavior)
      if (edgeSource==null){
        edgeSource = n.id;
        highlightNode(n.id,true);
        log(`Selected ${n.label} as source`);
      } else {
        addEdge(edgeSource, n.id);
        log(`Edge added: ${labelFor(edgeSource)} → ${n.label}`);
        edgeSource = null;
        highlightAllNodes(false);
      }
    });
  });

  updateAdjacencyView();
  updateKahnDisplay();
}

function labelFor(id){
  const n = nodes.find(x=>x.id===id);
  return n ? n.label : '?';
}

function highlightNode(id, on=true, color=null){
  const g = svg.querySelector(`g[data-id="${id}"]`);
  if (!g) return;
  const circle = g.querySelector('circle');
  if (on){
    circle.setAttribute('fill', color || 'var(--selected)');
    circle.setAttribute('transform','scale(1.08)');
  } else {
    circle.setAttribute('fill','var(--node)');
    circle.setAttribute('transform','scale(1)');
  }
}

function highlightAllNodes(on=false){
  nodes.forEach(n=>highlightNode(n.id,on,false));
}

// mouse move and up for dragging
window.addEventListener('mousemove', (ev)=>{
  if (dragging==null) return;
  const pt = svg.createSVGPoint();
  pt.x = ev.clientX; pt.y = ev.clientY;
  const ctm = svg.getScreenCTM();
  const loc = pt.matrixTransform(ctm.inverse());
  const n = nodes.find(x=>x.id===dragging);
  n.x = loc.x - dragOffset.x;
  n.y = loc.y - dragOffset.y;
  drawGraph();
});

window.addEventListener('mouseup',(ev)=>{
  dragging = null;
});

// canvas click to place nodes
svg.addEventListener('click',(ev)=>{
  // compute coordinates
  const pt = svg.createSVGPoint();
  pt.x = ev.clientX; pt.y = ev.clientY;
  const ctm = svg.getScreenCTM();
  const loc = pt.matrixTransform(ctm.inverse());
  if (mode==='none'){
    addNodeAt(loc.x, loc.y);
    const n = nodes[nodes.length-1];
    log(`Node ${n.label} added`);
  } else if (mode==='addEdge'){
    // clicked empty area: cancel selection
    if (edgeSource!=null){
      edgeSource = null;
      highlightAllNodes(false);
    }
  } else if (mode==='delete'){
    // clicking empty area clears selection
  }
});

// UI wiring
btnAddNode.addEventListener('click', ()=>{ mode='none'; edgeSource=null; btnEdgeMode.style.background=''; btnDeleteMode.style.background=''; log('Add-node mode: click canvas'); });
btnEdgeMode.addEventListener('click', ()=>{
  mode = (mode==='addEdge' ? 'none' : 'addEdge');
  btnEdgeMode.style.background = mode==='addEdge' ? 'rgba(167,139,250,0.15)' : '';
  btnDeleteMode.style.background = '';
  if (mode!=='addEdge') { edgeSource=null; highlightAllNodes(false); }
});
btnDeleteMode.addEventListener('click', ()=>{
  mode = (mode==='delete' ? 'none' : 'delete');
  btnDeleteMode.style.background = mode==='delete' ? 'rgba(251,113,133,0.08)' : '';
  btnEdgeMode.style.background = '';
  edgeSource = null;
  highlightAllNodes(false);
});

btnRandom.addEventListener('click', ()=>{
  const n = Math.max(1,Math.min(26,parseInt(randN.value)||5));
  const m = Math.max(0,parseInt(randM.value)||0);
  randomGraph(n,m, guaranteeDAG.checked);
  log(`Random graph: n=${n}, m=${m}, DAG_guaranteed=${guaranteeDAG.checked}`);
});

btnClear.addEventListener('click', ()=>{ clearGraph(); log('Graph cleared'); });

// adjacency and state display
function updateAdjacencyView(){
  const adj = adjacencyList();
  const lines = nodes.map(n=> `${n.label} (${n.id}) -> [${adj[n.id].map(id=>labelFor(id)).join(', ')}]`);
  adjListEl.textContent = lines.join('\n');
}

// Kahn's algorithm implementation
function computeInDegrees(){
  const inDeg = new Map();
  nodes.forEach(n=>inDeg.set(n.id,0));
  edges.forEach(e=>{
    inDeg.set(e.to, (inDeg.get(e.to)||0)+1);
  });
  return inDeg;
}

function resetKahnState(){
  kahnState = null;
  updateKahnDisplay();
}

runKahn.addEventListener('click', ()=>{
  if (nodes.length===0){ alert('Add nodes to graph first.'); return; }
  // initialize
  const inDeg = computeInDegrees();
  const queue = [];
  for (let [id,d] of inDeg.entries()) if (d===0) queue.push(id);
  kahnState = {
    inDeg, queue: queue.slice(), result: [], processed: new Set()
  };
  log(`Kahn initialized. Zero-indegree nodes: [${queue.map(id=>labelFor(id)).join(', ')}]`);
  updateKahnDisplay();
});

stepKahn.addEventListener('click', ()=>{
  if (!kahnState){ alert('Initialize Kahn first (Run Kahn).'); return; }
  const state = kahnState;
  if (state.queue.length===0){
    if (state.result.length === nodes.length){
      log('Kahn finished successfully — topological order found.');
      topoOrderEl.textContent = state.result.map(id=>labelFor(id)).join(', ');
      highlightOrder(state.result);
      updateKahnDisplay();
      return;
    } else {
      // cycle detected
      const remaining = nodes.filter(n=>!state.processed.has(n.id)).map(n=>n.id);
      log('Cycle detected! Remaining nodes: ' + remaining.map(id=>labelFor(id)).join(', '));
      // highlight remaining nodes in red
      remaining.forEach(id=>{
        const g = svg.querySelector(`g[data-id="${id}"]`);
        if (g) g.querySelector('circle').setAttribute('fill','var(--danger)');
      });
      updateKahnDisplay();
      return;
    }
  }
  // pop node
  const id = state.queue.shift();
  state.result.push(id);
  state.processed.add(id);
  log(`Kahn: process ${labelFor(id)}`);
  // highlight processed
  const g = svg.querySelector(`g[data-id="${id}"]`);
  if (g) g.querySelector('circle').setAttribute('fill','var(--node-processed)');
  // decrement neighbors
  const adj = adjacencyList();
  for (let nb of adj[id]){
    const old = state.inDeg.get(nb);
    state.inDeg.set(nb, old-1);
    log(`  decrease in-degree of ${labelFor(nb)}: ${old} → ${old-1}`);
    if (old-1===0){
      state.queue.push(nb);
      log(`  ${labelFor(nb)} enters zero-queue`);
      // color zero indegree nodes
      const g2 = svg.querySelector(`g[data-id="${nb}"]`);
      if (g2) g2.querySelector('circle').setAttribute('fill','var(--node-zero)');
    }
  }
  updateKahnDisplay();
});

resetKahn.addEventListener('click', ()=>{
  resetKahnState();
  // reset node colors
  nodes.forEach(n=>{
    const g = svg.querySelector(`g[data-id="${n.id}"]`);
    if (g) g.querySelector('circle').setAttribute('fill','var(--node)');
  });
  log('Kahn state reset.');
});

function updateKahnDisplay(){
  if (!kahnState){
    degreesEl.textContent = '—';
    kahnQueueEl.textContent = '[]';
    topoOrderEl.textContent = '[]';
    return;
  }
  const degs = [...kahnState.inDeg.entries()].map(([id,d])=> `${labelFor(id)}:${d}`).join(', ');
  degreesEl.textContent = degs;
  kahnQueueEl.textContent = '[' + kahnState.queue.map(id=>labelFor(id)).join(', ') + ']';
  topoOrderEl.textContent = '[' + kahnState.result.map(id=>labelFor(id)).join(', ') + ']';
}

/* DFS-based topological sort with animation.
   We'll generate an event list describing node enter/explore/exit, then animate.
*/
runDFS.addEventListener('click', ()=>{
  stopDFSAnimation();
  if (nodes.length===0){ alert('Add nodes to graph first.'); return; }
  // build adjacency
  const adj = adjacencyList();
  const color = {}; // 0 white, 1 gray, 2 black
  nodes.forEach(n=>color[n.id]=0);
  dfsEvents = []; // {type:'enter'|'exit'|'backedge', id, to?}
  let cycle = false;

  function dfs(u){
    color[u]=1;
    dfsEvents.push({type:'enter', id:u});
    for (let v of adj[u]){
      if (color[v]===0){
        dfsEvents.push({type:'tree','from':u,'to':v});
        dfsEvents.push({type:'descend', id:v});
        dfsEvents.push({type:'message', text:`Explore ${labelFor(u)} → ${labelFor(v)}`} );
        dfsEvents.push({type:'call', id:v});
        dfsEvents.push({type:'noop'}); // spacer
        dfs(u);
      } else if (color[v]===1){
        // back edge -> cycle
        cycle = true;
        dfsEvents.push({type:'backedge','from':u,'to':v});
      } else {
        dfsEvents.push({type:'cross','from':u,'to':v});
      }
    }
    color[u]=2;
    dfsEvents.push({type:'exit', id:u});
  }

  // run DFS and create events
  for (let n of nodes){
    if (color[n.id]===0) {
      dfsEvents.push({type:'start', id:n.id});
      dfs(n.id);
    }
  }

  // Now animate events (one every 450ms)
  let idx = 0;
  log('DFS events queued: ' + dfsEvents.length);
  dfsTimer = setInterval(()=>{
    if (idx>=dfsEvents.length){
      stopDFSAnimation();
      // after finishing, compute final order via reverse of exit times: run actual DFS topo to get order
      const order = computeDFSTopoOrder();
      if (order==null){
        log('DFS detected a cycle — no topological order.');
      } else {
        log('DFS finished. Topological order (by finish times): ' + order.map(id=>labelFor(id)).join(', '));
        topoOrderEl.textContent = order.map(id=>labelFor(id)).join(', ');
        highlightOrder(order);
      }
      return;
    }
    const ev = dfsEvents[idx++];
    handleDFSEvent(ev);
  }, 450);
});

stopDFS.addEventListener('click', ()=> stopDFSAnimation());

function stopDFSAnimation(){
  if (dfsTimer) clearInterval(dfsTimer);
  dfsTimer = null;
  // reset all node colors
  nodes.forEach(n=>{
    const g = svg.querySelector(`g[data-id="${n.id}"]`);
    if (g) g.querySelector('circle').setAttribute('fill','var(--node)');
  });
  log('DFS animation stopped/reset.');
}

// handle single dfs event for visualization
function handleDFSEvent(ev){
  switch(ev.type){
    case 'enter':
      {
        const g = svg.querySelector(`g[data-id="${ev.id}"]`);
        if (g) g.querySelector('circle').setAttribute('fill','var(--selected)');
        log(`DFS: enter ${labelFor(ev.id)}`);
      }
      break;
    case 'exit':
      {
        const g = svg.querySelector(`g[data-id="${ev.id}"]`);
        if (g) g.querySelector('circle').setAttribute('fill','var(--node-processed)');
        log(`DFS: exit ${labelFor(ev.id)}`);
      }
      break;
    case 'backedge':
      {
        const path = svg.querySelector(`path[data-from="${ev.from}"][data-to="${ev.to}"]`);
        if (path) { path.setAttribute('stroke','var(--danger)'); path.setAttribute('marker-end','url(#arrow-red)'); }
        const g = svg.querySelector(`g[data-id="${ev.to}"]`);
        if (g) g.querySelector('circle').setAttribute('fill','var(--danger)');
        log(`DFS: back edge detected (cycle): ${labelFor(ev.from)} → ${labelFor(ev.to)}`);
      }
      break;
    case 'tree':
      log(`DFS: tree edge ${labelFor(ev.from)} → ${labelFor(ev.to)}`);
      break;
    case 'cross':
      log(`DFS: cross edge ${labelFor(ev.from)} → ${labelFor(ev.to)}`);
      break;
    case 'message':
      log(ev.text);
      break;
    default:
      // ignore noop/start/descend/call etc.
      break;
  }
}

// compute topological order via DFS (postorder) — returns array or null if cycle
function computeDFSTopoOrder(){
  const adj = adjacencyList();
  const color = {}; nodes.forEach(n=>color[n.id]=0);
  const order = [];
  let cycle = false;
  function dfs(u){
    color[u]=1;
    for (let v of adj[u]){
      if (color[v]===0) dfs(v);
      else if (color[v]===1) cycle = true;
    }
    color[u]=2;
    order.push(u);
  }
  for (let n of nodes){
    if (color[n.id]===0) dfs(n.id);
  }
  if (cycle) return null;
  return order.reverse();
}

// highlight final order visually (small delay between highlights)
function highlightOrder(order){
  // reset first
  nodes.forEach(n=>{
    const g = svg.querySelector(`g[data-id="${n.id}"]`);
    if (g) g.querySelector('circle').setAttribute('fill','var(--node)');
  });
  let i=0;
  const timer = setInterval(()=>{
    if (i>=order.length){ clearInterval(timer); return; }
    const id = order[i++];
    const g = svg.querySelector(`g[data-id="${id}"]`);
    if (g) g.querySelector('circle').setAttribute('fill','var(--node-processed)');
  }, 220);
}

// initialization
drawGraph();
log('Interactive Topological Sort demo ready. Helpful tips: generate a DAG first or add nodes then create edges.');

/* Extra: allow keyboard shortcuts */
window.addEventListener('keydown',(ev)=>{
  if (ev.key === 'e'){ mode='addEdge'; btnEdgeMode.style.background='rgba(167,139,250,0.15)'; btnDeleteMode.style.background=''; log('Edge mode (shortcut e)'); }
  if (ev.key === 'd'){ mode='delete'; btnDeleteMode.style.background='rgba(251,113,133,0.08)'; btnEdgeMode.style.background=''; log('Delete mode (shortcut d)'); }
  if (ev.key === 'n'){ mode='none'; btnEdgeMode.style.background=''; btnDeleteMode.style.background=''; log('Add-node mode (shortcut n)'); }
});

</script>
</body>
</html>