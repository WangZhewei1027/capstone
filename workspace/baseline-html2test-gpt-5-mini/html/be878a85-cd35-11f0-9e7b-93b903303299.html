<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bubble Sort Visualization</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#2dd4bf;
    --muted:#94a3b8;
    --bar:#60a5fa;
    --compare:#f59e0b;
    --swap:#ef4444;
    --sorted:#34d399;
    --glass: rgba(255,255,255,0.03);
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071028);color:#e6eef8}
  .app{
    max-width:1100px;margin:28px auto;padding:20px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);
    box-shadow: 0 6px 30px rgba(2,6,23,0.6);
  }
  header{display:flex;align-items:center;justify-content:space-between;gap:20px;margin-bottom:12px}
  h1{font-size:20px;margin:0}
  .top-info{color:var(--muted);font-size:13px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button,select,input[type=range]{
    background:var(--glass);border:1px solid rgba(255,255,255,0.04);color:inherit;padding:8px 12px;border-radius:8px;
    cursor:pointer;font-size:14px
  }
  button:active{transform:translateY(1px)}
  .btn-primary{background: linear-gradient(90deg,var(--accent),#60a5fa); color:#042024;border:none}
  .btn-danger{background:linear-gradient(90deg,#fb7185,#ef4444);border:none}
  .layout{display:grid;grid-template-columns:1fr 320px;gap:16px;margin-top:12px}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .visual{height:360px;display:flex;align-items:flex-end;gap:6px;padding:12px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);overflow:hidden}
  .bar{
    flex:1 1 auto;min-width:6px;display:flex;align-items:flex-end;justify-content:center;
    background:linear-gradient(180deg,var(--bar),#1e3a8a);border-radius:6px;transition:height 300ms ease, transform 300ms ease, background 200ms ease;
    position:relative;color:#021024;font-weight:700;font-size:11px;
  }
  .bar span{position:absolute;bottom:4px;color:rgba(255,255,255,0.95);font-size:11px}
  .bar.compare{background:linear-gradient(180deg,var(--compare),#b45309);transform:translateY(-6px);z-index:3}
  .bar.swap{background:linear-gradient(180deg,var(--swap),#b91c1c);transform:translateY(-10px);z-index:4}
  .bar.sorted{background:linear-gradient(180deg,var(--sorted),#059669);transform:none;box-shadow:0 6px 18px rgba(3,105,161,0.12)}
  .stats{display:flex;gap:12px;flex-wrap:wrap;margin-top:10px;color:var(--muted);font-size:13px}
  .stat{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
  .sidebar-title{font-weight:600;margin-bottom:8px}
  .pseudocode{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;font-size:13px;line-height:1.45}
  .pseudocode div{padding:6px;border-radius:6px}
  .pc-active{background:linear-gradient(90deg, rgba(255,255,255,0.03), transparent);border:1px solid rgba(255,255,255,0.02)}
  .small{font-size:13px;color:var(--muted)}
  .controls-row{display:flex;gap:8px;align-items:center;margin-top:10px}
  .footer-note{margin-top:12px;color:var(--muted);font-size:13px}
  label{font-size:13px;color:var(--muted)}
  input[type=range]{-webkit-appearance:none;height:8px;border-radius:6px;background:linear-gradient(90deg,var(--accent),#60a5fa);outline:none}
  .code-block{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;background:#021024;padding:10px;border-radius:8px;font-size:12px;color:#bfe9e7;white-space:pre-wrap;overflow:auto;max-height:220px}
  .disabled{opacity:0.5;pointer-events:none}
  .top-left{display:flex;gap:12px;align-items:center}
  .toggle{display:flex;align-items:center;gap:6px}
  .small-muted{color:var(--muted);font-size:12px}
  @media (max-width:880px){
    .layout{grid-template-columns:1fr;max-height:none}
    .visual{height:260px}
  }
</style>
</head>
<body>
<div class="app" role="application" aria-label="Bubble Sort visualization">
  <header>
    <div class="top-left">
      <h1>Bubble Sort — Visualizer</h1>
      <div class="top-info small-muted">Compare & swap adjacent elements until array is sorted</div>
    </div>
    <div class="controls">
      <button id="randomizeBtn">Randomize</button>
      <button id="startBtn" class="btn-primary">Start</button>
      <button id="stepBtn">Step</button>
      <button id="resetBtn">Reset</button>
      <label class="toggle small-muted"><input type="checkbox" id="directionChk"> Descending</label>
    </div>
  </header>

  <div class="layout">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
        <div class="small-muted">Array visualization</div>
        <div style="display:flex;gap:8px;align-items:center">
          <label class="small-muted">Size</label>
          <input id="sizeRange" type="range" min="5" max="60" value="20">
        </div>
      </div>

      <div id="visual" class="visual" aria-live="polite" aria-atomic="true"></div>

      <div class="controls-row">
        <label class="small-muted">Speed</label>
        <input id="speedRange" type="range" min="50" max="1200" value="350">
        <div id="speedLabel" class="small-muted">350 ms</div>
      </div>

      <div class="stats" id="stats">
        <div class="stat">Comparisons: <strong id="comparisons">0</strong></div>
        <div class="stat">Swaps: <strong id="swaps">0</strong></div>
        <div class="stat">Pass: <strong id="pass">0</strong></div>
        <div class="stat">Index: <strong id="idx">—</strong></div>
        <div class="stat">Status: <strong id="status">Ready</strong></div>
      </div>

      <div class="footer-note">
        Try clicking Step to move one operation at a time. Press Start to autoplay. Use Descending for reversed order.
      </div>
    </div>

    <aside class="panel" aria-label="controls and explanation">
      <div>
        <div class="sidebar-title">Pseudocode</div>
        <div class="pseudocode" id="pseudocode">
          <div data-line="1">1. for n = length(array) downto 2</div>
          <div data-line="2">2.   for i = 0 to n - 2</div>
          <div data-line="3">3.     compare array[i] and array[i+1]</div>
          <div data-line="4">4.     if out of order then swap array[i], array[i+1]</div>
          <div data-line="5">5.   mark element at n-1 as sorted</div>
        </div>

        <div style="margin-top:12px" class="sidebar-title">Controls</div>
        <div class="small-muted">Change array size or randomize. Use step to see each compare/swap.</div>

        <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
          <button id="codeBtn">Show Code</button>
          <button id="explainBtn">Explain</button>
        </div>

        <div id="infoPanel" style="margin-top:12px"></div>

        <div style="margin-top:12px">
          <div class="sidebar-title">Bubble Sort Complexity</div>
          <div class="small-muted">Time: O(n^2) worst/average, O(n) best (optimized). Space: O(1).</div>
        </div>

        <div style="margin-top:12px">
          <div class="sidebar-title">Code (JavaScript)</div>
          <div id="codeBlock" class="code-block" style="display:none">
const bubbleSortGenerator = function*(arr, ascending=true) {
  // Outer loop: reduce unsorted portion
  for (let n = arr.length; n > 1; n--) {
    // Inner loop: sweep adjacent pairs
    for (let i = 0; i < n - 1; i++) {
      yield {type:'compare', i, j: i+1};
      if ((ascending && arr[i] > arr[i+1]) ||
          (!ascending && arr[i] < arr[i+1])) {
        yield {type:'swap', i, j: i+1};
        // swap values in the backing array
        const tmp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = tmp;
      }
    }
    yield {type:'sorted', index: n-1};
  }
  yield {type:'sorted', index: 0};
};
          </div>
        </div>
      </div>
    </aside>

  </div>
</div>

<script>
/*
  Bubble Sort Visualizer
  - Single-file demo with interactive controls
  - Implements bubble sort as a generator yielding actions:
      {type:'compare', i, j}
      {type:'swap', i, j}
      {type:'sorted', index}
  - Controls:
      Randomize, Start/Pause, Step, Reset, Size, Speed, Direction
*/

(() => {
  // Elements
  const visual = document.getElementById('visual');
  const randomizeBtn = document.getElementById('randomizeBtn');
  const startBtn = document.getElementById('startBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');
  const directionChk = document.getElementById('directionChk');
  const sizeRange = document.getElementById('sizeRange');
  const speedRange = document.getElementById('speedRange');
  const speedLabel = document.getElementById('speedLabel');
  const comparisonsEl = document.getElementById('comparisons');
  const swapsEl = document.getElementById('swaps');
  const passEl = document.getElementById('pass');
  const idxEl = document.getElementById('idx');
  const statusEl = document.getElementById('status');
  const pseudocode = document.getElementById('pseudocode');
  const codeBtn = document.getElementById('codeBtn');
  const codeBlock = document.getElementById('codeBlock');
  const explainBtn = document.getElementById('explainBtn');
  const infoPanel = document.getElementById('infoPanel');

  // State
  let arr = [];
  let bars = [];
  let gen = null;
  let autoId = null;
  let comparisons = 0;
  let swaps = 0;
  let currentPass = 0;
  let currentIndex = null;
  let ascending = true;
  let size = parseInt(sizeRange.value,10);
  let speed = parseInt(speedRange.value,10);

  // Initialize
  speedLabel.textContent = speed + ' ms';

  function randomArray(n) {
    const a = [];
    for (let i = 0; i < n; i++) {
      // generate varied values to make visualization interesting
      a.push(Math.floor(Math.random()*100) + 2);
    }
    return a;
  }

  function createBars() {
    visual.innerHTML = '';
    bars = [];
    const max = Math.max(...arr);
    for (let i = 0; i < arr.length; i++) {
      const bar = document.createElement('div');
      bar.className = 'bar';
      // height proportional to value
      const h = (arr[i] / max) * 100;
      bar.style.height = h + '%';
      const lbl = document.createElement('span');
      lbl.textContent = arr[i];
      bar.appendChild(lbl);
      visual.appendChild(bar);
      bars.push(bar);
    }
  }

  // Update counters and status UI
  function updateStats() {
    comparisonsEl.textContent = comparisons;
    swapsEl.textContent = swaps;
    passEl.textContent = currentPass;
    idxEl.textContent = (currentIndex === null) ? '—' : currentIndex;
  }

  // Highlight pseudocode line
  function highlightLine(num) {
    Array.from(pseudocode.children).forEach(div => {
      div.classList.toggle('pc-active', parseInt(div.dataset.line,10) === num);
    });
  }

  // Generator implementing bubble sort steps (operates on a copy of arr passed in)
  function* bubbleSortGenerator(arrCopy, ascendingFlag) {
    // n is length of unsorted portion
    for (let n = arrCopy.length; n > 1; n--) {
      // update pass information (for UI)
      yield {type:'passStart', pass: arrCopy.length - n + 1, n};
      for (let i = 0; i < n - 1; i++) {
        // Compare
        yield {type:'compare', i, j: i+1};
        if ((ascendingFlag && arrCopy[i] > arrCopy[i+1]) ||
            (!ascendingFlag && arrCopy[i] < arrCopy[i+1])) {
          // Swap
          yield {type:'swap', i, j: i+1};
          const tmp = arrCopy[i]; arrCopy[i] = arrCopy[i+1]; arrCopy[i+1] = tmp;
        }
      }
      // Mark last element of this pass as sorted
      yield {type:'sorted', index: n-1};
    }
    // All sorted: mark index 0 as sorted
    yield {type:'sorted', index: 0};
    yield {type:'done'};
  }

  // Apply a single step from generator
  async function step() {
    if (!gen) return;
    const {value, done} = gen.next();
    if (done) {
      statusEl.textContent = 'Finished';
      stopAuto();
      return;
    }
    const action = value;
    if (!action) return;

    switch(action.type) {
      case 'passStart':
        currentPass = action.pass;
        currentIndex = '—';
        highlightLine(1);
        statusEl.textContent = 'Running';
        updateStats();
        break;
      case 'compare':
        comparisons++;
        currentIndex = action.i;
        updateStats();
        // highlight bars
        clearBarClasses();
        bars[action.i].classList.add('compare');
        bars[action.j].classList.add('compare');
        highlightLine(3);
        break;
      case 'swap':
        swaps++;
        updateStats();
        // animate swap: swap heights and labels
        bars[action.i].classList.remove('compare');
        bars[action.j].classList.remove('compare');
        bars[action.i].classList.add('swap');
        bars[action.j].classList.add('swap');
        highlightLine(4);
        await animateSwap(action.i, action.j);
        break;
      case 'sorted':
        // mark bar as sorted (green)
        const idx = action.index;
        bars[idx].classList.remove('compare','swap');
        bars[idx].classList.add('sorted');
        highlightLine(5);
        break;
      case 'done':
        statusEl.textContent = 'Sorted';
        clearBarClasses();
        bars.forEach(b => b.classList.add('sorted'));
        highlightLine(null);
        stopAuto();
        break;
      default:
        break;
    }
  }

  // Swap visual bars by swapping heights/value labels
  function animateSwap(i,j) {
    return new Promise(resolve => {
      // swap heights and labels in DOM
      const bA = bars[i];
      const bB = bars[j];

      // swap values in the backing arr immediately so future steps reflect
      const tmpVal = arr[i]; arr[i] = arr[j]; arr[j] = tmpVal;

      // swap label text
      const labelA = bA.querySelector('span').textContent;
      const labelB = bB.querySelector('span').textContent;
      bA.querySelector('span').textContent = labelB;
      bB.querySelector('span').textContent = labelA;

      // swap heights via computed style
      const hA = bA.style.height;
      const hB = bB.style.height;
      // apply for smooth animation
      bA.style.height = hB;
      bB.style.height = hA;

      // Wait for transition end roughly equal to speed (some margin)
      const t = Math.max(120, Math.min(1000, speed));
      setTimeout(() => {
        // remove swap classes after animation
        bA.classList.remove('swap');
        bB.classList.remove('swap');
        resolve();
      }, t + 30);
    });
  }

  function clearBarClasses() {
    bars.forEach(b => b.classList.remove('compare','swap'));
  }

  function startAuto() {
    if (autoId) return;
    // disable manual randomize and size while running
    randomizeBtn.disabled = true;
    sizeRange.disabled = true;
    stepBtn.disabled = true;
    startBtn.textContent = 'Pause';
    autoId = setInterval(() => {
      // call step; if generator finished, clear interval
      const res = gen.next();
      if (res.done) {
        stopAuto();
        statusEl.textContent = 'Sorted';
        highlightLine(null);
        return;
      }
      const action = res.value;
      handleAutoAction(action);
    }, speed);
    statusEl.textContent = 'Running';
  }

  function handleAutoAction(action) {
    if (!action) return;
    switch(action.type) {
      case 'passStart':
        currentPass = action.pass;
        currentIndex = '—';
        highlightLine(1);
        updateStats();
        break;
      case 'compare':
        comparisons++;
        currentIndex = action.i;
        updateStats();
        clearBarClasses();
        bars[action.i].classList.add('compare');
        bars[action.j].classList.add('compare');
        highlightLine(3);
        break;
      case 'swap':
        swaps++;
        updateStats();
        // perform immediate swap animation but don't await (we still use interval pacing)
        bars[action.i].classList.remove('compare');
        bars[action.j].classList.remove('compare');
        bars[action.i].classList.add('swap');
        bars[action.j].classList.add('swap');
        highlightLine(4);
        // animate swap and then clean up after animation duration
        animateSwap(action.i, action.j);
        break;
      case 'sorted':
        bars[action.index].classList.remove('compare','swap');
        bars[action.index].classList.add('sorted');
        highlightLine(5);
        break;
      case 'done':
        clearInterval(autoId);
        autoId = null;
        statusEl.textContent = 'Sorted';
        clearBarClasses();
        bars.forEach(b => b.classList.add('sorted'));
        highlightLine(null);
        randomizeBtn.disabled = false;
        sizeRange.disabled = false;
        stepBtn.disabled = false;
        startBtn.textContent = 'Start';
        break;
    }
  }

  function stopAuto() {
    if (autoId) {
      clearInterval(autoId);
      autoId = null;
    }
    randomizeBtn.disabled = false;
    sizeRange.disabled = false;
    stepBtn.disabled = false;
    startBtn.textContent = 'Start';
  }

  // Prepare a new run: create generator over a copy of arr
  function prepareRun() {
    // reset counters
    comparisons = 0;
    swaps = 0;
    currentPass = 0;
    currentIndex = null;
    ascending = !directionChk.checked; // checkbox says "Descending", so ascending = !checked
    updateStats();
    statusEl.textContent = 'Ready';
    // create copy for generator to operate on (it will mutate its copy)
    gen = bubbleSortGenerator(arr.slice(), ascending);
    clearBarClasses();
    // remove any 'sorted' marking
    bars.forEach(b => b.classList.remove('sorted'));
    highlightLine(null);
  }

  // Reset visual to initial random array state
  function reset() {
    stopAuto();
    arr = randomArray(size);
    createBars();
    prepareRun();
    statusEl.textContent = 'Ready';
  }

  // Event wiring
  randomizeBtn.addEventListener('click', () => {
    reset();
  });

  startBtn.addEventListener('click', () => {
    if (!gen) prepareRun();
    if (autoId) {
      // currently running -> pause
      stopAuto();
      statusEl.textContent = 'Paused';
      startBtn.textContent = 'Start';
    } else {
      // start autoplay
      startAuto();
    }
  });

  stepBtn.addEventListener('click', async () => {
    if (autoId) return; // ignore steps while auto-running
    if (!gen) prepareRun();
    statusEl.textContent = 'Running';
    await step();
  });

  resetBtn.addEventListener('click', () => {
    stopAuto();
    arr = arr.map(v => v); // keep same array but reset run
    createBars();
    prepareRun();
    statusEl.textContent = 'Ready';
  });

  directionChk.addEventListener('change', () => {
    // If user toggles direction mid-run, reset the run to reflect new direction
    stopAuto();
    prepareRun();
    statusEl.textContent = 'Ready';
  });

  sizeRange.addEventListener('input', () => {
    size = parseInt(sizeRange.value,10);
    // regenerate immediately to show different size
    reset();
  });

  speedRange.addEventListener('input', () => {
    speed = parseInt(speedRange.value,10);
    speedLabel.textContent = speed + ' ms';
    // update transitions on bars to match speed
    bars.forEach(b => {
      const ms = Math.max(80, speed);
      b.style.transitionDuration = (ms*0.9) + 'ms';
    });
    // if running auto, restart interval so pacing changes immediately
    if (autoId) {
      stopAuto();
      startAuto();
    }
  });

  codeBtn.addEventListener('click', () => {
    codeBlock.style.display = codeBlock.style.display === 'none' ? 'block' : 'none';
  });

  explainBtn.addEventListener('click', () => {
    infoPanel.innerHTML = '<div class="small-muted" style="margin-top:8px">Bubble sort repeatedly steps through the list, compares adjacent items and swaps them if they are in the wrong order. Each pass places the next largest (or smallest) element at its final position. This implementation shows every compare and swap so you can step through the algorithm.</div>';
    setTimeout(()=> infoPanel.innerHTML = '', 6000);
  });

  // Setup initial array & UI
  function init() {
    arr = randomArray(size);
    createBars();
    prepareRun();
    updateStats();
    // set bar transition duration based on speed
    bars.forEach(b => b.style.transitionDuration = (speed*0.9) + 'ms');
  }

  // Basic accessibility: allow space to step or start/pause
  document.addEventListener('keydown', e => {
    if (e.code === 'Space') {
      e.preventDefault();
      if (autoId) {
        startBtn.click();
      } else {
        stepBtn.click();
      }
    }
  });

  // Implement bubbleSortGenerator local to closure
  function* bubbleSortGenerator(arrCopy, ascendingFlag) {
    for (let n = arrCopy.length; n > 1; n--) {
      // pass begins
      yield {type:'passStart', pass: arrCopy.length - n + 1, n};
      for (let i = 0; i < n - 1; i++) {
        yield {type:'compare', i, j: i+1};
        if ((ascendingFlag && arrCopy[i] > arrCopy[i+1]) ||
            (!ascendingFlag && arrCopy[i] < arrCopy[i+1])) {
          yield {type:'swap', i, j: i+1};
          const tmp = arrCopy[i]; arrCopy[i] = arrCopy[i+1]; arrCopy[i+1] = tmp;
        }
      }
      yield {type:'sorted', index: n-1};
    }
    yield {type:'sorted', index: 0};
    yield {type:'done'};
  }

  // Kick off
  init();
})();
</script>
</body>
</html>