<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Depth-First Search (DFS) Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#60a5fa;
      --muted:#94a3b8;
      --white:#e6eef8;
      --good:#34d399;
      --warn:#f59e0b;
      --bad:#f87171;
      --glass: rgba(255,255,255,0.04);
      --node-size:40;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071026 0%, #071621 60%);font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial}
    .app{display:flex;gap:12px;padding:14px;height:100%;box-sizing:border-box;color:var(--white)}
    .left{flex:1;display:flex;flex-direction:column;gap:12px}
    .canvas-wrap{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:8px;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}
    svg{width:100%;height:100%;touch-action:none;user-select:none}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button,select,label,input[type="checkbox"]{background:var(--panel);color:var(--white);border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;cursor:pointer}
    button.active{outline:2px solid rgba(96,165,250,0.16);box-shadow:0 4px 20px rgba(2,6,23,0.6)}
    .side{width:360px;display:flex;flex-direction:column;gap:12px}
    .panel{background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);min-height:40px}
    h3{margin:0 0 8px 0;color:var(--muted);font-weight:600;font-size:13px}
    .muted{color:var(--muted);font-size:13px}
    .status-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .node{fill:var(--glass);stroke:rgba(255,255,255,0.06);pointer-events:all}
    .node-label{fill:var(--white);font-weight:600;font-size:13px;text-anchor:middle;dominant-baseline:central;pointer-events:none}
    .edge{stroke:rgba(255,255,255,0.06);stroke-width:2}
    .edge.arrow{marker-end:url(#arrow)}
    .state-white{fill:#0b1220}
    .state-gray{fill:var(--warn)}
    .state-black{fill:var(--good)}
    .state-current{stroke:rgba(96,165,250,0.95);stroke-width:3}
    .small{font-size:12px;color:var(--muted)}
    .legend{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .chip{padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-size:13px}
    .list{max-height:220px;overflow:auto;padding:6px;border-radius:6px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .stack-view, .adj-view{font-family:monospace;background:rgba(0,0,0,0.15);padding:8px;border-radius:6px;color:var(--white)}
    .code{background:#071226;padding:8px;border-radius:6px;color:#cde8ff;font-family:monospace;font-size:13px;white-space:pre;overflow:auto}
    .footer{font-size:12px;color:var(--muted)}
    input[type=range]{accent-color:var(--accent);width:140px}
    .hint{font-size:13px;color:var(--muted)}
    .btn-small{padding:6px 8px;font-size:13px}
    .flex-col{display:flex;flex-direction:column;gap:6px}
    .row{display:flex;gap:6px;align-items:center}
    .muted-pill{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:999px;color:var(--muted);border:1px solid rgba(255,255,255,0.02)}
    .danger{background:linear-gradient(90deg,#3b0f0f,#220909);border-color:rgba(255,255,255,0.02)}
    .ok{background:linear-gradient(90deg,#083b22,#052516);border-color:rgba(255,255,255,0.02)}
    .edge-label{fill:var(--muted);font-size:11px;pointer-events:none}
    .small-muted{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div class="toolbar panel">
        <div class="controls">
          <button id="mode-add" class="btn-small active">Add Node</button>
          <button id="mode-edge" class="btn-small">Add Edge</button>
          <button id="mode-move" class="btn-small">Move</button>
          <button id="mode-delete" class="btn-small">Delete</button>
          <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="directed"> Directed</label>
          <button id="random" class="btn-small">Random Graph</button>
          <button id="sample" class="btn-small">Sample Graph</button>
          <button id="clear" class="btn-small danger">Clear</button>
        </div>
      </div>

      <div class="canvas-wrap panel" id="canvasWrap">
        <svg id="svg"></svg>
        <div style="position:absolute;right:12px;top:12px;background:rgba(2,6,23,0.5);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)">
          <div class="muted small">Mode: <span id="modeLabel">Add Node</span></div>
          <div class="muted small">Nodes: <span id="nodeCount">0</span> &nbsp; Edges: <span id="edgeCount">0</span></div>
        </div>
      </div>

      <div class="toolbar panel">
        <div class="controls">
          <label class="small-muted">Start:</label>
          <select id="startSelect"></select>
          <label class="small-muted">Method:</label>
          <select id="method">
            <option value="recursive">Recursive DFS</option>
            <option value="iterative">Iterative (stack)</option>
          </select>
          <button id="run" class="ok">Run</button>
          <button id="step" class="btn-small">Step</button>
          <button id="playpause" class="btn-small">Play</button>
          <label class="small-muted">Speed:</label>
          <input id="speed" type="range" min="100" max="1500" value="600">
          <div style="margin-left:auto" class="hint">Click nodes to add. In "Add Edge" mode click source then target.</div>
        </div>
      </div>

      <div class="panel" style="display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap">
        <div style="flex:1">
          <h3>Traversal State</h3>
          <div class="status-row">
            <div class="chip">Visited Order: <span id="visitedOrder">[]</span></div>
            <div class="chip">Time: <span id="time">0</span></div>
            <div class="chip">Running: <span id="running">No</span></div>
          </div>
          <div style="margin-top:8px" class="small-muted">Legend:</div>
          <div class="legend" style="margin-top:6px">
            <div class="chip"><span style="display:inline-block;width:12px;height:12px;background:#0b1220;margin-right:6px;border-radius:3px;vertical-align:middle"></span> Unvisited</div>
            <div class="chip"><span style="display:inline-block;width:12px;height:12px;background:var(--warn);margin-right:6px;border-radius:3px;vertical-align:middle"></span> Discovered / In Stack</div>
            <div class="chip"><span style="display:inline-block;width:12px;height:12px;background:var(--good);margin-right:6px;border-radius:3px;vertical-align:middle"></span> Finished</div>
            <div class="chip"><span style="display:inline-block;width:12px;height:12px;border:2px solid rgba(96,165,250,0.95);margin-right:6px;border-radius:3px;vertical-align:middle"></span> Current</div>
          </div>
        </div>

        <div style="width:320px">
          <h3>Stack / Call Stack</h3>
          <div id="stackView" class="stack-view" style="min-height:60px">[]</div>
          <div style="margin-top:8px" class="small-muted">Adjacency</div>
          <div id="adjView" class="adj-view list" style="max-height:120px"></div>
        </div>
      </div>

    </div>

    <div class="side">
      <div class="panel">
        <h3>What this demo shows</h3>
        <div class="muted small">Step through DFS (recursive vs iterative). Create your own graph by adding nodes and edges, or use a random/sample graph. Start node selection controls where traversal begins. Colors indicate node state; the stack/call-stack is shown to help you understand how DFS explores.</div>
      </div>

      <div class="panel">
        <h3>Code (pseudocode)</h3>
        <div class="code">Recursive DFS:
function dfs(u):
  visited[u] = true
  for v in neighbors(u):
    if not visited[v]:
      parent[v] = u
      dfs(v)

Iterative DFS (stack):
stack.push(start)
while stack not empty:
  u = stack.pop()
  if not visited[u]:
    visited[u] = true
    for v in neighbors(u) in reverse order:
      if not visited[v]:
        parent[v] = u
        stack.push(v)
</div>
      </div>

      <div class="panel">
        <h3>Adjacency List / Info</h3>
        <div class="small-muted">Click "Run" to animate full traversal, "Step" to advance one step, "Play" to continuously step. "Recursive" shows the call stack behavior; "Iterative" uses an explicit stack. Directed edges respect direction when running DFS.</div>
      </div>

      <div class="panel footer">
        Built for learning. Drag nodes to reposition. Created as a single-page interactive demo.
      </div>
    </div>
  </div>

<script>
(() => {
  // Simple interactive SVG graph + DFS visualization
  const svg = document.getElementById('svg');
  const canvasWrap = document.getElementById('canvasWrap');
  const modeAdd = document.getElementById('mode-add');
  const modeEdge = document.getElementById('mode-edge');
  const modeMove = document.getElementById('mode-move');
  const modeDelete = document.getElementById('mode-delete');
  const modeLabel = document.getElementById('modeLabel');
  const directedCheckbox = document.getElementById('directed');
  const randomBtn = document.getElementById('random');
  const sampleBtn = document.getElementById('sample');
  const clearBtn = document.getElementById('clear');
  const nodeCountSpan = document.getElementById('nodeCount');
  const edgeCountSpan = document.getElementById('edgeCount');
  const startSelect = document.getElementById('startSelect');
  const methodSelect = document.getElementById('method');
  const runBtn = document.getElementById('run');
  const stepBtn = document.getElementById('step');
  const playBtn = document.getElementById('playpause');
  const speedRange = document.getElementById('speed');
  const visitedOrderSpan = document.getElementById('visitedOrder');
  const timeSpan = document.getElementById('time');
  const runningSpan = document.getElementById('running');
  const stackView = document.getElementById('stackView');
  const adjView = document.getElementById('adjView');

  const NS = "http://www.w3.org/2000/svg";

  let nodes = []; // {id, x, y, label}
  let edges = []; // {id, u, v}
  let nodeId = 0;
  let edgeId = 0;

  const R = 20;
  let mode = 'add'; // add, edge, move, delete
  let directed = false;

  // Rendering groups
  const defs = document.createElementNS(NS,'defs');
  svg.appendChild(defs);
  const marker = document.createElementNS(NS,'marker');
  marker.setAttribute('id','arrow');
  marker.setAttribute('viewBox','0 0 10 10');
  marker.setAttribute('refX','10');
  marker.setAttribute('refY','5');
  marker.setAttribute('markerWidth','6');
  marker.setAttribute('markerHeight','6');
  marker.setAttribute('orient','auto-start-reverse');
  const path = document.createElementNS(NS,'path');
  path.setAttribute('d','M 0 0 L 10 5 L 0 10 z');
  path.setAttribute('fill','rgba(255,255,255,0.12)');
  marker.appendChild(path);
  defs.appendChild(marker);

  const edgeLayer = document.createElementNS(NS,'g');
  const edgeLabelLayer = document.createElementNS(NS,'g');
  const nodeLayer = document.createElementNS(NS,'g');
  svg.appendChild(edgeLayer);
  svg.appendChild(edgeLabelLayer);
  svg.appendChild(nodeLayer);

  // state for interactions
  let creatingEdgeFrom = null;
  let dragNode = null;
  let dragOffset = {x:0,y:0};
  let lastClick = null;

  // DFS runtime state
  let visited = {};
  let color = {}; // white/gray/black
  let parent = {};
  let time = 0;
  let visitedOrder = [];
  let running = false;
  let paused = false;
  let playInterval = null;
  let stepQueue = []; // for step-by-step ops (functions)
  let recursionStack = []; // for display of recursive calls in recursive mode
  let currentNode = null;

  // Utilities
  function $(id){return document.getElementById(id)}
  function setMode(m){
    mode = m;
    modeAdd.classList.toggle('active', m==='add');
    modeEdge.classList.toggle('active', m==='edge');
    modeMove.classList.toggle('active', m==='move');
    modeDelete.classList.toggle('active', m==='delete');
    modeLabel.textContent = m==='add'?'Add Node': m==='edge'?'Add Edge': m==='move'?'Move':'Delete';
    creatingEdgeFrom = null;
  }

  function updateCounts(){
    nodeCountSpan.textContent = nodes.length;
    edgeCountSpan.textContent = edges.length;
    // update startSelect
    const prev = startSelect.value;
    startSelect.innerHTML = '';
    nodes.forEach(n => {
      const opt = document.createElement('option');
      opt.value = n.id;
      opt.textContent = n.label;
      startSelect.appendChild(opt);
    });
    if(nodes.length>0){
      startSelect.value = prev || nodes[0].id;
    }
  }

  function addNodeAt(x,y,label){
    const id = String(nodeId++);
    const node = {id, x, y, label: label ?? id};
    nodes.push(node);
    render();
    updateCounts();
    return node;
  }

  function addEdge(u,v){
    // avoid duplicates for undirected if both ways
    const exists = edges.some(e => e.u===u && e.v===v && e.directed===directed);
    if(exists) return;
    const id = String(edgeId++);
    edges.push({id,u,v,directed});
    render();
    updateCounts();
  }

  function removeNode(id){
    nodes = nodes.filter(n => n.id!==id);
    edges = edges.filter(e => e.u!==id && e.v!==id);
    render();
    updateCounts();
  }

  function removeEdge(id){
    edges = edges.filter(e => e.id!==id);
    render();
    updateCounts();
  }

  function clearGraph(){
    nodes = []; edges = []; nodeId = 0; edgeId = 0;
    render(); updateCounts();
  }

  // Rendering
  function render(){
    // clear
    while(edgeLayer.firstChild) edgeLayer.removeChild(edgeLayer.firstChild);
    while(edgeLabelLayer.firstChild) edgeLabelLayer.removeChild(edgeLabelLayer.firstChild);
    while(nodeLayer.firstChild) nodeLayer.removeChild(nodeLayer.firstChild);

    // draw edges
    edges.forEach(e=>{
      const n1 = nodes.find(n=>n.id===e.u);
      const n2 = nodes.find(n=>n.id===e.v);
      if(!n1 || !n2) return;
      const g = document.createElementNS(NS,'g');
      const line = document.createElementNS(NS,'line');
      const dx = n2.x - n1.x;
      const dy = n2.y - n1.y;
      const dist = Math.sqrt(dx*dx+dy*dy) || 1;
      const ax = n1.x + (R/Math.max(1,dist))*dx;
      const ay = n1.y + (R/Math.max(1,dist))*dy;
      const bx = n2.x - (R/Math.max(1,dist))*dx;
      const by = n2.y - (R/Math.max(1,dist))*dy;
      line.setAttribute('x1',ax);
      line.setAttribute('y1',ay);
      line.setAttribute('x2',bx);
      line.setAttribute('y2',by);
      line.setAttribute('class','edge ' + (e.directed ? 'arrow' : ''));
      if(e.directed) line.setAttribute('marker-end','url(#arrow)');
      g.appendChild(line);

      // optionally edge label with arrow indicator
      const midx = (ax+bx)/2;
      const midy = (ay+by)/2;
      const el = document.createElementNS(NS,'text');
      el.setAttribute('x',midx);
      el.setAttribute('y',midy - 6);
      el.setAttribute('class','edge-label');
      el.textContent = e.directed ? 'â†’' : '';
      edgeLabelLayer.appendChild(el);

      // clickable hit area for deletion
      line.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        if(mode==='delete'){
          if(confirm('Delete this edge?')) removeEdge(e.id);
        }
      });

      edgeLayer.appendChild(g);
    });

    // draw nodes
    nodes.forEach(n=>{
      const g = document.createElementNS(NS,'g');
      g.setAttribute('transform',`translate(${n.x},${n.y})`);
      g.setAttribute('data-id',n.id);
      const circle = document.createElementNS(NS,'circle');
      circle.setAttribute('r',R);
      circle.setAttribute('class','node state-white');
      circle.style.transition = 'fill 160ms, stroke 160ms';
      const label = document.createElementNS(NS,'text');
      label.setAttribute('class','node-label');
      label.textContent = n.label;
      g.appendChild(circle);
      g.appendChild(label);

      // interactions
      g.addEventListener('mousedown', (ev)=>{
        ev.stopPropagation();
        const id = n.id;
        if(mode==='add'){
          // do nothing special
        } else if(mode==='edge'){
          if(!creatingEdgeFrom){
            creatingEdgeFrom = id;
            // small flash
            circle.style.stroke = 'rgba(96,165,250,0.8)';
            circle.style.strokeWidth = '3';
            setTimeout(()=>{circle.style.stroke='';circle.style.strokeWidth='';},400);
          } else {
            if(creatingEdgeFrom !== id){
              addEdge(creatingEdgeFrom, id);
            }
            creatingEdgeFrom = null;
          }
        } else if(mode==='move'){
          dragNode = n;
          const pt = svgPoint(ev);
          dragOffset.x = n.x - pt.x;
          dragOffset.y = n.y - pt.y;
        } else if(mode==='delete'){
          if(confirm('Delete this node and its edges?')){
            removeNode(id);
          }
        } else {
          // clicking node when running can set start maybe
        }
      });

      // click to set start when not in any special mode
      g.addEventListener('click', (ev)=>{
        if(mode==='add' && !running){
          // selection becomes start
          startSelect.value = n.id;
        }
      });

      // cursor and drag events
      g.style.cursor = mode==='move'?'grab':'pointer';
      nodeLayer.appendChild(g);
    });

    // update colors based on state
    nodes.forEach(n=>{
      const g = nodeLayer.querySelector(`g[data-id="${n.id}"]`);
      if(!g) return;
      const circle = g.querySelector('circle');
      const state = color[n.id] || 'white';
      circle.classList.remove('state-white','state-gray','state-black','state-current');
      circle.classList.add(state === 'white' ? 'state-white' : state === 'gray' ? 'state-gray' : 'state-black');
      if(currentNode === n.id) circle.classList.add('state-current');
    });

    // update adjacency view
    const adjacency = {};
    nodes.forEach(n => adjacency[n.id] = []);
    edges.forEach(e => {
      adjacency[e.u].push(e.v);
      if(!e.directed) adjacency[e.v].push(e.u);
    });
    adjView.innerHTML = '';
    nodes.forEach(n=>{
      const arr = adjacency[n.id].slice().sort();
      const div = document.createElement('div');
      div.textContent = `${n.label} (${n.id}): [ ${arr.join(', ')} ]`;
      adjView.appendChild(div);
    });
  }

  // helper to get mouse coordinates in svg
  function svgPoint(ev){
    const pt = svg.createSVGPoint();
    pt.x = ev.clientX;
    pt.y = ev.clientY;
    const ctm = svg.getScreenCTM().inverse();
    const p = pt.matrixTransform(ctm);
    return {x: p.x, y: p.y};
  }

  // canvas click to add node
  svg.addEventListener('mousedown', (ev)=>{
    const pt = svgPoint(ev);
    if(mode==='add'){
      const label = String(nodes.length);
      addNodeAt(pt.x, pt.y, label);
    }
  });

  // drag handling
  window.addEventListener('mousemove', (ev)=>{
    if(dragNode){
      const p = svgPoint(ev);
      dragNode.x = p.x + dragOffset.x;
      dragNode.y = p.y + dragOffset.y;
      render();
    }
  });
  window.addEventListener('mouseup', (ev)=>{
    dragNode = null;
  });

  // Node deletion via keyboard (optional)
  window.addEventListener('keydown', (ev)=>{
    if(ev.key === 'Escape') setMode('add');
  });

  // Buttons
  modeAdd.addEventListener('click', ()=> setMode('add'));
  modeEdge.addEventListener('click', ()=> setMode('edge'));
  modeMove.addEventListener('click', ()=> setMode('move'));
  modeDelete.addEventListener('click', ()=> setMode('delete'));

  directedCheckbox.addEventListener('change', ()=>{
    directed = directedCheckbox.checked;
  });

  clearBtn.addEventListener('click', ()=>{
    if(confirm('Clear entire graph?')) clearGraph();
  });

  randomBtn.addEventListener('click', ()=>{
    // create random graph with 6-10 nodes
    clearGraph();
    const n = Math.floor(Math.random()*5)+5;
    const w = canvasWrap.clientWidth, h = canvasWrap.clientHeight;
    for(let i=0;i<n;i++){
      addNodeAt(Math.random()*(w-80)+40, Math.random()*(h-160)+40, String(i));
    }
    // random edges
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        if(Math.random() < 0.25){
          edges.push({id:String(edgeId++), u:String(i), v:String(j), directed: Math.random() < 0.3});
        }
      }
    }
    render(); updateCounts();
  });

  sampleBtn.addEventListener('click', ()=>{
    clearGraph();
    // create a classic sample graph
    const positions = [
      [120,120],[300,70],[480,120],[200,250],[360,250],[600,200]
    ];
    positions.forEach((p,i)=>addNodeAt(p[0],p[1], String(i)));
    addEdge('0','1'); addEdge('0','3'); addEdge('1','2'); addEdge('1','4'); addEdge('2','5'); addEdge('3','4'); addEdge('4','5');
    // make some directed
    edges[2].directed = true; edges[5].directed = true;
    render(); updateCounts();
  });

  // DFS implementation with animation support
  function resetTraversal(){
    visited = {};
    color = {};
    parent = {};
    time = 0;
    visitedOrder = [];
    currentNode = null;
    recursionStack = [];
    stepQueue = [];
    running = false;
    paused = false;
    updateUI();
    render();
  }

  function updateUI(){
    visitedOrderSpan.textContent = '[' + visitedOrder.map(id=>labelOf(id)).join(', ') + ']';
    timeSpan.textContent = time;
    runningSpan.textContent = running ? 'Yes' : 'No';
    // stack view
    if(methodSelect.value === 'iterative'){
      stackView.textContent = '[' + (stepQueue.map(s => labelOf(s)).join(', ')) + ']';
    } else {
      // recursionStack display
      stackView.textContent = '[' + recursionStack.map(id=>labelOf(id)).join(', ') + ']';
    }
  }

  function labelOf(id){
    const n = nodes.find(x=>x.id===id);
    return n ? n.label : id;
  }

  // Build adjacency map
  function buildAdj(){
    const adj = {};
    nodes.forEach(n => adj[n.id]=[]);
    edges.forEach(e=>{
      if(!adj[e.u]) adj[e.u]=[];
      adj[e.u].push(e.v);
      if(!e.directed){
        if(!adj[e.v]) adj[e.v]=[];
        adj[e.v].push(e.u);
      }
    });
    // sort neighbors by label for deterministic order
    for(const k in adj){
      adj[k].sort((a,b)=>{
        const na = labelOf(a), nb = labelOf(b);
        return na.localeCompare(nb, undefined, {numeric:true});
      });
    }
    return adj;
  }

  // Async helper for delays
  function wait(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }

  // Animation controller
  async function runDFS(fullRun=true){
    resetTraversal();
    running = true;
    updateUI();
    const start = startSelect.value || (nodes[0] && nodes[0].id);
    if(!start){ alert('No start node. Add nodes first.'); running=false; updateUI(); return; }
    directed = directedCheckbox.checked;
    const adj = buildAdj();

    if(methodSelect.value === 'iterative'){
      // iterative DFS with explicit stack; we'll implement stepQueue as stack content
      const stack = [start];
      stepQueue = stack.slice();
      updateUI();
      while(stack.length > 0){
        if(!running) break;
        if(paused){
          await wait(100);
          continue;
        }
        const u = stack.pop();
        // update displayed stack
        stepQueue = stack.slice();
        currentNode = u;
        if(!visited[u]){
          // discover u
          color[u] = 'gray';
          visited[u] = true;
          time += 1;
          visitedOrder.push(u);
          updateUI(); render();
          await wait(speedRange.value);
          // push neighbors in reverse order so smallest is processed first
          const neighbors = (adj[u] || []).slice().reverse();
          for(const v of neighbors){
            if(!visited[v]){
              parent[v] = u;
              stack.push(v);
              stepQueue = stack.slice();
              color[v] = color[v] || 'white';
              // visually mark as in stack (gray)
              color[v] = 'gray';
              updateUI(); render();
              await wait(Math.min(200, speedRange.value/4));
            }
          }
          // finish u
          color[u] = 'black';
          currentNode = null;
          updateUI(); render();
          await wait(Math.min(200, speedRange.value/4));
        } else {
          // already visited; continue
        }
      }
      running = false;
      paused = false;
      updateUI(); render();
    } else {
      // recursive DFS: we will implement an async recursive function to animate call/return.
      const visitedLocal = visited;
      const adjLocal = adj;
      async function dfs(u){
        if(!running) return;
        recursionStack.push(u);
        currentNode = u;
        color[u] = 'gray';
        updateUI(); render();
        await wait(speedRange.value);
        visited[u] = true;
        time += 1;
        visitedOrder.push(u);
        updateUI(); render();
        await wait(speedRange.value);
        for(const v of (adjLocal[u] || [])){
          if(!visited[v]){
            parent[v] = u;
            // visually show neighbor is discovered soon
            color[v] = 'gray';
            updateUI(); render();
            await wait(Math.min(200, speedRange.value/4));
            await dfs(v);
            if(!running) return;
            await wait(80);
          }
        }
        // finish u
        color[u] = 'black';
        recursionStack.pop();
        currentNode = recursionStack.length ? recursionStack[recursionStack.length-1] : null;
        updateUI(); render();
        await wait(Math.min(200, speedRange.value/4));
      }
      await dfs(start);
      running = false;
      paused = false;
      updateUI(); render();
    }
  }

  // Step-by-step support: execute one micro-step depending on mode
  // For simplicity we implement step behavior as "advance one atomic DFS action" using miniature state machine
  let stepState = null; // holds controller state
  function initStepState(){
    resetTraversal();
    directed = directedCheckbox.checked;
    const start = startSelect.value || (nodes[0] && nodes[0].id);
    if(!start) return false;
    const adj = buildAdj();
    stepState = {
      adj,
      method: methodSelect.value,
      stack: methodSelect.value==='iterative' ? [start] : null,
      callStack: methodSelect.value==='recursive' ? [] : null,
      iterators: {}, // for recursion: store iterator index per node
      start
    };
    updateUI();
    return true;
  }

  function stepOnce(){
    if(!stepState){
      const ok = initStepState();
      if(!ok){ alert('No start node'); return; }
      running = true;
      paused = true;
    }
    if(stepState.method==='iterative'){
      const st = stepState.stack;
      if(st.length===0){
        running = false;
        stepState = null;
        updateUI(); render();
        return;
      }
      const u = st.pop();
      currentNode = u;
      if(!visited[u]){
        color[u] = 'gray';
        visited[u] = true;
        time += 1;
        visitedOrder.push(u);
        updateUI(); render();
        // next micro-step: push neighbors
        const neighbors = (stepState.adj[u]||[]).slice().reverse();
        // push one neighbor per subsequent step for fine control
        for(const v of neighbors){
          if(!visited[v]) st.push(v);
        }
        // mark finished in another micro-step
        color[u] = 'black';
        currentNode = null;
        updateUI(); render();
      } else {
        // nothing
      }
    } else {
      // recursive step emulation: we will simulate one call-return per step.
      const cs = stepState.callStack;
      if(cs.length===0){
        // start new call
        const s = stepState.start;
        cs.push(s);
        color[s] = 'gray'; visited[s] = true; time++; visitedOrder.push(s);
        stepState.iterators[s] = 0;
        currentNode = s;
        updateUI(); render();
        return;
      }
      const top = cs[cs.length-1];
      const it = stepState.iterators[top] || 0;
      const neighbors = stepState.adj[top] || [];
      // find next unvisited neighbor
      let pushed = false;
      for(let idx = it; idx < neighbors.length; idx++){
        const v = neighbors[idx];
        stepState.iterators[top] = idx+1; // advance iterator
        if(!visited[v]){
          // call dfs(v)
          parent[v] = top;
          cs.push(v);
          visited[v] = true; color[v]='gray'; time++; visitedOrder.push(v);
          stepState.iterators[v] = 0;
          currentNode = v;
          pushed = true;
          updateUI(); render();
          break;
        }
      }
      if(!pushed){
        // all neighbors processed -> return
        color[top] = 'black';
        cs.pop();
        currentNode = cs.length? cs[cs.length-1] : null;
        updateUI(); render();
      }
      // if call stack becomes empty, finished
      if(cs.length === 0){
        running = false;
        stepState = null;
      }
    }
  }

  // Button handlers
  runBtn.addEventListener('click', async ()=>{
    if(running){
      // stop
      running = false;
      paused = false;
      updateUI();
      return;
    }
    // else run full animation
    await runDFS(true);
  });

  stepBtn.addEventListener('click', ()=>{
    if(running && !paused){
      // if currently auto-running, pause and initialize step state from current state is complex; easier to reset
      paused = true;
      running = false;
      stepState = null;
      resetTraversal();
    }
    stepOnce();
  });

  playBtn.addEventListener('click', ()=>{
    if(playInterval){
      clearInterval(playInterval);
      playInterval = null;
      playBtn.textContent = 'Play';
      paused = true;
      return;
    }
    // start playing steps
    paused = false;
    playBtn.textContent = 'Pause';
    if(!stepState){
      const ok = initStepState();
      if(!ok) return;
    }
    playInterval = setInterval(()=>{
      if(!stepState && !running){
        clearInterval(playInterval);
        playInterval = null;
        playBtn.textContent = 'Play';
        return;
      }
      if(!paused) stepOnce();
    }, Math.max(150, speedRange.value));
  });

  // expose some helpful functions for dev
  updateCounts();
  render();

  // initialize sample graph
  sampleBtn.click();

  // small UX: clicking on empty space in edge mode resets creation
  svg.addEventListener('click', ()=>{
    if(mode==='edge'){
      creatingEdgeFrom = null;
    }
  });

  // allow window resize to adjust (SVG uses viewBox auto)
  window.addEventListener('resize', ()=> render());

})();
</script>
</body>
</html>