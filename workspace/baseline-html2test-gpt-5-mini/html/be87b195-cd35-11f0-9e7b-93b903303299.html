<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Prim's Algorithm Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, Roboto, "Segoe UI", Arial; margin: 0; display: flex; height: 100vh; }
    #left { width: 72%; border-right: 1px solid #ddd; position: relative; }
    #right { width: 28%; padding: 12px; box-sizing: border-box; overflow-y: auto; }
    header { padding: 10px 12px; border-bottom: 1px solid #eee; background: #fafafa; }
    #controls { display: flex; gap: 8px; align-items: center; margin-top: 8px; flex-wrap: wrap; }
    button, input[type=range], select { padding: 6px 8px; font-size: 14px; }
    button { cursor: pointer; }
    svg { width: 100%; height: calc(100vh - 60px); display: block; background: linear-gradient(180deg,#fff,#fbfbfd); }
    .node { cursor: pointer; }
    .node circle { stroke: #333; stroke-width: 1px; fill: #fff; transition: fill .12s, stroke .12s; }
    .node text { pointer-events: none; font-weight: 600; font-size: 12px; }
    .edge-line { stroke: #bbb; stroke-width: 3px; stroke-linecap: round; }
    .edge-text { fill: #222; font-size: 12px; font-weight: 600; background: #fff; }
    .node.inmst circle { fill: #1e88e5; stroke: #0b63b7; color: white; }
    .node.inmst text { fill: #fff; }
    .node.start circle { stroke: #00bfa5; stroke-width: 2.5px; }
    .edge.candidate { stroke: #ff9800; stroke-width: 4px; }
    .edge.mst { stroke: #e53935; stroke-width: 5px; }
    .edge.inactive { stroke: #ddd; stroke-width: 3px; opacity: 0.75; }
    #info { margin-top: 12px; font-size: 14px; }
    .panel { margin-bottom: 12px; padding: 10px; border: 1px solid #eee; border-radius: 6px; background: #fff; }
    pre { margin: 0; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; font-size: 13px; }
    .pseudocode-line { padding: 2px 6px; border-radius: 4px; }
    .highlight { background: #fff5e1; }
    .small { font-size: 13px; color: #555; }
    label { font-size: 13px; margin-right: 6px; }
    #pq { max-height: 140px; overflow-y: auto; margin-top: 6px; }
    .edge-item { padding: 6px; border-bottom: 1px solid #f1f1f1; }
    .edge-weight { font-weight: 700; }
    footer { padding-top: 6px; font-size: 13px; color: #666; }
    .controls-left { display:flex; gap:6px; align-items:center; }
    .controls-right { margin-left:auto; display:flex; gap:6px; align-items:center; }
    .muted { color: #777; font-size: 13px; }
  </style>
</head>
<body>
  <div id="left">
    <header>
      <div style="display:flex;align-items:center;">
        <div style="font-weight:700;font-size:16px;">Prim's Algorithm — Minimum Spanning Tree (Interactive)</div>
        <div style="margin-left:12px;" class="muted">Click a node to pick starting vertex. Drag nodes to reposition.</div>
      </div>
      <div id="controls" style="margin-top:10px;">
        <div class="controls-left">
          <label for="nRange">Nodes</label>
          <input id="nRange" type="range" min="4" max="12" value="7">
          <span id="nVal">7</span>
          <button id="genBtn">Generate Random Graph</button>
          <button id="clearBtn">Clear</button>
        </div>
        <div class="controls-right">
          <button id="chooseStartBtn">Choose Start</button>
          <button id="startBtn">Initialize Prim</button>
          <button id="stepBtn" disabled>Step</button>
          <button id="playBtn" disabled>Play</button>
          <button id="resetBtn" disabled>Reset</button>
        </div>
      </div>
    </header>

    <svg id="svgCanvas" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid meet"></svg>
  </div>

  <div id="right">
    <div class="panel">
      <div style="display:flex;align-items:center;justify-content:space-between;">
        <div><strong>MST Status</strong></div>
        <div class="small">Steps: <span id="stepCount">0</span></div>
      </div>
      <div id="info" style="margin-top:8px;">
        <div>MST total weight: <strong id="mstWeight">0</strong></div>
        <div style="margin-top:6px;">Start vertex: <span id="startVertex">none</span></div>
        <div style="margin-top:6px;">Visited vertices: <span id="visitedList">[]</span></div>
      </div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <strong>Candidate edges (min frontier)</strong>
        <div class="small">Sorted by weight</div>
      </div>
      <div id="pq"></div>
    </div>

    <div class="panel">
      <strong>Pseudocode (Prim)</strong>
      <pre id="pseudocode">
1: for each v in V:
2:   key[v] = ∞ ; parent[v] = null
3: key[start] = 0
4: Q = V
5: while Q not empty:
6:   u = extract-min(Q)            // vertex with minimal key
7:   add u to MST
8:   for each v adjacent to u:
9:     if v in Q and weight(u,v) < key[v]:
10:      parent[v] = u; key[v] = weight(u,v)
      </pre>
    </div>

    <div class="panel">
      <strong>How to use</strong>
      <ul style="margin:8px 0 0 18px;">
        <li>Generate a random connected graph or draw your own with "Clear" then add nodes by clicking (not implemented here).</li>
        <li>Click a node to set the starting vertex (or let it default to node 0).</li>
        <li>Click "Initialize Prim" then step through with "Step" or auto-run with "Play".</li>
      </ul>
    </div>

    <footer>
      Implementation: JavaScript + SVG. Edges highlighted orange are current candidates; red edges are in the MST; blue nodes belong to MST.
    </footer>
  </div>

  <script>
    // Prim's Algorithm Interactive Demo
    (function() {
      const svg = document.getElementById('svgCanvas');
      const nRange = document.getElementById('nRange');
      const nVal = document.getElementById('nVal');
      const genBtn = document.getElementById('genBtn');
      const clearBtn = document.getElementById('clearBtn');
      const chooseStartBtn = document.getElementById('chooseStartBtn');
      const startBtn = document.getElementById('startBtn');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const resetBtn = document.getElementById('resetBtn');
      const startVertexSpan = document.getElementById('startVertex');
      const visitedListSpan = document.getElementById('visitedList');
      const pqDiv = document.getElementById('pq');
      const mstWeightSpan = document.getElementById('mstWeight');
      const stepCountSpan = document.getElementById('stepCount');
      const pseudocode = document.getElementById('pseudocode');

      let width = 1200, height = 800;

      // Graph data
      let nodes = []; // {id, x, y, svgGroup}
      let edges = []; // {id, u, v, weight, line, text, group}
      let adj = {};   // adjacency lists: id -> [{to, edgeId, weight}]

      // UI state
      let selectedStart = null;
      let choosingStart = false;
      let dragging = null;
      let dragOffset = {x:0,y:0};

      // Prim algorithm state
      let primInitialized = false;
      let inMST = []; // boolean by node id
      let key = [];
      let parent = [];
      let Qcount = 0;
      let stepCount = 0;
      let playTimer = null;
      let finished = false;

      function uid(prefix='id') {
        return prefix + Math.random().toString(36).slice(2,9);
      }

      function clearSVG() {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
      }

      function resetAll() {
        nodes = []; edges = []; adj = {};
        selectedStart = null; choosingStart=false;
        primInitialized=false; inMST=[]; key=[]; parent=[]; Qcount=0; stepCount=0; finished=false;
        updateUI();
        clearSVG();
      }

      function generateRandomGraph(n = 7, density = 0.45) {
        resetAll();
        // Create nodes with random positions but reasonable spacing
        for (let i=0;i<n;i++) {
          let angle = Math.random()*Math.PI*2;
          let r = 150 + Math.random()*200;
          let x = 200 + (i%2? Math.random()*800 : Math.random()*900);
          let y = 150 + Math.random()*470;
          addNode(x, y, i);
        }
        // Ensure connected: create a random spanning path first
        let order = [...Array(n).keys()].sort(()=>Math.random()-0.5);
        for (let i=1;i<order.length;i++) {
          let u = order[i-1], v = order[i];
          addEdge(u,v,randWeight());
        }
        // Add random edges
        for (let u=0;u<n;u++){
          for (let v=u+1;v<n;v++){
            if (Math.random() < density && !edgeExists(u,v)) {
              addEdge(u,v,randWeight());
            }
          }
        }
        redrawAll();
      }

      function randWeight() {
        return Math.floor(1 + Math.random()*20);
      }

      function edgeExists(u,v) {
        return edges.some(e => (e.u===u && e.v===v) || (e.u===v && e.v===u));
      }

      function addNode(x,y,label) {
        const id = nodes.length;
        nodes.push({id, x, y, label: (label!==undefined?label:id)});
        adj[id] = [];
        drawNode(id);
      }

      function drawNode(id) {
        const node = nodes[id];
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.classList.add('node');
        g.setAttribute('data-id', id);
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('r', 20);
        circle.setAttribute('cx', node.x);
        circle.setAttribute('cy', node.y);
        circle.setAttribute('fill', '#fff');
        circle.setAttribute('stroke', '#333');
        circle.setAttribute('stroke-width', 1);
        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.setAttribute('x', node.x);
        text.setAttribute('y', node.y + 5);
        text.setAttribute('text-anchor', 'middle');
        text.textContent = node.label;
        g.appendChild(circle);
        g.appendChild(text);
        svg.appendChild(g);
        node.svg = g;

        // Events
        g.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          const id = Number(g.getAttribute('data-id'));
          if (choosingStart) {
            setStartVertex(id);
            choosingStart = false;
            chooseStartBtn.textContent = 'Choose Start';
            return;
          }
          if (!primInitialized) {
            // allow selecting start by clicking prior to init
            setStartVertex(id);
          }
          dragging = id;
          const pt = getSvgPoint(e);
          dragOffset.x = pt.x - nodes[id].x;
          dragOffset.y = pt.y - nodes[id].y;
        });

        g.addEventListener('mouseup', (e) => { dragging = null; });
      }

      function getSvgPoint(evt) {
        const rect = svg.getBoundingClientRect();
        const cx = (evt.clientX - rect.left) * (svg.viewBox.baseVal.width / rect.width);
        const cy = (evt.clientY - rect.top) * (svg.viewBox.baseVal.height / rect.height);
        return {x: cx, y: cy};
      }

      // Add undirected edge
      function addEdge(u, v, weight) {
        if (u===v) return;
        if (edgeExists(u,v)) return;
        const id = edges.length;
        edges.push({id, u, v, weight});
        adj[u].push({to:v, edgeId:id, weight});
        adj[v].push({to:u, edgeId:id, weight});
        drawEdge(id);
      }

      function drawEdge(id) {
        const e = edges[id];
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.classList.add('edge');
        g.classList.add('edge-'+id);
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.classList.add('edge-line');
        line.setAttribute('x1', nodes[e.u].x);
        line.setAttribute('y1', nodes[e.u].y);
        line.setAttribute('x2', nodes[e.v].x);
        line.setAttribute('y2', nodes[e.v].y);
        line.setAttribute('stroke','#bbb');
        line.setAttribute('stroke-width', 3);
        line.setAttribute('data-id', id);
        const tx = (nodes[e.u].x + nodes[e.v].x)/2;
        const ty = (nodes[e.u].y + nodes[e.v].y)/2;
        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.classList.add('edge-text');
        text.setAttribute('x', tx);
        text.setAttribute('y', ty - 6);
        text.setAttribute('text-anchor', 'middle');
        text.textContent = e.weight;
        g.appendChild(line);
        g.appendChild(text);
        // send edges behind nodes
        svg.insertBefore(g, svg.firstChild);
        e.group = g;
        e.line = line;
        e.text = text;

        // Clicking an edge allows changing weight
        g.addEventListener('click', (ev) => {
          ev.stopPropagation();
          if (primInitialized) return;
          const w = prompt('Edge weight (positive integer):', String(e.weight));
          if (w !== null) {
            const wi = Math.max(1, parseInt(w) || 1);
            e.weight = wi;
            e.text.textContent = wi;
            // Update adjacency weights
            for (let a of adj[e.u]) if (a.edgeId===id) a.weight = wi;
            for (let a of adj[e.v]) if (a.edgeId===id) a.weight = wi;
            if (primInitialized) updateCandidatesDisplay();
          }
        });
      }

      function redrawAll() {
        // reposition nodes and edges visuals
        for (let e of edges) {
          e.line.setAttribute('x1', nodes[e.u].x);
          e.line.setAttribute('y1', nodes[e.u].y);
          e.line.setAttribute('x2', nodes[e.v].x);
          e.line.setAttribute('y2', nodes[e.v].y);
          const tx = (nodes[e.u].x + nodes[e.v].x)/2;
          const ty = (nodes[e.u].y + nodes[e.v].y)/2;
          e.text.setAttribute('x', tx);
          e.text.setAttribute('y', ty - 6);
        }
        for (let n of nodes) {
          const g = n.svg;
          const circle = g.querySelector('circle');
          const text = g.querySelector('text');
          circle.setAttribute('cx', n.x);
          circle.setAttribute('cy', n.y);
          text.setAttribute('x', n.x);
          text.setAttribute('y', n.y + 5);
        }
      }

      // Mouse move for dragging
      svg.addEventListener('mousemove', (e) => {
        if (dragging === null) return;
        const pt = getSvgPoint(e);
        const id = dragging;
        nodes[id].x = Math.max(40, Math.min(width-40, pt.x - dragOffset.x));
        nodes[id].y = Math.max(40, Math.min(height-40, pt.y - dragOffset.y));
        redrawAll();
      });
      window.addEventListener('mouseup', () => { dragging = null; });

      // Click on empty svg to stop choosing start
      svg.addEventListener('click', (e) => {
        if (choosingStart) {
          choosingStart = false;
          chooseStartBtn.textContent = 'Choose Start';
        }
      });

      function setStartVertex(id) {
        selectedStart = id;
        renderNodeStyles();
        startVertexSpan.textContent = id;
      }

      function renderNodeStyles() {
        for (let n of nodes) {
          const g = n.svg;
          g.classList.remove('inmst','start');
          if (primInitialized && inMST[n.id]) g.classList.add('inmst');
          if (selectedStart === n.id) g.classList.add('start');
        }
      }

      // Prim algorithm core (step-by-step)
      function initializePrim() {
        if (nodes.length === 0) return alert('Create a graph first.');
        if (selectedStart === null) setStartVertex(0);
        const n = nodes.length;
        inMST = Array(n).fill(false);
        key = Array(n).fill(Infinity);
        parent = Array(n).fill(null);
        key[selectedStart] = 0;
        Qcount = n;
        primInitialized = true;
        finished = false;
        stepCount = 0;
        stepCountSpan.textContent = String(stepCount);
        updateUI();
        updateCandidatesDisplay();
        highlightPseudocodeLine(3);
        renderNodeStyles();
        stepBtn.disabled = false;
        playBtn.disabled = false;
        resetBtn.disabled = false;
      }

      function stepPrimOnce() {
        if (!primInitialized || finished) return;
        // extract min key among vertices not in MST
        let u = -1, minK = Infinity;
        for (let i=0;i<key.length;i++){
          if (!inMST[i] && key[i] < minK) {
            minK = key[i]; u = i;
          }
        }
        if (u === -1) {
          // All remaining vertices are disconnected (shouldn't happen if connected)
          finished = true;
          finalizeMST();
          return;
        }
        // Simulate pseudocode highlighting
        highlightPseudocodeLine(6);
        // Add u to MST
        inMST[u] = true;
        Qcount--;
        stepCount++;
        stepCountSpan.textContent = String(stepCount);
        // If parent exists, mark that edge as in MST
        if (parent[u] !== null) {
          const edgeId = findEdgeBetween(u, parent[u]);
          if (edgeId !== null) {
            edges[edgeId].line.classList.add('mst');
            edges[edgeId].line.classList.remove('edge-line');
            edges[edgeId].group.classList.add('edge-mst');
            edges[edgeId].group.classList.add('edge-'+edgeId);
            edges[edgeId].line.setAttribute('stroke', '#e53935');
          }
        }
        // Update node style
        renderNodeStyles();
        // Update keys for adjacent vertices
        highlightPseudocodeLine(8);
        for (let e of adj[u]) {
          const v = e.to;
          if (!inMST[v] && e.weight < key[v]) {
            parent[v] = u;
            key[v] = e.weight;
            // Visual note: candidate edges color
          }
        }
        updateCandidatesDisplay();
        updateMSTWeight();
        // Check finish
        if (Qcount === 0) {
          finished = true;
          finalizeMST();
        } else {
          highlightPseudocodeLine(5);
        }
      }

      function findEdgeBetween(a,b) {
        for (let e of edges) {
          if ((e.u===a && e.v===b) || (e.u===b && e.v===a)) return e.id;
        }
        return null;
      }

      function updateCandidatesDisplay() {
        // Show candidate edges: edges connecting inMST nodes to outside nodes via parent pointers and keys
        // We'll show for each v not inMST but with parent assigned: (parent[v], v, key[v])
        const list = [];
        for (let v=0; v<nodes.length; v++) {
          if (!inMST[v] && parent[v] !== null) {
            list.push({u: parent[v], v, weight: key[v]});
          }
        }
        // Also consider vertices with infinite key (disconnected)
        list.sort((a,b)=>a.weight - b.weight);
        // Update PQ display
        pqDiv.innerHTML = '';
        if (list.length === 0) {
          pqDiv.innerHTML = '<div class="small muted">No candidate edges (maybe starting state or graph disconnected).</div>';
        } else {
          for (let it of list) {
            const el = document.createElement('div');
            el.className = 'edge-item';
            el.innerHTML = `<span style="color:#444">(${it.u} — ${it.v})</span> &nbsp; weight: <span class="edge-weight">${it.weight}</span>`;
            pqDiv.appendChild(el);
          }
        }
        // Visual highlighting of candidate edges in SVG:
        // Reset edge styles then color those that match parent relations orange
        for (let e of edges) {
          e.line.classList.remove('candidate','inactivate','mst');
          e.group.classList.remove('candidate');
          // Base style
          e.line.setAttribute('stroke', '#bbb');
          e.line.setAttribute('stroke-width', 3);
        }
        for (let it of list) {
          const eid = findEdgeBetween(it.u, it.v);
          if (eid !== null) {
            edges[eid].line.classList.add('candidate');
            edges[eid].line.setAttribute('stroke', '#ff9800');
            edges[eid].line.setAttribute('stroke-width', 4);
          }
        }
        // Mark MST edges red
        for (let e of edges) {
          if (inMST[e.u] && inMST[e.v]) {
            // if both endpoints in MST and parent relation is consistent, mark as mst
            // We'll trust the earlier marking when node added; ensure styling
            if (e.line.getAttribute('stroke') === '#e53935') {
              e.line.classList.add('mst');
            }
          }
        }
      }

      function updateMSTWeight() {
        let total = 0;
        for (let v=0;v<nodes.length;v++) {
          if (parent[v] !== null) total += key[v];
        }
        mstWeightSpan.textContent = String(total);
      }

      function finalizeMST() {
        updateCandidatesDisplay();
        updateMSTWeight();
        highlightPseudocodeLine(null);
        stepBtn.disabled = true;
        playBtn.disabled = true;
      }

      function updateUI() {
        nVal.textContent = nRange.value;
        startVertexSpan.textContent = (selectedStart===null?'none':selectedStart);
        visitedListSpan.textContent = '[' + inMST.map((b,i)=>b?i:null).filter(x=>x!==null).join(', ') + ']';
        stepCountSpan.textContent = String(stepCount);
        mstWeightSpan.textContent = mstWeightSpan.textContent || '0';
        renderNodeStyles();
      }

      // Pseudocode highlighting helper
      function highlightPseudocodeLine(lineNumber) {
        // lines are numbered 1..10 as in displayed code. We'll map to actual lines in <pre>.
        const lines = pseudocode.textContent.split('\n');
        const newHtml = lines.map((ln,i)=>{
          const num = i+1;
          const safe = ln.replace(/</g,'&lt;').replace(/>/g,'&gt;');
          return `<div class="pseudocode-line ${num===lineNumber? 'highlight':''}"><span style="opacity:0.6;padding-right:6px">${num}:</span>${safe}</div>`;
        }).join('');
        pseudocode.innerHTML = newHtml;
      }

      // Event wiring
      nRange.addEventListener('input', () => { nVal.textContent = nRange.value; });
      genBtn.addEventListener('click', () => {
        generateRandomGraph(Number(nRange.value), 0.45);
        updateUI();
      });

      clearBtn.addEventListener('click', () => {
        resetAll();
      });

      chooseStartBtn.addEventListener('click', () => {
        choosingStart = !choosingStart;
        chooseStartBtn.textContent = choosingStart ? 'Click a node to set start (or click again to cancel)' : 'Choose Start';
      });

      startBtn.addEventListener('click', () => {
        if (!primInitialized) {
          initializePrim();
        }
      });

      stepBtn.addEventListener('click', () => {
        stepPrimOnce();
        updateUI();
      });

      playBtn.addEventListener('click', () => {
        if (playTimer) {
          clearInterval(playTimer); playTimer = null; playBtn.textContent = 'Play';
        } else {
          if (!primInitialized) initializePrim();
          playBtn.textContent = 'Pause';
          playTimer = setInterval(() => {
            if (!finished) stepPrimOnce();
            updateUI();
            if (finished) { clearInterval(playTimer); playTimer=null; playBtn.textContent='Play'; }
          }, 700);
        }
      });

      resetBtn.addEventListener('click', () => {
        // Reset prim algorithm state but keep graph and start selection
        primInitialized = false;
        inMST = []; key = []; parent = [];
        stepCount = 0; stepCountSpan.textContent = String(stepCount);
        // remove edge styles
        for (let e of edges) {
          e.line.classList.remove('mst','candidate');
          e.line.setAttribute('stroke', '#bbb');
          e.line.setAttribute('stroke-width', 3);
        }
        for (let n of nodes) {
          n.svg.classList.remove('inmst');
        }
        stepBtn.disabled = true; playBtn.disabled = true; resetBtn.disabled = true;
        pqDiv.innerHTML = '';
        mstWeightSpan.textContent = '0';
        highlightPseudocodeLine(null);
        updateUI();
      });

      // Initialize with a random graph
      generateRandomGraph(Number(nRange.value), 0.45);

      // Small accessibility: update visited display every 500ms
      setInterval(() => {
        visitedListSpan.textContent = '[' + (inMST? inMST.map((b,i)=>b?i:null).filter(x=>x!==null).join(', '):'') + ']';
      }, 400);

      // Initial pseudocode render
      highlightPseudocodeLine(null);

      // Resize handling: keep viewBox fixed
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    })();
  </script>
</body>
</html>