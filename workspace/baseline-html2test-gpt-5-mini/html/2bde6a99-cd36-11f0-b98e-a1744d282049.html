<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sliding Window Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#22c1c3;
      --muted:#9aa7b2;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{
      background: linear-gradient(180deg,#031027 0%, #061827 100%);
      color:#e6f0f2;
      padding:20px;
      box-sizing:border-box;
    }
    .app{
      max-width:1100px;
      margin:0 auto;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:20px;
      align-items:start;
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:18px;
      box-shadow: 0 6px 18px rgba(3,6,14,0.6);
      border:1px solid rgba(255,255,255,0.03);
    }
    h1{font-size:20px;margin:0 0 8px 0;}
    p.lead{margin:0 0 12px 0;color:var(--muted);font-size:13px;}
    label{display:block;font-size:13px;margin-top:8px;color:var(--muted);}
    input[type=text], input[type=number], select {
      width:100%;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.05);
      background:var(--glass);
      color:inherit;
      box-sizing:border-box;
      margin-top:6px;
    }
    .row{display:flex;gap:8px;margin-top:10px;}
    button{
      background:linear-gradient(180deg,var(--accent), #0fb5b7);
      color:#002627;
      border:none;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:600;
      box-shadow:0 6px 16px rgba(17,108,107,0.18);
    }
    button.secondary{
      background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04);box-shadow:none;
    }
    .small{padding:8px 10px;font-size:13px;}
    .controls{display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap}
    .visual{
      min-height:420px;
      display:flex;
      flex-direction:column;
      gap:14px;
      align-items:center;
      justify-content:flex-start;
    }
    .array{
      display:flex;
      gap:8px;
      padding:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent);
      border-radius:12px;
      width:100%;
      overflow:auto;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    }
    .cell{
      min-width:48px;
      height:48px;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:8px;
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      color:var(--muted);
      font-weight:700;
      font-size:15px;
      position:relative;
      box-sizing:border-box;
    }
    .cell.index{font-size:11px;color:var(--muted);position:absolute;left:6px;top:6px;font-weight:600}
    .cell.highlight{
      background:linear-gradient(180deg, rgba(34,193,195,0.12), rgba(34,193,195,0.06));
      border:1px solid rgba(34,193,195,0.18);
      color: #e6fbfb;
      box-shadow: 0 6px 14px rgba(34,193,195,0.06);
    }
    .cell.remove{
      background:linear-gradient(180deg, rgba(255,85,85,0.08), rgba(255,85,85,0.04));
      border:1px solid rgba(255,85,85,0.12);
      color:#ffdfe0;
    }
    .info{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:center;
      background:rgba(255,255,255,0.02);
      padding:10px;border-radius:10px;width:100%;
      box-sizing:border-box;
    }
    .info .box{min-width:120px;text-align:center;}
    .info .label{font-size:12px;color:var(--muted)}
    .info .value{font-weight:800;font-size:18px;margin-top:4px}
    .log{
      margin-top:10px;
      height:120px;
      overflow:auto;
      background:rgba(255,255,255,0.01);
      border-radius:8px;padding:10px;border:1px solid rgba(255,255,255,0.02);
      font-family:monospace;font-size:13px;color:var(--muted);
    }
    .footer{
      margin-top:12px;color:var(--muted);font-size:13px;
    }
    .example-arrays{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;}
    .chip{
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      padding:6px 8px;border-radius:8px;font-size:13px;color:var(--muted);cursor:pointer;
    }
    .status{
      margin-top:8px;font-size:13px;color:var(--muted);
    }
    @media (max-width:980px){
      .app{grid-template-columns:1fr; padding-bottom:80px;}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="card" id="panel">
      <h1>Sliding Window Visualizer</h1>
      <p class="lead">Explore fixed-size and variable-size sliding window examples. Input an array, choose a mode and window/target, then step through the algorithm or play an animation to see how the window moves and values update.</p>

      <label>Array (comma separated numbers)</label>
      <input id="arrayInput" type="text" value="2,1,5,2,8,3,1,4" />

      <div class="example-arrays">
        <div class="chip" onclick="loadExample('2,1,5,2,8,3,1,4')">2,1,5,2,8,3,1,4</div>
        <div class="chip" onclick="loadExample('4,2,1,7,8,1,2,8,1,0')">4,2,1,7,8,1,2,8,1,0</div>
        <div class="chip" onclick="loadExample('1,1,1,1,1,1,1')">1,1,1,1,1,1,1</div>
        <div class="chip" onclick="loadExample('5,3,8,1,2')">5,3,8,1,2</div>
      </div>

      <label>Mode</label>
      <select id="modeSelect">
        <option value="fixed">Fixed-size window — sliding sum / max sum (size k)</option>
        <option value="smallest">Smallest subarray with sum ≥ target (variable-size)</option>
      </select>

      <div id="fixedControls">
        <label>Window size (k)</label>
        <input id="windowSize" type="number" min="1" value="3" />
      </div>

      <div id="smallestControls" style="display:none;">
        <label>Target sum</label>
        <input id="targetSum" type="number" min="0" value="7" />
      </div>

      <div class="controls">
        <button id="btnPlay" class="small">Play</button>
        <button id="btnPause" class="small secondary">Pause</button>
        <button id="btnStep" class="small secondary">Step</button>
        <button id="btnBack" class="small secondary">Back</button>
        <button id="btnReset" class="small secondary">Reset</button>
        <button id="btnRandom" class="small">Randomize</button>
        <div style="flex:1"></div>
        <label style="margin:0;color:var(--muted);font-size:13px;">Speed</label>
        <select id="speedSelect" style="width:84px;">
          <option value="800">0.8s</option>
          <option value="500" selected>0.5s</option>
          <option value="300">0.3s</option>
          <option value="120">0.12s</option>
        </select>
      </div>

      <div class="status" id="statusText">Ready</div>

      <div class="footer">
        Tips: Fixed-size shows current window sum and tracks the maximum sum. Smallest-subarray finds the minimum-length contiguous subarray with sum ≥ target by expanding and contracting the window.
      </div>
    </div>

    <div class="card visual" id="visualCard">
      <div id="explain" style="text-align:center;color:var(--muted);font-size:13px;">
        Visual representation of the array and sliding window. Use controls to step through.
      </div>

      <div class="array" id="arrayRow" aria-hidden="false"></div>

      <div class="info" id="infoRow">
        <div class="box">
          <div class="label">Current sum</div>
          <div class="value" id="currentSum">-</div>
        </div>
        <div class="box">
          <div class="label">Window indices</div>
          <div class="value" id="indices">-</div>
        </div>
        <div class="box">
          <div class="label">Best found</div>
          <div class="value" id="bestFound">-</div>
        </div>
      </div>

      <div class="log" id="log"></div>
    </div>
  </div>

  <script>
    /*
      Sliding Window Visualizer
      - Two modes:
        1) Fixed-size window: sliding sum for window size k, track max sum and location
        2) Smallest subarray with sum >= target: variable window, track min length and indices

      Controls:
        Play / Pause / Step / Back / Reset / Randomize
      Implementation notes:
        We use generator functions to produce step-by-step states. Each step yields an object describing:
          - left, right pointers
          - currentSum
          - action (e.g., 'init', 'add', 'remove', 'check', 'found', 'move')
          - best state (max sum or min length)
          - highlight range
    */

    // DOM refs
    const arrayInput = document.getElementById('arrayInput');
    const modeSelect = document.getElementById('modeSelect');
    const windowSizeInput = document.getElementById('windowSize');
    const targetSumInput = document.getElementById('targetSum');
    const arrayRow = document.getElementById('arrayRow');
    const logEl = document.getElementById('log');
    const currentSumEl = document.getElementById('currentSum');
    const indicesEl = document.getElementById('indices');
    const bestFoundEl = document.getElementById('bestFound');
    const btnPlay = document.getElementById('btnPlay');
    const btnPause = document.getElementById('btnPause');
    const btnStep = document.getElementById('btnStep');
    const btnBack = document.getElementById('btnBack');
    const btnReset = document.getElementById('btnReset');
    const btnRandom = document.getElementById('btnRandom');
    const speedSelect = document.getElementById('speedSelect');
    const statusText = document.getElementById('statusText');
    const fixedControls = document.getElementById('fixedControls');
    const smallestControls = document.getElementById('smallestControls');

    // State
    let arr = [];
    let generator = null;
    let history = []; // for stepping/back
    let playing = false;
    let interval = null;

    function parseArrayInput() {
      const raw = arrayInput.value.trim();
      if (!raw) return [];
      // Accept commas, spaces
      const parts = raw.split(/[\s,]+/).filter(Boolean);
      const nums = parts.map(p => Number(p));
      return nums.map(n => isFinite(n) ? n : 0);
    }

    function loadExample(txt){
      arrayInput.value = txt;
      resetAll();
    }

    function randomizeArray(){
      const len = Math.floor(Math.random()*7) + 5; // 5..11
      const max = 12;
      const nums = Array.from({length:len}, () => Math.floor(Math.random()*max));
      arrayInput.value = nums.join(',');
      resetAll();
    }

    function renderArray(highlight = null, removeIndex = null, bestRange = null) {
      arrayRow.innerHTML = '';
      arr.forEach((v,i) => {
        const c = document.createElement('div');
        c.className = 'cell';
        c.innerHTML = `<div class="index">${i}</div><div>${v}</div>`;
        if (highlight && i >= highlight[0] && i <= highlight[1]) {
          c.classList.add('highlight');
        }
        if (removeIndex === i) {
          c.classList.add('remove');
        }
        if (bestRange && i >= bestRange[0] && i <= bestRange[1]) {
          // stronger highlight for best
          c.style.boxShadow = '0 8px 22px rgba(34,193,195,0.12)';
        }
        arrayRow.appendChild(c);
      });
    }

    function log(msg, kind='info') {
      const time = new Date().toLocaleTimeString();
      logEl.innerHTML = `<div>[${time}] ${msg}</div>` + logEl.innerHTML;
    }

    function updateInfo(state){
      currentSumEl.textContent = state.currentSum != null ? state.currentSum : '-';
      indicesEl.textContent = (state.left != null && state.right != null) ? `[${state.left}, ${state.right}]` : '-';
      bestFoundEl.textContent = state.bestDisplay || '-';
    }

    // Generators to step through the algorithms

    // Fixed-size sliding window (sum / max sum)
    function* fixedWindowGenerator(a, k) {
      const n = a.length;
      if (k <= 0) {
        yield { action:'init', left:0, right:-1, currentSum:0, best:{sum:0, left:0, right:-1}, bestDisplay:'k <= 0' };
        return;
      }
      if (k > n) {
        yield { action:'init', left:0, right:n-1, currentSum: a.reduce((s,v)=>s+v,0), best:{sum:null}, bestDisplay:'k > n (no full window)' };
        return;
      }
      let sum = 0;
      // first window
      for (let i=0;i<k;i++){
        sum += a[i];
        yield { action:'add', left:0, right:i, currentSum:sum, note:`Added a[${i}] = ${a[i]}` , best:{sum:null}, bestDisplay:'initializing' };
      }
      let bestSum = sum;
      let bestL = 0, bestR = k-1;
      yield { action:'check', left:0, right:k-1, currentSum:sum, best:{sum:bestSum,left:bestL,right:bestR}, bestDisplay:`maxSum = ${bestSum} at [${bestL}, ${bestR}]` };
      // slide
      for (let i=k;i<n;i++){
        const removeIndex = i-k;
        const addIndex = i;
        sum = sum - a[removeIndex];
        yield { action:'remove', left:removeIndex+1, right:addIndex-1, currentSum:sum, removeIndex, note:`Removed a[${removeIndex}] = ${a[removeIndex]}`, best:{sum:bestSum,left:bestL,right:bestR}, bestDisplay:`maxSum = ${bestSum} at [${bestL}, ${bestR}]`};
        sum = sum + a[addIndex];
        yield { action:'add', left:removeIndex+1, right:addIndex, currentSum:sum, note:`Added a[${addIndex}] = ${a[addIndex]}`, best:{sum:bestSum,left:bestL,right:bestR}, bestDisplay:`maxSum = ${bestSum} at [${bestL}, ${bestR}]`};
        if (sum > bestSum) {
          bestSum = sum; bestL = removeIndex+1; bestR = addIndex;
          yield { action:'found', left:bestL, right:bestR, currentSum:sum, best:{sum:bestSum,left:bestL,right:bestR}, bestDisplay:`UPDATED maxSum = ${bestSum} at [${bestL}, ${bestR}]` };
        } else {
          yield { action:'check', left:removeIndex+1, right:addIndex, currentSum:sum, best:{sum:bestSum,left:bestL,right:bestR}, bestDisplay:`maxSum = ${bestSum} at [${bestL}, ${bestR}]` };
        }
      }
      yield { action:'done', left:bestL, right:bestR, currentSum: bestSum, best:{sum:bestSum,left:bestL,right:bestR}, bestDisplay:`Completed. maxSum = ${bestSum} at [${bestL}, ${bestR}]` };
    }

    // Smallest subarray with sum >= target (variable-size sliding window)
    function* smallestSubarrayGenerator(a, target) {
      const n = a.length;
      let left = 0, sum = 0;
      let minLen = Infinity, bestL = -1, bestR = -1;
      yield { action:'init', left:0, right:-1, currentSum:0, bestDisplay:'start' };
      for (let right=0; right<n; right++){
        sum += a[right];
        yield { action:'add', left:left, right:right, currentSum:sum, note:`Added a[${right}] = ${a[right]}`, best:{minLen,minLen,left:bestL,right:bestR}, bestDisplay: minLen===Infinity ? 'no solution yet' : `minLen = ${minLen} at [${bestL},${bestR}]` };
        // Contract while meets target
        while (sum >= target && left <= right) {
          const currLen = right - left + 1;
          if (currLen < minLen) {
            minLen = currLen; bestL = left; bestR = right;
            yield { action:'found', left:left, right:right, currentSum:sum, best:{minLen,minLen,left:bestL,right:bestR}, bestDisplay:`UPDATED minLen = ${minLen} at [${bestL},${bestR}]` };
          } else {
            yield { action:'check', left:left, right:right, currentSum:sum, best:{minLen,minLen,left:bestL,right:bestR}, bestDisplay: minLen===Infinity ? 'no solution' : `minLen = ${minLen} at [${bestL},${bestR}]` };
          }
          // remove leftmost
          sum -= a[left];
          yield { action:'remove', left:left+1, right:right, currentSum:sum, removeIndex:left, note:`Removing a[${left}] = ${a[left]}` , best:{minLen,minLen,left:bestL,right:bestR}, bestDisplay: minLen===Infinity ? 'no solution' : `minLen = ${minLen} at [${bestL},${bestR}]`};
          left++;
        }
      }
      if (minLen === Infinity) {
        yield { action:'done', left:0, right:n-1, currentSum:sum, bestDisplay:'No valid subarray found (sum < target)' };
      } else {
        yield { action:'done', left:bestL, right:bestR, currentSum:0, bestDisplay:`Completed. minLen = ${minLen} at [${bestL},${bestR}]` };
      }
    }

    // Utility to create the appropriate generator based on mode
    function createGenerator(){
      arr = parseArrayInput();
      if (!arr.length) arr = [];
      const mode = modeSelect.value;
      if (mode === 'fixed') {
        const k = Math.max(0, Math.floor(Number(windowSizeInput.value) || 0));
        return fixedWindowGenerator(arr, k);
      } else if (mode === 'smallest') {
        const t = Number(targetSumInput.value) || 0;
        return smallestSubarrayGenerator(arr, t);
      }
      return (function*(){ yield {action:'done'}; })();
    }

    function resetAll(){
      stopPlaying();
      arr = parseArrayInput();
      history = [];
      generator = createGenerator();
      const first = generator.next();
      history.push(first.value);
      renderState(first.value);
      log('Reset and initialized generator.');
      statusText.textContent = 'Ready';
    }

    function renderState(state) {
      // state can be undefined if generator ended
      if (!state) return;
      // highlight range
      const left = state.left != null ? state.left : 0;
      const right = state.right != null ? state.right : arr.length-1;
      const highlight = (left<=right) ? [left,right] : null;
      // best range for display
      let bestRange = null;
      if (state.best && state.best.left != null && state.best.right != null && state.best.left <= state.best.right) {
        bestRange = [state.best.left, state.best.right];
      } else if (state.action === 'done' && state.left != null && state.right != null && modeSelect.value === 'fixed') {
        // final best for fixed maybe encoded in left/right
        bestRange = [state.left, state.right];
      }
      renderArray(highlight, state.removeIndex, bestRange);
      updateInfo({
        left: state.left,
        right: state.right,
        currentSum: state.currentSum,
        bestDisplay: state.bestDisplay || (state.best && state.best.sum != null ? `maxSum = ${state.best.sum}` : '-')
      });

      // log action
      if (state.note) log(state.note);
      if (state.action) {
        switch(state.action) {
          case 'init': statusText.textContent = 'Initialized'; break;
          case 'add': statusText.textContent = `Added index ${state.right}`; break;
          case 'remove': statusText.textContent = `Removed index ${state.removeIndex}`; break;
          case 'found': statusText.textContent = state.bestDisplay || 'Found better'; break;
          case 'check': statusText.textContent = 'Checking'; break;
          case 'done': statusText.textContent = 'Completed'; break;
        }
      }
    }

    function stepForward(){
      if (!generator) generator = createGenerator();
      const result = generator.next();
      if (result.done) {
        log('Reached end of algorithm.');
        statusText.textContent = 'Completed';
        playing = false;
        stopPlaying();
        return;
      }
      history.push(result.value);
      renderState(result.value);
    }

    function stepBack(){
      if (history.length <= 1) {
        log('At the beginning, cannot step back further.');
        return;
      }
      // remove last
      history.pop();
      const prev = history[history.length-1];
      renderState(prev);
      // We must rebuild generator from this point onward if user continues stepping forward.
      // Simpler: recreate generator and consume states to reach current history length.
      generator = createGenerator();
      // discard initial states to match history length
      for (let i=0;i<history.length;i++){
        const res = generator.next();
        if (res.done) break;
      }
      log('Stepped back.');
    }

    function play(){
      if (playing) return;
      playing = true;
      statusText.textContent = 'Playing';
      const delay = Number(speedSelect.value) || 500;
      interval = setInterval(() => {
        const result = generator.next();
        if (result.done) {
          log('Animation finished.');
          statusText.textContent = 'Completed';
          playing = false;
          stopPlaying();
          return;
        }
        history.push(result.value);
        renderState(result.value);
      }, delay);
    }

    function stopPlaying(){
      playing = false;
      if (interval) {
        clearInterval(interval);
        interval = null;
      }
    }

    // Event wiring
    btnPlay.addEventListener('click', () => {
      // if generator not created or at end, recreate
      if (!generator) {
        generator = createGenerator();
        const first = generator.next();
        history.push(first.value);
        renderState(first.value);
      }
      play();
    });
    btnPause.addEventListener('click', () => { stopPlaying(); statusText.textContent = 'Paused'; log('Paused.'); });
    btnStep.addEventListener('click', () => { stopPlaying(); stepForward(); });
    btnBack.addEventListener('click', () => { stopPlaying(); stepBack(); });
    btnReset.addEventListener('click', () => { resetAll(); log('Reset requested.'); });
    btnRandom.addEventListener('click', () => { randomizeArray(); log('Randomized array.'); });

    // When inputs change, reset
    arrayInput.addEventListener('change', () => { resetAll(); });
    windowSizeInput.addEventListener('change', () => { if (modeSelect.value === 'fixed') resetAll(); });
    targetSumInput.addEventListener('change', () => { if (modeSelect.value === 'smallest') resetAll(); });

    modeSelect.addEventListener('change', () => {
      if (modeSelect.value === 'fixed') {
        fixedControls.style.display = 'block';
        smallestControls.style.display = 'none';
      } else {
        fixedControls.style.display = 'none';
        smallestControls.style.display = 'block';
      }
      resetAll();
    });

    // initial setup
    resetAll();

    // expose some helpers for example chips to call
    window.loadExample = loadExample;
    window.randomizeArray = randomizeArray;
  </script>
</body>
</html>