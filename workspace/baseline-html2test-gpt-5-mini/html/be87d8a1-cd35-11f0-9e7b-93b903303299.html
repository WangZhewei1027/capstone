<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Recursion Demonstration</title>
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#7dd3fc;
      --muted:#94a3b8;
      --panel:#081025;
      --success:#a7f3d0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    body{
      margin:0;
      background: linear-gradient(180deg,#021025 0%, #071426 100%);
      color: #e6eef6;
      min-height:100vh;
      padding:20px;
      box-sizing:border-box;
    }
    header{
      display:flex;
      gap:16px;
      align-items:center;
      margin-bottom:18px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    main{
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:18px;
      align-items:start;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      padding:14px;
      border-radius:10px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
    }
    .small{
      font-size:13px;
      color:var(--muted);
    }
    label{display:block;font-size:13px;margin-top:8px;color:var(--muted)}
    input[type=number], input[type=range], select{
      width:100%;
      margin-top:6px;
      padding:8px 10px;
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:inherit;
      border-radius:6px;
      outline:none;
    }
    button{
      background:linear-gradient(90deg,var(--accent),#60a5fa);
      color:#042733;
      padding:8px 10px;
      border-radius:8px;
      border:none;
      font-weight:600;
      cursor:pointer;
    }
    .controls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
    .stack{
      margin-top:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border:1px solid rgba(255,255,255,0.03);
      padding:8px;
      border-radius:8px;
      min-height:120px;
      max-height:320px;
      overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
      color:#dbeafe;
    }
    .frame{
      padding:6px 8px;
      border-radius:6px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      border:1px solid rgba(255,255,255,0.02);
      margin:6px 0;
      display:flex;
      justify-content:space-between;
      gap:8px;
    }
    .frame .name{color:var(--accent);font-weight:700}
    .frame .ret{color:var(--success);font-weight:700}
    .muted{color:var(--muted)}
    canvas{width:100%;height:100%;border-radius:8px;background:linear-gradient(180deg,#071025,#02101b);display:block}
    .vis-panel{display:flex;flex-direction:column;height:560px;gap:12px}
    .row{display:flex;gap:12px;align-items:center}
    .legend{font-size:12px;color:var(--muted);margin-top:6px}
    footer{margin-top:18px;color:var(--muted);font-size:13px}
    .inline{display:inline-flex;gap:8px;align-items:center}
    .badge{background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:999px;font-weight:600;color:var(--muted);font-size:12px}
    .split{
      display:grid;grid-template-columns:1fr 1fr;gap:12px;
    }
    @media (max-width:980px){
      main{grid-template-columns:1fr; padding-bottom:40px}
      .vis-panel{height:420px}
    }
  </style>
</head>
<body>
  <header>
    <div class="badge">Concept: Recursion</div>
    <div style="flex:1">
      <h1>Interactive Recursion Playground</h1>
      <div class="small">See how functions call themselves, visualize call stacks and trees, and draw recursive fractals.</div>
    </div>
  </header>

  <main>
    <div class="card">
      <h2 style="margin:0 0 6px 0">1) Recursion Trace (Factorial)</h2>
      <div class="small">Watch an animated call stack as a recursive factorial function runs. The demo uses async recursion so we can visualize each call and return.</div>

      <label>n (integer &ge; 0)</label>
      <input id="factN" type="number" min="0" max="12" value="6" />
      <label>Animation speed (ms per step)</label>
      <input id="factSpeed" type="range" min="20" max="800" value="180" />
      <div class="controls">
        <button id="runFact">Run Recursive Factorial</button>
        <button id="runIter">Run Iterative Factorial</button>
        <button id="clearFact">Clear</button>
      </div>

      <div class="stack" id="factStack" aria-live="polite"></div>
      <div style="display:flex;justify-content:space-between;margin-top:8px;align-items:center">
        <div class="muted">Result: <span id="factResult">—</span></div>
        <div class="muted">Call count: <span id="factCalls">0</span></div>
      </div>

      <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.02)">

      <h2 style="margin:0 0 6px 0">2) Fibonacci: Tree & Memoization</h2>
      <div class="small">Compare naive recursion (exponential calls) with memoized recursion (linear calls). A tree drawing shows how calls branch.</div>

      <label>n (integer, small because naive grows fast)</label>
      <input id="fibN" type="number" min="0" max="12" value="6" />
      <label>Animation speed (ms per node, for naive tree)</label>
      <input id="fibSpeed" type="range" min="10" max="400" value="100" />
      <div class="controls">
        <button id="runFibNaive">Draw Naive Fib Tree</button>
        <button id="runFibMemo">Compute with Memoization</button>
        <button id="clearFib">Clear</button>
      </div>

      <div class="row" style="margin-top:8px">
        <div class="muted">Result: <span id="fibResult">—</span></div>
        <div class="muted">Calls: <span id="fibCalls">0</span></div>
      </div>

      <div class="legend">Legend: node = fib(k) call. Colors indicate active vs returned nodes.</div>
    </div>

    <div class="card vis-panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h2 style="margin:0">Visualizations</h2>
        <div class="small">Canvas area shows Fibonacci trees and a fractal tree below.</div>
      </div>

      <div style="flex:1;display:flex;flex-direction:column;gap:12px;">
        <div style="height:320px;">
          <canvas id="canvasFib" width="1200" height="640"></canvas>
        </div>

        <div style="height:200px;display:flex;gap:12px;">
          <div style="flex:1;display:flex;flex-direction:column;">
            <label>Fractal Tree Depth</label>
            <input id="frDepth" type="range" min="0" max="12" value="8" />
            <div class="controls" style="margin-top:6px">
              <button id="drawFractal">Draw Fractal Tree</button>
              <button id="clearFractal">Clear</button>
            </div>
          </div>
          <div style="flex:1;position:relative;">
            <canvas id="canvasFr" width="800" height="480"></canvas>
            <div class="small" style="position:absolute;left:12px;bottom:12px;color:var(--muted);">Fractal tree (recursive drawing)</div>
          </div>
        </div>
      </div>

      <footer>
        Short notes: Recursion is when a function calls itself. Each call gets its own frame on the call stack. Some recursion forms are naturally exponential (naive Fibonacci), others are linear (factorial). Memoization or turning recursion into iteration can improve performance.
      </footer>
    </div>
  </main>

  <script>
    // Utilities
    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
    function el(id){ return document.getElementById(id); }

    // ---------- Factorial trace with async recursion ----------
    (function(){
      const stackDiv = el('factStack');
      const resultSpan = el('factResult');
      const callsSpan = el('factCalls');
      const runBtn = el('runFact');
      const iterBtn = el('runIter');
      const clearBtn = el('clearFact');
      const nInput = el('factN');
      const speedInput = el('factSpeed');

      let running = false;

      function pushFrame(name, info){
        const frame = document.createElement('div');
        frame.className = 'frame';
        frame.dataset.name = name;
        frame.innerHTML = `<div><span class="name">${name}</span> <span class="muted">${info||''}</span></div><div class="ret">…</div>`;
        stackDiv.prepend(frame); // show newest on top as stack
        return frame;
      }
      function markReturn(frame, value){
        const ret = frame.querySelector('.ret');
        ret.textContent = value;
        frame.style.background = 'linear-gradient(180deg, rgba(0,255,170,0.03), rgba(0,255,170,0.02))';
        frame.style.border = '1px solid rgba(0,255,170,0.08)';
      }

      async function factAsync(n, speed, state){
        // state used for counting calls
        state.calls++;
        const frame = pushFrame(`fact(${n})`);
        await sleep(speed);
        if (n === 0 || n === 1){
          markReturn(frame, 1);
          await sleep(speed/2);
          return 1;
        } else {
          const sub = await factAsync(n-1, speed, state);
          const res = n * sub;
          markReturn(frame, res);
          await sleep(speed/2);
          return res;
        }
      }

      async function runRecursive(){
        if (running) return;
        running = true;
        stackDiv.innerHTML = '';
        resultSpan.textContent = '…';
        callsSpan.textContent = '0';
        const n = Math.max(0, Math.min(12, parseInt(nInput.value)||0));
        const speed = parseInt(speedInput.value)||150;
        const state = {calls:0};
        try{
          const res = await factAsync(n, speed, state);
          resultSpan.textContent = res;
          callsSpan.textContent = state.calls;
        }catch(e){
          console.error(e);
        }
        running = false;
      }

      function runIterative(){
        if (running) return;
        running = true;
        stackDiv.innerHTML = '';
        resultSpan.textContent = '…';
        callsSpan.textContent = '0';
        const n = Math.max(0, Math.min(1000, parseInt(nInput.value)||0));
        // iterative fast version
        let res = 1;
        for(let i=2;i<=n;i++) res *= i;
        resultSpan.textContent = res;
        callsSpan.textContent = '1 (iterative)';
        // show one frame to illustrate
        const frame = pushFrame(`fact_iter(${n})`, 'loop');
        markReturn(frame, res);
        running = false;
      }

      runBtn.addEventListener('click', runRecursive);
      iterBtn.addEventListener('click', runIterative);
      clearBtn.addEventListener('click', ()=>{
        if (running) return;
        stackDiv.innerHTML = '';
        resultSpan.textContent = '—';
        callsSpan.textContent = '0';
      });
    })();

    // ---------- Fibonacci (naive) tree drawing and memoization ----------
    (function(){
      const canvas = el('canvasFib');
      const ctx = canvas.getContext('2d', {alpha:false});
      const runNaive = el('runFibNaive');
      const runMemo = el('runFibMemo');
      const clearBtn = el('clearFib');
      const nInput = el('fibN');
      const speedInput = el('fibSpeed');
      const resultSpan = el('fibResult');
      const callsSpan = el('fibCalls');

      // Resize for devicePixelRatio
      function fixCanvas(c){
        const dpr = window.devicePixelRatio || 1;
        const rect = c.getBoundingClientRect();
        c.width = Math.floor(rect.width * dpr);
        c.height = Math.floor(rect.height * dpr);
        c.style.width = rect.width+'px';
        c.style.height = rect.height+'px';
        c.getContext('2d').setTransform(dpr,0,0,dpr,0,0);
      }
      fixCanvas(canvas);
      window.addEventListener('resize', ()=>fixCanvas(canvas));

      // Draw utilities
      function clear(){
        const w = canvas.width/(window.devicePixelRatio||1);
        const h = canvas.height/(window.devicePixelRatio||1);
        ctx.fillStyle = '#02101b';
        ctx.fillRect(0,0,w,h);
      }
      clear();

      // Layout an approximate tree (binary branching)
      function layoutTreeNodes(n, startX, startY, width, level=0, positions=[], parent=null){
        // For fib, each node is fib(k). We lay out recursively:
        const x = startX + width/2;
        const y = startY + level*70;
        const id = {k:n, x, y, parent};
        positions.push(id);
        if (n <= 1) return positions;
        // left child fib(n-1), right child fib(n-2)
        const leftWidth = width * (n-1)/(n+1); // heuristic to spread
        layoutTreeNodes(n-1, startX, startY, leftWidth, level+1, positions, id);
        layoutTreeNodes(n-2, startX+leftWidth, startY, width-leftWidth, level+1, positions, id);
        return positions;
      }

      function drawNode(node, state){
        // state: active/returned/visited
        ctx.beginPath();
        ctx.arc(node.x, node.y, 18, 0, Math.PI*2);
        if (state === 'active'){
          ctx.fillStyle = '#7dd3fc';
          ctx.strokeStyle = '#0369a1';
        } else if (state === 'returned'){
          ctx.fillStyle = '#6ee7b7';
          ctx.strokeStyle = '#065f46';
        } else {
          ctx.fillStyle = '#0b1220';
          ctx.strokeStyle = '#1f2937';
        }
        ctx.fill();
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.fillStyle = '#001728';
        ctx.font = 'bold 12px ui-sans-serif, system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('fib('+node.k+')', node.x, node.y);
      }

      async function drawNaive(n, speed){
        clear();
        resultSpan.textContent = '…';
        callsSpan.textContent = '0';
        if (n < 0) return;
        const rect = canvas.getBoundingClientRect();
        const width = rect.width - 40;
        const nodes = layoutTreeNodes(n, 20, 30, width);
        // draw edges
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        for(const node of nodes){
          if (node.parent){
            ctx.beginPath();
            ctx.moveTo(node.x, node.y-18);
            ctx.lineTo(node.parent.x, node.parent.y+18);
            ctx.stroke();
          }
        }

        // For visualization we will traverse and "visit" nodes in recursion order:
        let calls = 0;
        async function visit(k, x, y){
          calls++;
          callsSpan.textContent = calls;
          // find node object with these coords (approx)
          const node = nodes.find(nod => nod.k===k && Math.abs(nod.x-x)<1 && Math.abs(nod.y-y)<1) ||
                       nodes.find(nod => nod.k===k);
          drawNode(node, 'active');
          await sleep(speed);
          if (k <= 1){
            drawNode(node, 'returned');
            await sleep(speed/2);
            return 1;
          } else {
            // find children positions
            // left is first matching with parent=node and higher level
            const children = nodes.filter(nod => nod.parent === node);
            // ensure left then right by k
            children.sort((a,b)=>b.k - a.k); // bigger k usually left (n-1)
            const left = children[0], right = children[1];
            const vl = await visit(k-1, left.x, left.y);
            const vr = await visit(k-2, right.x, right.y);
            const res = vl + vr;
            drawNode(node, 'returned');
            await sleep(speed/2);
            return res;
          }
        }

        const res = await visit(n, nodes.find(nd=>nd.k===n).x, nodes.find(nd=>nd.k===n).y);
        resultSpan.textContent = res;
        callsSpan.textContent = calls;
      }

      function computeFibMemo(n){
        const cache = {};
        let calls = 0;
        function fib(k){
          calls++;
          if (k <= 1) return 1;
          if (cache[k] !== undefined) return cache[k];
          cache[k] = fib(k-1) + fib(k-2);
          return cache[k];
        }
        const res = fib(n);
        return {res, calls};
      }

      runNaive.addEventListener('click', async ()=>{
        const n = Math.max(0, Math.min(12, parseInt(nInput.value)||0));
        const speed = Math.max(10, parseInt(speedInput.value)||120);
        await drawNaive(n, speed);
      });

      runMemo.addEventListener('click', ()=>{
        const n = Math.max(0, Math.min(100, parseInt(nInput.value)||0));
        const {res, calls} = computeFibMemo(n);
        resultSpan.textContent = res;
        callsSpan.textContent = calls + ' (memoized)';
        // Draw a compact static tree to illustrate structure without many nodes:
        clear();
        const rect = canvas.getBoundingClientRect();
        const width = rect.width - 40;
        const nodes = layoutTreeNodes(Math.min(n,6), 20, 30, width); // limit depth for drawing
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        for(const node of nodes){
          if (node.parent){
            ctx.beginPath();
            ctx.moveTo(node.x, node.y-18);
            ctx.lineTo(node.parent.x, node.parent.y+18);
            ctx.stroke();
          }
        }
        for(const node of nodes) drawNode(node, 'returned');
      });

      clearBtn.addEventListener('click', ()=>{
        clear();
        resultSpan.textContent = '—';
        callsSpan.textContent = '0';
      });

    })();

    // ---------- Fractal Tree (recursive drawing) ----------
    (function(){
      const canvas = el('canvasFr');
      const ctx = canvas.getContext('2d');
      const depthInput = el('frDepth');
      const drawBtn = el('drawFractal');
      const clearBtn = el('clearFractal');

      function fix(c){
        const dpr = window.devicePixelRatio || 1;
        const rect = c.getBoundingClientRect();
        c.width = Math.floor(rect.width * dpr);
        c.height = Math.floor(rect.height * dpr);
        c.style.width = rect.width+'px';
        c.style.height = rect.height+'px';
        c.getContext('2d').setTransform(dpr,0,0,dpr,0,0);
      }
      fix(canvas);
      window.addEventListener('resize', ()=>fix(canvas));

      function clear(){
        const w = canvas.width/(window.devicePixelRatio||1);
        const h = canvas.height/(window.devicePixelRatio||1);
        ctx.fillStyle = '#061420';
        ctx.fillRect(0,0,w,h);
      }
      clear();

      function drawTree(x, y, length, angle, depth){
        // base case
        if (depth === 0 || length < 2) return;
        const x2 = x + Math.cos(angle) * length;
        const y2 = y + Math.sin(angle) * length;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x2, y2);
        // stroke color based on depth
        const t = depth/12;
        ctx.strokeStyle = `rgba(${Math.floor(200*t+40)}, ${Math.floor(255*t)}, ${Math.floor(180-120*t)}, 0.95)`;
        ctx.lineWidth = Math.max(1, depth/2);
        ctx.stroke();

        // recursive calls: left and right branches
        drawTree(x2, y2, length * 0.72, angle - 0.45, depth - 1);
        drawTree(x2, y2, length * 0.72, angle + 0.35, depth - 1);

        // occasional smaller middle branch
        if (depth % 3 === 0){
          drawTree(x2, y2, length * 0.5, angle + 0.05, depth - 2);
        }
      }

      drawBtn.addEventListener('click', ()=>{
        const depth = Math.max(0, Math.min(12, parseInt(depthInput.value)||8));
        clear();
        const rect = canvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        drawTree(w/2, h-20, Math.min(w,h)/4, -Math.PI/2, depth);
      });

      clearBtn.addEventListener('click', clear);
    })();

    // Initial small draws
    (function init(){
      // draw empty canvas patterns
      const canv = document.querySelectorAll('canvas');
      canv.forEach(c=>{
        const ctx = c.getContext('2d');
        ctx.fillStyle = '#02101b';
        ctx.fillRect(0,0,c.width/(window.devicePixelRatio||1), c.height/(window.devicePixelRatio||1));
      });
    })();
  </script>
</body>
</html>