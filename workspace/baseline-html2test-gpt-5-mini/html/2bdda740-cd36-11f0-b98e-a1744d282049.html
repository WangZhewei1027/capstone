<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Array Explorer — Interactive JavaScript Array Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; color:#111}
    body {margin:0;background:#f6f8fb}
    header {background:linear-gradient(90deg,#3b82f6,#06b6d4);color:white;padding:18px 22px}
    header h1 {margin:0;font-size:20px}
    main {display:flex;gap:18px;padding:18px;max-width:1200px;margin:0 auto}
    .panel {background:white;border-radius:10px;padding:14px;box-shadow:0 4px 18px rgba(11,22,39,0.06);flex:1;min-width:280px}
    .wide {flex:1.6}
    label {display:block;font-size:13px;margin:10px 0 6px;color:#334155}
    textarea,input[type="text"],select {width:100%;box-sizing:border-box;padding:8px;border:1px solid #e6eef6;border-radius:8px;font-size:14px}
    button {margin:6px 6px 6px 0;padding:8px 12px;border-radius:8px;border:1px solid #cbd5e1;background:white;cursor:pointer}
    .btn-primary {background:#0ea5a4;color:white;border:none;box-shadow:0 6px 18px rgba(14,165,164,0.12)}
    .grid {display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:8px;margin-top:8px}
    pre {background:#0f1724;color:#e6eef6;padding:12px;border-radius:8px;overflow:auto;font-size:13px}
    ul.array-visual {list-style:none;padding:0;margin:8px 0 0;display:flex;flex-wrap:wrap;gap:8px}
    ul.array-visual li {padding:8px 10px;border-radius:8px;background:#f1f5f9;border:1px solid #e2e8f0}
    .meta {font-size:13px;color:#64748b;margin-top:8px}
    .controls-row {display:flex;gap:8px;flex-wrap:wrap}
    .small {font-size:13px;padding:6px 8px}
    .log {height:160px;overflow:auto;background:#0b1220;color:#e6eef6;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    footer {text-align:center;padding:12px;color:#64748b;font-size:13px}
    .hint {font-size:13px;color:#475569}
    .danger {border-color:#fecaca;background:#fff1f2}
    .ok {border-color:#bbf7d0;background:#f0fdf4}
    .flex {display:flex;gap:8px;align-items:center}
    .nowrap {white-space:nowrap}
    .small-input {width:120px}
  </style>
</head>
<body>
  <header>
    <h1>Array Explorer — Interactive JavaScript Array Demo</h1>
  </header>

  <main>
    <section class="panel">
      <h2>1) Current Array (editable)</h2>
      <label for="arrayInput">Edit array as JSON (e.g. [1,2,3] or ["a","b"] or [[1,2],[3]])</label>
      <textarea id="arrayInput" rows="4">[1, 2, 3, 4, 5]</textarea>
      <div style="margin-top:10px" class="controls-row">
        <button id="loadBtn" class="btn-primary">Load</button>
        <button id="resetBtn">Reset Example</button>
        <button id="randomBtn">Randomize Numbers</button>
        <button id="sampleBtn">Sample Mixed Array</button>
      </div>

      <div class="meta">
        <div>Type: <span id="typeDisplay"></span> · Length: <strong id="lenDisplay"></strong></div>
        <div style="margin-top:8px" class="hint">Arrays are ordered collections. This pane shows the array you manipulate with the actions on the right.</div>
      </div>

      <h3 style="margin-top:14px">Visual representation</h3>
      <ul id="visual" class="array-visual" aria-live="polite"></ul>

      <h3 style="margin-top:14px">Quick operations</h3>
      <div class="grid">
        <button id="pushBtn">push()</button>
        <button id="popBtn">pop()</button>
        <button id="shiftBtn">shift()</button>
        <button id="unshiftBtn">unshift()</button>
        <button id="spliceBtn">splice()</button>
        <button id="sliceBtn">slice()</button>
        <button id="concatBtn">concat()</button>
        <button id="clearBtn" class="danger">clear (empty)</button>
      </div>

      <div style="margin-top:12px">
        <label for="valueInput">Value(s) (JSON) for push/unshift/splice etc.</label>
        <input id="valueInput" type="text" placeholder='e.g. "x" or 10 or [7,8]'>
      </div>
    </section>

    <section class="panel wide">
      <h2>2) Method Playground & Examples</h2>

      <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
        <label class="nowrap">Choose operation:</label>
        <select id="operation" style="flex:1;min-width:220px">
          <optgroup label="Transformations">
            <option value="map">map(fn)</option>
            <option value="filter">filter(fn)</option>
            <option value="reduce">reduce(fn, initial)</option>
            <option value="flat">flat(depth)</option>
            <option value="flatMap">flatMap(fn)</option>
            <option value="sort">sort()</option>
            <option value="reverse">reverse()</option>
            <option value="slice">slice(start,end)</option>
            <option value="splice">splice(index,count,items)</option>
            <option value="concat">concat(array)</option>
          </optgroup>
          <optgroup label="Queries & Others">
            <option value="find">find(fn)</option>
            <option value="findIndex">findIndex(fn)</option>
            <option value="includes">includes(value)</option>
            <option value="indexOf">indexOf(value)</option>
            <option value="join">join(sep)</option>
            <option value="forEach">forEach(fn)</option>
            <option value="from">Array.from(iterable)</option>
            <option value="of">Array.of(...)</option>
            <option value="isArray">Array.isArray()</option>
          </optgroup>
        </select>

        <label class="nowrap">Preset function:</label>
        <select id="presetFn" class="small-input">
          <option value="x=>x*2">x =&gt; x * 2</option>
          <option value="x=>x+1">x =&gt; x + 1</option>
          <option value="x=>x%2===0">even (x % 2 === 0)</option>
          <option value="s=>String(s).toUpperCase()">toUpperCase</option>
          <option value="(v,i)=>v+i">(v,i) =&gt; v + i</option>
          <option value="x=>[x,x]">x =&gt; [x, x] (for flatMap)</option>
        </select>

        <label class="nowrap">Extra arg:</label>
        <input id="extraArg" class="small-input" type="text" placeholder='e.g. 0 or "," or true'>

        <button id="runBtn" class="btn-primary">Run</button>
        <button id="applyBtn">Apply to current</button>
        <button id="previewBtn">Preview (no apply)</button>
      </div>

      <div style="margin-top:12px" class="meta">Preview shows result without changing the current array. Apply modifies the array (and updates the left pane).</div>

      <h3 style="margin-top:12px">Result / Explanation</h3>
      <pre id="codePreview">// Result appears here</pre>

      <h3 style="margin-top:12px">Console log (operation trace)</h3>
      <div id="log" class="log" aria-live="polite"></div>

      <h3 style="margin-top:12px">Examples & Tips</h3>
      <ul>
        <li>Use JSON input for values (e.g. [10,20] or "x").</li>
        <li>Preset functions are evaluated with new Function — be careful with input. This demo is local-only.</li>
        <li>Array is copied for preview; apply will replace the current array with the operation result when appropriate.</li>
      </ul>
    </section>
  </main>

  <footer>
    Built-in demos: push/pop/shift/unshift/splice/slice/map/filter/reduce/flat/flatMap/sort/reverse/concat/find/includes/forEach/Array.from/of/isArray
  </footer>

  <script>
    // Simple Array Explorer
    (() => {
      // Elements
      const arrayInput = document.getElementById('arrayInput');
      const loadBtn = document.getElementById('loadBtn');
      const resetBtn = document.getElementById('resetBtn');
      const randomBtn = document.getElementById('randomBtn');
      const sampleBtn = document.getElementById('sampleBtn');
      const visual = document.getElementById('visual');
      const typeDisplay = document.getElementById('typeDisplay');
      const lenDisplay = document.getElementById('lenDisplay');
      const valueInput = document.getElementById('valueInput');
      const pushBtn = document.getElementById('pushBtn');
      const popBtn = document.getElementById('popBtn');
      const shiftBtn = document.getElementById('shiftBtn');
      const unshiftBtn = document.getElementById('unshiftBtn');
      const spliceBtn = document.getElementById('spliceBtn');
      const sliceBtn = document.getElementById('sliceBtn');
      const concatBtn = document.getElementById('concatBtn');
      const clearBtn = document.getElementById('clearBtn');

      const operation = document.getElementById('operation');
      const presetFn = document.getElementById('presetFn');
      const extraArg = document.getElementById('extraArg');
      const runBtn = document.getElementById('runBtn');
      const applyBtn = document.getElementById('applyBtn');
      const previewBtn = document.getElementById('previewBtn');
      const codePreview = document.getElementById('codePreview');
      const logEl = document.getElementById('log');

      // Current array state (kept as JS array)
      let current = [1,2,3,4,5];

      // Helper: parse JSON-like input; fallback to single primitive parse
      function parseInput(text) {
        text = String(text).trim();
        if (text === "") return undefined;
        try {
          // Try as JSON
          return JSON.parse(text);
        } catch (e) {
          // Try eval as primitive (number, boolean) safely using Function
          try {
            // Be cautious: this evaluates simple literals only
            // Wrap in parentheses to allow object literals, but we already failed JSON
            return new Function("return (" + text + ")")();
          } catch (e2) {
            return text; // fallback to raw string
          }
        }
      }

      function safeClone(arr) {
        try {
          return JSON.parse(JSON.stringify(arr));
        } catch {
          return arr.slice();
        }
      }

      // Render the visual list and meta info
      function render() {
        visual.innerHTML = "";
        const isArr = Array.isArray(current);
        typeDisplay.textContent = isArr ? 'Array' : typeof current;
        lenDisplay.textContent = isArr ? current.length : '—';
        if (isArr) {
          current.forEach((v, i) => {
            const li = document.createElement('li');
            li.title = 'index ' + i;
            li.textContent = formatValue(v);
            visual.appendChild(li);
          });
        } else {
          const li = document.createElement('li');
          li.textContent = formatValue(current);
          visual.appendChild(li);
        }
        arrayInput.value = JSON.stringify(current, null, 2);
      }

      function formatValue(v) {
        if (v === null) return 'null';
        if (v === undefined) return 'undefined';
        if (Array.isArray(v)) return '[' + v.map(formatValue).join(', ') + ']';
        if (typeof v === 'object') return JSON.stringify(v);
        return String(v);
      }

      // Logging utility
      function log(...args) {
        const text = args.map(a => (typeof a === 'string' ? a : JSON.stringify(a))).join(' ');
        const node = document.createElement('div');
        node.textContent = text;
        logEl.appendChild(node);
        logEl.scrollTop = logEl.scrollHeight;
      }

      // Load array from textarea
      loadBtn.addEventListener('click', () => {
        try {
          const parsed = parseInput(arrayInput.value);
          if (!Array.isArray(parsed)) {
            if (parsed === undefined) {
              alert('Parsed value is undefined. Enter a valid array like [1,2,3].');
              return;
            }
            // Allow assigning non-array too
          }
          current = parsed;
          render();
          log('Loaded array:', current);
        } catch (e) {
          alert('Error parsing array input: ' + e.message);
        }
      });

      // Preset actions
      resetBtn.addEventListener('click', () => {
        current = [1,2,3,4,5];
        render(); log('Reset to [1,2,3,4,5]');
      });
      randomBtn.addEventListener('click', () => {
        current = Array.from({length:6}, ()=> Math.floor(Math.random()*100));
        render(); log('Randomized numbers:', current);
      });
      sampleBtn.addEventListener('click', () => {
        current = [1, "two", {k:3}, [4,5], null];
        render(); log('Loaded mixed sample:', current);
      });

      // Quick operation handlers
      pushBtn.addEventListener('click', () => {
        const val = parseInput(valueInput.value);
        if (val === undefined) { alert('Enter value(s) in the Value(s) box'); return; }
        if (Array.isArray(val)) {
          current.push(...val);
          log('push(...' + JSON.stringify(val) + ')');
        } else {
          current.push(val);
          log('push(' + JSON.stringify(val) + ')');
        }
        render();
      });
      popBtn.addEventListener('click', () => {
        const r = current.pop();
        log('pop() ->', r);
        render();
      });
      shiftBtn.addEventListener('click', () => {
        const r = current.shift();
        log('shift() ->', r);
        render();
      });
      unshiftBtn.addEventListener('click', () => {
        const val = parseInput(valueInput.value);
        if (val === undefined) { alert('Enter value(s)'); return; }
        if (Array.isArray(val)) current.unshift(...val);
        else current.unshift(val);
        log('unshift(' + JSON.stringify(val) + ')');
        render();
      });
      spliceBtn.addEventListener('click', () => {
        const text = valueInput.value.trim();
        // Expect "index,count,items" where items is JSON array or a single JSON value
        if (!text) { alert('Enter splice parameters in Value(s), e.g. "1,2, [7,8]" or "1,0, \"x\""'); return; }
        try {
          // Split by first two commas
          const parts = text.split(',').map(s=>s.trim());
          const index = parseInt(parts[0],10);
          const count = parseInt(parts[1],10);
          const rest = parts.slice(2).join(',');
          let items = [];
          if (rest) {
            const parsed = parseInput(rest);
            if (Array.isArray(parsed)) items = parsed;
            else items = [parsed];
          }
          const removed = current.splice(index, count, ...items);
          log(`splice(${index}, ${count}, ${JSON.stringify(items)}) -> removed ${JSON.stringify(removed)}`);
          render();
        } catch (e) { alert('Error parsing splice params: ' + e.message); }
      });
      sliceBtn.addEventListener('click', () => {
        const text = valueInput.value.trim();
        let start=0,end=undefined;
        if (text) {
          const parts = text.split(',').map(s=>s.trim());
          start = parseInt(parts[0],10);
          if (parts[1] !== undefined) end = parseInt(parts[1],10);
        }
        const res = current.slice(start, end);
        log(`slice(${start}, ${end}) ->`, res);
        codePreview.textContent = `// result (not applied)\n${JSON.stringify(res, null, 2)}`;
      });
      concatBtn.addEventListener('click', () => {
        const val = parseInput(valueInput.value);
        const other = Array.isArray(val) ? val : [val];
        const res = current.concat(other);
        log('concat', other, '->', res);
        codePreview.textContent = `// result (not applied)\n${JSON.stringify(res, null, 2)}`;
      });
      clearBtn.addEventListener('click', () => {
        current.length = 0;
        render(); log('Cleared array (length=0)');
      });

      // Operation runner
      function evaluateFunctionString(fnStr) {
        // Build a function from a string like "x=>x*2" or "function(x){return x*2}"
        if (!fnStr) return undefined;
        try {
          // If contains '=>' assume arrow function
          if (fnStr.includes('=>')) {
            // eslint-disable-next-line no-new-func
            return eval('(' + fnStr + ')');
          } else {
            // Try to create a Function
            // e.g. "(v,i) => v + i" or "function(v){return v*2}"
            return eval('(' + fnStr + ')');
          }
        } catch (e) {
          // last resort: try new Function with common args 'v,i,a'
          try {
            return new Function('v','i','a', 'return (' + fnStr + ')');
          } catch (e2) {
            throw new Error('Invalid function: ' + e.message);
          }
        }
      }

      function runOperation(apply=false) {
        const op = operation.value;
        const fnStr = presetFn.value;
        const extra = extraArg.value;
        let result;
        const arrCopy = safeClone(current);
        const logPrefix = apply ? '[APPLY]' : '[PREVIEW]';

        try {
          switch (op) {
            case 'map': {
              const fn = evaluateFunctionString(fnStr);
              result = arrCopy.map(fn);
              codePreview.textContent = `// map\n${JSON.stringify(result, null, 2)}\n// code: arr.map(${fnStr})`;
              log(`${logPrefix} map ->`, result);
              break;
            }
            case 'filter': {
              const fn = evaluateFunctionString(fnStr);
              result = arrCopy.filter(fn);
              codePreview.textContent = `// filter\n${JSON.stringify(result, null, 2)}\n// code: arr.filter(${fnStr})`;
              log(`${logPrefix} filter ->`, result);
              break;
            }
            case 'reduce': {
              const fn = evaluateFunctionString(fnStr);
              let initial = parseInput(extra);
              if (initial === undefined) {
                // If undefined and array not empty, start from first element
                result = arrCopy.reduce(fn);
              } else {
                result = arrCopy.reduce(fn, initial);
              }
              codePreview.textContent = `// reduce result\n${JSON.stringify(result, null, 2)}\n// code: arr.reduce(${fnStr}, ${JSON.stringify(initial)})`;
              log(`${logPrefix} reduce ->`, result);
              break;
            }
            case 'flat': {
              const depth = parseInt(extra || '1', 10) || 1;
              result = arrCopy.flat(depth);
              codePreview.textContent = `// flat(depth=${depth})\n${JSON.stringify(result, null, 2)}`;
              log(`${logPrefix} flat(${depth}) ->`, result);
              break;
            }
            case 'flatMap': {
              const fn = evaluateFunctionString(fnStr);
              result = arrCopy.flatMap(fn);
              codePreview.textContent = `// flatMap\n${JSON.stringify(result, null, 2)}\n// code: arr.flatMap(${fnStr})`;
              log(`${logPrefix} flatMap ->`, result);
              break;
            }
            case 'sort': {
              // If fnStr empty, do default sort
              let sorted = arrCopy.slice();
              if (!fnStr) sorted.sort();
              else {
                const fn = evaluateFunctionString(fnStr);
                sorted.sort(fn);
              }
              result = sorted;
              codePreview.textContent = `// sort\n${JSON.stringify(result, null, 2)}\n// code: arr.sort(${fnStr || 'undefined'})`;
              log(`${logPrefix} sort ->`, result);
              break;
            }
            case 'reverse': {
              result = arrCopy.slice().reverse();
              codePreview.textContent = `// reverse\n${JSON.stringify(result, null, 2)}`;
              log(`${logPrefix} reverse ->`, result);
              break;
            }
            case 'slice': {
              const parts = (extra || '').split(',').map(s=>s.trim()).filter(s=>s!=='');
              const start = parts[0] === undefined ? undefined : parseInt(parts[0],10);
              const end = parts[1] === undefined ? undefined : parseInt(parts[1],10);
              result = arrCopy.slice(start, end);
              codePreview.textContent = `// slice\n${JSON.stringify(result, null, 2)}\n// code: arr.slice(${start}, ${end})`;
              log(`${logPrefix} slice(${start}, ${end}) ->`, result);
              break;
            }
            case 'splice': {
              // Expect extra as "index,count,items"
              const parts = (extra || '').split(',').map(s=>s.trim());
              const index = parseInt(parts[0],10) || 0;
              const count = parseInt(parts[1],10) || 0;
              const rest = parts.slice(2).join(',');
              let items = [];
              if (rest) {
                const parsed = parseInput(rest);
                if (Array.isArray(parsed)) items = parsed;
                else items = [parsed];
              }
              const arr2 = arrCopy.slice();
              const removed = arr2.splice(index, count, ...items);
              result = arr2;
              codePreview.textContent = `// splice -> new array\n${JSON.stringify(result, null, 2)}\n// removed: ${JSON.stringify(removed)}\n// code: arr.splice(${index}, ${count}, ${JSON.stringify(items)})`;
              log(`${logPrefix} splice -> removed ${JSON.stringify(removed)} result ${JSON.stringify(result)}`);
              break;
            }
            case 'concat': {
              const other = parseInput(extra);
              const right = other === undefined ? [] : (Array.isArray(other) ? other : [other]);
              result = arrCopy.concat(right);
              codePreview.textContent = `// concat\n${JSON.stringify(result, null, 2)}`;
              log(`${logPrefix} concat ${JSON.stringify(right)} ->`, result);
              break;
            }
            case 'find': {
              const fn = evaluateFunctionString(fnStr);
              result = arrCopy.find(fn);
              codePreview.textContent = `// find -> ${JSON.stringify(result)}`;
              log(`${logPrefix} find ->`, result);
              break;
            }
            case 'findIndex': {
              const fn = evaluateFunctionString(fnStr);
              result = arrCopy.findIndex(fn);
              codePreview.textContent = `// findIndex -> ${JSON.stringify(result)}`;
              log(`${logPrefix} findIndex ->`, result);
              break;
            }
            case 'includes': {
              const val = parseInput(extra);
              result = arrCopy.includes(val);
              codePreview.textContent = `// includes(${JSON.stringify(val)}) -> ${result}`;
              log(`${logPrefix} includes(${JSON.stringify(val)}) ->`, result);
              break;
            }
            case 'indexOf': {
              const val = parseInput(extra);
              result = arrCopy.indexOf(val);
              codePreview.textContent = `// indexOf(${JSON.stringify(val)}) -> ${result}`;
              log(`${logPrefix} indexOf(${JSON.stringify(val)}) ->`, result);
              break;
            }
            case 'join': {
              const sep = extra === undefined ? ',' : extra;
              result = arrCopy.join(sep);
              codePreview.textContent = `// join('${sep}') ->\n${JSON.stringify(result)}`;
              log(`${logPrefix} join ->`, result);
              break;
            }
            case 'forEach': {
              const fn = evaluateFunctionString(fnStr);
              const outputs = [];
              arrCopy.forEach((v,i,a)=> {
                try {
                  const r = fn(v,i,a);
                  outputs.push([i,r]);
                } catch(e) {
                  outputs.push([i,'error']);
                }
              });
              codePreview.textContent = `// forEach traced results (function return values shown)\n${JSON.stringify(outputs, null, 2)}`;
              log(`${logPrefix} forEach ->`, outputs);
              // forEach doesn't produce a replacement array
              result = undefined;
              break;
            }
            case 'from': {
              // create new array from string or iterable provided in extra
              const src = parseInput(extra);
              result = Array.from(src);
              codePreview.textContent = `// Array.from(${JSON.stringify(src)}) ->\n${JSON.stringify(result, null, 2)}`;
              log(`${logPrefix} Array.from ->`, result);
              break;
            }
            case 'of': {
              const items = parseInput(extra);
              if (items === undefined) result = Array.of();
              else if (Array.isArray(items)) result = Array.of(...items);
              else result = Array.of(items);
              codePreview.textContent = `// Array.of ->\n${JSON.stringify(result, null, 2)}`;
              log(`${logPrefix} Array.of ->`, result);
              break;
            }
            case 'isArray': {
              result = Array.isArray(arrCopy);
              codePreview.textContent = `// Array.isArray -> ${result}`;
              log(`${logPrefix} Array.isArray ->`, result);
              break;
            }
            default:
              codePreview.textContent = '// Unknown operation';
              break;
          }

          if (apply) {
            // For operations that produce an array result, replace current.
            if (Array.isArray(result)) {
              current = result;
              render();
            } else if (result !== undefined) {
              // result is not an array (e.g., reduce returns a value). We show it but don't replace the array.
              log(`${logPrefix} Operation returned a non-array result; current array unchanged.`);
            } else {
              // for operations like forEach or isArray, replacement not applicable
              log(`${logPrefix} Applied operation (no replacement or non-array result)`);
            }
          }
        } catch (e) {
          codePreview.textContent = '// Error: ' + e.message;
          log('Error running operation:', e.message);
        }
      }

      runBtn.addEventListener('click', () => runOperation(false));
      previewBtn.addEventListener('click', () => runOperation(false));
      applyBtn.addEventListener('click', () => runOperation(true));

      // init
      render();
      log('Ready — edit the left pane or use operations to explore Arrays.');

      // Small helper: show example of destructuring, spread, typed arrays
      // Not interactive but printed once on load
      log('Examples: destructuring -> const [a,b,...rest] = arr; spread -> [...arr,6]; typed array -> new Int16Array(arr)');
    })();
  </script>
</body>
</html>