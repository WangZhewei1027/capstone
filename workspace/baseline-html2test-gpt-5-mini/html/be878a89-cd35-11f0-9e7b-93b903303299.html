<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Quick Sort Visualization</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f1724;
      --panel: #0b1220;
      --text: #e6eef8;
      --muted: #9fb3d1;
      --accent: #3b82f6;
      --bar-bg: linear-gradient(180deg, #60a5fa 0%, #2563eb 100%);
      --bar-sorted: linear-gradient(180deg, #34d399 0%, #059669 100%);
      --bar-compare: #ef4444;
      --bar-pivot: #f59e0b;
      --bar-swap: #10b981;
      --control-bg: rgba(255,255,255,0.03);
    }
    html,body {
      height:100%;
      margin:0;
      background: radial-gradient(1200px 600px at 10% 10%, rgba(59,130,246,0.05), transparent),
                  radial-gradient(1000px 500px at 90% 90%, rgba(16,185,129,0.03), transparent),
                  var(--bg);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app {
      max-width:1100px;
      margin:24px auto;
      padding:18px;
    }
    header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:12px;
    }
    h1 { font-size:20px; margin:0; letter-spacing:0.2px; }
    .controls {
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      padding:12px;
      border-radius:10px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
    }
    .control-row {
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    label { font-size:13px; color:var(--muted); }
    input[type=range] { accent-color: var(--accent); }
    button {
      background: var(--control-bg);
      border: 1px solid rgba(255,255,255,0.04);
      color:var(--text);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
    }
    button.primary {
      background: linear-gradient(90deg, rgba(59,130,246,0.12), rgba(16,185,129,0.06));
      border: 1px solid rgba(59,130,246,0.18);
      color:var(--text);
    }
    button:disabled { opacity:0.4; cursor:not-allowed; }
    .main {
      display:flex;
      gap:12px;
      margin-top:12px;
    }
    .vis {
      flex:1;
      height:420px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:10px;
      padding:12px;
      position:relative;
      overflow:hidden;
      display:flex;
      align-items:end;
      justify-content:center;
    }
    .bars {
      width:100%;
      height:100%;
      display:flex;
      align-items:end;
      gap:2px;
      padding:6px;
    }
    .bar {
      background: var(--bar-bg);
      width:20px;
      border-radius:6px 6px 2px 2px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:rgba(255,255,255,0.9);
      font-size:11px;
      box-shadow: 0 2px 6px rgba(2,6,23,0.45), inset 0 -6px 12px rgba(255,255,255,0.02);
      transition: height 200ms ease, background 200ms ease, transform 150ms ease;
    }
    .bar.small { font-size:9px; padding-bottom:4px; }
    .bar .label { transform: translateY(6px); opacity:0.95; }
    .legend { display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
    .legend .item { display:flex; gap:6px; align-items:center; color:var(--muted); font-size:13px; }
    .swatch { width:14px; height:14px; border-radius:3px; border:1px solid rgba(255,255,255,0.04); }
    .info {
      width:270px;
      min-width:220px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .stat {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      padding:10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      font-size:13px;
      color:var(--muted);
    }
    .stack {
      max-height:180px;
      overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
      background: rgba(255,255,255,0.01);
      border-radius:6px;
      padding:8px;
      color:var(--text);
    }
    footer { margin-top:12px; color:var(--muted); font-size:13px; text-align:center; }
    @media (max-width:800px){
      .main { flex-direction:column; }
      .info { width:100%; }
      .bars { gap:1px; padding:4px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Quick Sort Visualization</h1>
        <div style="color:var(--muted); font-size:13px;">Interactive demo showing pivot selection, partitioning, and swaps</div>
      </div>
      <div class="controls panel">
        <div class="control-row">
          <label>Array Size
            <input id="size" type="range" min="5" max="120" value="40" />
          </label>
          <label>Speed
            <input id="speed" type="range" min="1" max="100" value="35" />
          </label>
          <label style="display:flex;flex-direction:column;">
            Pivot
            <select id="pivot" style="margin-top:6px; padding:6px; border-radius:6px; background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.04);">
              <option value="last">Last Element</option>
              <option value="first">First Element</option>
              <option value="middle">Middle Element</option>
              <option value="random">Random</option>
              <option value="median">Median of Three</option>
            </select>
          </label>
          <button id="newArr">New Array</button>
          <button id="shuffle">Shuffle</button>
          <button id="sortBtn" class="primary">Start Sort</button>
          <button id="pauseBtn">Pause</button>
          <button id="cancelBtn">Cancel</button>
        </div>
      </div>
    </header>

    <div class="main">
      <div class="vis panel" aria-hidden="false">
        <div id="bars" class="bars"></div>
        <div style="position:absolute;left:12px;top:12px;">
          <div style="color:var(--muted); font-size:13px;">Comparisons: <span id="comp">0</span></div>
          <div style="color:var(--muted); font-size:13px; margin-top:4px;">Swaps: <span id="swaps">0</span></div>
        </div>
        <div style="position:absolute; right:12px; top:12px; text-align:right;">
          <div style="color:var(--muted); font-size:13px;">Speed: <span id="speedLabel">35</span></div>
          <div style="color:var(--muted); font-size:13px; margin-top:4px;">Pivot: <span id="pivotLabel">Last Element</span></div>
        </div>
        <div style="position:absolute; left:12px; bottom:12px;">
          <div class="legend">
            <div class="item"><div class="swatch" style="background:var(--bar-pivot)"></div> Pivot</div>
            <div class="item"><div class="swatch" style="background:var(--bar-compare)"></div> Comparing</div>
            <div class="item"><div class="swatch" style="background:var(--bar-swap)"></div> Swapped</div>
            <div class="item"><div class="swatch" style="background:var(--bar-sorted)"></div> Sorted</div>
          </div>
        </div>
      </div>

      <aside class="info">
        <div class="stat">
          <strong>Algorithm Info</strong>
          <div style="margin-top:8px; color:var(--muted); font-size:13px;">
            Quick Sort is a divide-and-conquer sorting algorithm. It picks a pivot and partitions the array so that elements less than pivot come before it and greater elements after. Then it recursively sorts the partitions.
          </div>
        </div>

        <div class="stat">
          <strong>Recursion Stack</strong>
          <div id="stack" class="stack" aria-live="polite"></div>
        </div>

        <div class="stat">
          <strong>Controls</strong>
          <div style="margin-top:8px; color:var(--muted); font-size:13px;">
            - New Array: generate a fresh random array.
            <br>- Shuffle: randomize current array.
            <br>- Start Sort: animate Quick Sort on the current array.
            <br>- Pause / Resume and Cancel available during sorting.
          </div>
        </div>
      </aside>
    </div>

    <footer class="panel">
      Tip: Try different pivot strategies (First, Last, Middle, Random, Median of Three) and watch how partitioning behavior changes.
    </footer>
  </div>

  <script>
    // Quick Sort Visualization - single-file demo
    const barsEl = document.getElementById('bars');
    const sizeInput = document.getElementById('size');
    const speedInput = document.getElementById('speed');
    const speedLabel = document.getElementById('speedLabel');
    const pivotSelect = document.getElementById('pivot');
    const pivotLabel = document.getElementById('pivotLabel');
    const newBtn = document.getElementById('newArr');
    const shuffleBtn = document.getElementById('shuffle');
    const sortBtn = document.getElementById('sortBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const compEl = document.getElementById('comp');
    const swapsEl = document.getElementById('swaps');
    const stackEl = document.getElementById('stack');

    let arr = [];
    let barEls = [];
    let comparisons = 0;
    let swaps = 0;

    let paused = false;
    let pauseResolvers = [];
    let cancelRequested = false;
    let running = false;

    function createArray(n) {
      arr = Array.from({length:n}, (_,i) => Math.floor(Math.random()*95)+5);
      comparisons = 0;
      swaps = 0;
      updateStats();
      render();
    }

    function render() {
      barsEl.innerHTML = '';
      barEls = [];
      const n = arr.length;
      const max = Math.max(...arr);
      const small = n > 70;
      for (let i=0;i<n;i++){
        const b = document.createElement('div');
        b.className = 'bar' + (small ? ' small' : '');
        const h = Math.round((arr[i]/max) * 100);
        b.style.height = h + '%';
        b.dataset.index = i;
        b.innerHTML = '<div class="label">'+arr[i]+'</div>';
        barsEl.appendChild(b);
        barEls.push(b);
      }
    }

    function updateStats() {
      compEl.textContent = comparisons;
      swapsEl.textContent = swaps;
      speedLabel.textContent = speedInput.value;
      pivotLabel.textContent = pivotSelect.options[pivotSelect.selectedIndex].text;
    }

    function colorBar(i, color) {
      const el = barEls[i];
      if (!el) return;
      el.style.background = color;
      el.style.transform = 'scale(1.02)';
      setTimeout(()=>el.style.transform='scale(1)', 120);
    }

    function resetBarColor(i) {
      const el = barEls[i];
      if (!el) return;
      el.style.background = '';
    }

    function markSorted(i) {
      const el = barEls[i];
      if (!el) return;
      el.style.background = 'var(--bar-sorted)';
      el.style.boxShadow = '0 4px 20px rgba(2,6,23,0.6)';
    }

    function swapVisual(i,j) {
      // swap heights and labels
      const a = barEls[i];
      const b = barEls[j];
      if (!a || !b) return;
      const ha = a.style.height;
      const hb = b.style.height;
      const la = a.querySelector('.label').textContent;
      const lb = b.querySelector('.label').textContent;
      a.style.height = hb;
      b.style.height = ha;
      a.querySelector('.label').textContent = lb;
      b.querySelector('.label').textContent = la;
    }

    function sleep(ms) {
      // allow pause/resume and cancel
      return new Promise((resolve, reject) => {
        const start = performance.now();
        function tick(){
          if (cancelRequested) return reject(new Error('cancelled'));
          if (paused) {
            // push resolver to be resumed
            pauseResolvers.push(() => {
              if (cancelRequested) return reject(new Error('cancelled'));
              waitMore();
            });
          } else {
            waitMore();
          }
        }
        function waitMore(){
          const elapsed = performance.now() - start;
          const remaining = ms - elapsed;
          if (remaining <= 0) return resolve();
          // wait in small chunks so we can react to pause/cancel quickly
          setTimeout(()=> {
            if (cancelRequested) return reject(new Error('cancelled'));
            if (paused) {
              pauseResolvers.push(() => {
                if (cancelRequested) return reject(new Error('cancelled'));
                waitMore();
              });
            } else {
              waitMore();
            }
          }, Math.min(50, remaining));
        }
        tick();
      });
    }

    function resumeAllFromPause() {
      while (pauseResolvers.length) {
        const r = pauseResolvers.shift();
        try { r(); } catch(e) {}
      }
    }

    function getDelay() {
      // map speed (1..100) to delay (600ms..5ms)
      const s = Number(speedInput.value);
      const min = 5;
      const max = 700;
      // higher speed => smaller delay
      const delay = Math.round(max - ((s-1)/99)*(max-min));
      return delay;
    }

    function choosePivotIndex(l, r) {
      const mode = pivotSelect.value;
      if (mode === 'last') return r;
      if (mode === 'first') return l;
      if (mode === 'middle') return Math.floor((l+r)/2);
      if (mode === 'random') return l + Math.floor(Math.random()*(r-l+1));
      if (mode === 'median') {
        const m = Math.floor((l+r)/2);
        const trio = [
          {i:l, v:arr[l]},
          {i:m, v:arr[m]},
          {i:r, v:arr[r]}
        ];
        trio.sort((a,b)=>a.v-b.v);
        return trio[1].i;
      }
      return r;
    }

    // recursion stack visualization
    let stackRanges = [];
    function pushStack(l,r) {
      stackRanges.push([l,r]);
      renderStack();
    }
    function popStack() {
      stackRanges.pop();
      renderStack();
    }
    function renderStack() {
      stackEl.innerHTML = '';
      if (stackRanges.length===0) {
        stackEl.innerHTML = '<div style="color:var(--muted);">Stack is empty (idle)</div>';
        return;
      }
      for (let i=stackRanges.length-1;i>=0;i--) {
        const [l,r] = stackRanges[i];
        const el = document.createElement('div');
        el.textContent = `quickSort(${l}, ${r})`;
        el.style.padding = '4px 6px';
        el.style.borderRadius = '5px';
        el.style.marginBottom = '6px';
        el.style.background = i===stackRanges.length-1 ? 'rgba(59,130,246,0.08)' : 'rgba(255,255,255,0.01)';
        el.style.color = 'var(--text)';
        stackEl.appendChild(el);
      }
    }

    async function partition(l, r) {
      // Lomuto partition scheme (with pivot chosen by strategy), visually animated
      const pIndex = choosePivotIndex(l,r);
      // highlight pivot chosen
      colorBar(pIndex, 'var(--bar-pivot)');
      await sleep(getDelay());
      if (pIndex !== r) {
        // move pivot to end for Lomuto convenience
        [arr[pIndex], arr[r]] = [arr[r], arr[pIndex]];
        swapVisual(pIndex, r);
        swaps++; updateStats();
        colorBar(r, 'var(--bar-pivot)');
        resetBarColor(pIndex);
        await sleep(getDelay());
      }
      const pivot = arr[r];
      let i = l - 1;
      for (let j = l; j < r; j++) {
        if (cancelRequested) throw new Error('cancelled');
        comparisons++; updateStats();
        colorBar(j, 'var(--bar-compare)');
        await sleep(getDelay());
        if (arr[j] <= pivot) {
          i++;
          if (i !== j) {
            // swap arr[i] and arr[j]
            colorBar(i, 'var(--bar-swap)');
            colorBar(j, 'var(--bar-swap)');
            await sleep(getDelay());
            [arr[i], arr[j]] = [arr[j], arr[i]];
            swapVisual(i,j);
            swaps++; updateStats();
            await sleep(getDelay());
            resetBarColor(i);
            resetBarColor(j);
          } else {
            // slight highlight for equality case
            colorBar(i,'var(--bar-swap)');
            await sleep(getDelay()/2);
            resetBarColor(i);
          }
        }
        resetBarColor(j);
      }
      // place pivot to correct position
      if (i+1 !== r) {
        colorBar(i+1,'var(--bar-swap)');
        colorBar(r,'var(--bar-pivot)');
        await sleep(getDelay());
        [arr[i+1], arr[r]] = [arr[r], arr[i+1]];
        swapVisual(i+1, r);
        swaps++; updateStats();
        await sleep(getDelay());
        resetBarColor(r);
        resetBarColor(i+1);
      } else {
        resetBarColor(r);
      }
      // mark pivot index as sorted-ish (not guaranteed global sorted until complete)
      markSorted(i+1);
      return i+1;
    }

    async function quickSort(l, r) {
      if (cancelRequested) throw new Error('cancelled');
      pushStack(l,r);
      if (l < r) {
        const p = await partition(l, r);
        // allow small pause after partition
        await sleep(Math.max(20, getDelay()/2));
        await quickSort(l, p-1);
        await quickSort(p+1, r);
      } else if (l === r) {
        // single element is sorted
        markSorted(l);
      }
      popStack();
    }

    async function startSort() {
      if (running) return;
      running = true;
      cancelRequested = false;
      paused = false;
      pauseBtn.textContent = 'Pause';
      disableControlsWhileRunning(true);
      updateStats();
      stackRanges = [];
      renderStack();
      try {
        await quickSort(0, arr.length-1);
      } catch(e) {
        // cancelled or error
      } finally {
        running = false;
        disableControlsWhileRunning(false);
        resumeAllFromPause(); // ensure no suspended promises remain
      }
    }

    function disableControlsWhileRunning(dis) {
      sizeInput.disabled = dis;
      newBtn.disabled = dis;
      shuffleBtn.disabled = dis;
      pivotSelect.disabled = dis;
      sortBtn.disabled = dis;
    }

    // Event bindings
    sizeInput.addEventListener('input', () => {
      const n = Number(sizeInput.value);
      createArray(n);
    });

    speedInput.addEventListener('input', () => {
      speedLabel.textContent = speedInput.value;
    });

    pivotSelect.addEventListener('change', () => {
      pivotLabel.textContent = pivotSelect.options[pivotSelect.selectedIndex].text;
    });

    newBtn.addEventListener('click', () => {
      if (running) return;
      createArray(Number(sizeInput.value));
    });

    shuffleBtn.addEventListener('click', () => {
      if (running) return;
      // Fisher-Yates shuffle
      for (let i = arr.length-1;i>0;i--) {
        const j = Math.floor(Math.random()*(i+1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      comparisons = 0; swaps = 0; updateStats();
      render();
    });

    sortBtn.addEventListener('click', () => {
      if (running) return startSort();
    });

    pauseBtn.addEventListener('click', () => {
      if (!running) return;
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      if (!paused) resumeAllFromPause();
    });

    cancelBtn.addEventListener('click', () => {
      if (!running) return;
      cancelRequested = true;
      paused = false;
      resumeAllFromPause();
      // reset visual highlights
      setTimeout(() => {
        for (let i=0;i<barEls.length;i++){
          resetBarColor(i);
        }
      }, 150);
    });

    // keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.key === ' ') {
        e.preventDefault();
        if (running) {
          paused = !paused;
          pauseBtn.textContent = paused ? 'Resume' : 'Pause';
          if (!paused) resumeAllFromPause();
        }
      }
      if (e.key === 'Escape') {
        if (running) {
          cancelRequested = true;
          paused = false;
          resumeAllFromPause();
        }
      }
    });

    // initialize
    createArray(Number(sizeInput.value));
    renderStack();

    // Make bars clickable to pin pivot (optional small interaction)
    barsEl.addEventListener('click', (e) => {
      if (running) return;
      const b = e.target.closest('.bar');
      if (!b) return;
      const idx = Number(b.dataset.index);
      // swap chosen bar to end and start a single partition step to visualize
      colorBar(idx,'var(--bar-pivot)');
      setTimeout(()=>resetBarColor(idx), 700);
    });

  </script>
</body>
</html>