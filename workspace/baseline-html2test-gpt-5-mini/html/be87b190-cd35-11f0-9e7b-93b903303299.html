<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Breadth-First Search (BFS) Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root {
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --good: #22c55e;
      --bad: #ef4444;
      --node-fill: #152238;
      --edge: rgba(255,255,255,0.08);
      --visited: #2563eb;
      --discovered: #f59e0b;
      --current: #fb923c;
      --path: #16a34a;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071126 0%, #071026 100%);
      color:#e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app {
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:14px;
      max-width:1200px;
      margin:12px auto;
    }
    header {
      display:flex;
      align-items:center;
      gap:12px;
    }
    h1 {
      font-size:20px;
      margin:0;
      letter-spacing:0.2px;
    }
    .controls {
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      background: linear-gradient(180deg,#081225 0%, #071122 100%);
      padding:10px;
      border-radius:10px;
      box-shadow: 0 2px 8px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    }
    .controls > * { margin:0 2px; }
    label { font-size:13px; color:var(--muted); display:flex; gap:6px; align-items:center; }
    input[type="range"] { width:120px; }
    button, select {
      background:#0b1220;
      color:#e6eef8;
      border:1px solid rgba(255,255,255,0.04);
      padding:6px 8px;
      border-radius:7px;
      cursor:pointer;
      font-size:13px;
    }
    button.primary {
      background: linear-gradient(90deg, #2563eb, #60a5fa);
      color:white;
      border:0;
      box-shadow: 0 6px 18px rgba(96,165,250,0.14);
    }
    button.ghost {
      background:transparent;
      border:1px dashed rgba(255,255,255,0.04);
    }
    .main {
      display:flex;
      gap:12px;
    }
    .canvas-panel {
      background: linear-gradient(180deg,#081228 0%, #071022 100%);
      flex:1;
      padding:10px;
      border-radius:10px;
      min-height:560px;
      position:relative;
      display:flex;
      flex-direction:column;
    }
    .svg-wrap {
      flex:1;
      border-radius:8px;
      background: linear-gradient(180deg,#061024 0%, #061023 100%);
      overflow:hidden;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
    }
    svg { width:100%; height:100%; display:block; }
    .side {
      width:360px;
      min-width:260px;
      background: linear-gradient(180deg,#061026 0%, #05101a 100%);
      border-radius:10px;
      padding:10px;
    }
    .panel-section {
      margin-bottom:10px;
      background: linear-gradient(180deg,#071328 0%, #061022 100%);
      padding:8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
    }
    .panel-section h3 {
      margin:0 0 8px 0;
      font-size:14px;
      color:#cfe6ff;
    }
    .info {
      font-size:13px;
      color:var(--muted);
      line-height:1.35;
    }
    .controls-row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .legend { display:flex; gap:8px; flex-wrap:wrap; }
    .legend-item { display:flex; gap:8px; align-items:center; font-size:13px; color:var(--muted); }
    .swatch { width:14px; height:14px; border-radius:4px; border:1px solid rgba(255,255,255,0.04); box-shadow: inset 0 -2px 3px rgba(0,0,0,0.4); }
    .status { display:flex; gap:8px; align-items:center; font-size:13px; color:var(--muted); }
    .lists { display:flex; gap:8px; }
    .list-box { flex:1; background: rgba(255,255,255,0.02); padding:8px; border-radius:6px; font-size:13px; color:var(--muted); min-height:44px; max-height:220px; overflow:auto; }
    .list-title { font-size:12px; color:#cfe6ff; margin-bottom:6px; }
    .node-label { font-size:12px; color:#cfe6ff; background:rgba(255,255,255,0.02); padding:4px 6px; border-radius:6px; display:inline-block; margin: 2px; }
    .footer-note { font-size:12px; color:var(--muted); margin-top:8px; }
    .small { font-size:12px; color:var(--muted); }
    .mode-toggle { display:flex; gap:6px; }
    .mode-toggle button.active { outline:2px solid rgba(96,165,250,0.18); }
    .btn-icon { display:inline-flex; align-items:center; gap:6px; }
    @media (max-width:980px){
      .main { flex-direction:column; }
      .side { width:100%; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Breadth-First Search (BFS) Visualizer</h1>
    </header>

    <div class="controls">
      <div class="controls-row">
        <label>
          Graph type:
          <select id="graphType">
            <option value="random">Random Graph</option>
            <option value="grid">Grid</option>
          </select>
        </label>

        <label id="nodesLabel">
          Nodes:
          <input id="nodeCount" type="number" value="16" min="4" max="200" style="width:70px;">
        </label>

        <label id="probLabel">
          Edge p:
          <input id="edgeProb" type="range" min="0" max="1" step="0.01" value="0.16">
          <span id="probVal" class="small">0.16</span>
        </label>

        <label id="gridSizeLabel" style="display:none;">
          Grid:
          <input id="gridRows" type="number" min="2" max="30" value="4" style="width:60px;"> x
          <input id="gridCols" type="number" min="2" max="30" value="4" style="width:60px;">
        </label>

        <label>
          Undirected:
          <input id="undirected" type="checkbox" checked>
        </label>

        <button id="regen" title="Regenerate graph">Regenerate</button>
        <button id="reset" class="ghost" title="Reset algorithm state">Reset BFS</button>
        <button id="autoPlay" class="primary">Auto-play</button>
        <button id="stepBtn">Step</button>
        <label>
          Speed:
          <input id="speed" type="range" min="50" max="1200" step="10" value="500">
        </label>
      </div>

      <div style="display:flex; gap:10px; align-items:center; margin-left:6px;">
        <div class="mode-toggle">
          <button id="setStartBtn" class="active">Set Start</button>
          <button id="setTargetBtn">Set Target</button>
          <button id="clearMarks" class="ghost">Clear Start/Target</button>
        </div>
        <div style="margin-left:8px; font-size:13px; color:var(--muted);">
          Click a node to set.
        </div>
      </div>
    </div>

    <div class="main">
      <div class="canvas-panel">
        <div style="display:flex; gap:10px; align-items:center; margin-bottom:8px;">
          <div class="status">
            <div class="small">Mode: <span id="modeText">Set Start</span></div>
          </div>
          <div style="flex:1"></div>
          <div class="legend">
            <div class="legend-item"><div class="swatch" style="background:var(--node-fill);"></div><div class="small">Unvisited</div></div>
            <div class="legend-item"><div class="swatch" style="background:var(--discovered);"></div><div class="small">Discovered (in queue)</div></div>
            <div class="legend-item"><div class="swatch" style="background:var(--visited);"></div><div class="small">Visited</div></div>
            <div class="legend-item"><div class="swatch" style="background:var(--current);"></div><div class="small">Currently exploring</div></div>
            <div class="legend-item"><div class="swatch" style="background:var(--path);"></div><div class="small">Shortest path</div></div>
          </div>
        </div>

        <div class="svg-wrap" id="svgWrap">
          <svg id="svg" viewBox="0 0 800 560" preserveAspectRatio="xMidYMid meet"></svg>
        </div>

        <div class="footer-note">Tip: Choose start and target nodes, then use Step or Auto-play to see how BFS discovers nodes level-by-level and finds the shortest path (in unweighted graphs).</div>
      </div>

      <aside class="side">
        <div class="panel-section">
          <h3>Algorithm Status</h3>
          <div class="info" id="statusText">Ready. Click nodes to choose start and target. Press "Auto-play" or "Step" to run BFS.</div>
        </div>

        <div class="panel-section">
          <h3>Queue</h3>
          <div class="list-box" id="queueBox">
            <div class="small">Queue is empty.</div>
          </div>
        </div>

        <div class="panel-section">
          <h3>Visited Order</h3>
          <div class="list-box" id="visitedBox">
            <div class="small">No nodes visited yet.</div>
          </div>
        </div>

        <div class="panel-section">
          <h3>Controls & Tips</h3>
          <div class="info">
            - Graph type: Random (Erdos-Renyi) or Grid.<br>
            - For random graphs, set number of nodes and edge probability.<br>
            - For grid, choose rows x cols; BFS respects grid adjacency.<br>
            - Click "Set Start" then a node to choose the source. Then "Set Target" and choose the goal.<br>
            - Use Step to move one BFS operation at a time, or Auto-play to animate.<br>
            - BFS finds the shortest path (fewest edges) in unweighted graphs when a target is set.
          </div>
        </div>

      </aside>
    </div>
  </div>

<script>
/* BFS Visualizer
   - Single-file app
   - Supports random graphs and grid graphs
   - Step-by-step BFS animation with queue display and path reconstruction
*/

// Utility
function $(id){ return document.getElementById(id); }
const svg = $("svg");
const svgNS = "http://www.w3.org/2000/svg";

let state = {
  nodes: [], // {id,x,y,status,parent,neighbors:[]}
  edges: [], // {a,b}
  width: 800, height:560,
  undirected: true,
  graphType: 'random',
  nodeCount: 16,
  edgeProb: 0.16,
  gridRows: 4,
  gridCols: 4,
  start: null,
  target: null,
  mode: 'start', // or 'target'
  bfs: null, // generator
  auto: false,
  intervalId: null,
  speed: 500,
};

// Colors
const COLORS = {
  unvisited: '#152238',
  edge: 'rgba(255,255,255,0.08)',
  discovered: '#f59e0b',
  visited: '#2563eb',
  current: '#fb923c',
  path: '#16a34a',
  startStroke: '#0ef09a',
  targetStroke: '#ff6b6b'
};

// DOM elements
const graphType = $("graphType");
const nodeCountInput = $("nodeCount");
const edgeProb = $("edgeProb");
const probVal = $("probVal");
const regenBtn = $("regen");
const resetBtn = $("reset");
const autoBtn = $("autoPlay");
const stepBtn = $("stepBtn");
const setStartBtn = $("setStartBtn");
const setTargetBtn = $("setTargetBtn");
const clearMarksBtn = $("clearMarks");
const modeText = $("modeText");
const queueBox = $("queueBox");
const visitedBox = $("visitedBox");
const statusText = $("statusText");
const undirectedChk = $("undirected");
const graphTypeSel = $("graphType");
const gridSizeLabel = $("gridSizeLabel");
const gridRowsInput = $("gridRows");
const gridColsInput = $("gridCols");
const nodesLabel = $("nodesLabel");
const probLabel = $("probLabel");
const speedInput = $("speed");

function randId(prefix='n') {
  return prefix + Math.random().toString(36).slice(2,9);
}

// Setup UI events
graphTypeSel.addEventListener('change', e=>{
  state.graphType = e.target.value;
  updateControlsVis();
});
nodeCountInput.addEventListener('change', e=>{
  const val = Math.max(4, Math.min(200, parseInt(e.target.value) || 16));
  state.nodeCount = val;
  nodeCountInput.value = val;
});
edgeProb.addEventListener('input', e=>{
  state.edgeProb = parseFloat(e.target.value);
  probVal.textContent = state.edgeProb.toFixed(2);
});
undirectedChk.addEventListener('change', e=>{
  state.undirected = e.target.checked;
});
gridRowsInput.addEventListener('change', e=>{
  const v = Math.max(2, Math.min(30, parseInt(e.target.value)||4));
  gridRowsInput.value = v;
  state.gridRows = v;
});
gridColsInput.addEventListener('change', e=>{
  const v = Math.max(2, Math.min(30, parseInt(e.target.value)||4));
  gridColsInput.value = v;
  state.gridCols = v;
});
regenBtn.addEventListener('click', ()=>{ stopAuto(); generateGraph(); resetBFS(); render(); });
resetBtn.addEventListener('click', ()=>{ resetBFS(); render(); });
autoBtn.addEventListener('click', toggleAuto);
stepBtn.addEventListener('click', ()=>{ stepBFS(); });

setStartBtn.addEventListener('click', ()=>{ setMode('start'); });
setTargetBtn.addEventListener('click', ()=>{ setMode('target'); });
clearMarksBtn.addEventListener('click', ()=>{ state.start=null; state.target=null; resetBFS(); render(); });

speedInput.addEventListener('input', ()=>{ state.speed = parseInt(speedInput.value); if(state.auto){ stopAuto(); startAuto(); } });

function updateControlsVis(){
  if(state.graphType === 'grid'){
    gridSizeLabel.style.display = 'inline-flex';
    nodesLabel.style.display = 'none';
    probLabel.style.display = 'none';
  } else {
    gridSizeLabel.style.display = 'none';
    nodesLabel.style.display = 'inline-flex';
    probLabel.style.display = 'inline-flex';
  }
}
updateControlsVis();

function setMode(m){
  state.mode = m;
  modeText.textContent = (m==='start')? 'Set Start' : 'Set Target';
  setStartBtn.classList.toggle('active', m==='start');
  setTargetBtn.classList.toggle('active', m==='target');
}

// Graph generation
function generateGraph(){
  state.nodes = [];
  state.edges = [];
  state.start = null;
  state.target = null;
  if(state.graphType === 'grid'){
    const rows = state.gridRows;
    const cols = state.gridCols;
    const total = rows*cols;
    state.nodeCount = total;
    const margin=24;
    const w = state.width - margin*2;
    const h = state.height - margin*2;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const id = r*cols + c;
        const x = margin + (c + 0.5)*(w/cols);
        const y = margin + (r + 0.5)*(h/rows);
        state.nodes.push({id:id.toString(), x,y, neighbors:[], status:'unvisited', parent:null});
      }
    }
    // neighbors: 4-directional
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const i = r*cols + c;
        const node = state.nodes[i];
        const deltas = [[0,1],[1,0],[0,-1],[-1,0]]; // 4-neigh
        deltas.forEach(d=>{
          const nr = r + d[0], nc = c + d[1];
          if(nr>=0 && nr<rows && nc>=0 && nc<cols){
            const j = nr*cols + nc;
            node.neighbors.push(state.nodes[j].id);
            state.edges.push({a: node.id, b: state.nodes[j].id});
          }
        });
      }
    }
    // For undirected grid we'll have duplicate edges; de-duplicate edges below.
  } else {
    // Random graph Erdos-Renyi G(n,p)
    const n = state.nodeCount;
    const margin=24;
    const w = state.width - margin*2;
    const h = state.height - margin*2;
    for(let i=0;i<n;i++){
      const id = i.toString();
      const x = margin + Math.random()*w;
      const y = margin + Math.random()*h;
      state.nodes.push({id, x,y, neighbors:[], status:'unvisited', parent:null});
    }
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        if(Math.random() < state.edgeProb){
          const a = state.nodes[i].id, b = state.nodes[j].id;
          state.nodes[i].neighbors.push(b);
          if(state.undirected) state.nodes[j].neighbors.push(a);
          state.edges.push({a,b});
          if(state.undirected) state.edges.push({a:b, b:a}); // We'll de-dupe later visually
          // For directed graphs, only one direction
        }
      }
    }
  }

  // If undirected, ensure neighbors symmetric and de-duplicate edges array for rendering
  if(state.undirected){
    const edgeset = new Set();
    const edgestoRender = [];
    state.nodes.forEach(n=>{
      n.neighbors.forEach(nb=>{
        const key = [n.id, nb].sort().join('|');
        if(!edgeset.has(key)){
          edgeset.add(key);
          edgestoRender.push({a:n.id, b:nb});
        }
      });
    });
    state.edges = edgestoRender;
    // symmetrize neighbors
    const neighborMap = {};
    state.nodes.forEach(n=> neighborMap[n.id]=new Set(n.neighbors));
    state.nodes.forEach(n=>{
      state.nodes.forEach(m=>{
        // ensure if a->b or b->a exists both have each other
      });
    });
    // Actually, ensure for each edge in edgestoRender both nodes include each other
    edgestoRender.forEach(e=>{
      const a = e.a, b = e.b;
      const na = state.nodes.find(x=>x.id===a);
      const nb = state.nodes.find(x=>x.id===b);
      if(na && nb){
        if(!na.neighbors.includes(b)) na.neighbors.push(b);
        if(!nb.neighbors.includes(a)) nb.neighbors.push(a);
      }
    });
  } else {
    // For directed graphs, edges array is fine (we'll keep single direction)
    // But ensure state.edges unique
    const uniq = {};
    const ed = [];
    state.edges.forEach(e=>{
      const key = e.a + '->' + e.b;
      if(!uniq[key]){ uniq[key]=true; ed.push(e); }
    });
    state.edges = ed;
  }

  // initialize statuses
  state.nodes.forEach(n=>{ n.status='unvisited'; n.parent=null; });
}

// Rendering
function clearSVG(){
  while(svg.firstChild) svg.removeChild(svg.firstChild);
}
function render(){
  clearSVG();
  // edges
  const edgeGroup = document.createElementNS(svgNS, 'g');
  edgeGroup.setAttribute('class','edges');
  svg.appendChild(edgeGroup);
  state.edges.forEach(e=>{
    const na = state.nodes.find(n=>n.id===e.a);
    const nb = state.nodes.find(n=>n.id===e.b);
    if(!na || !nb) return;
    const line = document.createElementNS(svgNS, 'line');
    line.setAttribute('x1', na.x);
    line.setAttribute('y1', na.y);
    line.setAttribute('x2', nb.x);
    line.setAttribute('y2', nb.y);
    line.setAttribute('stroke', COLORS.edge);
    line.setAttribute('stroke-width','2');
    edgeGroup.appendChild(line);
  });

  // nodes
  const nodeGroup = document.createElementNS(svgNS, 'g');
  nodeGroup.setAttribute('class','nodes');
  svg.appendChild(nodeGroup);
  state.nodes.forEach(n=>{
    const g = document.createElementNS(svgNS,'g');
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    g.style.cursor='pointer';
    g.addEventListener('click', (ev)=>{ onNodeClick(n.id); ev.stopPropagation(); });

    // circle
    const circle = document.createElementNS(svgNS,'circle');
    circle.setAttribute('r', 18);
    circle.setAttribute('fill', getNodeFill(n));
    circle.setAttribute('stroke', '#0b1220');
    circle.setAttribute('stroke-width','2');
    circle.setAttribute('data-id', n.id);
    g.appendChild(circle);

    // stroke for start/target
    if(state.start === n.id || state.target === n.id){
      const stroke = document.createElementNS(svgNS,'circle');
      stroke.setAttribute('r', 24);
      stroke.setAttribute('fill','none');
      stroke.setAttribute('stroke-width','3');
      stroke.setAttribute('stroke', state.start===n.id ? COLORS.startStroke : COLORS.targetStroke);
      stroke.setAttribute('opacity','0.92');
      g.insertBefore(stroke, circle);
    }

    // text
    const txt = document.createElementNS(svgNS,'text');
    txt.setAttribute('x',0); txt.setAttribute('y',6);
    txt.setAttribute('font-size','12');
    txt.setAttribute('text-anchor','middle');
    txt.setAttribute('fill','#e6eef8');
    txt.style.pointerEvents='none';
    txt.textContent = n.id;
    g.appendChild(txt);

    nodeGroup.appendChild(g);
    // attach element to node for updates
    n._el = g;
    n._circle = circle;
  });

  updateStatusUI();
  updateQueueVisitedUI();
}

function getNodeFill(n){
  if(n.status === 'current') return COLORS.current;
  if(n.status === 'visited') return COLORS.visited;
  if(n.status === 'discovered') return COLORS.discovered;
  if(n.status === 'path') return COLORS.path;
  return COLORS.unvisited;
}

// Node click handling
function onNodeClick(id){
  if(state.mode === 'start'){
    state.start = id;
    resetBFS(); // reset when changing start
    statusText.textContent = `Start set to node ${id}. Choose a target (optional) or run BFS.`;
  } else {
    state.target = id;
    resetBFS();
    statusText.textContent = `Target set to node ${id}. Run BFS to find shortest path.`;
  }
  render();
}

// BFS implementation (step generator)
function createBFSGenerator(){
  // Ensure start exists
  if(state.start == null){
    statusText.textContent = 'Please select a start node before running BFS.';
    return null;
  }
  // Reset statuses/parents
  state.nodes.forEach(n=>{ n.status='unvisited'; n.parent=null; });

  const nodeMap = {};
  state.nodes.forEach(n=> nodeMap[n.id] = n);

  let queue = [];
  const visitedOrder = [];
  // Enqueue start
  queue.push(state.start);
  nodeMap[state.start].status = 'discovered';
  yieldUpdateUI(queue, visitedOrder, `Enqueued start ${state.start}.`);

  let current = null;
  // We'll implement a generator that yields after meaningful micro-steps:
  // - Start: enqueue start (done)
  // - Loop: dequeue current -> mark current 'current', yield
  // - For each neighbor: check, if unvisited -> set parent, mark discovered, enqueue -> yield each discovery
  // - After neighbors done -> mark visited, push to visitedOrder -> yield
  // - If target found, reconstruct path, mark nodes path -> yield and finish.
  const gen = (function* (){
    while(queue.length > 0){
      const u = queue.shift();
      current = u;
      nodeMap[u].status = 'current';
      yield {type:'dequeue', node:u, queue:queue.slice(), visited:visitedOrder.slice(), msg:`Dequeued ${u} for exploration.`};

      const neighs = nodeMap[u].neighbors.slice(); // copy
      for(let nb of neighs){
        yield {type:'check', node:u, neighbor:nb, queue:queue.slice(), visited:visitedOrder.slice(), msg:`Checking neighbor ${nb} of ${u}.`};
        if(nodeMap[nb].status === 'unvisited'){
          nodeMap[nb].parent = u;
          nodeMap[nb].status = 'discovered';
          queue.push(nb);
          yield {type:'discover', node:nb, parent:u, queue:queue.slice(), visited:visitedOrder.slice(), msg:`Discovered ${nb}, parent=${u}. Enqueued ${nb}.`};
        } else {
          yield {type:'skip', node:nb, reason: nodeMap[nb].status, queue:queue.slice(), visited:visitedOrder.slice(), msg:`Skipped ${nb} (${nodeMap[nb].status}).`};
        }
        // If target is set and discovered, can early-stop when we dequeue target or when discovered? BFS gives shortest when you dequeue? Actually shortest path can be reconstructed when discovered because BFS explores in increasing depth, but to be safe we can stop when discovered if wanting shortest path; commonly we stop when dequeuing target, but discovered is sufficient for unweighted. We'll stop when discovered or dequeued either is fine.
        if(state.target != null && nodeMap[nb].id === state.target && nodeMap[nb].status === 'discovered'){
          // reconstruct path
          yield {type:'found', node: nb, queue: queue.slice(), visited: visitedOrder.slice(), msg:`Target ${state.target} discovered. Reconstructing path.`};
          // mark path
          let cur = nodeMap[nb];
          const path = [];
          while(cur){
            path.push(cur.id);
            if(cur.parent == null) break;
            cur = nodeMap[cur.parent];
          }
          path.reverse();
          path.forEach(pid=>{
            nodeMap[pid].status = 'path';
            yield {type:'markPath', path: path.slice(), msg:`Marking path: ${path.join(' -> ')}`};
          });
          yield {type:'done', result:'found', path, msg:`Shortest path found: ${path.join(' -> ')}`};
          return;
        }
      }

      // finished with u
      nodeMap[u].status = 'visited';
      visitedOrder.push(u);
      yield {type:'finish', node:u, queue:queue.slice(), visited:visitedOrder.slice(), msg:`Finished exploring ${u}. Marked visited.`};
    }
    // queue empty
    yield {type:'done', result:'exhausted', msg:'Queue exhausted. Target not found.'};
  });

  return gen;
}

// Step and Animation control
function resetBFS(){
  // stop auto
  stopAuto();
  // clear generator
  state.bfs = null;
  // reset node statuses to unvisited unless path statuses remain? Clear all
  state.nodes.forEach(n=>{ n.status='unvisited'; n.parent=null; });
  updateQueueVisitedUI();
  statusText.textContent = 'BFS reset. Ready.';
}

function stepBFS(){
  if(state.bfs == null){
    state.bfs = createBFSGenerator();
    if(state.bfs == null) return;
  }
  const res = state.bfs.next();
  if(res.done){
    // nothing
    state.bfs = null;
    render();
    return;
  }
  const payload = res.value;
  handleBfsStep(payload);
  render(); // update visuals
  if(payload.type === 'done'){
    state.bfs = null;
    if(payload.result === 'found'){
      statusText.textContent = `Target found. Shortest path: ${payload.path.join(' -> ')}`;
    } else {
      statusText.textContent = 'Search complete. Target not found.';
    }
    updateQueueVisitedUI();
  }
}

function handleBfsStep(p){
  // p may include type: dequeue, check, discover, skip, finish, found, markPath, done
  // Update node statuses accordingly
  const nodeMap = {};
  state.nodes.forEach(n=>nodeMap[n.id]=n);
  switch(p.type){
    case 'dequeue':
      // mark current node
      // reset other 'current' status
      state.nodes.forEach(n=>{ if(n.status === 'current') n.status='visited'; });
      if(nodeMap[p.node]) nodeMap[p.node].status='current';
      statusText.textContent = p.msg;
      updateQueueVisitedUI(p.queue, p.visited);
      break;
    case 'check':
      statusText.textContent = p.msg;
      updateQueueVisitedUI(p.queue, p.visited);
      break;
    case 'discover':
      if(nodeMap[p.node]) nodeMap[p.node].status='discovered';
      if(nodeMap[p.node]) nodeMap[p.node].parent = p.parent;
      statusText.textContent = p.msg;
      updateQueueVisitedUI(p.queue, p.visited);
      break;
    case 'skip':
      statusText.textContent = p.msg;
      updateQueueVisitedUI(p.queue, p.visited);
      break;
    case 'finish':
      if(nodeMap[p.node]) nodeMap[p.node].status='visited';
      statusText.textContent = p.msg;
      updateQueueVisitedUI(p.queue, p.visited);
      break;
    case 'found':
      statusText.textContent = p.msg;
      updateQueueVisitedUI(p.queue, p.visited);
      break;
    case 'markPath':
      // mark path nodes as 'path'
      p.path.forEach(id=>{
        if(nodeMap[id]) nodeMap[id].status = 'path';
      });
      statusText.textContent = p.msg;
      updateQueueVisitedUI(p.queue, p.visited);
      break;
    case 'done':
      statusText.textContent = p.msg;
      updateQueueVisitedUI();
      break;
  }
}

function updateQueueVisitedUI(queue=[], visited=[]){
  // If called with no args, infer from generator internal snapshot by scanning nodes statuses? We maintain queue via payloads,
  // but we can also show discovered nodes that are not visited and not current as queue approximate.
  if(queue.length === 0){
    // compute queue by listing discovered nodes that are not visited or path or current, but order unknown. We'll list discovered.
    queue = state.nodes.filter(n=>n.status === 'discovered').map(n=>n.id);
  }
  queueBox.innerHTML = '';
  if(queue.length === 0){
    queueBox.innerHTML = '<div class="small">Queue is empty.</div>';
  } else {
    queue.forEach((id,i)=>{
      const e = document.createElement('div');
      e.className = 'node-label';
      e.textContent = id;
      queueBox.appendChild(e);
    });
  }
  visitedBox.innerHTML = '';
  const visitedNodes = visited && visited.length>0 ? visited : state.nodes.filter(n=> n.status === 'visited' || n.status==='path').map(n=>n.id);
  if(visitedNodes.length === 0){
    visitedBox.innerHTML = '<div class="small">No nodes visited yet.</div>';
  } else {
    visitedNodes.forEach(id=>{
      const e = document.createElement('div');
      e.className = 'node-label';
      e.textContent = id;
      visitedBox.appendChild(e);
    });
  }
}

// Auto-play management
function startAuto(){
  if(state.auto) return;
  state.auto = true;
  autoBtn.textContent = 'Stop';
  autoBtn.classList.add('primary');
  state.intervalId = setInterval(()=>{
    // step
    if(state.bfs == null){
      state.bfs = createBFSGenerator();
      if(state.bfs == null){
        stopAuto();
        return;
      }
    }
    const res = state.bfs.next();
    if(res.done){
      state.bfs = null;
      stopAuto();
      render();
      return;
    }
    handleBfsStep(res.value);
    render();
    if(res.value.type === 'done'){
      state.bfs = null;
      stopAuto();
    }
  }, state.speed);
}
function stopAuto(){
  state.auto = false;
  autoBtn.textContent = 'Auto-play';
  autoBtn.classList.remove('primary');
  if(state.intervalId) { clearInterval(state.intervalId); state.intervalId = null; }
}
function toggleAuto(){
  if(state.auto) stopAuto();
  else startAuto();
}

// Initial setup & click outside to deselect mode?
svg.addEventListener('click', ()=>{ /* clicking background does nothing*/ });

// Initialize and render
function init(){
  // set initial state from controls
  state.graphType = graphTypeSel.value;
  state.nodeCount = parseInt(nodeCountInput.value) || 16;
  state.edgeProb = parseFloat(edgeProb.value);
  state.undirected = undirectedChk.checked;
  state.gridRows = parseInt(gridRowsInput.value) || 4;
  state.gridCols = parseInt(gridColsInput.value) || 4;
  state.speed = parseInt(speedInput.value) || 500;

  generateGraph();
  resetBFS();
  render();
}

init();

/* Make UI responsive to window resize: recalc svg viewBox? We'll keep viewBox static; nodes use absolute coords within 800x560. */
</script>
</body>
</html>