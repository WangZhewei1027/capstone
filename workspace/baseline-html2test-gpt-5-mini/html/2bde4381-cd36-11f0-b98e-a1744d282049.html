<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Union-Find (Disjoint Set) Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --card: #071024;
      --good: #10b981;
      --warn: #f59e0b;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    html,body { height:100%; margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: radial-gradient(1000px 600px at 10% 10%, rgba(6,182,212,0.06), transparent), radial-gradient(800px 500px at 90% 90%, rgba(16,185,129,0.04), transparent), var(--bg); color:#e6eef6; }
    .app { display:flex; gap:16px; padding:18px; box-sizing:border-box; height:100vh; }
    .left { width:360px; min-width:260px; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border-radius:12px; padding:14px; box-shadow: 0 6px 30px rgba(2,6,23,0.6); display:flex; flex-direction:column; }
    h1 { font-size:18px; margin:0 0 8px 0; letter-spacing:0.2px;}
    .section { background:var(--card); border-radius:10px; padding:10px; margin-bottom:10px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }
    label { display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input[type=number], input[type=text], select { width:100%; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; box-sizing:border-box; }
    button { background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); color:inherit; padding:8px 10px; border-radius:8px; cursor:pointer; }
    .row { display:flex; gap:8px; align-items:center; }
    .row.space { justify-content:space-between; }
    .small { font-size:12px; color:var(--muted); }
    .controls { display:flex; flex-direction:column; gap:8px; }
    .arrays { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .array { background:var(--glass); padding:8px; border-radius:8px; font-family:monospace; font-size:13px; min-width:120px; }
    .svg-wrap { flex:1; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.005)); padding:10px; display:flex; flex-direction:column; gap:10px; box-shadow: 0 6px 30px rgba(2,6,23,0.55); }
    .viz-toolbar { display:flex; gap:8px; align-items:center; }
    .legend { display:flex; gap:8px; align-items:center; font-size:13px; color:var(--muted); }
    .legend .dot { width:12px; height:12px; border-radius:50%; display:inline-block; margin-right:6px; }
    svg { width:100%; height:100%; border-radius:8px; background: linear-gradient(180deg, rgba(255,255,255,0.008), transparent); }
    .info { font-size:13px; color:var(--muted); }
    .footer { margin-top:auto; font-size:12px; color:var(--muted); text-align:center; }
    .btn-primary { background:linear-gradient(90deg,var(--accent),#34d399); border:none; color:#042027; }
    .switch { display:inline-flex; gap:8px; align-items:center; }
    .badge { font-size:12px; color:#021018; background:linear-gradient(90deg,var(--muted), rgba(255,255,255,0.06)); padding:6px 8px; border-radius:8px; }
    .highlight { stroke: #f59e0b; stroke-width:3px; }
    /* node styles */
    .node { cursor:pointer; }
    .node circle { fill: linear-gradient(#022, #024); fill: #041726; stroke: rgba(255,255,255,0.04); stroke-width:1.5px; transition: transform 200ms ease; }
    .node text { font-size:14px; fill:#d7eef6; pointer-events:none; }
    .root circle { fill: #063b4a; stroke: #06b6d4; stroke-width:2px; }
    .find-path circle { fill: #7c3aed; stroke: #a78bfa; stroke-width:2px; }
    .compressed circle { fill: #0ea5a4; stroke: #22c1c3; stroke-width:2px; }
    .edge { stroke: rgba(255,255,255,0.07); stroke-width:2px; marker-end: url(#arrow); }
    .edge.highlight { stroke: #f59e0b; stroke-width:3px; opacity:1; }
    .info-block { font-size:13px; color:var(--muted); background: rgba(255,255,255,0.02); padding:8px; border-radius:8px; }
    .small-muted { font-size:12px; color:var(--muted); }
    .controls .row > * { flex:1; }
    .tip { font-size:12px; color:var(--muted); margin-top:6px; }
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <h1>Union-Find (Disjoint Set) Visualizer</h1>
      <div class="section">
        <div class="controls">
          <div class="row space">
            <label style="margin:0">
              Nodes (n)
            </label>
            <div style="display:flex; gap:8px; align-items:center;">
              <input id="nInput" type="number" min="1" value="10" style="width:84px;" />
              <button id="resetBtn">Create</button>
            </div>
          </div>

          <div class="row">
            <label style="margin:0">Union (a, b)</label>
            <input id="unionInput" type="text" placeholder="e.g. 2,5" />
            <div style="display:flex; gap:8px;">
              <button id="unionBtn">Union</button>
              <button id="randUnionBtn">Random</button>
            </div>
          </div>

          <div class="row">
            <label style="margin:0">Find (x)</label>
            <input id="findInput" type="number" placeholder="index" />
            <div style="display:flex; gap:8px;">
              <button id="findBtn">Find (no compress)</button>
              <button id="findCompBtn" class="btn-primary">Find & Compress</button>
            </div>
          </div>

          <div class="row">
            <label style="margin:0">Options</label>
            <div style="display:flex; gap:8px; align-items:center;">
              <label class="switch small-muted"><input id="byRank" type="checkbox" checked /> Union by rank</label>
              <label class="switch small-muted"><input id="pathComp" type="checkbox" checked /> Path compression</label>
            </div>
          </div>

          <div class="row">
            <label style="margin:0">Animation speed</label>
            <input id="speed" type="range" min="50" max="1500" value="400" />
          </div>

          <div class="row">
            <label style="margin:0">Quick actions</label>
            <div style="display:flex; gap:8px;">
              <button id="mergeRandom">Merge random pairs</button>
              <button id="resetAll">Reset parents</button>
            </div>
          </div>

          <div class="tip">
            Click any node in the visualization to run Find(x) (with or without compression depending on toggle).
          </div>

        </div>
      </div>

      <div class="section">
        <div class="small-muted">Internal arrays</div>
        <div class="arrays" id="arrays">
          <div class="array" id="parentArr">parent: []</div>
          <div class="array" id="rankArr">rank: []</div>
        </div>
      </div>

      <div class="section">
        <div class="info-block">
          Concepts:
          <ul style="margin:6px 0 0 18px; padding:0; color:var(--muted);">
            <li>Find(x): find set representative (root) — optionally compress path.</li>
            <li>Union(a,b): attach one root under another, using rank/size heuristics.</li>
            <li>Time: amortized almost constant with union-by-rank + path compression.</li>
          </ul>
        </div>
      </div>

      <div class="footer">
        Built-in demo: interactive forest, animated pointer changes, and array view.
      </div>
    </div>

    <div class="svg-wrap">
      <div class="viz-toolbar">
        <div class="legend">
          <div class="dot" style="background:#063b4a"></div> root
          <div class="dot" style="background:#7c3aed; margin-left:10px;"></div> find path
          <div class="dot" style="background:#0ea5a4; margin-left:10px;"></div> compressed
        </div>
        <div style="flex:1"></div>
        <div class="small-muted" id="status">Status: ready</div>
      </div>
      <svg id="svg" viewBox="0 0 1200 720" preserveAspectRatio="xMidYMid meet">
        <defs>
          <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L10,5 L0,10 L2,5 z" fill="rgba(255,255,255,0.08)"></path>
          </marker>
        </defs>
        <!-- edges and nodes will be drawn here -->
      </svg>
      <div class="info" id="infoBox">Click nodes or use controls. Arrays show parent and rank.</div>
    </div>
  </div>

<script>
(() => {
  // Basic Union-Find implementation with visualization hooks
  let n = 10;
  let parent = [];
  let rank = [];
  let svg = document.getElementById('svg');
  let status = document.getElementById('status');
  let parentArrEl = document.getElementById('parentArr');
  let rankArrEl = document.getElementById('rankArr');
  let infoBox = document.getElementById('infoBox');

  const controls = {
    byRank: document.getElementById('byRank'),
    pathCompToggle: document.getElementById('pathComp'),
    speed: document.getElementById('speed'),
    nInput: document.getElementById('nInput'),
    resetBtn: document.getElementById('resetBtn'),
    unionBtn: document.getElementById('unionBtn'),
    unionInput: document.getElementById('unionInput'),
    randUnionBtn: document.getElementById('randUnionBtn'),
    findBtn: document.getElementById('findBtn'),
    findCompBtn: document.getElementById('findCompBtn'),
    findInput: document.getElementById('findInput'),
    mergeRandom: document.getElementById('mergeRandom'),
    resetAll: document.getElementById('resetAll'),
  };

  function initArrays(m) {
    n = m;
    parent = new Array(n);
    rank = new Array(n);
    for (let i=0;i<n;i++){ parent[i]=i; rank[i]=0; }
    updateArrays();
    render();
  }

  function updateArrays() {
    parentArrEl.textContent = 'parent: [' + parent.join(', ') + ']';
    rankArrEl.textContent = 'rank:   [' + rank.join(', ') + ']';
  }

  // Visualization helpers
  function clearSVG() {
    while (svg.lastChild) svg.removeChild(svg.lastChild);
    // re-add defs for marker
    const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
    defs.innerHTML = '<marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L10,5 L0,10 L2,5 z" fill="rgba(255,255,255,0.08)"></path></marker>';
    svg.appendChild(defs);
  }

  function buildChildren() {
    // children lists
    const children = Array.from({length:n}, ()=>[]);
    for (let i=0;i<n;i++){
      if (parent[i] !== i) children[parent[i]].push(i);
    }
    return children;
  }

  function computeTrees() {
    const children = buildChildren();
    const roots = [];
    for (let i=0;i<n;i++) if (parent[i] === i) roots.push(i);
    // For each root, create array of nodes in its tree
    const trees = roots.map(root=>{
      const nodes = [];
      (function dfs(u){
        nodes.push(u);
        for (const v of children[u]) dfs(v);
      })(root);
      return {root, nodes};
    });
    return {children, roots, trees};
  }

  function render() {
    clearSVG();
    const {children, roots, trees} = computeTrees();
    const pad = 20;
    const width = 1200;
    const height = 720;
    const availW = width - (roots.length+1)*pad;
    // allocate horizontal segments per tree proportional to tree size
    const totalNodes = n || 1;
    let xStart = pad;
    for (const tree of trees) {
      const segW = Math.max(150, Math.floor(availW * (tree.nodes.length / totalNodes)));
      // compute levels (breadth) using BFS from root to assign depth
      const levels = [];
      const root = tree.root;
      const queue = [{u:root, depth:0}];
      const depthMap = new Map();
      depthMap.set(root,0);
      while (queue.length) {
        const item = queue.shift();
        const u = item.u, d = item.depth;
        if (!levels[d]) levels[d]=[];
        levels[d].push(u);
        for (const v of children[u]) { depthMap.set(v,d+1); queue.push({u:v,depth:d+1}); }
      }
      const maxDepth = levels.length-1;
      // for each level, space horizontally within segment
      const segX = xStart;
      const segY = 40;
      const segRight = xStart + segW;
      for (let d=0; d<=maxDepth; d++){
        const row = levels[d];
        const y = segY + d*120;
        for (let i=0;i<row.length;i++){
          const u = row[i];
          const x = segX + (i+1)*(segW/(row.length+1));
          // store positions
          pos[u] = {x,y};
        }
      }
      xStart += segW + pad;
    }

    // draw edges then nodes
    // edges: for each node with parent != self, draw line from node to parent
    for (let i=0;i<n;i++){
      if (parent[i] !== i) {
        const p = parent[i];
        const A = pos[i];
        const B = pos[p];
        const line = document.createElementNS('http://www.w3.org/2000/svg','path');
        const dx = B.x - A.x;
        // curve to parent
        const midX = A.x + dx*0.5;
        const pathD = `M${A.x},${A.y} C ${midX},${A.y} ${midX},${B.y} ${B.x},${B.y}`;
        line.setAttribute('d', pathD);
        line.setAttribute('class','edge');
        line.setAttribute('data-from', i);
        line.setAttribute('data-to', p);
        svg.appendChild(line);
      }
    }

    // nodes
    for (let i=0;i<n;i++){
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class','node');
      g.setAttribute('data-i', i);
      g.style.cursor = 'pointer';
      const p = pos[i];
      g.setAttribute('transform', `translate(${p.x},${p.y})`);
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('r','22');
      // mark root
      if (parent[i] === i) {
        g.classList.add('root');
      }
      circle.setAttribute('fill','#041726');
      circle.setAttribute('stroke','rgba(255,255,255,0.04)');
      circle.setAttribute('stroke-width','1.5');
      g.appendChild(circle);
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x','0');
      text.setAttribute('y','6');
      text.setAttribute('text-anchor','middle');
      text.textContent = i;
      g.appendChild(text);

      // attach click
      g.addEventListener('click', async (ev) => {
        const idx = Number(g.getAttribute('data-i'));
        // if path compression toggle is on, run with compression, else just find
        if (controls.pathCompToggle.checked) {
          await animatedFind(idx, true);
        } else {
          await animatedFind(idx, false);
        }
      });

      svg.appendChild(g);

      // rank label
      const rlabel = document.createElementNS('http://www.w3.org/2000/svg','text');
      rlabel.setAttribute('x', p.x + 34);
      rlabel.setAttribute('y', p.y - 10);
      rlabel.setAttribute('font-size','12');
      rlabel.setAttribute('fill','rgba(255,255,255,0.6)');
      rlabel.textContent = 'r=' + rank[i];
      svg.appendChild(rlabel);
    }

    updateArrays();
  }

  // positions storage (node index -> {x,y})
  const pos = {};

  // Utilities for animation
  function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }
  function animDelay() { return Number(controls.speed.value) || 400; }

  // Non-visual find (returns root)
  function findRoot(x) {
    while (parent[x] !== x) x = parent[x];
    return x;
  }

  // Animated find: highlights path, optionally compresses step-by-step
  async function animatedFind(x, doCompress) {
    status.textContent = `Status: finding ${x}...`;
    // collect path to root
    const path = [];
    let cur = x;
    while (true) {
      path.push(cur);
      if (parent[cur] === cur) break;
      cur = parent[cur];
    }
    const root = cur;
    highlightPath(path);
    infoBox.textContent = `Find(${x}) -> ${root}. Path: ${path.join(' → ')}`;
    await sleep(animDelay()/1.2);

    if (doCompress) {
      status.textContent = `Status: compressing path of ${x} to root ${root}...`;
      // step-by-step compress: for each node in path (excluding root), set parent directly to root
      for (let i=0;i<path.length-1;i++){
        const u = path[i];
        // animate edge change
        await animateSetParent(u, root);
        parent[u] = root;
        await sleep(animDelay()/2);
        render();
      }
      status.textContent = `Status: compressed ${x} to root ${root}.`;
      updateArrays();
    } else {
      status.textContent = `Status: found root ${root} (no compression).`;
    }

    // flash root
    flashNode(root, '#0ea5a4');
    await sleep(200);
    render();
  }

  function highlightPath(path) {
    // add classes to nodes and edges
    // first remove existing highlights
    const edges = svg.querySelectorAll('.edge');
    edges.forEach(e => e.classList.remove('highlight'));
    const nodes = svg.querySelectorAll('.node');
    nodes.forEach(n => n.classList.remove('find-path'));
    for (let i=0;i<path.length;i++){
      const u = path[i];
      const node = svg.querySelector('.node[data-i="'+u+'"]');
      if (node) node.classList.add('find-path');
      if (i < path.length-1) {
        const v = path[i+1];
        const edge = findEdgeElement(u,v);
        if (edge) edge.classList.add('highlight');
      }
    }
  }

  function findEdgeElement(from, to) {
    return svg.querySelector('.edge[data-from="'+from+'"][data-to="'+to+'"]');
  }

  async function animateSetParent(child, newParent) {
    // animate edge changes: fade out old edge, draw new temporary edge, then render final
    const oldEdge = svg.querySelector('.edge[data-from="'+child+'"]');
    if (oldEdge) {
      oldEdge.style.transition = `opacity ${animDelay()/2}ms`;
      oldEdge.style.opacity = '0.1';
    }
    // draw temporary curve to new parent
    const cpos = pos[child];
    const npos = pos[newParent];
    const tmp = document.createElementNS('http://www.w3.org/2000/svg','path');
    const midX = cpos.x + (npos.x - cpos.x)*0.5;
    const d = `M${cpos.x},${cpos.y} C ${midX},${cpos.y} ${midX},${npos.y} ${npos.x},${npos.y}`;
    tmp.setAttribute('d', d);
    tmp.setAttribute('class','edge highlight');
    tmp.setAttribute('stroke', '#10b981');
    tmp.setAttribute('stroke-width','3');
    svg.appendChild(tmp);
    await sleep(animDelay()/1.6);
    // remove tmp
    svg.removeChild(tmp);
    if (oldEdge) oldEdge.remove();
  }

  function flashNode(i, color) {
    const node = svg.querySelector('.node[data-i="'+i+'"]');
    if (!node) return;
    const circle = node.querySelector('circle');
    if (!circle) return;
    const original = circle.getAttribute('fill');
    circle.setAttribute('fill', color);
    setTimeout(()=>{ circle.setAttribute('fill', original); }, 500);
  }

  // Union operation with animation
  async function union(a,b) {
    if (a<0 || a>=n || b<0 || b>=n) {
      status.textContent = 'Status: invalid indices';
      return;
    }
    status.textContent = `Status: union(${a}, ${b})...`;
    // find roots (non-destructive find to show path)
    const ra = findRoot(a);
    const rb = findRoot(b);
    if (ra === rb) {
      infoBox.textContent = `Union(${a}, ${b}): already in same set (root ${ra}).`;
      status.textContent = 'Status: no-op, same root';
      // highlight
      highlightPath([a,ra]);
      flashNode(ra, '#7c3aed');
      await sleep(600);
      render();
      return;
    }

    // show both roots
    highlightBothRoots(ra, rb);
    await sleep(animDelay()/1.2);

    if (controls.byRank.checked) {
      // union by rank
      if (rank[ra] < rank[rb]) {
        await performUnionVisual(ra, rb); // attach ra under rb
        parent[ra] = rb;
      } else if (rank[ra] > rank[rb]) {
        await performUnionVisual(rb, ra);
        parent[rb] = ra;
      } else {
        // equal rank: attach rb under ra (arbitrary) and increase rank[ra]
        await performUnionVisual(rb, ra);
        parent[rb] = ra;
        rank[ra]++;
      }
    } else {
      // naive attach b's root under a's root
      await performUnionVisual(rb, ra); // attach rb under ra
      parent[rb] = ra;
    }
    updateArrays();
    render();
    status.textContent = `Status: union completed.`;
    infoBox.textContent = `Union(${a}, ${b}) attached roots ${ra} & ${rb}.`;
    await sleep(220);
  }

  function highlightBothRoots(ra, rb) {
    // mark nodes
    const nodes = svg.querySelectorAll('.node');
    nodes.forEach(n => {
      n.classList.remove('find-path');
    });
    const nra = svg.querySelector('.node[data-i="'+ra+'"]');
    const nrb = svg.querySelector('.node[data-i="'+rb+'"]');
    if (nra) nra.classList.add('find-path');
    if (nrb) nrb.classList.add('find-path');
  }

  async function performUnionVisual(childRoot, newParentRoot) {
    // animate changing parent pointers for the root 'childRoot'
    status.textContent = `Status: attaching ${childRoot} under ${newParentRoot}...`;
    // visually show an edge from childRoot to newParentRoot
    await animateSetParent(childRoot, newParentRoot);
  }

  // Controls wiring
  controls.resetBtn.addEventListener('click', ()=>{
    const val = Number(controls.nInput.value) || 10;
    initArrays(Math.max(1, Math.min(120, val)));
    status.textContent = 'Status: created new forest.';
  });

  controls.unionBtn.addEventListener('click', async ()=>{
    const txt = controls.unionInput.value.trim();
    let a,b;
    if (txt.includes(',')) {
      const parts = txt.split(',').map(s=>Number(s.trim()));
      a = parts[0]; b = parts[1];
    } else {
      const parts = txt.split(/\s+/).map(s=>Number(s.trim()));
      a = parts[0]; b = parts[1];
    }
    if (!Number.isFinite(a) || !Number.isFinite(b)) {
      status.textContent = 'Status: invalid union input';
      return;
    }
    await union(a,b);
  });

  controls.randUnionBtn.addEventListener('click', async ()=>{
    // perform one random union
    const a = Math.floor(Math.random()*n);
    const b = Math.floor(Math.random()*n);
    await union(a,b);
  });

  controls.findBtn.addEventListener('click', async ()=>{
    const x = Number(controls.findInput.value);
    if (!Number.isFinite(x) || x<0 || x>=n) {
      status.textContent = 'Status: invalid index';
      return;
    }
    await animatedFind(x, false);
  });

  controls.findCompBtn.addEventListener('click', async ()=>{
    const x = Number(controls.findInput.value);
    if (!Number.isFinite(x) || x<0 || x>=n) {
      status.textContent = 'Status: invalid index';
      return;
    }
    await animatedFind(x, true);
  });

  controls.mergeRandom.addEventListener('click', async ()=>{
    // do a batch of random unions
    status.textContent = 'Status: merging random pairs...';
    const pairs = Math.max(1, Math.floor(n/2));
    for (let i=0;i<pairs;i++){
      const a = Math.floor(Math.random()*n);
      const b = Math.floor(Math.random()*n);
      await union(a,b);
      await sleep(120);
    }
    status.textContent = 'Status: random merges done.';
  });

  controls.resetAll.addEventListener('click', ()=>{
    for (let i=0;i<n;i++){ parent[i]=i; rank[i]=0; }
    updateArrays();
    render();
    status.textContent = 'Status: parents reset (all separate sets).';
  });

  // initial setup
  initArrays(10);

  // allow clicking empty area to clear highlights
  svg.addEventListener('click', (ev)=>{
    if (ev.target === svg) {
      // clear path highlights
      const nodes = svg.querySelectorAll('.node');
      nodes.forEach(n => n.classList.remove('find-path'));
      const edges = svg.querySelectorAll('.edge');
      edges.forEach(e => e.classList.remove('highlight'));
      infoBox.textContent = 'Ready.';
    }
  });

  // allow keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if (e.key === 'r') {
      controls.resetBtn.click();
    }
    if (e.key === 'u') {
      controls.unionBtn.click();
    }
  });

  // small responsive rendering on resize
  window.addEventListener('resize', ()=>{ render(); });

  // Expose some debug in console
  window.UF = {
    get parent(){ return parent.slice(); },
    get rank(){ return rank.slice(); },
    find: findRoot,
    unionSimple: async (a,b) => await union(a,b),
    compressAll: () => {
      for (let i=0;i<n;i++) parent[i] = findRoot(i);
      updateArrays(); render();
    }
  };

  // informative first render text
  infoBox.textContent = 'Click a node to Find(x). Use toggles for union-by-rank and path compression. Arrays update live.';

})();
</script>
</body>
</html>