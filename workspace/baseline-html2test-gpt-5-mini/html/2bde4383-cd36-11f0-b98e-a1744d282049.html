<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Bubble Sort Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #3b82f6;
      --muted: #94a3b8;
      --good: #16a34a;
      --bad: #ef4444;
      --card: #0b1220;
      --glass: rgba(255,255,255,0.03);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
    }
    * { box-sizing: border-box; font-family: Inter, Roboto, system-ui, -apple-system, "Segoe UI", sans-serif; color: #e6eef8; }
    html,body{ height:100%; margin:0; background: linear-gradient(180deg,#071026 0%, #0a1220 100%); }
    .app{
      max-width:1100px;
      margin:24px auto;
      padding:20px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 8px 30px rgba(2,6,23,0.6);
      min-height: 80vh;
    }
    header{ display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:18px; }
    header h1{ font-size:20px; margin:0; letter-spacing:0.2px; }
    header p{ margin:0; color:var(--muted); font-size:13px; }
    .controls{
      display:flex; gap:12px; flex-wrap:wrap; align-items:center;
      margin-bottom:12px;
    }
    .control {
      background:var(--glass);
      padding:10px;
      border-radius:8px;
      display:flex; gap:10px; align-items:center;
      min-width:120px;
    }
    .control label{ font-size:12px; color:var(--muted); display:block; }
    .control .val{ font-weight:600; color:#e6eef8; font-size:14px; }
    .buttons{ display:flex; gap:8px; align-items:center; }
    button.btn{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      padding:8px 12px;
      color: #e6eef8;
      border-radius:8px;
      cursor:pointer;
      transition: all .15s;
      font-weight:600;
    }
    button.btn.primary{
      background: linear-gradient(90deg,var(--accent),#06b6d4);
      color: black;
      border: none;
    }
    button.btn:hover{ transform: translateY(-2px); }
    .row { display:flex; gap:16px; align-items:center; }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      padding:12px;
      border-radius:10px;
      border: 1px solid rgba(255,255,255,0.03);
    }
    /* Visualization area */
    .visual{
      margin-top:16px;
      display:flex;
      gap:18px;
      align-items:flex-start;
    }
    .bars{
      flex:1;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      padding:14px;
      border-radius:10px;
      min-height:340px;
      display:flex;
      align-items:end;
      gap:6px;
    }
    .bar{
      flex:1;
      background: linear-gradient(180deg,#60a5fa,#2563eb);
      height:50px;
      border-radius:4px 4px 0 0;
      transition: height 300ms ease, background-color 200ms ease, transform 200ms ease;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      position:relative;
      box-shadow: 0 4px 10px rgba(2,6,23,0.45), inset 0 -6px 15px rgba(0,0,0,0.15);
    }
    .bar .label{
      position:absolute;
      bottom:2px;
      font-size:11px;
      color: rgba(255,255,255,0.92);
      padding: 2px 6px;
      background: rgba(0,0,0,0.18);
      border-radius: 6px;
      transform: translateY(0);
    }
    .bar.compare{ background: linear-gradient(180deg,var(--bad),#ef4444); transform: scaleY(1.02); }
    .bar.swap{ background: linear-gradient(180deg,#f97316,#fb923c); transform: scaleY(1.03); }
    .bar.sorted{ background: linear-gradient(180deg,var(--good),#6ee7b7); }
    .bar.inactive{ opacity:0.14; }
    .side{
      width:360px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .stats{ display:flex; gap:8px; flex-wrap:wrap; }
    .stat{
      padding:8px 10px;
      background:rgba(255,255,255,0.02);
      border-radius:8px;
      min-width:120px;
    }
    .pseudocode{
      padding:8px;
      border-radius:8px;
      background: rgba(255,255,255,0.015);
      font-family: var(--mono);
      font-size:13px;
      color:var(--muted);
      line-height:1.5;
      white-space:pre;
      border: 1px solid rgba(255,255,255,0.02);
      max-height:260px;
      overflow:auto;
    }
    .pseudocode .line{
      padding:4px 6px;
      border-radius:6px;
    }
    .pseudocode .active{ background: rgba(59,130,246,0.12); color:#dbeafe; }
    .footer{
      margin-top:14px; display:flex; justify-content:space-between; align-items:center;
      color:var(--muted); font-size:13px;
    }
    .small{ font-size:13px; color:var(--muted); }
    input[type="range"]{ width:140px; }
    select{ padding:6px 8px; border-radius:6px; background:transparent; border:1px solid rgba(255,255,255,0.04); color: #e6eef8; }
    .hint{ font-size:12px; color:var(--muted); }
    @media (max-width:920px){
      .visual{ flex-direction:column; }
      .side{ width:100%; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Bubble Sort Visualizer">
    <header>
      <div>
        <h1>Bubble Sort Visualizer</h1>
        <p>See how Bubble Sort compares and swaps elements step-by-step.</p>
      </div>
      <div class="small">Interactive demo • Click Start or Step to run</div>
    </header>

    <div class="controls">
      <div class="control">
        <div>
          <label for="size">Array Size</label>
          <div style="display:flex; gap:8px; align-items:center;">
            <input id="size" type="range" min="4" max="80" value="28" />
            <div class="val" id="sizeVal">28</div>
          </div>
        </div>
      </div>

      <div class="control">
        <div>
          <label for="speed">Speed</label>
          <div style="display:flex; gap:8px; align-items:center;">
            <input id="speed" type="range" min="1" max="1000" value="250" />
            <div class="val" id="speedVal">250ms</div>
          </div>
        </div>
      </div>

      <div class="control">
        <div>
          <label for="order">Order</label>
          <select id="order" aria-label="Sort order">
            <option value="asc">Ascending</option>
            <option value="desc">Descending</option>
          </select>
        </div>
      </div>

      <div class="control">
        <label><input type="checkbox" id="optimized" /> Optimized (stop early)</label>
      </div>

      <div class="buttons">
        <button id="newBtn" class="btn">Randomize</button>
        <button id="resetBtn" class="btn">Reset</button>
        <button id="stepBtn" class="btn">Step</button>
        <button id="playBtn" class="btn primary">Start</button>
      </div>
    </div>

    <div class="visual">
      <div class="bars panel" id="bars" aria-hidden="false" role="list" title="Array values visualized as bars"></div>

      <div class="side">
        <div class="panel stats">
          <div class="stat">
            <div style="font-size:12px; color:var(--muted)">Comparisons</div>
            <div id="compCount" style="font-weight:700; font-size:18px">0</div>
          </div>
          <div class="stat">
            <div style="font-size:12px; color:var(--muted)">Swaps</div>
            <div id="swapCount" style="font-weight:700; font-size:18px">0</div>
          </div>
          <div class="stat">
            <div style="font-size:12px; color:var(--muted)">Current i, j</div>
            <div id="indices" style="font-weight:700; font-size:15px">-</div>
          </div>
        </div>

        <div class="panel pseudocode" id="pseudocode" aria-hidden="false">
          <!-- Pseudocode lines -->
          <div class="line" data-line="1">1. procedure bubbleSort(A)</div>
          <div class="line" data-line="2">2.   n ← length(A)</div>
          <div class="line" data-line="3">3.   repeat</div>
          <div class="line" data-line="4">4.     swapped ← false</div>
          <div class="line" data-line="5">5.     for i from 1 to n - 1 do</div>
          <div class="line" data-line="6">6.       if A[i - 1] > A[i] then      // compare</div>
          <div class="line" data-line="7">7.         swap(A[i - 1], A[i])      // swap</div>
          <div class="line" data-line="8">8.         swapped ← true</div>
          <div class="line" data-line="9">9.       end if</div>
          <div class="line" data-line="10">10.    end for</div>
          <div class="line" data-line="11">11.    n ← n - 1</div>
          <div class="line" data-line="12">12.  until not swapped</div>
          <div class="line" data-line="13">13. end procedure</div>
        </div>

        <div class="panel" style="padding:10px;">
          <div style="display:flex; gap:8px; align-items:center; justify-content:space-between;">
            <div>
              <div style="font-weight:700">Controls</div>
              <div class="hint">Start = Play/Pause. Step moves one action.</div>
            </div>
            <div style="text-align:right;">
              <div id="status" class="small">Idle</div>
            </div>
          </div>
        </div>

      </div>
    </div>

    <div class="footer">
      <div>Bubble Sort animation — highlights comparisons & swaps</div>
      <div>Made for learning • Demo</div>
    </div>
  </div>

  <script>
    // Bubble Sort Visualizer
    (function(){
      const barsEl = document.getElementById('bars');
      const sizeEl = document.getElementById('size');
      const sizeValEl = document.getElementById('sizeVal');
      const speedEl = document.getElementById('speed');
      const speedValEl = document.getElementById('speedVal');
      const orderEl = document.getElementById('order');
      const optimizedEl = document.getElementById('optimized');
      const newBtn = document.getElementById('newBtn');
      const resetBtn = document.getElementById('resetBtn');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const compCountEl = document.getElementById('compCount');
      const swapCountEl = document.getElementById('swapCount');
      const indicesEl = document.getElementById('indices');
      const pseudocodeEl = document.getElementById('pseudocode');
      const statusEl = document.getElementById('status');

      let array = [];
      let bars = [];
      let sortedSet = new Set();
      let generator = null;
      let running = false;
      let timer = null;
      let comparisons = 0;
      let swaps = 0;
      let lastAction = null;

      function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

      function createArray(n){
        array = [];
        // create varied values
        for(let i=0;i<n;i++){
          array.push(randInt(5, 100));
        }
        sortedSet.clear();
        comparisons = 0; swaps = 0;
        updateCounts();
        renderBars();
        setStatus('Idle');
        highlightLine(null);
      }

      function resetArray(){
        // reset sorted flags and counts but keep array values
        sortedSet.clear();
        comparisons = 0; swaps = 0;
        updateCounts();
        renderBars();
        setStatus('Idle');
        highlightLine(null);
        if(generator){ generator = null; }
        stopAuto();
      }

      function renderBars(){
        barsEl.innerHTML = '';
        bars = [];
        const n = array.length;
        // compute heights
        const maxVal = Math.max(...array, 100);
        for(let i=0;i<n;i++){
          const v = array[i];
          const el = document.createElement('div');
          el.className = 'bar';
          el.style.height = (v / maxVal * 100) + '%';
          el.setAttribute('data-index', String(i));
          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = v;
          el.appendChild(label);
          barsEl.appendChild(el);
          bars.push(el);
        }
      }

      function updateBarHeight(i){
        const maxVal = Math.max(...array, 100);
        const el = bars[i];
        el.style.height = (array[i] / maxVal * 100) + '%';
        el.querySelector('.label').textContent = array[i];
      }

      function updateCounts(){
        compCountEl.textContent = comparisons;
        swapCountEl.textContent = swaps;
      }

      function sleep(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }

      // Generator for bubble sort actions
      // yields actions {type: 'compare'|'swap'|'setSorted'|'done', i, j, n}
      function* bubbleGenerator(arr, ascending=true, optimized=false){
        let n = arr.length;
        if(n <= 1){
          for(let k=0;k<n;k++) yield {type: 'setSorted', i: k};
          yield {type: 'done'};
          return;
        }
        let swapped;
        // We'll follow the standard "repeat...until not swapped" pseudocode to match displayed pseudo
        do {
          swapped = false;
          for(let i=0;i<n-1;i++){
            yield {type:'compare', i:i, j:i+1, n};
            const a = arr[i], b = arr[i+1];
            const comp = ascending ? (a > b) : (a < b);
            if(comp){
              // swap in array and yield
              // perform swap in array as generator consumer expects array updated when swap yielded
              [arr[i], arr[i+1]] = [arr[i+1], arr[i]];
              yield {type:'swap', i:i, j:i+1, n};
              swapped = true;
            }
            // continue loop
          }
          // after inner loop, the last element of current n is in place
          yield {type:'setSorted', i: n-1, n};
          n = n - 1;
          if(optimized && !swapped){
            // if optimized and no swap, mark remaining as sorted
            for(let k=n-1;k>=0;k--){
              yield {type:'setSorted', i: k, n};
            }
            break;
          }
        } while (n > 1);
        yield {type:'done'};
      }

      function startGeneratorIfNeeded(){
        if(!generator){
          // clone array for generator so swaps update that internal arr (we also update main array when swap action occurs)
          generator = bubbleGenerator(array.slice(), orderEl.value === 'asc', optimizedEl.checked);
        }
      }

      function step(){
        startGeneratorIfNeeded();
        const res = generator.next();
        if(res.done){
          setStatus('Finished');
          highlightLine(null);
          generator = null;
          running = false;
          stopAuto();
          return;
        }
        const action = res.value;
        handleAction(action);
      }

      function handleAction(action){
        lastAction = action;
        switch(action.type){
          case 'compare':
            comparisons++;
            updateCounts();
            indicesEl.textContent = `${action.i}, ${action.j}`;
            markBarsCompare(action.i, action.j);
            highlightLine(6); // pseudocode compare line
            break;
          case 'swap':
            swaps++;
            updateCounts();
            indicesEl.textContent = `${action.i}, ${action.j}`;
            // Update main array to reflect the swap (the generator already swapped its internal copy);
            // swap values in our array
            [array[action.i], array[action.j]] = [array[action.j], array[action.i]];
            // animate swap by updating heights; add 'swap' class
            markBarsSwap(action.i, action.j);
            highlightLine(7); // pseudocode swap line
            break;
          case 'setSorted':
            // Mark index as sorted (green)
            sortedSet.add(action.i);
            markBarSorted(action.i);
            highlightLine(11); // marking n = n -1 is line 11; marking sorted could map to after inner, but we highlight n decrement
            break;
          case 'done':
            // mark all sorted
            for(let i=0;i<array.length;i++) sortedSet.add(i);
            markAllSorted();
            indicesEl.textContent = '-';
            highlightLine(13);
            setStatus('Finished');
            break;
        }
      }

      function markBarsCompare(i,j){
        clearBarClasses();
        if(bars[i]) bars[i].classList.add('compare');
        if(bars[j]) bars[j].classList.add('compare');
      }
      function markBarsSwap(i,j){
        clearBarClasses();
        if(bars[i]) bars[i].classList.add('swap');
        if(bars[j]) bars[j].classList.add('swap');
        // update heights (they should animate because of CSS transitions)
        updateBarHeight(i);
        updateBarHeight(j);
      }
      function markBarSorted(i){
        if(bars[i]){
          bars[i].classList.remove('compare','swap','inactive');
          bars[i].classList.add('sorted');
        }
      }
      function markAllSorted(){
        for(let i=0;i<bars.length;i++){
          bars[i].classList.remove('compare','swap','inactive');
          bars[i].classList.add('sorted');
        }
      }
      function clearBarClasses(){
        for(let b of bars){
          b.classList.remove('compare','swap','inactive');
          // keep sorted class if already sorted
        }
      }

      function highlightLine(num){
        const lines = pseudocodeEl.querySelectorAll('.line');
        lines.forEach(el => {
          const n = parseInt(el.getAttribute('data-line'),10);
          if(num && n === num) el.classList.add('active'); else el.classList.remove('active');
        });
      }

      function setStatus(s){
        statusEl.textContent = s;
      }

      function stopAuto(){
        if(timer){ clearInterval(timer); timer = null; }
        running = false;
        playBtn.textContent = 'Start';
        playBtn.classList.add('primary');
      }

      function autoPlay(){
        startGeneratorIfNeeded();
        if(running) return;
        running = true;
        playBtn.textContent = 'Pause';
        playBtn.classList.remove('primary');
        setStatus('Running');
        const speed = parseInt(speedEl.value,10);
        // We'll use setInterval to step every speed ms
        timer = setInterval(()=>{
          // if generator consumed, stop
          if(!generator) { stopAuto(); return; }
          const res = generator.next();
          if(res.done){
            handleAction({type:'done'});
            generator = null;
            stopAuto();
            setStatus('Finished');
            return;
          } else {
            handleAction(res.value);
          }
        }, Math.max(10, speed));
      }

      // Controls wiring
      sizeEl.addEventListener('input', ()=> {
        sizeValEl.textContent = sizeEl.value;
      });

      speedEl.addEventListener('input', ()=> {
        speedValEl.textContent = speedEl.value + 'ms';
        // if running, restart interval with new speed
        if(running){
          stopAuto();
          autoPlay();
        }
      });

      newBtn.addEventListener('click', ()=>{
        createArray(parseInt(sizeEl.value,10));
      });

      resetBtn.addEventListener('click', ()=>{
        resetArray();
      });

      stepBtn.addEventListener('click', async ()=>{
        // stop autoplay if running
        if(running){
          stopAuto();
        }
        setStatus('Stepping');
        step();
      });

      playBtn.addEventListener('click', ()=>{
        if(running){
          // pause
          stopAuto();
          setStatus('Paused');
        } else {
          // start playing
          // if already finished, reset generator to allow a new run on same array (array may be modified)
          // but we want to run bubble sort on current array values, so recreate generator
          generator = null;
          autoPlay();
        }
      });

      orderEl.addEventListener('change', ()=>{
        // restart if running
        resetArray();
        generator = null;
      });

      optimizedEl.addEventListener('change', ()=>{
        generator = null;
        resetArray();
      });

      // initialize
      sizeValEl.textContent = sizeEl.value;
      speedValEl.textContent = speedEl.value + 'ms';
      createArray(parseInt(sizeEl.value,10));

      // Accessibility: allow keyboard step with space
      document.addEventListener('keydown', (e)=>{
        if(e.code === 'Space'){
          e.preventDefault();
          stepBtn.click();
        }
      });

      // When stepping or auto-play, after each action, we want to clear the compare/swap classes after a short time (speed/2)
      // We'll watch lastAction and clear after delay
      setInterval(()=>{
        if(!lastAction) return;
        const speed = parseInt(speedEl.value,10);
        // clear visual markers after half the speed interval
        // But keep sorted markers intact
        if(lastAction.type === 'compare' || lastAction.type === 'swap'){
          // remove their class after half speed (but do not remove 'sorted')
          setTimeout(()=>{
            // if the bar is now in sortedSet, keep sorted class
            for(let i=0;i<bars.length;i++){
              if(sortedSet.has(i)){
                bars[i].classList.add('sorted');
                bars[i].classList.remove('compare','swap','inactive');
              } else {
                bars[i].classList.remove('compare','swap');
              }
            }
          }, Math.max(40, speed/2));
        }
        lastAction = null;
      }, 80);

      // Resize behavior: update heights when window resizes (in case fonts or layout changes)
      window.addEventListener('resize', ()=>{
        for(let i=0;i<array.length;i++) updateBarHeight(i);
      });

      // Extra: when randomizing, ensure bars animate nicely
      // initial animation: slight stagger
      (function initialPulse(){
        const els = barsEl.children;
        for(let i=0;i<els.length;i++){
          const el = els[i];
          el.style.transform = 'translateY(3px)';
          setTimeout(()=> el.style.transform = '', 100 + i*6);
        }
      })();

    })();
  </script>
</body>
</html>