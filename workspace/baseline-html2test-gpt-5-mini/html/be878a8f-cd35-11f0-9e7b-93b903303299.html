<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Depth-First Search (DFS) Visualizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 0; display:flex; height:100vh; }
  #left { width: 68%; background: #f7f9fc; padding: 12px; box-sizing: border-box; display:flex; flex-direction:column; gap:8px; }
  #canvasWrap { flex:1; border: 1px solid #ddd; background: #fff; position: relative; overflow:hidden; border-radius:6px; }
  canvas { width:100%; height:100%; display:block; }
  #controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .btn { padding:8px 10px; border-radius:6px; border:1px solid #cfd8e3; background:#fff; cursor:pointer; }
  .btn.primary { background:#2b8cff; color:#fff; border-color:#267de6; }
  .btn.danger { background:#ff6b6b; color:#fff; border-color:#ff4c4c; }
  label { font-size:13px; color:#333; margin-right:6px; }
  input[type=range] { width:120px; }
  #right { width:32%; border-left:1px solid #e6eef7; padding:12px; box-sizing:border-box; overflow:auto; background:#fbfdff; }
  h3 { margin:6px 0 8px 0; font-size:15px; }
  .panel { background:#fff; border:1px solid #e6eef7; padding:10px; border-radius:8px; margin-bottom:10px; }
  .small { font-size:13px; color:#444; }
  ul { padding-left:20px; margin:6px 0; }
  .badge { display:inline-block; padding:3px 7px; border-radius:999px; background:#f0f4ff; color:#234; font-weight:600; font-size:12px; margin-right:6px; }
  table { width:100%; border-collapse:collapse; font-size:13px; }
  td, th { border-bottom:1px solid #f0f4ff; padding:6px; text-align:left; }
  .legend { display:flex; gap:8px; align-items:center; margin-top:6px; }
  .legend .box { width:16px; height:12px; border-radius:3px; display:inline-block; margin-right:6px; border:1px solid #ddd;}
  .node-white { background:#fff; }
  .node-gray { background:#ffd97a; }
  .node-black { background:#8fd3a8; }
  #adjList { font-family: monospace; background:#fbfbff; padding:8px; border-radius:6px; border:1px dashed #eef; }
  #status { font-size:13px; color:#333; margin-top:6px; }
  .controls-col { display:flex; gap:8px; flex-direction:column; }
  .muted { color:#666; font-size:13px; }
  .smallBtn { padding:6px 8px; font-size:13px; border-radius:6px; border:1px solid #e0e7f0; background:#fff; cursor:pointer; }
  select { padding:6px; border-radius:6px; border:1px solid #dfe7f3; background:white; }
</style>
</head>
<body>
<div id="left">
  <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
    <div>
      <h2 style="margin:0 0 6px 0;">Depth-First Search (DFS) Visualizer</h2>
      <div class="small muted">Click empty space to add nodes. Click a node to select a source, then click another node to add an edge. Drag a node to move it. Toggle directed/undirected graphs.</div>
    </div>
    <div style="text-align:right">
      <div class="muted small">Nodes: <span id="nodeCount">0</span>  Edges: <span id="edgeCount">0</span></div>
    </div>
  </div>

  <div id="controls" class="panel">
    <button class="btn" id="clearBtn">Clear All</button>
    <button class="btn" id="randBtn">Random Graph</button>
    <button class="btn" id="toggleDirBtn">Mode: Undirected</button>

    <div style="width:8px;"></div>

    <label for="startSelect">Start:</label>
    <select id="startSelect"></select>

    <div style="width:6px;"></div>

    <button class="btn primary" id="runRecBtn">Run Recursive DFS</button>
    <button class="btn primary" id="runIterBtn">Run Iterative DFS</button>

    <div style="width:6px;"></div>

    <button class="btn" id="stepBtn">Step</button>
    <button class="btn" id="playBtn">Play</button>
    <button class="btn" id="resetTraverseBtn">Reset Traversal</button>

    <label style="margin-left:auto">Speed
      <input id="speedRange" type="range" min="50" max="2000" step="50" value="500">
    </label>
  </div>

  <div id="canvasWrap">
    <canvas id="canvas"></canvas>
  </div>

  <div style="display:flex; gap:8px; margin-top:8px;">
    <div class="panel" style="flex:1;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <h3>Traversal</h3>
        <div class="muted small">Time: <span id="timeCounter">0</span></div>
      </div>
      <div id="status">Press Run to start. You can also Step through the algorithm.</div>
      <div style="margin-top:8px;">
        <strong>Order visited:</strong> <span id="visitedOrder"></span>
      </div>
    </div>

    <div class="panel" style="width:320px;">
      <h3>Stack / Call Stack</h3>
      <div id="stackView" class="muted small">[empty]</div>
      <div style="margin-top:8px;"><strong>Algorithm choice:</strong> <span id="algoChoice">None</span></div>
      <div style="margin-top:6px;"><button class="smallBtn" id="explainBtn">Show Short Explanation</button></div>
    </div>
  </div>
</div>

<div id="right">
  <div class="panel">
    <h3>Adjacency List</h3>
    <div id="adjList" class="small"></div>
    <div class="legend" style="margin-top:8px;">
      <div><span class="box node-white" style="border:1px solid #bbb;"></span> Unvisited</div>
      <div><span class="box node-gray"></span> In progress</div>
      <div><span class="box node-black"></span> Finished</div>
    </div>
  </div>

  <div class="panel">
    <h3>Discovery & Finish Times</h3>
    <div style="max-height:220px; overflow:auto;">
      <table id="timesTable"><thead><tr><th>Node</th><th>Disc</th><th>Finish</th></tr></thead><tbody></tbody></table>
    </div>
  </div>

  <div class="panel">
    <h3>Notes</h3>
    <ul class="small">
      <li>DFS explores as deep as possible along each branch before backtracking.</li>
      <li>Use "Recursive" to see the natural recursion stack, or "Iterative" to see an explicit stack simulation.</li>
      <li>Discovery time when a node is first visited; finish time when all descendants are fully explored.</li>
    </ul>
  </div>
</div>

<script>
(function(){
  // Canvas & graph data
  const canvas = document.getElementById('canvas');
  const wrap = document.getElementById('canvasWrap');
  const ctx = canvas.getContext('2d');
  const DPR = window.devicePixelRatio || 1;

  let width, height;
  function resize() {
    width = wrap.clientWidth;
    height = wrap.clientHeight;
    canvas.width = Math.floor(width * DPR);
    canvas.height = Math.floor(height * DPR);
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    draw();
  }
  window.addEventListener('resize', resize);
  resize();

  // Graph structures
  let nodes = []; // {id,label,x,y,r,...}
  let edges = []; // {from,to}
  let directed = false;
  let nextLabelCharCode = 65; // A...
  const NODE_RADIUS = 22;

  // Traversal state
  let visited = {}; // color: 0 white, 1 gray, 2 black
  let disc = {}, finish = {}, timeCounter = 0;
  let currentAlgo = null; // 'recursive'|'iterative'
  let generator = null;
  let playing = false;
  let playTimer = null;
  let speed = 500;

  // Interaction
  let selectedNode = null; // for edge creation
  let dragging = null;
  let dragOffset = {x:0,y:0};

  // UI elements
  const nodeCountEl = document.getElementById('nodeCount');
  const edgeCountEl = document.getElementById('edgeCount');
  const startSelect = document.getElementById('startSelect');
  const visitedOrderEl = document.getElementById('visitedOrder');
  const statusEl = document.getElementById('status');
  const stackView = document.getElementById('stackView');
  const adjListEl = document.getElementById('adjList');
  const timesTableBody = document.querySelector('#timesTable tbody');
  const timeCounterEl = document.getElementById('timeCounter');
  const algoChoiceEl = document.getElementById('algoChoice');
  const speedRange = document.getElementById('speedRange');

  // Buttons
  document.getElementById('clearBtn').onclick = clearAll;
  document.getElementById('randBtn').onclick = randomGraph;
  document.getElementById('toggleDirBtn').onclick = toggleDirected;
  document.getElementById('runRecBtn').onclick = ()=>startDFS('recursive');
  document.getElementById('runIterBtn').onclick = ()=>startDFS('iterative');
  document.getElementById('stepBtn').onclick = stepOnce;
  document.getElementById('playBtn').onclick = togglePlay;
  document.getElementById('resetTraverseBtn').onclick = resetTraversal;
  document.getElementById('explainBtn').onclick = ()=> alert(
    "Depth-First Search (DFS):\n\n" +
    "- Start at a chosen node.\n" +
    "- Mark node as visited and explore each neighbor recursively (or using an explicit stack) before moving to the next neighbor.\n" +
    "- Discovery time: when you first see a node. Finish time: after exploring all its descendants.\n\nUse this visualizer to step through and watch the recursion/stack behavior."
  );
  speedRange.oninput = ()=> { speed = Number(speedRange.value); if (playing) restartPlayTimer(); };

  // Canvas events
  canvas.addEventListener('mousedown', onDown);
  canvas.addEventListener('mousemove', onMove);
  canvas.addEventListener('mouseup', onUp);
  canvas.addEventListener('mouseleave', onUp);
  canvas.addEventListener('dblclick', onDoubleClick);

  function getMouse(e) {
    const rect = canvas.getBoundingClientRect();
    return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };
  }

  function findNodeAt(x,y) {
    for (let i=nodes.length-1;i>=0;i--) {
      const n = nodes[i];
      const dx = x - n.x, dy = y - n.y;
      if (Math.hypot(dx,dy) <= NODE_RADIUS+2) return n;
    }
    return null;
  }

  function onDown(e) {
    const m = getMouse(e);
    const n = findNodeAt(m.x,m.y);
    if (n) {
      // click on node: select for edge or start dragging
      if (selectedNode && selectedNode !== n) {
        // create edge from selectedNode -> n
        addEdge(selectedNode.id, n.id);
        selectedNode = null;
        draw();
        updateUI();
        return;
      }
      // no selected source: select node as source for edge or start drag
      selectedNode = n;
      dragging = n;
      dragOffset.x = m.x - n.x;
      dragOffset.y = m.y - n.y;
      draw();
    } else {
      // clicked empty: create new node
      createNode(m.x,m.y);
      updateUI();
    }
  }

  function onMove(e) {
    if (!dragging) return;
    const m = getMouse(e);
    dragging.x = m.x - dragOffset.x;
    dragging.y = m.y - dragOffset.y;
    draw();
  }

  function onUp(e) {
    if (!dragging) {
      // clear selection if click on empty area
      // (but keep selectedNode if we just selected for edge creation)
      return;
    }
    dragging = null;
  }

  function onDoubleClick(e) {
    // double-click on node to remove it
    const m = getMouse(e);
    const n = findNodeAt(m.x,m.y);
    if (n) {
      removeNode(n.id);
      updateUI();
    }
  }

  function createNode(x,y) {
    const label = String.fromCharCode(nextLabelCharCode++);
    nodes.push({ id:label, label, x, y, r:NODE_RADIUS });
    updateUI();
    draw();
  }

  function removeNode(id) {
    nodes = nodes.filter(n=>n.id!==id);
    edges = edges.filter(e=>e.from!==id && e.to!==id);
    updateUI();
    draw();
  }

  function addEdge(a,b) {
    // avoid duplicates
    if (edges.some(e=>e.from===a && e.to===b)) return;
    edges.push({ from:a, to:b });
    updateUI();
  }

  function clearAll() {
    nodes = []; edges = []; selectedNode=null; nextLabelCharCode = 65;
    resetTraversal();
    updateUI();
    draw();
  }

  function randomGraph() {
    clearAll();
    // generate 6-10 nodes
    const n = 6 + Math.floor(Math.random()*5);
    const padding = 50;
    for (let i=0;i<n;i++) {
      const x = padding + Math.random()*(width-2*padding);
      const y = padding + Math.random()*(height-2*padding);
      createNode(x,y);
    }
    // add random edges
    const nodeIds = nodes.map(x=>x.id);
    for (let i=0;i<n*1.6;i++) {
      const a = nodeIds[Math.floor(Math.random()*nodeIds.length)];
      const b = nodeIds[Math.floor(Math.random()*nodeIds.length)];
      if (a!==b) addEdge(a,b);
    }
    updateUI();
    draw();
  }

  function toggleDirected() {
    directed = !directed;
    document.getElementById('toggleDirBtn').textContent = 'Mode: ' + (directed? 'Directed':'Undirected');
    updateUI();
    draw();
  }

  function updateUI() {
    nodeCountEl.textContent = nodes.length;
    edgeCountEl.textContent = edges.length;
    // start select
    startSelect.innerHTML = '';
    nodes.forEach(n=>{
      const opt = document.createElement('option');
      opt.value = n.id;
      opt.textContent = n.id;
      startSelect.appendChild(opt);
    });
    // adjacency list
    const adj = buildAdjacency();
    let html = '';
    nodes.forEach(n=>{
      const arr = adj[n.id] || [];
      html += `<div><strong>${n.id}</strong>: ${arr.join(', ')}</div>`;
    });
    adjListEl.innerHTML = html || '<div class="muted">Graph empty</div>';
    // times table
    rebuildTimesTable();
  }

  function buildAdjacency() {
    const adj = {};
    nodes.forEach(n=>adj[n.id]=[]);
    edges.forEach(e=>{
      adj[e.from].push(e.to);
      if (!directed) {
        if (!adj[e.to].includes(e.from)) adj[e.to].push(e.from);
      }
    });
    // sort neighbors for deterministic behavior
    for (const k in adj) adj[k].sort();
    return adj;
  }

  function draw() {
    ctx.clearRect(0,0,width,height);
    // edges
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#b8c8db';
    ctx.fillStyle = '#b8c8db';
    for (const e of edges) {
      const a = nodes.find(n=>n.id===e.from);
      const b = nodes.find(n=>n.id===e.to);
      if (!a || !b) continue;
      drawEdge(a,b,e);
    }
    // nodes
    for (const n of nodes) {
      drawNode(n);
    }
    // selected node indicator
    if (selectedNode) {
      ctx.beginPath();
      ctx.strokeStyle = '#2b8cff';
      ctx.lineWidth = 2;
      ctx.arc(selectedNode.x, selectedNode.y, NODE_RADIUS+6, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  function drawEdge(a,b,e) {
    const dx = b.x - a.x, dy = b.y - a.y;
    const angle = Math.atan2(dy,dx);
    const ax = a.x + Math.cos(angle)*NODE_RADIUS;
    const ay = a.y + Math.sin(angle)*NODE_RADIUS;
    const bx = b.x - Math.cos(angle)*NODE_RADIUS;
    const by = b.y - Math.sin(angle)*NODE_RADIUS;
    ctx.beginPath();
    ctx.strokeStyle = '#b8c8db';
    ctx.lineWidth = 2;
    ctx.moveTo(ax,ay);
    ctx.lineTo(bx,by);
    ctx.stroke();

    if (directed) {
      // arrowhead
      const size = 8;
      ctx.beginPath();
      ctx.fillStyle = '#b8c8db';
      ctx.moveTo(bx,by);
      ctx.lineTo(bx - Math.cos(angle-Math.PI/8)*size, by - Math.sin(angle-Math.PI/8)*size);
      ctx.lineTo(bx - Math.cos(angle+Math.PI/8)*size, by - Math.sin(angle+Math.PI/8)*size);
      ctx.closePath();
      ctx.fill();
    }
  }

  function drawNode(n) {
    const col = visited[n.id] === undefined || visited[n.id]===0 ? '#fff' : (visited[n.id]===1 ? '#ffd97a' : '#8fd3a8');
    // circle
    ctx.beginPath();
    ctx.fillStyle = col;
    ctx.strokeStyle = '#7c8da1';
    ctx.lineWidth = 2;
    ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    // label
    ctx.fillStyle = '#102b4a';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(n.label, n.x, n.y);
    // discovery/finish small
    const d = disc[n.id] || '';
    const f = finish[n.id] || '';
    ctx.fillStyle = '#385170';
    ctx.font = '11px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`d:${d}`, n.x - NODE_RADIUS+6, n.y + NODE_RADIUS-6);
    ctx.textAlign = 'right';
    ctx.fillText(`f:${f}`, n.x + NODE_RADIUS-6, n.y + NODE_RADIUS-6);
  }

  // Traversal & generators
  function resetTraversal() {
    visited = {};
    disc = {}; finish = {};
    timeCounter = 0;
    visitedOrderEl.textContent = '';
    statusEl.textContent = 'Traversal reset.';
    stackView.textContent = '[empty]';
    timeCounterEl.textContent = '0';
    algoChoiceEl.textContent = 'None';
    generator = null;
    playing = false;
    if (playTimer) { clearInterval(playTimer); playTimer = null; document.getElementById('playBtn').textContent = 'Play'; }
    updateUI();
    draw();
  }

  function startDFS(mode) {
    if (nodes.length===0) { alert('Graph is empty. Add nodes first.'); return; }
    resetTraversal();
    currentAlgo = mode;
    algoChoiceEl.textContent = mode === 'recursive' ? 'Recursive DFS' : 'Iterative DFS';
    const start = startSelect.value || nodes[0].id;
    const adj = buildAdjacency();
    if (!adj[start] || adj[start].length===0) {
      // still allow
    }
    if (mode === 'recursive') {
      generator = recursiveDFSSteps(start, adj);
    } else {
      generator = iterativeDFSSteps(start, adj);
    }
    statusEl.textContent = `Ready. ${mode==='recursive' ? 'Recursive' : 'Iterative'} DFS prepared starting at ${start}. Use Step or Play.`;
    // show initial draw
    draw();
  }

  function stepOnce() {
    if (!generator) {
      statusEl.textContent = 'No algorithm running. Click Run to start.';
      return;
    }
    const res = generator.next();
    if (res.done) {
      statusEl.textContent = 'Traversal complete.';
      generator = null;
      playing = false;
      if (playTimer) { clearInterval(playTimer); playTimer = null; document.getElementById('playBtn').textContent = 'Play'; }
      draw(); updateUI();
      return;
    }
    applyStep(res.value);
    draw(); updateUI();
  }

  function togglePlay() {
    if (!generator) {
      statusEl.textContent = 'No algorithm prepared. Click Run to start.';
      return;
    }
    playing = !playing;
    document.getElementById('playBtn').textContent = playing ? 'Pause' : 'Play';
    if (playing) {
      restartPlayTimer();
    } else {
      if (playTimer) { clearInterval(playTimer); playTimer = null; }
    }
  }

  function restartPlayTimer() {
    if (playTimer) clearInterval(playTimer);
    playTimer = setInterval(()=>{
      if (!generator) { clearInterval(playTimer); playTimer=null; playing=false; document.getElementById('playBtn').textContent='Play'; return; }
      stepOnce();
    }, speed);
  }

  // Steps are objects like {type:'enter',node:'A'} / {type:'finish',node:'A'} / {type:'stack',stack:[]}
  function applyStep(step) {
    if (!step) return;
    if (step.type === 'enter') {
      visited[step.node] = 1;
      timeCounter++;
      disc[step.node] = timeCounter;
      visitedOrderEl.textContent = (visitedOrderEl.textContent ? visitedOrderEl.textContent + ' → ' : '') + step.node;
      statusEl.textContent = `Entered ${step.node}`;
    } else if (step.type === 'finish') {
      visited[step.node] = 2;
      timeCounter++;
      finish[step.node] = timeCounter;
      statusEl.textContent = `Finished ${step.node}`;
    } else if (step.type === 'stack') {
      stackView.textContent = '[' + step.stack.join(', ') + ']';
    } else if (step.type === 'visit') {
      visited[step.node] = 1;
      if (!disc[step.node]) { timeCounter++; disc[step.node] = timeCounter; visitedOrderEl.textContent = (visitedOrderEl.textContent ? visitedOrderEl.textContent + ' → ' : '') + step.node; }
    }
    timeCounterEl.textContent = String(timeCounter);
    rebuildTimesTable();
  }

  function rebuildTimesTable() {
    timesTableBody.innerHTML = '';
    nodes.sort((a,b)=>a.id.localeCompare(b.id)).forEach(n=>{
      const tr = document.createElement('tr');
      const td1 = document.createElement('td'); td1.textContent = n.id;
      const td2 = document.createElement('td'); td2.textContent = disc[n.id] || '';
      const td3 = document.createElement('td'); td3.textContent = finish[n.id] || '';
      tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
      timesTableBody.appendChild(tr);
    });
  }

  // DFS Generators

  // Recursive implementation yields steps at entry, stack updates, neighbor exploration, and finish
  function* recursiveDFSSteps(start, adj) {
    const visitedLocal = {};
    const callStack = [];

    function* visit(u) {
      // enter u
      visitedLocal[u] = 1;
      callStack.push(u);
      yield { type:'enter', node:u };
      yield { type:'stack', stack: [...callStack] };
      const neighbors = adj[u] || [];
      for (const v of neighbors) {
        if (!visitedLocal[v]) {
          // traverse
          yield* visit(v);
          yield { type:'stack', stack: [...callStack] };
        }
      }
      // finish u
      callStack.pop();
      yield { type:'finish', node:u };
      yield { type:'stack', stack: [...callStack] };
    }

    // DFS may need to cover disconnected nodes: we'll start at start, then others
    if (!visitedLocal[start]) yield* visit(start);
    for (const n of nodes.map(x=>x.id)) {
      if (!visitedLocal[n]) yield* visit(n);
    }
  }

  // Iterative implementation uses explicit stack of frames: {node, nextIndex}
  function* iterativeDFSSteps(start, adj) {
    const visitedLocal = {};
    const stack = [];
    const nodesOrder = nodes.map(n=>n.id);
    function push(u) {
      stack.push({ node:u, idx:0 });
      yieldStack();
      if (!visitedLocal[u]) {
        visitedLocal[u] = 1;
        yield { type:'enter', node:u };
        yieldStack();
      }
    }
    function* pushGen(u) { yield* (function*(){})(); } // placeholder

    // Start from start, then remaining nodes for disconnected graphs
    const startOrder = [start, ...nodesOrder.filter(x=>x!==start)];
    for (const s of startOrder) {
      if (visitedLocal[s]) continue;
      stack.push({ node:s, idx:0 });
      yield { type:'stack', stack: stack.map(f=>f.node) };
      visitedLocal[s]=1;
      yield { type:'enter', node:s };
      yield { type:'stack', stack: stack.map(f=>f.node) };

      while (stack.length>0) {
        const frame = stack[stack.length-1];
        const u = frame.node;
        const neighbors = adj[u] || [];
        if (frame.idx < neighbors.length) {
          const v = neighbors[frame.idx];
          frame.idx++;
          if (!visitedLocal[v]) {
            // push and enter v
            stack.push({ node:v, idx:0 });
            yield { type:'stack', stack: stack.map(f=>f.node) };
            visitedLocal[v]=1;
            yield { type:'enter', node:v };
            yield { type:'stack', stack: stack.map(f=>f.node) };
          } else {
            // already visited; continue
            yield { type:'stack', stack: stack.map(f=>f.node) };
          }
        } else {
          // all neighbors done -> finish u
          stack.pop();
          yield { type:'finish', node:u };
          yield { type:'stack', stack: stack.map(f=>f.node) };
        }
      }
    }
  }

  // Initialization
  updateUI();
  draw();

  // keyboard hints
  document.addEventListener('keydown', (e)=>{
    if (e.key === ' ') { e.preventDefault(); togglePlay(); }
    if (e.key === 'Enter') { e.preventDefault(); stepOnce(); }
    if (e.key === 'r') { resetTraversal(); }
  });

  // show some initial sample
  (function seedSample(){
    const spacing = Math.min(width, height) / 4;
    const cx = width/2, cy = height/2;
    createNode(cx - spacing, cy - spacing);
    createNode(cx + spacing, cy - spacing);
    createNode(cx - spacing, cy + spacing);
    createNode(cx + spacing, cy + spacing);
    createNode(cx, cy - spacing/1.6);
    createNode(cx, cy + spacing/1.6);
    addEdge('A','B'); addEdge('A','C'); addEdge('B','D'); addEdge('C','E'); addEdge('E','F'); addEdge('D','F');
    updateUI(); draw();
  })();

})();
</script>
</body>
</html>