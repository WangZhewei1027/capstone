<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive Binary Tree (BST) Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#60a5fa;
      --muted:#94a3b8;
      --node:#0ea5a9;
      --node-text:#001219;
      --edge:#94a3b8;
      --highlight:#f97316;
      --success:#34d399;
      --danger:#fb7185;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071024 0%, #041726 100%);color:#e6eef8}
    .app{
      display:flex;
      gap:18px;
      padding:18px;
      box-sizing:border-box;
      height:100vh;
    }
    .sidebar{
      width:360px;
      min-width:260px;
      max-width:420px;
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      box-sizing:border-box;
      backdrop-filter: blur(6px);
      border:1px solid rgba(255,255,255,0.04);
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow:auto;
    }
    h1{font-size:18px;margin:0 0 6px 0}
    p.lead{margin:0;color:var(--muted);font-size:13px}
    .controls{display:flex;flex-direction:column;gap:10px;margin-top:6px}
    .row{display:flex;gap:8px;align-items:center}
    input[type="number"], input[type="text"], select{
      padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;flex:1;
      outline:none;
    }
    button{
      padding:8px 10px;border-radius:8px;border:none;background:var(--accent);color:#04293a;font-weight:600;cursor:pointer;
      box-shadow:0 2px 8px rgba(96,165,250,0.12);
    }
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);box-shadow:none}
    button.warn{background:var(--danger);color:#fff}
    button.success{background:var(--success);color:#04293a}
    .small{padding:6px 8px;font-size:13px;border-radius:8px}
    .info{font-size:13px;color:var(--muted);padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px dashed rgba(255,255,255,0.02)}
    .svg-wrap{flex:1;min-width:0;display:flex;flex-direction:column;gap:12px}
    .canvas{
      flex:1;
      border-radius:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border:1px solid rgba(255,255,255,0.04);
      position:relative;
      overflow:auto;
      padding:12px;
    }
    svg{width:100%;height:100%}
    .legend{display:flex;gap:8px;align-items:center;color:var(--muted);font-size:13px}
    .dot{width:12px;height:12px;border-radius:50%}
    .dot.node{background:var(--node)}
    .dot.edge{background:var(--edge)}
    .status{font-size:13px;color:var(--muted)}
    .message{font-size:13px;padding:8px;border-radius:8px}
    .msg-success{background:rgba(52,211,153,0.08);color:var(--success);border:1px solid rgba(52,211,153,0.08)}
    .msg-error{background:rgba(251,113,133,0.06);color:var(--danger);border:1px solid rgba(251,113,133,0.06)}
    .traversal-output{display:flex;gap:8px;flex-wrap:wrap;padding:8px;background:rgba(255,255,255,0.01);border-radius:8px}
    .badge{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-weight:600}
    footer{font-size:12px;color:var(--muted);margin-top:8px}
    /* Node styles for SVG using classes */
    .node-circle{fill:var(--node);stroke:#063241;stroke-width:1.5}
    .node-text{font-size:12px;fill:var(--node-text);font-weight:700;text-anchor:middle;dominant-baseline:central}
    .edge-line{stroke:var(--edge);stroke-width:2;stroke-linecap:round}
    .highlight{fill:var(--highlight)!important}
    .search-hit{fill:var(--success)!important}
    .fade{opacity:0.12}
  </style>
</head>
<body>
  <div class="app">
    <div class="sidebar">
      <h1>Binary Tree Visualizer</h1>
      <p class="lead">Interactive demonstration of a Binary Search Tree (BST). Insert, delete, search, and animate traversals.
      Nodes are positioned using an inorder layout for clarity.</p>

      <div class="controls">
        <div class="row">
          <input id="valueInput" type="number" placeholder="Value (integer)" />
          <button id="insertBtn" title="Insert">Insert</button>
          <button id="deleteBtn" title="Delete" class="ghost small">Delete</button>
        </div>

        <div class="row">
          <input id="searchInput" type="number" placeholder="Search value" />
          <button id="searchBtn" class="small">Search</button>
          <button id="clearBtn" class="ghost small">Clear</button>
        </div>

        <div class="row">
          <select id="randomCount">
            <option value="5">Random 5</option>
            <option value="8" selected>Random 8</option>
            <option value="12">Random 12</option>
            <option value="20">Random 20</option>
          </select>
          <button id="randomBtn" class="small">Fill Random BST</button>
          <button id="balancedBtn" class="small ghost">Build from sorted</button>
        </div>

        <div class="row">
          <button data-trav="in" class="traversalBtn small">In-order</button>
          <button data-trav="pre" class="traversalBtn small">Pre-order</button>
          <button data-trav="post" class="traversalBtn small">Post-order</button>
          <button data-trav="level" class="traversalBtn small">Level-order</button>
        </div>

        <div class="row">
          <button id="animateBtn" class="success">Animate Traversal</button>
          <button id="stopAnimBtn" class="ghost">Stop</button>
        </div>

        <div class="info" id="infoBox">
          Tip: Use the "Balanced" button to build a balanced BST from a sorted list of current values.
        </div>

        <div class="status" id="stats">Nodes: 0</div>

        <div class="message msg-success" id="message" style="display:none;"></div>
      </div>

      <div style="flex:1"></div>

      <footer>
        - Click nodes in the canvas to highlight a value. Traversal animations will highlight nodes in order.
      </footer>
    </div>

    <div class="svg-wrap">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="legend">
          <div class="dot node"></div><div style="font-size:13px;color:var(--muted)">Node</div>
          <div class="dot edge" style="margin-left:8px"></div><div style="font-size:13px;color:var(--muted)">Edge</div>
        </div>
        <div class="traversal-output" id="travOut" aria-live="polite" style="min-height:36px">
          <div style="color:var(--muted);padding-right:8px">Traversal:</div>
        </div>
      </div>

      <div class="canvas" id="canvasWrap">
        <svg id="svgCanvas" viewBox="0 0 1200 600" preserveAspectRatio="xMinYMin meet">
          <!-- edges and nodes will be drawn here -->
        </svg>
      </div>
    </div>
  </div>

  <script>
    // Binary Search Tree visualizer
    (function(){
      // Utilities
      const $ = id => document.getElementById(id);
      const svg = $('svgCanvas');
      const valueInput = $('valueInput');
      const searchInput = $('searchInput');
      const insertBtn = $('insertBtn');
      const deleteBtn = $('deleteBtn');
      const searchBtn = $('searchBtn');
      const clearBtn = $('clearBtn');
      const randomBtn = $('randomBtn');
      const randomCount = $('randomCount');
      const balancedBtn = $('balancedBtn');
      const traversalBtns = document.querySelectorAll('.traversalBtn');
      const animateBtn = $('animateBtn');
      const stopAnimBtn = $('stopAnimBtn');
      const stats = $('stats');
      const message = $('message');
      const travOut = $('travOut');

      let nodeIdCounter = 0;
      function createNode(val){
        return { val: Number(val), left: null, right: null, id: ++nodeIdCounter };
      }

      // BST root
      let root = null;

      // For animations
      let animTimer = null;
      let currentAnimList = [];
      let animIndex = 0;

      // Insert (BST)
      function insert(val){
        if (val === '' || val === null || isNaN(val)) { showMessage('Enter a valid integer to insert', 'error'); return; }
        const v = Number(val);
        if (!Number.isFinite(v)) { showMessage('Enter a finite integer', 'error'); return; }
        root = insertRec(root, v);
        render();
        showMessage('Inserted ' + v, 'success');
      }

      function insertRec(node, val){
        if (node === null) return createNode(val);
        if (val === node.val){
          // duplicates not allowed in this BST implementation
          showMessage('Value ' + val + ' already exists (duplicates ignored)', 'error');
          return node;
        }
        if (val < node.val) node.left = insertRec(node.left, val);
        else node.right = insertRec(node.right, val);
        return node;
      }

      // Delete
      function deleteVal(val){
        if (val === '' || val === null || isNaN(val)) { showMessage('Enter a valid integer to delete', 'error'); return; }
        const v = Number(val);
        let existed = {flag:false};
        root = deleteRec(root, v, existed);
        if (existed.flag) {
          render();
          showMessage('Deleted ' + v, 'success');
        } else {
          showMessage('Value ' + v + ' not found', 'error');
        }
      }

      function deleteRec(node, val, existed){
        if (!node) return null;
        if (val < node.val) node.left = deleteRec(node.left, val, existed);
        else if (val > node.val) node.right = deleteRec(node.right, val, existed);
        else { // found
          existed.flag = true;
          // 0 or 1 child
          if (!node.left) return node.right;
          if (!node.right) return node.left;
          // 2 children: find inorder successor (smallest in right subtree)
          let succ = node.right;
          while (succ.left) succ = succ.left;
          node.val = succ.val;
          node.right = deleteRec(node.right, succ.val, existed);
        }
        return node;
      }

      // Search (returns path of nodes visited)
      function search(val){
        if (val === '' || val === null || isNaN(val)) { showMessage('Enter a valid integer to search', 'error'); return []; }
        const v = Number(val);
        let path = [];
        let node = root;
        while (node){
          path.push(node);
          if (v === node.val) break;
          node = v < node.val ? node.left : node.right;
        }
        if (path.length && path[path.length-1].val === v){
          showMessage('Found ' + v, 'success');
        } else {
          showMessage('Value ' + v + ' not found', 'error');
        }
        return path;
      }

      // Traversals
      function inorder(node, out){ if(!node) return; inorder(node.left,out); out.push(node); inorder(node.right,out); }
      function preorder(node,out){ if(!node) return; out.push(node); preorder(node.left,out); preorder(node.right,out); }
      function postorder(node,out){ if(!node) return; postorder(node.left,out); postorder(node.right,out); out.push(node); }
      function levelorder(node,out){
        if(!node) return;
        const q=[node];
        while(q.length){
          const n=q.shift();
          out.push(n);
          if(n.left) q.push(n.left);
          if(n.right) q.push(n.right);
        }
      }

      // Layout: assign x,y to nodes using inorder index
      function layoutTree(rootNode){
        const positions = new Map(); // id -> {x,y}
        const nodeList = [];
        function collect(node, depth=0){
          if(!node) return;
          collect(node.left, depth+1);
          nodeList.push({node, depth});
          collect(node.right, depth+1);
        }
        collect(rootNode,0);
        const levels = nodeList.reduce((acc,cur)=>{
          acc[cur.depth] = (acc[cur.depth]||0)+1; return acc;
        },[]);
        // horizontal spacing based on inorder index
        const width = 1100; // internal viewbox width
        const height = 520;
        const hPad = 40;
        const availableW = width - 2*hPad;
        const step = nodeList.length>0 ? availableW / (nodeList.length) : availableW;
        // build map of inorder index
        let idx=0;
        for(const item of nodeList){
          const centerX = hPad + idx*step + step/2;
          const centerY = 60 + item.depth * 90;
          positions.set(item.node.id, {x:centerX, y:centerY});
          idx++;
        }
        return positions;
      }

      // Render to SVG
      function render(){
        clearSVG();
        if(!root){
          stats.textContent = 'Nodes: 0';
          travOut.innerHTML = '<div style="color:var(--muted);padding-right:8px">Traversal:</div>';
          return;
        }
        const positions = layoutTree(root);
        // draw edges first
        function drawEdges(node){
          if(!node) return;
          const p = positions.get(node.id);
          if(node.left){
            const c = positions.get(node.left.id);
            drawEdge(p.x, p.y, c.x, c.y);
            drawEdges(node.left);
          }
          if(node.right){
            const c = positions.get(node.right.id);
            drawEdge(p.x, p.y, c.x, c.y);
            drawEdges(node.right);
          }
        }
        drawEdges(root);

        // draw nodes
        function drawNodes(node){
          if(!node) return;
          const p = positions.get(node.id);
          drawNode(node, p.x, p.y);
          drawNodes(node.left);
          drawNodes(node.right);
        }
        drawNodes(root);

        stats.textContent = 'Nodes: ' + countNodes(root);
      }

      function clearSVG(){
        while(svg.firstChild) svg.removeChild(svg.firstChild);
      }

      function drawEdge(x1,y1,x2,y2){
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',x1);
        line.setAttribute('y1',y1+14); // slightly below center of parent
        line.setAttribute('x2',x2);
        line.setAttribute('y2',y2-14); // slightly above center of child
        line.classList.add('edge-line');
        svg.appendChild(line);
      }

      function drawNode(node, x, y){
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('transform', `translate(${x},${y})`);
        g.setAttribute('data-id', node.id);
        g.style.cursor = 'pointer';

        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('r', 18);
        circle.classList.add('node-circle');
        circle.setAttribute('data-id', node.id);

        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.classList.add('node-text');
        text.textContent = node.val;
        text.setAttribute('data-id', node.id);

        g.appendChild(circle);
        g.appendChild(text);
        svg.appendChild(g);

        // click to show value and highlight
        g.addEventListener('click', (e)=>{
          e.stopPropagation();
          highlightPath([node], {style:'search'}); // briefly highlight node
          showMessage('Clicked node: ' + node.val, 'success');
        });
      }

      function countNodes(node){
        if(!node) return 0;
        return 1 + countNodes(node.left) + countNodes(node.right);
      }

      // Highlight sequence of nodes (by node objects)
      function highlightPath(nodes, opts={}){
        // clear existing highlights
        clearHighlight();
        if(!nodes || nodes.length===0) return;
        if(opts.instant){
          nodes.forEach(n => colorNodeById(n.id, opts.style || 'highlight'));
          return;
        }
        // animate: highlight one by one then clear after short time
        let i=0;
        const style = opts.style || 'highlight';
        const interval = opts.interval || 350;
        const id = setInterval(()=>{
          if(i>0) { // fade previous slightly
            colorNodeById(nodes[i-1].id, 'fade');
          }
          if(i >= nodes.length){ clearInterval(id); return; }
          colorNodeById(nodes[i].id, style);
          i++;
        }, interval);
        setTimeout(()=> {
          clearInterval(id);
        }, interval*(nodes.length+1));
      }

      function colorNodeById(nodeId, mode){
        // find circle with data-id
        const circles = svg.querySelectorAll('circle[data-id="'+nodeId+'"]');
        circles.forEach(c=>{
          c.classList.remove('highlight','search-hit','fade');
          if(mode === 'highlight') c.classList.add('highlight');
          else if(mode === 'search') c.classList.add('search-hit');
          else if(mode === 'fade') c.classList.add('fade');
          else if(mode === 'search-hit') c.classList.add('search-hit');
        });
      }

      function clearHighlight(){
        const nodes = svg.querySelectorAll('circle');
        nodes.forEach(n=>{ n.classList.remove('highlight','search-hit','fade'); });
      }

      // Messages
      function showMessage(txt, type='info', timeout=2600){
        message.style.display = 'block';
        message.textContent = txt;
        if(type === 'success'){ message.className = 'message msg-success'; }
        else if(type === 'error'){ message.className = 'message msg-error'; }
        else { message.className = 'message'; }
        if(timeout>0){
          clearTimeout(message._t);
          message._t = setTimeout(()=> message.style.display='none', timeout);
        }
      }

      // Traversal output display
      function showTraversalList(list){
        travOut.innerHTML = '<div style="color:var(--muted);padding-right:8px">Traversal:</div>';
        list.forEach(n=>{
          const b = document.createElement('div');
          b.className = 'badge';
          b.textContent = n.val;
          travOut.appendChild(b);
        });
      }

      // Animation controls
      function animateTraversal(list, interval=520){
        stopAnimation();
        if(!list || !list.length) return;
        currentAnimList = list;
        animIndex = 0;
        clearHighlight();
        animTimer = setInterval(()=>{
          if(animIndex>0){
            // fade previous
            colorNodeById(currentAnimList[animIndex-1].id, 'fade');
          }
          if(animIndex >= currentAnimList.length){
            stopAnimation();
            return;
          }
          colorNodeById(currentAnimList[animIndex].id, 'highlight');
          animIndex++;
        }, interval);
      }

      function stopAnimation(){
        if(animTimer){ clearInterval(animTimer); animTimer = null; }
      }

      // Helpers: random fill
      function fillRandom(n){
        root = null; nodeIdCounter = 0;
        const set = new Set();
        while(set.size < n){
          // random integers -50..+99
          const v = Math.floor(Math.random()*150) - 50;
          set.add(v);
        }
        const arr = Array.from(set);
        arr.forEach(v=> root = insertRec(root, v));
        render();
        showMessage('Inserted ' + arr.length + ' random values', 'success');
      }

      // Build balanced BST from sorted values (create minimal-height BST)
      function buildBalancedFromValues(values){
        if(values.length === 0) return null;
        const mid = Math.floor(values.length / 2);
        const node = createNode(values[mid]);
        node.left = buildBalancedFromValues(values.slice(0,mid));
        node.right = buildBalancedFromValues(values.slice(mid+1));
        return node;
      }

      function buildBalanced(){
        // collect current values and build balanced BST
        const vals = [];
        inorder(root, vals);
        const nums = vals.map(n=>n.val).sort((a,b)=>a-b);
        // reset ids so nodes get fresh ids
        nodeIdCounter = 0;
        root = buildBalancedFromValues(nums);
        render();
        showMessage('Built balanced BST from current values', 'success');
      }

      // Event wiring
      insertBtn.addEventListener('click', ()=>{ insert(valueInput.value); valueInput.focus(); });
      deleteBtn.addEventListener('click', ()=>{ deleteVal(valueInput.value || searchInput.value); });
      searchBtn.addEventListener('click', ()=>{
        const path = search(searchInput.value || valueInput.value);
        if(path.length){
          highlightPath(path, {interval:420, style:'search'});
        }
        // show visited nodes values in travOut
        showTraversalList(path);
      });
      clearBtn.addEventListener('click', ()=>{
        root = null; nodeIdCounter = 0; clearSVG(); stats.textContent = 'Nodes: 0';
        travOut.innerHTML = '<div style="color:var(--muted);padding-right:8px">Traversal:</div>';
        showMessage('Cleared tree', 'success');
      });

      randomBtn.addEventListener('click', ()=> fillRandom(Number(randomCount.value)));
      balancedBtn.addEventListener('click', ()=> buildBalanced());

      traversalBtns.forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const type = btn.getAttribute('data-trav');
          const list = [];
          if(type === 'in') inorder(root,list);
          if(type === 'pre') preorder(root,list);
          if(type === 'post') postorder(root,list);
          if(type === 'level') levelorder(root,list);
          if(list.length===0){ showMessage('Tree is empty', 'error'); return; }
          showTraversalList(list);
          // small flash
          highlightPath(list, {interval:340, style:'highlight'});
        });
      });

      animateBtn.addEventListener('click', ()=>{
        // by default animate in-order
        const list = [];
        inorder(root,list);
        if(list.length===0){ showMessage('Tree is empty', 'error'); return; }
        showTraversalList(list);
        animateTraversal(list, 520);
      });

      stopAnimBtn.addEventListener('click', ()=> stopAnimation());

      // canvas click clears highlight
      $('canvasWrap').addEventListener('click', ()=> clearHighlight());

      // keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){
          if(document.activeElement === searchInput) searchBtn.click();
          else insertBtn.click();
        }
      });

      // initial demo tree
      function initialDemo(){
        const demo = [50,30,70,20,40,60,80,10,25,35,45];
        root = null; nodeIdCounter = 0;
        demo.forEach(v => root = insertRec(root, v));
        render();
      }

      // initial render and message
      initialDemo();
      showMessage('Demo tree loaded â€” try inserting, deleting, searching, and animating traversals', 'success', 4000);

      // Expose some small helpers to global for debugging (optional)
      window._bst = {
        getRoot: ()=>root,
        insert: (v)=>{ insert(v); },
        delete: (v)=>{ deleteVal(v); },
        inorder: ()=>{ const out=[]; inorder(root,out); return out.map(n=>n.val); }
      };

    })();
  </script>
</body>
</html>