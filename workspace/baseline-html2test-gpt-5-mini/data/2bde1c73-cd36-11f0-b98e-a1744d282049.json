{
  "id": "2bde1c73-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:44.887Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\" />\n<title>Interactive Graph (Directed / Undirected)</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, Arial; margin: 0; height: 100vh; display: flex; }\n  #left { width: 72%; position: relative; background: #f6f8fa; border-right: 1px solid #ddd; }\n  #right { width: 28%; padding: 12px; box-sizing: border-box; overflow: auto; }\n  canvas { display: block; width: 100%; height: 100%; background: #fff; cursor: crosshair; }\n  header { padding: 10px 12px; border-bottom: 1px solid #e3e6ea; background: #fff; display:flex; align-items:center; gap:12px; }\n  .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n  button, select, input[type=\"button\"], input[type=\"checkbox\"] { padding:6px 8px; border-radius:6px; border:1px solid #c8ccd1; background:#fff; cursor:pointer; }\n  .panel { padding: 10px 0; }\n  label { font-size: 13px; }\n  .small { font-size: 12px; color: #444; }\n  pre { background:#f3f4f6; padding:8px; border-radius:6px; max-height:260px; overflow:auto; border:1px solid #e6e7ea; }\n  .muted { color:#666; font-size:13px; }\n  .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; }\n  .flex { display:flex; gap:8px; flex-wrap:wrap; }\n  .kbd { background:#eef1f6; padding:4px 6px; border-radius:4px; font-size:12px; border:1px solid #e1e4e8; }\n  footer { font-size:12px; color:#666; margin-top:8px; }\n  .selected { outline: 3px solid rgba(21,156,228,0.18); }\n</style>\n</head>\n<body>\n  <div id=\"left\">\n    <header>\n      <div style=\"flex:1;\">\n        <strong>Interactive Graph</strong>\n        <div class=\"small muted\">Create nodes & edges, drag nodes, toggle Directed/Undirected, show adjacency matrix/list, compute shortest path.</div>\n      </div>\n      <div class=\"controls\">\n        <label><input id=\"directedToggle\" type=\"checkbox\" checked> Directed</label>\n        <select id=\"mode\">\n          <option value=\"addNode\">Add Node (double-click)</option>\n          <option value=\"addEdge\">Add Edge (click source → target)</option>\n          <option value=\"move\">Move / Select</option>\n        </select>\n        <button id=\"btnClear\">Clear</button>\n        <button id=\"btnRandom\">Random</button>\n        <button id=\"btnExport\">Export</button>\n      </div>\n    </header>\n    <canvas id=\"c\"></canvas>\n    <div style=\"position:absolute; right:12px; bottom:12px; background:rgba(255,255,255,0.95); border:1px solid #ddd; padding:8px; border-radius:8px;\">\n      <div class=\"muted\" style=\"font-size:13px;\">Mode: <span id=\"modeLabel\">Add Node</span></div>\n      <div class=\"small muted\">Nodes: <span id=\"countNodes\">0</span> &nbsp; Edges: <span id=\"countEdges\">0</span></div>\n    </div>\n  </div>\n\n  <div id=\"right\">\n    <div class=\"panel\">\n      <div class=\"row\">\n        <label>Edge weight <input id=\"edgeWeight\" type=\"number\" value=\"1\" style=\"width:70px\"></label>\n        <button id=\"btnDelete\">Delete Selected</button>\n      </div>\n      <div class=\"row\">\n        <button id=\"btnPath\">Compute Shortest Path</button>\n        <select id=\"fromNode\"></select>\n        <select id=\"toNode\"></select>\n      </div>\n      <div class=\"row\">\n        <button id=\"btnAdjList\">Show Adjacency List</button>\n        <button id=\"btnAdjMatrix\">Show Adjacency Matrix</button>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div style=\"font-weight:600; margin-bottom:6px;\">Graph JSON</div>\n      <textarea id=\"jsonOut\" style=\"width:100%; height:110px; box-sizing:border-box; padding:8px; border-radius:6px; border:1px solid #e5e7ea;\"></textarea>\n      <div style=\"display:flex; gap:8px; margin-top:8px;\">\n        <button id=\"btnLoad\">Load JSON</button>\n        <button id=\"btnCopy\">Copy</button>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div style=\"font-weight:600; margin-bottom:6px;\">Adjacency Output</div>\n      <pre id=\"adjOutput\">(Press \"Show Adjacency List\" or \"Matrix\")</pre>\n    </div>\n\n    <div class=\"panel\">\n      <div style=\"font-weight:600; margin-bottom:6px;\">Instructions</div>\n      <ul class=\"small\">\n        <li>Double-click canvas to add nodes (in Add Node mode).</li>\n        <li>In Add Edge mode: click a source node then a target node to create an edge. Self-loops allowed.</li>\n        <li>Move mode: drag nodes to reposition. Click a node to select. Use Delete Selected to remove it.</li>\n        <li>Toggle Directed to switch how edges are interpreted and drawn.</li>\n        <li>Use Shortest Path to compute path (Dijkstra if weights ≠ 1, else BFS).</li>\n      </ul>\n    </div>\n\n    <footer>Tip: Click \"Random\" to generate a sample graph. Export to JSON to save.</footer>\n  </div>\n\n<script>\n(() => {\n  // Canvas setup\n  const canvas = document.getElementById('c');\n  const ctx = canvas.getContext('2d');\n  let DPR = window.devicePixelRatio || 1;\n\n  function resize() {\n    const rect = canvas.getBoundingClientRect();\n    canvas.width = Math.floor(rect.width * DPR);\n    canvas.height = Math.floor((window.innerHeight - document.querySelector('header').offsetHeight) * DPR);\n    canvas.style.height = (window.innerHeight - document.querySelector('header').offsetHeight) + 'px';\n    draw();\n  }\n  window.addEventListener('resize', resize);\n  window.addEventListener('orientationchange', resize);\n\n  // Graph data\n  let nodes = []; // {id, x, y}\n  let edges = []; // {id, from, to, w}\n  let nextNodeId = 1, nextEdgeId = 1;\n  let directed = true;\n\n  // Interaction state\n  let modeEl = document.getElementById('mode');\n  let modeLabel = document.getElementById('modeLabel');\n  let mode = modeEl.value;\n  let directedToggle = document.getElementById('directedToggle');\n  let edgeWeightEl = document.getElementById('edgeWeight');\n  let selectedNode = null;\n  let selectedEdge = null;\n  let dragOffset = {x:0,y:0};\n  let creatingEdgeFrom = null;\n  let highlightPath = [];\n  let hover = {node:null, edge:null};\n\n  // UI elements\n  const countNodesEl = document.getElementById('countNodes');\n  const countEdgesEl = document.getElementById('countEdges');\n  const fromSel = document.getElementById('fromNode');\n  const toSel = document.getElementById('toNode');\n  const jsonOut = document.getElementById('jsonOut');\n  const adjOutput = document.getElementById('adjOutput');\n\n  function updateCounts() {\n    countNodesEl.textContent = nodes.length;\n    countEdgesEl.textContent = edges.length;\n    updateNodeSelects();\n  }\n\n  function updateNodeSelects() {\n    [fromSel, toSel].forEach(sel => {\n      const val = sel.value;\n      sel.innerHTML = '';\n      nodes.forEach(n => {\n        const o = document.createElement('option');\n        o.value = n.id;\n        o.textContent = n.id;\n        sel.appendChild(o);\n      });\n      if (nodes.some(n=>n.id==val)) sel.value = val;\n    });\n  }\n\n  function toCanvasCoords(ev) {\n    const rect = canvas.getBoundingClientRect();\n    const x = (ev.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (ev.clientY - rect.top) * (canvas.height / rect.height);\n    return {x, y};\n  }\n\n  function findNodeAt(x, y) {\n    // nodes drawn with radius r\n    for (let i=nodes.length-1;i>=0;i--) {\n      const n = nodes[i];\n      const dx = x - n.x, dy = y - n.y, r = NODE_RADIUS;\n      if (dx*dx + dy*dy <= r*r) return n;\n    }\n    return null;\n  }\n\n  function findEdgeAt(x, y) {\n    // simple hit-testing: distance to segment small\n    for (let i=edges.length-1;i>=0;i--) {\n      const e = edges[i];\n      const a = getNodeById(e.from);\n      const b = getNodeById(e.to);\n      if (!a || !b) continue;\n      if (e.from===e.to) {\n        // self-loop: circle near node\n        const loopCenter = {x: a.x + 40*DPR, y: a.y - 40*DPR};\n        const dx = x - loopCenter.x, dy = y - loopCenter.y;\n        if (Math.hypot(dx,dy) <= 20*DPR) return e;\n        continue;\n      }\n      const dist = pointSegmentDistance({x,y}, a, b);\n      if (dist <= 8*DPR) return e;\n    }\n    return null;\n  }\n\n  function pointSegmentDistance(p, a, b) {\n    const vx = b.x - a.x, vy = b.y - a.y;\n    const wx = p.x - a.x, wy = p.y - a.y;\n    const c1 = vx*wx + vy*wy;\n    if (c1 <= 0) return Math.hypot(p.x-a.x, p.y-a.y);\n    const c2 = vx*vx + vy*vy;\n    if (c2 <= c1) return Math.hypot(p.x-b.x, p.y-b.y);\n    const t = c1 / c2;\n    const projx = a.x + t*vx, projy = a.y + t*vy;\n    return Math.hypot(p.x-projx, p.y-projy);\n  }\n\n  function getNodeById(id) { return nodes.find(n=>n.id===id); }\n  function getEdgeById(id) { return edges.find(e=>e.id===id); }\n\n  // Drawing constants\n  const NODE_RADIUS = 18 * DPR;\n  const FONT_SIZE = 12 * DPR;\n\n  function draw() {\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    // background grid\n    drawGrid();\n\n    // edges\n    for (const e of edges) {\n      drawEdge(e, highlightPath.includes(e.id) ? '#f39c12' : '#888', (selectedEdge && selectedEdge.id===e.id) ? 3 : 1.5);\n    }\n    // nodes\n    for (const n of nodes) drawNode(n, (selectedNode && selectedNode.id===n.id) ? '#159ce4' : (hover.node && hover.node.id===n.id ? '#2b90ff' : '#222'));\n    // action hints\n    if (creatingEdgeFrom) {\n      // draw line from source to cursor\n      ctx.save();\n      ctx.strokeStyle = '#2b90ff';\n      ctx.lineWidth = 2*DPR;\n      ctx.setLineDash([6*DPR,6*DPR]);\n      ctx.beginPath();\n      ctx.moveTo(creatingEdgeFrom.x, creatingEdgeFrom.y);\n      ctx.lineTo(mousePos.x, mousePos.y);\n      ctx.stroke();\n      ctx.restore();\n    }\n  }\n\n  function drawGrid() {\n    const step = 30 * DPR;\n    ctx.save();\n    ctx.fillStyle = '#ffffff';\n    ctx.fillRect(0,0,canvas.width,canvas.height);\n    ctx.strokeStyle = '#f0f2f4';\n    ctx.lineWidth = 1;\n    for (let x=0.5; x<canvas.width; x+=step) {\n      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();\n    }\n    for (let y=0.5; y<canvas.height; y+=step) {\n      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawNode(n, color='#222') {\n    ctx.save();\n    ctx.beginPath();\n    ctx.fillStyle = '#ffffff';\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2*DPR;\n    ctx.shadowColor = 'rgba(0,0,0,0.08)';\n    ctx.shadowBlur = 6*DPR;\n    ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI*2);\n    ctx.fill();\n    ctx.stroke();\n    ctx.shadowBlur = 0;\n    // label\n    ctx.fillStyle = '#111';\n    ctx.font = `${FONT_SIZE}px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(n.id), n.x, n.y);\n    ctx.restore();\n  }\n\n  function drawEdge(e, color='#888', width=1.5) {\n    const a = getNodeById(e.from);\n    const b = getNodeById(e.to);\n    if (!a || !b) return;\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = width*DPR;\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    if (e.from === e.to) {\n      // self-loop: draw circle on top-right\n      const cx = a.x + 40*DPR, cy = a.y - 40*DPR, r = 20*DPR;\n      ctx.arc(cx, cy, r, 0, Math.PI*2);\n      ctx.stroke();\n      // weight label\n      if (e.w != null) {\n        ctx.fillStyle = '#222';\n        ctx.font = `${FONT_SIZE}px sans-serif`;\n        ctx.fillText(String(e.w), cx + r + 8*DPR, cy - r - 4*DPR);\n      }\n      // arrowhead if directed\n      if (directed) {\n        drawArrowheadAt({x: cx + r, y: cy}, a, color);\n      }\n    } else {\n      // line from edge of circle to edge of circle\n      const dx = b.x - a.x, dy = b.y - a.y;\n      const dist = Math.hypot(dx,dy);\n      const ux = dx / dist, uy = dy / dist;\n      const startX = a.x + ux * NODE_RADIUS;\n      const startY = a.y + uy * NODE_RADIUS;\n      const endX = b.x - ux * NODE_RADIUS;\n      const endY = b.y - uy * NODE_RADIUS;\n\n      ctx.beginPath();\n      ctx.moveTo(startX, startY);\n      ctx.lineTo(endX, endY);\n      ctx.stroke();\n\n      // weight label near midpoint\n      if (e.w != null) {\n        const mx = (startX + endX)/2, my = (startY + endY)/2;\n        ctx.save();\n        ctx.fillStyle = '#222';\n        ctx.font = `${FONT_SIZE}px sans-serif`;\n        ctx.translate(mx, my);\n        ctx.rotate(Math.atan2(dy,dx));\n        ctx.fillText(String(e.w), 0, -6*DPR);\n        ctx.restore();\n      }\n\n      // arrowhead if directed\n      if (directed) {\n        // draw arrow at end\n        drawArrowhead({x:startX,y:startY},{x:endX,y:endY}, color);\n      }\n    }\n    ctx.restore();\n  }\n\n  function drawArrowhead(from, to, color) {\n    const angle = Math.atan2(to.y - from.y, to.x - from.x);\n    const size = 10 * DPR;\n    ctx.save();\n    ctx.fillStyle = color;\n    ctx.translate(to.x, to.y);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(0,0);\n    ctx.lineTo(-size, size*0.6);\n    ctx.lineTo(-size, -size*0.6);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawArrowheadAt(point, towardNode, color) {\n    // small arrow pointing from point toward node (for self-loop)\n    const angle = Math.atan2(towardNode.y - point.y, towardNode.x - point.x);\n    const size = 8 * DPR;\n    ctx.save();\n    ctx.fillStyle = color;\n    ctx.translate(point.x, point.y);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(0,0);\n    ctx.lineTo(-size, size*0.6);\n    ctx.lineTo(-size, -size*0.6);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Mouse events\n  let mousePos = {x:0,y:0};\n  let isDown = false;\n  let dragNode = null;\n\n  canvas.addEventListener('mousemove', ev => {\n    mousePos = toCanvasCoords(ev);\n    hover.node = findNodeAt(mousePos.x, mousePos.y);\n    hover.edge = hover.node ? null : findEdgeAt(mousePos.x, mousePos.y);\n    if (isDown && dragNode && mode === 'move') {\n      dragNode.x = mousePos.x;\n      dragNode.y = mousePos.y;\n      draw();\n    }\n    draw();\n  });\n\n  canvas.addEventListener('mousedown', ev => {\n    isDown = true;\n    const pos = toCanvasCoords(ev);\n    const n = findNodeAt(pos.x, pos.y);\n    if (mode === 'move') {\n      if (n) {\n        dragNode = n;\n        selectedNode = n;\n        selectedEdge = null;\n        dragOffset.x = n.x - pos.x;\n        dragOffset.y = n.y - pos.y;\n      } else {\n        // clicked on empty space: clear selection\n        selectedNode = null;\n        selectedEdge = null;\n      }\n    } else if (mode === 'addEdge') {\n      if (n) {\n        // start or complete edge\n        if (!creatingEdgeFrom) {\n          creatingEdgeFrom = n;\n        } else {\n          // create edge from creatingEdgeFrom to n\n          addEdge(creatingEdgeFrom.id, n.id, Number(edgeWeightEl.value) || 1);\n          creatingEdgeFrom = null;\n        }\n      } else {\n        // clicked empty -> cancel edge creation\n        creatingEdgeFrom = null;\n      }\n    } else if (mode === 'addNode') {\n      // nothing on mousedown; double-click adds node (see dblclick)\n    }\n    draw();\n  });\n\n  canvas.addEventListener('mouseup', ev => {\n    isDown = false;\n    dragNode = null;\n  });\n\n  canvas.addEventListener('click', ev => {\n    const pos = toCanvasCoords(ev);\n    const n = findNodeAt(pos.x, pos.y);\n    const e = findEdgeAt(pos.x, pos.y);\n    if (mode === 'move') {\n      if (n) {\n        selectedNode = n;\n        selectedEdge = null;\n      } else if (e) {\n        selectedEdge = e;\n        selectedNode = null;\n      } else {\n        selectedNode = null;\n        selectedEdge = null;\n      }\n      draw();\n    } else if (mode === 'addEdge') {\n      // clicks handled in mousedown\n    }\n  });\n\n  canvas.addEventListener('dblclick', ev => {\n    if (mode !== 'addNode') return;\n    const pos = toCanvasCoords(ev);\n    addNode(pos.x, pos.y);\n  });\n\n  // Data operations\n  function addNode(x,y,id=null) {\n    const nid = id || nextNodeId++;\n    nodes.push({id: nid, x, y});\n    updateCounts();\n    draw();\n  }\n\n  function addEdge(a,b,w=1,id=null) {\n    // prevent duplicate identical directed edges? allow duplicates but show separately.\n    edges.push({id: id || nextEdgeId++, from: a, to: b, w: w});\n    updateCounts();\n    draw();\n  }\n\n  function deleteSelected() {\n    if (selectedNode) {\n      // remove node and edges incident\n      edges = edges.filter(e => e.from !== selectedNode.id && e.to !== selectedNode.id);\n      nodes = nodes.filter(n => n.id !== selectedNode.id);\n      selectedNode = null;\n      updateCounts();\n      draw();\n    } else if (selectedEdge) {\n      edges = edges.filter(e => e.id !== selectedEdge.id);\n      selectedEdge = null;\n      updateCounts();\n      draw();\n    }\n  }\n\n  function clearGraph() {\n    nodes = []; edges = []; nextNodeId = 1; nextEdgeId = 1;\n    selectedNode = selectedEdge = creatingEdgeFrom = null;\n    updateCounts(); draw();\n  }\n\n  function randomGraph(n=6, p=0.25) {\n    clearGraph();\n    // place nodes in circle\n    const w = canvas.width, h = canvas.height;\n    const cx = w/2, cy = h/2, r = Math.min(w,h)/3;\n    for (let i=0;i<n;i++) {\n      const ang = i/n * Math.PI*2;\n      addNode(cx + Math.cos(ang)*r, cy + Math.sin(ang)*r);\n    }\n    for (let i=0;i<n;i++) for (let j=0;j<n;j++) {\n      if (i === j) continue;\n      if (Math.random() < p) addEdge(nodes[i].id, nodes[j].id, 1);\n    }\n    updateCounts(); draw();\n  }\n\n  // Adjacency list and matrix\n  function buildAdj() {\n    const adj = {};\n    nodes.forEach(n => adj[n.id] = []);\n    for (const e of edges) {\n      adj[e.from].push({to: e.to, w: e.w});\n      if (!directed) adj[e.to].push({to: e.from, w: e.w});\n    }\n    return adj;\n  }\n\n  function showAdjList() {\n    const adj = buildAdj();\n    let out = '';\n    for (const nid of Object.keys(adj)) {\n      const arr = adj[nid].map(x => `${x.to}${x.w!=null ? '('+x.w+')' : ''}`).join(', ');\n      out += `${nid} → ${arr}\\n`;\n    }\n    adjOutput.textContent = out || '(empty)';\n  }\n\n  function showAdjMatrix() {\n    const ids = nodes.map(n=>n.id).sort((a,b)=>a-b);\n    const idIndex = {}; ids.forEach((id,i)=>idIndex[id]=i);\n    const n = ids.length;\n    const mat = Array.from({length:n},()=>Array.from({length:n},()=>0));\n    for (const e of edges) {\n      const i = idIndex[e.from], j = idIndex[e.to];\n      if (i==null||j==null) continue;\n      mat[i][j] = e.w != null ? Number(e.w) : 1;\n      if (!directed) mat[j][i] = mat[i][j];\n    }\n    let out = '\\t' + ids.join('\\t') + '\\n';\n    for (let i=0;i<n;i++){\n      out += ids[i] + '\\t' + mat[i].join('\\t') + '\\n';\n    }\n    adjOutput.textContent = out || '(empty)';\n  }\n\n  // Shortest path (BFS if all weights 1, else Dijkstra)\n  function computeShortestPath(aId, bId) {\n    if (aId === bId) return [aId];\n    const adj = buildAdj();\n    // detect if weights are all 1\n    let allOnes = true;\n    for (const e of edges) if ((e.w || 1) !== 1) { allOnes = false; break; }\n    if (allOnes) {\n      // BFS\n      const q = [aId];\n      const prev = {};\n      prev[aId] = null;\n      while (q.length) {\n        const u = q.shift();\n        for (const nb of (adj[u]||[])) {\n          if (prev[nb.to] !== undefined) continue;\n          prev[nb.to] = u;\n          if (nb.to === bId) {\n            // reconstruct\n            const path = [];\n            let cur = bId;\n            while (cur!=null) { path.push(cur); cur = prev[cur]; }\n            return path.reverse();\n          }\n          q.push(nb.to);\n        }\n      }\n      return null;\n    } else {\n      // Dijkstra\n      const dist = {}, prev = {};\n      const Q = new Set(nodes.map(n=>n.id));\n      nodes.forEach(n=>{ dist[n.id] = Infinity; prev[n.id] = null; });\n      dist[aId] = 0;\n      while (Q.size) {\n        // pick min\n        let u = null, best = Infinity;\n        for (const id of Q) if (dist[id] < best) { best = dist[id]; u = id; }\n        if (u === null) break;\n        Q.delete(u);\n        if (u === bId) break;\n        for (const nb of (adj[u]||[])) {\n          const alt = dist[u] + (Number(nb.w) || 1);\n          if (alt < dist[nb.to]) { dist[nb.to] = alt; prev[nb.to] = u; }\n        }\n      }\n      if (dist[bId] === Infinity) return null;\n      const path = []; let cur = bId;\n      while (cur != null) { path.push(cur); cur = prev[cur]; }\n      return path.reverse();\n    }\n  }\n\n  // Export / Import\n  function exportJSON() {\n    const obj = {directed, nodes: nodes.map(n=>({id:n.id,x:n.x,y:n.y})), edges: edges.map(e=>({id:e.id,from:e.from,to:e.to,w:e.w}))};\n    jsonOut.value = JSON.stringify(obj, null, 2);\n  }\n\n  function loadJSON() {\n    try {\n      const obj = JSON.parse(jsonOut.value);\n      if (!obj.nodes || !obj.edges) throw new Error('Invalid format');\n      directed = !!obj.directed;\n      directedToggle.checked = directed;\n      nodes = obj.nodes.map(n=>({id:n.id,x:n.x,y:n.y}));\n      edges = obj.edges.map(e=>({id:e.id,from:e.from,to:e.to,w:e.w}));\n      nextNodeId = (nodes.reduce((max,n)=>Math.max(max,n.id),0) || 0) + 1;\n      nextEdgeId = (edges.reduce((max,e)=>Math.max(max,e.id),0) || 0) + 1;\n      selectedNode = selectedEdge = creatingEdgeFrom = null;\n      updateCounts();\n      draw();\n    } catch (err) {\n      alert('Failed to load JSON: ' + err.message);\n    }\n  }\n\n  // Helpers\n  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}\n\n  // UI wiring\n  document.getElementById('mode').addEventListener('change', e => {\n    mode = e.target.value;\n    modeLabel.textContent = e.target.options[e.target.selectedIndex].text;\n    creatingEdgeFrom = null;\n    selectedNode = selectedEdge = null;\n    draw();\n  });\n\n  directedToggle.addEventListener('change', e => {\n    directed = e.target.checked;\n    draw();\n    updateCounts();\n  });\n\n  document.getElementById('btnClear').addEventListener('click', clearGraph);\n  document.getElementById('btnRandom').addEventListener('click', ()=>randomGraph(6, 0.35));\n  document.getElementById('btnDelete').addEventListener('click', deleteSelected);\n  document.getElementById('btnAdjList').addEventListener('click', showAdjList);\n  document.getElementById('btnAdjMatrix').addEventListener('click', showAdjMatrix);\n  document.getElementById('btnExport').addEventListener('click', exportJSON);\n  document.getElementById('btnLoad').addEventListener('click', loadJSON);\n  document.getElementById('btnCopy').addEventListener('click', ()=>{ jsonOut.select(); document.execCommand('copy'); });\n\n  document.getElementById('btnPath').addEventListener('click', ()=> {\n    const a = Number(fromSel.value), b = Number(toSel.value);\n    if (!a || !b) { alert('Select nodes'); return; }\n    const path = computeShortestPath(a,b);\n    if (!path) { alert('No path found'); highlightPath = []; draw(); return; }\n    // highlight edges along path\n    highlightPath = [];\n    for (let i=0;i<path.length-1;i++) {\n      // find an edge connecting path[i] -> path[i+1] (respecting directed flag)\n      const e = edges.find(ed => ed.from === path[i] && ed.to === path[i+1]);\n      if (e) highlightPath.push(e.id);\n      else {\n        // maybe undirected stored reverse\n        const e2 = edges.find(ed => ed.from === path[i+1] && ed.to === path[i]);\n        if (e2) highlightPath.push(e2.id);\n      }\n    }\n    draw();\n    adjOutput.textContent = 'Path: ' + path.join(' → ');\n  });\n\n  // initial\n  resize();\n  randomGraph(5, 0.3);\n  exportJSON();\n\n  // keep JSON updated\n  setInterval(()=> {\n    exportJSON();\n  }, 3000);\n\n  // keyboard shortcuts\n  window.addEventListener('keydown', e=>{\n    if (e.key === 'Delete') deleteSelected();\n    if (e.ctrlKey && e.key.toLowerCase() === 's') { e.preventDefault(); exportJSON(); }\n  });\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": false,
  "hasTest": true
}