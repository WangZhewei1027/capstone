{
  "id": "be873c65-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:22.688Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Hash Map",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Interactive Hash Map Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root{\n      --bg:#0f1724; --card:#0b1220; --muted:#9aa4b2; --accent:#4fd1c5; --accent2:#7c5cff;\n      --white:#e6eef6; --red:#ff6b6b;\n    }\n    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,#051023 0%, #081426 60%); color:var(--white);}\n    .wrap{max-width:1100px;margin:24px auto;padding:20px;}\n    header{display:flex;gap:18px;align-items:center;margin-bottom:14px}\n    h1{font-size:20px;margin:0}\n    p.small{margin:4px 0;color:var(--muted);font-size:13px}\n    .grid{display:grid;grid-template-columns:360px 1fr;gap:18px}\n    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:14px;border-radius:10px}\n    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}\n    input[type=\"text\"], input[type=\"number\"], select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--white)}\n    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}\n    button{background:linear-gradient(90deg,var(--accent),var(--accent2));border:none;padding:8px 10px;border-radius:8px;color:#021017;cursor:pointer;font-weight:600}\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--white)}\n    .muted{color:var(--muted);font-size:13px}\n    .status{margin-top:10px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-size:13px}\n    .map-area{padding:12px;display:flex;gap:12px;flex-direction:column;align-items:stretch}\n    .buckets{display:flex;flex-wrap:wrap;gap:10px;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));}\n    .bucket{width:120px;min-height:48px;border-radius:8px;border:1px dashed rgba(255,255,255,0.03);padding:8px;background:rgba(255,255,255,0.01);position:relative}\n    .bindex{position:absolute;top:6px;right:6px;font-size:12px;color:var(--muted)}\n    .node{display:inline-flex;gap:6px;align-items:center;padding:6px;border-radius:8px;background:rgba(0,0,0,0.3);margin:6px 0;color:var(--white);font-size:13px;border:1px solid rgba(255,255,255,0.03)}\n    .node .k{font-weight:700;color:var(--accent2);padding-right:6px}\n    .node .v{color:var(--muted);font-weight:600}\n    .highlight{box-shadow:0 0 12px rgba(127,90,255,0.45);border-color:rgba(127,90,255,0.9)}\n    .found{box-shadow:0 0 12px rgba(79,209,197,0.45);border-color:rgba(79,209,197,0.9)}\n    .small-muted{font-size:12px;color:var(--muted)}\n    .row{display:flex;gap:8px;align-items:center}\n    footer{opacity:0.9;margin-top:14px;color:var(--muted);font-size:13px}\n    pre{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;overflow:auto;font-size:12px;color:var(--muted)}\n    .legend{display:flex;gap:8px;align-items:center;margin-top:10px}\n    .chip{padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-size:12px}\n    .controls-right{display:flex;gap:8px;align-items:center;justify-content:flex-end}\n    .flex{display:flex;gap:8px;align-items:center}\n    .badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;font-weight:700;color:var(--white)}\n    .note{font-size:13px;color:var(--muted);margin-top:8px}\n    @media(max-width:900px){.grid{grid-template-columns:1fr;}}\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <header>\n      <div style=\"flex:1\">\n        <h1>Hash Map â€” Interactive Demonstration</h1>\n        <p class=\"small\">Visualize how a hash map stores key-value pairs, handles collisions (separate chaining), and resizes as load increases.</p>\n      </div>\n      <div style=\"text-align:right\">\n        <div class=\"small-muted\">Implementation: separate chaining, string/number keys</div>\n      </div>\n    </header>\n\n    <div class=\"grid\">\n      <div class=\"card\">\n        <div style=\"display:flex;gap:8px;align-items:flex-start\">\n          <div style=\"flex:1\">\n            <label>Key (string/number)</label>\n            <input id=\"keyInput\" type=\"text\" value=\"apple\">\n            <label style=\"margin-top:8px\">Value</label>\n            <input id=\"valueInput\" type=\"text\" value=\"red\">\n            <div class=\"controls\">\n              <button id=\"putBtn\">Put / Insert</button>\n              <button id=\"getBtn\" class=\"ghost\">Get</button>\n              <button id=\"deleteBtn\" class=\"ghost\">Delete</button>\n              <button id=\"clearBtn\" class=\"ghost\">Clear</button>\n            </div>\n            <div class=\"note\">Tip: Insert keys that collide (e.g., \"a\", \"p\", \"q\" when capacity small) to see chaining.</div>\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px\">\n          <label>Animation Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"0\" max=\"1000\" value=\"300\">\n          <div class=\"row\" style=\"margin-top:8px\">\n            <div class=\"small-muted\">Slow</div>\n            <div style=\"flex:1\"><input id=\"stepMode\" type=\"checkbox\" style=\"margin-left:6px\"> <span class=\"small-muted\">Step mode (pause after highlights)</span></div>\n          </div>\n        </div>\n\n        <div class=\"status\" id=\"status\">\n          <div>Capacity: <span id=\"capacity\">8</span> &nbsp;|&nbsp; Size: <span id=\"size\">0</span> &nbsp;|&nbsp; Load factor: <span id=\"load\">0.00</span></div>\n          <div style=\"margin-top:8px\" class=\"small-muted\">Resize threshold: <span id=\"threshold\">0.75</span></div>\n        </div>\n\n        <div style=\"margin-top:10px;display:flex;gap:8px;align-items:center\">\n          <button id=\"fillBtn\" class=\"ghost\">Fill with sample entries</button>\n          <button id=\"randomBtn\" class=\"ghost\">Insert random 20</button>\n          <button id=\"forceResizeBtn\" class=\"ghost\">Force resize (double)</button>\n          <div style=\"flex:1\"></div>\n          <div class=\"chip\">Collision handling: separate chaining</div>\n        </div>\n\n        <div style=\"margin-top:10px\">\n          <div class=\"legend\">\n            <div class=\"chip\">Highlight = bucket visited</div>\n            <div class=\"chip\">Found = matching key</div>\n            <div class=\"chip\">Resize rehashes everything</div>\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px\">\n          <label>Source (implementation)</label>\n          <pre id=\"source\" style=\"height:220px;overflow:auto\"></pre>\n        </div>\n\n      </div>\n\n      <div class=\"card\">\n        <div class=\"map-area\">\n          <div style=\"display:flex;justify-content:space-between;align-items:center\">\n            <div class=\"small-muted\">Buckets (array of chains). Click a bucket to inspect its entries.</div>\n            <div class=\"small-muted\">Click a node to copy its key/value</div>\n          </div>\n          <div id=\"buckets\" class=\"buckets\"></div>\n          <div id=\"log\" style=\"margin-top:10px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);min-height:56px;color:var(--muted)\"></div>\n        </div>\n      </div>\n    </div>\n\n    <footer>\n      This demo uses a simple hash function (djb2) for strings and numeric hashing for numbers. Designed for learning: real production hash maps use more sophisticated hashing and memory management.\n    </footer>\n  </div>\n\n  <script>\n    // HashMap implementation (separate chaining)\n    class HashMap {\n      constructor(initialCapacity = 8, loadFactor = 0.75) {\n        this._capacity = Math.max(4, initialCapacity);\n        this._buckets = Array.from({length: this._capacity}, () => []);\n        this._size = 0;\n        this._loadFactor = loadFactor;\n      }\n\n      _hash(key) {\n        // Basic djb2 for strings, simple for numbers; fall back to string conversion\n        if (typeof key === 'number') {\n          // mix bits of the number\n          let h = key | 0;\n          h = ((h >>> 16) ^ h) * 0x45d9f3b;\n          h = ((h >>> 16) ^ h) * 0x45d9f3b;\n          h = (h >>> 16) ^ h;\n          return h >>> 0;\n        }\n        const str = String(key);\n        let hash = 5381;\n        for (let i = 0; i < str.length; i++) {\n          hash = ((hash << 5) + hash) + str.charCodeAt(i); /* hash * 33 + c */\n          hash = hash | 0;\n        }\n        return hash >>> 0; // unsigned\n      }\n\n      _index(hash) {\n        return hash % this._capacity;\n      }\n\n      size() { return this._size; }\n      capacity() { return this._capacity; }\n      loadFactor() { return this._size / this._capacity; }\n      threshold() { return this._loadFactor; }\n\n      get(key, walker=null) {\n        const hash = this._hash(key);\n        const idx = this._index(hash);\n        const bucket = this._buckets[idx];\n        if (walker) walker.visitBucket(idx);\n        for (let i = 0; i < bucket.length; i++) {\n          if (bucket[i].key === key) {\n            if (walker) walker.visitNode(idx,i,true);\n            return bucket[i].value;\n          }\n          if (walker) walker.visitNode(idx,i,false);\n        }\n        return undefined;\n      }\n\n      put(key, value, walker=null) {\n        const hash = this._hash(key);\n        const idx = this._index(hash);\n        const bucket = this._buckets[idx];\n        if (walker) walker.visitBucket(idx);\n        for (let i = 0; i < bucket.length; i++) {\n          if (bucket[i].key === key) {\n            bucket[i].value = value;\n            if (walker) walker.visitNode(idx,i,true);\n            return 'updated';\n          }\n          if (walker) walker.visitNode(idx,i,false);\n        }\n        bucket.push({key, value});\n        this._size++;\n        if (this.loadFactor() > this._loadFactor) {\n          this._resize(this._capacity * 2, walker);\n        }\n        return 'inserted';\n      }\n\n      delete(key, walker=null) {\n        const hash = this._hash(key);\n        const idx = this._index(hash);\n        const bucket = this._buckets[idx];\n        if (walker) walker.visitBucket(idx);\n        for (let i = 0; i < bucket.length; i++) {\n          if (bucket[i].key === key) {\n            bucket.splice(i,1);\n            this._size--;\n            if (walker) walker.visitNode(idx,i,true);\n            // optional shrink omitted for simplicity\n            return true;\n          }\n          if (walker) walker.visitNode(idx,i,false);\n        }\n        return false;\n      }\n\n      _resize(newCapacity, walker=null) {\n        // Rehash all entries\n        const oldBuckets = this._buckets;\n        this._capacity = Math.max(4, newCapacity);\n        this._buckets = Array.from({length: this._capacity}, () => []);\n        this._size = 0;\n        if (walker) walker.log('Resizing to ' + this._capacity + ' and rehashing all entries...');\n        for (let i = 0; i < oldBuckets.length; i++) {\n          const bucket = oldBuckets[i];\n          for (let j = 0; j < bucket.length; j++) {\n            const entry = bucket[j];\n            // Use put but without triggering further resize\n            const hash = this._hash(entry.key);\n            const idx = this._index(hash);\n            this._buckets[idx].push({key: entry.key, value: entry.value});\n            this._size++;\n            if (walker) walker.rehashStep(entry.key, idx);\n          }\n        }\n      }\n\n      entries() {\n        // returns array of {bucketIndex, key, value}\n        const out = [];\n        for (let i = 0; i < this._buckets.length; i++) {\n          for (let j = 0; j < this._buckets[i].length; j++) {\n            out.push({bucket:i, key:this._buckets[i][j].key, value:this._buckets[i][j].value});\n          }\n        }\n        return out;\n      }\n    }\n\n    // UI & visualization\n    const map = new HashMap(8, 0.75);\n    const bucketsEl = document.getElementById('buckets');\n    const capacityEl = document.getElementById('capacity');\n    const sizeEl = document.getElementById('size');\n    const loadEl = document.getElementById('load');\n    const thresholdEl = document.getElementById('threshold');\n    const logEl = document.getElementById('log');\n    const sourceEl = document.getElementById('source');\n\n    function updateStats() {\n      capacityEl.textContent = map.capacity();\n      sizeEl.textContent = map.size();\n      loadEl.textContent = map.loadFactor().toFixed(2);\n      thresholdEl.textContent = map.threshold();\n    }\n\n    function renderBuckets() {\n      bucketsEl.innerHTML = '';\n      const cap = map.capacity();\n      for (let i = 0; i < cap; i++) {\n        const bucket = document.createElement('div');\n        bucket.className = 'bucket';\n        bucket.dataset.index = i;\n        const idx = document.createElement('div');\n        idx.className = 'bindex';\n        idx.textContent = i;\n        bucket.appendChild(idx);\n        const list = map._buckets[i];\n        if (list.length === 0) {\n          const empty = document.createElement('div');\n          empty.className = 'small-muted';\n          empty.style.fontSize='12px';\n          empty.textContent = '(empty)';\n          bucket.appendChild(empty);\n        } else {\n          list.forEach((entry, j) => {\n            const node = document.createElement('div');\n            node.className = 'node';\n            node.dataset.bucket = i;\n            node.dataset.pos = j;\n            const k = document.createElement('div'); k.className = 'k'; k.textContent = entry.key;\n            const v = document.createElement('div'); v.className = 'v'; v.textContent = String(entry.value);\n            node.appendChild(k);\n            node.appendChild(v);\n            node.title = 'Click to copy';\n            node.addEventListener('click', (e) => {\n              e.stopPropagation();\n              navigator.clipboard?.writeText(JSON.stringify({key:entry.key, value:entry.value})).then(()=> {\n                flashLog('Copied { key: \"'+entry.key+'\", value: \"'+entry.value+'\" } to clipboard');\n              }).catch(()=> flashLog('Copied (failed to clipboard)'));\n            });\n            bucket.appendChild(node);\n          });\n        }\n        bucket.addEventListener('click', () => {\n          flashLog('Bucket ' + i + ' contains ' + list.length + ' entries');\n        });\n        bucketsEl.appendChild(bucket);\n      }\n      updateStats();\n    }\n\n    // walker object for visualization callbacks\n    class Walker {\n      constructor(speed, stepMode) {\n        this.speed = speed;\n        this.stepMode = stepMode;\n        this._promises = [];\n        this._activeHighlights = [];\n      }\n      async visitBucket(idx) {\n        await this._pause();\n        const bucket = document.querySelector('.bucket[data-index=\"'+idx+'\"]');\n        if (bucket) {\n          bucket.classList.add('highlight');\n          this._activeHighlights.push(bucket);\n          this.log('Visiting bucket ' + idx);\n          if (!this.stepMode) await this._sleep(this.speed);\n        }\n      }\n      async visitNode(bidx, pos, matched) {\n        await this._pause();\n        const sel = '.bucket[data-index=\"'+bidx+'\"] .node[data-pos=\"'+pos+'\"]';\n        const node = document.querySelector(sel);\n        if (node) {\n          node.classList.add(matched ? 'found' : 'highlight');\n          this._activeHighlights.push(node);\n          this.log((matched ? 'Found match' : 'Checking') + ' at bucket ' + bidx + ' pos ' + pos);\n          if (!this.stepMode) await this._sleep(this.speed);\n        }\n      }\n      async rehashStep(key, idx) {\n        await this._pause();\n        this.log('Rehash: placed key \"'+key+'\" into bucket '+idx);\n        // briefly highlight target bucket\n        const bucket = document.querySelector('.bucket[data-index=\"'+idx+'\"]');\n        if (bucket) {\n          bucket.classList.add('highlight');\n          this._activeHighlights.push(bucket);\n          if (!this.stepMode) await this._sleep(Math.max(60, this.speed/4));\n        }\n      }\n      clearHighlights() {\n        this._activeHighlights.forEach(el => {\n          el.classList.remove('highlight','found');\n        });\n        this._activeHighlights = [];\n      }\n      log(msg) {\n        flashLog(msg);\n      }\n      _sleep(ms) { return new Promise(res => setTimeout(res, ms)); }\n      async _pause() {\n        if (this.stepMode) {\n          // create a promise that will be resolved when the user clicks 'Next'\n          await new Promise(resolve => {\n            const handler = () => {\n              document.removeEventListener('click', handler);\n              resolve();\n            };\n            // clicking anywhere (except on buttons) will proceed; also show a brief hint\n            document.addEventListener('click', handler);\n            flashLog('Step mode: click anywhere to continue', 1400);\n          });\n        }\n      }\n    }\n\n    // helpers\n    function flashLog(msg, timeout=2000) {\n      logEl.textContent = msg;\n      if (timeout>0) {\n        setTimeout(()=> {\n          if (logEl.textContent === msg) logEl.textContent = '';\n        }, timeout);\n      }\n    }\n\n    // wire UI\n    const keyInput = document.getElementById('keyInput');\n    const valueInput = document.getElementById('valueInput');\n    const putBtn = document.getElementById('putBtn');\n    const getBtn = document.getElementById('getBtn');\n    const deleteBtn = document.getElementById('deleteBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const fillBtn = document.getElementById('fillBtn');\n    const randomBtn = document.getElementById('randomBtn');\n    const forceResizeBtn = document.getElementById('forceResizeBtn');\n    const speedEl = document.getElementById('speed');\n    const stepModeEl = document.getElementById('stepMode');\n\n    function parseKey(s){\n      // try to parse numbers for convenience\n      if (s === '') return '';\n      const n = Number(s);\n      if (!Number.isNaN(n) && String(n) === s) return n;\n      return s;\n    }\n\n    async function doPut(key, value) {\n      const speed = 1000 - Number(speedEl.value); // invert so slider intuitive\n      const walker = new Walker(Math.max(40,speed), stepModeEl.checked);\n      walker.clearHighlights();\n      const result = map.put(key, value, walker);\n      renderBuckets();\n      walker.clearHighlights();\n      flashLog('Put: ' + String(key) + ' -> ' + String(value) + ' ('+result+')', 2500);\n    }\n\n    async function doGet(key) {\n      const speed = 1000 - Number(speedEl.value);\n      const walker = new Walker(Math.max(40,speed), stepModeEl.checked);\n      walker.clearHighlights();\n      const val = map.get(key, walker);\n      renderBuckets();\n      walker.clearHighlights();\n      if (val === undefined) flashLog('Get: Key \"'+String(key)+'\" not found', 2500);\n      else flashLog('Get: \"'+String(key)+'\" -> \"'+String(val)+'\"', 3500);\n    }\n\n    async function doDelete(key) {\n      const speed = 1000 - Number(speedEl.value);\n      const walker = new Walker(Math.max(40,speed), stepModeEl.checked);\n      walker.clearHighlights();\n      const ok = map.delete(key, walker);\n      renderBuckets();\n      walker.clearHighlights();\n      if (ok) flashLog('Deleted key \"'+String(key)+'\"', 2200);\n      else flashLog('Delete: key \"'+String(key)+'\" not found', 2200);\n    }\n\n    putBtn.addEventListener('click', async () => {\n      const key = parseKey(keyInput.value.trim());\n      const value = valueInput.value;\n      await doPut(key, value);\n    });\n\n    getBtn.addEventListener('click', async () => {\n      const key = parseKey(keyInput.value.trim());\n      await doGet(key);\n    });\n\n    deleteBtn.addEventListener('click', async () => {\n      const key = parseKey(keyInput.value.trim());\n      await doDelete(key);\n    });\n\n    clearBtn.addEventListener('click', () => {\n      // reset the map\n      while (map.size() > 0) {\n        // cheap re-init\n        break;\n      }\n      // re-create\n      const newCap = 8;\n      const load = map._loadFactor;\n      // replace internal fields\n      map._capacity = newCap;\n      map._buckets = Array.from({length:newCap}, ()=>[]);\n      map._size = 0;\n      updateStats();\n      renderBuckets();\n      flashLog('Cleared map');\n    });\n\n    fillBtn.addEventListener('click', () => {\n      const samples = [\n        ['apple','red'],['banana','yellow'],['grape','purple'],['lemon','yellow'],\n        ['melon','green'],['peach','pink'],['apricot','orange'],['plum','violet'],\n        ['kiwi','brown'],['pear','green'],['mango','orange'],['lime','green']\n      ];\n      (async ()=> {\n        for (const [k,v] of samples) {\n          await doPut(k,v);\n        }\n      })();\n    });\n\n    randomBtn.addEventListener('click', () => {\n      (async ()=> {\n        for (let i=0;i<20;i++){\n          const k = 'k'+Math.floor(Math.random()*1000);\n          const v = Math.random().toString(36).slice(2,7);\n          await doPut(k,v);\n        }\n      })();\n    });\n\n    forceResizeBtn.addEventListener('click', () => {\n      map._resize(map.capacity()*2);\n      renderBuckets();\n      flashLog('Forced resize to capacity ' + map.capacity());\n    });\n\n    // load source code into pre (for readability we show the core class string)\n    sourceEl.textContent = (HashMap.toString());\n\n    // initial render\n    renderBuckets();\n    updateStats();\n\n    // Utility: find colliding key for a given key (same bucket index)\n    // Not exposed in UI but used by dev console if needed\n    window.findCollisionFor = function(origKey){\n      const origHash = map._hash(origKey);\n      const targetIdx = map._index(origHash);\n      let attempt = 0;\n      while (attempt < 200000) {\n        attempt++;\n        const cand = String(origKey) + '#' + attempt;\n        if (map._index(map._hash(cand)) === targetIdx && cand !== origKey) return cand;\n      }\n      return null;\n    };\n\n    // keyboard shortcuts (Enter to put)\n    document.addEventListener('keydown', (e) => {\n      if (e.key === 'Enter' && document.activeElement && (document.activeElement.tagName==='INPUT')) {\n        e.preventDefault();\n        putBtn.click();\n      }\n    });\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Hash Map"
    }
  ],
  "topic": "Hash Map",
  "hasFSM": false,
  "hasTest": true
}