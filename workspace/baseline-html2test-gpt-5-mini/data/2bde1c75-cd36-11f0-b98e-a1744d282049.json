{
  "id": "2bde1c75-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:47.172Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Adjacency Matrix Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  html,body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n  .container { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }\n  .left, .right { background:#fbfbfb; border:1px solid #ddd; border-radius:8px; padding:12px; box-sizing:border-box; }\n  .left { flex:1 1 60%; display:flex; flex-direction:column; gap:8px; min-width:420px; }\n  .canvas-wrap { background:white; border:1px solid #eee; border-radius:6px; flex:1; position:relative; overflow:hidden; }\n  svg { width:100%; height:100%; display:block; }\n  .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\n  button, input[type=\"number\"], select { padding:6px 8px; border-radius:6px; border:1px solid #ccc; background:white; }\n  label { display:flex; gap:6px; align-items:center; font-size:13px; color:#333; }\n  .right { flex:0 1 420px; display:flex; flex-direction:column; gap:10px; min-width:320px; max-width:480px; }\n  .panel { background:#fff; border:1px solid #eee; padding:8px; border-radius:6px; max-height:44vh; overflow:auto; }\n  table { border-collapse:collapse; font-size:13px; }\n  td, th { border:1px solid #e6e6e6; padding:6px; text-align:center; min-width:28px; }\n  th { background:#fafafa; position:sticky; top:0; z-index:2; }\n  .matrix-wrap { overflow:auto; max-height:36vh; border-radius:6px; border:1px solid #f0f0f0; }\n  .node { cursor:pointer; }\n  .selected { stroke:#f90 !important; stroke-width:3px !important; }\n  .small { font-size:12px; color:#444;}\n  .muted { color:#666; font-size:12px; }\n  .edge-weight { font-size:12px; fill:#000; background:transparent; }\n  .info { font-size:13px; color:#333; }\n  .footer { font-size:12px; color:#666; text-align:right; }\n  .hint { font-size:12px; color:#555; }\n  input[type=\"checkbox\"] { transform:scale(1.05); margin:0 4px 0 0; }\n  .top-row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }\n  .flex-col { display:flex; flex-direction:column; gap:6px; }\n  .adj-list { font-family:monospace; white-space:pre; font-size:13px; }\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"left\">\n    <div class=\"top-row controls\">\n      <button id=\"addNodeBtn\" title=\"Add a node\">Add Node</button>\n      <button id=\"removeNodeBtn\" title=\"Remove last node\">Remove Node</button>\n      <button id=\"randomBtn\" title=\"Generate random edges\">Random Graph</button>\n      <button id=\"clearBtn\" title=\"Remove all edges\">Clear Edges</button>\n      <label><input type=\"checkbox\" id=\"directedChk\"> Directed</label>\n      <label><input type=\"checkbox\" id=\"weightedChk\"> Weighted</label>\n      <label class=\"muted\">Max nodes: <span id=\"maxNodes\">20</span></label>\n      <div style=\"margin-left:auto\" class=\"hint\">Click nodes to select & connect. Or edit the matrix on the right.</div>\n    </div>\n\n    <div class=\"canvas-wrap\">\n      <svg id=\"svgCanvas\" viewBox=\"0 0 800 600\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n    </div>\n\n    <div class=\"controls\">\n      <div class=\"muted\">Selected node: <span id=\"selectedNode\">None</span></div>\n      <button id=\"deselectBtn\">Deselect</button>\n      <button id=\"fitBtn\" title=\"Center layout\">Center Nodes</button>\n      <button id=\"layoutCircleBtn\">Circle Layout</button>\n      <div style=\"margin-left:auto\" class=\"muted\">Click an adjacency matrix cell to toggle/edit edges.</div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"info\"><strong>Degrees / Totals</strong></div>\n      <div id=\"degreeInfo\" class=\"small muted\">No nodes</div>\n    </div>\n  </div>\n\n  <div class=\"right\">\n    <div class=\"panel flex-col\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center\">\n        <div><strong>Adjacency Matrix</strong> <span class=\"muted small\" id=\"matrixMode\"></span></div>\n        <div class=\"muted small\">Rows = source, Columns = target</div>\n      </div>\n      <div class=\"matrix-wrap\" id=\"matrixWrap\"></div>\n      <div class=\"muted small\">Click a cell: toggles edge (unweighted) or edit weight (weighted). For undirected graphs updates are symmetric.</div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"info\"><strong>Adjacency List</strong></div>\n      <pre id=\"adjList\" class=\"adj-list\"></pre>\n      <div class=\"muted small\">Format: node: (target, weight)</div>\n    </div>\n\n    <div class=\"panel\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center\">\n        <div><strong>Export / Import</strong></div>\n      </div>\n      <div style=\"display:flex; gap:6px; margin-top:8px;\">\n        <button id=\"exportBtn\">Export JSON</button>\n        <button id=\"importBtn\">Import JSON</button>\n        <input id=\"importArea\" placeholder='Paste JSON here' style=\"flex:1; padding:6px;\" />\n      </div>\n      <div class=\"muted small\" style=\"margin-top:8px\">Export includes nodes positions and adjacency matrix.</div>\n    </div>\n\n    <div class=\"panel\">\n      <div class=\"info\"><strong>Tips</strong></div>\n      <ul class=\"muted small\">\n        <li>Undirected: adjacency matrix is symmetric. Toggle \"Directed\" for arrows.</li>\n        <li>Weighted: matrix cells are numeric; zero means no edge.</li>\n        <li>Click a node to select it, then click another node to create/remove an edge between them.</li>\n      </ul>\n    </div>\n  </div>\n</div>\n\n<script>\n(function(){\n  // Data\n  const svg = document.getElementById('svgCanvas');\n  const matrixWrap = document.getElementById('matrixWrap');\n  const adjListPre = document.getElementById('adjList');\n  const degreeInfo = document.getElementById('degreeInfo');\n  const selectedNodeSpan = document.getElementById('selectedNode');\n  const matrixModeSpan = document.getElementById('matrixMode');\n  const maxNodesSpan = document.getElementById('maxNodes');\n\n  let directed = false;\n  let weighted = false;\n  const MAX_NODES = 20;\n  maxNodesSpan.textContent = MAX_NODES;\n\n  let nodes = []; // {id, x,y}\n  let adj = []; // NxN numeric matrix (0 means no edge)\n  let selectedNode = null;\n\n  // init basic elements\n  const defs = createSVG('defs');\n  svg.appendChild(defs);\n  // arrow marker\n  const marker = createSVG('marker');\n  marker.setAttribute('id','arrow');\n  marker.setAttribute('markerWidth','8');\n  marker.setAttribute('markerHeight','8');\n  marker.setAttribute('refX','10');\n  marker.setAttribute('refY','4');\n  marker.setAttribute('orient','auto');\n  const arrowPath = createSVG('path');\n  arrowPath.setAttribute('d','M0,0 L8,4 L0,8 Z');\n  arrowPath.setAttribute('fill','#555');\n  marker.appendChild(arrowPath);\n  defs.appendChild(marker);\n\n  // layers\n  const edgesLayer = createSVG('g'); svg.appendChild(edgesLayer);\n  const labelsLayer = createSVG('g'); svg.appendChild(labelsLayer);\n  const nodesLayer = createSVG('g'); svg.appendChild(nodesLayer);\n\n  // Utility to create SVG elements\n  function createSVG(tag, attrs){\n    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);\n    if (attrs) for (const k in attrs) el.setAttribute(k, attrs[k]);\n    return el;\n  }\n\n  // Initialize with 5 nodes in circle\n  function init(n=5){\n    nodes = [];\n    adj = [];\n    for (let i=0;i<n;i++){\n      nodes.push({id:i, x: 400 + 200*Math.cos(i*2*Math.PI/n), y:300 + 200*Math.sin(i*2*Math.PI/n)});\n    }\n    for (let i=0;i<n;i++){\n      adj[i] = Array(n).fill(0);\n    }\n    selectedNode = null;\n    updateUI();\n  }\n\n  // Draw graph\n  function draw(){\n    // clear layers\n    edgesLayer.innerHTML=''; labelsLayer.innerHTML=''; nodesLayer.innerHTML='';\n\n    // update arrow marker color and attach to defs\n    marker.setAttribute('markerUnits','strokeWidth');\n\n    // Draw edges\n    for (let i=0;i<nodes.length;i++){\n      for (let j=0;j<nodes.length;j++){\n        if (adj[i][j] && (i!==j || adj[i][j]!==0)) {\n          const a = nodes[i], b = nodes[j];\n          drawEdge(a,b,i,j,adj[i][j]);\n        }\n      }\n    }\n\n    // Draw nodes\n    for (const nd of nodes){\n      const g = createSVG('g');\n      g.classList.add('node');\n      g.setAttribute('data-id', nd.id);\n      const circle = createSVG('circle', {cx:nd.x, cy:nd.y, r:20, fill:'#fff', stroke:'#3b82f6', 'stroke-width':2});\n      if (selectedNode === nd.id) circle.classList.add('selected');\n      const label = createSVG('text', {x:nd.x, y:nd.y+5, 'text-anchor':'middle', 'font-size':14, 'fill':'#111'});\n      label.textContent = 'n' + nd.id;\n      g.appendChild(circle);\n      g.appendChild(label);\n      nodesLayer.appendChild(g);\n\n      // Event handlers\n      g.addEventListener('mousedown', onNodeMouseDown);\n      g.addEventListener('click', onNodeClick);\n    }\n\n    updateMatrix();\n    updateAdjList();\n    updateDegreeInfo();\n  }\n\n  function drawEdge(a,b,i,j,w){\n    // compute line endpoints so they don't touch node circles\n    const dx = b.x - a.x, dy = b.y - a.y;\n    const dist = Math.hypot(dx,dy) || 1;\n    const r = 20;\n    const ux = dx/dist, uy = dy/dist;\n    const startX = a.x + ux*r;\n    const startY = a.y + uy*r;\n    const endX = b.x - ux*r;\n    const endY = b.y - uy*r;\n\n    const line = createSVG('line', {x1:startX, y1:startY, x2:endX, y2:endY, stroke:'#444', 'stroke-width':2});\n    if (directed){\n      line.setAttribute('marker-end','url(#arrow)');\n    }\n    edgesLayer.appendChild(line);\n\n    // weight label if weighted\n    if (weighted){\n      const midX = (startX + endX)/2;\n      const midY = (startY + endY)/2;\n      const text = createSVG('text', {x:midX+6, y:midY-6, 'font-size':12, 'fill':'#000'});\n      text.textContent = String(w);\n      labelsLayer.appendChild(text);\n    }\n  }\n\n  // Matrix UI\n  function updateMatrix(){\n    matrixWrap.innerHTML = '';\n    matrixModeSpan.textContent = weighted ? 'weighted' : 'unweighted';\n    const n = nodes.length;\n    if (n === 0) return;\n    const table = document.createElement('table');\n    // header row\n    const thead = document.createElement('thead');\n    const hr = document.createElement('tr');\n    hr.appendChild(document.createElement('th')); // corner\n    for (let j=0;j<n;j++){\n      const th = document.createElement('th');\n      th.textContent = 'n'+j;\n      hr.appendChild(th);\n    }\n    thead.appendChild(hr);\n    table.appendChild(thead);\n\n    // body\n    const tbody = document.createElement('tbody');\n    for (let i=0;i<n;i++){\n      const tr = document.createElement('tr');\n      const rowHeader = document.createElement('th');\n      rowHeader.textContent = 'n'+i;\n      tr.appendChild(rowHeader);\n      for (let j=0;j<n;j++){\n        const td = document.createElement('td');\n        if (!weighted){\n          const cb = document.createElement('input');\n          cb.type = 'checkbox';\n          cb.checked = !!adj[i][j];\n          cb.addEventListener('change', (e)=>{\n            setEdgeFromMatrix(i,j, e.target.checked ? 1 : 0);\n          });\n          td.appendChild(cb);\n        } else {\n          const inp = document.createElement('input');\n          inp.type = 'number';\n          inp.value = adj[i][j] || 0;\n          inp.style.width = '60px';\n          inp.addEventListener('change', (e)=>{\n            const val = Number(e.target.value) || 0;\n            setEdgeFromMatrix(i,j, val);\n          });\n          td.appendChild(inp);\n        }\n        tr.appendChild(td);\n      }\n      tbody.appendChild(tr);\n    }\n    table.appendChild(tbody);\n    matrixWrap.appendChild(table);\n  }\n\n  function setEdgeFromMatrix(i,j,val){\n    if (!directed){\n      // symmetrize\n      adj[i][j] = val;\n      adj[j][i] = val;\n    } else {\n      adj[i][j] = val;\n    }\n    draw();\n  }\n\n  // Adj list\n  function updateAdjList(){\n    let s = '';\n    for (let i=0;i<nodes.length;i++){\n      const outs = [];\n      for (let j=0;j<nodes.length;j++){\n        if (adj[i][j]){\n          if (weighted) outs.push(`n${j}(${adj[i][j]})`);\n          else outs.push(`n${j}`);\n        }\n      }\n      s += `n${i}: ${outs.join(', ')}\\n`;\n    }\n    adjListPre.textContent = s;\n  }\n\n  // Degrees\n  function updateDegreeInfo(){\n    if (nodes.length===0){\n      degreeInfo.textContent = 'No nodes';\n      return;\n    }\n    if (!directed){\n      const arr = nodes.map((_,i)=> adj[i].reduce((a,b)=>a+(b?1:0),0));\n      const lines = arr.map((d,i)=> `n${i}: degree=${d}`);\n      degreeInfo.textContent = lines.join(' | ');\n    } else {\n      const lines = [];\n      for (let i=0;i<nodes.length;i++){\n        const out = adj[i].reduce((a,b)=>a+(b?1:0),0);\n        let inn = 0;\n        for (let r=0;r<nodes.length;r++) if (adj[r][i]) inn++;\n        lines.push(`n${i}: out=${out}, in=${inn}`);\n      }\n      degreeInfo.textContent = lines.join(' | ');\n    }\n  }\n\n  // Node interactions\n  let dragging = null;\n  let dragOffset = {x:0,y:0};\n\n  function onNodeMouseDown(e){\n    e.stopPropagation();\n    const id = Number(this.getAttribute('data-id'));\n    dragging = id;\n    const nd = nodes.find(n=>n.id===id);\n    const pt = getMousePoint(e);\n    dragOffset.x = pt.x - nd.x;\n    dragOffset.y = pt.y - nd.y;\n    window.addEventListener('mousemove', onDrag);\n    window.addEventListener('mouseup', onUp);\n  }\n\n  function onDrag(e){\n    if (dragging === null) return;\n    const nd = nodes.find(n=>n.id===dragging);\n    const pt = getMousePoint(e);\n    nd.x = pt.x - dragOffset.x;\n    nd.y = pt.y - dragOffset.y;\n    draw();\n  }\n\n  function onUp(){\n    dragging = null;\n    window.removeEventListener('mousemove', onDrag);\n    window.removeEventListener('mouseup', onUp);\n  }\n\n  function onNodeClick(e){\n    e.stopPropagation();\n    const id = Number(this.getAttribute('data-id'));\n    if (selectedNode === null){\n      selectedNode = id;\n    } else if (selectedNode === id) {\n      selectedNode = null;\n    } else {\n      // toggle edge between selectedNode -> id\n      if (!weighted){\n        const exists = !!adj[selectedNode][id];\n        const newVal = exists ? 0 : 1;\n        if (!directed){\n          adj[selectedNode][id] = newVal;\n          adj[id][selectedNode] = newVal;\n        } else {\n          adj[selectedNode][id] = newVal;\n        }\n      } else {\n        // ask for weight\n        const cur = adj[selectedNode][id] || 0;\n        const input = prompt('Enter edge weight (0 to remove):', String(cur));\n        if (input !== null){\n          const val = Number(input) || 0;\n          if (!directed){\n            adj[selectedNode][id] = val;\n            adj[id][selectedNode] = val;\n          } else {\n            adj[selectedNode][id] = val;\n          }\n        }\n      }\n      selectedNode = null;\n    }\n    updateUI();\n  }\n\n  // canvas background click to deselect\n  svg.addEventListener('click', ()=>{\n    selectedNode = null;\n    updateUI();\n  });\n\n  // UI update\n  function updateUI(){\n    selectedNodeSpan.textContent = selectedNode===null ? 'None' : 'n'+selectedNode;\n    draw();\n  }\n\n  // helper: get mouse position relative to svg viewBox coordinates\n  function getMousePoint(evt){\n    const pt = svg.createSVGPoint();\n    pt.x = evt.clientX;\n    pt.y = evt.clientY;\n    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());\n    return {x: svgP.x, y: svgP.y};\n  }\n\n  // Controls\n  document.getElementById('addNodeBtn').addEventListener('click', ()=>{\n    if (nodes.length >= MAX_NODES) return alert('Max nodes reached');\n    const id = nodes.length ? Math.max(...nodes.map(n=>n.id)) + 1 : 0;\n    nodes.push({id, x: 400 + (Math.random()*300-150), y: 300 + (Math.random()*200-100)});\n    // expand adj matrix\n    for (let i=0;i<adj.length;i++) adj[i].push(0);\n    adj.push(Array(nodes.length).fill(0));\n    updateUI();\n  });\n\n  document.getElementById('removeNodeBtn').addEventListener('click', ()=>{\n    if (!nodes.length) return;\n    const rem = nodes.pop();\n    // remove row and column\n    adj.splice(rem.id,1);\n    for (let i=0;i<adj.length;i++) adj[i].splice(rem.id,1);\n    // reassign ids to be 0..n-1 for clarity\n    nodes = nodes.map((n,i)=>({id:i,x:n.x,y:n.y}));\n    // rebuild adj to be sized correctly if necessary\n    while(adj.length < nodes.length) adj.push(Array(nodes.length).fill(0));\n    updateUI();\n  });\n\n  document.getElementById('randomBtn').addEventListener('click', ()=>{\n    if (nodes.length===0) return;\n    const p = Number(prompt('Edge probability (0-1):', '0.35')) || 0.35;\n    for (let i=0;i<nodes.length;i++){\n      for (let j=0;j<nodes.length;j++){\n        if (i===j){\n          adj[i][j] = 0;\n        } else {\n          if (!directed && j<i) continue; // fill only half and mirror\n          const exists = Math.random() < p;\n          const val = exists ? (weighted ? Math.round(Math.random()*9)+1 : 1) : 0;\n          adj[i][j] = val;\n          if (!directed) adj[j][i] = val;\n        }\n      }\n    }\n    draw();\n  });\n\n  document.getElementById('clearBtn').addEventListener('click', ()=>{\n    for (let i=0;i<nodes.length;i++) for (let j=0;j<nodes.length;j++) adj[i][j]=0;\n    draw();\n  });\n\n  document.getElementById('directedChk').addEventListener('change', (e)=>{\n    directed = e.target.checked;\n    // If toggling to undirected, symmetrize matrix: make symmetric using OR\n    if (!directed){\n      for (let i=0;i<nodes.length;i++){\n        for (let j=i+1;j<nodes.length;j++){\n          const v = adj[i][j] || adj[j][i] ? (weighted ? (adj[i][j] || adj[j][i]) : 1) : 0;\n          adj[i][j] = v;\n          adj[j][i] = v;\n        }\n      }\n    }\n    updateUI();\n  });\n\n  document.getElementById('weightedChk').addEventListener('change', (e)=>{\n    weighted = e.target.checked;\n    // If toggling to unweighted, convert positive weights to 1\n    if (!weighted){\n      for (let i=0;i<nodes.length;i++) for (let j=0;j<nodes.length;j++) adj[i][j] = adj[i][j] ? 1 : 0;\n    }\n    updateUI();\n  });\n\n  document.getElementById('deselectBtn').addEventListener('click', ()=>{\n    selectedNode = null; updateUI();\n  });\n\n  document.getElementById('fitBtn').addEventListener('click', ()=>{\n    // center nodes roughly in view, keep relative layout\n    if (nodes.length===0) return;\n    const cx = 400, cy=300;\n    const avgX = nodes.reduce((a,b)=>a+b.x,0)/nodes.length;\n    const avgY = nodes.reduce((a,b)=>a+b.y,0)/nodes.length;\n    const dx = cx - avgX, dy = cy - avgY;\n    nodes.forEach(n=>{ n.x += dx; n.y += dy; });\n    draw();\n  });\n\n  document.getElementById('layoutCircleBtn').addEventListener('click', ()=>{\n    const n = nodes.length;\n    if (!n) return;\n    const cx = 400, cy = 300, r = Math.min(240, 60 + n*12);\n    for (let i=0;i<n;i++){\n      nodes[i].x = cx + r*Math.cos(i*2*Math.PI/n);\n      nodes[i].y = cy + r*Math.sin(i*2*Math.PI/n);\n    }\n    draw();\n  });\n\n  document.getElementById('exportBtn').addEventListener('click', ()=>{\n    const data = {\n      directed, weighted, nodes, adj\n    };\n    const txt = JSON.stringify(data, null, 2);\n    prompt('Copy JSON export:', txt);\n  });\n\n  document.getElementById('importBtn').addEventListener('click', ()=>{\n    const raw = document.getElementById('importArea').value.trim();\n    if (!raw) { alert('Paste JSON in the input field first'); return; }\n    try {\n      const data = JSON.parse(raw);\n      directed = !!data.directed;\n      weighted = !!data.weighted;\n      document.getElementById('directedChk').checked = directed;\n      document.getElementById('weightedChk').checked = weighted;\n      nodes = (data.nodes || []).map((n,i)=>({id:i, x:n.x || 400 + Math.random()*200-100, y:n.y || 300 + Math.random()*150-75}));\n      // normalize adj\n      const n = nodes.length;\n      adj = Array.from({length:n}, (_,i)=> Array.from({length:n}, (_,j)=> (data.adj && data.adj[i] && data.adj[i][j]) ? data.adj[i][j] : 0));\n      updateUI();\n    } catch(err){\n      alert('Invalid JSON');\n    }\n  });\n\n  // initialize\n  init(5);\n\n  // Make initial random-ish edges\n  document.getElementById('randomBtn').click();\n\n  // Expose minor functions for debugging (not necessary)\n  window._graph = { nodes, adj };\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": false,
  "hasTest": true
}