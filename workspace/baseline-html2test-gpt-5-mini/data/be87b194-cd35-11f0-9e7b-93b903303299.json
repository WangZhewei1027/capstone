{
  "id": "be87b194-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:50.155Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Kruskal's Algorithm — Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    html,body { height:100%; margin:0; font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background: #f6f8fa; color: #222; }\n    .app { display:flex; height:100vh; }\n    .left { width:72%; min-width:520px; background: #fff; border-right: 1px solid #e2e6ea; display:flex; flex-direction:column; }\n    .canvas-wrap { flex:1; position:relative; overflow:hidden; }\n    svg { width:100%; height:100%; background: linear-gradient(180deg,#ffffff,#fbfdff); cursor:crosshair; }\n    .right { width:28%; min-width:320px; padding:12px; box-sizing:border-box; overflow:auto; }\n    h1 { font-size:18px; margin:6px 0 12px 0; }\n    .controls { display:flex; flex-wrap:wrap; gap:6px; align-items:center; margin-bottom:10px; }\n    button, input[type=range], select { padding:6px 8px; border-radius:6px; border:1px solid #cbd5db; background:#fff; cursor:pointer; }\n    button:active { transform:translateY(1px); }\n    .small { font-size:13px; padding:5px 8px; }\n    label { font-size:13px; display:flex; gap:6px; align-items:center; }\n    .info { font-size:13px; color:#444; margin-top:8px; line-height:1.4; }\n    .panel { background:#f8fafc; border:1px solid #e6edf3; padding:8px; border-radius:8px; margin-bottom:10px; }\n    .list { font-family: monospace; font-size:13px; max-height:220px; overflow:auto; padding:6px; background:#fff; border-radius:6px; border:1px dashed #e2e6ea; }\n    .edge-item { display:flex; justify-content:space-between; gap:6px; padding:4px 2px; align-items:center; }\n    .sets { font-size:13px; }\n    .legend { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }\n    .legend .box { display:flex; gap:6px; align-items:center; font-size:13px; }\n    .swatch { width:14px; height:12px; border-radius:3px; border:1px solid rgba(0,0,0,0.08); }\n    .footer { font-size:12px; color:#666; margin-top:8px; }\n    .btn-danger { background:#fff; border:1px solid #ff6b6b; color:#c0392b }\n    .btn-primary { background:#0b84ff; color:#fff; border:1px solid #0776e6 }\n    .btn-ghost { background:#fff; border:1px solid #cbd5db; color:#222; }\n    .weight-badge { background:#fff; border-radius:6px; padding:2px 6px; border:1px solid #e2e6ea; font-size:12px; }\n    .controls-row { display:flex; gap:6px; align-items:center; flex-wrap:wrap; }\n    .status { font-weight:600; margin-top:8px; font-size:14px; }\n    .muted { color:#666; font-size:13px; }\n    .node { cursor:grab; }\n    .node:active { cursor:grabbing; }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"left\">\n      <div style=\"display:flex;gap:10px;align-items:center;padding:10px;border-bottom:1px solid #eef2f6;\">\n        <div style=\"display:flex;flex-direction:column\">\n          <strong style=\"font-size:16px\">Kruskal's Algorithm — Interactive Visualization</strong>\n          <span class=\"muted\" style=\"font-size:13px\">Build a graph, run Kruskal step-by-step to get a Minimum Spanning Tree (MST)</span>\n        </div>\n        <div style=\"margin-left:auto\" class=\"muted\">Click canvas to add node. Drag from a node to create an edge. Double-click an edge to edit weight.</div>\n      </div>\n\n      <div class=\"canvas-wrap\" id=\"canvasWrap\">\n        <svg id=\"svgCanvas\" xmlns=\"http://www.w3.org/2000/svg\"></svg>\n      </div>\n\n      <div style=\"padding:8px;border-top:1px solid #eef2f6; display:flex; gap:8px; align-items:center;\">\n        <div class=\"muted\">Mode:</div>\n        <select id=\"modeSelect\" style=\"padding:6px;border-radius:6px;\">\n          <option value=\"add\">Add nodes + edges (default)</option>\n          <option value=\"move\">Move nodes</option>\n          <option value=\"delete\">Delete nodes/edges</option>\n        </select>\n        <div style=\"margin-left:8px\" class=\"muted\">Actions: Click empty → add node. Drag node → create edge. Click node → select for edge.</div>\n      </div>\n    </div>\n\n    <div class=\"right\">\n      <h1>Controls</h1>\n\n      <div class=\"panel\">\n        <div class=\"controls\">\n          <button id=\"randomGraph\" class=\"small btn-ghost\">Generate Random Graph</button>\n          <button id=\"clearBtn\" class=\"small btn-danger\">Clear Graph</button>\n          <button id=\"resetAlgo\" class=\"small\">Reset Algorithm</button>\n        </div>\n\n        <div class=\"controls-row\" style=\"margin-top:8px\">\n          <button id=\"stepBtn\" class=\"small btn-primary\">Step</button>\n          <button id=\"runBtn\" class=\"small\">Run</button>\n          <button id=\"stopBtn\" class=\"small btn-ghost\" disabled>Stop</button>\n          <label style=\"margin-left:6px\">Speed:\n            <input id=\"speed\" type=\"range\" min=\"100\" max=\"1500\" value=\"600\" style=\"width:120px;margin-left:6px;\">\n          </label>\n        </div>\n\n        <div class=\"info\">\n          <strong>Current edge:</strong> <span id=\"currentEdge\">—</span><br>\n          <strong>MST total weight:</strong> <span id=\"mstWeight\">0</span>\n        </div>\n\n        <div class=\"legend\">\n          <div class=\"box\"><div class=\"swatch\" style=\"background:#28a745\"></div><div>Accepted (MST)</div></div>\n          <div class=\"box\"><div class=\"swatch\" style=\"background:#9aa0a6\"></div><div>Rejected (would form cycle)</div></div>\n          <div class=\"box\"><div class=\"swatch\" style=\"background:#0b84ff\"></div><div>Candidate</div></div>\n          <div class=\"box\"><div class=\"swatch\" style=\"background:#ddd\"></div><div>Normal edge</div></div>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center\">\n          <strong>Edges (sorted by weight)</strong>\n          <div class=\"muted\">Count: <span id=\"edgeCount\">0</span></div>\n        </div>\n        <div class=\"list\" id=\"edgeList\" aria-live=\"polite\"></div>\n      </div>\n\n      <div class=\"panel\">\n        <strong>Disjoint Set (Union-Find)</strong>\n        <div class=\"sets\" id=\"setsView\"></div>\n      </div>\n\n      <div class=\"panel\">\n        <strong>Tips & Interaction</strong>\n        <div class=\"info\">\n          - Add nodes by clicking empty space. Drag from a node (press and move) to another node to create an edge.<br>\n          - Double-click an edge weight to edit it. In Delete mode, click nodes or edges to remove them.<br>\n          - Use Step to advance one edge; Run to autoplay. The algorithm sorts edges by weight (ascending) then examines each.\n        </div>\n      </div>\n\n      <div class=\"footer\">Built for learning Kruskal's algorithm • Visualizes sorting, union-find, and MST selection</div>\n    </div>\n  </div>\n\n<script>\n/*\n  Kruskal's Algorithm Interactive Demo\n  - SVG canvas for nodes and edges\n  - Add nodes by clicking empty space\n  - Drag from a node to another to create an edge\n  - Step through Kruskal: edges sorted by weight, union-find to detect cycles\n  - Visual feedback: accepted edges (green), rejected edges (gray), candidate (blue)\n*/\n\n(function(){\n  // Utilities\n  const svg = document.getElementById('svgCanvas');\n  const canvasWrap = document.getElementById('canvasWrap');\n  const modeSelect = document.getElementById('modeSelect');\n  const randomGraphBtn = document.getElementById('randomGraph');\n  const clearBtn = document.getElementById('clearBtn');\n  const resetAlgoBtn = document.getElementById('resetAlgo');\n  const stepBtn = document.getElementById('stepBtn');\n  const runBtn = document.getElementById('runBtn');\n  const stopBtn = document.getElementById('stopBtn');\n  const speedInput = document.getElementById('speed');\n  const edgeListDiv = document.getElementById('edgeList');\n  const edgeCountSpan = document.getElementById('edgeCount');\n  const currentEdgeSpan = document.getElementById('currentEdge');\n  const setsView = document.getElementById('setsView');\n  const mstWeightSpan = document.getElementById('mstWeight');\n\n  let nodes = []; // {id, x, y, g} where g is group element\n  let edges = []; // {id, a, b, w, g, state} state: normal/candidate/accepted/rejected\n  let nodeIdCounter = 0;\n  let edgeIdCounter = 0;\n\n  // Algorithm state\n  let algo = {\n    sortedEdges: [],\n    index: 0,\n    running: false,\n    timer: null,\n    mstWeight: 0,\n    uf: null\n  };\n\n  const COLORS = {\n    accepted: '#28a745',\n    rejected: '#9aa0a6',\n    candidate: '#0b84ff',\n    normal: '#ddd',\n    edgeStroke: '#bfcbd6',\n    nodeFill: '#fff',\n    nodeStroke: '#2b7cff'\n  };\n\n  // Create defs for arrowheads? Not needed.\n\n  // SVG helpers\n  function createSVG(tag, attrs) {\n    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);\n    for (const k in attrs) el.setAttribute(k, attrs[k]);\n    return el;\n  }\n\n  function redrawAll() {\n    // set sizes and re-render edges and nodes positions\n    nodes.forEach(n => {\n      n.circle.setAttribute('cx', n.x);\n      n.circle.setAttribute('cy', n.y);\n      n.label.setAttribute('x', n.x);\n      n.label.setAttribute('y', n.y + 4);\n    });\n    edges.forEach(e => {\n      const a = getNodeById(e.a);\n      const b = getNodeById(e.b);\n      if (!a || !b) return;\n      e.line.setAttribute('x1', a.x);\n      e.line.setAttribute('y1', a.y);\n      e.line.setAttribute('x2', b.x);\n      e.line.setAttribute('y2', b.y);\n\n      // position weight label at midpoint, offset a bit\n      const mx = (a.x + b.x) / 2;\n      const my = (a.y + b.y) / 2;\n      e.weightLabel.setAttribute('x', mx);\n      e.weightLabel.setAttribute('y', my - 6);\n    });\n  }\n\n  // Node management\n  function addNode(x, y, id=null) {\n    const nid = id !== null ? id : (++nodeIdCounter);\n    const g = createSVG('g', { class: 'node', cursor: 'grab' });\n    const circle = createSVG('circle', { cx:x, cy:y, r:18, fill:COLORS.nodeFill, stroke:COLORS.nodeStroke, 'stroke-width':2 });\n    const label = createSVG('text', { x:x, y:y+4, 'text-anchor':'middle', 'font-size':12, 'font-family':'monospace', fill:'#112', style:'pointer-events:none' });\n    label.textContent = nid;\n    g.appendChild(circle);\n    g.appendChild(label);\n    svg.appendChild(g);\n\n    const node = { id:nid, x, y, g, circle, label };\n    nodes.push(node);\n\n    // attach pointer handlers for drag to create edges or move\n    attachNodeHandlers(node);\n    return node;\n  }\n\n  function removeNode(id) {\n    // remove connected edges first\n    const toRemove = edges.filter(e => e.a === id || e.b === id).map(e=>e.id);\n    toRemove.forEach(removeEdgeById);\n    // remove node\n    const idx = nodes.findIndex(n=>n.id===id);\n    if (idx>=0) {\n      const n = nodes[idx];\n      svg.removeChild(n.g);\n      nodes.splice(idx,1);\n    }\n  }\n\n  function getNodeById(id) { return nodes.find(n=>n.id===id); }\n\n  // Edge management\n  function addEdge(aId, bId, w, id=null) {\n    if (aId === bId) return null; // no self-loop\n    // check if edge exists (undirected)\n    const existing = edges.find(e => (e.a===aId && e.b===bId) || (e.a===bId && e.b===aId));\n    if (existing) return null;\n    const eid = id !== null ? id : (++edgeIdCounter);\n\n    const a = getNodeById(aId);\n    const b = getNodeById(bId);\n    if (!a || !b) return null;\n\n    // create svg group\n    const g = createSVG('g', { 'data-eid': eid });\n    const line = createSVG('line', { x1:a.x, y1:a.y, x2:b.x, y2:b.y, stroke:COLORS.edgeStroke, 'stroke-width':6, 'stroke-linecap':'round', opacity:1 });\n    const weightLabel = createSVG('text', { x:(a.x+b.x)/2, y:(a.y+b.y)/2 - 6, 'text-anchor':'middle', 'font-size':12, 'font-family':'monospace', fill:'#111', 'pointer-events':'visible', cursor:'pointer' });\n    weightLabel.textContent = w;\n    // add thin overlay for better clicking\n    const lineOverlay = createSVG('line', { x1:a.x, y1:a.y, x2:b.x, y2:b.y, stroke:'transparent', 'stroke-width':20, cursor:'pointer' });\n    g.appendChild(line);\n    g.appendChild(lineOverlay);\n    g.appendChild(weightLabel);\n    // insert under nodes\n    svg.insertBefore(g, svg.querySelector('g.node') || null);\n\n    const edge = { id:eid, a:aId, b:bId, w: Number(w), g, line, lineOverlay, weightLabel, state:'normal' };\n    edges.push(edge);\n\n    // handlers\n    lineOverlay.addEventListener('dblclick', (ev)=> {\n      ev.stopPropagation();\n      const newW = prompt('Edit edge weight (numeric):', edge.w);\n      if (newW !== null && newW.trim() !== '' && !isNaN(Number(newW))) {\n        edge.w = Number(newW);\n        edge.weightLabel.textContent = edge.w;\n        resetAlgorithm();\n        renderEdgeList();\n      }\n    });\n    lineOverlay.addEventListener('click', (ev)=> {\n      ev.stopPropagation();\n      if (modeSelect.value === 'delete') {\n        removeEdgeById(edge.id);\n      }\n    });\n\n    return edge;\n  }\n\n  function removeEdgeById(id) {\n    const idx = edges.findIndex(e=>e.id===id);\n    if (idx>=0) {\n      const e = edges[idx];\n      svg.removeChild(e.g);\n      edges.splice(idx,1);\n      resetAlgorithm();\n      renderEdgeList();\n    }\n  }\n\n  function setEdgeState(edge, state) {\n    edge.state = state;\n    const strokeWidth = (state==='candidate' ? 6 : (state==='accepted' ? 6 : 6));\n    let color = COLORS.normal;\n    let opacity = 1;\n    if (state==='accepted') color = COLORS.accepted;\n    else if (state==='rejected') color = COLORS.rejected;\n    else if (state==='candidate') color = COLORS.candidate;\n    edge.line.setAttribute('stroke', color);\n    edge.line.setAttribute('stroke-width', strokeWidth);\n    // dims weight label accordingly\n    edge.weightLabel.setAttribute('fill', (state==='rejected' ? '#666' : '#111'));\n    renderEdgeList();\n  }\n\n  // Node handlers: drag to move or create edge\n  function attachNodeHandlers(node) {\n    let isPointerDown = false;\n    let startX=0, startY=0;\n    let draggingNode = false;\n    let creatingEdge = false;\n    let tempLine = null;\n    let pressTimeout = null;\n\n    const pointerdown = (ev) => {\n      ev.preventDefault();\n      const mode = modeSelect.value;\n      const p = getEventPoint(ev);\n      isPointerDown = true;\n      startX = p.x; startY = p.y;\n\n      if (mode === 'move') {\n        draggingNode = true;\n      } else if (mode === 'add') {\n        // start a drag to create an edge (we'll detect move distance)\n        pressTimeout = setTimeout(()=>{ /* no-op */ }, 300);\n      } else if (mode === 'delete') {\n        // delete node\n        removeNode(node.id);\n      }\n      node.g.setPointerCapture(ev.pointerId);\n    };\n\n    const pointermove = (ev) => {\n      if (!isPointerDown) return;\n      const p = getEventPoint(ev);\n      const dx = p.x - startX;\n      const dy = p.y - startY;\n      if (modeSelect.value === 'move' && Math.hypot(dx,dy) > 0) {\n        // move node\n        draggingNode = true;\n        node.x = p.x; node.y = p.y;\n        node.circle.setAttribute('cx', node.x);\n        node.circle.setAttribute('cy', node.y);\n        node.label.setAttribute('x', node.x);\n        node.label.setAttribute('y', node.y+4);\n        // update connected edges\n        edges.filter(e=>e.a===node.id || e.b===node.id).forEach(e=>{\n          const a = getNodeById(e.a), b = getNodeById(e.b);\n          e.line.setAttribute('x1', a.x); e.line.setAttribute('y1', a.y);\n          e.line.setAttribute('x2', b.x); e.line.setAttribute('y2', b.y);\n          e.lineOverlay.setAttribute('x1', a.x); e.lineOverlay.setAttribute('y1', a.y);\n          e.lineOverlay.setAttribute('x2', b.x); e.lineOverlay.setAttribute('y2', b.y);\n          e.weightLabel.setAttribute('x', (a.x+b.x)/2); e.weightLabel.setAttribute('y', (a.y+b.y)/2 - 6);\n        });\n      } else if (modeSelect.value === 'add') {\n        if (!creatingEdge && Math.hypot(dx,dy) > 8) {\n          creatingEdge = true;\n          // create temp line\n          tempLine = createSVG('line', { x1:node.x, y1:node.y, x2:p.x, y2:p.y, stroke:COLORS.candidate, 'stroke-width':4, 'stroke-linecap':'round', 'stroke-dasharray':'6,6' });\n          svg.insertBefore(tempLine, svg.querySelector('g.node') || null);\n        }\n        if (creatingEdge && tempLine) {\n          tempLine.setAttribute('x2', p.x);\n          tempLine.setAttribute('y2', p.y);\n        }\n      }\n    };\n\n    const pointerup = (ev) => {\n      isPointerDown = false;\n      node.g.releasePointerCapture(ev.pointerId);\n      const p = getEventPoint(ev);\n      if (creatingEdge) {\n        // detect target node under pointer\n        const target = findNodeNear(p.x, p.y);\n        if (target && target.id !== node.id) {\n          const w = Math.round(Math.random()*20 + 1); // default random weight\n          const edge = addEdge(node.id, target.id, w);\n          if (edge) {\n            edge.weightLabel.textContent = edge.w;\n            resetAlgorithm();\n            renderEdgeList();\n          }\n        }\n      } else if (!draggingNode && modeSelect.value === 'add') {\n        // maybe a click (no drag) — select node for edge creation? For simplicity, nothing\n      }\n      // cleanup\n      draggingNode = false;\n      creatingEdge = false;\n      if (tempLine && svg.contains(tempLine)) svg.removeChild(tempLine);\n      tempLine = null;\n      if (pressTimeout) { clearTimeout(pressTimeout); pressTimeout = null; }\n      redrawAll();\n    };\n\n    node.g.addEventListener('pointerdown', pointerdown);\n    node.g.addEventListener('pointermove', pointermove);\n    node.g.addEventListener('pointerup', pointerup);\n    node.g.addEventListener('pointerleave', (ev)=> { if (isPointerDown) pointerup(ev); });\n  }\n\n  // Canvas handlers for adding nodes by clicking empty space\n  svg.addEventListener('click', (ev)=>{\n    if (modeSelect.value !== 'add') return;\n    const p = getEventPoint(ev);\n    // check if clicked on empty space (not on node)\n    const near = findNodeNear(p.x, p.y, 22);\n    if (near) return;\n    addNode(p.x, p.y);\n    resetAlgorithm();\n    renderEdgeList();\n  });\n\n  function findNodeNear(x,y, radius=20) {\n    return nodes.find(n => (Math.hypot(n.x - x, n.y - y) <= radius));\n  }\n\n  function getEventPoint(ev) {\n    const rect = svg.getBoundingClientRect();\n    return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };\n  }\n\n  // Algorithm: Disjoint set (union-find)\n  class UnionFind {\n    constructor(elements) {\n      this.parent = {};\n      this.rank = {};\n      elements.forEach(e => { this.parent[e] = e; this.rank[e] = 0; });\n    }\n    find(x) {\n      if (this.parent[x] !== x) this.parent[x] = this.find(this.parent[x]);\n      return this.parent[x];\n    }\n    union(x, y) {\n      let rx = this.find(x), ry = this.find(y);\n      if (rx === ry) return false;\n      if (this.rank[rx] < this.rank[ry]) this.parent[rx] = ry;\n      else if (this.rank[ry] < this.rank[rx]) this.parent[ry] = rx;\n      else { this.parent[ry] = rx; this.rank[rx]++; }\n      return true;\n    }\n    sets() {\n      const m = {};\n      for (const k in this.parent) {\n        const r = this.find(k);\n        if (!m[r]) m[r] = [];\n        m[r].push(k);\n      }\n      return m;\n    }\n  }\n\n  // Kruskal algorithm functions\n  function prepareAlgorithm() {\n    // reset states\n    algo.sortedEdges = [...edges].sort((e1,e2)=> e1.w - e2.w || e1.id - e2.id);\n    algo.index = 0;\n    algo.mstWeight = 0;\n    algo.uf = new UnionFind(nodes.map(n=>n.id));\n    algo.running = false;\n    // mark all edges normal visually\n    edges.forEach(e => setEdgeState(e, 'normal'));\n    renderEdgeList();\n    updateSetsView();\n    updateMSTWeight();\n    updateCurrentEdgeDisplay();\n  }\n\n  function resetAlgorithm() {\n    // called whenever graph changes\n    if (algo.timer) { clearInterval(algo.timer); algo.timer = null; algo.running=false; stopBtn.disabled=true; runBtn.disabled=false; }\n    prepareAlgorithm();\n  }\n\n  // one step: consider next edge\n  function stepAlgorithm() {\n    if (algo.index >= algo.sortedEdges.length) {\n      algo.running = false;\n      updateCurrentEdgeDisplay();\n      stopRun();\n      return;\n    }\n    // reset previous candidate edges back to normal if they weren't accepted/rejected\n    algo.sortedEdges.forEach((ed, idx) => {\n      // keep accepted/rejected states, candidate only for current index\n      const e = edges.find(x=>x.id===ed.id);\n      if (e && e.state === 'candidate') setEdgeState(e, 'normal');\n    });\n\n    const edge = algo.sortedEdges[algo.index];\n    const e = edges.find(x=>x.id===edge.id);\n    if (!e) { algo.index++; return stepAlgorithm(); } // if edge removed meanwhile\n    setEdgeState(e, 'candidate');\n    updateCurrentEdgeDisplay(e);\n\n    // decide accept/reject based on union-find\n    const aRoot = algo.uf.find(String(e.a));\n    const bRoot = algo.uf.find(String(e.b));\n    // small timeout is left to UI; but stepAlgorithm is synchronous for single step\n    if (aRoot !== bRoot) {\n      // accept\n      algo.uf.union(String(e.a), String(e.b));\n      setEdgeState(e, 'accepted');\n      algo.mstWeight += e.w;\n    } else {\n      // reject\n      setEdgeState(e, 'rejected');\n    }\n    algo.index++;\n    updateSetsView();\n    updateMSTWeight();\n    renderEdgeList();\n\n    // if finished\n    if (algo.index >= algo.sortedEdges.length) {\n      updateCurrentEdgeDisplay();\n      stopRun();\n      algo.running = false;\n    }\n  }\n\n  function runAlgorithmAutoplay() {\n    if (algo.running) return;\n    algo.running = true;\n    runBtn.disabled = true; stopBtn.disabled = false;\n    const speed = Number(speedInput.value);\n    algo.timer = setInterval(()=> {\n      if (algo.index >= algo.sortedEdges.length) {\n        stopRun();\n        return;\n      }\n      stepAlgorithm();\n    }, speed);\n  }\n\n  function stopRun() {\n    if (algo.timer) clearInterval(algo.timer);\n    algo.timer = null;\n    algo.running = false;\n    runBtn.disabled = false;\n    stopBtn.disabled = true;\n  }\n\n  // UI rendering\n  function renderEdgeList() {\n    // show edges sorted by weight\n    edgeListDiv.innerHTML = '';\n    const arr = [...edges].sort((a,b) => a.w - b.w || a.id - b.id);\n    edgeCountSpan.textContent = arr.length;\n    arr.forEach(e => {\n      const div = document.createElement('div');\n      div.className = 'edge-item';\n      div.style.borderBottom = '1px dashed #eef4f8';\n      div.style.paddingBottom = '6px';\n      div.style.marginBottom = '6px';\n      const left = document.createElement('div');\n      left.textContent = `${e.a} — ${e.b}`;\n      left.style.fontFamily = 'monospace';\n      left.style.fontSize = '13px';\n      const right = document.createElement('div');\n      const wspan = document.createElement('span');\n      wspan.className = 'weight-badge';\n      wspan.textContent = e.w;\n      right.appendChild(wspan);\n      // state color dot\n      const dot = document.createElement('span');\n      dot.style.display='inline-block';\n      dot.style.width='10px';\n      dot.style.height='10px';\n      dot.style.borderRadius='3px';\n      dot.style.marginLeft='8px';\n      dot.style.verticalAlign='middle';\n      let color = '#ddd';\n      if (e.state==='accepted') color = COLORS.accepted;\n      else if (e.state==='rejected') color = COLORS.rejected;\n      else if (e.state==='candidate') color = COLORS.candidate;\n      dot.style.background = color;\n      right.appendChild(dot);\n      div.appendChild(left);\n      div.appendChild(right);\n      // clicking edge in list highlights it on canvas momentarily\n      div.addEventListener('click', ()=> {\n        // flash candidate\n        edges.forEach(ee => { if (ee.id !== e.id && ee.state === 'candidate') setEdgeState(ee,'normal'); });\n        setEdgeState(e, 'candidate');\n        setTimeout(()=> { if (e.state === 'candidate') setEdgeState(e,'normal'); }, 800);\n      });\n      edgeListDiv.appendChild(div);\n    });\n  }\n\n  function updateSetsView() {\n    if (!algo.uf) {\n      setsView.innerHTML = '<div class=\"muted\">—</div>';\n      return;\n    }\n    const sets = algo.uf.sets();\n    const keys = Object.keys(sets).sort((a,b)=>Number(a)-Number(b));\n    setsView.innerHTML = '';\n    keys.forEach(k => {\n      const div = document.createElement('div');\n      div.style.marginBottom = '6px';\n      div.textContent = `${k}: [ ${sets[k].join(', ')} ]`;\n      setsView.appendChild(div);\n    });\n  }\n\n  function updateMSTWeight() {\n    mstWeightSpan.textContent = algo.mstWeight;\n  }\n\n  function updateCurrentEdgeDisplay(e=null) {\n    if (!e) {\n      currentEdgeSpan.textContent = (algo.index >= algo.sortedEdges.length ? '— finished' : '—');\n    } else {\n      currentEdgeSpan.textContent = `${e.a} — ${e.b} (w=${e.w})`;\n    }\n  }\n\n  // Buttons\n  randomGraphBtn.addEventListener('click', ()=> {\n    clearGraph();\n    generateRandomGraph();\n  });\n\n  clearBtn.addEventListener('click', ()=> {\n    if (!confirm('Clear entire graph?')) return;\n    clearGraph();\n  });\n\n  resetAlgoBtn.addEventListener('click', ()=> {\n    resetAlgorithm();\n  });\n\n  stepBtn.addEventListener('click', ()=> {\n    if (!algo.uf) prepareAlgorithm();\n    stepAlgorithm();\n  });\n\n  runBtn.addEventListener('click', ()=> {\n    if (!algo.uf) prepareAlgorithm();\n    runAlgorithmAutoplay();\n  });\n\n  stopBtn.addEventListener('click', ()=> {\n    stopRun();\n  });\n\n  // clear graph\n  function clearGraph() {\n    // remove all svg children\n    nodes.forEach(n => { if (svg.contains(n.g)) svg.removeChild(n.g); });\n    edges.forEach(e => { if (svg.contains(e.g)) svg.removeChild(e.g); });\n    nodes = []; edges = []; nodeIdCounter = 0; edgeIdCounter = 0;\n    resetAlgorithm();\n    renderEdgeList();\n  }\n\n  // Random graph generation\n  function generateRandomGraph() {\n    const W = svg.clientWidth, H = svg.clientHeight;\n    const N = Math.max(4, Math.floor(Math.random()*4) + 5); // 5-8 nodes\n    for (let i=0;i<N;i++){\n      const x = Math.round(40 + Math.random()*(W-80));\n      const y = Math.round(40 + Math.random()*(H-120));\n      addNode(x,y);\n    }\n    // create random edges: connect a few\n    const nodeIds = nodes.map(n=>n.id);\n    // ensure connectivity: random tree first\n    for (let i=1;i<nodeIds.length;i++){\n      const a = nodeIds[i];\n      const b = nodeIds[Math.floor(Math.random()*i)];\n      addEdge(a,b, Math.round(Math.random()*20 + 1));\n    }\n    // add extra random edges\n    const extra = Math.floor(Math.random()* (nodeIds.length));\n    for (let k=0;k<extra;k++){\n      const a = nodeIds[Math.floor(Math.random()*nodeIds.length)];\n      const b = nodeIds[Math.floor(Math.random()*nodeIds.length)];\n      if (a!==b) addEdge(a,b, Math.round(Math.random()*20 + 1));\n    }\n    resetAlgorithm();\n    renderEdgeList();\n  }\n\n  // initial setup\n  prepareAlgorithm();\n  renderEdgeList();\n\n  // keyboard shortcuts\n  window.addEventListener('keydown', (ev)=> {\n    if (ev.key === 'r') { generateRandomGraph(); }\n    if (ev.key === 'c') { clearGraph(); }\n    if (ev.key === ' ') { ev.preventDefault(); stepAlgorithm(); }\n  });\n\n  // helpers: on window resize recalc positions? just redraw\n  window.addEventListener('resize', redrawAll);\n\n  // initial sample graph for demonstration\n  function seedSample() {\n    clearGraph();\n    const w = svg.clientWidth, h = svg.clientHeight;\n    const centerX = w/2;\n    const centerY = h/2;\n    const r = Math.min(w,h)/3.5;\n    // place 6 nodes in circle\n    const ids = [];\n    for (let i=0;i<6;i++){\n      const ang = i * (Math.PI*2/6) - Math.PI/6;\n      const x = Math.round(centerX + r * Math.cos(ang));\n      const y = Math.round(centerY + r * Math.sin(ang));\n      const n = addNode(x,y);\n      ids.push(n.id);\n    }\n    // add some edges with weights\n    addEdge(ids[0], ids[1], 7);\n    addEdge(ids[0], ids[2], 9);\n    addEdge(ids[0], ids[5], 14);\n    addEdge(ids[1], ids[2], 10);\n    addEdge(ids[1], ids[3], 15);\n    addEdge(ids[2], ids[3], 11);\n    addEdge(ids[2], ids[5], 2);\n    addEdge(ids[3], ids[4], 6);\n    addEdge(ids[4], ids[5], 9);\n    resetAlgorithm();\n    renderEdgeList();\n  }\n\n  seedSample();\n\n  // Expose some helpers to window for debugging (optional)\n  window._kruskaldemo = {\n    nodes, edges, resetAlgorithm, prepareAlgorithm, stepAlgorithm, runAlgorithmAutoplay, stopRun\n  };\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}