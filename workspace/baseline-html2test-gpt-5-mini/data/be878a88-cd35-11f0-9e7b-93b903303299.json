{
  "id": "be878a88-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:50.349Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Merge Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Merge Sort Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#60a5fa;\n      --muted:#94a3b8;\n      --good:#34d399;\n      --bad:#fb7185;\n      --bar:#60a5fa;\n      --bar-alt:#60e0a5;\n      --text:#e6eef8;\n    }\n    *{box-sizing:border-box;font-family:Inter, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;}\n    body{margin:0;min-height:100vh;background:linear-gradient(180deg,#071029 0%, #071824 60%);color:var(--text); display:flex;flex-direction:column;align-items:center;padding:18px;}\n    h1{margin:8px 0 12px;font-size:20px;}\n    .container{width:100%;max-width:1100px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));border:1px solid rgba(255,255,255,0.04);padding:14px;border-radius:10px;box-shadow:0 10px 30px rgba(2,6,23,0.6);}\n    .top{display:flex;gap:16px;align-items:center;flex-wrap:wrap;margin-bottom:12px;}\n    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}\n    button{background:var(--panel);border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;color:var(--text);cursor:pointer;}\n    button.primary{background:linear-gradient(90deg,var(--accent), #3b82f6);border:none;color:#02203a;font-weight:600;}\n    .small{padding:6px 8px;font-size:14px;}\n    .sliderRow{display:flex;gap:8px;align-items:center;}\n    input[type=range]{appearance:none;height:8px;background:linear-gradient(90deg,#263544,#12202c);border-radius:6px;outline:none;}\n    input[type=range]::-webkit-slider-thumb{appearance:none;width:14px;height:14px;border-radius:50%;background:var(--accent);box-shadow:0 2px 6px rgba(0,0,0,0.4);}\n    .info{margin-left:auto;color:var(--muted);display:flex;gap:16px;align-items:center;font-size:14px;}\n    .visual{height:340px;background:linear-gradient(180deg,#021027 0%, #041427 100%);border-radius:8px;padding:12px;margin-top:6px;display:flex;flex-direction:column;gap:12px;border:1px solid rgba(255,255,255,0.03);}\n    .bars{flex:1;display:flex;align-items:end;gap:2px;height:100%;width:100%;padding:4px;overflow:hidden;border-radius:6px;position:relative;}\n    .bar{background:var(--bar);flex:1 1 auto;border-radius:4px 4px 0 0;display:flex;align-items:flex-end;justify-content:center;color:rgba(0,0,0,0.7);font-size:11px;font-weight:700;user-select:none;transition:height 120ms linear, background 120ms;}\n    .bar.smallText{font-size:10px;padding-bottom:3px;}\n    .legend{display:flex;gap:6px;align-items:center;flex-wrap:wrap;font-size:13px;color:var(--muted);}\n    .dot{width:12px;height:12px;border-radius:3px;}\n    .dot.compare{background:#facc15;}\n    .dot.write{background:#f97316;}\n    .dot.sorted{background:var(--good);}\n    .panel{display:flex;gap:12px;align-items:center;}\n    .pseudocode{width:320px;background:#021826;border-radius:8px;padding:10px;color:var(--muted);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;font-size:13px;}\n    .code-line{padding:4px 6px;border-radius:6px;}\n    .code-line.active{background:linear-gradient(90deg, rgba(96,165,250,0.12), rgba(96,165,250,0.04));color:var(--accent);font-weight:600;}\n    .stats{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:13px;}\n    .stat{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:6px;}\n    .footer{margin-top:12px;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;color:var(--muted);font-size:13px;}\n    .rangeLabel{min-width:68px;text-align:center;}\n    .controls .input{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px 8px;border-radius:8px;color:var(--text);}\n    @media(max-width:900px){ .pseudocode{display:none;} .info{display:none;} }\n  </style>\n</head>\n<body>\n  <div class=\"container\" role=\"application\" aria-label=\"Merge Sort Visualizer\">\n    <h1>Merge Sort Visualizer</h1>\n    <div class=\"top\">\n      <div class=\"controls\" role=\"toolbar\">\n        <button id=\"generate\" class=\"small\">Generate</button>\n        <button id=\"shuffle\" class=\"small\">Shuffle</button>\n        <button id=\"start\" class=\"primary small\">Start</button>\n        <button id=\"pause\" class=\"small\" disabled>Pause</button>\n        <button id=\"step\" class=\"small\">Step</button>\n        <button id=\"reset\" class=\"small\">Reset</button>\n\n        <div class=\"sliderRow\">\n          <label for=\"size\" class=\"rangeLabel\">Size</label>\n          <input id=\"size\" type=\"range\" min=\"8\" max=\"160\" value=\"48\" />\n        </div>\n\n        <div class=\"sliderRow\">\n          <label for=\"speed\" class=\"rangeLabel\">Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"1\" max=\"100\" value=\"48\" />\n        </div>\n\n        <div>\n          <label style=\"display:flex;gap:6px;align-items:center;\">\n            <input id=\"order\" type=\"checkbox\" />\n            <span style=\"color:var(--muted);font-size:13px;\">Descending</span>\n          </label>\n        </div>\n      </div>\n\n      <div class=\"info\" aria-hidden=\"true\">\n        <div class=\"legend\">\n          <div style=\"display:flex;gap:6px;align-items:center;\"><div class=\"dot compare\"></div><div>Compare</div></div>\n          <div style=\"display:flex;gap:6px;align-items:center;\"><div class=\"dot write\"></div><div>Write</div></div>\n          <div style=\"display:flex;gap:6px;align-items:center;\"><div class=\"dot sorted\"></div><div>Sorted Range</div></div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"visual\" role=\"region\" aria-label=\"Sort visualization\">\n      <div class=\"bars\" id=\"bars\" aria-hidden=\"false\"></div>\n\n      <div style=\"display:flex;gap:12px;align-items:flex-start\">\n        <div class=\"panel\" style=\"gap:18px;align-items:center\">\n          <div class=\"stats\">\n            <div class=\"stat\">Comparisons: <span id=\"comp\">0</span></div>\n            <div class=\"stat\">Writes: <span id=\"writes\">0</span></div>\n            <div class=\"stat\">Actions queued: <span id=\"actionsCount\">0</span></div>\n          </div>\n          <div style=\"color:var(--muted);font-size:13px;\">\n            Tip: Use Step to advance one recorded action while paused. Increase Speed to animate faster.\n          </div>\n        </div>\n\n        <div class=\"pseudocode\" aria-hidden=\"true\">\n          <div style=\"font-weight:700;margin-bottom:6px;color:var(--text)\">Pseudocode (merge sort)</div>\n          <div id=\"code\">\n            <div class=\"code-line\" data-line=\"1\">1  function mergeSort(arr, l, r):</div>\n            <div class=\"code-line\" data-line=\"2\">2    if l >= r: return</div>\n            <div class=\"code-line\" data-line=\"3\">3    mid = (l + r) // 2</div>\n            <div class=\"code-line\" data-line=\"4\">4    mergeSort(arr, l, mid)</div>\n            <div class=\"code-line\" data-line=\"5\">5    mergeSort(arr, mid+1, r)</div>\n            <div class=\"code-line\" data-line=\"6\">6    merge(arr, l, mid, r)</div>\n            <div class=\"code-line\" data-line=\"7\">7  function merge(arr, l, mid, r):</div>\n            <div class=\"code-line\" data-line=\"8\">8    i = l; j = mid+1; k = l</div>\n            <div class=\"code-line\" data-line=\"9\">9    while i <= mid and j <= r:</div>\n            <div class=\"code-line\" data-line=\"10\">10     if arr[i] <= arr[j]: temp[k++] = arr[i++]</div>\n            <div class=\"code-line\" data-line=\"11\">11     else: temp[k++] = arr[j++]</div>\n            <div class=\"code-line\" data-line=\"12\">12    while i <= mid: temp[k++] = arr[i++]</div>\n            <div class=\"code-line\" data-line=\"13\">13    while j <= r: temp[k++] = arr[j++]</div>\n            <div class=\"code-line\" data-line=\"14\">14    copy temp[l..r] back into arr[l..r]</div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      <div>Stable sort • Time: O(n log n) average/worst • Space: O(n)</div>\n      <div style=\"color:var(--muted)\">Visualization by Merge Sort algorithm — interactive and step-through</div>\n    </div>\n  </div>\n\n  <script>\n    // Merge Sort Visualizer\n    (function(){\n      const barsEl = document.getElementById('bars');\n      const sizeInput = document.getElementById('size');\n      const speedInput = document.getElementById('speed');\n      const generateBtn = document.getElementById('generate');\n      const shuffleBtn = document.getElementById('shuffle');\n      const startBtn = document.getElementById('start');\n      const pauseBtn = document.getElementById('pause');\n      const stepBtn = document.getElementById('step');\n      const resetBtn = document.getElementById('reset');\n      const orderCheck = document.getElementById('order');\n      const compsEl = document.getElementById('comp');\n      const writesEl = document.getElementById('writes');\n      const actionsCountEl = document.getElementById('actionsCount');\n      const codeLines = Array.from(document.querySelectorAll('.code-line'));\n\n      let array = [];\n      let initialArray = [];\n      let actions = []; // queued actions describing the sort\n      let actionIndex = 0;\n      let timer = null;\n      let running = false;\n      let paused = false;\n      let comparisons = 0;\n      let writes = 0;\n\n      // Colors\n      const COLOR_DEFAULT = 'var(--bar)';\n      const COLOR_COMPARE = '#facc15'; // yellow\n      const COLOR_WRITE = '#f97316'; // orange\n      const COLOR_RANGE = 'rgba(96,165,250,0.18)';\n      const COLOR_SORTED = 'var(--good)';\n\n      function rand(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }\n\n      function createArray(n){\n        array = [];\n        for(let i=0;i<n;i++) array.push(rand(5, 100));\n        initialArray = array.slice();\n      }\n\n      function renderBars(){\n        barsEl.innerHTML = '';\n        const n = array.length;\n        for(let i=0;i<n;i++){\n          const v = array[i];\n          const bar = document.createElement('div');\n          bar.className = 'bar' + (n>80 ? ' smallText' : '');\n          bar.style.height = (v) + '%';\n          bar.style.flexBasis = (100/n) + '%';\n          bar.style.background = COLOR_DEFAULT;\n          bar.dataset.index = i;\n          bar.title = v;\n          bar.textContent = n <= 60 ? v : '';\n          barsEl.appendChild(bar);\n        }\n      }\n\n      function updateStats(){\n        compsEl.textContent = comparisons;\n        writesEl.textContent = writes;\n        actionsCountEl.textContent = Math.max(0, actions.length - actionIndex);\n      }\n\n      // Recording actions: we'll operate on a scratch array and push actions\n      function recordMergeSort(arr){\n        actions = [];\n        comparisons = 0;\n        writes = 0;\n        // We'll copy the array to a working array to generate writes precisely\n        const work = arr.slice();\n        function push(a){ actions.push(a); }\n        function mergeSort(l, r){\n          push({type:'range', start:l, end:r, line:1});\n          if(l >= r){\n            push({type:'rangeEnd', start:l, end:r}); // no-op marker\n            return;\n          }\n          push({type:'code', line:3});\n          const mid = Math.floor((l + r)/2);\n          push({type:'code', line:4});\n          mergeSort(l, mid);\n          push({type:'code', line:5});\n          mergeSort(mid+1, r);\n          push({type:'code', line:6});\n          // merge\n          push({type:'mergeStart', start:l, mid:mid, end:r});\n          const temp = [];\n          let i = l, j = mid+1, k = 0;\n          push({type:'code', line:7});\n          while(i <= mid && j <= r){\n            push({type:'code', line:9});\n            // compare\n            push({type:'compare', i:i, j:j});\n            comparisons++;\n            if(work[i] <= work[j]){\n              push({type:'code', line:10});\n              temp[k++] = work[i];\n              push({type:'writeTemp', index: (l + k - 1), value: work[i]});\n              // not counting writes to temp into 'writes' below; we'll count writes when copying back\n              i++;\n            } else {\n              push({type:'code', line:11});\n              temp[k++] = work[j];\n              push({type:'writeTemp', index: (l + k - 1), value: work[j]});\n              j++;\n            }\n          }\n          while(i <= mid){\n            push({type:'code', line:12});\n            temp[k++] = work[i];\n            push({type:'writeTemp', index: (l + k - 1), value: work[i]});\n            i++;\n          }\n          while(j <= r){\n            push({type:'code', line:13});\n            temp[k++] = work[j];\n            push({type:'writeTemp', index: (l + k - 1), value: work[j]});\n            j++;\n          }\n          // copy back\n          for(let t=0;t<temp.length;t++){\n            work[l + t] = temp[t];\n            push({type:'overwrite', index: l + t, value: temp[t]});\n            writes++;\n          }\n          push({type:'rangeSorted', start:l, end:r});\n          push({type:'mergeEnd', start:l, end:r});\n        }\n        if(arr.length > 0) mergeSort(0, arr.length-1);\n        push({type:'done'});\n      }\n\n      // Animation: apply next action\n      function applyAction(act){\n        // clear highlights first in most cases\n        const bars = barsEl.children;\n        function resetBars(){\n          for(let b of bars) b.style.background = COLOR_DEFAULT;\n        }\n        // helper to color range\n        function colorRange(start,end,color){\n          for(let i=start;i<=end && i<bars.length;i++){\n            if(i<0) continue;\n            bars[i].style.background = color;\n          }\n        }\n\n        switch(act.type){\n          case 'range':\n            resetBars();\n            colorRange(act.start, act.end, COLOR_RANGE);\n            highlightCode(1);\n            break;\n          case 'code':\n            resetBars();\n            highlightCode(act.line);\n            break;\n          case 'compare':\n            resetBars();\n            if(bars[act.i]) bars[act.i].style.background = COLOR_COMPARE;\n            if(bars[act.j]) bars[act.j].style.background = COLOR_COMPARE;\n            highlightCode(9);\n            comparisons = Math.max(0, comparisons); // already incremented during recording\n            break;\n          case 'writeTemp':\n            // show write visual on the target index (like writing into temp position within array)\n            resetBars();\n            if(bars[act.index]){\n              bars[act.index].style.background = COLOR_WRITE;\n              bars[act.index].style.height = (act.value) + '%';\n              bars[act.index].textContent = bars.length <= 60 ? act.value : '';\n            }\n            highlightCode(10); // approximate\n            break;\n          case 'overwrite':\n            // write back into the main array (count as write)\n            resetBars();\n            if(bars[act.index]){\n              bars[act.index].style.background = COLOR_WRITE;\n              bars[act.index].style.height = (act.value) + '%';\n              bars[act.index].textContent = bars.length <= 60 ? act.value : '';\n            }\n            highlightCode(14);\n            break;\n          case 'rangeSorted':\n            resetBars();\n            colorRange(act.start, act.end, COLOR_SORTED);\n            highlightCode(14);\n            break;\n          case 'mergeStart':\n            resetBars();\n            colorRange(act.start, act.end, COLOR_RANGE);\n            highlightCode(7);\n            break;\n          case 'mergeEnd':\n            resetBars();\n            colorRange(act.start, act.end, COLOR_SORTED);\n            highlightCode(6);\n            break;\n          case 'rangeEnd':\n            // nothing\n            resetBars();\n            break;\n          case 'done':\n            resetBars();\n            for(let i=0;i<bars.length;i++) bars[i].style.background = COLOR_SORTED;\n            highlightCode(null);\n            running = false;\n            paused = false;\n            startBtn.disabled = false;\n            pauseBtn.disabled = true;\n            break;\n        }\n        updateStats();\n      }\n\n      function highlightCode(line){\n        codeLines.forEach(cl=>{\n          const ln = cl.dataset.line ? Number(cl.dataset.line) : null;\n          if(line && ln === Number(line)) cl.classList.add('active'); else cl.classList.remove('active');\n        });\n      }\n\n      function play(){\n        if(actions.length === 0) return;\n        running = true;\n        paused = false;\n        startBtn.disabled = true;\n        pauseBtn.disabled = false;\n        stepBtn.disabled = false;\n        resetBtn.disabled = true;\n        generateBtn.disabled = true;\n        shuffleBtn.disabled = true;\n        sizeInput.disabled = true;\n        orderCheck.disabled = true;\n\n        const speedVal = Number(speedInput.value); // 1..100, higher = faster\n        // map speed to delay ms: speed 1 -> 800ms, 100 -> 5ms (non-linear)\n        const delay = Math.max(5, Math.floor(800 * (1 - (speedVal-1)/99)));\n\n        function step(){\n          if(paused || !running) return;\n          if(actionIndex >= actions.length){\n            running = false;\n            clearInterval(timer);\n            applyAction({type:'done'});\n            updateStats();\n            return;\n          }\n          const act = actions[actionIndex++];\n          applyAction(act);\n          updateStats();\n        }\n\n        // run first immediately so UI responds quickly\n        step();\n        timer = setInterval(()=>{\n          if(paused || !running) return;\n          if(actionIndex >= actions.length){\n            clearInterval(timer);\n            running = false;\n            applyAction({type:'done'});\n            updateStats();\n            return;\n          }\n          const act = actions[actionIndex++];\n          applyAction(act);\n          updateStats();\n        }, delay);\n      }\n\n      function pause(){\n        paused = true;\n        running = false;\n        startBtn.disabled = false;\n        pauseBtn.disabled = true;\n        resetBtn.disabled = false;\n        generateBtn.disabled = false;\n        shuffleBtn.disabled = false;\n        sizeInput.disabled = false;\n        orderCheck.disabled = false;\n        if(timer) clearInterval(timer);\n      }\n\n      function doStep(){\n        if(actionIndex >= actions.length) return;\n        const act = actions[actionIndex++];\n        applyAction(act);\n        updateStats();\n      }\n\n      // Build actions and then animate them on Start\n      function startSort(){\n        // if already running, do nothing\n        if(running && !paused) return;\n        // prepare array snapshot\n        const snapshot = Array.from(barsEl.children).map(b => parseInt(b.title || b.textContent) || 0);\n        // choose order\n        const descending = orderCheck.checked;\n        let arrCopy = snapshot.slice();\n        if(descending){\n          // to get descending, sort by ascending then reverse comparisons: easier to invert values\n          // We'll transform values by negating so that the recorded ascending merges produce descending final\n          arrCopy = arrCopy.map(v => 100 - v); // invert relative order\n        }\n        recordMergeSort(arrCopy);\n        actionIndex = 0;\n        comparisons = 0; writes = 0;\n        updateStats();\n        play();\n      }\n\n      // Utilities for buttons\n      function stopAnimation(){\n        running = false;\n        paused = false;\n        if(timer) clearInterval(timer);\n        startBtn.disabled = false;\n        pauseBtn.disabled = true;\n        resetBtn.disabled = false;\n        generateBtn.disabled = false;\n        shuffleBtn.disabled = false;\n        sizeInput.disabled = false;\n        orderCheck.disabled = false;\n      }\n\n      // initial setup\n      function initialize(){\n        createArray(Number(sizeInput.value));\n        renderBars();\n        updateStats();\n      }\n\n      // button handlers\n      generateBtn.addEventListener('click', ()=>{\n        stopAnimation();\n        createArray(Number(sizeInput.value));\n        renderBars();\n        actions = [];\n        actionIndex = 0;\n        comparisons = 0;\n        writes = 0;\n        updateStats();\n        highlightCode(null);\n      });\n\n      shuffleBtn.addEventListener('click', ()=>{\n        stopAnimation();\n        // Fisher-Yates shuffle\n        for(let i=array.length-1;i>0;i--){\n          const j = Math.floor(Math.random()*(i+1));\n          [array[i], array[j]] = [array[j], array[i]];\n        }\n        initialArray = array.slice();\n        renderBars();\n        actions = [];\n        actionIndex = 0;\n        comparisons = 0;\n        writes = 0;\n        updateStats();\n        highlightCode(null);\n      });\n\n      startBtn.addEventListener('click', ()=>{\n        startSort();\n      });\n\n      pauseBtn.addEventListener('click', ()=>{\n        pause();\n      });\n\n      stepBtn.addEventListener('click', ()=>{\n        if(running && !paused){\n          // if running, pause then step\n          pause();\n        }\n        if(actions.length === 0){\n          // record actions for current array to enable stepping\n          const snapshot = Array.from(barsEl.children).map(b => parseInt(b.title || b.textContent) || 0);\n          let arrCopy = snapshot.slice();\n          if(orderCheck.checked) arrCopy = arrCopy.map(v => 100 - v);\n          recordMergeSort(arrCopy);\n          actionIndex = 0;\n          comparisons = 0; writes = 0;\n        }\n        doStep();\n      });\n\n      resetBtn.addEventListener('click', ()=>{\n        stopAnimation();\n        array = initialArray.slice();\n        renderBars();\n        actions = [];\n        actionIndex = 0;\n        comparisons = 0;\n        writes = 0;\n        updateStats();\n        highlightCode(null);\n      });\n\n      sizeInput.addEventListener('input', ()=>{\n        // update but don't start heavy re-render until user clicks generate\n        // show a quick preview by generating small random array of new size\n        createArray(Number(sizeInput.value));\n        renderBars();\n        actions = [];\n        actionIndex = 0;\n        comparisons = 0;\n        writes = 0;\n        updateStats();\n      });\n\n      // assist: when speed changes while running, restart timer with new delay\n      speedInput.addEventListener('input', ()=>{\n        if(running && !paused){\n          if(timer) clearInterval(timer);\n          play();\n        }\n      });\n\n      // keyboard shortcuts\n      window.addEventListener('keydown', (e)=>{\n        if(e.key === ' '){ e.preventDefault(); if(running && !paused) pause(); else startSort(); }\n        if(e.key === 's'){ stepBtn.click(); }\n        if(e.key === 'r'){ generateBtn.click(); }\n      });\n\n      // initial call\n      initialize();\n\n      // Make sure bars update their title on write actions: since writes update elements directly in applyAction,\n      // but at the start we also need titles to reflect numbers for proper Step recording later.\n      // Ensure that after finishing recording, the actual DOM isn't left in inverted state for descending sorting:\n      // We recorded using inverted values if descending; but we showed the original array. During applyAction overwrite actions\n      // set heights to recorded values; to produce descending sort for the user we inverted values at recording time.\n      // To keep UI consistent, we will, upon every overwrite, show the final visible value by inverting back when order checked.\n      // To implement this, when applyAction sees overwrite or writeTemp and orderCheck.checked, it should invert displayed value.\n      // That logic is implemented below by reading orderCheck.checked.\n\n      // Update applyAction to account for descending visualization: we override it here with additional logic.\n      // (We patch applyAction with closure capturing orderCheck)\n      (function patchApplyActionForOrder(){\n        const originalApply = applyAction;\n        applyAction = function(act){\n          // For overwrite/writeTemp, if orderCheck.checked, display inverted value so the user sees descending final order.\n          const isDesc = orderCheck.checked;\n          if((act.type === 'overwrite' || act.type === 'writeTemp') && isDesc){\n            // act.value is in inverted domain (100 - original), so invert back for display:\n            const displayVal = 100 - act.value;\n            const patched = Object.assign({}, act, {value: displayVal});\n            originalApply(patched);\n          } else {\n            originalApply(act);\n          }\n        };\n      })();\n\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Merge Sort"
    }
  ],
  "topic": "Merge Sort",
  "hasFSM": false,
  "hasTest": true
}