{
  "id": "be87b191-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:56.630Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<title>Dijkstra's Algorithm Visualizer</title>\n<style>\n  :root {\n    --bg: #0f1724;\n    --panel: #0b1220;\n    --accent: #1e90ff;\n    --muted: #94a3b8;\n    --card: #071024;\n    --good: #10b981;\n    --warn: #f59e0b;\n    --danger: #ef4444;\n    --text: #e6eef8;\n  }\n  html,body{height:100%;margin:0;background:linear-gradient(180deg,#041028 0%, #071124 100%);font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n  .app {\n    display: grid;\n    grid-template-columns: 360px 1fr;\n    gap: 16px;\n    height:100vh;\n    padding:16px;\n    box-sizing:border-box;\n  }\n  .panel {\n    background: linear-gradient(180deg,var(--panel),#051227);\n    border-radius:10px;\n    padding:14px;\n    color:var(--text);\n    box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n    display:flex;\n    flex-direction:column;\n    gap:12px;\n  }\n  h1{font-size:18px;margin:0 0 6px 0}\n  .controls {display:flex;flex-wrap:wrap;gap:8px;}\n  button, .mode-btn {\n    background:transparent;border:1px solid rgba(255,255,255,0.06);\n    color:var(--text);padding:8px 10px;border-radius:8px;cursor:pointer;font-size:13px;\n  }\n  button:hover{border-color:rgba(255,255,255,0.12)}\n  .mode-btn.active{background:linear-gradient(90deg,var(--accent),#7cc0ff);color:#001027;border:none;box-shadow:0 6px 18px rgba(30,144,255,0.12)}\n  .small {padding:6px 8px;font-size:12px}\n  .muted {color:var(--muted);font-size:13px}\n  .row {display:flex;gap:8px;align-items:center}\n  .canvas-wrap {position:relative;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}\n  svg{width:100%;height:100%;display:block;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}\n  .legend {display:flex;gap:8px;flex-wrap:wrap}\n  .legend .item {display:flex;gap:6px;align-items:center;font-size:13px;color:var(--muted)}\n  .dot {width:14px;height:14px;border-radius:50%}\n  .dot.source{background:var(--accent)}\n  .dot.visited{background:var(--good)}\n  .dot.unvisited{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.04)}\n  .dot.current{background:var(--warn)}\n  .info {font-size:13px;color:var(--muted);padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}\n  .table {max-height:240px;overflow:auto;border-radius:8px;padding:6px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}\n  table{width:100%;border-collapse:collapse;color:var(--text);font-size:13px}\n  th,td{padding:6px 8px;border-bottom:1px dashed rgba(255,255,255,0.02);text-align:left}\n  th{color:var(--muted);font-weight:600;font-size:12px}\n  .badge {padding:4px 8px;border-radius:999px;font-size:12px}\n  .badge.visited{background:linear-gradient(90deg,var(--good),#41c18b);color:#032a17}\n  .badge.unvisited{background:transparent;border:1px solid rgba(255,255,255,0.04)}\n  .controls .input {display:flex;gap:6px;align-items:center}\n  input[type=number]{width:74px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}\n  .footer {margin-top:auto;font-size:12px;color:var(--muted)}\n  .hint{font-size:13px;color:var(--muted)}\n  .top-buttons{display:flex;gap:6px;flex-wrap:wrap}\n  .right-top {display:flex;gap:8px;align-items:center;justify-content:flex-end}\n  .controls .select {padding:7px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--text)}\n  /* SVG node/edge styles */\n  .node {cursor:pointer;transition:transform 0.08s}\n  .node circle {fill:#041534;stroke:#2b86ff;stroke-width:2;filter:drop-shadow(0 2px 6px rgba(20,100,200,0.12))}\n  .node.visited circle {fill:linear-gradient(#032a17,#044128)}\n  .node .label {pointer-events:none;font-weight:600;fill:#dff0ff;font-size:13px}\n  .node .sub {pointer-events:none;fill:#a9d6ff;font-size:11px}\n  .edge {stroke:#2b86ff;stroke-opacity:0.14;stroke-width:3;cursor:pointer}\n  .edge.relax {stroke:#f59e0b;stroke-width:4;stroke-opacity:0.95}\n  .edge.good {stroke:#10b981;stroke-width:4;stroke-opacity:0.95}\n  .edge-label {fill:#bcdfff;font-size:12px;pointer-events:none}\n  .node.current circle {stroke:#f59e0b;stroke-width:3.6}\n  .node.source circle {stroke: #7cc0ff;stroke-width:3.6;box-shadow:none}\n  .node.visited circle {stroke:#10b981; stroke-width:3.6}\n  .control-row {display:flex;gap:8px;align-items:center}\n  .small-muted{font-size:12px;color:var(--muted)}\n  .note{font-size:12px;color:var(--muted);padding:8px;background:rgba(255,255,255,0.01);border-radius:8px}\n  .center {display:flex;align-items:center;justify-content:center}\n  .edge-weight-input{width:70px}\n  .range {width:140px}\n</style>\n</head>\n<body>\n<div class=\"app\">\n  <div class=\"panel\" id=\"panel\">\n    <div style=\"display:flex;justify-content:space-between;align-items:center\">\n      <div>\n        <h1>Dijkstra's Algorithm — Visualizer</h1>\n        <div class=\"muted\" style=\"margin-top:4px\">Build a graph, pick a source node, and step through Dijkstra's algorithm.</div>\n      </div>\n      <div class=\"right-top\">\n        <button id=\"randomBtn\" title=\"Generate random graph\" class=\"small\">Random</button>\n        <button id=\"clearBtn\" title=\"Clear graph\" class=\"small\">Clear</button>\n      </div>\n    </div>\n\n    <div class=\"controls\">\n      <button class=\"mode-btn active\" id=\"modeAddNode\">Add Node</button>\n      <button class=\"mode-btn\" id=\"modeAddEdge\">Add Edge</button>\n      <button class=\"mode-btn\" id=\"modeSetSource\">Set Source</button>\n      <button class=\"mode-btn\" id=\"modeMove\">Move Node</button>\n      <button class=\"mode-btn\" id=\"modeDelete\">Delete</button>\n    </div>\n\n    <div class=\"control-row\">\n      <div style=\"display:flex;gap:6px;align-items:center\">\n        <button id=\"stepBtn\">Step</button>\n        <button id=\"runBtn\">Run</button>\n        <button id=\"resetBtn\">Reset</button>\n      </div>\n      <div style=\"margin-left:auto;display:flex;gap:6px;align-items:center\">\n        <label class=\"small-muted\">Delay</label>\n        <input id=\"delay\" type=\"range\" min=\"100\" max=\"1500\" value=\"500\" class=\"range\">\n        <span id=\"delayVal\" class=\"small-muted\">500ms</span>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"hint\">Modes: click the canvas or nodes. For edges: click first node, then second; you'll be prompted for weight.</div>\n    </div>\n\n    <div class=\"row\">\n      <div style=\"flex:1\">\n        <div class=\"legend\">\n          <div class=\"item\"><div class=\"dot source\"></div><div class=\"muted\">Source</div></div>\n          <div class=\"item\"><div class=\"dot current\"></div><div class=\"muted\">Current</div></div>\n          <div class=\"item\"><div class=\"dot visited\"></div><div class=\"muted\">Visited (final)</div></div>\n          <div class=\"item\"><div class=\"dot unvisited\"></div><div class=\"muted\">Unvisited</div></div>\n        </div>\n      </div>\n      <div style=\"margin-left:auto\" class=\"small-muted\">Non-negative weights only</div>\n    </div>\n\n    <div style=\"display:flex;gap:8px\">\n      <div style=\"flex:1\">\n        <div class=\"note\">\n          Controls show algorithm state: dist = current shortest known distance; prev = previous node along the path. Use Step to advance one atomic operation (node selection or relaxation).\n        </div>\n      </div>\n    </div>\n\n    <div class=\"table\" id=\"tableWrap\">\n      <table id=\"stateTable\">\n        <thead><tr><th>Node</th><th>Dist</th><th>Prev</th><th>Status</th></tr></thead>\n        <tbody></tbody>\n      </table>\n    </div>\n\n    <div class=\"footer\">\n      Tip: Create some nodes, add edges with weights, choose a source, then Step through Dijkstra to see how distances update. Edges highlight during relaxation.\n    </div>\n  </div>\n\n  <div class=\"canvas-wrap\" id=\"canvasWrap\" style=\"height:100%;border-radius:10px;\">\n    <svg id=\"svgCanvas\" viewBox=\"0 0 1200 800\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n  </div>\n</div>\n\n<script>\n/*\n  Dijkstra Visualizer\n  - Single-file demonstration\n  - Interactive graph creation:\n    - Add Node: click canvas to add nodes\n    - Add Edge: click two nodes sequentially to create an undirected edge (prompts for weight)\n    - Set Source: click node to set as source for algorithm\n    - Move Node: drag nodes around\n    - Delete: click node or edge to delete\n  - Controls: Step, Run, Reset, Random, Clear\n  - Table shows dist, prev, status\n  - Step-by-step generator yields on node selection and each relaxation\n*/\n\nconst svg = document.getElementById('svgCanvas');\nconst MODE = { ADD_NODE:'add_node', ADD_EDGE:'add_edge', SET_SOURCE:'set_source', MOVE:'move', DELETE:'delete' };\nlet mode = MODE.ADD_NODE;\n\nconst panel = document.getElementById('panel');\nconst tableBody = document.querySelector('#stateTable tbody');\nconst delayInput = document.getElementById('delay');\nconst delayVal = document.getElementById('delayVal');\n\ndelayInput.addEventListener('input', ()=> delayVal.textContent = delayInput.value + 'ms');\n\nconst state = {\n  nodes: [], // {id,x,y,svgGroup}\n  edges: [], // {id,a,b,weight,svg}\n  nextNodeId: 1,\n  source: null\n};\n\nlet svgNS = \"http://www.w3.org/2000/svg\";\n\nfunction clearSVG() {\n  while (svg.firstChild) svg.removeChild(svg.firstChild);\n}\n\nfunction createNodeSVG(x,y,id) {\n  const g = document.createElementNS(svgNS,'g');\n  g.setAttribute('class','node');\n  g.setAttribute('data-id', id);\n  g.setAttribute('transform', `translate(${x},${y})`);\n  // circle\n  const circle = document.createElementNS(svgNS,'circle');\n  circle.setAttribute('r', 22);\n  circle.setAttribute('cx',0);\n  circle.setAttribute('cy',0);\n  g.appendChild(circle);\n  // label (ID)\n  const label = document.createElementNS(svgNS,'text');\n  label.setAttribute('x',0);\n  label.setAttribute('y',6);\n  label.setAttribute('text-anchor','middle');\n  label.setAttribute('class','label');\n  label.textContent = id;\n  g.appendChild(label);\n  // sub (dist preview)\n  const sub = document.createElementNS(svgNS,'text');\n  sub.setAttribute('x',0);\n  sub.setAttribute('y',34);\n  sub.setAttribute('text-anchor','middle');\n  sub.setAttribute('class','sub');\n  sub.textContent = '';\n  g.appendChild(sub);\n\n  svg.appendChild(g);\n  return g;\n}\n\nfunction createEdgeSVG(aNode, bNode, weight, id) {\n  const g = document.createElementNS(svgNS,'g');\n  g.setAttribute('class','edge-group');\n  g.setAttribute('data-id', id);\n\n  const line = document.createElementNS(svgNS,'line');\n  line.setAttribute('class','edge');\n  line.setAttribute('x1', aNode.x);\n  line.setAttribute('y1', aNode.y);\n  line.setAttribute('x2', bNode.x);\n  line.setAttribute('y2', bNode.y);\n  g.appendChild(line);\n\n  // weight label\n  const tx = (aNode.x + bNode.x)/2;\n  const ty = (aNode.y + bNode.y)/2;\n  const label = document.createElementNS(svgNS,'text');\n  label.setAttribute('x', tx);\n  label.setAttribute('y', ty - 8);\n  label.setAttribute('text-anchor','middle');\n  label.setAttribute('class','edge-label');\n  label.textContent = weight;\n  g.appendChild(label);\n\n  svg.appendChild(g);\n  return {group:g, line, label};\n}\n\nfunction updateEdgeSVGPosition(edge) {\n  const a = getNodeById(edge.a);\n  const b = getNodeById(edge.b);\n  const line = edge.svg.line;\n  line.setAttribute('x1', a.x);\n  line.setAttribute('y1', a.y);\n  line.setAttribute('x2', b.x);\n  line.setAttribute('y2', b.y);\n  const tx = (a.x + b.x)/2;\n  const ty = (a.y + b.y)/2;\n  edge.svg.label.setAttribute('x', tx);\n  edge.svg.label.setAttribute('y', ty - 8);\n}\n\nfunction addNode(x,y) {\n  const id = state.nextNodeId++;\n  const svgGroup = createNodeSVG(x,y,id);\n  const node = {id:id, x:x, y:y, svg:svgGroup};\n  state.nodes.push(node);\n  attachNodeListeners(node);\n  refreshTable();\n  return node;\n}\n\nfunction removeNode(nodeId) {\n  // remove associated edges\n  const edgesToRemove = state.edges.filter(e => e.a===nodeId || e.b===nodeId);\n  edgesToRemove.forEach(e => removeEdge(e.id));\n  // remove node svg and from state\n  const node = getNodeById(nodeId);\n  if (!node) return;\n  svg.removeChild(node.svg);\n  state.nodes = state.nodes.filter(n => n.id !== nodeId);\n  if (state.source === nodeId) state.source = null;\n  refreshTable();\n}\n\nfunction addEdge(a,b,weight) {\n  // ensure not duplicate (undirected)\n  const exists = state.edges.some(e => (e.a===a && e.b===b) || (e.a===b && e.b===a));\n  if (exists) return null;\n  const id = 'e' + (state.edges.length+1) + '_' + Date.now();\n  const an = getNodeById(a);\n  const bn = getNodeById(b);\n  const svgEdge = createEdgeSVG(an, bn, weight, id);\n  const edge = {id:id, a:a, b:b, weight: weight, svg: svgEdge};\n  state.edges.push(edge);\n  attachEdgeListeners(edge);\n  refreshTable();\n  return edge;\n}\n\nfunction removeEdge(edgeId) {\n  const edge = state.edges.find(e => e.id === edgeId);\n  if (!edge) return;\n  svg.removeChild(edge.svg.group);\n  state.edges = state.edges.filter(e => e.id !== edgeId);\n  refreshTable();\n}\n\nfunction getNodeById(id) {\n  return state.nodes.find(n => n.id === id);\n}\n\nfunction attachNodeListeners(node) {\n  const g = node.svg;\n  g.addEventListener('mousedown', nodeMouseDown);\n  g.addEventListener('click', nodeClick);\n}\n\nfunction attachEdgeListeners(edge) {\n  edge.svg.group.addEventListener('click', (ev)=>{\n    ev.stopPropagation();\n    if (mode === MODE.DELETE) {\n      if (confirm('Delete this edge?')) removeEdge(edge.id);\n    }\n  });\n}\n\nlet pendingEdgeStart = null; // node id\n\nfunction nodeClick(ev) {\n  ev.stopPropagation();\n  const g = ev.currentTarget;\n  const id = parseInt(g.getAttribute('data-id'));\n  if (mode === MODE.ADD_EDGE) {\n    if (!pendingEdgeStart) {\n      pendingEdgeStart = id;\n      highlightNode(id, true); // temporary highlight\n    } else {\n      const a = pendingEdgeStart;\n      const b = id;\n      if (a === b) {\n        alert('Cannot create self-loop for this demo.');\n        clearPendingEdge();\n        return;\n      }\n      let w = prompt('Edge weight (non-negative number):', '1');\n      if (w === null) { clearPendingEdge(); return; }\n      w = Number(w);\n      if (isNaN(w) || w < 0) { alert('Weight must be a non-negative number.'); clearPendingEdge(); return; }\n      addEdge(a,b,w);\n      clearPendingEdge();\n    }\n  } else if (mode === MODE.SET_SOURCE) {\n    state.source = id;\n    markAllNodes(); refreshTable();\n    updateNodeClasses();\n  } else if (mode === MODE.DELETE) {\n    if (confirm('Delete node ' + id + ' ? This removes connected edges too.')) {\n      removeNode(id);\n    }\n  } else if (mode === MODE.MOVE) {\n    // handled by drag start\n  } else if (mode === MODE.ADD_NODE) {\n    // maybe treat click on node as no-op\n  }\n}\n\nfunction clearPendingEdge() {\n  if (pendingEdgeStart) {\n    highlightNode(pendingEdgeStart, false);\n    pendingEdgeStart = null;\n  }\n}\n\nfunction highlightNode(id, on) {\n  const n = getNodeById(id);\n  if (!n) return;\n  if (on) n.svg.classList.add('current');\n  else n.svg.classList.remove('current');\n}\n\nfunction updateNodeClasses(stateMap) {\n  // stateMap: {dist, prev, visited, current, source}\n  state.nodes.forEach(n=>{\n    n.svg.classList.remove('visited','source','current');\n    if (state.source === n.id) n.svg.classList.add('source');\n  });\n}\n\nfunction markAllNodes() {\n  // used to update labels, etc.\n  state.nodes.forEach(n=>{\n    const sub = n.svg.querySelector('.sub');\n    sub.textContent = '';\n  });\n}\n\nfunction refreshEdgePositions() {\n  state.edges.forEach(e => updateEdgeSVGPosition(e));\n}\n\nfunction refreshTable(dijkstraState) {\n  // dijkstraState optional: {dist, prev, visited, current}\n  tableBody.innerHTML = '';\n  state.nodes.forEach(n=>{\n    const tr = document.createElement('tr');\n    const tdNode = document.createElement('td');\n    tdNode.textContent = n.id + (state.source===n.id ? ' (S)' : '');\n    const tdDist = document.createElement('td');\n    const tdPrev = document.createElement('td');\n    const tdStatus = document.createElement('td');\n\n    if (dijkstraState) {\n      const d = dijkstraState.dist[n.id];\n      tdDist.textContent = (d === Infinity ? '∞' : d);\n      tdPrev.textContent = (dijkstraState.prev[n.id] === null ? '-' : dijkstraState.prev[n.id]);\n      if (dijkstraState.visited.has(n.id)) {\n        tdStatus.innerHTML = '<span class=\"badge visited\">visited</span>';\n      } else if (dijkstraState.current === n.id) {\n        tdStatus.innerHTML = '<span class=\"badge\" style=\"background:linear-gradient(90deg,var(--warn),#fbc08a);color:#2a1204\">current</span>';\n      } else {\n        tdStatus.innerHTML = '<span class=\"badge unvisited\">unvisited</span>';\n      }\n      // also update node subtext with dist preview\n      const sub = n.svg.querySelector('.sub');\n      sub.textContent = (d === Infinity ? '' : d);\n      // class updates on svg\n      n.svg.classList.remove('visited','current','source');\n      if (state.source === n.id) n.svg.classList.add('source');\n      if (dijkstraState.visited.has(n.id)) n.svg.classList.add('visited');\n      if (dijkstraState.current === n.id) n.svg.classList.add('current');\n    } else {\n      tdDist.textContent = '-';\n      tdPrev.textContent = '-';\n      tdStatus.innerHTML = '<span class=\"badge unvisited\">unvisited</span>';\n      const sub = n.svg.querySelector('.sub');\n      sub.textContent = '';\n      n.svg.classList.remove('visited','current','source');\n      if (state.source === n.id) n.svg.classList.add('source');\n    }\n\n    tr.appendChild(tdNode);\n    tr.appendChild(tdDist);\n    tr.appendChild(tdPrev);\n    tr.appendChild(tdStatus);\n    tableBody.appendChild(tr);\n  });\n}\n\n/* Mode buttons */\nconst modeButtons = {\n  addNode: document.getElementById('modeAddNode'),\n  addEdge: document.getElementById('modeAddEdge'),\n  setSource: document.getElementById('modeSetSource'),\n  move: document.getElementById('modeMove'),\n  del: document.getElementById('modeDelete')\n};\n\nfunction setMode(m) {\n  mode = m;\n  Object.values(modeButtons).forEach(btn => btn.classList.remove('active'));\n  if (m === MODE.ADD_NODE) modeButtons.addNode.classList.add('active');\n  if (m === MODE.ADD_EDGE) modeButtons.addEdge.classList.add('active');\n  if (m === MODE.SET_SOURCE) modeButtons.setSource.classList.add('active');\n  if (m === MODE.MOVE) modeButtons.move.classList.add('active');\n  if (m === MODE.DELETE) modeButtons.del.classList.add('active');\n  clearPendingEdge();\n}\n\nmodeButtons.addNode.addEventListener('click', ()=> setMode(MODE.ADD_NODE));\nmodeButtons.addEdge.addEventListener('click', ()=> setMode(MODE.ADD_EDGE));\nmodeButtons.setSource.addEventListener('click', ()=> setMode(MODE.SET_SOURCE));\nmodeButtons.move.addEventListener('click', ()=> setMode(MODE.MOVE));\nmodeButtons.del.addEventListener('click', ()=> setMode(MODE.DELETE));\n\n/* Canvas clicks: add node */\nsvg.addEventListener('click', (ev)=>{\n  if (mode !== MODE.ADD_NODE) { clearPendingEdge(); return; }\n  const pt = svg.createSVGPoint();\n  pt.x = ev.clientX;\n  pt.y = ev.clientY;\n  const ctm = svg.getScreenCTM();\n  const loc = pt.matrixTransform(ctm.inverse());\n  addNode(loc.x, loc.y);\n});\n\n/* Dragging nodes */\nlet dragNode = null;\nlet dragOffset = {x:0,y:0};\nfunction nodeMouseDown(ev) {\n  if (mode !== MODE.MOVE) return;\n  ev.stopPropagation();\n  const g = ev.currentTarget;\n  const id = parseInt(g.getAttribute('data-id'));\n  const node = getNodeById(id);\n  dragNode = node;\n  const pt = svg.createSVGPoint();\n  pt.x = ev.clientX; pt.y = ev.clientY;\n  const loc = pt.matrixTransform(svg.getScreenCTM().inverse());\n  dragOffset.x = loc.x - node.x;\n  dragOffset.y = loc.y - node.y;\n  window.addEventListener('mousemove', nodeMouseMove);\n  window.addEventListener('mouseup', nodeMouseUp);\n}\nfunction nodeMouseMove(ev) {\n  if (!dragNode) return;\n  const pt = svg.createSVGPoint();\n  pt.x = ev.clientX; pt.y = ev.clientY;\n  const loc = pt.matrixTransform(svg.getScreenCTM().inverse());\n  dragNode.x = loc.x - dragOffset.x;\n  dragNode.y = loc.y - dragOffset.y;\n  dragNode.svg.setAttribute('transform', `translate(${dragNode.x},${dragNode.y})`);\n  refreshEdgePositions();\n}\nfunction nodeMouseUp(ev) {\n  dragNode = null;\n  window.removeEventListener('mousemove', nodeMouseMove);\n  window.removeEventListener('mouseup', nodeMouseUp);\n}\n\n/* Edge/Node delete handled via click listeners */\n\n/* Random graph generator */\ndocument.getElementById('randomBtn').addEventListener('click', ()=>{\n  clearGraph();\n  const n = Math.floor(Math.random()*5)+5; // 5-9 nodes\n  const w = svg.viewBox.baseVal.width || 1200;\n  const h = svg.viewBox.baseVal.height || 800;\n  // place nodes\n  for (let i=0;i<n;i++) {\n    addNode(120 + Math.random()*(w-240), 80 + Math.random()*(h-160));\n  }\n  // add edges\n  const nodes = state.nodes.map(x=>x.id);\n  // ensure connected: build a random spanning tree\n  const perm = nodes.slice().sort(()=>Math.random()-0.5);\n  for (let i=1;i<perm.length;i++){\n    const a = perm[i];\n    const b = perm[Math.floor(Math.random()*i)];\n    const weight = Math.floor(Math.random()*9)+1;\n    addEdge(a,b,weight);\n  }\n  // add some extra edges\n  const extra = Math.floor(Math.random()*n);\n  for (let i=0;i<extra;i++){\n    const a = nodes[Math.floor(Math.random()*nodes.length)];\n    const b = nodes[Math.floor(Math.random()*nodes.length)];\n    if (a===b) continue;\n    if (state.edges.some(e=> (e.a===a && e.b===b) || (e.a===b && e.b===a))) continue;\n    addEdge(a,b,Math.floor(Math.random()*9)+1);\n  }\n  refreshTable();\n});\n\n/* Clear/Clear all */\ndocument.getElementById('clearBtn').addEventListener('click', ()=>{\n  if (!confirm('Clear the entire graph?')) return;\n  clearGraph();\n});\n\nfunction clearGraph() {\n  clearSVG();\n  state.nodes = [];\n  state.edges = [];\n  state.nextNodeId = 1;\n  state.source = null;\n  pendingEdgeStart = null;\n  refreshTable();\n}\n\n/* Dijkstra Implementation as generator to step */\nfunction buildAdjacency() {\n  const adj = {};\n  state.nodes.forEach(n => adj[n.id] = []);\n  state.edges.forEach(e=>{\n    adj[e.a].push({to:e.b, weight:e.weight, edgeId:e.id});\n    adj[e.b].push({to:e.a, weight:e.weight, edgeId:e.id});\n  });\n  return adj;\n}\n\nfunction* dijkstraGenerator() {\n  if (state.source == null) {\n    alert('Please set a source node (Set Source mode and click a node).');\n    return;\n  }\n  // initialize\n  const nodes = state.nodes.map(n => n.id);\n  const adj = buildAdjacency();\n  const dist = {};\n  const prev = {};\n  const visited = new Set();\n  nodes.forEach(id => { dist[id] = Infinity; prev[id] = null; });\n  dist[state.source] = 0;\n\n  // initial yield to show starting state\n  yield {phase: 'init', dist: structuredClone(dist), prev: structuredClone(prev), visited: new Set(), current: state.source};\n\n  while (visited.size < nodes.length) {\n    // select u = unvisited node with smallest dist\n    let u = null;\n    let min = Infinity;\n    for (const id of nodes) {\n      if (visited.has(id)) continue;\n      if (dist[id] < min) { min = dist[id]; u = id; }\n    }\n    if (u === null || min === Infinity) {\n      // remaining nodes unreachable\n      break;\n    }\n\n    // Node selection yield\n    yield {phase:'select', current:u, dist: structuredClone(dist), prev: structuredClone(prev), visited: new Set([...visited])};\n\n    // mark visited\n    visited.add(u);\n\n    // For visualization: highlight visited node (final)\n    yield {phase:'visit', current:u, dist: structuredClone(dist), prev: structuredClone(prev), visited: new Set([...visited])};\n\n    // relax edges from u one by one\n    const neighbors = adj[u] || [];\n    for (const nb of neighbors) {\n      const v = nb.to;\n      const w = nb.weight;\n      // yield before relaxation to show which edge is considered\n      yield {phase:'consider', current:u, neighbor:v, edgeId: nb.edgeId, dist: structuredClone(dist), prev: structuredClone(prev), visited: new Set([...visited]), weight: w};\n      if (!visited.has(v) && dist[u] + w < dist[v]) {\n        dist[v] = dist[u] + w;\n        prev[v] = u;\n        // yield to show successful relaxation\n        yield {phase:'relax', updated:true, current:u, neighbor:v, edgeId: nb.edgeId, dist: structuredClone(dist), prev: structuredClone(prev), visited: new Set([...visited])};\n      } else {\n        // yield to show no relaxation\n        yield {phase:'relax', updated:false, current:u, neighbor:v, edgeId: nb.edgeId, dist: structuredClone(dist), prev: structuredClone(prev), visited: new Set([...visited])};\n      }\n    }\n  }\n\n  // final state\n  yield {phase:'done', dist: structuredClone(dist), prev: structuredClone(prev), visited: new Set([...visited]), current: null};\n}\n\n/* Control buttons */\nconst stepBtn = document.getElementById('stepBtn');\nconst runBtn = document.getElementById('runBtn');\nconst resetBtn = document.getElementById('resetBtn');\n\nlet dijkstraIter = null;\nlet autoRunTimer = null;\nlet lastState = null;\n\nstepBtn.addEventListener('click', ()=> {\n  if (!dijkstraIter) {\n    dijkstraIter = dijkstraGenerator();\n  }\n  advanceStep();\n});\n\nrunBtn.addEventListener('click', ()=>{\n  if (!dijkstraIter) dijkstraIter = dijkstraGenerator();\n  if (!dijkstraIter) return;\n  if (autoRunTimer) {\n    clearInterval(autoRunTimer);\n    autoRunTimer = null;\n    runBtn.textContent = 'Run';\n  } else {\n    runBtn.textContent = 'Pause';\n    autoRunTimer = setInterval(()=>{\n      const done = advanceStep();\n      if (done) {\n        clearInterval(autoRunTimer);\n        autoRunTimer = null;\n        runBtn.textContent = 'Run';\n      }\n    }, Number(delayInput.value));\n  }\n});\n\nresetBtn.addEventListener('click', ()=>{\n  dijkstraIter = null;\n  if (autoRunTimer) { clearInterval(autoRunTimer); autoRunTimer = null; runBtn.textContent='Run'; }\n  // clear highlights and table\n  state.nodes.forEach(n => { n.svg.classList.remove('visited','current'); const sub = n.svg.querySelector('.sub'); sub.textContent=''; });\n  state.edges.forEach(e => e.svg.line.classList.remove('relax','good'));\n  refreshTable();\n});\n\nfunction advanceStep() {\n  const res = dijkstraIter.next();\n  if (res.done) {\n    dijkstraIter = null;\n    return true;\n  }\n  const s = res.value;\n  handleDijkstraState(s);\n  lastState = s;\n  if (s.phase === 'done') {\n    dijkstraIter = null;\n    return true;\n  }\n  return false;\n}\n\nfunction handleDijkstraState(s) {\n  // reset edge highlights unless in consider/relax\n  state.edges.forEach(e => {\n    e.svg.line.classList.remove('relax','good');\n  });\n\n  if (s.phase === 'init') {\n    refreshTable(s);\n    // source highlight\n    updateNodeClasses();\n  } else if (s.phase === 'select') {\n    // show current selection (not yet visited)\n    refreshTable(s);\n  } else if (s.phase === 'visit') {\n    // mark visited visually\n    refreshTable(s);\n  } else if (s.phase === 'consider') {\n    // highlight edge being considered and current nodes\n    const edge = state.edges.find(e => e.id === s.edgeId);\n    if (edge) edge.svg.line.classList.add('relax');\n    refreshTable(s);\n  } else if (s.phase === 'relax') {\n    const edge = state.edges.find(e => e.id === s.edgeId);\n    if (edge) {\n      if (s.updated) {\n        edge.svg.line.classList.remove('relax');\n        edge.svg.line.classList.add('good');\n      } else {\n        // leave as relax for a short moment\n        edge.svg.line.classList.add('relax');\n      }\n    }\n    refreshTable(s);\n  } else if (s.phase === 'done') {\n    // show final distances, highlight final tree edges\n    refreshTable(s);\n    // highlight edges that are part of shortest path tree (prev pointers)\n    const prev = s.prev;\n    state.edges.forEach(e => e.svg.line.classList.remove('relax','good'));\n    Object.keys(prev).forEach(v => {\n      const p = prev[v];\n      if (p === null) return;\n      // find edge between p and v\n      const e = state.edges.find(ed => (ed.a===Number(v) && ed.b===p) || (ed.b===Number(v) && ed.a===p));\n      if (e) e.svg.line.classList.add('good');\n    });\n  }\n}\n\n/* Utility to auto-update edge positions on window resize */\nwindow.addEventListener('resize', ()=> {\n  refreshEdgePositions();\n});\n\n/* Initialize with a small sample graph */\n(function initDemo(){\n  clearGraph();\n  // place some nodes manually\n  const w = svg.viewBox.baseVal.width || 1200;\n  const h = svg.viewBox.baseVal.height || 800;\n  addNode(200,200); //1\n  addNode(460,140); //2\n  addNode(700,210); //3\n  addNode(340,380); //4\n  addNode(820,400); //5\n  addEdge(1,2,4);\n  addEdge(1,4,2);\n  addEdge(2,3,6);\n  addEdge(2,4,5);\n  addEdge(3,5,1);\n  addEdge(4,5,7);\n  state.source = 1;\n  refreshTable();\n})();\n\n/* Extra: clicking empty canvas clears pending edge */\nsvg.addEventListener('mousedown',(ev)=> {\n  if (mode === MODE.ADD_EDGE) {\n    // clicking empty space cancels pending\n    // determine if click hit a node: if target is svg then cancel\n    if (ev.target === svg) {\n      clearPendingEdge();\n    }\n  } else {\n    clearPendingEdge();\n  }\n});\n\n// Prevent text selection on double click drag\ndocument.addEventListener('mousedown', (e)=> { if (e.detail > 1) e.preventDefault(); });\n\n// small helper: deep clone for objects (structuredClone fallback)\nfunction structuredClone(obj) {\n  // modern browsers support structuredClone; fallback to JSON\n  try { return window.structuredClone(obj); } catch (e) { return JSON.parse(JSON.stringify(obj)); }\n}\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}