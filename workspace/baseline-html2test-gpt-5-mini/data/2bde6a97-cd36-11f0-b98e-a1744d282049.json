{
  "id": "2bde6a97-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:57.624Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Recursion",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Recursion Explorer — Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724; --card:#0b1220; --accent:#60a5fa; --muted:#94a3b8; --panel:#071226;\n      --good:#34d399; --bad:#fb7185;\n    }\n    body{\n      margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;\n      background:linear-gradient(180deg,#071029 0%,#071127 50%, #071122 100%);\n      color:#e6eef8; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;\n    }\n    header{\n      padding:18px 20px; display:flex; gap:16px; align-items:center; background:linear-gradient(90deg,#07102988,#07112522);\n      border-bottom:1px solid rgba(255,255,255,0.03);\n    }\n    h1{ font-size:18px; margin:0; letter-spacing:0.2px; color:var(--accent) }\n    .subtitle{ color:var(--muted); font-size:13px; margin-left:8px }\n    main{ display:grid; grid-template-columns:380px 1fr 420px; gap:18px; padding:18px; height:calc(100vh - 72px); box-sizing:border-box; }\n    .card{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px; padding:14px; box-shadow: 0 6px 24px rgba(2,6,23,0.5); border:1px solid rgba(255,255,255,0.02);\n      height:100%; overflow:auto;\n    }\n    label{ display:block; font-size:13px; color:var(--muted); margin-bottom:6px }\n    input[type=number], select, button{\n      background:transparent; border:1px solid rgba(255,255,255,0.06); color:inherit; padding:8px 10px; border-radius:8px;\n      outline:none; font-size:14px;\n    }\n    .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }\n    .controls > *{ flex-shrink:0 }\n    button.primary{ background:linear-gradient(90deg,var(--accent),#7dd3fc); color:#04202f; border:none; font-weight:600; cursor:pointer }\n    button.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted); cursor:pointer }\n    .muted{ color:var(--muted); font-size:13px }\n    .stack{\n      margin-top:12px; display:flex; flex-direction:column; gap:8px; min-height:280px;\n    }\n    .frame{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:8px; padding:8px 10px; border:1px solid rgba(255,255,255,0.03); display:flex; justify-content:space-between; align-items:center;\n      font-family:Menlo,monospace; font-size:13px;\n    }\n    .frame.return{ border-left:4px solid var(--good) }\n    .frame.call{ border-left:4px solid var(--accent) }\n    .frame .info{ display:flex; gap:8px; align-items:center }\n    .small{ font-size:12px; color:var(--muted) }\n    .panel-title{ font-weight:700; margin-bottom:8px }\n    /* Canvas area */\n    #canvasWrap{ display:flex; flex-direction:column; height:100%; }\n    canvas{ background:linear-gradient(180deg,#051122,#021018); border-radius:10px; width:100%; height:100%; display:block }\n    .row{ display:flex; gap:8px; align-items:center; margin-top:10px; flex-wrap:wrap }\n    .stats{ font-size:13px; color:var(--muted) }\n    footer{ padding:12px 18px; color:var(--muted); text-align:center; font-size:13px }\n    a{ color:var(--accent) }\n    .danger{ color:var(--bad) }\n    .good{ color:var(--good) }\n    .explain{ font-size:13px; color:var(--muted); line-height:1.45; margin-top:8px }\n    .slider{ appearance:none; width:160px; height:8px; background:linear-gradient(90deg,#164e8a,#173956); border-radius:999px; }\n    .cta-row{ display:flex; gap:8px; margin-top:10px; align-items:center }\n  </style>\n</head>\n<body>\n  <header>\n    <div>\n      <h1>Recursion Explorer</h1>\n      <div class=\"subtitle\">Visualize and step through recursive calls</div>\n    </div>\n  </header>\n\n  <main>\n    <!-- Left: Controls & Examples -->\n    <section class=\"card\" style=\"min-width:300px;\">\n      <div class=\"panel-title\">Choose Example</div>\n      <div style=\"display:flex; gap:8px; margin-bottom:12px;\">\n        <select id=\"exampleSelect\" style=\"flex:1\">\n          <option value=\"factorial\">Factorial (n!) — classic recursion</option>\n          <option value=\"fibonacci\">Fibonacci (naive) — exponential calls</option>\n          <option value=\"fibonacciMemo\">Fibonacci (memoized) — optimized recursion</option>\n          <option value=\"tree\">Simulated Tree Traversal (preorder)</option>\n          <option value=\"fractal\">Fractal Tree (visual)</option>\n        </select>\n      </div>\n\n      <div id=\"controlsArea\">\n        <label>Input / Depth</label>\n        <div class=\"controls\">\n          <input id=\"inputN\" type=\"number\" value=\"5\" min=\"0\" max=\"20\" />\n          <button id=\"runBtn\" class=\"primary\">Run</button>\n          <button id=\"traceBtn\" class=\"ghost\">Generate Trace</button>\n        </div>\n\n        <div class=\"cta-row\">\n          <button id=\"stepPrev\" class=\"ghost\">◀ Step</button>\n          <button id=\"stepNext\" class=\"ghost\">Step ▶</button>\n          <button id=\"playPause\" class=\"ghost\">Play ▶</button>\n          <div class=\"muted\" id=\"stepInfo\">Step 0 / 0</div>\n        </div>\n\n        <div style=\"margin-top:12px;\">\n          <div class=\"muted\">Short explanation</div>\n          <div class=\"explain\" id=\"explainText\">\n            Recursion is when a function calls itself. Each call gets its own \"frame\" (local variables and state). Visualizing the call stack helps understand execution order and returns.\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px;\">\n          <div class=\"muted\">Notes</div>\n          <ul class=\"small\" style=\"margin:8px 0 0 16px; color:var(--muted)\">\n            <li>Naive Fibonacci grows fast; limits are enforced to avoid freezing.</li>\n            <li>Use memoization to drastically reduce calls.</li>\n            <li>Fractal drawing uses canvas and recursion to draw branches.</li>\n          </ul>\n        </div>\n      </div>\n    </section>\n\n    <!-- Middle: Stack Visualization -->\n    <section class=\"card\" id=\"stackCard\">\n      <div class=\"panel-title\">Call Stack Visualization</div>\n      <div class=\"muted\">Frames are pushed on call and popped on return. A return frame shows the resolved value.</div>\n\n      <div class=\"stack\" id=\"stackArea\" style=\"margin-top:12px;\">\n        <!-- frames appear here -->\n      </div>\n\n      <div style=\"margin-top:12px; display:flex; gap:8px; align-items:center; justify-content:space-between;\">\n        <div class=\"stats\" id=\"statsArea\">Calls: 0 &nbsp; • &nbsp; Max depth: 0</div>\n        <div style=\"display:flex; gap:8px;\">\n          <button id=\"resetBtn\" class=\"ghost\">Reset</button>\n          <button id=\"explainBtn\" class=\"ghost\">Show explanation</button>\n        </div>\n      </div>\n\n      <div style=\"margin-top:12px;\">\n        <div class=\"muted\">Trace (events)</div>\n        <pre id=\"traceOutput\" style=\"background:transparent; border-radius:8px; padding:8px; height:120px; overflow:auto; color:var(--muted); font-size:13px\"></pre>\n      </div>\n    </section>\n\n    <!-- Right: Canvas / Fractal / Info -->\n    <section class=\"card\" id=\"canvasCard\">\n      <div class=\"panel-title\" id=\"canvasTitle\">Visualization</div>\n\n      <div id=\"canvasWrap\">\n        <canvas id=\"canvas\" width=\"800\" height=\"600\"></canvas>\n\n        <div class=\"row\" style=\"justify-content:space-between;\">\n          <div>\n            <label class=\"small\">Depth / Size</label>\n            <input id=\"depthSlider\" type=\"range\" class=\"slider\" min=\"0\" max=\"12\" value=\"5\" />\n            <span class=\"muted\" id=\"depthLabel\">5</span>\n          </div>\n\n          <div style=\"text-align:right\">\n            <div class=\"small muted\">Performance</div>\n            <div id=\"perf\" class=\"muted\">—</div>\n          </div>\n        </div>\n\n        <div style=\"margin-top:8px; display:flex; gap:8px;\">\n          <button id=\"drawBtn\" class=\"primary\">Redraw</button>\n          <button id=\"clearBtn\" class=\"ghost\">Clear</button>\n        </div>\n      </div>\n    </section>\n  </main>\n\n  <footer>\n    Built to demonstrate recursion: call stacks, exponential vs memoized recursion, and a visual fractal tree. Source is client-side in this page.\n  </footer>\n\n  <script>\n    // Recursion Explorer JS\n    (function(){\n      // Utilities\n      function el(id){ return document.getElementById(id); }\n      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }\n      const maxNaiveFib = 11; // safe limit for naive fib (exponential)\n      const maxFactorial = 12; // avoid huge numbers and deep stacks\n      const canvas = el('canvas');\n      const ctx = canvas.getContext('2d');\n      let trace = []; // sequence of events for stepping\n      let currentStep = 0;\n      let playTimer = null;\n\n      // UI elements\n      const exampleSelect = el('exampleSelect');\n      const inputN = el('inputN');\n      const runBtn = el('runBtn');\n      const traceBtn = el('traceBtn');\n      const stepPrev = el('stepPrev');\n      const stepNext = el('stepNext');\n      const playPause = el('playPause');\n      const resetBtn = el('resetBtn');\n      const traceOutput = el('traceOutput');\n      const stackArea = el('stackArea');\n      const statsArea = el('statsArea');\n      const explainBtn = el('explainBtn');\n      const explainText = el('explainText');\n      const depthSlider = el('depthSlider');\n      const depthLabel = el('depthLabel');\n      const drawBtn = el('drawBtn');\n      const clearBtn = el('clearBtn');\n      const canvasTitle = el('canvasTitle');\n      const perf = el('perf');\n\n      // Event helpers\n      function setExplain(text){\n        explainText.textContent = text;\n      }\n      function setStats(calls, maxDepth){\n        statsArea.textContent = `Calls: ${calls} • Max depth: ${maxDepth}`;\n      }\n\n      // Trace event model:\n      // events: {type:'call'|'return', id, fn, args, depth, value?}\n      let idCounter = 1;\n\n      function newId(){ return idCounter++; }\n\n      // Generate trace for factorial\n      function generateFactorialTrace(n){\n        trace = []; idCounter = 1;\n        let maxDepth = 0, callCount = 0;\n        function fact(k, depth){\n          callCount++;\n          maxDepth = Math.max(maxDepth, depth);\n          const id = newId();\n          trace.push({type:'call', id, fn:'fact', args:[k], depth});\n          if(k === 0 || k === 1){\n            trace.push({type:'return', id, fn:'fact', args:[k], depth, value:1});\n            return 1;\n          }\n          const r = fact(k-1, depth+1) * k;\n          trace.push({type:'return', id, fn:'fact', args:[k], depth, value:r});\n          return r;\n        }\n        const value = fact(n, 0);\n        return {trace, callCount, maxDepth, value};\n      }\n\n      // Generate naive fibonacci trace (exponential)\n      function generateFibonacciTrace(n, memoized=false){\n        trace = []; idCounter = 1;\n        let maxDepth = 0, callCount = 0;\n        const memo = {};\n        function fib(k, depth){\n          callCount++;\n          maxDepth = Math.max(maxDepth, depth);\n          const id = newId();\n          trace.push({type:'call', id, fn:'fib', args:[k], depth});\n          if(memoized && memo[k] !== undefined){\n            const v = memo[k];\n            trace.push({type:'return', id, fn:'fib', args:[k], depth, value:v, memoHit:true});\n            return v;\n          }\n          if(k < 2){\n            trace.push({type:'return', id, fn:'fib', args:[k], depth, value:k});\n            memo[k] = k;\n            return k;\n          }\n          const a = fib(k-1, depth+1);\n          const b = fib(k-2, depth+1);\n          const v = a + b;\n          memo[k] = v;\n          trace.push({type:'return', id, fn:'fib', args:[k], depth, value:v});\n          return v;\n        }\n        const value = fib(n, 0);\n        return {trace, callCount, maxDepth, value};\n      }\n\n      // Simulated tree traversal trace (preorder)\n      function generateTreeTrace(depth, children=3){\n        trace = []; idCounter = 1;\n        let callCount = 0, maxDepth = 0;\n        function visit(nodeId, d, depthLeft){\n          callCount++;\n          maxDepth = Math.max(maxDepth, d);\n          const id = newId();\n          trace.push({type:'call', id, fn:'visit', args:[nodeId], depth:d});\n          // simulate work\n          trace.push({type:'return', id, fn:'visit', args:[nodeId], depth:d, value:`visited ${nodeId}`});\n          if(depthLeft <= 0) return;\n          for(let i=0;i<children;i++){\n            visit(nodeId + '.' + i, d+1, depthLeft-1);\n          }\n        }\n        visit('root', 0, depth);\n        return {trace, callCount, maxDepth, value: 'done'};\n      }\n\n      // UI: prepare the trace for stepping and visualization\n      function prepareTraceForExample(example, n){\n        if(example === 'factorial'){\n          n = clamp(n, 0, maxFactorial);\n          setExplain('Factorial: fact(n) calls fact(n-1) until 0 or 1. Observe call stack depth and returns.');\n          return generateFactorialTrace(n);\n        }\n        if(example === 'fibonacci'){\n          n = clamp(n, 0, maxNaiveFib);\n          setExplain('Naive Fibonacci: fib(n) calls fib(n-1) and fib(n-2). Number of calls grows exponentially with n.');\n          return generateFibonacciTrace(n, false);\n        }\n        if(example === 'fibonacciMemo'){\n          n = clamp(n, 0, 40);\n          setExplain('Memoized Fibonacci: results cached to avoid repeating work — drastically fewer calls.');\n          return generateFibonacciTrace(n, true);\n        }\n        if(example === 'tree'){\n          const depth = clamp(n, 0, 6);\n          setExplain('Simulated tree traversal: visit a node and recursively visit children (preorder).');\n          return generateTreeTrace(depth, 3);\n        }\n        if(example === 'fractal'){\n          setExplain('Fractal Tree: draws branches recursively. Use the depth slider and redraw.');\n          return {trace:[], callCount:0, maxDepth:0, value:null};\n        }\n        return {trace:[], callCount:0, maxDepth:0, value:null};\n      }\n\n      // Rendering stack for a given step index\n      function renderStep(stepIndex){\n        stackArea.innerHTML = '';\n        if(!trace || trace.length === 0){\n          traceOutput.textContent = '(no trace)';\n          currentStep = 0;\n          el('stepInfo').textContent = 'Step 0 / 0';\n          setStats(0,0);\n          return;\n        }\n        // Build the stack by processing events up to stepIndex (inclusive)\n        const stack = [];\n        let calls = 0;\n        let maxDepth = 0;\n        for(let i=0;i<=stepIndex && i<trace.length;i++){\n          const ev = trace[i];\n          if(ev.type === 'call'){\n            stack.push({id:ev.id, fn:ev.fn, args:ev.args, depth:ev.depth, status:'call'});\n            calls++;\n            maxDepth = Math.max(maxDepth, stack.length);\n          } else if(ev.type === 'return'){\n            // find top matching call by id and mark it returned with value\n            // it's possible multiple return events happen for same id in our model; handle gracefully\n            let idx = -1;\n            for(let j=stack.length-1;j>=0;j--){\n              if(stack[j].id === ev.id && stack[j].status === 'call'){ idx = j; break; }\n            }\n            if(idx !== -1){\n              stack[idx].status = 'return';\n              stack[idx].value = ev.value;\n            } else {\n              // If not found, the return pertains to something popped earlier; ignore\n            }\n          }\n        }\n        // Render stack top at the top of the column (like real stack)\n        for(let i=stack.length-1;i>=0;i--){\n          const s = stack[i];\n          const d = document.createElement('div');\n          d.className = 'frame ' + (s.status === 'return' ? 'return' : 'call');\n          const info = document.createElement('div');\n          info.className = 'info';\n          const fnSpan = document.createElement('div');\n          fnSpan.textContent = s.fn + '(' + s.args.join(',') + ')';\n          const depthSpan = document.createElement('div');\n          depthSpan.className = 'small';\n          depthSpan.textContent = 'depth ' + s.depth;\n          info.appendChild(fnSpan);\n          info.appendChild(depthSpan);\n          const right = document.createElement('div');\n          right.style.textAlign = 'right';\n          if(s.status === 'return'){\n            const val = document.createElement('div');\n            val.style.fontFamily = 'Menlo,monospace';\n            val.textContent = '→ ' + s.value;\n            val.className = 'small';\n            right.appendChild(val);\n          } else {\n            const wait = document.createElement('div');\n            wait.className = 'small muted';\n            wait.textContent = 'running';\n            right.appendChild(wait);\n          }\n          d.appendChild(info);\n          d.appendChild(right);\n          stackArea.appendChild(d);\n        }\n\n        // Trace output: show events up to step\n        traceOutput.textContent = trace.slice(0, stepIndex+1).map((e,i)=> {\n          if(e.type==='call') return `${i}: CALL  id=${e.id} ${e.fn}(${e.args.join(',')}) depth=${e.depth}`;\n          else return `${i}: RETURN id=${e.id} ${e.fn}(${e.args.join(',')}) depth=${e.depth} => ${JSON.stringify(e.value)}` + (e.memoHit ? ' (memo)' : '');\n        }).join('\\n');\n\n        currentStep = stepIndex;\n        el('stepInfo').textContent = `Step ${currentStep+1} / ${trace.length}`;\n        setStats(trace.length/2 | 0, maxDepth); // rough calls; not exact for all traces\n      }\n\n      // Step controls\n      function stepNextFunc(){\n        if(!trace || trace.length===0) return;\n        const next = Math.min(trace.length-1, currentStep+1);\n        renderStep(next);\n      }\n      function stepPrevFunc(){\n        if(!trace || trace.length===0) return;\n        const prev = Math.max(0, currentStep-1);\n        renderStep(prev);\n      }\n      function playToggle(){\n        if(playTimer){\n          clearInterval(playTimer); playTimer = null; playPause.textContent = 'Play ▶';\n        } else {\n          playPause.textContent = 'Pause ⏸';\n          playTimer = setInterval(()=>{\n            if(!trace || currentStep >= trace.length-1){\n              clearInterval(playTimer); playTimer = null; playPause.textContent = 'Play ▶'; return;\n            }\n            stepNextFunc();\n          }, 250);\n        }\n      }\n\n      // Run the selected example and generate trace + show final result\n      function runExample(){\n        stopPlay();\n        const ex = exampleSelect.value;\n        const n = parseInt(inputN.value,10) || 0;\n\n        if(ex === 'fractal'){\n          // just draw fractal\n          canvasTitle.textContent = 'Fractal Tree';\n          drawFractal(parseInt(depthSlider.value,10));\n          trace = [];\n          renderStep(0);\n          return;\n        }\n\n        const result = prepareTraceForExample(ex, n);\n        trace = result.trace || [];\n        // show stats\n        maintainLimits(ex, n);\n        renderStep(0);\n      }\n\n      function stopPlay(){\n        if(playTimer){ clearInterval(playTimer); playTimer = null; playPause.textContent = 'Play ▶'; }\n      }\n\n      function maintainLimits(example, n){\n        if(example === 'fibonacci' && n > maxNaiveFib){\n          alert('Naive Fibonacci is limited to n ≤ ' + maxNaiveFib + ' to avoid freezing. Using ' + maxNaiveFib + '.');\n          inputN.value = maxNaiveFib;\n        }\n        if(example === 'factorial' && n > maxFactorial){\n          alert('Factorial depth limited to ' + maxFactorial + '. Using ' + maxFactorial + '.');\n          inputN.value = maxFactorial;\n        }\n      }\n\n      // Trace generation button (just regenerates and shows)\n      traceBtn.addEventListener('click', ()=>{\n        runExample();\n      });\n\n      runBtn.addEventListener('click', ()=>{\n        runExample();\n      });\n\n      stepNext.addEventListener('click', stepNextFunc);\n      stepPrev.addEventListener('click', stepPrevFunc);\n      playPause.addEventListener('click', playToggle);\n      resetBtn.addEventListener('click', ()=>{\n        stopPlay();\n        trace = []; currentStep = 0;\n        stackArea.innerHTML = '';\n        traceOutput.textContent = '';\n        el('stepInfo').textContent = 'Step 0 / 0';\n        setStats(0,0);\n      });\n\n      // Switch UI for example changes\n      exampleSelect.addEventListener('change', ()=>{\n        const ex = exampleSelect.value;\n        if(ex === 'fractal'){\n          inputN.disabled = true;\n          depthSlider.disabled = false;\n          canvasTitle.textContent = 'Fractal Tree';\n          setExplain('Fractal Tree drawing: recursive branching using angle & length multiplier.');\n        } else if(ex === 'tree'){\n          inputN.disabled = false;\n          inputN.value = 3;\n          depthSlider.disabled = true;\n          canvasTitle.textContent = 'Call Stack';\n        } else {\n          depthSlider.disabled = true;\n          inputN.disabled = false;\n          canvasTitle.textContent = 'Call Stack';\n        }\n      });\n\n      explainBtn.addEventListener('click', ()=>{\n        alert(explainText.textContent);\n      });\n\n      // Depth slider for fractal\n      depthSlider.addEventListener('input', ()=>{\n        depthLabel.textContent = depthSlider.value;\n      });\n\n      // Canvas drawing: fractal tree\n      function clearCanvas(){\n        ctx.clearRect(0,0,canvas.width,canvas.height);\n        ctx.fillStyle = 'rgba(5,12,20,0.0)';\n        ctx.fillRect(0,0,canvas.width,canvas.height);\n        perf.textContent = 'cleared';\n      }\n\n      function drawFractal(depth){\n        clearCanvas();\n        const t0 = performance.now();\n        ctx.save();\n        ctx.translate(canvas.width/2, canvas.height-20);\n        ctx.strokeStyle = '#8ed0ff';\n        ctx.lineWidth = 2;\n        // recursive draw function\n        function branch(len, angle, depthLeft){\n          ctx.save();\n          ctx.rotate(angle);\n          ctx.beginPath();\n          ctx.moveTo(0,0);\n          ctx.lineTo(0,-len);\n          ctx.stroke();\n          ctx.translate(0,-len);\n          if(depthLeft <= 0){\n            // draw leaf\n            ctx.fillStyle = '#60a5fa33';\n            ctx.beginPath();\n            ctx.arc(0,0,2.5,0,Math.PI*2);\n            ctx.fill();\n          } else {\n            const factor = 0.72 - (depthLeft*0.02);\n            const spread = 0.6;\n            branch(len * factor, -spread, depthLeft-1);\n            branch(len * factor, spread, depthLeft-1);\n            // optional middle branch\n            if(depthLeft > 2) branch(len * factor*0.75, 0, depthLeft-1);\n          }\n          ctx.restore();\n        }\n        branch(Math.min(160, canvas.height/3), 0, depth|0);\n        ctx.restore();\n        const t1 = performance.now();\n        perf.textContent = `drawn in ${(t1-t0).toFixed(1)} ms`;\n      }\n\n      drawBtn.addEventListener('click', ()=> {\n        drawFractal(parseInt(depthSlider.value,10));\n      });\n      clearBtn.addEventListener('click', clearCanvas);\n\n      // Initialize canvas size to element size for crispness\n      function resizeCanvas(){\n        // Keep devicePixelRatio for sharper drawing\n        const dpr = window.devicePixelRatio || 1;\n        const rect = canvas.getBoundingClientRect();\n        canvas.width = Math.max(300, Math.round(rect.width * dpr));\n        canvas.height = Math.max(200, Math.round(rect.height * dpr));\n        canvas.style.width = rect.width + 'px';\n        canvas.style.height = rect.height + 'px';\n        ctx.setTransform(dpr,0,0,dpr,0,0);\n        clearCanvas();\n      }\n      window.addEventListener('resize', resizeCanvas);\n      resizeCanvas();\n\n      // Initialize default state\n      exampleSelect.dispatchEvent(new Event('change'));\n      drawFractal(parseInt(depthSlider.value,10));\n\n      // Keyboard shortcuts\n      document.addEventListener('keydown', (e)=>{\n        if(e.key === 'ArrowRight') stepNextFunc();\n        if(e.key === 'ArrowLeft') stepPrevFunc();\n        if(e.key === ' ') { e.preventDefault(); playToggle(); }\n      });\n\n      // Basic palette explanation\n      setExplain('Recursion is when a function calls itself. Use the examples to see how calls are stacked and how values are returned.');\n\n      // Ensure initial trace area shows nothing\n      traceOutput.textContent = '(no trace)';\n\n      // Accessibility: hint\n      console.log('Recursion Explorer ready. Use the UI to generate and step through traces.');\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Recursion"
    }
  ],
  "topic": "Recursion",
  "hasFSM": false,
  "hasTest": true
}