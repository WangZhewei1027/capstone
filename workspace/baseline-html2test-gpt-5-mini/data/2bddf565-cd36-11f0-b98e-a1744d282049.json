{
  "id": "2bddf565-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:45.629Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Binary Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Interactive Binary Tree (BST) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#60a5fa;\n      --muted:#94a3b8;\n      --node:#0ea5a9;\n      --node-text:#001219;\n      --edge:#94a3b8;\n      --highlight:#f97316;\n      --success:#34d399;\n      --danger:#fb7185;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071024 0%, #041726 100%);color:#e6eef8}\n    .app{\n      display:flex;\n      gap:18px;\n      padding:18px;\n      box-sizing:border-box;\n      height:100vh;\n    }\n    .sidebar{\n      width:360px;\n      min-width:260px;\n      max-width:420px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:16px;\n      box-sizing:border-box;\n      backdrop-filter: blur(6px);\n      border:1px solid rgba(255,255,255,0.04);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      overflow:auto;\n    }\n    h1{font-size:18px;margin:0 0 6px 0}\n    p.lead{margin:0;color:var(--muted);font-size:13px}\n    .controls{display:flex;flex-direction:column;gap:10px;margin-top:6px}\n    .row{display:flex;gap:8px;align-items:center}\n    input[type=\"number\"], input[type=\"text\"], select{\n      padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;flex:1;\n      outline:none;\n    }\n    button{\n      padding:8px 10px;border-radius:8px;border:none;background:var(--accent);color:#04293a;font-weight:600;cursor:pointer;\n      box-shadow:0 2px 8px rgba(96,165,250,0.12);\n    }\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);box-shadow:none}\n    button.warn{background:var(--danger);color:#fff}\n    button.success{background:var(--success);color:#04293a}\n    .small{padding:6px 8px;font-size:13px;border-radius:8px}\n    .info{font-size:13px;color:var(--muted);padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px dashed rgba(255,255,255,0.02)}\n    .svg-wrap{flex:1;min-width:0;display:flex;flex-direction:column;gap:12px}\n    .canvas{\n      flex:1;\n      border-radius:12px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border:1px solid rgba(255,255,255,0.04);\n      position:relative;\n      overflow:auto;\n      padding:12px;\n    }\n    svg{width:100%;height:100%}\n    .legend{display:flex;gap:8px;align-items:center;color:var(--muted);font-size:13px}\n    .dot{width:12px;height:12px;border-radius:50%}\n    .dot.node{background:var(--node)}\n    .dot.edge{background:var(--edge)}\n    .status{font-size:13px;color:var(--muted)}\n    .message{font-size:13px;padding:8px;border-radius:8px}\n    .msg-success{background:rgba(52,211,153,0.08);color:var(--success);border:1px solid rgba(52,211,153,0.08)}\n    .msg-error{background:rgba(251,113,133,0.06);color:var(--danger);border:1px solid rgba(251,113,133,0.06)}\n    .traversal-output{display:flex;gap:8px;flex-wrap:wrap;padding:8px;background:rgba(255,255,255,0.01);border-radius:8px}\n    .badge{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-weight:600}\n    footer{font-size:12px;color:var(--muted);margin-top:8px}\n    /* Node styles for SVG using classes */\n    .node-circle{fill:var(--node);stroke:#063241;stroke-width:1.5}\n    .node-text{font-size:12px;fill:var(--node-text);font-weight:700;text-anchor:middle;dominant-baseline:central}\n    .edge-line{stroke:var(--edge);stroke-width:2;stroke-linecap:round}\n    .highlight{fill:var(--highlight)!important}\n    .search-hit{fill:var(--success)!important}\n    .fade{opacity:0.12}\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"sidebar\">\n      <h1>Binary Tree Visualizer</h1>\n      <p class=\"lead\">Interactive demonstration of a Binary Search Tree (BST). Insert, delete, search, and animate traversals.\n      Nodes are positioned using an inorder layout for clarity.</p>\n\n      <div class=\"controls\">\n        <div class=\"row\">\n          <input id=\"valueInput\" type=\"number\" placeholder=\"Value (integer)\" />\n          <button id=\"insertBtn\" title=\"Insert\">Insert</button>\n          <button id=\"deleteBtn\" title=\"Delete\" class=\"ghost small\">Delete</button>\n        </div>\n\n        <div class=\"row\">\n          <input id=\"searchInput\" type=\"number\" placeholder=\"Search value\" />\n          <button id=\"searchBtn\" class=\"small\">Search</button>\n          <button id=\"clearBtn\" class=\"ghost small\">Clear</button>\n        </div>\n\n        <div class=\"row\">\n          <select id=\"randomCount\">\n            <option value=\"5\">Random 5</option>\n            <option value=\"8\" selected>Random 8</option>\n            <option value=\"12\">Random 12</option>\n            <option value=\"20\">Random 20</option>\n          </select>\n          <button id=\"randomBtn\" class=\"small\">Fill Random BST</button>\n          <button id=\"balancedBtn\" class=\"small ghost\">Build from sorted</button>\n        </div>\n\n        <div class=\"row\">\n          <button data-trav=\"in\" class=\"traversalBtn small\">In-order</button>\n          <button data-trav=\"pre\" class=\"traversalBtn small\">Pre-order</button>\n          <button data-trav=\"post\" class=\"traversalBtn small\">Post-order</button>\n          <button data-trav=\"level\" class=\"traversalBtn small\">Level-order</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"animateBtn\" class=\"success\">Animate Traversal</button>\n          <button id=\"stopAnimBtn\" class=\"ghost\">Stop</button>\n        </div>\n\n        <div class=\"info\" id=\"infoBox\">\n          Tip: Use the \"Balanced\" button to build a balanced BST from a sorted list of current values.\n        </div>\n\n        <div class=\"status\" id=\"stats\">Nodes: 0</div>\n\n        <div class=\"message msg-success\" id=\"message\" style=\"display:none;\"></div>\n      </div>\n\n      <div style=\"flex:1\"></div>\n\n      <footer>\n        - Click nodes in the canvas to highlight a value. Traversal animations will highlight nodes in order.\n      </footer>\n    </div>\n\n    <div class=\"svg-wrap\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center\">\n        <div class=\"legend\">\n          <div class=\"dot node\"></div><div style=\"font-size:13px;color:var(--muted)\">Node</div>\n          <div class=\"dot edge\" style=\"margin-left:8px\"></div><div style=\"font-size:13px;color:var(--muted)\">Edge</div>\n        </div>\n        <div class=\"traversal-output\" id=\"travOut\" aria-live=\"polite\" style=\"min-height:36px\">\n          <div style=\"color:var(--muted);padding-right:8px\">Traversal:</div>\n        </div>\n      </div>\n\n      <div class=\"canvas\" id=\"canvasWrap\">\n        <svg id=\"svgCanvas\" viewBox=\"0 0 1200 600\" preserveAspectRatio=\"xMinYMin meet\">\n          <!-- edges and nodes will be drawn here -->\n        </svg>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Binary Search Tree visualizer\n    (function(){\n      // Utilities\n      const $ = id => document.getElementById(id);\n      const svg = $('svgCanvas');\n      const valueInput = $('valueInput');\n      const searchInput = $('searchInput');\n      const insertBtn = $('insertBtn');\n      const deleteBtn = $('deleteBtn');\n      const searchBtn = $('searchBtn');\n      const clearBtn = $('clearBtn');\n      const randomBtn = $('randomBtn');\n      const randomCount = $('randomCount');\n      const balancedBtn = $('balancedBtn');\n      const traversalBtns = document.querySelectorAll('.traversalBtn');\n      const animateBtn = $('animateBtn');\n      const stopAnimBtn = $('stopAnimBtn');\n      const stats = $('stats');\n      const message = $('message');\n      const travOut = $('travOut');\n\n      let nodeIdCounter = 0;\n      function createNode(val){\n        return { val: Number(val), left: null, right: null, id: ++nodeIdCounter };\n      }\n\n      // BST root\n      let root = null;\n\n      // For animations\n      let animTimer = null;\n      let currentAnimList = [];\n      let animIndex = 0;\n\n      // Insert (BST)\n      function insert(val){\n        if (val === '' || val === null || isNaN(val)) { showMessage('Enter a valid integer to insert', 'error'); return; }\n        const v = Number(val);\n        if (!Number.isFinite(v)) { showMessage('Enter a finite integer', 'error'); return; }\n        root = insertRec(root, v);\n        render();\n        showMessage('Inserted ' + v, 'success');\n      }\n\n      function insertRec(node, val){\n        if (node === null) return createNode(val);\n        if (val === node.val){\n          // duplicates not allowed in this BST implementation\n          showMessage('Value ' + val + ' already exists (duplicates ignored)', 'error');\n          return node;\n        }\n        if (val < node.val) node.left = insertRec(node.left, val);\n        else node.right = insertRec(node.right, val);\n        return node;\n      }\n\n      // Delete\n      function deleteVal(val){\n        if (val === '' || val === null || isNaN(val)) { showMessage('Enter a valid integer to delete', 'error'); return; }\n        const v = Number(val);\n        let existed = {flag:false};\n        root = deleteRec(root, v, existed);\n        if (existed.flag) {\n          render();\n          showMessage('Deleted ' + v, 'success');\n        } else {\n          showMessage('Value ' + v + ' not found', 'error');\n        }\n      }\n\n      function deleteRec(node, val, existed){\n        if (!node) return null;\n        if (val < node.val) node.left = deleteRec(node.left, val, existed);\n        else if (val > node.val) node.right = deleteRec(node.right, val, existed);\n        else { // found\n          existed.flag = true;\n          // 0 or 1 child\n          if (!node.left) return node.right;\n          if (!node.right) return node.left;\n          // 2 children: find inorder successor (smallest in right subtree)\n          let succ = node.right;\n          while (succ.left) succ = succ.left;\n          node.val = succ.val;\n          node.right = deleteRec(node.right, succ.val, existed);\n        }\n        return node;\n      }\n\n      // Search (returns path of nodes visited)\n      function search(val){\n        if (val === '' || val === null || isNaN(val)) { showMessage('Enter a valid integer to search', 'error'); return []; }\n        const v = Number(val);\n        let path = [];\n        let node = root;\n        while (node){\n          path.push(node);\n          if (v === node.val) break;\n          node = v < node.val ? node.left : node.right;\n        }\n        if (path.length && path[path.length-1].val === v){\n          showMessage('Found ' + v, 'success');\n        } else {\n          showMessage('Value ' + v + ' not found', 'error');\n        }\n        return path;\n      }\n\n      // Traversals\n      function inorder(node, out){ if(!node) return; inorder(node.left,out); out.push(node); inorder(node.right,out); }\n      function preorder(node,out){ if(!node) return; out.push(node); preorder(node.left,out); preorder(node.right,out); }\n      function postorder(node,out){ if(!node) return; postorder(node.left,out); postorder(node.right,out); out.push(node); }\n      function levelorder(node,out){\n        if(!node) return;\n        const q=[node];\n        while(q.length){\n          const n=q.shift();\n          out.push(n);\n          if(n.left) q.push(n.left);\n          if(n.right) q.push(n.right);\n        }\n      }\n\n      // Layout: assign x,y to nodes using inorder index\n      function layoutTree(rootNode){\n        const positions = new Map(); // id -> {x,y}\n        const nodeList = [];\n        function collect(node, depth=0){\n          if(!node) return;\n          collect(node.left, depth+1);\n          nodeList.push({node, depth});\n          collect(node.right, depth+1);\n        }\n        collect(rootNode,0);\n        const levels = nodeList.reduce((acc,cur)=>{\n          acc[cur.depth] = (acc[cur.depth]||0)+1; return acc;\n        },[]);\n        // horizontal spacing based on inorder index\n        const width = 1100; // internal viewbox width\n        const height = 520;\n        const hPad = 40;\n        const availableW = width - 2*hPad;\n        const step = nodeList.length>0 ? availableW / (nodeList.length) : availableW;\n        // build map of inorder index\n        let idx=0;\n        for(const item of nodeList){\n          const centerX = hPad + idx*step + step/2;\n          const centerY = 60 + item.depth * 90;\n          positions.set(item.node.id, {x:centerX, y:centerY});\n          idx++;\n        }\n        return positions;\n      }\n\n      // Render to SVG\n      function render(){\n        clearSVG();\n        if(!root){\n          stats.textContent = 'Nodes: 0';\n          travOut.innerHTML = '<div style=\"color:var(--muted);padding-right:8px\">Traversal:</div>';\n          return;\n        }\n        const positions = layoutTree(root);\n        // draw edges first\n        function drawEdges(node){\n          if(!node) return;\n          const p = positions.get(node.id);\n          if(node.left){\n            const c = positions.get(node.left.id);\n            drawEdge(p.x, p.y, c.x, c.y);\n            drawEdges(node.left);\n          }\n          if(node.right){\n            const c = positions.get(node.right.id);\n            drawEdge(p.x, p.y, c.x, c.y);\n            drawEdges(node.right);\n          }\n        }\n        drawEdges(root);\n\n        // draw nodes\n        function drawNodes(node){\n          if(!node) return;\n          const p = positions.get(node.id);\n          drawNode(node, p.x, p.y);\n          drawNodes(node.left);\n          drawNodes(node.right);\n        }\n        drawNodes(root);\n\n        stats.textContent = 'Nodes: ' + countNodes(root);\n      }\n\n      function clearSVG(){\n        while(svg.firstChild) svg.removeChild(svg.firstChild);\n      }\n\n      function drawEdge(x1,y1,x2,y2){\n        const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n        line.setAttribute('x1',x1);\n        line.setAttribute('y1',y1+14); // slightly below center of parent\n        line.setAttribute('x2',x2);\n        line.setAttribute('y2',y2-14); // slightly above center of child\n        line.classList.add('edge-line');\n        svg.appendChild(line);\n      }\n\n      function drawNode(node, x, y){\n        const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n        g.setAttribute('transform', `translate(${x},${y})`);\n        g.setAttribute('data-id', node.id);\n        g.style.cursor = 'pointer';\n\n        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n        circle.setAttribute('r', 18);\n        circle.classList.add('node-circle');\n        circle.setAttribute('data-id', node.id);\n\n        const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n        text.classList.add('node-text');\n        text.textContent = node.val;\n        text.setAttribute('data-id', node.id);\n\n        g.appendChild(circle);\n        g.appendChild(text);\n        svg.appendChild(g);\n\n        // click to show value and highlight\n        g.addEventListener('click', (e)=>{\n          e.stopPropagation();\n          highlightPath([node], {style:'search'}); // briefly highlight node\n          showMessage('Clicked node: ' + node.val, 'success');\n        });\n      }\n\n      function countNodes(node){\n        if(!node) return 0;\n        return 1 + countNodes(node.left) + countNodes(node.right);\n      }\n\n      // Highlight sequence of nodes (by node objects)\n      function highlightPath(nodes, opts={}){\n        // clear existing highlights\n        clearHighlight();\n        if(!nodes || nodes.length===0) return;\n        if(opts.instant){\n          nodes.forEach(n => colorNodeById(n.id, opts.style || 'highlight'));\n          return;\n        }\n        // animate: highlight one by one then clear after short time\n        let i=0;\n        const style = opts.style || 'highlight';\n        const interval = opts.interval || 350;\n        const id = setInterval(()=>{\n          if(i>0) { // fade previous slightly\n            colorNodeById(nodes[i-1].id, 'fade');\n          }\n          if(i >= nodes.length){ clearInterval(id); return; }\n          colorNodeById(nodes[i].id, style);\n          i++;\n        }, interval);\n        setTimeout(()=> {\n          clearInterval(id);\n        }, interval*(nodes.length+1));\n      }\n\n      function colorNodeById(nodeId, mode){\n        // find circle with data-id\n        const circles = svg.querySelectorAll('circle[data-id=\"'+nodeId+'\"]');\n        circles.forEach(c=>{\n          c.classList.remove('highlight','search-hit','fade');\n          if(mode === 'highlight') c.classList.add('highlight');\n          else if(mode === 'search') c.classList.add('search-hit');\n          else if(mode === 'fade') c.classList.add('fade');\n          else if(mode === 'search-hit') c.classList.add('search-hit');\n        });\n      }\n\n      function clearHighlight(){\n        const nodes = svg.querySelectorAll('circle');\n        nodes.forEach(n=>{ n.classList.remove('highlight','search-hit','fade'); });\n      }\n\n      // Messages\n      function showMessage(txt, type='info', timeout=2600){\n        message.style.display = 'block';\n        message.textContent = txt;\n        if(type === 'success'){ message.className = 'message msg-success'; }\n        else if(type === 'error'){ message.className = 'message msg-error'; }\n        else { message.className = 'message'; }\n        if(timeout>0){\n          clearTimeout(message._t);\n          message._t = setTimeout(()=> message.style.display='none', timeout);\n        }\n      }\n\n      // Traversal output display\n      function showTraversalList(list){\n        travOut.innerHTML = '<div style=\"color:var(--muted);padding-right:8px\">Traversal:</div>';\n        list.forEach(n=>{\n          const b = document.createElement('div');\n          b.className = 'badge';\n          b.textContent = n.val;\n          travOut.appendChild(b);\n        });\n      }\n\n      // Animation controls\n      function animateTraversal(list, interval=520){\n        stopAnimation();\n        if(!list || !list.length) return;\n        currentAnimList = list;\n        animIndex = 0;\n        clearHighlight();\n        animTimer = setInterval(()=>{\n          if(animIndex>0){\n            // fade previous\n            colorNodeById(currentAnimList[animIndex-1].id, 'fade');\n          }\n          if(animIndex >= currentAnimList.length){\n            stopAnimation();\n            return;\n          }\n          colorNodeById(currentAnimList[animIndex].id, 'highlight');\n          animIndex++;\n        }, interval);\n      }\n\n      function stopAnimation(){\n        if(animTimer){ clearInterval(animTimer); animTimer = null; }\n      }\n\n      // Helpers: random fill\n      function fillRandom(n){\n        root = null; nodeIdCounter = 0;\n        const set = new Set();\n        while(set.size < n){\n          // random integers -50..+99\n          const v = Math.floor(Math.random()*150) - 50;\n          set.add(v);\n        }\n        const arr = Array.from(set);\n        arr.forEach(v=> root = insertRec(root, v));\n        render();\n        showMessage('Inserted ' + arr.length + ' random values', 'success');\n      }\n\n      // Build balanced BST from sorted values (create minimal-height BST)\n      function buildBalancedFromValues(values){\n        if(values.length === 0) return null;\n        const mid = Math.floor(values.length / 2);\n        const node = createNode(values[mid]);\n        node.left = buildBalancedFromValues(values.slice(0,mid));\n        node.right = buildBalancedFromValues(values.slice(mid+1));\n        return node;\n      }\n\n      function buildBalanced(){\n        // collect current values and build balanced BST\n        const vals = [];\n        inorder(root, vals);\n        const nums = vals.map(n=>n.val).sort((a,b)=>a-b);\n        // reset ids so nodes get fresh ids\n        nodeIdCounter = 0;\n        root = buildBalancedFromValues(nums);\n        render();\n        showMessage('Built balanced BST from current values', 'success');\n      }\n\n      // Event wiring\n      insertBtn.addEventListener('click', ()=>{ insert(valueInput.value); valueInput.focus(); });\n      deleteBtn.addEventListener('click', ()=>{ deleteVal(valueInput.value || searchInput.value); });\n      searchBtn.addEventListener('click', ()=>{\n        const path = search(searchInput.value || valueInput.value);\n        if(path.length){\n          highlightPath(path, {interval:420, style:'search'});\n        }\n        // show visited nodes values in travOut\n        showTraversalList(path);\n      });\n      clearBtn.addEventListener('click', ()=>{\n        root = null; nodeIdCounter = 0; clearSVG(); stats.textContent = 'Nodes: 0';\n        travOut.innerHTML = '<div style=\"color:var(--muted);padding-right:8px\">Traversal:</div>';\n        showMessage('Cleared tree', 'success');\n      });\n\n      randomBtn.addEventListener('click', ()=> fillRandom(Number(randomCount.value)));\n      balancedBtn.addEventListener('click', ()=> buildBalanced());\n\n      traversalBtns.forEach(btn=>{\n        btn.addEventListener('click', ()=>{\n          const type = btn.getAttribute('data-trav');\n          const list = [];\n          if(type === 'in') inorder(root,list);\n          if(type === 'pre') preorder(root,list);\n          if(type === 'post') postorder(root,list);\n          if(type === 'level') levelorder(root,list);\n          if(list.length===0){ showMessage('Tree is empty', 'error'); return; }\n          showTraversalList(list);\n          // small flash\n          highlightPath(list, {interval:340, style:'highlight'});\n        });\n      });\n\n      animateBtn.addEventListener('click', ()=>{\n        // by default animate in-order\n        const list = [];\n        inorder(root,list);\n        if(list.length===0){ showMessage('Tree is empty', 'error'); return; }\n        showTraversalList(list);\n        animateTraversal(list, 520);\n      });\n\n      stopAnimBtn.addEventListener('click', ()=> stopAnimation());\n\n      // canvas click clears highlight\n      $('canvasWrap').addEventListener('click', ()=> clearHighlight());\n\n      // keyboard shortcuts\n      document.addEventListener('keydown', (e)=>{\n        if(e.key === 'Enter'){\n          if(document.activeElement === searchInput) searchBtn.click();\n          else insertBtn.click();\n        }\n      });\n\n      // initial demo tree\n      function initialDemo(){\n        const demo = [50,30,70,20,40,60,80,10,25,35,45];\n        root = null; nodeIdCounter = 0;\n        demo.forEach(v => root = insertRec(root, v));\n        render();\n      }\n\n      // initial render and message\n      initialDemo();\n      showMessage('Demo tree loaded â€” try inserting, deleting, searching, and animating traversals', 'success', 4000);\n\n      // Expose some small helpers to global for debugging (optional)\n      window._bst = {\n        getRoot: ()=>root,\n        insert: (v)=>{ insert(v); },\n        delete: (v)=>{ deleteVal(v); },\n        inorder: ()=>{ const out=[]; inorder(root,out); return out.map(n=>n.val); }\n      };\n\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Tree"
    }
  ],
  "topic": "Binary Tree",
  "hasFSM": false,
  "hasTest": true
}