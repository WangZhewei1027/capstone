{
  "id": "2bddf560-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:36.960Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Queue",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Queue (FIFO) — Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#3b82f6;\n      --muted:#94a3b8;\n      --danger:#ef4444;\n      --success:#10b981;\n      --glass: rgba(255,255,255,0.03);\n    }\n    html,body{height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial;}\n    body{background: linear-gradient(180deg,#071024 0%, #071b2a 100%); color:#e6eef8; padding:24px; box-sizing:border-box;}\n    .container{max-width:1100px; margin:0 auto; display:grid; grid-template-columns: 360px 1fr; gap:20px; align-items:start;}\n    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:18px; border-radius:12px; box-shadow: 0 6px 24px rgba(2,6,23,0.6);}\n    h1{font-size:20px; margin:0 0 8px; color:#dbeafe;}\n    p.lead{margin:0 0 14px; color:var(--muted); font-size:13px;}\n    label{display:block; font-size:13px; color:var(--muted); margin-bottom:6px;}\n    .controls{display:flex; gap:8px; margin-bottom:12px; align-items:center;}\n    input[type=text], input[type=number]{background:var(--glass); border:1px solid rgba(255,255,255,0.04); color:inherit; padding:10px 12px; border-radius:8px; outline:none; min-width:0;}\n    input[type=number]{width:110px;}\n    button{background:linear-gradient(180deg,var(--accent), #2563eb); border:none; color:white; padding:10px 12px; border-radius:8px; cursor:pointer; font-weight:600;}\n    button.secondary{background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--muted); font-weight:600;}\n    button.danger{background:linear-gradient(180deg,var(--danger), #b91c1c);}\n    .small{padding:8px 10px; font-size:13px;}\n    .row{display:flex; gap:8px; align-items:center;}\n    .info{font-size:13px; color:var(--muted); margin-top:8px;}\n    .visual{min-height:200px; display:flex; align-items:center; justify-content:center; flex-direction:column;}\n    .queue-area{display:flex; gap:8px; align-items:center; padding:12px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02)); border:1px solid rgba(255,255,255,0.03); transition:all .2s; flex-wrap:wrap; justify-content:center;}\n    .node{min-width:62px; padding:10px 12px; background:rgba(255,255,255,0.03); border-radius:8px; border:1px solid rgba(255,255,255,0.04); text-align:center; color:#e6eef8; font-weight:700; position:relative; transform-origin:center center; transition: transform .25s ease, opacity .25s ease, box-shadow .2s;}\n    .node.new{animation:pop .25s ease;}\n    @keyframes pop{0%{transform:scale(.6);opacity:0}100%{transform:scale(1);opacity:1}}\n    .node.removed{opacity:0; transform:translateY(-18px) scale(.9);}\n    .label{font-size:12px; color:var(--muted); margin-bottom:6px; text-align:center;}\n    .tag{position:absolute; bottom:-11px; left:50%; transform:translateX(-50%); background:#0b1220; color:var(--muted); font-size:11px; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,0.03);}\n    .arrows{display:flex; gap:12px; align-items:center; margin-top:12px;}\n    .arrow{font-weight:800; font-size:18px; color:var(--muted);}\n    .log{max-height:220px; overflow:auto; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02)); border-radius:10px; padding:10px; border:1px solid rgba(255,255,255,0.03); font-family:monospace; font-size:13px; color:#cfe8ff;}\n    .meta{display:flex; gap:10px; align-items:center; margin-top:10px; flex-wrap:wrap;}\n    .badge{background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.04); padding:6px 8px; border-radius:8px; font-size:13px; color:var(--muted);}\n    .footer{margin-top:12px; font-size:13px; color:var(--muted);}\n    .flexcol{display:flex; flex-direction:column;}\n    .center{display:flex; align-items:center; justify-content:center;}\n    @media (max-width:880px){ .container{grid-template-columns:1fr; } .panel{padding:14px;} }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <!-- Left controls -->\n    <div class=\"panel\">\n      <h1>Queue (FIFO) Interactive Demo</h1>\n      <p class=\"lead\">A queue is a First-In-First-Out (FIFO) data structure. This demo lets you enqueue and dequeue items, see the internal state, and inspect common operations.</p>\n\n      <label for=\"valueInput\">Value to enqueue</label>\n      <div class=\"controls\">\n        <input id=\"valueInput\" type=\"text\" placeholder=\"e.g., Task A\" />\n        <button id=\"enqueueBtn\">Enqueue</button>\n      </div>\n\n      <div style=\"display:flex; gap:8px; margin-bottom:12px;\">\n        <button id=\"dequeueBtn\" class=\"small secondary\">Dequeue</button>\n        <button id=\"peekBtn\" class=\"small secondary\">Peek (front)</button>\n        <button id=\"clearBtn\" class=\"small danger\">Clear</button>\n      </div>\n\n      <label for=\"capacity\">Optional capacity (0 = unbounded)</label>\n      <div class=\"row\" style=\"margin-bottom:12px;\">\n        <input id=\"capacity\" type=\"number\" min=\"0\" value=\"0\" />\n        <button id=\"applyCap\" class=\"small\">Apply</button>\n      </div>\n\n      <div class=\"meta\">\n        <div class=\"badge\">Size: <span id=\"size\">0</span></div>\n        <div class=\"badge\">Front: <span id=\"frontVal\">—</span></div>\n        <div class=\"badge\">Rear: <span id=\"rearVal\">—</span></div>\n        <div class=\"badge\">Capacity: <span id=\"capVal\">∞</span></div>\n      </div>\n\n      <div class=\"footer\">\n        Complexity: Enqueue O(1), Dequeue O(1) — this implementation uses a circular buffer under the hood.\n      </div>\n    </div>\n\n    <!-- Right visualization & log -->\n    <div class=\"panel\">\n      <div class=\"visual\">\n        <div class=\"label\">Queue visualization</div>\n        <div id=\"queueArea\" class=\"queue-area\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n\n        <div class=\"arrows\">\n          <div class=\"center\" style=\"flex-direction:column; align-items:center;\">\n            <div class=\"arrow\">Front ⟵</div>\n          </div>\n          <div style=\"flex:1\"></div>\n          <div class=\"center\" style=\"flex-direction:column; align-items:center;\">\n            <div class=\"arrow\">⟶ Rear</div>\n          </div>\n        </div>\n\n        <div style=\"width:100%; margin-top:14px;\">\n          <div class=\"label\">Operation log</div>\n          <div id=\"log\" class=\"log\" role=\"log\" aria-live=\"polite\"></div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<script>\n/*\n  Queue demo\n  - Implements a circular buffer-backed queue (fixed capacity when set, unbounded by expanding internal buffer).\n  - Provides enqueue, dequeue, peek, clear.\n  - Updates UI visualization and operation log.\n*/\n\n// Simple Queue implementation using a circular buffer.\n// If capacity is 0 => treat as unbounded (we'll expand as needed).\nclass Queue {\n  constructor(capacity = 0) {\n    this._cap = capacity > 0 ? Math.max(2, Math.floor(capacity)) : 0; // min 2 when bounded\n    this._arr = this._cap ? new Array(this._cap) : []; // underlying array/buffer\n    this._head = 0; // index of front\n    this._tail = 0; // index where next element will be written\n    this._size = 0;\n  }\n\n  // current capacity (0 => unbounded)\n  capacity() { return this._cap; }\n\n  size() { return this._size; }\n  isEmpty() { return this._size === 0; }\n\n  peek() {\n    if (this.isEmpty()) return undefined;\n    return this._arr[this._head];\n  }\n\n  // ensure capacity for at least 'need' more elements\n  _ensureCapacity(need = 1) {\n    if (this._cap === 0) return; // unbounded mode: underlying array grows with push/shift approach\n    if (this._size + need <= this._cap) return;\n    // need to grow buffer: double it\n    const newCap = Math.max(this._cap * 2, this._size + need);\n    const newArr = new Array(newCap);\n    // copy current elements in order to newArr\n    for (let i = 0; i < this._size; i++) {\n      newArr[i] = this._arr[(this._head + i) % this._cap];\n    }\n    this._arr = newArr;\n    this._cap = newCap;\n    this._head = 0;\n    this._tail = this._size % this._cap;\n  }\n\n  enqueue(value) {\n    if (this._cap === 0) {\n      // unbounded: simple push to array backend\n      this._arr.push(value);\n      this._size++;\n      return true;\n    }\n    // bounded or expandable circular buffer\n    if (this._size >= this._cap) {\n      // buffer full: expand automatically\n      this._ensureCapacity(1);\n    }\n    this._arr[this._tail] = value;\n    this._tail = (this._tail + 1) % this._cap;\n    this._size++;\n    return true;\n  }\n\n  dequeue() {\n    if (this.isEmpty()) return undefined;\n    let val;\n    if (this._cap === 0) {\n      // unbounded: using plain array - shift\n      val = this._arr.shift();\n      this._size--;\n      return val;\n    }\n    val = this._arr[this._head];\n    // optional: clear slot\n    this._arr[this._head] = undefined;\n    this._head = (this._head + 1) % this._cap;\n    this._size--;\n    return val;\n  }\n\n  clear() {\n    if (this._cap === 0) {\n      this._arr = [];\n    } else {\n      this._arr = new Array(this._cap);\n    }\n    this._head = this._tail = this._size = 0;\n  }\n\n  toArray() {\n    if (this._cap === 0) return this._arr.slice();\n    const res = [];\n    for (let i = 0; i < this._size; i++) {\n      res.push(this._arr[(this._head + i) % this._cap]);\n    }\n    return res;\n  }\n}\n\n/* UI wiring */\nconst queueArea = document.getElementById('queueArea');\nconst logEl = document.getElementById('log');\nconst sizeEl = document.getElementById('size');\nconst frontEl = document.getElementById('frontVal');\nconst rearEl = document.getElementById('rearVal');\nconst capEl = document.getElementById('capVal');\nconst valueInput = document.getElementById('valueInput');\nconst enqueueBtn = document.getElementById('enqueueBtn');\nconst dequeueBtn = document.getElementById('dequeueBtn');\nconst peekBtn = document.getElementById('peekBtn');\nconst clearBtn = document.getElementById('clearBtn');\nconst capacityInput = document.getElementById('capacity');\nconst applyCapBtn = document.getElementById('applyCap');\n\nlet queue = new Queue(0); // start unbounded\n\nfunction appendLog(text, color) {\n  const line = document.createElement('div');\n  line.textContent = `${new Date().toLocaleTimeString()}: ${text}`;\n  if (color) line.style.color = color;\n  logEl.prepend(line);\n}\n\n// Render queue visually as boxes. Front on left.\nfunction renderQueue(highlight = {}) {\n  // highlight: {newIndex, removedIndex, peekIndex}\n  queueArea.innerHTML = '';\n  const arr = queue.toArray();\n  if (arr.length === 0) {\n    const empty = document.createElement('div');\n    empty.className = 'node';\n    empty.style.opacity = '0.6';\n    empty.textContent = 'Empty';\n    queueArea.appendChild(empty);\n  } else {\n    arr.forEach((v, i) => {\n      const n = document.createElement('div');\n      n.className = 'node';\n      n.textContent = String(v);\n      // label front/rear tags\n      if (i === 0) {\n        const t = document.createElement('div'); t.className = 'tag'; t.textContent = 'front';\n        n.appendChild(t);\n      }\n      if (i === arr.length - 1) {\n        const t2 = document.createElement('div'); t2.className = 'tag'; t2.textContent = 'rear';\n        n.appendChild(t2);\n      }\n      // visual highlight\n      if (highlight.newIndex === i) n.classList.add('new');\n      if (highlight.removedIndex === i) n.classList.add('removed');\n      if (highlight.peekIndex === i) { n.style.boxShadow = '0 6px 18px rgba(59,130,246,0.18)'; }\n      queueArea.appendChild(n);\n    });\n  }\n\n  // update meta\n  sizeEl.textContent = queue.size();\n  const front = queue.peek();\n  frontEl.textContent = front !== undefined ? String(front) : '—';\n  const arrRep = queue.toArray();\n  rearEl.textContent = arrRep.length ? String(arrRep[arrRep.length - 1]) : '—';\n  capEl.textContent = queue.capacity() === 0 ? '∞' : String(queue.capacity());\n}\n\n// Hook up controls\nenqueueBtn.addEventListener('click', () => {\n  const val = valueInput.value.trim();\n  const useVal = val === '' ? `Item-${Math.floor(Math.random()*1000)}` : val;\n  const success = queue.enqueue(useVal);\n  if (success) {\n    appendLog(`Enqueued \"${useVal}\"`, '#a7f3d0');\n    renderQueue({newIndex: queue.size()-1});\n  } else {\n    appendLog(`Failed to enqueue \"${useVal}\"`, '#fca5a5');\n  }\n  valueInput.value = '';\n  valueInput.focus();\n});\n\ndequeueBtn.addEventListener('click', () => {\n  const before = queue.toArray();\n  const removed = queue.dequeue();\n  if (removed === undefined) {\n    appendLog('Dequeue attempted on empty queue', '#fca5a5');\n    renderQueue();\n    return;\n  }\n  appendLog(`Dequeued \"${removed}\"`, '#ffd580');\n  // show removed element briefly by rendering with removedIndex = 0 before actual shift (front)\n  // Since we've already dequeued, show a small animation capturing last front removed behavior:\n  renderQueue();\n});\n\npeekBtn.addEventListener('click', () => {\n  const v = queue.peek();\n  if (v === undefined) {\n    appendLog('Peek: queue is empty', '#fca5a5');\n    renderQueue();\n    return;\n  }\n  appendLog(`Peek: \"${v}\" (front)`, '#bfdbfe');\n  // highlight front\n  renderQueue({peekIndex: 0});\n});\n\nclearBtn.addEventListener('click', () => {\n  queue.clear();\n  appendLog('Cleared queue', '#fda4af');\n  renderQueue();\n});\n\napplyCapBtn.addEventListener('click', () => {\n  const val = Number(capacityInput.value);\n  if (!Number.isFinite(val) || val < 0) {\n    appendLog('Invalid capacity', '#fca5a5');\n    return;\n  }\n  const capVal = Math.floor(val);\n  // create new queue with new capacity and copy elements (if possible)\n  const items = queue.toArray();\n  const maxAllowed = capVal === 0 ? Infinity : capVal;\n  if (items.length > maxAllowed) {\n    // drop oldest items to fit\n    const toKeep = items.slice(items.length - maxAllowed);\n    queue = new Queue(capVal);\n    toKeep.forEach(x => queue.enqueue(x));\n    appendLog(`Applied capacity ${capVal}. Dropped oldest items to fit.`, '#fbcfe8');\n  } else {\n    const newQ = new Queue(capVal);\n    items.forEach(x => newQ.enqueue(x));\n    queue = newQ;\n    appendLog(`Applied capacity ${capVal}.`, '#bbf7d0');\n  }\n  renderQueue();\n});\n\n// allow Enter to enqueue\nvalueInput.addEventListener('keydown', (e) => {\n  if (e.key === 'Enter') enqueueBtn.click();\n});\n\n// initial render\nrenderQueue();\n\n// Example automated demo sequence to illustrate FIFO (run once)\n(function autoDemo(){\n  appendLog('Demo: enqueue A, B, C, then dequeue twice to show FIFO', '#93c5fd');\n  const demoItems = ['A','B','C'];\n  let step = 0;\n  function next(){\n    if (step < demoItems.length) {\n      queue.enqueue(demoItems[step]);\n      appendLog(`Enqueued \"${demoItems[step]}\"`, '#a7f3d0');\n      renderQueue({newIndex: queue.size()-1});\n    } else if (step < demoItems.length + 2) {\n      const removed = queue.dequeue();\n      appendLog(`Dequeued \"${removed}\"`, '#ffd580');\n      renderQueue();\n    } else {\n      appendLog('Demo complete — queue preserves FIFO: A then B were removed first', '#c7f9cc');\n      return;\n    }\n    step++;\n    setTimeout(next, 700);\n  }\n  // run after short delay so the page draws\n  setTimeout(next, 600);\n})();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Queue"
    }
  ],
  "topic": "Queue",
  "hasFSM": false,
  "hasTest": true
}