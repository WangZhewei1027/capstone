{
  "id": "2bde438a-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:52.587Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Radix Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Radix Sort Visualizer (LSD)</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#60a5fa;\n      --muted:#94a3b8;\n      --card:#0b1226;\n      --good:#16a34a;\n      --danger:#ef4444;\n      --glass: rgba(255,255,255,0.03);\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{\n      background:linear-gradient(180deg,#071027 0%, #081524 55%, #04111b 100%);\n      color:#e6eef8;\n      padding:20px;\n      box-sizing:border-box;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app{\n      max-width:1100px;margin:0 auto;\n      display:grid;grid-template-columns: 360px 1fr;gap:20px;\n    }\n    .panel{\n      background:var(--panel);\n      border-radius:12px;padding:16px;box-shadow:0 6px 20px rgba(2,6,23,0.6);\n    }\n    h1{margin:0 0 8px 0;font-size:18px;}\n    p.lead{margin:0 0 12px 0;color:var(--muted);font-size:13px;line-height:1.4;}\n    .controls{display:flex;flex-direction:column;gap:12px;}\n    label{font-size:12px;color:var(--muted);}\n    input[type=\"text\"]{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;}\n    .row{display:flex;gap:8px;align-items:center;}\n    .row .btn{padding:8px 10px;border-radius:8px;background:var(--glass);border:1px solid rgba(255,255,255,0.03);color:var(--accent);cursor:pointer;}\n    .btn.primary{background:linear-gradient(90deg,var(--accent),#7dd3fc);color:#03203a;font-weight:700;border:0;}\n    .btn.warn{background:linear-gradient(90deg,#f97316,#fca34b);color:#111;}\n    .small{font-size:12px;padding:6px 8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);}\n    .visual{\n      padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;\n      min-height:420px;display:flex;flex-direction:column;gap:12px;\n    }\n    .array-row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}\n    .cell{\n      min-width:48px;height:48px;border-radius:8px;background:var(--card);display:flex;align-items:center;justify-content:center;\n      box-shadow:inset 0 -10px 30px rgba(0,0,0,0.45);\n      font-weight:700;font-size:15px;color:#e6f2ff;position:relative;\n      transition:transform .25s ease, box-shadow .15s ease;\n    }\n    .cell .digit{position:absolute;right:6px;top:4px;font-size:11px;color:var(--muted);opacity:0.9;}\n    .cell.highlight{box-shadow:0 8px 30px rgba(96,165,250,0.15);transform:translateY(-6px);}\n    .cell.moved{background:linear-gradient(90deg,#34d399,#60a5fa);}\n    .buckets{display:flex;gap:8px;align-items:flex-start;overflow:auto;padding-bottom:6px;}\n    .bucket{\n      min-width:70px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px dashed rgba(255,255,255,0.03);\n      display:flex;flex-direction:column;gap:8px;align-items:center;\n    }\n    .bucket .label{font-size:12px;color:var(--muted);margin-bottom:4px;}\n    .bucket .stack{display:flex;flex-direction:column;gap:6px;width:100%;align-items:center;}\n    .bucket .stack .cell{min-width:52px;height:36px;font-size:13px;}\n    .status{display:flex;justify-content:space-between;align-items:center;font-size:13px;color:var(--muted);}\n    .controls-row{display:flex;gap:8px;align-items:center;}\n    .slider{width:140px;}\n    .footer-note{font-size:12px;color:var(--muted);margin-top:10px;}\n    .error{color:var(--danger);font-size:13px;}\n    .kbd{background:rgba(255,255,255,0.03);padding:4px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);font-size:12px;}\n    .legend{display:flex;gap:8px;align-items:center;font-size:13px;}\n    .dot{width:12px;height:12px;border-radius:3px;}\n    .dot.dist{background:#60a5fa;}\n    .dot.collect{background:#34d399;}\n    .note{font-size:13px;color:var(--muted);}\n    @media (max-width:880px){\n      .app{grid-template-columns:1fr; padding-bottom:80px;}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"panel\">\n      <h1>Radix Sort (LSD) Visualizer</h1>\n      <p class=\"lead\">\n        Visual demonstration of Least Significant Digit (LSD) Radix Sort. Works with non-negative integers.\n        Use the controls to input numbers, change base (radix), step through distribution and collection phases, or autoplay.\n      </p>\n\n      <div class=\"controls\">\n        <div>\n          <label>Array (comma separated integers, non-negative)</label>\n          <input id=\"arrayInput\" type=\"text\" value=\"170,45,75,90,802,24,2,66\" />\n        </div>\n\n        <div class=\"row\">\n          <div style=\"flex:1\">\n            <label>Base (radix)</label>\n            <input id=\"baseInput\" type=\"number\" min=\"2\" max=\"16\" value=\"10\" class=\"small\" />\n          </div>\n          <div style=\"width:120px\">\n            <label>Animation speed</label>\n            <input id=\"speed\" type=\"range\" min=\"100\" max=\"1500\" value=\"600\" class=\"slider\" />\n          </div>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"loadBtn\" class=\"btn primary\">Load Array</button>\n          <button id=\"randomBtn\" class=\"btn\">Random</button>\n          <button id=\"clearBtn\" class=\"btn\">Clear</button>\n        </div>\n\n        <div class=\"row\">\n          <button id=\"stepBack\" class=\"btn\">Step ◀</button>\n          <button id=\"playPause\" class=\"btn primary\">Play ▶</button>\n          <button id=\"stepForward\" class=\"btn\">Step ▶</button>\n          <button id=\"resetBtn\" class=\"btn warn\">Reset</button>\n        </div>\n\n        <div class=\"row\">\n          <div style=\"flex:1\">\n            <label>Predefined sets</label>\n            <select id=\"preset\" class=\"small\" style=\"width:100%\">\n              <option value=\"170,45,75,90,802,24,2,66\">Classic</option>\n              <option value=\"3,1,4,1,5,9,2,6,5,3,5\">Pi digits</option>\n              <option value=\"0,0,0,0\">Zeros</option>\n              <option value=\"12,123,1234,12345,1,0\">Varying lengths</option>\n              <option value=\"\">Empty</option>\n            </select>\n          </div>\n          <div style=\"width:120px\">\n            <label>Count random</label>\n            <input id=\"randCount\" type=\"number\" min=\"1\" max=\"40\" value=\"10\" class=\"small\" />\n          </div>\n        </div>\n\n        <div class=\"footer-note\">\n          Tip: Radix sort processes digits from least to most significant. This demo performs distribution (to buckets) then collection for each digit.\n        </div>\n      </div>\n    </div>\n\n    <div class=\"panel visual\">\n      <div class=\"status\">\n        <div>\n          <span class=\"legend\"><span class=\"dot dist\"></span>&nbsp;Distribution</span>\n          &nbsp;&nbsp;&nbsp;\n          <span class=\"legend\"><span class=\"dot collect\"></span>&nbsp;Collection</span>\n        </div>\n        <div class=\"note\">\n          Base: <span id=\"curBase\">10</span> &nbsp;|&nbsp; Digit position: <span id=\"digitPos\">-</span> &nbsp;|&nbsp; Phase: <span id=\"phase\">idle</span>\n        </div>\n      </div>\n\n      <div>\n        <label style=\"font-size:13px;color:var(--muted)\">Working array</label>\n        <div id=\"arrayRow\" class=\"array-row\" style=\"margin-top:8px\"></div>\n      </div>\n\n      <div>\n        <label style=\"font-size:13px;color:var(--muted)\">Buckets</label>\n        <div id=\"buckets\" class=\"buckets\" style=\"margin-top:8px\"></div>\n      </div>\n\n      <div style=\"display:flex;justify-content:space-between;align-items:center;margin-top:6px\">\n        <div id=\"message\" class=\"note\"></div>\n        <div id=\"controlsTiny\" style=\"display:flex;gap:8px;align-items:center\">\n          <span class=\"note\">Click cells to toggle highlight</span>\n          <span class=\"note\" style=\"margin-left:8px;color:var(--muted)\">Sorted result appears in array after full passes</span>\n        </div>\n      </div>\n\n      <div style=\"margin-top:6px\">\n        <div id=\"error\" class=\"error\" style=\"display:none\"></div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n  // Radix Sort Visualizer (LSD) - Single-file demo\n  (function(){\n    // DOM refs\n    const arrayInput = document.getElementById('arrayInput');\n    const loadBtn = document.getElementById('loadBtn');\n    const randomBtn = document.getElementById('randomBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const baseInput = document.getElementById('baseInput');\n    const speedInput = document.getElementById('speed');\n    const stepForward = document.getElementById('stepForward');\n    const stepBack = document.getElementById('stepBack');\n    const playPause = document.getElementById('playPause');\n    const resetBtn = document.getElementById('resetBtn');\n    const arrayRow = document.getElementById('arrayRow');\n    const bucketsEl = document.getElementById('buckets');\n    const digitPosEl = document.getElementById('digitPos');\n    const phaseEl = document.getElementById('phase');\n    const curBaseEl = document.getElementById('curBase');\n    const messageEl = document.getElementById('message');\n    const errorEl = document.getElementById('error');\n    const preset = document.getElementById('preset');\n    const randCount = document.getElementById('randCount');\n\n    // internal state\n    let initialArray = [];\n    let workingArray = [];\n    let buckets = [];\n    let base = 10;\n    let timer = null;\n    let speed = 600;\n    let phase = 'idle'; // 'idle'|'distribute'|'collect'|'done'\n    let digitPos = -1;\n    let maxDigits = 0;\n    let distIndex = 0; // index in workingArray for distribution step\n    let collectBucket = 0; // which bucket we're collecting\n    let playing = false;\n    let highlighted = new Set();\n\n    // Utility helpers\n    function showError(msg){\n      errorEl.textContent = msg;\n      errorEl.style.display = msg ? 'block' : 'none';\n    }\n    function parseArrayInput(text){\n      if (!text.trim()) return [];\n      const parts = text.split(',').map(s=>s.trim()).filter(s=>s.length);\n      const nums = [];\n      for (const p of parts){\n        if (!/^-?\\d+$/.test(p)){\n          throw new Error(\"Only integers allowed.\");\n        }\n        const n = parseInt(p,10);\n        if (n < 0) throw new Error(\"Negative numbers not supported in this demo.\");\n        nums.push(n);\n      }\n      return nums;\n    }\n    function digitsCount(n, b){\n      if (n === 0) return 1;\n      let c = 0;\n      while (n > 0) { c++; n = Math.floor(n / b); }\n      return c;\n    }\n    function getDigit(n, pos, b){\n      // least significant digit pos=0\n      return Math.floor(n / Math.pow(b, pos)) % b;\n    }\n\n    // Render functions\n    function render(){\n      // Working array\n      arrayRow.innerHTML = '';\n      workingArray.forEach((val, idx) => {\n        const c = document.createElement('div');\n        c.className = 'cell' + (highlighted.has(val + '::' + idx) ? ' highlight' : '');\n        c.textContent = val;\n        const d = document.createElement('div');\n        d.className = 'digit';\n        d.textContent = (digitPos >= 0 && val != null) ? String(getDigit(val, digitPos, base)) : '';\n        c.appendChild(d);\n        c.onclick = () => {\n          const key = val + '::' + idx;\n          if (highlighted.has(key)) highlighted.delete(key); else highlighted.add(key);\n          render();\n        };\n        arrayRow.appendChild(c);\n      });\n\n      // Buckets\n      bucketsEl.innerHTML = '';\n      for (let b = 0; b < base; b++){\n        const bucket = document.createElement('div');\n        bucket.className = 'bucket';\n        const label = document.createElement('div');\n        label.className = 'label';\n        label.textContent = b;\n        bucket.appendChild(label);\n        const stack = document.createElement('div');\n        stack.className = 'stack';\n        buckets[b].forEach((val, idx) => {\n          const c = document.createElement('div');\n          c.className = 'cell' + (highlighted.has(val + '::bucket::' + b + '::' + idx) ? ' highlight' : '');\n          c.textContent = val;\n          const d = document.createElement('div');\n          d.className = 'digit';\n          d.textContent = (digitPos >= 0 && val != null) ? String(getDigit(val, digitPos, base)) : '';\n          c.appendChild(d);\n          c.onclick = () => {\n            const key = val + '::bucket::' + b + '::' + idx;\n            if (highlighted.has(key)) highlighted.delete(key); else highlighted.add(key);\n            render();\n          };\n          stack.appendChild(c);\n        });\n        bucket.appendChild(stack);\n        bucketsEl.appendChild(bucket);\n      }\n\n      curBaseEl.textContent = base;\n      digitPosEl.textContent = digitPos >=0 ? digitPos : '-';\n      phaseEl.textContent = phase;\n      messageEl.textContent = `Array size: ${workingArray.length}  | Max digits: ${maxDigits}`;\n    }\n\n    function resetState(keepArray){\n      clearInterval(timer); timer = null; playing = false; playPause.textContent = 'Play ▶';\n      speed = parseInt(speedInput.value,10) || 600;\n      base = Math.max(2, Math.min(16, parseInt(baseInput.value,10) || 10));\n      curBaseEl.textContent = base;\n      if (!keepArray) highlighted.clear();\n      if (!keepArray) errorEl.style.display = 'none';\n      // initialize buckets\n      buckets = Array.from({length: base}, ()=>[]);\n      if (!keepArray){\n        workingArray = initialArray.slice();\n      }\n      // compute digits\n      maxDigits = 0;\n      for (const v of workingArray) maxDigits = Math.max(maxDigits, digitsCount(v, base));\n      if (workingArray.length === 0) {\n        phase = 'idle';\n        digitPos = -1;\n      } else {\n        phase = 'distribute';\n        digitPos = 0;\n      }\n      distIndex = 0;\n      collectBucket = 0;\n      render();\n    }\n\n    // Step behavior\n    function stepForwardAction(){\n      if (workingArray.length === 0) {\n        phase = 'idle'; render(); return;\n      }\n      if (phase === 'idle') { phase = 'distribute'; digitPos = 0; distIndex = 0; render(); return; }\n      if (phase === 'done') { render(); return; }\n\n      // Distribution phase: move next element from workingArray to corresponding bucket\n      if (phase === 'distribute'){\n        if (distIndex < workingArray.length){\n          const val = workingArray[distIndex];\n          const bucketIdx = getDigit(val, digitPos, base);\n          // move element from array to bucket visually: we'll mark as removed in workingArray by null placeholder but keep order\n          // To keep stable ordering, we'll remove it physically and push to buckets\n          workingArray.splice(distIndex,1);\n          buckets[bucketIdx].push(val);\n          // do not increment distIndex because the array shifted; we keep same distIndex to process next element at same index\n        } else {\n          // finished distribution for this digit\n          phase = 'collect';\n          collectBucket = 0;\n        }\n        // If we just finished distribution (no elements), switch to collect\n        if (phase === 'distribute') {\n          // if no more to process and we didn't switch earlier:\n          if (workingArray.length === 0 && distIndex >= workingArray.length) {\n            phase = 'collect';\n            collectBucket = 0;\n          }\n        }\n        render();\n        return;\n      }\n\n      // Collection phase: take from buckets starting at bucket 0..base-1 in order and append back to workingArray\n      if (phase === 'collect'){\n        // find next non-empty bucket\n        while (collectBucket < base && buckets[collectBucket].length === 0) collectBucket++;\n        if (collectBucket >= base){\n          // finished collecting for this digit -> prepare next digit or finish\n          digitPos++;\n          if (digitPos >= maxDigits){\n            phase = 'done';\n            // ensure workingArray is fully assembled (should be)\n            render();\n            return;\n          } else {\n            // prepare for next distribution: reset distIndex, but array currently contains collected values.\n            phase = 'distribute';\n            distIndex = 0;\n            // clear buckets (should be empty already)\n            for (let i=0;i<base;i++) buckets[i] = [];\n            render();\n            return;\n          }\n        } else {\n          // pop first element from bucket and push to workingArray\n          const val = buckets[collectBucket].shift();\n          workingArray.push(val);\n          // stay on same bucket (maybe still has more)\n        }\n        render();\n        return;\n      }\n    }\n\n    function stepBackAction(){\n      // For simplicity, stepping back rewinds to initial and plays forward to desired step-1.\n      // Implementing true backward micro-step is complex; this approach is acceptable for visualization.\n      // We'll rewind and then simulate up to (current step - 1).\n      // Compute number of micro-steps that have been executed so far:\n      // Let's create a deterministic simulation from initialArray through actions until we reach current state and then stop one step earlier.\n      if (initialArray.length === 0) return;\n\n      // Build action log forward until 'done' using a simulated copy\n      const simBase = base;\n      const simInitial = initialArray.slice();\n      let simBuckets = Array.from({length: simBase}, ()=>[]);\n      let simWorking = simInitial.slice();\n      let simDigit = 0;\n      const simMaxDigits = Math.max(...simInitial.map(n=>digitsCount(n, simBase)));\n      const actions = []; // each action: {type:'dist'|'collect', value, fromIndex?, bucket?}\n      while (true){\n        if (simDigit >= simMaxDigits) break;\n        // distribution\n        for (let i=0;i<simWorking.length;){\n          const val = simWorking[i];\n          const bidx = getDigit(val, simDigit, simBase);\n          // dist action removes simWorking[i] and pushes to bucket\n          actions.push({type:'dist', value:val, bucket:bidx});\n          simWorking.splice(i,1);\n          simBuckets[bidx].push(val);\n          // i stays (next element shifts into this index)\n        }\n        // collection\n        for (let b=0;b<simBase;b++){\n          while(simBuckets[b].length>0){\n            const val = simBuckets[b].shift();\n            actions.push({type:'collect', value:val, bucket:b});\n            simWorking.push(val);\n          }\n        }\n        simDigit++;\n      }\n      // Now actions describes the entire micro-step sequence from initial to sorted final.\n      // Find current micro-step index by comparing current state to simulated progressive states.\n      // We'll simulate again and stop when we first match the current state; then step back one action.\n      let simWorking2 = initialArray.slice();\n      let simBuckets2 = Array.from({length: simBase}, ()=>[]);\n      let matchedIndex = -1;\n      function stateEquals(){\n        if (simWorking2.length !== workingArray.length) return false;\n        for (let i=0;i<simWorking2.length;i++){\n          if (simWorking2[i] !== workingArray[i]) return false;\n        }\n        // check buckets\n        for (let b=0;b<simBase;b++){\n          if ((simBuckets2[b]||[]).length !== (buckets[b]||[]).length) return false;\n          for (let k=0;k<(simBuckets2[b]||[]).length;k++){\n            if ((simBuckets2[b]||[])[k] !== (buckets[b]||[])[k]) return false;\n          }\n        }\n        return true;\n      }\n      // iterate through actions; at step start (0) we compare too.\n      if (stateEquals()){\n        // we're at start -> nothing to go back to\n        return;\n      }\n      for (let ai=0; ai<actions.length; ai++){\n        const a = actions[ai];\n        if (a.type === 'dist'){\n          // remove first occurrence of a.value from simWorking2 at index where it's expected per simulation\n          // In our deterministic simulation, it will be found at some index; find index by matching digit at current simDigit (hard).\n          // But above actions are from a simulation; applying them sequentially will match.\n          // So we need to apply sequentially:\n          const idx = simWorking2.findIndex(x=>x===a.value);\n          if (idx >= 0) simWorking2.splice(idx,1);\n          simBuckets2[a.bucket].push(a.value);\n        } else {\n          const val = a.value;\n          simBuckets2[a.bucket].shift();\n          simWorking2.push(val);\n        }\n        if (stateEquals()){\n          matchedIndex = ai; break;\n        }\n      }\n      if (matchedIndex === -1){\n        // No match, just reset to initial\n        initialLoad();\n        return;\n      }\n      // We want to step back one action: rebuild state by applying actions up to matchedIndex-1\n      let targetWorking = initialArray.slice();\n      let targetBuckets = Array.from({length: base}, ()=>[]);\n      for (let ai=0; ai<=matchedIndex-1; ai++){\n        const a = actions[ai];\n        if (a.type === 'dist'){\n          // find first occurrence in targetWorking (deterministic)\n          const idx = targetWorking.findIndex(x=>x===a.value);\n          if (idx>=0) targetWorking.splice(idx,1);\n          targetBuckets[a.bucket].push(a.value);\n        } else {\n          targetBuckets[a.bucket].shift();\n          targetWorking.push(a.value);\n        }\n      }\n      // set state to target\n      workingArray = targetWorking;\n      buckets = targetBuckets;\n      // set appropriate digitPos and phase by approximating where we are in action sequence\n      // Count how many full distribution/collection passes have completed\n      // Quick heuristic: find how many digits fully processed by scanning how many collects occurred for full base\n      // We'll compute digitPos by simulating actions until ai <= matchedIndex-1 and tracking digit position.\n      let simW = initialArray.slice();\n      let simB = Array.from({length: base}, ()=>[]);\n      let simD = 0;\n      let idxAct = 0;\n      while (simD < 32 && idxAct <= matchedIndex-1){\n        // distribution\n        while (simW.length > 0 && idxAct <= matchedIndex-1){\n          // In actions list, we can inspect actions[idxAct] to know if next is dist or collect\n          const a = actions[idxAct];\n          if (a.type !== 'dist') break;\n          // apply\n          const idxx = simW.findIndex(x=>x===a.value);\n          if (idxx>=0) simW.splice(idxx,1);\n          simB[a.bucket].push(a.value);\n          idxAct++;\n        }\n        // check if we've already passed all distributes in this digit (depending on idxAct)\n        // if next action is collect, apply collects as long as idxAct <= matched\n        while (idxAct <= matchedIndex-1 && idxAct < actions.length && actions[idxAct].type === 'collect'){\n          const a = actions[idxAct];\n          simB[a.bucket].shift();\n          simW.push(a.value);\n          idxAct++;\n        }\n        // finished gather for this digit\n        simD++;\n      }\n      // set digitPos to simD (current next digit to process) but clamp\n      digitPos = Math.min(simD, maxDigits-1);\n      phase = (idxAct <= matchedIndex-1) ? 'collect' : 'distribute';\n      render();\n    }\n\n    function play(){\n      if (playing){\n        clearInterval(timer); timer = null; playing = false; playPause.textContent = 'Play ▶';\n      } else {\n        playing = true; playPause.textContent = 'Pause ❚❚';\n        timer = setInterval(()=>{\n          // stop when done\n          if (phase === 'done'){ play(); return; }\n          stepForwardAction();\n        }, Math.max(80, speedInput.value|0));\n      }\n    }\n\n    // Event handlers\n    function initialLoad(){\n      try{\n        showError('');\n        initialArray = parseArrayInput(arrayInput.value);\n        if (initialArray.some(v=>v < 0)) { showError(\"Negative numbers not supported.\"); return; }\n        if (initialArray.length > 80) { showError(\"Array too large for visualization (max 80).\"); return; }\n        resetState(false);\n      }catch(e){\n        showError(e.message);\n      }\n    }\n    loadBtn.addEventListener('click', initialLoad);\n    preset.addEventListener('change', ()=>{ arrayInput.value = preset.value; });\n    clearBtn.addEventListener('click', ()=>{\n      arrayInput.value = '';\n      initialLoad();\n    });\n    randomBtn.addEventListener('click', ()=>{\n      const count = Math.max(1, Math.min(40, parseInt(randCount.value,10) || 10));\n      const maxVal = Math.pow(10, Math.min(6, Math.max(1, Math.floor(Math.random()*4)+2))); // random vary\n      const arr = [];\n      for (let i=0;i<count;i++) arr.push(Math.floor(Math.random()*maxVal));\n      arrayInput.value = arr.join(',');\n      initialLoad();\n    });\n    baseInput.addEventListener('change', ()=>{ resetState(false); });\n    speedInput.addEventListener('input', ()=>{ /* live */ });\n    stepForward.addEventListener('click', ()=>{ stepForwardAction(); });\n    stepBack.addEventListener('click', ()=>{ stepBackAction(); });\n    playPause.addEventListener('click', ()=>{ play(); });\n    resetBtn.addEventListener('click', ()=>{ resetState(true); });\n\n    // initial render\n    initialLoad();\n\n    // Make sure we update UI on window focus if playing\n    window.addEventListener('blur', ()=>{ /* optionally pause on blur */ });\n\n    // Additional feature: keyboard shortcuts\n    window.addEventListener('keydown', (e)=>{\n      if (e.key === ' ') { e.preventDefault(); play(); }\n      if (e.key === 'ArrowRight') stepForwardAction();\n      if (e.key === 'ArrowLeft') stepBackAction();\n    });\n\n    // Explanatory console output (for those who open devtools)\n    console.log(\"Radix Sort (LSD) Visualizer loaded. Use the UI to interact.\");\n  })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Radix Sort"
    }
  ],
  "topic": "Radix Sort",
  "hasFSM": false,
  "hasTest": true
}