{
  "id": "be87b197-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:30.794Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Fibonacci Sequence",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Fibonacci Sequence Explorer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 18px; color: #222; }\n    h1 { margin-bottom: 6px; }\n    .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; max-width: 980px; align-items: center; }\n    .controls > div { background: #f8f9fb; padding: 12px; border-radius: 8px; border: 1px solid #e3e6ea; }\n    label { display: block; margin-bottom: 6px; font-weight: 600; }\n    input[type=\"number\"] { width: 100%; padding: 6px 8px; border-radius: 6px; border: 1px solid #ccc; }\n    .methods { display:flex; gap: 10px; flex-wrap:wrap; }\n    .methods label { font-weight: 500; }\n    button { padding: 8px 12px; border: none; background: #0b74de; color: white; border-radius: 6px; cursor: pointer; }\n    button.secondary { background: #64748b; }\n    button:active { transform: translateY(1px); }\n    .output { margin-top: 14px; display: grid; grid-template-columns: 1fr 420px; gap: 14px; align-items: start; }\n    .panel { background: #fff; border: 1px solid #e3e6ea; border-radius: 8px; padding: 12px; }\n    .sequence { max-height: 260px; overflow: auto; padding-right: 6px; font-family: monospace; white-space: pre; }\n    .stats { font-size: 14px; line-height: 1.6; }\n    canvas { width: 100%; height: 260px; background: linear-gradient(180deg,#ffffff,#fbfdff); border-radius: 6px; display:block; }\n    .small { font-size: 13px; color: #555; }\n    .hint { margin-top:8px; color:#666; font-size:13px; }\n    .bad { color: #9b1c1c; font-weight:700; }\n    .good { color: #11623a; font-weight:700; }\n    footer { margin-top: 18px; font-size: 13px; color: #666; }\n    .legend { display:flex; gap:10px; margin-bottom:8px; align-items:center; }\n    .legend span { display:inline-block; width:12px; height:12px; border-radius:2px; }\n    .ratio { color: #0b74de; }\n  </style>\n</head>\n<body>\n  <h1>Fibonacci Sequence Explorer</h1>\n  <div class=\"small\">Interactive demonstration: compute Fibonacci numbers, compare methods, visualize growth and convergence to the golden ratio (φ).</div>\n\n  <div class=\"controls\" style=\"margin-top:12px;\">\n    <div>\n      <label for=\"n\">Number of terms (n)</label>\n      <input id=\"n\" type=\"number\" min=\"1\" max=\"2000\" value=\"20\" />\n      <div style=\"display:flex; gap:8px; margin-top:8px; align-items:center;\">\n        <label style=\"font-weight:600;\"><input id=\"useBigInt\" type=\"checkbox\" /> Use BigInt for integer accuracy</label>\n        <label style=\"font-weight:600;\"><input id=\"animate\" type=\"checkbox\" /> Animate build</label>\n      </div>\n      <div style=\"margin-top:8px;\">\n        <div class=\"methods\">\n          <label><input name=\"method\" type=\"radio\" value=\"iterative\" checked /> Iterative</label>\n          <label><input name=\"method\" type=\"radio\" value=\"naive\" /> Recursive (naive)</label>\n          <label><input name=\"method\" type=\"radio\" value=\"memo\" /> Recursive (memoized)</label>\n          <label><input name=\"method\" type=\"radio\" value=\"binet\" /> Binet's formula</label>\n        </div>\n      </div>\n    </div>\n\n    <div>\n      <label>Actions</label>\n      <div style=\"display:flex; gap:8px; flex-wrap:wrap;\">\n        <button id=\"generateBtn\">Generate</button>\n        <button id=\"clearBtn\" class=\"secondary\">Clear</button>\n        <button id=\"demoBtn\">Auto demo</button>\n      </div>\n      <div class=\"hint\">Notes: naive recursion is exponentially slow and limited to small n (recommended n ≤ 40). Binet uses floating point and can lose precision for large n.</div>\n      <div style=\"margin-top:10px;\">\n        <label style=\"font-weight:600;\">Max safe Binet n (approx): <span id=\"binetLimit\">70</span></label>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"output\">\n    <div class=\"panel\">\n      <div class=\"legend\">\n        <span style=\"background:#0b74de\"></span><div style=\"font-size:13px;\">Fibonacci values (index: value)</div>\n      </div>\n      <div id=\"sequence\" class=\"sequence\" aria-live=\"polite\"></div>\n      <div style=\"margin-top:8px;\" class=\"small\">\n        <div id=\"ratios\"></div>\n      </div>\n    </div>\n\n    <div>\n      <div class=\"panel\" style=\"margin-bottom:10px;\">\n        <h3 style=\"margin:4px 0 8px 0;\">Statistics</h3>\n        <div id=\"stats\" class=\"stats\">No computation yet.</div>\n      </div>\n\n      <div class=\"panel\">\n        <h3 style=\"margin:4px 0 8px 0;\">Growth chart (log scale)</h3>\n        <canvas id=\"chart\" width=\"600\" height=\"260\"></canvas>\n        <div class=\"small\" style=\"margin-top:8px;\">Hover the chart to see values. Display uses log scale to keep visualization readable for large terms.</div>\n      </div>\n    </div>\n  </div>\n\n  <footer>\n    Built to demonstrate different Fibonacci computation techniques, timing, and how ratios converge to φ = (1 + √5)/2 ≈ 1.6180339887.\n  </footer>\n\n  <script>\n/*\n  Fibonacci Sequence Explorer\n  - Iterative (fast)\n  - Naive recursive (exponential time; limited)\n  - Memoized recursive (fast)\n  - Binet's formula (floating-point)\n  Features:\n  - Option to use BigInt for exact integer values\n  - Animated building of sequence\n  - Timing and counters for method comparison\n  - Log-scale chart visualization (canvas) with tooltip on hover\n*/\n\n(function () {\n  // DOM elements\n  const nInput = document.getElementById('n');\n  const generateBtn = document.getElementById('generateBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const demoBtn = document.getElementById('demoBtn');\n  const seqContainer = document.getElementById('sequence');\n  const statsContainer = document.getElementById('stats');\n  const chart = document.getElementById('chart');\n  const ratiosDiv = document.getElementById('ratios');\n  const useBigIntBox = document.getElementById('useBigInt');\n  const animateBox = document.getElementById('animate');\n  const binetLimitSpan = document.getElementById('binetLimit');\n\n  const ctx = chart.getContext('2d');\n  const PHI = (1 + Math.sqrt(5)) / 2;\n  const SQRT5 = Math.sqrt(5);\n\n  // safety limits\n  const NAIVE_RECURSION_LIMIT = 40;\n  const BINET_REASONABLE_LIMIT = 70; // beyond this floating inaccuracy and overflow happens\n\n  binetLimitSpan.textContent = BINET_REASONABLE_LIMIT;\n\n  // helper: format value (BigInt or Number)\n  function formatValue(v) {\n    if (typeof v === 'bigint') return v.toString();\n    // Use toLocaleString for readability for large numbers (but not too large)\n    if (Number.isFinite(v)) {\n      // Show integers without decimals; small fractions if any\n      if (Math.abs(Math.round(v) - v) < 1e-12) return Math.round(v).toLocaleString();\n      return v.toPrecision(10);\n    }\n    return String(v);\n  }\n\n  // Iterative Fibonacci (returns array of length n)\n  function iterativeFib(n, useBigInt) {\n    if (n <= 0) return [];\n    if (useBigInt) {\n      const arr = new Array(n);\n      arr[0] = 0n;\n      if (n > 1) arr[1] = 1n;\n      for (let i = 2; i < n; i++) arr[i] = arr[i-1] + arr[i-2];\n      return arr;\n    } else {\n      const arr = new Array(n);\n      arr[0] = 0;\n      if (n > 1) arr[1] = 1;\n      for (let i = 2; i < n; i++) arr[i] = arr[i-1] + arr[i-2];\n      return arr;\n    }\n  }\n\n  // Naive recursion with counter (counts function invocations)\n  function naiveRecursiveFib(n, useBigInt, counter) {\n    counter.count++;\n    if (n === 0) return useBigInt ? 0n : 0;\n    if (n === 1) return useBigInt ? 1n : 1;\n    const a = naiveRecursiveFib(n-1, useBigInt, counter);\n    const b = naiveRecursiveFib(n-2, useBigInt, counter);\n    return useBigInt ? (BigInt(a) + BigInt(b)) : (a + b);\n  }\n\n  // Memoized recursion: builds values up to n and returns array\n  function memoizedFib(n, useBigInt) {\n    const mem = {};\n    const calls = { count: 0 };\n    function f(k) {\n      calls.count++;\n      if (k in mem) return mem[k];\n      if (k === 0) return mem[k] = useBigInt ? 0n : 0;\n      if (k === 1) return mem[k] = useBigInt ? 1n : 1;\n      const a = f(k-1), b = f(k-2);\n      return mem[k] = useBigInt ? (BigInt(a) + BigInt(b)) : (a + b);\n    }\n    const arr = new Array(n);\n    for (let i = 0; i < n; i++) arr[i] = f(i);\n    return { arr, calls: calls.count };\n  }\n\n  // Binet's formula: fib(n) = round(phi^n / sqrt(5))\n  // returns array of length n\n  function binetFib(n) {\n    const arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n      // For large i, using pow may overflow to Infinity; handle carefully\n      const val = Math.round(Math.pow(PHI, i) / SQRT5);\n      arr[i] = val;\n    }\n    return arr;\n  }\n\n  // Compute ratios (F[n]/F[n-1]) for indices >=1\n  function computeRatios(fibArr) {\n    const res = [];\n    for (let i = 1; i < fibArr.length; i++) {\n      const a = fibArr[i], b = fibArr[i-1];\n      let ratio;\n      if (typeof a === 'bigint' || typeof b === 'bigint') {\n        // convert to Number for ratio (may lose precision for very big values)\n        ratio = Number(a) / Number(b);\n      } else {\n        ratio = a / b;\n      }\n      res.push(ratio);\n    }\n    return res;\n  }\n\n  // Chart drawing (log scale)\n  function drawChart(fibArr) {\n    const canvas = chart;\n    const w = canvas.width = canvas.clientWidth * devicePixelRatio;\n    const h = canvas.height = canvas.clientHeight * devicePixelRatio;\n    ctx.clearRect(0, 0, w, h);\n\n    if (!fibArr || fibArr.length === 0) {\n      ctx.fillStyle = \"#888\";\n      ctx.font = `${12 * devicePixelRatio}px sans-serif`;\n      ctx.fillText(\"No data to plot\", 10 * devicePixelRatio, 20 * devicePixelRatio);\n      return;\n    }\n\n    // Convert to numeric logs; handle BigInt by converting to Number (lossy for huge)\n    const vals = fibArr.map(v => {\n      if (typeof v === 'bigint') {\n        // convert BigInt to Number when safe; if too large, use magnitude via string length\n        const s = v.toString();\n        // approximate log10 by length\n        const log10 = Math.log10(parseFloat(s.slice(0, 15))) + (s.length - Math.min(15, s.length));\n        return { v, log: log10 * Math.LOG10E }; // not used; keep simple\n      } else {\n        return { v, log: Math.log10(Math.max(1, Math.abs(v))) };\n      }\n    });\n\n    // For simplicity use numeric log values when possible; fallback: derive from string length for BigInt\n    const logs = fibArr.map(v => {\n      if (typeof v === 'bigint') {\n        const s = v.toString();\n        // approximate log10 by number of digits - 1 plus fractional part from first digits\n        const len = s.length;\n        const head = parseFloat(s.slice(0, Math.min(15, len)));\n        const log10 = Math.log10(head) + (len - Math.min(15, len));\n        return log10;\n      } else {\n        return Math.log10(Math.max(1, Math.abs(v)));\n      }\n    });\n\n    const maxLog = Math.max(...logs);\n    const minLog = Math.min(...logs);\n\n    const padding = 32 * devicePixelRatio;\n    const chartW = w - padding * 1.2;\n    const chartH = h - padding;\n    const left = padding * 0.8;\n    const top = padding * 0.25;\n    const n = logs.length;\n    const barW = Math.max(2 * devicePixelRatio, chartW / Math.max(1, n) - 4 * devicePixelRatio);\n\n    // background grid lines\n    ctx.strokeStyle = \"#eef3fb\";\n    ctx.lineWidth = 1 * devicePixelRatio;\n    ctx.beginPath();\n    for (let i = 0; i <= 4; i++) {\n      const y = top + (chartH) * (i / 4);\n      ctx.moveTo(left, y);\n      ctx.lineTo(left + chartW, y);\n    }\n    ctx.stroke();\n\n    // bars\n    for (let i = 0; i < n; i++) {\n      const logv = logs[i];\n      // normalize: map minLog..maxLog to 0..1\n      const t = (logv - minLog) / (maxLog - minLog + 1e-12);\n      const barH = Math.max(4 * devicePixelRatio, t * chartH);\n      const x = left + i * (chartW / n) + 2 * devicePixelRatio;\n      const y = top + chartH - barH;\n      ctx.fillStyle = \"#0b74de\";\n      ctx.fillRect(x, y, barW, barH);\n    }\n\n    // axes / labels\n    ctx.fillStyle = \"#333\";\n    ctx.font = `${12 * devicePixelRatio}px sans-serif`;\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"log10 scale (approx)\", left, top - 8 * devicePixelRatio);\n\n    // x labels: show 0, mid, last\n    ctx.textAlign = \"center\";\n    ctx.fillStyle = \"#555\";\n    ctx.font = `${11 * devicePixelRatio}px sans-serif`;\n    const xs = [0, Math.floor(n/2), n-1];\n    xs.forEach(ix => {\n      const x = left + ix * (chartW / n) + barW / 2;\n      ctx.fillText(String(ix), x, top + chartH + 14 * devicePixelRatio);\n    });\n\n    // add hover tooltip handling\n    // store normalized data for quick tooltip\n    chart._plot = { left, top, chartW, chartH, barW, n, logs, fibArr };\n  }\n\n  // Chart tooltip: on mouse move, show details under stats area temporarily\n  chart.addEventListener('mousemove', function (ev) {\n    const rect = chart.getBoundingClientRect();\n    const dpr = devicePixelRatio;\n    if (!chart._plot) return;\n    const { left, top, chartW, chartH, barW, n, logs, fibArr } = chart._plot;\n    const x = (ev.clientX - rect.left) * dpr;\n    const y = (ev.clientY - rect.top) * dpr;\n    if (x < left || x > left + chartW) return;\n    const idx = Math.floor((x - left) / (chartW / n));\n    if (idx < 0 || idx >= n) return;\n\n    // prepare tooltip info\n    const value = fibArr[idx];\n    let valueStr = formatValue(value);\n    // ratio to previous\n    let ratioStr = \"—\";\n    if (idx >= 1) {\n      const a = fibArr[idx], b = fibArr[idx-1];\n      const ratio = (typeof a === 'bigint' || typeof b === 'bigint') ? (Number(a)/Number(b)) : (a/b);\n      ratioStr = ratio.toPrecision(10);\n    }\n    // temporarily show near stats\n    const old = statsContainer._oldHTML || statsContainer.innerHTML;\n    statsContainer._oldHTML = old;\n    statsContainer.innerHTML = `<strong>Index ${idx}</strong><div>${valueStr}</div><div class=\"small\">Ratio to previous: <span class=\"ratio\">${ratioStr}</span></div>`;\n  });\n\n  chart.addEventListener('mouseleave', function () {\n    // restore stats area if we changed it due to hover\n    if (statsContainer._oldHTML) {\n      statsContainer.innerHTML = statsContainer._oldHTML;\n      delete statsContainer._oldHTML;\n    }\n  });\n\n  // Build and display sequence according to chosen method\n  let animationTimer = null;\n  async function buildAndDisplay() {\n    // cancel any active animation\n    if (animationTimer) {\n      clearInterval(animationTimer); animationTimer = null;\n    }\n    const n = parseInt(nInput.value, 10);\n    if (!Number.isFinite(n) || n <= 0) {\n      alert(\"Please enter a positive integer for n.\");\n      return;\n    }\n    if (n > 2000 && useBigIntBox.checked === false) {\n      // for visualization, restrict extremely large n when not using BigInt? Not strictly required.\n    }\n\n    const method = document.querySelector('input[name=\"method\"]:checked').value;\n    const useBigInt = useBigIntBox.checked;\n    const animate = animateBox.checked;\n\n    // handle method-specific limits\n    if (method === 'naive' && n > NAIVE_RECURSION_LIMIT) {\n      if (!confirm(`Naive recursion is extremely slow for n > ${NAIVE_RECURSION_LIMIT}. Continue?`)) return;\n    }\n    if (method === 'binet' && n > BINET_REASONABLE_LIMIT) {\n      if (!confirm(`Binet's formula will lose integer precision for n > ${BINET_REASONABLE_LIMIT}. Continue?`)) return;\n    }\n\n    seqContainer.textContent = \"Computing...\";\n    ratiosDiv.textContent = \"\";\n    statsContainer.textContent = \"Working...\";\n\n    let fibArr = [];\n    let info = { method, timeMs: 0, calls: 0 };\n    const t0 = performance.now();\n\n    try {\n      if (method === 'iterative') {\n        const start = performance.now();\n        fibArr = iterativeFib(n, useBigInt);\n        info.timeMs = performance.now() - start;\n      } else if (method === 'naive') {\n        // naive recursion computes single nth term; we can compute all terms up to n by calling naive for each index (very expensive).\n        // to show the sequence we compute naive for each i from 0..n-1. Limit n in UI to small values.\n        const arr = new Array(n);\n        let calls = 0;\n        const start = performance.now();\n        for (let i = 0; i < n; i++) {\n          const counter = { count: 0 };\n          arr[i] = naiveRecursiveFib(i, useBigInt, counter);\n          calls += counter.count;\n        }\n        info.timeMs = performance.now() - start;\n        info.calls = calls;\n        fibArr = arr;\n      } else if (method === 'memo') {\n        const start = performance.now();\n        const res = memoizedFib(n, useBigInt);\n        info.timeMs = performance.now() - start;\n        info.calls = res.calls;\n        fibArr = res.arr;\n      } else if (method === 'binet') {\n        const start = performance.now();\n        fibArr = binetFib(n);\n        info.timeMs = performance.now() - start;\n      }\n    } catch (err) {\n      seqContainer.textContent = \"Error during computation: \" + err;\n      console.error(err);\n      return;\n    }\n\n    // If animate: reveal one term at a time\n    if (animate && n <= 1000) {\n      seqContainer.textContent = \"\";\n      let i = 0;\n      const interval = Math.max(20, 400 / Math.min(n, 40)); // adaptive speed\n      return new Promise(resolve => {\n        animationTimer = setInterval(() => {\n          if (i >= fibArr.length) {\n            clearInterval(animationTimer); animationTimer = null;\n            // show final stats and chart\n            displayResults(fibArr, info);\n            resolve();\n            return;\n          }\n          appendSequenceLine(i, fibArr[i]);\n          i++;\n        }, interval);\n      });\n    } else {\n      // immediate display\n      displayResults(fibArr, info);\n    }\n  }\n\n  function appendSequenceLine(i, val) {\n    const indexStr = String(i).padStart(3, ' ');\n    const line = `${indexStr}: ${formatValue(val)}\\n`;\n    seqContainer.textContent += line;\n    seqContainer.scrollTop = seqContainer.scrollHeight;\n  }\n\n  function displayResults(fibArr, info) {\n    // Display sequence text (limit how many to print for very large n)\n    const MAX_PRINT = 500;\n    seqContainer.textContent = \"\";\n    if (fibArr.length <= MAX_PRINT) {\n      fibArr.forEach((v, i) => appendSequenceLine(i, v));\n    } else {\n      // print first 20 and last 20\n      for (let i = 0; i < 20; i++) appendSequenceLine(i, fibArr[i]);\n      seqContainer.textContent += \"   ...\\n\";\n      for (let i = fibArr.length - 20; i < fibArr.length; i++) appendSequenceLine(i, fibArr[i]);\n    }\n\n    // compute ratios and show a few\n    let ratiosHTML = \"\";\n    if (fibArr.length >= 2) {\n      const ratios = computeRatios(fibArr);\n      // show last 6 ratios to indicate convergence\n      const shown = ratios.slice(Math.max(0, ratios.length - 6));\n      ratiosHTML = \"Last ratios (F[n]/F[n-1]): \" + shown.map(r => r.toFixed(10)).join(\", \");\n      // Show convergence to PHI using last ratio\n      const lastRatio = shown[shown.length - 1];\n      const diff = Math.abs(lastRatio - PHI);\n      ratiosHTML += `<div class=\"small\">Last ratio ≈ <span class=\"ratio\">${lastRatio.toPrecision(10)}</span> (difference from φ: ${diff.toExponential(3)})</div>`;\n    } else {\n      ratiosHTML = \"Ratios require at least 2 terms.\";\n    }\n    ratiosDiv.innerHTML = ratiosHTML;\n\n    // Stats\n    const methodNice = info.method === 'naive' ? 'Naive recursion' :\n                       info.method === 'memo' ? 'Memoized recursion' :\n                       info.method === 'binet' ? \"Binet's formula\" : 'Iterative';\n    let statsHTML = `<strong>Method:</strong> ${methodNice}<br>`;\n    statsHTML += `<strong>Computed terms:</strong> ${fibArr.length}<br>`;\n    statsHTML += `<strong>Time:</strong> ${info.timeMs.toFixed(3)} ms<br>`;\n    if (info.calls) statsHTML += `<strong>Function calls:</strong> ${info.calls}<br>`;\n    if (info.method === 'binet') statsHTML += `<div class=\"small\">Note: Binet uses floating point and can be inaccurate for large n.</div>`;\n    statsContainer.innerHTML = statsHTML;\n\n    // draw chart\n    drawChart(fibArr);\n  }\n\n  // Event handlers\n  generateBtn.addEventListener('click', buildAndDisplay);\n  clearBtn.addEventListener('click', function () {\n    seqContainer.textContent = \"\";\n    ratiosDiv.textContent = \"\";\n    statsContainer.textContent = \"Cleared.\";\n    ctx.clearRect(0,0,chart.width,chart.height);\n  });\n\n  // Demo: run increasing n values automatically to show growth & performance\n  demoBtn.addEventListener('click', async function () {\n    const originalN = parseInt(nInput.value, 10);\n    const methodSaved = document.querySelector('input[name=\"method\"]:checked').value;\n    const useBigIntSaved = useBigIntBox.checked;\n    // cycle through small to moderate n\n    const demoNs = [5, 8, 12, 16, 20, 30];\n    // If method is naive and demo includes large n, limit\n    for (const m of demoNs) {\n      nInput.value = m;\n      await buildAndDisplay();\n      // wait 700ms between steps\n      await new Promise(r => setTimeout(r, 700));\n    }\n    // restore\n    nInput.value = originalN;\n    document.querySelector(`input[name=\"method\"][value=\"${methodSaved}\"]`).checked = true;\n    useBigIntBox.checked = useBigIntSaved;\n  });\n\n  // Initialize chart empty\n  drawChart([]);\n\n  // Prettify enter key in n input to trigger generate\n  nInput.addEventListener('keydown', function (e) {\n    if (e.key === 'Enter') { buildAndDisplay(); }\n  });\n})();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Fibonacci Sequence"
    }
  ],
  "topic": "Fibonacci Sequence",
  "hasFSM": false,
  "hasTest": true
}