{
  "id": "be87b190-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:45.895Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\"/>\n  <title>Breadth-First Search (BFS) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n  <style>\n    :root {\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --muted: #94a3b8;\n      --accent: #60a5fa;\n      --good: #22c55e;\n      --bad: #ef4444;\n      --node-fill: #152238;\n      --edge: rgba(255,255,255,0.08);\n      --visited: #2563eb;\n      --discovered: #f59e0b;\n      --current: #fb923c;\n      --path: #16a34a;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background: linear-gradient(180deg,#071126 0%, #071026 100%);\n      color:#e6eef8;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app {\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      padding:14px;\n      max-width:1200px;\n      margin:12px auto;\n    }\n    header {\n      display:flex;\n      align-items:center;\n      gap:12px;\n    }\n    h1 {\n      font-size:20px;\n      margin:0;\n      letter-spacing:0.2px;\n    }\n    .controls {\n      display:flex;\n      gap:10px;\n      flex-wrap:wrap;\n      align-items:center;\n      background: linear-gradient(180deg,#081225 0%, #071122 100%);\n      padding:10px;\n      border-radius:10px;\n      box-shadow: 0 2px 8px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);\n    }\n    .controls > * { margin:0 2px; }\n    label { font-size:13px; color:var(--muted); display:flex; gap:6px; align-items:center; }\n    input[type=\"range\"] { width:120px; }\n    button, select {\n      background:#0b1220;\n      color:#e6eef8;\n      border:1px solid rgba(255,255,255,0.04);\n      padding:6px 8px;\n      border-radius:7px;\n      cursor:pointer;\n      font-size:13px;\n    }\n    button.primary {\n      background: linear-gradient(90deg, #2563eb, #60a5fa);\n      color:white;\n      border:0;\n      box-shadow: 0 6px 18px rgba(96,165,250,0.14);\n    }\n    button.ghost {\n      background:transparent;\n      border:1px dashed rgba(255,255,255,0.04);\n    }\n    .main {\n      display:flex;\n      gap:12px;\n    }\n    .canvas-panel {\n      background: linear-gradient(180deg,#081228 0%, #071022 100%);\n      flex:1;\n      padding:10px;\n      border-radius:10px;\n      min-height:560px;\n      position:relative;\n      display:flex;\n      flex-direction:column;\n    }\n    .svg-wrap {\n      flex:1;\n      border-radius:8px;\n      background: linear-gradient(180deg,#061024 0%, #061023 100%);\n      overflow:hidden;\n      display:flex;\n      align-items:stretch;\n      justify-content:stretch;\n    }\n    svg { width:100%; height:100%; display:block; }\n    .side {\n      width:360px;\n      min-width:260px;\n      background: linear-gradient(180deg,#061026 0%, #05101a 100%);\n      border-radius:10px;\n      padding:10px;\n    }\n    .panel-section {\n      margin-bottom:10px;\n      background: linear-gradient(180deg,#071328 0%, #061022 100%);\n      padding:8px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .panel-section h3 {\n      margin:0 0 8px 0;\n      font-size:14px;\n      color:#cfe6ff;\n    }\n    .info {\n      font-size:13px;\n      color:var(--muted);\n      line-height:1.35;\n    }\n    .controls-row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n    .legend { display:flex; gap:8px; flex-wrap:wrap; }\n    .legend-item { display:flex; gap:8px; align-items:center; font-size:13px; color:var(--muted); }\n    .swatch { width:14px; height:14px; border-radius:4px; border:1px solid rgba(255,255,255,0.04); box-shadow: inset 0 -2px 3px rgba(0,0,0,0.4); }\n    .status { display:flex; gap:8px; align-items:center; font-size:13px; color:var(--muted); }\n    .lists { display:flex; gap:8px; }\n    .list-box { flex:1; background: rgba(255,255,255,0.02); padding:8px; border-radius:6px; font-size:13px; color:var(--muted); min-height:44px; max-height:220px; overflow:auto; }\n    .list-title { font-size:12px; color:#cfe6ff; margin-bottom:6px; }\n    .node-label { font-size:12px; color:#cfe6ff; background:rgba(255,255,255,0.02); padding:4px 6px; border-radius:6px; display:inline-block; margin: 2px; }\n    .footer-note { font-size:12px; color:var(--muted); margin-top:8px; }\n    .small { font-size:12px; color:var(--muted); }\n    .mode-toggle { display:flex; gap:6px; }\n    .mode-toggle button.active { outline:2px solid rgba(96,165,250,0.18); }\n    .btn-icon { display:inline-flex; align-items:center; gap:6px; }\n    @media (max-width:980px){\n      .main { flex-direction:column; }\n      .side { width:100%; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <header>\n      <h1>Breadth-First Search (BFS) Visualizer</h1>\n    </header>\n\n    <div class=\"controls\">\n      <div class=\"controls-row\">\n        <label>\n          Graph type:\n          <select id=\"graphType\">\n            <option value=\"random\">Random Graph</option>\n            <option value=\"grid\">Grid</option>\n          </select>\n        </label>\n\n        <label id=\"nodesLabel\">\n          Nodes:\n          <input id=\"nodeCount\" type=\"number\" value=\"16\" min=\"4\" max=\"200\" style=\"width:70px;\">\n        </label>\n\n        <label id=\"probLabel\">\n          Edge p:\n          <input id=\"edgeProb\" type=\"range\" min=\"0\" max=\"1\" step=\"0.01\" value=\"0.16\">\n          <span id=\"probVal\" class=\"small\">0.16</span>\n        </label>\n\n        <label id=\"gridSizeLabel\" style=\"display:none;\">\n          Grid:\n          <input id=\"gridRows\" type=\"number\" min=\"2\" max=\"30\" value=\"4\" style=\"width:60px;\"> x\n          <input id=\"gridCols\" type=\"number\" min=\"2\" max=\"30\" value=\"4\" style=\"width:60px;\">\n        </label>\n\n        <label>\n          Undirected:\n          <input id=\"undirected\" type=\"checkbox\" checked>\n        </label>\n\n        <button id=\"regen\" title=\"Regenerate graph\">Regenerate</button>\n        <button id=\"reset\" class=\"ghost\" title=\"Reset algorithm state\">Reset BFS</button>\n        <button id=\"autoPlay\" class=\"primary\">Auto-play</button>\n        <button id=\"stepBtn\">Step</button>\n        <label>\n          Speed:\n          <input id=\"speed\" type=\"range\" min=\"50\" max=\"1200\" step=\"10\" value=\"500\">\n        </label>\n      </div>\n\n      <div style=\"display:flex; gap:10px; align-items:center; margin-left:6px;\">\n        <div class=\"mode-toggle\">\n          <button id=\"setStartBtn\" class=\"active\">Set Start</button>\n          <button id=\"setTargetBtn\">Set Target</button>\n          <button id=\"clearMarks\" class=\"ghost\">Clear Start/Target</button>\n        </div>\n        <div style=\"margin-left:8px; font-size:13px; color:var(--muted);\">\n          Click a node to set.\n        </div>\n      </div>\n    </div>\n\n    <div class=\"main\">\n      <div class=\"canvas-panel\">\n        <div style=\"display:flex; gap:10px; align-items:center; margin-bottom:8px;\">\n          <div class=\"status\">\n            <div class=\"small\">Mode: <span id=\"modeText\">Set Start</span></div>\n          </div>\n          <div style=\"flex:1\"></div>\n          <div class=\"legend\">\n            <div class=\"legend-item\"><div class=\"swatch\" style=\"background:var(--node-fill);\"></div><div class=\"small\">Unvisited</div></div>\n            <div class=\"legend-item\"><div class=\"swatch\" style=\"background:var(--discovered);\"></div><div class=\"small\">Discovered (in queue)</div></div>\n            <div class=\"legend-item\"><div class=\"swatch\" style=\"background:var(--visited);\"></div><div class=\"small\">Visited</div></div>\n            <div class=\"legend-item\"><div class=\"swatch\" style=\"background:var(--current);\"></div><div class=\"small\">Currently exploring</div></div>\n            <div class=\"legend-item\"><div class=\"swatch\" style=\"background:var(--path);\"></div><div class=\"small\">Shortest path</div></div>\n          </div>\n        </div>\n\n        <div class=\"svg-wrap\" id=\"svgWrap\">\n          <svg id=\"svg\" viewBox=\"0 0 800 560\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n        </div>\n\n        <div class=\"footer-note\">Tip: Choose start and target nodes, then use Step or Auto-play to see how BFS discovers nodes level-by-level and finds the shortest path (in unweighted graphs).</div>\n      </div>\n\n      <aside class=\"side\">\n        <div class=\"panel-section\">\n          <h3>Algorithm Status</h3>\n          <div class=\"info\" id=\"statusText\">Ready. Click nodes to choose start and target. Press \"Auto-play\" or \"Step\" to run BFS.</div>\n        </div>\n\n        <div class=\"panel-section\">\n          <h3>Queue</h3>\n          <div class=\"list-box\" id=\"queueBox\">\n            <div class=\"small\">Queue is empty.</div>\n          </div>\n        </div>\n\n        <div class=\"panel-section\">\n          <h3>Visited Order</h3>\n          <div class=\"list-box\" id=\"visitedBox\">\n            <div class=\"small\">No nodes visited yet.</div>\n          </div>\n        </div>\n\n        <div class=\"panel-section\">\n          <h3>Controls & Tips</h3>\n          <div class=\"info\">\n            - Graph type: Random (Erdos-Renyi) or Grid.<br>\n            - For random graphs, set number of nodes and edge probability.<br>\n            - For grid, choose rows x cols; BFS respects grid adjacency.<br>\n            - Click \"Set Start\" then a node to choose the source. Then \"Set Target\" and choose the goal.<br>\n            - Use Step to move one BFS operation at a time, or Auto-play to animate.<br>\n            - BFS finds the shortest path (fewest edges) in unweighted graphs when a target is set.\n          </div>\n        </div>\n\n      </aside>\n    </div>\n  </div>\n\n<script>\n/* BFS Visualizer\n   - Single-file app\n   - Supports random graphs and grid graphs\n   - Step-by-step BFS animation with queue display and path reconstruction\n*/\n\n// Utility\nfunction $(id){ return document.getElementById(id); }\nconst svg = $(\"svg\");\nconst svgNS = \"http://www.w3.org/2000/svg\";\n\nlet state = {\n  nodes: [], // {id,x,y,status,parent,neighbors:[]}\n  edges: [], // {a,b}\n  width: 800, height:560,\n  undirected: true,\n  graphType: 'random',\n  nodeCount: 16,\n  edgeProb: 0.16,\n  gridRows: 4,\n  gridCols: 4,\n  start: null,\n  target: null,\n  mode: 'start', // or 'target'\n  bfs: null, // generator\n  auto: false,\n  intervalId: null,\n  speed: 500,\n};\n\n// Colors\nconst COLORS = {\n  unvisited: '#152238',\n  edge: 'rgba(255,255,255,0.08)',\n  discovered: '#f59e0b',\n  visited: '#2563eb',\n  current: '#fb923c',\n  path: '#16a34a',\n  startStroke: '#0ef09a',\n  targetStroke: '#ff6b6b'\n};\n\n// DOM elements\nconst graphType = $(\"graphType\");\nconst nodeCountInput = $(\"nodeCount\");\nconst edgeProb = $(\"edgeProb\");\nconst probVal = $(\"probVal\");\nconst regenBtn = $(\"regen\");\nconst resetBtn = $(\"reset\");\nconst autoBtn = $(\"autoPlay\");\nconst stepBtn = $(\"stepBtn\");\nconst setStartBtn = $(\"setStartBtn\");\nconst setTargetBtn = $(\"setTargetBtn\");\nconst clearMarksBtn = $(\"clearMarks\");\nconst modeText = $(\"modeText\");\nconst queueBox = $(\"queueBox\");\nconst visitedBox = $(\"visitedBox\");\nconst statusText = $(\"statusText\");\nconst undirectedChk = $(\"undirected\");\nconst graphTypeSel = $(\"graphType\");\nconst gridSizeLabel = $(\"gridSizeLabel\");\nconst gridRowsInput = $(\"gridRows\");\nconst gridColsInput = $(\"gridCols\");\nconst nodesLabel = $(\"nodesLabel\");\nconst probLabel = $(\"probLabel\");\nconst speedInput = $(\"speed\");\n\nfunction randId(prefix='n') {\n  return prefix + Math.random().toString(36).slice(2,9);\n}\n\n// Setup UI events\ngraphTypeSel.addEventListener('change', e=>{\n  state.graphType = e.target.value;\n  updateControlsVis();\n});\nnodeCountInput.addEventListener('change', e=>{\n  const val = Math.max(4, Math.min(200, parseInt(e.target.value) || 16));\n  state.nodeCount = val;\n  nodeCountInput.value = val;\n});\nedgeProb.addEventListener('input', e=>{\n  state.edgeProb = parseFloat(e.target.value);\n  probVal.textContent = state.edgeProb.toFixed(2);\n});\nundirectedChk.addEventListener('change', e=>{\n  state.undirected = e.target.checked;\n});\ngridRowsInput.addEventListener('change', e=>{\n  const v = Math.max(2, Math.min(30, parseInt(e.target.value)||4));\n  gridRowsInput.value = v;\n  state.gridRows = v;\n});\ngridColsInput.addEventListener('change', e=>{\n  const v = Math.max(2, Math.min(30, parseInt(e.target.value)||4));\n  gridColsInput.value = v;\n  state.gridCols = v;\n});\nregenBtn.addEventListener('click', ()=>{ stopAuto(); generateGraph(); resetBFS(); render(); });\nresetBtn.addEventListener('click', ()=>{ resetBFS(); render(); });\nautoBtn.addEventListener('click', toggleAuto);\nstepBtn.addEventListener('click', ()=>{ stepBFS(); });\n\nsetStartBtn.addEventListener('click', ()=>{ setMode('start'); });\nsetTargetBtn.addEventListener('click', ()=>{ setMode('target'); });\nclearMarksBtn.addEventListener('click', ()=>{ state.start=null; state.target=null; resetBFS(); render(); });\n\nspeedInput.addEventListener('input', ()=>{ state.speed = parseInt(speedInput.value); if(state.auto){ stopAuto(); startAuto(); } });\n\nfunction updateControlsVis(){\n  if(state.graphType === 'grid'){\n    gridSizeLabel.style.display = 'inline-flex';\n    nodesLabel.style.display = 'none';\n    probLabel.style.display = 'none';\n  } else {\n    gridSizeLabel.style.display = 'none';\n    nodesLabel.style.display = 'inline-flex';\n    probLabel.style.display = 'inline-flex';\n  }\n}\nupdateControlsVis();\n\nfunction setMode(m){\n  state.mode = m;\n  modeText.textContent = (m==='start')? 'Set Start' : 'Set Target';\n  setStartBtn.classList.toggle('active', m==='start');\n  setTargetBtn.classList.toggle('active', m==='target');\n}\n\n// Graph generation\nfunction generateGraph(){\n  state.nodes = [];\n  state.edges = [];\n  state.start = null;\n  state.target = null;\n  if(state.graphType === 'grid'){\n    const rows = state.gridRows;\n    const cols = state.gridCols;\n    const total = rows*cols;\n    state.nodeCount = total;\n    const margin=24;\n    const w = state.width - margin*2;\n    const h = state.height - margin*2;\n    for(let r=0;r<rows;r++){\n      for(let c=0;c<cols;c++){\n        const id = r*cols + c;\n        const x = margin + (c + 0.5)*(w/cols);\n        const y = margin + (r + 0.5)*(h/rows);\n        state.nodes.push({id:id.toString(), x,y, neighbors:[], status:'unvisited', parent:null});\n      }\n    }\n    // neighbors: 4-directional\n    for(let r=0;r<rows;r++){\n      for(let c=0;c<cols;c++){\n        const i = r*cols + c;\n        const node = state.nodes[i];\n        const deltas = [[0,1],[1,0],[0,-1],[-1,0]]; // 4-neigh\n        deltas.forEach(d=>{\n          const nr = r + d[0], nc = c + d[1];\n          if(nr>=0 && nr<rows && nc>=0 && nc<cols){\n            const j = nr*cols + nc;\n            node.neighbors.push(state.nodes[j].id);\n            state.edges.push({a: node.id, b: state.nodes[j].id});\n          }\n        });\n      }\n    }\n    // For undirected grid we'll have duplicate edges; de-duplicate edges below.\n  } else {\n    // Random graph Erdos-Renyi G(n,p)\n    const n = state.nodeCount;\n    const margin=24;\n    const w = state.width - margin*2;\n    const h = state.height - margin*2;\n    for(let i=0;i<n;i++){\n      const id = i.toString();\n      const x = margin + Math.random()*w;\n      const y = margin + Math.random()*h;\n      state.nodes.push({id, x,y, neighbors:[], status:'unvisited', parent:null});\n    }\n    for(let i=0;i<n;i++){\n      for(let j=i+1;j<n;j++){\n        if(Math.random() < state.edgeProb){\n          const a = state.nodes[i].id, b = state.nodes[j].id;\n          state.nodes[i].neighbors.push(b);\n          if(state.undirected) state.nodes[j].neighbors.push(a);\n          state.edges.push({a,b});\n          if(state.undirected) state.edges.push({a:b, b:a}); // We'll de-dupe later visually\n          // For directed graphs, only one direction\n        }\n      }\n    }\n  }\n\n  // If undirected, ensure neighbors symmetric and de-duplicate edges array for rendering\n  if(state.undirected){\n    const edgeset = new Set();\n    const edgestoRender = [];\n    state.nodes.forEach(n=>{\n      n.neighbors.forEach(nb=>{\n        const key = [n.id, nb].sort().join('|');\n        if(!edgeset.has(key)){\n          edgeset.add(key);\n          edgestoRender.push({a:n.id, b:nb});\n        }\n      });\n    });\n    state.edges = edgestoRender;\n    // symmetrize neighbors\n    const neighborMap = {};\n    state.nodes.forEach(n=> neighborMap[n.id]=new Set(n.neighbors));\n    state.nodes.forEach(n=>{\n      state.nodes.forEach(m=>{\n        // ensure if a->b or b->a exists both have each other\n      });\n    });\n    // Actually, ensure for each edge in edgestoRender both nodes include each other\n    edgestoRender.forEach(e=>{\n      const a = e.a, b = e.b;\n      const na = state.nodes.find(x=>x.id===a);\n      const nb = state.nodes.find(x=>x.id===b);\n      if(na && nb){\n        if(!na.neighbors.includes(b)) na.neighbors.push(b);\n        if(!nb.neighbors.includes(a)) nb.neighbors.push(a);\n      }\n    });\n  } else {\n    // For directed graphs, edges array is fine (we'll keep single direction)\n    // But ensure state.edges unique\n    const uniq = {};\n    const ed = [];\n    state.edges.forEach(e=>{\n      const key = e.a + '->' + e.b;\n      if(!uniq[key]){ uniq[key]=true; ed.push(e); }\n    });\n    state.edges = ed;\n  }\n\n  // initialize statuses\n  state.nodes.forEach(n=>{ n.status='unvisited'; n.parent=null; });\n}\n\n// Rendering\nfunction clearSVG(){\n  while(svg.firstChild) svg.removeChild(svg.firstChild);\n}\nfunction render(){\n  clearSVG();\n  // edges\n  const edgeGroup = document.createElementNS(svgNS, 'g');\n  edgeGroup.setAttribute('class','edges');\n  svg.appendChild(edgeGroup);\n  state.edges.forEach(e=>{\n    const na = state.nodes.find(n=>n.id===e.a);\n    const nb = state.nodes.find(n=>n.id===e.b);\n    if(!na || !nb) return;\n    const line = document.createElementNS(svgNS, 'line');\n    line.setAttribute('x1', na.x);\n    line.setAttribute('y1', na.y);\n    line.setAttribute('x2', nb.x);\n    line.setAttribute('y2', nb.y);\n    line.setAttribute('stroke', COLORS.edge);\n    line.setAttribute('stroke-width','2');\n    edgeGroup.appendChild(line);\n  });\n\n  // nodes\n  const nodeGroup = document.createElementNS(svgNS, 'g');\n  nodeGroup.setAttribute('class','nodes');\n  svg.appendChild(nodeGroup);\n  state.nodes.forEach(n=>{\n    const g = document.createElementNS(svgNS,'g');\n    g.setAttribute('transform', `translate(${n.x},${n.y})`);\n    g.style.cursor='pointer';\n    g.addEventListener('click', (ev)=>{ onNodeClick(n.id); ev.stopPropagation(); });\n\n    // circle\n    const circle = document.createElementNS(svgNS,'circle');\n    circle.setAttribute('r', 18);\n    circle.setAttribute('fill', getNodeFill(n));\n    circle.setAttribute('stroke', '#0b1220');\n    circle.setAttribute('stroke-width','2');\n    circle.setAttribute('data-id', n.id);\n    g.appendChild(circle);\n\n    // stroke for start/target\n    if(state.start === n.id || state.target === n.id){\n      const stroke = document.createElementNS(svgNS,'circle');\n      stroke.setAttribute('r', 24);\n      stroke.setAttribute('fill','none');\n      stroke.setAttribute('stroke-width','3');\n      stroke.setAttribute('stroke', state.start===n.id ? COLORS.startStroke : COLORS.targetStroke);\n      stroke.setAttribute('opacity','0.92');\n      g.insertBefore(stroke, circle);\n    }\n\n    // text\n    const txt = document.createElementNS(svgNS,'text');\n    txt.setAttribute('x',0); txt.setAttribute('y',6);\n    txt.setAttribute('font-size','12');\n    txt.setAttribute('text-anchor','middle');\n    txt.setAttribute('fill','#e6eef8');\n    txt.style.pointerEvents='none';\n    txt.textContent = n.id;\n    g.appendChild(txt);\n\n    nodeGroup.appendChild(g);\n    // attach element to node for updates\n    n._el = g;\n    n._circle = circle;\n  });\n\n  updateStatusUI();\n  updateQueueVisitedUI();\n}\n\nfunction getNodeFill(n){\n  if(n.status === 'current') return COLORS.current;\n  if(n.status === 'visited') return COLORS.visited;\n  if(n.status === 'discovered') return COLORS.discovered;\n  if(n.status === 'path') return COLORS.path;\n  return COLORS.unvisited;\n}\n\n// Node click handling\nfunction onNodeClick(id){\n  if(state.mode === 'start'){\n    state.start = id;\n    resetBFS(); // reset when changing start\n    statusText.textContent = `Start set to node ${id}. Choose a target (optional) or run BFS.`;\n  } else {\n    state.target = id;\n    resetBFS();\n    statusText.textContent = `Target set to node ${id}. Run BFS to find shortest path.`;\n  }\n  render();\n}\n\n// BFS implementation (step generator)\nfunction createBFSGenerator(){\n  // Ensure start exists\n  if(state.start == null){\n    statusText.textContent = 'Please select a start node before running BFS.';\n    return null;\n  }\n  // Reset statuses/parents\n  state.nodes.forEach(n=>{ n.status='unvisited'; n.parent=null; });\n\n  const nodeMap = {};\n  state.nodes.forEach(n=> nodeMap[n.id] = n);\n\n  let queue = [];\n  const visitedOrder = [];\n  // Enqueue start\n  queue.push(state.start);\n  nodeMap[state.start].status = 'discovered';\n  yieldUpdateUI(queue, visitedOrder, `Enqueued start ${state.start}.`);\n\n  let current = null;\n  // We'll implement a generator that yields after meaningful micro-steps:\n  // - Start: enqueue start (done)\n  // - Loop: dequeue current -> mark current 'current', yield\n  // - For each neighbor: check, if unvisited -> set parent, mark discovered, enqueue -> yield each discovery\n  // - After neighbors done -> mark visited, push to visitedOrder -> yield\n  // - If target found, reconstruct path, mark nodes path -> yield and finish.\n  const gen = (function* (){\n    while(queue.length > 0){\n      const u = queue.shift();\n      current = u;\n      nodeMap[u].status = 'current';\n      yield {type:'dequeue', node:u, queue:queue.slice(), visited:visitedOrder.slice(), msg:`Dequeued ${u} for exploration.`};\n\n      const neighs = nodeMap[u].neighbors.slice(); // copy\n      for(let nb of neighs){\n        yield {type:'check', node:u, neighbor:nb, queue:queue.slice(), visited:visitedOrder.slice(), msg:`Checking neighbor ${nb} of ${u}.`};\n        if(nodeMap[nb].status === 'unvisited'){\n          nodeMap[nb].parent = u;\n          nodeMap[nb].status = 'discovered';\n          queue.push(nb);\n          yield {type:'discover', node:nb, parent:u, queue:queue.slice(), visited:visitedOrder.slice(), msg:`Discovered ${nb}, parent=${u}. Enqueued ${nb}.`};\n        } else {\n          yield {type:'skip', node:nb, reason: nodeMap[nb].status, queue:queue.slice(), visited:visitedOrder.slice(), msg:`Skipped ${nb} (${nodeMap[nb].status}).`};\n        }\n        // If target is set and discovered, can early-stop when we dequeue target or when discovered? BFS gives shortest when you dequeue? Actually shortest path can be reconstructed when discovered because BFS explores in increasing depth, but to be safe we can stop when discovered if wanting shortest path; commonly we stop when dequeuing target, but discovered is sufficient for unweighted. We'll stop when discovered or dequeued either is fine.\n        if(state.target != null && nodeMap[nb].id === state.target && nodeMap[nb].status === 'discovered'){\n          // reconstruct path\n          yield {type:'found', node: nb, queue: queue.slice(), visited: visitedOrder.slice(), msg:`Target ${state.target} discovered. Reconstructing path.`};\n          // mark path\n          let cur = nodeMap[nb];\n          const path = [];\n          while(cur){\n            path.push(cur.id);\n            if(cur.parent == null) break;\n            cur = nodeMap[cur.parent];\n          }\n          path.reverse();\n          path.forEach(pid=>{\n            nodeMap[pid].status = 'path';\n            yield {type:'markPath', path: path.slice(), msg:`Marking path: ${path.join(' -> ')}`};\n          });\n          yield {type:'done', result:'found', path, msg:`Shortest path found: ${path.join(' -> ')}`};\n          return;\n        }\n      }\n\n      // finished with u\n      nodeMap[u].status = 'visited';\n      visitedOrder.push(u);\n      yield {type:'finish', node:u, queue:queue.slice(), visited:visitedOrder.slice(), msg:`Finished exploring ${u}. Marked visited.`};\n    }\n    // queue empty\n    yield {type:'done', result:'exhausted', msg:'Queue exhausted. Target not found.'};\n  });\n\n  return gen;\n}\n\n// Step and Animation control\nfunction resetBFS(){\n  // stop auto\n  stopAuto();\n  // clear generator\n  state.bfs = null;\n  // reset node statuses to unvisited unless path statuses remain? Clear all\n  state.nodes.forEach(n=>{ n.status='unvisited'; n.parent=null; });\n  updateQueueVisitedUI();\n  statusText.textContent = 'BFS reset. Ready.';\n}\n\nfunction stepBFS(){\n  if(state.bfs == null){\n    state.bfs = createBFSGenerator();\n    if(state.bfs == null) return;\n  }\n  const res = state.bfs.next();\n  if(res.done){\n    // nothing\n    state.bfs = null;\n    render();\n    return;\n  }\n  const payload = res.value;\n  handleBfsStep(payload);\n  render(); // update visuals\n  if(payload.type === 'done'){\n    state.bfs = null;\n    if(payload.result === 'found'){\n      statusText.textContent = `Target found. Shortest path: ${payload.path.join(' -> ')}`;\n    } else {\n      statusText.textContent = 'Search complete. Target not found.';\n    }\n    updateQueueVisitedUI();\n  }\n}\n\nfunction handleBfsStep(p){\n  // p may include type: dequeue, check, discover, skip, finish, found, markPath, done\n  // Update node statuses accordingly\n  const nodeMap = {};\n  state.nodes.forEach(n=>nodeMap[n.id]=n);\n  switch(p.type){\n    case 'dequeue':\n      // mark current node\n      // reset other 'current' status\n      state.nodes.forEach(n=>{ if(n.status === 'current') n.status='visited'; });\n      if(nodeMap[p.node]) nodeMap[p.node].status='current';\n      statusText.textContent = p.msg;\n      updateQueueVisitedUI(p.queue, p.visited);\n      break;\n    case 'check':\n      statusText.textContent = p.msg;\n      updateQueueVisitedUI(p.queue, p.visited);\n      break;\n    case 'discover':\n      if(nodeMap[p.node]) nodeMap[p.node].status='discovered';\n      if(nodeMap[p.node]) nodeMap[p.node].parent = p.parent;\n      statusText.textContent = p.msg;\n      updateQueueVisitedUI(p.queue, p.visited);\n      break;\n    case 'skip':\n      statusText.textContent = p.msg;\n      updateQueueVisitedUI(p.queue, p.visited);\n      break;\n    case 'finish':\n      if(nodeMap[p.node]) nodeMap[p.node].status='visited';\n      statusText.textContent = p.msg;\n      updateQueueVisitedUI(p.queue, p.visited);\n      break;\n    case 'found':\n      statusText.textContent = p.msg;\n      updateQueueVisitedUI(p.queue, p.visited);\n      break;\n    case 'markPath':\n      // mark path nodes as 'path'\n      p.path.forEach(id=>{\n        if(nodeMap[id]) nodeMap[id].status = 'path';\n      });\n      statusText.textContent = p.msg;\n      updateQueueVisitedUI(p.queue, p.visited);\n      break;\n    case 'done':\n      statusText.textContent = p.msg;\n      updateQueueVisitedUI();\n      break;\n  }\n}\n\nfunction updateQueueVisitedUI(queue=[], visited=[]){\n  // If called with no args, infer from generator internal snapshot by scanning nodes statuses? We maintain queue via payloads,\n  // but we can also show discovered nodes that are not visited and not current as queue approximate.\n  if(queue.length === 0){\n    // compute queue by listing discovered nodes that are not visited or path or current, but order unknown. We'll list discovered.\n    queue = state.nodes.filter(n=>n.status === 'discovered').map(n=>n.id);\n  }\n  queueBox.innerHTML = '';\n  if(queue.length === 0){\n    queueBox.innerHTML = '<div class=\"small\">Queue is empty.</div>';\n  } else {\n    queue.forEach((id,i)=>{\n      const e = document.createElement('div');\n      e.className = 'node-label';\n      e.textContent = id;\n      queueBox.appendChild(e);\n    });\n  }\n  visitedBox.innerHTML = '';\n  const visitedNodes = visited && visited.length>0 ? visited : state.nodes.filter(n=> n.status === 'visited' || n.status==='path').map(n=>n.id);\n  if(visitedNodes.length === 0){\n    visitedBox.innerHTML = '<div class=\"small\">No nodes visited yet.</div>';\n  } else {\n    visitedNodes.forEach(id=>{\n      const e = document.createElement('div');\n      e.className = 'node-label';\n      e.textContent = id;\n      visitedBox.appendChild(e);\n    });\n  }\n}\n\n// Auto-play management\nfunction startAuto(){\n  if(state.auto) return;\n  state.auto = true;\n  autoBtn.textContent = 'Stop';\n  autoBtn.classList.add('primary');\n  state.intervalId = setInterval(()=>{\n    // step\n    if(state.bfs == null){\n      state.bfs = createBFSGenerator();\n      if(state.bfs == null){\n        stopAuto();\n        return;\n      }\n    }\n    const res = state.bfs.next();\n    if(res.done){\n      state.bfs = null;\n      stopAuto();\n      render();\n      return;\n    }\n    handleBfsStep(res.value);\n    render();\n    if(res.value.type === 'done'){\n      state.bfs = null;\n      stopAuto();\n    }\n  }, state.speed);\n}\nfunction stopAuto(){\n  state.auto = false;\n  autoBtn.textContent = 'Auto-play';\n  autoBtn.classList.remove('primary');\n  if(state.intervalId) { clearInterval(state.intervalId); state.intervalId = null; }\n}\nfunction toggleAuto(){\n  if(state.auto) stopAuto();\n  else startAuto();\n}\n\n// Initial setup & click outside to deselect mode?\nsvg.addEventListener('click', ()=>{ /* clicking background does nothing*/ });\n\n// Initialize and render\nfunction init(){\n  // set initial state from controls\n  state.graphType = graphTypeSel.value;\n  state.nodeCount = parseInt(nodeCountInput.value) || 16;\n  state.edgeProb = parseFloat(edgeProb.value);\n  state.undirected = undirectedChk.checked;\n  state.gridRows = parseInt(gridRowsInput.value) || 4;\n  state.gridCols = parseInt(gridColsInput.value) || 4;\n  state.speed = parseInt(speedInput.value) || 500;\n\n  generateGraph();\n  resetBFS();\n  render();\n}\n\ninit();\n\n/* Make UI responsive to window resize: recalc svg viewBox? We'll keep viewBox static; nodes use absolute coords within 800x560. */\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": false,
  "hasTest": true
}