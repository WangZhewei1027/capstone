{
  "id": "2bddf563-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:55.312Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Hash Map",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Hash Map (Hash Table) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#2dd4bf;\n      --muted:#94a3b8;\n      --card:#071022;\n      --danger:#fb7185;\n      --success:#86efac;\n      --glass: rgba(255,255,255,0.02);\n    }\n    html,body{height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",\"Noto Sans\",Arial,\"Apple Color Emoji\",\"Segoe UI Emoji\"; background:linear-gradient(180deg,#071024 0%, #071129 50%, #041420 100%); color:#e6eef6;}\n    .app{display:flex; gap:16px; padding:20px; box-sizing:border-box; min-height:100vh;}\n    .side{\n      width:340px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n      border:1px solid rgba(255,255,255,0.03);\n      padding:18px;\n      border-radius:10px;\n      box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n    }\n    h1{font-size:18px; margin:0 0 8px 0; color:var(--accent);}\n    p.lead{margin:0 0 14px 0; color:var(--muted); font-size:13px;}\n    label{display:block; font-size:13px; color:var(--muted); margin-top:10px;}\n    input[type=\"text\"], input[type=\"number\"], select{\n      width:100%; padding:8px 10px; margin-top:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:var(--glass); color:#dff9f0; box-sizing:border-box;\n    }\n    button, .btn{\n      margin-top:8px; padding:8px 10px; border-radius:6px; border:0; background:var(--accent); color:#032025; cursor:pointer; font-weight:600;\n    }\n    .btn.secondary{background:#1f2937; color:#cbd5e1;}\n    .btn.warn{background:var(--danger); color:white;}\n    .row{display:flex; gap:8px;}\n    .controls{margin-top:12px;}\n    .vis{\n      flex:1; padding:18px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n      border:1px solid rgba(255,255,255,0.03); box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n      display:flex; flex-direction:column; height:calc(100vh - 80px); overflow:hidden;\n    }\n    .stats{display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap;}\n    .stat{\n      background:rgba(255,255,255,0.02); padding:8px 10px; border-radius:8px; color:var(--muted); font-size:13px; min-width:120px;\n    }\n    .buckets{flex:1; overflow:auto; padding:12px; display:flex; gap:8px; align-items:flex-start;}\n    .bucket{\n      min-width:120px; max-width:160px; background:rgba(255,255,255,0.02); padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.02);\n      box-sizing:border-box; position:relative;\n    }\n    .bucketIndex{font-size:12px; color:var(--muted); margin-bottom:6px;}\n    .items{display:flex; flex-direction:column; gap:6px;}\n    .item{\n      background:#04222a; color:#bcefe2; padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.02); font-size:13px; display:flex; justify-content:space-between; align-items:center;\n    }\n    .item .k{color:#9fead5; font-weight:700; margin-right:8px;}\n    .item .v{color:#d4fbe8; opacity:0.9;}\n    .bucket .len{position:absolute; top:10px; right:8px; background:rgba(255,255,255,0.03); padding:2px 6px; border-radius:999px; font-size:12px; color:var(--muted);}\n    .highlight{box-shadow:0 0 0 3px rgba(45,212,191,0.08) inset, 0 8px 30px rgba(2,6,23,0.6); transform:translateY(-2px); transition:all 200ms;}\n    .found{box-shadow:0 0 10px rgba(134,239,172,0.25); border:1px solid rgba(134,239,172,0.2);}\n    .log{height:140px; margin-top:12px; overflow:auto; background:rgba(1,6,11,0.4); border-radius:8px; padding:8px; font-size:13px; color:var(--muted);}\n    .logEntry{margin-bottom:6px;}\n    .small{font-size:12px; color:var(--muted);}\n    .controls .hint{margin-top:6px; font-size:12px; color:var(--muted);}\n    .footer{margin-top:10px; font-size:12px; color:var(--muted);}\n    .toggle{display:flex; align-items:center; gap:8px; margin-top:10px; font-size:13px;}\n    .mini{font-size:11px; padding:6px 8px;}\n    .danger{color:var(--danger);}\n    .success{color:var(--success);}\n    .kbd{background:rgba(255,255,255,0.02); padding:2px 6px; border-radius:4px; font-weight:700; font-size:12px; color:#dff9f0;}\n    .progress{height:8px; background:rgba(255,255,255,0.02); border-radius:999px; overflow:hidden; margin-top:6px;}\n    .progress > i{display:block; height:100%; background:linear-gradient(90deg,var(--accent),#86efac); width:0%;}\n    /* small screens */\n    @media (max-width:900px){\n      .app{flex-direction:column;}\n      .side{width:100%;}\n      .vis{height:auto; min-height:60vh;}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"side\">\n      <h1>Hash Map (Hash Table) â€” Demo</h1>\n      <p class=\"lead\">Interactive visualization of a hash map implemented with separate chaining. Try put/get/delete, inspect buckets, and see collisions & resizing.</p>\n\n      <label>Key</label>\n      <input id=\"keyInput\" type=\"text\" placeholder=\"e.g. username or 42\" />\n\n      <label>Value</label>\n      <input id=\"valueInput\" type=\"text\" placeholder=\"e.g. Alice\" />\n\n      <div class=\"controls\">\n        <div class=\"row\">\n          <button id=\"putBtn\" class=\"btn\">Put</button>\n          <button id=\"getBtn\" class=\"btn secondary\">Get</button>\n          <button id=\"delBtn\" class=\"btn warn\">Delete</button>\n        </div>\n\n        <div class=\"row\" style=\"margin-top:8px;\">\n          <button id=\"containsBtn\" class=\"btn secondary mini\">Contains?</button>\n          <button id=\"clearBtn\" class=\"btn secondary mini\">Clear</button>\n          <button id=\"randomBtn\" class=\"btn mini\">Insert 8 Random</button>\n        </div>\n\n        <label style=\"margin-top:12px;\">Initial Capacity</label>\n        <input id=\"capacityInput\" type=\"number\" min=\"2\" value=\"8\" />\n        <div class=\"row\">\n          <button id=\"setCapacityBtn\" class=\"btn secondary mini\">Set Capacity</button>\n          <button id=\"rebuildBtn\" class=\"btn mini\">Rehash (rehash items)</button>\n        </div>\n\n        <label>Auto-resize</label>\n        <div class=\"toggle\">\n          <input id=\"autoResize\" type=\"checkbox\" checked />\n          <span class=\"small\">Enable automatic resizing (when load factor exceeds threshold)</span>\n        </div>\n\n        <label style=\"margin-top:8px;\">Load factor threshold: <span id=\"thresholdLabel\">0.75</span></label>\n        <input id=\"thresholdInput\" type=\"number\" min=\"0.1\" max=\"0.95\" step=\"0.05\" value=\"0.75\" />\n\n        <label style=\"margin-top:8px;\">Find collisions for key</label>\n        <div class=\"row\">\n          <button id=\"findCollisionsBtn\" class=\"btn mini\">Find 1 collision</button>\n          <button id=\"findManyBtn\" class=\"btn secondary mini\">Find 5 collisions</button>\n        </div>\n        <div class=\"hint small\">Collision search tests small strings; it searches deterministically (a..z) and won't freeze the UI.</div>\n      </div>\n\n      <div class=\"footer\">\n        <div style=\"margin-top:12px;\"><span class=\"kbd\">Hash:</span> djb2 (string -> integer) mod capacity</div>\n        <div class=\"small\" style=\"margin-top:6px;\">Implementation: separate chaining (each bucket holds an array of entries)</div>\n      </div>\n    </div>\n\n    <div class=\"vis\">\n      <div class=\"stats\">\n        <div class=\"stat\">Capacity: <span id=\"cap\">8</span></div>\n        <div class=\"stat\">Size: <span id=\"size\">0</span></div>\n        <div class=\"stat\">Load factor: <span id=\"lf\">0.00</span></div>\n        <div class=\"stat\">Resizing: <span id=\"resizing\">on</span></div>\n        <div class=\"stat\">Threshold: <span id=\"thresh\">0.75</span></div>\n      </div>\n\n      <div id=\"progressBar\" class=\"progress\" title=\"Load\">\n        <i id=\"progressFill\"></i>\n      </div>\n\n      <div id=\"buckets\" class=\"buckets\" aria-live=\"polite\" style=\"margin-top:12px;\"></div>\n\n      <div class=\"log\" id=\"log\"></div>\n    </div>\n  </div>\n\n  <script>\n    // Simple djb2 hash for strings\n    function djb2(str) {\n      // Accept non-string keys by converting to string\n      str = String(str);\n      var hash = 5381;\n      for (var i = 0; i < str.length; i++) {\n        hash = ((hash << 5) + hash) + str.charCodeAt(i); // hash * 33 + c\n        hash = hash & 0xFFFFFFFF;\n      }\n      return Math.abs(hash);\n    }\n\n    // HashMap with separate chaining (buckets are arrays of {k,v})\n    class HashMap {\n      constructor(capacity=8, loadFactor=0.75, enableResize=true) {\n        this.capacity = Math.max(2, Math.floor(capacity));\n        this.loadFactor = loadFactor;\n        this.enableResize = enableResize;\n        this.size = 0;\n        this.buckets = [];\n        for (let i = 0; i < this.capacity; i++) this.buckets.push([]);\n      }\n\n      _index(key) {\n        const h = djb2(key);\n        return {hash: h, index: h % this.capacity};\n      }\n\n      put(key, value) {\n        const {hash, index} = this._index(key);\n        const bucket = this.buckets[index];\n        for (let e of bucket) {\n          if (this._equals(e.k, key)) {\n            e.v = value;\n            return {action: 'updated', index, hash};\n          }\n        }\n        bucket.push({k: key, v: value});\n        this.size++;\n        const shouldResize = this.enableResize && (this.size / this.capacity > this.loadFactor);\n        return {action: 'inserted', index, hash, shouldResize};\n      }\n\n      get(key) {\n        const {hash, index} = this._index(key);\n        const bucket = this.buckets[index];\n        for (let e of bucket) {\n          if (this._equals(e.k, key)) return {found: true, value: e.v, index, hash};\n        }\n        return {found: false, index, hash};\n      }\n\n      delete(key) {\n        const {hash, index} = this._index(key);\n        const bucket = this.buckets[index];\n        for (let i = 0; i < bucket.length; i++) {\n          if (this._equals(bucket[i].k, key)) {\n            const val = bucket[i].v;\n            bucket.splice(i, 1);\n            this.size--;\n            return {deleted: true, value: val, index, hash};\n          }\n        }\n        return {deleted: false, index, hash};\n      }\n\n      containsKey(key) {\n        return this.get(key).found;\n      }\n\n      clear() {\n        this.capacity = Math.max(2, this.capacity);\n        this.buckets = [];\n        for (let i = 0; i < this.capacity; i++) this.buckets.push([]);\n        this.size = 0;\n      }\n\n      // Rehash: change capacity and reinsert all items\n      rehash(newCapacity) {\n        const oldEntries = [];\n        for (let b of this.buckets) {\n          for (let e of b) oldEntries.push(e);\n        }\n        this.capacity = Math.max(2, Math.floor(newCapacity));\n        this.buckets = [];\n        for (let i = 0; i < this.capacity; i++) this.buckets.push([]);\n        this.size = 0;\n        for (let e of oldEntries) {\n          const {index} = this._index(e.k);\n          this.buckets[index].push({k: e.k, v: e.v});\n          this.size++;\n        }\n      }\n\n      entries() {\n        const arr = [];\n        for (let b of this.buckets) for (let e of b) arr.push(e);\n        return arr;\n      }\n\n      _equals(a,b) {\n        // using strict equality for this demo; transforming both to string would treat numbers and strings same\n        return a === b;\n      }\n    }\n\n    // UI / App logic\n    const keyInput = document.getElementById('keyInput');\n    const valueInput = document.getElementById('valueInput');\n    const putBtn = document.getElementById('putBtn');\n    const getBtn = document.getElementById('getBtn');\n    const delBtn = document.getElementById('delBtn');\n    const containsBtn = document.getElementById('containsBtn');\n    const clearBtn = document.getElementById('clearBtn');\n    const randomBtn = document.getElementById('randomBtn');\n    const capacityInput = document.getElementById('capacityInput');\n    const setCapacityBtn = document.getElementById('setCapacityBtn');\n    const rehashBtn = document.getElementById('rebuildBtn');\n    const autoResize = document.getElementById('autoResize');\n    const thresholdInput = document.getElementById('thresholdInput');\n    const thresholdLabel = document.getElementById('thresholdLabel');\n    const findCollisionsBtn = document.getElementById('findCollisionsBtn');\n    const findManyBtn = document.getElementById('findManyBtn');\n\n    const capEl = document.getElementById('cap');\n    const sizeEl = document.getElementById('size');\n    const lfEl = document.getElementById('lf');\n    const resizingEl = document.getElementById('resizing');\n    const threshEl = document.getElementById('thresh');\n\n    const bucketsEl = document.getElementById('buckets');\n    const logEl = document.getElementById('log');\n    const progressFill = document.getElementById('progressFill');\n    const progressBar = document.getElementById('progressBar');\n\n    let map = new HashMap(8, parseFloat(thresholdInput.value), autoResize.checked);\n\n    function log(msg, cls) {\n      const div = document.createElement('div');\n      div.className = 'logEntry';\n      if (cls) div.style.color = cls;\n      div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;\n      logEl.prepend(div);\n    }\n\n    function render() {\n      // update stats\n      capEl.textContent = map.capacity;\n      sizeEl.textContent = map.size;\n      const lf = (map.size / map.capacity) || 0;\n      lfEl.textContent = lf.toFixed(2);\n      threshEl.textContent = map.loadFactor.toFixed(2);\n      resizingEl.textContent = map.enableResize ? 'on' : 'off';\n      thresholdLabel.textContent = map.loadFactor.toFixed(2);\n\n      // progress bar\n      const pct = Math.min(100, Math.round(lf * 100));\n      progressFill.style.width = pct + '%';\n\n      // show buckets\n      bucketsEl.innerHTML = '';\n      for (let i = 0; i < map.capacity; i++) {\n        const bdiv = document.createElement('div');\n        bdiv.className = 'bucket';\n        bdiv.dataset.index = i;\n\n        const idx = document.createElement('div');\n        idx.className = 'bucketIndex';\n        idx.textContent = `Bucket ${i}`;\n        bdiv.appendChild(idx);\n\n        const len = document.createElement('div');\n        len.className = 'len';\n        len.textContent = map.buckets[i].length;\n        bdiv.appendChild(len);\n\n        const items = document.createElement('div');\n        items.className = 'items';\n\n        for (let e of map.buckets[i]) {\n          const it = document.createElement('div');\n          it.className = 'item';\n          it.dataset.key = String(e.k);\n          const left = document.createElement('div');\n          left.style.display = 'flex';\n          left.style.alignItems = 'center';\n          const kspan = document.createElement('div');\n          kspan.className = 'k';\n          kspan.textContent = String(e.k);\n          const vspan = document.createElement('div');\n          vspan.className = 'v';\n          vspan.textContent = String(e.v);\n          left.appendChild(kspan);\n          left.appendChild(vspan);\n\n          const right = document.createElement('div');\n          right.style.fontSize = '11px';\n          right.style.opacity = '0.7';\n          right.textContent = ''; // could put small hex hash or arrow\n          it.appendChild(left);\n          it.appendChild(right);\n\n          items.appendChild(it);\n        }\n\n        bdiv.appendChild(items);\n        bucketsEl.appendChild(bdiv);\n      }\n    }\n\n    function highlightBucket(index, ms=700) {\n      const el = bucketsEl.querySelector('.bucket[data-index=\"'+index+'\"]');\n      if (!el) return;\n      el.classList.add('highlight');\n      setTimeout(()=> el.classList.remove('highlight'), ms);\n      // scroll into view if overflowing\n      el.scrollIntoView({behavior:'smooth', inline:'center', block:'nearest'});\n    }\n\n    function brieflyMarkItem(key, colorClass='found', ms=1000) {\n      const sel = bucketsEl.querySelector('.item[data-key=\"'+String(key)+'\"]');\n      if (!sel) return;\n      sel.classList.add(colorClass);\n      setTimeout(()=> sel.classList.remove(colorClass), ms);\n    }\n\n    putBtn.addEventListener('click', () => {\n      const k = keyInput.value;\n      const v = valueInput.value;\n      if (k === '') { alert('Please provide a key'); return; }\n      const res = map.put(k, v);\n      log(`PUT key='${k}' value='${v}' -> ${res.action}. index=${res.index} hash=${res.hash}`);\n      if (res.shouldResize) {\n        log(`Load factor ${(map.size/map.capacity).toFixed(2)} > ${map.loadFactor}. Resizing to ${map.capacity*2}...`, '#ffd580');\n        map.rehash(map.capacity*2);\n        log('Resize complete.');\n      }\n      render();\n      highlightBucket(res.index);\n      brieflyMarkItem(k);\n    });\n\n    getBtn.addEventListener('click', () => {\n      const k = keyInput.value;\n      if (k === '') { alert('Please provide a key'); return; }\n      const res = map.get(k);\n      if (res.found) {\n        log(`GET key='${k}' -> found value='${res.value}'. index=${res.index} hash=${res.hash}`, '#86efac');\n        highlightBucket(res.index);\n        brieflyMarkItem(k);\n      } else {\n        log(`GET key='${k}' -> NOT FOUND. index=${res.index} hash=${res.hash}`, '#fb7185');\n        highlightBucket(res.index);\n      }\n      render();\n    });\n\n    delBtn.addEventListener('click', () => {\n      const k = keyInput.value;\n      if (k === '') { alert('Please provide a key'); return; }\n      const res = map.delete(k);\n      if (res.deleted) {\n        log(`DELETE key='${k}' -> deleted value='${res.value}'. index=${res.index} hash=${res.hash}`, '#ffd580');\n      } else {\n        log(`DELETE key='${k}' -> NOT FOUND. index=${res.index} hash=${res.hash}`, '#fb7185');\n      }\n      render();\n    });\n\n    containsBtn.addEventListener('click', () => {\n      const k = keyInput.value;\n      if (k === '') { alert('Please provide a key'); return; }\n      const has = map.containsKey(k);\n      log(`CONTAINS key='${k}' -> ${has}`, has ? '#86efac' : '#fb7185');\n      if (has) {\n        const {index} = map._index(k);\n        highlightBucket(index);\n        brieflyMarkItem(k);\n      }\n    });\n\n    clearBtn.addEventListener('click', () => {\n      if (!confirm('Clear all items from the hash map?')) return;\n      map.clear();\n      log('Cleared hash map.');\n      render();\n    });\n\n    randomBtn.addEventListener('click', () => {\n      const n = 8;\n      for (let i = 0; i < n; i++) {\n        const k = 'k' + Math.random().toString(36).slice(2,8);\n        const v = Math.random().toString(36).slice(2,8);\n        const r = map.put(k, v);\n        if (r.shouldResize) {\n          log(`Auto-resize triggered. Rehashing to ${map.capacity*2}...`, '#ffd580');\n          map.rehash(map.capacity*2);\n          log('Resize complete.');\n        }\n        log(`PUT '${k}' -> bucket ${r.index}`);\n      }\n      render();\n    });\n\n    setCapacityBtn.addEventListener('click', () => {\n      const val = Number(capacityInput.value);\n      if (!Number.isFinite(val) || val < 2) { alert('Capacity must be a number >= 2'); return; }\n      // rehash to new capacity (preserve items)\n      map.rehash(Math.floor(val));\n      log(`Capacity set to ${map.capacity} and items rehashed.`);\n      render();\n    });\n\n    rehashBtn.addEventListener('click', () => {\n      map.rehash(map.capacity);\n      log('Rehash complete (same capacity).');\n      render();\n    });\n\n    autoResize.addEventListener('change', () => {\n      map.enableResize = autoResize.checked;\n      render();\n      log(`Auto-resize ${map.enableResize ? 'enabled' : 'disabled'}.`);\n    });\n\n    thresholdInput.addEventListener('change', () => {\n      let lf = parseFloat(thresholdInput.value);\n      if (!Number.isFinite(lf) || lf <= 0 || lf >= 1) { alert('Load factor must be between 0 and 1'); return; }\n      map.loadFactor = lf;\n      thresholdLabel.textContent = lf.toFixed(2);\n      render();\n      log(`Load factor threshold set to ${lf.toFixed(2)}.`);\n    });\n\n    // Collision finder: search small lowercase strings deterministically until collisions found.\n    function findCollisionsForKey(targetKey, count=1) {\n      return new Promise((resolve) => {\n        const targetIdx = map._index(targetKey).index;\n        const results = [];\n        const charset = 'abcdefghijklmnopqrstuvwxyz';\n        let length = 1;\n        let stopped = false;\n        const chunk = 2000; // how many candidates to check per tick (keeps UI responsive)\n        function nextBatch() {\n          // generate strings of current length using iterative counters\n          let maxComb = Math.pow(charset.length, length);\n          // iterate with an index across all combinations\n          for (let start = 0; start < maxComb && !stopped; start += chunk) {\n            const end = Math.min(maxComb, start + chunk);\n            for (let i = start; i < end; i++) {\n              // convert i to base-N representation\n              let tmp = i;\n              let s = '';\n              for (let p = 0; p < length; p++) {\n                s = charset[tmp % charset.length] + s;\n                tmp = Math.floor(tmp / charset.length);\n              }\n              if (s === String(targetKey)) continue; // skip identical\n              if (map._index(s).index === targetIdx) {\n                results.push(s);\n                if (results.length >= count) { stopped = true; break; }\n              }\n            }\n            if (stopped) break;\n            // yield control for UI\n            // schedule next inner chunk\n            if (end < maxComb) {\n              setTimeout(nextBatch, 0);\n              return;\n            }\n          }\n          if (!stopped) {\n            length++;\n            // cap length to avoid infinite loops\n            if (length > 6) stopped = true;\n            if (!stopped) setTimeout(nextBatch, 0); else resolve(results);\n          } else {\n            resolve(results);\n          }\n        }\n        nextBatch();\n      });\n    }\n\n    findCollisionsBtn.addEventListener('click', async () => {\n      const k = keyInput.value;\n      if (k === '') { alert('Please provide a key to find collisions for'); return; }\n      log(`Searching for 1 collision for key='${k}' in current capacity ${map.capacity}...`);\n      const t0 = performance.now();\n      const found = await findCollisionsForKey(k, 1);\n      const t1 = performance.now();\n      if (found.length) {\n        log(`Found collision: '${found[0]}' -> same bucket as '${k}' (took ${(t1-t0).toFixed(1)} ms)`, '#86efac');\n        // Show where it would go\n        const idx = map._index(found[0]).index;\n        highlightBucket(idx, 1500);\n        // temporarily insert colliding key to show visually (not altering map)\n        const b = bucketsEl.querySelector('.bucket[data-index=\"'+idx+'\"] .items');\n        if (b) {\n          const placeholder = document.createElement('div');\n          placeholder.className = 'item';\n          placeholder.style.opacity = '0.6';\n          placeholder.textContent = `'${found[0]}' (collision)`;\n          b.appendChild(placeholder);\n          setTimeout(()=> placeholder.remove(), 3000);\n        }\n      } else {\n        log('No collisions found in search limit (strings up to length 6)', '#ffd580');\n      }\n    });\n\n    findManyBtn.addEventListener('click', async () => {\n      const k = keyInput.value;\n      if (k === '') { alert('Please provide a key to find collisions for'); return; }\n      log(`Searching for up to 5 collisions for key='${k}'...`);\n      const t0 = performance.now();\n      const found = await findCollisionsForKey(k, 5);\n      const t1 = performance.now();\n      if (found.length) {\n        log(`Found ${found.length} collisions (took ${(t1-t0).toFixed(1)} ms): ${found.join(', ')}`, '#86efac');\n      } else {\n        log('No collisions found in search limit.', '#ffd580');\n      }\n    });\n\n    // initial render and some sample data\n    function seed() {\n      const samples = [\n        ['Alice','id:1'],\n        ['Bob','id:2'],\n        ['Carol','id:3'],\n        ['Dave','id:4'],\n        ['Eve','id:5'],\n      ];\n      for (let [k,v] of samples) map.put(k,v);\n      render();\n      log('Seeded with sample entries: Alice, Bob, Carol, Dave, Eve');\n    }\n\n    seed();\n    render();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Hash Map"
    }
  ],
  "topic": "Hash Map",
  "hasFSM": false,
  "hasTest": true
}