{
  "id": "be87b195-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:33.851Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Prim's Algorithm Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    body { font-family: system-ui, -apple-system, Roboto, \"Segoe UI\", Arial; margin: 0; display: flex; height: 100vh; }\n    #left { width: 72%; border-right: 1px solid #ddd; position: relative; }\n    #right { width: 28%; padding: 12px; box-sizing: border-box; overflow-y: auto; }\n    header { padding: 10px 12px; border-bottom: 1px solid #eee; background: #fafafa; }\n    #controls { display: flex; gap: 8px; align-items: center; margin-top: 8px; flex-wrap: wrap; }\n    button, input[type=range], select { padding: 6px 8px; font-size: 14px; }\n    button { cursor: pointer; }\n    svg { width: 100%; height: calc(100vh - 60px); display: block; background: linear-gradient(180deg,#fff,#fbfbfd); }\n    .node { cursor: pointer; }\n    .node circle { stroke: #333; stroke-width: 1px; fill: #fff; transition: fill .12s, stroke .12s; }\n    .node text { pointer-events: none; font-weight: 600; font-size: 12px; }\n    .edge-line { stroke: #bbb; stroke-width: 3px; stroke-linecap: round; }\n    .edge-text { fill: #222; font-size: 12px; font-weight: 600; background: #fff; }\n    .node.inmst circle { fill: #1e88e5; stroke: #0b63b7; color: white; }\n    .node.inmst text { fill: #fff; }\n    .node.start circle { stroke: #00bfa5; stroke-width: 2.5px; }\n    .edge.candidate { stroke: #ff9800; stroke-width: 4px; }\n    .edge.mst { stroke: #e53935; stroke-width: 5px; }\n    .edge.inactive { stroke: #ddd; stroke-width: 3px; opacity: 0.75; }\n    #info { margin-top: 12px; font-size: 14px; }\n    .panel { margin-bottom: 12px; padding: 10px; border: 1px solid #eee; border-radius: 6px; background: #fff; }\n    pre { margin: 0; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace; font-size: 13px; }\n    .pseudocode-line { padding: 2px 6px; border-radius: 4px; }\n    .highlight { background: #fff5e1; }\n    .small { font-size: 13px; color: #555; }\n    label { font-size: 13px; margin-right: 6px; }\n    #pq { max-height: 140px; overflow-y: auto; margin-top: 6px; }\n    .edge-item { padding: 6px; border-bottom: 1px solid #f1f1f1; }\n    .edge-weight { font-weight: 700; }\n    footer { padding-top: 6px; font-size: 13px; color: #666; }\n    .controls-left { display:flex; gap:6px; align-items:center; }\n    .controls-right { margin-left:auto; display:flex; gap:6px; align-items:center; }\n    .muted { color: #777; font-size: 13px; }\n  </style>\n</head>\n<body>\n  <div id=\"left\">\n    <header>\n      <div style=\"display:flex;align-items:center;\">\n        <div style=\"font-weight:700;font-size:16px;\">Prim's Algorithm — Minimum Spanning Tree (Interactive)</div>\n        <div style=\"margin-left:12px;\" class=\"muted\">Click a node to pick starting vertex. Drag nodes to reposition.</div>\n      </div>\n      <div id=\"controls\" style=\"margin-top:10px;\">\n        <div class=\"controls-left\">\n          <label for=\"nRange\">Nodes</label>\n          <input id=\"nRange\" type=\"range\" min=\"4\" max=\"12\" value=\"7\">\n          <span id=\"nVal\">7</span>\n          <button id=\"genBtn\">Generate Random Graph</button>\n          <button id=\"clearBtn\">Clear</button>\n        </div>\n        <div class=\"controls-right\">\n          <button id=\"chooseStartBtn\">Choose Start</button>\n          <button id=\"startBtn\">Initialize Prim</button>\n          <button id=\"stepBtn\" disabled>Step</button>\n          <button id=\"playBtn\" disabled>Play</button>\n          <button id=\"resetBtn\" disabled>Reset</button>\n        </div>\n      </div>\n    </header>\n\n    <svg id=\"svgCanvas\" viewBox=\"0 0 1200 800\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n  </div>\n\n  <div id=\"right\">\n    <div class=\"panel\">\n      <div style=\"display:flex;align-items:center;justify-content:space-between;\">\n        <div><strong>MST Status</strong></div>\n        <div class=\"small\">Steps: <span id=\"stepCount\">0</span></div>\n      </div>\n      <div id=\"info\" style=\"margin-top:8px;\">\n        <div>MST total weight: <strong id=\"mstWeight\">0</strong></div>\n        <div style=\"margin-top:6px;\">Start vertex: <span id=\"startVertex\">none</span></div>\n        <div style=\"margin-top:6px;\">Visited vertices: <span id=\"visitedList\">[]</span></div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n        <strong>Candidate edges (min frontier)</strong>\n        <div class=\"small\">Sorted by weight</div>\n      </div>\n      <div id=\"pq\"></div>\n    </div>\n\n    <div class=\"panel\">\n      <strong>Pseudocode (Prim)</strong>\n      <pre id=\"pseudocode\">\n1: for each v in V:\n2:   key[v] = ∞ ; parent[v] = null\n3: key[start] = 0\n4: Q = V\n5: while Q not empty:\n6:   u = extract-min(Q)            // vertex with minimal key\n7:   add u to MST\n8:   for each v adjacent to u:\n9:     if v in Q and weight(u,v) < key[v]:\n10:      parent[v] = u; key[v] = weight(u,v)\n      </pre>\n    </div>\n\n    <div class=\"panel\">\n      <strong>How to use</strong>\n      <ul style=\"margin:8px 0 0 18px;\">\n        <li>Generate a random connected graph or draw your own with \"Clear\" then add nodes by clicking (not implemented here).</li>\n        <li>Click a node to set the starting vertex (or let it default to node 0).</li>\n        <li>Click \"Initialize Prim\" then step through with \"Step\" or auto-run with \"Play\".</li>\n      </ul>\n    </div>\n\n    <footer>\n      Implementation: JavaScript + SVG. Edges highlighted orange are current candidates; red edges are in the MST; blue nodes belong to MST.\n    </footer>\n  </div>\n\n  <script>\n    // Prim's Algorithm Interactive Demo\n    (function() {\n      const svg = document.getElementById('svgCanvas');\n      const nRange = document.getElementById('nRange');\n      const nVal = document.getElementById('nVal');\n      const genBtn = document.getElementById('genBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const chooseStartBtn = document.getElementById('chooseStartBtn');\n      const startBtn = document.getElementById('startBtn');\n      const stepBtn = document.getElementById('stepBtn');\n      const playBtn = document.getElementById('playBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const startVertexSpan = document.getElementById('startVertex');\n      const visitedListSpan = document.getElementById('visitedList');\n      const pqDiv = document.getElementById('pq');\n      const mstWeightSpan = document.getElementById('mstWeight');\n      const stepCountSpan = document.getElementById('stepCount');\n      const pseudocode = document.getElementById('pseudocode');\n\n      let width = 1200, height = 800;\n\n      // Graph data\n      let nodes = []; // {id, x, y, svgGroup}\n      let edges = []; // {id, u, v, weight, line, text, group}\n      let adj = {};   // adjacency lists: id -> [{to, edgeId, weight}]\n\n      // UI state\n      let selectedStart = null;\n      let choosingStart = false;\n      let dragging = null;\n      let dragOffset = {x:0,y:0};\n\n      // Prim algorithm state\n      let primInitialized = false;\n      let inMST = []; // boolean by node id\n      let key = [];\n      let parent = [];\n      let Qcount = 0;\n      let stepCount = 0;\n      let playTimer = null;\n      let finished = false;\n\n      function uid(prefix='id') {\n        return prefix + Math.random().toString(36).slice(2,9);\n      }\n\n      function clearSVG() {\n        while (svg.firstChild) svg.removeChild(svg.firstChild);\n      }\n\n      function resetAll() {\n        nodes = []; edges = []; adj = {};\n        selectedStart = null; choosingStart=false;\n        primInitialized=false; inMST=[]; key=[]; parent=[]; Qcount=0; stepCount=0; finished=false;\n        updateUI();\n        clearSVG();\n      }\n\n      function generateRandomGraph(n = 7, density = 0.45) {\n        resetAll();\n        // Create nodes with random positions but reasonable spacing\n        for (let i=0;i<n;i++) {\n          let angle = Math.random()*Math.PI*2;\n          let r = 150 + Math.random()*200;\n          let x = 200 + (i%2? Math.random()*800 : Math.random()*900);\n          let y = 150 + Math.random()*470;\n          addNode(x, y, i);\n        }\n        // Ensure connected: create a random spanning path first\n        let order = [...Array(n).keys()].sort(()=>Math.random()-0.5);\n        for (let i=1;i<order.length;i++) {\n          let u = order[i-1], v = order[i];\n          addEdge(u,v,randWeight());\n        }\n        // Add random edges\n        for (let u=0;u<n;u++){\n          for (let v=u+1;v<n;v++){\n            if (Math.random() < density && !edgeExists(u,v)) {\n              addEdge(u,v,randWeight());\n            }\n          }\n        }\n        redrawAll();\n      }\n\n      function randWeight() {\n        return Math.floor(1 + Math.random()*20);\n      }\n\n      function edgeExists(u,v) {\n        return edges.some(e => (e.u===u && e.v===v) || (e.u===v && e.v===u));\n      }\n\n      function addNode(x,y,label) {\n        const id = nodes.length;\n        nodes.push({id, x, y, label: (label!==undefined?label:id)});\n        adj[id] = [];\n        drawNode(id);\n      }\n\n      function drawNode(id) {\n        const node = nodes[id];\n        const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n        g.classList.add('node');\n        g.setAttribute('data-id', id);\n        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n        circle.setAttribute('r', 20);\n        circle.setAttribute('cx', node.x);\n        circle.setAttribute('cy', node.y);\n        circle.setAttribute('fill', '#fff');\n        circle.setAttribute('stroke', '#333');\n        circle.setAttribute('stroke-width', 1);\n        const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n        text.setAttribute('x', node.x);\n        text.setAttribute('y', node.y + 5);\n        text.setAttribute('text-anchor', 'middle');\n        text.textContent = node.label;\n        g.appendChild(circle);\n        g.appendChild(text);\n        svg.appendChild(g);\n        node.svg = g;\n\n        // Events\n        g.addEventListener('mousedown', (e) => {\n          e.stopPropagation();\n          const id = Number(g.getAttribute('data-id'));\n          if (choosingStart) {\n            setStartVertex(id);\n            choosingStart = false;\n            chooseStartBtn.textContent = 'Choose Start';\n            return;\n          }\n          if (!primInitialized) {\n            // allow selecting start by clicking prior to init\n            setStartVertex(id);\n          }\n          dragging = id;\n          const pt = getSvgPoint(e);\n          dragOffset.x = pt.x - nodes[id].x;\n          dragOffset.y = pt.y - nodes[id].y;\n        });\n\n        g.addEventListener('mouseup', (e) => { dragging = null; });\n      }\n\n      function getSvgPoint(evt) {\n        const rect = svg.getBoundingClientRect();\n        const cx = (evt.clientX - rect.left) * (svg.viewBox.baseVal.width / rect.width);\n        const cy = (evt.clientY - rect.top) * (svg.viewBox.baseVal.height / rect.height);\n        return {x: cx, y: cy};\n      }\n\n      // Add undirected edge\n      function addEdge(u, v, weight) {\n        if (u===v) return;\n        if (edgeExists(u,v)) return;\n        const id = edges.length;\n        edges.push({id, u, v, weight});\n        adj[u].push({to:v, edgeId:id, weight});\n        adj[v].push({to:u, edgeId:id, weight});\n        drawEdge(id);\n      }\n\n      function drawEdge(id) {\n        const e = edges[id];\n        const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n        g.classList.add('edge');\n        g.classList.add('edge-'+id);\n        const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n        line.classList.add('edge-line');\n        line.setAttribute('x1', nodes[e.u].x);\n        line.setAttribute('y1', nodes[e.u].y);\n        line.setAttribute('x2', nodes[e.v].x);\n        line.setAttribute('y2', nodes[e.v].y);\n        line.setAttribute('stroke','#bbb');\n        line.setAttribute('stroke-width', 3);\n        line.setAttribute('data-id', id);\n        const tx = (nodes[e.u].x + nodes[e.v].x)/2;\n        const ty = (nodes[e.u].y + nodes[e.v].y)/2;\n        const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n        text.classList.add('edge-text');\n        text.setAttribute('x', tx);\n        text.setAttribute('y', ty - 6);\n        text.setAttribute('text-anchor', 'middle');\n        text.textContent = e.weight;\n        g.appendChild(line);\n        g.appendChild(text);\n        // send edges behind nodes\n        svg.insertBefore(g, svg.firstChild);\n        e.group = g;\n        e.line = line;\n        e.text = text;\n\n        // Clicking an edge allows changing weight\n        g.addEventListener('click', (ev) => {\n          ev.stopPropagation();\n          if (primInitialized) return;\n          const w = prompt('Edge weight (positive integer):', String(e.weight));\n          if (w !== null) {\n            const wi = Math.max(1, parseInt(w) || 1);\n            e.weight = wi;\n            e.text.textContent = wi;\n            // Update adjacency weights\n            for (let a of adj[e.u]) if (a.edgeId===id) a.weight = wi;\n            for (let a of adj[e.v]) if (a.edgeId===id) a.weight = wi;\n            if (primInitialized) updateCandidatesDisplay();\n          }\n        });\n      }\n\n      function redrawAll() {\n        // reposition nodes and edges visuals\n        for (let e of edges) {\n          e.line.setAttribute('x1', nodes[e.u].x);\n          e.line.setAttribute('y1', nodes[e.u].y);\n          e.line.setAttribute('x2', nodes[e.v].x);\n          e.line.setAttribute('y2', nodes[e.v].y);\n          const tx = (nodes[e.u].x + nodes[e.v].x)/2;\n          const ty = (nodes[e.u].y + nodes[e.v].y)/2;\n          e.text.setAttribute('x', tx);\n          e.text.setAttribute('y', ty - 6);\n        }\n        for (let n of nodes) {\n          const g = n.svg;\n          const circle = g.querySelector('circle');\n          const text = g.querySelector('text');\n          circle.setAttribute('cx', n.x);\n          circle.setAttribute('cy', n.y);\n          text.setAttribute('x', n.x);\n          text.setAttribute('y', n.y + 5);\n        }\n      }\n\n      // Mouse move for dragging\n      svg.addEventListener('mousemove', (e) => {\n        if (dragging === null) return;\n        const pt = getSvgPoint(e);\n        const id = dragging;\n        nodes[id].x = Math.max(40, Math.min(width-40, pt.x - dragOffset.x));\n        nodes[id].y = Math.max(40, Math.min(height-40, pt.y - dragOffset.y));\n        redrawAll();\n      });\n      window.addEventListener('mouseup', () => { dragging = null; });\n\n      // Click on empty svg to stop choosing start\n      svg.addEventListener('click', (e) => {\n        if (choosingStart) {\n          choosingStart = false;\n          chooseStartBtn.textContent = 'Choose Start';\n        }\n      });\n\n      function setStartVertex(id) {\n        selectedStart = id;\n        renderNodeStyles();\n        startVertexSpan.textContent = id;\n      }\n\n      function renderNodeStyles() {\n        for (let n of nodes) {\n          const g = n.svg;\n          g.classList.remove('inmst','start');\n          if (primInitialized && inMST[n.id]) g.classList.add('inmst');\n          if (selectedStart === n.id) g.classList.add('start');\n        }\n      }\n\n      // Prim algorithm core (step-by-step)\n      function initializePrim() {\n        if (nodes.length === 0) return alert('Create a graph first.');\n        if (selectedStart === null) setStartVertex(0);\n        const n = nodes.length;\n        inMST = Array(n).fill(false);\n        key = Array(n).fill(Infinity);\n        parent = Array(n).fill(null);\n        key[selectedStart] = 0;\n        Qcount = n;\n        primInitialized = true;\n        finished = false;\n        stepCount = 0;\n        stepCountSpan.textContent = String(stepCount);\n        updateUI();\n        updateCandidatesDisplay();\n        highlightPseudocodeLine(3);\n        renderNodeStyles();\n        stepBtn.disabled = false;\n        playBtn.disabled = false;\n        resetBtn.disabled = false;\n      }\n\n      function stepPrimOnce() {\n        if (!primInitialized || finished) return;\n        // extract min key among vertices not in MST\n        let u = -1, minK = Infinity;\n        for (let i=0;i<key.length;i++){\n          if (!inMST[i] && key[i] < minK) {\n            minK = key[i]; u = i;\n          }\n        }\n        if (u === -1) {\n          // All remaining vertices are disconnected (shouldn't happen if connected)\n          finished = true;\n          finalizeMST();\n          return;\n        }\n        // Simulate pseudocode highlighting\n        highlightPseudocodeLine(6);\n        // Add u to MST\n        inMST[u] = true;\n        Qcount--;\n        stepCount++;\n        stepCountSpan.textContent = String(stepCount);\n        // If parent exists, mark that edge as in MST\n        if (parent[u] !== null) {\n          const edgeId = findEdgeBetween(u, parent[u]);\n          if (edgeId !== null) {\n            edges[edgeId].line.classList.add('mst');\n            edges[edgeId].line.classList.remove('edge-line');\n            edges[edgeId].group.classList.add('edge-mst');\n            edges[edgeId].group.classList.add('edge-'+edgeId);\n            edges[edgeId].line.setAttribute('stroke', '#e53935');\n          }\n        }\n        // Update node style\n        renderNodeStyles();\n        // Update keys for adjacent vertices\n        highlightPseudocodeLine(8);\n        for (let e of adj[u]) {\n          const v = e.to;\n          if (!inMST[v] && e.weight < key[v]) {\n            parent[v] = u;\n            key[v] = e.weight;\n            // Visual note: candidate edges color\n          }\n        }\n        updateCandidatesDisplay();\n        updateMSTWeight();\n        // Check finish\n        if (Qcount === 0) {\n          finished = true;\n          finalizeMST();\n        } else {\n          highlightPseudocodeLine(5);\n        }\n      }\n\n      function findEdgeBetween(a,b) {\n        for (let e of edges) {\n          if ((e.u===a && e.v===b) || (e.u===b && e.v===a)) return e.id;\n        }\n        return null;\n      }\n\n      function updateCandidatesDisplay() {\n        // Show candidate edges: edges connecting inMST nodes to outside nodes via parent pointers and keys\n        // We'll show for each v not inMST but with parent assigned: (parent[v], v, key[v])\n        const list = [];\n        for (let v=0; v<nodes.length; v++) {\n          if (!inMST[v] && parent[v] !== null) {\n            list.push({u: parent[v], v, weight: key[v]});\n          }\n        }\n        // Also consider vertices with infinite key (disconnected)\n        list.sort((a,b)=>a.weight - b.weight);\n        // Update PQ display\n        pqDiv.innerHTML = '';\n        if (list.length === 0) {\n          pqDiv.innerHTML = '<div class=\"small muted\">No candidate edges (maybe starting state or graph disconnected).</div>';\n        } else {\n          for (let it of list) {\n            const el = document.createElement('div');\n            el.className = 'edge-item';\n            el.innerHTML = `<span style=\"color:#444\">(${it.u} — ${it.v})</span> &nbsp; weight: <span class=\"edge-weight\">${it.weight}</span>`;\n            pqDiv.appendChild(el);\n          }\n        }\n        // Visual highlighting of candidate edges in SVG:\n        // Reset edge styles then color those that match parent relations orange\n        for (let e of edges) {\n          e.line.classList.remove('candidate','inactivate','mst');\n          e.group.classList.remove('candidate');\n          // Base style\n          e.line.setAttribute('stroke', '#bbb');\n          e.line.setAttribute('stroke-width', 3);\n        }\n        for (let it of list) {\n          const eid = findEdgeBetween(it.u, it.v);\n          if (eid !== null) {\n            edges[eid].line.classList.add('candidate');\n            edges[eid].line.setAttribute('stroke', '#ff9800');\n            edges[eid].line.setAttribute('stroke-width', 4);\n          }\n        }\n        // Mark MST edges red\n        for (let e of edges) {\n          if (inMST[e.u] && inMST[e.v]) {\n            // if both endpoints in MST and parent relation is consistent, mark as mst\n            // We'll trust the earlier marking when node added; ensure styling\n            if (e.line.getAttribute('stroke') === '#e53935') {\n              e.line.classList.add('mst');\n            }\n          }\n        }\n      }\n\n      function updateMSTWeight() {\n        let total = 0;\n        for (let v=0;v<nodes.length;v++) {\n          if (parent[v] !== null) total += key[v];\n        }\n        mstWeightSpan.textContent = String(total);\n      }\n\n      function finalizeMST() {\n        updateCandidatesDisplay();\n        updateMSTWeight();\n        highlightPseudocodeLine(null);\n        stepBtn.disabled = true;\n        playBtn.disabled = true;\n      }\n\n      function updateUI() {\n        nVal.textContent = nRange.value;\n        startVertexSpan.textContent = (selectedStart===null?'none':selectedStart);\n        visitedListSpan.textContent = '[' + inMST.map((b,i)=>b?i:null).filter(x=>x!==null).join(', ') + ']';\n        stepCountSpan.textContent = String(stepCount);\n        mstWeightSpan.textContent = mstWeightSpan.textContent || '0';\n        renderNodeStyles();\n      }\n\n      // Pseudocode highlighting helper\n      function highlightPseudocodeLine(lineNumber) {\n        // lines are numbered 1..10 as in displayed code. We'll map to actual lines in <pre>.\n        const lines = pseudocode.textContent.split('\\n');\n        const newHtml = lines.map((ln,i)=>{\n          const num = i+1;\n          const safe = ln.replace(/</g,'&lt;').replace(/>/g,'&gt;');\n          return `<div class=\"pseudocode-line ${num===lineNumber? 'highlight':''}\"><span style=\"opacity:0.6;padding-right:6px\">${num}:</span>${safe}</div>`;\n        }).join('');\n        pseudocode.innerHTML = newHtml;\n      }\n\n      // Event wiring\n      nRange.addEventListener('input', () => { nVal.textContent = nRange.value; });\n      genBtn.addEventListener('click', () => {\n        generateRandomGraph(Number(nRange.value), 0.45);\n        updateUI();\n      });\n\n      clearBtn.addEventListener('click', () => {\n        resetAll();\n      });\n\n      chooseStartBtn.addEventListener('click', () => {\n        choosingStart = !choosingStart;\n        chooseStartBtn.textContent = choosingStart ? 'Click a node to set start (or click again to cancel)' : 'Choose Start';\n      });\n\n      startBtn.addEventListener('click', () => {\n        if (!primInitialized) {\n          initializePrim();\n        }\n      });\n\n      stepBtn.addEventListener('click', () => {\n        stepPrimOnce();\n        updateUI();\n      });\n\n      playBtn.addEventListener('click', () => {\n        if (playTimer) {\n          clearInterval(playTimer); playTimer = null; playBtn.textContent = 'Play';\n        } else {\n          if (!primInitialized) initializePrim();\n          playBtn.textContent = 'Pause';\n          playTimer = setInterval(() => {\n            if (!finished) stepPrimOnce();\n            updateUI();\n            if (finished) { clearInterval(playTimer); playTimer=null; playBtn.textContent='Play'; }\n          }, 700);\n        }\n      });\n\n      resetBtn.addEventListener('click', () => {\n        // Reset prim algorithm state but keep graph and start selection\n        primInitialized = false;\n        inMST = []; key = []; parent = [];\n        stepCount = 0; stepCountSpan.textContent = String(stepCount);\n        // remove edge styles\n        for (let e of edges) {\n          e.line.classList.remove('mst','candidate');\n          e.line.setAttribute('stroke', '#bbb');\n          e.line.setAttribute('stroke-width', 3);\n        }\n        for (let n of nodes) {\n          n.svg.classList.remove('inmst');\n        }\n        stepBtn.disabled = true; playBtn.disabled = true; resetBtn.disabled = true;\n        pqDiv.innerHTML = '';\n        mstWeightSpan.textContent = '0';\n        highlightPseudocodeLine(null);\n        updateUI();\n      });\n\n      // Initialize with a random graph\n      generateRandomGraph(Number(nRange.value), 0.45);\n\n      // Small accessibility: update visited display every 500ms\n      setInterval(() => {\n        visitedListSpan.textContent = '[' + (inMST? inMST.map((b,i)=>b?i:null).filter(x=>x!==null).join(', '):'') + ']';\n      }, 400);\n\n      // Initial pseudocode render\n      highlightPseudocodeLine(null);\n\n      // Resize handling: keep viewBox fixed\n      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}