{
  "id": "2bde4380-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:17:37.058Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency List",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Adjacency List - Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #22c1c3;\n      --muted: #9aa7b2;\n      --card: #0f1728;\n      --danger: #ef4444;\n    }\n    html,body { height:100%; margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background: linear-gradient(180deg,#071026 0%, #081224 100%); color:#e6eef6; }\n    .container { display:flex; gap:12px; padding:16px; box-sizing:border-box; }\n    .left, .right { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; padding:12px; box-sizing:border-box; }\n    .left { flex:1; min-width:480px; display:flex; flex-direction:column; align-items:stretch; }\n    .canvas-wrap { background: linear-gradient(180deg,#081222 0%, #071122 100%); border-radius:8px; flex:1; position:relative; overflow:hidden; }\n    svg { width:100%; height:100%; cursor:grab; display:block; }\n    .toolbar { display:flex; gap:8px; align-items:center; margin-bottom:10px; flex-wrap:wrap; }\n    .btn, input[type=\"text\"], select { background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.06); padding:8px 10px; border-radius:8px; font-size:13px; }\n    .btn { cursor:pointer; color:#e6eef6; background:linear-gradient(90deg, rgba(34,193,195,0.14), rgba(59,120,255,0.08)); border:1px solid rgba(34,193,195,0.15); }\n    .btn.warn { background:transparent; border:1px solid rgba(239,68,68,0.12); color:var(--danger); }\n    .controls { display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }\n    .panel { padding:10px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); border:1px solid rgba(255,255,255,0.03); }\n    .right { width:420px; display:flex; flex-direction:column; gap:10px; }\n    .section-title { font-weight:600; color:#d9eef6; margin-bottom:6px; }\n    textarea { width:100%; height:160px; background:transparent; color:#dff1f2; border:1px dashed rgba(255,255,255,0.03); padding:8px; border-radius:8px; resize:vertical; font-family: monospace; font-size:13px; }\n    .list { font-family: monospace; background:transparent; color:#dff1f2; padding:8px; border-radius:8px; border:1px dashed rgba(255,255,255,0.03); min-height:120px; overflow:auto; white-space:pre; }\n    label { font-size:13px; color:var(--muted); display:flex; gap:8px; align-items:center; }\n    .small { font-size:13px; color:var(--muted); }\n    .footer { margin-top:8px; color:var(--muted); font-size:13px; }\n    .node { cursor:pointer; }\n    .node circle { fill:linear-gradient(#1e293b,#0b1220); stroke: rgba(34,193,195,0.14); stroke-width:2; }\n    .node text { dominant-baseline:middle; text-anchor:middle; pointer-events:none; font-weight:600; }\n    .edge { stroke:rgba(255,255,255,0.12); stroke-width:2; fill:none; }\n    .edge.selected { stroke: #ffd166; stroke-width:3.5; }\n    .edge-label { font-family: monospace; font-size:12px; fill:#dff1f2; pointer-events:none; }\n    .node-selected circle { stroke:#ffd166; stroke-width:3.5; }\n    .hint { color:var(--muted); font-size:13px; }\n    .sample-buttons { display:flex; gap:6px; flex-wrap:wrap; }\n    .small-muted { font-size:12px; color:var(--muted); }\n    .input-row { display:flex; gap:8px; align-items:center; }\n    .key-hint { font-size:12px; color:var(--muted); margin-left:auto; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"left panel\">\n      <div class=\"toolbar\">\n        <div class=\"controls\">\n          <label title=\"Graph type\">\n            <input id=\"directedToggle\" type=\"checkbox\" /> Directed\n          </label>\n          <label title=\"Weighted edges\">\n            <input id=\"weightedToggle\" type=\"checkbox\" /> Weighted\n          </label>\n          <button id=\"clearBtn\" class=\"btn warn\" title=\"Clear all nodes and edges\">Clear</button>\n        </div>\n        <div style=\"margin-left:auto\" class=\"small-muted\">Click canvas to create nodes • Drag nodes to move • Click edge to select • Delete key removes selected</div>\n      </div>\n\n      <div style=\"display:flex; gap:8px; align-items:center; margin-bottom:10px;\">\n        <div style=\"display:flex; gap:8px; align-items:center;\">\n          <input id=\"nodeName\" type=\"text\" placeholder=\"Node label (A,B...)\" style=\"width:120px\" />\n          <button id=\"addNodeBtn\" class=\"btn\">Add Node</button>\n        </div>\n        <div style=\"display:flex; gap:8px; align-items:center;\">\n          <select id=\"sourceSelect\"></select>\n          <select id=\"targetSelect\"></select>\n          <input id=\"edgeWeight\" type=\"text\" placeholder=\"weight\" style=\"width:72px\" />\n          <button id=\"addEdgeBtn\" class=\"btn\">Add Edge</button>\n        </div>\n      </div>\n\n      <div class=\"canvas-wrap panel\" id=\"canvasPanel\" style=\"height:560px;\">\n        <svg id=\"svgCanvas\" viewBox=\"0 0 800 560\" preserveAspectRatio=\"xMidYMid meet\">\n          <defs>\n            <marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\" markerWidth=\"7\" markerHeight=\"7\" orient=\"auto-start-reverse\">\n              <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#dff1f2\" opacity=\"0.92\"/>\n            </marker>\n            <marker id=\"arrow-orange\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\" markerWidth=\"8\" markerHeight=\"8\" orient=\"auto-start-reverse\">\n              <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#ffd166\" opacity=\"0.98\"/>\n            </marker>\n          </defs>\n\n          <g id=\"edgesLayer\"></g>\n          <g id=\"nodesLayer\"></g>\n          <g id=\"labelsLayer\"></g>\n        </svg>\n      </div>\n\n      <div style=\"display:flex; gap:10px; margin-top:8px; align-items:center;\">\n        <div style=\"display:flex; gap:6px;\">\n          <button id=\"bfsBtn\" class=\"btn\">BFS</button>\n          <button id=\"dfsBtn\" class=\"btn\">DFS</button>\n        </div>\n        <div style=\"margin-left:auto; display:flex; gap:6px; align-items:center;\">\n          <label class=\"small-muted\">Start:</label>\n          <select id=\"startSelect\"></select>\n          <div class=\"key-hint\">Tip: press Delete to remove selected</div>\n        </div>\n      </div>\n\n    </div>\n\n    <div class=\"right panel\">\n      <div>\n        <div class=\"section-title\">Adjacency List (visual)</div>\n        <div id=\"adjList\" class=\"list\" aria-live=\"polite\"></div>\n      </div>\n\n      <div>\n        <div class=\"section-title\">Edge List</div>\n        <div id=\"edgeList\" class=\"list\"></div>\n      </div>\n\n      <div>\n        <div class=\"section-title\">Adjacency Matrix</div>\n        <div id=\"matrixArea\" class=\"list\"></div>\n      </div>\n\n      <div>\n        <div class=\"section-title\">Import / Export</div>\n        <div style=\"display:flex; gap:8px; margin-bottom:6px;\">\n          <button id=\"exportBtn\" class=\"btn\">Export JSON</button>\n          <button id=\"importBtn\" class=\"btn\">Import JSON</button>\n          <input id=\"importFile\" type=\"file\" accept=\"application/json\" style=\"display:none\" />\n        </div>\n        <div class=\"small-muted\">You can export the graph (nodes, edges, directed, weighted) as JSON and re-import it.</div>\n      </div>\n\n      <div style=\"margin-top:auto;\">\n        <div class=\"section-title\">Sample Graphs</div>\n        <div class=\"sample-buttons\">\n          <button class=\"btn\" id=\"sample1\">Triangle</button>\n          <button class=\"btn\" id=\"sample2\">Directed DAG</button>\n          <button class=\"btn\" id=\"sample3\">Weighted</button>\n          <button class=\"btn\" id=\"sample4\">Undirected Complex</button>\n        </div>\n      </div>\n\n    </div>\n  </div>\n\n  <script>\n    // Interactive adjacency list demo\n    (function(){\n      // Data model\n      let nodes = []; // {id, label, x, y}\n      let edges = []; // {id, source, target, weight}\n      let directed = false;\n      let weighted = false;\n      let nodeIdCounter = 1;\n      let edgeIdCounter = 1;\n      let selectedEdgeId = null;\n      const svg = document.getElementById('svgCanvas');\n      const nodesLayer = document.getElementById('nodesLayer');\n      const edgesLayer = document.getElementById('edgesLayer');\n      const labelsLayer = document.getElementById('labelsLayer');\n\n      // UI elements\n      const directedToggle = document.getElementById('directedToggle');\n      const weightedToggle = document.getElementById('weightedToggle');\n      const addNodeBtn = document.getElementById('addNodeBtn');\n      const addEdgeBtn = document.getElementById('addEdgeBtn');\n      const nodeNameInput = document.getElementById('nodeName');\n      const sourceSelect = document.getElementById('sourceSelect');\n      const targetSelect = document.getElementById('targetSelect');\n      const edgeWeightInput = document.getElementById('edgeWeight');\n      const adjListDiv = document.getElementById('adjList');\n      const edgeListDiv = document.getElementById('edgeList');\n      const matrixDiv = document.getElementById('matrixArea');\n      const clearBtn = document.getElementById('clearBtn');\n      const exportBtn = document.getElementById('exportBtn');\n      const importBtn = document.getElementById('importBtn');\n      const importFile = document.getElementById('importFile');\n      const sample1 = document.getElementById('sample1');\n      const sample2 = document.getElementById('sample2');\n      const sample3 = document.getElementById('sample3');\n      const sample4 = document.getElementById('sample4');\n      const bfsBtn = document.getElementById('bfsBtn');\n      const dfsBtn = document.getElementById('dfsBtn');\n      const startSelect = document.getElementById('startSelect');\n\n      // Initial setup\n      directedToggle.addEventListener('change', () => { directed = directedToggle.checked; render(); });\n      weightedToggle.addEventListener('change', () => { weighted = weightedToggle.checked; updateWeightUI(); render(); });\n      addNodeBtn.addEventListener('click', () => {\n        const lab = (nodeNameInput.value || '').trim();\n        addNode(lab || undefined);\n        nodeNameInput.value = '';\n      });\n      addEdgeBtn.addEventListener('click', () => {\n        const s = sourceSelect.value;\n        const t = targetSelect.value;\n        if (!s || !t) return alert('Choose source and target nodes.');\n        const w = edgeWeightInput.value.trim();\n        addEdge(s, t, weighted ? (w === '' ? 1 : parseFloat(w) || 0) : 1);\n        edgeWeightInput.value = '';\n      });\n      clearBtn.addEventListener('click', () => {\n        if (!confirm('Clear the graph?')) return;\n        nodes = []; edges = []; nodeIdCounter = 1; edgeIdCounter = 1; selectedEdgeId = null;\n        render();\n      });\n\n      exportBtn.addEventListener('click', () => {\n        const data = { nodes, edges, directed, weighted };\n        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = 'graph.json';\n        document.body.appendChild(a);\n        a.click();\n        a.remove();\n        URL.revokeObjectURL(url);\n      });\n      importBtn.addEventListener('click', () => importFile.click());\n      importFile.addEventListener('change', (e) => {\n        const f = e.target.files[0];\n        if (!f) return;\n        const reader = new FileReader();\n        reader.onload = () => {\n          try {\n            const obj = JSON.parse(reader.result);\n            if (!obj.nodes || !obj.edges) throw new Error('Invalid JSON');\n            nodes = obj.nodes.map(n => ({...n}));\n            edges = obj.edges.map(e => ({...e}));\n            directed = !!obj.directed; weighted = !!obj.weighted;\n            directedToggle.checked = directed;\n            weightedToggle.checked = weighted;\n            nodeIdCounter = nodes.reduce((m,n)=>Math.max(m, parseInt(n.id.replace('n',''))||0),0)+1;\n            edgeIdCounter = edges.reduce((m,e)=>Math.max(m, parseInt(e.id.replace('e',''))||0),0)+1;\n            render();\n          } catch(err) {\n            alert('Failed to import: ' + err.message);\n          }\n        };\n        reader.readAsText(f);\n        importFile.value = '';\n      });\n\n      sample1.addEventListener('click', () => {\n        // Triangle undirected\n        nodes = [];\n        edges = [];\n        nodeIdCounter = 1; edgeIdCounter = 1;\n        directed = false; weighted = false;\n        directedToggle.checked = false; weightedToggle.checked = false;\n        addNode('A', 200, 120);\n        addNode('B', 420, 120);\n        addNode('C', 310, 320);\n        addEdge(nodes[0].id, nodes[1].id, 1);\n        addEdge(nodes[1].id, nodes[2].id, 1);\n        addEdge(nodes[2].id, nodes[0].id, 1);\n        render();\n      });\n      sample2.addEventListener('click', () => {\n        // Directed DAG\n        nodes = []; edges = []; nodeIdCounter = 1; edgeIdCounter = 1;\n        directed = true; weighted = false;\n        directedToggle.checked = true; weightedToggle.checked = false;\n        addNode('Start', 140, 120); // n1\n        addNode('A', 350, 80);      // n2\n        addNode('B', 350, 200);     // n3\n        addNode('C', 560, 120);     // n4\n        addEdge(nodes[0].id, nodes[1].id,1);\n        addEdge(nodes[0].id, nodes[2].id,1);\n        addEdge(nodes[1].id, nodes[3].id,1);\n        addEdge(nodes[2].id, nodes[3].id,1);\n        render();\n      });\n      sample3.addEventListener('click', () => {\n        // Weighted graph\n        nodes = []; edges = []; nodeIdCounter = 1; edgeIdCounter = 1;\n        directed = false; weighted = true;\n        directedToggle.checked = false; weightedToggle.checked = true;\n        addNode('1', 140, 120);\n        addNode('2', 320, 70);\n        addNode('3', 520, 120);\n        addNode('4', 320, 300);\n        addEdge(nodes[0].id, nodes[1].id, 4);\n        addEdge(nodes[1].id, nodes[2].id, 2);\n        addEdge(nodes[2].id, nodes[3].id, 7);\n        addEdge(nodes[3].id, nodes[0].id, 6);\n        render();\n      });\n      sample4.addEventListener('click', () => {\n        // Undirected complex\n        nodes = []; edges = []; nodeIdCounter = 1; edgeIdCounter = 1;\n        directed = false; weighted = false;\n        directedToggle.checked = false; weightedToggle.checked = false;\n        for(let i=0;i<6;i++){\n          addNode(String.fromCharCode(65+i), 120 + (i%3)*200, 80 + Math.floor(i/3)*220);\n        }\n        addEdge(nodes[0].id, nodes[1].id,1);\n        addEdge(nodes[1].id, nodes[2].id,1);\n        addEdge(nodes[2].id, nodes[5].id,1);\n        addEdge(nodes[4].id, nodes[5].id,1);\n        addEdge(nodes[0].id, nodes[3].id,1);\n        addEdge(nodes[1].id, nodes[4].id,1);\n        render();\n      });\n\n      bfsBtn.addEventListener('click', () => {\n        const start = startSelect.value;\n        if (!start) return alert('Choose start node for BFS.');\n        animateTraversal(bfs(start));\n      });\n      dfsBtn.addEventListener('click', () => {\n        const start = startSelect.value;\n        if (!start) return alert('Choose start node for DFS.');\n        animateTraversal(dfs(start));\n      });\n\n      // Canvas interactions: click to add node, drag nodes\n      let isPanning = false;\n      let dragNode = null;\n      let dragOffset = {x:0,y:0};\n\n      svg.addEventListener('mousedown', (e) => {\n        const pt = getSvgPoint(e);\n        const target = e.target;\n        if (target.tagName === 'svg') {\n          // Add node at click\n          // But if user ctrl/shift might want something else; keep simple: add node\n          // Only add when clicking empty area (not on node)\n          addNode(undefined, pt.x, pt.y);\n        } else if (target.closest('.node')) {\n          // start drag handled by node mousedown\n        } else {\n          // empty space\n        }\n      });\n\n      // Keyboard: Delete to remove selected edge\n      window.addEventListener('keydown', (e) => {\n        if (e.key === 'Delete' || e.key === 'Backspace') {\n          if (selectedEdgeId) {\n            edges = edges.filter(ed => ed.id !== selectedEdgeId);\n            selectedEdgeId = null;\n            render();\n          }\n        }\n      });\n\n      // Utility functions\n      function addNode(label, x, y) {\n        const id = 'n' + (++nodeIdCounter);\n        const lab = label || id;\n        const w = svg.viewBox.baseVal.width || 800;\n        const h = svg.viewBox.baseVal.height || 560;\n        const nx = (typeof x === 'number') ? x : (100 + Math.random() * (w - 200));\n        const ny = (typeof y === 'number') ? y : (80 + Math.random() * (h - 160));\n        nodes.push({ id, label: lab, x: nx, y: ny });\n        render();\n      }\n      function addEdge(sourceId, targetId, weight) {\n        if (!getNodeById(sourceId) || !getNodeById(targetId)) return;\n        const id = 'e' + (++edgeIdCounter);\n        const w = (typeof weight === 'number') ? weight : (weighted ? parseFloat(weight) || 1 : 1);\n        edges.push({ id, source: sourceId, target: targetId, weight: w });\n        // If undirected, also add reverse? No: representation is oriented edges; for undirected visual we add both directions in adjacency display by symmetrically rendering.\n        render();\n      }\n      function getNodeById(id) { return nodes.find(n => n.id === id); }\n      function getEdgesFrom(id) { return edges.filter(e => e.source === id); }\n      function getEdgesTo(id) { return edges.filter(e => e.target === id); }\n\n      function updateSelects() {\n        [sourceSelect, targetSelect, startSelect].forEach(sel => {\n          const val = sel.value;\n          sel.innerHTML = '';\n          nodes.forEach(n => {\n            const opt = document.createElement('option');\n            opt.value = n.id;\n            opt.textContent = n.label;\n            sel.appendChild(opt);\n          });\n          if (nodes.length > 0) sel.value = val || nodes[0].id;\n        });\n      }\n\n      function updateWeightUI() {\n        edgeWeightInput.disabled = !weighted;\n        edgeWeightInput.placeholder = weighted ? 'weight (number)' : 'weight disabled';\n      }\n\n      // Rendering\n      function render() {\n        updateSelects();\n        drawEdges();\n        drawNodes();\n        updateAdjList();\n        updateEdgeList();\n        updateMatrix();\n      }\n\n      function drawNodes() {\n        nodesLayer.innerHTML = '';\n        labelsLayer.innerHTML = '';\n        nodes.forEach(n => {\n          const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n          g.classList.add('node');\n          g.setAttribute('data-id', n.id);\n          g.style.cursor = 'pointer';\n          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n          circle.setAttribute('cx', n.x);\n          circle.setAttribute('cy', n.y);\n          circle.setAttribute('r', 22);\n          circle.setAttribute('fill', '#07202a');\n          circle.setAttribute('stroke', 'rgba(34,193,195,0.14)');\n          circle.setAttribute('stroke-width', '2');\n          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n          text.setAttribute('x', n.x);\n          text.setAttribute('y', n.y);\n          text.setAttribute('fill', '#dff1f2');\n          text.setAttribute('font-size', '12px');\n          text.setAttribute('font-weight','700');\n          text.textContent = n.label;\n          g.appendChild(circle);\n          g.appendChild(text);\n          nodesLayer.appendChild(g);\n\n          // Events: drag\n          g.addEventListener('mousedown', (e) => {\n            e.stopPropagation();\n            dragNode = n;\n            const pt = getSvgPoint(e);\n            dragOffset.x = pt.x - n.x;\n            dragOffset.y = pt.y - n.y;\n            svg.style.cursor = 'grabbing';\n          });\n          // doubleclick to edit label\n          g.addEventListener('dblclick', (e) => {\n            e.stopPropagation();\n            const newLabel = prompt('Edit node label', n.label);\n            if (newLabel !== null) {\n              n.label = String(newLabel);\n              render();\n            }\n          });\n          // right-click to remove node\n          g.addEventListener('contextmenu', (e)=> {\n            e.preventDefault();\n            e.stopPropagation();\n            if (confirm('Remove node ' + n.label + ' and its incident edges?')) {\n              nodes = nodes.filter(x => x.id !== n.id);\n              edges = edges.filter(ed => ed.source !== n.id && ed.target !== n.id);\n              render();\n            }\n          });\n        });\n      }\n\n      // Mouse move and up for dragging\n      window.addEventListener('mousemove', (e) => {\n        if (!dragNode) return;\n        const pt = getSvgPoint(e);\n        dragNode.x = Math.max(30, Math.min(pt.x - dragOffset.x, (svg.viewBox.baseVal.width || 800)-30));\n        dragNode.y = Math.max(30, Math.min(pt.y - dragOffset.y, (svg.viewBox.baseVal.height || 560)-30));\n        drawEdges();\n        drawNodes();\n      });\n      window.addEventListener('mouseup', (e) => {\n        if (dragNode) {\n          dragNode = null;\n          svg.style.cursor = 'grab';\n          render();\n        }\n      });\n\n      function drawEdges() {\n        edgesLayer.innerHTML = '';\n        labelsLayer.innerHTML = '';\n        edges.forEach(ed => {\n          const s = getNodeById(ed.source);\n          const t = getNodeById(ed.target);\n          if (!s || !t) return;\n          // Edge path (straight or curved if same source+target exist both ways)\n          const sameOpp = edges.some(o => o.source === ed.target && o.target === ed.source);\n          const selfLoop = ed.source === ed.target;\n          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n          path.classList.add('edge');\n          path.setAttribute('data-id', ed.id);\n          path.setAttribute('stroke', selectedEdgeId === ed.id ? '#ffd166' : 'rgba(255,255,255,0.12)');\n          path.setAttribute('stroke-width', selectedEdgeId === ed.id ? 3.5 : 2);\n          path.setAttribute('fill','none');\n          // Use arrow marker for directed graphs\n          if (directed) {\n            path.setAttribute('marker-end', selectedEdgeId === ed.id ? 'url(#arrow-orange)' : 'url(#arrow)');\n          } else {\n            path.removeAttribute('marker-end');\n          }\n\n          let d;\n          if (selfLoop) {\n            // draw a loop\n            const cx = s.x, cy = s.y;\n            d = `M ${cx+16} ${cy} C ${cx+60} ${cy-40}, ${cx+60} ${cy+40}, ${cx+16} ${cy}`;\n          } else if (sameOpp) {\n            // curve to avoid overlap\n            const dx = t.x - s.x;\n            const dy = t.y - s.y;\n            const mx = (s.x + t.x) / 2;\n            const my = (s.y + t.y) / 2;\n            const norm = Math.sqrt(dx*dx + dy*dy) || 1;\n            const offset = 30; // curve offset\n            const ux = -dy / norm;\n            const uy = dx / norm;\n            const cx1 = mx + ux * offset;\n            const cy1 = my + uy * offset;\n            d = `M ${s.x} ${s.y} Q ${cx1} ${cy1} ${t.x} ${t.y}`;\n          } else {\n            d = `M ${s.x} ${s.y} L ${t.x} ${t.y}`;\n          }\n          path.setAttribute('d', d);\n          edgesLayer.appendChild(path);\n\n          // Event for selecting/removing edge\n          path.addEventListener('click', (ev) => {\n            ev.stopPropagation();\n            selectedEdgeId = (selectedEdgeId === ed.id) ? null : ed.id;\n            render();\n          });\n\n          path.addEventListener('dblclick', (ev) => {\n            ev.stopPropagation();\n            if (weighted) {\n              const newW = prompt('Edit edge weight', ed.weight);\n              if (newW !== null) {\n                ed.weight = parseFloat(newW) || ed.weight;\n                render();\n              }\n            } else {\n              if (!confirm('Remove this edge?')) return;\n              edges = edges.filter(x => x.id !== ed.id);\n              render();\n            }\n          });\n\n          // Edge label (weight)\n          if (weighted) {\n            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n            label.classList.add('edge-label');\n            // compute point at middle of the path\n            const tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n            tempPath.setAttribute('d', d);\n            const l = tempPath.getTotalLength();\n            const pos = tempPath.getPointAtLength(l / 2);\n            label.setAttribute('x', pos.x + 8);\n            label.setAttribute('y', pos.y - 6);\n            label.textContent = String(ed.weight);\n            labelsLayer.appendChild(label);\n          }\n        });\n      }\n\n      // Utility to convert to adjacency list and display\n      function buildAdjacencyList() {\n        // adjacency list: map nodeLabel -> array of {label,weight}\n        const map = {};\n        nodes.forEach(n => map[n.label] = []);\n        edges.forEach(e => {\n          const s = getNodeById(e.source);\n          const t = getNodeById(e.target);\n          if (!s || !t) return;\n          map[s.label].push(weighted ? { to: t.label, w: e.weight } : { to: t.label });\n          if (!directed) {\n            // For undirected graphs, also show the reverse\n            map[t.label].push(weighted ? { to: s.label, w: e.weight } : { to: s.label });\n          }\n        });\n        // Sorting adjacency lists for determinism\n        Object.keys(map).forEach(k => {\n          map[k].sort((a,b)=> (a.to||a) > (b.to||b) ? 1 : -1);\n        });\n        return map;\n      }\n\n      function updateAdjList() {\n        const map = buildAdjacencyList();\n        // Render a friendly textual representation\n        const lines = [];\n        Object.keys(map).forEach(u => {\n          const arr = map[u];\n          if (weighted) {\n            const targets = arr.map(o => `${o.to}(${o.w})`).join(', ');\n            lines.push(`${u} -> [ ${targets} ]`);\n          } else {\n            const targets = arr.map(o => o.to).join(', ');\n            lines.push(`${u} -> [ ${targets} ]`);\n          }\n        });\n        adjListDiv.textContent = lines.join('\\n') || '(empty graph)';\n      }\n\n      function updateEdgeList() {\n        if (edges.length === 0) { edgeListDiv.textContent = '(no edges)'; return; }\n        const lines = edges.map(e => {\n          const s = getNodeById(e.source)?.label || e.source;\n          const t = getNodeById(e.target)?.label || e.target;\n          return weighted ? `${s} -(${e.weight})-> ${t}` : `${s} -> ${t}`;\n        });\n        edgeListDiv.textContent = lines.join('\\n');\n      }\n\n      function updateMatrix() {\n        if (nodes.length === 0) { matrixDiv.textContent = '(empty)'; return; }\n        // Build an index map by label\n        const labels = nodes.map(n => n.label);\n        const idx = {};\n        labels.forEach((l,i)=>idx[l]=i);\n        // Initialize matrix with zeros or Infinity for weighted?\n        const mat = Array(labels.length).fill(0).map(()=>Array(labels.length).fill(0));\n        edges.forEach(e => {\n          const s = getNodeById(e.source);\n          const t = getNodeById(e.target);\n          if (!s||!t) return;\n          const i = idx[s.label], j = idx[t.label];\n          mat[i][j] = weighted ? e.weight : 1;\n          if (!directed) mat[j][i] = weighted ? e.weight : 1;\n        });\n        // Format matrix as text\n        const header = ['   '].concat(labels.map(l => pad(l,6))).join('');\n        const rows = labels.map((l,i) => {\n          const row = mat[i].map(v => pad(String(v),6)).join('');\n          return pad(l,3) + ' ' + row;\n        });\n        matrixDiv.textContent = header + '\\n' + rows.join('\\n');\n      }\n\n      function pad(s, n) {\n        s = String(s);\n        while (s.length < n) s = s + ' ';\n        return s;\n      }\n\n      function getSvgPoint(evt) {\n        const pt = svg.createSVGPoint();\n        pt.x = evt.clientX;\n        pt.y = evt.clientY;\n        const ctm = svg.getScreenCTM().inverse();\n        const sp = pt.matrixTransform(ctm);\n        // Due to viewBox scaling, convert to viewBox coordinates\n        const vb = svg.viewBox.baseVal;\n        const rect = svg.getBoundingClientRect();\n        const scaleX = vb.width / rect.width;\n        const scaleY = vb.height / rect.height;\n        // map screen coords to viewBox coords\n        const x = (evt.clientX - rect.left) * scaleX + vb.x;\n        const y = (evt.clientY - rect.top) * scaleY + vb.y;\n        return { x, y };\n      }\n\n      // Graph algorithms: BFS, DFS (return order of node labels and the edges used)\n      function bfs(startNodeId) {\n        const visited = new Set();\n        const queue = [];\n        const order = [];\n        const edgesUsed = [];\n        queue.push(startNodeId);\n        visited.add(startNodeId);\n        while (queue.length) {\n          const u = queue.shift();\n          order.push(getNodeById(u).label);\n          // neighbors: outgoing edges\n          const neighbors = edges.filter(e => e.source === u).map(e => ({id:e.target,edgeId:e.id}));\n          if (!directed) {\n            // for undirected also include incoming edges\n            const inN = edges.filter(e=>e.target === u).map(e=>({id:e.source,edgeId:e.id}));\n            neighbors.push(...inN);\n          }\n          for (const nb of neighbors) {\n            if (!visited.has(nb.id)) {\n              visited.add(nb.id);\n              queue.push(nb.id);\n              edgesUsed.push(nb.edgeId);\n            }\n          }\n        }\n        return { order, edgesUsed };\n      }\n\n      function dfs(startNodeId) {\n        const visited = new Set();\n        const order = [];\n        const edgesUsed = [];\n        function visit(u) {\n          visited.add(u);\n          order.push(getNodeById(u).label);\n          const neighbors = edges.filter(e => e.source === u).map(e => ({id:e.target,edgeId:e.id}));\n          if (!directed) {\n            const inN = edges.filter(e=>e.target === u).map(e=>({id:e.source,edgeId:e.id}));\n            neighbors.push(...inN);\n          }\n          for (const nb of neighbors) {\n            if (!visited.has(nb.id)) {\n              edgesUsed.push(nb.edgeId);\n              visit(nb.id);\n            }\n          }\n        }\n        visit(startNodeId);\n        return { order, edgesUsed };\n      }\n\n      // Animate traversal: highlight nodes and edges\n      function animateTraversal(result) {\n        if (!result || !result.order) return;\n        // reset visuals\n        drawEdges(); drawNodes();\n        const sequence = result.order;\n        const edgesSeq = result.edgesUsed;\n        let i = 0;\n        const highlightNext = () => {\n          if (i >= sequence.length) {\n            // done\n            setTimeout(render, 500);\n            return;\n          }\n          const label = sequence[i];\n          // highlight node with this label\n          nodes.forEach(n => {\n            const nodeEl = nodesLayer.querySelector(`[data-id=\"${n.id}\"]`);\n            if (!nodeEl) return;\n            const circle = nodeEl.querySelector('circle');\n            if (n.label === label) {\n              circle.setAttribute('stroke', '#ffd166');\n              circle.setAttribute('stroke-width', '3.5');\n            } else {\n              circle.setAttribute('stroke', 'rgba(34,193,195,0.14)');\n              circle.setAttribute('stroke-width', '2');\n            }\n          });\n          // highlight edges used up to i\n          edgesLayer.querySelectorAll('path').forEach(p => {\n            const id = p.getAttribute('data-id');\n            if (edgesSeq.slice(0,i).includes(id)) {\n              p.setAttribute('stroke', '#ffd166');\n              p.setAttribute('stroke-width', '3');\n              if (directed) p.setAttribute('marker-end','url(#arrow-orange)');\n            } else {\n              p.setAttribute('stroke', 'rgba(255,255,255,0.12)');\n              p.setAttribute('stroke-width', '2');\n              if (directed) p.setAttribute('marker-end','url(#arrow)');\n            }\n          });\n\n          // show order in a small overlay on adjList\n          adjListDiv.textContent = 'Traversal order: ' + sequence.slice(0, i+1).join(' -> ');\n          i++;\n          setTimeout(highlightNext, 700);\n        };\n        highlightNext();\n      }\n\n      // Initial render\n      updateWeightUI();\n      render();\n\n      // small helper: clicking outside clears selection\n      svg.addEventListener('click', (e) => {\n        if (e.target.tagName === 'svg') {\n          selectedEdgeId = null;\n          render();\n        }\n      });\n\n      // Helpful tip: show adjacency list when user hovers label area\n      // (not necessary)\n\n      // expose some for debugging\n      window.__graph = { nodes, edges };\n\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency List"
    }
  ],
  "topic": "Adjacency List",
  "hasFSM": false,
  "hasTest": true
}