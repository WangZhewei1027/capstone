{
  "id": "be878a80-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:53.020Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Weighted Graph Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  :root{--bg:#0f1720;--panel:#0b1220;--accent:#06b6d4;--muted:#95a0ab;--node:#1f2937;}\n  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,\"Helvetica Neue\",Arial;background:linear-gradient(180deg,#071021 0%, #081424 100%);color:#e6eef6}\n  .app{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box}\n  .panel{width:320px;background:linear-gradient(180deg,var(--panel) 0%, #08111a 100%);border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6);overflow:auto}\n  h1{font-size:18px;margin:0 0 8px;color:#dff7fb}\n  p.lead{margin:6px 0 12px;color:var(--muted);font-size:13px}\n  .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:10px}\n  label.row{display:flex;align-items:center;gap:8px;font-size:13px}\n  input[type=\"number\"],select,input[type=\"text\"]{width:100%;padding:6px 8px;border-radius:6px;border:1px solid #123;background:#07121a;color:#dff7fb}\n  .modes{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:10px}\n  .mode-btn{padding:8px 10px;border-radius:8px;background:#071b25;color:var(--muted);border:1px solid rgba(255,255,255,0.03);cursor:pointer;font-size:13px}\n  .mode-btn.active{background:var(--accent);color:#042024;font-weight:600}\n  button{padding:8px 10px;border-radius:8px;background:#072032;border:1px solid rgba(255,255,255,0.03);color:#dff7fb;cursor:pointer}\n  .btn-row{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}\n  .svg-wrap{flex:1;border-radius:10px;overflow:hidden;position:relative;background:linear-gradient(180deg,#06101a 0%, #05131b 100%);box-shadow:inset 0 0 60px rgba(0,0,0,0.7)}\n  svg{width:100%;height:100%;display:block;touch-action:none}\n  .info{font-size:13px;color:var(--muted);margin-top:10px}\n  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}\n  .legend .item{display:flex;align-items:center;gap:8px;font-size:13px;color:var(--muted)}\n  .node-label{pointer-events:none;font-size:12px;fill:#e6eef6}\n  .edge-weight{pointer-events:none;font-size:12px;fill:#d7f0f4}\n  .small{font-size:12px;color:var(--muted)}\n  footer{position:absolute;left:20px;bottom:18px;color:rgba(255,255,255,0.12);font-size:12px}\n  .top-row{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px}\n  input[type=\"checkbox\"]{transform:scale(1.05)}\n  .status{font-size:13px;color:var(--muted);margin-top:8px}\n  .select-n{width:100%;padding:6px;border-radius:6px;border:1px solid #123;background:#07121a;color:#dff7fb}\n</style>\n</head>\n<body>\n<div class=\"app\">\n  <div class=\"panel\">\n    <div class=\"top-row\">\n      <h1>Weighted Graph — Interactive</h1>\n      <div class=\"small\">Click canvas to add nodes. Drag to move.</div>\n    </div>\n    <p class=\"lead\">Build a weighted graph, add edges with weights, and run algorithms: Dijkstra (shortest path) and Kruskal (MST).</p>\n\n    <div class=\"modes\" id=\"modes\">\n      <button class=\"mode-btn active\" data-mode=\"add-node\">Add Node</button>\n      <button class=\"mode-btn\" data-mode=\"add-edge\">Add Edge</button>\n      <button class=\"mode-btn\" data-mode=\"move\">Move</button>\n      <button class=\"mode-btn\" data-mode=\"delete\">Delete</button>\n    </div>\n\n    <div style=\"display:flex;gap:8px;margin-bottom:8px\">\n      <input type=\"number\" id=\"edgeWeight\" placeholder=\"Edge weight\" value=\"1\" min=\"0\" step=\"1\" />\n      <label style=\"display:flex;align-items:center;gap:6px;color:var(--muted)\">\n        <input type=\"checkbox\" id=\"directed\"> Directed\n      </label>\n    </div>\n\n    <div style=\"display:flex;gap:8px\">\n      <select id=\"selectSource\" class=\"select-n\"><option value=\"\">Source</option></select>\n      <select id=\"selectTarget\" class=\"select-n\"><option value=\"\">Target</option></select>\n    </div>\n\n    <div class=\"btn-row\">\n      <button id=\"btnDijkstra\">Run Dijkstra</button>\n      <button id=\"btnMST\">Run Kruskal (MST)</button>\n      <button id=\"btnClear\">Clear</button>\n      <button id=\"btnRandom\">Random</button>\n    </div>\n\n    <div style=\"margin-top:10px;display:flex;gap:8px\">\n      <button id=\"btnExport\">Export JSON</button>\n      <button id=\"btnImport\">Import JSON</button>\n      <input type=\"file\" id=\"fileInput\" style=\"display:none\" accept=\".json\" />\n    </div>\n\n    <div class=\"info\">\n      <div class=\"legend\">\n        <div class=\"item\"><svg width=\"14\" height=\"14\"><circle cx=\"7\" cy=\"7\" r=\"6\" fill=\"#2dd4bf\"/></svg> Node</div>\n        <div class=\"item\"><svg width=\"40\" height=\"14\"><line x1=\"2\" y1=\"7\" x2=\"38\" y2=\"7\" stroke=\"#9fb7bf\" stroke-width=\"2\"/></svg> Edge</div>\n        <div class=\"item\"><svg width=\"40\" height=\"14\"><line x1=\"2\" y1=\"7\" x2=\"38\" y2=\"7\" stroke=\"#ffd166\" stroke-width=\"4\"/></svg> Highlight</div>\n      </div>\n      <div class=\"status\" id=\"status\">Mode: Add Node</div>\n      <div class=\"small\" style=\"margin-top:8px\">Shortcuts: Delete mode -> click node/edge to remove. Add Edge -> click two nodes. Move -> drag node.</div>\n    </div>\n\n    <footer>&copy; Weighted Graph Demo</footer>\n  </div>\n\n  <div class=\"svg-wrap\">\n    <svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\">\n      <defs>\n        <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n          <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#9fb7bf\"/>\n        </marker>\n        <marker id=\"arrow-highlight\" markerWidth=\"10\" markerHeight=\"10\" refX=\"10\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n          <path d=\"M0,0 L10,5 L0,10 z\" fill=\"#ffd166\"/>\n        </marker>\n      </defs>\n      <g id=\"edges\"></g>\n      <g id=\"edgeLabels\"></g>\n      <g id=\"nodes\"></g>\n      <g id=\"nodeLabels\"></g>\n    </svg>\n  </div>\n</div>\n\n<script>\n(() => {\n  const svg = document.getElementById('svg');\n  const edgesG = document.getElementById('edges');\n  const edgeLabelsG = document.getElementById('edgeLabels');\n  const nodesG = document.getElementById('nodes');\n  const nodeLabelsG = document.getElementById('nodeLabels');\n\n  const modesEl = document.querySelectorAll('.mode-btn');\n  const statusEl = document.getElementById('status');\n  const weightInput = document.getElementById('edgeWeight');\n  const directedChk = document.getElementById('directed');\n  const selectSource = document.getElementById('selectSource');\n  const selectTarget = document.getElementById('selectTarget');\n\n  let mode = 'add-node';\n  let nodes = []; // {id,x,y}\n  let edges = []; // {id,u,v,weight,directed}\n  let nodeIdCounter = 1;\n  let edgeIdCounter = 1;\n  let selectedForEdge = null;\n  let dragging = null;\n  let hoverEdgeId = null;\n  let highlight = {edges: new Set(), nodes: new Set()};\n\n  const R = 18;\n\n  function setMode(m) {\n    mode = m;\n    modesEl.forEach(b => b.classList.toggle('active', b.dataset.mode === m));\n    statusEl.textContent = 'Mode: ' + ({'add-node':'Add Node','add-edge':'Add Edge','move':'Move','delete':'Delete'}[m] || m);\n    selectedForEdge = null;\n    render();\n  }\n  modesEl.forEach(b => b.addEventListener('click', () => setMode(b.dataset.mode)));\n\n  svg.addEventListener('mousedown', svgMouseDown);\n  svg.addEventListener('mousemove', svgMouseMove);\n  window.addEventListener('mouseup', svgMouseUp);\n  svg.addEventListener('click', svgClick);\n\n  function svgCoords(evt) {\n    const rect = svg.getBoundingClientRect();\n    return {x: evt.clientX - rect.left, y: evt.clientY - rect.top};\n  }\n\n  function addNode(x,y,label) {\n    const id = String(nodeIdCounter++);\n    nodes.push({id,x,y,label: label || id});\n    updateSelects();\n    render();\n    return id;\n  }\n\n  function addEdge(u,v,w,directed=false) {\n    if (u === v) return;\n    // prevent duplicate (same direction if directed, or unordered if undirected)\n    const exists = edges.some(e => {\n      if (directed || e.directed) return e.u === u && e.v === v && e.directed === directed;\n      return (e.u === u && e.v === v) || (e.u === v && e.v === u);\n    });\n    if (exists) return;\n    const id = String(edgeIdCounter++);\n    edges.push({id,u,v,weight: Number(w),directed});\n    render();\n    return id;\n  }\n\n  function removeNode(id) {\n    nodes = nodes.filter(n=>n.id!==id);\n    edges = edges.filter(e => e.u!==id && e.v!==id);\n    updateSelects();\n    render();\n  }\n\n  function removeEdge(id) {\n    edges = edges.filter(e=>e.id!==id);\n    render();\n  }\n\n  function updateSelects() {\n    const opts = ['','<option value=\"\">Source</option>'].join('');\n    selectSource.innerHTML = '<option value=\"\">Source</option>';\n    selectTarget.innerHTML = '<option value=\"\">Target</option>';\n    nodes.forEach(n => {\n      const o1 = document.createElement('option'); o1.value = n.id; o1.textContent = n.label || n.id;\n      const o2 = document.createElement('option'); o2.value = n.id; o2.textContent = n.label || n.id;\n      selectSource.appendChild(o1); selectTarget.appendChild(o2);\n    });\n  }\n\n  function render() {\n    // Clear\n    while (edgesG.firstChild) edgesG.removeChild(edgesG.firstChild);\n    while (edgeLabelsG.firstChild) edgeLabelsG.removeChild(edgeLabelsG.firstChild);\n    while (nodesG.firstChild) nodesG.removeChild(nodesG.firstChild);\n    while (nodeLabelsG.firstChild) nodeLabelsG.removeChild(nodeLabelsG.firstChild);\n\n    // Draw edges\n    edges.forEach(e => {\n      const u = nodes.find(n=>n.id===e.u);\n      const v = nodes.find(n=>n.id===e.v);\n      if (!u || !v) return;\n      // compute line endpoints offset by node radius\n      const dx = v.x - u.x, dy = v.y - u.y;\n      const dist = Math.hypot(dx,dy) || 1;\n      const ux = dx/dist, uy = dy/dist;\n      const offset = R - 3;\n      const x1 = u.x + ux * offset, y1 = u.y + uy * offset;\n      const x2 = v.x - ux * offset, y2 = v.y - uy * offset;\n\n      // thicker if highlighted\n      const isHighlighted = highlight.edges.has(e.id);\n      const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n      line.setAttribute('x1',x1); line.setAttribute('y1',y1); line.setAttribute('x2',x2); line.setAttribute('y2',y2);\n      line.setAttribute('stroke', isHighlighted ? '#ffd166' : '#9fb7bf');\n      line.setAttribute('stroke-width', isHighlighted ? 4 : 2);\n      line.setAttribute('stroke-linecap','round');\n      if (e.directed) {\n        line.setAttribute('marker-end', isHighlighted ? 'url(#arrow-highlight)' : 'url(#arrow)');\n      }\n      line.dataset.edgeId = e.id;\n      line.style.cursor = 'pointer';\n      line.addEventListener('click', (ev)=>{ ev.stopPropagation(); if(mode==='delete'){ removeEdge(e.id); } });\n      line.addEventListener('mouseenter', ()=>{ hoverEdgeId = e.id; });\n      line.addEventListener('mouseleave', ()=>{ hoverEdgeId = null; });\n      edgesG.appendChild(line);\n\n      // weight label\n      const lx = (x1 + x2)/2, ly = (y1 + y2)/2;\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('x', lx);\n      text.setAttribute('y', ly - 6);\n      text.setAttribute('text-anchor','middle');\n      text.setAttribute('class','edge-weight');\n      text.setAttribute('fill', isHighlighted ? '#27241c' : '#d7f0f4');\n      text.textContent = e.weight;\n      edgeLabelsG.appendChild(text);\n\n      // small invisible thick path for easier clicking\n      const hit = document.createElementNS('http://www.w3.org/2000/svg','line');\n      hit.setAttribute('x1',x1); hit.setAttribute('y1',y1); hit.setAttribute('x2',x2); hit.setAttribute('y2',y2);\n      hit.setAttribute('stroke','transparent'); hit.setAttribute('stroke-width',12); hit.dataset.edgeId = e.id;\n      hit.addEventListener('click',(ev)=>{ ev.stopPropagation(); if(mode==='delete'){ removeEdge(e.id); }});\n      edgesG.appendChild(hit);\n    });\n\n    // Draw nodes\n    nodes.forEach(n => {\n      const isSel = selectedForEdge === n.id;\n      const isHighlighted = highlight.nodes.has(n.id);\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      g.setAttribute('transform', `translate(${n.x},${n.y})`);\n      g.style.cursor = mode === 'move' ? 'grab' : 'pointer';\n\n      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      circle.setAttribute('r', R);\n      circle.setAttribute('fill', isHighlighted ? '#ffd166' : '#2dd4bf');\n      circle.setAttribute('stroke', isSel ? '#ffffff' : '#08323a');\n      circle.setAttribute('stroke-width', isSel ? 3 : 2);\n      circle.dataset.nodeId = n.id;\n      circle.addEventListener('mousedown',(ev)=>{ ev.stopPropagation(); onNodeMouseDown(ev,n.id); });\n      circle.addEventListener('click',(ev)=>{ ev.stopPropagation(); onNodeClick(n.id); });\n      circle.addEventListener('dblclick',(ev)=>{ ev.stopPropagation(); const lab=prompt('Node label', n.label||n.id); if(lab!==null){ n.label=lab; updateSelects(); render(); } });\n      g.appendChild(circle);\n\n      // id/label\n      const txt = document.createElementNS('http://www.w3.org/2000/svg','text');\n      txt.setAttribute('x',0); txt.setAttribute('y',4); txt.setAttribute('text-anchor','middle');\n      txt.setAttribute('class','node-label');\n      txt.textContent = n.label || n.id;\n      nodeLabelsG.appendChild(txt);\n      // For easier drag detection place text separately aligned (so nodesG shows circles stacked)\n      nodesG.appendChild(g);\n    });\n  }\n\n  function onNodeClick(nodeId) {\n    if (mode === 'add-edge') {\n      if (!selectedForEdge) {\n        selectedForEdge = nodeId;\n        render();\n      } else if (selectedForEdge === nodeId) {\n        selectedForEdge = null;\n        render();\n      } else {\n        const w = Number(weightInput.value) || 1;\n        addEdge(selectedForEdge, nodeId, w, directedChk.checked);\n        selectedForEdge = null;\n        render();\n      }\n    } else if (mode === 'delete') {\n      if (confirm('Delete node and its edges?')) removeNode(nodeId);\n    }\n  }\n\n  function onNodeMouseDown(evt,nodeId) {\n    if (mode === 'move') {\n      dragging = {id: nodeId, offset: svgCoords(evt)};\n      const n = nodes.find(x=>x.id===nodeId);\n      dragging.dx = dragging.offset.x - n.x;\n      dragging.dy = dragging.offset.y - n.y;\n      svg.style.userSelect = 'none';\n    }\n  }\n\n  function svgMouseDown(evt) {\n    // add node on click if in add-node mode\n    if (mode === 'add-node') {\n      const c = svgCoords(evt);\n      addNode(c.x,c.y);\n    }\n  }\n\n  function svgMouseMove(evt) {\n    const c = svgCoords(evt);\n    if (dragging) {\n      const n = nodes.find(x=>x.id===dragging.id);\n      if (!n) return;\n      n.x = c.x - dragging.dx;\n      n.y = c.y - dragging.dy;\n      render();\n    }\n  }\n\n  function svgMouseUp(evt) {\n    if (dragging) {\n      dragging = null;\n      svg.style.userSelect = '';\n    }\n  }\n\n  function svgClick(evt) {\n    // used to clear selectedForEdge when clicking background\n    if (mode === 'add-edge') {\n      if (selectedForEdge) {\n        selectedForEdge = null;\n        render();\n      }\n    }\n  }\n\n  // Buttons\n  document.getElementById('btnClear').addEventListener('click', ()=>{\n    if (!confirm('Clear the entire graph?')) return;\n    nodes = []; edges = []; nodeIdCounter = 1; edgeIdCounter = 1;\n    updateSelects(); render();\n  });\n\n  document.getElementById('btnRandom').addEventListener('click', ()=>{\n    // create small random graph\n    nodes = []; edges = []; nodeIdCounter=1; edgeIdCounter=1;\n    const n = 7;\n    const pad = 40;\n    const W = svg.clientWidth, H = svg.clientHeight;\n    for (let i=0;i<n;i++){\n      addNode(pad + Math.random()*(W-2*pad), pad + Math.random()*(H-2*pad));\n    }\n    // random edges\n    const nodeIds = nodes.map(a=>a.id);\n    for (let i=0;i<n-1;i++){\n      const u = nodeIds[i];\n      const v = nodeIds[i+1];\n      addEdge(u,v,Math.ceil(Math.random()*9));\n    }\n    for (let i=0;i<n;i++){\n      if (Math.random()<0.5){\n        const u = nodeIds[Math.floor(Math.random()*n)];\n        const v = nodeIds[Math.floor(Math.random()*n)];\n        if (u!==v) addEdge(u,v,Math.ceil(Math.random()*12));\n      }\n    }\n    updateSelects(); render();\n  });\n\n  // Export / Import\n  document.getElementById('btnExport').addEventListener('click', ()=>{\n    const data = {nodes,edges};\n    const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url; a.download = 'graph.json'; a.click();\n    URL.revokeObjectURL(url);\n  });\n  document.getElementById('btnImport').addEventListener('click', ()=> document.getElementById('fileInput').click());\n  document.getElementById('fileInput').addEventListener('change', (ev)=>{\n    const f = ev.target.files[0];\n    if (!f) return;\n    const reader = new FileReader();\n    reader.onload = ()=> {\n      try {\n        const data = JSON.parse(reader.result);\n        if (Array.isArray(data.nodes) && Array.isArray(data.edges)) {\n          nodes = data.nodes.map(n=>({...n}));\n          edges = data.edges.map(e=>({...e}));\n          // set counters\n          nodeIdCounter = nodes.reduce((m,n)=>Math.max(m, Number(n.id)||0),0)+1;\n          edgeIdCounter = edges.reduce((m,e)=>Math.max(m, Number(e.id)||0),0)+1;\n          updateSelects(); render();\n        } else alert('Invalid JSON format.');\n      } catch (err) { alert('Error reading file: '+err); }\n    };\n    reader.readAsText(f);\n  });\n\n  // Algorithms\n  document.getElementById('btnDijkstra').addEventListener('click', ()=>{\n    const s = selectSource.value, t = selectTarget.value;\n    if (!s || !t) { alert('Please select source and target nodes'); return; }\n    const res = dijkstra(s);\n    if (!res.dist[t] || !isFinite(res.dist[t])) {\n      alert('Target unreachable from source.');\n      highlight = {edges:new Set(), nodes:new Set()};\n      render();\n      return;\n    }\n    // reconstruct path\n    const pathNodes = [];\n    let cur = t;\n    while(cur) { pathNodes.push(cur); if (cur===s) break; cur=res.prev[cur]; }\n    pathNodes.reverse();\n    // compute edges in path\n    const pathEdges = new Set();\n    for (let i=0;i<pathNodes.length-1;i++){\n      const a=pathNodes[i], b=pathNodes[i+1];\n      // find matching edge (respecting direction)\n      const e = edges.find(ed=>{\n        if (ed.directed) return ed.u===a && ed.v===b;\n        return (ed.u===a && ed.v===b) || (ed.u===b && ed.v===a);\n      });\n      if (e) pathEdges.add(e.id);\n    }\n    highlight = {edges: pathEdges, nodes: new Set(pathNodes)};\n    render();\n    alert('Shortest path weight = '+res.dist[t]+' (path: '+pathNodes.join(' → ')+')');\n  });\n\n  document.getElementById('btnMST').addEventListener('click', ()=>{\n    // Kruskal for undirected portion: ignore directed edges for MST (or treat them as undirected)\n    if (nodes.length===0) return;\n    // build edges sorted\n    const pool = edges.map(e=>e).sort((a,b)=>a.weight-b.weight);\n    const uf = new UnionFind(nodes.map(n=>n.id));\n    const treeEdges = new Set();\n    let total = 0;\n    for (const e of pool) {\n      if (!uf.same(e.u,e.v)) {\n        uf.unite(e.u,e.v);\n        treeEdges.add(e.id);\n        total += e.weight;\n      }\n    }\n    highlight = {edges: treeEdges, nodes: new Set(nodes.map(n=>n.id))};\n    render();\n    alert('MST computed. Total weight = '+total);\n  });\n\n  // Dijkstra implementation\n  function dijkstra(source) {\n    const dist = {}; const prev = {};\n    const q = new MinHeap();\n    nodes.forEach(n => { dist[n.id]=Infinity; prev[n.id]=null; });\n    dist[source]=0; q.push({id:source,dist:0});\n    while (!q.empty()) {\n      const cur = q.pop();\n      if (cur.dist !== dist[cur.id]) continue;\n      // relax neighbors\n      for (const e of edges) {\n        let nei = null; let w = e.weight;\n        if (e.u === cur.id) nei = e.v;\n        else if (e.v === cur.id) {\n          if (e.directed) { if (e.v === cur.id && e.u !== cur.id) { /* e: u->v, so cannot go v->u */ } }\n          // if directed and direction is u->v, then only allow u->v; else if undirected allow both\n          if (!e.directed) nei = e.u;\n        }\n        // For directed edges, allow from u->v only\n        if (e.directed) {\n          if (e.u === cur.id) nei = e.v;\n          else nei = null;\n        }\n        if (!nei) continue;\n        const nd = dist[cur.id] + Number(w);\n        if (nd < dist[nei]) {\n          dist[nei] = nd; prev[nei] = cur.id; q.push({id:nei,dist:nd});\n        }\n      }\n    }\n    return {dist,prev};\n  }\n\n  // Utility: MinHeap for Dijkstra\n  class MinHeap {\n    constructor(){ this.a=[]; }\n    push(x){ this.a.push(x); this._siftUp(this.a.length-1); }\n    pop(){\n      if (this.a.length===0) return null;\n      const r = this.a[0];\n      const last = this.a.pop();\n      if (this.a.length) { this.a[0]=last; this._siftDown(0); }\n      return r;\n    }\n    empty(){ return this.a.length===0; }\n    _siftUp(i){\n      while(i>0){\n        const p = Math.floor((i-1)/2);\n        if (this.a[p].dist <= this.a[i].dist) break;\n        [this.a[p],this.a[i]]=[this.a[i],this.a[p]]; i=p;\n      }\n    }\n    _siftDown(i){\n      const n=this.a.length;\n      while(true){\n        let l=2*i+1, r=2*i+2, smallest=i;\n        if (l<n && this.a[l].dist < this.a[smallest].dist) smallest=l;\n        if (r<n && this.a[r].dist < this.a[smallest].dist) smallest=r;\n        if (smallest===i) break;\n        [this.a[i],this.a[smallest]]=[this.a[smallest],this.a[i]];\n        i=smallest;\n      }\n    }\n  }\n\n  // Union-Find\n  class UnionFind {\n    constructor(items){\n      this.p = {}; this.r = {};\n      items.forEach(x=>{ this.p[x]=x; this.r[x]=0; });\n    }\n    find(a){ return this.p[a]===a ? a : (this.p[a]=this.find(this.p[a])); }\n    unite(a,b){\n      a=this.find(a); b=this.find(b); if (a===b) return false;\n      if (this.r[a]<this.r[b]) this.p[a]=b; else if (this.r[b]<this.r[a]) this.p[b]=a; else { this.p[b]=a; this.r[a]++; }\n      return true;\n    }\n    same(a,b){ return this.find(a)===this.find(b); }\n  }\n\n  // initialize with a small example\n  function initDemo() {\n    nodes = []; edges = []; nodeIdCounter=1; edgeIdCounter=1;\n    const a = addNode(120, 120); const b = addNode(280,80); const c=addNode(420,160);\n    const d = addNode(220,260); const e = addNode(420,280);\n    addEdge(a,b,4); addEdge(a,d,2); addEdge(b,c,3); addEdge(d,e,7); addEdge(c,e,1); addEdge(b,d,5);\n    updateSelects(); render();\n  }\n\n  initDemo();\n\n  // make SVG responsive on resize\n  window.addEventListener('resize', ()=> render());\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": false,
  "hasTest": true
}