{
  "id": "be876372-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:38.002Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Binary Search Tree (BST) Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 0; padding: 0; display:flex; flex-direction:column; min-height:100vh; }\n    header { background:#0b5; padding:12px 18px; color:#003; }\n    header h1 { margin:0; font-size:18px; }\n    .container { display:flex; gap:12px; padding:12px; flex:1; }\n    .controls { width:320px; background:#fafafa; border-right:1px solid #eee; padding:12px; box-sizing:border-box; }\n    .controls label { display:block; margin-top:8px; font-weight:600; }\n    .controls input[type=\"number\"], .controls input[type=\"text\"] { width:100%; padding:8px; box-sizing:border-box; margin-top:6px; }\n    .controls button { margin-top:8px; padding:8px 10px; width:100%; border:0; background:#0366d6; color:white; cursor:pointer; border-radius:6px; }\n    .controls button.secondary { background:#6c757d; }\n    .controls .row { display:flex; gap:8px; }\n    .controls .row button { flex:1; margin-top:6px; }\n    .info { margin-top:12px; font-size:13px; color:#333; background:#fff; padding:8px; border-radius:6px; border:1px solid #eee; max-height:180px; overflow:auto; }\n    .visual { flex:1; padding:12px; display:flex; flex-direction:column; gap:8px; }\n    #stageWrap { background:linear-gradient(#fff,#f8fafc); border:1px solid #e6eef8; border-radius:8px; padding:8px; flex:1; overflow:auto; }\n    svg { width:100%; height:520px; }\n    .log { font-family: monospace; font-size:13px; background:#111; color:#bfffbf; padding:8px; border-radius:6px; max-height:120px; overflow:auto; }\n    footer { padding:8px 12px; font-size:12px; color:#666; border-top:1px solid #eee; }\n    .small { font-size:13px; color:#444; margin-top:8px; }\n  </style>\n</head>\n<body>\n  <header>\n    <h1>Binary Search Tree (BST) Visualizer</h1>\n  </header>\n\n  <div class=\"container\">\n    <div class=\"controls\">\n      <label for=\"valueInput\">Value (number)</label>\n      <input id=\"valueInput\" type=\"number\" placeholder=\"e.g. 42\" />\n\n      <div class=\"row\">\n        <button id=\"insertBtn\">Insert</button>\n        <button id=\"deleteBtn\" class=\"secondary\">Delete</button>\n      </div>\n\n      <label for=\"searchInput\" style=\"margin-top:10px\">Search</label>\n      <input id=\"searchInput\" type=\"number\" placeholder=\"e.g. 42\" />\n      <div class=\"row\">\n        <button id=\"searchBtn\">Search</button>\n        <button id=\"clearBtn\" class=\"secondary\">Clear Tree</button>\n      </div>\n\n      <label style=\"margin-top:10px\">Utilities</label>\n      <div class=\"row\">\n        <button id=\"randomBtn\">Randomize (10)</button>\n        <button id=\"balancedBtn\" class=\"secondary\">Make Balanced</button>\n      </div>\n\n      <label style=\"margin-top:10px\">Traversals</label>\n      <div class=\"row\">\n        <button id=\"inorderBtn\">In-order</button>\n        <button id=\"preorderBtn\" class=\"secondary\">Pre-order</button>\n      </div>\n      <div class=\"row\">\n        <button id=\"postorderBtn\">Post-order</button>\n        <button id=\"levelBtn\" class=\"secondary\">Level-order</button>\n      </div>\n\n      <div class=\"small\">Click a node to delete it. Search animates visited nodes. Duplicates are ignored.</div>\n\n      <div class=\"info\" id=\"info\">Tree is empty.</div>\n    </div>\n\n    <div class=\"visual\">\n      <div id=\"stageWrap\">\n        <svg id=\"svgStage\" xmlns=\"http://www.w3.org/2000/svg\"></svg>\n      </div>\n      <div style=\"display:flex; gap:8px;\">\n        <div style=\"flex:1\">\n          <div class=\"log\" id=\"log\">Ready.</div>\n        </div>\n        <div style=\"width:260px\">\n          <div style=\"margin-bottom:6px; font-weight:600\">Traversal Output</div>\n          <div class=\"info\" id=\"traversal\">—</div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <footer>BST demo • Insert, Search, Delete, Traversals, Randomize, and simple layout/animation</footer>\n\n  <script>\n    // BST Implementation + Visualization\n    (function () {\n      // Data structure\n      function Node(value) {\n        this.value = value;\n        this.left = null;\n        this.right = null;\n        // visualization props\n        this.x = 0;\n        this.y = 0;\n        this.id = 'n' + (++Node.counter);\n      }\n      Node.counter = 0;\n\n      let root = null;\n\n      // DOM\n      const svg = document.getElementById('svgStage');\n      const info = document.getElementById('info');\n      const log = document.getElementById('log');\n      const traversalEl = document.getElementById('traversal');\n\n      // UI\n      const valInput = document.getElementById('valueInput');\n      const insertBtn = document.getElementById('insertBtn');\n      const deleteBtn = document.getElementById('deleteBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const randomBtn = document.getElementById('randomBtn');\n      const balancedBtn = document.getElementById('balancedBtn');\n      const searchInput = document.getElementById('searchInput');\n      const searchBtn = document.getElementById('searchBtn');\n      const inorderBtn = document.getElementById('inorderBtn');\n      const preorderBtn = document.getElementById('preorderBtn');\n      const postorderBtn = document.getElementById('postorderBtn');\n      const levelBtn = document.getElementById('levelBtn');\n\n      // Insert value\n      function insert(value) {\n        if (root === null) {\n          root = new Node(value);\n          logMsg('Inserted root: ' + value);\n          update();\n          return true;\n        }\n        let cur = root;\n        while (true) {\n          if (value === cur.value) {\n            logMsg('Value exists: ' + value + ' (duplicates ignored)');\n            return false;\n          } else if (value < cur.value) {\n            if (cur.left === null) {\n              cur.left = new Node(value);\n              logMsg('Inserted ' + value + ' (left of ' + cur.value + ')');\n              update();\n              return true;\n            }\n            cur = cur.left;\n          } else {\n            if (cur.right === null) {\n              cur.right = new Node(value);\n              logMsg('Inserted ' + value + ' (right of ' + cur.value + ')');\n              update();\n              return true;\n            }\n            cur = cur.right;\n          }\n        }\n      }\n\n      // Search returning path\n      function search(value) {\n        let path = [];\n        let cur = root;\n        while (cur) {\n          path.push(cur);\n          if (value === cur.value) {\n            return { found: true, path: path, node: cur };\n          } else if (value < cur.value) {\n            cur = cur.left;\n          } else {\n            cur = cur.right;\n          }\n        }\n        return { found: false, path: path, node: null };\n      }\n\n      // Find minimum node and its parent in subtree\n      function findMinNodeWithParent(node) {\n        let parent = null;\n        let cur = node;\n        while (cur.left) {\n          parent = cur;\n          cur = cur.left;\n        }\n        return { min: cur, parent: parent };\n      }\n\n      // Delete value\n      function deleteValue(value) {\n        let deleted = false;\n\n        function remove(node, value) {\n          if (!node) return null;\n          if (value < node.value) {\n            node.left = remove(node.left, value);\n            return node;\n          } else if (value > node.value) {\n            node.right = remove(node.right, value);\n            return node;\n          } else {\n            // node to delete\n            deleted = true;\n            // case: no child\n            if (!node.left && !node.right) return null;\n            // case: one child\n            if (!node.left) return node.right;\n            if (!node.right) return node.left;\n            // case: two children -> replace with inorder successor\n            let { min } = findMinNodeWithParent(node.right);\n            node.value = min.value;\n            node.right = remove(node.right, min.value);\n            return node;\n          }\n        }\n\n        root = remove(root, value);\n        if (deleted) {\n          logMsg('Deleted ' + value);\n        } else {\n          logMsg('Value not found: ' + value);\n        }\n        update();\n        return deleted;\n      }\n\n      // Traversals\n      function inorder(node, arr) {\n        if (!node) return;\n        inorder(node.left, arr);\n        arr.push(node.value);\n        inorder(node.right, arr);\n      }\n      function preorder(node, arr) {\n        if (!node) return;\n        arr.push(node.value);\n        preorder(node.left, arr);\n        preorder(node.right, arr);\n      }\n      function postorder(node, arr) {\n        if (!node) return;\n        postorder(node.left, arr);\n        postorder(node.right, arr);\n        arr.push(node.value);\n      }\n      function levelOrder(node, arr) {\n        if (!node) return;\n        const q = [node];\n        while (q.length) {\n          const n = q.shift();\n          arr.push(n.value);\n          if (n.left) q.push(n.left);\n          if (n.right) q.push(n.right);\n        }\n      }\n\n      // Balanced tree creation from sorted array\n      function buildBalancedFromSorted(arr, l = 0, r = arr.length - 1) {\n        if (l > r) return null;\n        const m = Math.floor((l + r) / 2);\n        const n = new Node(arr[m]);\n        n.left = buildBalancedFromSorted(arr, l, m - 1);\n        n.right = buildBalancedFromSorted(arr, m + 1, r);\n        return n;\n      }\n\n      // Utility log\n      function logMsg(msg) {\n        const t = new Date().toLocaleTimeString();\n        log.textContent = '[' + t + '] ' + msg + '\\n' + log.textContent;\n      }\n\n      // Visualization layout: in-order x assignment\n      function assignPositions() {\n        let spacingX = 60;\n        let spacingY = 84;\n        let nextX = 0;\n        function dfs(node, depth) {\n          if (!node) return;\n          dfs(node.left, depth + 1);\n          node.x = nextX++ * spacingX + 40;\n          node.y = depth * spacingY + 40;\n          dfs(node.right, depth + 1);\n        }\n        nextX = 0;\n        dfs(root, 0);\n      }\n\n      // Draw the tree in SVG\n      function draw() {\n        // clear\n        while (svg.firstChild) svg.removeChild(svg.firstChild);\n\n        if (!root) {\n          info.textContent = 'Tree is empty.';\n          return;\n        }\n        assignPositions();\n\n        // draw edges first\n        function drawEdges(node) {\n          if (!node) return;\n          if (node.left) {\n            let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n            line.setAttribute('x1', node.x);\n            line.setAttribute('y1', node.y);\n            line.setAttribute('x2', node.left.x);\n            line.setAttribute('y2', node.left.y);\n            line.setAttribute('stroke', '#999');\n            line.setAttribute('stroke-width', '2');\n            svg.appendChild(line);\n          }\n          if (node.right) {\n            let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n            line.setAttribute('x1', node.x);\n            line.setAttribute('y1', node.y);\n            line.setAttribute('x2', node.right.x);\n            line.setAttribute('y2', node.right.y);\n            line.setAttribute('stroke', '#999');\n            line.setAttribute('stroke-width', '2');\n            svg.appendChild(line);\n          }\n          drawEdges(node.left);\n          drawEdges(node.right);\n        }\n        drawEdges(root);\n\n        // draw nodes (circles + text), clickable\n        function drawNodes(node) {\n          if (!node) return;\n          // group\n          const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n          g.setAttribute('transform', 'translate(' + node.x + ',' + node.y + ')');\n          g.setAttribute('data-id', node.id);\n          g.style.cursor = 'pointer';\n\n          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n          circle.setAttribute('r', 20);\n          circle.setAttribute('fill', '#fff');\n          circle.setAttribute('stroke', '#0366d6');\n          circle.setAttribute('stroke-width', '2');\n          circle.setAttribute('class', 'bst-node');\n          g.appendChild(circle);\n\n          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n          text.setAttribute('x', 0);\n          text.setAttribute('y', 6);\n          text.setAttribute('text-anchor', 'middle');\n          text.setAttribute('font-size', '12');\n          text.setAttribute('fill', '#0366d6');\n          text.textContent = node.value;\n          g.appendChild(text);\n\n          // click events: delete node on click\n          g.addEventListener('click', function (ev) {\n            ev.stopPropagation();\n            if (confirm('Delete node ' + node.value + '?')) {\n              deleteValue(node.value);\n            }\n          });\n\n          // attach to svg\n          svg.appendChild(g);\n\n          // annotate data-id mapping (so we can highlight by node object later)\n          g._nodeRef = node;\n\n          drawNodes(node.left);\n          drawNodes(node.right);\n        }\n        drawNodes(root);\n\n        info.textContent = 'Root: ' + root.value;\n      }\n\n      // Highlight path (array of node objects) sequentially\n      function animatePath(path, found) {\n        if (!path || path.length === 0) {\n          logMsg('No nodes visited.');\n          return;\n        }\n        let i = 0;\n        function step() {\n          // clear all highlights\n          const allCircles = svg.querySelectorAll('g > circle');\n          allCircles.forEach(c => c.setAttribute('fill', '#fff'));\n          const allTexts = svg.querySelectorAll('g > text');\n          allTexts.forEach(t => t.setAttribute('fill', '#0366d6'));\n\n          // highlight visited up to i\n          for (let j = 0; j <= i && j < path.length; j++) {\n            // find group for this node\n            const groups = svg.querySelectorAll('g');\n            for (const g of groups) {\n              if (g._nodeRef === path[j]) {\n                const c = g.querySelector('circle');\n                const t = g.querySelector('text');\n                if (j === i) {\n                  c.setAttribute('fill', found && j === path.length - 1 ? '#7ee787' : '#ffe08a'); // green if found at last\n                  t.setAttribute('fill', '#000');\n                } else {\n                  c.setAttribute('fill', '#fff3cd');\n                  t.setAttribute('fill', '#000');\n                }\n                break;\n              }\n            }\n          }\n          i++;\n          if (i < path.length) {\n            setTimeout(step, 450);\n          } else {\n            // final highlight for result remains for a short time, then clear\n            setTimeout(() => {\n              const allCircles2 = svg.querySelectorAll('g > circle');\n              allCircles2.forEach(c => c.setAttribute('fill', '#fff'));\n              const allTexts2 = svg.querySelectorAll('g > text');\n              allTexts2.forEach(t => t.setAttribute('fill', '#0366d6'));\n            }, 800);\n          }\n        }\n        step();\n      }\n\n      // Update UI and redraw\n      function update() {\n        draw();\n        updateInfo();\n      }\n\n      function updateInfo() {\n        if (!root) {\n          info.textContent = 'Tree is empty.';\n          document.title = 'BST: empty';\n          traversalEl.textContent = '—';\n          return;\n        }\n        document.title = 'BST: root=' + root.value;\n        // show some stats\n        let count = 0, height = 0;\n        function dfs(n, d) {\n          if (!n) return;\n          count++;\n          height = Math.max(height, d);\n          dfs(n.left, d + 1);\n          dfs(n.right, d + 1);\n        }\n        dfs(root, 1);\n        info.textContent = 'Nodes: ' + count + ' • Height: ' + height + ' • Root: ' + root.value;\n      }\n\n      // Wire controls\n      insertBtn.addEventListener('click', () => {\n        const v = Number(valInput.value);\n        if (Number.isNaN(v)) { alert('Enter a number'); return; }\n        insert(v);\n        valInput.value = '';\n      });\n      deleteBtn.addEventListener('click', () => {\n        const v = Number(valInput.value);\n        if (Number.isNaN(v)) { alert('Enter a number to delete (or click a node)'); return; }\n        deleteValue(v);\n        valInput.value = '';\n      });\n      clearBtn.addEventListener('click', () => {\n        if (!root) return;\n        if (!confirm('Clear the entire tree?')) return;\n        root = null;\n        logMsg('Tree cleared.');\n        update();\n      });\n\n      randomBtn.addEventListener('click', () => {\n        // generate 10 distinct random integers between 1 and 99\n        const arr = [];\n        while (arr.length < 10) {\n          const n = Math.floor(Math.random() * 99) + 1;\n          if (!arr.includes(n)) arr.push(n);\n        }\n        root = null;\n        Node.counter = 0;\n        arr.forEach(n => insert(n));\n        logMsg('Random tree generated: ' + arr.join(', '));\n        update();\n      });\n\n      balancedBtn.addEventListener('click', () => {\n        // create balanced tree from current nodes\n        const arr = [];\n        inorder(root, arr);\n        if (arr.length === 0) { alert('Tree is empty.'); return; }\n        Node.counter = 0;\n        root = buildBalancedFromSorted(arr);\n        logMsg('Balanced tree created from sorted values.');\n        update();\n      });\n\n      searchBtn.addEventListener('click', () => {\n        const v = Number(searchInput.value);\n        if (Number.isNaN(v)) { alert('Enter a number to search'); return; }\n        const res = search(v);\n        if (res.path.length === 0) {\n          logMsg('Search visited 0 nodes.');\n        } else {\n          logMsg('Search visited: ' + res.path.map(n => n.value).join(' -> '));\n        }\n        animatePath(res.path, res.found);\n        if (res.found) {\n          logMsg('Found: ' + v);\n        } else {\n          logMsg('Not found: ' + v);\n        }\n      });\n\n      inorderBtn.addEventListener('click', () => {\n        const arr = [];\n        inorder(root, arr);\n        traversalEl.textContent = arr.length ? arr.join(', ') : '—';\n        logMsg('In-order: ' + (arr.length ? arr.join(', ') : 'empty'));\n      });\n      preorderBtn.addEventListener('click', () => {\n        const arr = [];\n        preorder(root, arr);\n        traversalEl.textContent = arr.length ? arr.join(', ') : '—';\n        logMsg('Pre-order: ' + (arr.length ? arr.join(', ') : 'empty'));\n      });\n      postorderBtn.addEventListener('click', () => {\n        const arr = [];\n        postorder(root, arr);\n        traversalEl.textContent = arr.length ? arr.join(', ') : '—';\n        logMsg('Post-order: ' + (arr.length ? arr.join(', ') : 'empty'));\n      });\n      levelBtn.addEventListener('click', () => {\n        const arr = [];\n        levelOrder(root, arr);\n        traversalEl.textContent = arr.length ? arr.join(', ') : '—';\n        logMsg('Level-order: ' + (arr.length ? arr.join(', ') : 'empty'));\n      });\n\n      // click on blank SVG to focus inputs / clear highlight\n      svg.addEventListener('click', () => {\n        // clear highlight\n        const allCircles = svg.querySelectorAll('g > circle');\n        allCircles.forEach(c => c.setAttribute('fill', '#fff'));\n        const allTexts = svg.querySelectorAll('g > text');\n        allTexts.forEach(t => t.setAttribute('fill', '#0366d6'));\n      });\n\n      // initialize with a sample tree\n      (function seed() {\n        const sample = [50, 30, 70, 20, 40, 60, 80];\n        root = null;\n        Node.counter = 0;\n        sample.forEach(n => insert(n));\n        logMsg('Sample tree loaded: ' + sample.join(', '));\n        update();\n      })();\n\n      // expose some functions to console for experimentation (optional)\n      window._bst = {\n        insert: (v) => insert(Number(v)),\n        delete: (v) => deleteValue(Number(v)),\n        search: (v) => search(Number(v)),\n        root: () => root\n      };\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": false,
  "hasTest": true
}