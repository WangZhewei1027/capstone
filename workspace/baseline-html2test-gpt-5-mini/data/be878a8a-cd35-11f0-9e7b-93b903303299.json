{
  "id": "be878a8a-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:14:07.916Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Heap Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Heap Sort Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#4f46e5;\n      --muted:#9aa4bf;\n      --good:#16a34a;\n      --bad:#ef4444;\n      --compare:#f59e0b;\n      --swap:#ef4444;\n      --bar:#60a5fa;\n      --sorted:#10b981;\n      --text:#e6eef8;\n      --glass: rgba(255,255,255,0.03);\n    }\n    *{box-sizing:border-box;font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;}\n    html,body{height:100%;margin:0;background:linear-gradient(180deg, #071025 0%, #081028 60%); color:var(--text);}\n    .container{max-width:1200px;margin:18px auto;padding:18px;}\n    header{display:flex;align-items:center;gap:16px;margin-bottom:16px}\n    h1{font-size:20px;margin:0}\n    .controls{display:flex;flex-wrap:wrap;gap:12px;align-items:center;background:var(--panel);padding:12px;border-radius:10px;box-shadow: 0 6px 18px rgba(6,8,12,0.6)}\n    .control-group{display:flex;gap:8px;align-items:center}\n    label{font-size:13px;color:var(--muted)}\n    input[type=range]{width:160px}\n    button{background:linear-gradient(180deg,var(--accent),#3730a3);color:white;padding:8px 12px;border-radius:8px;border:0;cursor:pointer;box-shadow: 0 6px 14px rgba(79,70,229,0.18)}\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);box-shadow:none}\n    input[type=text]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);min-width:220px}\n    .main{display:grid;grid-template-columns:1fr 360px;gap:16px;margin-top:16px}\n    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.012));padding:12px;border-radius:10px;box-shadow: 0 6px 18px rgba(2,6,23,0.6)}\n    #visual{height:420px;display:flex;flex-direction:column;gap:8px;align-items:center;justify-content:center}\n    #arrayCanvas{width:100%;height:180px;display:block}\n    #treeSVG{width:100%;height:200px;display:block}\n    .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}\n    .legend span{font-size:13px;padding:6px 8px;border-radius:6px;background:var(--glass);display:inline-flex;gap:8px;align-items:center}\n    .dot{width:12px;height:12px;border-radius:3px;display:inline-block}\n    .info{font-size:13px;color:var(--muted);margin-top:8px}\n    pre{background:transparent;padding:8px;border-radius:8px;overflow:auto;color:var(--muted);font-size:13px}\n    .pseudocode{line-height:1.6;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);font-family:monospace;margin-top:8px}\n    .pseudocode div{padding:4px 6px;border-radius:6px}\n    .pseudocode .active{background:linear-gradient(90deg, rgba(79,70,229,0.12), rgba(79,70,229,0.04));color:var(--text)}\n    footer{margin-top:12px;font-size:13px;color:var(--muted)}\n    .small{font-size:12px;color:var(--muted)}\n    .big-button{padding:10px 14px;font-weight:600}\n    .center{display:flex;align-items:center;gap:8px}\n    .stats{display:flex;flex-direction:column;gap:6px;padding:8px}\n    .stat{display:flex;justify-content:space-between;color:var(--muted);font-size:14px;padding:4px 6px;border-radius:6px}\n    .array-controls{display:flex;gap:8px;flex-wrap:wrap}\n    @media(max-width:980px){\n      .main{grid-template-columns:1fr}\n      #visual{height:520px}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <header>\n      <h1>Heap Sort — Visualizer & Interactive Demo</h1>\n      <div class=\"small\" style=\"margin-left:auto\">Algorithm: In-place, comparison-based, O(n log n) average/worst</div>\n    </header>\n\n    <div class=\"controls\">\n      <div class=\"control-group\">\n        <label>Array size</label>\n        <input id=\"sizeRange\" type=\"range\" min=\"5\" max=\"32\" value=\"12\" />\n        <div id=\"sizeLabel\" class=\"small\">12</div>\n      </div>\n\n      <div class=\"control-group\">\n        <label>Speed</label>\n        <input id=\"speedRange\" type=\"range\" min=\"50\" max=\"2000\" value=\"450\" />\n        <div id=\"speedLabel\" class=\"small\">450 ms</div>\n      </div>\n\n      <div class=\"control-group array-controls\">\n        <button id=\"randomBtn\">Randomize</button>\n        <button id=\"ascBtn\" class=\"ghost\">Ascending</button>\n        <button id=\"descBtn\" class=\"ghost\">Descending</button>\n      </div>\n\n      <div style=\"margin-left:auto;display:flex;gap:8px\">\n        <button id=\"playBtn\" class=\"big-button\">Play</button>\n        <button id=\"stepBackBtn\" class=\"ghost\">Step ◀</button>\n        <button id=\"stepFwdBtn\" class=\"ghost\">Step ▶</button>\n        <button id=\"recordBtn\" class=\"ghost\">Record</button>\n      </div>\n    </div>\n\n    <div class=\"main\">\n      <div class=\"panel\" id=\"visual\">\n        <svg id=\"treeSVG\" viewBox=\"0 0 1000 360\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n        <canvas id=\"arrayCanvas\"></canvas>\n\n        <div class=\"legend\">\n          <span><span class=\"dot\" style=\"background:var(--compare)\"></span> Comparing</span>\n          <span><span class=\"dot\" style=\"background:var(--swap)\"></span> Swapping</span>\n          <span><span class=\"dot\" style=\"background:var(--sorted)\"></span> Sorted</span>\n          <span><span class=\"dot\" style=\"background:var(--bar)\"></span> Unsorted</span>\n        </div>\n\n        <div class=\"info\" id=\"actionText\">Press Record to generate the step list, then Play or Step through actions.</div>\n      </div>\n\n      <div class=\"panel\">\n        <div class=\"stats\">\n          <div class=\"stat\"><strong>Action</strong><span id=\"statAction\">—</span></div>\n          <div class=\"stat\"><strong>Comparisons</strong><span id=\"statCompares\">0</span></div>\n          <div class=\"stat\"><strong>Swaps</strong><span id=\"statSwaps\">0</span></div>\n          <div class=\"stat\"><strong>Heap size</strong><span id=\"statHeapSize\">—</span></div>\n          <div class=\"stat\"><strong>Step</strong><span id=\"statStep\">0 / 0</span></div>\n        </div>\n\n        <div style=\"margin-top:10px\">\n          <label>Custom array (comma separated)</label>\n          <div style=\"display:flex;gap:8px;margin-top:6px\">\n            <input id=\"customInput\" type=\"text\" placeholder=\"e.g. 5,3,8,1,7\" />\n            <button id=\"applyCustom\" class=\"ghost\">Apply</button>\n          </div>\n        </div>\n\n        <div class=\"pseudocode\" id=\"pseudocode\">\n          <!-- pseudocode lines will be inserted by JS -->\n        </div>\n\n        <footer>\n          <div style=\"margin-top:10px\" class=\"small\">\n            How it works: First build a max-heap (sift-down from middle to root). Then repeatedly swap the root (max) with the last element of the heap, reduce heap size, and sift-down the new root. This demo records comparisons and swaps and replays them for step-by-step visualization.\n          </div>\n        </footer>\n      </div>\n    </div>\n  </div>\n\n  <script>\n/*\n  Heap Sort Visualizer\n  - Records actions (compare, swap, changeHeapSize, markSorted) while performing heap sort on a copy.\n  - Replay engine rebuilds the array at any step by re-applying actions from the initial array.\n  - Visualizes array as bars and as a binary tree (SVG). Highlights indices involved in current action.\n*/\n\n(function(){\n  // UI references\n  const sizeRange = document.getElementById('sizeRange');\n  const sizeLabel = document.getElementById('sizeLabel');\n  const speedRange = document.getElementById('speedRange');\n  const speedLabel = document.getElementById('speedLabel');\n  const randomBtn = document.getElementById('randomBtn');\n  const ascBtn = document.getElementById('ascBtn');\n  const descBtn = document.getElementById('descBtn');\n  const playBtn = document.getElementById('playBtn');\n  const stepBackBtn = document.getElementById('stepBackBtn');\n  const stepFwdBtn = document.getElementById('stepFwdBtn');\n  const recordBtn = document.getElementById('recordBtn');\n  const arrayCanvas = document.getElementById('arrayCanvas');\n  const treeSVG = document.getElementById('treeSVG');\n  const actionText = document.getElementById('actionText');\n  const statCompares = document.getElementById('statCompares');\n  const statSwaps = document.getElementById('statSwaps');\n  const statHeapSize = document.getElementById('statHeapSize');\n  const statAction = document.getElementById('statAction');\n  const statStep = document.getElementById('statStep');\n  const customInput = document.getElementById('customInput');\n  const applyCustom = document.getElementById('applyCustom');\n  const pseudocodeDiv = document.getElementById('pseudocode');\n\n  const ctx = arrayCanvas.getContext('2d');\n\n  // State\n  let array = [];\n  let initialArray = [];\n  let actions = []; // recorded actions\n  let stepIndex = 0; // how many actions applied (0..actions.length)\n  let playing = false;\n  let timer = null;\n  let compares = 0, swaps = 0;\n  let currentMarkers = {}; // for highlighting current indices in visualization\n  let heapSize = 0;\n\n  // pseudocode lines for highlighting\n  const pseudocodeLines = [\n    \"function heapSort(A):\",\n    \"  n = A.length\",\n    \"  // Build max heap\",\n    \"  for i = floor(n/2)-1 down to 0:\",\n    \"    siftDown(A, i, n)\",\n    \"  // Extract elements\",\n    \"  for end = n-1 down to 1:\",\n    \"    swap(A[0], A[end])\",\n    \"    heapSize = end\",\n    \"    siftDown(A, 0, heapSize)\",\n    \"\",\n    \"function siftDown(A, i, heapSize):\",\n    \"  while true:\",\n    \"    left = 2*i + 1\",\n    \"    right = left + 1\",\n    \"    largest = i\",\n    \"    if left < heapSize and A[left] > A[largest]: largest = left\",\n    \"    if right < heapSize and A[right] > A[largest]: largest = right\",\n    \"    if largest == i: break\",\n    \"    swap(A[i], A[largest])\",\n    \"    i = largest\"\n  ];\n\n  function renderPseudocode(activeIndex){\n    pseudocodeDiv.innerHTML = '';\n    pseudocodeLines.forEach((line, i) => {\n      const el = document.createElement('div');\n      el.textContent = (i+1).toString().padStart(2,' ') + \"  \" + line;\n      if(activeIndex === i+1) el.classList.add('active');\n      pseudocodeDiv.appendChild(el);\n    });\n  }\n\n  // Initialize pseudocode\n  renderPseudocode(null);\n\n  // Helpers: random array\n  function generateRandom(n){\n    const arr=[];\n    for(let i=0;i<n;i++){\n      arr.push(Math.floor(Math.random()*100)+1);\n    }\n    return arr;\n  }\n\n  function setArray(arr){\n    array = arr.slice();\n    initialArray = arr.slice();\n    actions = [];\n    stepIndex = 0;\n    compares = 0;\n    swaps = 0;\n    heapSize = arr.length;\n    updateStats();\n    draw();\n    treeDraw();\n    actionText.textContent = \"Array ready. Press Record to produce the action list for Heap Sort.\";\n  }\n\n  // Resize canvas to device pixel ratio for crispness\n  function fitCanvas(){\n    const dpr = window.devicePixelRatio || 1;\n    const rect = arrayCanvas.getBoundingClientRect();\n    arrayCanvas.width = Math.max(300, rect.width) * dpr;\n    arrayCanvas.height = rect.height * dpr;\n    ctx.setTransform(dpr,0,0,dpr,0,0);\n  }\n  window.addEventListener('resize',()=>{\n    fitCanvas();\n    draw();\n    treeDraw();\n  });\n\n  // Drawing array as bars\n  function draw(stateArray = array, markers = currentMarkers){\n    fitCanvas();\n    const w = arrayCanvas.width / (window.devicePixelRatio || 1);\n    const h = arrayCanvas.height / (window.devicePixelRatio || 1);\n    ctx.clearRect(0,0,w,h);\n    const n = stateArray.length;\n    if(n===0) return;\n    const padding = 10;\n    const usableW = w - padding*2;\n    const gap = Math.max(2, Math.floor(usableW / (n*15)));\n    const barW = Math.max(8, (usableW - (n-1)*gap)/n);\n    const maxVal = Math.max(...stateArray);\n    for(let i=0;i<n;i++){\n      const val = stateArray[i];\n      const x = padding + i*(barW+gap);\n      const barH = (h-40) * (val / (maxVal || 1));\n      const y = h - barH - 20;\n      // decide color\n      let color = getComputedStyle(document.documentElement).getPropertyValue('--bar').trim();\n      if(markers.swap && (markers.swap[0]===i || markers.swap[1]===i)) color = getComputedStyle(document.documentElement).getPropertyValue('--swap').trim();\n      else if(markers.compare && (markers.compare[0]===i || markers.compare[1]===i)) color = getComputedStyle(document.documentElement).getPropertyValue('--compare').trim();\n      else if(markers.sorted && markers.sorted.includes(i)) color = getComputedStyle(document.documentElement).getPropertyValue('--sorted').trim();\n      // draw bar\n      ctx.fillStyle = color;\n      roundRect(ctx, x, y, barW, barH, 4, true, false);\n      // index label\n      ctx.fillStyle = \"#dbeafe\";\n      ctx.font = \"11px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(String(val), x+barW/2, h-6);\n    }\n  }\n\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof stroke == 'undefined') stroke = true;\n    if (typeof r === 'undefined') r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y,   x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x,   y + h, r);\n    ctx.arcTo(x,   y + h, x,   y,   r);\n    ctx.arcTo(x,   y,   x + w, y,   r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Tree drawing using indexed positions\n  function treeDraw(stateArray = array, markers = currentMarkers){\n    // clear\n    while(treeSVG.firstChild) treeSVG.removeChild(treeSVG.firstChild);\n    const n = stateArray.length;\n    if(n===0) return;\n    const svgW = 1000;\n    const svgH = 360;\n    // compute positions: per level, nodes spread evenly\n    const positions = [];\n    const levels = Math.floor(Math.log2(n))+1;\n    for(let i=0;i<n;i++){\n      const level = Math.floor(Math.log2(i+1));\n      const indexInLevel = i - (Math.pow(2,level)-1);\n      const nodesThisLevel = Math.pow(2,level);\n      const margin = 40;\n      const availW = svgW - margin*2;\n      const x = margin + (indexInLevel + 0.5) * (availW / nodesThisLevel);\n      const y = 30 + level * (svgH - 60) / Math.max(1, levels-1);\n      positions.push({x,y});\n    }\n    // draw connections\n    for(let i=1;i<n;i++){\n      const parent = Math.floor((i-1)/2);\n      const p = positions[parent];\n      const c = positions[i];\n      const line = document.createElementNS(\"http://www.w3.org/2000/svg\",\"line\");\n      line.setAttribute('x1', p.x);\n      line.setAttribute('y1', p.y + 16);\n      line.setAttribute('x2', c.x);\n      line.setAttribute('y2', c.y - 16);\n      line.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n      line.setAttribute('stroke-width','2');\n      treeSVG.appendChild(line);\n    }\n    // draw nodes\n    for(let i=0;i<n;i++){\n      const pos = positions[i];\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\n      g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);\n      const rect = document.createElementNS(\"http://www.w3.org/2000/svg\",\"rect\");\n      rect.setAttribute('x', -18);\n      rect.setAttribute('y', -18);\n      rect.setAttribute('rx', 6);\n      rect.setAttribute('ry', 6);\n      rect.setAttribute('width', 36);\n      rect.setAttribute('height', 36);\n      // choose fill based on markers\n      let fill = getComputedStyle(document.documentElement).getPropertyValue('--glass').trim();\n      if(markers.swap && (markers.swap[0]===i || markers.swap[1]===i)) fill = getComputedStyle(document.documentElement).getPropertyValue('--swap').trim();\n      else if(markers.compare && (markers.compare[0]===i || markers.compare[1]===i)) fill = getComputedStyle(document.documentElement).getPropertyValue('--compare').trim();\n      else if(markers.sorted && markers.sorted.includes(i)) fill = getComputedStyle(document.documentElement).getPropertyValue('--sorted').trim();\n      rect.setAttribute('fill', fill);\n      rect.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n      g.appendChild(rect);\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n      text.setAttribute('x', 0);\n      text.setAttribute('y', 5);\n      text.setAttribute('text-anchor', 'middle');\n      text.setAttribute('font-size', '13');\n      text.setAttribute('fill', '#e6eef8');\n      text.textContent = String(stateArray[i]);\n      g.appendChild(text);\n      const idxText = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n      idxText.setAttribute('x', 0);\n      idxText.setAttribute('y', 26);\n      idxText.setAttribute('text-anchor', 'middle');\n      idxText.setAttribute('fill', '#9aa4bf');\n      idxText.setAttribute('font-size', '11');\n      idxText.textContent = i;\n      g.appendChild(idxText);\n      treeSVG.appendChild(g);\n    }\n  }\n\n  // Recording actions during heap sort\n  function record(actionType, ...args){\n    actions.push({type:actionType, args:args});\n  }\n\n  // Implement heap sort on a copy while recording actions. We mutate arr internally to simulate behavior and record.\n  function recordHeapSort(arrInput){\n    const arr = arrInput.slice();\n    actions = [];\n    compares = 0;\n    swaps = 0;\n    const n = arr.length;\n    let heapSz = n;\n\n    function recCompare(i,j){\n      if(i<0||j<0||i>=heapSz||j>=heapSz) return;\n      record('compare', i, j);\n      compares++;\n      // no return value recorded; actual comparison done in code below\n    }\n    function recSwap(i,j){\n      record('swap', i, j);\n      const t=arr[i]; arr[i]=arr[j]; arr[j]=t;\n      swaps++;\n    }\n    function siftDown(i){\n      record('siftStart', i); // highlight sifting root\n      while(true){\n        let left = 2*i+1, right = left+1;\n        let largest = i;\n        if(left < heapSz){\n          recCompare(left, largest);\n          if(arr[left] > arr[largest]) largest = left;\n        }\n        if(right < heapSz){\n          recCompare(right, largest);\n          if(arr[right] > arr[largest]) largest = right;\n        }\n        if(largest === i){\n          record('siftEnd', i);\n          break;\n        }\n        recSwap(i, largest);\n        i = largest;\n      }\n    }\n\n    // Build heap\n    for(let i = Math.floor(n/2)-1; i>=0; i--){\n      record('buildStep', i);\n      siftDown(i);\n    }\n\n    // Extract\n    for(let end = n-1; end>0; end--){\n      recSwap(0,end);\n      heapSz = end;\n      record('heapSize', heapSz);\n      record('markSorted', end);\n      siftDown(0);\n    }\n    record('markSorted', 0);\n    record('done');\n    return {actions, compares, swaps};\n  }\n\n  // Apply first k actions to reconstruct state. This allows stepping backwards by resetting and replaying.\n  function applyActions(k){\n    // reset\n    array = initialArray.slice();\n    compares = 0;\n    swaps = 0;\n    heapSize = array.length;\n    currentMarkers = {compare:null, swap:null, sorted:[]};\n    // apply actions in sequence\n    for(let i=0;i<k && i<actions.length;i++){\n      const a = actions[i];\n      if(a.type==='compare'){\n        compares++;\n        currentMarkers.compare = a.args.slice();\n        currentMarkers.swap = null;\n      } else if(a.type==='swap'){\n        swaps++;\n        const [p,q] = a.args;\n        const t = array[p]; array[p] = array[q]; array[q] = t;\n        currentMarkers.swap = a.args.slice();\n        currentMarkers.compare = null;\n      } else if(a.type==='heapSize'){\n        heapSize = a.args[0];\n      } else if(a.type==='markSorted'){\n        const idx = a.args[0];\n        if(!currentMarkers.sorted.includes(idx)) currentMarkers.sorted.push(idx);\n      } else if(a.type==='siftStart'){\n        currentMarkers.compare = null;\n        currentMarkers.swap = null;\n      } else if(a.type==='siftEnd'){\n        // no op\n      } else if(a.type==='buildStep'){\n        // no op\n      } else if(a.type==='done'){\n        // done\n      }\n    }\n    // After replaying up to k, ensure sorted mark includes elements with index >= heapSize\n    for(let i=heapSize;i<array.length;i++){\n      if(!currentMarkers.sorted.includes(i)) currentMarkers.sorted.push(i);\n    }\n    // update UI\n    draw(array, currentMarkers);\n    treeDraw(array, currentMarkers);\n    updateStats();\n  }\n\n  // Progress control\n  function play(){\n    if(playing) return;\n    if(actions.length===0){\n      actionText.textContent = \"No recorded actions. Press Record first.\";\n      return;\n    }\n    playing = true;\n    playBtn.textContent = \"Pause\";\n    runLoop();\n  }\n  function pause(){\n    playing = false;\n    playBtn.textContent = \"Play\";\n    if(timer) { clearTimeout(timer); timer=null; }\n  }\n  function togglePlay(){\n    if(playing) pause(); else play();\n  }\n  function runLoop(){\n    const delay = Math.max(50, parseInt(speedRange.value,10));\n    if(stepIndex >= actions.length){\n      pause();\n      return;\n    }\n    stepIndex++;\n    applyActions(stepIndex);\n    // highlight relevant pseudocode line\n    highlightForAction(actions[Math.max(0,stepIndex-1)]);\n    timer = setTimeout(()=>{\n      if(playing) runLoop();\n    }, delay);\n  }\n\n  // Step functions\n  function stepForward(){\n    if(actions.length===0) { actionText.textContent = \"No recorded actions. Press Record.\"; return; }\n    if(stepIndex < actions.length) stepIndex++;\n    applyActions(stepIndex);\n    highlightForAction(actions[Math.max(0,stepIndex-1)]);\n    pause();\n  }\n  function stepBack(){\n    if(stepIndex>0) stepIndex--;\n    applyActions(stepIndex);\n    if(stepIndex>0) highlightForAction(actions[stepIndex-1]);\n    else { renderPseudocode(null); actionText.textContent = \"At start.\"; }\n    pause();\n  }\n\n  // Map actions to pseudocode lines and action text\n  function highlightForAction(action){\n    if(!action) return;\n    let actionDesc = \"\";\n    let line = null;\n    switch(action.type){\n      case 'compare':\n        actionDesc = `Compare indices ${action.args[0]} and ${action.args[1]}`;\n        line = 14; // comparisons in siftDown (line numbers correspond to pseudocodeLines index +1)\n        break;\n      case 'swap':\n        actionDesc = `Swap indices ${action.args[0]} and ${action.args[1]}`;\n        line = 18;\n        break;\n      case 'heapSize':\n        actionDesc = `Heap size reduced to ${action.args[0]}`;\n        line = 7;\n        break;\n      case 'markSorted':\n        actionDesc = `Mark index ${action.args[0]} as sorted`;\n        line = 6;\n        break;\n      case 'siftStart':\n        actionDesc = `Sift down from index ${action.args[0]}`;\n        line = 11;\n        break;\n      case 'siftEnd':\n        actionDesc = `Sift finished`;\n        line = 16;\n        break;\n      case 'buildStep':\n        actionDesc = `Build-heap: sift index ${action.args[0]}`;\n        line = 4;\n        break;\n      case 'done':\n        actionDesc = `Sorting complete`;\n        line = 6;\n        break;\n      default:\n        actionDesc = action.type;\n    }\n    actionText.textContent = actionDesc;\n    renderPseudocode(line);\n  }\n\n  // Update stat displays\n  function updateStats(){\n    statCompares.textContent = compares;\n    statSwaps.textContent = swaps;\n    statHeapSize.textContent = heapSize;\n    statStep.textContent = `${stepIndex} / ${Math.max(0, actions.length)}`;\n    // action text updated elsewhere\n  }\n\n  // Event handlers\n  sizeRange.addEventListener('input',()=>{\n    const n = parseInt(sizeRange.value,10);\n    sizeLabel.textContent = n;\n    // regenerate random array of size n\n    setArray(generateRandom(n));\n  });\n\n  speedRange.addEventListener('input',()=>{\n    speedLabel.textContent = speedRange.value + \" ms\";\n  });\n\n  randomBtn.addEventListener('click',()=>{\n    setArray(generateRandom(parseInt(sizeRange.value,10)));\n  });\n\n  ascBtn.addEventListener('click',()=>{\n    const n = parseInt(sizeRange.value,10);\n    const arr = [];\n    for(let i=1;i<=n;i++) arr.push(i);\n    setArray(arr);\n  });\n\n  descBtn.addEventListener('click',()=>{\n    const n = parseInt(sizeRange.value,10);\n    const arr = [];\n    for(let i=n;i>=1;i--) arr.push(i);\n    setArray(arr);\n  });\n\n  applyCustom.addEventListener('click',()=>{\n    const text = customInput.value.trim();\n    if(!text) return;\n    const parts = text.split(',').map(s=>s.trim()).filter(s=>s.length);\n    const nums = [];\n    for(const p of parts){\n      const v = Number(p);\n      if(Number.isNaN(v)){ alert('Invalid number: ' + p); return; }\n      nums.push(v);\n    }\n    setArray(nums);\n    sizeRange.value = Math.min(32, Math.max(5, nums.length));\n    sizeLabel.textContent = nums.length;\n  });\n\n  recordBtn.addEventListener('click',()=>{\n    // record actions based on initialArray\n    if(initialArray.length===0) {\n      actionText.textContent = \"No array to record.\";\n      return;\n    }\n    const res = recordHeapSort(initialArray);\n    compares = res.compares;\n    swaps = res.swaps;\n    // reset counters for replay; we'll show final counts via stats as we step\n    stepIndex = 0;\n    currentMarkers = {compare:null, swap:null, sorted:[]};\n    heapSize = initialArray.length;\n    updateStats();\n    actionText.textContent = `Recorded ${actions.length} actions (approx). Comparisons: ${compares}, Swaps: ${swaps}. Use Play or Step to replay.`;\n    // reset counters displayed to zero until replay\n    statCompares.textContent = 0;\n    statSwaps.textContent = 0;\n    statStep.textContent = `0 / ${actions.length}`;\n    renderPseudocode(null);\n  });\n\n  playBtn.addEventListener('click', ()=>{ togglePlay(); });\n\n  stepFwdBtn.addEventListener('click', ()=>{ stepForward(); });\n\n  stepBackBtn.addEventListener('click', ()=>{ stepBack(); });\n\n  // Initialize with random array\n  setArray(generateRandom(parseInt(sizeRange.value,10)));\n\n  // initial drawing\n  draw();\n  treeDraw();\n\n  // Keyboard shortcuts\n  window.addEventListener('keydown',(e)=>{\n    if(e.key === \" \"){ e.preventDefault(); togglePlay(); }\n    if(e.key === \"ArrowRight\"){ stepForward(); }\n    if(e.key === \"ArrowLeft\"){ stepBack(); }\n  });\n\n  // Make sure initial canvas height set\n  function setCanvasHeight(){\n    arrayCanvas.style.height = '180px';\n    fitCanvas();\n    draw();\n  }\n  setCanvasHeight();\n\n})();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap Sort"
    }
  ],
  "topic": "Heap Sort",
  "hasFSM": false,
  "hasTest": true
}