{
  "id": "2bde6a95-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:50.630Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Longest Common Subsequence",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Longest Common Subsequence (LCS) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#0ea5ff;\n      --muted:#94a3b8;\n      --card:#071022;\n      --good:#16a34a;\n      --warn:#f59e0b;\n    }\n    html,body{\n      margin:0;\n      padding:0;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg, #041025 0%, #07172b 100%);\n      color:#e6eef8;\n      min-height:100vh;\n      box-sizing:border-box;\n    }\n    .container{\n      max-width:1100px;\n      margin:30px auto;\n      padding:24px;\n      border-radius:12px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\n    }\n    h1{\n      margin:0 0 6px 0;\n      font-size:20px;\n      color:var(--accent);\n    }\n    p.lead{\n      margin:0 0 18px 0;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .row{\n      display:flex;\n      gap:18px;\n      align-items:flex-start;\n      flex-wrap:wrap;\n    }\n    .col{\n      background:var(--card);\n      padding:14px;\n      border-radius:10px;\n      flex:1 1 320px;\n      min-width:260px;\n      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);\n    }\n    label{\n      display:block;\n      font-size:12px;\n      color:var(--muted);\n      margin-bottom:6px;\n    }\n    input[type=\"text\"], textarea, select{\n      width:100%;\n      padding:10px 12px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.04);\n      background:transparent;\n      color:inherit;\n      resize:none;\n      box-sizing:border-box;\n      font-size:14px;\n    }\n    textarea { min-height:60px; }\n    .controls{\n      display:flex;\n      gap:8px;\n      margin-top:10px;\n      flex-wrap:wrap;\n    }\n    button{\n      background:linear-gradient(180deg,var(--accent),#0090e6);\n      color:#021228;\n      border:none;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      box-shadow: 0 6px 18px rgba(12,56,88,0.25);\n    }\n    button.ghost{\n      background:transparent;\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.03);\n      box-shadow:none;\n    }\n    .small{\n      padding:6px 8px;\n      font-size:13px;\n    }\n    .panel-title{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:10px;\n    }\n    .result{\n      margin-top:12px;\n      padding:12px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:8px;\n      font-size:14px;\n      color:var(--muted);\n    }\n    .badge{\n      display:inline-block;\n      background:rgba(255,255,255,0.02);\n      color:var(--accent);\n      padding:6px 8px;\n      border-radius:8px;\n      font-weight:700;\n      font-size:13px;\n      margin-left:8px;\n    }\n    .matrix-wrap{\n      overflow:auto;\n      max-width:100%;\n      margin-top:12px;\n    }\n    table.matrix{\n      border-collapse:collapse;\n      font-family:monospace;\n      background:transparent;\n      margin-bottom:8px;\n    }\n    table.matrix th, table.matrix td{\n      border:1px solid rgba(255,255,255,0.03);\n      padding:6px 8px;\n      text-align:center;\n      min-width:34px;\n      position:relative;\n      color:var(--muted);\n      font-size:13px;\n    }\n    table.matrix th.header{\n      background:rgba(255,255,255,0.02);\n      color:var(--accent);\n      font-weight:700;\n    }\n    table.matrix td.match{\n      background:linear-gradient(180deg, rgba(16,185,129,0.08), rgba(16,185,129,0.03));\n      color:#a7f3d0;\n      font-weight:700;\n    }\n    table.matrix td.path{\n      outline:3px solid rgba(14,165,255,0.12);\n      box-shadow: inset 0 0 0 1px rgba(14,165,255,0.06);\n    }\n    .cell-arrows{\n      font-size:10px;\n      color:var(--muted);\n      position:absolute;\n      bottom:3px;\n      right:4px;\n    }\n    .meta{\n      font-size:13px;\n      color:var(--muted);\n      margin-top:10px;\n    }\n    .lcs-list{\n      margin-top:10px;\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      align-items:center;\n    }\n    .chip{\n      background:rgba(255,255,255,0.02);\n      color:var(--accent);\n      padding:8px 10px;\n      border-radius:999px;\n      font-weight:600;\n      font-size:13px;\n      cursor:pointer;\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .chip.selected{\n      background:linear-gradient(90deg,var(--accent),#0090e6);\n      color:#021228;\n      box-shadow:0 6px 18px rgba(3,40,62,0.45);\n    }\n    .explain{\n      margin-top:12px;\n      color:var(--muted);\n      font-size:13px;\n      line-height:1.4;\n    }\n    .footnote{\n      margin-top:14px;\n      font-size:12px;\n      color:var(--muted);\n    }\n    .controls .option{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      color:var(--muted);\n      font-size:13px;\n    }\n    .danger{\n      color:#ffb4b4;\n      background:rgba(255,50,50,0.06);\n      padding:6px 8px;\n      border-radius:8px;\n    }\n\n    @media (max-width:820px){\n      .row{ flex-direction:column; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <h1>Longest Common Subsequence (LCS) Visualizer</h1>\n    <p class=\"lead\">Enter two strings to compute their longest common subsequence using dynamic programming. Visualize the DP table, reconstruct one or all LCSs (within limits), and step through the backtracking path.</p>\n\n    <div class=\"row\">\n      <div class=\"col\" style=\"flex:0 0 420px;\">\n        <div class=\"panel-title\">\n          <div>\n            <label for=\"strA\">String A</label>\n            <textarea id=\"strA\" placeholder=\"Type first string (max 120 characters)\">AGGTAB</textarea>\n          </div>\n        </div>\n\n        <div style=\"margin-top:12px;\">\n          <label for=\"strB\">String B</label>\n          <textarea id=\"strB\" placeholder=\"Type second string (max 120 characters)\">GXTXAYB</textarea>\n        </div>\n\n        <div class=\"controls\">\n          <button id=\"computeBtn\">Compute LCS</button>\n          <button id=\"randomBtn\" class=\"ghost small\">Random example</button>\n          <div class=\"option\" style=\"margin-left:auto\">\n            <label title=\"Show all distinct LCS (may be many)\">Show all</label>\n            <input type=\"checkbox\" id=\"showAll\" />\n          </div>\n          <div class=\"option\">\n            <label title=\"Max number of sequences to list\">Limit</label>\n            <input id=\"limit\" type=\"number\" min=\"1\" max=\"1000\" value=\"50\" style=\"width:80px;padding:6px 8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:var(--muted)\"/>\n          </div>\n        </div>\n\n        <div class=\"result\" id=\"summary\">\n          Click \"Compute LCS\" to begin. You can use the random example button for sample input.\n        </div>\n\n        <div class=\"explain\">\n          Notes:\n          <ul style=\"margin-top:8px;color:var(--muted)\">\n            <li>DP computes dp[i][j] = length of LCS of A[0..i-1] and B[0..j-1].</li>\n            <li>Backtracking follows choices: if A[i-1]==B[j-1] take diagonal; else follow larger neighbor (up or left).</li>\n            <li>Number of distinct LCS can grow exponentially — use the <span style=\"color:var(--warn)\">Limit</span> to avoid huge output.</li>\n          </ul>\n        </div>\n      </div>\n\n      <div class=\"col\" style=\"flex:1 1 620px;\">\n        <div class=\"panel-title\">\n          <div>\n            <label>DP Matrix & Reconstruction</label>\n          </div>\n          <div style=\"display:flex;gap:8px;align-items:center\">\n            <button id=\"stepBtn\" class=\"ghost small\">Step backtracking</button>\n            <button id=\"resetStep\" class=\"ghost small\">Reset</button>\n            <button id=\"highlightBtn\" class=\"small\">Highlight greedy LCS path</button>\n          </div>\n        </div>\n\n        <div id=\"matrixContainer\" class=\"matrix-wrap\" aria-live=\"polite\" style=\"min-height:180px;\">\n          <!-- Matrix will be injected here -->\n        </div>\n\n        <div class=\"meta\" id=\"metaInfo\"></div>\n\n        <div id=\"lcsList\" class=\"lcs-list\"></div>\n        <div id=\"foot\" class=\"footnote\"></div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // LCS Visualizer JavaScript. All in one file.\n\n    // DOM references\n    const strAInput = document.getElementById('strA');\n    const strBInput = document.getElementById('strB');\n    const computeBtn = document.getElementById('computeBtn');\n    const randomBtn = document.getElementById('randomBtn');\n    const matrixContainer = document.getElementById('matrixContainer');\n    const summary = document.getElementById('summary');\n    const metaInfo = document.getElementById('metaInfo');\n    const lcsList = document.getElementById('lcsList');\n    const showAllCb = document.getElementById('showAll');\n    const limitInput = document.getElementById('limit');\n    const stepBtn = document.getElementById('stepBtn');\n    const resetStep = document.getElementById('resetStep');\n    const highlightBtn = document.getElementById('highlightBtn');\n    const foot = document.getElementById('foot');\n\n    // State\n    let A = \"\", B = \"\";\n    let dp = []; // dp matrix (m+1) x (n+1)\n    let m = 0, n = 0;\n    let allLCS = [];\n    let greedyPath = []; // array of [i,j] positions\n    let stepIndex = 0; // for stepping\n    let highlighted = false;\n\n    function clampInputLength(s) {\n      // Keep strings reasonable for UI\n      const max = 120;\n      return s.length > max ? s.slice(0, max) : s;\n    }\n\n    function computeDP(a, b) {\n      m = a.length; n = b.length;\n      // dp as (m+1)x(n+1) with zeros\n      dp = Array.from({length: m+1}, () => new Array(n+1).fill(0));\n      for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n          if (a[i-1] === b[j-1]) dp[i][j] = dp[i-1][j-1] + 1;\n          else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n        }\n      }\n      return dp;\n    }\n\n    function buildMatrixHtml(a, b, dp) {\n      // Build an HTML table representation of dp with headers showing chars.\n      // Rows correspond to A (i from 0..m), cols correspond to B (j from 0..n)\n      const table = document.createElement('table');\n      table.className = 'matrix';\n      const thead = document.createElement('thead');\n      const hdrRow = document.createElement('tr');\n\n      // top-left empty corner\n      const empty = document.createElement('th');\n      empty.className = 'header';\n      empty.textContent = '';\n      hdrRow.appendChild(empty);\n\n      // header for B chars (with initial blank)\n      const blank = document.createElement('th');\n      blank.className = 'header';\n      blank.textContent = '∅';\n      hdrRow.appendChild(blank);\n\n      for (let j = 0; j < b.length; j++) {\n        const th = document.createElement('th');\n        th.className = 'header';\n        th.textContent = b[j];\n        hdrRow.appendChild(th);\n      }\n      thead.appendChild(hdrRow);\n      table.appendChild(thead);\n\n      const tbody = document.createElement('tbody');\n\n      // For each row i: header char for A (including blank row), then dp values\n      for (let i = 0; i <= a.length; i++) {\n        const tr = document.createElement('tr');\n\n        // header cell for A (first is ∅)\n        const thRow = document.createElement('th');\n        thRow.className = 'header';\n        thRow.textContent = i === 0 ? '∅' : a[i-1];\n        tr.appendChild(thRow);\n\n        for (let j = 0; j <= b.length; j++) {\n          const td = document.createElement('td');\n          td.dataset.i = i;\n          td.dataset.j = j;\n          td.textContent = dp[i][j];\n          // mark matches (if i>0 && j>0 && a[i-1]==b[j-1])\n          if (i > 0 && j > 0 && a[i-1] === b[j-1]) {\n            td.classList.add('match');\n          }\n          // compute arrows: diagonal if from dp[i-1][j-1] +1 equals; up if dp[i-1][j] == dp[i][j]; left if dp[i][j-1] == dp[i][j]\n          let arrows = [];\n          if (i > 0 && j > 0 && a[i-1] === b[j-1] && dp[i][j] === dp[i-1][j-1] + 1) {\n            arrows.push('↖');\n          }\n          if (i > 0 && dp[i][j] === dp[i-1][j]) arrows.push('↑');\n          if (j > 0 && dp[i][j] === dp[i][j-1]) arrows.push('←');\n\n          if (arrows.length) {\n            const span = document.createElement('span');\n            span.className = 'cell-arrows';\n            span.title = arrows.join(' ');\n            span.textContent = arrows.join('');\n            td.appendChild(span);\n          }\n\n          // click to reconstruct LCS from this cell\n          td.addEventListener('click', () => {\n            // reconstruct one LCS starting from (i,j) greedily\n            const i0 = parseInt(td.dataset.i,10);\n            const j0 = parseInt(td.dataset.j,10);\n            const greedy = reconstructGreedy(a,b,dp,i0,j0);\n            if (greedy === '') {\n              summary.textContent = `Greedy from (${i0},${j0}) => empty LCS (length 0)`;\n            } else {\n              summary.textContent = `Greedy from (${i0},${j0}) => \"${greedy}\" (length ${greedy.length})`;\n            }\n            highlightGreedyPathFor(greedy ? [i0,j0] : null, greedy);\n          });\n\n          tr.appendChild(td);\n        }\n        tbody.appendChild(tr);\n      }\n\n      table.appendChild(tbody);\n      return table;\n    }\n\n    function reconstructGreedy(a,b,dp, i0=null, j0=null) {\n      // Backtracking choosing one path (prefer diagonal when match, else prefer up when dp[i-1][j] >= dp[i][j-1])\n      let i = i0 ?? a.length;\n      let j = j0 ?? b.length;\n      let res = [];\n      greedyPath = [];\n      while (i > 0 && j > 0) {\n        greedyPath.push([i,j]);\n        if (a[i-1] === b[j-1] && dp[i][j] === dp[i-1][j-1] + 1) {\n          res.push(a[i-1]);\n          i--; j--;\n        } else {\n          if (dp[i-1][j] >= dp[i][j-1]) {\n            i--;\n          } else {\n            j--;\n          }\n        }\n      }\n      // include last position (0,0) optionally\n      greedyPath.push([i,j]);\n      return res.reverse().join('');\n    }\n\n    function backtrackAll(a,b,dp, limit = 200) {\n      // Return sorted array of distinct LCS strings.\n      // Use memoization on (i,j).\n      const memo = new Map();\n      function key(i,j){ return i + ',' + j; }\n      function rec(i,j) {\n        const k = key(i,j);\n        if (memo.has(k)) return memo.get(k);\n        let res = new Set();\n        if (i === 0 || j === 0) {\n          res.add('');\n          memo.set(k,res);\n          return res;\n        }\n        if (a[i-1] === b[j-1]) {\n          const prev = rec(i-1,j-1);\n          for (const s of prev) {\n            res.add(s + a[i-1]);\n            if (res.size > limit) break;\n          }\n          memo.set(k,res);\n          return res;\n        } else {\n          if (dp[i-1][j] >= dp[i][j-1]) {\n            const up = rec(i-1,j);\n            for (const s of up) {\n              res.add(s);\n              if (res.size > limit) break;\n            }\n          }\n          if (dp[i][j-1] >= dp[i-1][j]) {\n            const left = rec(i,j-1);\n            for (const s of left) {\n              res.add(s);\n              if (res.size > limit) break;\n            }\n          }\n          memo.set(k,res);\n          return res;\n        }\n      }\n      const out = Array.from(rec(a.length,b.length));\n      // They are built reversed (because we appended from left?), check ordering:\n      // In our construction for the matching case we did s + a[i-1] where prev s is LCS of prefixes up to i-1,j-1.\n      // That means resulting strings are in correct left-to-right order.\n      out.sort();\n      return out;\n    }\n\n    function renderAll() {\n      // read inputs\n      A = clampInputLength(strAInput.value || '');\n      B = clampInputLength(strBInput.value || '');\n      strAInput.value = A;\n      strBInput.value = B;\n      if (A.length === 0 || B.length === 0) {\n        summary.innerHTML = '<span class=\"danger\">Both strings must be non-empty to compute LCS.</span>';\n        matrixContainer.innerHTML = '';\n        metaInfo.textContent = '';\n        lcsList.innerHTML = '';\n        foot.textContent = '';\n        return;\n      }\n      computeDP(A,B);\n      // Build table\n      const table = buildMatrixHtml(A,B,dp);\n      matrixContainer.innerHTML = '';\n      matrixContainer.appendChild(table);\n\n      const lcsLen = dp[m][n];\n      const greedy = reconstructGreedy(A,B,dp); // will set greedyPath\n      // Note: reconstructGreedy set greedyPath for the full (m,n) cell\n      greedyPath = greedyPath.slice(); // snapshot\n      summary.innerHTML = `LCS length = <span class=\"badge\">${lcsLen}</span> &nbsp; Greedy example: <span class=\"badge\">${greedy || '∅'}</span>`;\n      metaInfo.textContent = `Strings: A length=${A.length}, B length=${B.length}. DP table size ${(m+1)}x${(n+1)}.`;\n\n      lcsList.innerHTML = '';\n      const showAll = showAllCb.checked;\n      const limit = Math.max(1, Math.min(10000, parseInt(limitInput.value || '50',10)));\n      if (showAll) {\n        // compute all distinct LCS up to limit\n        const start = performance.now();\n        let all = [];\n        try {\n          all = backtrackAll(A,B,dp, limit+1); // get up to limit+1 to detect truncation\n        } catch (e) {\n          all = [];\n        }\n        const dur = (performance.now() - start).toFixed(1);\n        const truncated = all.length > limit;\n        if (truncated) {\n          all = all.slice(0, limit);\n        }\n        allLCS = all;\n        if (all.length === 0) {\n          lcsList.textContent = 'No subsequence (length 0).';\n        } else {\n          all.forEach((s, idx) => {\n            const chip = document.createElement('div');\n            chip.className = 'chip';\n            chip.textContent = s === '' ? '∅' : s;\n            chip.title = 'Click to highlight the greedy path corresponding to this subsequence (if possible)';\n            chip.addEventListener('click', () => {\n              // When clicking a specific LCS, attempt to highlight one path that realizes it.\n              highlightPathForSequence(s);\n              // mark selection\n              document.querySelectorAll('.chip').forEach(c => c.classList.remove('selected'));\n              chip.classList.add('selected');\n            });\n            lcsList.appendChild(chip);\n          });\n        }\n        foot.textContent = `Computed ${all.length}${truncated? ' (truncated)':''} distinct LCS in ${dur} ms. Limited to ${limit}.`;\n      } else {\n        // show just the greedy one\n        allLCS = [greedy];\n        lcsList.innerHTML = '';\n        const chip = document.createElement('div');\n        chip.className = 'chip selected';\n        chip.textContent = greedy || '∅';\n        chip.title = 'Greedy LCS example';\n        chip.addEventListener('click', () => {\n          highlightGreedyPath();\n        });\n        lcsList.appendChild(chip);\n        foot.textContent = 'Showing a single greedy example (not necessarily the lexicographically smallest). Toggle \"Show all\" to list distinct LCS strings (may be many).';\n      }\n\n      // clear any highlighting\n      clearHighlighting();\n      highlighted = false;\n      stepIndex = 0;\n    }\n\n    function clearHighlighting() {\n      // remove 'path' class\n      document.querySelectorAll('td.path').forEach(td => td.classList.remove('path'));\n    }\n\n    function highlightGreedyPath() {\n      // highlight greedyPath computed from full (m,n)\n      clearHighlighting();\n      if (!greedyPath || greedyPath.length === 0) return;\n      greedyPath.forEach(([i,j]) => {\n        // find the td with data-i and data-j\n        const td = matrixContainer.querySelector(`td[data-i=\"${i}\"][data-j=\"${j}\"]`);\n        if (td) td.classList.add('path');\n      });\n      highlighted = true;\n    }\n\n    function highlightGreedyPathFor(start, seq=null) {\n      // Recompute greedy from start pos if provided. Otherwise use global greedyPath.\n      clearHighlighting();\n      let path = [];\n      if (start) {\n        const seqG = reconstructGreedy(A,B,dp, start[0],start[1]);\n        path = greedyPath.slice();\n      } else {\n        path = greedyPath.slice();\n      }\n      path.forEach(([i,j]) => {\n        const td = matrixContainer.querySelector(`td[data-i=\"${i}\"][data-j=\"${j}\"]`);\n        if (td) td.classList.add('path');\n      });\n      highlighted = true;\n    }\n\n    function highlightPathForSequence(seqStr) {\n      // We know seqStr is an LCS string (one of allLCS). We want to find one path (i,j) sequence in dp that yields it.\n      // We'll backtrack while matching seq characters from end to start.\n      // Approach: walk from (m,n) down while building indexes where matches happen correspond to seq characters.\n      clearHighlighting();\n      if (seqStr === '') return;\n      const L = seqStr.length;\n      let i = m, j = n;\n      const coords = [];\n      let k = L - 1; // index into seqStr from end\n      while (i > 0 && j > 0 && k >= 0) {\n        if (A[i-1] === B[j-1] && A[i-1] === seqStr[k] && dp[i][j] === dp[i-1][j-1] + 1) {\n          coords.push([i,j]);\n          i--; j--; k--;\n        } else {\n          // prefer up if dp[i-1][j] >= dp[i][j-1]\n          if (dp[i-1][j] >= dp[i][j-1]) i--;\n          else j--;\n        }\n      }\n      if (k >= 0) {\n        // failed to find sequence along greedy choices; do a more exhaustive search to find any path that produces seqStr\n        // We'll perform DFS that matches seqStr from start to finish.\n        const target = seqStr;\n        const memo = new Set();\n        let foundPath = null;\n        function dfs(i0,j0, pos, path) {\n          if (foundPath) return true;\n          const key = `${i0},${j0},${pos}`;\n          if (memo.has(key)) return false;\n          memo.add(key);\n          if (pos === target.length) {\n            // must have dp[i0][j0] === dp[0][0] ??? but we want to collect remaining zeros\n            foundPath = path.slice();\n            return true;\n          }\n          if (i0 === 0 || j0 === 0) return false;\n          // try match going backward: look for a match at some (p,q) where A[p-1] == B[q-1] == target[pos]\n          // But pos increases from 0..L-1; we are going forward in sequence; we need to walk forward through indices increasing.\n          // To simplify, we'll search forward from (0,0).\n          return false;\n        }\n        // fallback: highlight nothing\n        foot.textContent = 'Could not locate a simple path for that sequence using greedy backtracking. (This can happen when multiple choices exist.)';\n        return;\n      } else {\n        // coords are match positions in reverse order; highlight them plus intermediate steps optionally\n        coords.forEach(([ii,jj]) => {\n          const td = matrixContainer.querySelector(`td[data-i=\"${ii}\"][data-j=\"${jj}\"]`);\n          if (td) td.classList.add('path');\n        });\n      }\n    }\n\n    // Step backtracking: step through greedyPath showing current cell\n    function stepBacktracking() {\n      if (!greedyPath || greedyPath.length === 0) return;\n      // show next step by toggling 'path' for first stepIndex positions\n      clearHighlighting();\n      stepIndex = (stepIndex + 1) % (greedyPath.length + 1);\n      for (let s = 0; s < stepIndex; s++) {\n        const [i,j] = greedyPath[s];\n        const td = matrixContainer.querySelector(`td[data-i=\"${i}\"][data-j=\"${j}\"]`);\n        if (td) td.classList.add('path');\n      }\n      metaInfo.textContent = `Backtracking step ${stepIndex}/${greedyPath.length}. Click \"Step\" to advance.`;\n    }\n\n    computeBtn.addEventListener('click', () => {\n      try {\n        renderAll();\n      } catch (e) {\n        summary.innerHTML = '<span class=\"danger\">Error computing LCS: ' + (e && e.message ? e.message : String(e)) + '</span>';\n        console.error(e);\n      }\n    });\n\n    randomBtn.addEventListener('click', () => {\n      // generate two random strings using uppercase letters of modest length\n      const letters = \"ABCDEFGHJKLMNPQRSTUVWXYZ\"; // avoid some ambiguous letters\n      const lenA = 6 + Math.floor(Math.random()*5);\n      const lenB = 6 + Math.floor(Math.random()*5);\n      let s1 = '', s2 = '';\n      for (let i=0;i<lenA;i++) s1 += letters[Math.floor(Math.random()*letters.length)];\n      for (let i=0;i<lenB;i++) s2 += letters[Math.floor(Math.random()*letters.length)];\n      strAInput.value = s1;\n      strBInput.value = s2;\n      renderAll();\n    });\n\n    showAllCb.addEventListener('change', () => {\n      // recompute when toggling\n      if (A && B) renderAll();\n    });\n\n    limitInput.addEventListener('change', () => {\n      if (A && B && showAllCb.checked) renderAll();\n    });\n\n    stepBtn.addEventListener('click', () => {\n      if (!greedyPath || greedyPath.length === 0) {\n        metaInfo.textContent = 'No path available. Compute LCS first.';\n        return;\n      }\n      stepBacktracking();\n    });\n\n    resetStep.addEventListener('click', () => {\n      stepIndex = 0;\n      clearHighlighting();\n      metaInfo.textContent = 'Backtracking reset.';\n    });\n\n    highlightBtn.addEventListener('click', () => {\n      if (!greedyPath || greedyPath.length === 0) {\n        metaInfo.textContent = 'No path available. Compute LCS first.';\n        return;\n      }\n      if (highlighted) {\n        clearHighlighting();\n        highlighted = false;\n      } else {\n        highlightGreedyPath();\n        highlighted = true;\n      }\n    });\n\n    // Initial compute for defaults\n    renderAll();\n\n    // Explanatory helper in console\n    console.log('LCS Visualizer ready. Use the UI to compute and explore DP table and backtracking.');\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Longest Common Subsequence"
    }
  ],
  "topic": "Longest Common Subsequence",
  "hasFSM": false,
  "hasTest": true
}