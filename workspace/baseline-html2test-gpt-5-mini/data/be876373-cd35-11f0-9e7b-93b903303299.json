{
  "id": "be876373-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:55.138Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>Interactive Red-Black Tree (Insertion Demonstration)</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 0; padding: 0; background: #f7f8fb; color: #111; }\n  header { padding: 18px 22px; background: linear-gradient(90deg,#3b82f6,#06b6d4); color: white; }\n  header h1 { margin: 0; font-size: 20px; }\n  #container { display:flex; gap:18px; padding:18px; }\n  #left { width: 640px; background: white; border-radius:8px; padding:12px; box-shadow: 0 6px 18px rgba(15,23,42,0.06); }\n  #canvasWrap { background: #fff; border-radius:6px; padding:6px; min-height:420px; display:flex; align-items:center; justify-content:center; }\n  svg { width:100%; height:520px; }\n  #controls { display:flex; gap:8px; align-items:center; padding-top:10px; flex-wrap:wrap; }\n  input[type=\"number\"], input[type=\"text\"] { padding:8px 10px; border-radius:6px; border:1px solid #d1d5db; width:130px; }\n  button { padding:8px 12px; border:none; border-radius:6px; background:#111827; color:white; cursor:pointer; }\n  button.secondary { background:#efefef; color:#111; border:1px solid #e5e7eb; }\n  button:disabled { opacity:0.5; cursor:default; }\n  #stepsPanel { margin-top:12px; max-height:180px; overflow:auto; border-radius:6px; padding:8px; background:#fbfbfd; border:1px dashed #eef2ff; font-size:13px; }\n  .stepItem { padding:6px 8px; border-radius:6px; margin-bottom:6px; cursor:pointer; }\n  .stepItem.active { background:#eef2ff; border:1px solid #c7ddff; }\n  .desc { margin-top:8px; font-size:14px; }\n  #right { flex:1; display:flex; flex-direction:column; gap:12px; }\n  .card { background:white; border-radius:8px; padding:12px; box-shadow: 0 6px 18px rgba(15,23,42,0.04); }\n  .legend { display:flex; gap:10px; align-items:center; font-size:14px; }\n  .legend .nodePreview { width:22px; height:22px; border-radius:22px; display:inline-block; margin-right:6px; border:2px solid #111827; box-sizing: border-box; }\n  .controlsRow { display:flex; gap:8px; align-items:center; }\n  .status { font-size:13px; color:#374151; }\n  .propsGood { color: #047857; font-weight:600 }\n  .propsBad { color:#b91c1c; font-weight:700 }\n  footer { padding:12px 18px; font-size:13px; color:#6b7280; background:transparent; }\n  small.note { color:#6b7280; display:block; margin-top:6px; }\n  .nodeLabel { font-size:12px; text-anchor:middle; dominant-baseline:middle; fill:white; font-weight:700; }\n  .edge { stroke:#94a3b8; stroke-width:2; stroke-linecap:round; }\n</style>\n</head>\n<body>\n  <header>\n    <h1>Red-Black Tree — Interactive Insertion Visualizer</h1>\n    <small style=\"opacity:.9\">See how insertion, recoloring and rotations maintain Red-Black properties (step-by-step).</small>\n  </header>\n\n  <div id=\"container\">\n    <div id=\"left\">\n      <div id=\"canvasWrap\">\n        <svg id=\"svgRoot\" viewBox=\"0 0 1200 520\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n      </div>\n\n      <div id=\"controls\">\n        <input id=\"valueInput\" type=\"number\" placeholder=\"Enter integer\" />\n        <button id=\"insertBtn\">Insert</button>\n        <button id=\"randomBtn\" class=\"secondary\">Insert random</button>\n        <button id=\"clearBtn\" class=\"secondary\">Clear</button>\n\n        <div style=\"margin-left:12px; display:flex; gap:6px; align-items:center;\">\n          <button id=\"prevStep\" class=\"secondary\">Prev</button>\n          <button id=\"playPause\" class=\"secondary\">Play</button>\n          <button id=\"nextStep\" class=\"secondary\">Next</button>\n        </div>\n\n        <div style=\"margin-left:auto; display:flex; gap:6px; align-items:center;\">\n          <label style=\"font-size:13px; color:#374151;\">Speed</label>\n          <input id=\"speed\" type=\"range\" min=\"200\" max=\"2000\" step=\"100\" value=\"900\"/>\n        </div>\n      </div>\n\n      <div id=\"stepsPanel\" aria-live=\"polite\"></div>\n      <div class=\"desc card\" id=\"stepDesc\">No operations yet. Insert a number to see steps.</div>\n    </div>\n\n    <div id=\"right\">\n      <div class=\"card\">\n        <h3 style=\"margin:0 0 8px 0\">Legend & Status</h3>\n        <div class=\"legend\">\n          <div style=\"display:flex; align-items:center;\">\n            <div class=\"nodePreview\" style=\"background: #111827; border-color: #111827;\"></div> Black node\n          </div>\n          <div style=\"display:flex; align-items:center;\">\n            <div class=\"nodePreview\" style=\"background: #ef4444; border-color: #7f1d1d;\"></div> Red node\n          </div>\n        </div>\n        <div style=\"margin-top:10px;\" class=\"status\">\n          Tree size: <span id=\"treeSize\">0</span> nodes\n          <div id=\"propsStatus\" style=\"margin-top:8px;\"></div>\n        </div>\n      </div>\n\n      <div class=\"card\">\n        <h3 style=\"margin:0 0 8px 0\">About</h3>\n        <div style=\"font-size:13px; color:#374151;\">\n          A Red-Black Tree is a self-balancing binary search tree with these key properties:\n          <ul>\n            <li>Every node is red or black.</li>\n            <li>The root is black.</li>\n            <li>No red node has a red parent (no consecutive reds).</li>\n            <li>Every path from a node to its descendant NIL nodes contains the same number of black nodes (black-depth).</li>\n          </ul>\n          This demo implements insertion (CLRS-style). Each step shows the intermediate tree states: insert as red, recolor operations, and rotations that restore balance.\n        </div>\n      </div>\n\n      <div class=\"card\">\n        <h3 style=\"margin:0 0 8px 0\">Tips</h3>\n        <div style=\"font-size:13px; color:#374151;\">\n          - Insert several values to watch how rebalancing works.<br/>\n          - Click steps to jump. Use Play to animate the sequence.<br/>\n          - This demo omits explicit NIL nodes in the drawing for clarity (they remain in the algorithm).\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <footer>\n    Implementation note: Classic insertion algorithm with step recording. Deletion is not implemented in this demo.\n  </footer>\n\n<script>\n(() => {\n  // Simple Red-Black Tree with sentinel NIL, step recording for visualization of insert/fixup.\n  const svg = document.getElementById('svgRoot');\n  const stepsPanel = document.getElementById('stepsPanel');\n  const stepDesc = document.getElementById('stepDesc');\n  const treeSizeEl = document.getElementById('treeSize');\n  const propsStatus = document.getElementById('propsStatus');\n\n  const input = document.getElementById('valueInput');\n  const insertBtn = document.getElementById('insertBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const prevBtn = document.getElementById('prevStep');\n  const nextBtn = document.getElementById('nextStep');\n  const playPauseBtn = document.getElementById('playPause');\n  const speedInput = document.getElementById('speed');\n\n  let playTimer = null;\n\n  // Node ID generator to maintain persistent ids across snapshots\n  let globalNodeId = 1;\n\n  // RB tree internal objects use sentinel nil object for algorithmic simplicity.\n  function createNil() {\n    const n = { id: 0, val: null, color: 'B', left: null, right: null, parent: null };\n    n.left = n.right = n.parent = n;\n    return n;\n  }\n  const NIL = createNil();\n\n  // Root pointer\n  let root = NIL;\n  let nodeCount = 0;\n\n  // Steps array: each step is { nodes: [...], rootId, desc }\n  let steps = [];\n  let stepIndex = -1;\n\n  // Capture snapshot helper: traverse and record nodes (skip NIL sentinel in output)\n  function snapshot(desc, highlightIds=[]) {\n    // BFS or DFS to collect nodes (exclude NIL)\n    const nodes = [];\n    const visited = new Set();\n    function visit(n) {\n      if (!n || n === NIL) return;\n      if (visited.has(n.id)) return;\n      visited.add(n.id);\n      nodes.push({\n        id: n.id,\n        val: n.val,\n        color: n.color,\n        left: n.left !== NIL ? n.left.id : null,\n        right: n.right !== NIL ? n.right.id : null,\n        parent: n.parent !== NIL ? (n.parent ? n.parent.id : null) : null\n      });\n      visit(n.left);\n      visit(n.right);\n    }\n    visit(root);\n    steps.push({ nodes, rootId: root !== NIL ? root.id : null, desc: desc || '', highlight: highlightIds.slice() });\n    stepIndex = steps.length - 1;\n    renderStepsList();\n    renderCurrentStep();\n  }\n\n  // Utility to find a node by value (return actual reference)\n  function findNodeByValue(v) {\n    let x = root;\n    while (x !== NIL) {\n      if (v === x.val) return x;\n      x = v < x.val ? x.left : x.right;\n    }\n    return null;\n  }\n\n  // Left rotate at node x\n  function leftRotate(x) {\n    const y = x.right;\n    // Standard rotate\n    x.right = y.left;\n    if (y.left !== NIL) y.left.parent = x;\n    y.parent = x.parent;\n    if (x.parent === NIL) {\n      root = y;\n    } else if (x === x.parent.left) {\n      x.parent.left = y;\n    } else {\n      x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n    snapshot(`Left rotate at node ${x.val}`, [x.id, y.id]);\n  }\n\n  // Right rotate at node x\n  function rightRotate(x) {\n    const y = x.left;\n    x.left = y.right;\n    if (y.right !== NIL) y.right.parent = x;\n    y.parent = x.parent;\n    if (x.parent === NIL) {\n      root = y;\n    } else if (x === x.parent.right) {\n      x.parent.right = y;\n    } else {\n      x.parent.left = y;\n    }\n    y.right = x;\n    x.parent = y;\n    snapshot(`Right rotate at node ${x.val}`, [x.id, y.id]);\n  }\n\n  // Insert and fix-up with step recording\n  function rbInsertValue(val) {\n    if (typeof val !== 'number' || Number.isNaN(val)) return;\n    if (findNodeByValue(val)) {\n      snapshot(`Value ${val} already exists — no insertion performed.`);\n      return;\n    }\n\n    // Create new node\n    const z = { id: globalNodeId++, val: val, color: 'R', left: NIL, right: NIL, parent: NIL };\n    nodeCount++;\n\n    // BST insert\n    let y = NIL;\n    let x = root;\n    while (x !== NIL) {\n      y = x;\n      if (z.val < x.val) x = x.left;\n      else x = x.right;\n    }\n    z.parent = y;\n    if (y === NIL) {\n      root = z;\n    } else if (z.val < y.val) {\n      y.left = z;\n    } else {\n      y.right = z;\n    }\n\n    snapshot(`Inserted ${z.val} as red leaf`, [z.id, z.parent && z.parent !== NIL ? z.parent.id : null].filter(Boolean));\n\n    // Fixup\n    rbInsertFixup(z);\n    // Ensure root black\n    if (root.color !== 'B') {\n      root.color = 'B';\n      snapshot(`Ensure root is black (set node ${root.val} black)`, [root.id]);\n    }\n\n    snapshot(`Insertion of ${val} complete.`, []);\n  }\n\n  function rbInsertFixup(z) {\n    while (z.parent.color === 'R') {\n      const p = z.parent;\n      const g = p.parent;\n      if (g === NIL) break; // safety\n      if (p === g.left) {\n        const y = g.right;\n        if (y.color === 'R') {\n          // Case 1: uncle red -> recolor parent and uncle black, grandparent red, move z up\n          p.color = 'B';\n          y.color = 'B';\n          g.color = 'R';\n          snapshot(`Case 1: recolor parent ${p.val} and uncle ${y.val} black; grandparent ${g.val} red`, [p.id, y.id, g.id]);\n          z = g;\n        } else {\n          if (z === p.right) {\n            // Case 2: z is right child -> left-rotate at parent\n            z = p;\n            snapshot(`Case 2: prepare left-rotate at parent ${z.val}`, [z.id]);\n            leftRotate(z);\n          }\n          // Case 3: z is left child -> right-rotate at grandparent\n          p.color = 'B';\n          g.color = 'R';\n          snapshot(`Case 3: recolor parent ${p.val} black and grandparent ${g.val} red, then right-rotate at ${g.val}`, [p.id, g.id]);\n          rightRotate(g);\n        }\n      } else {\n        // mirror\n        const y = g.left;\n        if (y.color === 'R') {\n          p.color = 'B';\n          y.color = 'B';\n          g.color = 'R';\n          snapshot(`Case 1 (mirror): recolor parent ${p.val} and uncle ${y.val} black; grandparent ${g.val} red`, [p.id, y.id, g.id]);\n          z = g;\n        } else {\n          if (z === p.left) {\n            z = p;\n            snapshot(`Case 2 (mirror): prepare right-rotate at parent ${z.val}`, [z.id]);\n            rightRotate(z);\n          }\n          p.color = 'B';\n          g.color = 'R';\n          snapshot(`Case 3 (mirror): recolor parent ${p.val} black and grandparent ${g.val} red, then left-rotate at ${g.val}`, [p.id, g.id]);\n          leftRotate(g);\n        }\n      }\n    }\n  }\n\n  // Rendering of a step (snapshot)\n  function renderCurrentStep() {\n    if (stepIndex < 0 || stepIndex >= steps.length) {\n      svg.innerHTML = '';\n      stepDesc.textContent = 'No steps recorded.';\n      treeSizeEl.textContent = nodeCount;\n      updatePropsDisplay(null);\n      return;\n    }\n    const s = steps[stepIndex];\n    stepDesc.textContent = s.desc || '';\n    // Build map of nodes\n    const map = new Map();\n    s.nodes.forEach(n => map.set(n.id, Object.assign({}, n)));\n\n    // Compute positions using inorder traversal starting from rootId\n    let positions = new Map(); // id -> {x,y}\n    let xCounter = 0;\n    const levelGap = 80;\n    const nodeSpacing = 60;\n\n    function inorder(id, depth) {\n      if (id == null || !map.has(id)) return;\n      const node = map.get(id);\n      inorder(node.left, depth + 1);\n      const x = ++xCounter;\n      positions.set(node.id, { x: x, y: depth });\n      inorder(node.right, depth + 1);\n    }\n\n    if (s.rootId !== null && map.size > 0) inorder(s.rootId, 0);\n\n    // If tree is empty, show message\n    svg.innerHTML = '';\n    const width = 1200, height = 520;\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n\n    if (!s.rootId) {\n      const g = createSVG('g', {});\n      const txt = createSVG('text', { x: width/2, y: height/2 - 8, 'text-anchor': 'middle', 'font-size': 18, 'fill': '#475569' });\n      txt.textContent = 'Empty tree — insert values to start';\n      g.appendChild(txt);\n      svg.appendChild(g);\n      treeSizeEl.textContent = nodeCount;\n      updatePropsDisplay(s);\n      return;\n    }\n\n    // translate logical positions to pixels\n    const maxX = Math.max(...Array.from(positions.values()).map(p=>p.x));\n    const xStart = 40;\n    const yStart = 40;\n    const usableW = width - xStart*2;\n    const xStep = maxX > 1 ? Math.max(nodeSpacing, usableW / (maxX)) : usableW / 2;\n    // compute actual coordinates\n    const coords = new Map();\n    positions.forEach((p, id) => {\n      const cx = xStart + (p.x - 0.5) * xStep;\n      const cy = yStart + p.y * levelGap;\n      coords.set(id, {cx, cy});\n    });\n\n    // draw edges first\n    const edgesGroup = createSVG('g', {});\n    map.forEach(n => {\n      const c = coords.get(n.id);\n      if (!c) return;\n      if (n.left !== null && map.has(n.left)) {\n        const lc = coords.get(n.left);\n        edgesGroup.appendChild(createEdge(c.cx, c.cy, lc.cx, lc.cy));\n      }\n      if (n.right !== null && map.has(n.right)) {\n        const rc = coords.get(n.right);\n        edgesGroup.appendChild(createEdge(c.cx, c.cy, rc.cx, rc.cy));\n      }\n    });\n    svg.appendChild(edgesGroup);\n\n    // draw nodes\n    const nodeGroup = createSVG('g', {});\n    map.forEach(n => {\n      const c = coords.get(n.id);\n      if (!c) return;\n      const isHighlighted = (s.highlight || []).includes(n.id);\n      nodeGroup.appendChild(createNode(c.cx, c.cy, n.val, n.color, isHighlighted));\n    });\n    svg.appendChild(nodeGroup);\n\n    treeSizeEl.textContent = nodeCount;\n    updatePropsDisplay(s);\n\n    // Update step list highlighting\n    const items = stepsPanel.querySelectorAll('.stepItem');\n    items.forEach((el, idx) => {\n      el.classList.toggle('active', idx === stepIndex);\n    });\n  }\n\n  // Draw helpers\n  function createSVG(tag, attrs) {\n    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);\n    for (const k in attrs) el.setAttribute(k, attrs[k]);\n    return el;\n  }\n\n  function createEdge(x1,y1,x2,y2) {\n    // draw curved line or simple straight with slight vertical offset to avoid touching node center\n    const g = createSVG('g', {});\n    const path = createSVG('path', {\n      d: `M ${x1} ${y1+18} L ${x2} ${y2-18}`,\n      class: 'edge',\n      fill: 'none'\n    });\n    g.appendChild(path);\n    return g;\n  }\n\n  function createNode(cx, cy, val, color, highlight) {\n    const g = createSVG('g', {});\n    const r = 20;\n    const circle = createSVG('circle', {\n      cx, cy, r,\n      fill: color === 'B' ? '#111827' : '#ef4444',\n      stroke: highlight ? '#fde68a' : '#0f172a',\n      'stroke-width': highlight ? 3 : 2,\n      'filter': 'none'\n    });\n    g.appendChild(circle);\n    const txt = createSVG('text', {\n      x: cx, y: cy, 'class': 'nodeLabel'\n    });\n    txt.textContent = String(val);\n    g.appendChild(txt);\n    return g;\n  }\n\n  // Steps panel rendering\n  function renderStepsList() {\n    stepsPanel.innerHTML = '';\n    steps.forEach((s, idx) => {\n      const div = document.createElement('div');\n      div.className = 'stepItem' + (idx === stepIndex ? ' active' : '');\n      div.textContent = `${idx+1}. ${s.desc}`;\n      div.onclick = () => {\n        stepIndex = idx;\n        stopPlay();\n        renderCurrentStep();\n      };\n      stepsPanel.appendChild(div);\n    });\n  }\n\n  // Play/pause controls\n  function play() {\n    if (playTimer) return;\n    playPauseBtn.textContent = 'Pause';\n    playTimer = setInterval(() => {\n      if (stepIndex < steps.length - 1) {\n        stepIndex++;\n        renderCurrentStep();\n      } else {\n        stopPlay();\n      }\n    }, Number(speedInput.value));\n  }\n  function stopPlay() {\n    if (playTimer) clearInterval(playTimer);\n    playTimer = null;\n    playPauseBtn.textContent = 'Play';\n  }\n\n  // Property check: root black, no red-red, equal black depth\n  function updatePropsDisplay(snapshot) {\n    // Build map\n    if (!snapshot || !snapshot.rootId) {\n      propsStatus.innerHTML = `<span class=\"propsBad\">Tree is empty</span>`;\n      return;\n    }\n    const map = new Map();\n    snapshot.nodes.forEach(n => map.set(n.id, n));\n\n    function check() {\n      const rootNode = map.get(snapshot.rootId);\n      if (!rootNode) return { ok: false, msg: 'Invalid root' };\n      // root black\n      if (rootNode.color !== 'B') return { ok: false, msg: 'Root is not black' };\n\n      // no consecutive reds\n      let redIssue = null;\n      function dfs(nId, parentColor) {\n        if (!nId || !map.has(nId)) return;\n        const n = map.get(nId);\n        if (n.color === 'R' && parentColor === 'R') redIssue = `Red node ${n.val} has red parent`;\n        dfs(n.left, n.color);\n        dfs(n.right, n.color);\n      }\n      dfs(rootNode.id, 'B');\n      if (redIssue) return { ok: false, msg: redIssue };\n\n      // black-depth consistency\n      const blackCounts = new Set();\n      function dfsDepth(nId, currBlack) {\n        if (!nId || !map.has(nId)) {\n          blackCounts.add(currBlack);\n          return;\n        }\n        const n = map.get(nId);\n        if (n.color === 'B') currBlack++;\n        dfsDepth(n.left, currBlack);\n        dfsDepth(n.right, currBlack);\n      }\n      dfsDepth(rootNode.id, 0);\n      if (blackCounts.size !== 1) return { ok: false, msg: `Inconsistent black-depths (${Array.from(blackCounts).join(',')})` };\n\n      return { ok: true, msg: 'All Red-Black properties satisfied' };\n    }\n\n    const res = check();\n    if (res.ok) propsStatus.innerHTML = `<span class=\"propsGood\">${res.msg}</span>`;\n    else propsStatus.innerHTML = `<span class=\"propsBad\">${res.msg}</span>`;\n  }\n\n  // UI event wiring\n  insertBtn.addEventListener('click', () => {\n    const val = Number(input.value);\n    if (!Number.isFinite(val) || input.value.trim() === '') {\n      alert('Please enter an integer value to insert.');\n      return;\n    }\n    stopPlay();\n    rbInsertValue(val);\n    renderStepsList();\n    renderCurrentStep();\n    input.value = '';\n  });\n\n  randomBtn.addEventListener('click', () => {\n    stopPlay();\n    const val = Math.floor(Math.random() * 100);\n    rbInsertValue(val);\n    renderStepsList();\n    renderCurrentStep();\n  });\n\n  clearBtn.addEventListener('click', () => {\n    stopPlay();\n    root = NIL;\n    nodeCount = 0;\n    steps = [];\n    stepIndex = -1;\n    globalNodeId = 1;\n    stepsPanel.innerHTML = '';\n    renderCurrentStep();\n  });\n\n  prevBtn.addEventListener('click', () => {\n    stopPlay();\n    if (stepIndex > 0) {\n      stepIndex--;\n      renderCurrentStep();\n    }\n  });\n\n  nextBtn.addEventListener('click', () => {\n    stopPlay();\n    if (stepIndex < steps.length - 1) {\n      stepIndex++;\n      renderCurrentStep();\n    }\n  });\n\n  playPauseBtn.addEventListener('click', () => {\n    if (playTimer) stopPlay();\n    else {\n      // if at end, go to first\n      if (stepIndex >= steps.length - 1) stepIndex = Math.max(0, steps.length - 1);\n      play();\n    }\n  });\n\n  // keyboard: Enter to insert\n  input.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter') insertBtn.click();\n  });\n\n  // Initial empty snapshot\n  snapshot('Initial empty tree');\n\n  // Expose for debugging (optional)\n  window._rb_demo = {\n    rootRef: () => root,\n    steps,\n    rbInsertValue\n  };\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": false,
  "hasTest": true
}