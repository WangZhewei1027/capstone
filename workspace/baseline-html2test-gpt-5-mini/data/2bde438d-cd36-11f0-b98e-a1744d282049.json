{
  "id": "2bde438d-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:17:11.814Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Depth-First Search (DFS) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#60a5fa;\n      --muted:#94a3b8;\n      --white:#e6eef8;\n      --good:#34d399;\n      --warn:#f59e0b;\n      --bad:#f87171;\n      --glass: rgba(255,255,255,0.04);\n      --node-size:40;\n    }\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071026 0%, #071621 60%);font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial}\n    .app{display:flex;gap:12px;padding:14px;height:100%;box-sizing:border-box;color:var(--white)}\n    .left{flex:1;display:flex;flex-direction:column;gap:12px}\n    .canvas-wrap{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:8px;position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}\n    svg{width:100%;height:100%;touch-action:none;user-select:none}\n    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}\n    button,select,label,input[type=\"checkbox\"]{background:var(--panel);color:var(--white);border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;cursor:pointer}\n    button.active{outline:2px solid rgba(96,165,250,0.16);box-shadow:0 4px 20px rgba(2,6,23,0.6)}\n    .side{width:360px;display:flex;flex-direction:column;gap:12px}\n    .panel{background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);min-height:40px}\n    h3{margin:0 0 8px 0;color:var(--muted);font-weight:600;font-size:13px}\n    .muted{color:var(--muted);font-size:13px}\n    .status-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n    .node{fill:var(--glass);stroke:rgba(255,255,255,0.06);pointer-events:all}\n    .node-label{fill:var(--white);font-weight:600;font-size:13px;text-anchor:middle;dominant-baseline:central;pointer-events:none}\n    .edge{stroke:rgba(255,255,255,0.06);stroke-width:2}\n    .edge.arrow{marker-end:url(#arrow)}\n    .state-white{fill:#0b1220}\n    .state-gray{fill:var(--warn)}\n    .state-black{fill:var(--good)}\n    .state-current{stroke:rgba(96,165,250,0.95);stroke-width:3}\n    .small{font-size:12px;color:var(--muted)}\n    .legend{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n    .chip{padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-size:13px}\n    .list{max-height:220px;overflow:auto;padding:6px;border-radius:6px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}\n    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n    .stack-view, .adj-view{font-family:monospace;background:rgba(0,0,0,0.15);padding:8px;border-radius:6px;color:var(--white)}\n    .code{background:#071226;padding:8px;border-radius:6px;color:#cde8ff;font-family:monospace;font-size:13px;white-space:pre;overflow:auto}\n    .footer{font-size:12px;color:var(--muted)}\n    input[type=range]{accent-color:var(--accent);width:140px}\n    .hint{font-size:13px;color:var(--muted)}\n    .btn-small{padding:6px 8px;font-size:13px}\n    .flex-col{display:flex;flex-direction:column;gap:6px}\n    .row{display:flex;gap:6px;align-items:center}\n    .muted-pill{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:999px;color:var(--muted);border:1px solid rgba(255,255,255,0.02)}\n    .danger{background:linear-gradient(90deg,#3b0f0f,#220909);border-color:rgba(255,255,255,0.02)}\n    .ok{background:linear-gradient(90deg,#083b22,#052516);border-color:rgba(255,255,255,0.02)}\n    .edge-label{fill:var(--muted);font-size:11px;pointer-events:none}\n    .small-muted{font-size:12px;color:var(--muted)}\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"left\">\n      <div class=\"toolbar panel\">\n        <div class=\"controls\">\n          <button id=\"mode-add\" class=\"btn-small active\">Add Node</button>\n          <button id=\"mode-edge\" class=\"btn-small\">Add Edge</button>\n          <button id=\"mode-move\" class=\"btn-small\">Move</button>\n          <button id=\"mode-delete\" class=\"btn-small\">Delete</button>\n          <label style=\"display:flex;align-items:center;gap:6px\"><input type=\"checkbox\" id=\"directed\"> Directed</label>\n          <button id=\"random\" class=\"btn-small\">Random Graph</button>\n          <button id=\"sample\" class=\"btn-small\">Sample Graph</button>\n          <button id=\"clear\" class=\"btn-small danger\">Clear</button>\n        </div>\n      </div>\n\n      <div class=\"canvas-wrap panel\" id=\"canvasWrap\">\n        <svg id=\"svg\"></svg>\n        <div style=\"position:absolute;right:12px;top:12px;background:rgba(2,6,23,0.5);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)\">\n          <div class=\"muted small\">Mode: <span id=\"modeLabel\">Add Node</span></div>\n          <div class=\"muted small\">Nodes: <span id=\"nodeCount\">0</span> &nbsp; Edges: <span id=\"edgeCount\">0</span></div>\n        </div>\n      </div>\n\n      <div class=\"toolbar panel\">\n        <div class=\"controls\">\n          <label class=\"small-muted\">Start:</label>\n          <select id=\"startSelect\"></select>\n          <label class=\"small-muted\">Method:</label>\n          <select id=\"method\">\n            <option value=\"recursive\">Recursive DFS</option>\n            <option value=\"iterative\">Iterative (stack)</option>\n          </select>\n          <button id=\"run\" class=\"ok\">Run</button>\n          <button id=\"step\" class=\"btn-small\">Step</button>\n          <button id=\"playpause\" class=\"btn-small\">Play</button>\n          <label class=\"small-muted\">Speed:</label>\n          <input id=\"speed\" type=\"range\" min=\"100\" max=\"1500\" value=\"600\">\n          <div style=\"margin-left:auto\" class=\"hint\">Click nodes to add. In \"Add Edge\" mode click source then target.</div>\n        </div>\n      </div>\n\n      <div class=\"panel\" style=\"display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap\">\n        <div style=\"flex:1\">\n          <h3>Traversal State</h3>\n          <div class=\"status-row\">\n            <div class=\"chip\">Visited Order: <span id=\"visitedOrder\">[]</span></div>\n            <div class=\"chip\">Time: <span id=\"time\">0</span></div>\n            <div class=\"chip\">Running: <span id=\"running\">No</span></div>\n          </div>\n          <div style=\"margin-top:8px\" class=\"small-muted\">Legend:</div>\n          <div class=\"legend\" style=\"margin-top:6px\">\n            <div class=\"chip\"><span style=\"display:inline-block;width:12px;height:12px;background:#0b1220;margin-right:6px;border-radius:3px;vertical-align:middle\"></span> Unvisited</div>\n            <div class=\"chip\"><span style=\"display:inline-block;width:12px;height:12px;background:var(--warn);margin-right:6px;border-radius:3px;vertical-align:middle\"></span> Discovered / In Stack</div>\n            <div class=\"chip\"><span style=\"display:inline-block;width:12px;height:12px;background:var(--good);margin-right:6px;border-radius:3px;vertical-align:middle\"></span> Finished</div>\n            <div class=\"chip\"><span style=\"display:inline-block;width:12px;height:12px;border:2px solid rgba(96,165,250,0.95);margin-right:6px;border-radius:3px;vertical-align:middle\"></span> Current</div>\n          </div>\n        </div>\n\n        <div style=\"width:320px\">\n          <h3>Stack / Call Stack</h3>\n          <div id=\"stackView\" class=\"stack-view\" style=\"min-height:60px\">[]</div>\n          <div style=\"margin-top:8px\" class=\"small-muted\">Adjacency</div>\n          <div id=\"adjView\" class=\"adj-view list\" style=\"max-height:120px\"></div>\n        </div>\n      </div>\n\n    </div>\n\n    <div class=\"side\">\n      <div class=\"panel\">\n        <h3>What this demo shows</h3>\n        <div class=\"muted small\">Step through DFS (recursive vs iterative). Create your own graph by adding nodes and edges, or use a random/sample graph. Start node selection controls where traversal begins. Colors indicate node state; the stack/call-stack is shown to help you understand how DFS explores.</div>\n      </div>\n\n      <div class=\"panel\">\n        <h3>Code (pseudocode)</h3>\n        <div class=\"code\">Recursive DFS:\nfunction dfs(u):\n  visited[u] = true\n  for v in neighbors(u):\n    if not visited[v]:\n      parent[v] = u\n      dfs(v)\n\nIterative DFS (stack):\nstack.push(start)\nwhile stack not empty:\n  u = stack.pop()\n  if not visited[u]:\n    visited[u] = true\n    for v in neighbors(u) in reverse order:\n      if not visited[v]:\n        parent[v] = u\n        stack.push(v)\n</div>\n      </div>\n\n      <div class=\"panel\">\n        <h3>Adjacency List / Info</h3>\n        <div class=\"small-muted\">Click \"Run\" to animate full traversal, \"Step\" to advance one step, \"Play\" to continuously step. \"Recursive\" shows the call stack behavior; \"Iterative\" uses an explicit stack. Directed edges respect direction when running DFS.</div>\n      </div>\n\n      <div class=\"panel footer\">\n        Built for learning. Drag nodes to reposition. Created as a single-page interactive demo.\n      </div>\n    </div>\n  </div>\n\n<script>\n(() => {\n  // Simple interactive SVG graph + DFS visualization\n  const svg = document.getElementById('svg');\n  const canvasWrap = document.getElementById('canvasWrap');\n  const modeAdd = document.getElementById('mode-add');\n  const modeEdge = document.getElementById('mode-edge');\n  const modeMove = document.getElementById('mode-move');\n  const modeDelete = document.getElementById('mode-delete');\n  const modeLabel = document.getElementById('modeLabel');\n  const directedCheckbox = document.getElementById('directed');\n  const randomBtn = document.getElementById('random');\n  const sampleBtn = document.getElementById('sample');\n  const clearBtn = document.getElementById('clear');\n  const nodeCountSpan = document.getElementById('nodeCount');\n  const edgeCountSpan = document.getElementById('edgeCount');\n  const startSelect = document.getElementById('startSelect');\n  const methodSelect = document.getElementById('method');\n  const runBtn = document.getElementById('run');\n  const stepBtn = document.getElementById('step');\n  const playBtn = document.getElementById('playpause');\n  const speedRange = document.getElementById('speed');\n  const visitedOrderSpan = document.getElementById('visitedOrder');\n  const timeSpan = document.getElementById('time');\n  const runningSpan = document.getElementById('running');\n  const stackView = document.getElementById('stackView');\n  const adjView = document.getElementById('adjView');\n\n  const NS = \"http://www.w3.org/2000/svg\";\n\n  let nodes = []; // {id, x, y, label}\n  let edges = []; // {id, u, v}\n  let nodeId = 0;\n  let edgeId = 0;\n\n  const R = 20;\n  let mode = 'add'; // add, edge, move, delete\n  let directed = false;\n\n  // Rendering groups\n  const defs = document.createElementNS(NS,'defs');\n  svg.appendChild(defs);\n  const marker = document.createElementNS(NS,'marker');\n  marker.setAttribute('id','arrow');\n  marker.setAttribute('viewBox','0 0 10 10');\n  marker.setAttribute('refX','10');\n  marker.setAttribute('refY','5');\n  marker.setAttribute('markerWidth','6');\n  marker.setAttribute('markerHeight','6');\n  marker.setAttribute('orient','auto-start-reverse');\n  const path = document.createElementNS(NS,'path');\n  path.setAttribute('d','M 0 0 L 10 5 L 0 10 z');\n  path.setAttribute('fill','rgba(255,255,255,0.12)');\n  marker.appendChild(path);\n  defs.appendChild(marker);\n\n  const edgeLayer = document.createElementNS(NS,'g');\n  const edgeLabelLayer = document.createElementNS(NS,'g');\n  const nodeLayer = document.createElementNS(NS,'g');\n  svg.appendChild(edgeLayer);\n  svg.appendChild(edgeLabelLayer);\n  svg.appendChild(nodeLayer);\n\n  // state for interactions\n  let creatingEdgeFrom = null;\n  let dragNode = null;\n  let dragOffset = {x:0,y:0};\n  let lastClick = null;\n\n  // DFS runtime state\n  let visited = {};\n  let color = {}; // white/gray/black\n  let parent = {};\n  let time = 0;\n  let visitedOrder = [];\n  let running = false;\n  let paused = false;\n  let playInterval = null;\n  let stepQueue = []; // for step-by-step ops (functions)\n  let recursionStack = []; // for display of recursive calls in recursive mode\n  let currentNode = null;\n\n  // Utilities\n  function $(id){return document.getElementById(id)}\n  function setMode(m){\n    mode = m;\n    modeAdd.classList.toggle('active', m==='add');\n    modeEdge.classList.toggle('active', m==='edge');\n    modeMove.classList.toggle('active', m==='move');\n    modeDelete.classList.toggle('active', m==='delete');\n    modeLabel.textContent = m==='add'?'Add Node': m==='edge'?'Add Edge': m==='move'?'Move':'Delete';\n    creatingEdgeFrom = null;\n  }\n\n  function updateCounts(){\n    nodeCountSpan.textContent = nodes.length;\n    edgeCountSpan.textContent = edges.length;\n    // update startSelect\n    const prev = startSelect.value;\n    startSelect.innerHTML = '';\n    nodes.forEach(n => {\n      const opt = document.createElement('option');\n      opt.value = n.id;\n      opt.textContent = n.label;\n      startSelect.appendChild(opt);\n    });\n    if(nodes.length>0){\n      startSelect.value = prev || nodes[0].id;\n    }\n  }\n\n  function addNodeAt(x,y,label){\n    const id = String(nodeId++);\n    const node = {id, x, y, label: label ?? id};\n    nodes.push(node);\n    render();\n    updateCounts();\n    return node;\n  }\n\n  function addEdge(u,v){\n    // avoid duplicates for undirected if both ways\n    const exists = edges.some(e => e.u===u && e.v===v && e.directed===directed);\n    if(exists) return;\n    const id = String(edgeId++);\n    edges.push({id,u,v,directed});\n    render();\n    updateCounts();\n  }\n\n  function removeNode(id){\n    nodes = nodes.filter(n => n.id!==id);\n    edges = edges.filter(e => e.u!==id && e.v!==id);\n    render();\n    updateCounts();\n  }\n\n  function removeEdge(id){\n    edges = edges.filter(e => e.id!==id);\n    render();\n    updateCounts();\n  }\n\n  function clearGraph(){\n    nodes = []; edges = []; nodeId = 0; edgeId = 0;\n    render(); updateCounts();\n  }\n\n  // Rendering\n  function render(){\n    // clear\n    while(edgeLayer.firstChild) edgeLayer.removeChild(edgeLayer.firstChild);\n    while(edgeLabelLayer.firstChild) edgeLabelLayer.removeChild(edgeLabelLayer.firstChild);\n    while(nodeLayer.firstChild) nodeLayer.removeChild(nodeLayer.firstChild);\n\n    // draw edges\n    edges.forEach(e=>{\n      const n1 = nodes.find(n=>n.id===e.u);\n      const n2 = nodes.find(n=>n.id===e.v);\n      if(!n1 || !n2) return;\n      const g = document.createElementNS(NS,'g');\n      const line = document.createElementNS(NS,'line');\n      const dx = n2.x - n1.x;\n      const dy = n2.y - n1.y;\n      const dist = Math.sqrt(dx*dx+dy*dy) || 1;\n      const ax = n1.x + (R/Math.max(1,dist))*dx;\n      const ay = n1.y + (R/Math.max(1,dist))*dy;\n      const bx = n2.x - (R/Math.max(1,dist))*dx;\n      const by = n2.y - (R/Math.max(1,dist))*dy;\n      line.setAttribute('x1',ax);\n      line.setAttribute('y1',ay);\n      line.setAttribute('x2',bx);\n      line.setAttribute('y2',by);\n      line.setAttribute('class','edge ' + (e.directed ? 'arrow' : ''));\n      if(e.directed) line.setAttribute('marker-end','url(#arrow)');\n      g.appendChild(line);\n\n      // optionally edge label with arrow indicator\n      const midx = (ax+bx)/2;\n      const midy = (ay+by)/2;\n      const el = document.createElementNS(NS,'text');\n      el.setAttribute('x',midx);\n      el.setAttribute('y',midy - 6);\n      el.setAttribute('class','edge-label');\n      el.textContent = e.directed ? 'â†’' : '';\n      edgeLabelLayer.appendChild(el);\n\n      // clickable hit area for deletion\n      line.addEventListener('click', (ev)=>{\n        ev.stopPropagation();\n        if(mode==='delete'){\n          if(confirm('Delete this edge?')) removeEdge(e.id);\n        }\n      });\n\n      edgeLayer.appendChild(g);\n    });\n\n    // draw nodes\n    nodes.forEach(n=>{\n      const g = document.createElementNS(NS,'g');\n      g.setAttribute('transform',`translate(${n.x},${n.y})`);\n      g.setAttribute('data-id',n.id);\n      const circle = document.createElementNS(NS,'circle');\n      circle.setAttribute('r',R);\n      circle.setAttribute('class','node state-white');\n      circle.style.transition = 'fill 160ms, stroke 160ms';\n      const label = document.createElementNS(NS,'text');\n      label.setAttribute('class','node-label');\n      label.textContent = n.label;\n      g.appendChild(circle);\n      g.appendChild(label);\n\n      // interactions\n      g.addEventListener('mousedown', (ev)=>{\n        ev.stopPropagation();\n        const id = n.id;\n        if(mode==='add'){\n          // do nothing special\n        } else if(mode==='edge'){\n          if(!creatingEdgeFrom){\n            creatingEdgeFrom = id;\n            // small flash\n            circle.style.stroke = 'rgba(96,165,250,0.8)';\n            circle.style.strokeWidth = '3';\n            setTimeout(()=>{circle.style.stroke='';circle.style.strokeWidth='';},400);\n          } else {\n            if(creatingEdgeFrom !== id){\n              addEdge(creatingEdgeFrom, id);\n            }\n            creatingEdgeFrom = null;\n          }\n        } else if(mode==='move'){\n          dragNode = n;\n          const pt = svgPoint(ev);\n          dragOffset.x = n.x - pt.x;\n          dragOffset.y = n.y - pt.y;\n        } else if(mode==='delete'){\n          if(confirm('Delete this node and its edges?')){\n            removeNode(id);\n          }\n        } else {\n          // clicking node when running can set start maybe\n        }\n      });\n\n      // click to set start when not in any special mode\n      g.addEventListener('click', (ev)=>{\n        if(mode==='add' && !running){\n          // selection becomes start\n          startSelect.value = n.id;\n        }\n      });\n\n      // cursor and drag events\n      g.style.cursor = mode==='move'?'grab':'pointer';\n      nodeLayer.appendChild(g);\n    });\n\n    // update colors based on state\n    nodes.forEach(n=>{\n      const g = nodeLayer.querySelector(`g[data-id=\"${n.id}\"]`);\n      if(!g) return;\n      const circle = g.querySelector('circle');\n      const state = color[n.id] || 'white';\n      circle.classList.remove('state-white','state-gray','state-black','state-current');\n      circle.classList.add(state === 'white' ? 'state-white' : state === 'gray' ? 'state-gray' : 'state-black');\n      if(currentNode === n.id) circle.classList.add('state-current');\n    });\n\n    // update adjacency view\n    const adjacency = {};\n    nodes.forEach(n => adjacency[n.id] = []);\n    edges.forEach(e => {\n      adjacency[e.u].push(e.v);\n      if(!e.directed) adjacency[e.v].push(e.u);\n    });\n    adjView.innerHTML = '';\n    nodes.forEach(n=>{\n      const arr = adjacency[n.id].slice().sort();\n      const div = document.createElement('div');\n      div.textContent = `${n.label} (${n.id}): [ ${arr.join(', ')} ]`;\n      adjView.appendChild(div);\n    });\n  }\n\n  // helper to get mouse coordinates in svg\n  function svgPoint(ev){\n    const pt = svg.createSVGPoint();\n    pt.x = ev.clientX;\n    pt.y = ev.clientY;\n    const ctm = svg.getScreenCTM().inverse();\n    const p = pt.matrixTransform(ctm);\n    return {x: p.x, y: p.y};\n  }\n\n  // canvas click to add node\n  svg.addEventListener('mousedown', (ev)=>{\n    const pt = svgPoint(ev);\n    if(mode==='add'){\n      const label = String(nodes.length);\n      addNodeAt(pt.x, pt.y, label);\n    }\n  });\n\n  // drag handling\n  window.addEventListener('mousemove', (ev)=>{\n    if(dragNode){\n      const p = svgPoint(ev);\n      dragNode.x = p.x + dragOffset.x;\n      dragNode.y = p.y + dragOffset.y;\n      render();\n    }\n  });\n  window.addEventListener('mouseup', (ev)=>{\n    dragNode = null;\n  });\n\n  // Node deletion via keyboard (optional)\n  window.addEventListener('keydown', (ev)=>{\n    if(ev.key === 'Escape') setMode('add');\n  });\n\n  // Buttons\n  modeAdd.addEventListener('click', ()=> setMode('add'));\n  modeEdge.addEventListener('click', ()=> setMode('edge'));\n  modeMove.addEventListener('click', ()=> setMode('move'));\n  modeDelete.addEventListener('click', ()=> setMode('delete'));\n\n  directedCheckbox.addEventListener('change', ()=>{\n    directed = directedCheckbox.checked;\n  });\n\n  clearBtn.addEventListener('click', ()=>{\n    if(confirm('Clear entire graph?')) clearGraph();\n  });\n\n  randomBtn.addEventListener('click', ()=>{\n    // create random graph with 6-10 nodes\n    clearGraph();\n    const n = Math.floor(Math.random()*5)+5;\n    const w = canvasWrap.clientWidth, h = canvasWrap.clientHeight;\n    for(let i=0;i<n;i++){\n      addNodeAt(Math.random()*(w-80)+40, Math.random()*(h-160)+40, String(i));\n    }\n    // random edges\n    for(let i=0;i<n;i++){\n      for(let j=i+1;j<n;j++){\n        if(Math.random() < 0.25){\n          edges.push({id:String(edgeId++), u:String(i), v:String(j), directed: Math.random() < 0.3});\n        }\n      }\n    }\n    render(); updateCounts();\n  });\n\n  sampleBtn.addEventListener('click', ()=>{\n    clearGraph();\n    // create a classic sample graph\n    const positions = [\n      [120,120],[300,70],[480,120],[200,250],[360,250],[600,200]\n    ];\n    positions.forEach((p,i)=>addNodeAt(p[0],p[1], String(i)));\n    addEdge('0','1'); addEdge('0','3'); addEdge('1','2'); addEdge('1','4'); addEdge('2','5'); addEdge('3','4'); addEdge('4','5');\n    // make some directed\n    edges[2].directed = true; edges[5].directed = true;\n    render(); updateCounts();\n  });\n\n  // DFS implementation with animation support\n  function resetTraversal(){\n    visited = {};\n    color = {};\n    parent = {};\n    time = 0;\n    visitedOrder = [];\n    currentNode = null;\n    recursionStack = [];\n    stepQueue = [];\n    running = false;\n    paused = false;\n    updateUI();\n    render();\n  }\n\n  function updateUI(){\n    visitedOrderSpan.textContent = '[' + visitedOrder.map(id=>labelOf(id)).join(', ') + ']';\n    timeSpan.textContent = time;\n    runningSpan.textContent = running ? 'Yes' : 'No';\n    // stack view\n    if(methodSelect.value === 'iterative'){\n      stackView.textContent = '[' + (stepQueue.map(s => labelOf(s)).join(', ')) + ']';\n    } else {\n      // recursionStack display\n      stackView.textContent = '[' + recursionStack.map(id=>labelOf(id)).join(', ') + ']';\n    }\n  }\n\n  function labelOf(id){\n    const n = nodes.find(x=>x.id===id);\n    return n ? n.label : id;\n  }\n\n  // Build adjacency map\n  function buildAdj(){\n    const adj = {};\n    nodes.forEach(n => adj[n.id]=[]);\n    edges.forEach(e=>{\n      if(!adj[e.u]) adj[e.u]=[];\n      adj[e.u].push(e.v);\n      if(!e.directed){\n        if(!adj[e.v]) adj[e.v]=[];\n        adj[e.v].push(e.u);\n      }\n    });\n    // sort neighbors by label for deterministic order\n    for(const k in adj){\n      adj[k].sort((a,b)=>{\n        const na = labelOf(a), nb = labelOf(b);\n        return na.localeCompare(nb, undefined, {numeric:true});\n      });\n    }\n    return adj;\n  }\n\n  // Async helper for delays\n  function wait(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }\n\n  // Animation controller\n  async function runDFS(fullRun=true){\n    resetTraversal();\n    running = true;\n    updateUI();\n    const start = startSelect.value || (nodes[0] && nodes[0].id);\n    if(!start){ alert('No start node. Add nodes first.'); running=false; updateUI(); return; }\n    directed = directedCheckbox.checked;\n    const adj = buildAdj();\n\n    if(methodSelect.value === 'iterative'){\n      // iterative DFS with explicit stack; we'll implement stepQueue as stack content\n      const stack = [start];\n      stepQueue = stack.slice();\n      updateUI();\n      while(stack.length > 0){\n        if(!running) break;\n        if(paused){\n          await wait(100);\n          continue;\n        }\n        const u = stack.pop();\n        // update displayed stack\n        stepQueue = stack.slice();\n        currentNode = u;\n        if(!visited[u]){\n          // discover u\n          color[u] = 'gray';\n          visited[u] = true;\n          time += 1;\n          visitedOrder.push(u);\n          updateUI(); render();\n          await wait(speedRange.value);\n          // push neighbors in reverse order so smallest is processed first\n          const neighbors = (adj[u] || []).slice().reverse();\n          for(const v of neighbors){\n            if(!visited[v]){\n              parent[v] = u;\n              stack.push(v);\n              stepQueue = stack.slice();\n              color[v] = color[v] || 'white';\n              // visually mark as in stack (gray)\n              color[v] = 'gray';\n              updateUI(); render();\n              await wait(Math.min(200, speedRange.value/4));\n            }\n          }\n          // finish u\n          color[u] = 'black';\n          currentNode = null;\n          updateUI(); render();\n          await wait(Math.min(200, speedRange.value/4));\n        } else {\n          // already visited; continue\n        }\n      }\n      running = false;\n      paused = false;\n      updateUI(); render();\n    } else {\n      // recursive DFS: we will implement an async recursive function to animate call/return.\n      const visitedLocal = visited;\n      const adjLocal = adj;\n      async function dfs(u){\n        if(!running) return;\n        recursionStack.push(u);\n        currentNode = u;\n        color[u] = 'gray';\n        updateUI(); render();\n        await wait(speedRange.value);\n        visited[u] = true;\n        time += 1;\n        visitedOrder.push(u);\n        updateUI(); render();\n        await wait(speedRange.value);\n        for(const v of (adjLocal[u] || [])){\n          if(!visited[v]){\n            parent[v] = u;\n            // visually show neighbor is discovered soon\n            color[v] = 'gray';\n            updateUI(); render();\n            await wait(Math.min(200, speedRange.value/4));\n            await dfs(v);\n            if(!running) return;\n            await wait(80);\n          }\n        }\n        // finish u\n        color[u] = 'black';\n        recursionStack.pop();\n        currentNode = recursionStack.length ? recursionStack[recursionStack.length-1] : null;\n        updateUI(); render();\n        await wait(Math.min(200, speedRange.value/4));\n      }\n      await dfs(start);\n      running = false;\n      paused = false;\n      updateUI(); render();\n    }\n  }\n\n  // Step-by-step support: execute one micro-step depending on mode\n  // For simplicity we implement step behavior as \"advance one atomic DFS action\" using miniature state machine\n  let stepState = null; // holds controller state\n  function initStepState(){\n    resetTraversal();\n    directed = directedCheckbox.checked;\n    const start = startSelect.value || (nodes[0] && nodes[0].id);\n    if(!start) return false;\n    const adj = buildAdj();\n    stepState = {\n      adj,\n      method: methodSelect.value,\n      stack: methodSelect.value==='iterative' ? [start] : null,\n      callStack: methodSelect.value==='recursive' ? [] : null,\n      iterators: {}, // for recursion: store iterator index per node\n      start\n    };\n    updateUI();\n    return true;\n  }\n\n  function stepOnce(){\n    if(!stepState){\n      const ok = initStepState();\n      if(!ok){ alert('No start node'); return; }\n      running = true;\n      paused = true;\n    }\n    if(stepState.method==='iterative'){\n      const st = stepState.stack;\n      if(st.length===0){\n        running = false;\n        stepState = null;\n        updateUI(); render();\n        return;\n      }\n      const u = st.pop();\n      currentNode = u;\n      if(!visited[u]){\n        color[u] = 'gray';\n        visited[u] = true;\n        time += 1;\n        visitedOrder.push(u);\n        updateUI(); render();\n        // next micro-step: push neighbors\n        const neighbors = (stepState.adj[u]||[]).slice().reverse();\n        // push one neighbor per subsequent step for fine control\n        for(const v of neighbors){\n          if(!visited[v]) st.push(v);\n        }\n        // mark finished in another micro-step\n        color[u] = 'black';\n        currentNode = null;\n        updateUI(); render();\n      } else {\n        // nothing\n      }\n    } else {\n      // recursive step emulation: we will simulate one call-return per step.\n      const cs = stepState.callStack;\n      if(cs.length===0){\n        // start new call\n        const s = stepState.start;\n        cs.push(s);\n        color[s] = 'gray'; visited[s] = true; time++; visitedOrder.push(s);\n        stepState.iterators[s] = 0;\n        currentNode = s;\n        updateUI(); render();\n        return;\n      }\n      const top = cs[cs.length-1];\n      const it = stepState.iterators[top] || 0;\n      const neighbors = stepState.adj[top] || [];\n      // find next unvisited neighbor\n      let pushed = false;\n      for(let idx = it; idx < neighbors.length; idx++){\n        const v = neighbors[idx];\n        stepState.iterators[top] = idx+1; // advance iterator\n        if(!visited[v]){\n          // call dfs(v)\n          parent[v] = top;\n          cs.push(v);\n          visited[v] = true; color[v]='gray'; time++; visitedOrder.push(v);\n          stepState.iterators[v] = 0;\n          currentNode = v;\n          pushed = true;\n          updateUI(); render();\n          break;\n        }\n      }\n      if(!pushed){\n        // all neighbors processed -> return\n        color[top] = 'black';\n        cs.pop();\n        currentNode = cs.length? cs[cs.length-1] : null;\n        updateUI(); render();\n      }\n      // if call stack becomes empty, finished\n      if(cs.length === 0){\n        running = false;\n        stepState = null;\n      }\n    }\n  }\n\n  // Button handlers\n  runBtn.addEventListener('click', async ()=>{\n    if(running){\n      // stop\n      running = false;\n      paused = false;\n      updateUI();\n      return;\n    }\n    // else run full animation\n    await runDFS(true);\n  });\n\n  stepBtn.addEventListener('click', ()=>{\n    if(running && !paused){\n      // if currently auto-running, pause and initialize step state from current state is complex; easier to reset\n      paused = true;\n      running = false;\n      stepState = null;\n      resetTraversal();\n    }\n    stepOnce();\n  });\n\n  playBtn.addEventListener('click', ()=>{\n    if(playInterval){\n      clearInterval(playInterval);\n      playInterval = null;\n      playBtn.textContent = 'Play';\n      paused = true;\n      return;\n    }\n    // start playing steps\n    paused = false;\n    playBtn.textContent = 'Pause';\n    if(!stepState){\n      const ok = initStepState();\n      if(!ok) return;\n    }\n    playInterval = setInterval(()=>{\n      if(!stepState && !running){\n        clearInterval(playInterval);\n        playInterval = null;\n        playBtn.textContent = 'Play';\n        return;\n      }\n      if(!paused) stepOnce();\n    }, Math.max(150, speedRange.value));\n  });\n\n  // expose some helpful functions for dev\n  updateCounts();\n  render();\n\n  // initialize sample graph\n  sampleBtn.click();\n\n  // small UX: clicking on empty space in edge mode resets creation\n  svg.addEventListener('click', ()=>{\n    if(mode==='edge'){\n      creatingEdgeFrom = null;\n    }\n  });\n\n  // allow window resize to adjust (SVG uses viewBox auto)\n  window.addEventListener('resize', ()=> render());\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": false,
  "hasTest": true
}