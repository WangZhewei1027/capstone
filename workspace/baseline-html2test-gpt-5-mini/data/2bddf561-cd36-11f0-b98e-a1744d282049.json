{
  "id": "2bddf561-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:47.498Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Deque",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Deque (Double-Ended Queue) Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #06b6d4;\n      --muted: #94a3b8;\n      --card: #0b1220;\n      --ok: #10b981;\n      --warn: #f59e0b;\n      --bad: #ef4444;\n    }\n    html,body { height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial; background:linear-gradient(180deg,#071025 0%, #071426 100%); color:#e6eef8; }\n    .container { max-width:1100px; margin:28px auto; padding:22px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 6px 30px rgba(2,6,23,0.6); }\n    h1 { margin:0 0 6px 0; font-size:20px; color:var(--accent); }\n    p.desc { margin:0 0 18px 0; color:var(--muted); font-size:13px; }\n    .layout { display:flex; gap:18px; align-items:flex-start; }\n    .panel { background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); padding:14px; border-radius:10px; }\n    .controls { width:320px; flex-shrink:0; }\n    .visual { flex:1; }\n    .row { display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap; }\n    input[type=\"text\"] { padding:8px 10px; background:#071826; border:1px solid rgba(255,255,255,0.04); color:#e6eef8; border-radius:8px; outline:none; min-width:120px; }\n    button { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); color:#e6eef8; padding:8px 10px; border-radius:8px; cursor:pointer; }\n    button.primary { background:linear-gradient(180deg,var(--accent), #0aa2b5); color:#002028; font-weight:600; border:none; }\n    button.warn { background:linear-gradient(180deg,var(--warn), #d9820b); color:#08140b; border:none; }\n    button.danger { background:linear-gradient(180deg,var(--bad), #d32f2f); color:#2b0505; border:none; }\n    .small { font-size:12px; padding:6px 8px; border-radius:6px; }\n    .vis-area { padding:12px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015)); border-radius:8px; border:1px solid rgba(255,255,255,0.03); }\n    .deque-line { display:flex; gap:8px; align-items:center; flex-wrap:nowrap; min-height:72px; margin-bottom:14px; overflow:auto; padding-bottom:6px; }\n    .elem { min-width:54px; height:48px; border-radius:8px; background:#031526; border:1px solid rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center; color:#dff7fb; font-weight:600; box-shadow: 0 4px 18px rgba(0,0,0,0.6); }\n    .tag { font-size:12px; color:var(--muted); margin-right:8px; }\n    .idx-grid { display:flex; gap:8px; overflow:auto; padding:10px 2px; align-items:end; }\n    .cell { min-width:64px; min-height:56px; border-radius:6px; background:rgba(255,255,255,0.01); border:1px dashed rgba(255,255,255,0.02); display:flex; flex-direction:column; align-items:center; justify-content:center; color:var(--muted); font-size:13px; position:relative; }\n    .cell .val { margin-top:6px; font-weight:700; color:#dff7fb; }\n    .marker { position:absolute; top:6px; left:6px; background:var(--accent); color:#022; padding:2px 6px; border-radius:6px; font-size:11px; font-weight:700; }\n    .marker.tail { right:6px; left:auto; background:#fab005; color:#2b1502; }\n    .log { max-height:180px; overflow:auto; background:#031026; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.02); color:var(--muted); font-family:monospace; font-size:13px; }\n    .info { font-size:13px; color:var(--muted); margin-top:8px; }\n    .stat { display:flex; gap:12px; color:var(--muted); margin-top:8px; font-size:13px; }\n    .stat .s { background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:8px; }\n    footer { margin-top:14px; color:var(--muted); font-size:13px; }\n    a { color:var(--accent); text-decoration:none; }\n    .controls .group { margin-bottom:12px; }\n    .ops { display:flex; gap:8px; flex-wrap:wrap; }\n    .hint { font-size:12px; color:var(--muted); margin-top:6px;}\n  </style>\n</head>\n<body>\n  <div class=\"container panel\">\n    <h1>Deque (Double-Ended Queue) — Interactive Demo</h1>\n    <p class=\"desc\">A deque supports adding and removing items from both front and back. This demo includes an efficient circular-buffer implementation with automatic resizing and a visualizer of the logical deque plus the internal buffer.</p>\n\n    <div class=\"layout\">\n      <div class=\"controls panel\">\n        <div class=\"group\">\n          <input id=\"valueInput\" type=\"text\" placeholder=\"Value (string/number)\" />\n          <div class=\"row\" style=\"margin-top:10px;\">\n            <button id=\"pushFront\" class=\"small primary\">pushFront</button>\n            <button id=\"pushBack\" class=\"small primary\">pushBack</button>\n          </div>\n          <div class=\"row\">\n            <button id=\"popFront\" class=\"small warn\">popFront</button>\n            <button id=\"popBack\" class=\"small warn\">popBack</button>\n          </div>\n          <div class=\"row\">\n            <button id=\"peekFront\" class=\"small\">peekFront</button>\n            <button id=\"peekBack\" class=\"small\">peekBack</button>\n          </div>\n          <div class=\"row\" style=\"margin-top:6px;\">\n            <button id=\"clearBtn\" class=\"small danger\">clear</button>\n            <button id=\"fillRandom\" class=\"small\">fill random (5)</button>\n          </div>\n        </div>\n\n        <div class=\"group\">\n          <div class=\"row\">\n            <button id=\"stepRand\" class=\"small\">step random op</button>\n            <button id=\"runRandom\" class=\"small\">run 20 random ops</button>\n            <button id=\"stopRandom\" class=\"small\">stop</button>\n          </div>\n          <div class=\"hint\">Random ops: push/pop front/back with random integers. Useful to exercise resize/shrink.</div>\n        </div>\n\n        <div class=\"group\">\n          <div class=\"stat\">\n            <div class=\"s\">size: <span id=\"statSize\">0</span></div>\n            <div class=\"s\">capacity: <span id=\"statCap\">8</span></div>\n            <div class=\"s\">head: <span id=\"statHead\">0</span></div>\n            <div class=\"s\">tail: <span id=\"statTail\">0</span></div>\n          </div>\n        </div>\n\n        <div class=\"group\">\n          <div style=\"font-size:13px; font-weight:600; color:var(--muted); margin-bottom:6px;\">Operation log</div>\n          <div id=\"log\" class=\"log\" aria-live=\"polite\"></div>\n        </div>\n\n        <footer>\n          Note: This Deque uses a circular buffer with doubling/shrinking — push/pop are O(1) amortized.\n        </footer>\n      </div>\n\n      <div class=\"visual panel\">\n        <div class=\"vis-area\">\n          <div style=\"display:flex; align-items:center; justify-content:space-between; gap:12px;\">\n            <div style=\"display:flex; align-items:center; gap:8px;\">\n              <div class=\"tag\">Logical deque (front → back)</div>\n              <div class=\"hint\" style=\"margin-left:8px;\">Shows elements in their deque order</div>\n            </div>\n            <div style=\"font-size:13px; color:var(--muted);\">Underlying buffer visualized below</div>\n          </div>\n\n          <div class=\"deque-line\" id=\"dequeLine\" aria-hidden=\"false\">\n            <!-- elements inserted here -->\n          </div>\n\n          <div style=\"margin-top:6px; color:var(--muted); font-size:13px;\">Internal buffer (indexes 0..capacity-1). Head points to first element; tail points to the slot after last element.</div>\n          <div class=\"idx-grid\" id=\"bufferGrid\" style=\"margin-top:8px;\">\n            <!-- buffer cells -->\n          </div>\n\n          <div class=\"info\" id=\"infoText\"></div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Deque implementation using circular buffer with dynamic resizing\n    class Deque {\n      constructor(initialCapacity = 8) {\n        if (initialCapacity < 1) initialCapacity = 1;\n        // normalize to power of two for nicer wrap (not required but convenient)\n        this._cap = 1;\n        while (this._cap < initialCapacity) this._cap <<= 1;\n        this._buf = new Array(this._cap);\n        this._head = 0; // index of first element\n        this._tail = 0; // index one past last element\n        this._size = 0;\n        this._minCap = this._cap;\n      }\n\n      size() { return this._size; }\n      isEmpty() { return this._size === 0; }\n      capacity() { return this._cap; }\n      headIndex() { return this._head; }\n      tailIndex() { return this._tail; }\n\n      _grow() {\n        const newCap = this._cap * 2;\n        this._resizeBuffer(newCap);\n      }\n\n      _shrink() {\n        // shrink when size <= cap/4 (amortized)\n        let newCap = this._cap >> 1;\n        if (newCap < this._minCap) newCap = this._minCap;\n        if (newCap < this._cap && this._size <= newCap) {\n          this._resizeBuffer(newCap);\n        }\n      }\n\n      _resizeBuffer(newCap) {\n        const newBuf = new Array(newCap);\n        for (let i = 0; i < this._size; i++) {\n          newBuf[i] = this._buf[(this._head + i) & (this._cap - 1)];\n        }\n        this._buf = newBuf;\n        this._cap = newCap;\n        this._head = 0;\n        this._tail = this._size % this._cap;\n      }\n\n      pushBack(val) {\n        if (this._size === this._cap) this._grow();\n        this._buf[this._tail] = val;\n        this._tail = (this._tail + 1) & (this._cap - 1);\n        this._size++;\n      }\n\n      pushFront(val) {\n        if (this._size === this._cap) this._grow();\n        this._head = (this._head - 1) & (this._cap - 1);\n        this._buf[this._head] = val;\n        this._size++;\n      }\n\n      popFront() {\n        if (this._size === 0) return undefined;\n        const val = this._buf[this._head];\n        this._buf[this._head] = undefined;\n        this._head = (this._head + 1) & (this._cap - 1);\n        this._size--;\n        if (this._size > 0) this._shrink();\n        return val;\n      }\n\n      popBack() {\n        if (this._size === 0) return undefined;\n        this._tail = (this._tail - 1) & (this._cap - 1);\n        const val = this._buf[this._tail];\n        this._buf[this._tail] = undefined;\n        this._size--;\n        if (this._size > 0) this._shrink();\n        return val;\n      }\n\n      peekFront() {\n        if (this._size === 0) return undefined;\n        return this._buf[this._head];\n      }\n\n      peekBack() {\n        if (this._size === 0) return undefined;\n        const idx = (this._tail - 1) & (this._cap - 1);\n        return this._buf[idx];\n      }\n\n      clear() {\n        this._buf = new Array(this._minCap);\n        this._cap = this._minCap;\n        this._head = 0;\n        this._tail = 0;\n        this._size = 0;\n      }\n\n      toArray() {\n        const arr = [];\n        for (let i = 0; i < this._size; i++) {\n          arr.push(this._buf[(this._head + i) & (this._cap - 1)]);\n        }\n        return arr;\n      }\n\n      bufferSnapshot() {\n        // returns array of buffer contents and marks positions\n        return {\n          buf: this._buf.slice(),\n          head: this._head,\n          tail: this._tail,\n          cap: this._cap,\n          size: this._size\n        };\n      }\n    }\n\n    // UI wiring\n    const dq = new Deque(8);\n    const dequeLine = document.getElementById('dequeLine');\n    const bufferGrid = document.getElementById('bufferGrid');\n    const logEl = document.getElementById('log');\n    const statSize = document.getElementById('statSize');\n    const statCap = document.getElementById('statCap');\n    const statHead = document.getElementById('statHead');\n    const statTail = document.getElementById('statTail');\n    const infoText = document.getElementById('infoText');\n\n    function log(msg, type = 'info') {\n      const time = new Date().toLocaleTimeString();\n      const line = document.createElement('div');\n      line.textContent = `[${time}] ${msg}`;\n      if (type === 'err') line.style.color = 'var(--warn)';\n      logEl.prepend(line);\n    }\n\n    function render() {\n      // logical deque\n      dequeLine.innerHTML = '';\n      const arr = dq.toArray();\n      if (arr.length === 0) {\n        const hint = document.createElement('div');\n        hint.className = 'elem';\n        hint.style.opacity = '0.45';\n        hint.textContent = '(empty)';\n        dequeLine.appendChild(hint);\n      } else {\n        for (let i = 0; i < arr.length; i++) {\n          const el = document.createElement('div');\n          el.className = 'elem';\n          el.textContent = String(arr[i]);\n          dequeLine.appendChild(el);\n        }\n      }\n\n      // buffer visualization\n      const snap = dq.bufferSnapshot();\n      bufferGrid.innerHTML = '';\n      for (let i = 0; i < snap.cap; i++) {\n        const cell = document.createElement('div');\n        cell.className = 'cell';\n        const idxLabel = document.createElement('div');\n        idxLabel.style.fontSize = '12px';\n        idxLabel.style.color = 'var(--muted)';\n        idxLabel.textContent = i;\n        const val = document.createElement('div');\n        val.className = 'val';\n        val.textContent = snap.buf[i] === undefined ? '' : String(snap.buf[i]);\n        cell.appendChild(idxLabel);\n        cell.appendChild(val);\n\n        if (i === snap.head && snap.size > 0) {\n          const m = document.createElement('div');\n          m.className = 'marker';\n          m.textContent = 'HEAD';\n          cell.appendChild(m);\n        } else if (i === snap.head && snap.size === 0) {\n          // when empty head===tail, mark both?\n          const m = document.createElement('div');\n          m.className = 'marker';\n          m.textContent = 'HEAD';\n          cell.appendChild(m);\n        }\n\n        if (i === snap.tail) {\n          const m2 = document.createElement('div');\n          m2.className = 'marker tail';\n          m2.textContent = 'TAIL';\n          cell.appendChild(m2);\n        }\n\n        // highlight occupied slots\n        // occupied indices are head .. head+size-1 modulo cap\n        let occupied = false;\n        if (snap.size > 0) {\n          const rel = (i - snap.head + snap.cap) & (snap.cap - 1);\n          if (rel >= 0 && rel < snap.size) occupied = true;\n        }\n        if (occupied) {\n          cell.style.background = 'linear-gradient(180deg, rgba(6,182,212,0.06), rgba(6,182,212,0.03))';\n          cell.style.border = '1px solid rgba(6,182,212,0.12)';\n        }\n\n        bufferGrid.appendChild(cell);\n      }\n\n      // stats\n      statSize.textContent = dq.size();\n      statCap.textContent = dq.capacity();\n      statHead.textContent = dq.headIndex();\n      statTail.textContent = dq.tailIndex();\n\n      infoText.textContent = `Logical order: [${dq.toArray().map(x=>String(x)).join(', ')}]`;\n    }\n\n    // wired controls\n    const valueInput = document.getElementById('valueInput');\n    document.getElementById('pushFront').addEventListener('click', () => {\n      const v = parseInput(valueInput.value);\n      dq.pushFront(v);\n      log(`pushFront(${formatForLog(v)})`);\n      render();\n    });\n    document.getElementById('pushBack').addEventListener('click', () => {\n      const v = parseInput(valueInput.value);\n      dq.pushBack(v);\n      log(`pushBack(${formatForLog(v)})`);\n      render();\n    });\n    document.getElementById('popFront').addEventListener('click', () => {\n      const v = dq.popFront();\n      if (v === undefined) log('popFront() -> undefined (empty)', 'err'); else log(`popFront() -> ${formatForLog(v)}`);\n      render();\n    });\n    document.getElementById('popBack').addEventListener('click', () => {\n      const v = dq.popBack();\n      if (v === undefined) log('popBack() -> undefined (empty)', 'err'); else log(`popBack() -> ${formatForLog(v)}`);\n      render();\n    });\n    document.getElementById('peekFront').addEventListener('click', () => {\n      const v = dq.peekFront();\n      if (v === undefined) log('peekFront() -> undefined (empty)', 'err'); else log(`peekFront() -> ${formatForLog(v)}`);\n    });\n    document.getElementById('peekBack').addEventListener('click', () => {\n      const v = dq.peekBack();\n      if (v === undefined) log('peekBack() -> undefined (empty)', 'err'); else log(`peekBack() -> ${formatForLog(v)}`);\n    });\n    document.getElementById('clearBtn').addEventListener('click', () => {\n      dq.clear();\n      log('clear() — deque reset');\n      render();\n    });\n    document.getElementById('fillRandom').addEventListener('click', () => {\n      for (let i=0;i<5;i++) dq.pushBack(randInt(1,99));\n      log('Filled 5 random values to back');\n      render();\n    });\n\n    function parseInput(s) {\n      s = String(s).trim();\n      if (s === '') return '';\n      // try to parse number\n      if (!isNaN(s) && s !== '') {\n        // interpret as number if it's a numeric literal\n        const n = Number(s);\n        return n;\n      }\n      return s;\n    }\n    function formatForLog(v) {\n      if (v === '') return \"''\";\n      if (v === undefined) return 'undefined';\n      return JSON.stringify(v);\n    }\n\n    function randInt(a,b) { return Math.floor(Math.random()*(b-a+1))+a; }\n\n    // random op runner\n    let runner = null;\n    document.getElementById('stepRand').addEventListener('click', () => {\n      randomOpStep();\n    });\n    document.getElementById('runRandom').addEventListener('click', () => {\n      if (runner) return;\n      let steps = 20;\n      runner = setInterval(() => {\n        randomOpStep();\n        steps--;\n        if (steps <= 0) { clearInterval(runner); runner = null; }\n      }, 220);\n    });\n    document.getElementById('stopRandom').addEventListener('click', () => {\n      if (runner) { clearInterval(runner); runner = null; log('Stopped random runner'); }\n    });\n\n    function randomOpStep() {\n      const op = randInt(0,3);\n      const val = randInt(1,99);\n      switch(op) {\n        case 0:\n          dq.pushFront(val);\n          log(`pushFront(${val})`);\n          break;\n        case 1:\n          dq.pushBack(val);\n          log(`pushBack(${val})`);\n          break;\n        case 2:\n          const a = dq.popFront();\n          log(a === undefined ? 'popFront() -> undefined' : `popFront() -> ${a}`);\n          break;\n        case 3:\n          const b = dq.popBack();\n          log(b === undefined ? 'popBack() -> undefined' : `popBack() -> ${b}`);\n          break;\n      }\n      render();\n    }\n\n    // initial render\n    render();\n    log('Deque initialized');\n\n    // Accessibility: allow Enter to pushBack in input\n    valueInput.addEventListener('keydown', (e) => {\n      if (e.key === 'Enter') {\n        document.getElementById('pushBack').click();\n        valueInput.value = '';\n      }\n    });\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Deque"
    }
  ],
  "topic": "Deque",
  "hasFSM": false,
  "hasTest": true
}