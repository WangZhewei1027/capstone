{
  "id": "2bde4390-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:35.550Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>Bellman-Ford Algorithm Visualizer</title>\n<style>\n  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;}\n  #app{display:flex;height:100vh;}\n  #canvasWrap{flex:1;position:relative;background:#f6f8fa;border-right:1px solid #ddd;}\n  canvas{width:100%;height:100%;display:block;}\n  #controls{width:420px;padding:14px;box-sizing:border-box;overflow:auto;background:#fff;}\n  h2{margin:6px 0 10px;font-size:18px;}\n  .row{display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap;}\n  button,input,select{padding:6px 8px;font-size:14px;border:1px solid #bbb;border-radius:6px;background:#fff;}\n  button{cursor:pointer}\n  .small{font-size:12px;padding:6px}\n  #log{height:160px;overflow:auto;background:#111;color:#0f0;padding:8px;border-radius:6px;font-family:monospace;font-size:12px;}\n  .table{margin-top:8px;border:1px solid #ddd;padding:8px;border-radius:6px;background:#fafafa;}\n  .table-item{display:flex;gap:8px;align-items:center;margin-bottom:6px;}\n  label{font-size:13px;}\n  .nodeHint{position:absolute;left:8px;top:8px;background:rgba(255,255,255,0.9);padding:6px;border-radius:6px;border:1px solid #ddd;font-size:13px;}\n  .badge{display:inline-block;padding:3px 6px;border-radius:6px;background:#eee;font-size:12px;margin-left:6px;}\n  .edge-inputs{display:flex;gap:6px;align-items:center}\n  .dist-cell{min-width:140px;padding:6px;border-radius:6px;background:#fff;border:1px solid #e6e6e6;margin-bottom:6px}\n</style>\n</head>\n<body>\n<div id=\"app\">\n  <div id=\"canvasWrap\">\n    <div class=\"nodeHint\">\n      Click canvas to add node. Drag nodes to move. Click a node, then another to create an edge (you'll be prompted for weight).<br>\n      Click \"Sample Graph\" to load an example. Select a source node by clicking it (it will be highlighted).\n    </div>\n    <canvas id=\"c\"></canvas>\n  </div>\n  <div id=\"controls\">\n    <h2>Bellman-Ford Visualizer</h2>\n    <div class=\"row\">\n      <button id=\"sampleBtn\">Sample Graph</button>\n      <button id=\"randomBtn\">Random Graph</button>\n      <button id=\"clearBtn\">Clear</button>\n    </div>\n\n    <div class=\"row\">\n      <button id=\"selectBtn\" class=\"small\">Select Source</button>\n      <button id=\"resetBtn\" class=\"small\">Reset Algorithm</button>\n      <select id=\"mode\">\n        <option value=\"step\">Step-by-step</option>\n        <option value=\"auto\">Animate</option>\n      </select>\n      <button id=\"runBtn\" class=\"small\">Run</button>\n      <button id=\"pauseBtn\" class=\"small\">Pause</button>\n    </div>\n\n    <div class=\"row\">\n      <button id=\"stepBtn\">Step</button>\n      <button id=\"detectBtn\">Detect Negative Cycle</button>\n    </div>\n\n    <div style=\"margin-top:10px;\">\n      <label>Iterations: <span id=\"iter\">0</span></label>\n      <label class=\"badge\">V = <span id=\"vcount\">0</span></label>\n      <label class=\"badge\">E = <span id=\"ecount\">0</span></label>\n    </div>\n\n    <div class=\"table\" id=\"distTable\">\n      <strong>Distances / Predecessors</strong>\n      <div id=\"distList\"></div>\n    </div>\n\n    <div class=\"table\">\n      <strong>Controls & Tips</strong>\n      <div style=\"font-size:13px;margin-top:6px\">- To create an edge: click one node (it will flash), then click target node and enter weight (can be negative).<br>\n      - Click a node to set it as source (orange).<br>\n      - \"Run\" with auto mode animates relaxations. \"Step\" executes one relaxation.</div>\n    </div>\n\n    <div style=\"margin-top:10px;\">\n      <strong>Log / Events</strong>\n      <div id=\"log\"></div>\n    </div>\n  </div>\n</div>\n\n<script>\n(function(){\n  const canvas = document.getElementById('c');\n  const wrap = document.getElementById('canvasWrap');\n  const ctx = canvas.getContext('2d');\n  let w = canvas.width = wrap.clientWidth;\n  let h = canvas.height = wrap.clientHeight;\n  function resize(){\n    w = canvas.width = wrap.clientWidth;\n    h = canvas.height = wrap.clientHeight;\n    draw();\n  }\n  window.addEventListener('resize',resize);\n\n  // Data structures\n  let nodes = []; // {id,label,x,y}\n  let edges = []; // {u,v,w}\n  let nextId = 0;\n\n  // Algorithm state\n  let source = null;\n  let dist = [];\n  let pred = [];\n  let inNegCycle = []; // boolean markers\n  let iter = 0; // current iteration (0..V-1)\n  let edgeIdx = 0; // current edge index in this iteration\n  let running = false;\n  let animationTimer = null;\n  let stepDelay = 450; // ms for auto mode\n\n  // UI references\n  const sampleBtn = document.getElementById('sampleBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const runBtn = document.getElementById('runBtn');\n  const pauseBtn = document.getElementById('pauseBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const detectBtn = document.getElementById('detectBtn');\n  const modeSelect = document.getElementById('mode');\n  const selectBtn = document.getElementById('selectBtn');\n  const iterLabel = document.getElementById('iter');\n  const vcount = document.getElementById('vcount');\n  const ecount = document.getElementById('ecount');\n  const distList = document.getElementById('distList');\n  const logEl = document.getElementById('log');\n\n  function log(msg){\n    const t = new Date().toLocaleTimeString();\n    logEl.innerHTML = '['+t+'] ' + msg + '<br>' + logEl.innerHTML;\n  }\n\n  // Drawing functions\n  function draw(){\n    ctx.clearRect(0,0,w,h);\n    // draw edges\n    edges.forEach((e,idx)=>{\n      drawEdge(e, idx);\n    });\n    // draw nodes\n    nodes.forEach(n=> drawNode(n));\n  }\n\n  function drawNode(n){\n    const r = 20;\n    // fill\n    ctx.beginPath();\n    ctx.fillStyle = (n.id === source) ? '#ffecb3' : '#fff';\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 1.5;\n    ctx.arc(n.x,n.y,r,0,Math.PI*2);\n    ctx.fill();\n    ctx.stroke();\n    // label\n    ctx.fillStyle = '#000';\n    ctx.font = 'bold 13px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(n.label, n.x, n.y);\n    // distance small text\n    const di = dist[n.id];\n    ctx.font = '12px monospace';\n    ctx.textBaseline = 'top';\n    const dx = n.x;\n    const dy = n.y + r + 4;\n    let s = (di === Infinity) ? '∞' : (di === -Infinity ? '-∞' : di.toString());\n    if(inNegCycle[n.id]) s += ' *';\n    ctx.fillStyle = (inNegCycle[n.id] ? '#d32' : '#555');\n    ctx.fillText(s, dx, dy);\n  }\n\n  function drawEdge(e, idx){\n    const u = nodes.find(n=>n.id===e.u);\n    const v = nodes.find(n=>n.id===e.v);\n    if(!u || !v) return;\n    // compute line endpoints (so they touch node circles)\n    const dx = v.x - u.x;\n    const dy = v.y - u.y;\n    const distUV = Math.hypot(dx,dy) || 1;\n    const r = 20;\n    const ux = u.x + dx*(r/distUV);\n    const uy = u.y + dy*(r/distUV);\n    const vx = v.x - dx*(r/distUV);\n    const vy = v.y - dy*(r/distUV);\n\n    // draw line\n    ctx.beginPath();\n    ctx.strokeStyle = e._highlight ? '#ff6f00' : '#444';\n    ctx.lineWidth = e._highlight ? 3 : 1.5;\n    ctx.moveTo(ux,uy);\n    ctx.lineTo(vx,vy);\n    ctx.stroke();\n\n    // arrow head\n    const arrowSize = 8 + (e._highlight ? 3 : 0);\n    const angle = Math.atan2(vy-uy, vx-ux);\n    ctx.beginPath();\n    ctx.fillStyle = e._highlight ? '#ff6f00' : '#444';\n    ctx.moveTo(vx,vy);\n    ctx.lineTo(vx - arrowSize*Math.cos(angle - Math.PI/6), vy - arrowSize*Math.sin(angle - Math.PI/6));\n    ctx.lineTo(vx - arrowSize*Math.cos(angle + Math.PI/6), vy - arrowSize*Math.sin(angle + Math.PI/6));\n    ctx.closePath();\n    ctx.fill();\n\n    // weight label at mid point offset a bit\n    const mx = (ux+vx)/2;\n    const my = (uy+vy)/2;\n    const ox = -dy/distUV * 12; // perpendicular offset\n    const oy = dx/distUV * 12;\n    ctx.fillStyle = '#000';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(e.w, mx+ox, my+oy);\n    // edge index debug (optional)\n    //ctx.fillStyle='#666'; ctx.fillText(idx, mx-ox, my-oy);\n  }\n\n  // Interaction\n  let dragging = null;\n  let creatingFrom = null;\n  let selectingSourceMode = false;\n\n  canvas.addEventListener('mousedown', (evt)=>{\n    const rect = canvas.getBoundingClientRect();\n    const x = (evt.clientX - rect.left);\n    const y = (evt.clientY - rect.top);\n    const node = hitNode(x,y);\n    if(node){\n      // click on node\n      if(selectingSourceMode){\n        source = node.id;\n        selectingSourceMode = false;\n        selectBtn.textContent = 'Select Source';\n        log('Source set to ' + node.label);\n        resetAlgorithmState();\n        draw();\n        return;\n      }\n      // begin drag or start creating edge\n      if(evt.shiftKey){\n        // shift-click to start creating edge intentionally\n        creatingFrom = node;\n        node._flash = Date.now();\n      } else {\n        // start dragging\n        dragging = {node, offsetX: x-node.x, offsetY: y-node.y};\n      }\n    } else {\n      // click empty space -> add node\n      const label = 'N' + nextId;\n      const id = nextId++;\n      nodes.push({id, label, x, y});\n      log('Added node ' + label);\n      resetAlgorithmState();\n      draw();\n    }\n  });\n\n  canvas.addEventListener('mousemove', (evt)=>{\n    if(dragging){\n      const rect = canvas.getBoundingClientRect();\n      const x = (evt.clientX - rect.left);\n      const y = (evt.clientY - rect.top);\n      dragging.node.x = x - dragging.offsetX;\n      dragging.node.y = y - dragging.offsetY;\n      draw();\n    }\n  });\n\n  canvas.addEventListener('mouseup', (evt)=>{\n    const rect = canvas.getBoundingClientRect();\n    const x = (evt.clientX - rect.left);\n    const y = (evt.clientY - rect.top);\n    const node = hitNode(x,y);\n    if(creatingFrom){\n      if(node && node.id !== creatingFrom.id){\n        const weight = prompt('Enter weight for edge ' + creatingFrom.label + ' -> ' + node.label + ' (can be negative)', '1');\n        if(weight !== null){\n          const wv = Number(weight);\n          if(!Number.isFinite(wv) || weight.trim()===''){\n            alert('Invalid weight');\n          } else {\n            edges.push({u:creatingFrom.id, v:node.id, w:wv, _highlight:false});\n            log('Added edge ' + creatingFrom.label + ' -> ' + node.label + ' weight=' + wv);\n            resetAlgorithmState();\n          }\n        }\n      }\n    } else if(!dragging){\n      // simple click (not drag) on node to set source\n      if(node){\n        source = node.id;\n        log('Source set to ' + node.label);\n        resetAlgorithmState();\n      }\n    }\n    creatingFrom = null;\n    dragging = null;\n    draw();\n  });\n\n  // double click to remove node or edge?\n  canvas.addEventListener('dblclick',(evt)=>{\n    const rect = canvas.getBoundingClientRect();\n    const x = (evt.clientX - rect.left);\n    const y = (evt.clientY - rect.top);\n    const node = hitNode(x,y);\n    if(node){\n      // remove node and connected edges\n      nodes = nodes.filter(n=>n.id!==node.id);\n      edges = edges.filter(e=>e.u!==node.id && e.v!==node.id);\n      log('Removed node ' + node.label);\n      resetAlgorithmState();\n      draw();\n    } else {\n      // double click on empty area -> nothing\n    }\n  });\n\n  function hitNode(x,y){\n    for(let i=nodes.length-1;i>=0;i--){\n      const n = nodes[i];\n      const dx = x - n.x;\n      const dy = y - n.y;\n      if(Math.hypot(dx,dy) <= 20) return n;\n    }\n    return null;\n  }\n\n  // Buttons\n  sampleBtn.addEventListener('click', loadSample);\n  randomBtn.addEventListener('click', createRandom);\n  clearBtn.addEventListener('click', ()=>{\n    nodes=[]; edges=[]; nextId=0; source=null;\n    log('Cleared graph.');\n    resetAlgorithmState();\n    draw();\n  });\n  resetBtn.addEventListener('click', ()=>{\n    resetAlgorithmState();\n    draw();\n    log('Algorithm reset.');\n  });\n  runBtn.addEventListener('click', ()=>{\n    if(!source){ alert('Select a source node first (click a node)'); return; }\n    running = true;\n    if(modeSelect.value === 'auto'){\n      startAuto();\n    }\n  });\n  pauseBtn.addEventListener('click', ()=>{\n    running = false;\n    stopAuto();\n  });\n  stepBtn.addEventListener('click', ()=>{\n    if(!source){ alert('Select a source node first (click a node)'); return; }\n    stepOnce();\n  });\n  detectBtn.addEventListener('click', ()=>{\n    if(!source){ alert('Select a source first'); return; }\n    detectNegativeCycle();\n  });\n  selectBtn.addEventListener('click', ()=>{\n    selectingSourceMode = !selectingSourceMode;\n    selectBtn.textContent = selectingSourceMode ? 'Click a node...' : 'Select Source';\n  });\n\n  // Algorithm functions\n  function resetAlgorithmState(){\n    const V = nodes.length;\n    dist = new Array(nextId).fill(Infinity);\n    pred = new Array(nextId).fill(null);\n    inNegCycle = new Array(nextId).fill(false);\n    iter = 0;\n    edgeIdx = 0;\n    running = false;\n    stopAuto();\n    iterLabel.textContent = '0';\n    vcount.textContent = V;\n    ecount.textContent = edges.length;\n    if(source !== null && nodes.find(n=>n.id===source) ){\n      dist[source] = 0;\n    } else {\n      source = null;\n    }\n    edges.forEach(e=> e._highlight = false);\n    refreshDistTable();\n  }\n\n  function refreshDistTable(){\n    distList.innerHTML = '';\n    nodes.forEach(n=>{\n      const d = dist[n.id];\n      const p = pred[n.id];\n      const div = document.createElement('div');\n      div.className = 'dist-cell';\n      div.innerHTML = '<strong>'+n.label+'</strong> &nbsp; dist: <em>' + (d===Infinity ? '∞' : (d===-Infinity ? '-∞' : d)) + '</em>' +\n        ' &nbsp; pred: ' + (p===null ? '-' : nodes.find(m=>m.id===p)?.label || '?') +\n        (inNegCycle[n.id] ? ' <span style=\"color:#b00\">[neg-cycle]</span>' : '');\n      distList.appendChild(div);\n    });\n  }\n\n  function stepOnce(){\n    // If finished iterations (V-1), do nothing or run negative cycle detection\n    const V = nodes.length;\n    if(V===0) return;\n    if(source===null){ alert('Pick a source node first (click a node)'); return; }\n    if(iter >= Math.max(V-1,0)){\n      log('All iterations done. You can run negative cycle detection.');\n      return;\n    }\n    if(edges.length === 0){\n      iter = V-1;\n      iterLabel.textContent = iter;\n      refreshDistTable();\n      draw();\n      return;\n    }\n    // Relax current edge\n    const e = edges[edgeIdx];\n    edges.forEach(ed=>ed._highlight=false);\n    e._highlight = true;\n    const uDist = dist[e.u];\n    const vDist = dist[e.v];\n    const via = (uDist === Infinity) ? Infinity : (uDist + e.w);\n\n    if(uDist !== Infinity && via < vDist){\n      dist[e.v] = via;\n      pred[e.v] = e.u;\n      log(`Relaxed edge ${nodeLabel(e.u)} -> ${nodeLabel(e.v)} (w=${e.w}): updated ${nodeLabel(e.v)} dist=${via}`);\n    } else {\n      log(`Tried edge ${nodeLabel(e.u)} -> ${nodeLabel(e.v)} (w=${e.w}): no change`);\n    }\n    edgeIdx++;\n    if(edgeIdx >= edges.length){\n      // finished an iteration\n      iter++;\n      edgeIdx = 0;\n      iterLabel.textContent = iter;\n      log('Completed iteration ' + iter + ' of ' + Math.max(V-1,0));\n    }\n    refreshDistTable();\n    draw();\n  }\n\n  function startAuto(){\n    stopAuto();\n    animationTimer = setInterval(()=>{\n      if(!running) { stopAuto(); return; }\n      const V = nodes.length;\n      if(iter >= Math.max(V-1,0)){\n        running = false;\n        stopAuto();\n        log('Finished V-1 iterations.');\n        return;\n      }\n      stepOnce();\n    }, stepDelay);\n  }\n\n  function stopAuto(){\n    if(animationTimer){ clearInterval(animationTimer); animationTimer = null; }\n  }\n\n  function nodeLabel(id){\n    const n = nodes.find(x=>x.id===id);\n    return n ? n.label : id;\n  }\n\n  function detectNegativeCycle(){\n    // After V-1 iterations, perform one more pass to find relaxable edges\n    const V = nodes.length;\n    if(V===0) return;\n    // ensure we've run V-1 iterations; run remaining iterations automatically if not\n    while(iter < Math.max(V-1,0)){\n      // run through all edges in each missing iteration\n      for(let i=0;i<edges.length;i++){\n        const e = edges[i];\n        if(dist[e.u] !== Infinity && dist[e.u] + e.w < dist[e.v]){\n          dist[e.v] = dist[e.u] + e.w;\n          pred[e.v] = e.u;\n        }\n      }\n      iter++;\n    }\n    // one more pass to detect nodes that can still be relaxed\n    const affected = [];\n    edges.forEach(e=>{\n      if(dist[e.u] !== Infinity && dist[e.u] + e.w < dist[e.v]){\n        affected.push(e.v);\n        log('Edge ' + nodeLabel(e.u) + ' -> ' + nodeLabel(e.v) + ' can still relax, negative cycle reachable.');\n      }\n    });\n    // propagate affected to mark all reachable nodes from them\n    const mark = new Set();\n    const adj = buildAdjacency();\n    const stack = [...affected];\n    while(stack.length){\n      const v = stack.pop();\n      if(mark.has(v)) continue;\n      mark.add(v);\n      const out = adj[v] || [];\n      out.forEach(w=>{ if(!mark.has(w)) stack.push(w); });\n    }\n    inNegCycle = inNegCycle.map((_,i)=> mark.has(i));\n    if(mark.size === 0) {\n      log('No negative cycle reachable from the source detected.');\n      alert('No negative cycle reachable from the source.');\n    } else {\n      log('Marked nodes involved/reachable from negative cycle: ' + Array.from(mark).map(nodeLabel).join(', '));\n      alert('Negative cycle detected! Some nodes are marked with *.');\n    }\n    refreshDistTable();\n    draw();\n  }\n\n  function buildAdjacency(){\n    const adj = {};\n    edges.forEach(e=>{\n      if(!adj[e.u]) adj[e.u]=[];\n      adj[e.u].push(e.v);\n    });\n    return adj;\n  }\n\n  // Sample graph\n  function loadSample(){\n    nodes = [\n      {id:0,label:'A',x:120,y:120},\n      {id:1,label:'B',x:300,y:80},\n      {id:2,label:'C',x:500,y:120},\n      {id:3,label:'D',x:220,y:260},\n      {id:4,label:'E',x:420,y:260}\n    ];\n    nextId = 5;\n    edges = [\n      {u:0,v:1,w:6,_highlight:false},\n      {u:0,v:3,w:7,_highlight:false},\n      {u:1,v:2,w:5,_highlight:false},\n      {u:1,v:3,w:8,_highlight:false},\n      {u:1,v:4,w:-4,_highlight:false},\n      {u:2,v:1,w:-2,_highlight:false},\n      {u:3,v:2,w:-3,_highlight:false},\n      {u:3,v:4,w:9,_highlight:false},\n      {u:4,v:0,w:2,_highlight:false},\n    ];\n    source = 0;\n    log('Loaded sample graph (classic Bellman-Ford example). Source = A');\n    resetAlgorithmState();\n    // set source again to preserve\n    source = 0;\n    dist[source] = 0;\n    draw();\n  }\n\n  function createRandom(){\n    const count = Math.max(4, Math.min(10, Math.floor(Math.random()*6)+4));\n    nodes = [];\n    edges = [];\n    nextId=0;\n    for(let i=0;i<count;i++){\n      const x = 80 + Math.random()*(w-160);\n      const y = 60 + Math.random()*(h-160);\n      nodes.push({id:nextId,label:'N'+nextId,x,y});\n      nextId++;\n    }\n    // create edges\n    const m = Math.floor(count*1.6) + Math.floor(Math.random()*count);\n    for(let i=0;i<m;i++){\n      const u = nodes[Math.floor(Math.random()*nodes.length)].id;\n      let v = nodes[Math.floor(Math.random()*nodes.length)].id;\n      if(u===v) continue;\n      const wgt = Math.floor(Math.random()*21)-10; // -10..10\n      edges.push({u,v,w:wgt,_highlight:false});\n    }\n    source = nodes[0].id;\n    log('Created random graph with ' + nodes.length + ' nodes.');\n    resetAlgorithmState();\n    source = nodes[0].id;\n    dist[source]=0;\n    draw();\n  }\n\n  // initialize\n  resize();\n  loadSample();\n\n  // keyboard shortcuts\n  window.addEventListener('keydown',(e)=>{\n    if(e.key === ' '){\n      e.preventDefault();\n      if(modeSelect.value === 'step') stepOnce(); else {\n        running = !running;\n        if(running) startAuto(); else stopAuto();\n      }\n    }\n  });\n\n  // ensure canvas is crisp on high-DPI\n  function fixHiDPI(){\n    const ratio = window.devicePixelRatio || 1;\n    canvas.width = wrap.clientWidth * ratio;\n    canvas.height = wrap.clientHeight * ratio;\n    canvas.style.width = wrap.clientWidth + 'px';\n    canvas.style.height = wrap.clientHeight + 'px';\n    ctx.setTransform(ratio,0,0,ratio,0,0);\n  }\n  fixHiDPI();\n  window.addEventListener('resize', fixHiDPI);\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": false,
  "hasTest": true
}