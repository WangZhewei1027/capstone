{
  "id": "2bde438e-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:17:13.580Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>Breadth-First Search (BFS) Interactive Demo</title>\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, Arial; margin: 0; display: flex; height: 100vh; }\n  #left { width: 72%; border-right: 1px solid #ddd; position: relative; background: #fafafa; }\n  #controls { padding: 12px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; background: #fff; border-bottom: 1px solid #eee; }\n  button, select, input[type=range] { padding: 6px 10px; border-radius: 6px; border: 1px solid #ccc; background: white; cursor: pointer; }\n  button:active { transform: translateY(1px); }\n  #canvas { width: 100%; height: calc(100% - 56px); }\n  svg { width: 100%; height: 100%; display: block; }\n  .node { cursor: grab; }\n  .node:active { cursor: grabbing; }\n  .label { font-weight: 600; font-size: 13px; pointer-events: none; }\n  .info { width: 28%; padding: 12px; overflow: auto; }\n  .panel { background: #fff; border: 1px solid #eee; padding: 10px; border-radius: 8px; margin-bottom: 12px; }\n  .small { font-size: 13px; color: #555; }\n  .queues { display: flex; gap: 8px; flex-wrap: wrap; }\n  .box { padding: 8px; border-radius: 6px; background: #f5f7fa; min-width: 120px; }\n  .legend { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }\n  .legend .item { display:flex; gap:6px; align-items:center; }\n  .dot { width: 14px; height: 14px; border-radius: 50%; display:inline-block; border: 1px solid rgba(0,0,0,0.08); }\n  .controls-right { margin-left: auto; display:flex; gap:8px; align-items:center; }\n  .hint { color:#666; font-size:13px; margin-top:6px; }\n  a { color: #0077cc; text-decoration:none; }\n</style>\n</head>\n<body>\n  <div id=\"left\">\n    <div id=\"controls\">\n      <button id=\"addNodeBtn\">Add Node</button>\n      <button id=\"addEdgeBtn\">Add Edge</button>\n      <button id=\"deleteBtn\">Delete</button>\n      <label class=\"small\">Start:</label>\n      <select id=\"startSelect\"></select>\n      <button id=\"stepBtn\">Step</button>\n      <button id=\"playBtn\">Play</button>\n      <button id=\"resetBtn\">Reset</button>\n      <div class=\"controls-right\">\n        <label class=\"small\">Speed</label>\n        <input id=\"speed\" type=\"range\" min=\"200\" max=\"2000\" value=\"800\">\n        <select id=\"exampleSel\">\n          <option value=\"example1\">Example: Simple</option>\n          <option value=\"example2\">Example: Tree</option>\n          <option value=\"example3\">Example: Grid</option>\n          <option value=\"random\">Random graph</option>\n        </select>\n      </div>\n    </div>\n    <div id=\"canvas\">\n      <svg id=\"svgCanvas\"></svg>\n    </div>\n  </div>\n  <div class=\"info\">\n    <div class=\"panel\">\n      <div style=\"display:flex;align-items:center;gap:8px;\">\n        <strong>Breadth-First Search (BFS)</strong>\n        <div style=\"margin-left:auto;font-size:13px;color:#666\">Undirected graph demo</div>\n      </div>\n      <p class=\"small\">Click \"Add Node\" then click on canvas to create nodes. Click \"Add Edge\" then click two nodes to connect them. Drag nodes to rearrange. Select a start node and press \"Step\" to advance one BFS step or \"Play\" to animate. \"Reset\" clears the BFS state so you can re-run.</p>\n      <div class=\"legend\">\n        <div class=\"item\"><span class=\"dot\" style=\"background:#ffffff;border:1px solid #bbb\"></span> Unvisited</div>\n        <div class=\"item\"><span class=\"dot\" style=\"background: #ffdf7d\"></span> In Queue</div>\n        <div class=\"item\"><span class=\"dot\" style=\"background: #7bc96f\"></span> Visited</div>\n        <div class=\"item\"><span class=\"dot\" style=\"background: #66b2ff\"></span> Current</div>\n      </div>\n    </div>\n\n    <div class=\"panel\">\n      <strong>Queue</strong>\n      <div id=\"queueView\" class=\"box small\" style=\"margin-top:8px; min-height:28px\"></div>\n      <div style=\"margin-top:8px\"><strong>Visited order</strong></div>\n      <div id=\"visitedView\" class=\"box small\" style=\"margin-top:8px; min-height:28px\"></div>\n    </div>\n\n    <div class=\"panel\">\n      <strong>Actions</strong>\n      <p class=\"small\">Modes:</p>\n      <ul class=\"small\">\n        <li><b>Add Node</b>: click on empty canvas to place node.</li>\n        <li><b>Add Edge</b>: click first node then second to connect (undirected).</li>\n        <li><b>Delete</b>: click a node to remove it and its edges; click an edge to remove that edge.</li>\n      </ul>\n      <p class=\"hint\">This visualization highlights how BFS explores neighbors by processing nodes level-by-level using a queue. Try different graphs and starting nodes.</p>\n    </div>\n\n    <div class=\"panel small\">\n      <strong>Implementation notes</strong>\n      <p>BFS uses a queue. When a node is discovered it's enqueued and marked \"in queue\". When dequeued it's processed and marked \"visited\". Neighbors not yet seen are discovered and enqueued.</p>\n    </div>\n  </div>\n\n<script>\n(function(){\n  // Simple interactive BFS demo\n  const svg = document.getElementById('svgCanvas');\n  const addNodeBtn = document.getElementById('addNodeBtn');\n  const addEdgeBtn = document.getElementById('addEdgeBtn');\n  const deleteBtn = document.getElementById('deleteBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const playBtn = document.getElementById('playBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const startSelect = document.getElementById('startSelect');\n  const queueView = document.getElementById('queueView');\n  const visitedView = document.getElementById('visitedView');\n  const speedInput = document.getElementById('speed');\n  const exampleSel = document.getElementById('exampleSel');\n\n  let mode = null; // 'addNode', 'addEdge', 'delete', null means drag/none\n  let nodes = []; // {id,x,y,group}\n  let edges = []; // {id,a,b}\n  let nodeIdCounter = 0;\n  let edgeIdCounter = 0;\n\n  // BFS state\n  let bfsQueue = [];\n  let visitedSet = new Set();\n  let discoveredSet = new Set();\n  let current = null;\n  let playing = false;\n  let playTimer = null;\n\n  // UI helpers\n  function setMode(m){\n    mode = m;\n    addNodeBtn.style.background = m === 'addNode' ? '#e8f4ff' : 'white';\n    addEdgeBtn.style.background = m === 'addEdge' ? '#e8f4ff' : 'white';\n    deleteBtn.style.background = m === 'delete' ? '#ffecec' : 'white';\n  }\n\n  addNodeBtn.onclick = ()=> setMode(mode === 'addNode' ? null : 'addNode');\n  addEdgeBtn.onclick = ()=> setMode(mode === 'addEdge' ? null : 'addEdge');\n  deleteBtn.onclick = ()=> setMode(mode === 'delete' ? null : 'delete');\n\n  // Canvas interactions\n  let selectedForEdge = null;\n  function createNode(x,y,label){\n    const id = 'n' + (++nodeIdCounter);\n    const node = { id, x, y, r:22, label: label || id, elGroup: null };\n    nodes.push(node);\n    draw();\n    populateStartSelect();\n    return node;\n  }\n  function removeNode(node){\n    edges = edges.filter(e => e.a !== node.id && e.b !== node.id);\n    nodes = nodes.filter(n => n.id !== node.id);\n    draw();\n    populateStartSelect();\n  }\n  function createEdge(aId,bId){\n    // avoid duplicates and self-loops\n    if(aId === bId) return null;\n    if(edges.some(e => (e.a===aId && e.b===bId) || (e.a===bId && e.b===aId))) return null;\n    const id = 'e' + (++edgeIdCounter);\n    const e = { id, a: aId, b: bId };\n    edges.push(e);\n    draw();\n    return e;\n  }\n  function removeEdge(edge){\n    edges = edges.filter(e => e.id !== edge.id);\n    draw();\n  }\n\n  function clearBFSState(){\n    bfsQueue = [];\n    visitedSet.clear();\n    discoveredSet.clear();\n    current = null;\n    playing = false;\n    if(playTimer) {\n      clearInterval(playTimer);\n      playTimer = null;\n    }\n    playBtn.textContent = 'Play';\n    updateViews();\n    draw(); // to reset colors\n  }\n\n  // BFS logic: one step performs processing of one node from queue and enqueues undiscovered neighbors\n  function bfsStep(startId){\n    // If BFS not started: initialize\n    if(!bfsQueue.length && !visitedSet.size && !discoveredSet.size){\n      // begin BFS\n      bfsQueue.push(startId);\n      discoveredSet.add(startId);\n      updateViews();\n      draw();\n      return;\n    }\n    if(bfsQueue.length === 0){\n      current = null;\n      updateViews();\n      draw();\n      return;\n    }\n    const nodeId = bfsQueue.shift();\n    current = nodeId;\n    visitedSet.add(nodeId);\n    updateViews();\n    draw();\n    // discover neighbors\n    const neighbors = getNeighbors(nodeId);\n    neighbors.forEach(nei => {\n      if(!discoveredSet.has(nei)){\n        discoveredSet.add(nei);\n        bfsQueue.push(nei);\n      }\n    });\n    updateViews();\n    drawEdgeHighlights(nodeId, neighbors);\n  }\n\n  function getNeighbors(nodeId){\n    const ns = [];\n    edges.forEach(e => {\n      if(e.a === nodeId) ns.push(e.b);\n      else if(e.b === nodeId) ns.push(e.a);\n    });\n    // sort to stable deterministic order (by id)\n    ns.sort();\n    return ns;\n  }\n\n  // Visual rendering\n  function draw(){\n    while(svg.firstChild) svg.removeChild(svg.firstChild);\n    // draw edges\n    edges.forEach(e => {\n      const a = nodes.find(n=>n.id===e.a);\n      const b = nodes.find(n=>n.id===e.b);\n      if(!a || !b) return;\n      const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n      line.setAttribute('x1', a.x);\n      line.setAttribute('y1', a.y);\n      line.setAttribute('x2', b.x);\n      line.setAttribute('y2', b.y);\n      line.setAttribute('stroke', '#bbb');\n      line.setAttribute('stroke-width', 3);\n      line.setAttribute('stroke-linecap','round');\n      line.dataset.edgeId = e.id;\n      line.style.cursor = mode === 'delete' ? 'pointer' : 'default';\n      line.addEventListener('click', ev => {\n        ev.stopPropagation();\n        if(mode === 'delete') removeEdge(e);\n      });\n      svg.appendChild(line);\n    });\n    // draw nodes\n    nodes.forEach(n => {\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      g.setAttribute('transform', `translate(${n.x},${n.y})`);\n      g.classList.add('node');\n      // circle\n      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      circle.setAttribute('r', n.r);\n      circle.setAttribute('cx', 0);\n      circle.setAttribute('cy', 0);\n      circle.setAttribute('stroke', '#888');\n      circle.setAttribute('stroke-width', 1);\n      circle.dataset.nodeId = n.id;\n\n      // determine color based on BFS state\n      if(current === n.id){\n        circle.setAttribute('fill', '#66b2ff'); // current\n        circle.setAttribute('stroke', '#2470d9');\n        circle.setAttribute('stroke-width', 2.5);\n      } else if(visitedSet.has(n.id)){\n        circle.setAttribute('fill', '#7bc96f'); // visited\n        circle.setAttribute('stroke', '#4f9d4a');\n      } else if(discoveredSet.has(n.id)){\n        circle.setAttribute('fill', '#ffdf7d'); // in queue\n        circle.setAttribute('stroke', '#e6c85c');\n      } else {\n        circle.setAttribute('fill', '#ffffff'); // unvisited\n      }\n\n      // shadow\n      circle.setAttribute('filter','');\n      g.appendChild(circle);\n\n      // label\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('text-anchor','middle');\n      text.setAttribute('dy','6');\n      text.setAttribute('class','label');\n      text.setAttribute('pointer-events','none');\n      text.textContent = n.label;\n      g.appendChild(text);\n\n      // events\n      g.addEventListener('mousedown', ev => {\n        ev.stopPropagation();\n        if(mode === 'addEdge'){\n          if(!selectedForEdge){\n            selectedForEdge = n;\n            circle.setAttribute('stroke', '#d95bff');\n            circle.setAttribute('stroke-width', 3);\n          } else {\n            createEdge(selectedForEdge.id, n.id);\n            selectedForEdge = null;\n            draw();\n          }\n          return;\n        }\n        if(mode === 'delete'){\n          removeNode(n);\n          return;\n        }\n        // start drag\n        startDrag(n, g);\n      });\n\n      svg.appendChild(g);\n      n.elGroup = g;\n    });\n    // bring node groups to front so they overlay edges\n    // (we appended edges first then nodes, so OK)\n  }\n\n  // temporary highlight when exploring neighbors\n  function drawEdgeHighlights(nodeId, neighbors){\n    // briefly highlight edges between current node and its neighbors\n    edges.forEach(e => {\n      if(e.a === nodeId && neighbors.includes(e.b) || e.b === nodeId && neighbors.includes(e.a)){\n        // draw overlay line\n        const a = nodes.find(n=>n.id===e.a);\n        const b = nodes.find(n=>n.id===e.b);\n        if(!a||!b) return;\n        const path = document.createElementNS('http://www.w3.org/2000/svg','line');\n        path.setAttribute('x1', a.x);\n        path.setAttribute('y1', a.y);\n        path.setAttribute('x2', b.x);\n        path.setAttribute('y2', b.y);\n        path.setAttribute('stroke', '#ff7a7a');\n        path.setAttribute('stroke-width', 5);\n        path.setAttribute('stroke-linecap','round');\n        path.style.opacity = 0.95;\n        svg.appendChild(path);\n        setTimeout(()=> {\n          if(path.parentNode) path.parentNode.removeChild(path);\n        }, Math.max(400, parseInt(speedInput.value)/2));\n      }\n    });\n  }\n\n  // drag handling\n  let dragging = null;\n  let dragOffset = {x:0,y:0};\n  function startDrag(node, group){\n    if(mode) return;\n    dragging = node;\n    const pt = getMouseSVGPoint(lastMouseEvent);\n    dragOffset.x = node.x - pt.x;\n    dragOffset.y = node.y - pt.y;\n    document.addEventListener('mousemove', onDrag);\n    document.addEventListener('mouseup', endDrag);\n  }\n  function onDrag(ev){\n    if(!dragging) return;\n    const pt = getMouseSVGPoint(ev);\n    dragging.x = pt.x + dragOffset.x;\n    dragging.y = pt.y + dragOffset.y;\n    draw();\n  }\n  function endDrag(ev){\n    dragging = null;\n    document.removeEventListener('mousemove', onDrag);\n    document.removeEventListener('mouseup', endDrag);\n  }\n\n  function getMouseSVGPoint(evt){\n    const rect = svg.getBoundingClientRect();\n    const x = (evt.clientX - rect.left);\n    const y = (evt.clientY - rect.top);\n    return {x,y};\n  }\n\n  let lastMouseEvent = null;\n  svg.addEventListener('mousemove', ev => lastMouseEvent = ev);\n\n  // click canvas to add node or clear selection\n  svg.addEventListener('click', ev => {\n    const pt = getMouseSVGPoint(ev);\n    if(mode === 'addNode'){\n      const lab = String.fromCharCode(65 + (nodes.length % 26));\n      createNode(pt.x, pt.y, lab + nodes.length);\n    } else {\n      // clicking blank clears selectedForEdge\n      if(selectedForEdge){\n        selectedForEdge = null;\n        draw();\n      }\n    }\n  });\n\n  // delete edges by clicking line when in delete mode is handled earlier\n\n  // populate startSelect\n  function populateStartSelect(){\n    const prev = startSelect.value;\n    while(startSelect.firstChild) startSelect.removeChild(startSelect.firstChild);\n    nodes.forEach(n => {\n      const opt = document.createElement('option');\n      opt.value = n.id;\n      opt.textContent = n.label;\n      startSelect.appendChild(opt);\n    });\n    if(nodes.length){\n      startSelect.value = prev && nodes.some(n=>n.id===prev) ? prev : nodes[0].id;\n    }\n  }\n\n  // Views update\n  function updateViews(){\n    queueView.innerHTML = '';\n    visitedView.innerHTML = '';\n    // queue items show labels\n    const qlabels = bfsQueue.map(id => (nodes.find(n=>n.id===id)||{label:id}).label);\n    queueView.textContent = qlabels.join(' â† ');\n    const vlabels = Array.from(visitedSet).map(id => (nodes.find(n=>n.id===id)||{label:id}).label);\n    visitedView.textContent = vlabels.join(', ');\n    // update play button text\n    playBtn.textContent = playing ? 'Pause' : 'Play';\n  }\n\n  // Step and play controls\n  stepBtn.onclick = ()=> {\n    if(!nodes.length) return;\n    const start = startSelect.value || nodes[0].id;\n    bfsStep(start);\n  };\n\n  playBtn.onclick = ()=> {\n    if(playing){\n      playing = false;\n      if(playTimer) { clearInterval(playTimer); playTimer = null; }\n      playBtn.textContent = 'Play';\n    } else {\n      if(!nodes.length) return;\n      playing = true;\n      playBtn.textContent = 'Pause';\n      const start = startSelect.value || nodes[0].id;\n      // initialize if first step not yet done\n      if(!bfsQueue.length && !visitedSet.size && !discoveredSet.size){\n        bfsQueue.push(start);\n        discoveredSet.add(start);\n        updateViews();\n        draw();\n      }\n      playTimer = setInterval(()=> {\n        if(bfsQueue.length === 0){\n          playing = false;\n          clearInterval(playTimer);\n          playTimer = null;\n          playBtn.textContent = 'Play';\n          current = null;\n          draw();\n          updateViews();\n          return;\n        }\n        bfsStep(start);\n      }, Math.max(80, parseInt(speedInput.value)));\n    }\n  };\n\n  resetBtn.onclick = ()=> {\n    clearBFSState();\n  };\n\n  // Example graphs\n  exampleSel.onchange = ()=> loadExample(exampleSel.value);\n  function clearGraph(){\n    nodes = [];\n    edges = [];\n    nodeIdCounter = 0;\n    edgeIdCounter = 0;\n    selectedForEdge = null;\n    clearBFSState();\n    draw();\n    populateStartSelect();\n  }\n  function loadExample(name){\n    clearGraph();\n    if(name === 'example1'){\n      // simple\n      const a = createNode(140,120,'A'); const b = createNode(300,100,'B');\n      const c = createNode(420,160,'C'); const d = createNode(240,240,'D');\n      const e = createNode(420,260,'E');\n      createEdge(a.id,b.id); createEdge(a.id,d.id); createEdge(b.id,c.id); createEdge(d.id,e.id); createEdge(c.id,e.id);\n    } else if(name === 'example2'){\n      // tree\n      const root = createNode(300,80,'1');\n      const n2 = createNode(200,160,'2'); const n3 = createNode(400,160,'3');\n      const n4 = createNode(150,240,'4'); const n5 = createNode(250,240,'5');\n      const n6 = createNode(350,240,'6'); const n7 = createNode(450,240,'7');\n      createEdge(root.id,n2.id); createEdge(root.id,n3.id);\n      createEdge(n2.id,n4.id); createEdge(n2.id,n5.id);\n      createEdge(n3.id,n6.id); createEdge(n3.id,n7.id);\n    } else if(name === 'example3'){\n      // grid 3x3\n      const grid = [];\n      for(let r=0;r<3;r++){\n        for(let c=0;c<3;c++){\n          grid.push(createNode(120 + c*140, 80 + r*120, `${r},${c}`));\n        }\n      }\n      function idx(r,c){ return r*3 + c; }\n      for(let r=0;r<3;r++){\n        for(let c=0;c<3;c++){\n          if(c<2) createEdge(grid[idx(r,c)].id, grid[idx(r,c+1)].id);\n          if(r<2) createEdge(grid[idx(r,c)].id, grid[idx(r+1,c)].id);\n        }\n      }\n    } else if(name === 'random'){\n      // random graph\n      const count = 8;\n      for(let i=0;i<count;i++){\n        createNode(80 + Math.random() * 640, 60 + Math.random() * 420, String.fromCharCode(65+i));\n      }\n      // random edges\n      for(let i=0;i<count;i++){\n        for(let j=i+1;j<count;j++){\n          if(Math.random() < 0.25) createEdge(nodes[i].id, nodes[j].id);\n        }\n      }\n      // ensure connectivity by at least chaining\n      for(let i=0;i<count-1;i++){\n        if(!edges.some(e => (e.a===nodes[i].id && e.b===nodes[i+1].id) || (e.a===nodes[i+1].id && e.b===nodes[i].id))){\n          createEdge(nodes[i].id, nodes[i+1].id);\n        }\n      }\n    }\n    clearBFSState();\n    draw();\n    populateStartSelect();\n  }\n\n  // deletion of edges by clicking lines handled in draw() addEventListener\n\n  // initialize with example1\n  loadExample('example1');\n\n  // small helper: clicking outside stops edge selection\n  document.addEventListener('keydown', ev => {\n    if(ev.key === 'Escape'){\n      selectedForEdge = null;\n      setMode(null);\n      draw();\n    }\n  });\n\n  // ensure UI responsiveness\n  speedInput.addEventListener('input', ()=> {\n    if(playing){\n      if(playTimer) { clearInterval(playTimer); playTimer = null; }\n      playTimer = setInterval(()=> {\n        const start = startSelect.value || (nodes[0] && nodes[0].id);\n        if(!start) return;\n        if(bfsQueue.length === 0){\n          playing = false;\n          clearInterval(playTimer);\n          playTimer = null;\n          playBtn.textContent = 'Play';\n          current = null;\n          draw();\n          updateViews();\n          return;\n        }\n        bfsStep(start);\n      }, Math.max(80, parseInt(speedInput.value)));\n    }\n  });\n\n  // expose for debugging (not necessary)\n  window._graphDemo = { createNode, createEdge, nodes, edges, draw };\n\n  // small safety: clicking on UI should not add node\n  document.getElementById('left').addEventListener('click', ev => {\n    // keep default\n  });\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": false,
  "hasTest": true
}