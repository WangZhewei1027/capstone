{
  "id": "2bde4381-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:17:07.533Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Union-Find (Disjoint Set)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Union-Find (Disjoint Set) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #06b6d4;\n      --muted: #94a3b8;\n      --card: #071024;\n      --good: #10b981;\n      --warn: #f59e0b;\n      --danger: #ef4444;\n      --glass: rgba(255,255,255,0.03);\n    }\n    html,body { height:100%; margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background: radial-gradient(1000px 600px at 10% 10%, rgba(6,182,212,0.06), transparent), radial-gradient(800px 500px at 90% 90%, rgba(16,185,129,0.04), transparent), var(--bg); color:#e6eef6; }\n    .app { display:flex; gap:16px; padding:18px; box-sizing:border-box; height:100vh; }\n    .left { width:360px; min-width:260px; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border-radius:12px; padding:14px; box-shadow: 0 6px 30px rgba(2,6,23,0.6); display:flex; flex-direction:column; }\n    h1 { font-size:18px; margin:0 0 8px 0; letter-spacing:0.2px;}\n    .section { background:var(--card); border-radius:10px; padding:10px; margin-bottom:10px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }\n    label { display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }\n    input[type=number], input[type=text], select { width:100%; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; box-sizing:border-box; }\n    button { background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); color:inherit; padding:8px 10px; border-radius:8px; cursor:pointer; }\n    .row { display:flex; gap:8px; align-items:center; }\n    .row.space { justify-content:space-between; }\n    .small { font-size:12px; color:var(--muted); }\n    .controls { display:flex; flex-direction:column; gap:8px; }\n    .arrays { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }\n    .array { background:var(--glass); padding:8px; border-radius:8px; font-family:monospace; font-size:13px; min-width:120px; }\n    .svg-wrap { flex:1; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.005)); padding:10px; display:flex; flex-direction:column; gap:10px; box-shadow: 0 6px 30px rgba(2,6,23,0.55); }\n    .viz-toolbar { display:flex; gap:8px; align-items:center; }\n    .legend { display:flex; gap:8px; align-items:center; font-size:13px; color:var(--muted); }\n    .legend .dot { width:12px; height:12px; border-radius:50%; display:inline-block; margin-right:6px; }\n    svg { width:100%; height:100%; border-radius:8px; background: linear-gradient(180deg, rgba(255,255,255,0.008), transparent); }\n    .info { font-size:13px; color:var(--muted); }\n    .footer { margin-top:auto; font-size:12px; color:var(--muted); text-align:center; }\n    .btn-primary { background:linear-gradient(90deg,var(--accent),#34d399); border:none; color:#042027; }\n    .switch { display:inline-flex; gap:8px; align-items:center; }\n    .badge { font-size:12px; color:#021018; background:linear-gradient(90deg,var(--muted), rgba(255,255,255,0.06)); padding:6px 8px; border-radius:8px; }\n    .highlight { stroke: #f59e0b; stroke-width:3px; }\n    /* node styles */\n    .node { cursor:pointer; }\n    .node circle { fill: linear-gradient(#022, #024); fill: #041726; stroke: rgba(255,255,255,0.04); stroke-width:1.5px; transition: transform 200ms ease; }\n    .node text { font-size:14px; fill:#d7eef6; pointer-events:none; }\n    .root circle { fill: #063b4a; stroke: #06b6d4; stroke-width:2px; }\n    .find-path circle { fill: #7c3aed; stroke: #a78bfa; stroke-width:2px; }\n    .compressed circle { fill: #0ea5a4; stroke: #22c1c3; stroke-width:2px; }\n    .edge { stroke: rgba(255,255,255,0.07); stroke-width:2px; marker-end: url(#arrow); }\n    .edge.highlight { stroke: #f59e0b; stroke-width:3px; opacity:1; }\n    .info-block { font-size:13px; color:var(--muted); background: rgba(255,255,255,0.02); padding:8px; border-radius:8px; }\n    .small-muted { font-size:12px; color:var(--muted); }\n    .controls .row > * { flex:1; }\n    .tip { font-size:12px; color:var(--muted); margin-top:6px; }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"left\">\n      <h1>Union-Find (Disjoint Set) Visualizer</h1>\n      <div class=\"section\">\n        <div class=\"controls\">\n          <div class=\"row space\">\n            <label style=\"margin:0\">\n              Nodes (n)\n            </label>\n            <div style=\"display:flex; gap:8px; align-items:center;\">\n              <input id=\"nInput\" type=\"number\" min=\"1\" value=\"10\" style=\"width:84px;\" />\n              <button id=\"resetBtn\">Create</button>\n            </div>\n          </div>\n\n          <div class=\"row\">\n            <label style=\"margin:0\">Union (a, b)</label>\n            <input id=\"unionInput\" type=\"text\" placeholder=\"e.g. 2,5\" />\n            <div style=\"display:flex; gap:8px;\">\n              <button id=\"unionBtn\">Union</button>\n              <button id=\"randUnionBtn\">Random</button>\n            </div>\n          </div>\n\n          <div class=\"row\">\n            <label style=\"margin:0\">Find (x)</label>\n            <input id=\"findInput\" type=\"number\" placeholder=\"index\" />\n            <div style=\"display:flex; gap:8px;\">\n              <button id=\"findBtn\">Find (no compress)</button>\n              <button id=\"findCompBtn\" class=\"btn-primary\">Find & Compress</button>\n            </div>\n          </div>\n\n          <div class=\"row\">\n            <label style=\"margin:0\">Options</label>\n            <div style=\"display:flex; gap:8px; align-items:center;\">\n              <label class=\"switch small-muted\"><input id=\"byRank\" type=\"checkbox\" checked /> Union by rank</label>\n              <label class=\"switch small-muted\"><input id=\"pathComp\" type=\"checkbox\" checked /> Path compression</label>\n            </div>\n          </div>\n\n          <div class=\"row\">\n            <label style=\"margin:0\">Animation speed</label>\n            <input id=\"speed\" type=\"range\" min=\"50\" max=\"1500\" value=\"400\" />\n          </div>\n\n          <div class=\"row\">\n            <label style=\"margin:0\">Quick actions</label>\n            <div style=\"display:flex; gap:8px;\">\n              <button id=\"mergeRandom\">Merge random pairs</button>\n              <button id=\"resetAll\">Reset parents</button>\n            </div>\n          </div>\n\n          <div class=\"tip\">\n            Click any node in the visualization to run Find(x) (with or without compression depending on toggle).\n          </div>\n\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <div class=\"small-muted\">Internal arrays</div>\n        <div class=\"arrays\" id=\"arrays\">\n          <div class=\"array\" id=\"parentArr\">parent: []</div>\n          <div class=\"array\" id=\"rankArr\">rank: []</div>\n        </div>\n      </div>\n\n      <div class=\"section\">\n        <div class=\"info-block\">\n          Concepts:\n          <ul style=\"margin:6px 0 0 18px; padding:0; color:var(--muted);\">\n            <li>Find(x): find set representative (root) — optionally compress path.</li>\n            <li>Union(a,b): attach one root under another, using rank/size heuristics.</li>\n            <li>Time: amortized almost constant with union-by-rank + path compression.</li>\n          </ul>\n        </div>\n      </div>\n\n      <div class=\"footer\">\n        Built-in demo: interactive forest, animated pointer changes, and array view.\n      </div>\n    </div>\n\n    <div class=\"svg-wrap\">\n      <div class=\"viz-toolbar\">\n        <div class=\"legend\">\n          <div class=\"dot\" style=\"background:#063b4a\"></div> root\n          <div class=\"dot\" style=\"background:#7c3aed; margin-left:10px;\"></div> find path\n          <div class=\"dot\" style=\"background:#0ea5a4; margin-left:10px;\"></div> compressed\n        </div>\n        <div style=\"flex:1\"></div>\n        <div class=\"small-muted\" id=\"status\">Status: ready</div>\n      </div>\n      <svg id=\"svg\" viewBox=\"0 0 1200 720\" preserveAspectRatio=\"xMidYMid meet\">\n        <defs>\n          <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"8\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n            <path d=\"M0,0 L10,5 L0,10 L2,5 z\" fill=\"rgba(255,255,255,0.08)\"></path>\n          </marker>\n        </defs>\n        <!-- edges and nodes will be drawn here -->\n      </svg>\n      <div class=\"info\" id=\"infoBox\">Click nodes or use controls. Arrays show parent and rank.</div>\n    </div>\n  </div>\n\n<script>\n(() => {\n  // Basic Union-Find implementation with visualization hooks\n  let n = 10;\n  let parent = [];\n  let rank = [];\n  let svg = document.getElementById('svg');\n  let status = document.getElementById('status');\n  let parentArrEl = document.getElementById('parentArr');\n  let rankArrEl = document.getElementById('rankArr');\n  let infoBox = document.getElementById('infoBox');\n\n  const controls = {\n    byRank: document.getElementById('byRank'),\n    pathCompToggle: document.getElementById('pathComp'),\n    speed: document.getElementById('speed'),\n    nInput: document.getElementById('nInput'),\n    resetBtn: document.getElementById('resetBtn'),\n    unionBtn: document.getElementById('unionBtn'),\n    unionInput: document.getElementById('unionInput'),\n    randUnionBtn: document.getElementById('randUnionBtn'),\n    findBtn: document.getElementById('findBtn'),\n    findCompBtn: document.getElementById('findCompBtn'),\n    findInput: document.getElementById('findInput'),\n    mergeRandom: document.getElementById('mergeRandom'),\n    resetAll: document.getElementById('resetAll'),\n  };\n\n  function initArrays(m) {\n    n = m;\n    parent = new Array(n);\n    rank = new Array(n);\n    for (let i=0;i<n;i++){ parent[i]=i; rank[i]=0; }\n    updateArrays();\n    render();\n  }\n\n  function updateArrays() {\n    parentArrEl.textContent = 'parent: [' + parent.join(', ') + ']';\n    rankArrEl.textContent = 'rank:   [' + rank.join(', ') + ']';\n  }\n\n  // Visualization helpers\n  function clearSVG() {\n    while (svg.lastChild) svg.removeChild(svg.lastChild);\n    // re-add defs for marker\n    const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');\n    defs.innerHTML = '<marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"10\" refX=\"8\" refY=\"5\" orient=\"auto\" markerUnits=\"strokeWidth\"><path d=\"M0,0 L10,5 L0,10 L2,5 z\" fill=\"rgba(255,255,255,0.08)\"></path></marker>';\n    svg.appendChild(defs);\n  }\n\n  function buildChildren() {\n    // children lists\n    const children = Array.from({length:n}, ()=>[]);\n    for (let i=0;i<n;i++){\n      if (parent[i] !== i) children[parent[i]].push(i);\n    }\n    return children;\n  }\n\n  function computeTrees() {\n    const children = buildChildren();\n    const roots = [];\n    for (let i=0;i<n;i++) if (parent[i] === i) roots.push(i);\n    // For each root, create array of nodes in its tree\n    const trees = roots.map(root=>{\n      const nodes = [];\n      (function dfs(u){\n        nodes.push(u);\n        for (const v of children[u]) dfs(v);\n      })(root);\n      return {root, nodes};\n    });\n    return {children, roots, trees};\n  }\n\n  function render() {\n    clearSVG();\n    const {children, roots, trees} = computeTrees();\n    const pad = 20;\n    const width = 1200;\n    const height = 720;\n    const availW = width - (roots.length+1)*pad;\n    // allocate horizontal segments per tree proportional to tree size\n    const totalNodes = n || 1;\n    let xStart = pad;\n    for (const tree of trees) {\n      const segW = Math.max(150, Math.floor(availW * (tree.nodes.length / totalNodes)));\n      // compute levels (breadth) using BFS from root to assign depth\n      const levels = [];\n      const root = tree.root;\n      const queue = [{u:root, depth:0}];\n      const depthMap = new Map();\n      depthMap.set(root,0);\n      while (queue.length) {\n        const item = queue.shift();\n        const u = item.u, d = item.depth;\n        if (!levels[d]) levels[d]=[];\n        levels[d].push(u);\n        for (const v of children[u]) { depthMap.set(v,d+1); queue.push({u:v,depth:d+1}); }\n      }\n      const maxDepth = levels.length-1;\n      // for each level, space horizontally within segment\n      const segX = xStart;\n      const segY = 40;\n      const segRight = xStart + segW;\n      for (let d=0; d<=maxDepth; d++){\n        const row = levels[d];\n        const y = segY + d*120;\n        for (let i=0;i<row.length;i++){\n          const u = row[i];\n          const x = segX + (i+1)*(segW/(row.length+1));\n          // store positions\n          pos[u] = {x,y};\n        }\n      }\n      xStart += segW + pad;\n    }\n\n    // draw edges then nodes\n    // edges: for each node with parent != self, draw line from node to parent\n    for (let i=0;i<n;i++){\n      if (parent[i] !== i) {\n        const p = parent[i];\n        const A = pos[i];\n        const B = pos[p];\n        const line = document.createElementNS('http://www.w3.org/2000/svg','path');\n        const dx = B.x - A.x;\n        // curve to parent\n        const midX = A.x + dx*0.5;\n        const pathD = `M${A.x},${A.y} C ${midX},${A.y} ${midX},${B.y} ${B.x},${B.y}`;\n        line.setAttribute('d', pathD);\n        line.setAttribute('class','edge');\n        line.setAttribute('data-from', i);\n        line.setAttribute('data-to', p);\n        svg.appendChild(line);\n      }\n    }\n\n    // nodes\n    for (let i=0;i<n;i++){\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      g.setAttribute('class','node');\n      g.setAttribute('data-i', i);\n      g.style.cursor = 'pointer';\n      const p = pos[i];\n      g.setAttribute('transform', `translate(${p.x},${p.y})`);\n      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      circle.setAttribute('r','22');\n      // mark root\n      if (parent[i] === i) {\n        g.classList.add('root');\n      }\n      circle.setAttribute('fill','#041726');\n      circle.setAttribute('stroke','rgba(255,255,255,0.04)');\n      circle.setAttribute('stroke-width','1.5');\n      g.appendChild(circle);\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('x','0');\n      text.setAttribute('y','6');\n      text.setAttribute('text-anchor','middle');\n      text.textContent = i;\n      g.appendChild(text);\n\n      // attach click\n      g.addEventListener('click', async (ev) => {\n        const idx = Number(g.getAttribute('data-i'));\n        // if path compression toggle is on, run with compression, else just find\n        if (controls.pathCompToggle.checked) {\n          await animatedFind(idx, true);\n        } else {\n          await animatedFind(idx, false);\n        }\n      });\n\n      svg.appendChild(g);\n\n      // rank label\n      const rlabel = document.createElementNS('http://www.w3.org/2000/svg','text');\n      rlabel.setAttribute('x', p.x + 34);\n      rlabel.setAttribute('y', p.y - 10);\n      rlabel.setAttribute('font-size','12');\n      rlabel.setAttribute('fill','rgba(255,255,255,0.6)');\n      rlabel.textContent = 'r=' + rank[i];\n      svg.appendChild(rlabel);\n    }\n\n    updateArrays();\n  }\n\n  // positions storage (node index -> {x,y})\n  const pos = {};\n\n  // Utilities for animation\n  function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }\n  function animDelay() { return Number(controls.speed.value) || 400; }\n\n  // Non-visual find (returns root)\n  function findRoot(x) {\n    while (parent[x] !== x) x = parent[x];\n    return x;\n  }\n\n  // Animated find: highlights path, optionally compresses step-by-step\n  async function animatedFind(x, doCompress) {\n    status.textContent = `Status: finding ${x}...`;\n    // collect path to root\n    const path = [];\n    let cur = x;\n    while (true) {\n      path.push(cur);\n      if (parent[cur] === cur) break;\n      cur = parent[cur];\n    }\n    const root = cur;\n    highlightPath(path);\n    infoBox.textContent = `Find(${x}) -> ${root}. Path: ${path.join(' → ')}`;\n    await sleep(animDelay()/1.2);\n\n    if (doCompress) {\n      status.textContent = `Status: compressing path of ${x} to root ${root}...`;\n      // step-by-step compress: for each node in path (excluding root), set parent directly to root\n      for (let i=0;i<path.length-1;i++){\n        const u = path[i];\n        // animate edge change\n        await animateSetParent(u, root);\n        parent[u] = root;\n        await sleep(animDelay()/2);\n        render();\n      }\n      status.textContent = `Status: compressed ${x} to root ${root}.`;\n      updateArrays();\n    } else {\n      status.textContent = `Status: found root ${root} (no compression).`;\n    }\n\n    // flash root\n    flashNode(root, '#0ea5a4');\n    await sleep(200);\n    render();\n  }\n\n  function highlightPath(path) {\n    // add classes to nodes and edges\n    // first remove existing highlights\n    const edges = svg.querySelectorAll('.edge');\n    edges.forEach(e => e.classList.remove('highlight'));\n    const nodes = svg.querySelectorAll('.node');\n    nodes.forEach(n => n.classList.remove('find-path'));\n    for (let i=0;i<path.length;i++){\n      const u = path[i];\n      const node = svg.querySelector('.node[data-i=\"'+u+'\"]');\n      if (node) node.classList.add('find-path');\n      if (i < path.length-1) {\n        const v = path[i+1];\n        const edge = findEdgeElement(u,v);\n        if (edge) edge.classList.add('highlight');\n      }\n    }\n  }\n\n  function findEdgeElement(from, to) {\n    return svg.querySelector('.edge[data-from=\"'+from+'\"][data-to=\"'+to+'\"]');\n  }\n\n  async function animateSetParent(child, newParent) {\n    // animate edge changes: fade out old edge, draw new temporary edge, then render final\n    const oldEdge = svg.querySelector('.edge[data-from=\"'+child+'\"]');\n    if (oldEdge) {\n      oldEdge.style.transition = `opacity ${animDelay()/2}ms`;\n      oldEdge.style.opacity = '0.1';\n    }\n    // draw temporary curve to new parent\n    const cpos = pos[child];\n    const npos = pos[newParent];\n    const tmp = document.createElementNS('http://www.w3.org/2000/svg','path');\n    const midX = cpos.x + (npos.x - cpos.x)*0.5;\n    const d = `M${cpos.x},${cpos.y} C ${midX},${cpos.y} ${midX},${npos.y} ${npos.x},${npos.y}`;\n    tmp.setAttribute('d', d);\n    tmp.setAttribute('class','edge highlight');\n    tmp.setAttribute('stroke', '#10b981');\n    tmp.setAttribute('stroke-width','3');\n    svg.appendChild(tmp);\n    await sleep(animDelay()/1.6);\n    // remove tmp\n    svg.removeChild(tmp);\n    if (oldEdge) oldEdge.remove();\n  }\n\n  function flashNode(i, color) {\n    const node = svg.querySelector('.node[data-i=\"'+i+'\"]');\n    if (!node) return;\n    const circle = node.querySelector('circle');\n    if (!circle) return;\n    const original = circle.getAttribute('fill');\n    circle.setAttribute('fill', color);\n    setTimeout(()=>{ circle.setAttribute('fill', original); }, 500);\n  }\n\n  // Union operation with animation\n  async function union(a,b) {\n    if (a<0 || a>=n || b<0 || b>=n) {\n      status.textContent = 'Status: invalid indices';\n      return;\n    }\n    status.textContent = `Status: union(${a}, ${b})...`;\n    // find roots (non-destructive find to show path)\n    const ra = findRoot(a);\n    const rb = findRoot(b);\n    if (ra === rb) {\n      infoBox.textContent = `Union(${a}, ${b}): already in same set (root ${ra}).`;\n      status.textContent = 'Status: no-op, same root';\n      // highlight\n      highlightPath([a,ra]);\n      flashNode(ra, '#7c3aed');\n      await sleep(600);\n      render();\n      return;\n    }\n\n    // show both roots\n    highlightBothRoots(ra, rb);\n    await sleep(animDelay()/1.2);\n\n    if (controls.byRank.checked) {\n      // union by rank\n      if (rank[ra] < rank[rb]) {\n        await performUnionVisual(ra, rb); // attach ra under rb\n        parent[ra] = rb;\n      } else if (rank[ra] > rank[rb]) {\n        await performUnionVisual(rb, ra);\n        parent[rb] = ra;\n      } else {\n        // equal rank: attach rb under ra (arbitrary) and increase rank[ra]\n        await performUnionVisual(rb, ra);\n        parent[rb] = ra;\n        rank[ra]++;\n      }\n    } else {\n      // naive attach b's root under a's root\n      await performUnionVisual(rb, ra); // attach rb under ra\n      parent[rb] = ra;\n    }\n    updateArrays();\n    render();\n    status.textContent = `Status: union completed.`;\n    infoBox.textContent = `Union(${a}, ${b}) attached roots ${ra} & ${rb}.`;\n    await sleep(220);\n  }\n\n  function highlightBothRoots(ra, rb) {\n    // mark nodes\n    const nodes = svg.querySelectorAll('.node');\n    nodes.forEach(n => {\n      n.classList.remove('find-path');\n    });\n    const nra = svg.querySelector('.node[data-i=\"'+ra+'\"]');\n    const nrb = svg.querySelector('.node[data-i=\"'+rb+'\"]');\n    if (nra) nra.classList.add('find-path');\n    if (nrb) nrb.classList.add('find-path');\n  }\n\n  async function performUnionVisual(childRoot, newParentRoot) {\n    // animate changing parent pointers for the root 'childRoot'\n    status.textContent = `Status: attaching ${childRoot} under ${newParentRoot}...`;\n    // visually show an edge from childRoot to newParentRoot\n    await animateSetParent(childRoot, newParentRoot);\n  }\n\n  // Controls wiring\n  controls.resetBtn.addEventListener('click', ()=>{\n    const val = Number(controls.nInput.value) || 10;\n    initArrays(Math.max(1, Math.min(120, val)));\n    status.textContent = 'Status: created new forest.';\n  });\n\n  controls.unionBtn.addEventListener('click', async ()=>{\n    const txt = controls.unionInput.value.trim();\n    let a,b;\n    if (txt.includes(',')) {\n      const parts = txt.split(',').map(s=>Number(s.trim()));\n      a = parts[0]; b = parts[1];\n    } else {\n      const parts = txt.split(/\\s+/).map(s=>Number(s.trim()));\n      a = parts[0]; b = parts[1];\n    }\n    if (!Number.isFinite(a) || !Number.isFinite(b)) {\n      status.textContent = 'Status: invalid union input';\n      return;\n    }\n    await union(a,b);\n  });\n\n  controls.randUnionBtn.addEventListener('click', async ()=>{\n    // perform one random union\n    const a = Math.floor(Math.random()*n);\n    const b = Math.floor(Math.random()*n);\n    await union(a,b);\n  });\n\n  controls.findBtn.addEventListener('click', async ()=>{\n    const x = Number(controls.findInput.value);\n    if (!Number.isFinite(x) || x<0 || x>=n) {\n      status.textContent = 'Status: invalid index';\n      return;\n    }\n    await animatedFind(x, false);\n  });\n\n  controls.findCompBtn.addEventListener('click', async ()=>{\n    const x = Number(controls.findInput.value);\n    if (!Number.isFinite(x) || x<0 || x>=n) {\n      status.textContent = 'Status: invalid index';\n      return;\n    }\n    await animatedFind(x, true);\n  });\n\n  controls.mergeRandom.addEventListener('click', async ()=>{\n    // do a batch of random unions\n    status.textContent = 'Status: merging random pairs...';\n    const pairs = Math.max(1, Math.floor(n/2));\n    for (let i=0;i<pairs;i++){\n      const a = Math.floor(Math.random()*n);\n      const b = Math.floor(Math.random()*n);\n      await union(a,b);\n      await sleep(120);\n    }\n    status.textContent = 'Status: random merges done.';\n  });\n\n  controls.resetAll.addEventListener('click', ()=>{\n    for (let i=0;i<n;i++){ parent[i]=i; rank[i]=0; }\n    updateArrays();\n    render();\n    status.textContent = 'Status: parents reset (all separate sets).';\n  });\n\n  // initial setup\n  initArrays(10);\n\n  // allow clicking empty area to clear highlights\n  svg.addEventListener('click', (ev)=>{\n    if (ev.target === svg) {\n      // clear path highlights\n      const nodes = svg.querySelectorAll('.node');\n      nodes.forEach(n => n.classList.remove('find-path'));\n      const edges = svg.querySelectorAll('.edge');\n      edges.forEach(e => e.classList.remove('highlight'));\n      infoBox.textContent = 'Ready.';\n    }\n  });\n\n  // allow keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if (e.key === 'r') {\n      controls.resetBtn.click();\n    }\n    if (e.key === 'u') {\n      controls.unionBtn.click();\n    }\n  });\n\n  // small responsive rendering on resize\n  window.addEventListener('resize', ()=>{ render(); });\n\n  // Expose some debug in console\n  window.UF = {\n    get parent(){ return parent.slice(); },\n    get rank(){ return rank.slice(); },\n    find: findRoot,\n    unionSimple: async (a,b) => await union(a,b),\n    compressAll: () => {\n      for (let i=0;i<n;i++) parent[i] = findRoot(i);\n      updateArrays(); render();\n    }\n  };\n\n  // informative first render text\n  infoBox.textContent = 'Click a node to Find(x). Use toggles for union-by-rank and path compression. Arrays update live.';\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Union-Find (Disjoint Set)"
    }
  ],
  "topic": "Union-Find (Disjoint Set)",
  "hasFSM": false,
  "hasTest": true
}