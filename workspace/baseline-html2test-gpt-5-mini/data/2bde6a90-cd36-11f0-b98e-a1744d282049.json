{
  "id": "2bde6a90-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:17:22.558Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Kruskal's Algorithm Interactive Demo</title>\n<style>\n  html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background: #f7f9fc; color:#1b2b3a; }\n  #app { display:flex; height:100vh; }\n  #canvasPane { flex:1; display:flex; align-items:stretch; padding:12px; }\n  #canvas { background: linear-gradient(180deg,#ffffff,#eef5ff); border:1px solid #d0d7e6; border-radius:8px; box-shadow: 0 6px 20px rgba(20,30,50,0.06); width:100%; height:100%; cursor:default; }\n  #controls { width:360px; border-left:1px solid #e6ecf5; padding:16px; box-sizing:border-box; overflow:auto; background:#fff; }\n  h2 { margin:4px 0 12px 0; font-size:18px; }\n  .btn { display:inline-block; padding:8px 12px; background:#2b7cff; color:white; border-radius:6px; cursor:pointer; margin:4px 4px 8px 0; user-select:none; font-size:13px; }\n  .btn.secondary { background:#5b6b7f; }\n  .btn.warn { background:#ff6b6b; }\n  .row { margin-bottom:10px; }\n  label { font-size:13px; color:#274056; display:block; margin-bottom:6px; }\n  input[type=number], input[type=range], select { width:100%; padding:6px 8px; box-sizing:border-box; border-radius:6px; border:1px solid #d7e0ed; background:#fbfdff; }\n  .small { font-size:12px; color:#5b6b7f; margin-top:6px; }\n  #edgeList { max-height:220px; overflow:auto; border:1px solid #eef3fb; padding:8px; border-radius:6px; background:#fcfeff; }\n  .edgeItem { padding:6px; border-radius:6px; margin-bottom:6px; display:flex; align-items:center; justify-content:space-between; font-size:13px; }\n  .edgeItem.pending { background:#fff; color:#122334; }\n  .edgeItem.current { background: linear-gradient(90deg,#fff7dd,#fff); border:1px solid #ffecb5; }\n  .edgeItem.selected { background:#e6fff0; color:#0b4f2e; }\n  .edgeItem.rejected { background:#fff3f3; color:#6f1e1e; }\n  .statusDot { width:10px; height:10px; border-radius:50%; margin-right:8px; display:inline-block; vertical-align:middle; }\n  .dot-pending { background:#ccc; }\n  .dot-current { background:#ffb74d; }\n  .dot-selected { background:#22c55e; }\n  .dot-rejected { background:#ff6b6b; }\n  #ufTable { width:100%; border-collapse:collapse; margin-top:6px;}\n  #ufTable td, #ufTable th { border:1px solid #eef3fb; padding:6px; text-align:center; font-size:13px; }\n  .footer { margin-top:12px; font-size:13px; color:#334a61; }\n  .controls-row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n  .hint { font-size:12px; color:#4b5966; margin-top:8px; }\n  .smallBtn { padding:6px 8px; font-size:12px; border-radius:6px; background:#edf4ff; color:#1f59a0; cursor:pointer; border:1px solid #d7eafc; }\n  .weightBadge { background:#fff; border-radius:6px; padding:4px 8px; border:1px solid #e6eefc; font-weight:600; color:#1b2b3a; min-width:36px; text-align:center; }\n  .topRow { display:flex; justify-content:space-between; align-items:center; gap:8px; }\n  .tight { margin:4px 0; }\n  .muted { color:#557085; font-size:12px; }\n</style>\n</head>\n<body>\n<div id=\"app\">\n  <div id=\"canvasPane\">\n    <canvas id=\"canvas\"></canvas>\n  </div>\n  <div id=\"controls\">\n    <div class=\"topRow\">\n      <h2>Kruskal's Algorithm Demo</h2>\n      <div style=\"text-align:right;\" class=\"muted\">Step-by-step MST using Union-Find</div>\n    </div>\n\n    <div class=\"row controls-row\">\n      <div class=\"btn\" id=\"addNodeBtn\">Add Node</div>\n      <div class=\"btn secondary\" id=\"edgeModeBtn\">Edge Mode: OFF</div>\n      <div class=\"btn warn\" id=\"clearBtn\">Clear Graph</div>\n    </div>\n    <div class=\"row\">\n      <label>Random Graph</label>\n      <div style=\"display:flex; gap:8px;\">\n        <input id=\"randN\" type=\"number\" min=\"2\" max=\"20\" value=\"8\" />\n        <input id=\"randDensity\" type=\"range\" min=\"10\" max=\"100\" value=\"40\" />\n      </div>\n      <div style=\"display:flex; gap:8px; margin-top:8px;\">\n        <div class=\"smallBtn\" id=\"genBtn\">Generate</div>\n        <div class=\"smallBtn\" id=\"connectBtn\">Ensure Connected</div>\n      </div>\n      <div class=\"hint\">Density: <span id=\"densityVal\">40</span>%</div>\n    </div>\n\n    <div class=\"row\">\n      <label>Algorithm Controls</label>\n      <div style=\"display:flex; gap:8px; flex-wrap:wrap;\">\n        <div class=\"btn\" id=\"resetAlgoBtn\">Reset Algorithm</div>\n        <div class=\"btn\" id=\"stepBtn\">Step</div>\n        <div class=\"btn secondary\" id=\"runBtn\">Auto Run</div>\n        <div class=\"btn secondary\" id=\"pauseBtn\" style=\"display:none;\">Pause</div>\n      </div>\n      <div class=\"small muted tight\">Click Step to process one edge (sorted by weight). Auto Run animates steps.</div>\n    </div>\n\n    <div class=\"row\">\n      <label>Edges (sorted)</label>\n      <div id=\"edgeList\"></div>\n    </div>\n\n    <div class=\"row\">\n      <label>MST Total Weight</label>\n      <div style=\"display:flex; align-items:center; gap:8px;\">\n        <div class=\"weightBadge\" id=\"mstWeight\">0</div>\n        <div class=\"muted\">edges selected: <span id=\"mstCount\">0</span> / <span id=\"neededEdges\">0</span></div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <label>Union-Find (parents & ranks)</label>\n      <table id=\"ufTable\"><thead><tr><th>Node</th><th>Parent</th><th>Rank</th></tr></thead><tbody id=\"ufBody\"></tbody></table>\n    </div>\n\n    <div class=\"row\">\n      <label>Tips</label>\n      <div class=\"small\">- Click \"Add Node\" and then click canvas to add at mouse. Drag nodes to reposition. <br>- Toggle \"Edge Mode\" then click two nodes to create an edge (you'll be prompted for a weight). <br>- You can also generate random graphs. <br>- Run Kruskal step-by-step to see selection or rejection of edges.</div>\n    </div>\n\n    <div class=\"footer\">\n      Implementation notes: edges colored green=selected (MST), red=rejected (would form cycle), yellow=current; gray=pending.\n    </div>\n  </div>\n</div>\n\n<script>\n// Kruskal's Algorithm Interactive Demo\n// Single-file implementation with canvas visualization\n\n// --- Canvas setup ---\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\nfunction resizeCanvas() {\n  const rect = canvas.getBoundingClientRect();\n  canvas.width = Math.floor(rect.width);\n  canvas.height = Math.floor(rect.height);\n}\nfunction fitCanvas() {\n  // Make canvas fill its container\n  const pane = document.getElementById('canvasPane');\n  const style = getComputedStyle(pane);\n  const pad = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);\n  canvas.style.width = '100%';\n  canvas.style.height = '100%';\n  resizeCanvas();\n}\nwindow.addEventListener('resize', () => { fitCanvas(); draw(); });\nfitCanvas();\n\n// --- Data structures ---\nlet nodes = []; // {id,x,y}\nlet edges = []; // {id,u,v,weight,status} status: pending,current,selected,rejected\nlet nextNodeId = 0;\nlet nextEdgeId = 0;\n\n// Union-Find\nclass UnionFind {\n  constructor(n=0) {\n    this.parent = [];\n    this.rank = [];\n    for (let i=0;i<n;i++){\n      this.parent[i]=i;\n      this.rank[i]=0;\n    }\n  }\n  ensure(n) {\n    while (this.parent.length < n) {\n      const i = this.parent.length;\n      this.parent.push(i);\n      this.rank.push(0);\n    }\n  }\n  find(a) {\n    if (this.parent[a] !== a) {\n      this.parent[a] = this.find(this.parent[a]);\n    }\n    return this.parent[a];\n  }\n  union(a,b) {\n    let ra = this.find(a), rb = this.find(b);\n    if (ra === rb) return false;\n    // union by rank\n    if (this.rank[ra] < this.rank[rb]) {\n      this.parent[ra] = rb;\n    } else if (this.rank[ra] > this.rank[rb]) {\n      this.parent[rb] = ra;\n    } else {\n      this.parent[rb] = ra;\n      this.rank[ra]++;\n    }\n    return true;\n  }\n}\n\n// Kruskal state\nlet uf = new UnionFind();\nlet sortedEdges = []; // array of edges (references) in sorted order\nlet currentIndex = 0;\nlet autoRunTimer = null;\nlet edgeMode = false;\nlet connectingNode = null;\nlet drag = { nodeId:null, offsetX:0, offsetY:0 };\nlet canvasMousePos = {x:0,y:0};\nlet lastClickAddPosition = {x:80,y:80};\n\n// --- DOM refs ---\nconst addNodeBtn = document.getElementById('addNodeBtn');\nconst edgeModeBtn = document.getElementById('edgeModeBtn');\nconst clearBtn = document.getElementById('clearBtn');\nconst genBtn = document.getElementById('genBtn');\nconst randN = document.getElementById('randN');\nconst randDensity = document.getElementById('randDensity');\nconst densityVal = document.getElementById('densityVal');\nconst connectBtn = document.getElementById('connectBtn');\nconst resetAlgoBtn = document.getElementById('resetAlgoBtn');\nconst stepBtn = document.getElementById('stepBtn');\nconst runBtn = document.getElementById('runBtn');\nconst pauseBtn = document.getElementById('pauseBtn');\nconst edgeListDiv = document.getElementById('edgeList');\nconst mstWeightBadge = document.getElementById('mstWeight');\nconst mstCountSpan = document.getElementById('mstCount');\nconst neededEdgesSpan = document.getElementById('neededEdges');\nconst ufBody = document.getElementById('ufBody');\n\n// --- Utilities ---\nfunction dist(a,b) { return Math.hypot(a.x-b.x,a.y-b.y); }\nfunction findNodeAt(x,y) {\n  for (let i=nodes.length-1;i>=0;i--){\n    const n = nodes[i];\n    if (Math.hypot(n.x-x,n.y-y) <= 18) return n;\n  }\n  return null;\n}\nfunction findEdgeAt(x,y) {\n  for (let e of edges) {\n    const a = nodes[e.u], b = nodes[e.v];\n    if (!a || !b) continue;\n    const midX = (a.x+b.x)/2, midY = (a.y+b.y)/2;\n    if (Math.hypot(midX-x,midY-y) < 14) return e;\n  }\n  return null;\n}\n\n// --- Drawing ---\nfunction draw() {\n  resizeCanvas();\n  ctx.clearRect(0,0,canvas.width,canvas.height);\n\n  // draw edges\n  for (let e of edges) {\n    const a = nodes[e.u], b = nodes[e.v];\n    if (!a || !b) continue;\n    ctx.lineWidth = (e.status==='selected'?4:2);\n    ctx.beginPath();\n    ctx.moveTo(a.x,a.y);\n    ctx.lineTo(b.x,b.y);\n    // color by status\n    let color = '#9aa9bf';\n    if (e.status==='pending') color = '#9aa9bf';\n    if (e.status==='current') color = '#ffb74d';\n    if (e.status==='selected') color = '#22c55e';\n    if (e.status==='rejected') color = '#ff6b6b';\n    ctx.strokeStyle = color;\n    ctx.stroke();\n\n    // weight label\n    const mx = (a.x+b.x)/2, my = (a.y+b.y)/2;\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.fillRect(mx-18,my-12,36,20);\n    ctx.fillStyle = '#223544';\n    ctx.font = '12px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(e.weight), mx, my-2);\n    // small outline\n    ctx.strokeStyle = '#e6eefc';\n    ctx.lineWidth = 1;\n    ctx.strokeRect(mx-18,my-12,36,20);\n  }\n\n  // draw nodes\n  for (let n of nodes) {\n    // circle\n    ctx.beginPath();\n    ctx.fillStyle = '#fff';\n    ctx.strokeStyle = '#2b7cff';\n    ctx.lineWidth = 2;\n    ctx.arc(n.x,n.y,18,0,Math.PI*2);\n    ctx.fill();\n    ctx.stroke();\n    // label\n    ctx.fillStyle = '#122334';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(n.id), n.x, n.y);\n  }\n\n  // if connecting node, highlight it\n  if (edgeMode && connectingNode) {\n    ctx.beginPath();\n    ctx.strokeStyle = '#ffb74d';\n    ctx.lineWidth = 2;\n    ctx.arc(connectingNode.x, connectingNode.y, 22, 0, Math.PI*2);\n    ctx.stroke();\n    // draw rubber line to mouse\n    ctx.beginPath();\n    ctx.moveTo(connectingNode.x, connectingNode.y);\n    ctx.lineTo(canvasMousePos.x, canvasMousePos.y);\n    ctx.setLineDash([6,6]);\n    ctx.strokeStyle = '#ffb74d';\n    ctx.lineWidth = 1.5;\n    ctx.stroke();\n    ctx.setLineDash([]);\n  }\n}\n\n// --- Graph modification functions ---\nfunction addNodeAt(x,y) {\n  const id = nextNodeId++;\n  nodes.push({id:id,x:x,y:y});\n  uf.ensure(nextNodeId);\n  redrawAll();\n  return id;\n}\nfunction addEdge(u,v,weight) {\n  if (u===v) return null;\n  // check duplicates\n  if (edges.some(e => (e.u===u && e.v===v) || (e.u===v && e.v===u))) return null;\n  const id = nextEdgeId++;\n  const edge = {id:id,u:u,v:v,weight:weight, status:'pending'};\n  edges.push(edge);\n  rebuildSortedEdges();\n  redrawAll();\n  return edge;\n}\nfunction clearGraph() {\n  nodes = []; edges = []; nextNodeId = 0; nextEdgeId = 0;\n  uf = new UnionFind();\n  sortedEdges = []; currentIndex = 0;\n  stopAutoRun();\n  redrawAll();\n  updateUI();\n}\nfunction rebuildSortedEdges() {\n  // sort edges by weight ascending, break ties by id for deterministic order\n  sortedEdges = edges.slice().sort((a,b)=> (a.weight - b.weight) || (a.id - b.id));\n  currentIndex = 0;\n  // reset statuses if starting fresh\n  for (let e of edges) if (e.status!=='selected' && e.status!=='rejected') e.status='pending';\n  uf = new UnionFind(nextNodeId);\n  updateUI();\n}\n\n// --- Kruskal steps ---\nfunction resetAlgorithmState() {\n  stopAutoRun();\n  uf = new UnionFind(nextNodeId);\n  currentIndex = 0;\n  for (let e of edges) e.status = 'pending';\n  rebuildSortedEdges();\n  updateUI();\n  redrawAll();\n}\nfunction stepKruskal() {\n  if (currentIndex >= sortedEdges.length) return false;\n  // mark previous current as pending if it was current\n  for (let e of edges) if (e.status==='current') e.status='pending';\n  const edge = sortedEdges[currentIndex];\n  edge.status = 'current';\n  updateUI();\n  redrawAll();\n\n  // process it\n  const u = edge.u, v = edge.v;\n  const ru = uf.find(u), rv = uf.find(v);\n  if (ru !== rv) {\n    uf.union(ru, rv);\n    edge.status = 'selected';\n  } else {\n    edge.status = 'rejected';\n  }\n  currentIndex++;\n  updateUI();\n  redrawAll();\n  return currentIndex <= sortedEdges.length;\n}\nfunction autoRunKruskal(stepDelay=600) {\n  if (autoRunTimer) return;\n  runBtn.style.display = 'none';\n  pauseBtn.style.display = 'inline-block';\n  autoRunTimer = setInterval(()=>{\n    const cont = stepKruskal();\n    if (!cont || currentIndex >= sortedEdges.length) {\n      stopAutoRun();\n    }\n  }, stepDelay);\n}\nfunction stopAutoRun() {\n  if (autoRunTimer) {\n    clearInterval(autoRunTimer);\n    autoRunTimer = null;\n  }\n  runBtn.style.display = 'inline-block';\n  pauseBtn.style.display = 'none';\n  updateUI();\n}\n\n// --- UI updates ---\nfunction updateEdgeListUI() {\n  // show sorted list\n  edgeListDiv.innerHTML = '';\n  for (let i=0;i<sortedEdges.length;i++){\n    const e = sortedEdges[i];\n    const div = document.createElement('div');\n    div.className = 'edgeItem ' + (e.status||'pending');\n    if (e.status==='current') div.classList.add('current');\n    div.title = `Edge ${e.u} - ${e.v}`;\n    const left = document.createElement('div');\n    left.style.display='flex';\n    left.style.alignItems='center';\n    const dot = document.createElement('span');\n    dot.className = 'statusDot ' + (e.status==='selected'?'dot-selected': e.status==='rejected'?'dot-rejected': e.status==='current'?'dot-current':'dot-pending');\n    left.appendChild(dot);\n    const txt = document.createElement('span');\n    txt.textContent = `${e.u} — ${e.v}`;\n    left.appendChild(txt);\n    div.appendChild(left);\n\n    const right = document.createElement('div');\n    right.style.display='flex';\n    right.style.alignItems='center';\n    right.style.gap='8px';\n    const weight = document.createElement('div');\n    weight.className = 'weightBadge';\n    weight.textContent = e.weight;\n    right.appendChild(weight);\n    const btn = document.createElement('div');\n    btn.className='smallBtn';\n    btn.textContent='Edit';\n    btn.onclick = (ev)=>{\n      ev.stopPropagation();\n      const w = prompt('Edge weight (integer):', String(e.weight));\n      if (w !== null) {\n        const val = parseInt(w);\n        if (!isNaN(val)) {\n          e.weight = val;\n          rebuildSortedEdges();\n          updateUI();\n          draw();\n        } else alert('Enter a number.');\n      }\n    };\n    right.appendChild(btn);\n    div.appendChild(right);\n\n    div.onclick = ()=>{\n      // highlight edge on canvas\n      for (let other of edges) if (other.status==='current') other.status='pending';\n      e.status = (e.status==='current' ? 'pending' : 'current');\n      redrawAll();\n      updateUI();\n    };\n\n    edgeListDiv.appendChild(div);\n  }\n}\nfunction updateUFUI() {\n  ufBody.innerHTML = '';\n  uf.ensure(nextNodeId);\n  for (let i=0;i<nextNodeId;i++){\n    const tr = document.createElement('tr');\n    const td1 = document.createElement('td'); td1.textContent = i;\n    const td2 = document.createElement('td'); td2.textContent = uf.parent[i];\n    const td3 = document.createElement('td'); td3.textContent = uf.rank[i];\n    tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);\n    ufBody.appendChild(tr);\n  }\n}\nfunction updateMSTStats() {\n  const sel = edges.filter(e=>e.status==='selected');\n  const weight = sel.reduce((s,e)=>s+e.weight,0);\n  mstWeightBadge.textContent = String(weight);\n  mstCountSpan.textContent = String(sel.length);\n  neededEdgesSpan.textContent = Math.max(0,nextNodeId-1);\n}\nfunction updateUI() {\n  updateEdgeListUI();\n  updateUFUI();\n  updateMSTStats();\n}\n\n// --- Interaction handlers ---\ncanvas.addEventListener('mousemove', (ev)=>{\n  const r = canvas.getBoundingClientRect();\n  const x = ev.clientX - r.left;\n  const y = ev.clientY - r.top;\n  canvasMousePos.x = x; canvasMousePos.y = y;\n  if (drag.nodeId !== null) {\n    const n = nodes.find(n=>n.id===drag.nodeId);\n    if (n) {\n      n.x = x + drag.offsetX;\n      n.y = y + drag.offsetY;\n      redrawAll();\n      updateUI();\n    }\n  } else {\n    // just update rubberband if connecting\n    if (edgeMode && connectingNode) draw();\n  }\n});\ncanvas.addEventListener('mousedown', (ev)=>{\n  const r = canvas.getBoundingClientRect();\n  const x = ev.clientX - r.left;\n  const y = ev.clientY - r.top;\n  const n = findNodeAt(x,y);\n  if (n) {\n    // start dragging\n    drag.nodeId = n.id;\n    drag.offsetX = n.x - x;\n    drag.offsetY = n.y - y;\n  } else {\n    drag.nodeId = null;\n  }\n});\ncanvas.addEventListener('mouseup', (ev)=>{\n  const r = canvas.getBoundingClientRect();\n  const x = ev.clientX - r.left;\n  const y = ev.clientY - r.top;\n  const n = findNodeAt(x,y);\n\n  if (edgeMode) {\n    if (!connectingNode && n) {\n      connectingNode = n;\n      draw();\n    } else if (connectingNode && n && connectingNode.id !== n.id) {\n      // create edge between connectingNode and n\n      const w = prompt('Enter weight for edge (integer):', String(Math.floor(Math.random()*99)+1));\n      if (w !== null) {\n        const val = parseInt(w);\n        if (!isNaN(val)) {\n          addEdge(connectingNode.id, n.id, val);\n        } else {\n          alert('Invalid weight.');\n        }\n      }\n      connectingNode = null;\n      draw();\n    } else {\n      // clicked elsewhere - cancel\n      connectingNode = null;\n      draw();\n    }\n  } else {\n    // if not edge mode and click empty space and Add Node mode was triggered by last \"Add Node\" press, we place node\n    // For simplicity, Add Node button toggles a 'one-time add' state: next click adds node.\n    if (awaitAddNodeFlag) {\n      addNodeAt(x,y);\n      awaitAddNodeFlag = false;\n      addNodeBtn.textContent = 'Add Node';\n      addNodeBtn.style.background = '';\n    }\n  }\n  drag.nodeId = null;\n  updateUI();\n});\ncanvas.addEventListener('dblclick', (ev)=>{\n  // double click to add node quickly\n  const r = canvas.getBoundingClientRect();\n  const x = ev.clientX - r.left;\n  const y = ev.clientY - r.top;\n  addNodeAt(x,y);\n  updateUI();\n});\ncanvas.addEventListener('click', (ev)=>{\n  // clicking an edge shows edit prompt\n  const r = canvas.getBoundingClientRect();\n  const x = ev.clientX - r.left;\n  const y = ev.clientY - r.top;\n  const e = findEdgeAt(x,y);\n  if (e) {\n    const w = prompt('Modify edge weight (integer):', String(e.weight));\n    if (w !== null) {\n      const val = parseInt(w);\n      if (!isNaN(val)) {\n        e.weight = val;\n        rebuildSortedEdges();\n        updateUI();\n        draw();\n      }\n    }\n  }\n});\n\n// buttons\nlet awaitAddNodeFlag = false;\naddNodeBtn.addEventListener('click', ()=>{\n  // toggles a one-time add: next click on canvas adds node\n  awaitAddNodeFlag = !awaitAddNodeFlag;\n  if (awaitAddNodeFlag) {\n    addNodeBtn.textContent = 'Click on canvas';\n    addNodeBtn.style.background = '#22c55e';\n  } else {\n    addNodeBtn.textContent = 'Add Node';\n    addNodeBtn.style.background = '';\n  }\n});\n\nedgeModeBtn.addEventListener('click', ()=>{\n  edgeMode = !edgeMode;\n  edgeModeBtn.textContent = 'Edge Mode: ' + (edgeMode ? 'ON' : 'OFF');\n  edgeModeBtn.style.background = edgeMode ? '#ffb74d' : '';\n  connectingNode = null;\n  draw();\n});\n\nclearBtn.addEventListener('click', ()=>{\n  if (confirm('Clear entire graph?')) clearGraph();\n});\n\nrandDensity.addEventListener('input', ()=>{\n  densityVal.textContent = randDensity.value;\n});\n\ngenBtn.addEventListener('click', ()=>{\n  const n = parseInt(randN.value) || 6;\n  const density = parseInt(randDensity.value)/100;\n  generateRandomGraph(n, density);\n});\n\nconnectBtn.addEventListener('click', ()=>{\n  ensureConnected();\n});\n\nresetAlgoBtn.addEventListener('click', ()=>{\n  resetAlgorithmState();\n});\n\nstepBtn.addEventListener('click', ()=>{\n  stepKruskal();\n});\n\nrunBtn.addEventListener('click', ()=>{\n  autoRunKruskal(450);\n});\npauseBtn.addEventListener('click', ()=>{\n  stopAutoRun();\n});\n\n// --- Graph generation helpers ---\nfunction generateRandomGraph(n, density) {\n  clearGraph();\n  nextNodeId = 0;\n  // place nodes in circle\n  const cx = canvas.width/2, cy = canvas.height/2;\n  const r = Math.min(canvas.width, canvas.height)/2 - 60;\n  for (let i=0;i<n;i++){\n    const ang = (i/n) * Math.PI*2;\n    const x = cx + Math.cos(ang)* (r*0.7) + (Math.random()*40-20);\n    const y = cy + Math.sin(ang)* (r*0.7) + (Math.random()*40-20);\n    addNodeAt(x,y);\n  }\n  // edges between pairs with probability density\n  for (let i=0;i<n;i++){\n    for (let j=i+1;j<n;j++){\n      if (Math.random() < density) {\n        const w = Math.floor(Math.random()*90)+1;\n        addEdge(nodes[i].id, nodes[j].id, w);\n      }\n    }\n  }\n  rebuildSortedEdges();\n  updateUI();\n  draw();\n}\n\nfunction ensureConnected() {\n  if (nodes.length <= 1) return;\n  // build MST-like connecting edges: connect nodes sequentially to ensure connectivity\n  // Use a simple randomized chain: shuffle nodes and connect successive if not already connected\n  const order = nodes.map(n=>n.id).slice();\n  for (let i=order.length-1;i>0;i--){\n    const j = Math.floor(Math.random()*(i+1));\n    [order[i],order[j]] = [order[j],order[i]];\n  }\n  for (let i=1;i<order.length;i++){\n    const a = order[i-1], b = order[i];\n    if (!edges.some(e => (e.u===a && e.v===b) || (e.u===b && e.v===a))) {\n      addEdge(a,b, Math.floor(Math.random()*40)+1);\n    }\n  }\n  rebuildSortedEdges();\n  updateUI();\n  draw();\n}\n\n// initial sample\ngenerateRandomGraph(6, 0.4);\n\n// --- redraw wrapper ---\nfunction redrawAll() {\n  draw();\n  updateUI();\n}\n\n// initial UI update\nupdateUI();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}