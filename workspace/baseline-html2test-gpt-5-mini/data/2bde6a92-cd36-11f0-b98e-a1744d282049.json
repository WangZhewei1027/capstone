{
  "id": "2bde6a92-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:17:26.131Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Topological Sort — Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  :root{\n    --bg:#0f1724;\n    --panel:#0b1220;\n    --accent:#2dd4bf;\n    --muted:#94a3b8;\n    --danger:#fb7185;\n    --node:#60a5fa;\n    --node-processed:#34d399;\n    --node-zero:#fbbf24;\n    --edge:#cbd5e1;\n    --selected:#a78bfa;\n  }\n  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,\"Helvetica Neue\",Arial;background:linear-gradient(180deg,#071028 0%,#041022 100%);color:#e6eef8}\n  .container{display:flex;gap:16px;padding:18px;box-sizing:border-box;height:100%}\n  .sidebar{width:340px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:14px;box-sizing:border-box;overflow:auto;box-shadow:0 6px 20px rgba(2,6,23,0.6)}\n  h1{font-size:20px;margin:6px 0 12px 0;color:var(--accent)}\n  .controls{display:flex;flex-direction:column;gap:8px}\n  .row{display:flex;gap:8px;align-items:center}\n  button, input[type=\"number\"], select {background:#07142a;border:1px solid rgba(255,255,255,0.04);color:#e6eef8;padding:8px;border-radius:8px}\n  button:hover{opacity:0.95;cursor:pointer}\n  input[type=\"text\"]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}\n  label{font-size:13px;color:var(--muted)}\n  small{color:var(--muted);display:block;margin-top:6px}\n  .canvas-wrap{flex:1;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:10px}\n  svg{width:100%;height:100%;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);overflow:visible}\n  .legend{display:flex;gap:10px;flex-wrap:wrap;font-size:13px;color:var(--muted)}\n  .legend .item{display:flex;gap:6px;align-items:center}\n  .badge{width:14px;height:14px;border-radius:3px}\n  .panel{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-top:8px}\n  .adj-list{font-family:monospace;font-size:13px;color:var(--muted);white-space:pre}\n  .log{font-family:monospace;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;max-height:160px;overflow:auto;color:var(--muted);font-size:13px}\n  .small-btn{padding:6px 8px;border-radius:8px;font-size:13px}\n  .controls .hint{font-size:12px;color:var(--muted);margin-top:4px}\n  .footer{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-top:8px}\n  .order-output{font-weight:600;color:var(--accent);font-family:monospace}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"sidebar\">\n    <h1>Topological Sort — Interactive Demo</h1>\n    <div class=\"controls\">\n      <div>\n        <label>Graph construction</label>\n        <div class=\"row\" style=\"margin-top:8px\">\n          <button id=\"btnAddNode\">Add Node</button>\n          <button id=\"btnEdgeMode\" class=\"small-btn\">Create Edge</button>\n          <button id=\"btnDeleteMode\" class=\"small-btn\">Delete</button>\n        </div>\n        <small>Click on canvas to add nodes. Use Create Edge then click source → target. Delete mode: click node/edge to remove. Drag nodes to reposition.</small>\n      </div>\n\n      <div class=\"panel\">\n        <div class=\"row\">\n          <label style=\"flex:1\">Random DAG generator</label>\n        </div>\n        <div class=\"row\" style=\"margin-top:8px\">\n          <input id=\"randN\" type=\"number\" min=\"1\" max=\"26\" value=\"7\" style=\"width:80px\">\n          <input id=\"randM\" type=\"number\" min=\"0\" max=\"200\" value=\"10\" style=\"width:80px\">\n          <button id=\"btnRandom\" class=\"small-btn\">Generate</button>\n          <button id=\"btnClear\" class=\"small-btn\">Clear</button>\n        </div>\n        <small>Random generator ensures edges point forward by node index if \"DAG guaranteed\" checked.</small>\n        <div class=\"row\" style=\"margin-top:8px\">\n          <label><input id=\"guaranteeDAG\" type=\"checkbox\" checked> DAG guaranteed</label>\n        </div>\n      </div>\n\n      <div style=\"margin-top:8px\">\n        <label>Algorithms</label>\n        <div class=\"row\" style=\"margin-top:8px\">\n          <button id=\"runKahn\">Run Kahn (step)</button>\n          <button id=\"stepKahn\" class=\"small-btn\">Next Step</button>\n          <button id=\"resetKahn\" class=\"small-btn\">Reset Kahn</button>\n        </div>\n        <div class=\"row\" style=\"margin-top:8px\">\n          <button id=\"runDFS\">Run DFS topo (animate)</button>\n          <button id=\"stopDFS\" class=\"small-btn\">Stop</button>\n        </div>\n        <small class=\"hint\">Kahn's algorithm is iterative and uses in-degree / zero queue. DFS-based uses post-order (finish times).</small>\n      </div>\n\n      <div class=\"panel\" style=\"margin-top:8px\">\n        <label>State</label>\n        <div style=\"margin-top:8px\">\n          <div>In-degrees: <span id=\"degrees\" class=\"order-output\">—</span></div>\n          <div style=\"margin-top:6px\">Kahn queue: <span id=\"kahnQueue\" class=\"order-output\">[]</span></div>\n          <div style=\"margin-top:6px\">Topological order: <span id=\"topoOrder\" class=\"order-output\">[]</span></div>\n        </div>\n      </div>\n\n      <div class=\"panel\">\n        <label>Adjacency</label>\n        <div class=\"adj-list\" id=\"adjList\">[]</div>\n      </div>\n\n      <div class=\"panel\">\n        <label>Execution Log</label>\n        <div class=\"log\" id=\"log\"></div>\n      </div>\n\n      <div class=\"footer\">\n        <div class=\"legend\">\n          <div class=\"item\"><div class=\"badge\" style=\"background:var(--node)\"></div><div>Unvisited</div></div>\n          <div class=\"item\"><div class=\"badge\" style=\"background:var(--node-zero)\"></div><div>Zero indegree</div></div>\n          <div class=\"item\"><div class=\"badge\" style=\"background:var(--node-processed)\"></div><div>Processed</div></div>\n          <div class=\"item\"><div class=\"badge\" style=\"background:var(--danger)\"></div><div>Cycle / Back edge</div></div>\n        </div>\n      </div>\n\n    </div>\n  </div>\n\n  <div class=\"canvas-wrap\">\n    <svg id=\"svgCanvas\" viewBox=\"0 0 1000 700\" preserveAspectRatio=\"xMidYMid meet\">\n      <defs>\n        <marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\" markerUnits=\"strokeWidth\" markerWidth=\"8\" markerHeight=\"8\" orient=\"auto\">\n          <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"var(--edge)\"></path>\n        </marker>\n        <marker id=\"arrow-red\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\" markerUnits=\"strokeWidth\" markerWidth=\"8\" markerHeight=\"8\" orient=\"auto\">\n          <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"var(--danger)\"></path>\n        </marker>\n      </defs>\n      <!-- edges and nodes will be drawn here -->\n    </svg>\n    <small style=\"color:var(--muted)\">Canvas: click to add nodes; drag nodes; use modes for edges/deleting. Nodes are labeled A, B, C ...</small>\n  </div>\n</div>\n\n<script>\n/* Topological Sort interactive demo\n   - Build directed graph by clicking or generating random graphs\n   - Create edges by selecting source then target\n   - Run Kahn's algorithm step-by-step\n   - Run DFS-based topological sort with animation\n   - Detect cycles and display them\n*/\n\nconst svg = document.getElementById('svgCanvas');\nconst NS = \"http://www.w3.org/2000/svg\";\nlet nodes = []; // {id:int,label:str,x,y}\nlet edges = []; // {from:int,to:int,svgElement,svgPath}\n// mapping from id to indegree etc computed as needed\nlet nextId = 0;\n\nlet mode = 'none'; // 'addEdge' or 'delete' or 'none'\nlet edgeSource = null;\nlet selectedElement = null;\nlet dragging = null;\nlet dragOffset = {x:0,y:0};\n\n// Kahn state\nlet kahnState = null; // {inDeg:Map,idToNode,result:[],queue:[],processed:Set,stepLog:[]}\nlet dfsTimer = null;\nlet dfsEvents = [];\n\n// UI elements\nconst btnAddNode = document.getElementById('btnAddNode');\nconst btnEdgeMode = document.getElementById('btnEdgeMode');\nconst btnDeleteMode = document.getElementById('btnDeleteMode');\nconst btnRandom = document.getElementById('btnRandom');\nconst btnClear = document.getElementById('btnClear');\nconst randN = document.getElementById('randN');\nconst randM = document.getElementById('randM');\nconst guaranteeDAG = document.getElementById('guaranteeDAG');\n\nconst runKahn = document.getElementById('runKahn');\nconst stepKahn = document.getElementById('stepKahn');\nconst resetKahn = document.getElementById('resetKahn');\nconst runDFS = document.getElementById('runDFS');\nconst stopDFS = document.getElementById('stopDFS');\n\nconst degreesEl = document.getElementById('degrees');\nconst kahnQueueEl = document.getElementById('kahnQueue');\nconst topoOrderEl = document.getElementById('topoOrder');\nconst adjListEl = document.getElementById('adjList');\nconst logEl = document.getElementById('log');\n\n// helper: create svg elements\nfunction svgElem(name, attrs={}) {\n  const el = document.createElementNS(NS,name);\n  for (let k in attrs) el.setAttribute(k, attrs[k]);\n  return el;\n}\n\nfunction log(msg){\n  const time = new Date().toLocaleTimeString();\n  logEl.textContent = `[${time}] ${msg}\\n` + logEl.textContent;\n}\n\n// Graph operations\nfunction addNodeAt(x,y){\n  const id = nextId++;\n  const label = String.fromCharCode(65 + (id % 26)) + (Math.floor(id/26) || '');\n  const node = {id,label,x,y};\n  nodes.push(node);\n  drawGraph();\n  return node;\n}\n\nfunction removeNode(id){\n  nodes = nodes.filter(n=>n.id!==id);\n  edges = edges.filter(e=>{\n    if (e.from===id || e.to===id){\n      if (e.svgPath) e.svgPath.remove();\n      return false;\n    }\n    return true;\n  });\n  drawGraph();\n}\n\nfunction addEdge(from,to){\n  // prevent duplicate\n  if (edges.some(e=>e.from===from && e.to===to)) return;\n  edges.push({from,to});\n  drawGraph();\n}\n\nfunction removeEdge(from,to){\n  edges = edges.filter(e=> !(e.from===from && e.to===to));\n  drawGraph();\n}\n\nfunction clearGraph(){\n  nodes = []; edges = []; nextId = 0;\n  drawGraph();\n  resetKahnState();\n  stopDFSAnimation();\n  logEl.textContent = '';\n}\n\nfunction randomGraph(n,m,dag=true){\n  clearGraph();\n  // create nodes arranged in circle\n  const cx = 500, cy = 350, r = Math.min(280, 40*n);\n  for (let i=0;i<n;i++){\n    const angle = (i / n) * Math.PI*2;\n    addNodeAt(cx + r*Math.cos(angle), cy + r*Math.sin(angle));\n  }\n  const ids = nodes.map(n=>n.id);\n  let attempts=0;\n  while (edges.length < m && attempts < m*8){\n    attempts++;\n    if (dag){\n      // ensure edges go from lower to higher index to avoid cycles\n      const i = Math.floor(Math.random()*(n-1));\n      const j = i+1 + Math.floor(Math.random()*(n-1-i+1));\n      addEdge(ids[i], ids[j]);\n    } else {\n      const a = ids[Math.floor(Math.random()*n)];\n      const b = ids[Math.floor(Math.random()*n)];\n      if (a!==b) addEdge(a,b);\n    }\n  }\n  drawGraph();\n}\n\nfunction adjacencyList(){\n  const adj = {};\n  nodes.forEach(n=>adj[n.id]=[]);\n  edges.forEach(e=>adj[e.from].push(e.to));\n  return adj;\n}\n\nfunction drawGraph(){\n  // clear svg children except defs\n  [...svg.children].forEach(ch=>{\n    if (ch.tagName.toLowerCase() === 'defs') return;\n    ch.remove();\n  });\n\n  // draw edges first (so they are below nodes)\n  const idToNode = Object.fromEntries(nodes.map(n=>[n.id,n]));\n  edges.forEach((e,idx)=>{\n    const a = idToNode[e.from];\n    const b = idToNode[e.to];\n    if (!a || !b) return;\n    // compute path with slight curvature to avoid overlapping\n    const dx = b.x - a.x, dy = b.y - a.y;\n    const dist = Math.hypot(dx,dy);\n    const normX = dx/dist, normY = dy/dist;\n    const startX = a.x + normX*20, startY = a.y + normY*20;\n    const endX = b.x - normX*20, endY = b.y - normY*20;\n    const mx = (startX + endX)/2, my = (startY + endY)/2;\n    // perpendicular offset for curve\n    const px = -normY*(10 + ( ( (e.from + e.to) % 3) * 6 ));\n    const py = normX*(10 + ( ( (e.from + e.to) % 3) * 6 ));\n    const path = svgElem('path',{d:`M ${startX} ${startY} Q ${mx+px} ${my+py} ${endX} ${endY}`, stroke: 'var(--edge)', 'stroke-width':2, fill:'none', 'marker-end':'url(#arrow)', 'data-from':e.from, 'data-to':e.to});\n    path.style.transition = 'stroke 160ms, opacity 120ms';\n    path.addEventListener('click', (ev)=>{\n      ev.stopPropagation();\n      if (mode==='delete'){\n        removeEdge(e.from,e.to);\n        log(`Edge removed: ${labelFor(e.from)} → ${labelFor(e.to)}`);\n      }\n    });\n    svg.appendChild(path);\n    e.svgPath = path;\n  });\n\n  // draw nodes\n  nodes.forEach(n=>{\n    const g = svgElem('g',{cursor:'pointer', 'data-id':n.id});\n    const circle = svgElem('circle',{cx:n.x, cy:n.y, r:20, fill:'var(--node)', stroke:'rgba(255,255,255,0.04)', 'stroke-width':1});\n    circle.style.transition = 'fill 160ms, transform 120ms';\n    const text = svgElem('text',{x:n.x, y:n.y+5, 'text-anchor':'middle', 'font-size':14, fill:'#072033', 'font-weight':700});\n    text.textContent = n.label;\n    g.appendChild(circle);\n    g.appendChild(text);\n    svg.appendChild(g);\n\n    // events\n    g.addEventListener('mousedown', (ev)=>{\n      ev.stopPropagation();\n      if (mode==='delete'){\n        removeNode(n.id);\n        log(`Node ${n.label} removed`);\n        return;\n      }\n      if (mode==='addEdge'){\n        if (edgeSource==null){\n          edgeSource = n.id;\n          highlightNode(n.id,true);\n        } else {\n          const from = edgeSource, to = n.id;\n          edgeSource = null;\n          highlightAllNodes(false);\n          if (from===to){\n            log('No self-loops allowed.');\n          } else {\n            addEdge(from,to);\n            log(`Edge added: ${labelFor(from)} → ${labelFor(to)}`);\n          }\n        }\n        return;\n      }\n      // otherwise start dragging\n      dragging = n.id;\n      const pt = svg.createSVGPoint();\n      pt.x = ev.clientX; pt.y = ev.clientY;\n      const ctm = svg.getScreenCTM();\n      const loc = pt.matrixTransform(ctm.inverse());\n      dragOffset.x = loc.x - n.x;\n      dragOffset.y = loc.y - n.y;\n    });\n\n    g.addEventListener('dblclick', (ev)=>{\n      ev.stopPropagation();\n      // double-click to select for quick-edge creation (alternate behavior)\n      if (edgeSource==null){\n        edgeSource = n.id;\n        highlightNode(n.id,true);\n        log(`Selected ${n.label} as source`);\n      } else {\n        addEdge(edgeSource, n.id);\n        log(`Edge added: ${labelFor(edgeSource)} → ${n.label}`);\n        edgeSource = null;\n        highlightAllNodes(false);\n      }\n    });\n  });\n\n  updateAdjacencyView();\n  updateKahnDisplay();\n}\n\nfunction labelFor(id){\n  const n = nodes.find(x=>x.id===id);\n  return n ? n.label : '?';\n}\n\nfunction highlightNode(id, on=true, color=null){\n  const g = svg.querySelector(`g[data-id=\"${id}\"]`);\n  if (!g) return;\n  const circle = g.querySelector('circle');\n  if (on){\n    circle.setAttribute('fill', color || 'var(--selected)');\n    circle.setAttribute('transform','scale(1.08)');\n  } else {\n    circle.setAttribute('fill','var(--node)');\n    circle.setAttribute('transform','scale(1)');\n  }\n}\n\nfunction highlightAllNodes(on=false){\n  nodes.forEach(n=>highlightNode(n.id,on,false));\n}\n\n// mouse move and up for dragging\nwindow.addEventListener('mousemove', (ev)=>{\n  if (dragging==null) return;\n  const pt = svg.createSVGPoint();\n  pt.x = ev.clientX; pt.y = ev.clientY;\n  const ctm = svg.getScreenCTM();\n  const loc = pt.matrixTransform(ctm.inverse());\n  const n = nodes.find(x=>x.id===dragging);\n  n.x = loc.x - dragOffset.x;\n  n.y = loc.y - dragOffset.y;\n  drawGraph();\n});\n\nwindow.addEventListener('mouseup',(ev)=>{\n  dragging = null;\n});\n\n// canvas click to place nodes\nsvg.addEventListener('click',(ev)=>{\n  // compute coordinates\n  const pt = svg.createSVGPoint();\n  pt.x = ev.clientX; pt.y = ev.clientY;\n  const ctm = svg.getScreenCTM();\n  const loc = pt.matrixTransform(ctm.inverse());\n  if (mode==='none'){\n    addNodeAt(loc.x, loc.y);\n    const n = nodes[nodes.length-1];\n    log(`Node ${n.label} added`);\n  } else if (mode==='addEdge'){\n    // clicked empty area: cancel selection\n    if (edgeSource!=null){\n      edgeSource = null;\n      highlightAllNodes(false);\n    }\n  } else if (mode==='delete'){\n    // clicking empty area clears selection\n  }\n});\n\n// UI wiring\nbtnAddNode.addEventListener('click', ()=>{ mode='none'; edgeSource=null; btnEdgeMode.style.background=''; btnDeleteMode.style.background=''; log('Add-node mode: click canvas'); });\nbtnEdgeMode.addEventListener('click', ()=>{\n  mode = (mode==='addEdge' ? 'none' : 'addEdge');\n  btnEdgeMode.style.background = mode==='addEdge' ? 'rgba(167,139,250,0.15)' : '';\n  btnDeleteMode.style.background = '';\n  if (mode!=='addEdge') { edgeSource=null; highlightAllNodes(false); }\n});\nbtnDeleteMode.addEventListener('click', ()=>{\n  mode = (mode==='delete' ? 'none' : 'delete');\n  btnDeleteMode.style.background = mode==='delete' ? 'rgba(251,113,133,0.08)' : '';\n  btnEdgeMode.style.background = '';\n  edgeSource = null;\n  highlightAllNodes(false);\n});\n\nbtnRandom.addEventListener('click', ()=>{\n  const n = Math.max(1,Math.min(26,parseInt(randN.value)||5));\n  const m = Math.max(0,parseInt(randM.value)||0);\n  randomGraph(n,m, guaranteeDAG.checked);\n  log(`Random graph: n=${n}, m=${m}, DAG_guaranteed=${guaranteeDAG.checked}`);\n});\n\nbtnClear.addEventListener('click', ()=>{ clearGraph(); log('Graph cleared'); });\n\n// adjacency and state display\nfunction updateAdjacencyView(){\n  const adj = adjacencyList();\n  const lines = nodes.map(n=> `${n.label} (${n.id}) -> [${adj[n.id].map(id=>labelFor(id)).join(', ')}]`);\n  adjListEl.textContent = lines.join('\\n');\n}\n\n// Kahn's algorithm implementation\nfunction computeInDegrees(){\n  const inDeg = new Map();\n  nodes.forEach(n=>inDeg.set(n.id,0));\n  edges.forEach(e=>{\n    inDeg.set(e.to, (inDeg.get(e.to)||0)+1);\n  });\n  return inDeg;\n}\n\nfunction resetKahnState(){\n  kahnState = null;\n  updateKahnDisplay();\n}\n\nrunKahn.addEventListener('click', ()=>{\n  if (nodes.length===0){ alert('Add nodes to graph first.'); return; }\n  // initialize\n  const inDeg = computeInDegrees();\n  const queue = [];\n  for (let [id,d] of inDeg.entries()) if (d===0) queue.push(id);\n  kahnState = {\n    inDeg, queue: queue.slice(), result: [], processed: new Set()\n  };\n  log(`Kahn initialized. Zero-indegree nodes: [${queue.map(id=>labelFor(id)).join(', ')}]`);\n  updateKahnDisplay();\n});\n\nstepKahn.addEventListener('click', ()=>{\n  if (!kahnState){ alert('Initialize Kahn first (Run Kahn).'); return; }\n  const state = kahnState;\n  if (state.queue.length===0){\n    if (state.result.length === nodes.length){\n      log('Kahn finished successfully — topological order found.');\n      topoOrderEl.textContent = state.result.map(id=>labelFor(id)).join(', ');\n      highlightOrder(state.result);\n      updateKahnDisplay();\n      return;\n    } else {\n      // cycle detected\n      const remaining = nodes.filter(n=>!state.processed.has(n.id)).map(n=>n.id);\n      log('Cycle detected! Remaining nodes: ' + remaining.map(id=>labelFor(id)).join(', '));\n      // highlight remaining nodes in red\n      remaining.forEach(id=>{\n        const g = svg.querySelector(`g[data-id=\"${id}\"]`);\n        if (g) g.querySelector('circle').setAttribute('fill','var(--danger)');\n      });\n      updateKahnDisplay();\n      return;\n    }\n  }\n  // pop node\n  const id = state.queue.shift();\n  state.result.push(id);\n  state.processed.add(id);\n  log(`Kahn: process ${labelFor(id)}`);\n  // highlight processed\n  const g = svg.querySelector(`g[data-id=\"${id}\"]`);\n  if (g) g.querySelector('circle').setAttribute('fill','var(--node-processed)');\n  // decrement neighbors\n  const adj = adjacencyList();\n  for (let nb of adj[id]){\n    const old = state.inDeg.get(nb);\n    state.inDeg.set(nb, old-1);\n    log(`  decrease in-degree of ${labelFor(nb)}: ${old} → ${old-1}`);\n    if (old-1===0){\n      state.queue.push(nb);\n      log(`  ${labelFor(nb)} enters zero-queue`);\n      // color zero indegree nodes\n      const g2 = svg.querySelector(`g[data-id=\"${nb}\"]`);\n      if (g2) g2.querySelector('circle').setAttribute('fill','var(--node-zero)');\n    }\n  }\n  updateKahnDisplay();\n});\n\nresetKahn.addEventListener('click', ()=>{\n  resetKahnState();\n  // reset node colors\n  nodes.forEach(n=>{\n    const g = svg.querySelector(`g[data-id=\"${n.id}\"]`);\n    if (g) g.querySelector('circle').setAttribute('fill','var(--node)');\n  });\n  log('Kahn state reset.');\n});\n\nfunction updateKahnDisplay(){\n  if (!kahnState){\n    degreesEl.textContent = '—';\n    kahnQueueEl.textContent = '[]';\n    topoOrderEl.textContent = '[]';\n    return;\n  }\n  const degs = [...kahnState.inDeg.entries()].map(([id,d])=> `${labelFor(id)}:${d}`).join(', ');\n  degreesEl.textContent = degs;\n  kahnQueueEl.textContent = '[' + kahnState.queue.map(id=>labelFor(id)).join(', ') + ']';\n  topoOrderEl.textContent = '[' + kahnState.result.map(id=>labelFor(id)).join(', ') + ']';\n}\n\n/* DFS-based topological sort with animation.\n   We'll generate an event list describing node enter/explore/exit, then animate.\n*/\nrunDFS.addEventListener('click', ()=>{\n  stopDFSAnimation();\n  if (nodes.length===0){ alert('Add nodes to graph first.'); return; }\n  // build adjacency\n  const adj = adjacencyList();\n  const color = {}; // 0 white, 1 gray, 2 black\n  nodes.forEach(n=>color[n.id]=0);\n  dfsEvents = []; // {type:'enter'|'exit'|'backedge', id, to?}\n  let cycle = false;\n\n  function dfs(u){\n    color[u]=1;\n    dfsEvents.push({type:'enter', id:u});\n    for (let v of adj[u]){\n      if (color[v]===0){\n        dfsEvents.push({type:'tree','from':u,'to':v});\n        dfsEvents.push({type:'descend', id:v});\n        dfsEvents.push({type:'message', text:`Explore ${labelFor(u)} → ${labelFor(v)}`} );\n        dfsEvents.push({type:'call', id:v});\n        dfsEvents.push({type:'noop'}); // spacer\n        dfs(u);\n      } else if (color[v]===1){\n        // back edge -> cycle\n        cycle = true;\n        dfsEvents.push({type:'backedge','from':u,'to':v});\n      } else {\n        dfsEvents.push({type:'cross','from':u,'to':v});\n      }\n    }\n    color[u]=2;\n    dfsEvents.push({type:'exit', id:u});\n  }\n\n  // run DFS and create events\n  for (let n of nodes){\n    if (color[n.id]===0) {\n      dfsEvents.push({type:'start', id:n.id});\n      dfs(n.id);\n    }\n  }\n\n  // Now animate events (one every 450ms)\n  let idx = 0;\n  log('DFS events queued: ' + dfsEvents.length);\n  dfsTimer = setInterval(()=>{\n    if (idx>=dfsEvents.length){\n      stopDFSAnimation();\n      // after finishing, compute final order via reverse of exit times: run actual DFS topo to get order\n      const order = computeDFSTopoOrder();\n      if (order==null){\n        log('DFS detected a cycle — no topological order.');\n      } else {\n        log('DFS finished. Topological order (by finish times): ' + order.map(id=>labelFor(id)).join(', '));\n        topoOrderEl.textContent = order.map(id=>labelFor(id)).join(', ');\n        highlightOrder(order);\n      }\n      return;\n    }\n    const ev = dfsEvents[idx++];\n    handleDFSEvent(ev);\n  }, 450);\n});\n\nstopDFS.addEventListener('click', ()=> stopDFSAnimation());\n\nfunction stopDFSAnimation(){\n  if (dfsTimer) clearInterval(dfsTimer);\n  dfsTimer = null;\n  // reset all node colors\n  nodes.forEach(n=>{\n    const g = svg.querySelector(`g[data-id=\"${n.id}\"]`);\n    if (g) g.querySelector('circle').setAttribute('fill','var(--node)');\n  });\n  log('DFS animation stopped/reset.');\n}\n\n// handle single dfs event for visualization\nfunction handleDFSEvent(ev){\n  switch(ev.type){\n    case 'enter':\n      {\n        const g = svg.querySelector(`g[data-id=\"${ev.id}\"]`);\n        if (g) g.querySelector('circle').setAttribute('fill','var(--selected)');\n        log(`DFS: enter ${labelFor(ev.id)}`);\n      }\n      break;\n    case 'exit':\n      {\n        const g = svg.querySelector(`g[data-id=\"${ev.id}\"]`);\n        if (g) g.querySelector('circle').setAttribute('fill','var(--node-processed)');\n        log(`DFS: exit ${labelFor(ev.id)}`);\n      }\n      break;\n    case 'backedge':\n      {\n        const path = svg.querySelector(`path[data-from=\"${ev.from}\"][data-to=\"${ev.to}\"]`);\n        if (path) { path.setAttribute('stroke','var(--danger)'); path.setAttribute('marker-end','url(#arrow-red)'); }\n        const g = svg.querySelector(`g[data-id=\"${ev.to}\"]`);\n        if (g) g.querySelector('circle').setAttribute('fill','var(--danger)');\n        log(`DFS: back edge detected (cycle): ${labelFor(ev.from)} → ${labelFor(ev.to)}`);\n      }\n      break;\n    case 'tree':\n      log(`DFS: tree edge ${labelFor(ev.from)} → ${labelFor(ev.to)}`);\n      break;\n    case 'cross':\n      log(`DFS: cross edge ${labelFor(ev.from)} → ${labelFor(ev.to)}`);\n      break;\n    case 'message':\n      log(ev.text);\n      break;\n    default:\n      // ignore noop/start/descend/call etc.\n      break;\n  }\n}\n\n// compute topological order via DFS (postorder) — returns array or null if cycle\nfunction computeDFSTopoOrder(){\n  const adj = adjacencyList();\n  const color = {}; nodes.forEach(n=>color[n.id]=0);\n  const order = [];\n  let cycle = false;\n  function dfs(u){\n    color[u]=1;\n    for (let v of adj[u]){\n      if (color[v]===0) dfs(v);\n      else if (color[v]===1) cycle = true;\n    }\n    color[u]=2;\n    order.push(u);\n  }\n  for (let n of nodes){\n    if (color[n.id]===0) dfs(n.id);\n  }\n  if (cycle) return null;\n  return order.reverse();\n}\n\n// highlight final order visually (small delay between highlights)\nfunction highlightOrder(order){\n  // reset first\n  nodes.forEach(n=>{\n    const g = svg.querySelector(`g[data-id=\"${n.id}\"]`);\n    if (g) g.querySelector('circle').setAttribute('fill','var(--node)');\n  });\n  let i=0;\n  const timer = setInterval(()=>{\n    if (i>=order.length){ clearInterval(timer); return; }\n    const id = order[i++];\n    const g = svg.querySelector(`g[data-id=\"${id}\"]`);\n    if (g) g.querySelector('circle').setAttribute('fill','var(--node-processed)');\n  }, 220);\n}\n\n// initialization\ndrawGraph();\nlog('Interactive Topological Sort demo ready. Helpful tips: generate a DAG first or add nodes then create edges.');\n\n/* Extra: allow keyboard shortcuts */\nwindow.addEventListener('keydown',(ev)=>{\n  if (ev.key === 'e'){ mode='addEdge'; btnEdgeMode.style.background='rgba(167,139,250,0.15)'; btnDeleteMode.style.background=''; log('Edge mode (shortcut e)'); }\n  if (ev.key === 'd'){ mode='delete'; btnDeleteMode.style.background='rgba(251,113,133,0.08)'; btnEdgeMode.style.background=''; log('Delete mode (shortcut d)'); }\n  if (ev.key === 'n'){ mode='none'; btnEdgeMode.style.background=''; btnDeleteMode.style.background=''; log('Add-node mode (shortcut n)'); }\n});\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": false,
  "hasTest": true
}