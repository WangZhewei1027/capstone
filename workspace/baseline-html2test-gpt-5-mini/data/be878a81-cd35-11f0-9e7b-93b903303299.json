{
  "id": "be878a81-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:42.248Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<title>Adjacency Matrix Visualizer</title>\n<style>\n  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial; font-size:14px;}\n  body{margin:16px; color:#111;}\n  h1{margin:0 0 8px 0; font-size:20px;}\n  .top{display:flex; gap:12px; align-items:center; flex-wrap:wrap;}\n  label{display:inline-flex; gap:6px; align-items:center;}\n  input[type=\"number\"]{width:64px;}\n  .container{display:flex; gap:16px; margin-top:12px; align-items:flex-start;}\n  .left{min-width:320px; max-width:520px;}\n  .controls{display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px;}\n  button{padding:6px 10px; border:1px solid #bbb; background:#f6f6f6; cursor:pointer; border-radius:6px;}\n  button:hover{background:#eee;}\n  .matrix-wrapper{overflow:auto; max-height:520px; border:1px solid #e0e0e0; padding:8px; border-radius:8px; background:#fff;}\n  table.matrix{border-collapse:collapse; font-size:13px;}\n  table.matrix th, table.matrix td{border:1px solid #e6e6e6; padding:6px; text-align:center; min-width:34px; height:34px;}\n  table.matrix th{background:#fafafa; font-weight:600; position:sticky; top:0; z-index:2;}\n  table.matrix th:first-child{left:0; z-index:3; position:sticky;}\n  td.cell{cursor:pointer; user-select:none;}\n  td.cell.on{background:linear-gradient(180deg,#dff3ff,#bfe8ff);}\n  td.cell.off{background:#fff;}\n  td.cell.selfloop{background:linear-gradient(180deg,#fff3d9,#ffe2b3);}\n  input.weight{width:56px; padding:4px; box-sizing:border-box; text-align:center;}\n  .right{flex:1; min-width:420px;}\n  .canvas-box{width:100%; height:520px; border:1px solid #e0e0e0; border-radius:8px; background:#fff; display:flex; align-items:stretch; position:relative; overflow:hidden;}\n  svg{width:100%; height:100%; display:block; background:linear-gradient(180deg,#ffffff,#fbfbff);}\n  .legend{font-size:12px; margin-top:8px; color:#444;}\n  .adjlist{margin-top:12px; font-family:monospace; white-space:pre; background:#fafafa; padding:8px; border-radius:6px; border:1px dashed #eee; max-height:220px; overflow:auto;}\n  .small{font-size:12px; color:#555;}\n  .importexport{display:flex; gap:8px; align-items:center; margin-left:auto;}\n  textarea#importArea{width:100%; height:80px; box-sizing:border-box; font-family:monospace; font-size:12px; margin-top:8px; padding:6px;}\n  .footer{margin-top:12px; font-size:12px; color:#666;}\n  .node-label{font-size:12px; pointer-events:none;}\n  .btn-danger{background:#ffeceb; border-color:#ffbdb8;}\n</style>\n</head>\n<body>\n<h1>Adjacency Matrix Visualizer</h1>\n<div class=\"top\">\n  <div class=\"small\">Explore graphs by editing the adjacency matrix. Click cells to toggle edges (or enter weights).</div>\n  <div class=\"importexport\">\n    <button id=\"exportBtn\" title=\"Export graph (JSON)\">Export JSON</button>\n    <button id=\"copyBtn\" title=\"Copy JSON to clipboard\">Copy JSON</button>\n  </div>\n</div>\n\n<div class=\"container\">\n  <div class=\"left\">\n    <div class=\"controls\">\n      <label># nodes: <input type=\"number\" id=\"nodeCount\" min=\"1\" max=\"40\" value=\"6\"></label>\n      <label><input type=\"checkbox\" id=\"directed\"> Directed</label>\n      <label><input type=\"checkbox\" id=\"weighted\"> Weighted</label>\n      <label><input type=\"checkbox\" id=\"allowSelf\" checked> Allow self-loops</label>\n      <button id=\"resizeBtn\">Resize</button>\n      <button id=\"randomBtn\">Randomize</button>\n      <button id=\"clearBtn\">Clear</button>\n      <button id=\"symBtn\" title=\"Enforce symmetry for undirected\">Enforce Symmetry</button>\n    </div>\n\n    <div class=\"matrix-wrapper\" id=\"matrixWrap\" aria-label=\"Adjacency matrix\">\n      <table class=\"matrix\" id=\"matrixTable\"></table>\n    </div>\n\n    <div style=\"display:flex; gap:8px; margin-top:8px;\">\n      <button id=\"importBtn\">Import JSON</button>\n      <button id=\"fromAdjListBtn\">From Adjacency List</button>\n    </div>\n\n    <textarea id=\"importArea\" placeholder='Paste exported JSON here or an adjacency list like:\n0: 1 2\n1: 2\n'> </textarea>\n\n    <div class=\"adjlist\" id=\"adjList\"></div>\n  </div>\n\n  <div class=\"right\">\n    <div class=\"canvas-box\" id=\"canvasBox\">\n      <svg id=\"svg\"></svg>\n    </div>\n    <div class=\"legend\">\n      <span style=\"display:inline-block;width:12px;height:12px;background:#bfe8ff;border-radius:2px;margin-right:6px;vertical-align:middle;\"></span> Edge present (unweighted) &nbsp;&nbsp;\n      <span style=\"display:inline-block;width:12px;height:12px;background:#ffe2b3;border-radius:2px;margin-right:6px;vertical-align:middle;\"></span> Self-loop\n    </div>\n  </div>\n</div>\n\n<div class=\"footer\">Tip: Toggle \"Weighted\" to enter numbers in matrix cells. For undirected graphs, toggle \"Enforce Symmetry\" to keep matrix symmetric when editing.</div>\n\n<script>\n(function(){\n  // State\n  let n = 6;\n  let directed = false;\n  let weighted = false;\n  let allowSelf = true;\n  let enforceSymmetry = false;\n  const maxNodes = 40;\n\n  // adjacency matrix as numbers: 0 means no edge. Weighted graphs can have any numeric weight. For unweighted use 1 for edge.\n  let A = [];\n\n  // Node positions for drawing\n  let nodes = [];\n\n  // DOM\n  const nodeCountInput = document.getElementById('nodeCount');\n  const directedCb = document.getElementById('directed');\n  const weightedCb = document.getElementById('weighted');\n  const allowSelfCb = document.getElementById('allowSelf');\n  const resizeBtn = document.getElementById('resizeBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const symBtn = document.getElementById('symBtn');\n  const matrixTable = document.getElementById('matrixTable');\n  const svg = document.getElementById('svg');\n  const adjListDiv = document.getElementById('adjList');\n  const importArea = document.getElementById('importArea');\n  const importBtn = document.getElementById('importBtn');\n  const fromAdjListBtn = document.getElementById('fromAdjListBtn');\n  const exportBtn = document.getElementById('exportBtn');\n  const copyBtn = document.getElementById('copyBtn');\n  const canvasBox = document.getElementById('canvasBox');\n\n  // Initialize\n  function initMatrix(size){\n    n = Math.max(1, Math.min(maxNodes, size));\n    A = new Array(n);\n    for(let i=0;i<n;i++){\n      A[i] = new Array(n).fill(0);\n    }\n    // default simple example: a path\n    for(let i=0;i<n-1;i++){\n      A[i][i+1] = 1;\n      if(!directed) A[i+1][i] = 1;\n    }\n    randomizePositions();\n  }\n\n  function randomizePositions(){\n    nodes = [];\n    const w = canvasBox.clientWidth;\n    const h = canvasBox.clientHeight;\n    const cx = w/2, cy = h/2;\n    const radius = Math.min(w,h)/2 - 60;\n    for(let i=0;i<n;i++){\n      const ang = (i/n)*Math.PI*2;\n      nodes.push({\n        x: cx + Math.cos(ang)*radius,\n        y: cy + Math.sin(ang)*radius,\n        fx: null, fy: null\n      });\n    }\n  }\n\n  function rebuild(){\n    // update controls\n    nodeCountInput.value = n;\n    directedCb.checked = directed;\n    weightedCb.checked = weighted;\n    allowSelfCb.checked = allowSelf;\n    symBtn.style.opacity = enforceSymmetry ? 1 : 0.65;\n    renderMatrix();\n    drawGraph();\n    renderAdjList();\n  }\n\n  function renderMatrix(){\n    // Clear table\n    while(matrixTable.firstChild) matrixTable.removeChild(matrixTable.firstChild);\n\n    // header row\n    const thead = document.createElement('thead');\n    const headerRow = document.createElement('tr');\n    const topLeft = document.createElement('th');\n    topLeft.textContent = '\\\\';\n    headerRow.appendChild(topLeft);\n    for(let j=0;j<n;j++){\n      const th = document.createElement('th');\n      th.textContent = j;\n      headerRow.appendChild(th);\n    }\n    thead.appendChild(headerRow);\n    matrixTable.appendChild(thead);\n\n    const tbody = document.createElement('tbody');\n    for(let i=0;i<n;i++){\n      const tr = document.createElement('tr');\n      const rowHeader = document.createElement('th');\n      rowHeader.textContent = i;\n      tr.appendChild(rowHeader);\n\n      for(let j=0;j<n;j++){\n        const td = document.createElement('td');\n        td.dataset.i = i;\n        td.dataset.j = j;\n\n        if(weighted){\n          const input = document.createElement('input');\n          input.type = 'number';\n          input.step = 'any';\n          input.className = 'weight';\n          input.value = (A[i][j] !== 0) ? A[i][j] : '';\n          input.title = `Edge ${i} → ${j}`;\n          input.addEventListener('change', (e)=>{\n            let val = e.target.value.trim();\n            if(val === '' || val === null){\n              setEdge(i,j,0);\n            } else {\n              const num = Number(val);\n              if(!isFinite(num)){ e.target.value=''; setEdge(i,j,0); }\n              else setEdge(i,j,num);\n            }\n            renderMatrix(); drawGraph(); renderAdjList();\n          });\n          input.addEventListener('keydown', (e)=>{\n            if(e.key === 'Enter'){ input.blur(); }\n          });\n          td.appendChild(input);\n        } else {\n          td.classList.add('cell');\n          td.classList.add(A[i][j] ? 'on' : 'off');\n          if(i===j) td.classList.add('selfloop');\n          td.title = `Click to toggle edge ${i} → ${j}`;\n          td.addEventListener('click', ()=>{\n            if(i===j && !allowSelf) return;\n            const newVal = A[i][j] ? 0 : 1;\n            setEdge(i,j,newVal);\n            renderMatrix(); drawGraph(); renderAdjList();\n          });\n        }\n        tr.appendChild(td);\n      }\n      tbody.appendChild(tr);\n    }\n    matrixTable.appendChild(tbody);\n  }\n\n  function setEdge(i,j,val){\n    if(i===j && !allowSelf) return;\n    if(!weighted){\n      val = val ? 1 : 0;\n    } else {\n      if(typeof val !== 'number') val = Number(val) || 0;\n    }\n    A[i][j] = val;\n    if(enforceSymmetry){\n      A[j][i] = val;\n    }\n    if(!directed && !enforceSymmetry){\n      // For undirected graphs, it's convenient to mirror toggles unless user wants asymmetry.\n      // We won't auto-mirror unless enforceSymmetry is set; this keeps user control.\n    }\n  }\n\n  function drawGraph(){\n    while(svg.firstChild) svg.removeChild(svg.firstChild);\n\n    const w = svg.clientWidth;\n    const h = svg.clientHeight;\n\n    // defs for arrowhead\n    const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');\n    const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');\n    marker.setAttribute('id','arrowhead');\n    marker.setAttribute('markerWidth','10');\n    marker.setAttribute('markerHeight','8');\n    marker.setAttribute('refX','10');\n    marker.setAttribute('refY','4');\n    marker.setAttribute('orient','auto');\n    const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n    path.setAttribute('d','M0,0 L10,4 L0,8 z');\n    path.setAttribute('fill','#444');\n    marker.appendChild(path);\n    defs.appendChild(marker);\n    svg.appendChild(defs);\n\n    // draw edges behind nodes\n    // For each nonzero A[i][j], draw line from i to j\n    for(let i=0;i<n;i++){\n      for(let j=0;j<n;j++){\n        const val = A[i][j];\n        if(!val) continue;\n        // skip duplicate drawing for undirected if we've already drawn the opposite? We'll draw both if both set.\n        const ni = nodes[i], nj = nodes[j];\n        if(!ni || !nj) continue;\n\n        const dx = nj.x - ni.x;\n        const dy = nj.y - ni.y;\n        const dist = Math.sqrt(dx*dx + dy*dy) || 1;\n        const r = 20; // node radius\n        // points offset to avoid overlapping node circles\n        const sx = ni.x + (dx/dist)*r;\n        const sy = ni.y + (dy/dist)*r;\n        const ex = nj.x - (dx/dist)*r;\n        const ey = nj.y - (dy/dist)*r;\n\n        const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n\n        const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n        line.setAttribute('x1',sx);\n        line.setAttribute('y1',sy);\n        line.setAttribute('x2',ex);\n        line.setAttribute('y2',ey);\n        line.setAttribute('stroke','#4a5568');\n        line.setAttribute('stroke-width','2');\n        line.setAttribute('stroke-opacity','0.9');\n\n        if(directed){\n          line.setAttribute('marker-end','url(#arrowhead)');\n        } else {\n          line.setAttribute('stroke-linecap','round');\n        }\n\n        g.appendChild(line);\n\n        // weight label or simple dot\n        if(weighted){\n          const mx = (sx+ex)/2;\n          const my = (sy+ey)/2;\n          const label = document.createElementNS('http://www.w3.org/2000/svg','text');\n          label.setAttribute('x', mx);\n          label.setAttribute('y', my - 6);\n          label.setAttribute('fill','#222');\n          label.setAttribute('font-size','12');\n          label.setAttribute('text-anchor','middle');\n          label.textContent = A[i][j];\n          g.appendChild(label);\n        }\n\n        // For self-loops, draw small loop\n        if(i===j){\n          // remove the straight line and draw a loop\n          g.removeChild(line);\n          const loop = document.createElementNS('http://www.w3.org/2000/svg','path');\n          const cx = ni.x, cy = ni.y;\n          const loopR = 18;\n          loop.setAttribute('d', `M ${cx+loopR} ${cy} A ${loopR} ${loopR} 0 1 1 ${cx+loopR-1} ${cy+0.1}`);\n          loop.setAttribute('stroke','#b86200');\n          loop.setAttribute('stroke-width','2');\n          loop.setAttribute('fill','none');\n          g.appendChild(loop);\n          if(weighted){\n            const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n            t.setAttribute('x', cx + loopR + 6);\n            t.setAttribute('y', cy - 6);\n            t.setAttribute('fill','#222');\n            t.setAttribute('font-size','12');\n            t.textContent = A[i][j];\n            g.appendChild(t);\n          }\n        }\n\n        svg.appendChild(g);\n      }\n    }\n\n    // nodes on top\n    for(let i=0;i<n;i++){\n      const node = nodes[i] || {x:50+i*30,y:50};\n      const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n      g.setAttribute('class','node');\n      g.dataset.index = i;\n\n      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n      circle.setAttribute('cx',node.x);\n      circle.setAttribute('cy',node.y);\n      circle.setAttribute('r',20);\n      circle.setAttribute('fill','#fff');\n      circle.setAttribute('stroke','#333');\n      circle.setAttribute('stroke-width','1.5');\n      circle.setAttribute('style','cursor:move;');\n      g.appendChild(circle);\n\n      const text = document.createElementNS('http://www.w3.org/2000/svg','text');\n      text.setAttribute('x', node.x);\n      text.setAttribute('y', node.y + 4);\n      text.setAttribute('text-anchor','middle');\n      text.setAttribute('class','node-label');\n      text.textContent = i;\n      g.appendChild(text);\n\n      // drag handlers\n      addDragHandlers(g, i);\n\n      svg.appendChild(g);\n    }\n  }\n\n  // Drag nodes to reposition\n  let dragging = {active:false, idx:-1, offsetX:0, offsetY:0};\n  function addDragHandlers(elem, idx){\n    elem.addEventListener('mousedown', (ev)=>{\n      ev.preventDefault();\n      dragging.active = true;\n      dragging.idx = idx;\n      const pt = getSVGPoint(ev);\n      dragging.offsetX = nodes[idx].x - pt.x;\n      dragging.offsetY = nodes[idx].y - pt.y;\n    });\n  }\n  function getSVGPoint(evt){\n    const pt = svg.createSVGPoint();\n    pt.x = evt.clientX;\n    pt.y = evt.clientY;\n    const ctm = svg.getScreenCTM().inverse();\n    return pt.matrixTransform(ctm);\n  }\n  window.addEventListener('mousemove', (ev)=>{\n    if(!dragging.active) return;\n    const p = getSVGPoint(ev);\n    const idx = dragging.idx;\n    nodes[idx].x = p.x + dragging.offsetX;\n    nodes[idx].y = p.y + dragging.offsetY;\n    drawGraph();\n  });\n  window.addEventListener('mouseup', (ev)=>{\n    dragging.active = false;\n    dragging.idx = -1;\n  });\n\n  // adjacency list render\n  function renderAdjList(){\n    let out = '';\n    for(let i=0;i<n;i++){\n      const neigh = [];\n      for(let j=0;j<n;j++){\n        if(A[i][j]){\n          if(weighted) neigh.push(`${j}(${A[i][j]})`);\n          else neigh.push(`${j}`);\n        }\n      }\n      out += `${i}: ${neigh.join(' ')}\\n`;\n    }\n    adjListDiv.textContent = out;\n  }\n\n  // Randomize graph\n  function randomizeGraph(){\n    for(let i=0;i<n;i++){\n      for(let j=0;j<n;j++){\n        if(i===j && !allowSelf){ A[i][j]=0; continue; }\n        if(Math.random() < 0.25){\n          A[i][j] = weighted ? Math.round((Math.random()*9+1)*10)/10 : 1;\n          if(enforceSymmetry) A[j][i] = A[i][j];\n        } else {\n          A[i][j] = 0;\n        }\n      }\n    }\n  }\n\n  // Import / Export\n  function exportJSON(){\n    const data = {\n      n, directed, weighted, allowSelf, enforceSymmetry, A\n    };\n    return JSON.stringify(data, null, 2);\n  }\n\n  function importJSON(text){\n    try{\n      const data = JSON.parse(text);\n      if(!Array.isArray(data.A)) throw new Error('No matrix A');\n      const m = data.A.length;\n      initMatrix(m);\n      n = m;\n      directed = !!data.directed;\n      weighted = !!data.weighted;\n      allowSelf = !!data.allowSelf;\n      enforceSymmetry = !!data.enforceSymmetry;\n      // copy matrix (coerce numbers)\n      for(let i=0;i<n;i++){\n        for(let j=0;j<n;j++){\n          A[i][j] = Number(data.A[i][j]) || 0;\n        }\n      }\n      randomizePositions();\n      rebuild();\n      return true;\n    } catch(err){\n      alert('Import failed: ' + err.message);\n      return false;\n    }\n  }\n\n  // Parse adjacency list like:\n  // 0: 1 2\n  // 1: 2\n  function importFromAdjList(text){\n    const lines = text.split(/\\r?\\n/).map(s=>s.trim()).filter(Boolean);\n    const pairs = [];\n    let maxIndex = -1;\n    for(const line of lines){\n      const parts = line.split(':');\n      if(parts.length < 2) continue;\n      const i = Number(parts[0]);\n      if(!Number.isFinite(i)) continue;\n      const items = parts[1].trim().split(/\\s+/).filter(Boolean);\n      for(const it of items){\n        // allow weights like 2(3.5)\n        const m = it.match(/^(\\d+)(?:\\(([-\\d.]+)\\))?$/);\n        if(m){\n          const j = Number(m[1]);\n          const w = m[2] ? Number(m[2]) : 1;\n          pairs.push([i,j,w]);\n          maxIndex = Math.max(maxIndex, i, j);\n        }\n      }\n    }\n    if(maxIndex < 0) { alert('No valid adjacency list found'); return; }\n    initMatrix(maxIndex+1);\n    for(const [i,j,w] of pairs){\n      A[i][j] = weighted ? w : 1;\n      if(enforceSymmetry) A[j][i] = A[i][j];\n    }\n    randomizePositions();\n    rebuild();\n  }\n\n  // Wire up controls\n  resizeBtn.addEventListener('click', ()=>{\n    const val = parseInt(nodeCountInput.value);\n    if(!Number.isInteger(val) || val < 1 || val > maxNodes){ alert('Enter valid node count (1-'+maxNodes+')'); return; }\n    const old = n;\n    initMatrix(val);\n    // try to copy existing values where possible\n    for(let i=0;i<Math.min(old,n);i++){\n      for(let j=0;j<Math.min(old,n);j++){\n        A[i][j] = A[i][j] || 0;\n      }\n    }\n    randomizePositions();\n    rebuild();\n  });\n\n  directedCb.addEventListener('change', (e)=>{\n    directed = e.target.checked;\n    rebuild();\n  });\n  weightedCb.addEventListener('change', (e)=>{\n    weighted = e.target.checked;\n    rebuild();\n  });\n  allowSelfCb.addEventListener('change', (e)=>{\n    allowSelf = e.target.checked;\n    if(!allowSelf){\n      for(let i=0;i<n;i++) A[i][i]=0;\n    }\n    rebuild();\n  });\n\n  randomBtn.addEventListener('click', ()=>{\n    randomizeGraph();\n    rebuild();\n  });\n\n  clearBtn.addEventListener('click', ()=>{\n    for(let i=0;i<n;i++) for(let j=0;j<n;j++) A[i][j] = 0;\n    rebuild();\n  });\n\n  symBtn.addEventListener('click', ()=>{\n    enforceSymmetry = !enforceSymmetry;\n    if(enforceSymmetry){\n      // force symmetry now\n      for(let i=0;i<n;i++) for(let j=0;j<n;j++){\n        if(A[i][j] && !A[j][i]) A[j][i] = A[i][j];\n      }\n    }\n    rebuild();\n  });\n\n  importBtn.addEventListener('click', ()=>{\n    const text = importArea.value.trim();\n    if(!text){ alert('Paste JSON or adjacency list in the textarea.'); return; }\n    // try parse as JSON first\n    if(text.startsWith('{') || text.startsWith('[')){\n      importJSON(text);\n    } else {\n      importFromAdjList(text);\n    }\n  });\n\n  fromAdjListBtn.addEventListener('click', ()=>{\n    const text = importArea.value.trim();\n    if(!text){ alert('Paste adjacency list into the textarea.'); return; }\n    importFromAdjList(text);\n  });\n\n  exportBtn.addEventListener('click', ()=>{\n    const txt = exportJSON();\n    const w = window.open('about:blank','_blank');\n    w.document.write('<pre>'+escapeHtml(txt)+'</pre>');\n    w.document.title = 'Exported Graph JSON';\n  });\n\n  copyBtn.addEventListener('click', async ()=>{\n    const txt = exportJSON();\n    try{\n      await navigator.clipboard.writeText(txt);\n      copyBtn.textContent = 'Copied!';\n      setTimeout(()=>copyBtn.textContent = 'Copy JSON', 1200);\n    }catch(e){\n      alert('Copy failed. Here is the JSON:\\n\\n' + txt);\n    }\n  });\n\n  function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }\n\n  // Initialize and start\n  initMatrix(n);\n  rebuild();\n\n  // Responsive: reposition nodes when svg size changes\n  window.addEventListener('resize', ()=> {\n    randomizePositions();\n    drawGraph();\n  });\n\n  // Helpful: double click matrix header to center nodes\n  matrixTable.addEventListener('dblclick',(e)=>{\n    if(e.target.tagName.toLowerCase()==='th'){\n      randomizePositions();\n      drawGraph();\n    }\n  });\n\n  // Keyboard shortcut: 's' to toggle symmetry\n  window.addEventListener('keydown', (e)=>{\n    if(e.key.toLowerCase() === 's' && (e.ctrlKey || e.metaKey)){\n      e.preventDefault();\n      enforceSymmetry = !enforceSymmetry;\n      rebuild();\n    }\n  });\n\n  // Initial sample pattern: cycle\n  (function samplePattern(){\n    for(let i=0;i<n;i++){\n      A[i][(i+1)%n] = 1;\n    }\n    rebuild();\n  })();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": false,
  "hasTest": true
}