{
  "id": "be87d8a7-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:42.563Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>K-Means Clustering Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 0; display: flex; height: 100vh; }\n    #controls { width: 330px; padding: 14px; box-sizing: border-box; border-right: 1px solid #e0e0e0; background: #fafafa; overflow: auto; }\n    #canvasWrap { flex: 1; display: flex; flex-direction: column; align-items: center; padding: 10px; box-sizing: border-box; }\n    canvas { background: #fff; border: 1px solid #ddd; box-shadow: 0 1px 4px rgba(0,0,0,0.04); }\n    h1 { font-size: 18px; margin: 6px 0 12px; }\n    label { display: block; margin-top: 10px; font-size: 13px; color: #333; }\n    input[type=\"number\"], select, input[type=\"range\"] { width: 100%; padding: 6px 8px; box-sizing: border-box; margin-top: 6px; }\n    button { margin-top: 8px; padding: 8px 10px; width: 48%; }\n    .row { display:flex; gap:6px; }\n    .small { width: 48%; }\n    .info { margin-top: 12px; font-size: 13px; color: #444; background: #fff; padding: 10px; border-radius: 6px; border: 1px solid #f0f0f0; }\n    .legend { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }\n    .legendItem { display:flex; align-items:center; gap:6px; font-size:12px; }\n    .dot { width:16px; height:12px; border-radius:3px; display:inline-block; border:1px solid rgba(0,0,0,0.08); }\n    #chart { width:100%; height:80px; background:#fff; border:1px solid #eee; margin-top:8px; }\n    footer { margin-top:8px; font-size:12px; color:#666; }\n    .muted { color:#666; font-size:13px; }\n    small { color:#666; }\n  </style>\n</head>\n<body>\n  <div id=\"controls\">\n    <h1>K-Means Clustering — Interactive Demo</h1>\n    <div class=\"muted\">Click on the canvas to add points. Use controls to generate data, choose K and initialization, then run step-by-step or autoplay.</div>\n\n    <label>Number of points (when generating)</label>\n    <input id=\"numPoints\" type=\"number\" min=\"1\" max=\"5000\" value=\"200\">\n\n    <label>Number of clusters (K)</label>\n    <input id=\"kValue\" type=\"number\" min=\"1\" max=\"20\" value=\"4\">\n\n    <label>Initialization</label>\n    <select id=\"initMethod\">\n      <option value=\"random\">Random (pick K random points)</option>\n      <option value=\"kmeans++\">K-Means++</option>\n    </select>\n\n    <label>Generate pattern</label>\n    <select id=\"pattern\">\n      <option value=\"blobs\">Gaussian blobs</option>\n      <option value=\"uniform\">Uniform random</option>\n      <option value=\"circles\">Concentric circles</option>\n      <option value=\"gaussian_mixture\">Mixture (variable)</option>\n    </select>\n\n    <div class=\"row\">\n      <button id=\"generate\">Generate Data</button>\n      <button id=\"clear\">Clear Points</button>\n    </div>\n\n    <label>Iterations / autoplay</label>\n    <div class=\"row\">\n      <button id=\"initButton\">Initialize Centroids</button>\n      <button id=\"stepButton\">Step</button>\n    </div>\n    <div class=\"row\">\n      <button id=\"startButton\">Start</button>\n      <button id=\"pauseButton\">Pause</button>\n    </div>\n\n    <label>Auto speed (ms per iteration)</label>\n    <input id=\"speedRange\" type=\"range\" min=\"50\" max=\"2000\" value=\"400\">\n\n    <div class=\"info\">\n      <div><strong>Iteration:</strong> <span id=\"iter\">0</span></div>\n      <div><strong>SSE (sum squared error):</strong> <span id=\"sse\">—</span></div>\n      <div><strong>Centroids:</strong> <span id=\"centroidsCount\">0</span></div>\n      <div><strong>Empty clusters handled:</strong> <span id=\"empties\">0</span></div>\n    </div>\n\n    <label>Legend (clusters)</label>\n    <div class=\"legend\" id=\"legend\"></div>\n\n    <label>Loss history</label>\n    <canvas id=\"chart\" width=\"290\" height=\"80\"></canvas>\n\n    <footer>\n      <small>Tips: After initialization, press Step to see assignment and centroid updates. Click canvas to add single points. When an empty cluster appears it's reinitialized to a random point.</small>\n    </footer>\n  </div>\n\n  <div id=\"canvasWrap\">\n    <canvas id=\"canvas\" width=\"900\" height=\"600\"></canvas>\n  </div>\n\n<script>\n(() => {\n  // Colors for clusters\n  const COLORS = ['#e6194b','#3cb44b','#ffe119','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6','#bcf60c','#fabebe','#008080','#e6beff','#9a6324','#fffac8','#800000'];\n  // State\n  let points = []; // {x,y,cluster}\n  let centroids = []; // {x,y}\n  let k = 4;\n  let iter = 0;\n  let sseHistory = [];\n  let running = false;\n  let empties = 0;\n  let assignmentsChanged = true;\n  let speed = 400;\n  let initMethod = 'random';\n  // Canvas\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  const chart = document.getElementById('chart');\n  const cctx = chart.getContext('2d');\n\n  // Controls\n  const numPointsInput = document.getElementById('numPoints');\n  const kInput = document.getElementById('kValue');\n  const initSelect = document.getElementById('initMethod');\n  const patternSelect = document.getElementById('pattern');\n  const generateBtn = document.getElementById('generate');\n  const clearBtn = document.getElementById('clear');\n  const initBtn = document.getElementById('initButton');\n  const stepBtn = document.getElementById('stepButton');\n  const startBtn = document.getElementById('startButton');\n  const pauseBtn = document.getElementById('pauseButton');\n  const iterEl = document.getElementById('iter');\n  const sseEl = document.getElementById('sse');\n  const centroidsCountEl = document.getElementById('centroidsCount');\n  const legendEl = document.getElementById('legend');\n  const emptiesEl = document.getElementById('empties');\n  const speedRange = document.getElementById('speedRange');\n\n  // Helpers: map mouse coords\n  function getMousePos(evt) {\n    const rect = canvas.getBoundingClientRect();\n    return {\n      x: (evt.clientX - rect.left),\n      y: (evt.clientY - rect.top)\n    };\n  }\n\n  // Generate synthetic data\n  function generateData() {\n    const n = Math.max(1, Math.min(5000, parseInt(numPointsInput.value||200)));\n    const pattern = patternSelect.value;\n    points = [];\n    const W = canvas.width, H = canvas.height;\n    if (pattern === 'uniform') {\n      for (let i=0;i<n;i++) points.push({x: Math.random()*W, y: Math.random()*H, cluster: -1});\n    } else if (pattern === 'blobs') {\n      const centers = [];\n      const ccount = Math.max(2, Math.min(8, Math.round(kInput.value) || 4));\n      for (let i=0;i<ccount;i++) centers.push({x: 60 + Math.random()*(W-120), y: 60 + Math.random()*(H-120)});\n      for (let i=0;i<n;i++){\n        const c = centers[Math.floor(Math.random()*centers.length)];\n        const r = Math.random()*40;\n        const a = Math.random()*Math.PI*2;\n        points.push({x: c.x + r*Math.cos(a) + randn()*6, y: c.y + r*Math.sin(a) + randn()*6, cluster: -1});\n      }\n    } else if (pattern === 'circles') {\n      for (let i=0;i<n;i++){\n        const r = (Math.random()*0.9+0.05) * Math.min(W,H)/2 * (Math.random()<0.5?0.4:1.0);\n        const a = Math.random()*Math.PI*2;\n        const cx = W/2 + randn()*10, cy = H/2 + randn()*10;\n        points.push({x: cx + r*Math.cos(a), y: cy + r*Math.sin(a), cluster: -1});\n      }\n    } else if (pattern === 'gaussian_mixture') {\n      const comps = Math.max(2, Math.min(8, Math.round(kInput.value) || 4));\n      for (let i=0;i<comps;i++){\n        const cx = 40 + Math.random()*(W-80), cy = 40 + Math.random()*(H-80);\n        const sigma = 10 + Math.random()*40;\n        for (let j=0;j<Math.floor(n/comps);j++){\n          points.push({x: cx + randn()*sigma, y: cy + randn()*sigma, cluster: -1});\n        }\n      }\n      while(points.length < n) points.push({x: Math.random()*W, y: Math.random()*H, cluster: -1});\n    }\n    iter = 0;\n    sseHistory = [];\n    centroids = [];\n    empties = 0;\n    updateInfo();\n    redraw();\n  }\n\n  // Random normal helper (Box-Muller)\n  function randn() {\n    let u=0,v=0;\n    while(u===0) u=Math.random();\n    while(v===0) v=Math.random();\n    return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);\n  }\n\n  // Initialize centroids\n  function initializeCentroids() {\n    k = Math.max(1, Math.min(20, parseInt(kInput.value||4)));\n    initMethod = initSelect.value;\n    centroids = [];\n    if (points.length === 0) {\n      // place random centroids if no points\n      for (let i=0;i<k;i++) centroids.push({x: Math.random()*canvas.width, y: Math.random()*canvas.height});\n    } else {\n      if (initMethod === 'random') {\n        const idx = [];\n        for (let i=0;i<points.length;i++) idx.push(i);\n        // shuffle and pick first k\n        for (let i=idx.length-1;i>0;i--) { const j=Math.floor(Math.random()*(i+1)); [idx[i],idx[j]]=[idx[j],idx[i]]; }\n        for (let i=0;i<k;i++){\n          const p = points[idx[i % idx.length]];\n          centroids.push({x: p.x, y: p.y});\n        }\n      } else if (initMethod === 'kmeans++') {\n        // k-means++ initialization\n        const pts = points;\n        // pick first uniformly\n        const first = pts[Math.floor(Math.random()*pts.length)];\n        centroids.push({x:first.x, y:first.y});\n        while (centroids.length < k) {\n          // compute squared distances to nearest existing centroid\n          const d2 = pts.map(p => {\n            let best = Infinity;\n            for (const c of centroids) {\n              const dx = p.x-c.x, dy = p.y-c.y;\n              const dist2 = dx*dx + dy*dy;\n              if (dist2 < best) best = dist2;\n            }\n            return best;\n          });\n          const sum = d2.reduce((a,b)=>a+b,0);\n          if (sum === 0) { // all points identical\n            // pick random\n            const p = pts[Math.floor(Math.random()*pts.length)];\n            centroids.push({x:p.x,y:p.y});\n            continue;\n          }\n          // choose next with probability proportional to d2\n          let r = Math.random()*sum;\n          let chosen = 0;\n          for (let i=0;i<d2.length;i++){\n            r -= d2[i];\n            if (r <= 0) { chosen = i; break; }\n          }\n          const p = pts[chosen];\n          centroids.push({x:p.x,y:p.y});\n        }\n      }\n    }\n    // reset assignments\n    for (const p of points) p.cluster = -1;\n    iter = 0;\n    empties = 0;\n    sseHistory = [];\n    updateInfo();\n    redraw();\n  }\n\n  // Assignment step: assign each point to nearest centroid\n  function assignPoints() {\n    if (centroids.length === 0) return false;\n    let changed = false;\n    for (const p of points) {\n      let best = -1, bestd = Infinity;\n      for (let i=0;i<centroids.length;i++){\n        const c = centroids[i];\n        const dx = p.x - c.x, dy = p.y - c.y;\n        const d2 = dx*dx + dy*dy;\n        if (d2 < bestd) { bestd = d2; best = i; }\n      }\n      if (p.cluster !== best) { p.cluster = best; changed = true; }\n    }\n    return changed;\n  }\n\n  // Update centroids: recompute as mean of assigned points\n  function updateCentroids() {\n    const sums = [];\n    for (let i=0;i<centroids.length;i++) sums.push({x:0,y:0,c:0});\n    for (const p of points) {\n      const ci = p.cluster;\n      if (ci >= 0 && ci < sums.length) {\n        sums[ci].x += p.x; sums[ci].y += p.y; sums[ci].c += 1;\n      }\n    }\n    let reinitCount = 0;\n    for (let i=0;i<centroids.length;i++){\n      if (sums[i].c === 0) {\n        // empty cluster: reinitialize centroid to a random point\n        const rp = points[Math.floor(Math.random()*points.length)];\n        centroids[i] = {x: rp.x + (Math.random()-0.5)*20, y: rp.y + (Math.random()-0.5)*20};\n        reinitCount++;\n      } else {\n        centroids[i] = {x: sums[i].x / sums[i].c, y: sums[i].y / sums[i].c};\n      }\n    }\n    empties += reinitCount;\n    return reinitCount;\n  }\n\n  // Compute SSE\n  function computeSSE() {\n    if (centroids.length === 0) return 0;\n    let sse = 0;\n    for (const p of points) {\n      const c = centroids[p.cluster] || {x:0,y:0};\n      const dx = p.x - c.x, dy = p.y - c.y;\n      sse += dx*dx + dy*dy;\n    }\n    return sse;\n  }\n\n  // Perform one k-means iteration: assign then update\n  function iterate() {\n    if (centroids.length === 0 || points.length === 0) return;\n    const changed = assignPoints();\n    const reinit = updateCentroids();\n    iter++;\n    const sse = computeSSE();\n    sseHistory.push(sse);\n    updateInfo();\n    redraw();\n    // if no changes, we can stop\n    if (!changed) {\n      running = false;\n      updateInfo();\n    }\n    return changed;\n  }\n\n  // Redraw canvas\n  function redraw() {\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    // draw points\n    ctx.save();\n    for (const p of points) {\n      const color = p.cluster >= 0 ? COLORS[p.cluster % COLORS.length] : '#888';\n      ctx.beginPath();\n      ctx.fillStyle = color;\n      ctx.globalAlpha = 0.9;\n      ctx.arc(p.x, p.y, 4, 0, Math.PI*2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n      ctx.lineWidth = 1;\n      ctx.strokeStyle = 'rgba(255,255,255,0.6)';\n      ctx.stroke();\n    }\n    // draw centroids\n    for (let i=0;i<centroids.length;i++){\n      const c = centroids[i];\n      const color = COLORS[i % COLORS.length];\n      // draw cross\n      ctx.beginPath();\n      ctx.strokeStyle = '#000';\n      ctx.lineWidth = 2;\n      ctx.moveTo(c.x-10, c.y);\n      ctx.lineTo(c.x+10, c.y);\n      ctx.moveTo(c.x, c.y-10);\n      ctx.lineTo(c.x, c.y+10);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.fillStyle = color;\n      ctx.globalAlpha = 0.9;\n      ctx.arc(c.x, c.y, 7, 0, Math.PI*2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n      ctx.fillStyle = '#fff';\n      ctx.font = '11px sans-serif';\n      ctx.fillText(i+1, c.x-6, c.y+4);\n    }\n    ctx.restore();\n    drawLegend();\n    drawChart();\n  }\n\n  // Update info panel\n  function updateInfo() {\n    iterEl.textContent = iter;\n    sseEl.textContent = sseHistory.length ? sseHistory[sseHistory.length-1].toFixed(1) : '—';\n    centroidsCountEl.textContent = centroids.length;\n    emptiesEl.textContent = empties;\n  }\n\n  // Draw legend\n  function drawLegend() {\n    legendEl.innerHTML = '';\n    for (let i=0;i<centroids.length;i++){\n      const div = document.createElement('div');\n      div.className = 'legendItem';\n      const color = COLORS[i % COLORS.length];\n      const box = document.createElement('span');\n      box.className = 'dot';\n      box.style.background = color;\n      div.appendChild(box);\n      const txt = document.createElement('span');\n      // count points in cluster\n      const count = points.filter(p=>p.cluster===i).length;\n      txt.textContent = `#${i+1} (${count})`;\n      div.appendChild(txt);\n      legendEl.appendChild(div);\n    }\n    if (centroids.length === 0) {\n      const div = document.createElement('div');\n      div.className = 'muted';\n      div.textContent = 'No centroids yet';\n      legendEl.appendChild(div);\n    }\n  }\n\n  // Draw SSE history chart\n  function drawChart() {\n    cctx.clearRect(0,0,chart.width,chart.height);\n    cctx.fillStyle = '#fafafa';\n    cctx.fillRect(0,0,chart.width,chart.height);\n    if (sseHistory.length === 0) return;\n    const w = chart.width, h = chart.height;\n    const maxSSE = Math.max(...sseHistory);\n    const minSSE = Math.min(...sseHistory);\n    // small padding\n    const pad = 6;\n    cctx.beginPath();\n    cctx.strokeStyle = '#3b82f6';\n    cctx.lineWidth = 2;\n    for (let i=0;i<sseHistory.length;i++){\n      const x = pad + (w-2*pad) * (i/(sseHistory.length-1 || 1));\n      const y = pad + (h-2*pad) * (1 - (sseHistory[i]-minSSE) / (maxSSE-minSSE || 1));\n      if (i===0) cctx.moveTo(x,y); else cctx.lineTo(x,y);\n    }\n    cctx.stroke();\n    // labels\n    cctx.fillStyle = '#666';\n    cctx.font = '10px sans-serif';\n    cctx.fillText('SSE history', 6, 12);\n    cctx.fillText((maxSSE||0).toFixed(0), w-40, 12);\n    cctx.fillText((minSSE||0).toFixed(0), w-40, h-4);\n  }\n\n  // Control handlers\n  generateBtn.addEventListener('click', ()=>{ generateData(); });\n  clearBtn.addEventListener('click', ()=>{ points = []; centroids = []; iter = 0; sseHistory = []; empties = 0; updateInfo(); redraw(); });\n  initBtn.addEventListener('click', ()=>{ initializeCentroids(); });\n  stepBtn.addEventListener('click', ()=>{ iterate(); });\n  startBtn.addEventListener('click', ()=>{ if (!running) { running = true; autoLoop(); } });\n  pauseBtn.addEventListener('click', ()=>{ running = false; });\n  kInput.addEventListener('change', ()=>{ /* nothing automatic */ });\n  speedRange.addEventListener('input', ()=>{ speed = parseInt(speedRange.value); });\n\n  // Canvas click to add points\n  canvas.addEventListener('click', (e)=>{\n    const pos = getMousePos(e);\n    points.push({x: pos.x, y: pos.y, cluster: -1});\n    iter = 0;\n    sseHistory = [];\n    redraw();\n  });\n\n  // Auto loop\n  let lastTime=0;\n  function autoLoop(ts) {\n    if (!running) return;\n    const now = Date.now();\n    if (!lastTime || now - lastTime >= speed) {\n      const changed = iterate();\n      lastTime = now;\n      if (!changed) running = false;\n    }\n    if (running) requestAnimationFrame(autoLoop);\n  }\n\n  // Initialize small demo\n  function initDemo() {\n    generateData();\n  }\n\n  // Handle empty cluster prevention: if user reduces K below current centroids, trim\n  kInput.addEventListener('change', ()=> {\n    const newK = Math.max(1, Math.min(20, parseInt(kInput.value||4)));\n    if (centroids.length > newK) {\n      centroids = centroids.slice(0,newK);\n      for (const p of points) {\n        if (p.cluster >= newK) p.cluster = -1;\n      }\n    }\n    redraw();\n  });\n\n  // Responsive: adjust canvas size to available area (optional)\n  function fitCanvas() {\n    // keep fixed size for simplicity; we could adapt\n    redraw();\n  }\n  window.addEventListener('resize', fitCanvas);\n\n  // keyboard shortcuts\n  window.addEventListener('keydown', (e) => {\n    if (e.key === ' ') { e.preventDefault(); running = !running; if (running) autoLoop(); }\n    if (e.key === 's') iterate();\n    if (e.key === 'i') initializeCentroids();\n  });\n\n  // Kick off\n  initDemo();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": false,
  "hasTest": true
}