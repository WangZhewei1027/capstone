{
  "id": "2bde1c74-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:17:14.687Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>Weighted Graph Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<style>\n  :root { --bg:#fafafa; --panel:#ffffff; --accent:#2b7cff; --muted:#666; }\n  html,body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial; background:var(--bg); color:#111; }\n  .container { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }\n  .canvas-panel { flex:1; background:linear-gradient(180deg,#fff, #f6f9ff); border:1px solid #dde7ff; border-radius:8px; position:relative; overflow:hidden; }\n  canvas { width:100%; height:100%; display:block; cursor:crosshair; }\n  .controls { width:380px; background:var(--panel); border:1px solid #e6e9ef; border-radius:8px; padding:12px; box-sizing:border-box; overflow:auto; }\n  h2 { margin:6px 0 12px 0; font-size:18px; }\n  .row { display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap; }\n  button { background:var(--accent); color:white; border:none; padding:8px 10px; border-radius:6px; cursor:pointer; font-weight:600; }\n  button.secondary { background:#f3f3f6; color:#222; border:1px solid #dedfe5; }\n  button.warn { background:#ff6b6b; }\n  .muted { color:var(--muted); font-size:13px; }\n  label { font-size:13px; margin-bottom:6px; display:block; }\n  select,input[type=\"number\"], input[type=\"text\"] { width:100%; padding:8px; border-radius:6px; border:1px solid #d8dbe6; box-sizing:border-box; }\n  pre { background:#f7f8fb; padding:8px; border-radius:6px; max-height:160px; overflow:auto; border:1px solid #eef1fb; }\n  .legend { display:flex; gap:8px; align-items:center; margin-top:6px; flex-wrap:wrap; }\n  .key { display:flex; gap:6px; align-items:center; font-size:13px; }\n  .color-box { width:18px; height:10px; border-radius:3px; }\n  .small { font-size:13px; padding:6px 8px; }\n  .info { background:#fff2c2; border:1px solid #ffe6a3; padding:8px; border-radius:6px; margin-bottom:10px; font-size:13px; }\n  footer { margin-top:12px; font-size:12px; color:var(--muted); }\n  .controls .half { width:48%; }\n  .controls .full { width:100%; }\n  .note { font-size:13px; color:var(--muted); margin-top:6px; }\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <div class=\"canvas-panel\" id=\"canvasPanel\">\n    <canvas id=\"graphCanvas\"></canvas>\n    <div style=\"position:absolute;left:10px;top:10px;background:rgba(255,255,255,0.9);padding:6px 8px;border-radius:6px;border:1px solid #eee;font-size:13px;\">\n      Left-click: add/select node • Drag: move node • Click edge: select • Right-click: delete selected\n    </div>\n  </div>\n  <div class=\"controls\">\n    <h2>Weighted Graph — Interactive Demo</h2>\n\n    <div class=\"info\">\n      Create nodes by clicking the canvas. Select nodes to add edges, compute shortest paths (Dijkstra), or build an MST (Kruskal). You can drag nodes. Right-click empty canvas to clear selection; right-click a node/edge to delete it.\n    </div>\n\n    <div class=\"row\">\n      <button id=\"addEdgeBtn\">Create Edge (between 2 selected)</button>\n      <button id=\"randomBtn\" class=\"secondary\">Generate Random Graph</button>\n      <button id=\"clearBtn\" class=\"secondary warn\">Clear Graph</button>\n    </div>\n\n    <div style=\"display:flex;gap:8px;\">\n      <div style=\"flex:1\">\n        <label>Shortest Path (Dijkstra)</label>\n        <div style=\"display:flex;gap:8px;\">\n          <select id=\"srcSelect\"></select>\n          <select id=\"dstSelect\"></select>\n        </div>\n        <div style=\"display:flex;gap:8px;margin-top:8px;\">\n          <button id=\"runDijkstraBtn\" class=\"small\">Compute</button>\n          <button id=\"clearPathBtn\" class=\"small secondary\">Clear Path</button>\n        </div>\n      </div>\n    </div>\n\n    <div style=\"margin-top:10px;\">\n      <label>Minimum Spanning Tree</label>\n      <div style=\"display:flex;gap:8px;\">\n        <button id=\"mstBtn\">Show MST (Kruskal)</button>\n        <button id=\"clearMstBtn\" class=\"secondary\">Clear MST</button>\n      </div>\n      <div class=\"note\">MST shown for the current undirected graph. If the graph is disconnected, MST will show forest edges.</div>\n    </div>\n\n    <hr/>\n\n    <div style=\"display:flex;gap:8px;margin-bottom:8px;\">\n      <div style=\"flex:1\">\n        <label>Selected Node</label>\n        <input id=\"selectedNodeLabel\" type=\"text\" placeholder=\"No node selected\" />\n      </div>\n      <div style=\"width:110px;\">\n        <label>Weight (edge)</label>\n        <input id=\"selectedEdgeWeight\" type=\"number\" step=\"0.1\" />\n      </div>\n    </div>\n    <div style=\"display:flex;gap:8px;margin-bottom:8px;\">\n      <button id=\"renameNodeBtn\" class=\"secondary\">Rename Node</button>\n      <button id=\"setEdgeWeightBtn\" class=\"secondary\">Set Edge Weight</button>\n      <button id=\"deleteSelectedBtn\" class=\"warn\">Delete Selected</button>\n    </div>\n\n    <hr/>\n\n    <label>Graph Representations</label>\n    <div style=\"display:flex;gap:8px;\">\n      <div style=\"flex:1\">\n        <div class=\"muted\">Adjacency List</div>\n        <pre id=\"adjList\"></pre>\n      </div>\n      <div style=\"width:180px\">\n        <div class=\"muted\">Adjacency Matrix</div>\n        <pre id=\"adjMatrix\"></pre>\n      </div>\n    </div>\n\n    <hr/>\n\n    <div class=\"legend\">\n      <div class=\"key\"><div class=\"color-box\" style=\"background:#2b7cff\"></div> Node</div>\n      <div class=\"key\"><div class=\"color-box\" style=\"background:#999\"></div> Edge</div>\n      <div class=\"key\"><div class=\"color-box\" style=\"background:#ff9f1c\"></div> Shortest Path</div>\n      <div class=\"key\"><div class=\"color-box\" style=\"background:#2ecc71\"></div> MST</div>\n      <div class=\"key\"><div class=\"color-box\" style=\"background:#ff6b6b\"></div> Selected</div>\n    </div>\n\n    <footer>Tip: click two nodes to select them quickly (shift-click to add to selection).</footer>\n  </div>\n</div>\n\n<script>\n(() => {\n  // Canvas setup\n  const canvas = document.getElementById('graphCanvas');\n  const panel = document.getElementById('canvasPanel');\n  const ctx = canvas.getContext('2d');\n\n  // Resize to device pixel ratio\n  function resize() {\n    const rect = panel.getBoundingClientRect();\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = Math.round(rect.width * dpr);\n    canvas.height = Math.round(rect.height * dpr);\n    canvas.style.width = rect.width + 'px';\n    canvas.style.height = rect.height + 'px';\n    ctx.setTransform(dpr,0,0,dpr,0,0);\n    render();\n  }\n  window.addEventListener('resize', resize);\n  resize();\n\n  // Data structures\n  let nodes = []; // {id,x,y,label}\n  let edges = []; // {id,u,v,weight}\n  let nodeIdSeq = 1, edgeIdSeq = 1;\n\n  // Interaction state\n  let selectedNodes = []; // array of node ids\n  let selectedEdge = null; // edge id\n  let draggingNode = null;\n  let dragOffset = {x:0,y:0};\n  let highlightedPathEdges = new Set();\n  let highlightedMstEdges = new Set();\n\n  // UI elements\n  const addEdgeBtn = document.getElementById('addEdgeBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const srcSelect = document.getElementById('srcSelect');\n  const dstSelect = document.getElementById('dstSelect');\n  const runDijkstraBtn = document.getElementById('runDijkstraBtn');\n  const clearPathBtn = document.getElementById('clearPathBtn');\n  const mstBtn = document.getElementById('mstBtn');\n  const clearMstBtn = document.getElementById('clearMstBtn');\n  const adjListEl = document.getElementById('adjList');\n  const adjMatrixEl = document.getElementById('adjMatrix');\n  const selectedNodeLabel = document.getElementById('selectedNodeLabel');\n  const selectedEdgeWeight = document.getElementById('selectedEdgeWeight');\n  const renameNodeBtn = document.getElementById('renameNodeBtn');\n  const setEdgeWeightBtn = document.getElementById('setEdgeWeightBtn');\n  const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');\n\n  // Helpers\n  function getNodeById(id) { return nodes.find(n => n.id === id); }\n  function getEdgeById(id) { return edges.find(e => e.id === id); }\n  function findEdgeBetween(u,v) {\n    return edges.find(e => (e.u===u && e.v===v) || (e.u===v && e.v===u));\n  }\n\n  function screenToCanvas(evt) {\n    const rect = canvas.getBoundingClientRect();\n    const x = evt.clientX - rect.left;\n    const y = evt.clientY - rect.top;\n    return {x,y};\n  }\n\n  // Geometry utilities\n  function dist(a,b) { const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }\n  function pointToSegDistance(p, a, b) {\n    const A = p.x - a.x, B = p.y - a.y, C = b.x - a.x, D = b.y - a.y;\n    const dot = A*C + B*D;\n    const len_sq = C*C + D*D;\n    let t = (len_sq === 0) ? -1 : dot / len_sq;\n    if (t < 0) t = 0;\n    else if (t > 1) t = 1;\n    const proj = { x: a.x + C * t, y: a.y + D * t };\n    return Math.hypot(p.x - proj.x, p.y - proj.y);\n  }\n\n  // Rendering\n  function render() {\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    // scale independent drawing handled via ctx transform earlier\n    // draw edges\n    for (const e of edges) {\n      const a = getNodeById(e.u);\n      const b = getNodeById(e.v);\n      if (!a || !b) continue;\n      // choose color\n      let color = '#9aa3b8';\n      if (highlightedPathEdges.has(e.id)) color = '#ff9f1c';\n      else if (highlightedMstEdges.has(e.id)) color = '#2ecc71';\n      else if (selectedEdge === e.id) color = '#ff6b6b';\n      ctx.strokeStyle = color;\n      ctx.lineWidth = (selectedEdge === e.id ? 4 : 2);\n      ctx.beginPath();\n      ctx.moveTo(a.x, a.y);\n      ctx.lineTo(b.x, b.y);\n      ctx.stroke();\n\n      // weight label\n      const mx = (a.x + b.x)/2, my = (a.y + b.y)/2;\n      ctx.fillStyle = '#fff';\n      ctx.strokeStyle = 'rgba(0,0,0,0.05)';\n      ctx.lineWidth = 6;\n      ctx.strokeText(String(e.weight), mx, my - 6);\n      ctx.lineWidth = 1;\n      ctx.fillStyle = '#333';\n      ctx.font = '13px system-ui, Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(e.weight), mx, my - 6);\n    }\n\n    // draw nodes\n    for (const n of nodes) {\n      const r = 18;\n      const isSelected = selectedNodes.includes(n.id);\n      // outer\n      ctx.beginPath();\n      ctx.fillStyle = isSelected ? '#2b7cff' : '#fff';\n      ctx.strokeStyle = isSelected ? '#174ea6' : '#cfd6e3';\n      ctx.lineWidth = isSelected ? 3 : 2;\n      ctx.arc(n.x, n.y, r, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      // label\n      ctx.fillStyle = isSelected ? '#fff' : '#111';\n      ctx.font = 'bold 13px system-ui, Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(n.label, n.x, n.y);\n    }\n  }\n\n  // Selection helpers\n  function clearSelection() {\n    selectedNodes = [];\n    selectedEdge = null;\n    selectedNodeLabel.value = '';\n    selectedEdgeWeight.value = '';\n    render();\n    updateUI();\n  }\n\n  function updateUI() {\n    // update selects\n    srcSelect.innerHTML = '<option value=\"\">— source —</option>';\n    dstSelect.innerHTML = '<option value=\"\">— target —</option>';\n    for (const n of nodes) {\n      const opt1 = document.createElement('option');\n      opt1.value = n.id; opt1.textContent = `${n.label} (${n.id})`;\n      srcSelect.appendChild(opt1);\n      const opt2 = opt1.cloneNode(true);\n      dstSelect.appendChild(opt2);\n    }\n\n    // show selected node/edge\n    if (selectedNodes.length === 1) {\n      const n = getNodeById(selectedNodes[0]);\n      selectedNodeLabel.value = n ? n.label : '';\n    } else {\n      selectedNodeLabel.value = '';\n    }\n    if (selectedEdge !== null) {\n      const e = getEdgeById(selectedEdge);\n      selectedEdgeWeight.value = e ? e.weight : '';\n    } else {\n      selectedEdgeWeight.value = '';\n    }\n\n    // adjacency list / matrix\n    adjListEl.textContent = buildAdjListText();\n    adjMatrixEl.textContent = buildAdjMatrixText();\n  }\n\n  function buildAdjListText() {\n    const map = {};\n    for (const n of nodes) map[n.id] = [];\n    for (const e of edges) {\n      map[e.u].push({to:e.v, w:e.weight});\n      map[e.v].push({to:e.u, w:e.weight});\n    }\n    let out = '';\n    for (const n of nodes) {\n      const arr = map[n.id].map(it => `${getNodeById(it.to).label}(${it.to}):${it.w}`).join(', ');\n      out += `${n.label}(${n.id}) -> ${arr}\\n`;\n    }\n    return out;\n  }\n\n  function buildAdjMatrixText() {\n    const ids = nodes.map(n=>n.id);\n    const idx = {};\n    ids.forEach((id,i)=>idx[id]=i);\n    const n = ids.length;\n    const mat = Array.from({length:n}, ()=>Array(n).fill('∞'));\n    for (const e of edges) {\n      const i = idx[e.u], j = idx[e.v];\n      if (i==null||j==null) continue;\n      mat[i][j] = String(e.weight);\n      mat[j][i] = String(e.weight);\n    }\n    const header = nodes.map(nd=>nd.label).join(' ');\n    let out = '    ' + nodes.map(nd=>nd.label.padStart(4)).join('') + '\\n';\n    for (let i=0;i<n;i++) {\n      out += nodes[i].label.padEnd(4) + ' ';\n      for (let j=0;j<n;j++) {\n        out += mat[i][j].toString().padStart(4);\n      }\n      out += '\\n';\n    }\n    return out;\n  }\n\n  // Node/edge operations\n  function addNode(x,y,label) {\n    const node = { id: nodeIdSeq++, x, y, label: label || `N${nodeIdSeq-1}` };\n    nodes.push(node);\n    updateUI();\n    render();\n    return node;\n  }\n\n  function addEdge(u,v,w) {\n    if (u===v) return null;\n    if (findEdgeBetween(u,v)) {\n      alert('Edge already exists between those nodes.');\n      return null;\n    }\n    const e = { id: edgeIdSeq++, u, v, weight: Number(w) };\n    edges.push(e);\n    updateUI();\n    render();\n    return e;\n  }\n\n  function deleteNode(id) {\n    nodes = nodes.filter(n=>n.id!==id);\n    edges = edges.filter(e=>e.u!==id && e.v!==id);\n    selectedNodes = selectedNodes.filter(i=>i!==id);\n    if (selectedEdge && !edges.find(e=>e.id===selectedEdge)) selectedEdge = null;\n    updateUI();\n    render();\n  }\n\n  function deleteEdge(id) {\n    edges = edges.filter(e=>e.id!==id);\n    if (selectedEdge === id) selectedEdge = null;\n    updateUI();\n    render();\n  }\n\n  // Events\n  canvas.addEventListener('mousedown', (evt) => {\n    evt.preventDefault();\n    const p = screenToCanvas(evt);\n    // find if clicking a node\n    const radius = 18;\n    let hitNode = null;\n    for (let i=nodes.length-1;i>=0;i--) {\n      const n = nodes[i];\n      if (Math.hypot(n.x - p.x, n.y - p.y) <= radius+2) { hitNode = n; break; }\n    }\n    // right-click handling\n    if (evt.button === 2) { // right click\n      if (hitNode) {\n        deleteNode(hitNode.id);\n      } else {\n        // try edge\n        const hitEdge = findEdgeAtPoint(p);\n        if (hitEdge) deleteEdge(hitEdge.id);\n        else { // clear selection\n          clearSelection();\n        }\n      }\n      return;\n    }\n\n    if (hitNode) {\n      // start dragging\n      draggingNode = hitNode.id;\n      dragOffset.x = p.x - hitNode.x;\n      dragOffset.y = p.y - hitNode.y;\n\n      // selection behavior: shift-click to add/remove from selection, otherwise select single\n      if (evt.shiftKey) {\n        if (selectedNodes.includes(hitNode.id)) selectedNodes = selectedNodes.filter(i=>i!==hitNode.id);\n        else selectedNodes.push(hitNode.id);\n      } else {\n        selectedNodes = [hitNode.id];\n        selectedEdge = null;\n      }\n      updateUI();\n      render();\n      return;\n    }\n\n    // click on edge?\n    const hitEdge = findEdgeAtPoint(p);\n    if (hitEdge) {\n      selectedEdge = hitEdge.id;\n      selectedNodes = [];\n      updateUI();\n      render();\n      return;\n    }\n\n    // click empty space: create node\n    const label = `N${nodeIdSeq}`;\n    addNode(p.x, p.y, label);\n    // select new node\n    selectedNodes = [nodeIdSeq-1];\n    selectedEdge = null;\n    updateUI();\n    render();\n  });\n\n  canvas.addEventListener('mousemove', (evt) => {\n    if (!draggingNode) return;\n    const p = screenToCanvas(evt);\n    const n = getNodeById(draggingNode);\n    if (!n) return;\n    n.x = p.x - dragOffset.x;\n    n.y = p.y - dragOffset.y;\n    render();\n    updateUI();\n  });\n\n  window.addEventListener('mouseup', (evt) => {\n    if (draggingNode) draggingNode = null;\n  });\n\n  // prevent default context menu on canvas for right-click interactions\n  canvas.addEventListener('contextmenu', (e)=>e.preventDefault());\n\n  function findEdgeAtPoint(p) {\n    // returns edge where distance to segment < threshold\n    let best = null;\n    for (const e of edges) {\n      const a = getNodeById(e.u); const b = getNodeById(e.v);\n      if (!a||!b) continue;\n      const d = pointToSegDistance(p,a,b);\n      if (d < 8) { best = e; break; }\n    }\n    return best;\n  }\n\n  // Buttons\n  addEdgeBtn.addEventListener('click', () => {\n    if (selectedNodes.length !== 2) { alert('Select exactly two nodes to create an edge (shift-click to multi-select).'); return; }\n    const u = selectedNodes[0], v = selectedNodes[1];\n    const w = prompt('Enter edge weight (number):', '1');\n    if (w === null) return;\n    const num = Number(w);\n    if (Number.isNaN(num)) { alert('Invalid weight'); return; }\n    addEdge(u,v,num);\n    highlightedPathEdges.clear(); highlightedMstEdges.clear();\n  });\n\n  randomBtn.addEventListener('click', () => {\n    const nodeCount = Math.max(3, Math.min(12, Number(prompt('Number of nodes (3-12):', '7')) || 7));\n    const edgeProb = Math.min(1, Math.max(0, Number(prompt('Edge probability (0-1):', '0.35')) || 0.35));\n    // clear\n    nodes = []; edges = []; nodeIdSeq = 1; edgeIdSeq = 1;\n    const rect = canvas.getBoundingClientRect();\n    for (let i=0;i<nodeCount;i++) {\n      const padding = 40;\n      const x = padding + Math.random()*(rect.width-2*padding);\n      const y = padding + Math.random()*(rect.height-2*padding);\n      addNode(x,y, `N${nodeIdSeq}`);\n    }\n    // randomly add edges\n    for (let i=0;i<nodes.length;i++){\n      for (let j=i+1;j<nodes.length;j++){\n        if (Math.random() < edgeProb) {\n          const w = +(Math.random()*18 + 1).toFixed(1);\n          addEdge(nodes[i].id, nodes[j].id, w);\n        }\n      }\n    }\n    selectedNodes = [];\n    selectedEdge = null;\n    highlightedPathEdges.clear(); highlightedMstEdges.clear();\n    updateUI();\n    render();\n  });\n\n  clearBtn.addEventListener('click', () => {\n    if (!confirm('Clear entire graph?')) return;\n    nodes = []; edges = []; nodeIdSeq = 1; edgeIdSeq = 1;\n    selectedNodes = []; selectedEdge = null; highlightedPathEdges.clear(); highlightedMstEdges.clear();\n    updateUI(); render();\n  });\n\n  runDijkstraBtn.addEventListener('click', () => {\n    const src = Number(srcSelect.value);\n    const dst = Number(dstSelect.value);\n    if (!src || !dst) { alert('Select source and target nodes.'); return; }\n    const result = dijkstra(src, dst);\n    if (!result) { alert('No path found.'); return; }\n    highlightedPathEdges = new Set(result.pathEdgeIds);\n    // optionally select nodes along path\n    selectedNodes = result.pathNodeIds.slice();\n    selectedEdge = null;\n    updateUI();\n    render();\n    alert('Shortest path distance: ' + result.distance);\n  });\n\n  clearPathBtn.addEventListener('click', () => {\n    highlightedPathEdges.clear();\n    selectedNodes = [];\n    updateUI();\n    render();\n  });\n\n  mstBtn.addEventListener('click', () => {\n    highlightedMstEdges = new Set(kruskalMST());\n    selectedNodes = [];\n    selectedEdge = null;\n    updateUI();\n    render();\n  });\n\n  clearMstBtn.addEventListener('click', () => {\n    highlightedMstEdges.clear();\n    updateUI();\n    render();\n  });\n\n  renameNodeBtn.addEventListener('click', () => {\n    if (selectedNodes.length !== 1) { alert('Select exactly one node to rename.'); return; }\n    const id = selectedNodes[0];\n    const n = getNodeById(id);\n    const newLabel = selectedNodeLabel.value.trim();\n    if (!newLabel) { alert('Label cannot be empty'); return; }\n    n.label = newLabel;\n    updateUI();\n    render();\n  });\n\n  setEdgeWeightBtn.addEventListener('click', () => {\n    if (!selectedEdge) { alert('Select an edge first.'); return; }\n    const e = getEdgeById(selectedEdge);\n    const w = Number(selectedEdgeWeight.value);\n    if (Number.isNaN(w)) { alert('Invalid weight'); return; }\n    e.weight = w;\n    highlightedPathEdges.clear(); highlightedMstEdges.clear();\n    updateUI();\n    render();\n  });\n\n  deleteSelectedBtn.addEventListener('click', () => {\n    if (selectedEdge) { deleteEdge(selectedEdge); selectedEdge = null; }\n    else if (selectedNodes.length===1) { deleteNode(selectedNodes[0]); selectedNodes=[]; }\n    else { alert('Select a single node or an edge to delete.'); }\n    updateUI(); render();\n  });\n\n  // Algorithms\n  function buildAdjMap() {\n    const map = new Map();\n    for (const n of nodes) map.set(n.id, []);\n    for (const e of edges) {\n      if (!map.has(e.u) || !map.has(e.v)) continue;\n      map.get(e.u).push({to:e.v, w:e.weight, eid:e.id});\n      map.get(e.v).push({to:e.u, w:e.weight, eid:e.id});\n    }\n    return map;\n  }\n\n  function dijkstra(srcId, dstId) {\n    const adj = buildAdjMap();\n    const dist = new Map();\n    const prev = new Map();\n    const prevEdge = new Map();\n    const pq = new MinHeap();\n    for (const id of adj.keys()) { dist.set(id, Infinity); }\n    dist.set(srcId, 0);\n    pq.push({id:srcId, d:0});\n    while (!pq.empty()) {\n      const cur = pq.pop();\n      if (cur.d !== dist.get(cur.id)) continue;\n      if (cur.id === dstId) break;\n      for (const nb of adj.get(cur.id) || []) {\n        const nd = cur.d + nb.w;\n        if (nd < dist.get(nb.to)) {\n          dist.set(nb.to, nd);\n          prev.set(nb.to, cur.id);\n          prevEdge.set(nb.to, nb.eid);\n          pq.push({id:nb.to, d:nd});\n        }\n      }\n    }\n    if (!prev.has(dstId) && srcId !== dstId) return null;\n    // reconstruct path\n    const pathNodeIds = [];\n    const pathEdgeIds = [];\n    let cur = dstId;\n    pathNodeIds.push(cur);\n    while (prev.has(cur)) {\n      pathEdgeIds.push(prevEdge.get(cur));\n      cur = prev.get(cur);\n      pathNodeIds.push(cur);\n    }\n    pathNodeIds.reverse(); pathEdgeIds.reverse();\n    return { distance: dist.get(dstId), pathNodeIds, pathEdgeIds };\n  }\n\n  // Kruskal for undirected graph\n  function kruskalMST() {\n    const edgesSorted = edges.slice().sort((a,b)=>a.weight - b.weight);\n    const parent = {};\n    for (const n of nodes) parent[n.id] = n.id;\n    function find(x){ return parent[x] === x ? x : (parent[x]=find(parent[x])); }\n    const res = [];\n    for (const e of edgesSorted) {\n      const ru = find(e.u), rv = find(e.v);\n      if (ru !== rv) {\n        parent[ru] = rv;\n        res.push(e.id);\n      }\n    }\n    return res;\n  }\n\n  // Simple MinHeap for dijkstra\n  class MinHeap {\n    constructor(){ this.a = []; }\n    push(x){ this.a.push(x); this._siftUp(this.a.length-1); }\n    pop() {\n      if (this.a.length===0) return null;\n      const ret = this.a[0];\n      const last = this.a.pop();\n      if (this.a.length>0){ this.a[0]=last; this._siftDown(0); }\n      return ret;\n    }\n    empty(){ return this.a.length===0; }\n    _siftUp(i){\n      while (i>0){ const p=Math.floor((i-1)/2); if (this._cmp(this.a[i],this.a[p])<0){ [this.a[i],this.a[p]]=[this.a[p],this.a[i]]; i=p; } else break; }\n    }\n    _siftDown(i){\n      while(true){\n        let l = 2*i+1, r = l+1, m = i;\n        if (l < this.a.length && this._cmp(this.a[l], this.a[m]) < 0) m = l;\n        if (r < this.a.length && this._cmp(this.a[r], this.a[m]) < 0) m = r;\n        if (m === i) break;\n        [this.a[i],this.a[m]] = [this.a[m],this.a[i]];\n        i = m;\n      }\n    }\n    _cmp(a,b){ return a.d - b.d; }\n  }\n\n  // Initial example graph\n  function initExample() {\n    const rect = canvas.getBoundingClientRect();\n    nodes = [];\n    edges = [];\n    nodeIdSeq = 1; edgeIdSeq = 1;\n    const centerX = rect.width/2, centerY = rect.height/2;\n    const nA = addNode(centerX-140, centerY-40, 'A');\n    const nB = addNode(centerX-30, centerY-90, 'B');\n    const nC = addNode(centerX+80, centerY-40, 'C');\n    const nD = addNode(centerX-60, centerY+60, 'D');\n    const nE = addNode(centerX+60, centerY+70, 'E');\n    addEdge(nA.id, nB.id, 4);\n    addEdge(nB.id, nC.id, 2);\n    addEdge(nA.id, nD.id, 1.5);\n    addEdge(nD.id, nE.id, 2.5);\n    addEdge(nC.id, nE.id, 3);\n    addEdge(nA.id, nC.id, 6);\n    selectedNodes = [];\n    selectedEdge = null;\n    updateUI();\n    render();\n  }\n\n  // Initialize\n  initExample();\n\n  // keyboard shortcuts\n  window.addEventListener('keydown', (e) => {\n    if (e.key === 'Delete') {\n      if (selectedEdge) deleteEdge(selectedEdge);\n      else if (selectedNodes.length===1) deleteNode(selectedNodes[0]);\n    }\n  });\n\n  // expose some functions for debugging in console (optional)\n  window._graph = { nodes, edges, addNode, addEdge, dijkstra, kruskalMST };\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": false,
  "hasTest": true
}