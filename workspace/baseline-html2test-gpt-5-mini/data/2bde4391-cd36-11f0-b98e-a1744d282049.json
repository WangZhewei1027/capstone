{
  "id": "2bde4391-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:52.663Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Floyd-Warshall Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html>\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Floyd–Warshall Algorithm Visualizer</title>\n  <style>\n    body { font-family: system-ui, -apple-system, Roboto, \"Segoe UI\", Arial; margin: 18px; color:#111 }\n    h1 { margin: 0 0 8px 0; font-size: 22px; }\n    p { margin: 6px 0; color:#333; }\n    .controls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin:12px 0 18px 0; }\n    .controls > * { display:inline-flex; gap:8px; align-items:center; }\n    button { padding:6px 10px; border-radius:6px; border:1px solid #bbb; background:#f8f8f8; cursor:pointer; }\n    button:active { transform:translateY(1px); }\n    input[type=\"number\"] { width:70px; padding:6px; border:1px solid #ccc; border-radius:6px; }\n    label { font-size:13px; color:#333 }\n    .section { margin-top:16px; }\n    .matrices { display:flex; gap:18px; flex-wrap:wrap; }\n    .matrix { border:1px solid #ddd; padding:10px; border-radius:8px; background:#fff; box-shadow: 0 1px 0 rgba(0,0,0,0.02); }\n    table { border-collapse:collapse; }\n    th, td { padding:6px 8px; border:1px solid #eee; text-align:center; min-width:44px; }\n    th { background:#fafafa; color:#222; font-weight:600; }\n    .cell-infty { color:#999; font-style:italic }\n    .cell-zero { color:#2b8cff; font-weight:700 }\n    .compare { background: #fff3bf; }\n    .update { background: #d1f7d7; font-weight:700; }\n    .k-highlight { border:2px solid #ffcc66; padding:4px; border-radius:6px; }\n    .log { max-height:200px; overflow:auto; background:#f9fbff; border:1px solid #eef2ff; padding:8px; border-radius:6px; font-size:13px; color:#222 }\n    .small { font-size:13px; color:#444 }\n    .muted { color:#666; font-size:13px }\n    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }\n    select { padding:6px; border-radius:6px; border:1px solid #ccc; }\n    input[type=\"range\"] { width:120px; }\n    footer { margin-top:18px; color:#555; font-size:13px }\n    .matrix-title { font-weight:700; margin-bottom:8px }\n    .path-output { margin-top:8px; font-weight:600; color:#0b6; }\n    .danger { color:#c44; font-weight:700; }\n  </style>\n</head>\n<body>\n  <h1>Floyd–Warshall Algorithm Visualizer</h1>\n  <p>Interactive demo of the Floyd–Warshall algorithm (all-pairs shortest paths). Edit edges by clicking adjacency cells. Use \"Run\" or step through comparisons to see how distances update. Reconstruct paths after the algorithm completes.</p>\n\n  <div class=\"controls\">\n    <div>\n      <button id=\"addNodeBtn\">Add Node</button>\n      <button id=\"removeNodeBtn\">Remove Node</button>\n      <label><input type=\"checkbox\" id=\"directedToggle\" /> Directed</label>\n    </div>\n\n    <div>\n      <label>Nodes: <span id=\"nodeCount\">4</span></label>\n    </div>\n\n    <div>\n      <label>Random: \n        <input type=\"number\" id=\"randN\" value=\"5\" min=\"2\" max=\"12\" style=\"width:56px\" />\n        density %\n        <input type=\"number\" id=\"randD\" value=\"40\" min=\"0\" max=\"100\" style=\"width:56px\" />\n      </label>\n      <button id=\"randBtn\">Generate</button>\n    </div>\n\n    <div>\n      <button id=\"resetBtn\">Reset Graph</button>\n      <button id=\"runBtn\">Run</button>\n      <button id=\"stepModeBtn\">Step Mode</button>\n      <button id=\"clearStepsBtn\">Clear Steps</button>\n    </div>\n\n    <div>\n      <button id=\"playPauseBtn\">Play</button>\n      <button id=\"stepBackBtn\">◀ Step</button>\n      <button id=\"stepForwardBtn\">Step ▶</button>\n      <label>Speed <input type=\"range\" id=\"speedRange\" min=\"100\" max=\"2000\" value=\"700\" /></label>\n    </div>\n  </div>\n\n  <div class=\"section matrices\">\n    <div class=\"matrix\" style=\"min-width: 320px;\">\n      <div class=\"matrix-title\">Adjacency (click to edit weight)</div>\n      <div id=\"adjacencyContainer\"></div>\n      <div class=\"muted small\" style=\"margin-top:8px;\">Enter a number or 'INF' for no edge. Self-edges allowed (weight on diagonal).</div>\n    </div>\n\n    <div class=\"matrix\" id=\"distMatrixBox\" style=\"min-width:300px;\">\n      <div class=\"matrix-title\">Distance matrix</div>\n      <div id=\"distContainer\"></div>\n    </div>\n\n    <div class=\"matrix\" id=\"nextMatrixBox\" style=\"min-width:300px;\">\n      <div class=\"matrix-title\">Next (for path reconstruction)</div>\n      <div id=\"nextContainer\"></div>\n    </div>\n  </div>\n\n  <div class=\"section\">\n    <div class=\"row\">\n      <div>\n        <label>From: <select id=\"fromSelect\"></select></label>\n        <label>To: <select id=\"toSelect\"></select></label>\n        <button id=\"showPathBtn\">Show Path</button>\n      </div>\n      <div id=\"pathResult\" class=\"path-output\"></div>\n      <div id=\"negCycleNotice\" class=\"danger\"></div>\n    </div>\n  </div>\n\n  <div class=\"section\">\n    <div class=\"matrix\" style=\"flex:1;\">\n      <div class=\"matrix-title\">Step log</div>\n      <div id=\"log\" class=\"log small\"></div>\n    </div>\n  </div>\n\n  <footer>\n    Tip: Start with a small graph (4-6 nodes). Negative edge weights are allowed, but negative cycles break shortest-path assumptions — the demo will highlight if one is detected.\n  </footer>\n\n<script>\n/*\n  Floyd–Warshall Visualizer\n  - Adjacency editable by clicking cells\n  - Run algorithm and record each comparison (k,i,j)\n  - Step through comparisons; visualize compares and updates\n  - Reconstruct paths with 'next' matrix\n*/\n\n(function(){\n  // Helpers\n  const INF = 1e12;\n  const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n  // State\n  let n = 4;\n  let directed = false;\n  let adj = []; // adj matrix with null meaning no edge, otherwise numeric weight\n  let dist = []; // working distance\n  let next = []; // next pointers for reconstruction\n  let steps = []; // recorded steps (each comparison)\n  let stepIndex = -1; // current step applied index ( -1=initial state )\n  let playing = false;\n  let playTimer = null;\n\n  // DOM\n  const adjacencyContainer = document.getElementById('adjacencyContainer');\n  const distContainer = document.getElementById('distContainer');\n  const nextContainer = document.getElementById('nextContainer');\n  const nodeCountLabel = document.getElementById('nodeCount');\n  const fromSelect = document.getElementById('fromSelect');\n  const toSelect = document.getElementById('toSelect');\n  const logEl = document.getElementById('log');\n  const negCycleNotice = document.getElementById('negCycleNotice');\n\n  // Controls\n  document.getElementById('addNodeBtn').onclick = ()=>{ addNode(); renderAll(); };\n  document.getElementById('removeNodeBtn').onclick = ()=>{ removeNode(); renderAll(); };\n  document.getElementById('directedToggle').onchange = (e)=>{ directed = e.target.checked; renderAll(); };\n  document.getElementById('randBtn').onclick = ()=>{ generateRandom(); renderAll(); };\n  document.getElementById('resetBtn').onclick = ()=>{ resetGraph(); renderAll(); };\n  document.getElementById('runBtn').onclick = ()=>{ runFull(); };\n  document.getElementById('stepModeBtn').onclick = ()=>{ prepareSteps(); };\n  document.getElementById('playPauseBtn').onclick = ()=>{ togglePlay(); };\n  document.getElementById('stepForwardBtn').onclick = ()=>{ stepForward(); };\n  document.getElementById('stepBackBtn').onclick = ()=>{ stepBack(); };\n  document.getElementById('clearStepsBtn').onclick = ()=>{ clearSteps(); };\n  document.getElementById('showPathBtn').onclick = ()=>{ showPath(); };\n\n  document.getElementById('randN').addEventListener('keypress', (e)=>{ if(e.key==='Enter') generateRandom(); });\n\n  // Initialization\n  function init(){\n    // default small example\n    directed = false;\n    n = 4;\n    adj = Array.from({length:n}, ()=>Array.from({length:n}, ()=>null));\n    // sample edges\n    setEdge(0,1,5);\n    setEdge(0,3,10);\n    setEdge(1,2,3);\n    setEdge(2,3,1);\n    updateUIState();\n    renderAll();\n  }\n\n  function updateUIState(){\n    nodeCountLabel.textContent = n;\n    document.getElementById('directedToggle').checked = directed;\n    // update selects\n    populateNodeSelectors();\n  }\n\n  function populateNodeSelectors(){\n    fromSelect.innerHTML = ''; toSelect.innerHTML = '';\n    for(let i=0;i<n;i++){\n      const opt = document.createElement('option'); opt.value = i; opt.textContent = getLabel(i);\n      fromSelect.appendChild(opt);\n      const opt2 = document.createElement('option'); opt2.value = i; opt2.textContent = getLabel(i);\n      toSelect.appendChild(opt2);\n    }\n  }\n\n  function getLabel(i){ return letters[i] || ('N'+i); }\n\n  function setEdge(i,j,w){\n    if(w===null) adj[i][j]=null;\n    else adj[i][j]=Number(w);\n  }\n\n  function addNode(){\n    if(n>=12){ alert('Max nodes: 12'); return; }\n    adj.forEach(row=>row.push(null));\n    n++;\n    adj.push(Array.from({length:n}, ()=>null));\n    // keep symmetric edges if undirected: add new node with no edges\n    updateUIState();\n    clearSteps();\n  }\n\n  function removeNode(){\n    if(n<=2){ alert('Minimum 2 nodes'); return; }\n    adj.splice(n-1,1);\n    adj.forEach(row=>row.splice(n-1,1));\n    n--;\n    updateUIState();\n    clearSteps();\n  }\n\n  function resetGraph(){\n    adj = Array.from({length:n}, ()=>Array.from({length:n}, ()=>null));\n    clearSteps();\n  }\n\n  function generateRandom(){\n    const nn = Math.max(2, Math.min(12, parseInt(document.getElementById('randN').value)||n));\n    const density = Math.max(0, Math.min(100, parseInt(document.getElementById('randD').value)||40));\n    n = nn;\n    adj = Array.from({length:n}, ()=>Array.from({length:n}, ()=>null));\n    for(let i=0;i<n;i++){\n      for(let j=0;j<n;j++){\n        if(i===j) continue;\n        if(Math.random()*100 < density){\n          // weight between -5 and 15 with bias positive\n          const w = Math.floor(Math.random()*21)-5;\n          adj[i][j] = w;\n          if(!directed) adj[j][i] = w;\n        }\n      }\n    }\n    updateUIState();\n    clearSteps();\n  }\n\n  // Rendering functions\n  function renderAll(){\n    renderAdjacency();\n    // initial dist/next derived from adj\n    initDistNext();\n    renderDist();\n    renderNext();\n    logEl.innerHTML = '';\n    negCycleNotice.textContent = '';\n  }\n\n  function renderAdjacency(){\n    const table = document.createElement('table');\n    const thead = document.createElement('thead');\n    const headRow = document.createElement('tr');\n    headRow.appendChild(document.createElement('th')); // corner\n    for(let j=0;j<n;j++){\n      const th = document.createElement('th'); th.textContent = getLabel(j); headRow.appendChild(th);\n    }\n    thead.appendChild(headRow);\n    table.appendChild(thead);\n\n    const tbody = document.createElement('tbody');\n    for(let i=0;i<n;i++){\n      const tr = document.createElement('tr');\n      const th = document.createElement('th'); th.textContent = getLabel(i); tr.appendChild(th);\n      for(let j=0;j<n;j++){\n        const td = document.createElement('td');\n        td.style.cursor = 'pointer';\n        td.addEventListener('click', ()=>{ editEdge(i,j); });\n        const w = adj[i][j];\n        td.innerHTML = (w===null ? '<span class=\"cell-infty\">∞</span>' : (w===0 ? '<span class=\"cell-zero\">0</span>' : String(w)));\n        tr.appendChild(td);\n      }\n      tbody.appendChild(tr);\n    }\n    table.appendChild(tbody);\n    adjacencyContainer.innerHTML = '';\n    adjacencyContainer.appendChild(table);\n  }\n\n  function editEdge(i,j){\n    const cur = adj[i][j];\n    let val = prompt(`Set weight for edge ${getLabel(i)} → ${getLabel(j)}\\nEnter number or leave empty / 'INF' to remove edge.`, cur===null ? 'INF' : String(cur));\n    if(val===null) return;\n    val = val.trim();\n    if(val.toUpperCase()==='INF' || val==='') {\n      adj[i][j] = null;\n      if(!directed) adj[j][i] = null;\n    } else {\n      const num = Number(val);\n      if(Number.isNaN(num)){ alert('Invalid number'); return; }\n      adj[i][j] = num;\n      if(!directed) adj[j][i] = num;\n    }\n    clearSteps();\n    renderAll();\n  }\n\n  function initDistNext(){\n    dist = Array.from({length:n}, (_,i)=>Array.from({length:n}, (_,j)=>{\n      if(i===j) return 0;\n      if(adj[i][j]===null) return INF;\n      return Number(adj[i][j]);\n    }));\n    next = Array.from({length:n}, (_,i)=>Array.from({length:n}, (_,j)=>{\n      if(i===j) return j; // convention: path from i to i exists via i\n      return (adj[i][j]===null ? null : j);\n    }));\n  }\n\n  function renderDist(highlight={i:-1,j:-1,k:-1,updated:false}){\n    const table = document.createElement('table');\n    const thead = document.createElement('thead');\n    const headRow = document.createElement('tr'); headRow.appendChild(document.createElement('th'));\n    for(let j=0;j<n;j++){ const th = document.createElement('th'); th.textContent = getLabel(j); headRow.appendChild(th); }\n    thead.appendChild(headRow); table.appendChild(thead);\n\n    const tbody = document.createElement('tbody');\n    for(let i=0;i<n;i++){\n      const tr = document.createElement('tr');\n      const th = document.createElement('th'); th.textContent = getLabel(i); tr.appendChild(th);\n      for(let j=0;j<n;j++){\n        const td = document.createElement('td');\n        const val = dist[i][j];\n        if(i===j && val===0) td.innerHTML = '<span class=\"cell-zero\">0</span>';\n        else if(val >= INF/2) td.innerHTML = '<span class=\"cell-infty\">∞</span>';\n        else td.textContent = val.toString();\n        if(i===highlight.i && j===highlight.j){\n          td.classList.add(highlight.updated ? 'update' : 'compare');\n        }\n        tr.appendChild(td);\n      }\n      tbody.appendChild(tr);\n    }\n    table.appendChild(tbody);\n    distContainer.innerHTML = '';\n    distContainer.appendChild(table);\n    // show current k highlight\n    if(highlight.k>=0){\n      const title = document.createElement('div'); title.className='muted small';\n      title.innerHTML = `Current k = ${getLabel(highlight.k)} (${highlight.k})`;\n      distContainer.insertBefore(title, distContainer.firstChild);\n    }\n  }\n\n  function renderNext(highlight={i:-1,j:-1,k:-1,updated:false}){\n    const table = document.createElement('table');\n    const thead = document.createElement('thead');\n    const headRow = document.createElement('tr'); headRow.appendChild(document.createElement('th'));\n    for(let j=0;j<n;j++){ const th = document.createElement('th'); th.textContent = getLabel(j); headRow.appendChild(th); }\n    thead.appendChild(headRow); table.appendChild(thead);\n\n    const tbody = document.createElement('tbody');\n    for(let i=0;i<n;i++){\n      const tr = document.createElement('tr');\n      const th = document.createElement('th'); th.textContent = getLabel(i); tr.appendChild(th);\n      for(let j=0;j<n;j++){\n        const td = document.createElement('td');\n        const nx = next[i][j];\n        td.textContent = (nx===null ? '—' : getLabel(nx));\n        if(i===highlight.i && j===highlight.j) td.classList.add(highlight.updated ? 'update' : 'compare');\n        tr.appendChild(td);\n      }\n      tbody.appendChild(tr);\n    }\n    table.appendChild(tbody);\n    nextContainer.innerHTML = '';\n    nextContainer.appendChild(table);\n  }\n\n  // Floyd–Warshall with step recording\n  function prepareSteps(){\n    initDistNext();\n    steps = [];\n    // Save initial snapshot as step -1? We'll use stepIndex -1 as initial state\n    // Loop\n    for(let k=0;k<n;k++){\n      for(let i=0;i<n;i++){\n        for(let j=0;j<n;j++){\n          const a = dist[i][k];\n          const b = dist[k][j];\n          const old = dist[i][j];\n          const alt = (a >= INF/2 || b >= INF/2) ? INF : a + b;\n          const updated = alt < old - 1e-9;\n          const step = {\n            k, i, j,\n            old, alt,\n            updated,\n            nextBefore: next[i][j],\n            nextFromIK: next[i][k] // if update, next[i][j] becomes next[i][k]\n          };\n          steps.push(step);\n          if(updated){\n            // apply immediately to our base dist/next so subsequent comparisons use new values\n            dist[i][j] = alt;\n            next[i][j] = next[i][k];\n          }\n        }\n      }\n    }\n    // After finishing, detect negative cycles and record as final step\n    const negCycles = [];\n    for(let v=0;v<n;v++){\n      if(dist[v][v] < 0) negCycles.push(v);\n    }\n    steps.push({type:'complete', neg: negCycles});\n    // Reset dist/next to initial for playback\n    initDistNext();\n    stepIndex = -1;\n    renderDist(); renderNext();\n    logEl.innerHTML = '';\n    negCycleNotice.textContent = '';\n    appendLog(`Prepared ${steps.length} steps. Use Step or Play to advance through comparisons.`);\n  }\n\n  function runFull(){\n    initDistNext();\n    // run entire algorithm (no recording)\n    for(let k=0;k<n;k++){\n      for(let i=0;i<n;i++){\n        for(let j=0;j<n;j++){\n          if(dist[i][k] >= INF/2 || dist[k][j] >= INF/2) continue;\n          const alt = dist[i][k] + dist[k][j];\n          if(alt < dist[i][j]){\n            dist[i][j] = alt;\n            next[i][j] = next[i][k];\n          }\n        }\n      }\n    }\n    renderDist(); renderNext();\n    // detect negative cycles\n    const negCycles = [];\n    for(let v=0;v<n;v++) if(dist[v][v] < 0) negCycles.push(v);\n    if(negCycles.length) {\n      negCycleNotice.textContent = 'Negative cycle detected at nodes: ' + negCycles.map(getLabel).join(', ');\n      appendLog('Run complete — negative cycle detected.');\n    } else {\n      negCycleNotice.textContent = '';\n      appendLog('Run complete. No negative cycles detected.');\n    }\n    // set steps to none (we ran full)\n    steps = [];\n    stepIndex = -1;\n  }\n\n  // Step playback\n  function clearSteps(){\n    steps = [];\n    stepIndex = -1;\n    playing = false;\n    if(playTimer) clearInterval(playTimer);\n    playTimer = null;\n    appendLog('Cleared recorded steps.');\n    initDistNext();\n    renderDist(); renderNext();\n    negCycleNotice.textContent = '';\n  }\n\n  function applyStep(idx){\n    // apply step at index idx (0-based) to current dist/next; stepIndex points to last applied\n    if(idx < -1) return;\n    initDistNext();\n    // apply all steps up to idx\n    for(let s=0;s<=idx && s<steps.length; s++){\n      const step = steps[s];\n      if(step.type === 'complete') break;\n      if(step.updated){\n        dist[step.i][step.j] = step.alt;\n        next[step.i][step.j] = step.nextFromIK;\n      }\n    }\n    // Render highlighting for the next compared cell (current step)\n    const highlight = (idx+1 < steps.length && idx+1>=0 && steps[idx+1].type!=='complete') ? {\n      i: steps[idx+1].i,\n      j: steps[idx+1].j,\n      k: steps[idx+1].k,\n      updated: (idx>=0 && idx<steps.length && steps[idx].updated) // show last applied update style\n    } : {i:-1,j:-1,k:-1,updated:false};\n    renderDist(highlight);\n    renderNext(highlight);\n  }\n\n  function stepForward(){\n    if(steps.length===0){ appendLog('No recorded steps. Click \"Step Mode\" to prepare steps.'); return; }\n    if(stepIndex >= steps.length-1) { appendLog('Already at the end.'); playing=false; return; }\n    stepIndex++;\n    const step = steps[stepIndex];\n    if(step.type === 'complete'){\n      // apply final complete snapshot (dist already computed in our prepareSteps app; but for playback we've re-applied above)\n      // detect negative cycles now\n      const neg = step.neg || [];\n      if(neg.length) {\n        negCycleNotice.textContent = 'Negative cycle detected at nodes: ' + neg.map(getLabel).join(', ');\n        appendLog('Complete: Negative cycle detected at ' + neg.map(getLabel).join(', '));\n      } else {\n        appendLog('Complete: No negative cycles detected.');\n      }\n      applyStep(stepIndex-1);\n      return;\n    }\n    // apply up to stepIndex\n    applyStep(stepIndex);\n    // log this comparison\n    const msg = `k=${getLabel(step.k)} (${step.k}) compare i=${getLabel(step.i)} → j=${getLabel(step.j)}: old=${(step.old>=INF/2?'∞':step.old)} alt=${(step.alt>=INF/2?'∞':step.alt)} ${step.updated? ' → UPDATED' : ''}`;\n    appendLog(msg);\n  }\n\n  function stepBack(){\n    if(steps.length===0){ appendLog('No recorded steps.'); return; }\n    if(stepIndex <= -1){ appendLog('Already at the start.'); return; }\n    stepIndex--;\n    applyStep(stepIndex);\n    appendLog('Stepped back. (stepIndex=' + stepIndex + ')');\n  }\n\n  function togglePlay(){\n    if(playing){ stopPlay(); return; }\n    if(steps.length===0){ appendLog('No recorded steps. Prepare steps first.'); return; }\n    playing = true;\n    document.getElementById('playPauseBtn').textContent = 'Pause';\n    const speed = Number(document.getElementById('speedRange').value);\n    playTimer = setInterval(()=>{\n      if(stepIndex >= steps.length-1){ stopPlay(); return; }\n      stepForward();\n    }, speed);\n  }\n\n  function stopPlay(){\n    playing = false;\n    document.getElementById('playPauseBtn').textContent = 'Play';\n    if(playTimer) clearInterval(playTimer);\n    playTimer = null;\n  }\n\n  function togglePlayPauseUI(){\n    if(playing) document.getElementById('playPauseBtn').textContent = 'Pause';\n    else document.getElementById('playPauseBtn').textContent = 'Play';\n  }\n\n  function appendLog(msg){\n    const time = new Date().toLocaleTimeString();\n    const p = document.createElement('div'); p.textContent = `[${time}] ${msg}`;\n    logEl.appendChild(p);\n    logEl.scrollTop = logEl.scrollHeight;\n  }\n\n  // Path reconstruction using 'next' matrix (note: only valid after running the algorithm to completion)\n  function reconstructPath(u,v){\n    if(next[u][v] === null) return null;\n    const path = [u];\n    let cur = u;\n    const seen = new Set([u]);\n    while(cur !== v){\n      cur = next[cur][v];\n      if(cur === null) return null;\n      if(seen.has(cur)){ // cycle prevention\n        return null;\n      }\n      path.push(cur);\n      seen.add(cur);\n      if(path.length > n+5) return null;\n    }\n    return path;\n  }\n\n  function showPath(){\n    // Ensure we have final dist/next: if steps exist and not completed, we should either run full or apply final\n    if(steps.length>0 && (stepIndex === -1 || stepIndex < steps.length-1)){\n      if(!confirm('Path reconstruction requires the final completed matrices. Do you want to run the full algorithm now (this will overwrite step playback)?')) return;\n      runFull();\n    }\n    const u = Number(fromSelect.value);\n    const v = Number(toSelect.value);\n    if(u===v){ document.getElementById('pathResult').textContent = `Trivial path: ${getLabel(u)} (distance 0)`; return; }\n    if(next[u][v] === null){ document.getElementById('pathResult').textContent = `No path from ${getLabel(u)} to ${getLabel(v)}`; return; }\n    const path = reconstructPath(u,v);\n    if(!path){ document.getElementById('pathResult').textContent = `Could not reconstruct path (possible negative cycle or corrupted 'next' matrix).`; return; }\n    const distVal = dist[u][v] >= INF/2 ? '∞' : dist[u][v];\n    document.getElementById('pathResult').textContent = `${path.map(getLabel).join(' → ')} (distance ${distVal})`;\n  }\n\n  // Initialize UI events for speed range and others\n  document.getElementById('speedRange').addEventListener('input', ()=>{\n    if(playing){\n      stopPlay();\n      togglePlay(); // restart with new speed\n    }\n  });\n\n  // Kick off\n  init();\n\n  // Expose some functions to console for debugging (optional)\n  window.FW = {\n    getAdj: ()=>adj,\n    runFull, prepareSteps, stepForward, stepBack, steps\n  };\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Floyd-Warshall Algorithm"
    }
  ],
  "topic": "Floyd-Warshall Algorithm",
  "hasFSM": false,
  "hasTest": true
}