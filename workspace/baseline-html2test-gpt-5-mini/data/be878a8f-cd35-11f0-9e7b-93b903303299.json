{
  "id": "be878a8f-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:57.712Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Depth-First Search (DFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>Depth-First Search (DFS) Visualizer</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, Arial; margin: 0; display:flex; height:100vh; }\n  #left { width: 68%; background: #f7f9fc; padding: 12px; box-sizing: border-box; display:flex; flex-direction:column; gap:8px; }\n  #canvasWrap { flex:1; border: 1px solid #ddd; background: #fff; position: relative; overflow:hidden; border-radius:6px; }\n  canvas { width:100%; height:100%; display:block; }\n  #controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\n  .btn { padding:8px 10px; border-radius:6px; border:1px solid #cfd8e3; background:#fff; cursor:pointer; }\n  .btn.primary { background:#2b8cff; color:#fff; border-color:#267de6; }\n  .btn.danger { background:#ff6b6b; color:#fff; border-color:#ff4c4c; }\n  label { font-size:13px; color:#333; margin-right:6px; }\n  input[type=range] { width:120px; }\n  #right { width:32%; border-left:1px solid #e6eef7; padding:12px; box-sizing:border-box; overflow:auto; background:#fbfdff; }\n  h3 { margin:6px 0 8px 0; font-size:15px; }\n  .panel { background:#fff; border:1px solid #e6eef7; padding:10px; border-radius:8px; margin-bottom:10px; }\n  .small { font-size:13px; color:#444; }\n  ul { padding-left:20px; margin:6px 0; }\n  .badge { display:inline-block; padding:3px 7px; border-radius:999px; background:#f0f4ff; color:#234; font-weight:600; font-size:12px; margin-right:6px; }\n  table { width:100%; border-collapse:collapse; font-size:13px; }\n  td, th { border-bottom:1px solid #f0f4ff; padding:6px; text-align:left; }\n  .legend { display:flex; gap:8px; align-items:center; margin-top:6px; }\n  .legend .box { width:16px; height:12px; border-radius:3px; display:inline-block; margin-right:6px; border:1px solid #ddd;}\n  .node-white { background:#fff; }\n  .node-gray { background:#ffd97a; }\n  .node-black { background:#8fd3a8; }\n  #adjList { font-family: monospace; background:#fbfbff; padding:8px; border-radius:6px; border:1px dashed #eef; }\n  #status { font-size:13px; color:#333; margin-top:6px; }\n  .controls-col { display:flex; gap:8px; flex-direction:column; }\n  .muted { color:#666; font-size:13px; }\n  .smallBtn { padding:6px 8px; font-size:13px; border-radius:6px; border:1px solid #e0e7f0; background:#fff; cursor:pointer; }\n  select { padding:6px; border-radius:6px; border:1px solid #dfe7f3; background:white; }\n</style>\n</head>\n<body>\n<div id=\"left\">\n  <div style=\"display:flex; align-items:center; justify-content:space-between; gap:10px;\">\n    <div>\n      <h2 style=\"margin:0 0 6px 0;\">Depth-First Search (DFS) Visualizer</h2>\n      <div class=\"small muted\">Click empty space to add nodes. Click a node to select a source, then click another node to add an edge. Drag a node to move it. Toggle directed/undirected graphs.</div>\n    </div>\n    <div style=\"text-align:right\">\n      <div class=\"muted small\">Nodes: <span id=\"nodeCount\">0</span>  Edges: <span id=\"edgeCount\">0</span></div>\n    </div>\n  </div>\n\n  <div id=\"controls\" class=\"panel\">\n    <button class=\"btn\" id=\"clearBtn\">Clear All</button>\n    <button class=\"btn\" id=\"randBtn\">Random Graph</button>\n    <button class=\"btn\" id=\"toggleDirBtn\">Mode: Undirected</button>\n\n    <div style=\"width:8px;\"></div>\n\n    <label for=\"startSelect\">Start:</label>\n    <select id=\"startSelect\"></select>\n\n    <div style=\"width:6px;\"></div>\n\n    <button class=\"btn primary\" id=\"runRecBtn\">Run Recursive DFS</button>\n    <button class=\"btn primary\" id=\"runIterBtn\">Run Iterative DFS</button>\n\n    <div style=\"width:6px;\"></div>\n\n    <button class=\"btn\" id=\"stepBtn\">Step</button>\n    <button class=\"btn\" id=\"playBtn\">Play</button>\n    <button class=\"btn\" id=\"resetTraverseBtn\">Reset Traversal</button>\n\n    <label style=\"margin-left:auto\">Speed\n      <input id=\"speedRange\" type=\"range\" min=\"50\" max=\"2000\" step=\"50\" value=\"500\">\n    </label>\n  </div>\n\n  <div id=\"canvasWrap\">\n    <canvas id=\"canvas\"></canvas>\n  </div>\n\n  <div style=\"display:flex; gap:8px; margin-top:8px;\">\n    <div class=\"panel\" style=\"flex:1;\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n        <h3>Traversal</h3>\n        <div class=\"muted small\">Time: <span id=\"timeCounter\">0</span></div>\n      </div>\n      <div id=\"status\">Press Run to start. You can also Step through the algorithm.</div>\n      <div style=\"margin-top:8px;\">\n        <strong>Order visited:</strong> <span id=\"visitedOrder\"></span>\n      </div>\n    </div>\n\n    <div class=\"panel\" style=\"width:320px;\">\n      <h3>Stack / Call Stack</h3>\n      <div id=\"stackView\" class=\"muted small\">[empty]</div>\n      <div style=\"margin-top:8px;\"><strong>Algorithm choice:</strong> <span id=\"algoChoice\">None</span></div>\n      <div style=\"margin-top:6px;\"><button class=\"smallBtn\" id=\"explainBtn\">Show Short Explanation</button></div>\n    </div>\n  </div>\n</div>\n\n<div id=\"right\">\n  <div class=\"panel\">\n    <h3>Adjacency List</h3>\n    <div id=\"adjList\" class=\"small\"></div>\n    <div class=\"legend\" style=\"margin-top:8px;\">\n      <div><span class=\"box node-white\" style=\"border:1px solid #bbb;\"></span> Unvisited</div>\n      <div><span class=\"box node-gray\"></span> In progress</div>\n      <div><span class=\"box node-black\"></span> Finished</div>\n    </div>\n  </div>\n\n  <div class=\"panel\">\n    <h3>Discovery & Finish Times</h3>\n    <div style=\"max-height:220px; overflow:auto;\">\n      <table id=\"timesTable\"><thead><tr><th>Node</th><th>Disc</th><th>Finish</th></tr></thead><tbody></tbody></table>\n    </div>\n  </div>\n\n  <div class=\"panel\">\n    <h3>Notes</h3>\n    <ul class=\"small\">\n      <li>DFS explores as deep as possible along each branch before backtracking.</li>\n      <li>Use \"Recursive\" to see the natural recursion stack, or \"Iterative\" to see an explicit stack simulation.</li>\n      <li>Discovery time when a node is first visited; finish time when all descendants are fully explored.</li>\n    </ul>\n  </div>\n</div>\n\n<script>\n(function(){\n  // Canvas & graph data\n  const canvas = document.getElementById('canvas');\n  const wrap = document.getElementById('canvasWrap');\n  const ctx = canvas.getContext('2d');\n  const DPR = window.devicePixelRatio || 1;\n\n  let width, height;\n  function resize() {\n    width = wrap.clientWidth;\n    height = wrap.clientHeight;\n    canvas.width = Math.floor(width * DPR);\n    canvas.height = Math.floor(height * DPR);\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n    ctx.setTransform(DPR,0,0,DPR,0,0);\n    draw();\n  }\n  window.addEventListener('resize', resize);\n  resize();\n\n  // Graph structures\n  let nodes = []; // {id,label,x,y,r,...}\n  let edges = []; // {from,to}\n  let directed = false;\n  let nextLabelCharCode = 65; // A...\n  const NODE_RADIUS = 22;\n\n  // Traversal state\n  let visited = {}; // color: 0 white, 1 gray, 2 black\n  let disc = {}, finish = {}, timeCounter = 0;\n  let currentAlgo = null; // 'recursive'|'iterative'\n  let generator = null;\n  let playing = false;\n  let playTimer = null;\n  let speed = 500;\n\n  // Interaction\n  let selectedNode = null; // for edge creation\n  let dragging = null;\n  let dragOffset = {x:0,y:0};\n\n  // UI elements\n  const nodeCountEl = document.getElementById('nodeCount');\n  const edgeCountEl = document.getElementById('edgeCount');\n  const startSelect = document.getElementById('startSelect');\n  const visitedOrderEl = document.getElementById('visitedOrder');\n  const statusEl = document.getElementById('status');\n  const stackView = document.getElementById('stackView');\n  const adjListEl = document.getElementById('adjList');\n  const timesTableBody = document.querySelector('#timesTable tbody');\n  const timeCounterEl = document.getElementById('timeCounter');\n  const algoChoiceEl = document.getElementById('algoChoice');\n  const speedRange = document.getElementById('speedRange');\n\n  // Buttons\n  document.getElementById('clearBtn').onclick = clearAll;\n  document.getElementById('randBtn').onclick = randomGraph;\n  document.getElementById('toggleDirBtn').onclick = toggleDirected;\n  document.getElementById('runRecBtn').onclick = ()=>startDFS('recursive');\n  document.getElementById('runIterBtn').onclick = ()=>startDFS('iterative');\n  document.getElementById('stepBtn').onclick = stepOnce;\n  document.getElementById('playBtn').onclick = togglePlay;\n  document.getElementById('resetTraverseBtn').onclick = resetTraversal;\n  document.getElementById('explainBtn').onclick = ()=> alert(\n    \"Depth-First Search (DFS):\\n\\n\" +\n    \"- Start at a chosen node.\\n\" +\n    \"- Mark node as visited and explore each neighbor recursively (or using an explicit stack) before moving to the next neighbor.\\n\" +\n    \"- Discovery time: when you first see a node. Finish time: after exploring all its descendants.\\n\\nUse this visualizer to step through and watch the recursion/stack behavior.\"\n  );\n  speedRange.oninput = ()=> { speed = Number(speedRange.value); if (playing) restartPlayTimer(); };\n\n  // Canvas events\n  canvas.addEventListener('mousedown', onDown);\n  canvas.addEventListener('mousemove', onMove);\n  canvas.addEventListener('mouseup', onUp);\n  canvas.addEventListener('mouseleave', onUp);\n  canvas.addEventListener('dblclick', onDoubleClick);\n\n  function getMouse(e) {\n    const rect = canvas.getBoundingClientRect();\n    return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  }\n\n  function findNodeAt(x,y) {\n    for (let i=nodes.length-1;i>=0;i--) {\n      const n = nodes[i];\n      const dx = x - n.x, dy = y - n.y;\n      if (Math.hypot(dx,dy) <= NODE_RADIUS+2) return n;\n    }\n    return null;\n  }\n\n  function onDown(e) {\n    const m = getMouse(e);\n    const n = findNodeAt(m.x,m.y);\n    if (n) {\n      // click on node: select for edge or start dragging\n      if (selectedNode && selectedNode !== n) {\n        // create edge from selectedNode -> n\n        addEdge(selectedNode.id, n.id);\n        selectedNode = null;\n        draw();\n        updateUI();\n        return;\n      }\n      // no selected source: select node as source for edge or start drag\n      selectedNode = n;\n      dragging = n;\n      dragOffset.x = m.x - n.x;\n      dragOffset.y = m.y - n.y;\n      draw();\n    } else {\n      // clicked empty: create new node\n      createNode(m.x,m.y);\n      updateUI();\n    }\n  }\n\n  function onMove(e) {\n    if (!dragging) return;\n    const m = getMouse(e);\n    dragging.x = m.x - dragOffset.x;\n    dragging.y = m.y - dragOffset.y;\n    draw();\n  }\n\n  function onUp(e) {\n    if (!dragging) {\n      // clear selection if click on empty area\n      // (but keep selectedNode if we just selected for edge creation)\n      return;\n    }\n    dragging = null;\n  }\n\n  function onDoubleClick(e) {\n    // double-click on node to remove it\n    const m = getMouse(e);\n    const n = findNodeAt(m.x,m.y);\n    if (n) {\n      removeNode(n.id);\n      updateUI();\n    }\n  }\n\n  function createNode(x,y) {\n    const label = String.fromCharCode(nextLabelCharCode++);\n    nodes.push({ id:label, label, x, y, r:NODE_RADIUS });\n    updateUI();\n    draw();\n  }\n\n  function removeNode(id) {\n    nodes = nodes.filter(n=>n.id!==id);\n    edges = edges.filter(e=>e.from!==id && e.to!==id);\n    updateUI();\n    draw();\n  }\n\n  function addEdge(a,b) {\n    // avoid duplicates\n    if (edges.some(e=>e.from===a && e.to===b)) return;\n    edges.push({ from:a, to:b });\n    updateUI();\n  }\n\n  function clearAll() {\n    nodes = []; edges = []; selectedNode=null; nextLabelCharCode = 65;\n    resetTraversal();\n    updateUI();\n    draw();\n  }\n\n  function randomGraph() {\n    clearAll();\n    // generate 6-10 nodes\n    const n = 6 + Math.floor(Math.random()*5);\n    const padding = 50;\n    for (let i=0;i<n;i++) {\n      const x = padding + Math.random()*(width-2*padding);\n      const y = padding + Math.random()*(height-2*padding);\n      createNode(x,y);\n    }\n    // add random edges\n    const nodeIds = nodes.map(x=>x.id);\n    for (let i=0;i<n*1.6;i++) {\n      const a = nodeIds[Math.floor(Math.random()*nodeIds.length)];\n      const b = nodeIds[Math.floor(Math.random()*nodeIds.length)];\n      if (a!==b) addEdge(a,b);\n    }\n    updateUI();\n    draw();\n  }\n\n  function toggleDirected() {\n    directed = !directed;\n    document.getElementById('toggleDirBtn').textContent = 'Mode: ' + (directed? 'Directed':'Undirected');\n    updateUI();\n    draw();\n  }\n\n  function updateUI() {\n    nodeCountEl.textContent = nodes.length;\n    edgeCountEl.textContent = edges.length;\n    // start select\n    startSelect.innerHTML = '';\n    nodes.forEach(n=>{\n      const opt = document.createElement('option');\n      opt.value = n.id;\n      opt.textContent = n.id;\n      startSelect.appendChild(opt);\n    });\n    // adjacency list\n    const adj = buildAdjacency();\n    let html = '';\n    nodes.forEach(n=>{\n      const arr = adj[n.id] || [];\n      html += `<div><strong>${n.id}</strong>: ${arr.join(', ')}</div>`;\n    });\n    adjListEl.innerHTML = html || '<div class=\"muted\">Graph empty</div>';\n    // times table\n    rebuildTimesTable();\n  }\n\n  function buildAdjacency() {\n    const adj = {};\n    nodes.forEach(n=>adj[n.id]=[]);\n    edges.forEach(e=>{\n      adj[e.from].push(e.to);\n      if (!directed) {\n        if (!adj[e.to].includes(e.from)) adj[e.to].push(e.from);\n      }\n    });\n    // sort neighbors for deterministic behavior\n    for (const k in adj) adj[k].sort();\n    return adj;\n  }\n\n  function draw() {\n    ctx.clearRect(0,0,width,height);\n    // edges\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = '#b8c8db';\n    ctx.fillStyle = '#b8c8db';\n    for (const e of edges) {\n      const a = nodes.find(n=>n.id===e.from);\n      const b = nodes.find(n=>n.id===e.to);\n      if (!a || !b) continue;\n      drawEdge(a,b,e);\n    }\n    // nodes\n    for (const n of nodes) {\n      drawNode(n);\n    }\n    // selected node indicator\n    if (selectedNode) {\n      ctx.beginPath();\n      ctx.strokeStyle = '#2b8cff';\n      ctx.lineWidth = 2;\n      ctx.arc(selectedNode.x, selectedNode.y, NODE_RADIUS+6, 0, Math.PI*2);\n      ctx.stroke();\n    }\n  }\n\n  function drawEdge(a,b,e) {\n    const dx = b.x - a.x, dy = b.y - a.y;\n    const angle = Math.atan2(dy,dx);\n    const ax = a.x + Math.cos(angle)*NODE_RADIUS;\n    const ay = a.y + Math.sin(angle)*NODE_RADIUS;\n    const bx = b.x - Math.cos(angle)*NODE_RADIUS;\n    const by = b.y - Math.sin(angle)*NODE_RADIUS;\n    ctx.beginPath();\n    ctx.strokeStyle = '#b8c8db';\n    ctx.lineWidth = 2;\n    ctx.moveTo(ax,ay);\n    ctx.lineTo(bx,by);\n    ctx.stroke();\n\n    if (directed) {\n      // arrowhead\n      const size = 8;\n      ctx.beginPath();\n      ctx.fillStyle = '#b8c8db';\n      ctx.moveTo(bx,by);\n      ctx.lineTo(bx - Math.cos(angle-Math.PI/8)*size, by - Math.sin(angle-Math.PI/8)*size);\n      ctx.lineTo(bx - Math.cos(angle+Math.PI/8)*size, by - Math.sin(angle+Math.PI/8)*size);\n      ctx.closePath();\n      ctx.fill();\n    }\n  }\n\n  function drawNode(n) {\n    const col = visited[n.id] === undefined || visited[n.id]===0 ? '#fff' : (visited[n.id]===1 ? '#ffd97a' : '#8fd3a8');\n    // circle\n    ctx.beginPath();\n    ctx.fillStyle = col;\n    ctx.strokeStyle = '#7c8da1';\n    ctx.lineWidth = 2;\n    ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI*2);\n    ctx.fill();\n    ctx.stroke();\n    // label\n    ctx.fillStyle = '#102b4a';\n    ctx.font = 'bold 16px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(n.label, n.x, n.y);\n    // discovery/finish small\n    const d = disc[n.id] || '';\n    const f = finish[n.id] || '';\n    ctx.fillStyle = '#385170';\n    ctx.font = '11px monospace';\n    ctx.textAlign = 'left';\n    ctx.fillText(`d:${d}`, n.x - NODE_RADIUS+6, n.y + NODE_RADIUS-6);\n    ctx.textAlign = 'right';\n    ctx.fillText(`f:${f}`, n.x + NODE_RADIUS-6, n.y + NODE_RADIUS-6);\n  }\n\n  // Traversal & generators\n  function resetTraversal() {\n    visited = {};\n    disc = {}; finish = {};\n    timeCounter = 0;\n    visitedOrderEl.textContent = '';\n    statusEl.textContent = 'Traversal reset.';\n    stackView.textContent = '[empty]';\n    timeCounterEl.textContent = '0';\n    algoChoiceEl.textContent = 'None';\n    generator = null;\n    playing = false;\n    if (playTimer) { clearInterval(playTimer); playTimer = null; document.getElementById('playBtn').textContent = 'Play'; }\n    updateUI();\n    draw();\n  }\n\n  function startDFS(mode) {\n    if (nodes.length===0) { alert('Graph is empty. Add nodes first.'); return; }\n    resetTraversal();\n    currentAlgo = mode;\n    algoChoiceEl.textContent = mode === 'recursive' ? 'Recursive DFS' : 'Iterative DFS';\n    const start = startSelect.value || nodes[0].id;\n    const adj = buildAdjacency();\n    if (!adj[start] || adj[start].length===0) {\n      // still allow\n    }\n    if (mode === 'recursive') {\n      generator = recursiveDFSSteps(start, adj);\n    } else {\n      generator = iterativeDFSSteps(start, adj);\n    }\n    statusEl.textContent = `Ready. ${mode==='recursive' ? 'Recursive' : 'Iterative'} DFS prepared starting at ${start}. Use Step or Play.`;\n    // show initial draw\n    draw();\n  }\n\n  function stepOnce() {\n    if (!generator) {\n      statusEl.textContent = 'No algorithm running. Click Run to start.';\n      return;\n    }\n    const res = generator.next();\n    if (res.done) {\n      statusEl.textContent = 'Traversal complete.';\n      generator = null;\n      playing = false;\n      if (playTimer) { clearInterval(playTimer); playTimer = null; document.getElementById('playBtn').textContent = 'Play'; }\n      draw(); updateUI();\n      return;\n    }\n    applyStep(res.value);\n    draw(); updateUI();\n  }\n\n  function togglePlay() {\n    if (!generator) {\n      statusEl.textContent = 'No algorithm prepared. Click Run to start.';\n      return;\n    }\n    playing = !playing;\n    document.getElementById('playBtn').textContent = playing ? 'Pause' : 'Play';\n    if (playing) {\n      restartPlayTimer();\n    } else {\n      if (playTimer) { clearInterval(playTimer); playTimer = null; }\n    }\n  }\n\n  function restartPlayTimer() {\n    if (playTimer) clearInterval(playTimer);\n    playTimer = setInterval(()=>{\n      if (!generator) { clearInterval(playTimer); playTimer=null; playing=false; document.getElementById('playBtn').textContent='Play'; return; }\n      stepOnce();\n    }, speed);\n  }\n\n  // Steps are objects like {type:'enter',node:'A'} / {type:'finish',node:'A'} / {type:'stack',stack:[]}\n  function applyStep(step) {\n    if (!step) return;\n    if (step.type === 'enter') {\n      visited[step.node] = 1;\n      timeCounter++;\n      disc[step.node] = timeCounter;\n      visitedOrderEl.textContent = (visitedOrderEl.textContent ? visitedOrderEl.textContent + ' → ' : '') + step.node;\n      statusEl.textContent = `Entered ${step.node}`;\n    } else if (step.type === 'finish') {\n      visited[step.node] = 2;\n      timeCounter++;\n      finish[step.node] = timeCounter;\n      statusEl.textContent = `Finished ${step.node}`;\n    } else if (step.type === 'stack') {\n      stackView.textContent = '[' + step.stack.join(', ') + ']';\n    } else if (step.type === 'visit') {\n      visited[step.node] = 1;\n      if (!disc[step.node]) { timeCounter++; disc[step.node] = timeCounter; visitedOrderEl.textContent = (visitedOrderEl.textContent ? visitedOrderEl.textContent + ' → ' : '') + step.node; }\n    }\n    timeCounterEl.textContent = String(timeCounter);\n    rebuildTimesTable();\n  }\n\n  function rebuildTimesTable() {\n    timesTableBody.innerHTML = '';\n    nodes.sort((a,b)=>a.id.localeCompare(b.id)).forEach(n=>{\n      const tr = document.createElement('tr');\n      const td1 = document.createElement('td'); td1.textContent = n.id;\n      const td2 = document.createElement('td'); td2.textContent = disc[n.id] || '';\n      const td3 = document.createElement('td'); td3.textContent = finish[n.id] || '';\n      tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);\n      timesTableBody.appendChild(tr);\n    });\n  }\n\n  // DFS Generators\n\n  // Recursive implementation yields steps at entry, stack updates, neighbor exploration, and finish\n  function* recursiveDFSSteps(start, adj) {\n    const visitedLocal = {};\n    const callStack = [];\n\n    function* visit(u) {\n      // enter u\n      visitedLocal[u] = 1;\n      callStack.push(u);\n      yield { type:'enter', node:u };\n      yield { type:'stack', stack: [...callStack] };\n      const neighbors = adj[u] || [];\n      for (const v of neighbors) {\n        if (!visitedLocal[v]) {\n          // traverse\n          yield* visit(v);\n          yield { type:'stack', stack: [...callStack] };\n        }\n      }\n      // finish u\n      callStack.pop();\n      yield { type:'finish', node:u };\n      yield { type:'stack', stack: [...callStack] };\n    }\n\n    // DFS may need to cover disconnected nodes: we'll start at start, then others\n    if (!visitedLocal[start]) yield* visit(start);\n    for (const n of nodes.map(x=>x.id)) {\n      if (!visitedLocal[n]) yield* visit(n);\n    }\n  }\n\n  // Iterative implementation uses explicit stack of frames: {node, nextIndex}\n  function* iterativeDFSSteps(start, adj) {\n    const visitedLocal = {};\n    const stack = [];\n    const nodesOrder = nodes.map(n=>n.id);\n    function push(u) {\n      stack.push({ node:u, idx:0 });\n      yieldStack();\n      if (!visitedLocal[u]) {\n        visitedLocal[u] = 1;\n        yield { type:'enter', node:u };\n        yieldStack();\n      }\n    }\n    function* pushGen(u) { yield* (function*(){})(); } // placeholder\n\n    // Start from start, then remaining nodes for disconnected graphs\n    const startOrder = [start, ...nodesOrder.filter(x=>x!==start)];\n    for (const s of startOrder) {\n      if (visitedLocal[s]) continue;\n      stack.push({ node:s, idx:0 });\n      yield { type:'stack', stack: stack.map(f=>f.node) };\n      visitedLocal[s]=1;\n      yield { type:'enter', node:s };\n      yield { type:'stack', stack: stack.map(f=>f.node) };\n\n      while (stack.length>0) {\n        const frame = stack[stack.length-1];\n        const u = frame.node;\n        const neighbors = adj[u] || [];\n        if (frame.idx < neighbors.length) {\n          const v = neighbors[frame.idx];\n          frame.idx++;\n          if (!visitedLocal[v]) {\n            // push and enter v\n            stack.push({ node:v, idx:0 });\n            yield { type:'stack', stack: stack.map(f=>f.node) };\n            visitedLocal[v]=1;\n            yield { type:'enter', node:v };\n            yield { type:'stack', stack: stack.map(f=>f.node) };\n          } else {\n            // already visited; continue\n            yield { type:'stack', stack: stack.map(f=>f.node) };\n          }\n        } else {\n          // all neighbors done -> finish u\n          stack.pop();\n          yield { type:'finish', node:u };\n          yield { type:'stack', stack: stack.map(f=>f.node) };\n        }\n      }\n    }\n  }\n\n  // Initialization\n  updateUI();\n  draw();\n\n  // keyboard hints\n  document.addEventListener('keydown', (e)=>{\n    if (e.key === ' ') { e.preventDefault(); togglePlay(); }\n    if (e.key === 'Enter') { e.preventDefault(); stepOnce(); }\n    if (e.key === 'r') { resetTraversal(); }\n  });\n\n  // show some initial sample\n  (function seedSample(){\n    const spacing = Math.min(width, height) / 4;\n    const cx = width/2, cy = height/2;\n    createNode(cx - spacing, cy - spacing);\n    createNode(cx + spacing, cy - spacing);\n    createNode(cx - spacing, cy + spacing);\n    createNode(cx + spacing, cy + spacing);\n    createNode(cx, cy - spacing/1.6);\n    createNode(cx, cy + spacing/1.6);\n    addEdge('A','B'); addEdge('A','C'); addEdge('B','D'); addEdge('C','E'); addEdge('E','F'); addEdge('D','F');\n    updateUI(); draw();\n  })();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Depth-First Search (DFS)"
    }
  ],
  "topic": "Depth-First Search (DFS)",
  "hasFSM": false,
  "hasTest": true
}