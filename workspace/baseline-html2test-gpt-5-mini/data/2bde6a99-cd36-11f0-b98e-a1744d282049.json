{
  "id": "2bde6a99-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:17:01.371Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Sliding Window",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Sliding Window Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#22c1c3;\n      --muted:#9aa7b2;\n      --glass: rgba(255,255,255,0.03);\n    }\n    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;}\n    body{\n      background: linear-gradient(180deg,#031027 0%, #061827 100%);\n      color:#e6f0f2;\n      padding:20px;\n      box-sizing:border-box;\n    }\n    .app{\n      max-width:1100px;\n      margin:0 auto;\n      display:grid;\n      grid-template-columns: 420px 1fr;\n      gap:20px;\n      align-items:start;\n    }\n    .card{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:12px;\n      padding:18px;\n      box-shadow: 0 6px 18px rgba(3,6,14,0.6);\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    h1{font-size:20px;margin:0 0 8px 0;}\n    p.lead{margin:0 0 12px 0;color:var(--muted);font-size:13px;}\n    label{display:block;font-size:13px;margin-top:8px;color:var(--muted);}\n    input[type=text], input[type=number], select {\n      width:100%;\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.05);\n      background:var(--glass);\n      color:inherit;\n      box-sizing:border-box;\n      margin-top:6px;\n    }\n    .row{display:flex;gap:8px;margin-top:10px;}\n    button{\n      background:linear-gradient(180deg,var(--accent), #0fb5b7);\n      color:#002627;\n      border:none;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:600;\n      box-shadow:0 6px 16px rgba(17,108,107,0.18);\n    }\n    button.secondary{\n      background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04);box-shadow:none;\n    }\n    .small{padding:8px 10px;font-size:13px;}\n    .controls{display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap}\n    .visual{\n      min-height:420px;\n      display:flex;\n      flex-direction:column;\n      gap:14px;\n      align-items:center;\n      justify-content:flex-start;\n    }\n    .array{\n      display:flex;\n      gap:8px;\n      padding:12px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent);\n      border-radius:12px;\n      width:100%;\n      overflow:auto;\n      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);\n    }\n    .cell{\n      min-width:48px;\n      height:48px;\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      border-radius:8px;\n      background:rgba(255,255,255,0.02);\n      border:1px solid rgba(255,255,255,0.03);\n      color:var(--muted);\n      font-weight:700;\n      font-size:15px;\n      position:relative;\n      box-sizing:border-box;\n    }\n    .cell.index{font-size:11px;color:var(--muted);position:absolute;left:6px;top:6px;font-weight:600}\n    .cell.highlight{\n      background:linear-gradient(180deg, rgba(34,193,195,0.12), rgba(34,193,195,0.06));\n      border:1px solid rgba(34,193,195,0.18);\n      color: #e6fbfb;\n      box-shadow: 0 6px 14px rgba(34,193,195,0.06);\n    }\n    .cell.remove{\n      background:linear-gradient(180deg, rgba(255,85,85,0.08), rgba(255,85,85,0.04));\n      border:1px solid rgba(255,85,85,0.12);\n      color:#ffdfe0;\n    }\n    .info{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      justify-content:center;\n      background:rgba(255,255,255,0.02);\n      padding:10px;border-radius:10px;width:100%;\n      box-sizing:border-box;\n    }\n    .info .box{min-width:120px;text-align:center;}\n    .info .label{font-size:12px;color:var(--muted)}\n    .info .value{font-weight:800;font-size:18px;margin-top:4px}\n    .log{\n      margin-top:10px;\n      height:120px;\n      overflow:auto;\n      background:rgba(255,255,255,0.01);\n      border-radius:8px;padding:10px;border:1px solid rgba(255,255,255,0.02);\n      font-family:monospace;font-size:13px;color:var(--muted);\n    }\n    .footer{\n      margin-top:12px;color:var(--muted);font-size:13px;\n    }\n    .example-arrays{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;}\n    .chip{\n      background:rgba(255,255,255,0.02);\n      border:1px solid rgba(255,255,255,0.03);\n      padding:6px 8px;border-radius:8px;font-size:13px;color:var(--muted);cursor:pointer;\n    }\n    .status{\n      margin-top:8px;font-size:13px;color:var(--muted);\n    }\n    @media (max-width:980px){\n      .app{grid-template-columns:1fr; padding-bottom:80px;}\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"card\" id=\"panel\">\n      <h1>Sliding Window Visualizer</h1>\n      <p class=\"lead\">Explore fixed-size and variable-size sliding window examples. Input an array, choose a mode and window/target, then step through the algorithm or play an animation to see how the window moves and values update.</p>\n\n      <label>Array (comma separated numbers)</label>\n      <input id=\"arrayInput\" type=\"text\" value=\"2,1,5,2,8,3,1,4\" />\n\n      <div class=\"example-arrays\">\n        <div class=\"chip\" onclick=\"loadExample('2,1,5,2,8,3,1,4')\">2,1,5,2,8,3,1,4</div>\n        <div class=\"chip\" onclick=\"loadExample('4,2,1,7,8,1,2,8,1,0')\">4,2,1,7,8,1,2,8,1,0</div>\n        <div class=\"chip\" onclick=\"loadExample('1,1,1,1,1,1,1')\">1,1,1,1,1,1,1</div>\n        <div class=\"chip\" onclick=\"loadExample('5,3,8,1,2')\">5,3,8,1,2</div>\n      </div>\n\n      <label>Mode</label>\n      <select id=\"modeSelect\">\n        <option value=\"fixed\">Fixed-size window — sliding sum / max sum (size k)</option>\n        <option value=\"smallest\">Smallest subarray with sum ≥ target (variable-size)</option>\n      </select>\n\n      <div id=\"fixedControls\">\n        <label>Window size (k)</label>\n        <input id=\"windowSize\" type=\"number\" min=\"1\" value=\"3\" />\n      </div>\n\n      <div id=\"smallestControls\" style=\"display:none;\">\n        <label>Target sum</label>\n        <input id=\"targetSum\" type=\"number\" min=\"0\" value=\"7\" />\n      </div>\n\n      <div class=\"controls\">\n        <button id=\"btnPlay\" class=\"small\">Play</button>\n        <button id=\"btnPause\" class=\"small secondary\">Pause</button>\n        <button id=\"btnStep\" class=\"small secondary\">Step</button>\n        <button id=\"btnBack\" class=\"small secondary\">Back</button>\n        <button id=\"btnReset\" class=\"small secondary\">Reset</button>\n        <button id=\"btnRandom\" class=\"small\">Randomize</button>\n        <div style=\"flex:1\"></div>\n        <label style=\"margin:0;color:var(--muted);font-size:13px;\">Speed</label>\n        <select id=\"speedSelect\" style=\"width:84px;\">\n          <option value=\"800\">0.8s</option>\n          <option value=\"500\" selected>0.5s</option>\n          <option value=\"300\">0.3s</option>\n          <option value=\"120\">0.12s</option>\n        </select>\n      </div>\n\n      <div class=\"status\" id=\"statusText\">Ready</div>\n\n      <div class=\"footer\">\n        Tips: Fixed-size shows current window sum and tracks the maximum sum. Smallest-subarray finds the minimum-length contiguous subarray with sum ≥ target by expanding and contracting the window.\n      </div>\n    </div>\n\n    <div class=\"card visual\" id=\"visualCard\">\n      <div id=\"explain\" style=\"text-align:center;color:var(--muted);font-size:13px;\">\n        Visual representation of the array and sliding window. Use controls to step through.\n      </div>\n\n      <div class=\"array\" id=\"arrayRow\" aria-hidden=\"false\"></div>\n\n      <div class=\"info\" id=\"infoRow\">\n        <div class=\"box\">\n          <div class=\"label\">Current sum</div>\n          <div class=\"value\" id=\"currentSum\">-</div>\n        </div>\n        <div class=\"box\">\n          <div class=\"label\">Window indices</div>\n          <div class=\"value\" id=\"indices\">-</div>\n        </div>\n        <div class=\"box\">\n          <div class=\"label\">Best found</div>\n          <div class=\"value\" id=\"bestFound\">-</div>\n        </div>\n      </div>\n\n      <div class=\"log\" id=\"log\"></div>\n    </div>\n  </div>\n\n  <script>\n    /*\n      Sliding Window Visualizer\n      - Two modes:\n        1) Fixed-size window: sliding sum for window size k, track max sum and location\n        2) Smallest subarray with sum >= target: variable window, track min length and indices\n\n      Controls:\n        Play / Pause / Step / Back / Reset / Randomize\n      Implementation notes:\n        We use generator functions to produce step-by-step states. Each step yields an object describing:\n          - left, right pointers\n          - currentSum\n          - action (e.g., 'init', 'add', 'remove', 'check', 'found', 'move')\n          - best state (max sum or min length)\n          - highlight range\n    */\n\n    // DOM refs\n    const arrayInput = document.getElementById('arrayInput');\n    const modeSelect = document.getElementById('modeSelect');\n    const windowSizeInput = document.getElementById('windowSize');\n    const targetSumInput = document.getElementById('targetSum');\n    const arrayRow = document.getElementById('arrayRow');\n    const logEl = document.getElementById('log');\n    const currentSumEl = document.getElementById('currentSum');\n    const indicesEl = document.getElementById('indices');\n    const bestFoundEl = document.getElementById('bestFound');\n    const btnPlay = document.getElementById('btnPlay');\n    const btnPause = document.getElementById('btnPause');\n    const btnStep = document.getElementById('btnStep');\n    const btnBack = document.getElementById('btnBack');\n    const btnReset = document.getElementById('btnReset');\n    const btnRandom = document.getElementById('btnRandom');\n    const speedSelect = document.getElementById('speedSelect');\n    const statusText = document.getElementById('statusText');\n    const fixedControls = document.getElementById('fixedControls');\n    const smallestControls = document.getElementById('smallestControls');\n\n    // State\n    let arr = [];\n    let generator = null;\n    let history = []; // for stepping/back\n    let playing = false;\n    let interval = null;\n\n    function parseArrayInput() {\n      const raw = arrayInput.value.trim();\n      if (!raw) return [];\n      // Accept commas, spaces\n      const parts = raw.split(/[\\s,]+/).filter(Boolean);\n      const nums = parts.map(p => Number(p));\n      return nums.map(n => isFinite(n) ? n : 0);\n    }\n\n    function loadExample(txt){\n      arrayInput.value = txt;\n      resetAll();\n    }\n\n    function randomizeArray(){\n      const len = Math.floor(Math.random()*7) + 5; // 5..11\n      const max = 12;\n      const nums = Array.from({length:len}, () => Math.floor(Math.random()*max));\n      arrayInput.value = nums.join(',');\n      resetAll();\n    }\n\n    function renderArray(highlight = null, removeIndex = null, bestRange = null) {\n      arrayRow.innerHTML = '';\n      arr.forEach((v,i) => {\n        const c = document.createElement('div');\n        c.className = 'cell';\n        c.innerHTML = `<div class=\"index\">${i}</div><div>${v}</div>`;\n        if (highlight && i >= highlight[0] && i <= highlight[1]) {\n          c.classList.add('highlight');\n        }\n        if (removeIndex === i) {\n          c.classList.add('remove');\n        }\n        if (bestRange && i >= bestRange[0] && i <= bestRange[1]) {\n          // stronger highlight for best\n          c.style.boxShadow = '0 8px 22px rgba(34,193,195,0.12)';\n        }\n        arrayRow.appendChild(c);\n      });\n    }\n\n    function log(msg, kind='info') {\n      const time = new Date().toLocaleTimeString();\n      logEl.innerHTML = `<div>[${time}] ${msg}</div>` + logEl.innerHTML;\n    }\n\n    function updateInfo(state){\n      currentSumEl.textContent = state.currentSum != null ? state.currentSum : '-';\n      indicesEl.textContent = (state.left != null && state.right != null) ? `[${state.left}, ${state.right}]` : '-';\n      bestFoundEl.textContent = state.bestDisplay || '-';\n    }\n\n    // Generators to step through the algorithms\n\n    // Fixed-size sliding window (sum / max sum)\n    function* fixedWindowGenerator(a, k) {\n      const n = a.length;\n      if (k <= 0) {\n        yield { action:'init', left:0, right:-1, currentSum:0, best:{sum:0, left:0, right:-1}, bestDisplay:'k <= 0' };\n        return;\n      }\n      if (k > n) {\n        yield { action:'init', left:0, right:n-1, currentSum: a.reduce((s,v)=>s+v,0), best:{sum:null}, bestDisplay:'k > n (no full window)' };\n        return;\n      }\n      let sum = 0;\n      // first window\n      for (let i=0;i<k;i++){\n        sum += a[i];\n        yield { action:'add', left:0, right:i, currentSum:sum, note:`Added a[${i}] = ${a[i]}` , best:{sum:null}, bestDisplay:'initializing' };\n      }\n      let bestSum = sum;\n      let bestL = 0, bestR = k-1;\n      yield { action:'check', left:0, right:k-1, currentSum:sum, best:{sum:bestSum,left:bestL,right:bestR}, bestDisplay:`maxSum = ${bestSum} at [${bestL}, ${bestR}]` };\n      // slide\n      for (let i=k;i<n;i++){\n        const removeIndex = i-k;\n        const addIndex = i;\n        sum = sum - a[removeIndex];\n        yield { action:'remove', left:removeIndex+1, right:addIndex-1, currentSum:sum, removeIndex, note:`Removed a[${removeIndex}] = ${a[removeIndex]}`, best:{sum:bestSum,left:bestL,right:bestR}, bestDisplay:`maxSum = ${bestSum} at [${bestL}, ${bestR}]`};\n        sum = sum + a[addIndex];\n        yield { action:'add', left:removeIndex+1, right:addIndex, currentSum:sum, note:`Added a[${addIndex}] = ${a[addIndex]}`, best:{sum:bestSum,left:bestL,right:bestR}, bestDisplay:`maxSum = ${bestSum} at [${bestL}, ${bestR}]`};\n        if (sum > bestSum) {\n          bestSum = sum; bestL = removeIndex+1; bestR = addIndex;\n          yield { action:'found', left:bestL, right:bestR, currentSum:sum, best:{sum:bestSum,left:bestL,right:bestR}, bestDisplay:`UPDATED maxSum = ${bestSum} at [${bestL}, ${bestR}]` };\n        } else {\n          yield { action:'check', left:removeIndex+1, right:addIndex, currentSum:sum, best:{sum:bestSum,left:bestL,right:bestR}, bestDisplay:`maxSum = ${bestSum} at [${bestL}, ${bestR}]` };\n        }\n      }\n      yield { action:'done', left:bestL, right:bestR, currentSum: bestSum, best:{sum:bestSum,left:bestL,right:bestR}, bestDisplay:`Completed. maxSum = ${bestSum} at [${bestL}, ${bestR}]` };\n    }\n\n    // Smallest subarray with sum >= target (variable-size sliding window)\n    function* smallestSubarrayGenerator(a, target) {\n      const n = a.length;\n      let left = 0, sum = 0;\n      let minLen = Infinity, bestL = -1, bestR = -1;\n      yield { action:'init', left:0, right:-1, currentSum:0, bestDisplay:'start' };\n      for (let right=0; right<n; right++){\n        sum += a[right];\n        yield { action:'add', left:left, right:right, currentSum:sum, note:`Added a[${right}] = ${a[right]}`, best:{minLen,minLen,left:bestL,right:bestR}, bestDisplay: minLen===Infinity ? 'no solution yet' : `minLen = ${minLen} at [${bestL},${bestR}]` };\n        // Contract while meets target\n        while (sum >= target && left <= right) {\n          const currLen = right - left + 1;\n          if (currLen < minLen) {\n            minLen = currLen; bestL = left; bestR = right;\n            yield { action:'found', left:left, right:right, currentSum:sum, best:{minLen,minLen,left:bestL,right:bestR}, bestDisplay:`UPDATED minLen = ${minLen} at [${bestL},${bestR}]` };\n          } else {\n            yield { action:'check', left:left, right:right, currentSum:sum, best:{minLen,minLen,left:bestL,right:bestR}, bestDisplay: minLen===Infinity ? 'no solution' : `minLen = ${minLen} at [${bestL},${bestR}]` };\n          }\n          // remove leftmost\n          sum -= a[left];\n          yield { action:'remove', left:left+1, right:right, currentSum:sum, removeIndex:left, note:`Removing a[${left}] = ${a[left]}` , best:{minLen,minLen,left:bestL,right:bestR}, bestDisplay: minLen===Infinity ? 'no solution' : `minLen = ${minLen} at [${bestL},${bestR}]`};\n          left++;\n        }\n      }\n      if (minLen === Infinity) {\n        yield { action:'done', left:0, right:n-1, currentSum:sum, bestDisplay:'No valid subarray found (sum < target)' };\n      } else {\n        yield { action:'done', left:bestL, right:bestR, currentSum:0, bestDisplay:`Completed. minLen = ${minLen} at [${bestL},${bestR}]` };\n      }\n    }\n\n    // Utility to create the appropriate generator based on mode\n    function createGenerator(){\n      arr = parseArrayInput();\n      if (!arr.length) arr = [];\n      const mode = modeSelect.value;\n      if (mode === 'fixed') {\n        const k = Math.max(0, Math.floor(Number(windowSizeInput.value) || 0));\n        return fixedWindowGenerator(arr, k);\n      } else if (mode === 'smallest') {\n        const t = Number(targetSumInput.value) || 0;\n        return smallestSubarrayGenerator(arr, t);\n      }\n      return (function*(){ yield {action:'done'}; })();\n    }\n\n    function resetAll(){\n      stopPlaying();\n      arr = parseArrayInput();\n      history = [];\n      generator = createGenerator();\n      const first = generator.next();\n      history.push(first.value);\n      renderState(first.value);\n      log('Reset and initialized generator.');\n      statusText.textContent = 'Ready';\n    }\n\n    function renderState(state) {\n      // state can be undefined if generator ended\n      if (!state) return;\n      // highlight range\n      const left = state.left != null ? state.left : 0;\n      const right = state.right != null ? state.right : arr.length-1;\n      const highlight = (left<=right) ? [left,right] : null;\n      // best range for display\n      let bestRange = null;\n      if (state.best && state.best.left != null && state.best.right != null && state.best.left <= state.best.right) {\n        bestRange = [state.best.left, state.best.right];\n      } else if (state.action === 'done' && state.left != null && state.right != null && modeSelect.value === 'fixed') {\n        // final best for fixed maybe encoded in left/right\n        bestRange = [state.left, state.right];\n      }\n      renderArray(highlight, state.removeIndex, bestRange);\n      updateInfo({\n        left: state.left,\n        right: state.right,\n        currentSum: state.currentSum,\n        bestDisplay: state.bestDisplay || (state.best && state.best.sum != null ? `maxSum = ${state.best.sum}` : '-')\n      });\n\n      // log action\n      if (state.note) log(state.note);\n      if (state.action) {\n        switch(state.action) {\n          case 'init': statusText.textContent = 'Initialized'; break;\n          case 'add': statusText.textContent = `Added index ${state.right}`; break;\n          case 'remove': statusText.textContent = `Removed index ${state.removeIndex}`; break;\n          case 'found': statusText.textContent = state.bestDisplay || 'Found better'; break;\n          case 'check': statusText.textContent = 'Checking'; break;\n          case 'done': statusText.textContent = 'Completed'; break;\n        }\n      }\n    }\n\n    function stepForward(){\n      if (!generator) generator = createGenerator();\n      const result = generator.next();\n      if (result.done) {\n        log('Reached end of algorithm.');\n        statusText.textContent = 'Completed';\n        playing = false;\n        stopPlaying();\n        return;\n      }\n      history.push(result.value);\n      renderState(result.value);\n    }\n\n    function stepBack(){\n      if (history.length <= 1) {\n        log('At the beginning, cannot step back further.');\n        return;\n      }\n      // remove last\n      history.pop();\n      const prev = history[history.length-1];\n      renderState(prev);\n      // We must rebuild generator from this point onward if user continues stepping forward.\n      // Simpler: recreate generator and consume states to reach current history length.\n      generator = createGenerator();\n      // discard initial states to match history length\n      for (let i=0;i<history.length;i++){\n        const res = generator.next();\n        if (res.done) break;\n      }\n      log('Stepped back.');\n    }\n\n    function play(){\n      if (playing) return;\n      playing = true;\n      statusText.textContent = 'Playing';\n      const delay = Number(speedSelect.value) || 500;\n      interval = setInterval(() => {\n        const result = generator.next();\n        if (result.done) {\n          log('Animation finished.');\n          statusText.textContent = 'Completed';\n          playing = false;\n          stopPlaying();\n          return;\n        }\n        history.push(result.value);\n        renderState(result.value);\n      }, delay);\n    }\n\n    function stopPlaying(){\n      playing = false;\n      if (interval) {\n        clearInterval(interval);\n        interval = null;\n      }\n    }\n\n    // Event wiring\n    btnPlay.addEventListener('click', () => {\n      // if generator not created or at end, recreate\n      if (!generator) {\n        generator = createGenerator();\n        const first = generator.next();\n        history.push(first.value);\n        renderState(first.value);\n      }\n      play();\n    });\n    btnPause.addEventListener('click', () => { stopPlaying(); statusText.textContent = 'Paused'; log('Paused.'); });\n    btnStep.addEventListener('click', () => { stopPlaying(); stepForward(); });\n    btnBack.addEventListener('click', () => { stopPlaying(); stepBack(); });\n    btnReset.addEventListener('click', () => { resetAll(); log('Reset requested.'); });\n    btnRandom.addEventListener('click', () => { randomizeArray(); log('Randomized array.'); });\n\n    // When inputs change, reset\n    arrayInput.addEventListener('change', () => { resetAll(); });\n    windowSizeInput.addEventListener('change', () => { if (modeSelect.value === 'fixed') resetAll(); });\n    targetSumInput.addEventListener('change', () => { if (modeSelect.value === 'smallest') resetAll(); });\n\n    modeSelect.addEventListener('change', () => {\n      if (modeSelect.value === 'fixed') {\n        fixedControls.style.display = 'block';\n        smallestControls.style.display = 'none';\n      } else {\n        fixedControls.style.display = 'none';\n        smallestControls.style.display = 'block';\n      }\n      resetAll();\n    });\n\n    // initial setup\n    resetAll();\n\n    // expose some helpers for example chips to call\n    window.loadExample = loadExample;\n    window.randomizeArray = randomizeArray;\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Sliding Window"
    }
  ],
  "topic": "Sliding Window",
  "hasFSM": false,
  "hasTest": true
}