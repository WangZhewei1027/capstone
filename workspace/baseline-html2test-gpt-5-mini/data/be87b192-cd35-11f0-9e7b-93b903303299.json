{
  "id": "be87b192-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:14:12.645Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Bellman-Ford Algorithm Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    html,body { height:100%; margin:0; font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background: #f7f9fb; color:#111; }\n    #app { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }\n    #left { flex:1; background:#fff; border-radius:8px; padding:12px; box-shadow:0 4px 18px rgba(20,40,80,0.06); display:flex; flex-direction:column; }\n    #canvasWrap { flex:1; position:relative; border:1px dashed #e3e9ef; border-radius:8px; overflow:hidden; background:linear-gradient(180deg,#fcfeff, #f7fbff); }\n    canvas { width:100%; height:100%; display:block; }\n    #controls { margin-top:12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\n    button, input[type=number], select { padding:8px 10px; border-radius:6px; border:1px solid #cfd8e3; background:#fff; cursor:pointer; }\n    button:active { transform:translateY(1px); }\n    .btn-primary { background:linear-gradient(180deg,#2f8cff,#216ad8); color:#fff; border-color: #1e66c8; }\n    .btn-danger { background:linear-gradient(180deg,#ff6b6b,#e64a4a); color:#fff; border-color: #d63b3b; }\n    #right { width:360px; min-width:260px; background:#fff; border-radius:8px; padding:12px; box-shadow:0 4px 18px rgba(20,40,80,0.06); display:flex; flex-direction:column; gap:8px; }\n    h3 { margin:0 0 6px 0; font-size:16px; }\n    .panel { padding:8px; border-radius:6px; background:#fbfcfe; border:1px solid #eef3fb; }\n    label { font-size:13px; color:#334155; display:block; margin-bottom:6px; }\n    #edgeList { max-height:140px; overflow:auto; font-family:monospace; background:#fff; border-radius:6px; padding:8px; border:1px solid #eef3fb; }\n    .small { font-size:13px; color:#555; }\n    #distanceTable { display:grid; gap:6px; grid-template-columns:1fr 1fr; }\n    .nodeRow { display:flex; align-items:center; gap:8px; padding:6px; border-radius:6px; }\n    .nodeBadge { width:28px; height:28px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center; color:#fff; font-weight:600; }\n    .distVal { font-weight:700; }\n    #log { max-height:140px; overflow:auto; font-family:monospace; font-size:13px; background:#fff; padding:8px; border-radius:6px; border:1px solid #eef3fb; }\n    .statusOk { color:green; font-weight:700; }\n    .statusWarn { color:crimson; font-weight:700; }\n    footer { font-size:12px; color:#5b6b7a; margin-top:6px; }\n    .topRow { display:flex; gap:8px; align-items:center; margin-bottom:8px; }\n    .hint { font-size:12px; color:#5b6b7a; }\n    input[type=range] { width:120px; }\n    .edgeItem { display:flex; justify-content:space-between; gap:8px; padding:6px 4px; align-items:center; }\n    .edgeText { font-family:monospace; }\n  </style>\n</head>\n<body>\n<div id=\"app\">\n  <div id=\"left\">\n    <div class=\"topRow\">\n      <div>\n        <button id=\"addNodeBtn\">Add Node (click canvas)</button>\n        <button id=\"addEdgeBtn\">Add Edge (click source → target)</button>\n        <button id=\"delBtn\">Delete Element</button>\n      </div>\n      <div style=\"margin-left:auto; display:flex; gap:8px; align-items:center;\">\n        <label class=\"hint\">Directed\n          <input id=\"directedChk\" type=\"checkbox\" checked style=\"margin-left:6px;\">\n        </label>\n        <label class=\"hint\">Allow negative weights\n          <input id=\"negAllowChk\" type=\"checkbox\" checked style=\"margin-left:6px;\">\n        </label>\n      </div>\n    </div>\n\n    <div id=\"canvasWrap\">\n      <canvas id=\"canvas\"></canvas>\n    </div>\n\n    <div id=\"controls\">\n      <button id=\"setSourceBtn\">Set Source Node</button>\n      <button id=\"resetBtn\">Reset Distances</button>\n      <button id=\"stepBtn\" class=\"btn-primary\">Step</button>\n      <button id=\"runBtn\" class=\"btn-primary\">Run</button>\n      <button id=\"stopBtn\" class=\"btn-danger\">Stop</button>\n      <label style=\"display:flex;align-items:center;gap:6px;margin-left:auto;\">\n        Speed <input id=\"speed\" type=\"range\" min=\"100\" max=\"2000\" step=\"100\" value=\"800\">\n      </label>\n    </div>\n\n    <div style=\"margin-top:8px; display:flex; gap:8px;\">\n      <button id=\"sampleBtn\">Load Sample (negative edge)</button>\n      <button id=\"randomBtn\">Random Graph</button>\n      <button id=\"clearBtn\">Clear Graph</button>\n    </div>\n\n    <footer>\n      Controls:\n      - Click empty canvas to add node when \"Add Node\" is active.\n      - Click \"Add Edge\", then click source then target to create edge (weight prompted).\n      - Use \"Set Source\" then click a node to mark source.\n      - Drag nodes to rearrange.\n    </footer>\n  </div>\n\n  <div id=\"right\">\n    <h3>Graph Info</h3>\n    <div class=\"panel\">\n      <label>Nodes: <span id=\"nodeCount\">0</span> &nbsp; Edges: <span id=\"edgeCount\">0</span></label>\n      <label>Source: <span id=\"sourceDisplay\">—</span></label>\n      <div style=\"margin-top:8px;\">\n        <label>Edge list (order used by Bellman-Ford):</label>\n        <div id=\"edgeList\"></div>\n      </div>\n    </div>\n\n    <h3>Algorithm State</h3>\n    <div class=\"panel\">\n      <div style=\"display:flex; gap:8px; align-items:center; margin-bottom:8px;\">\n        <label>Iteration: <strong id=\"iterDisplay\">0</strong> / <span id=\"maxIter\">0</span></label>\n        <label>Edge idx: <strong id=\"edgeIdxDisplay\">-</strong></label>\n      </div>\n      <div id=\"distanceTable\"></div>\n      <div style=\"margin-top:8px;\">\n        <label>Predecessors:</label>\n        <div id=\"predList\" class=\"small\"></div>\n      </div>\n    </div>\n\n    <h3>Log & Status</h3>\n    <div class=\"panel\">\n      <div id=\"log\"></div>\n      <div style=\"margin-top:8px;\">\n        <span id=\"status\" class=\"small\"></span>\n      </div>\n    </div>\n  </div>\n</div>\n\n<script>\n/*\n  Bellman-Ford Visualizer\n  - Single-file interactive demo\n  - Add nodes, create edges (directed/undirected), set source node\n  - Step through Bellman-Ford relaxations; auto-run with speed control\n  - Detect negative cycles after V-1 iterations\n*/\n\n(() => {\n  // Canvas / Graph data structures\n  const canvas = document.getElementById('canvas');\n  const wrap = document.getElementById('canvasWrap');\n  const ctx = canvas.getContext('2d');\n  let DPR = window.devicePixelRatio || 1;\n\n  function resize() {\n    canvas.width = wrap.clientWidth * DPR;\n    canvas.height = wrap.clientHeight * DPR;\n    canvas.style.width = wrap.clientWidth + 'px';\n    canvas.style.height = wrap.clientHeight + 'px';\n    ctx.setTransform(DPR,0,0,DPR,0,0);\n    draw();\n  }\n  window.addEventListener('resize', resize);\n\n  // Graph\n  let nodes = []; // {id, x, y}\n  let edges = []; // {u, v, w, id}\n  let nextNodeId = 0;\n  let nextEdgeId = 0;\n  let directed = true;\n  let allowNegative = true;\n\n  // Interaction state\n  let mode = 'none'; // addNode, addEdge, delete, setSource\n  let addingEdgeFrom = null;\n  let draggingNode = null;\n  let dragOffset = {x:0,y:0};\n  let sourceNode = null;\n\n  // Algorithm state\n  let dist = {}; // nodeId -> distance (number or +Infinity)\n  let pred = {}; // nodeId -> predecessor nodeId or null\n  let iter = 0; // current iteration (1..V-1). We'll display 0 as not started.\n  let edgeIndex = 0; // index of edge inside each iteration\n  let running = false;\n  let runTimer = null;\n  let speed = 800; // ms per step\n  let V = 0;\n  let maxIter = 0;\n\n  // UI elements\n  const addNodeBtn = document.getElementById('addNodeBtn');\n  const addEdgeBtn = document.getElementById('addEdgeBtn');\n  const delBtn = document.getElementById('delBtn');\n  const setSourceBtn = document.getElementById('setSourceBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const runBtn = document.getElementById('runBtn');\n  const stopBtn = document.getElementById('stopBtn');\n  const sampleBtn = document.getElementById('sampleBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const directedChk = document.getElementById('directedChk');\n  const negAllowChk = document.getElementById('negAllowChk');\n  const nodeCountEl = document.getElementById('nodeCount');\n  const edgeCountEl = document.getElementById('edgeCount');\n  const edgeListEl = document.getElementById('edgeList');\n  const distanceTable = document.getElementById('distanceTable');\n  const predList = document.getElementById('predList');\n  const logEl = document.getElementById('log');\n  const statusEl = document.getElementById('status');\n  const iterDisplay = document.getElementById('iterDisplay');\n  const edgeIdxDisplay = document.getElementById('edgeIdxDisplay');\n  const maxIterEl = document.getElementById('maxIter');\n  const sourceDisplay = document.getElementById('sourceDisplay');\n  const speedInput = document.getElementById('speed');\n\n  // Colors\n  const nodeColor = '#2f8cff';\n  const nodeSelectedColor = '#21a2ff';\n  const nodeTextColor = '#fff';\n  const edgeColor = '#2b3440';\n  const edgeHighlightColor = '#ff9900';\n  const relaxedColor = '#22c55e';\n  const negativeCycleColor = '#ff3b3b';\n\n  // Utilities\n  function findNodeAt(x,y) {\n    for (let i = nodes.length-1; i>=0; i--) {\n      const n = nodes[i];\n      const dx = x - n.x;\n      const dy = y - n.y;\n      if (Math.hypot(dx,dy) <= 18) return n;\n    }\n    return null;\n  }\n\n  function addNode(x,y) {\n    const n = { id: String(nextNodeId++), x, y };\n    nodes.push(n);\n    updateCounts();\n    draw();\n    return n;\n  }\n\n  function addEdge(uId, vId, w) {\n    const e = { id: String(nextEdgeId++), u: uId, v: vId, w: Number(w) };\n    edges.push(e);\n    updateCounts();\n    draw();\n    return e;\n  }\n\n  function removeNode(node) {\n    nodes = nodes.filter(n => n.id !== node.id);\n    edges = edges.filter(e => e.u !== node.id && e.v !== node.id);\n    if (sourceNode === node.id) sourceNode = null;\n    updateCounts();\n    draw();\n  }\n\n  function removeEdge(edge) {\n    edges = edges.filter(e => e.id !== edge.id);\n    updateCounts();\n    draw();\n  }\n\n  function updateCounts() {\n    nodeCountEl.textContent = nodes.length;\n    edgeCountEl.textContent = edges.length;\n    edgeListEl.innerHTML = '';\n    edges.forEach((e, idx) => {\n      const div = document.createElement('div');\n      div.className = 'edgeItem';\n      const txt = document.createElement('div');\n      txt.className = 'edgeText';\n      txt.textContent = `[${idx}] ${e.u} → ${e.v}  w=${e.w}`;\n      const del = document.createElement('button');\n      del.textContent = 'Delete';\n      del.style.padding = '4px 6px';\n      del.onclick = (ev) => { ev.stopPropagation(); removeEdge(e); };\n      div.appendChild(txt);\n      div.appendChild(del);\n      edgeListEl.appendChild(div);\n    });\n    refreshDistanceUI();\n  }\n\n  function refreshDistanceUI(highlightNode) {\n    distanceTable.innerHTML = '';\n    predList.textContent = '';\n    nodes.forEach(n => {\n      const row = document.createElement('div');\n      row.className = 'nodeRow';\n      const badge = document.createElement('div');\n      badge.className = 'nodeBadge';\n      badge.style.background = (n.id === sourceNode ? nodeSelectedColor : nodeColor);\n      badge.textContent = n.id;\n      const info = document.createElement('div');\n      const d = dist[n.id];\n      info.innerHTML = `<div style=\"font-size:13px\">${n.id}</div><div class=\"distVal\">${d===Infinity? '∞' : d}</div>`;\n      if (highlightNode && highlightNode === n.id) row.style.background = '#fff5e6';\n      row.appendChild(badge);\n      row.appendChild(info);\n      distanceTable.appendChild(row);\n\n      const p = document.createElement('div');\n      p.textContent = `${n.id}: ${pred[n.id] === null ? '—' : pred[n.id]}`;\n      predList.appendChild(p);\n    });\n    sourceDisplay.textContent = sourceNode === null ? '—' : sourceNode;\n  }\n\n  function log(msg, kind='info') {\n    const p = document.createElement('div');\n    p.textContent = msg;\n    if (kind === 'warn') p.style.color = 'crimson';\n    if (kind === 'ok') p.style.color = 'green';\n    logEl.prepend(p);\n  }\n\n  // Drawing\n  function draw() {\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    const W = canvas.width / DPR;\n    const H = canvas.height / DPR;\n\n    // Draw edges\n    edges.forEach(e => {\n      const u = nodes.find(n => n.id === e.u);\n      const v = nodes.find(n => n.id === e.v);\n      if (!u || !v) return;\n      drawEdge(u.x, u.y, v.x, v.y, e.w, e.id);\n    });\n\n    // Draw nodes\n    nodes.forEach(n => {\n      drawNode(n);\n    });\n\n    // If adding edge and we have a start, draw temporary line from start to mouse\n    if (addingEdgeFrom) {\n      if (mousePos) {\n        drawTempEdge(addingEdgeFrom.x, addingEdgeFrom.y, mousePos.x, mousePos.y);\n      }\n    }\n  }\n\n  function drawNode(n) {\n    ctx.beginPath();\n    ctx.fillStyle = (n.id === sourceNode ? nodeSelectedColor : nodeColor);\n    ctx.strokeStyle = '#12314f';\n    ctx.lineWidth = 1;\n    ctx.arc(n.x, n.y, 18, 0, Math.PI*2);\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = nodeTextColor;\n    ctx.font = 'bold 13px system-ui, Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(n.id, n.x, n.y);\n  }\n\n  function drawEdge(x1, y1, x2, y2, w, id) {\n    const ang = Math.atan2(y2-y1, x2-x1);\n    const offset = 18; // node radius\n    const startX = x1 + Math.cos(ang)*offset;\n    const startY = y1 + Math.sin(ang)*offset;\n    const endX = x2 - Math.cos(ang)*offset;\n    const endY = y2 - Math.sin(ang)*offset;\n\n    ctx.beginPath();\n    ctx.strokeStyle = edgeColor;\n    ctx.lineWidth = 2;\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n\n    // Arrowhead for directed\n    if (directed) {\n      drawArrowhead(endX, endY, ang);\n    } else {\n      // small circle midpoint for undirected\n      const mx = (startX+endX)/2, my = (startY+endY)/2;\n      ctx.beginPath();\n      ctx.fillStyle = '#fff';\n      ctx.strokeStyle = '#223248';\n      ctx.lineWidth = 1;\n      ctx.arc(mx, my, 6, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n    }\n\n    // Draw weight label near middle, offset slightly perpendicular\n    const mx = (startX+endX)/2, my = (startY+endY)/2;\n    const perpAng = ang + Math.PI/2;\n    const labelX = mx + Math.cos(perpAng)*12;\n    const labelY = my + Math.sin(perpAng)*12;\n    ctx.beginPath();\n    ctx.fillStyle = '#0f1724';\n    ctx.font = '12px system-ui';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(w, labelX, labelY);\n  }\n\n  function drawArrowhead(x,y,ang) {\n    const size=8;\n    ctx.beginPath();\n    ctx.fillStyle = edgeColor;\n    ctx.moveTo(x, y);\n    ctx.lineTo(x - Math.cos(ang - 0.4)*size, y - Math.sin(ang - 0.4)*size);\n    ctx.lineTo(x - Math.cos(ang + 0.4)*size, y - Math.sin(ang + 0.4)*size);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function drawTempEdge(x1,y1,x2,y2) {\n    const ang = Math.atan2(y2-y1, x2-x1);\n    const offset = 18;\n    const startX = x1 + Math.cos(ang)*offset;\n    const startY = y1 + Math.sin(ang)*offset;\n    const endX = x2;\n    const endY = y2;\n    ctx.beginPath();\n    ctx.strokeStyle = '#7aaefc';\n    ctx.setLineDash([6,6]);\n    ctx.lineWidth = 2;\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n    ctx.setLineDash([]);\n  }\n\n  // Mouse handling\n  let mousePos = null;\n  canvas.addEventListener('mousemove', (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = (ev.clientX - rect.left);\n    const y = (ev.clientY - rect.top);\n    mousePos = {x,y};\n    if (draggingNode) {\n      draggingNode.x = x - dragOffset.x;\n      draggingNode.y = y - dragOffset.y;\n      draw();\n    } else {\n      if (addingEdgeFrom) draw();\n    }\n  });\n\n  canvas.addEventListener('mouseleave', () => { mousePos = null; if (!draggingNode) draw(); });\n\n  canvas.addEventListener('mousedown', (ev) => {\n    ev.preventDefault();\n    const rect = canvas.getBoundingClientRect();\n    const x = (ev.clientX - rect.left);\n    const y = (ev.clientY - rect.top);\n    const clicked = findNodeAt(x,y);\n\n    if (mode === 'addNode') {\n      addNode(x,y);\n      return;\n    }\n\n    if (mode === 'addEdge') {\n      if (!addingEdgeFrom) {\n        if (clicked) {\n          addingEdgeFrom = clicked;\n        }\n      } else {\n        if (clicked && clicked.id === addingEdgeFrom.id) {\n          // Cancel\n          addingEdgeFrom = null;\n        } else if (clicked) {\n          // prompt for weight\n          let w = prompt(\"Edge weight (can be negative if allowed):\", \"1\");\n          if (w !== null) {\n            w = Number(w);\n            if (!allowNegative && w < 0) {\n              alert(\"Negative weights are disabled in settings.\");\n            } else if (isNaN(w)) {\n              alert(\"Invalid weight.\");\n            } else {\n              addEdge(addingEdgeFrom.id, clicked.id, w);\n              if (!directed) addEdge(clicked.id, addingEdgeFrom.id, w);\n            }\n          }\n          addingEdgeFrom = null;\n        } else {\n          // clicked empty - allow drawing to empty space? We'll create node and edge to it.\n          const newN = addNode(x,y);\n          let w = prompt(\"Edge weight (can be negative if allowed):\", \"1\");\n          if (w !== null) {\n            w = Number(w);\n            if (!allowNegative && w < 0) {\n              alert(\"Negative weights are disabled in settings.\");\n            } else if (isNaN(w)) {\n              alert(\"Invalid weight.\");\n            } else {\n              addEdge(addingEdgeFrom.id, newN.id, w);\n              if (!directed) addEdge(newN.id, addingEdgeFrom.id, w);\n            }\n          }\n          addingEdgeFrom = null;\n        }\n      }\n      draw();\n      return;\n    }\n\n    if (mode === 'delete') {\n      if (clicked) {\n        if (confirm('Delete node ' + clicked.id + ' and its incident edges?')) {\n          removeNode(clicked);\n        }\n      } else {\n        // maybe click an edge? find closest edge within threshold\n        const edge = findEdgeNear(x,y);\n        if (edge) {\n          if (confirm('Delete edge ' + edge.u + '→' + edge.v + ' ?')) removeEdge(edge);\n        }\n      }\n      return;\n    }\n\n    if (mode === 'setSource') {\n      if (clicked) {\n        sourceNode = clicked.id;\n        resetAlgorithm();\n      }\n      mode = 'none';\n      setModeButtonStyles();\n      draw();\n      return;\n    }\n\n    // Default interactions: start dragging node\n    if (clicked) {\n      draggingNode = clicked;\n      dragOffset.x = x - clicked.x;\n      dragOffset.y = y - clicked.y;\n    }\n  });\n\n  canvas.addEventListener('mouseup', (ev) => {\n    draggingNode = null;\n  });\n\n  function findEdgeNear(x,y) {\n    // find an edge where distance to segment < threshold\n    const threshold = 8;\n    for (let e of edges) {\n      const u = nodes.find(n=>n.id===e.u);\n      const v = nodes.find(n=>n.id===e.v);\n      if (!u || !v) continue;\n      const d = distToSegment({x,y}, {x:u.x,y:u.y}, {x:v.x,y:v.y});\n      if (d < threshold) return e;\n    }\n    return null;\n  }\n\n  function distToSegment(p, v, w) {\n    // distance point p to segment vw\n    const l2 = (v.x-w.x)*(v.x-w.x)+(v.y-w.y)*(v.y-w.y);\n    if (l2===0) return Math.hypot(p.x-v.x, p.y-v.y);\n    let t = ((p.x - v.x)*(w.x - v.x) + (p.y - v.y)*(w.y - v.y)) / l2;\n    t = Math.max(0, Math.min(1, t));\n    const projx = v.x + t*(w.x - v.x);\n    const projy = v.y + t*(w.y - v.y);\n    return Math.hypot(p.x - projx, p.y - projy);\n  }\n\n  // Mode buttons\n  addNodeBtn.onclick = () => { mode='addNode'; setModeButtonStyles(); addingEdgeFrom=null; };\n  addEdgeBtn.onclick = () => { mode='addEdge'; setModeButtonStyles(); addingEdgeFrom=null; };\n  delBtn.onclick = () => { mode='delete'; setModeButtonStyles(); addingEdgeFrom=null; };\n  setSourceBtn.onclick = () => { mode='setSource'; setModeButtonStyles(); addingEdgeFrom=null; };\n\n  function setModeButtonStyles() {\n    addNodeBtn.style.border = mode==='addNode' ? '2px solid #1e66c8' : '';\n    addEdgeBtn.style.border = mode==='addEdge' ? '2px solid #1e66c8' : '';\n    delBtn.style.border = mode==='delete' ? '2px solid #1e66c8' : '';\n    setSourceBtn.style.border = mode==='setSource' ? '2px solid #1e66c8' : '';\n  }\n\n  directedChk.onchange = () => { directed = directedChk.checked; draw(); };\n  negAllowChk.onchange = () => { allowNegative = negAllowChk.checked; };\n\n  // Algorithmic implementation: step-by-step Bellman-Ford\n  function initAlgorithm() {\n    if (sourceNode === null) {\n      alert('Please set a source node first (use Set Source).');\n      return false;\n    }\n    dist = {};\n    pred = {};\n    nodes.forEach(n => { dist[n.id] = Infinity; pred[n.id] = null; });\n    dist[sourceNode] = 0;\n    V = nodes.length;\n    maxIter = Math.max(0, V-1);\n    iter = 1;\n    edgeIndex = 0;\n    running = false;\n    clearInterval(runTimer);\n    maxIterEl.textContent = maxIter;\n    iterDisplay.textContent = 0;\n    edgeIdxDisplay.textContent = '-';\n    updateStatus('Initialized. Ready to step.', 'ok');\n    refreshDistanceUI();\n    return true;\n  }\n\n  function resetAlgorithm() {\n    // reinitialize dist/pred but do not change graph\n    initAlgorithm();\n    draw();\n  }\n\n  resetBtn.onclick = () => { resetAlgorithm(); log('Distances reset.'); };\n\n  stepBtn.onclick = () => {\n    if (!dist || Object.keys(dist).length===0) {\n      if (!initAlgorithm()) return;\n    }\n    stepOnce();\n  };\n\n  runBtn.onclick = () => {\n    if (!dist || Object.keys(dist).length===0) {\n      if (!initAlgorithm()) return;\n    }\n    running = true;\n    speed = Number(speedInput.value);\n    runTimer = setInterval(() => {\n      if (!running) return;\n      stepOnce();\n    }, speed);\n  };\n\n  stopBtn.onclick = () => {\n    running = false;\n    clearInterval(runTimer);\n    updateStatus('Stopped.', 'warn');\n  };\n\n  speedInput.oninput = (e) => { speed = Number(e.target.value); if (running) { clearInterval(runTimer); runTimer = setInterval(() => stepOnce(), speed); } };\n\n  function stepOnce() {\n    if (iter === 0) {\n      if (!initAlgorithm()) return;\n    }\n    if (iter > maxIter) {\n      // Completed V-1 iterations, now do negative cycle check\n      updateStatus('Checking for negative-weight cycles...', 'info');\n      let negFound = false;\n      for (let i=0;i<edges.length;i++) {\n        const e = edges[i];\n        const u = e.u, v = e.v, w = e.w;\n        if (dist[u] !== Infinity && dist[u] + w < dist[v]) {\n          negFound = true;\n          highlightNegativeEdge(e);\n          log(`Negative cycle detected via edge ${u}→${v} (w=${w}).`, 'warn');\n          updateStatus('Negative-weight cycle detected! Shortest paths are undefined.', 'warn');\n          running = false;\n          clearInterval(runTimer);\n          return;\n        }\n      }\n      // if not found\n      updateStatus('No negative-weight cycles detected. Shortest paths found.', 'ok');\n      log('Bellman-Ford completed successfully. Shortest distances set.', 'ok');\n      running = false;\n      clearInterval(runTimer);\n      iterDisplay.textContent = maxIter;\n      edgeIdxDisplay.textContent = '-';\n      return;\n    }\n\n    // If there are no edges, simply finish\n    if (edges.length === 0) {\n      iter = maxIter + 1;\n      stepOnce();\n      return;\n    }\n\n    // Process edge at edgeIndex of current iteration\n    const e = edges[edgeIndex];\n    iterDisplay.textContent = iter;\n    edgeIdxDisplay.textContent = edgeIndex;\n    highlightEdgeTemp(e);\n\n    const u = e.u, v = e.v, w = e.w;\n    const du = dist[u];\n    const dv = dist[v];\n    if (du !== Infinity && du + w < dv) {\n      // relax\n      dist[v] = du + w;\n      pred[v] = u;\n      log(`Relaxed edge ${u}→${v}: dist[${v}] updated to ${dist[v]}`, 'ok');\n      refreshDistanceUI(v);\n    } else {\n      log(`Edge ${u}→${v} did not relax (dist[${v}] remains ${dv===Infinity? '∞': dv}).`);\n      refreshDistanceUI();\n    }\n\n    edgeIndex++;\n    if (edgeIndex >= edges.length) {\n      // done an iteration\n      iter++;\n      edgeIndex = 0;\n    }\n    draw();\n  }\n\n  function highlightEdgeTemp(e) {\n    // temporarily draw edge highlighted\n    draw();\n    const u = nodes.find(n => n.id === e.u);\n    const v = nodes.find(n => n.id === e.v);\n    if (!u || !v) return;\n    const ang = Math.atan2(v.y-u.y, v.x-u.x);\n    const offset = 18;\n    const startX = u.x + Math.cos(ang)*offset;\n    const startY = u.y + Math.sin(ang)*offset;\n    const endX = v.x - Math.cos(ang)*offset;\n    const endY = v.y - Math.sin(ang)*offset;\n    ctx.beginPath();\n    ctx.strokeStyle = edgeHighlightColor;\n    ctx.lineWidth = 3;\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n    if (directed) drawArrowhead(endX,endY,ang);\n    // highlight weight\n    const mx = (startX+endX)/2, my = (startY+endY)/2;\n    ctx.beginPath();\n    ctx.fillStyle = edgeHighlightColor;\n    ctx.font = '12px system-ui';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(e.w, mx + Math.cos(ang+Math.PI/2)*12, my + Math.sin(ang+Math.PI/2)*12);\n  }\n\n  function highlightNegativeEdge(e) {\n    draw();\n    const u = nodes.find(n => n.id === e.u);\n    const v = nodes.find(n => n.id === e.v);\n    if (!u || !v) return;\n    const ang = Math.atan2(v.y-u.y, v.x-u.x);\n    const offset = 18;\n    const startX = u.x + Math.cos(ang)*offset;\n    const startY = u.y + Math.sin(ang)*offset;\n    const endX = v.x - Math.cos(ang)*offset;\n    const endY = v.y - Math.sin(ang)*offset;\n    ctx.beginPath();\n    ctx.strokeStyle = negativeCycleColor;\n    ctx.lineWidth = 4;\n    ctx.setLineDash([8,4]);\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n    ctx.setLineDash([]);\n    if (directed) drawArrowhead(endX,endY,ang);\n  }\n\n  function updateStatus(msg, kind='info') {\n    statusEl.textContent = msg;\n    if (kind === 'ok') statusEl.className = 'statusOk';\n    else if (kind === 'warn') statusEl.className = 'statusWarn';\n    else statusEl.className = 'small';\n  }\n\n  // Sample graph\n  sampleBtn.onclick = () => {\n    clearGraph();\n    // create sample graph (with negative edge)\n    const n0 = addNode(80,80);\n    const n1 = addNode(260,60);\n    const n2 = addNode(420,120);\n    const n3 = addNode(200,200);\n    const n4 = addNode(340,240);\n    // edges\n    addEdge(n0.id, n1.id, 6);\n    addEdge(n0.id, n3.id, 7);\n    addEdge(n1.id, n2.id, 5);\n    addEdge(n1.id, n3.id, 8);\n    addEdge(n1.id, n4.id, -4);\n    addEdge(n3.id, n2.id, -3);\n    addEdge(n3.id, n4.id, 9);\n    addEdge(n4.id, n2.id, 7);\n    directedChk.checked = true; directed = true;\n    negAllowChk.checked = true; allowNegative = true;\n    updateCounts();\n    log('Sample graph loaded (classic Bellman-Ford example).');\n  };\n\n  // Random graph generator\n  randomBtn.onclick = () => {\n    clearGraph();\n    const N = Math.max(3, Math.min(8, Math.floor(Math.random()*6)+3));\n    for (let i=0;i<N;i++) {\n      addNode(80 + Math.random()*(wrap.clientWidth-160), 60 + Math.random()*(wrap.clientHeight-120));\n    }\n    directed = directedChk.checked;\n    allowNegative = negAllowChk.checked;\n    // add random edges\n    for (let i=0;i<N*2;i++) {\n      const a = nodes[Math.floor(Math.random()*nodes.length)].id;\n      const b = nodes[Math.floor(Math.random()*nodes.length)].id;\n      if (a === b) continue;\n      let w = Math.floor(Math.random()*11)-5; // -5..5\n      if (!allowNegative && w<0) w = Math.abs(w);\n      addEdge(a,b,w);\n    }\n    updateCounts();\n    log('Random graph generated.');\n  };\n\n  clearBtn.onclick = clearGraph;\n\n  function clearGraph() {\n    nodes = [];\n    edges = [];\n    nextNodeId = 0;\n    nextEdgeId = 0;\n    addingEdgeFrom = null;\n    sourceNode = null;\n    dist = {};\n    pred = {};\n    iter = 0;\n    edgeIndex = 0;\n    running = false;\n    clearInterval(runTimer);\n    updateCounts();\n    draw();\n    log('Cleared graph.');\n  }\n\n  // Initialization\n  resize();\n  setModeButtonStyles();\n  updateCounts();\n  updateStatus('Idle. Create a graph and set a source to begin.', 'info');\n\n  // Simple helpful default graph to start\n  (function autoSample(){\n    // small default graph\n    clearGraph();\n    const A = addNode(120,100);\n    const B = addNode(260,70);\n    const C = addNode(400,110);\n    const D = addNode(200,220);\n    addEdge(A.id,B.id, 4);\n    addEdge(A.id,D.id, 5);\n    addEdge(B.id,C.id, -2);\n    addEdge(C.id,D.id, 3);\n    addEdge(D.id,B.id, 1);\n    directed = true; directedChk.checked = true;\n    negAllowChk.checked = true; allowNegative = true;\n    updateCounts();\n    log('Default demo graph placed. Set source and Step/Run to see Bellman-Ford.');\n  })();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": false,
  "hasTest": true
}