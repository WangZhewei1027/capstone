{
  "id": "be87d8a5-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:35.006Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Linear Regression",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Interactive Linear Regression Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, Arial; margin: 16px; color: #111; }\n    h1 { margin: 0 0 8px 0; font-size: 20px; }\n    p.lead { margin: 0 0 12px 0; color: #444; font-size: 14px; }\n    .container { display: flex; gap: 16px; flex-wrap: wrap; }\n    .panel { background: #fff; border: 1px solid #ddd; padding: 12px; border-radius: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.03); }\n    #left { flex: 1 1 640px; min-width: 320px; }\n    #right { width: 360px; min-width: 280px; }\n    canvas { background: linear-gradient(#fcfeff,#f7fbff); border-radius: 6px; display:block; width:100%; height: 420px; }\n    #costCanvas { width:100%; height:140px; background:#fafafa; border-radius:6px; display:block; }\n    .controls { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }\n    .controls > * { margin: 0; }\n    button { background:#2563eb; color:white; border:none; padding:8px 10px; border-radius:6px; cursor:pointer; }\n    button.secondary { background:#6b7280; }\n    button.warn { background:#b91c1c; }\n    button:disabled { opacity:0.5; cursor:not-allowed; }\n    label { display:block; font-size:12px; color:#444; margin-top:8px; }\n    input[type=\"range\"] { width:100%; }\n    input[type=\"number\"], input[type=\"text\"] { padding:6px 8px; border-radius:6px; border:1px solid #ccc; width:100%; box-sizing:border-box; }\n    .stat-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:8px; }\n    .stat { background:#fbfdff; border:1px solid #eef2ff; padding:8px; border-radius:6px; font-size:13px; }\n    .small { font-size:12px; color:#555; }\n    .hint { font-size:12px; color:#666; margin-top:8px; }\n    .footer { margin-top:12px; font-size:12px; color:#666; }\n    .row { display:flex; gap:8px; }\n    .flex { flex:1; }\n  </style>\n</head>\n<body>\n  <h1>Linear Regression — Interactive Demo</h1>\n  <p class=\"lead\">Click on the main plot to add points. Use \"Normal Eq.\" (closed-form) or run Gradient Descent to fit y = θ0 + θ1·x. Generate synthetic data, adjust noise, learning rate, and watch the cost decrease.</p>\n\n  <div class=\"container\">\n    <div id=\"left\" class=\"panel\">\n      <canvas id=\"plot\" width=\"800\" height=\"420\"></canvas>\n      <div class=\"controls\">\n        <button id=\"btnNormal\">Normal Eq. (closed-form)</button>\n        <button id=\"btnRunGD\">Run GD</button>\n        <button id=\"btnPause\" class=\"secondary\" disabled>Pause</button>\n        <button id=\"btnStep\" class=\"secondary\">Step 100 iters</button>\n        <button id=\"btnClear\" class=\"warn\">Clear</button>\n        <button id=\"btnUndo\" class=\"secondary\">Undo</button>\n      </div>\n\n      <div class=\"row\" style=\"margin-top:10px; gap:12px;\">\n        <div style=\"flex:1\">\n          <label>Learning rate (α): <span id=\"alphaVal\">0.01</span></label>\n          <input type=\"range\" id=\"alpha\" min=\"0.0001\" max=\"1\" step=\"0.0001\" value=\"0.01\">\n        </div>\n        <div style=\"width:120px;\">\n          <label>Batch iters / animate</label>\n          <input type=\"number\" id=\"iters\" min=\"1\" step=\"1\" value=\"50\">\n        </div>\n      </div>\n\n      <div style=\"display:flex; gap:12px; margin-top:10px;\">\n        <div style=\"flex:1\">\n          <label>Predict x (domain -10..10)</label>\n          <input type=\"number\" id=\"predictX\" value=\"0\" step=\"0.1\">\n        </div>\n        <div style=\"width:160px;\">\n          <label>Prediction y</label>\n          <input type=\"text\" id=\"predictY\" readonly>\n        </div>\n      </div>\n\n      <div style=\"margin-top:10px;\">\n        <label>Cost (MSE) history</label>\n        <canvas id=\"costCanvas\" width=\"800\" height=\"140\"></canvas>\n      </div>\n    </div>\n\n    <div id=\"right\" class=\"panel\">\n      <h3>Model & stats</h3>\n      <div class=\"stat-grid\">\n        <div class=\"stat\"><strong>θ0 (intercept)</strong><div id=\"theta0\" class=\"small\">—</div></div>\n        <div class=\"stat\"><strong>θ1 (slope)</strong><div id=\"theta1\" class=\"small\">—</div></div>\n        <div class=\"stat\"><strong>MSE</strong><div id=\"mse\" class=\"small\">—</div></div>\n        <div class=\"stat\"><strong>R²</strong><div id=\"r2\" class=\"small\">—</div></div>\n      </div>\n\n      <div style=\"margin-top:12px;\">\n        <h4>Data generation</h4>\n        <label>Points</label>\n        <input type=\"number\" id=\"genN\" value=\"40\" min=\"2\" step=\"1\">\n        <label>True slope (θ1)</label>\n        <input type=\"number\" id=\"trueSlope\" value=\"1.5\" step=\"0.1\">\n        <label>True intercept (θ0)</label>\n        <input type=\"number\" id=\"trueIntercept\" value=\"-1.0\" step=\"0.1\">\n        <label>Noise σ (std dev)</label>\n        <input type=\"number\" id=\"noise\" value=\"2.0\" step=\"0.1\">\n        <div class=\"controls\" style=\"margin-top:8px;\">\n          <button id=\"btnGen\">Generate</button>\n          <button id=\"btnGenClear\" class=\"secondary\">Generate & Replace</button>\n        </div>\n      </div>\n\n      <div class=\"footer\">\n        Tips: Click to add points. Use Normal Eq. for exact fit (closed-form). Gradient Descent learns gradually — change α if it diverges or is too slow.\n      </div>\n    </div>\n  </div>\n\n<script>\n(function(){\n  // Data & model\n  let xs = []; let ys = [];\n  let theta0 = 0, theta1 = 0;\n  let costHistory = [];\n  const domain = {minX:-10, maxX:10, minY:-10, maxY:10};\n\n  // DOM\n  const plot = document.getElementById('plot');\n  const ctx = plot.getContext('2d');\n  const costCanvas = document.getElementById('costCanvas');\n  const cctx = costCanvas.getContext('2d');\n\n  const btnNormal = document.getElementById('btnNormal');\n  const btnRunGD = document.getElementById('btnRunGD');\n  const btnPause = document.getElementById('btnPause');\n  const btnStep = document.getElementById('btnStep');\n  const btnClear = document.getElementById('btnClear');\n  const btnUndo = document.getElementById('btnUndo');\n  const alphaSlider = document.getElementById('alpha');\n  const alphaVal = document.getElementById('alphaVal');\n  const itersInput = document.getElementById('iters');\n  const predictX = document.getElementById('predictX');\n  const predictY = document.getElementById('predictY');\n  const theta0El = document.getElementById('theta0');\n  const theta1El = document.getElementById('theta1');\n  const mseEl = document.getElementById('mse');\n  const r2El = document.getElementById('r2');\n\n  const genN = document.getElementById('genN');\n  const trueSlope = document.getElementById('trueSlope');\n  const trueIntercept = document.getElementById('trueIntercept');\n  const noiseInput = document.getElementById('noise');\n  const btnGen = document.getElementById('btnGen');\n  const btnGenClear = document.getElementById('btnGenClear');\n\n  // Animation / GD control\n  let running = false;\n  let gdTimer = null;\n\n  // Helpers: map domain to canvas\n  function xToCanvas(x){\n    const w = plot.width;\n    return ( (x - domain.minX) / (domain.maxX - domain.minX) ) * w;\n  }\n  function yToCanvas(y){\n    const h = plot.height;\n    // invert y (canvas y grows downward)\n    return h - ( (y - domain.minY) / (domain.maxY - domain.minY) ) * h;\n  }\n  function canvasToX(px){\n    const w = plot.width;\n    return domain.minX + (px / w) * (domain.maxX - domain.minX);\n  }\n  function canvasToY(py){\n    const h = plot.height;\n    return domain.minY + ((h - py) / h) * (domain.maxY - domain.minY);\n  }\n\n  // Drawing\n  function clearPlot(){\n    ctx.clearRect(0,0,plot.width,plot.height);\n    // background\n    ctx.fillStyle = \"rgba(250,252,255,0.6)\";\n    ctx.fillRect(0,0,plot.width,plot.height);\n    // grid lines\n    ctx.strokeStyle = \"#eef4ff\";\n    ctx.lineWidth = 1;\n    const step = 5;\n    for(let x = Math.ceil(domain.minX); x<=domain.maxX; x+=step){\n      const px = xToCanvas(x);\n      ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,plot.height); ctx.stroke();\n    }\n    for(let y = Math.ceil(domain.minY); y<=domain.maxY; y+=step){\n      const py = yToCanvas(y);\n      ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(plot.width,py); ctx.stroke();\n    }\n    // axes\n    ctx.strokeStyle = \"#333\";\n    ctx.lineWidth = 1.4;\n    // x axis (y=0)\n    if(domain.minY <= 0 && domain.maxY >= 0){\n      const py = yToCanvas(0);\n      ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(plot.width,py); ctx.stroke();\n    }\n    // y axis (x=0)\n    if(domain.minX <= 0 && domain.maxX >= 0){\n      const px = xToCanvas(0);\n      ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,plot.height); ctx.stroke();\n    }\n  }\n\n  function drawPoints(){\n    ctx.fillStyle = \"#0ea5a4\";\n    for(let i=0;i<xs.length;i++){\n      const px = xToCanvas(xs[i]), py = yToCanvas(ys[i]);\n      ctx.beginPath();\n      ctx.arc(px,py,5,0,Math.PI*2);\n      ctx.fill();\n      ctx.strokeStyle = \"rgba(0,0,0,0.08)\";\n      ctx.lineWidth = 1;\n      ctx.stroke();\n    }\n  }\n\n  function drawLine(){\n    // draw regression line y = theta0 + theta1*x\n    if(typeof theta0 !== \"number\" || typeof theta1 !== \"number\") return;\n    // compute y at left and right domain edges\n    const xL = domain.minX; const xR = domain.maxX;\n    const yL = theta0 + theta1 * xL;\n    const yR = theta0 + theta1 * xR;\n    ctx.strokeStyle = \"#ef4444\";\n    ctx.lineWidth = 2.2;\n    ctx.beginPath();\n    ctx.moveTo(xToCanvas(xL), yToCanvas(yL));\n    ctx.lineTo(xToCanvas(xR), yToCanvas(yR));\n    ctx.stroke();\n\n    // draw predicted point if provided\n    const px = Number(predictX.value);\n    if(!isNaN(px)){\n      const pyVal = theta0 + theta1 * px;\n      predictY.value = pyVal.toFixed(3);\n      ctx.fillStyle = \"rgba(239,68,68,0.95)\";\n      ctx.beginPath(); ctx.arc(xToCanvas(px), yToCanvas(pyVal), 6,0,Math.PI*2); ctx.fill();\n      ctx.strokeStyle = \"#fff\"; ctx.lineWidth = 1; ctx.stroke();\n    } else {\n      predictY.value = \"\";\n    }\n  }\n\n  function redraw(){\n    clearPlot();\n    drawPoints();\n    if(xs.length>0) drawLine();\n    drawCost();\n    updateStats();\n  }\n\n  // Cost & stats\n  function computeMSE(t0, t1){\n    if(xs.length===0) return Infinity;\n    let s = 0;\n    for(let i=0;i<xs.length;i++){\n      const pred = t0 + t1*xs[i];\n      const e = pred - ys[i];\n      s += e*e;\n    }\n    return s / xs.length;\n  }\n  function computeR2(t0, t1){\n    if(xs.length===0) return NaN;\n    let ssRes=0, ssTot=0;\n    const ybar = ys.reduce((a,b)=>a+b,0)/ys.length;\n    for(let i=0;i<ys.length;i++){\n      ssRes += Math.pow( (ys[i] - (t0 + t1*xs[i])) , 2);\n      ssTot += Math.pow(ys[i] - ybar, 2);\n    }\n    return 1 - (ssRes/ssTot || 1);\n  }\n  function updateStats(){\n    theta0El.textContent = Number(theta0).toFixed(5);\n    theta1El.textContent = Number(theta1).toFixed(5);\n    const mse = computeMSE(theta0, theta1);\n    mseEl.textContent = (isFinite(mse) ? mse.toFixed(5) : \"—\");\n    const r2 = computeR2(theta0, theta1);\n    r2El.textContent = (isNaN(r2) ? \"—\" : r2.toFixed(4));\n  }\n\n  // Normal equation (single feature): slope = cov(x,y)/var(x), intercept = ybar - slope*xbar\n  function fitNormalEq(){\n    if(xs.length < 2){\n      alert(\"Need at least 2 points to fit.\");\n      return;\n    }\n    const n = xs.length;\n    const xbar = xs.reduce((a,b)=>a+b,0)/n;\n    const ybar = ys.reduce((a,b)=>a+b,0)/n;\n    let num=0, den=0;\n    for(let i=0;i<n;i++){\n      num += (xs[i]-xbar)*(ys[i]-ybar);\n      den += (xs[i]-xbar)*(xs[i]-xbar);\n    }\n    if(Math.abs(den) < 1e-12){\n      alert(\"Cannot fit: all x values are (nearly) identical.\");\n      return;\n    }\n    theta1 = num/den;\n    theta0 = ybar - theta1 * xbar;\n    costHistory.push(computeMSE(theta0, theta1));\n    redraw();\n  }\n\n  // Gradient descent (batch)\n  function gradientDescentStep(alpha, iterations){\n    if(xs.length === 0) return;\n    const n = xs.length;\n    // perform 'iterations' batch updates\n    for(let it=0; it<iterations; it++){\n      let grad0 = 0, grad1 = 0;\n      for(let i=0;i<n;i++){\n        const pred = theta0 + theta1 * xs[i];\n        const err = pred - ys[i];\n        grad0 += err;\n        grad1 += err * xs[i];\n      }\n      grad0 /= n; grad1 /= n;\n      theta0 -= alpha * grad0;\n      theta1 -= alpha * grad1;\n      // record cost occasionally\n      if(it % Math.max(1, Math.floor(iterations/10)) === 0){\n        costHistory.push(computeMSE(theta0, theta1));\n      }\n    }\n  }\n\n  // Cost plot\n  function drawCost(){\n    const w = costCanvas.width;\n    const h = costCanvas.height;\n    cctx.clearRect(0,0,w,h);\n    // background\n    cctx.fillStyle = \"#fff\";\n    cctx.fillRect(0,0,w,h);\n    // axes\n    cctx.strokeStyle = \"#e6eefc\";\n    cctx.lineWidth = 1;\n    cctx.beginPath(); cctx.moveTo(0,h-20); cctx.lineTo(w,h-20); cctx.stroke();\n    if(costHistory.length===0) return;\n    // compute y scale\n    const maxC = Math.max(...costHistory);\n    const minC = Math.min(...costHistory);\n    const span = Math.max(1e-8, maxC - minC);\n    cctx.strokeStyle = \"#2563eb\";\n    cctx.lineWidth = 2;\n    cctx.beginPath();\n    for(let i=0;i<costHistory.length;i++){\n      const x = (i/(costHistory.length-1)) * w;\n      const y = h-20 - ((costHistory[i]-minC)/span) * (h-40);\n      if(i===0) cctx.moveTo(x,y); else cctx.lineTo(x,y);\n    }\n    cctx.stroke();\n    // draw latest value\n    cctx.fillStyle = \"#111827\";\n    cctx.font = \"12px sans-serif\";\n    const last = costHistory[costHistory.length-1];\n    cctx.fillText(\"Latest cost: \" + last.toFixed(4), 6, 14);\n  }\n\n  // Events\n  plot.addEventListener('click', (e)=>{\n    const rect = plot.getBoundingClientRect();\n    const px = (e.clientX - rect.left) * (plot.width / rect.width);\n    const py = (e.clientY - rect.top) * (plot.height / rect.height);\n    const x = canvasToX(px);\n    const y = canvasToY(py);\n    xs.push(x); ys.push(y);\n    // when adding first point, initialize model to pass through it simply\n    if(xs.length===1){ theta0 = ys[0]; theta1 = 0; costHistory = []; }\n    costHistory.push(computeMSE(theta0,theta1));\n    redraw();\n  });\n\n  btnClear.addEventListener('click', ()=>{\n    xs = []; ys = []; costHistory = []; theta0 = 0; theta1 = 0;\n    redraw();\n  });\n  btnUndo.addEventListener('click', ()=>{\n    if(xs.length>0){ xs.pop(); ys.pop(); costHistory = []; redraw(); }\n  });\n  btnNormal.addEventListener('click', ()=>{\n    fitNormalEq();\n  });\n\n  alphaSlider.addEventListener('input', ()=>{\n    alphaVal.textContent = Number(alphaSlider.value).toFixed(4);\n  });\n\n  btnStep.addEventListener('click', ()=>{\n    const iters = Math.max(1, parseInt(itersInput.value || 50));\n    gradientDescentStep(Number(alphaSlider.value), iters);\n    costHistory.push(computeMSE(theta0, theta1));\n    redraw();\n  });\n\n  btnRunGD.addEventListener('click', ()=>{\n    if(running) return;\n    running = true;\n    btnRunGD.disabled = true;\n    btnPause.disabled = false;\n    const iters = Math.max(1, parseInt(itersInput.value || 50));\n    // animate: repeatedly do 'iters' iterations every 100ms\n    gdTimer = setInterval(()=>{\n      gradientDescentStep(Number(alphaSlider.value), iters);\n      costHistory.push(computeMSE(theta0, theta1));\n      redraw();\n    }, 120);\n  });\n\n  btnPause.addEventListener('click', ()=>{\n    if(!running) return;\n    running = false;\n    btnRunGD.disabled = false;\n    btnPause.disabled = true;\n    if(gdTimer) clearInterval(gdTimer);\n    gdTimer = null;\n  });\n\n  predictX.addEventListener('input', redraw);\n\n  // Data generation\n  function generateData(n, slope, intercept, noise, replace){\n    if(replace){ xs = []; ys = []; costHistory = []; }\n    for(let i=0;i<n;i++){\n      const x = Math.random()*(domain.maxX-domain.minX)+domain.minX;\n      const y = intercept + slope * x + gaussRand()*noise;\n      xs.push(x); ys.push(y);\n    }\n    // initialize theta by normal eq for convenience\n    fitNormalEq();\n    redraw();\n  }\n  function gaussRand(){\n    // Box-Muller\n    let u=0,v=0;\n    while(u===0) u=Math.random();\n    while(v===0) v=Math.random();\n    return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);\n  }\n\n  btnGen.addEventListener('click', ()=>{\n    const n = Math.max(1, parseInt(genN.value||40));\n    const slope = Number(trueSlope.value);\n    const intercept = Number(trueIntercept.value);\n    const noise = Math.max(0, Number(noiseInput.value));\n    generateData(n, slope, intercept, noise, false);\n  });\n  btnGenClear.addEventListener('click', ()=>{\n    const n = Math.max(1, parseInt(genN.value||40));\n    const slope = Number(trueSlope.value);\n    const intercept = Number(trueIntercept.value);\n    const noise = Math.max(0, Number(noiseInput.value));\n    generateData(n, slope, intercept, noise, true);\n  });\n\n  // Resize canvases to devicePixelRatio to keep crisp\n  function fixHiDPI(){\n    [plot,costCanvas].forEach(canvas=>{\n      const ratio = window.devicePixelRatio || 1;\n      const w = canvas.clientWidth;\n      const h = canvas.clientHeight;\n      canvas.width = Math.floor(w * ratio);\n      canvas.height = Math.floor(h * ratio);\n      const ctx = canvas.getContext('2d');\n      ctx.setTransform(ratio,0,0,ratio,0,0);\n    });\n    redraw();\n  }\n  window.addEventListener('resize', fixHiDPI);\n  fixHiDPI();\n\n  // initial example\n  generateData(30, 1.5, -1.0, 2.0, true);\n\n  // small keyboard shortcuts\n  window.addEventListener('keydown',(e)=>{\n    if(e.key === \" \") { // space toggles run/pause\n      e.preventDefault();\n      if(!running) btnRunGD.click(); else btnPause.click();\n    } else if(e.key === \"n\" || e.key === \"N\") { btnNormal.click(); }\n    else if(e.key === \"c\" || e.key === \"C\") { btnClear.click(); }\n    else if(e.key === \"u\" || e.key === \"U\") { btnUndo.click(); }\n  });\n\n  // expose for debugging (not required)\n  window.__lr_demo = { xs, ys };\n\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Linear Regression"
    }
  ],
  "topic": "Linear Regression",
  "hasFSM": false,
  "hasTest": true
}