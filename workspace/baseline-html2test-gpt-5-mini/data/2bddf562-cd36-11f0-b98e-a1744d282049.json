{
  "id": "2bddf562-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:17:06.403Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Hash Table",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Hash Table Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#7dd3fc;\n      --muted:#94a3b8;\n      --card:#071025;\n      --green:#86efac;\n      --red:#fda4af;\n      --yellow:#fde68a;\n      --glass: rgba(255,255,255,0.03);\n      --glass-2: rgba(255,255,255,0.02);\n      --shadow: 0 6px 18px rgba(2,6,23,0.6);\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg,var(--bg),#041025);\n      color:#e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app{\n      max-width:1100px;\n      margin:28px auto;\n      padding:20px;\n    }\n    header{\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n      gap:16px;\n      margin-bottom:14px;\n    }\n    header h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:0.2px;\n    }\n    .controls{\n      display:flex;\n      gap:12px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .card{\n      background: linear-gradient(180deg,var(--card),rgba(255,255,255,0.02));\n      border-radius:12px;\n      padding:12px;\n      box-shadow:var(--shadow);\n    }\n    .inputs{\n      display:flex;\n      gap:10px;\n      align-items:center;\n    }\n    input[type=\"text\"], input[type=\"number\"]{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      padding:8px 10px;\n      border-radius:8px;\n      color:inherit;\n      outline:none;\n      min-width:120px;\n    }\n    select{\n      padding:8px 10px;\n      border-radius:8px;\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:inherit;\n    }\n    button{\n      background:linear-gradient(180deg,var(--accent),#38bdf8);\n      border:none;\n      color:#022;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      box-shadow: 0 6px 18px rgba(3, 105, 161, 0.18);\n    }\n    button.ghost{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.06);\n      color:var(--muted);\n      box-shadow:none;\n    }\n    .main{\n      display:grid;\n      grid-template-columns: 1fr 360px;\n      gap:16px;\n      margin-top:16px;\n    }\n    .visual{\n      min-height:420px;\n      padding:12px;\n      border-radius:12px;\n      background:linear-gradient(180deg,var(--panel), rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n    }\n    .buckets{\n      display:flex;\n      flex-wrap:wrap;\n      gap:8px;\n    }\n    .bucket{\n      width: calc(33.333% - 10px);\n      min-width:150px;\n      background:var(--glass);\n      border-radius:10px;\n      padding:8px;\n      border:1px solid rgba(255,255,255,0.03);\n      position:relative;\n      transition:transform 240ms ease, box-shadow 180ms ease;\n    }\n    .bucket.highlight{\n      transform:translateY(-6px) scale(1.02);\n      box-shadow:0 8px 30px rgba(125,211,252,0.12);\n      border-color: rgba(125,211,252,0.18);\n    }\n    .bucket .idx{\n      font-size:12px;\n      color:var(--muted);\n    }\n    .bucket .content{\n      margin-top:6px;\n      display:flex;\n      gap:8px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .node{\n      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));\n      border-radius:8px;\n      padding:6px 8px;\n      border:1px solid rgba(255,255,255,0.04);\n      display:flex;\n      gap:8px;\n      align-items:center;\n      min-width:60px;\n    }\n    .node .k{ font-weight:700; color:var(--accent); }\n    .node .v{ font-size:12px; color:var(--muted); }\n    .node.tombstone{\n      opacity:0.5;\n      border-style:dashed;\n    }\n    .info{\n      padding:12px;\n      border-radius:12px;\n      background:linear-gradient(180deg,var(--card), rgba(255,255,255,0.02));\n      border:1px solid rgba(255,255,255,0.04);\n      height:100%;\n      display:flex;\n      flex-direction:column;\n      gap:10px;\n    }\n    .stats{\n      display:flex;\n      gap:8px;\n      flex-wrap:wrap;\n      align-items:center;\n    }\n    .stat{\n      background:var(--glass-2);\n      padding:8px 10px;\n      border-radius:8px;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .log{\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border-radius:8px;\n      padding:8px;\n      overflow:auto;\n      max-height:320px;\n      font-family: monospace;\n      font-size:13px;\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .log .entry{\n      padding:6px 0;\n      border-bottom:1px dashed rgba(255,255,255,0.02);\n    }\n    footer{\n      margin-top:18px;\n      color:var(--muted);\n      font-size:13px;\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n    }\n    .mode-indicator{\n      padding:6px 10px;\n      border-radius:8px;\n      background:rgba(255,255,255,0.02);\n      border:1px solid rgba(255,255,255,0.03);\n      font-weight:600;\n      color:var(--muted);\n    }\n    .small{\n      font-size:12px;\n      color:var(--muted);\n    }\n    .controls-right{\n      display:flex;\n      gap:8px;\n      align-items:center;\n    }\n    .bucket .chain{\n      display:flex;\n      gap:6px;\n      align-items:center;\n      flex-wrap:wrap;\n    }\n    .hint{\n      font-size:13px;\n      color:var(--muted);\n      margin-top:8px;\n    }\n\n    /* responsive */\n    @media (max-width:920px){\n      .main{ grid-template-columns: 1fr; }\n      .bucket{ width: calc(50% - 10px); }\n    }\n    @media (max-width:540px){\n      header{ flex-direction:column; align-items:flex-start; gap:12px; }\n      .bucket{ width:100%; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <header>\n      <div>\n        <h1>Hash Table Interactive Demo</h1>\n        <div class=\"small\">Explore hashing, collisions, probing & chaining, rehashing and load factor visually.</div>\n      </div>\n\n      <div class=\"controls\">\n        <div class=\"card inputs\">\n          <input id=\"keyInput\" type=\"text\" placeholder=\"Key (string)\" />\n          <input id=\"valInput\" type=\"text\" placeholder=\"Value\" />\n          <button id=\"insertBtn\">Insert / Update</button>\n          <button id=\"getBtn\" class=\"ghost\">Get</button>\n          <button id=\"delBtn\" class=\"ghost\">Delete</button>\n        </div>\n\n        <div class=\"card inputs\">\n          <label class=\"small\">Mode:</label>\n          <select id=\"modeSelect\">\n            <option value=\"chaining\">Separate Chaining</option>\n            <option value=\"open\">Open Addressing (Linear Probing)</option>\n          </select>\n\n          <label class=\"small\">Capacity:</label>\n          <input id=\"capInput\" type=\"number\" min=\"3\" max=\"256\" value=\"12\" />\n\n          <button id=\"applyCap\" class=\"ghost\">Apply</button>\n        </div>\n\n        <div class=\"card inputs\">\n          <button id=\"randBtn\" class=\"ghost\">Insert 6 Random</button>\n          <button id=\"clearBtn\" class=\"ghost\">Clear</button>\n          <button id=\"stepBtn\" class=\"ghost\">Step Insert</button>\n        </div>\n      </div>\n    </header>\n\n    <div class=\"main\">\n      <div class=\"visual card\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;\">\n          <div class=\"small\">Buckets (indices 0 .. capacity-1)</div>\n          <div class=\"small\">Click a node to highlight its bucket and key details.</div>\n        </div>\n        <div id=\"buckets\" class=\"buckets\" aria-live=\"polite\"></div>\n\n        <div class=\"hint small\">Tip: Try collisions by inserting keys that hash to the same bucket (e.g., \"ab\" and \"ba\" with simple hash).</div>\n      </div>\n\n      <aside class=\"info\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <div>\n            <div class=\"stat\">Mode: <span id=\"modeIndicator\" class=\"mode-indicator\">Separate Chaining</span></div>\n          </div>\n          <div style=\"text-align:right\">\n            <div>Hash function: djb2 (string → integer)</div>\n          </div>\n        </div>\n\n        <div class=\"stats\">\n          <div class=\"stat\">Capacity: <strong id=\"capacity\">12</strong></div>\n          <div class=\"stat\">Size: <strong id=\"size\">0</strong></div>\n          <div class=\"stat\">Load Factor: <strong id=\"load\">0.00</strong></div>\n          <div class=\"stat\">Collisions: <strong id=\"collisions\">0</strong></div>\n        </div>\n\n        <div style=\"display:flex;gap:8px;align-items:center;\">\n          <button id=\"rehashBtn\" class=\"ghost\">Rehash (resize & reinsert)</button>\n          <label class=\"small\">Auto-resize</label>\n          <input id=\"autoResize\" type=\"checkbox\" checked />\n        </div>\n\n        <div class=\"small\" style=\"margin-top:6px;\">Operation Log</div>\n        <div id=\"log\" class=\"log\" aria-live=\"polite\"></div>\n      </aside>\n    </div>\n\n    <footer>\n      <div class=\"small\">Demonstration of hashing concepts. Separate chaining uses arrays of key/value pairs. Open addressing uses linear probing with tombstones.</div>\n      <div class=\"small\">Built-in hash: djb2 (case-sensitive strings).</div>\n    </footer>\n  </div>\n\n  <script>\n    /*********************************************************************\n     * Hash Table Demo\n     * - Supports two modes: Separate Chaining and Open Addressing (linear probing).\n     * - Visualizes buckets, collisions, tombstones, resizing and operations.\n     *********************************************************************/\n\n    // Utility helpers\n    const $ = (id) => document.getElementById(id);\n    const sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\n    // djb2 string hash (returns non-negative integer)\n    function djb2Hash(str) {\n      let h = 5381;\n      for (let i = 0; i < str.length; i++) {\n        h = ((h << 5) + h) + str.charCodeAt(i); // h * 33 + c\n        // keep in JS safe int range by truncating periodically\n        h = h & 0xFFFFFFFF;\n      }\n      return Math.abs(h >>> 0);\n    }\n\n    class HashTable {\n      constructor(capacity = 12, mode = 'chaining', onChange = ()=>{}) {\n        this.mode = mode; // 'chaining' or 'open'\n        this.capacity = Math.max(3, Math.floor(capacity));\n        this.onChange = onChange;\n        this.reset();\n      }\n\n      reset(){\n        this.size = 0;\n        this.collisions = 0;\n        this.tombstones = 0;\n        if (this.mode === 'chaining') {\n          this.buckets = new Array(this.capacity).fill(null).map(()=>[]);\n        } else {\n          this.buckets = new Array(this.capacity).fill(null); // null = empty, {k,v} = used, TOMBSTONE = {__T:true}\n          this.TOMBSTONE = {__T: true};\n        }\n        this.onChange();\n      }\n\n      _indexFor(key) {\n        const h = djb2Hash(String(key));\n        return {hash: h, idx: h % this.capacity};\n      }\n\n      // Insert or update\n      insert(key, value) {\n        if (this.mode === 'chaining') {\n          const {hash, idx} = this._indexFor(key);\n          const bucket = this.buckets[idx];\n          const existing = bucket.find(item => item.k === key);\n          if (existing) {\n            existing.v = value;\n            this.onChange && this.onChange({type:'update', key, value, hash, idx});\n            return {updated:true, idx, hash};\n          } else {\n            if (bucket.length > 0) this.collisions++;\n            bucket.push({k:key, v:value});\n            this.size++;\n            this._autoResizeCheck();\n            this.onChange && this.onChange({type:'insert', key, value, hash, idx});\n            return {inserted:true, idx, hash};\n          }\n        } else {\n          // open addressing linear probing\n          const {hash, idx} = this._indexFor(key);\n          let i = idx;\n          let firstTombstone = -1;\n          let steps = 0;\n          while (true) {\n            const slot = this.buckets[i];\n            if (slot === null) {\n              // empty slot\n              const place = firstTombstone >=0 ? firstTombstone : i;\n              if (firstTombstone >=0) {\n                this.tombstones--;\n                this.buckets[place] = {k:key, v:value};\n              } else {\n                this.buckets[place] = {k:key, v:value};\n              }\n              if (steps > 0) this.collisions++;\n              this.size++;\n              this._autoResizeCheck();\n              this.onChange && this.onChange({type:'insert', key, value, hash, idx:place, steps});\n              return {inserted:true, idx:place, hash, steps};\n            } else if (slot === this.TOMBSTONE) {\n              if (firstTombstone < 0) firstTombstone = i;\n            } else if (slot.k === key) {\n              // update existing\n              slot.v = value;\n              this.onChange && this.onChange({type:'update', key, value, hash, idx:i, steps});\n              return {updated:true, idx:i, hash, steps};\n            }\n            i = (i+1) % this.capacity;\n            steps++;\n            if (steps > this.capacity) {\n              // table full\n              throw new Error('HashTable is full');\n            }\n          }\n        }\n      }\n\n      get(key) {\n        if (this.mode === 'chaining') {\n          const {hash, idx} = this._indexFor(key);\n          const bucket = this.buckets[idx];\n          const found = bucket.find(item => item.k === key);\n          this.onChange && this.onChange({type:'get', key, found, hash, idx});\n          return found ? found.v : undefined;\n        } else {\n          const {hash, idx} = this._indexFor(key);\n          let i = idx;\n          let steps = 0;\n          while (true) {\n            const slot = this.buckets[i];\n            if (slot === null) {\n              this.onChange && this.onChange({type:'get', key, found:false, hash, idx:i, steps});\n              return undefined;\n            } else if (slot !== this.TOMBSTONE && slot.k === key) {\n              this.onChange && this.onChange({type:'get', key, found:true, value:slot.v, hash, idx:i, steps});\n              return slot.v;\n            }\n            i = (i+1) % this.capacity;\n            steps++;\n            if (steps > this.capacity) {\n              this.onChange && this.onChange({type:'get', key, found:false, hash});\n              return undefined;\n            }\n          }\n        }\n      }\n\n      delete(key) {\n        if (this.mode === 'chaining') {\n          const {hash, idx} = this._indexFor(key);\n          const bucket = this.buckets[idx];\n          const i = bucket.findIndex(item => item.k === key);\n          if (i >= 0) {\n            const removed = bucket.splice(i,1)[0];\n            this.size--;\n            this.onChange && this.onChange({type:'delete', key, removed, hash, idx});\n            return true;\n          } else {\n            this.onChange && this.onChange({type:'delete', key, removed:null, hash, idx});\n            return false;\n          }\n        } else {\n          const {hash, idx} = this._indexFor(key);\n          let i = idx;\n          let steps = 0;\n          while (true) {\n            const slot = this.buckets[i];\n            if (slot === null) {\n              this.onChange && this.onChange({type:'delete', key, found:false, hash});\n              return false;\n            } else if (slot !== this.TOMBSTONE && slot.k === key) {\n              this.buckets[i] = this.TOMBSTONE;\n              this.size--;\n              this.tombstones++;\n              this.onChange && this.onChange({type:'delete', key, found:true, hash, idx:i, steps});\n              return true;\n            }\n            i = (i+1) % this.capacity;\n            steps++;\n            if (steps > this.capacity) {\n              this.onChange && this.onChange({type:'delete', key, found:false, hash});\n              return false;\n            }\n          }\n        }\n      }\n\n      // manual rehash/resizing\n      rehash(newCap = null) {\n        const old = {mode:this.mode, capacity:this.capacity, buckets:this.buckets};\n        const entries = [];\n        if (this.mode === 'chaining') {\n          for (let b of this.buckets) for (let it of b) entries.push({k:it.k,v:it.v});\n        } else {\n          for (let s of this.buckets) {\n            if (s && s !== this.TOMBSTONE) entries.push({k:s.k,v:s.v});\n          }\n        }\n        this.capacity = newCap ? Math.max(3, Math.floor(newCap)) : this.capacity;\n        this.size = 0;\n        this.collisions = 0;\n        this.tombstones = 0;\n        if (this.mode === 'chaining') this.buckets = new Array(this.capacity).fill(null).map(()=>[]);\n        else this.buckets = new Array(this.capacity).fill(null);\n\n        // reinsert sequentially (count collisions as we go)\n        for (let e of entries) this.insert(e.k, e.v);\n        this.onChange && this.onChange({type:'rehash', from:old, to:{capacity:this.capacity}});\n      }\n\n      // auto resize heuristics\n      _autoResizeCheck() {\n        if (!appState.autoResize) return;\n        const load = this.size / this.capacity;\n        if (this.mode === 'chaining') {\n          // expand when average chain length > 2\n          if (load > 2.0) {\n            this.rehash(Math.max(3, Math.floor(this.capacity * 2)));\n          }\n          if (load < 0.25 && this.capacity > 6) {\n            this.rehash(Math.max(6, Math.floor(this.capacity / 2)));\n          }\n        } else {\n          if (load > 0.6) {\n            this.rehash(Math.max(3, Math.floor(this.capacity * 2)));\n          }\n          if (load < 0.2 && this.capacity > 8) {\n            this.rehash(Math.max(8, Math.floor(this.capacity / 2)));\n          }\n        }\n      }\n\n      entries() {\n        if (this.mode === 'chaining') {\n          return this.buckets.map((b, idx) => ({idx, bucket:b.slice()}));\n        } else {\n          return this.buckets.map((s, idx) => ({idx, slot:s}));\n        }\n      }\n    }\n\n    // App state and UI wiring\n    const appState = {\n      mode: 'chaining',\n      capacity: 12,\n      autoResize: true,\n      stepping: false\n    };\n\n    // Create initial table\n    let table = new HashTable(appState.capacity, appState.mode, onTableChange);\n\n    // DOM refs\n    const bucketsEl = $('buckets');\n    const capEl = $('capacity');\n    const sizeEl = $('size');\n    const loadEl = $('load');\n    const collEl = $('collisions');\n    const logEl = $('log');\n    const modeIndicator = $('modeIndicator');\n\n    function formatNumber(n, decimals=2) {\n      return Number.isFinite(n) ? n.toFixed(decimals) : '—';\n    }\n\n    // Render visualization\n    function render() {\n      // update stats\n      $('capacity').textContent = table.capacity;\n      $('size').textContent = table.size;\n      $('load').textContent = formatNumber(table.size / table.capacity, 2);\n      $('collisions').textContent = table.collisions;\n\n      modeIndicator.textContent = table.mode === 'chaining' ? 'Separate Chaining' : 'Open Addressing';\n      // Clear and recreate bucket elements\n      bucketsEl.innerHTML = '';\n      const entries = table.entries();\n      for (let e of entries) {\n        const b = document.createElement('div');\n        b.className = 'bucket';\n        b.dataset.idx = e.idx;\n        const idx = document.createElement('div');\n        idx.className = 'idx';\n        idx.textContent = 'Index ' + e.idx;\n        const content = document.createElement('div');\n        content.className = 'content';\n\n        if (table.mode === 'chaining') {\n          const arr = e.bucket;\n          if (arr.length === 0) {\n            const empty = document.createElement('div');\n            empty.className = 'small';\n            empty.style.opacity = 0.6;\n            empty.textContent = '(empty)';\n            content.appendChild(empty);\n          } else {\n            const chain = document.createElement('div');\n            chain.className = 'chain';\n            for (let it of arr) {\n              const node = document.createElement('div');\n              node.className = 'node';\n              node.tabIndex = 0;\n              node.innerHTML = `<span class=\"k\">${escapeHtml(it.k)}</span><span class=\"v\">${escapeHtml(String(it.v))}</span>`;\n              node.title = `key: ${it.k}\\nvalue: ${it.v}`;\n              node.onclick = () => highlightBucket(e.idx, it.k);\n              chain.appendChild(node);\n            }\n            content.appendChild(chain);\n          }\n        } else {\n          const slot = e.slot;\n          if (slot === null) {\n            const empty = document.createElement('div');\n            empty.className = 'small';\n            empty.style.opacity = 0.6;\n            empty.textContent = '(empty)';\n            content.appendChild(empty);\n          } else if (slot && slot.__T) {\n            const tomb = document.createElement('div');\n            tomb.className = 'node tombstone';\n            tomb.textContent = 'TOMBSTONE';\n            content.appendChild(tomb);\n          } else {\n            const node = document.createElement('div');\n            node.className = 'node';\n            node.innerHTML = `<span class=\"k\">${escapeHtml(slot.k)}</span><span class=\"v\">${escapeHtml(String(slot.v))}</span>`;\n            node.title = `key: ${slot.k}\\nvalue: ${slot.v}`;\n            node.onclick = () => highlightBucket(e.idx, slot.k);\n            content.appendChild(node);\n          }\n        }\n\n        b.appendChild(idx);\n        b.appendChild(content);\n        bucketsEl.appendChild(b);\n      }\n    }\n\n    // small helper to escape HTML for display\n    function escapeHtml(s) {\n      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');\n    }\n\n    // Logging\n    function log(msg, type='info') {\n      const ent = document.createElement('div');\n      ent.className = 'entry';\n      const time = new Date().toLocaleTimeString();\n      ent.innerHTML = `<div style=\"color:${type==='error'?'#fda4af':'#94a3b8'};\">[${time}] ${escapeHtml(msg)}</div>`;\n      logEl.prepend(ent);\n    }\n\n    // on change callback for table actions\n    async function onTableChange(evt) {\n      if (!evt) {\n        render();\n        return;\n      }\n      // handle events and display nice messages\n      switch(evt.type) {\n        case 'insert':\n          log(`Insert key=\"${evt.key}\" value=\"${evt.value}\" → bucket ${evt.idx} (hash ${evt.hash})`);\n          break;\n        case 'update':\n          log(`Update key=\"${evt.key}\" set value=\"${evt.value}\" → bucket ${evt.idx} (hash ${evt.hash})`);\n          break;\n        case 'get':\n          if (evt.found) {\n            log(`Get key=\"${evt.key}\" found value=\"${evt.value ?? '(object)'}\" at bucket ${evt.idx} (hash ${evt.hash})`);\n          } else {\n            log(`Get key=\"${evt.key}\" not found (hash ${evt.hash})`);\n          }\n          break;\n        case 'delete':\n          if (evt.found || evt.removed) {\n            log(`Delete key=\"${evt.key}\" removed from bucket ${evt.idx || '—'}`);\n          } else {\n            log(`Delete key=\"${evt.key}\" not found`);\n          }\n          break;\n        case 'rehash':\n          log(`Rehash performed. New capacity: ${table.capacity}`);\n          break;\n        default:\n          log(JSON.stringify(evt));\n      }\n      render();\n      // highlight bucket briefly for visual feedback\n      if (evt.idx !== undefined) await flashBucket(evt.idx);\n    }\n\n    async function flashBucket(idx) {\n      const node = document.querySelector(`.bucket[data-idx=\"${idx}\"]`);\n      if (!node) return;\n      node.classList.add('highlight');\n      await sleep(550);\n      node.classList.remove('highlight');\n    }\n\n    function highlightBucket(idx, key) {\n      // highlight and log details\n      const node = document.querySelector(`.bucket[data-idx=\"${idx}\"]`);\n      if (!node) return;\n      node.classList.add('highlight');\n      setTimeout(()=>node.classList.remove('highlight'), 800);\n      const h = djb2Hash(String(key));\n      log(`Highlighted: key=\"${key}\" → hash ${h} → index ${idx}`);\n    }\n\n    // UI event bindings\n    $('insertBtn').addEventListener('click', async () => {\n      const k = $('keyInput').value.trim();\n      const v = $('valInput').value;\n      if (!k) { log('Key required', 'error'); return; }\n      try {\n        table.insert(k, v);\n      } catch (err) {\n        log('Error: ' + err.message, 'error');\n      }\n    });\n\n    $('getBtn').addEventListener('click', () => {\n      const k = $('keyInput').value.trim();\n      if (!k) { log('Key required', 'error'); return; }\n      const val = table.get(k);\n      if (val === undefined) log(`Get: key=\"${k}\" → not found`);\n      else log(`Get: key=\"${k}\" → value=\"${val}\"`);\n    });\n\n    $('delBtn').addEventListener('click', () => {\n      const k = $('keyInput').value.trim();\n      if (!k) { log('Key required', 'error'); return; }\n      const ok = table.delete(k);\n      if (ok) log(`Deleted key=\"${k}\"`);\n      else log(`Key=\"${k}\" not found`);\n      render();\n    });\n\n    $('modeSelect').addEventListener('change', (e) => {\n      const mode = e.target.value;\n      appState.mode = mode;\n      // rebuild table with same capacity but clear\n      table.mode = mode;\n      table.reset();\n      log(`Switched mode to ${mode === 'chaining'? 'Separate Chaining' : 'Open Addressing'}`);\n    });\n\n    $('capInput').addEventListener('change', (e) => {\n      const val = parseInt(e.target.value, 10);\n      if (!isNaN(val) && val >= 3) appState.capacity = val;\n    });\n\n    $('applyCap').addEventListener('click', () => {\n      const newCap = parseInt($('capInput').value, 10) || appState.capacity;\n      appState.capacity = Math.max(3, newCap);\n      table.capacity = appState.capacity;\n      table.reset();\n      log(`Applied capacity = ${table.capacity} (table cleared)`);\n    });\n\n    $('randBtn').addEventListener('click', () => {\n      const samples = [\n        ['apple', 5], ['banana', 3], ['car', 'red'], ['dog', 'bark'], ['egg', 'oval'],\n        ['foo', 1], ['bar', 2], ['baz', 3], ['qux', 'x'], ['quux', 'y'], ['alpha', 'A'],\n        ['beta','B']\n      ];\n      for (let i=0;i<6;i++) {\n        const s = samples[Math.floor(Math.random()*samples.length)];\n        try { table.insert(s[0]+Math.floor(Math.random()*1000), s[1]); } catch(e){ log(e.message,'error'); }\n      }\n    });\n\n    $('clearBtn').addEventListener('click', () => {\n      table.reset();\n      log('Cleared table');\n    });\n\n    $('rehashBtn').addEventListener('click', () => {\n      const suggested = Math.max(3, table.capacity * 2);\n      table.rehash(suggested);\n      log('Rehashed explicitly to capacity ' + table.capacity);\n    });\n\n    $('autoResize').addEventListener('change', (e) => {\n      appState.autoResize = e.target.checked;\n      log('Auto-resize ' + (appState.autoResize ? 'enabled' : 'disabled'));\n    });\n\n    // Step-by-step insertion visualizer (async)\n    $('stepBtn').addEventListener('click', async () => {\n      const k = $('keyInput').value.trim();\n      const v = $('valInput').value;\n      if (!k) { log('Key required for step insert', 'error'); return; }\n      await stepInsert(k, v);\n    });\n\n    async function stepInsert(key, val) {\n      // Visual step: compute hash, target idx, then show traversal\n      const {hash, idx} = table._indexFor(key);\n      log(`STEP: Compute hash for \"${key}\" → ${hash}, index = ${idx}`);\n      await flashBucket(idx);\n      if (table.mode === 'chaining') {\n        const bucket = table.buckets[idx];\n        if (bucket.length === 0) {\n          log(`Bucket ${idx} empty → directly insert`);\n          table.insert(key, val);\n          await flashBucket(idx);\n        } else {\n          log(`Bucket ${idx} has ${bucket.length} item(s). Traverse chain to check for key or append.`);\n          // highlight nodes in chain sequentially\n          for (let i=0;i<bucket.length;i++) {\n            const it = bucket[i];\n            const nodeEl = queryNodeElement(idx, it.k);\n            if (nodeEl) {\n              nodeEl.classList.add('highlight');\n              await sleep(500);\n              nodeEl.classList.remove('highlight');\n            } else {\n              await sleep(400);\n            }\n            if (it.k === key) {\n              log(`Found existing key in chain → update value`);\n              table.insert(key, val); // will update\n              return;\n            }\n          }\n          log(`Key not found in chain → append to bucket ${idx}`);\n          table.insert(key, val);\n        }\n      } else {\n        log(`Open addressing linear probing from index ${idx}`);\n        let i = idx;\n        let steps = 0;\n        while (true) {\n          const slot = table.buckets[i];\n          const bEl = document.querySelector(`.bucket[data-idx=\"${i}\"]`);\n          if (bEl) {\n            bEl.classList.add('highlight');\n            await sleep(520);\n            bEl.classList.remove('highlight');\n          }\n          if (slot === null || slot === table.TOMBSTONE) {\n            log(`Empty slot at ${i} → insert here`);\n            table.insert(key, val);\n            return;\n          } else if (slot.k === key) {\n            log(`Found existing key at ${i} → update`);\n            table.insert(key, val);\n            return;\n          } else {\n            log(`Slot ${i} occupied by \"${slot.k}\". Probe next.`);\n          }\n          i = (i+1) % table.capacity;\n          steps++;\n          if (steps > table.capacity) {\n            log('Table full. Cannot insert.', 'error');\n            return;\n          }\n        }\n      }\n    }\n\n    function queryNodeElement(bucketIdx, key) {\n      const b = document.querySelector(`.bucket[data-idx=\"${bucketIdx}\"]`);\n      if (!b) return null;\n      const nodes = b.querySelectorAll('.node');\n      for (let n of nodes) {\n        if (n.textContent.includes(key)) return n;\n      }\n      return null;\n    }\n\n    // Initialize UI\n    function init() {\n      $('modeSelect').value = appState.mode;\n      $('capInput').value = appState.capacity;\n      $('autoResize').checked = appState.autoResize;\n      render();\n      log('Demo ready. Mode: ' + (appState.mode === 'chaining' ? 'Separate Chaining' : 'Open Addressing'));\n    }\n\n    init();\n\n    // Seed with a few entries to show collisions\n    (function seed(){\n      try {\n        table.insert('ab','1');\n        table.insert('ba','2'); // might collide depending on hash\n        table.insert('apple', 'fruit');\n        table.insert('applf', 'fruit2');\n        table.insert('car','vehicle');\n        table.insert('arc','arch');\n      } catch(e){}\n      render();\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Hash Table"
    }
  ],
  "topic": "Hash Table",
  "hasFSM": false,
  "hasTest": true
}