{
  "id": "2bde6a9b-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:30.180Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Linear Regression",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Interactive Linear Regression Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, Arial; margin: 16px; color:#111; }\n    h1 { margin: 0 0 8px 0; font-size: 20px; }\n    .container { display: flex; gap:16px; flex-wrap:wrap; }\n    .panel { background:#fff; border:1px solid #ddd; padding:10px; border-radius:8px; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }\n    .left { flex: 1 1 640px; min-width:320px; }\n    .right { width:320px; min-width:260px; }\n    canvas { background: #f8f9fb; border-radius:6px; width:100%; height:420px; display:block; }\n    label { display:block; margin-top:8px; font-size:13px; }\n    input[type=\"range\"] { width:100%; }\n    .row { display:flex; gap:8px; align-items:center; margin-top:8px; }\n    button { padding:6px 10px; border-radius:6px; border:1px solid #bbb; background:#f4f6f8; cursor:pointer; }\n    button.primary { background:#2b7cff; color:white; border-color:#1f63d6; }\n    small { color:#555; display:block; margin-top:6px; }\n    .stats { font-size:14px; line-height:1.4; }\n    .muted { color:#666; font-size:12px; margin-top:6px; }\n    input[type=\"number\"] { width:100%; padding:6px; border-radius:6px; border:1px solid #ccc; }\n    .inline { display:flex; gap:8px; align-items:center; }\n    .legend { display:flex; gap:10px; margin-top:8px; flex-wrap:wrap; }\n    .legend-item { display:flex; gap:6px; align-items:center; font-size:13px; color:#444; }\n    .swatch { width:12px; height:12px; border-radius:3px; display:inline-block; }\n    footer { margin-top:12px; font-size:12px; color:#666; }\n  </style>\n</head>\n<body>\n  <h1>Interactive Linear Regression</h1>\n  <div class=\"container\">\n    <div class=\"panel left\">\n      <canvas id=\"plot\" width=\"800\" height=\"420\"></canvas>\n      <div class=\"legend\">\n        <div class=\"legend-item\"><span class=\"swatch\" style=\"background:#2b7cff\"></span> Fit (Gradient Descent)</div>\n        <div class=\"legend-item\"><span class=\"swatch\" style=\"background:#ff5c5c\"></span> Closed-form (Normal Eq.)</div>\n        <div class=\"legend-item\"><span class=\"swatch\" style=\"background:#333\"></span> Data points</div>\n      </div>\n      <small class=\"muted\">Click on the plot to add points. Drag vertically while holding Shift to adjust noise when generating synthetic data.</small>\n    </div>\n\n    <div class=\"panel right\">\n      <div>\n        <label>Data controls</label>\n        <div class=\"row\">\n          <button id=\"randBtn\">Generate Random Data</button>\n          <button id=\"clearBtn\">Clear</button>\n        </div>\n        <div class=\"row\">\n          <label style=\"flex:1\">Number of points: <span id=\"nPtsLabel\">30</span></label>\n        </div>\n        <input id=\"nPts\" type=\"range\" min=\"5\" max=\"200\" value=\"30\" />\n        <label>True slope (for synthetic): <span id=\"trueSlopeLabel\">1.2</span></label>\n        <input id=\"trueSlope\" type=\"range\" min=\"-3\" max=\"3\" step=\"0.1\" value=\"1.2\" />\n        <label>True intercept: <span id=\"trueIntLabel\">0.0</span></label>\n        <input id=\"trueInt\" type=\"range\" min=\"-5\" max=\"5\" step=\"0.1\" value=\"0\" />\n        <label>Noise std (σ): <span id=\"noiseLabel\">1.0</span></label>\n        <input id=\"noise\" type=\"range\" min=\"0\" max=\"4\" step=\"0.1\" value=\"1\" />\n      </div>\n\n      <hr />\n\n      <div>\n        <label>Gradient Descent</label>\n        <label>Learning rate α: <span id=\"lrLabel\">0.01</span></label>\n        <input id=\"lr\" type=\"range\" min=\"0.0001\" max=\"0.5\" step=\"0.0001\" value=\"0.01\" />\n        <label>Iterations per second: <span id=\"iterLabel\">200</span></label>\n        <input id=\"itersPerSec\" type=\"range\" min=\"10\" max=\"2000\" step=\"10\" value=\"200\" />\n        <div class=\"row\">\n          <button id=\"startBtn\" class=\"primary\">Start GD</button>\n          <button id=\"stopBtn\">Stop</button>\n          <button id=\"resetGD\">Reset params</button>\n        </div>\n        <small class=\"muted\">Gradient descent uses batch updates minimizing mean squared error.</small>\n      </div>\n\n      <hr />\n\n      <div class=\"stats\">\n        <div><strong>Parameters</strong></div>\n        <div>Gradient Descent: m = <span id=\"mGD\">—</span>, b = <span id=\"bGD\">—</span></div>\n        <div>Closed-form: m = <span id=\"mCF\">—</span>, b = <span id=\"bCF\">—</span></div>\n        <div>Loss (MSE) GD: <span id=\"lossGD\">—</span></div>\n        <div>Loss (MSE) CF: <span id=\"lossCF\">—</span></div>\n        <div>RMSE GD: <span id=\"rmseGD\">—</span>, RMSE CF: <span id=\"rmseCF\">—</span></div>\n      </div>\n\n      <hr />\n\n      <div>\n        <label>Predict</label>\n        <div class=\"row\">\n          <input id=\"xPred\" type=\"number\" placeholder=\"x value\" />\n          <button id=\"predBtn\">Predict</button>\n        </div>\n        <div id=\"predResult\" class=\"muted\"></div>\n      </div>\n      <footer>\n        Demo: closed-form (normal equation) vs. gradient descent. Click to add points; generate synthetic linear data; watch the fit update.\n      </footer>\n    </div>\n  </div>\n\n<script>\n/*\nInteractive Linear Regression demo\n- Click the canvas to add points\n- Generate synthetic data with a true slope/intercept and Gaussian noise\n- Fit using closed-form (ordinary least squares) and using batch gradient descent\n- Visualize data points and fitted lines; show metrics\n*/\n\n// Canvas & coordinate helpers\nconst canvas = document.getElementById('plot');\nconst ctx = canvas.getContext('2d');\nconst W = canvas.width;\nconst H = canvas.height;\nconst padding = 40;\n\n// Data storage\nlet points = []; // array of {x,y} in data coordinates (x,y in range chosen below)\n\n// Default data coordinate ranges\nlet xMin = -10, xMax = 10, yMin = -10, yMax = 10;\n\n// Parameters for gradient descent\nlet mGD = 0.0, bGD = 0.0;\nlet learningRate = parseFloat(document.getElementById('lr').value);\nlet gdRunning = false;\nlet gdTimer = null;\nlet itersPerSec = parseInt(document.getElementById('itersPerSec').value);\n\n// DOM elements\nconst randBtn = document.getElementById('randBtn');\nconst clearBtn = document.getElementById('clearBtn');\nconst nPtsInput = document.getElementById('nPts');\nconst nPtsLabel = document.getElementById('nPtsLabel');\nconst trueSlopeInput = document.getElementById('trueSlope');\nconst trueIntInput = document.getElementById('trueInt');\nconst noiseInput = document.getElementById('noise');\nconst trueSlopeLabel = document.getElementById('trueSlopeLabel');\nconst trueIntLabel = document.getElementById('trueIntLabel');\nconst noiseLabel = document.getElementById('noiseLabel');\n\nconst startBtn = document.getElementById('startBtn');\nconst stopBtn = document.getElementById('stopBtn');\nconst resetGDBtn = document.getElementById('resetGD');\n\nconst lrInput = document.getElementById('lr');\nconst lrLabel = document.getElementById('lrLabel');\nconst itersPerSecInput = document.getElementById('itersPerSec');\nconst iterLabel = document.getElementById('iterLabel');\n\nconst mGDSpan = document.getElementById('mGD');\nconst bGDSpan = document.getElementById('bGD');\nconst mCFSpan = document.getElementById('mCF');\nconst bCFSpan = document.getElementById('bCF');\nconst lossGDSpan = document.getElementById('lossGD');\nconst lossCFSpan = document.getElementById('lossCF');\nconst rmseGDSpan = document.getElementById('rmseGD');\nconst rmseCFSpan = document.getElementById('rmseCF');\n\nconst xPredInput = document.getElementById('xPred');\nconst predBtn = document.getElementById('predBtn');\nconst predResult = document.getElementById('predResult');\n\n// Utils: map data coord -> pixel and vice versa\nfunction xToPixel(x) {\n  return padding + ((x - xMin) / (xMax - xMin)) * (W - 2 * padding);\n}\nfunction yToPixel(y) {\n  // canvas y increases downward\n  return H - padding - ((y - yMin) / (yMax - yMin)) * (H - 2 * padding);\n}\nfunction pixelToX(px) {\n  return xMin + ((px - padding) / (W - 2 * padding)) * (xMax - xMin);\n}\nfunction pixelToY(py) {\n  return yMin + ((H - padding - py) / (H - 2 * padding)) * (yMax - yMin);\n}\n\n// Draw axes, grid, points, and lines\nfunction draw() {\n  ctx.clearRect(0,0,W,H);\n  drawGrid();\n  drawAxes();\n  drawPoints();\n  drawFitLines();\n}\n\n// draw axes and tick labels\nfunction drawAxes() {\n  ctx.strokeStyle = '#666';\n  ctx.lineWidth = 1;\n  ctx.beginPath();\n  // x axis\n  let y0 = yToPixel(0);\n  ctx.moveTo(padding, y0);\n  ctx.lineTo(W - padding, y0);\n  ctx.stroke();\n  // y axis\n  let x0 = xToPixel(0);\n  ctx.beginPath();\n  ctx.moveTo(x0, padding);\n  ctx.lineTo(x0, H - padding);\n  ctx.stroke();\n\n  // ticks\n  ctx.fillStyle = '#333';\n  ctx.font = '12px system-ui, sans-serif';\n  ctx.textAlign = 'center';\n  for (let i = Math.ceil(xMin); i <= Math.floor(xMax); i++) {\n    let px = xToPixel(i);\n    ctx.beginPath();\n    ctx.moveTo(px, y0 - 4);\n    ctx.lineTo(px, y0 + 4);\n    ctx.stroke();\n    ctx.fillText(i.toString(), px, y0 + 16);\n  }\n  ctx.textAlign = 'right';\n  for (let j = Math.ceil(yMin); j <= Math.floor(yMax); j++) {\n    let py = yToPixel(j);\n    ctx.beginPath();\n    ctx.moveTo(x0 - 4, py);\n    ctx.lineTo(x0 + 4, py);\n    ctx.stroke();\n    ctx.fillText(j.toString(), x0 - 8, py + 4);\n  }\n}\n\n// soft grid\nfunction drawGrid() {\n  ctx.fillStyle = '#f8f9fb';\n  ctx.fillRect(0,0,W,H);\n  ctx.strokeStyle = '#eee';\n  ctx.lineWidth = 1;\n  for (let i = Math.ceil(xMin); i <= Math.floor(xMax); i++) {\n    let px = xToPixel(i);\n    ctx.beginPath();\n    ctx.moveTo(px, padding);\n    ctx.lineTo(px, H-padding);\n    ctx.stroke();\n  }\n  for (let j = Math.ceil(yMin); j <= Math.floor(yMax); j++) {\n    let py = yToPixel(j);\n    ctx.beginPath();\n    ctx.moveTo(padding, py);\n    ctx.lineTo(W-padding, py);\n    ctx.stroke();\n  }\n}\n\n// draw points\nfunction drawPoints() {\n  for (let p of points) {\n    let px = xToPixel(p.x);\n    let py = yToPixel(p.y);\n    ctx.beginPath();\n    ctx.fillStyle = '#222';\n    ctx.strokeStyle = '#fff';\n    ctx.lineWidth = 1;\n    ctx.arc(px, py, 5, 0, Math.PI*2);\n    ctx.fill();\n    ctx.stroke();\n  }\n}\n\n// draw fitted lines: GD in blue, closed-form in red\nfunction drawFitLines() {\n  // helper to draw line from xMin to xMax\n  function drawLine(m, b, color, width=2, dash=null) {\n    if (!isFinite(m) || !isFinite(b)) return;\n    const x1 = xMin, y1 = m * x1 + b;\n    const x2 = xMax, y2 = m * x2 + b;\n    const p1x = xToPixel(x1), p1y = yToPixel(y1);\n    const p2x = xToPixel(x2), p2y = yToPixel(y2);\n    ctx.beginPath();\n    ctx.moveTo(p1x, p1y);\n    ctx.lineTo(p2x, p2y);\n    ctx.strokeStyle = color;\n    ctx.lineWidth = width;\n    if (dash) ctx.setLineDash(dash); else ctx.setLineDash([]);\n    ctx.stroke();\n    ctx.setLineDash([]);\n  }\n  // gradient descent line (blue)\n  drawLine(mGD, bGD, '#2b7cff', 3, null);\n  // closed-form line (red, dashed)\n  const cf = closedFormFit(points);\n  if (cf) drawLine(cf.m, cf.b, '#ff5c5c', 2, [6,6]);\n}\n\n// Compute closed-form least squares for simple linear regression\nfunction closedFormFit(pts) {\n  if (!pts || pts.length === 0) return null;\n  const n = pts.length;\n  let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;\n  for (let p of pts) {\n    sumX += p.x;\n    sumY += p.y;\n    sumXY += p.x * p.y;\n    sumXX += p.x * p.x;\n  }\n  const xBar = sumX / n;\n  const yBar = sumY / n;\n  const denom = (sumXX - n * xBar * xBar);\n  if (Math.abs(denom) < 1e-12) {\n    return {m: NaN, b: NaN};\n  }\n  const m = (sumXY - n * xBar * yBar) / denom;\n  const b = yBar - m * xBar;\n  return {m, b};\n}\n\n// Loss (MSE) and RMSE for given params\nfunction mseLoss(pts, m, b) {\n  if (!pts || pts.length === 0) return NaN;\n  let sum = 0;\n  for (let p of pts) {\n    const err = (m * p.x + b) - p.y;\n    sum += err * err;\n  }\n  return sum / pts.length;\n}\nfunction rmse(pts, m, b) {\n  const ms = mseLoss(pts, m, b);\n  return isFinite(ms) ? Math.sqrt(ms) : NaN;\n}\n\n// Gradient descent step (batch)\nfunction gradientDescentStep(pts, m, b, lr) {\n  const n = pts.length;\n  if (n === 0) return {m,b};\n  let dm = 0, db = 0;\n  for (let p of pts) {\n    const pred = m * p.x + b;\n    const err = pred - p.y;\n    dm += (2 / n) * err * p.x;\n    db += (2 / n) * err;\n  }\n  return { m: m - lr * dm, b: b - lr * db };\n}\n\n// Hooks and UI wiring\ncanvas.addEventListener('click', (ev) => {\n  const rect = canvas.getBoundingClientRect();\n  const px = (ev.clientX - rect.left) * (canvas.width / rect.width);\n  const py = (ev.clientY - rect.top) * (canvas.height / rect.height);\n  const x = pixelToX(px);\n  const y = pixelToY(py);\n  points.push({x,y});\n  // update axes scale dynamically to keep points visible (optional)\n  adjustBoundsToPoints();\n  recomputeAndRender();\n});\n\n// adjust plot bounds to include all points with margin\nfunction adjustBoundsToPoints() {\n  if (points.length === 0) {\n    xMin = -10; xMax = 10; yMin = -10; yMax = 10;\n    return;\n  }\n  const xs = points.map(p => p.x);\n  const ys = points.map(p => p.y);\n  const minX = Math.min(...xs), maxX = Math.max(...xs);\n  const minY = Math.min(...ys), maxY = Math.max(...ys);\n  const marginX = Math.max(1, (maxX - minX) * 0.2);\n  const marginY = Math.max(1, (maxY - minY) * 0.2);\n  xMin = minX - marginX; xMax = maxX + marginX;\n  yMin = minY - marginY; yMax = maxY + marginY;\n}\n\n// generate synthetic data\nfunction generateRandomData() {\n  const n = parseInt(nPtsInput.value);\n  const trueM = parseFloat(trueSlopeInput.value);\n  const trueB = parseFloat(trueIntInput.value);\n  const noiseStd = parseFloat(noiseInput.value);\n  points = [];\n  // sample x uniformly in [-8,8]\n  for (let i = 0; i < n; i++) {\n    const x = (Math.random() * 16) - 8;\n    // gaussian noise via Box-Muller\n    const u1 = Math.random(), u2 = Math.random();\n    const z = Math.sqrt(-2 * Math.log(Math.max(u1,1e-12))) * Math.cos(2*Math.PI*u2);\n    const y = trueM * x + trueB + z * noiseStd;\n    points.push({x,y});\n  }\n  adjustBoundsToPoints();\n  // initialize GD params near closed-form to speed convergence (optional)\n  const cf = closedFormFit(points);\n  if (cf) { mGD = cf.m + (Math.random()-0.5)*0.5; bGD = cf.b + (Math.random()-0.5)*0.5; }\n  recomputeAndRender();\n}\n\n// recompute closed-form and losses, update display, and draw\nfunction recomputeAndRender() {\n  // closed-form\n  const cf = closedFormFit(points);\n  if (cf) {\n    mCFSpan.textContent = isFinite(cf.m) ? cf.m.toFixed(4) : '—';\n    bCFSpan.textContent = isFinite(cf.b) ? cf.b.toFixed(4) : '—';\n    const lossCF = mseLoss(points, cf.m, cf.b);\n    lossCFSpan.textContent = isFinite(lossCF) ? lossCF.toFixed(4) : '—';\n    rmseCFSpan.textContent = isFinite(lossCF) ? Math.sqrt(lossCF).toFixed(4) : '—';\n  } else {\n    mCFSpan.textContent = '—'; bCFSpan.textContent = '—'; lossCFSpan.textContent = '—'; rmseCFSpan.textContent = '—';\n  }\n  const lossGD = mseLoss(points, mGD, bGD);\n  mGDSpan.textContent = isFinite(mGD) ? mGD.toFixed(4) : '—';\n  bGDSpan.textContent = isFinite(bGD) ? bGD.toFixed(4) : '—';\n  lossGDSpan.textContent = isFinite(lossGD) ? lossGD.toFixed(4) : '—';\n  rmseGDSpan.textContent = isFinite(lossGD) ? Math.sqrt(lossGD).toFixed(4) : '—';\n  draw();\n}\n\n// gradient descent loop\nfunction startGD() {\n  if (gdRunning) return;\n  gdRunning = true;\n  const intervalMs = 1000 / itersPerSec;\n  // we will perform multiple GD steps per timer callback to accommodate high iters/sec with smooth visuals\n  gdTimer = setInterval(() => {\n    // apply one batch step\n    const step = gradientDescentStep(points, mGD, bGD, learningRate);\n    mGD = step.m; bGD = step.b;\n    recomputeAndRender();\n  }, intervalMs);\n}\n\nfunction stopGD() {\n  if (!gdRunning) return;\n  clearInterval(gdTimer);\n  gdTimer = null;\n  gdRunning = false;\n}\n\n// restore params\nfunction resetGD() {\n  mGD = 0; bGD = 0;\n  recomputeAndRender();\n}\n\n// UI event wiring\nrandBtn.addEventListener('click', generateRandomData);\nclearBtn.addEventListener('click', () => { points = []; adjustBoundsToPoints(); recomputeAndRender(); });\n\nnPtsInput.addEventListener('input', () => { nPtsLabel.textContent = nPtsInput.value; });\ntrueSlopeInput.addEventListener('input', () => { trueSlopeLabel.textContent = trueSlopeInput.value; });\ntrueIntInput.addEventListener('input', () => { trueIntLabel.textContent = trueIntInput.value; });\nnoiseInput.addEventListener('input', () => { noiseLabel.textContent = noiseInput.value; });\n\nstartBtn.addEventListener('click', () => { startGD(); });\nstopBtn.addEventListener('click', () => { stopGD(); });\nresetGDBtn.addEventListener('click', () => { resetGD(); });\n\nlrInput.addEventListener('input', () => {\n  learningRate = parseFloat(lrInput.value);\n  lrLabel.textContent = learningRate.toFixed(4);\n});\niterLabel.textContent = itersPerSecInput.value;\nitersPerSecInput.addEventListener('input', () => {\n  itersPerSec = parseInt(itersPerSecInput.value);\n  iterLabel.textContent = itersPerSec;\n  if (gdRunning) { stopGD(); startGD(); }\n});\n\n// prediction\npredBtn.addEventListener('click', () => {\n  const xVal = parseFloat(xPredInput.value);\n  if (!isFinite(xVal)) { predResult.textContent = 'Enter a valid x value'; return; }\n  let out = '';\n  if (isFinite(mGD) && isFinite(bGD)) {\n    out += `GD: y = ${ (mGD * xVal + bGD).toFixed(4) } `;\n  }\n  const cf = closedFormFit(points);\n  if (cf && isFinite(cf.m) && isFinite(cf.b)) {\n    out += `(CF: y = ${(cf.m * xVal + cf.b).toFixed(4)})`;\n  }\n  predResult.textContent = out;\n});\n\n// keyboard: space toggles GD\nwindow.addEventListener('keydown', (e) => {\n  if (e.code === 'Space') {\n    e.preventDefault();\n    if (gdRunning) stopGD(); else startGD();\n  }\n});\n\n// initial set up\n(function init(){\n  // set default labels\n  nPtsLabel.textContent = nPtsInput.value;\n  trueSlopeLabel.textContent = trueSlopeInput.value;\n  trueIntLabel.textContent = trueIntInput.value;\n  noiseLabel.textContent = noiseInput.value;\n  lrLabel.textContent = lrInput.value;\n  iterLabel.textContent = itersPerSecInput.value;\n  // generate an initial dataset\n  generateRandomData();\n})();\n\n// small performance: animate continuous GD smoothly with requestAnimationFrame (optional enhancement)\n// We'll not do it here because the setInterval steps update and call draw() each step.\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Linear Regression"
    }
  ],
  "topic": "Linear Regression",
  "hasFSM": false,
  "hasTest": true
}