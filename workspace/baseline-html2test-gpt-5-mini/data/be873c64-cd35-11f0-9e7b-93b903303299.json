{
  "id": "be873c64-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:46.653Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Hash Table",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Interactive Hash Table Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --muted:#9aa7bd;\n      --accent:#6ee7b7;\n      --danger:#ff7b7b;\n      --card:#0b1320;\n      --glass: rgba(255,255,255,0.03);\n      font-family: Inter, Roboto, system-ui, Arial, sans-serif;\n    }\n    html,body{height:100%;margin:0;background:linear-gradient(120deg,#071021 0%,#081427 60%);color:#e6eef8;}\n    .wrap{max-width:1100px;margin:28px auto;padding:22px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);box-shadow:0 6px 30px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03);}\n    header{display:flex;gap:18px;align-items:center;margin-bottom:18px;}\n    h1{font-size:20px;margin:0;}\n    p.lead{margin:4px 0 0;color:var(--muted);font-size:13px;}\n    .controls{display:flex;gap:18px;flex-wrap:wrap;margin-top:12px;}\n    .card{background:var(--card);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);}\n    .card.small{padding:8px;}\n    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px;}\n    input[type=text], input[type=number], select{background:var(--glass);border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:8px;color:inherit;width:220px;}\n    button{background:linear-gradient(180deg,#0ea5a0,#087f75);color:#081622;border:0;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}\n    .btn-danger{background:linear-gradient(180deg,#ff6b6b,#ef4b4b);}\n    .btn-small{padding:6px 8px;font-size:13px}\n    .row{display:flex;gap:12px;align-items:center;}\n    .visual{margin-top:18px;padding:14px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:12px;border:1px solid rgba(255,255,255,0.02);}\n    .buckets{display:flex;gap:8px;flex-wrap:wrap;padding:6px;}\n    .bucket{min-width:88px;background:linear-gradient(180deg,#071323,#04202b);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);position:relative;}\n    .bucket .idx{position:absolute;top:-12px;left:8px;padding:4px 8px;border-radius:8px;background:rgba(255,255,255,0.03);font-size:12px;color:var(--muted);}\n    .items{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px;}\n    .item{background:linear-gradient(180deg,#0b2840,#06314a);padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);font-size:13px;}\n    .item.kv{display:flex;flex-direction:column;gap:4px;}\n    .key{font-weight:700;color:#d7eef9;}\n    .val{font-size:12px;color:var(--muted);padding-top:3px;}\n    .highlight{box-shadow:0 0 0 3px rgba(110,231,183,0.07);border-color:rgba(110,231,183,0.3)}\n    .notice{margin-top:12px;color:var(--muted);font-size:13px;}\n    .status{display:flex;gap:12px;margin-top:12px;flex-wrap:wrap;}\n    .chip{background:rgba(255,255,255,0.02);padding:8px 10px;border-radius:10px;font-size:13px;border:1px solid rgba(255,255,255,0.02);color:var(--muted)}\n    .explain{margin-top:14px;color:var(--muted);font-size:13px;line-height:1.45}\n    .small-muted{font-size:12px;color:var(--muted)}\n    .probe-seq{margin-top:10px;font-size:13px;color:var(--muted)}\n    .controls-right{margin-left:auto;display:flex;gap:10px;align-items:center}\n    .footer{margin-top:18px;color:var(--muted);font-size:12px}\n    .hash-box{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-weight:600}\n    .tomb{opacity:0.55;font-style:italic;color:#ffa691}\n    @media (max-width:900px){ .controls{flex-direction:column;} .controls-right{margin-left:0} .buckets{justify-content:center} }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <header>\n      <div>\n        <h1>Interactive Hash Table</h1>\n        <p class=\"lead\">Explore how a hash table stores key → value pairs, handles collisions, and resizes.</p>\n      </div>\n      <div class=\"controls-right\" style=\"margin-left:auto\">\n        <div class=\"card small\">\n          <label style=\"margin-bottom:4px\">Collision Method</label>\n          <select id=\"modeSelect\">\n            <option value=\"separate\">Separate chaining (buckets with lists)</option>\n            <option value=\"linear\">Open addressing (linear probing)</option>\n          </select>\n        </div>\n      </div>\n    </header>\n\n    <div class=\"controls\">\n      <div class=\"card\">\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <div style=\"min-width:240px\">\n            <label>Key (string)</label>\n            <input id=\"keyInput\" type=\"text\" placeholder=\"e.g. user:42\" />\n          </div>\n          <div style=\"min-width:160px\">\n            <label>Value (string)</label>\n            <input id=\"valueInput\" type=\"text\" placeholder=\"e.g. Alice\" />\n          </div>\n          <div>\n            <label>&nbsp;</label>\n            <div style=\"display:flex;gap:8px;\">\n              <button id=\"insertBtn\">Insert</button>\n              <button id=\"getBtn\" class=\"ghost\">Get</button>\n              <button id=\"delBtn\" class=\"ghost btn-danger\">Delete</button>\n            </div>\n          </div>\n        </div>\n        <div style=\"margin-top:10px;display:flex;gap:8px;align-items:center;\">\n          <div style=\"min-width:180px\">\n            <label>Initial buckets</label>\n            <input id=\"sizeInput\" type=\"number\" min=\"2\" max=\"1024\" value=\"8\" />\n          </div>\n          <div style=\"align-self:flex-end;\">\n            <button id=\"resetBtn\" class=\"ghost btn-small\">Reset table</button>\n          </div>\n          <div style=\"align-self:flex-end;\">\n            <button id=\"populateBtn\" class=\"ghost btn-small\">Populate sample</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"card\" style=\"min-width:260px;\">\n        <label>Hash info & load factor</label>\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <div class=\"hash-box\" id=\"hashInfo\">Index: —</div>\n          <div class=\"chip\" id=\"loadChip\">Load: 0 / 0</div>\n        </div>\n        <div class=\"probe-seq\" id=\"probeSeq\"></div>\n      </div>\n\n      <div class=\"card\" style=\"flex:1\">\n        <label>Actions</label>\n        <div style=\"display:flex;gap:8px;flex-wrap:wrap\">\n          <button id=\"rehashBtn\" class=\"ghost btn-small\">Force resize (double)</button>\n          <button id=\"clearBtn\" class=\"ghost btn-small\">Clear all</button>\n          <button id=\"explainBtn\" class=\"ghost btn-small\">Explain hash function</button>\n        </div>\n        <div class=\"notice\" id=\"notice\">Tip: Enter a key and press Insert. Click Get to locate a key and highlight where it lives.</div>\n      </div>\n    </div>\n\n    <div class=\"visual card\" id=\"visualArea\">\n      <div style=\"display:flex;align-items:center;justify-content:space-between;\">\n        <div style=\"display:flex;gap:12px;align-items:center;\">\n          <strong>Buckets</strong>\n          <span class=\"small-muted\">Visual representation of internal array slots</span>\n        </div>\n        <div style=\"display:flex;gap:8px;align-items:center;\">\n          <div class=\"small-muted\">Size</div>\n          <div class=\"chip\" id=\"sizeChip\">0</div>\n        </div>\n      </div>\n\n      <div class=\"buckets\" id=\"bucketsArea\" style=\"margin-top:12px;\"></div>\n\n      <div class=\"status\" id=\"statusArea\"></div>\n      <div class=\"explain\" id=\"explainArea\">\n        A hash table maps keys to indices using a hash function. This demo uses a simple string hash and shows two collision strategies:\n        separate chaining (each bucket holds a list) and open addressing with linear probing (store directly in slots and probe for next empty).\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      Built-in simple hash: for each character: h = (h * 31 + charCode) mod bigPrime, then index = h % capacity.\n    </div>\n  </div>\n\n  <script>\n    // Interactive Hash Table Demo\n    (function(){\n      // Utility: simple robust string hash (32-bit)\n      function stringHash(s) {\n        let h = 2166136261 >>> 0; // FNV-1a start\n        for (let i = 0; i < s.length; i++) {\n          h ^= s.charCodeAt(i);\n          h = Math.imul(h, 16777619) >>> 0;\n        }\n        return h >>> 0; // unsigned\n      }\n\n      // HashTable implementation supporting both modes\n      class HashTable {\n        constructor(size = 8, mode = 'separate') {\n          this.mode = mode; // 'separate' or 'linear'\n          this._init(size);\n        }\n        _init(size) {\n          this.capacity = Math.max(2, Math.floor(size));\n          this.count = 0;\n          this._tombstone = {__tombstone: true};\n          if (this.mode === 'separate') {\n            this.table = Array.from({length: this.capacity}, () => []);\n          } else {\n            this.table = Array.from({length: this.capacity}, () => null);\n          }\n        }\n        _hashToIndex(key) {\n          const h = stringHash(String(key));\n          return {raw: h, idx: h % this.capacity};\n        }\n        loadFactor() {\n          return this.count / this.capacity;\n        }\n        keysEntries() {\n          const out = [];\n          if (this.mode === 'separate') {\n            for (let i = 0; i < this.capacity; i++) {\n              for (const e of this.table[i]) out.push([e.key,e.value]);\n            }\n          } else {\n            for (const slot of this.table) {\n              if (slot && slot !== this._tombstone) out.push([slot.key, slot.value]);\n            }\n          }\n          return out;\n        }\n        put(key, value) {\n          if (this.mode === 'separate') return this._putSeparate(key, value);\n          return this._putLinear(key, value);\n        }\n        _putSeparate(key,value){\n          const {idx} = this._hashToIndex(key);\n          const bucket = this.table[idx];\n          for (const e of bucket) {\n            if (e.key === key) { e.value = value; return {inserted:false, idx}; }\n          }\n          bucket.push({key,value});\n          this.count++;\n          if (this.loadFactor() > 0.7) this._resize(this.capacity * 2);\n          return {inserted:true, idx};\n        }\n        _putLinear(key,value){\n          const {raw} = this._hashToIndex(key);\n          let idx = raw % this.capacity;\n          let firstTomb = -1;\n          for (let probe = 0; probe < this.capacity; probe++) {\n            const slot = this.table[idx];\n            if (slot === null) {\n              const useIdx = firstTomb >= 0 ? firstTomb : idx;\n              this.table[useIdx] = {key,value};\n              this.count++;\n              if (this.loadFactor() > 0.6) this._resize(this.capacity * 2);\n              return {inserted:true, idx:useIdx};\n            } else if (slot === this._tombstone) {\n              if (firstTomb < 0) firstTomb = idx;\n            } else if (slot.key === key) {\n              slot.value = value;\n              return {inserted:false, idx};\n            }\n            idx = (idx + 1) % this.capacity;\n          }\n          // full (rare)\n          this._resize(this.capacity * 2);\n          return this.put(key,value);\n        }\n        get(key) {\n          if (this.mode === 'separate') return this._getSeparate(key);\n          return this._getLinear(key);\n        }\n        _getSeparate(key){\n          const {idx,raw} = this._hashToIndex(key);\n          const bucket = this.table[idx];\n          for (const e of bucket) {\n            if (e.key === key) return {found:true,value:e.value, idx};\n          }\n          return {found:false, idx};\n        }\n        _getLinear(key){\n          const {raw} = this._hashToIndex(key);\n          let idx = raw % this.capacity;\n          for (let probe=0; probe < this.capacity; probe++){\n            const slot = this.table[idx];\n            if (slot === null) return {found:false, idx, probeSeq:null};\n            if (slot !== this._tombstone && slot.key === key) return {found:true, value:slot.value, idx, probeSeq:null};\n            idx = (idx+1) % this.capacity;\n          }\n          return {found:false, idx};\n        }\n        remove(key) {\n          if (this.mode === 'separate') return this._removeSeparate(key);\n          return this._removeLinear(key);\n        }\n        _removeSeparate(key){\n          const {idx} = this._hashToIndex(key);\n          const bucket = this.table[idx];\n          for (let i=0;i<bucket.length;i++){\n            if (bucket[i].key === key) { bucket.splice(i,1); this.count--; return true; }\n          }\n          return false;\n        }\n        _removeLinear(key){\n          const {raw} = this._hashToIndex(key);\n          let idx = raw % this.capacity;\n          for (let probe=0; probe < this.capacity; probe++){\n            const slot = this.table[idx];\n            if (slot === null) return false;\n            if (slot !== this._tombstone && slot.key === key) {\n              this.table[idx] = this._tombstone;\n              this.count--;\n              return true;\n            }\n            idx = (idx+1)%this.capacity;\n          }\n          return false;\n        }\n        clear() {\n          this._init(this.capacity);\n        }\n        _resize(newCap) {\n          const entries = this.keysEntries();\n          this.capacity = Math.max(2, Math.floor(newCap));\n          this.count = 0;\n          if (this.mode === 'separate') this.table = Array.from({length:this.capacity},()=>[]);\n          else this.table = Array.from({length:this.capacity},()=>null);\n          for (const [k,v] of entries) this.put(k,v);\n        }\n        forceResizeDouble() {\n          this._resize(this.capacity * 2);\n        }\n        setMode(mode) {\n          if (mode === this.mode) return;\n          this.mode = mode;\n          const entries = this.keysEntries();\n          this.capacity = Math.max(2, this.capacity);\n          this.count = 0;\n          if (this.mode === 'separate') this.table = Array.from({length:this.capacity},()=>[]);\n          else this.table = Array.from({length:this.capacity},()=>null);\n          for (const [k,v] of entries) this.put(k,v);\n        }\n        // For linear probing: return probe sequence (indices) when searching key\n        probeSequenceFor(key) {\n          if (this.mode !== 'linear') return null;\n          const raw = stringHash(String(key));\n          let idx = raw % this.capacity;\n          const seq = [];\n          for (let i=0;i<this.capacity;i++){\n            seq.push(idx);\n            const slot = this.table[idx];\n            if (slot===null || (slot!==this._tombstone && slot.key===key)) break;\n            idx = (idx+1)%this.capacity;\n          }\n          return seq;\n        }\n      }\n\n      // UI wiring\n      const keyInput = document.getElementById('keyInput');\n      const valueInput = document.getElementById('valueInput');\n      const insertBtn = document.getElementById('insertBtn');\n      const getBtn = document.getElementById('getBtn');\n      const delBtn = document.getElementById('delBtn');\n      const resetBtn = document.getElementById('resetBtn');\n      const populateBtn = document.getElementById('populateBtn');\n      const sizeInput = document.getElementById('sizeInput');\n      const bucketsArea = document.getElementById('bucketsArea');\n      const sizeChip = document.getElementById('sizeChip');\n      const loadChip = document.getElementById('loadChip');\n      const modeSelect = document.getElementById('modeSelect');\n      const hashInfo = document.getElementById('hashInfo');\n      const probeSeq = document.getElementById('probeSeq');\n      const rehashBtn = document.getElementById('rehashBtn');\n      const clearBtn = document.getElementById('clearBtn');\n      const explainBtn = document.getElementById('explainBtn');\n      const statusArea = document.getElementById('statusArea');\n      const notice = document.getElementById('notice');\n      const explainArea = document.getElementById('explainArea');\n\n      let table = new HashTable(parseInt(sizeInput.value,10), modeSelect.value);\n      render();\n\n      function render() {\n        // Update chips\n        sizeChip.textContent = table.capacity;\n        loadChip.textContent = `${table.count} / ${table.capacity}  (LF ${(table.loadFactor()*100).toFixed(1)}%)`;\n        // Render buckets\n        bucketsArea.innerHTML = '';\n        if (table.mode === 'separate') {\n          for (let i=0;i<table.capacity;i++){\n            const b = document.createElement('div');\n            b.className = 'bucket';\n            b.dataset.idx = i;\n            b.innerHTML = `<div class=\"idx\">#${i}</div>`;\n            const items = document.createElement('div');\n            items.className = 'items';\n            const bucket = table.table[i];\n            if (bucket.length === 0) {\n              const empty = document.createElement('div');\n              empty.className = 'item';\n              empty.textContent = 'empty';\n              empty.style.opacity = 0.5;\n              items.appendChild(empty);\n            } else {\n              for (const e of bucket) {\n                const it = document.createElement('div');\n                it.className = 'item kv';\n                it.innerHTML = `<div class=\"key\">${escapeHtml(String(e.key))}</div><div class=\"val\">${escapeHtml(String(e.value))}</div>`;\n                items.appendChild(it);\n              }\n            }\n            b.appendChild(items);\n            bucketsArea.appendChild(b);\n          }\n        } else {\n          // linear probing: show slots\n          for (let i=0;i<table.capacity;i++){\n            const slot = table.table[i];\n            const b = document.createElement('div');\n            b.className = 'bucket';\n            b.dataset.idx = i;\n            b.innerHTML = `<div class=\"idx\">#${i}</div>`;\n            const items = document.createElement('div'); items.className='items';\n            const it = document.createElement('div');\n            it.className = 'item';\n            if (slot === null) {\n              it.textContent = 'empty';\n              it.style.opacity = 0.5;\n            } else if (slot === table._tombstone) {\n              it.innerHTML = `<span class=\"tomb\">tombstone</span>`;\n            } else {\n              it.classList.add('kv');\n              it.innerHTML = `<div class=\"key\">${escapeHtml(String(slot.key))}</div><div class=\"val\">${escapeHtml(String(slot.value))}</div>`;\n            }\n            items.appendChild(it);\n            b.appendChild(items);\n            bucketsArea.appendChild(b);\n          }\n        }\n        // Show status chips\n        statusArea.innerHTML = '';\n        const m = document.createElement('div'); m.className='chip'; m.textContent = 'Mode: ' + (table.mode === 'separate' ? 'Separate chaining' : 'Linear probing');\n        statusArea.appendChild(m);\n        const c2 = document.createElement('div'); c2.className='chip'; c2.textContent = 'Entries: ' + table.count;\n        statusArea.appendChild(c2);\n        const c3 = document.createElement('div'); c3.className='chip'; c3.textContent = `Capacity: ${table.capacity}`;\n        statusArea.appendChild(c3);\n      }\n\n      // helpers\n      function escapeHtml(s) {\n        return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');\n      }\n\n      function highlightIndex(idx) {\n        const all = bucketsArea.querySelectorAll('.bucket');\n        all.forEach(b=>b.classList.toggle('highlight', b.dataset.idx == idx));\n      }\n\n      function clearHighlight() {\n        const all = bucketsArea.querySelectorAll('.bucket');\n        all.forEach(b=>b.classList.remove('highlight'));\n      }\n\n      function showProbeSequence(seq) {\n        if (!seq) { probeSeq.textContent = ''; return; }\n        probeSeq.textContent = 'Probe sequence: ' + seq.map(i=>`#${i}`).join(' → ');\n        // highlight sequence temporarily\n        clearHighlight();\n        seq.forEach((i,idx)=>{\n          setTimeout(()=> {\n            const el = bucketsArea.querySelector(`.bucket[data-idx=\"${i}\"]`);\n            if (el) el.classList.add('highlight');\n            // remove after a moment\n            setTimeout(()=>el && el.classList.remove('highlight'), 900);\n          }, idx*220);\n        });\n      }\n\n      // Events\n      insertBtn.addEventListener('click', ()=>{\n        const k = keyInput.value.trim();\n        if (!k) { notice.textContent = 'Please provide a non-empty key.'; return; }\n        const v = valueInput.value;\n        const res = table.put(k,v);\n        notice.textContent = res.inserted ? `Inserted key \"${k}\" into index ${res.idx}.` : `Updated existing key \"${k}\" at index ${res.idx}.`;\n        render();\n        const {idx,raw} = table._hashToIndex(k);\n        hashInfo.textContent = `Index: ${idx}  (raw hash ${raw})`;\n        highlightIndex(idx);\n      });\n\n      getBtn.addEventListener('click', ()=>{\n        const k = keyInput.value.trim();\n        if (!k) { notice.textContent = 'Please provide a key to fetch.'; return; }\n        const res = table.get(k);\n        if (res.found) {\n          notice.textContent = `Found \"${k}\" => \"${res.value}\" at index ${res.idx}.`;\n          hashInfo.textContent = `Index: ${res.idx}`;\n          if (table.mode === 'linear') {\n            const seq = table.probeSequenceFor(k);\n            showProbeSequence(seq);\n          } else {\n            highlightIndex(res.idx);\n          }\n        } else {\n          notice.textContent = `Key \"${k}\" not found (would map to index ${res.idx}).`;\n          hashInfo.textContent = `Index: ${res.idx}`;\n          highlightIndex(res.idx);\n          probeSeq.textContent = '';\n        }\n      });\n\n      delBtn.addEventListener('click', ()=>{\n        const k = keyInput.value.trim();\n        if (!k) { notice.textContent = 'Please provide a key to delete.'; return; }\n        const ok = table.remove(k);\n        notice.textContent = ok ? `Removed key \"${k}\".` : `Key \"${k}\" not found.`;\n        render();\n      });\n\n      resetBtn.addEventListener('click', ()=>{\n        const sz = parseInt(sizeInput.value,10) || 8;\n        table = new HashTable(sz, modeSelect.value);\n        notice.textContent = `Table reset to ${sz} buckets with mode ${modeSelect.value}.`;\n        render();\n        clearHighlight();\n        probeSeq.textContent = '';\n        hashInfo.textContent = 'Index: —';\n      });\n\n      populateBtn.addEventListener('click', ()=>{\n        // Some sample keys likely to collide for small table sizes\n        const samples = ['apple','banana','grape','orange','peach','plum','kiwi','pear','berry','melon','lemon','lime','mango','apricot'];\n        for (let i=0; i<Math.min(samples.length, Math.floor(table.capacity*1.2)); i++){\n          table.put(samples[i], `val:${samples[i]}`);\n        }\n        notice.textContent = `Populated with ${Math.min(samples.length, Math.floor(table.capacity*1.2))} sample items.`;\n        render();\n      });\n\n      sizeInput.addEventListener('change', ()=>{\n        // allow changing initial size before reset\n        let v = parseInt(sizeInput.value,10);\n        if (isNaN(v) || v < 2) v = 2;\n        sizeInput.value = v;\n      });\n\n      modeSelect.addEventListener('change', ()=>{\n        table.setMode(modeSelect.value);\n        notice.textContent = `Switched mode to ${modeSelect.value}. Rehashed existing entries.`;\n        render();\n      });\n\n      rehashBtn.addEventListener('click', ()=>{\n        table.forceResizeDouble();\n        notice.textContent = `Forced resize: doubled capacity to ${table.capacity}.`;\n        render();\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        table.clear();\n        notice.textContent = 'Cleared all entries.';\n        render();\n      });\n\n      explainBtn.addEventListener('click', ()=>{\n        explainArea.innerHTML = `<strong>Hash function used (FNV-1a-like):</strong>\n          <div style=\"margin-top:8px;color:var(--muted)\">\n            We compute a 32-bit unsigned hash from the string (FNV-1a style mix). Then index = hash % capacity.\n            For demonstration we use doubling resize and thresholds:\n            - Separate chaining: resize when load factor > 0.7\n            - Linear probing : resize when load factor > 0.6\n          </div>`;\n      });\n\n      // Live highlight of where a typed key would map\n      keyInput.addEventListener('input', ()=>{\n        const k = keyInput.value;\n        if (!k) { hashInfo.textContent = 'Index: —'; clearHighlight(); probeSeq.textContent = ''; return; }\n        const {raw, idx} = table._hashToIndex(k);\n        hashInfo.textContent = `Index: ${idx}  (raw hash ${raw})`;\n        if (table.mode === 'linear') {\n          const seq = table.probeSequenceFor(k);\n          showProbeSequence(seq);\n        } else {\n          clearHighlight();\n          highlightIndex(idx);\n          probeSeq.textContent = '';\n        }\n      });\n\n      // small keyboard sugar: Enter to insert\n      valueInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') insertBtn.click(); });\n      keyInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') insertBtn.click(); });\n\n      // initial render\n      render();\n\n      // Expose table for debugging in console (developer convenience)\n      window._demoHashTable = table;\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Hash Table"
    }
  ],
  "topic": "Hash Table",
  "hasFSM": false,
  "hasTest": true
}