{
  "id": "be87d8a6-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:37.326Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>K-Nearest Neighbors (KNN) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 18px; color: #111;}\n    h1 { margin: 0 0 10px 0; font-size: 20px;}\n    .wrap { display: flex; gap: 18px; align-items: flex-start; }\n    .left { width: 760px; }\n    canvas { border: 1px solid #bbb; background: #fff; cursor: crosshair; }\n    .controls { width: 360px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; background: #fafafa; }\n    label { display: block; margin: 8px 0 4px; font-weight: 600; font-size: 13px; }\n    .row { display:flex; gap:8px; align-items:center; }\n    input[type=\"range\"] { width: 100%; }\n    button, select, input[type=\"number\"], input[type=\"text\"] { padding:6px 8px; border-radius:6px; border:1px solid #ccc; background:#fff; }\n    .small { font-size: 12px; color: #444; }\n    .legend { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }\n    .legend-item { display:flex; align-items:center; gap:8px; padding:4px 6px; border-radius:6px; border:1px solid #eee; background:#fff; }\n    .sw { width:14px; height:14px; border-radius:4px; }\n    .info { margin-top:10px; font-size:13px; }\n    .btn-row { display:flex; gap:8px; margin-top:8px; }\n    .muted { color:#666; font-size:12px; }\n    .footer { margin-top:12px; font-size:12px; color:#444; }\n    .bold { font-weight:700; }\n    textarea { width:100%; height:90px; }\n    .control-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; }\n    .topbar { display:flex; gap:12px; align-items:center; margin-bottom:8px; }\n    .explain { margin-top:12px; font-size:13px; color:#333; line-height:1.35; }\n    a { color:#1a73e8; text-decoration:none; }\n  </style>\n</head>\n<body>\n  <h1>K-Nearest Neighbors (KNN) — Interactive Demo</h1>\n  <div class=\"wrap\">\n    <div class=\"left\">\n      <div class=\"topbar\">\n        <div class=\"muted\">Canvas: click to add points (mode selects label). In \"Classify\" mode, click to set query point.</div>\n        <div style=\"margin-left:auto;\" class=\"muted\">Canvas size: 760×500</div>\n      </div>\n      <canvas id=\"canvas\" width=\"760\" height=\"500\"></canvas>\n      <div class=\"info\">\n        <div><span class=\"bold\">Query:</span> <span id=\"queryInfo\">none</span></div>\n        <div><span class=\"bold\">Prediction:</span> <span id=\"prediction\">—</span></div>\n        <div id=\"neighborsInfo\" class=\"muted\"></div>\n      </div>\n    </div>\n\n    <div class=\"controls\">\n      <label>Mode</label>\n      <div class=\"row\">\n        <select id=\"mode\">\n          <option value=\"add\">Add points</option>\n          <option value=\"classify\">Classify (set query)</option>\n          <option value=\"erase\">Erase nearest point</option>\n        </select>\n        <button id=\"clearBtn\">Clear all</button>\n        <button id=\"undoBtn\">Undo</button>\n      </div>\n\n      <label>Class (for adding points)</label>\n      <div class=\"row\">\n        <select id=\"classSelect\"></select>\n        <button id=\"addClassBtn\">Add class</button>\n      </div>\n\n      <div class=\"legend\" id=\"legend\"></div>\n\n      <label>K (number of neighbors)</label>\n      <input id=\"kRange\" type=\"range\" min=\"1\" max=\"25\" value=\"5\" />\n      <div class=\"row small\">\n        <div>K = <span id=\"kVal\">5</span></div>\n        <div style=\"margin-left:auto;\"><input type=\"checkbox\" id=\"weighted\" /> <label for=\"weighted\" class=\"small\" style=\"display:inline\">Distance-weighted</label></div>\n      </div>\n\n      <label>Distance metric</label>\n      <select id=\"metric\">\n        <option value=\"euclidean\">Euclidean</option>\n        <option value=\"manhattan\">Manhattan (L1)</option>\n        <option value=\"chebyshev\">Chebyshev (L∞)</option>\n      </select>\n\n      <label>Decision boundary resolution</label>\n      <div class=\"row\">\n        <input id=\"resolution\" type=\"range\" min=\"2\" max=\"20\" value=\"8\" />\n        <div style=\"width:60px; text-align:right;\">step: <span id=\"resVal\">8</span> px</div>\n      </div>\n\n      <div class=\"btn-row\">\n        <button id=\"randomBtn\">Generate random clusters</button>\n        <button id=\"gridBtn\">Quick demo (2 clusters)</button>\n        <button id=\"showBoundBtn\">Recompute boundary</button>\n      </div>\n\n      <label>Options</label>\n      <div class=\"row\">\n        <input type=\"checkbox\" id=\"showNeighbors\" checked /> <label for=\"showNeighbors\" class=\"small\" style=\"display:inline\">Show neighbors lines</label>\n      </div>\n\n      <div class=\"explain\">\n        <strong>How it works:</strong>\n        KNN predicts the label of a query point by finding the K closest training points (neighbors) and letting them vote. Smaller K makes the model sensitive to noise; larger K smooths decisions. Distance-weighting gives nearer neighbors more influence.\n      </div>\n\n      <div class=\"footer\">\n        Tip: add several classes, click \"Classify\" and set a query point — adjust K and the metric to see how the prediction changes.\n      </div>\n    </div>\n  </div>\n\n<script>\n/*\n  KNN Interactive Demo\n  - Add points with chosen class\n  - Classify query point\n  - Show decision boundary (grid-colored)\n  - Options: K, metric, weighting, resolution\n*/\n\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d', { willReadFrequently: true });\nconst modeEl = document.getElementById('mode');\nconst classSelect = document.getElementById('classSelect');\nconst addClassBtn = document.getElementById('addClassBtn');\nconst legendDiv = document.getElementById('legend');\nconst kRange = document.getElementById('kRange');\nconst kVal = document.getElementById('kVal');\nconst metricEl = document.getElementById('metric');\nconst weightedEl = document.getElementById('weighted');\nconst resRange = document.getElementById('resolution');\nconst resVal = document.getElementById('resVal');\nconst randomBtn = document.getElementById('randomBtn');\nconst gridBtn = document.getElementById('gridBtn');\nconst clearBtn = document.getElementById('clearBtn');\nconst undoBtn = document.getElementById('undoBtn');\nconst showBoundBtn = document.getElementById('showBoundBtn');\nconst showNeighborsEl = document.getElementById('showNeighbors');\nconst queryInfo = document.getElementById('queryInfo');\nconst predictionEl = document.getElementById('prediction');\nconst neighborsInfo = document.getElementById('neighborsInfo');\n\nlet classes = []; // array of {id,label,color}\nlet points = []; // array of {x,y,labelId}\nlet query = null; // {x,y}\nlet neighbors = []; // latest neighbors\nlet boundaryCache = null;\nlet lastActionStack = [];\n\n// default classes\nconst defaultColors = ['#e53935','#1e88e5','#43a047','#fb8c00','#8e24aa','#00acc1'];\nfunction addClass(name, color=null){\n  const id = classes.length ? classes[classes.length-1].id + 1 : 1;\n  color = color || defaultColors[classes.length % defaultColors.length];\n  classes.push({id, label: name, color});\n  updateClassUI();\n  return id;\n}\nfunction updateClassUI(){\n  classSelect.innerHTML = '';\n  legendDiv.innerHTML = '';\n  classes.forEach(cls => {\n    const opt = document.createElement('option');\n    opt.value = cls.id;\n    opt.textContent = cls.label;\n    classSelect.appendChild(opt);\n\n    const item = document.createElement('div');\n    item.className = 'legend-item';\n    const sw = document.createElement('div');\n    sw.className = 'sw';\n    sw.style.background = cls.color;\n    const text = document.createElement('div');\n    text.textContent = cls.label;\n    item.appendChild(sw);\n    item.appendChild(text);\n    legendDiv.appendChild(item);\n  });\n}\n\n// initialize a couple classes\naddClass('Class A');\naddClass('Class B');\n\nkRange.addEventListener('input', ()=>{ kVal.textContent = kRange.value; computeAndRender(); });\nresRange.addEventListener('input', ()=>{ resVal.textContent = resRange.value; });\nmetricEl.addEventListener('change', ()=> computeAndRender());\nweightedEl.addEventListener('change', ()=> computeAndRender());\nshowNeighborsEl.addEventListener('change', ()=> draw());\nmodeEl.addEventListener('change', ()=> {\n  // reset query when changing away from classify?\n  if (modeEl.value !== 'classify') {\n    query = null;\n    updateInfo();\n    computeAndRender(); // re-render without query\n  }\n});\n\n// canvas coordinate helpers\nfunction canvasToData(x,y){\n  return {x: x, y: y};\n}\n\n// add point\nfunction addPoint(x,y,labelId){\n  points.push({x,y,labelId});\n  lastActionStack.push({type:'add', point:{x,y,labelId}});\n  invalidateBoundary();\n  computeAndRender();\n}\n\nfunction removeNearest(x,y){\n  if (!points.length) return;\n  let bestIdx = 0;\n  let bestD = distSq(points[0].x - x, points[0].y - y);\n  for (let i=1;i<points.length;i++){\n    const d = distSq(points[i].x - x, points[i].y - y);\n    if (d < bestD){ bestD = d; bestIdx = i; }\n  }\n  const removed = points.splice(bestIdx,1)[0];\n  lastActionStack.push({type:'remove', point:removed, index:bestIdx});\n  invalidateBoundary();\n  computeAndRender();\n}\n\nfunction undo(){\n  const action = lastActionStack.pop();\n  if (!action) return;\n  if (action.type === 'add'){\n    // remove the last matching point (coordinates & label)\n    for (let i=points.length-1;i>=0;i--){\n      const p = points[i];\n      if (p.x === action.point.x && p.y === action.point.y && p.labelId === action.point.labelId){\n        points.splice(i,1);\n        break;\n      }\n    }\n  } else if (action.type === 'remove'){\n    // reinsert\n    points.splice(action.index,0,action.point);\n  } else if (action.type === 'clear'){\n    points = action.points.slice();\n  }\n  invalidateBoundary();\n  computeAndRender();\n}\n\nclearBtn.addEventListener('click', ()=>{\n  if (!points.length) return;\n  lastActionStack.push({type:'clear', points: points.slice()});\n  points = [];\n  query = null;\n  invalidateBoundary();\n  computeAndRender();\n});\nundoBtn.addEventListener('click', undo);\n\n// mouse handling\ncanvas.addEventListener('mousedown', (ev)=>{\n  const rect = canvas.getBoundingClientRect();\n  const x = Math.round(ev.clientX - rect.left);\n  const y = Math.round(ev.clientY - rect.top);\n  const mode = modeEl.value;\n  if (mode === 'add'){\n    const labelId = parseInt(classSelect.value,10);\n    addPoint(x,y,labelId);\n  } else if (mode === 'erase'){\n    removeNearest(x,y);\n  } else if (mode === 'classify'){\n    query = {x,y};\n    computeAndRender();\n  }\n});\n\n// distance functions\nfunction distSq(dx,dy){ return dx*dx + dy*dy; }\nfunction distance(a,b, metric='euclidean'){\n  const dx = Math.abs(a.x - b.x);\n  const dy = Math.abs(a.y - b.y);\n  if (metric === 'euclidean') return Math.sqrt(dx*dx + dy*dy);\n  if (metric === 'manhattan') return dx + dy;\n  if (metric === 'chebyshev') return Math.max(dx,dy);\n  return Math.sqrt(dx*dx + dy*dy);\n}\n\n// KNN prediction\nfunction knnPredict(q, K, metric='euclidean', weighted=false){\n  if (!points.length) return null;\n  // compute distances\n  const items = points.map((p,i) => {\n    return {i, x:p.x, y:p.y, labelId:p.labelId, d: distance(q, p, metric) };\n  });\n  // sort by distance\n  items.sort((a,b)=> a.d - b.d);\n  const k = Math.min(K, items.length);\n  const votes = new Map();\n  let zeroDistLabel = null;\n  for (let j=0;j<k;j++){\n    const it = items[j];\n    if (it.d === 0){\n      // exact match -> immediate prediction\n      zeroDistLabel = it.labelId;\n      break;\n    }\n    const weight = weighted ? 1 / (it.d + 1e-6) : 1;\n    votes.set(it.labelId, (votes.get(it.labelId)||0) + weight);\n  }\n  if (zeroDistLabel !== null){\n    // neighbors are the first k items (for visualization), but prediction is the label of the zero-distance point\n    return {prediction:zeroDistLabel, probs: {[zeroDistLabel]: 1}, neighbors: items.slice(0,k)};\n  }\n  // choose label with max vote\n  let bestLabel = null, bestScore = -Infinity;\n  let total = 0;\n  for (const [lab,score] of votes.entries()){ total += score; if (score > bestScore){ bestScore = score; bestLabel = lab; } }\n  // probabilities map\n  const probs = {};\n  for (const [lab,score] of votes.entries()){ probs[lab] = score / total; }\n  return {prediction: bestLabel, probs, neighbors: items.slice(0,k)};\n}\n\n// boundary grid coloring\nfunction computeBoundaryGrid(step){\n  // returns an array of {x,y,labelId} for cell centers\n  const w = canvas.width, h = canvas.height;\n  const grid = [];\n  const K = parseInt(kRange.value,10);\n  const metric = metricEl.value;\n  const weighted = weightedEl.checked;\n  if (!points.length) return grid;\n  for (let y=0;y<h;y+=step){\n    for (let x=0;x<w;x+=step){\n      const q = {x:x+0.5*step, y:y+0.5*step};\n      const pred = knnPredict(q,K,metric,weighted);\n      grid.push({x:x, y:y, labelId: pred ? pred.prediction : null});\n    }\n  }\n  return grid;\n}\n\nfunction invalidateBoundary(){ boundaryCache = null; }\n\n// main render\nfunction computeAndRender(){\n  // compute boundary if needed\n  const showNeighbors = showNeighborsEl.checked;\n  if (!boundaryCache){\n    const step = parseInt(resRange.value,10);\n    boundaryCache = computeBoundaryGrid(step);\n  }\n  draw();\n}\n\n// draw\nfunction draw(){\n  // clear\n  ctx.clearRect(0,0,canvas.width,canvas.height);\n  // background: color decision boundary\n  if (boundaryCache && boundaryCache.length){\n    boundaryCache.forEach(cell => {\n      const cls = classes.find(c=>c.id === cell.labelId);\n      if (!cls) return;\n      ctx.fillStyle = hexToRGBA(cls.color, 0.12);\n      ctx.fillRect(cell.x, cell.y, parseInt(resRange.value,10), parseInt(resRange.value,10));\n    });\n  }\n  // draw grid lines lightly (optional)\n  // draw points\n  points.forEach(p=>{\n    const cls = classes.find(c=>c.id === p.labelId);\n    drawPoint(p.x,p.y, cls ? cls.color : '#000', 7);\n    // inner white for visibility\n    ctx.beginPath();\n    ctx.arc(p.x,p.y,2,0,2*Math.PI);\n    ctx.fillStyle = '#fff';\n    ctx.fill();\n  });\n\n  // if query exists, compute prediction and show neighbors\n  if (query){\n    const K = parseInt(kRange.value,10);\n    const pred = knnPredict(query,K, metricEl.value, weightedEl.checked);\n    neighbors = pred ? pred.neighbors : [];\n    // show neighbor lines\n    if (showNeighborsEl.checked && neighbors && neighbors.length){\n      neighbors.forEach((n,idx)=>{\n        const p = points[n.i];\n        ctx.beginPath();\n        ctx.moveTo(query.x, query.y);\n        ctx.lineTo(p.x, p.y);\n        ctx.strokeStyle = hexToRGBA(classes.find(c=>c.id===p.labelId).color, 0.6);\n        ctx.lineWidth = 2 - Math.min(1.6, idx*0.08);\n        ctx.stroke();\n      });\n    }\n    // draw query point bigger\n    drawPoint(query.x,query.y, pred ? (classes.find(c=>c.id===pred.prediction).color) : '#444', 12, true);\n    // draw smaller center\n    ctx.beginPath();\n    ctx.arc(query.x, query.y, 4,0,2*Math.PI);\n    ctx.fillStyle = '#fff';\n    ctx.fill();\n    // update info\n    updateInfo(pred);\n  } else {\n    neighbors = [];\n    updateInfo(null);\n  }\n}\n\n// helper to draw a solid circle with stroke\nfunction drawPoint(x,y,color,size, thick=false){\n  ctx.beginPath();\n  ctx.arc(x,y,size/2,0,2*Math.PI);\n  ctx.fillStyle = color;\n  ctx.fill();\n  ctx.lineWidth = thick ? 3 : 1.2;\n  ctx.strokeStyle = '#222';\n  ctx.globalAlpha = 0.9;\n  ctx.stroke();\n  ctx.globalAlpha = 1;\n}\n\nfunction hexToRGBA(hex, alpha=1.0){\n  // hex like #rrggbb\n  const c = hex.replace('#','');\n  const r = parseInt(c.substring(0,2),16);\n  const g = parseInt(c.substring(2,4),16);\n  const b = parseInt(c.substring(4,6),16);\n  return `rgba(${r},${g},${b},${alpha})`;\n}\n\nfunction updateInfo(predictionObj){\n  if (!query){ queryInfo.textContent = 'none'; predictionEl.textContent = '—'; neighborsInfo.textContent = ''; return; }\n  queryInfo.textContent = `(${Math.round(query.x)}, ${Math.round(query.y)})`;\n  if (!predictionObj){ predictionEl.textContent = 'no data'; neighborsInfo.textContent = ''; return; }\n  const predCls = classes.find(c => c.id === predictionObj.prediction);\n  predictionEl.textContent = predCls ? `${predCls.label}` : 'unknown';\n  // show votes and neighbors distances\n  let txt = '';\n  if (predictionObj.probs){\n    const arr = Object.entries(predictionObj.probs).sort((a,b)=>b[1]-a[1]);\n    txt += 'Votes: ' + arr.map(([lab,score])=>{\n      const cls = classes.find(c=>c.id==lab);\n      return `${cls ? cls.label : lab}: ${(score*100).toFixed(0)}%`;\n    }).join(', ');\n  }\n  if (predictionObj.neighbors && predictionObj.neighbors.length){\n    txt += '\\nNeighbors distances: ' + predictionObj.neighbors.map(n=> `${Math.round(n.d)}`).join(', ');\n  }\n  neighborsInfo.textContent = txt;\n}\n\n// UI: add class button\naddClassBtn.addEventListener('click', ()=>{\n  const name = prompt('New class label', `Class ${classes.length + 1}`);\n  if (!name) return;\n  const color = prompt('Color (CSS hex or name)', defaultColors[classes.length % defaultColors.length]);\n  addClass(name, color);\n});\n\n// random clusters generator\nrandomBtn.addEventListener('click', ()=>{\n  // generate 3 clusters if more classes, otherwise equal classes\n  const nClusters = Math.min(5, classes.length);\n  points = [];\n  lastActionStack.push({type:'clear', points: []}); // allow undo of generation? We'll push each add instead\n  for (let k=0;k<nClusters;k++){\n    const cls = classes[k];\n    const cx = 80 + Math.random()*(canvas.width-160);\n    const cy = 80 + Math.random()*(canvas.height-160);\n    const count = 20 + Math.round(Math.random()*30);\n    for (let i=0;i<count;i++){\n      const x = cx + (Math.random()-0.5)*120;\n      const y = cy + (Math.random()-0.5)*120;\n      points.push({x,y,labelId: cls.id});\n    }\n  }\n  invalidateBoundary();\n  computeAndRender();\n});\n\n// quick grid demo\ngridBtn.addEventListener('click', ()=>{\n  points = [];\n  const w = canvas.width, h = canvas.height;\n  // 2 clusters: left = class A, right = class B with some overlap\n  const left = classes[0] ? classes[0].id : addClass('A');\n  const right = classes[1] ? classes[1].id : addClass('B');\n  for (let i=0;i<80;i++){\n    const x = 60 + Math.random()*280 + (Math.random()*40);\n    const y = 40 + Math.random()*(h-80);\n    points.push({x,y,labelId:left});\n  }\n  for (let i=0;i<80;i++){\n    const x = w-60 - Math.random()*280 - (Math.random()*40);\n    const y = 40 + Math.random()*(h-80);\n    points.push({x,y,labelId:right});\n  }\n  invalidateBoundary();\n  computeAndRender();\n});\n\n// recompute boundary\nshowBoundBtn.addEventListener('click', ()=>{\n  boundaryCache = null;\n  computeAndRender();\n});\n\n// initial render\ncomputeAndRender();\n\n// ensure initial k display\nkVal.textContent = kRange.value;\nresVal.textContent = resRange.value;\n\n// keyboard shortcuts\ndocument.addEventListener('keydown', (e)=>{\n  if (e.key === 'z' && (e.ctrlKey || e.metaKey)) { undo(); }\n});\n\n// small optimization: throttle recompute when dragging ranges\nlet recomputeTimer = null;\n['kRange','metric','weighted','resolution'].forEach(id=>{\n  const el = document.getElementById(id);\n  if (!el) return;\n  el.addEventListener('input', ()=> {\n    if (recomputeTimer) clearTimeout(recomputeTimer);\n    recomputeTimer = setTimeout(()=>{ boundaryCache = null; computeAndRender(); }, 120);\n  });\n});\n\n// Helper: compute and show initial explanation in canvas when empty\nfunction drawEmptyHint(){\n  if (points.length === 0){\n    ctx.save();\n    ctx.fillStyle = '#f1f5f9';\n    ctx.fillRect(0,0,canvas.width,canvas.height);\n    ctx.fillStyle = '#666';\n    ctx.font = '14px system-ui, sans-serif';\n    ctx.fillText('Add some points (mode: Add points) — choose a class and click on the canvas.', 18, 30);\n    ctx.restore();\n  }\n}\ndrawEmptyHint();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": false,
  "hasTest": true
}