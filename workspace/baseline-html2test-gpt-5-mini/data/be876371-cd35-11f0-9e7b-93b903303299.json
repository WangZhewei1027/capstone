{
  "id": "be876371-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:38.250Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Binary Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>Interactive Binary Tree (BST) Demonstration</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root {\n      --bg: #f7f9fc;\n      --panel: #ffffff;\n      --accent: #2b7cff;\n      --muted: #6b7280;\n      --success: #16a34a;\n      --danger: #ef4444;\n      --node-fill: #ffffff;\n      --node-stroke: #1f2937;\n    }\n    html,body { height:100%; margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background:var(--bg); color:#111827; }\n    .wrap { display:flex; gap:16px; padding:18px; box-sizing:border-box; height:100%; }\n    .left {\n      flex:1 1 0;\n      display:flex;\n      flex-direction:column;\n      background:var(--panel);\n      border-radius:12px;\n      padding:14px;\n      box-shadow:0 2px 8px rgba(15,23,42,0.06);\n    }\n    .right {\n      width:360px;\n      min-width:260px;\n      max-width:420px;\n      background:var(--panel);\n      border-radius:12px;\n      padding:14px;\n      box-shadow:0 2px 8px rgba(15,23,42,0.06);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    h2 { margin:4px 0 8px 0; font-size:16px; }\n    .canvas-wrap {\n      position:relative;\n      border-radius:10px;\n      background:linear-gradient(180deg,#fff,#fbfdff);\n      flex:1 1 0;\n      overflow:auto;\n      padding:8px;\n      border:1px solid rgba(15,23,42,0.04);\n    }\n    svg { width:100%; height:600px; display:block; }\n    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }\n    .controls input[type=\"number\"] { width:110px; padding:8px 10px; border-radius:8px; border:1px solid #e6e9ef; }\n    button {\n      background:var(--accent);\n      color:white;\n      border:0;\n      padding:8px 12px;\n      border-radius:8px;\n      cursor:pointer;\n      font-weight:600;\n      box-shadow:0 2px 6px rgba(43,124,255,0.18);\n    }\n    button.secondary {\n      background:#f3f4f6; color:#111827; box-shadow:none; border:1px solid rgba(15,23,42,0.06);\n    }\n    button.danger { background:var(--danger); box-shadow:none; }\n    .muted { color:var(--muted); font-size:13px; }\n    .panel-section { background: #fbfdff; border-radius:8px; padding:10px; border:1px dashed rgba(15,23,42,0.04); }\n    .stats { display:flex; gap:10px; flex-wrap:wrap; }\n    .stat { background:linear-gradient(180deg,#ffffff,#f8fafc); padding:8px 10px; border-radius:8px; border:1px solid rgba(15,23,42,0.04); min-width:90px; text-align:center; }\n    .traversal-buttons { display:flex; gap:8px; flex-wrap:wrap; }\n    .log { background:#0b1220; color:#dbeafe; padding:8px; border-radius:8px; font-family: monospace; font-size:13px; max-height:120px; overflow:auto; }\n    .hint { font-size:13px; color:var(--muted); }\n    .small { font-size:13px; color:var(--muted); }\n    .legend { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }\n    .legend .item { display:flex; gap:6px; align-items:center; }\n    .circle-key { width:16px; height:16px; border-radius:50%; display:inline-block; border:1px solid rgba(0,0,0,0.06); }\n    .footer { font-size:13px; color:var(--muted); margin-top:8px; }\n    a { color:var(--accent); text-decoration:none; }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <div class=\"left\">\n      <h2>Binary Tree (Binary Search Tree) Visualizer</h2>\n      <div class=\"canvas-wrap\">\n        <!-- SVG will be inserted here by JS -->\n        <svg id=\"svgCanvas\" viewBox=\"0 0 1200 700\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n      </div>\n      <div style=\"display:flex; justify-content:space-between; margin-top:10px; gap:8px; align-items:center;\">\n        <div class=\"hint\">Click a node to fill its value in the input. The layout uses the inorder-based placement to show tree structure clearly.</div>\n        <div class=\"legend\">\n          <div class=\"item\"><span class=\"circle-key\" style=\"background:var(--node-fill); border:2px solid var(--node-stroke)\"></span> Node</div>\n          <div class=\"item\"><span class=\"circle-key\" style=\"background:var(--accent)\"></span> Visiting</div>\n          <div class=\"item\"><span class=\"circle-key\" style=\"background:var(--success)\"></span> Found / Active</div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"right\">\n      <div class=\"panel-section\">\n        <div style=\"display:flex; gap:8px; align-items:center; margin-bottom:8px;\">\n          <input id=\"valueInput\" type=\"number\" placeholder=\"Value (integer)\" />\n          <button id=\"insertBtn\">Insert</button>\n          <button id=\"deleteBtn\" class=\"secondary\">Delete</button>\n          <button id=\"searchBtn\" class=\"secondary\">Search</button>\n        </div>\n        <div style=\"display:flex; gap:8px; align-items:center; margin-bottom:6px;\">\n          <button id=\"randomBtn\" class=\"secondary\">Random tree</button>\n          <button id=\"clearBtn\" class=\"danger\">Clear</button>\n        </div>\n        <div class=\"small\">Click nodes to pick value. Duplicates are not allowed in this demo (simple BST).</div>\n      </div>\n\n      <div class=\"panel-section\">\n        <h3 style=\"margin:6px 0 8px 0; font-size:14px;\">Traversals & Animation</h3>\n        <div class=\"traversal-buttons\">\n          <button data-tr=\"inorder\" class=\"secondary\">Inorder</button>\n          <button data-tr=\"preorder\" class=\"secondary\">Preorder</button>\n          <button data-tr=\"postorder\" class=\"secondary\">Postorder</button>\n          <button data-tr=\"levelorder\" class=\"secondary\">Level-order</button>\n        </div>\n        <div style=\"display:flex; gap:8px; margin-top:8px;\">\n          <button id=\"playBtn\">Play</button>\n          <button id=\"stepBtn\" class=\"secondary\">Step</button>\n          <button id=\"stopBtn\" class=\"secondary\">Stop</button>\n        </div>\n        <div style=\"margin-top:8px;\">\n          <div class=\"muted\">Traversal output:</div>\n          <div id=\"traversalOutput\" class=\"log\" aria-live=\"polite\"></div>\n        </div>\n      </div>\n\n      <div class=\"panel-section\">\n        <h3 style=\"margin:6px 0 8px 0; font-size:14px;\">Tree Info</h3>\n        <div class=\"stats\">\n          <div class=\"stat\">\n            <div class=\"muted\">Nodes</div>\n            <div id=\"nodeCount\">0</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"muted\">Height</div>\n            <div id=\"treeHeight\">0</div>\n          </div>\n          <div class=\"stat\">\n            <div class=\"muted\">Root</div>\n            <div id=\"rootVal\">—</div>\n          </div>\n        </div>\n        <div style=\"margin-top:8px;\">\n          <div class=\"muted\">Search result:</div>\n          <div id=\"searchResult\" class=\"small\">No query</div>\n        </div>\n      </div>\n\n      <div class=\"panel-section\">\n        <div class=\"muted\">Instructions</div>\n        <ul style=\"margin:6px 0 0 16px; padding:0;\">\n          <li>Insert integers; the tree is organized as a Binary Search Tree (left < value < right).</li>\n          <li>Use traversal buttons to prepare a traversal, then Play to animate node visits.</li>\n          <li>Click a node in the drawing to auto-fill its value into the input for quick delete/search.</li>\n        </ul>\n      </div>\n\n      <div class=\"footer small\">Built for demonstration. Source is in the page. Enjoy exploring binary tree operations.</div>\n    </div>\n  </div>\n\n<script>\n/*\n Interactive Binary Search Tree visualizer\n - Insert, Delete, Search\n - Traversals: inorder, preorder, postorder, level-order\n - Animated visiting with Play / Step / Stop\n - Clicking nodes fills the input with its value\n - Layout: positions assigned using inorder index for clean structure\n*/\n\n(function(){\n  // Basic BST Node\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n      this.parent = null;\n      // layout\n      this.x = 0;\n      this.y = 0;\n      this.depth = 0;\n      this._id = Node._idCounter++;\n    }\n  }\n  Node._idCounter = 1;\n\n  // BST class\n  class BST {\n    constructor() {\n      this.root = null;\n      this._count = 0;\n    }\n    insert(value) {\n      if (this.root == null) {\n        this.root = new Node(value);\n        this._count = 1;\n        return this.root;\n      }\n      let cur = this.root;\n      while (true) {\n        if (value === cur.value) return null; // no duplicates in this demo\n        if (value < cur.value) {\n          if (cur.left) cur = cur.left;\n          else {\n            let n = new Node(value);\n            cur.left = n; n.parent = cur;\n            this._count++;\n            return n;\n          }\n        } else {\n          if (cur.right) cur = cur.right;\n          else {\n            let n = new Node(value);\n            cur.right = n; n.parent = cur;\n            this._count++;\n            return n;\n          }\n        }\n      }\n    }\n    search(value) {\n      let cur = this.root;\n      const path = [];\n      while (cur) {\n        path.push(cur);\n        if (value === cur.value) return { node:cur, path };\n        cur = (value < cur.value) ? cur.left : cur.right;\n      }\n      return { node:null, path };\n    }\n    delete(value) {\n      const res = this.search(value);\n      const node = res.node;\n      if (!node) return false;\n      this._deleteNode(node);\n      this._count--;\n      return true;\n    }\n    _transplant(u,v) {\n      if (!u.parent) this.root = v;\n      else if (u === u.parent.left) u.parent.left = v;\n      else u.parent.right = v;\n      if (v) v.parent = u.parent;\n    }\n    _minimum(n) {\n      while (n.left) n = n.left;\n      return n;\n    }\n    _deleteNode(z) {\n      // standard BST delete\n      if (!z.left) {\n        this._transplant(z, z.right);\n      } else if (!z.right) {\n        this._transplant(z, z.left);\n      } else {\n        const y = this._minimum(z.right);\n        if (y.parent !== z) {\n          this._transplant(y, y.right);\n          y.right = z.right;\n          if (y.right) y.right.parent = y;\n        }\n        this._transplant(z, y);\n        y.left = z.left;\n        if (y.left) y.left.parent = y;\n      }\n    }\n    size() { return this._count; }\n    height() {\n      function h(node) {\n        if (!node) return 0;\n        return 1 + Math.max(h(node.left), h(node.right));\n      }\n      return h(this.root);\n    }\n    // Traversals returning arrays of nodes\n    inorder() {\n      const out = [];\n      (function dfs(n){ if(!n) return; dfs(n.left); out.push(n); dfs(n.right);} )(this.root);\n      return out;\n    }\n    preorder() {\n      const out = [];\n      (function dfs(n){ if(!n) return; out.push(n); dfs(n.left); dfs(n.right);} )(this.root);\n      return out;\n    }\n    postorder() {\n      const out = [];\n      (function dfs(n){ if(!n) return; dfs(n.left); dfs(n.right); out.push(n);} )(this.root);\n      return out;\n    }\n    levelorder() {\n      const out = [];\n      if (!this.root) return out;\n      const q = [this.root];\n      while (q.length) {\n        const n = q.shift();\n        out.push(n);\n        if (n.left) q.push(n.left);\n        if (n.right) q.push(n.right);\n      }\n      return out;\n    }\n  }\n\n  // Global tree instance\n  const tree = new BST();\n\n  // DOM references\n  const svg = document.getElementById('svgCanvas');\n  const insertBtn = document.getElementById('insertBtn');\n  const deleteBtn = document.getElementById('deleteBtn');\n  const searchBtn = document.getElementById('searchBtn');\n  const randomBtn = document.getElementById('randomBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const valueInput = document.getElementById('valueInput');\n\n  const nodeCountEl = document.getElementById('nodeCount');\n  const treeHeightEl = document.getElementById('treeHeight');\n  const rootValEl = document.getElementById('rootVal');\n\n  const traversalOutput = document.getElementById('traversalOutput');\n  const traversalButtons = document.querySelectorAll('[data-tr]');\n  const playBtn = document.getElementById('playBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const stopBtn = document.getElementById('stopBtn');\n\n  const searchResult = document.getElementById('searchResult');\n\n  // Visualization parameters\n  const NODE_RADIUS = 22;\n  const V_SPACING = 90; // vertical spacing per depth\n  const H_SPACING = 70; // horizontal multiplier for inorder positions\n\n  // State for animation\n  let currentTraversal = []; // array of nodes\n  let travIndex = 0;\n  let travTimer = null;\n  let travSpeed = 700; // ms per node\n\n  // Helper: clear svg\n  function clearSVG() {\n    while (svg.firstChild) svg.removeChild(svg.firstChild);\n  }\n\n  // Layout assignment using inorder index (gives tidy BST layout)\n  function assignLayout() {\n    let xCounter = 0;\n    function assign(node, depth=0) {\n      if (!node) return;\n      assign(node.left, depth+1);\n      node.depth = depth;\n      node.x = ++xCounter * H_SPACING;\n      node.y = (depth+1) * V_SPACING;\n      assign(node.right, depth+1);\n    }\n    assign(tree.root, 0);\n    // If tree is not empty, adjust svg viewBox width to fit\n    const totalWidth = Math.max(1200, (xCounter+2) * H_SPACING);\n    svg.setAttribute('viewBox', `0 0 ${Math.max(1200,totalWidth)} 700`);\n  }\n\n  // Draw tree: lines then nodes\n  function render() {\n    clearSVG();\n    assignLayout();\n    if (!tree.root) {\n      drawEmptyHint();\n      updateStats();\n      return;\n    }\n    // Prepare connectors\n    function drawEdges(node) {\n      if (!node) return;\n      if (node.left) drawLine(node, node.left);\n      if (node.right) drawLine(node, node.right);\n      drawEdges(node.left);\n      drawEdges(node.right);\n    }\n    drawEdges(tree.root);\n\n    // Draw nodes (so they appear above lines)\n    function drawNodes(node) {\n      if (!node) return;\n      drawNode(node);\n      drawNodes(node.left);\n      drawNodes(node.right);\n    }\n    drawNodes(tree.root);\n    updateStats();\n  }\n\n  function drawEmptyHint() {\n    const g = createSVG('g');\n    g.setAttribute('transform','translate(260,220)');\n    const rect = createSVG('rect');\n    rect.setAttribute('x','0'); rect.setAttribute('y','0'); rect.setAttribute('width','680'); rect.setAttribute('height','160');\n    rect.setAttribute('fill','transparent');\n    g.appendChild(rect);\n    const text = createSVG('text');\n    text.setAttribute('x','20'); text.setAttribute('y','30'); text.setAttribute('fill','#374151'); text.setAttribute('font-size','16');\n    text.textContent = 'The tree is empty. Insert some integers to begin.';\n    g.appendChild(text);\n    svg.appendChild(g);\n  }\n\n  function drawLine(a,b) {\n    const line = createSVG('line');\n    line.setAttribute('x1', a.x);\n    line.setAttribute('y1', a.y);\n    line.setAttribute('x2', b.x);\n    line.setAttribute('y2', b.y);\n    line.setAttribute('stroke','#94a3b8');\n    line.setAttribute('stroke-width','2');\n    svg.appendChild(line);\n  }\n\n  // Create node group: circle + text, with id linking to node._id\n  function drawNode(node) {\n    const g = createSVG('g');\n    g.setAttribute('data-id', node._id);\n    g.setAttribute('transform', `translate(${node.x},${node.y})`);\n    g.style.cursor = 'pointer';\n    const circle = createSVG('circle');\n    circle.setAttribute('cx','0'); circle.setAttribute('cy','0'); circle.setAttribute('r', NODE_RADIUS);\n    circle.setAttribute('fill', 'var(--node-fill)');\n    circle.setAttribute('stroke', 'var(--node-stroke)');\n    circle.setAttribute('stroke-width','2');\n    circle.setAttribute('data-role','circle');\n    g.appendChild(circle);\n\n    const text = createSVG('text');\n    text.setAttribute('x','0'); text.setAttribute('y','6');\n    text.setAttribute('fill','#0b1220'); text.setAttribute('font-size','13'); text.setAttribute('text-anchor','middle');\n    text.setAttribute('font-weight','700');\n    text.textContent = node.value;\n    g.appendChild(text);\n\n    // Attach click to pick value\n    g.addEventListener('click', (ev) => {\n      ev.stopPropagation();\n      valueInput.value = node.value;\n      highlightNode(node, '#16a34a', 800); // briefly highlight as selected\n    });\n\n    svg.appendChild(g);\n  }\n\n  // Utility: create SVG element\n  function createSVG(tag) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tag);\n  }\n\n  // Highlight node (by node object) with color and optional duration\n  function highlightNode(node, color='#2b7cff', duration=500) {\n    // find element with data-id\n    const g = svg.querySelector(`g[data-id=\"${node._id}\"]`);\n    if (!g) return;\n    const circle = g.querySelector('circle[data-role=\"circle\"]');\n    if (!circle) return;\n    const prevFill = circle.getAttribute('fill');\n    circle.setAttribute('fill', color);\n    circle.setAttribute('stroke','#0b1220');\n    if (duration) {\n      setTimeout(()=> {\n        circle.setAttribute('fill', prevFill);\n        circle.setAttribute('stroke','var(--node-stroke)');\n      }, duration);\n    }\n  }\n\n  // Update stats panel\n  function updateStats() {\n    nodeCountEl.textContent = tree.size();\n    treeHeightEl.textContent = tree.height();\n    rootValEl.textContent = tree.root ? tree.root.value : '—';\n  }\n\n  // Traversal selection logic\n  let selectedTraversal = 'inorder';\n  traversalButtons.forEach(btn => {\n    btn.addEventListener('click', () => {\n      selectedTraversal = btn.getAttribute('data-tr');\n      traversalButtons.forEach(b => b.classList.remove('active'));\n      btn.classList.add('active');\n      prepareTraversal();\n    });\n  });\n\n  function prepareTraversal() {\n    if (!tree.root) {\n      traversalOutput.textContent = '';\n      currentTraversal = [];\n      travIndex = 0;\n      return;\n    }\n    switch (selectedTraversal) {\n      case 'inorder': currentTraversal = tree.inorder(); break;\n      case 'preorder': currentTraversal = tree.preorder(); break;\n      case 'postorder': currentTraversal = tree.postorder(); break;\n      case 'levelorder': currentTraversal = tree.levelorder(); break;\n      default: currentTraversal = [];\n    }\n    travIndex = 0;\n    renderTraversalOutput();\n    // reset node visuals\n    render();\n  }\n\n  function renderTraversalOutput() {\n    const values = currentTraversal.map(n => n.value);\n    traversalOutput.textContent = values.length ? values.join(' → ') : '(empty)';\n  }\n\n  // Play animation\n  function playTraversal() {\n    if (!currentTraversal || currentTraversal.length === 0) return;\n    stopTraversal();\n    travTimer = setInterval(()=> {\n      if (travIndex >= currentTraversal.length) {\n        stopTraversal();\n        return;\n      }\n      const node = currentTraversal[travIndex++];\n      highlightNode(node, getVisitColor(node), travSpeed * 0.9);\n      flashOutput(node.value);\n    }, travSpeed);\n  }\n  function stepTraversal() {\n    if (!currentTraversal || currentTraversal.length === 0) return;\n    if (travIndex >= currentTraversal.length) return;\n    const node = currentTraversal[travIndex++];\n    highlightNode(node, getVisitColor(node), travSpeed * 0.9);\n    flashOutput(node.value);\n  }\n  function stopTraversal() {\n    if (travTimer) clearInterval(travTimer);\n    travTimer = null;\n  }\n\n  // Color selection for visit (special-case: if search active and found, green)\n  function getVisitColor(node) {\n    if (searchTarget !== null && node.value === searchTarget) return '#16a34a';\n    return 'var(--accent)';\n  }\n\n  // Flash the traversal output region to show visiting\n  function flashOutput(val) {\n    traversalOutput.textContent = `[visiting] ${val}   —  sequence: ${currentTraversal.map(n=>n.value).join(' → ')}`;\n    // revert after short delay (non-blocking)\n    setTimeout(()=> {\n      renderTraversalOutput();\n    }, travSpeed * 0.9);\n  }\n\n  // Event bindings\n  insertBtn.addEventListener('click', () => {\n    const v = parseInt(valueInput.value);\n    if (Number.isNaN(v)) { alert('Enter an integer value.'); return; }\n    const inserted = tree.insert(v);\n    if (!inserted) {\n      alert('Value already exists in this BST (duplicates not allowed).');\n      return;\n    }\n    prepareTraversal();\n    render();\n    valueInput.focus();\n  });\n\n  deleteBtn.addEventListener('click', () => {\n    const v = parseInt(valueInput.value);\n    if (Number.isNaN(v)) { alert('Enter an integer to delete.'); return; }\n    const ok = tree.delete(v);\n    if (!ok) {\n      alert('Value not found.');\n      return;\n    }\n    prepareTraversal();\n    render();\n  });\n\n  let searchTarget = null;\n  searchBtn.addEventListener('click', () => {\n    const v = parseInt(valueInput.value);\n    if (Number.isNaN(v)) { alert('Enter an integer to search.'); return; }\n    searchTarget = v;\n    const res = tree.search(v);\n    if (res.node) {\n      // highlight path and found node\n      render();\n      // show path highlights progressively\n      res.path.forEach((n, i) => {\n        setTimeout(()=> {\n          highlightNode(n, i === res.path.length-1 ? '#16a34a' : '#f59e0b', 700);\n        }, i * 250);\n      });\n      searchResult.textContent = `Found. Visited ${res.path.map(n=>n.value).join(' → ')}`;\n    } else {\n      render();\n      // highlight path only\n      res.path.forEach((n, i) => {\n        setTimeout(()=> {\n          highlightNode(n, '#f97316', 700);\n        }, i * 250);\n      });\n      searchResult.textContent = `Not found. Path: ${res.path.map(n=>n.value).join(' → ')}`;\n    }\n  });\n\n  randomBtn.addEventListener('click', () => {\n    const count = Math.floor(Math.random() * 8) + 4; // 4..11 nodes\n    tree.root = null;\n    tree._count = 0;\n    Node._idCounter = 1;\n    const values = [];\n    while (values.length < count) {\n      const v = Math.floor(Math.random() * 99) + 1;\n      if (!values.includes(v)) values.push(v);\n    }\n    values.forEach(v => tree.insert(v));\n    prepareTraversal();\n    render();\n  });\n\n  clearBtn.addEventListener('click', () => {\n    if (!confirm('Clear the entire tree?')) return;\n    tree.root = null;\n    tree._count = 0;\n    Node._idCounter = 1;\n    prepareTraversal();\n    render();\n  });\n\n  playBtn.addEventListener('click', () => {\n    if (!currentTraversal || currentTraversal.length === 0) prepareTraversal();\n    playTraversal();\n  });\n  stepBtn.addEventListener('click', () => {\n    if (!currentTraversal || currentTraversal.length === 0) prepareTraversal();\n    stepTraversal();\n  });\n  stopBtn.addEventListener('click', () => {\n    stopTraversal();\n  });\n\n  // Clicking background clears input and selection\n  svg.addEventListener('click', (ev) => {\n    valueInput.value = '';\n    searchTarget = null;\n    searchResult.textContent = 'No query';\n  });\n\n  // Initialize with some sample values\n  (function initDemo(){\n    const initial = [50, 30, 70, 20, 40, 60, 80];\n    initial.forEach(v => tree.insert(v));\n    prepareTraversal();\n    render();\n  })();\n\n  // Expose some keyboard shortcuts for convenience\n  document.addEventListener('keydown', (ev) => {\n    if (ev.key === 'Enter') {\n      // Enter triggers Insert\n      insertBtn.click();\n    }\n  });\n\n  // Make the nodes slightly more responsive on resize: recompute layout on window resize\n  let resizeTimer = null;\n  window.addEventListener('resize', ()=> {\n    if (resizeTimer) clearTimeout(resizeTimer);\n    resizeTimer = setTimeout(()=> {\n      render();\n    }, 120);\n  });\n\n  // Initial stats update\n  updateStats();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Tree"
    }
  ],
  "topic": "Binary Tree",
  "hasFSM": false,
  "hasTest": true
}