{
  "id": "2bde6a9c-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:53.910Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>K-Nearest Neighbors (KNN) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <style>\n    :root{\n      --bg:#0f1724; --panel:#0b1220; --accent:#6ee7b7; --muted:#94a3b8;\n      --red:#fb7185; --blue:#60a5fa; --yellow:#fef08a;\n      color-scheme: dark;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{background:linear-gradient(180deg,#021428 0%, #081428 45%, #071223 100%); color:#dbeafe; padding:18px; box-sizing:border-box;}\n    h1{margin:0 0 10px 0;font-size:20px;}\n    .wrap{display:flex;gap:18px;align-items:flex-start;max-width:1200px;margin:0 auto;}\n    .left{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:12px; border-radius:8px;}\n    .canvas-wrap{position:relative;}\n    canvas{background:#041426;border-radius:6px; box-shadow:0 6px 20px rgba(0,0,0,0.6);}\n    .controls{width:360px;padding:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:8px;border:1px solid rgba(255,255,255,0.04);}\n    label{display:block;margin:8px 0 4px 0;color:var(--muted);font-size:13px;}\n    .row{display:flex;gap:8px;align-items:center;margin:8px 0;}\n    .btn{cursor:pointer;padding:8px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:rgba(255,255,255,0.02);color:inherit;}\n    .btn.primary{background:linear-gradient(90deg,var(--accent),#43c6f2);color:#021018;border:0;}\n    .small{font-size:13px;padding:6px 8px;}\n    input[type=range]{width:100%;}\n    .legend{display:flex;gap:8px;align-items:center;margin-top:6px;}\n    .swatch{width:14px;height:14px;border-radius:999px;display:inline-block;margin-right:8px;vertical-align:middle;}\n    .info{font-size:13px;color:var(--muted);margin-top:8px;line-height:1.35;}\n    .stats{background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;margin-top:8px;font-size:13px;}\n    .neighbor-list{margin-top:8px;font-size:13px;max-height:160px;overflow:auto;padding-right:6px;}\n    .muted{color:var(--muted);}\n    .footer{font-size:12px;color:var(--muted);margin-top:12px;}\n    .top-row{display:flex;gap:12px;align-items:center;margin-bottom:6px;}\n    .control-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;}\n    .toggle{display:flex;gap:6px;align-items:center}\n    .badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:6px;font-size:13px;}\n    .link{color:var(--accent);cursor:pointer;text-decoration:underline}\n    footer small{color:var(--muted)}\n    @media (max-width:980px){ .wrap{flex-direction:column;align-items:center} .controls{width:100%}}\n  </style>\n</head>\n<body>\n  <h1>K-Nearest Neighbors (KNN) — Interactive Visual Demo</h1>\n  <div class=\"wrap\">\n    <div class=\"left canvas-wrap\">\n      <div class=\"top-row\">\n        <div class=\"badge\">Click canvas to add point of selected class. Drag the yellow query point to classify.</div>\n        <div style=\"flex:1\"></div>\n        <div class=\"badge\">Right-click a point to delete it.</div>\n      </div>\n      <canvas id=\"knnCanvas\" width=\"720\" height=\"520\"></canvas>\n      <div class=\"info\">\n        Explanation: KNN classifies new items by finding the K closest training points and using majority voting (optionally weighted). Try different K and distance metrics and watch how the decision boundary changes.\n      </div>\n    </div>\n\n    <div class=\"controls\">\n      <div style=\"display:flex;gap:8px;align-items:center;\">\n        <label style=\"margin:0;font-weight:600\">Active class for adding:</label>\n      </div>\n      <div style=\"display:flex;gap:8px;margin-top:8px;\">\n        <button id=\"class0\" class=\"btn\" style=\"background:rgba(255,255,255,0.015)\"><span class=\"swatch\" style=\"background:var(--red)\"></span>Class A</button>\n        <button id=\"class1\" class=\"btn\" style=\"background:rgba(255,255,255,0.015)\"><span class=\"swatch\" style=\"background:var(--blue)\"></span>Class B</button>\n        <button id=\"eraser\" class=\"btn\" title=\"Switch to erase mode\">Eraser</button>\n      </div>\n\n      <label for=\"kRange\">K (neighbors): <span id=\"kValue\">3</span></label>\n      <input id=\"kRange\" type=\"range\" min=\"1\" max=\"25\" value=\"3\">\n\n      <label for=\"metric\">Distance metric</label>\n      <select id=\"metric\" style=\"width:100%;padding:8px;border-radius:6px;background:rgba(255,255,255,0.02);color:inherit;border:1px solid rgba(255,255,255,0.03)\">\n        <option value=\"euclidean\">Euclidean (L2)</option>\n        <option value=\"manhattan\">Manhattan (L1)</option>\n        <option value=\"chebyshev\">Chebyshev (L∞)</option>\n      </select>\n\n      <label>Decision boundary</label>\n      <div style=\"display:flex;gap:8px;\">\n        <button id=\"toggleBoundary\" class=\"btn small\">Toggle Boundary</button>\n        <button id=\"toggleWeighted\" class=\"btn small\">Weighted Voting: Off</button>\n        <button id=\"randomData\" class=\"btn small\">Random data</button>\n      </div>\n\n      <div class=\"row\">\n        <label style=\"margin:0;\">Query point</label>\n      </div>\n      <div style=\"display:flex;gap:8px;align-items:center;\">\n        <div class=\"swatch\" style=\"background:var(--yellow);width:18px;height:18px;border-radius:4px\"></div>\n        <div>\n          <div id=\"queryInfo\" class=\"muted\">Drag the yellow point on the canvas; classification updates live.</div>\n        </div>\n      </div>\n\n      <div class=\"stats\">\n        <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n          <div><strong>Prediction:</strong> <span id=\"prediction\">—</span></div>\n          <div><strong>Prob:</strong> <span id=\"prob\">—</span></div>\n        </div>\n        <div style=\"margin-top:6px;\"><strong>Neighbors (closest first):</strong></div>\n        <div class=\"neighbor-list\" id=\"neighbors\"></div>\n        <div style=\"margin-top:8px;\" id=\"looContainer\"></div>\n      </div>\n\n      <div style=\"margin-top:10px;display:flex;gap:8px;\">\n        <button id=\"clearBtn\" class=\"btn\">Clear all</button>\n        <button id=\"seedBtn\" class=\"btn\">Load Stylish Example</button>\n        <button id=\"explainBtn\" class=\"btn\">How it works</button>\n      </div>\n\n      <div class=\"footer\">\n        <div style=\"margin-top:10px;\">\n          Tip: Increase K to smooth the boundary; use weighted voting to give nearer neighbors more influence.\n        </div>\n        <footer style=\"margin-top:10px\"><small>Interactive demo — K-Nearest Neighbors</small></footer>\n      </div>\n    </div>\n  </div>\n\n<script>\n(function(){\n  const canvas = document.getElementById('knnCanvas');\n  const ctx = canvas.getContext('2d');\n  const rect = () => canvas.getBoundingClientRect();\n\n  const width = canvas.width;\n  const height = canvas.height;\n\n  // State\n  let points = []; // {x,y,label}\n  let activeClass = 0; // 0 red, 1 blue, 2 eraser\n  let k = 3;\n  let metric = 'euclidean';\n  let showBoundary = true;\n  let weighted = false;\n  let query = {x: width*0.75, y: height*0.25};\n  let draggingQuery = false;\n  let neighborsCache = [];\n  const colorA = getComputedStyle(document.documentElement).getPropertyValue('--red').trim() || '#fb7185';\n  const colorB = getComputedStyle(document.documentElement).getPropertyValue('--blue').trim() || '#60a5fa';\n  const colorQuery = getComputedStyle(document.documentElement).getPropertyValue('--yellow').trim() || '#fef08a';\n  const bg = '#041426';\n\n  // DOM elements\n  const class0Btn = document.getElementById('class0');\n  const class1Btn = document.getElementById('class1');\n  const eraserBtn = document.getElementById('eraser');\n  const kRange = document.getElementById('kRange');\n  const kValue = document.getElementById('kValue');\n  const metricSelect = document.getElementById('metric');\n  const neighborsDiv = document.getElementById('neighbors');\n  const predictionSpan = document.getElementById('prediction');\n  const probSpan = document.getElementById('prob');\n  const toggleBoundaryBtn = document.getElementById('toggleBoundary');\n  const toggleWeightedBtn = document.getElementById('toggleWeighted');\n  const randomDataBtn = document.getElementById('randomData');\n  const clearBtn = document.getElementById('clearBtn');\n  const seedBtn = document.getElementById('seedBtn');\n  const explainBtn = document.getElementById('explainBtn');\n  const looContainer = document.getElementById('looContainer');\n\n  // Utility distances\n  function dist(a,b,metric){\n    const dx = Math.abs(a.x-b.x);\n    const dy = Math.abs(a.y-b.y);\n    if(metric === 'euclidean') return Math.hypot(dx,dy);\n    if(metric === 'manhattan') return dx+dy;\n    if(metric === 'chebyshev') return Math.max(dx,dy);\n    return Math.hypot(dx,dy);\n  }\n\n  // KNN classify a point (x,y) given dataset and options\n  function knnClassify(x,y, options = {}) {\n    const m = options.metric || metric;\n    let K = options.k || k;\n    const weightedOpt = options.weighted !== undefined ? options.weighted : weighted;\n\n    if(points.length === 0) return {label:null, probs:[0,0], neighbors:[]};\n\n    // clamp K\n    K = Math.max(1, Math.min(K, points.length));\n\n    const distances = points.map((p,i) => ({index:i, p, d: dist({x,y}, p, m)}));\n    distances.sort((a,b)=> a.d - b.d);\n\n    const neighbors = distances.slice(0,K);\n    // Voting\n    const votes = new Map(); // label -> weighted count\n    for(const nb of neighbors){\n      const lab = nb.p.label;\n      let weight = 1;\n      if(weightedOpt){\n        // avoid divide by zero\n        weight = nb.d === 0 ? 1e6 : 1 / nb.d;\n      }\n      votes.set(lab, (votes.get(lab) || 0) + weight);\n    }\n    // determine winner and probabilities\n    const total = Array.from(votes.values()).reduce((a,b)=>a+b,0) || 1;\n    const probs = [ (votes.get(0) || 0)/total, (votes.get(1) || 0)/total ];\n    // handle ties: choose class with smallest sum distances among tied classes\n    let bestLabel = null; let bestScore = -Infinity;\n    // If tie in vote, break by sum of distances (smaller sum wins)\n    // We'll compute vote values and tie-break if needed.\n    const voteArr = [{label:0, v:votes.get(0)||0},{label:1, v:votes.get(1)||0}];\n    voteArr.sort((a,b) => b.v - a.v);\n    if(voteArr[0].v > voteArr[1].v){\n      bestLabel = voteArr[0].label;\n    } else {\n      // tie or equal -> compute sum distances per label and pick smaller\n      const sumDist = [0,0];\n      for(const nb of neighbors){\n        sumDist[nb.p.label] += nb.d;\n      }\n      if(sumDist[0] < sumDist[1]) bestLabel = 0;\n      else if(sumDist[1] < sumDist[0]) bestLabel = 1;\n      else {\n        // still tie -> random\n        bestLabel = Math.random() < 0.5 ? 0 : 1;\n      }\n    }\n    return {label:bestLabel, probs, neighbors};\n  }\n\n  // Draw functions\n  function draw(){\n    // background\n    ctx.fillStyle = bg;\n    ctx.fillRect(0,0,width,height);\n\n    // decision boundary grid\n    if(showBoundary && points.length>0){\n      const step = 8; // pixel step for sampling grid\n      const imgData = ctx.getImageData(0,0,width,height);\n      // We'll compute and paint small squares (step x step)\n      for(let y=0; y<height; y+=step){\n        for(let x=0; x<width; x+=step){\n          const res = knnClassify(x+0.5*step,y+0.5*step,{k,metric,weighted});\n          const a = 0.12 + Math.max(res.probs[0],res.probs[1]) * 0.5; // alpha by confidence\n          const col = res.label === 0 ? hexToRgba(colorA,a) : hexToRgba(colorB,a);\n          ctx.fillStyle = col;\n          ctx.fillRect(x,y,step,step);\n        }\n      }\n    }\n\n    // draw grid lines subtle\n    drawGrid();\n\n    // draw points\n    for(let i=0;i<points.length;i++){\n      const p = points[i];\n      drawPoint(p.x,p.y,p.label===0?colorA:colorB,8, true);\n    }\n\n    // highlight neighbors\n    if(neighborsCache && neighborsCache.length){\n      ctx.lineWidth = 2;\n      for(const nb of neighborsCache){\n        drawPoint(nb.p.x, nb.p.y, nb.p.label===0?colorA:colorB, 12, false, true);\n        // draw line to query\n        ctx.beginPath();\n        ctx.moveTo(query.x, query.y);\n        ctx.lineTo(nb.p.x, nb.p.y);\n        ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n        ctx.stroke();\n      }\n    }\n\n    // draw query\n    drawQuery();\n\n    // overlay axes or labels if needed\n  }\n\n  function drawGrid(){\n    ctx.save();\n    ctx.strokeStyle = 'rgba(255,255,255,0.02)';\n    ctx.lineWidth = 1;\n    const spacing = 40;\n    for(let x=0;x<=width;x+=spacing){\n      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,height); ctx.stroke();\n    }\n    for(let y=0;y<=height;y+=spacing){\n      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(width,y); ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawPoint(x,y,color,size=8, fill=true, outline=false){\n    ctx.beginPath();\n    ctx.arc(x,y,size/2,0,Math.PI*2);\n    if(fill){\n      ctx.fillStyle = color;\n      ctx.fill();\n    }\n    if(outline){\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = 'rgba(255,255,255,0.12)';\n      ctx.stroke();\n    }\n  }\n\n  function drawQuery(){\n    // outer ring\n    ctx.beginPath();\n    ctx.arc(query.x, query.y, 12, 0, Math.PI*2);\n    ctx.fillStyle = hexToRgba(colorQuery, 0.18);\n    ctx.fill();\n    // inner square or circle\n    ctx.beginPath();\n    ctx.rect(query.x-6, query.y-6, 12, 12);\n    ctx.fillStyle = colorQuery;\n    ctx.fill();\n    // label predicted class\n    const res = knnClassify(query.x, query.y, {k,metric,weighted});\n    ctx.fillStyle = 'rgba(0,0,0,0.5)';\n    ctx.fillRect(query.x+12, query.y-18, 72, 22);\n    ctx.fillStyle = '#fff';\n    ctx.font = '12px system-ui,Arial';\n    ctx.fillText('P: ' + (res.label===0 ? 'A' : res.label===1 ? 'B' : '—'), query.x+16, query.y-3);\n  }\n\n  // Helpers\n  function hexToRgba(hex, a){\n    // accept #rrggbb or rgb...\n    let c = hex.trim();\n    if(c.startsWith('#')){\n      c = c.slice(1);\n      const r = parseInt(c.substr(0,2),16);\n      const g = parseInt(c.substr(2,2),16);\n      const b = parseInt(c.substr(4,2),16);\n      return `rgba(${r},${g},${b},${a})`;\n    }\n    // fallback\n    return hex;\n  }\n\n  // UI updates\n  function updateUI(){\n    kValue.textContent = k;\n    toggleWeightedBtn.textContent = 'Weighted Voting: ' + (weighted ? 'On' : 'Off');\n    // compute prediction\n    const res = knnClassify(query.x, query.y, {k,metric,weighted});\n    predictionSpan.textContent = res.label===0 ? 'Class A' : res.label===1 ? 'Class B' : '—';\n    probSpan.textContent = (res.probs[res.label]!==undefined ? (res.probs[res.label]*100).toFixed(1) + '%' : '—');\n    // neighbors list\n    neighborsDiv.innerHTML = '';\n    neighborsCache = res.neighbors;\n    for(const nb of neighborsCache){\n      const li = document.createElement('div');\n      li.style.display = 'flex'; li.style.justifyContent = 'space-between'; li.style.padding = '4px 0';\n      const left = document.createElement('div');\n      left.innerHTML = `<span style=\"display:inline-block;width:10px;height:10px;border-radius:999px;background:${nb.p.label===0?colorA:colorB};margin-right:8px;vertical-align:middle\"></span> ${nb.p.label===0?'A':'B'}`\n      const right = document.createElement('div');\n      right.className = 'muted';\n      right.textContent = nb.d.toFixed(1) + ' px';\n      li.appendChild(left); li.appendChild(right);\n      neighborsDiv.appendChild(li);\n    }\n\n    // leave-one-out accuracy\n    if(points.length >= 2){\n      let correct = 0;\n      for(let i=0;i<points.length;i++){\n        const test = points[i];\n        const others = points.filter((_,idx)=>idx!==i);\n        // temporarily swap\n        const saved = points;\n        points = others;\n        const pred = knnClassify(test.x,test.y,{k: Math.max(1, Math.min(k, others.length)), metric, weighted});\n        if(pred.label === test.label) correct++;\n        points = saved;\n      }\n      const acc = correct / points.length;\n      looContainer.innerHTML = `<div><strong>Leave-one-out accuracy:</strong> ${(acc*100).toFixed(1)}% (${correct}/${points.length})</div>`;\n    } else {\n      looContainer.innerHTML = '<div class=\"muted\">Need at least 2 points to compute leave-one-out accuracy.</div>';\n    }\n  }\n\n  // Event handlers for canvas interactions\n  function getMousePos(evt){\n    const r = rect();\n    let clientX = evt.clientX, clientY = evt.clientY;\n    if(evt.touches && evt.touches[0]){\n      clientX = evt.touches[0].clientX; clientY = evt.touches[0].clientY;\n    }\n    return {\n      x: Math.max(0, Math.min(width, clientX - r.left)),\n      y: Math.max(0, Math.min(height, clientY - r.top))\n    };\n  }\n\n  canvas.addEventListener('mousedown', (e)=>{\n    e.preventDefault();\n    const pos = getMousePos(e);\n    // right click -> try delete nearest point if close\n    if(e.button === 2){\n      // find nearest point\n      let nearest = null; let nd = Infinity;\n      for(let i=0;i<points.length;i++){\n        const d = dist(pos, points[i], 'euclidean');\n        if(d < nd){ nd = d; nearest = i; }\n      }\n      if(nearest !== null && nd < 12){\n        points.splice(nearest,1);\n        updateUI();\n        draw();\n      }\n      return;\n    }\n    // if clicking on query point -> start dragging\n    const dQ = dist(pos, query, 'euclidean');\n    if(dQ < 16){\n      draggingQuery = true;\n      return;\n    }\n    // otherwise add point of activeClass or erase\n    if(activeClass === 2){\n      // eraser mode: delete nearest\n      let nearest = null; let nd = Infinity;\n      for(let i=0;i<points.length;i++){\n        const d = dist(pos, points[i], 'euclidean');\n        if(d < nd){ nd = d; nearest = i; }\n      }\n      if(nearest !== null && nd < 12){\n        points.splice(nearest,1);\n      }\n    } else {\n      points.push({x: pos.x, y: pos.y, label: activeClass});\n    }\n    updateUI();\n    draw();\n  });\n\n  window.addEventListener('mousemove', (e)=>{\n    if(draggingQuery){\n      const pos = getMousePos(e);\n      query.x = pos.x; query.y = pos.y;\n      updateUI();\n      draw();\n    }\n  });\n\n  window.addEventListener('mouseup', (e)=>{\n    draggingQuery = false;\n  });\n\n  // touch support for dragging query\n  canvas.addEventListener('touchstart', (e)=>{\n    const pos = getMousePos(e);\n    const dQ = dist(pos, query, 'euclidean');\n    if(dQ < 16){\n      draggingQuery = true;\n    } else {\n      // add point\n      if(activeClass !== 2) points.push({x: pos.x, y: pos.y, label: activeClass});\n    }\n    updateUI();\n    draw();\n    e.preventDefault();\n  }, {passive:false});\n\n  canvas.addEventListener('touchmove', (e)=>{\n    if(draggingQuery){\n      const pos = getMousePos(e);\n      query.x = pos.x; query.y = pos.y;\n      updateUI();\n      draw();\n    }\n    e.preventDefault();\n  }, {passive:false});\n\n  canvas.addEventListener('dblclick', (e)=>{\n    // double click to place query\n    const pos = getMousePos(e);\n    query.x = pos.x; query.y = pos.y;\n    updateUI(); draw();\n  });\n\n  // prevent context menu on canvas to allow right-click delete\n  canvas.addEventListener('contextmenu', (e)=> e.preventDefault());\n\n  // UI control events\n  class0Btn.addEventListener('click', ()=>{\n    activeClass = 0;\n    class0Btn.classList.add('primary'); class1Btn.classList.remove('primary'); eraserBtn.classList.remove('primary');\n  });\n\n  class1Btn.addEventListener('click', ()=>{\n    activeClass = 1;\n    class1Btn.classList.add('primary'); class0Btn.classList.remove('primary'); eraserBtn.classList.remove('primary');\n  });\n\n  eraserBtn.addEventListener('click', ()=>{\n    activeClass = 2;\n    eraserBtn.classList.add('primary'); class0Btn.classList.remove('primary'); class1Btn.classList.remove('primary');\n  });\n\n  kRange.addEventListener('input', (e)=>{\n    k = parseInt(e.target.value,10);\n    updateUI(); draw();\n  });\n\n  metricSelect.addEventListener('change', (e)=>{\n    metric = e.target.value;\n    updateUI(); draw();\n  });\n\n  toggleBoundaryBtn.addEventListener('click', ()=>{\n    showBoundary = !showBoundary;\n    toggleBoundaryBtn.textContent = showBoundary ? 'Toggle Boundary' : 'Toggle Boundary';\n    draw();\n  });\n\n  toggleWeightedBtn.addEventListener('click', ()=>{\n    weighted = !weighted;\n    toggleWeightedBtn.textContent = 'Weighted Voting: ' + (weighted ? 'On' : 'Off');\n    updateUI(); draw();\n  });\n\n  randomDataBtn.addEventListener('click', ()=>{\n    // generate random clusters\n    points = [];\n    // create two Gaussian clusters\n    function randn_bm() {\n      let u = 0, v = 0;\n      while(u === 0) u = Math.random();\n      while(v === 0) v = Math.random();\n      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n    }\n    const cx1 = width*0.3, cy1 = height*0.6;\n    const cx2 = width*0.7, cy2 = height*0.3;\n    for(let i=0;i<40;i++){\n      points.push({x: cx1 + randn_bm()*60, y: cy1 + randn_bm()*40, label:0});\n      points.push({x: cx2 + randn_bm()*60, y: cy2 + randn_bm()*40, label:1});\n    }\n    updateUI(); draw();\n  });\n\n  clearBtn.addEventListener('click', ()=>{\n    points = [];\n    updateUI(); draw();\n  });\n\n  seedBtn.addEventListener('click', ()=>{\n    // stylish example with two spirals or moon shapes\n    points = [];\n    // half-moon dataset\n    for(let i=0;i<60;i++){\n      const t = Math.PI * (Math.random()*1.0 + 0.0);\n      const r = 80 + Math.random()*20;\n      points.push({x: width*0.35 + Math.cos(t)*r + Math.random()*12, y: height*0.6 + Math.sin(t)*r + Math.random()*12, label:0});\n    }\n    for(let i=0;i<60;i++){\n      const t = Math.PI * (Math.random()*1.0 + 0.6);\n      const r = 80 + Math.random()*20;\n      points.push({x: width*0.65 + Math.cos(t)*r + Math.random()*12, y: height*0.4 + Math.sin(t)*r + Math.random()*12, label:1});\n    }\n    updateUI(); draw();\n  });\n\n  explainBtn.addEventListener('click', ()=>{\n    alert(`How KNN works (short):\n1) Choose K (number of nearest neighbors).\n2) Pick a distance metric (e.g. Euclidean).\n3) For a new query point, find the K closest training points.\n4) Majority vote among those neighbors determines the predicted class.\nWeighted voting gives nearer neighbors more influence (weight = 1/distance).`);\n  });\n\n  // Initial state\n  class0Btn.classList.add('primary');\n\n  // initial random sample\n  (function init(){\n    // Add a few default points to show behavior\n    points = [\n      {x:120,y:380,label:0},{x:150,y:420,label:0},{x:200,y:360,label:0},{x:220,y:400,label:0},\n      {x:520,y:120,label:1},{x:560,y:160,label:1},{x:600,y:100,label:1},{x:480,y:80,label:1}\n    ];\n    updateUI();\n    draw();\n  })();\n\n  // Resize handling (optional)\n  window.addEventListener('resize', ()=>{\n    // keep canvas fixed size for demo; can add responsive scaling if needed\n    draw();\n  });\n\n  // Expose knnClassify to console for experimentation\n  window.knnClassify = knnClassify;\n  window.points = points;\n\n  // Initial draw loop\n  draw();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": false,
  "hasTest": true
}