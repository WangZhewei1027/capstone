{
  "id": "2bde438f-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:48.797Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Dijkstra's Algorithm - Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, Ubuntu, \"Helvetica Neue\", Arial; margin: 0; display: flex; height: 100vh; }\n  #left { flex: 1; background: #f7f9fc; position: relative; }\n  canvas { width: 100%; height: 100%; display: block; background: linear-gradient(180deg,#fff,#eef3fb); }\n  #right { width: 360px; border-left: 1px solid #ddd; padding: 12px; box-sizing: border-box; overflow:auto; background: #fff; }\n  h2 { margin: 6px 0 10px 0; font-size: 18px; }\n  .controls { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 10px; }\n  button, select, input { padding: 6px 8px; font-size: 14px; }\n  button { cursor: pointer; }\n  .mode { display:flex; gap:6px; margin-bottom:8px; flex-wrap:wrap; }\n  .label { font-size: 13px; margin-bottom:6px; color:#333; }\n  table { width:100%; border-collapse: collapse; margin-top:8px; font-size:13px; }\n  th, td { border: 1px solid #e3e6ea; padding:6px 8px; text-align:left; }\n  th { background:#fafafa; font-weight:600; }\n  .small { font-size:12px; color:#666; }\n  #pq { font-size:13px; margin-top:8px; }\n  #info { font-size:13px; color:#444; margin-top:10px; }\n  .hint { font-size:12px; color:#666; margin-top:6px; }\n  .footer { margin-top:12px; font-size:12px; color:#777; }\n  input[type=\"number\"] { width:72px; }\n  label.inline { display:inline-flex; align-items:center; gap:6px; font-size:13px; }\n  #speed { width:140px; }\n</style>\n</head>\n<body>\n  <div id=\"left\">\n    <canvas id=\"canvas\"></canvas>\n  </div>\n  <div id=\"right\">\n    <h2>Dijkstra's Algorithm — Interactive Demo</h2>\n    <div class=\"label\">Mode</div>\n    <div class=\"mode\">\n      <button id=\"mode-add-node\">Add Node</button>\n      <button id=\"mode-add-edge\">Add Edge</button>\n      <button id=\"mode-move\">Move</button>\n      <button id=\"mode-delete\">Delete</button>\n    </div>\n\n    <div class=\"label\">Selection</div>\n    <div class=\"controls\">\n      <button id=\"set-source\">Set Source</button>\n      <button id=\"set-target\">Set Target</button>\n      <label class=\"inline\"><input type=\"checkbox\" id=\"undirected\" checked> Undirected</label>\n      <input id=\"default-weight\" type=\"number\" value=\"1\" min=\"0\" step=\"0.1\" title=\"Default weight used when creating an edge\">\n    </div>\n\n    <div class=\"label\">Algorithm Controls</div>\n    <div class=\"controls\">\n      <button id=\"reset\">Reset Algorithm</button>\n      <button id=\"step\">Step</button>\n      <button id=\"run\">Run</button>\n      <button id=\"pause\">Pause</button>\n      <label class=\"inline\">Speed <input id=\"speed\" type=\"range\" min=\"100\" max=\"2000\" step=\"100\" value=\"700\"></label>\n    </div>\n\n    <div class=\"label\">Graph Utilities</div>\n    <div class=\"controls\">\n      <button id=\"clear\">Clear Graph</button>\n      <button id=\"random\">Random Graph</button>\n      <button id=\"auto-layout\">Auto Layout</button>\n    </div>\n\n    <div id=\"info\">\n      Click \"Add Node\" then click canvas to place nodes. Use \"Add Edge\" to click one node then another (prompt for weight). Move mode drags nodes. Double-click an edge to edit weight. Click a node in Set Source/Target mode to mark them. Delete mode removes clicked node/edge.\n    </div>\n\n    <div class=\"label\">Nodes (dist, prev, visited)</div>\n    <div id=\"table-wrap\">\n      <table id=\"nodes-table\">\n        <thead><tr><th>Node</th><th>Distance</th><th>Prev</th><th>Visited</th></tr></thead>\n        <tbody></tbody>\n      </table>\n    </div>\n\n    <div class=\"label\">Priority Queue</div>\n    <div id=\"pq\">[]</div>\n\n    <div class=\"hint\">When algorithm finishes, the shortest path from source to target (if set) will be highlighted in blue.</div>\n    <div class=\"footer\">Dijkstra's algorithm visualized. Weighted edges; non-negative weights required.</div>\n  </div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  let DPR = window.devicePixelRatio || 1;\n  function resize() {\n    const rect = canvas.getBoundingClientRect();\n    canvas.width = Math.floor(rect.width * DPR);\n    canvas.height = Math.floor(rect.height * DPR);\n    ctx.setTransform(DPR,0,0,DPR,0,0);\n    draw();\n  }\n  window.addEventListener('resize', () => { DPR = window.devicePixelRatio || 1; resize(); });\n  resize();\n\n  // State\n  let nodes = []; // {id,x,y}\n  let edges = []; // {id, from, to, weight, undirected}\n  let nodeId = 0, edgeId = 0;\n\n  let mode = 'add-node'; // add-node, add-edge, move, delete\n  const modeButtons = {\n    'add-node': document.getElementById('mode-add-node'),\n    'add-edge': document.getElementById('mode-add-edge'),\n    'move': document.getElementById('mode-move'),\n    'delete': document.getElementById('mode-delete')\n  };\n  function setMode(m) {\n    mode = m;\n    Object.keys(modeButtons).forEach(k => modeButtons[k].style.background = (k===m ? '#e0f0ff' : ''));\n    tempEdgeStart = null;\n    draw();\n  }\n  Object.entries(modeButtons).forEach(([k,btn])=>btn.addEventListener('click',()=>setMode(k)));\n  setMode('add-node');\n\n  const undirectedCheckbox = document.getElementById('undirected');\n  const defaultWeightInput = document.getElementById('default-weight');\n\n  // Source/target\n  let source = null, target = null;\n  document.getElementById('set-source').addEventListener('click', ()=> { setMode('move'); clickMode = 'set-source'; });\n  document.getElementById('set-target').addEventListener('click', ()=> { setMode('move'); clickMode = 'set-target'; });\n  let clickMode = null; // 'set-source' or 'set-target' or null\n\n  // Algorithm state\n  let dist = {}; // id -> number\n  let prev = {}; // id -> id or null\n  let visited = {}; // id -> bool\n  let pq = []; // array of {id,dist}\n  let running = false;\n  let autoTimer = null;\n\n  const nodesTableBody = document.querySelector('#nodes-table tbody');\n  const pqDiv = document.getElementById('pq');\n\n  // Buttons\n  document.getElementById('reset').addEventListener('click', resetAlgorithm);\n  document.getElementById('step').addEventListener('click', step);\n  document.getElementById('run').addEventListener('click', runAuto);\n  document.getElementById('pause').addEventListener('click', pauseAuto);\n  document.getElementById('clear').addEventListener('click', ()=>{ if(confirm('Clear entire graph?')) { nodes=[]; edges=[]; nodeId=edgeId=0; source=target=null; resetAlgorithm(); }});\n  document.getElementById('random').addEventListener('click', ()=>{ generateRandomGraph(); });\n  document.getElementById('auto-layout').addEventListener('click', ()=>{ autoLayout(); });\n\n  function generateRandomGraph() {\n    nodes = [];\n    edges = [];\n    nodeId = edgeId = 0;\n    const n = Math.max(4, Math.min(12, Math.round(Math.random()*8)+4));\n    const W = canvas.width / DPR, H = canvas.height / DPR;\n    for(let i=0;i<n;i++){\n      nodes.push({id: nodeId++, x: 50 + Math.random()*(W-100), y: 50 + Math.random()*(H-100)});\n    }\n    // add edges\n    for(let i=0;i<n;i++){\n      for(let j=i+1;j<n;j++){\n        if(Math.random() < 0.35) {\n          const w = +(Math.random()*9+1).toFixed(1);\n          const und = undirectedCheckbox.checked;\n          edges.push({id: edgeId++, from: nodes[i].id, to: nodes[j].id, weight: w, undirected: und});\n        }\n      }\n    }\n    source = nodes[0]?.id ?? null;\n    target = nodes[n-1]?.id ?? null;\n    resetAlgorithm();\n  }\n\n  function autoLayout() {\n    // simple force layout-ish: random jitter and spread\n    const W = canvas.width / DPR, H = canvas.height / DPR;\n    for(let i=0;i<nodes.length;i++){\n      nodes[i].x = 50 + (i % 5) * ((W-100)/Math.min(4,nodes.length)) + Math.random()*20;\n      nodes[i].y = 50 + Math.floor(i/5) * 100 + Math.random()*20;\n    }\n    draw();\n  }\n\n  // Canvas interactions\n  let tempEdgeStart = null;\n  let draggingNode = null;\n  let dragOffset = {x:0,y:0};\n  const R = 20;\n  function getMouse(e){\n    const rect = canvas.getBoundingClientRect();\n    return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };\n  }\n  function findNodeAt(x,y){\n    for(let i=nodes.length-1;i>=0;i--){\n      const n = nodes[i];\n      const dx = n.x - x, dy = n.y - y;\n      if(dx*dx + dy*dy <= R*R) return n;\n    }\n    return null;\n  }\n  function findEdgeAt(x,y){\n    // return edge if click close to its line\n    for(let i=edges.length-1;i>=0;i--){\n      const e = edges[i];\n      const a = nodes.find(n=>n.id===e.from);\n      const b = nodes.find(n=>n.id===e.to);\n      if(!a || !b) continue;\n      const d = distancePointToSegment(x,y,a.x,a.y,b.x,b.y);\n      if(d < 8) return e;\n    }\n    return null;\n  }\n  function distancePointToSegment(px,py,x1,y1,x2,y2) {\n    const A = px-x1, B = py-y1, C = x2-x1, D = y2-y1;\n    const dot = A*C + B*D;\n    const len2 = C*C + D*D;\n    let t = len2 ? dot / len2 : -1;\n    if(t<0) t=0; else if(t>1) t=1;\n    const nx = x1 + C*t, ny = y1 + D*t;\n    const dx = px - nx, dy = py - ny;\n    return Math.sqrt(dx*dx + dy*dy);\n  }\n\n  canvas.addEventListener('mousedown', (e)=>{\n    const m = getMouse(e);\n    const node = findNodeAt(m.x, m.y);\n    if(mode === 'add-node') {\n      // place node\n      nodes.push({id: nodeId++, x: m.x, y: m.y});\n      resetAlgorithm();\n      draw();\n    } else if(mode === 'add-edge') {\n      if(node) {\n        if(!tempEdgeStart) {\n          tempEdgeStart = node;\n        } else if(node.id === tempEdgeStart.id) {\n          // clicked same node -> cancel\n          tempEdgeStart = null;\n        } else {\n          // create edge\n          const w = parseFloat(defaultWeightInput.value) || 1;\n          const und = undirectedCheckbox.checked;\n          edges.push({id: edgeId++, from: tempEdgeStart.id, to: node.id, weight: w, undirected: und});\n          tempEdgeStart = null;\n          resetAlgorithm();\n        }\n        draw();\n      }\n    } else if(mode === 'move') {\n      if(node) {\n        draggingNode = node;\n        dragOffset.x = m.x - node.x;\n        dragOffset.y = m.y - node.y;\n      } else {\n        // might be in set-source/target modes\n        const edge = findEdgeAt(m.x, m.y);\n        if(!node && !edge) {\n          // clicked empty space -> clear clickMode\n          clickMode = null;\n        }\n      }\n    } else if(mode === 'delete') {\n      // delete node or edge\n      if(node) {\n        if(confirm('Delete node and its incident edges?')) {\n          edges = edges.filter(e=>e.from!==node.id && e.to!==node.id);\n          nodes = nodes.filter(n=>n.id!==node.id);\n          if(source===node.id) source=null;\n          if(target===node.id) target=null;\n          resetAlgorithm();\n          draw();\n        }\n      } else {\n        const edge = findEdgeAt(m.x, m.y);\n        if(edge) {\n          if(confirm('Delete edge?')) {\n            edges = edges.filter(e=>e.id!==edge.id);\n            resetAlgorithm();\n            draw();\n          }\n        }\n      }\n    }\n  });\n\n  canvas.addEventListener('mousemove', (e)=>{\n    const m = getMouse(e);\n    if(draggingNode) {\n      draggingNode.x = m.x - dragOffset.x;\n      draggingNode.y = m.y - dragOffset.y;\n      draw();\n    } else {\n      // hover effects for cursor\n      const node = findNodeAt(m.x,m.y);\n      const edge = findEdgeAt(m.x,m.y);\n      canvas.style.cursor = node ? (mode==='move' ? 'grab' : 'pointer') : (edge ? 'pointer' : 'default');\n    }\n  });\n\n  canvas.addEventListener('mouseup', (e)=>{\n    if(draggingNode) {\n      draggingNode = null;\n    } else {\n      const m = getMouse(e);\n      const node = findNodeAt(m.x,m.y);\n      const edge = findEdgeAt(m.x,m.y);\n      if(clickMode && node) {\n        if(clickMode === 'set-source') {\n          source = node.id;\n          resetAlgorithm();\n        } else if(clickMode === 'set-target') {\n          target = node.id;\n        }\n        clickMode = null;\n        draw();\n      } else if(e.detail === 2) {\n        // double click: maybe edit edge weight\n        if(edge) {\n          const input = prompt('Edit edge weight (non-negative):', String(edge.weight));\n          if(input !== null) {\n            const w = parseFloat(input);\n            if(!isFinite(w) || w < 0) alert('Invalid weight.');\n            else { edge.weight = w; resetAlgorithm(); draw(); }\n          }\n        } else if(node) {\n          // double click node to set as source quickly (alt)\n          if(confirm('Set this node as source? OK = source, Cancel = target')) {\n            source = node.id;\n            resetAlgorithm();\n          } else {\n            target = node.id;\n          }\n          draw();\n        }\n      }\n    }\n  });\n\n  // Dijkstra implementation (step-by-step)\n  function resetAlgorithm() {\n    // initialize distances, prev, visited, pq\n    dist = {};\n    prev = {};\n    visited = {};\n    pq = [];\n    nodes.forEach(n => { dist[n.id] = Infinity; prev[n.id] = null; visited[n.id] = false; });\n    if(source != null && nodes.find(n=>n.id===source)) {\n      dist[source] = 0;\n      pq = [{id: source, dist: 0}];\n    } else {\n      pq = [];\n    }\n    running = false;\n    pauseAuto();\n    updateTable();\n    draw();\n  }\n\n  function updateTable() {\n    nodesTableBody.innerHTML = '';\n    const sorted = nodes.slice().sort((a,b)=>a.id - b.id);\n    for(const n of sorted) {\n      const tr = document.createElement('tr');\n      const td0 = document.createElement('td'); td0.textContent = n.id;\n      const td1 = document.createElement('td'); td1.textContent = dist[n.id]===Infinity ? '∞' : +dist[n.id].toFixed(3);\n      const td2 = document.createElement('td'); td2.textContent = prev[n.id]===null ? '-' : prev[n.id];\n      const td3 = document.createElement('td'); td3.textContent = visited[n.id] ? 'yes' : 'no';\n      tr.appendChild(td0); tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);\n      nodesTableBody.appendChild(tr);\n    }\n    pqDiv.textContent = '[' + pq.map(x=>`${x.id}:${(+x.dist.toFixed(3))}`).join(', ') + ']';\n  }\n\n  function popMinFromPQ() {\n    if(pq.length===0) return null;\n    pq.sort((a,b)=>a.dist - b.dist);\n    return pq.shift();\n  }\n\n  // For step granularity, we will: each step pops one node (the min) and relaxes all outgoing edges.\n  // Each call to step executes one \"node visit\". If there is no source or pq empty -> nothing to do.\n  function step() {\n    if(!source || !nodes.find(n=>n.id===source)) { alert('Set a valid source node before running the algorithm.'); return; }\n    // If all nodes visited or pq empty: finish.\n    // Skip nodes already visited in pq: pop until non-visited node.\n    while(pq.length && visited[pq[0].id]) pq.shift();\n    if(pq.length===0) {\n      running = false;\n      pauseAuto();\n      draw();\n      updateTable();\n      return;\n    }\n    const nodeEntry = popMinFromPQ();\n    if(!nodeEntry) { running=false; pauseAuto(); return; }\n    const u = nodeEntry.id;\n    visited[u] = true;\n    // Relax outgoing edges from u\n    const outgoing = edges.filter(e => e.from === u || (e.undirected && e.to === u)); // include undirected reversed by filtering both directions\n    // But the above includes edges where u is to for undirected; ensure neighbor id is correct\n    for(const e of outgoing) {\n      const v = (e.from === u) ? e.to : e.from;\n      if(visited[v]) continue;\n      const alt = dist[u] + Number(e.weight);\n      if(alt < (dist[v] ?? Infinity)) {\n        dist[v] = alt;\n        prev[v] = u;\n        pq.push({id: v, dist: alt});\n      }\n    }\n    updateTable();\n    draw();\n    // check if finished (no more reachable nodes)\n    if(pq.every(x=>visited[x.id]) || pq.length === 0) {\n      running = false;\n      pauseAuto();\n      draw();\n    }\n  }\n\n  function runAuto() {\n    const interval = Number(document.getElementById('speed').value) || 700;\n    if(running) return;\n    running = true;\n    if(!source || !nodes.find(n=>n.id===source)) { alert('Set a valid source node before running.'); running=false; return; }\n    autoTimer = setInterval(()=>{\n      // attempt a step; if step makes no progress and pq empty, stop\n      // ensure we break when nothing left\n      // Note: if pq empty initially, finish\n      // skip visited entries\n      while(pq.length && visited[pq[0].id]) pq.shift();\n      if(pq.length===0) {\n        running = false;\n        pauseAuto();\n        draw();\n        updateTable();\n        return;\n      }\n      step();\n    }, interval);\n  }\n\n  function pauseAuto() {\n    running = false;\n    if(autoTimer) { clearInterval(autoTimer); autoTimer = null; }\n  }\n\n  document.getElementById('speed').addEventListener('input', ()=>{\n    if(running) {\n      pauseAuto();\n      runAuto();\n    }\n  });\n\n  // Rendering\n  function draw() {\n    ctx.clearRect(0,0,canvas.width,DPR ? canvas.height/DPR*DPR : canvas.height);\n    const W = canvas.width / DPR, H = canvas.height / DPR;\n    // Edges\n    ctx.lineWidth = 2;\n    for(const e of edges) {\n      const a = nodes.find(n=>n.id===e.from);\n      const b = nodes.find(n=>n.id===e.to);\n      if(!a || !b) continue;\n      // Determine style: if part of current shortest path to target or visited\n      const onShortPath = isEdgeOnShortestPath(e);\n      const isVisitedEdge = (visited[a.id] && visited[b.id]);\n      ctx.beginPath();\n      ctx.strokeStyle = onShortPath ? '#1f77b4' : (isVisitedEdge ? '#bbb' : '#888');\n      ctx.moveTo(a.x, a.y);\n      ctx.lineTo(b.x, b.y);\n      ctx.stroke();\n\n      // arrow for directed edges\n      if(!e.undirected) {\n        drawArrowHead(a.x,a.y,b.x,b.y, onShortPath ? '#1f77b4' : '#888');\n      }\n\n      // weight label (midpoint)\n      const mx = (a.x + b.x)/2, my = (a.y + b.y)/2;\n      ctx.fillStyle = '#222';\n      ctx.font = '13px sans-serif';\n      const txt = String(e.weight);\n      ctx.fillText(txt, mx + 6, my - 6);\n    }\n\n    // If adding edge and a start selected, show temporary line from node to mouse\n    if(mode==='add-edge' && tempEdgeStart && lastMousePos) {\n      ctx.beginPath();\n      ctx.strokeStyle = '#4aa3ff';\n      ctx.setLineDash([6,6]);\n      ctx.moveTo(tempEdgeStart.x,tempEdgeStart.y);\n      ctx.lineTo(lastMousePos.x,lastMousePos.y);\n      ctx.stroke();\n      ctx.setLineDash([]);\n    }\n\n    // Nodes\n    for(const n of nodes) {\n      const isSource = (n.id === source);\n      const isTarget = (n.id === target);\n      const isVisited = visited[n.id];\n      const curr = (pq.length && pq[0] && pq[0].id === n.id && !isVisited) && running;\n\n      ctx.beginPath();\n      ctx.fillStyle = isSource ? '#2ecc71' : (isTarget ? '#e74c3c' : (curr ? '#ffeaa7' : (isVisited ? '#dfe7ef' : '#ffffff')));\n      ctx.strokeStyle = '#2b3a4a';\n      ctx.lineWidth = 1.5;\n      ctx.arc(n.x, n.y, R, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      // label\n      ctx.fillStyle = '#111';\n      ctx.font = 'bold 13px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(n.id), n.x, n.y);\n\n      // small distance badge\n      const d = dist[n.id];\n      ctx.font = '11px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      ctx.fillStyle = '#333';\n      ctx.fillText(d===Infinity ? '∞' : (+d.toFixed(2)), n.x, n.y + R + 4);\n    }\n\n    // highlight shortest path from source to target if finished\n    if(target != null && prev[target] != null) {\n      const path = reconstructPath(target);\n      if(path.length > 1) {\n        ctx.lineWidth = 4;\n        ctx.strokeStyle = '#1f77b4';\n        for(let i=0;i<path.length-1;i++){\n          const a = nodes.find(n=>n.id===path[i]);\n          const b = nodes.find(n=>n.id===path[i+1]);\n          if(!a||!b) continue;\n          ctx.beginPath();\n          ctx.moveTo(a.x,a.y);\n          ctx.lineTo(b.x,b.y);\n          ctx.stroke();\n        }\n      }\n    }\n  }\n\n  function drawArrowHead(x1,y1,x2,y2, color) {\n    // draw small arrow at 80% of line\n    const t = 0.78;\n    const x = x1 + (x2 - x1)*t;\n    const y = y1 + (y2 - y1)*t;\n    const angle = Math.atan2(y2-y1, x2-x1);\n    const size = 8;\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x - size*Math.cos(angle - Math.PI/6), y - size*Math.sin(angle - Math.PI/6));\n    ctx.lineTo(x - size*Math.cos(angle + Math.PI/6), y - size*Math.sin(angle + Math.PI/6));\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function isEdgeOnShortestPath(e) {\n    // check if edge is between consecutive nodes in prev chain to target\n    if(target == null) return false;\n    const path = reconstructPath(target);\n    for(let i=0;i<path.length-1;i++){\n      const a = path[i], b = path[i+1];\n      if((e.from===a && e.to===b) || (e.undirected && e.from===b && e.to===a) || (e.undirected && e.from===a && e.to===b) || (e.from===b && e.to===a)) {\n        // We'll consider undirected special; essentially check if this edge connects a-b in any orientation\n        if((e.from===a && e.to===b) || (e.from===b && e.to===a) || (e.undirected && ((e.from===a && e.to===b) || (e.from===b && e.to===a)))) return true;\n      }\n    }\n    return false;\n  }\n\n  function reconstructPath(dest) {\n    const path = [];\n    let u = dest;\n    if(prev[u] === null && u !== source) {\n      // if dest==source, return [source]\n      if(u===source) return [source];\n      return [];\n    }\n    while(u !== null) {\n      path.unshift(u);\n      if(u === source) break;\n      u = prev[u];\n      if(u == null) break;\n    }\n    return path;\n  }\n\n  // track mouse pos for temp edge drawing\n  let lastMousePos = null;\n  canvas.addEventListener('mousemove', (e)=>{\n    lastMousePos = getMouse(e);\n    if(mode==='add-edge' && tempEdgeStart) draw();\n  });\n  canvas.addEventListener('mouseleave', ()=>{ lastMousePos = null; draw(); });\n\n  // initialize an example graph\n  function initExample() {\n    nodes = [\n      {id: nodeId++, x: 120, y: 80},\n      {id: nodeId++, x: 260, y: 60},\n      {id: nodeId++, x: 420, y: 90},\n      {id: nodeId++, x: 150, y: 220},\n      {id: nodeId++, x: 320, y: 200},\n      {id: nodeId++, x: 470, y: 220},\n    ];\n    edges = [\n      {id: edgeId++, from: 0, to: 1, weight: 2, undirected: true},\n      {id: edgeId++, from: 0, to: 3, weight: 5, undirected: true},\n      {id: edgeId++, from: 1, to: 2, weight: 3, undirected: true},\n      {id: edgeId++, from: 1, to: 4, weight: 4, undirected: true},\n      {id: edgeId++, from: 2, to: 5, weight: 2, undirected: true},\n      {id: edgeId++, from: 3, to: 4, weight: 2, undirected: true},\n      {id: edgeId++, from: 4, to: 5, weight: 3, undirected: true},\n    ];\n    source = 0; target = 5;\n    resetAlgorithm();\n  }\n\n  // initial example\n  initExample();\n\n  // ensure initial size\n  resize();\n\n  // keyboard shortcuts\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === '1') setMode('add-node');\n    if(e.key === '2') setMode('add-edge');\n    if(e.key === '3') setMode('move');\n    if(e.key === '4') setMode('delete');\n    if(e.key === ' ') { e.preventDefault(); if(running) pauseAuto(); else runAuto(); }\n  });\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}