{
  "id": "be87d8a1-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:32.137Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Recursion",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Recursion Demonstration</title>\n  <style>\n    :root{\n      --bg:#0f1724;\n      --card:#0b1220;\n      --accent:#7dd3fc;\n      --muted:#94a3b8;\n      --panel:#081025;\n      --success:#a7f3d0;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n    }\n    body{\n      margin:0;\n      background: linear-gradient(180deg,#021025 0%, #071426 100%);\n      color: #e6eef6;\n      min-height:100vh;\n      padding:20px;\n      box-sizing:border-box;\n    }\n    header{\n      display:flex;\n      gap:16px;\n      align-items:center;\n      margin-bottom:18px;\n    }\n    h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:0.2px;\n    }\n    main{\n      display:grid;\n      grid-template-columns: 420px 1fr;\n      gap:18px;\n      align-items:start;\n    }\n    .card{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      border: 1px solid rgba(255,255,255,0.04);\n      padding:14px;\n      border-radius:10px;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.6);\n    }\n    .small{\n      font-size:13px;\n      color:var(--muted);\n    }\n    label{display:block;font-size:13px;margin-top:8px;color:var(--muted)}\n    input[type=number], input[type=range], select{\n      width:100%;\n      margin-top:6px;\n      padding:8px 10px;\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.04);\n      color:inherit;\n      border-radius:6px;\n      outline:none;\n    }\n    button{\n      background:linear-gradient(90deg,var(--accent),#60a5fa);\n      color:#042733;\n      padding:8px 10px;\n      border-radius:8px;\n      border:none;\n      font-weight:600;\n      cursor:pointer;\n    }\n    .controls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}\n    .stack{\n      margin-top:12px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border:1px solid rgba(255,255,255,0.03);\n      padding:8px;\n      border-radius:8px;\n      min-height:120px;\n      max-height:320px;\n      overflow:auto;\n      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n      font-size:13px;\n      color:#dbeafe;\n    }\n    .frame{\n      padding:6px 8px;\n      border-radius:6px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));\n      border:1px solid rgba(255,255,255,0.02);\n      margin:6px 0;\n      display:flex;\n      justify-content:space-between;\n      gap:8px;\n    }\n    .frame .name{color:var(--accent);font-weight:700}\n    .frame .ret{color:var(--success);font-weight:700}\n    .muted{color:var(--muted)}\n    canvas{width:100%;height:100%;border-radius:8px;background:linear-gradient(180deg,#071025,#02101b);display:block}\n    .vis-panel{display:flex;flex-direction:column;height:560px;gap:12px}\n    .row{display:flex;gap:12px;align-items:center}\n    .legend{font-size:12px;color:var(--muted);margin-top:6px}\n    footer{margin-top:18px;color:var(--muted);font-size:13px}\n    .inline{display:inline-flex;gap:8px;align-items:center}\n    .badge{background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:999px;font-weight:600;color:var(--muted);font-size:12px}\n    .split{\n      display:grid;grid-template-columns:1fr 1fr;gap:12px;\n    }\n    @media (max-width:980px){\n      main{grid-template-columns:1fr; padding-bottom:40px}\n      .vis-panel{height:420px}\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <div class=\"badge\">Concept: Recursion</div>\n    <div style=\"flex:1\">\n      <h1>Interactive Recursion Playground</h1>\n      <div class=\"small\">See how functions call themselves, visualize call stacks and trees, and draw recursive fractals.</div>\n    </div>\n  </header>\n\n  <main>\n    <div class=\"card\">\n      <h2 style=\"margin:0 0 6px 0\">1) Recursion Trace (Factorial)</h2>\n      <div class=\"small\">Watch an animated call stack as a recursive factorial function runs. The demo uses async recursion so we can visualize each call and return.</div>\n\n      <label>n (integer &ge; 0)</label>\n      <input id=\"factN\" type=\"number\" min=\"0\" max=\"12\" value=\"6\" />\n      <label>Animation speed (ms per step)</label>\n      <input id=\"factSpeed\" type=\"range\" min=\"20\" max=\"800\" value=\"180\" />\n      <div class=\"controls\">\n        <button id=\"runFact\">Run Recursive Factorial</button>\n        <button id=\"runIter\">Run Iterative Factorial</button>\n        <button id=\"clearFact\">Clear</button>\n      </div>\n\n      <div class=\"stack\" id=\"factStack\" aria-live=\"polite\"></div>\n      <div style=\"display:flex;justify-content:space-between;margin-top:8px;align-items:center\">\n        <div class=\"muted\">Result: <span id=\"factResult\">—</span></div>\n        <div class=\"muted\">Call count: <span id=\"factCalls\">0</span></div>\n      </div>\n\n      <hr style=\"margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.02)\">\n\n      <h2 style=\"margin:0 0 6px 0\">2) Fibonacci: Tree & Memoization</h2>\n      <div class=\"small\">Compare naive recursion (exponential calls) with memoized recursion (linear calls). A tree drawing shows how calls branch.</div>\n\n      <label>n (integer, small because naive grows fast)</label>\n      <input id=\"fibN\" type=\"number\" min=\"0\" max=\"12\" value=\"6\" />\n      <label>Animation speed (ms per node, for naive tree)</label>\n      <input id=\"fibSpeed\" type=\"range\" min=\"10\" max=\"400\" value=\"100\" />\n      <div class=\"controls\">\n        <button id=\"runFibNaive\">Draw Naive Fib Tree</button>\n        <button id=\"runFibMemo\">Compute with Memoization</button>\n        <button id=\"clearFib\">Clear</button>\n      </div>\n\n      <div class=\"row\" style=\"margin-top:8px\">\n        <div class=\"muted\">Result: <span id=\"fibResult\">—</span></div>\n        <div class=\"muted\">Calls: <span id=\"fibCalls\">0</span></div>\n      </div>\n\n      <div class=\"legend\">Legend: node = fib(k) call. Colors indicate active vs returned nodes.</div>\n    </div>\n\n    <div class=\"card vis-panel\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center\">\n        <h2 style=\"margin:0\">Visualizations</h2>\n        <div class=\"small\">Canvas area shows Fibonacci trees and a fractal tree below.</div>\n      </div>\n\n      <div style=\"flex:1;display:flex;flex-direction:column;gap:12px;\">\n        <div style=\"height:320px;\">\n          <canvas id=\"canvasFib\" width=\"1200\" height=\"640\"></canvas>\n        </div>\n\n        <div style=\"height:200px;display:flex;gap:12px;\">\n          <div style=\"flex:1;display:flex;flex-direction:column;\">\n            <label>Fractal Tree Depth</label>\n            <input id=\"frDepth\" type=\"range\" min=\"0\" max=\"12\" value=\"8\" />\n            <div class=\"controls\" style=\"margin-top:6px\">\n              <button id=\"drawFractal\">Draw Fractal Tree</button>\n              <button id=\"clearFractal\">Clear</button>\n            </div>\n          </div>\n          <div style=\"flex:1;position:relative;\">\n            <canvas id=\"canvasFr\" width=\"800\" height=\"480\"></canvas>\n            <div class=\"small\" style=\"position:absolute;left:12px;bottom:12px;color:var(--muted);\">Fractal tree (recursive drawing)</div>\n          </div>\n        </div>\n      </div>\n\n      <footer>\n        Short notes: Recursion is when a function calls itself. Each call gets its own frame on the call stack. Some recursion forms are naturally exponential (naive Fibonacci), others are linear (factorial). Memoization or turning recursion into iteration can improve performance.\n      </footer>\n    </div>\n  </main>\n\n  <script>\n    // Utilities\n    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }\n    function el(id){ return document.getElementById(id); }\n\n    // ---------- Factorial trace with async recursion ----------\n    (function(){\n      const stackDiv = el('factStack');\n      const resultSpan = el('factResult');\n      const callsSpan = el('factCalls');\n      const runBtn = el('runFact');\n      const iterBtn = el('runIter');\n      const clearBtn = el('clearFact');\n      const nInput = el('factN');\n      const speedInput = el('factSpeed');\n\n      let running = false;\n\n      function pushFrame(name, info){\n        const frame = document.createElement('div');\n        frame.className = 'frame';\n        frame.dataset.name = name;\n        frame.innerHTML = `<div><span class=\"name\">${name}</span> <span class=\"muted\">${info||''}</span></div><div class=\"ret\">…</div>`;\n        stackDiv.prepend(frame); // show newest on top as stack\n        return frame;\n      }\n      function markReturn(frame, value){\n        const ret = frame.querySelector('.ret');\n        ret.textContent = value;\n        frame.style.background = 'linear-gradient(180deg, rgba(0,255,170,0.03), rgba(0,255,170,0.02))';\n        frame.style.border = '1px solid rgba(0,255,170,0.08)';\n      }\n\n      async function factAsync(n, speed, state){\n        // state used for counting calls\n        state.calls++;\n        const frame = pushFrame(`fact(${n})`);\n        await sleep(speed);\n        if (n === 0 || n === 1){\n          markReturn(frame, 1);\n          await sleep(speed/2);\n          return 1;\n        } else {\n          const sub = await factAsync(n-1, speed, state);\n          const res = n * sub;\n          markReturn(frame, res);\n          await sleep(speed/2);\n          return res;\n        }\n      }\n\n      async function runRecursive(){\n        if (running) return;\n        running = true;\n        stackDiv.innerHTML = '';\n        resultSpan.textContent = '…';\n        callsSpan.textContent = '0';\n        const n = Math.max(0, Math.min(12, parseInt(nInput.value)||0));\n        const speed = parseInt(speedInput.value)||150;\n        const state = {calls:0};\n        try{\n          const res = await factAsync(n, speed, state);\n          resultSpan.textContent = res;\n          callsSpan.textContent = state.calls;\n        }catch(e){\n          console.error(e);\n        }\n        running = false;\n      }\n\n      function runIterative(){\n        if (running) return;\n        running = true;\n        stackDiv.innerHTML = '';\n        resultSpan.textContent = '…';\n        callsSpan.textContent = '0';\n        const n = Math.max(0, Math.min(1000, parseInt(nInput.value)||0));\n        // iterative fast version\n        let res = 1;\n        for(let i=2;i<=n;i++) res *= i;\n        resultSpan.textContent = res;\n        callsSpan.textContent = '1 (iterative)';\n        // show one frame to illustrate\n        const frame = pushFrame(`fact_iter(${n})`, 'loop');\n        markReturn(frame, res);\n        running = false;\n      }\n\n      runBtn.addEventListener('click', runRecursive);\n      iterBtn.addEventListener('click', runIterative);\n      clearBtn.addEventListener('click', ()=>{\n        if (running) return;\n        stackDiv.innerHTML = '';\n        resultSpan.textContent = '—';\n        callsSpan.textContent = '0';\n      });\n    })();\n\n    // ---------- Fibonacci (naive) tree drawing and memoization ----------\n    (function(){\n      const canvas = el('canvasFib');\n      const ctx = canvas.getContext('2d', {alpha:false});\n      const runNaive = el('runFibNaive');\n      const runMemo = el('runFibMemo');\n      const clearBtn = el('clearFib');\n      const nInput = el('fibN');\n      const speedInput = el('fibSpeed');\n      const resultSpan = el('fibResult');\n      const callsSpan = el('fibCalls');\n\n      // Resize for devicePixelRatio\n      function fixCanvas(c){\n        const dpr = window.devicePixelRatio || 1;\n        const rect = c.getBoundingClientRect();\n        c.width = Math.floor(rect.width * dpr);\n        c.height = Math.floor(rect.height * dpr);\n        c.style.width = rect.width+'px';\n        c.style.height = rect.height+'px';\n        c.getContext('2d').setTransform(dpr,0,0,dpr,0,0);\n      }\n      fixCanvas(canvas);\n      window.addEventListener('resize', ()=>fixCanvas(canvas));\n\n      // Draw utilities\n      function clear(){\n        const w = canvas.width/(window.devicePixelRatio||1);\n        const h = canvas.height/(window.devicePixelRatio||1);\n        ctx.fillStyle = '#02101b';\n        ctx.fillRect(0,0,w,h);\n      }\n      clear();\n\n      // Layout an approximate tree (binary branching)\n      function layoutTreeNodes(n, startX, startY, width, level=0, positions=[], parent=null){\n        // For fib, each node is fib(k). We lay out recursively:\n        const x = startX + width/2;\n        const y = startY + level*70;\n        const id = {k:n, x, y, parent};\n        positions.push(id);\n        if (n <= 1) return positions;\n        // left child fib(n-1), right child fib(n-2)\n        const leftWidth = width * (n-1)/(n+1); // heuristic to spread\n        layoutTreeNodes(n-1, startX, startY, leftWidth, level+1, positions, id);\n        layoutTreeNodes(n-2, startX+leftWidth, startY, width-leftWidth, level+1, positions, id);\n        return positions;\n      }\n\n      function drawNode(node, state){\n        // state: active/returned/visited\n        ctx.beginPath();\n        ctx.arc(node.x, node.y, 18, 0, Math.PI*2);\n        if (state === 'active'){\n          ctx.fillStyle = '#7dd3fc';\n          ctx.strokeStyle = '#0369a1';\n        } else if (state === 'returned'){\n          ctx.fillStyle = '#6ee7b7';\n          ctx.strokeStyle = '#065f46';\n        } else {\n          ctx.fillStyle = '#0b1220';\n          ctx.strokeStyle = '#1f2937';\n        }\n        ctx.fill();\n        ctx.lineWidth = 1;\n        ctx.stroke();\n\n        ctx.fillStyle = '#001728';\n        ctx.font = 'bold 12px ui-sans-serif, system-ui';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText('fib('+node.k+')', node.x, node.y);\n      }\n\n      async function drawNaive(n, speed){\n        clear();\n        resultSpan.textContent = '…';\n        callsSpan.textContent = '0';\n        if (n < 0) return;\n        const rect = canvas.getBoundingClientRect();\n        const width = rect.width - 40;\n        const nodes = layoutTreeNodes(n, 20, 30, width);\n        // draw edges\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = 'rgba(255,255,255,0.03)';\n        for(const node of nodes){\n          if (node.parent){\n            ctx.beginPath();\n            ctx.moveTo(node.x, node.y-18);\n            ctx.lineTo(node.parent.x, node.parent.y+18);\n            ctx.stroke();\n          }\n        }\n\n        // For visualization we will traverse and \"visit\" nodes in recursion order:\n        let calls = 0;\n        async function visit(k, x, y){\n          calls++;\n          callsSpan.textContent = calls;\n          // find node object with these coords (approx)\n          const node = nodes.find(nod => nod.k===k && Math.abs(nod.x-x)<1 && Math.abs(nod.y-y)<1) ||\n                       nodes.find(nod => nod.k===k);\n          drawNode(node, 'active');\n          await sleep(speed);\n          if (k <= 1){\n            drawNode(node, 'returned');\n            await sleep(speed/2);\n            return 1;\n          } else {\n            // find children positions\n            // left is first matching with parent=node and higher level\n            const children = nodes.filter(nod => nod.parent === node);\n            // ensure left then right by k\n            children.sort((a,b)=>b.k - a.k); // bigger k usually left (n-1)\n            const left = children[0], right = children[1];\n            const vl = await visit(k-1, left.x, left.y);\n            const vr = await visit(k-2, right.x, right.y);\n            const res = vl + vr;\n            drawNode(node, 'returned');\n            await sleep(speed/2);\n            return res;\n          }\n        }\n\n        const res = await visit(n, nodes.find(nd=>nd.k===n).x, nodes.find(nd=>nd.k===n).y);\n        resultSpan.textContent = res;\n        callsSpan.textContent = calls;\n      }\n\n      function computeFibMemo(n){\n        const cache = {};\n        let calls = 0;\n        function fib(k){\n          calls++;\n          if (k <= 1) return 1;\n          if (cache[k] !== undefined) return cache[k];\n          cache[k] = fib(k-1) + fib(k-2);\n          return cache[k];\n        }\n        const res = fib(n);\n        return {res, calls};\n      }\n\n      runNaive.addEventListener('click', async ()=>{\n        const n = Math.max(0, Math.min(12, parseInt(nInput.value)||0));\n        const speed = Math.max(10, parseInt(speedInput.value)||120);\n        await drawNaive(n, speed);\n      });\n\n      runMemo.addEventListener('click', ()=>{\n        const n = Math.max(0, Math.min(100, parseInt(nInput.value)||0));\n        const {res, calls} = computeFibMemo(n);\n        resultSpan.textContent = res;\n        callsSpan.textContent = calls + ' (memoized)';\n        // Draw a compact static tree to illustrate structure without many nodes:\n        clear();\n        const rect = canvas.getBoundingClientRect();\n        const width = rect.width - 40;\n        const nodes = layoutTreeNodes(Math.min(n,6), 20, 30, width); // limit depth for drawing\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = 'rgba(255,255,255,0.03)';\n        for(const node of nodes){\n          if (node.parent){\n            ctx.beginPath();\n            ctx.moveTo(node.x, node.y-18);\n            ctx.lineTo(node.parent.x, node.parent.y+18);\n            ctx.stroke();\n          }\n        }\n        for(const node of nodes) drawNode(node, 'returned');\n      });\n\n      clearBtn.addEventListener('click', ()=>{\n        clear();\n        resultSpan.textContent = '—';\n        callsSpan.textContent = '0';\n      });\n\n    })();\n\n    // ---------- Fractal Tree (recursive drawing) ----------\n    (function(){\n      const canvas = el('canvasFr');\n      const ctx = canvas.getContext('2d');\n      const depthInput = el('frDepth');\n      const drawBtn = el('drawFractal');\n      const clearBtn = el('clearFractal');\n\n      function fix(c){\n        const dpr = window.devicePixelRatio || 1;\n        const rect = c.getBoundingClientRect();\n        c.width = Math.floor(rect.width * dpr);\n        c.height = Math.floor(rect.height * dpr);\n        c.style.width = rect.width+'px';\n        c.style.height = rect.height+'px';\n        c.getContext('2d').setTransform(dpr,0,0,dpr,0,0);\n      }\n      fix(canvas);\n      window.addEventListener('resize', ()=>fix(canvas));\n\n      function clear(){\n        const w = canvas.width/(window.devicePixelRatio||1);\n        const h = canvas.height/(window.devicePixelRatio||1);\n        ctx.fillStyle = '#061420';\n        ctx.fillRect(0,0,w,h);\n      }\n      clear();\n\n      function drawTree(x, y, length, angle, depth){\n        // base case\n        if (depth === 0 || length < 2) return;\n        const x2 = x + Math.cos(angle) * length;\n        const y2 = y + Math.sin(angle) * length;\n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.lineTo(x2, y2);\n        // stroke color based on depth\n        const t = depth/12;\n        ctx.strokeStyle = `rgba(${Math.floor(200*t+40)}, ${Math.floor(255*t)}, ${Math.floor(180-120*t)}, 0.95)`;\n        ctx.lineWidth = Math.max(1, depth/2);\n        ctx.stroke();\n\n        // recursive calls: left and right branches\n        drawTree(x2, y2, length * 0.72, angle - 0.45, depth - 1);\n        drawTree(x2, y2, length * 0.72, angle + 0.35, depth - 1);\n\n        // occasional smaller middle branch\n        if (depth % 3 === 0){\n          drawTree(x2, y2, length * 0.5, angle + 0.05, depth - 2);\n        }\n      }\n\n      drawBtn.addEventListener('click', ()=>{\n        const depth = Math.max(0, Math.min(12, parseInt(depthInput.value)||8));\n        clear();\n        const rect = canvas.getBoundingClientRect();\n        const w = rect.width, h = rect.height;\n        drawTree(w/2, h-20, Math.min(w,h)/4, -Math.PI/2, depth);\n      });\n\n      clearBtn.addEventListener('click', clear);\n    })();\n\n    // Initial small draws\n    (function init(){\n      // draw empty canvas patterns\n      const canv = document.querySelectorAll('canvas');\n      canv.forEach(c=>{\n        const ctx = c.getContext('2d');\n        ctx.fillStyle = '#02101b';\n        ctx.fillRect(0,0,c.width/(window.devicePixelRatio||1), c.height/(window.devicePixelRatio||1));\n      });\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Recursion"
    }
  ],
  "topic": "Recursion",
  "hasFSM": false,
  "hasTest": true
}