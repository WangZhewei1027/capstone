{
  "id": "2bde1c71-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:17:02.651Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Red-Black Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Red-Black Tree Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 0; display: flex; height: 100vh; }\n    #left { width: 360px; padding: 16px; box-sizing: border-box; border-right: 1px solid #ddd; overflow:auto; }\n    #right { flex:1; position: relative; display:flex; flex-direction:column; }\n    h1 { font-size:18px; margin:4px 0 12px 0; }\n    .controls { display:flex; gap:8px; margin-bottom:8px; flex-wrap:wrap; }\n    input[type=\"number\"], input[type=\"text\"] { padding:6px; border-radius:4px; border:1px solid #ccc; width:120px; }\n    button { padding:6px 10px; border-radius:4px; border:1px solid #888; background:#f7f7f7; cursor:pointer; }\n    button:active { transform: translateY(1px); }\n    #svgWrap { flex:1; overflow:auto; background: linear-gradient(#fff,#fafafa); }\n    svg { width:100%; height:100%; }\n    #log { height:180px; border-top:1px solid #eee; padding-top:8px; margin-top:8px; overflow:auto; font-size:13px; background:#fff; }\n    .step-controls { display:flex; gap:8px; align-items:center; margin-top:8px; }\n    .small { font-size:12px; padding:4px 6px; }\n    #status { margin-top:10px; font-size:13px; color:#333; }\n    .muted { color:#666; font-size:13px; }\n    label { font-size:13px; }\n    .info { font-size:13px; margin-top:8px; color:#222; }\n    .legend { display:flex; gap:10px; margin-top:10px; align-items:center }\n    .legend .item { display:flex; align-items:center; gap:6px; font-size:13px; }\n    .dot { width:18px; height:18px; border-radius:50%; display:inline-block; border:1px solid #444; }\n    .redDot{ background:red; }\n    .blackDot{ background:#111; }\n    .nilDot{ width:16px; height:16px; background:#ccc; border-radius:3px; display:inline-block; border:1px solid #bbb; }\n    .log-line { padding:6px 4px; border-bottom:1px dashed #f0f0f0; font-family: monospace; white-space:pre-wrap; }\n    #footer { font-size:12px; color:#666; margin-top:12px; }\n    @media (max-width:800px){ #left{ width:100%; max-height:38vh; border-right:none; border-bottom:1px solid #eee; } body{ flex-direction:column; } }\n  </style>\n</head>\n<body>\n  <div id=\"left\">\n    <h1>Red-Black Tree Visualizer</h1>\n    <div class=\"controls\">\n      <input id=\"valueInput\" type=\"number\" placeholder=\"Value (int)\" />\n      <button id=\"insertBtn\">Insert</button>\n      <button id=\"deleteBtn\">Delete</button>\n      <button id=\"searchBtn\">Search</button>\n    </div>\n\n    <div class=\"controls\">\n      <button id=\"randomBtn\">Add 7 Random</button>\n      <button id=\"clearBtn\">Clear</button>\n      <button id=\"sampleBtn\">Load Sample</button>\n    </div>\n\n    <div class=\"step-controls\">\n      <button id=\"prevStep\" class=\"small\">◀ Prev</button>\n      <button id=\"playPause\" class=\"small\">Play ▶</button>\n      <button id=\"nextStep\" class=\"small\">Next ▶</button>\n      <label class=\"muted\" style=\"margin-left:8px\">Speed</label>\n      <input id=\"speed\" type=\"range\" min=\"200\" max=\"1600\" step=\"100\" value=\"800\" />\n      <span id=\"stepIndex\" class=\"muted\">Step 0 / 0</span>\n    </div>\n\n    <div class=\"info\">\n      <div class=\"legend\">\n        <div class=\"item\"><span class=\"dot redDot\"></span> red</div>\n        <div class=\"item\"><span class=\"dot blackDot\"></span> black</div>\n        <div class=\"item\"><span class=\"nilDot\"></span> nil (not shown)</div>\n      </div>\n      <div id=\"status\" class=\"muted\">Tree size: 0 • Black-height: 0</div>\n    </div>\n\n    <div id=\"log\"></div>\n\n    <div id=\"footer\">\n      How to use: Insert integers. Click Play to auto-step through algorithm snapshots. Steps capture important color changes and rotations during insert (and search). This visualizer uses a sentinel nil (not drawn by default). Deletion is provided but more complex cases may produce many steps.\n    </div>\n  </div>\n\n  <div id=\"right\">\n    <div id=\"svgWrap\">\n      <svg id=\"svg\"></svg>\n    </div>\n  </div>\n\n<script>\n/*\n Red-Black Tree Visualizer (single-file)\n - Implements RB-Tree insertion, deletion, search with step-by-step snapshots.\n - Uses a sentinel NIL node internally (not drawn by default).\n - Snapshots capture the whole tree (values, colors, ids) and a message and highlighted node IDs.\n - Visualization draws tree using an inorder layout.\n*/\n\n// ---------- Data structures ----------\nlet globalId = 1;\n\nclass Node {\n  constructor(val) {\n    this.id = globalId++;\n    this.val = val;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n    this.color = 'R'; // 'R' or 'B'\n  }\n}\n\nclass RBTree {\n  constructor() {\n    this.NIL = new Node(null);\n    this.NIL.color = 'B';\n    this.NIL.left = this.NIL.right = this.NIL.parent = null;\n    this.root = this.NIL;\n    this.size = 0;\n  }\n\n  // Standard BST insert (without fixup)\n  bstInsert(z) {\n    let y = null;\n    let x = this.root;\n    while (x !== this.NIL) {\n      y = x;\n      if (z.val < x.val) x = x.left;\n      else x = x.right;\n    }\n    z.parent = y;\n    if (y === null) {\n      this.root = z;\n    } else if (z.val < y.val) {\n      y.left = z;\n    } else {\n      y.right = z;\n    }\n    z.left = this.NIL;\n    z.right = this.NIL;\n  }\n\n  // left rotate around x\n  leftRotate(x) {\n    const y = x.right;\n    x.right = y.left;\n    if (y.left !== this.NIL) y.left.parent = x;\n    y.parent = x.parent;\n    if (!x.parent) {\n      this.root = y;\n    } else if (x === x.parent.left) {\n      x.parent.left = y;\n    } else {\n      x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n  }\n\n  // right rotate around x\n  rightRotate(x) {\n    const y = x.left;\n    x.left = y.right;\n    if (y.right !== this.NIL) y.right.parent = x;\n    y.parent = x.parent;\n    if (!x.parent) {\n      this.root = y;\n    } else if (x === x.parent.right) {\n      x.parent.right = y;\n    } else {\n      x.parent.left = y;\n    }\n    y.right = x;\n    x.parent = y;\n  }\n\n  // insert with fixup, but we will record snapshots externally via callbacks\n  insert(val, snapshotCallback) {\n    const z = new Node(val);\n    // place temporarily; we'll mark left/right to NIL\n    this.bstInsert(z);\n    z.color = 'R';\n    this.size++;\n    if (snapshotCallback) snapshotCallback(`Inserted ${val} as red node (initial)`, [z.id]);\n\n    // fixup\n    while (z.parent && z.parent.color === 'R') {\n      const p = z.parent;\n      const g = p.parent;\n      if (!g) break; // should not happen normally\n      if (p === g.left) {\n        let y = g.right;\n        if (y && y.color === 'R') {\n          // case 1: uncle red — recolor\n          p.color = 'B';\n          y.color = 'B';\n          g.color = 'R';\n          if (snapshotCallback) snapshotCallback(`Recolor: parent ${p.val} -> B, uncle ${y.val} -> B, grandparent ${g.val} -> R`, [p.id, y.id, g.id]);\n          z = g;\n        } else {\n          if (z === p.right) {\n            // case 2\n            z = p;\n            if (snapshotCallback) snapshotCallback(`Prepare for left-rotate at ${z.val} (Case 2)`, [z.id]);\n            this.leftRotate(z);\n            if (snapshotCallback) snapshotCallback(`Left-rotate at ${z.val}`, [z.id]);\n          }\n          // case 3\n          p.color = 'B';\n          g.color = 'R';\n          if (snapshotCallback) snapshotCallback(`Case 3: recolor parent ${p.val}->B and grandparent ${g.val}->R, right-rotate at ${g.val}`, [p.id, g.id]);\n          this.rightRotate(g);\n          if (snapshotCallback) snapshotCallback(`Right-rotate at ${g.val}`, [g.id]);\n        }\n      } else {\n        // mirror\n        let y = g.left;\n        if (y && y.color === 'R') {\n          p.color = 'B';\n          y.color = 'B';\n          g.color = 'R';\n          if (snapshotCallback) snapshotCallback(`Recolor: parent ${p.val} -> B, uncle ${y.val} -> B, grandparent ${g.val} -> R`, [p.id, y.id, g.id]);\n          z = g;\n        } else {\n          if (z === p.left) {\n            z = p;\n            if (snapshotCallback) snapshotCallback(`Prepare for right-rotate at ${z.val} (Case 2 mirror)`, [z.id]);\n            this.rightRotate(z);\n            if (snapshotCallback) snapshotCallback(`Right-rotate at ${z.val}`, [z.id]);\n          }\n          p.color = 'B';\n          g.color = 'R';\n          if (snapshotCallback) snapshotCallback(`Case 3 mirror: recolor parent ${p.val}->B and grandparent ${g.val}->R, left-rotate at ${g.val}`, [p.id, g.id]);\n          this.leftRotate(g);\n          if (snapshotCallback) snapshotCallback(`Left-rotate at ${g.val}`, [g.id]);\n        }\n      }\n    }\n    this.root.color = 'B';\n    if (snapshotCallback) snapshotCallback(`Ensure root ${this.root.val} is black`, [this.root.id]);\n  }\n\n  // transplant u with v\n  transplant(u, v) {\n    if (!u.parent) {\n      this.root = v;\n    } else if (u === u.parent.left) {\n      u.parent.left = v;\n    } else {\n      u.parent.right = v;\n    }\n    if (v !== this.NIL) v.parent = u.parent;\n  }\n\n  minimum(x) {\n    while (x.left !== this.NIL) x = x.left;\n    return x;\n  }\n\n  // delete z (node instance) with fixup; snapshotCallback called for important events\n  deleteVal(val, snapshotCallback) {\n    // find node with value\n    let z = this.root;\n    while (z !== this.NIL && z.val !== val) {\n      if (val < z.val) z = z.left; else z = z.right;\n    }\n    if (z === this.NIL) {\n      if (snapshotCallback) snapshotCallback(`Value ${val} not found`, []);\n      return false;\n    }\n    if (snapshotCallback) snapshotCallback(`Deleting node ${val}`, [z.id]);\n    let y = z;\n    let yOriginalColor = y.color;\n    let x;\n    if (z.left === this.NIL) {\n      x = z.right;\n      this.transplant(z, z.right);\n    } else if (z.right === this.NIL) {\n      x = z.left;\n      this.transplant(z, z.left);\n    } else {\n      y = this.minimum(z.right);\n      yOriginalColor = y.color;\n      x = y.right;\n      if (y.parent === z) {\n        if (x !== this.NIL) x.parent = y;\n      } else {\n        this.transplant(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.transplant(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n      y.color = z.color;\n    }\n    this.size--;\n    if (snapshotCallback) snapshotCallback(`Node removed physically; fixup if needed (deleted color: ${yOriginalColor})`, [ (x && x.id) || (y && y.id) ]);\n    if (yOriginalColor === 'B') {\n      this.deleteFixup(x, snapshotCallback);\n    } else {\n      if (snapshotCallback) snapshotCallback(`No fixup needed (deleted node was red)`, []);\n    }\n    return true;\n  }\n\n  deleteFixup(x, snapshotCallback) {\n    // x may be NIL sentinel\n    while (x !== this.root && (x === this.NIL || x.color === 'B')) {\n      if (x === x.parent.left) {\n        let w = x.parent.right;\n        if (w.color === 'R') {\n          w.color = 'B';\n          x.parent.color = 'R';\n          if (snapshotCallback) snapshotCallback(`DeleteFixup: sibling ${w.val} is red: recolor and left-rotate at ${x.parent.val}`, [w.id, x.parent.id]);\n          this.leftRotate(x.parent);\n        } \n        w = x.parent.right;\n        if ((w.left === this.NIL || w.left.color === 'B') && (w.right === this.NIL || w.right.color === 'B')) {\n          w.color = 'R';\n          x = x.parent;\n          if (snapshotCallback) snapshotCallback(`DeleteFixup case: sibling ${w.val} both children black -> recolor sibling red, move up`, [w.id, x.id]);\n        } else {\n          if (w.right === this.NIL || w.right.color === 'B') {\n            if (w.left !== this.NIL) w.left.color = 'B';\n            w.color = 'R';\n            if (snapshotCallback) snapshotCallback(`DeleteFixup: sibling ${w.val} right black, left red -> right-rotate at ${w.val}`, [w.id]);\n            this.rightRotate(w);\n            w = x.parent.right;\n          }\n          w.color = x.parent.color;\n          x.parent.color = 'B';\n          if (w.right !== this.NIL) w.right.color = 'B';\n          if (snapshotCallback) snapshotCallback(`DeleteFixup final: recolor and left-rotate at ${x.parent.val}`, [w.id, x.parent.id]);\n          this.leftRotate(x.parent);\n          x = this.root;\n        }\n      } else {\n        // mirror\n        let w = x.parent.left;\n        if (w.color === 'R') {\n          w.color = 'B';\n          x.parent.color = 'R';\n          if (snapshotCallback) snapshotCallback(`DeleteFixup mirror: sibling ${w.val} is red: recolor and right-rotate at ${x.parent.val}`, [w.id, x.parent.id]);\n          this.rightRotate(x.parent);\n        }\n        w = x.parent.left;\n        if ((w.right === this.NIL || w.right.color === 'B') && (w.left === this.NIL || w.left.color === 'B')) {\n          w.color = 'R';\n          x = x.parent;\n          if (snapshotCallback) snapshotCallback(`DeleteFixup mirror case: sibling ${w.val} both children black -> recolor sibling red, move up`, [w.id, x.id]);\n        } else {\n          if (w.left === this.NIL || w.left.color === 'B') {\n            if (w.right !== this.NIL) w.right.color = 'B';\n            w.color = 'R';\n            if (snapshotCallback) snapshotCallback(`DeleteFixup mirror: sibling ${w.val} left black, right red -> left-rotate at ${w.val}`, [w.id]);\n            this.leftRotate(w);\n            w = x.parent.left;\n          }\n          w.color = x.parent.color;\n          x.parent.color = 'B';\n          if (w.left !== this.NIL) w.left.color = 'B';\n          if (snapshotCallback) snapshotCallback(`DeleteFixup mirror final: recolor and right-rotate at ${x.parent.val}`, [w.id, x.parent.id]);\n          this.rightRotate(x.parent);\n          x = this.root;\n        }\n      }\n    }\n    if (x !== this.NIL) x.color = 'B';\n    if (snapshotCallback) snapshotCallback(`Finish delete fixup; ensure node ${x !== this.NIL ? x.val : 'NIL'} is black`, [ x !== this.NIL ? x.id : null ]);\n  }\n\n  // search for value, returns path of nodes visited for visualization\n  searchPath(val) {\n    let path = [];\n    let x = this.root;\n    while (x !== this.NIL) {\n      path.push(x);\n      if (val === x.val) break;\n      if (val < x.val) x = x.left; else x = x.right;\n    }\n    return path;\n  }\n\n  // compute black-height from root (number of black nodes from root to any leaf)\n  blackHeight() {\n    let x = this.root;\n    if (x === this.NIL) return 0;\n    let bh = 0;\n    // descend to leftmost leaf counting black nodes excluding NIL sentinel at bottom\n    while (x !== this.NIL) {\n      if (x.color === 'B') bh++;\n      x = x.left;\n    }\n    return bh;\n  }\n\n  // clone structure into plain objects for snapshots\n  clonePlain() {\n    // Convert nodes to plain objects preserving id and color\n    const rec = (n) => {\n      if (!n || n === this.NIL) return null;\n      return {\n        id: n.id,\n        val: n.val,\n        color: n.color,\n        left: rec(n.left),\n        right: rec(n.right)\n      };\n    };\n    return rec(this.root);\n  }\n}\n\n// ---------- Visualization & Snapshot Control ----------\nconst tree = new RBTree();\nlet snapshots = []; // array of {rootPlain, msg, highlights}\nlet stepIndex = -1;\nlet playing = false;\nlet playTimer = null;\n\n// utility to push snapshot capturing current tree\nfunction pushSnapshot(msg, highlightIds=[]) {\n  snapshots.push({ root: tree.clonePlain(), msg: msg, highlights: highlightIds.slice() });\n}\n\n// Clear snapshots and push initial state\nfunction resetSnapshots(initialMsg) {\n  snapshots = [];\n  stepIndex = -1;\n  pushSnapshot(initialMsg || 'Initial state', []);\n  stepIndex = 0;\n  renderCurrent();\n}\n\n// Render functions (SVG)\nconst svg = document.getElementById('svg');\nconst svgNS = \"http://www.w3.org/2000/svg\";\n\nfunction clearSVG() {\n  while (svg.firstChild) svg.removeChild(svg.firstChild);\n}\n\nfunction renderSnapshot(snapshot) {\n  clearSVG();\n  const root = snapshot.root;\n  // compute layout: inorder assigns x positions, depth => y\n  const positions = new Map();\n  let counter = 0;\n  const radius = 20;\n  const hGap = 28;\n  const vGap = 84;\n\n  function inorder(n, depth) {\n    if (!n) return;\n    inorder(n.left, depth+1);\n    const x = ++counter;\n    positions.set(n.id, { x, depth, node: n });\n    inorder(n.right, depth+1);\n  }\n  if (root) inorder(root, 0);\n  if (counter === 0) {\n    // empty tree, show message text\n    const txt = document.createElementNS(svgNS, 'text');\n    txt.setAttribute('x', 20);\n    txt.setAttribute('y', 30);\n    txt.textContent = '(empty tree)';\n    txt.setAttribute('fill', '#666');\n    svg.appendChild(txt);\n    return;\n  }\n\n  // compute scale to fit width\n  const width = Math.max(svg.clientWidth, window.innerWidth - 400);\n  const leftPadding = 20;\n  const rightPadding = 20;\n  const usableWidth = Math.max(300, width - leftPadding - rightPadding);\n  // map x index to pixel x coordinate\n  const totalColumns = counter;\n  const colWidth = Math.max(40, (usableWidth - (totalColumns-1)*hGap) / totalColumns);\n  // compute positions in pixels\n  const pixel = new Map();\n  positions.forEach((v, id) => {\n    const px = leftPadding + (v.x - 1) * (colWidth + hGap) + colWidth/2;\n    const py = 30 + v.depth * vGap;\n    pixel.set(id, { px, py, node: v.node });\n  });\n\n  // draw edges (lines) first\n  // traverse again building lines between parent and child\n  function drawEdges(n) {\n    if (!n) return;\n    const ppos = pixel.get(n.id);\n    if (n.left) {\n      const child = pixel.get(n.left.id);\n      if (child) drawLine(ppos.px, ppos.py, child.px, child.py);\n    }\n    if (n.right) {\n      const child = pixel.get(n.right.id);\n      if (child) drawLine(ppos.px, ppos.py, child.px, child.py);\n    }\n    if (n.left) drawEdges(n.left);\n    if (n.right) drawEdges(n.right);\n  }\n\n  function drawLine(x1,y1,x2,y2) {\n    const line = document.createElementNS(svgNS, 'line');\n    const angle = Math.atan2(y2-y1, x2-x1);\n    const offsetX1 = Math.cos(angle) * radius;\n    const offsetY1 = Math.sin(angle) * radius;\n    const offsetX2 = Math.cos(angle) * radius;\n    const offsetY2 = Math.sin(angle) * radius;\n    line.setAttribute('x1', x1 + offsetX1);\n    line.setAttribute('y1', y1 + offsetY1);\n    line.setAttribute('x2', x2 - offsetX2);\n    line.setAttribute('y2', y2 - offsetY2);\n    line.setAttribute('stroke', '#777');\n    line.setAttribute('stroke-width', '2');\n    svg.appendChild(line);\n  }\n\n  drawEdges(root);\n\n  // draw nodes\n  const highlights = new Set(snapshot.highlights || []);\n  function drawNode(n) {\n    if (!n) return;\n    const pos = pixel.get(n.id);\n    if (!pos) return;\n    const g = document.createElementNS(svgNS, 'g');\n    g.setAttribute('transform', `translate(${pos.px},${pos.py})`);\n    const circle = document.createElementNS(svgNS, 'circle');\n    circle.setAttribute('r', radius);\n    circle.setAttribute('stroke', highlights.has(n.id) ? '#ff9800' : '#333');\n    circle.setAttribute('stroke-width', highlights.has(n.id) ? '4' : '2');\n    if (n.color === 'R') {\n      circle.setAttribute('fill', '#d93c3c');\n      circle.setAttribute('stroke', highlights.has(n.id) ? '#ffb380' : '#7a1e1e');\n    } else {\n      circle.setAttribute('fill', '#111');\n      circle.setAttribute('stroke', highlights.has(n.id) ? '#ffd580' : '#222');\n    }\n    // label\n    const txt = document.createElementNS(svgNS, 'text');\n    txt.setAttribute('text-anchor', 'middle');\n    txt.setAttribute('alignment-baseline', 'middle');\n    txt.setAttribute('fill', n.color === 'B' ? '#fff' : '#fff');\n    txt.setAttribute('font-size', '12px');\n    txt.setAttribute('font-family', 'monospace');\n    txt.textContent = String(n.val);\n    g.appendChild(circle);\n    g.appendChild(txt);\n    // small color letter\n    const lab = document.createElementNS(svgNS, 'text');\n    lab.setAttribute('x', radius + 12);\n    lab.setAttribute('y', -radius + 10);\n    lab.setAttribute('fill', '#666');\n    lab.setAttribute('font-size', '11px');\n    lab.textContent = n.color === 'R' ? 'R' : 'B';\n    g.appendChild(lab);\n    svg.appendChild(g);\n    drawNode(n.left);\n    drawNode(n.right);\n  }\n\n  drawNode(root);\n\n  // display message text at top-left\n  const msg = document.createElementNS(svgNS, 'text');\n  msg.setAttribute('x', 14);\n  msg.setAttribute('y', 14);\n  msg.setAttribute('fill', '#333');\n  msg.setAttribute('font-size', '13');\n  msg.textContent = snapshot.msg;\n  svg.appendChild(msg);\n}\n\n// ---------- UI & Control Handlers ----------\nconst valueInput = document.getElementById('valueInput');\nconst insertBtn = document.getElementById('insertBtn');\nconst deleteBtn = document.getElementById('deleteBtn');\nconst searchBtn = document.getElementById('searchBtn');\nconst randomBtn = document.getElementById('randomBtn');\nconst clearBtn = document.getElementById('clearBtn');\nconst sampleBtn = document.getElementById('sampleBtn');\n\nconst prevStepBtn = document.getElementById('prevStep');\nconst nextStepBtn = document.getElementById('nextStep');\nconst playPauseBtn = document.getElementById('playPause');\nconst speedInput = document.getElementById('speed');\nconst stepIndexLabel = document.getElementById('stepIndex');\nconst logDiv = document.getElementById('log');\nconst statusDiv = document.getElementById('status');\n\nfunction appendLogLine(text) {\n  const d = document.createElement('div');\n  d.className = 'log-line';\n  d.textContent = text;\n  logDiv.appendChild(d);\n  logDiv.scrollTop = logDiv.scrollHeight;\n}\n\nfunction rebuildStatus() {\n  statusDiv.textContent = `Tree size: ${tree.size} • Black-height: ${tree.blackHeight()}`;\n}\n\nfunction renderCurrent() {\n  if (snapshots.length === 0) {\n    resetSnapshots('Empty snapshot');\n    return;\n  }\n  if (stepIndex < 0) stepIndex = 0;\n  if (stepIndex >= snapshots.length) stepIndex = snapshots.length - 1;\n  const s = snapshots[stepIndex];\n  renderSnapshot(s);\n  // update log and step label\n  stepIndexLabel.textContent = `Step ${stepIndex+1} / ${snapshots.length}`;\n  // refresh log highlighting\n  // We'll show the entire snapshot sequence as lines with the current one highlighted\n  logDiv.innerHTML = '';\n  snapshots.forEach((snap, i) => {\n    const el = document.createElement('div');\n    el.className = 'log-line';\n    if (i === stepIndex) el.style.background = '#fff8e6';\n    el.textContent = `${i+1}. ${snap.msg}`;\n    logDiv.appendChild(el);\n  });\n  logDiv.scrollTop = Math.max(0, stepIndex*24 - 40);\n  rebuildStatus();\n}\n\nfunction stepNext() {\n  if (stepIndex < snapshots.length - 1) {\n    stepIndex++;\n    renderCurrent();\n  } else {\n    // pause if at end\n    playing = false;\n    playPauseBtn.textContent = 'Play ▶';\n    stopAutoPlay();\n  }\n}\nfunction stepPrev() {\n  if (stepIndex > 0) {\n    stepIndex--;\n    renderCurrent();\n  }\n}\n\nfunction startAutoPlay() {\n  if (playing) return;\n  playing = true;\n  playPauseBtn.textContent = 'Pause ▮▮';\n  const delay = parseInt(speedInput.value, 10);\n  playTimer = setInterval(() => {\n    if (stepIndex < snapshots.length - 1) {\n      stepNext();\n    } else {\n      stopAutoPlay();\n    }\n  }, delay);\n}\n\nfunction stopAutoPlay() {\n  playing = false;\n  playPauseBtn.textContent = 'Play ▶';\n  if (playTimer) { clearInterval(playTimer); playTimer = null; }\n}\n\nplayPauseBtn.addEventListener('click', () => {\n  if (playing) stopAutoPlay(); else startAutoPlay();\n});\nnextStepBtn.addEventListener('click', () => { stopAutoPlay(); stepNext(); });\nprevStepBtn.addEventListener('click', () => { stopAutoPlay(); stepPrev(); });\nspeedInput.addEventListener('input', () => {\n  if (playing) {\n    stopAutoPlay();\n    startAutoPlay();\n  }\n});\n\ninsertBtn.addEventListener('click', () => {\n  const v = Number(valueInput.value);\n  if (!Number.isFinite(v)) { alert('Enter a numeric value'); return; }\n  // Build snapshots for this insertion\n  const baseIndex = snapshots.length;\n  // Temporary callback to push snapshots per event with a clone of tree at that moment\n  const cb = (msg, highlightIds=[]) => {\n    pushSnapshot(msg, highlightIds);\n  };\n  tree.insert(v, cb);\n  // ensure a final summary state\n  pushSnapshot(`Final state after inserting ${v}`, []);\n  // move to first new snapshot\n  stepIndex = baseIndex;\n  renderCurrent();\n});\n\ndeleteBtn.addEventListener('click', () => {\n  const v = Number(valueInput.value);\n  if (!Number.isFinite(v)) { alert('Enter a numeric value'); return; }\n  const baseIndex = snapshots.length;\n  const cb = (msg, highlightIds=[]) => {\n    pushSnapshot(msg, highlightIds.filter(x=>x!=null));\n  };\n  const ok = tree.deleteVal(v, cb);\n  if (ok) pushSnapshot(`Final state after deleting ${v}`, []);\n  stepIndex = baseIndex;\n  renderCurrent();\n});\n\nsearchBtn.addEventListener('click', () => {\n  const v = Number(valueInput.value);\n  if (!Number.isFinite(v)) { alert('Enter a numeric value'); return; }\n  const baseIndex = snapshots.length;\n  // push snapshots for each visited node\n  const path = tree.searchPath(v);\n  if (path.length === 0) {\n    pushSnapshot(`Search: tree empty`, []);\n  } else {\n    path.forEach((node, idx) => {\n      pushSnapshot(`Search: visited ${node.val}`, [node.id]);\n    });\n    const found = path.length && path[path.length-1].val === v;\n    pushSnapshot(found ? `Search finished: found ${v}` : `Search finished: ${v} not found`);\n  }\n  stepIndex = baseIndex;\n  renderCurrent();\n});\n\nrandomBtn.addEventListener('click', () => {\n  // insert 7 random unique ints between 1 and 99\n  const set = new Set();\n  while (set.size < 7) set.add(Math.floor(Math.random()*99)+1);\n  const arr = Array.from(set);\n  const baseIndex = snapshots.length;\n  arr.forEach((v, i) => {\n    pushSnapshot(`About to insert ${v}`, []);\n    tree.insert(v, (msg, highlights)=> pushSnapshot(msg, highlights));\n  });\n  pushSnapshot(`Final state after adding ${arr.join(', ')}`, []);\n  stepIndex = baseIndex;\n  renderCurrent();\n});\n\nclearBtn.addEventListener('click', () => {\n  // reset the tree (new instance), reset snapshots\n  globalId = 1;\n  while (svg.firstChild) svg.removeChild(svg.firstChild);\n  tree.root = tree.NIL = (new RBTree()).NIL; // reuse tree object but empty\n  tree.size = 0;\n  resetSnapshots('Cleared tree');\n});\n\nsampleBtn.addEventListener('click', () => {\n  // load a common sample to demonstrate rotations\n  const sample = [11,2,14,1,7,15,5,8,4];\n  const baseIndex = snapshots.length;\n  sample.forEach(v => {\n    pushSnapshot(`About to insert ${v}`, []);\n    tree.insert(v, (msg, highlights) => pushSnapshot(msg, highlights));\n  });\n  pushSnapshot(`Inserted sample sequence: ${sample.join(', ')}`, []);\n  stepIndex = baseIndex;\n  renderCurrent();\n});\n\n// init\nresetSnapshots('Empty tree');\nrebuildStatus();\n\n// handle window resizing to re-render\nwindow.addEventListener('resize', renderCurrent);\n\n// provide an initial sample to explore\nconst startup = [10, 20, 30];\nstartup.forEach(v => {\n  tree.insert(v, (msg, h)=> pushSnapshot(msg, h));\n});\npushSnapshot('Initial sample inserted (10,20,30)', []);\nstepIndex = 0;\nrenderCurrent();\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Red-Black Tree"
    }
  ],
  "topic": "Red-Black Tree",
  "hasFSM": false,
  "hasTest": true
}