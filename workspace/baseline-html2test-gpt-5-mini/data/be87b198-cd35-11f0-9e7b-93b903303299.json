{
  "id": "be87b198-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:39.620Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Knapsack Problem",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\"/>\n  <title>Knapsack Problem Demo (0/1, Fractional, Brute-force)</title>\n  <style>\n    body { font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; margin: 20px; color: #111;}\n    h1 { margin: 0 0 8px 0; font-size: 20px;}\n    p.lead { margin: 0 0 16px 0; color: #444; }\n    .container { display: grid; grid-template-columns: 360px 1fr; gap: 18px; }\n    .panel { border: 1px solid #ddd; padding: 12px; border-radius: 8px; background: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.03);}\n    label { display:block; font-size: 13px; margin-top:8px; color:#333; }\n    input[type=\"number\"], input[type=\"text\"] { width: calc(100% - 10px); padding:6px; margin-top:6px; box-sizing:border-box; }\n    button { margin-top:10px; padding:8px 10px; border-radius:6px; border:1px solid #2b7; background:linear-gradient(#3c9,#2b8); color:#fff; cursor:pointer;}\n    button.secondary { background: #f5f5f5; color:#222; border:1px solid #ccc; }\n    table { width:100%; border-collapse: collapse; margin-top:8px; font-size:13px; }\n    th, td { padding:6px 8px; border-bottom:1px solid #eee; text-align:left; }\n    .controls-row { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }\n    .small { font-size:12px; padding:6px 8px; border-radius:6px; }\n    .result { margin-top:12px; padding:10px; background:#fbfbff; border:1px solid #e6e6ff; border-radius:6px; }\n    .bar-row { display:flex; gap:6px; align-items:flex-end; margin-top:8px; }\n    .bar { width:40px; background: linear-gradient(#59f,#37c); color:#fff; text-align:center; font-size:11px; border-radius:4px 4px 0 0; padding-top:4px; box-sizing:border-box;}\n    .bar .label { transform: translateY(4px); display:block; padding:4px 2px; font-size:11px; }\n    .fraction { background: linear-gradient(#ffd27f,#ffb347); color:#111; }\n    .warn { color:#a33; font-size:13px; margin-top:8px;}\n    .algo-list { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }\n    .dp-table { overflow:auto; max-height:260px; border:1px solid #eee; margin-top:8px; }\n    .dp-table table { border-collapse:collapse; width:100%; font-size:12px; }\n    .dp-table th, .dp-table td { border:1px solid #f0f0f0; padding:4px 6px; text-align:center; }\n    footer { margin-top:14px; font-size:12px; color:#666; }\n  </style>\n</head>\n<body>\n  <h1>Knapsack Problem Demo</h1>\n  <p class=\"lead\">Interactive playground for 0/1 Knapsack (dynamic programming), Fractional (greedy), and brute-force. Add items, pick a capacity, and compare results.</p>\n\n  <div class=\"container\">\n    <div class=\"panel\">\n      <label>New item name</label>\n      <input id=\"itemName\" type=\"text\" placeholder=\"Item A\">\n      <label>Value (benefit)</label>\n      <input id=\"itemValue\" type=\"number\" min=\"0\" value=\"10\">\n      <label>Weight (cost)</label>\n      <input id=\"itemWeight\" type=\"number\" min=\"1\" value=\"5\">\n      <div class=\"controls-row\">\n        <button id=\"addItem\">Add item</button>\n        <button id=\"randomItems\" class=\"secondary small\">Generate random 6</button>\n        <button id=\"clearItems\" class=\"secondary small\">Clear items</button>\n      </div>\n\n      <label style=\"margin-top:12px\">Capacity (max weight)</label>\n      <input id=\"capacity\" type=\"number\" min=\"0\" value=\"20\">\n\n      <div class=\"algo-list\">\n        <button id=\"runDP\" class=\"small\">Run 0/1 DP</button>\n        <button id=\"runFractional\" class=\"small\">Run Fractional (Greedy)</button>\n        <button id=\"runBrute\" class=\"small\">Run Brute-force</button>\n      </div>\n\n      <div id=\"warnings\" class=\"warn\" aria-live=\"polite\"></div>\n\n      <div style=\"margin-top:12px;\">\n        <strong>Items</strong>\n        <table id=\"itemsTable\" aria-live=\"polite\">\n          <thead>\n            <tr><th>#</th><th>Name</th><th>Value</th><th>Weight</th><th></th></tr>\n          </thead>\n          <tbody></tbody>\n        </table>\n      </div>\n\n      <footer>\n        Tips: 0/1 DP gives exact integer solutions for 0/1 knapsack. Fractional allows splitting items (faster). Brute-force is exact but exponential; disabled for >20 items.\n      </footer>\n    </div>\n\n    <div class=\"panel\">\n      <div style=\"display:flex; justify-content:space-between; align-items:center;\">\n        <div><strong>Solution</strong></div>\n        <div id=\"runtime\" style=\"color:#666; font-size:13px;\"></div>\n      </div>\n\n      <div id=\"resultArea\" class=\"result\">\n        No solution computed yet. Add items and choose an algorithm.\n      </div>\n\n      <div id=\"visual\" style=\"margin-top:12px;\"></div>\n\n      <div id=\"dpViz\" class=\"dp-table\" style=\"display:none;\"></div>\n    </div>\n  </div>\n\n<script>\n(() => {\n  // State\n  let items = [];\n  let idCounter = 1;\n\n  // DOM refs\n  const itemName = document.getElementById('itemName');\n  const itemValue = document.getElementById('itemValue');\n  const itemWeight = document.getElementById('itemWeight');\n  const addItemBtn = document.getElementById('addItem');\n  const itemsTableBody = document.querySelector('#itemsTable tbody');\n  const capacityInput = document.getElementById('capacity');\n  const runDPBtn = document.getElementById('runDP');\n  const runFractionalBtn = document.getElementById('runFractional');\n  const runBruteBtn = document.getElementById('runBrute');\n  const randomBtn = document.getElementById('randomItems');\n  const clearBtn = document.getElementById('clearItems');\n  const warnings = document.getElementById('warnings');\n  const resultArea = document.getElementById('resultArea');\n  const visual = document.getElementById('visual');\n  const dpViz = document.getElementById('dpViz');\n  const runtimeEl = document.getElementById('runtime');\n\n  // Helpers\n  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }\n\n  function renderItems(){\n    itemsTableBody.innerHTML = '';\n    items.forEach((it, idx) => {\n      const tr = document.createElement('tr');\n      tr.innerHTML = `<td>${idx+1}</td><td>${escapeHtml(it.name)}</td><td>${it.value}</td><td>${it.weight}</td><td><button data-id=\"${it.id}\" class=\"delBtn\">Del</button></td>`;\n      itemsTableBody.appendChild(tr);\n    });\n    itemsTableBody.querySelectorAll('.delBtn').forEach(btn=>{\n      btn.addEventListener('click', ()=> {\n        const id = parseInt(btn.getAttribute('data-id'));\n        items = items.filter(i => i.id !== id);\n        renderItems();\n      });\n    });\n    warnings.textContent = '';\n    if(items.length > 20) warnings.textContent = \"Warning: Many items; brute-force will be disabled for >20 items and DP might be slow if capacity is large.\";\n  }\n\n  function escapeHtml(s){ return String(s).replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c])); }\n\n  // Add item\n  addItemBtn.addEventListener('click', ()=>{\n    const name = itemName.value.trim() || ('Item ' + idCounter);\n    let v = Number(itemValue.value);\n    let w = Number(itemWeight.value);\n    if(!isFinite(v) || v < 0) { alert('Value must be >= 0'); return; }\n    if(!isFinite(w) || w <= 0) { alert('Weight must be > 0'); return; }\n    items.push({ id: idCounter++, name, value: Math.round(v), weight: Math.round(w) });\n    itemValue.value = Math.max(0, Math.round(v));\n    itemWeight.value = Math.max(1, Math.round(w));\n    renderItems();\n  });\n\n  randomBtn.addEventListener('click', ()=> {\n    items = [];\n    const n = 6;\n    for(let i=0;i<n;i++){\n      const w = Math.floor(Math.random()*12)+1;\n      const v = Math.floor(Math.random()*20)+1;\n      items.push({ id: idCounter++, name: 'I'+(i+1), value: v, weight: w });\n    }\n    capacityInput.value = Math.floor(Math.random()*30)+10;\n    renderItems();\n  });\n\n  clearBtn.addEventListener('click', ()=> {\n    items = [];\n    renderItems();\n    resultArea.innerHTML = 'Cleared items.';\n    visual.innerHTML = '';\n    dpViz.style.display='none';\n  });\n\n  // Algorithms\n  function fractionalKnapsack(items, capacity){\n    // items: array of {id,name,value,weight}\n    const start = performance.now();\n    const arr = items.map(it => ({...it, ratio: it.value / it.weight}));\n    arr.sort((a,b) => b.ratio - a.ratio);\n    let cap = capacity;\n    const selected = [];\n    let totalV = 0, totalW = 0;\n    for(const it of arr){\n      if(cap <= 0) break;\n      if(it.weight <= cap){\n        selected.push({ ...it, fraction: 1 });\n        cap -= it.weight;\n        totalV += it.value;\n        totalW += it.weight;\n      } else {\n        const frac = cap / it.weight;\n        selected.push({ ...it, fraction: frac });\n        totalV += it.value * frac;\n        totalW += cap;\n        cap = 0;\n      }\n    }\n    const ms = (performance.now()-start).toFixed(3);\n    return { selected, totalValue: totalV, totalWeight: totalW, timeMs: ms };\n  }\n\n  function knapsackDP(items, capacity){\n    // classic 0/1 knapsack DP (integer capacity)\n    // Warning: complexity O(n*capacity) memory O(capacity)\n    const start = performance.now();\n    const n = items.length;\n    const W = Math.floor(capacity);\n    // Safety: if W is huge, abort\n    if(W > 20000 || n * W > 4e7) {\n      throw new Error('DP would be too large (capacity or n too big). Reduce capacity or items.');\n    }\n    // dp[c] = max value achievable with capacity c using first k items (we will keep prev)\n    const dp = new Array(W+1).fill(0);\n    // To reconstruct, we store choices in a 2D boolean table if small, otherwise we use parent pointers.\n    // We'll build a 2D table only if n*W <= 200000 (for visualization). Otherwise reconstruct by iterating items backwards storing states.\n    const smallViz = (n * (W+1) <= 200000);\n    let takeTable = null;\n    if(smallViz){\n      // takeTable[k][c] = true if we took item k (1-based) at capacity c\n      takeTable = Array.from({length: n}, () => new Array(W+1).fill(false));\n    } else {\n      // we'll store snapshot of dp after each item to allow reconstruction by comparing dp values\n      // store copies is expensive; instead we'll remember dp after each item as Uint32Array if small else null - but for now we will reconstruct by running DP again while tracing.\n      takeTable = null;\n    }\n\n    // DP\n    for(let i=0;i<n;i++){\n      const w = items[i].weight;\n      const v = items[i].value;\n      for(let c=W; c>=0; c--){\n        if(c >= w){\n          const cand = dp[c-w] + v;\n          if(cand > dp[c]){\n            if(smallViz) takeTable[i][c] = true;\n            dp[c] = cand;\n          }\n        }\n      }\n    }\n\n    // Reconstruction\n    const selected = [];\n    let rem = W;\n    if(smallViz){\n      // Walk backwards using takeTable\n      for(let i = n-1; i>=0; i--){\n        if(rem <= 0) break;\n        if(takeTable[i][rem]){\n          selected.push(items[i]);\n          rem -= items[i].weight;\n        }\n      }\n    } else {\n      // Re-run DP but keep previous arrays to check membership\n      // We'll compute dp2[k][c] on the fly by processing items backwards to see whether item i was included.\n      // Simpler: iterate items from n-1 to 0, and check if dp[rem] equals dpWithoutItem (we recompute dpWithout for items 0..i-1).\n      // For efficiency, recompute dp prefix arrays incrementally.\n      // Build dpPrefix[i][c] for i from 0..n as dp using first i items. But that's similar cost to original - still O(nW). Acceptable if not huge because earlier we blocked huge sizes.\n      const prefix = Array.from({length: n+1}, () => new Array(W+1).fill(0));\n      for(let i=1;i<=n;i++){\n        const w = items[i-1].weight, v = items[i-1].value;\n        for(let c=0;c<=W;c++){\n          let val = prefix[i-1][c];\n          if(c >= w) val = Math.max(val, prefix[i-1][c-w] + v);\n          prefix[i][c] = val;\n        }\n      }\n      rem = W;\n      for(let i=n;i>=1;i--){\n        if(rem <= 0) break;\n        if(prefix[i][rem] !== prefix[i-1][rem]){\n          // item i-1 was taken\n          selected.push(items[i-1]);\n          rem -= items[i-1].weight;\n        }\n      }\n      // Note: this uses additional memory but only for moderate sizes allowed above.\n      // We'll expose takeTable visualization if smallViz as well.\n      if(smallViz){\n        // Build takeTable for visualization from prefix\n        takeTable = Array.from({length: n}, () => new Array(W+1).fill(false));\n        for(let i=n;i>=1;i--){\n          for(let c=0;c<=W;c++){\n            if(prefix[i][c] !== prefix[i-1][c] && c>=items[i-1].weight) takeTable[i-1][c] = true;\n          }\n        }\n      }\n    }\n\n    const totalValue = dp[W];\n    const totalWeight = selected.reduce((s, it)=> s + it.weight, 0);\n    const timeMs = (performance.now() - start).toFixed(3);\n    return { selected: selected.reverse(), totalValue, totalWeight, timeMs, takeTable, W };\n  }\n\n  function bruteForce(items, capacity){\n    const start = performance.now();\n    const n = items.length;\n    const W = capacity;\n    if(n > 20) throw new Error('Brute-force disabled for n > 20 (exponential).');\n    let bestVal = -Infinity;\n    let bestMask = 0;\n    let bestWeight = 0;\n    const combos = 1<<n;\n    for(let mask=0; mask<combos; mask++){\n      let w=0, v=0;\n      for(let i=0;i<n;i++){\n        if(mask & (1<<i)){ w += items[i].weight; v += items[i].value; }\n        if(w > W) break;\n      }\n      if(w <= W && v > bestVal){\n        bestVal = v;\n        bestMask = mask;\n        bestWeight = w;\n      }\n    }\n    const selected = [];\n    for(let i=0;i<n;i++) if(bestMask & (1<<i)) selected.push(items[i]);\n    const timeMs = (performance.now() - start).toFixed(3);\n    return { selected, totalValue: bestVal === -Infinity ? 0 : bestVal, totalWeight: bestWeight, timeMs };\n  }\n\n  // Visualization helpers\n  function showResult(title, out, algoType, extra){\n    runtimeEl.textContent = `${algoType} • ${out.timeMs} ms`;\n    const v = Math.round((out.totalValue + Number.EPSILON) * 1000)/1000;\n    const w = Math.round((out.totalWeight + Number.EPSILON) * 1000)/1000;\n    const lines = [];\n    lines.push(`<strong>${title}</strong>`);\n    lines.push(`Total value: <strong>${v}</strong> &nbsp;&nbsp; Total weight: <strong>${w}</strong>`);\n    const list = out.selected.map(it => {\n      const frac = ('fraction' in it) ? ` × ${Math.round(it.fraction*1000)/1000}` : '';\n      return `${escapeHtml(it.name)} (v:${it.value}, w:${it.weight})${frac}`;\n    }).join(', ');\n    lines.push(`<div style=\"margin-top:8px\">${list || '<em>(none)</em>'}</div>`);\n    resultArea.innerHTML = lines.join('');\n    renderBars(out.selected, Number(capacityInput.value));\n    // DP visualization\n    if(extra && extra.takeTable){\n      dpViz.style.display='block';\n      dpViz.innerHTML = renderDPTable(extra.takeTable, extra.W, items);\n    } else {\n      dpViz.style.display='none';\n      dpViz.innerHTML = '';\n    }\n  }\n\n  function renderBars(selected, capacity){\n    visual.innerHTML = '';\n    if(!selected || selected.length===0) return;\n    const cap = Math.max(1, Number(capacity) || 1);\n    const maxBarHeight = 160;\n    const fragment = document.createDocumentFragment();\n    const row = document.createElement('div');\n    row.className = 'bar-row';\n    // Sort by ratio for nicer colors\n    const sorted = selected.slice().sort((a,b)=> (b.value/b.weight) - (a.value/a.weight));\n    let maxWeight = Math.max(...sorted.map(it => it.weight * (it.fraction || 1)));\n    maxWeight = Math.max(maxWeight, cap/4);\n    for(const it of sorted){\n      const bw = (it.weight * (it.fraction || 1));\n      const height = Math.round((bw / Math.max(cap, maxWeight)) * maxBarHeight) + 14;\n      const div = document.createElement('div');\n      div.className = 'bar' + (it.fraction && it.fraction<1 ? ' fraction' : '');\n      div.style.height = height + 'px';\n      div.title = `${it.name}\\nvalue: ${it.value}\\nweight: ${it.weight}${it.fraction?`\\nfraction: ${Math.round(it.fraction*1000)/1000}`:''}`;\n      div.innerHTML = `<span class=\"label\">${escapeHtml(it.name)}<br/>w:${Math.round(bw*1000)/1000}</span>`;\n      row.appendChild(div);\n    }\n    fragment.appendChild(row);\n    visual.appendChild(fragment);\n  }\n\n  function renderDPTable(takeTable, W, itemsList){\n    // takeTable: [i][c] boolean\n    // We'll show header with capacities 0..W (but limit columns to 50 for readability)\n    const maxCols = 50;\n    const cols = Math.min(W+1, maxCols);\n    const colStep = Math.ceil((W+1)/cols);\n    let html = '<table><thead><tr><th>Item \\\\ cap</th>';\n    for(let c=0;c<=W;c+=colStep) html += `<th>${c}</th>`;\n    html += '</tr></thead><tbody>';\n    for(let i=0;i<itemsList.length;i++){\n      html += `<tr><td>${escapeHtml(itemsList[i].name)} (w:${itemsList[i].weight})</td>`;\n      for(let c=0;c<=W;c+=colStep){\n        html += `<td>${takeTable[i][c] ? '✓' : ''}</td>`;\n      }\n      html += '</tr>';\n    }\n    html += '</tbody></table>';\n    return html;\n  }\n\n  // Button handlers\n  runFractionalBtn.addEventListener('click', ()=>{\n    if(items.length === 0) { alert('No items.'); return; }\n    const cap = Number(capacityInput.value);\n    if(!isFinite(cap) || cap < 0) { alert('Invalid capacity'); return; }\n    try{\n      const out = fractionalKnapsack(items, cap);\n      showResult('Fractional knapsack (greedy)', out, 'Fractional', null);\n    } catch(e){\n      alert('Error: ' + e.message);\n    }\n  });\n\n  runDPBtn.addEventListener('click', ()=>{\n    if(items.length === 0) { alert('No items.'); return; }\n    const cap = Math.floor(Number(capacityInput.value));\n    if(!isFinite(cap) || cap < 0) { alert('Invalid capacity'); return; }\n    try{\n      const out = knapsackDP(items, cap);\n      showResult('0/1 knapsack (dynamic programming)', out, '0/1 DP', { takeTable: out.takeTable, W: out.W });\n    } catch(e){\n      alert('Error: ' + e.message);\n    }\n  });\n\n  runBruteBtn.addEventListener('click', ()=>{\n    if(items.length === 0) { alert('No items.'); return; }\n    if(items.length > 20){ alert('Brute-force disabled for more than 20 items.'); return; }\n    const cap = Number(capacityInput.value);\n    if(!isFinite(cap) || cap < 0) { alert('Invalid capacity'); return; }\n    try{\n      const out = bruteForce(items, cap);\n      showResult('Brute-force exact', out, 'Brute-force', null);\n    } catch(e){\n      alert('Error: ' + e.message);\n    }\n  });\n\n  // Initial sample\n  (()=>{\n    items = [\n      { id: idCounter++, name: 'A', value: 24, weight: 12 },\n      { id: idCounter++, name: 'B', value: 18, weight: 6 },\n      { id: idCounter++, name: 'C', value: 18, weight: 9 },\n      { id: idCounter++, name: 'D', value: 10, weight: 4 },\n      { id: idCounter++, name: 'E', value: 15, weight: 7 }\n    ];\n    capacityInput.value = 25;\n    renderItems();\n  })();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Knapsack Problem"
    }
  ],
  "topic": "Knapsack Problem",
  "hasFSM": false,
  "hasTest": true
}