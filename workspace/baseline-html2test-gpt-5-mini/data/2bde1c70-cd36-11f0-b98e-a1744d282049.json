{
  "id": "2bde1c70-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:17:17.829Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Binary Search Tree (BST) Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#3b82f6;\n      --muted:#94a3b8;\n      --good:#10b981;\n      --danger:#f43f5e;\n      --card:#071025;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg, #071022 0%, #001528 100%);\n      color:#e6eef8;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app{\n      max-width:1100px;\n      margin:24px auto;\n      padding:20px;\n      border-radius:12px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n      display:grid;\n      grid-template-columns: 360px 1fr;\n      gap:20px;\n      align-items:start;\n    }\n    h1{\n      font-size:20px;\n      margin:0 0 8px 0;\n      color:#d9f0ff;\n    }\n    .panel{\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n      border-radius:10px;\n      padding:14px;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n    .controls label{\n      font-size:13px;\n      color:var(--muted);\n      display:block;\n      margin-bottom:6px;\n    }\n    .row{\n      display:flex;\n      gap:8px;\n      margin-bottom:10px;\n      align-items:center;\n    }\n    input[type=\"number\"], input[type=\"text\"]{\n      width:100%;\n      padding:8px 10px;\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.06);\n      background:transparent;\n      color:inherit;\n      outline:none;\n      box-sizing:border-box;\n    }\n    button{\n      cursor:pointer;\n      border:0;\n      padding:8px 10px;\n      border-radius:8px;\n      background:var(--accent);\n      color:white;\n      font-weight:600;\n      box-shadow: 0 6px 16px rgba(59,130,246,0.12);\n    }\n    button.ghost{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.05);\n      color:var(--muted);\n      box-shadow:none;\n    }\n    .small{\n      padding:6px 8px;\n      font-size:13px;\n    }\n    .muted{\n      color:var(--muted);\n      font-size:13px;\n    }\n    .stats{\n      display:flex;\n      gap:8px;\n      margin-top:12px;\n      flex-wrap:wrap;\n    }\n    .stat{\n      background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent);\n      padding:8px 10px;\n      border-radius:8px;\n      font-size:13px;\n      color:var(--muted);\n      border:1px solid rgba(255,255,255,0.02);\n    }\n    .svg-wrap{\n      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));\n      border-radius:10px;\n      padding:12px;\n      border:1px solid rgba(255,255,255,0.03);\n      min-height:520px;\n      display:flex;\n      flex-direction:column;\n      gap:10px;\n    }\n    .canvas{\n      flex:1;\n      background:linear-gradient(180deg, rgba(2,6,23,0.4), rgba(2,6,23,0.2));\n      border-radius:8px;\n      overflow:auto;\n      padding:12px;\n    }\n    svg{\n      width:100%;\n      height:520px;\n    }\n    .legend{\n      display:flex;\n      gap:8px;\n      align-items:center;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .dot{\n      width:12px;height:12px;border-radius:50%;\n      display:inline-block;margin-right:6px;\n    }\n    .info{\n      margin-top:8px;\n      font-size:13px;\n      color:var(--muted);\n    }\n    .traversal-output{\n      margin-top:10px;\n      padding:8px;\n      background:rgba(255,255,255,0.02);\n      border-radius:8px;\n      border:1px solid rgba(255,255,255,0.02);\n      font-family:monospace;\n      color:#dbeafe;\n      max-height:120px;\n      overflow:auto;\n      font-size:13px;\n    }\n    .small-muted{\n      color:var(--muted);\n      font-size:12px;\n    }\n\n    /* node visuals (we'll override fill/stroke from JS for highlights) */\n    .node-circle{\n      fill:#0b1220;\n      stroke:#9fb8ff33;\n      stroke-width:2;\n    }\n    .node-text{\n      font-size:13px;\n      fill:#dbeafe;\n      pointer-events:none;\n      font-weight:700;\n    }\n    .edge{\n      stroke:#203a66;\n      stroke-width:2;\n    }\n\n    @media (max-width:880px){\n      .app{ grid-template-columns: 1fr; padding:12px; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Binary Search Tree Visualizer\">\n    <div class=\"panel controls\" aria-hidden=\"false\">\n      <h1>Binary Search Tree (BST)</h1>\n      <div class=\"muted\">Insert, delete, search and visualize the BST. Duplicates are not allowed.</div>\n\n      <div style=\"height:12px\"></div>\n\n      <div>\n        <label for=\"valueInput\">Value (integer)</label>\n        <div class=\"row\">\n          <input id=\"valueInput\" type=\"number\" placeholder=\"e.g. 42\" />\n          <button id=\"insertBtn\" class=\"small\">Insert</button>\n          <button id=\"deleteBtn\" class=\"small ghost\">Delete</button>\n        </div>\n      </div>\n\n      <div style=\"height:6px\"></div>\n\n      <div>\n        <label for=\"searchInput\">Search</label>\n        <div class=\"row\">\n          <input id=\"searchInput\" type=\"number\" placeholder=\"Find value...\" />\n          <button id=\"searchBtn\" class=\"small\">Find</button>\n          <button id=\"clearBtn\" class=\"small ghost\">Reset</button>\n        </div>\n      </div>\n\n      <div style=\"height:12px\"></div>\n\n      <div>\n        <label>Traversals & Animation</label>\n        <div class=\"row\">\n          <button id=\"inorderBtn\" class=\"small ghost\">In-order</button>\n          <button id=\"preorderBtn\" class=\"small ghost\">Pre-order</button>\n          <button id=\"postorderBtn\" class=\"small ghost\">Post-order</button>\n          <button id=\"levelBtn\" class=\"small ghost\">Level-order</button>\n        </div>\n      </div>\n\n      <div style=\"height:12px\"></div>\n\n      <div>\n        <label>Quick actions</label>\n        <div class=\"row\">\n          <button id=\"randomBtn\" class=\"small\">Random 8</button>\n          <button id=\"balancedBtn\" class=\"small\">Make Balanced (rebuild)</button>\n          <button id=\"fillBtn\" class=\"small ghost\">Clear & Fill (1..10)</button>\n        </div>\n      </div>\n\n      <div class=\"stats\" aria-hidden=\"false\" style=\"margin-top:12px\">\n        <div class=\"stat\">Nodes: <span id=\"statNodes\">0</span></div>\n        <div class=\"stat\">Height: <span id=\"statHeight\">0</span></div>\n        <div class=\"stat\">Min: <span id=\"statMin\">—</span></div>\n        <div class=\"stat\">Max: <span id=\"statMax\">—</span></div>\n      </div>\n\n      <div class=\"info\">\n        Click any node in the SVG to search for it. Visited nodes are highlighted during operations.\n      </div>\n\n      <div class=\"traversal-output\" id=\"traceOutput\" aria-live=\"polite\"></div>\n    </div>\n\n    <div class=\"panel svg-wrap\">\n      <div class=\"legend\">\n        <div style=\"display:flex;gap:8px;align-items:center\">\n          <div class=\"dot\" style=\"background:var(--accent)\"></div> Active / found\n          <div style=\"width:12px\"></div>\n          <div class=\"dot\" style=\"background:#ffd166\"></div> Visited\n          <div style=\"width:12px\"></div>\n          <div class=\"dot\" style=\"background:#94a3b8\"></div> Node\n        </div>\n        <div style=\"flex:1\"></div>\n        <div class=\"small-muted\">SVG Canvas</div>\n      </div>\n\n      <div class=\"canvas\" id=\"canvas\">\n        <svg id=\"svg\" viewBox=\"0 0 1200 520\" preserveAspectRatio=\"xMidYMid meet\" role=\"img\" aria-label=\"Binary search tree visualization\"></svg>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // BST Visualizer\n    // Node structure: {value, left, right}\n    (function(){\n      // Utilities\n      const $ = (id)=>document.getElementById(id);\n      const svg = $('svg');\n      const valueInput = $('valueInput');\n      const insertBtn = $('insertBtn');\n      const deleteBtn = $('deleteBtn');\n      const searchInput = $('searchInput');\n      const searchBtn = $('searchBtn');\n      const clearBtn = $('clearBtn');\n      const inorderBtn = $('inorderBtn');\n      const preorderBtn = $('preorderBtn');\n      const postorderBtn = $('postorderBtn');\n      const levelBtn = $('levelBtn');\n      const randomBtn = $('randomBtn');\n      const balancedBtn = $('balancedBtn');\n      const fillBtn = $('fillBtn');\n      const traceOutput = $('traceOutput');\n      const statNodes = $('statNodes');\n      const statHeight = $('statHeight');\n      const statMin = $('statMin');\n      const statMax = $('statMax');\n\n      let root = null;\n      let nodeCount = 0;\n      let animationRunning = false;\n\n      // Insert (records visited values)\n      function insert(value){\n        if (root === null){\n          root = {value, left:null, right:null};\n          nodeCount=1;\n          return {inserted:true, steps:[value]};\n        }\n        const steps = [];\n        let cur = root;\n        while(true){\n          steps.push(cur.value);\n          if (value === cur.value) {\n            // duplicate\n            return {inserted:false, steps, msg:'duplicate'};\n          } else if (value < cur.value){\n            if (cur.left === null){\n              cur.left = {value, left:null, right:null};\n              nodeCount++;\n              steps.push(value);\n              return {inserted:true, steps};\n            } else {\n              cur = cur.left;\n            }\n          } else {\n            if (cur.right === null){\n              cur.right = {value, left:null, right:null};\n              nodeCount++;\n              steps.push(value);\n              return {inserted:true, steps};\n            } else {\n              cur = cur.right;\n            }\n          }\n        }\n      }\n\n      // Search (records visited values)\n      function search(value){\n        const steps = [];\n        let cur = root;\n        while(cur){\n          steps.push(cur.value);\n          if (value === cur.value) return {found:true, steps};\n          cur = value < cur.value ? cur.left : cur.right;\n        }\n        return {found:false, steps};\n      }\n\n      // Find min node in subtree\n      function findMinNode(node){\n        let cur = node;\n        while(cur && cur.left) cur = cur.left;\n        return cur;\n      }\n\n      // Delete value from BST. Returns steps of visited node values.\n      function deleteValue(value){\n        const steps = [];\n        let deleted = false;\n        function deleteRec(node){\n          if (!node) return null;\n          steps.push(node.value);\n          if (value < node.value){\n            node.left = deleteRec(node.left);\n            return node;\n          } else if (value > node.value){\n            node.right = deleteRec(node.right);\n            return node;\n          } else {\n            // found node to delete\n            deleted = true;\n            // case 1: no children\n            if (!node.left && !node.right) return null;\n            // case 2: one child\n            if (!node.left) return node.right;\n            if (!node.right) return node.left;\n            // case 3: two children -> replace with inorder successor\n            const succ = findMinNode(node.right);\n            // record successor visited (value)\n            if (succ) steps.push(succ.value);\n            node.value = succ.value;\n            // delete successor from right subtree\n            node.right = deleteRec(node.right);\n            return node;\n          }\n        }\n        root = deleteRec(root);\n        if (deleted) nodeCount = countNodes(root);\n        return {deleted, steps};\n      }\n\n      function countNodes(node){\n        if (!node) return 0;\n        return 1 + countNodes(node.left) + countNodes(node.right);\n      }\n\n      function treeHeight(node){\n        if (!node) return 0;\n        return 1 + Math.max(treeHeight(node.left), treeHeight(node.right));\n      }\n\n      function findMin(node){\n        if (!node) return null;\n        let cur = node;\n        while(cur.left) cur = cur.left;\n        return cur.value;\n      }\n      function findMax(node){\n        if (!node) return null;\n        let cur = node;\n        while(cur.right) cur = cur.right;\n        return cur.value;\n      }\n\n      // Traversals\n      function inorder(node, out=[]){ if(!node) return out; inorder(node.left,out); out.push(node.value); inorder(node.right,out); return out; }\n      function preorder(node, out=[]){ if(!node) return out; out.push(node.value); preorder(node.left,out); preorder(node.right,out); return out; }\n      function postorder(node, out=[]){ if(!node) return out; postorder(node.left,out); postorder(node.right,out); out.push(node.value); return out; }\n      function levelOrder(node){\n        const out=[]; if(!node) return out;\n        const q=[node];\n        while(q.length){\n          const n=q.shift();\n          out.push(n.value);\n          if(n.left) q.push(n.left);\n          if(n.right) q.push(n.right);\n        }\n        return out;\n      }\n\n      // Layout: assign x by inorder index, y by depth.\n      function computePositions(rootNode){\n        const positions = new Map(); // value -> {x,y,depth}\n        let index = 0;\n        function dfs(node, depth){\n          if(!node) return;\n          dfs(node.left, depth+1);\n          const x = index++;\n          positions.set(node.value, {x, depth});\n          dfs(node.right, depth+1);\n        }\n        dfs(rootNode, 0);\n        return {positions, total:index};\n      }\n\n      // Draw tree into SVG\n      function draw(){\n        // clear\n        while(svg.firstChild) svg.removeChild(svg.firstChild);\n        if(!root) return;\n        const padding = 40;\n        const {positions, total} = computePositions(root);\n        const levelH = 80;\n        const width = 1200;\n        const height = 520;\n        const availableWidth = Math.max(600, width - padding*2);\n        const step = total>1 ? (availableWidth / (total-1)) : 0;\n        // helper to get coordinates by value\n        function coordFor(val){\n          const p = positions.get(val);\n          const x = padding + (p.x * step);\n          const y = padding + p.depth * levelH;\n          return {x,y,depth:p.depth};\n        }\n\n        // draw edges by traversing nodes\n        function drawEdges(node){\n          if(!node) return;\n          if(node.left){\n            const a = coordFor(node.value), b = coordFor(node.left.value);\n            const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n            line.setAttribute('x1', a.x); line.setAttribute('y1', a.y+18);\n            line.setAttribute('x2', b.x); line.setAttribute('y2', b.y-18);\n            line.setAttribute('class','edge');\n            svg.appendChild(line);\n          }\n          if(node.right){\n            const a = coordFor(node.value), b = coordFor(node.right.value);\n            const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n            line.setAttribute('x1', a.x); line.setAttribute('y1', a.y+18);\n            line.setAttribute('x2', b.x); line.setAttribute('y2', b.y-18);\n            line.setAttribute('class','edge');\n            svg.appendChild(line);\n          }\n          drawEdges(node.left);\n          drawEdges(node.right);\n        }\n        drawEdges(root);\n\n        // draw nodes\n        function drawNodes(node){\n          if(!node) return;\n          const {x,y} = coordFor(node.value);\n          const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n          g.setAttribute('transform', `translate(${x},${y})`);\n          g.setAttribute('data-value', node.value);\n          g.setAttribute('role','button');\n          // circle\n          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');\n          c.setAttribute('r', 18);\n          c.setAttribute('class','node-circle');\n          c.setAttribute('id', 'node-'+node.value);\n          // text\n          const t = document.createElementNS('http://www.w3.org/2000/svg','text');\n          t.setAttribute('class','node-text');\n          t.setAttribute('text-anchor','middle');\n          t.setAttribute('dy','5');\n          t.textContent = node.value;\n          g.appendChild(c);\n          g.appendChild(t);\n          // click search\n          g.addEventListener('click', ()=> {\n            if (animationRunning) return;\n            searchInput.value = node.value;\n            handleSearch();\n          });\n          svg.appendChild(g);\n          drawNodes(node.left);\n          drawNodes(node.right);\n        }\n        drawNodes(root);\n      }\n\n      // Highlight utilities (value-based)\n      function highlightSequence(values, {visitColor='#ffd166', foundColor='var(--accent)', delay=450, keep=false} = {}){\n        if (!values || values.length===0) return Promise.resolve();\n        animationRunning = true;\n        traceOutput.textContent = '';\n        let p = Promise.resolve();\n        values.forEach((val, idx)=>{\n          p = p.then(()=> new Promise(resolve=>{\n            // highlight visited\n            const el = document.getElementById('node-'+val);\n            if (el){\n              const circle = el;\n              const nodeParent = circle.parentNode;\n              // visited highlight\n              circle.style.transition = 'fill 180ms, stroke 180ms';\n              circle.setAttribute('fill', visitColor);\n              circle.setAttribute('stroke', '#7a4f05');\n              // append trace\n              traceOutput.textContent += (idx? ' ➜ ' : '') + val;\n            }\n            setTimeout(()=> {\n              // after delay, if final and keep, set final color\n              if (idx === values.length-1 && keep){\n                const el2 = document.getElementById('node-'+values[values.length-1]);\n                if (el2){\n                  el2.setAttribute('fill', foundColor);\n                  el2.setAttribute('stroke', '#1e40af');\n                }\n              } else {\n                // revert visited color to default\n                const el3 = document.getElementById('node-'+val);\n                if (el3){\n                  el3.setAttribute('fill', '#0b1220');\n                  el3.setAttribute('stroke', '#9fb8ff33');\n                }\n              }\n              resolve();\n            }, delay);\n          }));\n        });\n        return p.then(()=>{ animationRunning = false; });\n      }\n\n      // For searches we want to keep last node highlighted\n      function animateSearch(steps, found){\n        const colorVisited = '#ffd166';\n        const colorFound = 'var(--accent)';\n        return highlightSequence(steps, {visitColor:colorVisited, foundColor:colorFound, delay:420, keep:found});\n      }\n\n      // For traversals: highlight nodes in traversal order\n      function animateTraversal(list){\n        const colorVisited = '#ffd166';\n        animationRunning = true;\n        traceOutput.textContent = '';\n        let p = Promise.resolve();\n        list.forEach((val, idx) => {\n          p = p.then(()=> new Promise(resolve=>{\n            const el = document.getElementById('node-'+val);\n            if(el){\n              el.setAttribute('fill', colorVisited);\n              el.setAttribute('stroke', '#7a4f05');\n            }\n            traceOutput.textContent += (idx? ' ➜ ' : '') + val;\n            setTimeout(()=> {\n              const el2 = document.getElementById('node-'+val);\n              if(el2){\n                el2.setAttribute('fill', '#0b1220');\n                el2.setAttribute('stroke', '#9fb8ff33');\n              }\n              resolve();\n            }, 300);\n          }));\n        });\n        return p.then(()=> { animationRunning = false; });\n      }\n\n      // UI Handlers\n      function updateStats(){\n        statNodes.textContent = nodeCount;\n        statHeight.textContent = treeHeight(root);\n        const min = findMin(root), max = findMax(root);\n        statMin.textContent = min===null? '—':min;\n        statMax.textContent = max===null? '—':max;\n      }\n\n      function handleInsert(){\n        if (animationRunning) return;\n        const v = parseInt(valueInput.value);\n        if (Number.isNaN(v)) return alert('Enter an integer value to insert.');\n        const res = insert(v);\n        draw();\n        updateStats();\n        if(!res.inserted){\n          alert('Duplicate values are not allowed in this BST (ignored).');\n        } else {\n          // animate insertion path\n          animateSearch(res.steps, true).then(()=> {});\n        }\n      }\n      function handleDelete(){\n        if (animationRunning) return;\n        const v = parseInt(valueInput.value);\n        if (Number.isNaN(v)) return alert('Enter an integer value to delete.');\n        const res = deleteValue(v);\n        draw();\n        updateStats();\n        if (!res.deleted){\n          // animate visited path showing not found\n          animateSearch(res.steps, false).then(()=> {\n            if (res.steps.length===0) alert('Tree is empty.');\n            else alert('Value not found.');\n          });\n        } else {\n          animateSearch(res.steps, false).then(()=> {});\n        }\n      }\n      function handleSearch(){\n        if (animationRunning) return;\n        const v = parseInt(searchInput.value);\n        if (Number.isNaN(v)) return alert('Enter an integer to search.');\n        const res = search(v);\n        if (res.steps.length===0){\n          alert('Tree is empty.');\n          return;\n        }\n        animateSearch(res.steps, res.found).then(()=> {\n          if (!res.found) alert('Not found.');\n        });\n      }\n\n      // Utility to create random unique integers\n      function randomUnique(count, min=1, max=99){\n        const s = new Set();\n        while(s.size < count){\n          const r = Math.floor(Math.random()*(max-min+1))+min;\n          s.add(r);\n          if (s.size > (max-min+1)) break;\n        }\n        return Array.from(s);\n      }\n\n      // Build balanced tree from sorted array\n      function buildBalanced(sorted){\n        function build(l,r){\n          if (l>r) return null;\n          const m = Math.floor((l+r)/2);\n          return {value: sorted[m], left: build(l,m-1), right: build(m+1,r)};\n        }\n        return build(0, sorted.length-1);\n      }\n\n      // Event Listeners\n      insertBtn.addEventListener('click', handleInsert);\n      deleteBtn.addEventListener('click', handleDelete);\n      searchBtn.addEventListener('click', handleSearch);\n      clearBtn.addEventListener('click', ()=> {\n        if (animationRunning) return;\n        if (!confirm('Clear the entire tree?')) return;\n        root = null; nodeCount=0; draw(); updateStats();\n        traceOutput.textContent = '';\n      });\n\n      inorderBtn.addEventListener('click', ()=> {\n        if (animationRunning) return;\n        const list = inorder(root,[]);\n        if(list.length===0) return alert('Tree is empty.');\n        // animate traversal\n        animateTraversal(list);\n      });\n      preorderBtn.addEventListener('click', ()=> {\n        if (animationRunning) return;\n        const list = preorder(root,[]);\n        if(list.length===0) return alert('Tree is empty.');\n        animateTraversal(list);\n      });\n      postorderBtn.addEventListener('click', ()=> {\n        if (animationRunning) return;\n        const list = postorder(root,[]);\n        if(list.length===0) return alert('Tree is empty.');\n        animateTraversal(list);\n      });\n      levelBtn.addEventListener('click', ()=> {\n        if (animationRunning) return;\n        const list = levelOrder(root);\n        if(list.length===0) return alert('Tree is empty.');\n        animateTraversal(list);\n      });\n\n      randomBtn.addEventListener('click', ()=> {\n        if (animationRunning) return;\n        root = null; nodeCount=0;\n        const vals = randomUnique(8,1,99);\n        vals.forEach(v=> insert(v));\n        draw(); updateStats();\n      });\n\n      fillBtn.addEventListener('click', ()=> {\n        if (animationRunning) return;\n        if (!confirm('Clear and insert values 1..10?')) return;\n        root = null; nodeCount=0;\n        for(let i=1;i<=10;i++) insert(i);\n        draw(); updateStats();\n      });\n\n      balancedBtn.addEventListener('click', ()=> {\n        if (animationRunning) return;\n        // rebuild tree as balanced tree using current values\n        const vals = inorder(root,[]);\n        if (vals.length===0) return;\n        root = buildBalanced(vals);\n        nodeCount = vals.length;\n        draw(); updateStats();\n      });\n\n      // Initialize with a small example\n      (function seed(){\n        const seeds = [60,40,80,30,50,70,90,20,35,45,55];\n        root = null; nodeCount=0;\n        seeds.forEach(v=> insert(v));\n        draw(); updateStats();\n      })();\n\n      // Make SVG responsive to resizing\n      window.addEventListener('resize', ()=> draw());\n\n      // Keyboard shortcuts\n      document.addEventListener('keydown', (e)=>{\n        if (e.key === 'Enter'){\n          if (document.activeElement === valueInput) handleInsert();\n          else if (document.activeElement === searchInput) handleSearch();\n        }\n      });\n\n      // Accessibility: announce when animation running\n      const obs = new MutationObserver(()=>{});\n      updateStats();\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": false,
  "hasTest": true
}