{
  "id": "2bde6a91-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:46.632Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Prim's Algorithm Visualizer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --muted:#95a0b5;\n      --accent:#3b82f6;\n      --good:#10b981;\n      --warn:#f59e0b;\n      --danger:#ef4444;\n      --glass: rgba(255,255,255,0.04);\n      --card-radius:10px;\n      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;\n    }\n    html,body{height:100%;margin:0;background:linear-gradient(180deg,#041028 0%,#061530 60%);color:#e6eef8;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}\n    .wrap{display:flex;gap:16px;padding:18px;box-sizing:border-box;height:100%;}\n    .left{flex:1;display:flex;flex-direction:column;gap:12px;}\n    .canvasCard{background:var(--panel);border-radius:var(--card-radius);padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);display:flex;flex-direction:column;gap:8px;}\n    #svgCanvas{width:100%;height:640px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02) 0%, rgba(255,255,255,0.01) 100%);touch-action:none;}\n    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}\n    .controls > *{background:var(--glass);border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:8px;color:var(--muted);font-weight:600;}\n    button.controlBtn{cursor:pointer;color:#e6eef8;background:linear-gradient(180deg,rgba(255,255,255,0.02), rgba(255,255,255,0));border:none;padding:8px 12px;border-radius:8px;}\n    button.controlBtn:active{transform:translateY(1px);}\n    .small{font-size:13px;padding:6px 10px;}\n    .sliders{display:flex;gap:8px;align-items:center;}\n    .panelRight{width:360px;display:flex;flex-direction:column;gap:12px;}\n    .card{background:var(--panel);border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.55);}\n    .title{font-size:14px;color:#d7e3f4;font-weight:700;margin-bottom:8px;}\n    .muted{color:var(--muted);font-size:13px;}\n    .table{display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;}\n    .cell{padding:6px;border-radius:6px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted);display:flex;justify-content:space-between;align-items:center;}\n    .key{font-family:var(--mono);font-weight:700;color:#eaf2ff;}\n    .legend{display:flex;gap:8px;flex-wrap:wrap;}\n    .legendItem{display:flex;gap:6px;align-items:center;font-size:13px;color:var(--muted);}\n    .dot{width:16px;height:10px;border-radius:4px;}\n    footer{opacity:0.7;font-size:12px;color:var(--muted);margin-top:6px;}\n    .weightTag{font-family:var(--mono);font-size:12px;fill:#d6e9ff;stroke:#001;stroke-width:0.2;}\n    .nodeLabel{font-family:var(--mono);font-size:12px;fill:#eaf2ff;text-anchor:middle;dominant-baseline:central;pointer-events:none;}\n    .edgeLine{stroke:#7b8da6;stroke-opacity:0.35;stroke-width:2;}\n    .edgeLabelBG{fill:#091226;opacity:0.85;rx:4;ry:4;}\n    .buttonRow{display:flex;gap:8px;flex-wrap:wrap;}\n    .infoRow{display:flex;justify-content:space-between;align-items:center;}\n    input[type=range]{accent-color:var(--accent);width:140px;}\n    .smallmuted{font-size:12px;color:var(--muted);}\n    .highlight{outline:2px solid rgba(59,130,246,0.18);border-radius:8px;padding:6px;}\n    @media (max-width:980px){.wrap{flex-direction:column}.panelRight{width:100%}}\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <div class=\"left\">\n      <div class=\"canvasCard\">\n        <div class=\"controls\">\n          <div style=\"display:flex;gap:8px;align-items:center;\">\n            <label class=\"muted\">Nodes</label>\n            <input id=\"nodeCount\" type=\"range\" min=\"4\" max=\"20\" value=\"10\" />\n            <span id=\"nodeCountVal\" class=\"smallmuted\">10</span>\n          </div>\n          <div style=\"display:flex;gap:8px;align-items:center;\">\n            <label class=\"muted\">Density</label>\n            <input id=\"density\" type=\"range\" min=\"0\" max=\"100\" value=\"45\" />\n            <span id=\"densityVal\" class=\"smallmuted\">45%</span>\n          </div>\n          <div class=\"sliders\">\n            <label class=\"muted\">Weight</label>\n            <input id=\"minW\" type=\"number\" value=\"1\" style=\"width:64px;border-radius:6px;padding:6px;background:var(--glass);border:none;color:var(--muted)\"/>\n            <input id=\"maxW\" type=\"number\" value=\"20\" style=\"width:64px;border-radius:6px;padding:6px;background:var(--glass);border:none;color:var(--muted)\"/>\n          </div>\n          <button id=\"genBtn\" class=\"controlBtn small\">Generate Graph</button>\n          <button id=\"resetBtn\" class=\"controlBtn small\">Reset</button>\n        </div>\n\n        <svg id=\"svgCanvas\" viewBox=\"0 0 1000 640\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n\n        <div class=\"controls\" style=\"justify-content:space-between;\">\n          <div class=\"buttonRow\">\n            <button id=\"startBtn\" class=\"controlBtn small\">Start Prim</button>\n            <button id=\"stepBtn\" class=\"controlBtn small\">Step</button>\n            <button id=\"playBtn\" class=\"controlBtn small\">Play</button>\n            <button id=\"pauseBtn\" class=\"controlBtn small\" disabled>Pause</button>\n            <label class=\"muted\">Speed</label>\n            <input id=\"speed\" type=\"range\" min=\"100\" max=\"2000\" value=\"700\"/>\n            <span id=\"status\" class=\"muted\">Click a node to choose start (or press Start to pick random)</span>\n          </div>\n          <div class=\"muted smallmuted\">Click a node to set start. Hover edges to view weight.</div>\n        </div>\n      </div>\n\n      <div class=\"card\" style=\"display:flex;gap:12px;align-items:center;justify-content:space-between;\">\n        <div>\n          <div class=\"title\">Current MST</div>\n          <div class=\"muted\">Total Weight: <span id=\"totalWeight\" class=\"key\">0</span></div>\n        </div>\n        <div>\n          <div class=\"title\">Algorithm</div>\n          <div class=\"muted\">Selected: <span id=\"selectedCount\" class=\"key\">0</span> / <span id=\"needCount\" class=\"key\">0</span></div>\n        </div>\n      </div>\n\n      <div class=\"card\">\n        <div class=\"title\">Legend</div>\n        <div class=\"legend\">\n          <div class=\"legendItem\"><div class=\"dot\" style=\"background:#e6eef8;\"></div>Node (unvisited)</div>\n          <div class=\"legendItem\"><div class=\"dot\" style=\"background:#10b981;\"></div>In MST</div>\n          <div class=\"legendItem\"><div class=\"dot\" style=\"background:#f59e0b;\"></div>Currently chosen</div>\n          <div class=\"legendItem\"><div class=\"dot\" style=\"background:#60a5fa;\"></div>Candidate edge (best for a node)</div>\n          <div class=\"legendItem\"><div class=\"dot\" style=\"background:#a0aec0;\"></div>Normal edge</div>\n        </div>\n        <footer>Prim's algorithm grows a tree by always attaching the minimum-weight edge crossing the cut.</footer>\n      </div>\n    </div>\n\n    <div class=\"panelRight\">\n      <div class=\"card\">\n        <div class=\"title\">Vertex Keys (key = best edge weight to MST)</div>\n        <div id=\"vertexTable\" class=\"table\" style=\"margin-top:8px;\"></div>\n      </div>\n\n      <div class=\"card\">\n        <div class=\"title\">Edges in MST</div>\n        <div id=\"mstList\" class=\"muted\" style=\"max-height:240px;overflow:auto;padding-top:6px;\"></div>\n      </div>\n\n      <div class=\"card\">\n        <div class=\"title\">How to use</div>\n        <div class=\"muted\" style=\"line-height:1.4;\">\n          - Generate a random weighted graph. Click any node to pick starting node before starting.<br/>\n          - Press \"Start Prim\" to initialize. Use \"Step\" to advance one vertex, or \"Play\" to animate.<br/>\n          - Watch the keys (best candidate edge for each non-MST node) and the MST edges update live.\n        </div>\n      </div>\n    </div>\n  </div>\n\n<script>\n(() => {\n  // Canvas and graph data\n  const svg = document.getElementById('svgCanvas');\n  const nodeCountSlider = document.getElementById('nodeCount');\n  const nodeCountVal = document.getElementById('nodeCountVal');\n  const densitySlider = document.getElementById('density');\n  const densityVal = document.getElementById('densityVal');\n  const genBtn = document.getElementById('genBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const startBtn = document.getElementById('startBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const playBtn = document.getElementById('playBtn');\n  const pauseBtn = document.getElementById('pauseBtn');\n  const speedSlider = document.getElementById('speed');\n  const status = document.getElementById('status');\n  const totalWeightEl = document.getElementById('totalWeight');\n  const selectedCountEl = document.getElementById('selectedCount');\n  const needCountEl = document.getElementById('needCount');\n  const vertexTable = document.getElementById('vertexTable');\n  const mstList = document.getElementById('mstList');\n  const minWInput = document.getElementById('minW');\n  const maxWInput = document.getElementById('maxW');\n\n  nodeCountVal.textContent = nodeCountSlider.value;\n  densityVal.textContent = densitySlider.value + '%';\n\n  // Graph storage\n  let W = []; // adjacency weight matrix, Infinity means no edge\n  let nodes = []; // {id,x,y,svgGroup}\n  let edges = {}; // key \"u-v\" -> {u,v,w,svgLine,svgLabel,svgLabelBG}\n  let nodeCount = parseInt(nodeCountSlider.value);\n\n  // Prim state\n  let inMST = [];\n  let key = [];\n  let parent = [];\n  let started = false;\n  let startNode = null;\n  let selectedCount = 0;\n  let intervalHandle = null;\n  let animLock = false; // prevent overlapping animations\n\n  // Responsive scaling\n  const viewW = 1000, viewH = 640;\n\n  function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }\n\n  function clearSVG(){\n    while(svg.firstChild) svg.removeChild(svg.firstChild);\n  }\n\n  function makeGraph(n, densityPercent, wmin, wmax){\n    clearSVG();\n    nodes = [];\n    W = Array.from({length:n},()=>Array(n).fill(Infinity));\n    edges = {};\n    // random positions with padding\n    const pad = 60;\n    const cols = Math.ceil(Math.sqrt(n));\n    for(let i=0;i<n;i++){\n      const cx = rand(pad, viewW-pad);\n      const cy = rand(pad, viewH-pad);\n      nodes.push({id:i,x:cx,y:cy});\n    }\n    // ensure connected: generate random spanning tree first\n    const order = nodes.map((_,i)=>i).sort(()=>Math.random()-0.5);\n    for(let i=1;i<n;i++){\n      const a = order[i];\n      const b = order[rand(0,i-1)];\n      const w = rand(wmin,wmax);\n      addEdge(a,b,w);\n    }\n    // add extra edges per density\n    for(let i=0;i<n;i++){\n      for(let j=i+1;j<n;j++){\n        if(W[i][j]<Infinity) continue; // already edge from spanning tree\n        if(Math.random()*100 < densityPercent){\n          addEdge(i,j, rand(wmin,wmax));\n        }\n      }\n    }\n    // draw edges then nodes\n    drawEdges();\n    drawNodes();\n    nodeCount = n;\n    resetState();\n  }\n\n  function addEdge(u,v,w){\n    W[u][v]=W[v][u]=w;\n    const key = edgeKey(u,v);\n    edges[key] = {u,v,w};\n  }\n\n  function edgeKey(a,b){ return (a<b)? a+'-'+b : b+'-'+a; }\n\n  function drawEdges(){\n    // draw straight lines and weight labels\n    Object.values(edges).forEach(e=>{\n      const {u,v,w} = e;\n      const nu = nodes[u], nv = nodes[v];\n      // line\n      const line = document.createElementNS(\"http://www.w3.org/2000/svg\",\"line\");\n      line.setAttribute('x1',nu.x); line.setAttribute('y1',nu.y);\n      line.setAttribute('x2',nv.x); line.setAttribute('y2',nv.y);\n      line.setAttribute('class','edgeLine');\n      line.setAttribute('data-key',edgeKey(u,v));\n      svg.appendChild(line);\n      // midpoint label group\n      const mx = (nu.x+nv.x)/2, my = (nu.y+nv.y)/2;\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\n      g.setAttribute('transform',`translate(${mx},${my})`);\n      // background rect\n      const bg = document.createElementNS(\"http://www.w3.org/2000/svg\",\"rect\");\n      bg.setAttribute('x',-18); bg.setAttribute('y',-12); bg.setAttribute('width',36); bg.setAttribute('height',20);\n      bg.setAttribute('class','edgeLabelBG');\n      bg.setAttribute('rx',4);\n      g.appendChild(bg);\n      // text\n      const t = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n      t.setAttribute('class','weightTag');\n      t.textContent = w;\n      g.appendChild(t);\n      svg.appendChild(g);\n      e.svgLine = line; e.svgLabel = t; e.svgLabelBG = bg;\n      // hover interaction\n      line.addEventListener('mouseenter', ()=> {\n        e.svgLine.style.strokeOpacity = 1; e.svgLine.style.strokeWidth = 3.2;\n      });\n      line.addEventListener('mouseleave', ()=> {\n        e.svgLine.style.strokeOpacity = 0.35; e.svgLine.style.strokeWidth = 2;\n      });\n    });\n  }\n\n  function drawNodes(){\n    nodes.forEach(n=>{\n      // group for circle + label\n      const g = document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");\n      g.setAttribute('transform', `translate(${n.x},${n.y})`);\n      g.style.cursor = 'pointer';\n      // circle\n      const c = document.createElementNS(\"http://www.w3.org/2000/svg\",\"circle\");\n      c.setAttribute('r',12);\n      c.setAttribute('fill','#e6eef8');\n      c.setAttribute('stroke','#021428');\n      c.setAttribute('stroke-width',2);\n      g.appendChild(c);\n      // label\n      const l = document.createElementNS(\"http://www.w3.org/2000/svg\",\"text\");\n      l.setAttribute('class','nodeLabel');\n      l.textContent = n.id;\n      g.appendChild(l);\n      svg.appendChild(g);\n      n.svgGroup = g;\n      n.svgCircle = c;\n      n.svgLabel = l;\n      g.addEventListener('click',(ev)=>{\n        if(started) return;\n        setStartNode(n.id);\n      });\n      // drag support (optional)\n      let dragging=false, ox=0,oy=0;\n      g.addEventListener('pointerdown',(e)=>{\n        dragging=true; ox=e.clientX; oy=e.clientY;\n        g.setPointerCapture(e.pointerId);\n      });\n      window.addEventListener('pointerup', (e)=>{ if(dragging){ dragging=false; }});\n      window.addEventListener('pointermove', (e)=>{\n        if(!dragging) return;\n        const dx = e.clientX - ox, dy = e.clientY - oy;\n        ox = e.clientX; oy = e.clientY;\n        // translate relative to viewbox scale: we used fixed viewBox so screen pixels map to viewBox 1000x640 proportionally\n        const bbox = svg.getBoundingClientRect();\n        const scaleX = viewW / bbox.width;\n        const scaleY = viewH / bbox.height;\n        n.x += dx*scaleX; n.y += dy*scaleY;\n        // limit to padding\n        n.x = Math.max(40, Math.min(viewW-40, n.x));\n        n.y = Math.max(40, Math.min(viewH-40, n.y));\n        // update rendering\n        updateAllPositions();\n      });\n    });\n    updateAllPositions();\n  }\n\n  function updateAllPositions(){\n    // update edges and node groups\n    Object.values(edges).forEach(e=>{\n      const nu = nodes[e.u], nv = nodes[e.v];\n      e.svgLine.setAttribute('x1',nu.x); e.svgLine.setAttribute('y1',nu.y);\n      e.svgLine.setAttribute('x2',nv.x); e.svgLine.setAttribute('y2',nv.y);\n      const mx = (nu.x+nv.x)/2, my = (nu.y+nv.y)/2;\n      const g = e.svgLabel.parentNode;\n      g.setAttribute('transform',`translate(${mx},${my})`);\n    });\n    nodes.forEach(n=>{\n      n.svgGroup.setAttribute('transform',`translate(${n.x},${n.y})`);\n    });\n  }\n\n  function resetState(){\n    inMST = Array(nodeCount).fill(false);\n    key = Array(nodeCount).fill(Infinity);\n    parent = Array(nodeCount).fill(-1);\n    started = false;\n    startNode = null;\n    selectedCount = 0;\n    totalWeightEl.textContent = '0';\n    selectedCountEl.textContent = '0';\n    needCountEl.textContent = (nodeCount-1).toString();\n    vertexTable.innerHTML = '';\n    mstList.innerHTML = '';\n    status.textContent = 'Click a node to choose start (or press Start to pick random)';\n    // reset visuals\n    Object.values(edges).forEach(e=>{\n      e.svgLine.style.stroke = '#7b8da6'; e.svgLine.style.strokeOpacity = 0.35; e.svgLine.style.strokeWidth = 2;\n    });\n    nodes.forEach(n=>{\n      n.svgCircle.setAttribute('fill','#e6eef8');\n      n.svgLabel.style.fill = '#001826';\n    });\n    if(intervalHandle){ clearInterval(intervalHandle); intervalHandle = null; }\n    pauseBtn.disabled = true; playBtn.disabled = false;\n  }\n\n  function setStartNode(i){\n    startNode = i;\n    status.textContent = 'Chosen start node: ' + i;\n    // highlight\n    nodes.forEach(n=> n.svgCircle.setAttribute('stroke','#021428'));\n    nodes[i].svgCircle.setAttribute('stroke','#ffd166');\n    nodes[i].svgCircle.setAttribute('stroke-width','3');\n  }\n\n  // UI bindings\n  nodeCountSlider.addEventListener('input', ()=> { nodeCountVal.textContent = nodeCountSlider.value; });\n  densitySlider.addEventListener('input', ()=> { densityVal.textContent = densitySlider.value + '%'; });\n  genBtn.addEventListener('click', ()=> {\n    const n = parseInt(nodeCountSlider.value);\n    const den = parseInt(densitySlider.value);\n    const wmin = parseInt(minWInput.value)||1;\n    const wmax = parseInt(maxWInput.value)||20;\n    makeGraph(n, den, wmin, wmax);\n  });\n  resetBtn.addEventListener('click', ()=> { resetState(); });\n\n  startBtn.addEventListener('click', ()=> {\n    if(Object.keys(edges).length === 0){ status.textContent = 'Generate a graph first.'; return; }\n    if(started){ status.textContent = 'Prim already started.'; return; }\n    if(startNode===null) startNode = rand(0,nodeCount-1);\n    initPrim(startNode);\n  });\n\n  stepBtn.addEventListener('click', async ()=> {\n    if(!started){ status.textContent = 'Start Prim first.'; return; }\n    if(animLock){ return; }\n    await primStep();\n  });\n\n  playBtn.addEventListener('click', ()=> {\n    if(!started){ status.textContent = 'Start Prim first.'; return; }\n    if(intervalHandle) return;\n    playBtn.disabled = true; pauseBtn.disabled = false;\n    intervalHandle = setInterval(async ()=>{\n      if(animLock) return;\n      if(selectedCount >= nodeCount-1){\n        clearInterval(intervalHandle); intervalHandle=null; playBtn.disabled=false; pauseBtn.disabled=true;\n        status.textContent = 'Done. MST complete.';\n        return;\n      }\n      await primStep();\n    }, Math.max(100, parseInt(speedSlider.value)));\n  });\n\n  pauseBtn.addEventListener('click', ()=> {\n    if(intervalHandle){ clearInterval(intervalHandle); intervalHandle=null; }\n    playBtn.disabled=false; pauseBtn.disabled=true;\n  });\n\n  // Initialize prim\n  function initPrim(s){\n    started = true;\n    inMST = Array(nodeCount).fill(false);\n    key = Array(nodeCount).fill(Infinity);\n    parent = Array(nodeCount).fill(-1);\n    key[s]=0;\n    parent[s]=-1;\n    selectedCount = 0;\n    totalWeightEl.textContent = '0';\n    selectedCountEl.textContent = '0';\n    needCountEl.textContent = (nodeCount-1).toString();\n    status.textContent = 'Prim initialized. Start at node ' + s + '. Use Step/Play.';\n    // visual\n    nodes.forEach(n=> {\n      n.svgCircle.setAttribute('fill','#e6eef8');\n      n.svgCircle.setAttribute('stroke','#021428');\n      n.svgCircle.setAttribute('stroke-width','2');\n      n.svgLabel.style.fill = '#001826';\n    });\n    nodes[s].svgCircle.setAttribute('fill','#e6eef8');\n    nodes[s].svgCircle.setAttribute('stroke','#ffd166');\n    nodes[s].svgCircle.setAttribute('stroke-width','3');\n    updateVertexTable();\n    updateEdgeStyles();\n  }\n\n  // find minimum key vertex not in MST\n  function extractMinIndex(){\n    let min = Infinity, idx = -1;\n    for(let v=0;v<nodeCount;v++){\n      if(!inMST[v] && key[v] < min){\n        min = key[v]; idx = v;\n      }\n    }\n    return idx;\n  }\n\n  // update candidate edges style: for each v not inMST if parent[v]!=-1 highlight edge parent->v as candidate\n  function updateEdgeStyles(){\n    // reset\n    Object.values(edges).forEach(e=>{\n      e.svgLine.style.stroke = '#7b8da6';\n      e.svgLine.style.strokeOpacity = 0.35;\n      e.svgLine.style.strokeWidth = 2;\n    });\n    // candidate edges\n    for(let v=0; v<nodeCount; v++){\n      if(inMST[v]) continue;\n      const p = parent[v];\n      if(p>=0){\n        const k = edgeKey(p,v);\n        const e = edges[k];\n        if(e){\n          e.svgLine.style.stroke = '#60a5fa';\n          e.svgLine.style.strokeOpacity = 1;\n          e.svgLine.style.strokeWidth = 3;\n        }\n      }\n    }\n    // MST edges green\n    Array.from(mstList.children).forEach(li=>{\n      const pair = li.getAttribute('data-edge');\n      if(pair){\n        const [u,v] = pair.split('-').map(x=>parseInt(x));\n        const e = edges[edgeKey(u,v)];\n        if(e){ e.svgLine.style.stroke = '#10b981'; e.svgLine.style.strokeOpacity = 1; e.svgLine.style.strokeWidth = 3.6; }\n      }\n    });\n  }\n\n  // single Prim step\n  async function primStep(){\n    animLock = true;\n    // pick min key\n    const u = extractMinIndex();\n    if(u === -1){\n      status.textContent = 'No reachable vertex remained. MST complete or graph disconnected.';\n      animLock = false;\n      return;\n    }\n    // visually mark selected node as current\n    status.textContent = 'Selecting vertex ' + u + ' with key=' + (key[u]===Infinity?'∞':key[u]);\n    const prevStroke = nodes[u].svgCircle.getAttribute('stroke');\n    nodes[u].svgCircle.setAttribute('stroke','#f59e0b'); nodes[u].svgCircle.setAttribute('stroke-width','3.5');\n    // if it has a parent, highlight the edge chosen\n    if(parent[u] !== -1){\n      const e = edges[edgeKey(parent[u], u)];\n      if(e){\n        // highlight chosen edge (orange) briefly\n        e.svgLine.style.stroke = '#f59e0b';\n        e.svgLine.style.strokeOpacity = 1; e.svgLine.style.strokeWidth = 4;\n        await sleep( Math.max(120, parseInt(speedSlider.value)/3) );\n        // finalize as MST edge (green)\n        const li = document.createElement('div');\n        li.textContent = `${parent[u]} — ${u}  (w=${e.w})`;\n        li.setAttribute('data-edge', `${parent[u]}-${u}`);\n        li.style.padding = '6px';\n        li.style.background = 'rgba(255,255,255,0.02)';\n        li.style.borderRadius = '6px';\n        li.style.fontSize = '13px';\n        mstList.appendChild(li);\n        // update visuals\n        e.svgLine.style.stroke = '#10b981'; e.svgLine.style.strokeWidth = 3.6; e.svgLine.style.strokeOpacity = 1;\n        totalWeightEl.textContent = (parseInt(totalWeightEl.textContent)+e.w).toString();\n        selectedCount++;\n        selectedCountEl.textContent = selectedCount.toString();\n      }\n    } else {\n      // starting node\n      await sleep( Math.max(100, parseInt(speedSlider.value)/6) );\n    }\n\n    // include u in MST\n    inMST[u] = true;\n    nodes[u].svgCircle.setAttribute('fill','#10b981');\n    nodes[u].svgLabel.style.fill = '#021428';\n    nodes[u].svgCircle.setAttribute('stroke','#025a3e');\n    nodes[u].svgCircle.setAttribute('stroke-width','2');\n\n    // relax edges from u\n    // for each neighbor v\n    for(let v=0; v<nodeCount; v++){\n      if(W[u][v] < Infinity && !inMST[v]){\n        if(W[u][v] < key[v]){\n          key[v] = W[u][v];\n          parent[v] = u;\n          // small visual update: highlight the updating edge\n          const e = edges[edgeKey(u,v)];\n          if(e){\n            e.svgLine.style.stroke = '#60a5fa'; e.svgLine.style.strokeOpacity = 1; e.svgLine.style.strokeWidth = 3.2;\n            await sleep( Math.max(50, parseInt(speedSlider.value)/6) );\n          }\n        }\n      }\n    }\n\n    updateVertexTable();\n    updateEdgeStyles();\n\n    // check finish\n    if(selectedCount >= nodeCount-1){\n      status.textContent = 'MST complete!';\n      animLock = false;\n      if(intervalHandle){ clearInterval(intervalHandle); intervalHandle=null; playBtn.disabled=false; pauseBtn.disabled=true; }\n      return;\n    }\n    status.textContent = `Added ${u} to MST. ${selectedCount} edges chosen so far.`;\n    animLock = false;\n  }\n\n  function sleep(ms){ return new Promise(res=>setTimeout(res,ms)); }\n\n  function updateVertexTable(){\n    vertexTable.innerHTML = '';\n    // headers\n    for(let i=0;i<nodeCount;i++){\n      const div = document.createElement('div');\n      div.className='cell'; div.style.fontWeight='700';\n      div.textContent = i;\n      vertexTable.appendChild(div);\n    }\n    for(let i=0;i<nodeCount;i++){\n      const div = document.createElement('div'); div.className='cell';\n      div.textContent = inMST[i] ? 'in MST' : (key[i]===Infinity ? '∞' : key[i]);\n      if(!inMST[i] && key[i]!==Infinity) div.style.color = '#eaf2ff';\n      vertexTable.appendChild(div);\n    }\n    for(let i=0;i<nodeCount;i++){\n      const div = document.createElement('div'); div.className='cell';\n      div.textContent = parent[i]===-1 ? '-' : parent[i];\n      vertexTable.appendChild(div);\n    }\n  }\n\n  // initial random graph\n  makeGraph(nodeCount, parseInt(densitySlider.value), parseInt(minWInput.value), parseInt(maxWInput.value));\n\n  // convenience: space to start step\n  window.addEventListener('keydown', (e)=>{\n    if(e.key === ' '){ e.preventDefault(); if(!started) startBtn.click(); else stepBtn.click(); }\n    if(e.key === 'p'){ playBtn.click(); }\n    if(e.key === 'o'){ pauseBtn.click(); }\n  });\n\n  // Small touch: show disconnected nodes if any (not necessary because we ensured connectivity)\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": false,
  "hasTest": true
}