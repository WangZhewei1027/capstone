{
  "id": "2bde6a9d-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:58.918Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\"/>\n  <title>K-Means Clustering Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\n  <style>\n    :root { --panel-w: 320px; --bg: #f7f9fb; --accent: #2563eb; }\n    html,body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background:var(--bg); color:#0f172a; }\n    .app { display:flex; height:100vh; gap:16px; padding:16px; box-sizing:border-box; }\n    .panel { width:var(--panel-w); background:white; border-radius:8px; box-shadow:0 6px 18px rgba(2,6,23,0.08); padding:14px; box-sizing:border-box; }\n    h1 { font-size:18px; margin:0 0 10px 0; }\n    label { display:block; font-size:13px; margin:8px 0 4px; }\n    .row { display:flex; gap:8px; align-items:center; }\n    input[type=range] { width:100%; }\n    select, input[type=number] { width:100%; padding:6px; border-radius:6px; border:1px solid #e6eef8; }\n    button { background:var(--accent); color:white; border:none; padding:8px 10px; border-radius:6px; cursor:pointer; }\n    button.secondary { background:#e6eef8; color:#0f172a; }\n    button.warn { background:#ef4444; }\n    .controls { display:grid; gap:8px; margin-top:8px; }\n    .canvas-wrap { flex:1; display:flex; flex-direction:column; gap:10px; }\n    canvas { background:linear-gradient(180deg,#ffffff,#f1f5f9); border-radius:8px; box-shadow:inset 0 1px 0 rgba(255,255,255,.6), 0 6px 18px rgba(2,6,23,0.06); cursor:crosshair; }\n    .help { font-size:13px; color:#334155; margin-top:8px; }\n    .metrics { margin-top:8px; font-size:13px; color:#0f172a; display:flex; gap:12px; flex-wrap:wrap;}\n    .metric { background:#eef2ff; padding:8px 10px; border-radius:6px; font-weight:600; color:#0f172a; }\n    .small { font-size:12px; color:#475569; }\n    .legend { display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; }\n    .legend-item { display:flex; gap:6px; align-items:center; font-size:13px; }\n    .color-dot { width:16px; height:16px; border-radius:50%; border:1px solid rgba(0,0,0,0.08); }\n    .footer { margin-top:8px; font-size:12px; color:#475569; }\n    .top-controls { display:flex; gap:8px; align-items:center; margin-bottom:8px; }\n    .row-gap { display:flex; gap:8px; }\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"panel\">\n      <h1>K-Means Clustering â€” Interactive Demo</h1>\n      <div class=\"top-controls\">\n        <label style=\"margin:0; flex:1;\">\n          K: <span id=\"kValue\">3</span>\n          <input id=\"kSlider\" type=\"range\" min=\"1\" max=\"12\" value=\"3\"/>\n        </label>\n      </div>\n\n      <label>Initialization</label>\n      <select id=\"initMethod\">\n        <option value=\"random\">Random points</option>\n        <option value=\"kpp\">K-Means++</option>\n      </select>\n\n      <div style=\"margin-top:8px;\">\n        <div class=\"row-gap\">\n          <button id=\"initBtn\">Init</button>\n          <button id=\"stepBtn\" class=\"secondary\">Step</button>\n          <button id=\"runBtn\" class=\"secondary\">Run</button>\n          <button id=\"stopBtn\" class=\"secondary\" disabled>Stop</button>\n        </div>\n      </div>\n\n      <div class=\"controls\">\n        <div class=\"row\">\n          <button id=\"genBtn\" class=\"secondary\">Generate Blobs</button>\n          <button id=\"clearBtn\" class=\"warn\">Clear</button>\n        </div>\n\n        <label>Algorithm settings</label>\n        <div class=\"row\">\n          <label style=\"flex:1;\">\n            Max iterations\n            <input type=\"number\" id=\"maxIter\" value=\"100\" min=\"1\"/>\n          </label>\n          <label style=\"width:90px;\">\n            Tol\n            <input type=\"number\" id=\"tol\" value=\"0.001\" step=\"0.001\"/>\n          </label>\n        </div>\n\n        <label>Interaction</label>\n        <div class=\"help\">\n          - Left-click on canvas to add a point. Drag points to move them.<br/>\n          - Shift+click to remove a point. Right-click is disabled.<br/>\n          - You can re-initialize centroids anytime.\n        </div>\n\n        <div class=\"metrics\" style=\"margin-top:6px;\">\n          <div class=\"metric\">Iter: <span id=\"iter\">0</span></div>\n          <div class=\"metric\">SSE: <span id=\"sse\">0</span></div>\n          <div class=\"metric\">Points: <span id=\"nPoints\">0</span></div>\n        </div>\n\n        <label>Legend</label>\n        <div id=\"legend\" class=\"legend\"></div>\n\n        <div class=\"footer small\">\n          Explanation: K-Means partitions points into K clusters by alternating assignment (each point -> nearest centroid)\n          and update (move centroids to cluster means). K-Means++ chooses starting centroids to improve convergence.\n        </div>\n      </div>\n    </div>\n\n    <div class=\"canvas-wrap\">\n      <canvas id=\"canvas\"></canvas>\n    </div>\n  </div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  const dpr = window.devicePixelRatio || 1;\n\n  function resizeCanvas() {\n    const rect = canvas.getBoundingClientRect();\n    canvas.width = rect.width * dpr;\n    canvas.height = rect.height * dpr;\n    ctx.setTransform(dpr,0,0,dpr,0,0);\n    draw();\n  }\n\n  // create a responsive canvas area\n  function setCanvasSize() {\n    const wrap = document.querySelector('.canvas-wrap');\n    // use remaining width and height\n    const rect = wrap.getBoundingClientRect();\n    const width = window.innerWidth - 320 - 56; // panel width + paddings approx\n    const height = window.innerHeight - 56;\n    canvas.style.width = Math.max(400, width) + 'px';\n    canvas.style.height = Math.max(300, height) + 'px';\n    resizeCanvas();\n  }\n  window.addEventListener('resize', setCanvasSize);\n  setCanvasSize();\n\n  // Data structures\n  let points = []; // {x,y,cluster,id}\n  let centroids = []; // {x,y,id}\n  let K = parseInt(document.getElementById('kSlider').value,10);\n  let initMethod = document.getElementById('initMethod').value;\n  let maxIter = parseInt(document.getElementById('maxIter').value,10);\n  let tol = parseFloat(document.getElementById('tol').value);\n  let iter = 0;\n  let running = false;\n  let animHandle = null;\n\n  const colorFor = (i,opacity=1) => {\n    const hue = (i*47) % 360; // spaced hues\n    return `hsla(${hue} 70% 45% / ${opacity})`.replace(/ /g,'');\n  };\n\n  // Utilities\n  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }\n  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }\n  function rand(min,max){return Math.random()*(max-min)+min;}\n  function updateUI(){\n    document.getElementById('kValue').textContent = K;\n    document.getElementById('iter').textContent = iter;\n    document.getElementById('nPoints').textContent = points.length;\n    document.getElementById('sse').textContent = computeSSE().toFixed(2);\n    updateLegend();\n    document.getElementById('stopBtn').disabled = !running;\n  }\n\n  function updateLegend(){\n    const legend = document.getElementById('legend');\n    legend.innerHTML = '';\n    for(let i=0;i<K;i++){\n      const div = document.createElement('div');\n      div.className='legend-item';\n      const dot = document.createElement('div');\n      dot.className='color-dot';\n      dot.style.background = colorFor(i);\n      dot.title = `Cluster ${i}`;\n      div.appendChild(dot);\n      const t = document.createElement('div');\n      t.textContent = `C${i}`;\n      div.appendChild(t);\n      legend.appendChild(div);\n    }\n  }\n\n  // Drawing\n  function draw(){\n    const w = canvas.clientWidth;\n    const h = canvas.clientHeight;\n    ctx.clearRect(0,0,w,h);\n\n    // optional background grid\n    const gridSize = 40;\n    ctx.save();\n    ctx.globalAlpha = 0.06;\n    ctx.strokeStyle = '#0f172a';\n    for(let x=0;x<w;x+=gridSize){ ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,h); ctx.stroke(); }\n    for(let y=0;y<h;y+=gridSize){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(w,y+0.5); ctx.stroke(); }\n    ctx.restore();\n\n    // draw points\n    for(const p of points){\n      const col = p.cluster != null ? colorFor(p.cluster,0.95) : 'rgba(100,116,139,0.75)';\n      ctx.beginPath();\n      ctx.fillStyle = col;\n      ctx.strokeStyle = '#ffffff';\n      ctx.lineWidth = 1;\n      ctx.arc(p.x, p.y, 6, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n    }\n\n    // draw centroids and connecting lines\n    for(let i=0;i<centroids.length;i++){\n      const c = centroids[i];\n      // lines from centroid to its points (faint, optional)\n      ctx.save();\n      ctx.globalAlpha = 0.06;\n      ctx.strokeStyle = colorFor(i);\n      ctx.beginPath();\n      for(const p of points){ if(p.cluster===i){ ctx.moveTo(c.x,c.y); ctx.lineTo(p.x,p.y); } }\n      ctx.stroke();\n      ctx.restore();\n\n      // centroid\n      ctx.beginPath();\n      ctx.fillStyle = colorFor(i,1);\n      ctx.strokeStyle = '#0b1220';\n      ctx.lineWidth = 2;\n      ctx.arc(c.x, c.y, 10, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n\n      // label\n      ctx.fillStyle = '#fff';\n      ctx.font = \"11px sans-serif\";\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText('C'+i, c.x, c.y);\n    }\n  }\n\n  // Algorithm: assign and update\n  function assignPoints(){\n    let changed = false;\n    for(const p of points){\n      let best = null;\n      let bestD = Infinity;\n      for(let i=0;i<centroids.length;i++){\n        const c = centroids[i];\n        const d = dist2(p,c);\n        if(d < bestD){ bestD = d; best = i; }\n      }\n      if(p.cluster !== best){\n        changed = true;\n        p.cluster = best;\n      }\n    }\n    return changed;\n  }\n\n  function updateCentroids(){\n    const sums = Array.from({length:K},()=>({x:0,y:0,n:0}));\n    for(const p of points){\n      if(p.cluster != null){\n        sums[p.cluster].x += p.x;\n        sums[p.cluster].y += p.y;\n        sums[p.cluster].n += 1;\n      }\n    }\n    let moved = 0;\n    for(let i=0;i<K;i++){\n      const s = sums[i];\n      const c = centroids[i];\n      if(s.n === 0){\n        // empty cluster: reinitialize to a random point or random location\n        const p = points.length ? points[Math.floor(Math.random()*points.length)] : {x:rand(20,canvas.clientWidth-20),y:rand(20,canvas.clientHeight-20)};\n        const dx = c.x - p.x;\n        const dy = c.y - p.y;\n        moved += Math.sqrt(dx*dx+dy*dy);\n        c.x = p.x + rand(-10,10);\n        c.y = p.y + rand(-10,10);\n      } else {\n        const nx = s.x/s.n;\n        const ny = s.y/s.n;\n        const dx = c.x - nx;\n        const dy = c.y - ny;\n        moved += Math.sqrt(dx*dx+dy*dy);\n        c.x = nx;\n        c.y = ny;\n      }\n    }\n    return moved;\n  }\n\n  function computeSSE(){\n    let sum = 0;\n    for(const p of points){\n      if(p.cluster!=null){\n        const c = centroids[p.cluster];\n        sum += dist2(p,c);\n      }\n    }\n    return sum;\n  }\n\n  // Initialization\n  function initCentroids(method = 'random'){\n    K = clamp(K,1,Math.max(1,K));\n    centroids = [];\n    if(points.length === 0){\n      // no points: place centroids uniformly\n      for(let i=0;i<K;i++){\n        centroids.push({x: rand(40, canvas.clientWidth-40), y: rand(40, canvas.clientHeight-40), id:i});\n      }\n    } else {\n      if(method === 'kpp'){\n        // k-means++ initialization using squared distances\n        const pts = points.slice();\n        // first centroid random\n        const first = pts[Math.floor(Math.random()*pts.length)];\n        centroids.push({x:first.x, y:first.y, id:0});\n        while(centroids.length < K){\n          // compute distance squared to nearest chosen centroid\n          const d2 = pts.map(p => {\n            let best = Infinity;\n            for(const c of centroids){\n              const dx = p.x - c.x, dy = p.y - c.y;\n              const dd = dx*dx+dy*dy;\n              if(dd < best) best = dd;\n            }\n            return best;\n          });\n          // choose weighted by d2\n          const sum = d2.reduce((a,b)=>a+b,0);\n          if(sum === 0){\n            // all identical points, pick random\n            const p = pts[Math.floor(Math.random()*pts.length)];\n            centroids.push({x:p.x,y:p.y,id:centroids.length});\n            continue;\n          }\n          let r = Math.random()*sum;\n          let idx = 0;\n          while(r > d2[idx]) { r -= d2[idx]; idx++; if(idx>=d2.length) break; }\n          const chosen = pts[idx] || pts[pts.length-1];\n          centroids.push({x:chosen.x, y:chosen.y, id:centroids.length});\n        }\n      } else {\n        // random selection from points (without replacement if possible)\n        const chosen = new Set();\n        const n = Math.min(points.length, K);\n        while(centroids.length < n){\n          const p = points[Math.floor(Math.random()*points.length)];\n          if(chosen.has(p)) continue;\n          chosen.add(p);\n          centroids.push({x:p.x, y:p.y, id:centroids.length});\n        }\n        while(centroids.length < K){\n          centroids.push({x: rand(40, canvas.clientWidth-40), y: rand(40, canvas.clientHeight-40), id:centroids.length});\n        }\n      }\n    }\n    // clear assignments\n    for(const p of points) p.cluster = null;\n    iter = 0;\n    updateUI();\n    draw();\n  }\n\n  // One iteration: assign then update\n  function iterateOnce(){\n    const changedAssignments = assignPoints();\n    const moved = updateCentroids();\n    iter += 1;\n    updateUI();\n    draw();\n    return {changedAssignments, moved};\n  }\n\n  // Run until convergence or maxIter\n  function runUntilConverged(){\n    running = true;\n    document.getElementById('stopBtn').disabled = false;\n    const max = parseInt(document.getElementById('maxIter').value,10) || 100;\n    const tolerance = parseFloat(document.getElementById('tol').value) || 1e-3;\n    function step(){\n      if(!running) return;\n      const {changedAssignments, moved} = iterateOnce();\n      if((!changedAssignments && moved <= tolerance) || iter >= max){\n        running = false;\n        updateUI();\n        return;\n      }\n      // schedule next\n      animHandle = requestAnimationFrame(step);\n    }\n    animHandle = requestAnimationFrame(step);\n  }\n\n  // Event handlers for UI\n  document.getElementById('kSlider').addEventListener('input', (e)=>{\n    K = parseInt(e.target.value,10);\n    document.getElementById('kValue').textContent = K;\n    updateUI();\n  });\n  document.getElementById('initMethod').addEventListener('change', (e)=>{ initMethod = e.target.value; });\n  document.getElementById('initBtn').addEventListener('click', ()=>{ initCentroids(initMethod); });\n  document.getElementById('stepBtn').addEventListener('click', ()=>{ iterateOnce(); });\n  document.getElementById('runBtn').addEventListener('click', ()=>{\n    if(points.length === 0) return;\n    // ensure centroids initialized\n    if(centroids.length !== K) initCentroids(initMethod);\n    running = true;\n    runUntilConverged();\n  });\n  document.getElementById('stopBtn').addEventListener('click', ()=>{\n    running = false;\n    if(animHandle) cancelAnimationFrame(animHandle);\n    updateUI();\n  });\n  document.getElementById('maxIter').addEventListener('change', ()=>{ maxIter = parseInt(document.getElementById('maxIter').value,10); });\n  document.getElementById('tol').addEventListener('change', ()=>{ tol = parseFloat(document.getElementById('tol').value); });\n\n  document.getElementById('clearBtn').addEventListener('click', ()=>{\n    points = [];\n    centroids = [];\n    iter = 0;\n    running = false;\n    updateUI();\n    draw();\n  });\n\n  document.getElementById('genBtn').addEventListener('click', ()=>{\n    // generate random blobs\n    const blobCount = Math.max(2, Math.min(6, K));\n    const total = 80;\n    points = [];\n    for(let i=0;i<blobCount;i++){\n      const cx = rand(60, canvas.clientWidth-60);\n      const cy = rand(60, canvas.clientHeight-60);\n      const r = rand(20, 80);\n      const n = Math.floor(total / blobCount) + (Math.random() < 0.5 ? 1 : 0);\n      for(let j=0;j<n;j++){\n        const angle = Math.random()*Math.PI*2;\n        const rad = Math.sqrt(Math.random()) * r;\n        const x = cx + Math.cos(angle)*rad + rand(-8,8);\n        const y = cy + Math.sin(angle)*rad + rand(-8,8);\n        points.push({x: clamp(x,8,canvas.clientWidth-8), y: clamp(y,8,canvas.clientHeight-8), cluster:null, id:points.length});\n      }\n    }\n    centroids = [];\n    iter = 0;\n    updateUI();\n    draw();\n  });\n\n  // Canvas interactions: add point, remove shift+click, drag points\n  let dragging = null;\n  let dragType = null; // 'point' or 'centroid'\n  canvas.addEventListener('contextmenu', (e)=> e.preventDefault());\n\n  function getMouse(e){\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left);\n    const y = (e.clientY - rect.top);\n    return {x,y};\n  }\n\n  function findNearbyPoint(pos, radius=10){\n    for(const p of points){\n      const dx = p.x - pos.x, dy = p.y - pos.y;\n      if(dx*dx+dy*dy <= radius*radius) return p;\n    }\n    return null;\n  }\n  function findNearbyCentroid(pos, radius=12){\n    for(const c of centroids){\n      const dx = c.x - pos.x, dy = c.y - pos.y;\n      if(dx*dx+dy*dy <= radius*radius) return c;\n    }\n    return null;\n  }\n\n  canvas.addEventListener('mousedown', (e)=>{\n    const pos = getMouse(e);\n    const shift = e.shiftKey;\n    if(shift){\n      // remove nearby point\n      const p = findNearbyPoint(pos, 12);\n      if(p){\n        points = points.filter(q=>q!==p);\n        updateUI();\n        draw();\n        return;\n      }\n    }\n\n    // try dragging point first\n    const p = findNearbyPoint(pos, 10);\n    if(p && e.button === 0){\n      dragging = p;\n      dragType = 'point';\n      return;\n    }\n    // try dragging centroid if ctrl/alt pressed\n    if((e.ctrlKey || e.altKey) && centroids.length){\n      const c = findNearbyCentroid(pos, 12);\n      if(c){\n        dragging = c;\n        dragType = 'centroid';\n        return;\n      }\n    }\n\n    // otherwise add a new point\n    if(e.button === 0){\n      const newP = {x:pos.x, y:pos.y, cluster:null, id:points.length};\n      points.push(newP);\n      updateUI();\n      draw();\n    }\n  });\n\n  window.addEventListener('mousemove', (e)=>{\n    if(!dragging) return;\n    const pos = getMouse(e);\n    dragging.x = clamp(pos.x, 6, canvas.clientWidth-6);\n    dragging.y = clamp(pos.y, 6, canvas.clientHeight-6);\n    // if dragging a point, clear cluster to let reassignment happen manually\n    if(dragType === 'point') dragging.cluster = null;\n    draw();\n    updateUI();\n  });\n\n  window.addEventListener('mouseup', (e)=>{\n    if(dragging){\n      dragging = null;\n      dragType = null;\n      updateUI();\n      draw();\n    }\n  });\n\n  // initialize with some default blobs\n  document.getElementById('genBtn').click();\n\n  // auto-initialize centroids initially\n  initCentroids(initMethod);\n\n  // expose some debug for console (optional)\n  window._kmeans = {\n    getPoints: ()=>points,\n    getCentroids: ()=>centroids,\n    iterate: iterateOnce,\n    init: initCentroids\n  };\n\n  // keep UI updated\n  updateUI();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": false,
  "hasTest": true
}