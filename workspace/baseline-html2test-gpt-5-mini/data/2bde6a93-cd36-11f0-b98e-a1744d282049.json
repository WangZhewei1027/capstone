{
  "id": "2bde6a93-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:32.914Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Fibonacci Sequence",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Fibonacci Sequence Explorer</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724; --card:#0b1220; --muted:#9aa4b2; --accent:#4fd1c5; --accent2:#7c3aed;\n      --glass: rgba(255,255,255,0.03);\n      color-scheme: dark;\n    }\n    *{box-sizing:border-box}\n    body{\n      margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;\n      background: linear-gradient(180deg,#071021 0%, #071425 60%); color:#e6eef8; min-height:100vh; padding:24px;\n    }\n    .container{max-width:1100px;margin:0 auto;}\n    header{display:flex;gap:16px;align-items:center;margin-bottom:18px}\n    h1{font-size:20px;margin:0}\n    p.lead{margin:0;color:var(--muted);font-size:13px}\n    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:16px;border-radius:12px; box-shadow: 0 6px 24px rgba(2,6,23,0.7); margin-bottom:16px;}\n    .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center}\n    label{font-size:13px;color:var(--muted)}\n    input[type=\"number\"]{width:110px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}\n    select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}\n    button{padding:9px 12px;border-radius:10px;border:0;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#032023;cursor:pointer;font-weight:600}\n    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.05);color:var(--muted);font-weight:600}\n    .row{display:flex;gap:16px;align-items:flex-start}\n    .col{flex:1}\n    .small{font-size:13px;color:var(--muted)}\n    .output{padding:12px;border-radius:10px;background:var(--glass);margin-top:12px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace; font-size:13px; white-space:pre-wrap; max-height:320px; overflow:auto;}\n    canvas{width:100%;height:260px;border-radius:8px;display:block}\n    .meta{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}\n    .meta .item{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;font-size:13px;min-width:120px}\n    .legend{display:flex;gap:8px;align-items:center}\n    .dot{width:12px;height:12px;border-radius:3px}\n    .muted{color:var(--muted)}\n    footer{margin-top:18px;color:var(--muted);font-size:13px}\n    a.inline{color:var(--accent);text-decoration:none}\n    @media(max-width:720px){ .row{flex-direction:column} canvas{height:200px} }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <header>\n      <div>\n        <h1>Fibonacci Sequence Explorer</h1>\n        <p class=\"lead\">Generate Fibonacci numbers, try different algorithms, and visualize growth and ratios.</p>\n      </div>\n    </header>\n\n    <div class=\"card\">\n      <div class=\"controls\">\n        <label>\n          n (terms or index):\n          <input id=\"input-n\" type=\"number\" min=\"0\" value=\"20\" />\n        </label>\n\n        <label>\n          Mode:\n          <select id=\"mode\">\n            <option value=\"sequence\">Generate sequence (0..n)</option>\n            <option value=\"nth\">Compute F(n) only</option>\n          </select>\n        </label>\n\n        <label>\n          Algorithm:\n          <select id=\"algo\">\n            <option value=\"iterative\">Iterative (fast, BigInt)</option>\n            <option value=\"fast-doubling\">Fast doubling (log n, BigInt)</option>\n            <option value=\"recursive-naive\">Recursive naive (very slow)</option>\n            <option value=\"recursive-memo\">Recursive with memo (fast for small/medium n)</option>\n          </select>\n        </label>\n\n        <button id=\"run\">Run</button>\n        <button id=\"copy\" class=\"secondary\">Copy Result</button>\n      </div>\n\n      <div class=\"small\" style=\"margin-top:8px\">\n        Note: Results use BigInt internally for exact integer results. Recursive naive is limited to n ≤ 40 to prevent freezing.\n      </div>\n\n      <div class=\"row\" style=\"margin-top:12px\">\n        <div class=\"col\">\n          <div class=\"card\" style=\"padding:12px\">\n            <div class=\"small\">Result</div>\n            <div id=\"result\" class=\"output\">Press \"Run\" to compute.</div>\n\n            <div class=\"meta\" id=\"meta\">\n              <!-- filled by JS -->\n            </div>\n          </div>\n        </div>\n\n        <div style=\"width:420px;max-width:100%\">\n          <div class=\"card\" style=\"padding:12px\">\n            <div class=\"small\">Visualization</div>\n            <canvas id=\"chart\" width=\"800\" height=\"400\"></canvas>\n            <div style=\"display:flex;gap:10px;margin-top:10px;align-items:center\">\n              <label class=\"small\" style=\"margin:0\">Log scale</label>\n              <input id=\"logscale\" type=\"checkbox\" />\n              <div style=\"flex:1\"></div>\n              <div class=\"legend small muted\">\n                <div class=\"dot\" style=\"background:linear-gradient(90deg,var(--accent),var(--accent2))\"></div>\n                Fibonacci values (bars)\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <details style=\"margin-top:12px;color:var(--muted)\">\n        <summary style=\"cursor:pointer\">About algorithms</summary>\n        <div style=\"margin-top:8px\">\n          <ul>\n            <li><strong>Iterative:</strong> Simple loop using BigInt, O(n).</li>\n            <li><strong>Fast doubling:</strong> Uses binary exponentiation-like recurrence to compute F(n) in O(log n) multiplications.</li>\n            <li><strong>Recursive naive:</strong> Direct recurrence F(n)=F(n-1)+F(n-2), exponential time, only for tiny n.</li>\n            <li><strong>Recursive with memo:</strong> Caches results to make recursion linear time and avoid redundant work.</li>\n          </ul>\n        </div>\n      </details>\n    </div>\n\n    <footer>\n      Built-in demonstration — exact integer results for large n (BigInt). Try n up to a few thousand (fast-doubling recommended).\n    </footer>\n  </div>\n\n  <script>\n    // Utility: quick BigInt conversion and formatting with commas\n    function toBigInt(n){ return typeof n === 'bigint' ? n : BigInt(n); }\n    function fmtBigInt(x){\n      let s = x.toString();\n      let sign = '';\n      if (s[0] === '-') { sign = '-'; s = s.slice(1); }\n      let out = '';\n      for (let i = 0, len = s.length; i < len; i++){\n        let pos = len - i;\n        out = s[i] + out;\n        if ((pos-1) % 3 === 0 && i !== len-1) out = ',' + out;\n      }\n      return sign + out;\n    }\n\n    // Iterative O(n) using BigInt\n    function fibIterative(n){\n      n = Number(n);\n      if (n === 0) return 0n;\n      if (n === 1) return 1n;\n      let a = 0n, b = 1n;\n      for (let i = 2; i <= n; i++){\n        let c = a + b;\n        a = b;\n        b = c;\n      }\n      return b;\n    }\n\n    // Fast doubling algorithm, returns [F(n), F(n+1)]\n    function fibFastDoublingPair(n){\n      // n as Number or BigInt\n      n = BigInt(n);\n      function rec(k){\n        if (k === 0n) return [0n, 1n];\n        const [fk, fk1] = rec(k >> 1n);\n        const c = fk * ((fk1 << 1n) - fk); // F(2k) = Fk*(2*Fk+1 - Fk)\n        const d = fk*fk + fk1*fk1; // F(2k+1) = Fk^2 + Fk+1^2\n        if ((k & 1n) === 0n) {\n          return [c, d];\n        } else {\n          return [d, c + d];\n        }\n      }\n      return rec(n);\n    }\n\n    function fibFastDoubling(n){\n      return fibFastDoublingPair(n)[0];\n    }\n\n    // Recursive naive (extremely slow for n > ~40)\n    function fibRecursiveNaive(n){\n      n = Number(n);\n      if (n <= 1) return BigInt(n);\n      return fibRecursiveNaive(n-1) + fibRecursiveNaive(n-2);\n    }\n\n    // Recursive with memo (top-down)\n    function fibMemo(n, memo = new Map()){\n      n = Number(n);\n      if (n <= 1) return 1n * BigInt(n);\n      if (memo.has(n)) return memo.get(n);\n      const res = fibMemo(n-1, memo) + fibMemo(n-2, memo);\n      memo.set(n, res);\n      return res;\n    }\n\n    // Generate sequence 0..n inclusive using chosen method for each term efficiently\n    function generateSequence(n, method){\n      n = Number(n);\n      const seq = [];\n      if (method === 'iterative'){\n        let a = 0n, b = 1n;\n        if (n >= 0) seq.push(a);\n        for (let i = 1; i <= n; i++){\n          seq.push(b);\n          const c = a + b;\n          a = b; b = c;\n        }\n        return seq;\n      }\n      if (method === 'fast-doubling'){\n        for (let i = 0; i <= n; i++){\n          seq.push(fibFastDoubling(i));\n        }\n        return seq;\n      }\n      if (method === 'recursive-naive'){\n        for (let i = 0; i <= n; i++){\n          seq.push(fibRecursiveNaive(i));\n        }\n        return seq;\n      }\n      if (method === 'recursive-memo'){\n        const memo = new Map();\n        for (let i = 0; i <= n; i++){\n          seq.push(fibMemo(i, memo));\n        }\n        return seq;\n      }\n      // fallback\n      for (let i = 0; i <= n; i++) seq.push(fibFastDoubling(i));\n      return seq;\n    }\n\n    // DOM elements\n    const inputN = document.getElementById('input-n');\n    const algo = document.getElementById('algo');\n    const mode = document.getElementById('mode');\n    const runBtn = document.getElementById('run');\n    const resultNode = document.getElementById('result');\n    const metaNode = document.getElementById('meta');\n    const copyBtn = document.getElementById('copy');\n    const chart = document.getElementById('chart');\n    const ctx = chart.getContext('2d');\n    const logscale = document.getElementById('logscale');\n\n    function clearCanvas(){\n      ctx.clearRect(0,0,chart.width,chart.height);\n      // background\n      ctx.fillStyle = '#071025';\n      ctx.fillRect(0,0,chart.width,chart.height);\n    }\n\n    function drawBars(values, opts = {}){\n      // values: array of BigInt\n      const w = chart.width = chart.clientWidth * devicePixelRatio;\n      const h = chart.height = chart.clientHeight * devicePixelRatio;\n      clearCanvas();\n      if (values.length === 0) return;\n      // convert to numbers for plotting; use log scale optionally\n      const useLog = opts.log;\n      const nums = values.map(v => {\n        let s = v < 0n ? -1 : 1;\n        let abs = v >= 0n ? v : -v;\n        // convert to Number for plotting; may overflow for very large BigInt, so use log10\n        if (abs <= 1n << 52n) {\n          return s * Number(abs);\n        } else {\n          // approximate using digits count: log10(abs)\n          const digits = abs.toString().length;\n          // return something proportional to digits (monotonic)\n          return s * Math.pow(10, digits - 1);\n        }\n      });\n      let plotVals = nums.slice();\n      if (useLog){\n        plotVals = nums.map(x => Math.log10(Math.max(1, Math.abs(x))) * Math.sign(x));\n      }\n      const maxVal = Math.max(...plotVals.map(Math.abs)) || 1;\n      const barW = Math.max(2, Math.floor(w / values.length));\n      const gap = Math.max(1, Math.floor(barW * 0.15));\n      const usableBarW = barW - gap;\n      ctx.save();\n      // Draw grid lines\n      ctx.strokeStyle = 'rgba(255,255,255,0.03)';\n      ctx.lineWidth = 1 * devicePixelRatio;\n      ctx.beginPath();\n      for (let i = 0; i <= 4; i++){\n        const y = (i/4) * h;\n        ctx.moveTo(0, y + 0.5);\n        ctx.lineTo(w, y + 0.5);\n      }\n      ctx.stroke();\n\n      // Bars\n      for (let i = 0; i < plotVals.length; i++){\n        const val = plotVals[i];\n        const norm = Math.abs(val) / maxVal;\n        const barH = Math.max(1, Math.floor(norm * (h * 0.9)));\n        const x = i * barW + gap/2;\n        const y = h - barH;\n        // gradient fill\n        const g = ctx.createLinearGradient(x, y, x + usableBarW, y + barH);\n        g.addColorStop(0, '#4fd1c5');\n        g.addColorStop(1, '#7c3aed');\n        ctx.fillStyle = g;\n        ctx.fillRect(x + 1, y, usableBarW - 2, barH);\n      }\n\n      // X labels: show 0, n/2, n\n      ctx.fillStyle = '#9aa4b2';\n      ctx.font = `${12 * devicePixelRatio}px Inter, Arial`;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      const labels = [0, Math.floor((values.length-1)/2), values.length-1];\n      labels.forEach(i => {\n        const x = (i * barW) + barW/2;\n        ctx.fillText(String(i), x, h - 14 * devicePixelRatio);\n      });\n      ctx.restore();\n    }\n\n    // event handlers\n    runBtn.addEventListener('click', run);\n    copyBtn.addEventListener('click', () => {\n      const txt = resultNode.innerText;\n      navigator.clipboard?.writeText(txt).then(()=>{\n        copyBtn.textContent = 'Copied ✓';\n        setTimeout(()=>copyBtn.textContent = 'Copy Result', 1200);\n      }).catch(()=>{ copyBtn.textContent = 'Copy failed'; setTimeout(()=>copyBtn.textContent = 'Copy Result', 1200); });\n    });\n\n    // Allow Enter to run\n    inputN.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') run(); });\n\n    function run(){\n      const nRaw = inputN.value;\n      if (nRaw === '' || isNaN(Number(nRaw))) {\n        resultNode.textContent = 'Please enter a valid integer n (≥ 0).';\n        return;\n      }\n      let n = Number(nRaw);\n      if (!Number.isFinite(n) || n < 0) {\n        resultNode.textContent = 'Please enter a non-negative integer n.';\n        return;\n      }\n      // clamp n\n      if (n > 10000000) { resultNode.textContent = 'n too large.'; return; }\n\n      const chosenMode = mode.value;\n      const chosenAlgo = algo.value;\n\n      // safety: recursive naive limited\n      if (chosenAlgo === 'recursive-naive' && n > 40){\n        resultNode.textContent = 'Recursive naive algorithm is too slow for n > 40. Choose another algorithm or smaller n.';\n        return;\n      }\n\n      // computation\n      const t0 = performance.now();\n      try {\n        if (chosenMode === 'nth'){\n          // compute F(n) only\n          let value;\n          if (chosenAlgo === 'iterative') value = fibIterative(n);\n          else if (chosenAlgo === 'fast-doubling') value = fibFastDoubling(n);\n          else if (chosenAlgo === 'recursive-naive') value = fibRecursiveNaive(n);\n          else if (chosenAlgo === 'recursive-memo') value = fibMemo(n);\n          else value = fibFastDoubling(n);\n\n          const t1 = performance.now();\n          const timeMs = (t1 - t0).toFixed(3);\n          resultNode.textContent = `F(${n}) = ${fmtBigInt(value)}\\n\\n(Exact integer using BigInt)\\nComputed in ${timeMs} ms using ${chosenAlgo}.`;\n\n          // meta\n          metaNode.innerHTML = '';\n          const metaItems = [\n            ['Index', String(n)],\n            ['Digits', String(value.toString().length)],\n            ['Time', `${timeMs} ms`]\n          ];\n          if (n >= 1){\n            // compute ratio F(n)/F(n-1)\n            const prev = (chosenAlgo === 'fast-doubling') ? fibFastDoubling(n-1) :\n                         (chosenAlgo === 'iterative') ? fibIterative(n-1) :\n                         (chosenAlgo === 'recursive-naive' || chosenAlgo === 'recursive-memo') ? (n>0 ? fibFastDoubling(n-1) : 0n) : fibFastDoubling(n-1);\n\n            const ratio = Number(value) && Number(prev) && Math.abs(Number(value)) < 1e307 && Math.abs(Number(prev)) < 1e307\n                          ? (Number(value)/Number(prev))\n                          : null;\n            if (ratio !== null && isFinite(ratio)) metaItems.push(['Ratio F(n)/F(n-1)', ratio.toFixed(12)]);\n            else {\n              // approximate with high precision using string-based division? We'll approximate using decimal digits:\n              // For large n, ratio ≈ phi ≈ 1.618...\n              metaItems.push(['Ratio F(n)/F(n-1)', '≈ φ (golden ratio)']);\n            }\n          }\n          metaItems.forEach(([k,v])=>{\n            const el = document.createElement('div');\n            el.className = 'item';\n            el.innerHTML = `<div style=\"font-size:12px;color:var(--muted)\">${k}</div><div style=\"margin-top:4px\">${v}</div>`;\n            metaNode.appendChild(el);\n          });\n\n          // visualization: show a small range around n (e.g., last 20 terms)\n          const maxPlot = Math.min(80, Math.max(10, n+1));\n          const start = Math.max(0, n - (maxPlot-1));\n          const seq = [];\n          for (let i = start; i <= n; i++) seq.push(fibFastDoubling(i));\n          drawBars(seq, {log: logscale.checked});\n        } else {\n          // sequence mode: generate 0..n\n          const tStartGen = performance.now();\n          const seq = generateSequence(n, chosenAlgo);\n          const tAfter = performance.now();\n          const timeMs = (tAfter - tStartGen).toFixed(3);\n\n          // display first 200 terms in full, otherwise show summary\n          let display;\n          if (seq.length <= 200){\n            display = seq.map((v,i)=>`F(${i}) = ${fmtBigInt(v)}`).join('\\n');\n          } else {\n            display = `Showing first 100 and last 100 of ${seq.length} terms:\\n\\n`;\n            const first = seq.slice(0,100).map((v,i)=>`F(${i}) = ${fmtBigInt(v)}`).join('\\n');\n            const last = seq.slice(seq.length-100).map((v,i)=>`F(${seq.length-100+i}) = ${fmtBigInt(v)}`).join('\\n');\n            display += first + '\\n\\n...\\n\\n' + last;\n          }\n          resultNode.textContent = display + `\\n\\nComputed in ${timeMs} ms using ${chosenAlgo}.`;\n\n          // meta\n          metaNode.innerHTML = '';\n          const last = seq[seq.length-1];\n          const metaItems = [\n            ['Terms', String(seq.length)],\n            ['Last term digits', String(last.toString().length)],\n            ['Time', `${timeMs} ms`]\n          ];\n          metaItems.forEach(([k,v])=>{\n            const el = document.createElement('div');\n            el.className = 'item';\n            el.innerHTML = `<div style=\"font-size:12px;color:var(--muted)\">${k}</div><div style=\"margin-top:4px\">${v}</div>`;\n            metaNode.appendChild(el);\n          });\n\n          drawBars(seq, {log: logscale.checked});\n        }\n      } catch (err) {\n        resultNode.textContent = 'Error during computation: ' + (err && err.message ? err.message : String(err));\n      }\n    }\n\n    // Initial draw\n    clearCanvas();\n    ctx.fillStyle = '#9aa4b2';\n    ctx.font = `${14 * devicePixelRatio}px Inter, Arial`;\n    ctx.fillText('Visualization will appear here after running.', 12 * devicePixelRatio, 24 * devicePixelRatio);\n\n    // Redraw when resizing\n    let resizeTimer;\n    window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer = setTimeout(()=>{ run(); }, 200); });\n    // toggle log scale redraw\n    logscale.addEventListener('change', ()=>{ run(); });\n\n    // Run once initially\n    run();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Fibonacci Sequence"
    }
  ],
  "topic": "Fibonacci Sequence",
  "hasFSM": false,
  "hasTest": true
}