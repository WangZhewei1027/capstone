{
  "id": "be873c63-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:34.514Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Deque",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<title>Deque (Double-Ended Queue) — Interactive Demo</title>\n<style>\n  :root {\n    --bg: #0f1724;\n    --panel: #0b1220;\n    --accent: #7dd3fc;\n    --muted: #94a3b8;\n    --good: #bbf7d0;\n    --danger: #fecaca;\n    --slot: #071022;\n    --slot-border: #1f2937;\n  }\n  html,body { height:100%; margin:0; font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial; background: linear-gradient(180deg,#071226 0%, #071530 60%); color:#e6eef8; }\n  .wrap { max-width:1000px; margin:28px auto; padding:20px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 6px 30px rgba(2,6,23,0.6); }\n  h1 { margin:6px 0 12px 0; font-size:20px; color:var(--accent); }\n  p.lead { margin:0 0 12px 0; color:var(--muted); font-size:13px; }\n  .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:16px; }\n  .input-row { display:flex; gap:8px; align-items:center; }\n  input[type=\"text\"] { padding:8px 10px; border-radius:8px; border:1px solid var(--slot-border); background:#031022; color:#dff3ff; outline:none; width:160px; }\n  button { padding:8px 12px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); color:var(--accent); cursor:pointer; }\n  button.secondary { color:var(--muted); border-color:rgba(255,255,255,0.02); }\n  button.danger { color:#ffb4b4; }\n  .panel { display:flex; gap:16px; align-items:flex-start; }\n  .vis { flex:1 1 60%; min-width:300px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); padding:14px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); }\n  .info { flex:1 1 36%; min-width:220px; padding:12px; border-radius:10px; background:linear-gradient(180deg, rgba(125,211,252,0.03), rgba(255,255,255,0.00)); border:1px solid rgba(125,211,252,0.06); }\n  .buffer { display:flex; gap:8px; padding:18px 12px; justify-content:center; align-items:end; overflow:auto; }\n  .slot { width:72px; height:72px; background:var(--slot); border:1px solid var(--slot-border); border-radius:8px; display:flex; align-items:center; justify-content:center; color:#bfe9ff; font-weight:600; position:relative; transition:transform 300ms ease, box-shadow 200ms ease; }\n  .slot.empty { color:#243241; opacity:0.6; font-weight:400; }\n  .slot .index { position:absolute; left:6px; top:6px; font-size:11px; color:var(--muted); }\n  .pointer { text-align:center; font-size:12px; color:var(--muted); margin-top:6px; min-width:72px; }\n  .pointers { display:flex; gap:8px; justify-content:center; margin-top:6px; }\n  .slot.head { box-shadow: 0 6px 20px rgba(29,78,216,0.18); border-color:rgba(125,211,252,0.5); transform:translateY(-6px); }\n  .slot.tail { box-shadow: 0 6px 20px rgba(16,185,129,0.12); border-color:rgba(34,197,94,0.4); transform:translateY(-6px); }\n  .meta { font-size:13px; color:var(--muted); display:flex; gap:10px; flex-wrap:wrap; margin-bottom:8px; }\n  .log { background: rgba(255,255,255,0.01); padding:8px; border-radius:8px; font-size:13px; color:var(--muted); max-height:220px; overflow:auto; border:1px solid rgba(255,255,255,0.02); }\n  .complex { font-size:13px; color:var(--muted); margin-top:10px; }\n  .complex b { color:var(--accent); }\n  .small { font-size:12px; color:var(--muted); margin-top:8px; }\n  .row { display:flex; gap:8px; flex-wrap:wrap; }\n  footer { margin-top:14px; font-size:12px; color:var(--muted); }\n  .badge { background:rgba(255,255,255,0.02); padding:6px 10px; border-radius:999px; color:var(--muted); border:1px solid rgba(255,255,255,0.02); }\n  .muted { color:var(--muted); font-size:13px; }\n  @media (max-width:760px) {\n    .panel { flex-direction:column; }\n    .buffer { padding:12px; }\n    .slot { width:56px; height:56px; }\n    .pointer, .pointers { min-width:56px; }\n  }\n</style>\n</head>\n<body>\n<div class=\"wrap\" role=\"application\" aria-label=\"Deque demo\">\n  <h1>Deque (Double-Ended Queue) — Interactive Demo</h1>\n  <p class=\"lead\">A deque supports insertion and removal at both ends. This demo implements a circular-buffer-backed Deque with dynamic resizing. Try pushing/popping from either end and watch the internal buffer change.</p>\n\n  <div class=\"controls\">\n    <div class=\"input-row\">\n      <input id=\"valueInput\" type=\"text\" placeholder=\"value (text or number)\" aria-label=\"Value to insert\">\n      <button id=\"pushFrontBtn\">Push Front</button>\n      <button id=\"pushBackBtn\">Push Back</button>\n    </div>\n    <div class=\"row\">\n      <button id=\"popFrontBtn\" class=\"secondary\">Pop Front</button>\n      <button id=\"popBackBtn\" class=\"secondary\">Pop Back</button>\n      <button id=\"peekFrontBtn\" class=\"secondary\">Peek Front</button>\n      <button id=\"peekBackBtn\" class=\"secondary\">Peek Back</button>\n      <button id=\"clearBtn\" class=\"danger\">Clear</button>\n    </div>\n    <div class=\"row\">\n      <button id=\"randomFillBtn\" class=\"secondary\">Random Fill</button>\n      <button id=\"rotateLeftBtn\" class=\"secondary\">Rotate Left</button>\n      <button id=\"rotateRightBtn\" class=\"secondary\">Rotate Right</button>\n    </div>\n  </div>\n\n  <div class=\"panel\">\n    <div class=\"vis\" aria-live=\"polite\">\n      <div class=\"meta\">\n        <div class=\"badge\">Capacity: <span id=\"capSpan\">—</span></div>\n        <div class=\"badge\">Size: <span id=\"sizeSpan\">0</span></div>\n        <div class=\"badge\">Head index: <span id=\"headSpan\">0</span></div>\n      </div>\n\n      <div class=\"buffer\" id=\"buffer\"></div>\n      <div class=\"pointers\" id=\"pointers\"></div>\n      <div class=\"small muted\">Array-level view: empty slots show as faded. Highlights show logical head and tail.</div>\n    </div>\n\n    <div class=\"info\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;\">\n        <strong style=\"color:var(--accent)\">Operations Log</strong>\n        <button id=\"clearLogBtn\" class=\"secondary\">Clear Log</button>\n      </div>\n      <div class=\"log\" id=\"log\" aria-live=\"polite\"></div>\n\n      <div class=\"complex\">\n        Complexity (amortized):\n        <ul style=\"margin:6px 0 0 18px; padding:0; color:var(--muted)\">\n          <li><b>pushFront / pushBack / popFront / popBack:</b> O(1)</li>\n          <li><b>peekFront / peekBack / size / clear:</b> O(1)</li>\n          <li><b>resize (internal):</b> O(n) but happens rarely; overall amortized O(1).</li>\n        </ul>\n      </div>\n      <div class=\"small muted\">Tip: Try alternating push/pop at different ends to see head/tail wrap inside the circular buffer.</div>\n    </div>\n  </div>\n\n  <footer>\n    Implementation note: This demo uses a circular array with a head index and a length. When capacity is reached it doubles the buffer and realigns items starting at index 0.\n  </footer>\n</div>\n\n<script>\n/*\n  Deque implementation using a circular buffer with dynamic resizing.\n  Methods: pushFront, pushBack, popFront, popBack, peekFront, peekBack, size, clear, toArray, rotate.\n*/\nclass Deque {\n  constructor(initialCapacity = 8) {\n    this._capacity = Math.max(1, initialCapacity >>> 0);\n    this._buffer = new Array(this._capacity);\n    this._head = 0;   // index of first element\n    this._length = 0; // number of elements\n  }\n\n  size() { return this._length; }\n\n  _idx(i) {\n    // logical index i (0..length-1) -> physical index in buffer\n    return (this._head + i) % this._capacity;\n  }\n\n  _ensureCapacity(minCapacity) {\n    if (this._capacity >= minCapacity) return;\n    let newCap = this._capacity;\n    while (newCap < minCapacity) newCap *= 2;\n    const nb = new Array(newCap);\n    // copy elements in order starting at head\n    for (let i = 0; i < this._length; i++) nb[i] = this._buffer[this._idx(i)];\n    this._buffer = nb;\n    this._capacity = newCap;\n    this._head = 0;\n  }\n\n  pushBack(value) {\n    this._ensureCapacity(this._length + 1);\n    this._buffer[this._idx(this._length)] = value;\n    this._length++;\n  }\n\n  pushFront(value) {\n    this._ensureCapacity(this._length + 1);\n    this._head = (this._head - 1 + this._capacity) % this._capacity;\n    this._buffer[this._head] = value;\n    this._length++;\n  }\n\n  popFront() {\n    if (this._length === 0) return undefined;\n    const v = this._buffer[this._head];\n    this._buffer[this._head] = undefined;\n    this._head = (this._head + 1) % this._capacity;\n    this._length--;\n    return v;\n  }\n\n  popBack() {\n    if (this._length === 0) return undefined;\n    const idx = this._idx(this._length - 1);\n    const v = this._buffer[idx];\n    this._buffer[idx] = undefined;\n    this._length--;\n    return v;\n  }\n\n  peekFront() {\n    if (this._length === 0) return undefined;\n    return this._buffer[this._head];\n  }\n\n  peekBack() {\n    if (this._length === 0) return undefined;\n    return this._buffer[this._idx(this._length - 1)];\n  }\n\n  clear() {\n    this._buffer = new Array(this._capacity);\n    this._head = 0;\n    this._length = 0;\n  }\n\n  toArray() {\n    const a = new Array(this._length);\n    for (let i = 0; i < this._length; i++) a[i] = this._buffer[this._idx(i)];\n    return a;\n  }\n\n  // rotate by k steps to the left (positive k) or right (negative)\n  rotate(k) {\n    if (this._length === 0) return;\n    // normalize k to [-length,length]\n    k = ((k % this._length) + this._length) % this._length;\n    this._head = (this._head + k) % this._capacity;\n  }\n\n  // Expose internal snapshot for visualization (do not mutate)\n  _snapshot() {\n    return {\n      buffer: this._buffer.slice(),\n      capacity: this._capacity,\n      head: this._head,\n      length: this._length\n    };\n  }\n}\n\n/* ---------- UI Code ---------- */\n\nconst deque = new Deque(8);\n\nconst bufferEl = document.getElementById('buffer');\nconst pointersEl = document.getElementById('pointers');\nconst capSpan = document.getElementById('capSpan');\nconst sizeSpan = document.getElementById('sizeSpan');\nconst headSpan = document.getElementById('headSpan');\nconst logEl = document.getElementById('log');\n\nconst valueInput = document.getElementById('valueInput');\nconst pushFrontBtn = document.getElementById('pushFrontBtn');\nconst pushBackBtn = document.getElementById('pushBackBtn');\nconst popFrontBtn = document.getElementById('popFrontBtn');\nconst popBackBtn = document.getElementById('popBackBtn');\nconst peekFrontBtn = document.getElementById('peekFrontBtn');\nconst peekBackBtn = document.getElementById('peekBackBtn');\nconst clearBtn = document.getElementById('clearBtn');\nconst randomFillBtn = document.getElementById('randomFillBtn');\nconst rotateLeftBtn = document.getElementById('rotateLeftBtn');\nconst rotateRightBtn = document.getElementById('rotateRightBtn');\nconst clearLogBtn = document.getElementById('clearLogBtn');\n\nfunction log(msg, kind = 'info') {\n  const p = document.createElement('div');\n  p.textContent = msg;\n  p.style.padding = '6px 4px';\n  p.style.borderBottom = '1px dashed rgba(255,255,255,0.02)';\n  if (kind === 'err') p.style.color = '#ffc2c2';\n  logEl.prepend(p);\n}\n\nfunction render() {\n  const snap = deque._snapshot();\n  bufferEl.innerHTML = '';\n  pointersEl.innerHTML = '';\n\n  capSpan.textContent = snap.capacity;\n  sizeSpan.textContent = snap.length;\n  headSpan.textContent = snap.head;\n\n  // create slot elements for each buffer cell\n  for (let i = 0; i < snap.capacity; i++) {\n    const slot = document.createElement('div');\n    slot.className = 'slot';\n    const idxLabel = document.createElement('div');\n    idxLabel.className = 'index';\n    idxLabel.textContent = i;\n    slot.appendChild(idxLabel);\n\n    const cell = snap.buffer[i];\n    if (cell === undefined) {\n      slot.classList.add('empty');\n      slot.appendChild(document.createTextNode('•'));\n    } else {\n      slot.appendChild(document.createTextNode(String(cell)));\n    }\n\n    // highlight head/tail if inside logical region\n    const inLogical = (() => {\n      if (snap.length === 0) return false;\n      const first = snap.head;\n      const last = (snap.head + snap.length - 1) % snap.capacity;\n      if (first <= last) {\n        return i >= first && i <= last;\n      } else {\n        return i >= first || i <= last;\n      }\n    })();\n\n    if (!inLogical) slot.style.opacity = '0.5';\n\n    if (snap.length > 0) {\n      if (i === snap.head) slot.classList.add('head');\n      if (i === ((snap.head + snap.length - 1) % snap.capacity)) slot.classList.add('tail');\n    }\n\n    bufferEl.appendChild(slot);\n  }\n\n  // pointers (labels below)\n  const headPtr = document.createElement('div');\n  headPtr.className = 'pointer';\n  headPtr.textContent = 'head → ' + (snap.length > 0 ? snap._head : snap.head); // fallback if empty\n  // For correct displayed head, we use snap.head\n  headPtr.textContent = 'head → ' + snap.head;\n  pointersEl.appendChild(headPtr);\n\n  const tailPtr = document.createElement('div');\n  tailPtr.className = 'pointer';\n  tailPtr.textContent = 'tail → ' + (snap.length > 0 ? ((snap.head + snap.length - 1) % snap.capacity) : '—');\n  pointersEl.appendChild(tailPtr);\n}\n\n// wire up buttons\npushFrontBtn.addEventListener('click', () => {\n  const v = valueInput.value.trim();\n  if (v === '') {\n    log('Enter a value before pushing.', 'err');\n    return;\n  }\n  deque.pushFront(v);\n  log(`pushFront(${v})`);\n  valueInput.value = '';\n  render();\n});\n\npushBackBtn.addEventListener('click', () => {\n  const v = valueInput.value.trim();\n  if (v === '') {\n    log('Enter a value before pushing.', 'err');\n    return;\n  }\n  deque.pushBack(v);\n  log(`pushBack(${v})`);\n  valueInput.value = '';\n  render();\n});\n\npopFrontBtn.addEventListener('click', () => {\n  const v = deque.popFront();\n  if (v === undefined) {\n    log('popFront() → undefined (empty)', 'err');\n  } else {\n    log(`popFront() → ${v}`);\n  }\n  render();\n});\n\npopBackBtn.addEventListener('click', () => {\n  const v = deque.popBack();\n  if (v === undefined) {\n    log('popBack() → undefined (empty)', 'err');\n  } else {\n    log(`popBack() → ${v}`);\n  }\n  render();\n});\n\npeekFrontBtn.addEventListener('click', () => {\n  const v = deque.peekFront();\n  log(`peekFront() → ${v === undefined ? 'undefined (empty)' : v}`);\n});\n\npeekBackBtn.addEventListener('click', () => {\n  const v = deque.peekBack();\n  log(`peekBack() → ${v === undefined ? 'undefined (empty)' : v}`);\n});\n\nclearBtn.addEventListener('click', () => {\n  deque.clear();\n  log('clear() — deque emptied');\n  render();\n});\n\nrandomFillBtn.addEventListener('click', () => {\n  const count = Math.floor(Math.random() * 6) + 1;\n  for (let i = 0; i < count; i++) {\n    const v = Math.random().toString(36).substring(2, 7);\n    // randomly push front or back\n    if (Math.random() < 0.5) deque.pushBack(v);\n    else deque.pushFront(v);\n  }\n  log(`random fill of ${count} elements`);\n  render();\n});\n\nrotateLeftBtn.addEventListener('click', () => {\n  if (deque.size() === 0) {\n    log('rotateLeft() — deque empty', 'err'); return;\n  }\n  deque.rotate(1);\n  log('rotate(1) — rotated left by 1');\n  render();\n});\n\nrotateRightBtn.addEventListener('click', () => {\n  if (deque.size() === 0) {\n    log('rotateRight() — deque empty', 'err'); return;\n  }\n  deque.rotate(-1);\n  log('rotate(-1) — rotated right by 1');\n  render();\n});\n\nclearLogBtn.addEventListener('click', () => {\n  logEl.innerHTML = '';\n});\n\n// allow Enter to push back by default\nvalueInput.addEventListener('keydown', (e) => {\n  if (e.key === 'Enter') {\n    pushBackBtn.click();\n  }\n});\n\n// initial state\nrender();\nlog('Deque initialized (capacity 8). Try pushFront/pushBack, then popFront/popBack.');\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Deque"
    }
  ],
  "topic": "Deque",
  "hasFSM": false,
  "hasTest": true
}