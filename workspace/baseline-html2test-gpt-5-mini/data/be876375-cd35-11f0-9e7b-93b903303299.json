{
  "id": "be876375-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:56.799Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\"/>\n  <title>Interactive Graph (Directed / Undirected)</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>\n  <style>\n    :root{\n      --bg:#f6f9fc;\n      --panel:#ffffff;\n      --accent:#2563eb;\n      --muted:#6b7280;\n      --danger:#ef4444;\n      --success:#10b981;\n      --node:#111827;\n      --node-fill:#fff;\n      --edge:#374151;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{background:var(--bg);display:flex;align-items:stretch;gap:12px;padding:12px;}\n    .app{\n      display:flex;flex:1;min-height:0;border-radius:8px;overflow:hidden;box-shadow:0 8px 24px rgba(15,23,42,0.08);\n      background:linear-gradient(180deg,rgba(255,255,255,0.9),rgba(250,250,252,0.9));\n    }\n    .canvas-wrap{flex:1;position:relative;display:flex;flex-direction:column}\n    canvas{flex:1;width:100%;height:100%;background:\n      linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.6));cursor:crosshair;}\n    .topbar{\n      display:flex;gap:8px;padding:10px;border-bottom:1px solid rgba(15,23,42,0.04);align-items:center;background:transparent;\n    }\n    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}\n    .btn,select,input[type=\"button\"]{\n      border:1px solid rgba(15,23,42,0.08);\n      background:var(--panel);\n      padding:8px 10px;border-radius:6px;color:var(--node);cursor:pointer;font-size:13px;\n      box-shadow:0 1px 0 rgba(255,255,255,0.5) inset;\n    }\n    .btn.active{border-color:var(--accent);box-shadow:0 0 0 3px rgba(37,99,235,0.08);}\n    .sidebar{\n      width:360px;padding:12px;box-sizing:border-box;background:linear-gradient(180deg,var(--panel),#fbfdff);\n      border-left:1px solid rgba(15,23,42,0.04);overflow:auto;\n    }\n    h3{margin:8px 0 6px 0;font-size:15px;color:var(--node)}\n    .muted{color:var(--muted);font-size:13px;margin-bottom:6px}\n    .info-row{display:flex;gap:6px;align-items:center;flex-wrap:wrap}\n    .small{font-size:12px;padding:6px;border-radius:6px;background:#f8fafc;border:1px solid rgba(15,23,42,0.03)}\n    pre{background:#111827;color:#fff;padding:8px;border-radius:6px;overflow:auto;font-size:13px}\n    table{border-collapse:collapse;width:100%;font-size:13px}\n    td,th{border:1px solid rgba(15,23,42,0.06);padding:6px;text-align:center}\n    .legend{display:flex;gap:8px;align-items:center;margin-top:6px}\n    .dot{width:14px;height:14px;border-radius:50%;display:inline-block;border:1px solid rgba(0,0,0,0.06)}\n    .node-dot{background:var(--node-fill);border-color:var(--node)}\n    .edge-dot{width:28px;height:10px;border-radius:4px;background:linear-gradient(90deg,var(--edge),#9ca3af)}\n    .footer{font-size:12px;color:var(--muted);margin-top:10px}\n    .code{white-space:pre-wrap;font-family:monospace;background:#f3f4f6;padding:8px;border-radius:6px;border:1px solid rgba(15,23,42,0.03)}\n    label{font-size:13px;color:var(--muted);display:block;margin-top:8px}\n    input[type=\"text\"],select{padding:8px;border-radius:6px;border:1px solid rgba(15,23,42,0.08);background:#fff}\n    .row{display:flex;gap:6px;align-items:center}\n    .small-btn{padding:6px 8px;font-size:13px;border-radius:6px}\n    .status{font-size:13px;color:var(--muted);padding:6px;border-radius:6px}\n    .highlighted{box-shadow:0 0 0 3px rgba(16,185,129,0.08);border-color:var(--success)}\n    .danger{border-color:var(--danger);box-shadow:0 0 0 3px rgba(239,68,68,0.06)}\n    .matrix-wrap{overflow:auto;max-height:200px;padding:6px;border-radius:6px;border:1px solid rgba(15,23,42,0.03);background:#fff}\n    .note{font-size:12px;color:var(--muted);margin-top:6px}\n    a.link{color:var(--accent);text-decoration:none}\n  </style>\n</head>\n<body>\n  <div class=\"app\" id=\"app\">\n    <div class=\"canvas-wrap\">\n      <div class=\"topbar\">\n        <div class=\"controls\">\n          <button class=\"btn active\" id=\"mode-add-node\" title=\"Add nodes by clicking the canvas\">Add Node</button>\n          <button class=\"btn\" id=\"mode-add-edge\" title=\"Connect two nodes (click first then second)\">Add Edge</button>\n          <button class=\"btn\" id=\"mode-move\" title=\"Drag nodes\">Move</button>\n          <button class=\"btn\" id=\"mode-delete\" title=\"Delete nodes/edges\">Delete</button>\n\n          <label style=\"display:flex;align-items:center;gap:8px;margin:0 0 0 8px;font-size:13px;color:var(--muted)\">\n            <input type=\"checkbox\" id=\"global-directed\" /> Directed graph\n          </label>\n\n          <button class=\"btn\" id=\"clear\" title=\"Remove all nodes and edges\">Clear</button>\n          <button class=\"btn\" id=\"random\" title=\"Generate random graph\">Random</button>\n        </div>\n\n        <div style=\"margin-left:auto;display:flex;gap:8px;align-items:center\">\n          <div class=\"status\" id=\"status\">Mode: Add Node</div>\n        </div>\n      </div>\n\n      <canvas id=\"canvas\"></canvas>\n      <div style=\"position:absolute;right:12px;bottom:12px;background:rgba(255,255,255,0.9);padding:8px;border-radius:8px;border:1px solid rgba(15,23,42,0.04);font-size:13px\">\n        Nodes: <span id=\"node-count\">0</span> &nbsp; Edges: <span id=\"edge-count\">0</span>\n      </div>\n    </div>\n\n    <div class=\"sidebar\">\n      <h3>Graph Controls & Tools</h3>\n      <div class=\"muted\">Interactively build and explore directed or undirected graphs. Use modes to add, connect, move, or remove elements.</div>\n\n      <label>Selected node (for traversals):\n        <select id=\"node-select\"><option value=\"\">— pick node —</option></select>\n      </label>\n\n      <div style=\"display:flex;gap:6px;margin-top:8px\">\n        <button class=\"btn\" id=\"bfs-btn\">Run BFS</button>\n        <button class=\"btn\" id=\"dfs-btn\">Run DFS</button>\n        <button class=\"btn\" id=\"stop-traversal\">Stop</button>\n      </div>\n\n      <div class=\"note\">Traversal animations highlight nodes/edges in order. Click a node then press BFS/DFS, or pick from the dropdown.</div>\n\n      <h3>Adjacency List</h3>\n      <div class=\"matrix-wrap\" id=\"adj-list\"></div>\n\n      <h3 style=\"margin-top:10px\">Adjacency Matrix</h3>\n      <div class=\"matrix-wrap\" id=\"adj-matrix\"></div>\n\n      <h3 style=\"margin-top:10px\">Examples and Hints</h3>\n      <div class=\"code\">\n        - Click canvas to add nodes. <br/>\n        - Switch to \"Add Edge\" then click a node and then another to connect. Toggle \"Directed graph\" to create directed edges.<br/>\n        - Use Move to drag; Delete to remove nodes or edges.<br/>\n        - Self-loop is created by connecting a node to itself.<br/>\n      </div>\n\n      <div class=\"footer\">\n        Built-in demo • Interactive HTML + JavaScript • Designed for learning graph concepts\n      </div>\n    </div>\n  </div>\n\n  <script>\n    // Interactive Graph Editor: Directed/Undirected with BFS/DFS + Adjacency views\n    (function(){\n      const canvas = document.getElementById('canvas');\n      const ctx = canvas.getContext('2d');\n      let DPR = window.devicePixelRatio || 1;\n\n      function resize(){\n        DPR = window.devicePixelRatio || 1;\n        canvas.width = canvas.clientWidth * DPR;\n        canvas.height = canvas.clientHeight * DPR;\n        ctx.setTransform(DPR,0,0,DPR,0,0);\n        draw();\n      }\n      // initial sizing\n      window.addEventListener('resize', resize);\n      setTimeout(resize, 50);\n\n      // Data structures\n      let nodes = []; // {id,label,x,y}\n      let edges = []; // {from,to,directed}\n      let nextNodeId = 1;\n\n      // State\n      let mode = 'add-node'; // add-node, add-edge, move, delete\n      let globalDirected = false;\n      let drag = null; // {node,offsetX,offsetY}\n      let addEdgeSource = null;\n      let selectedNodeId = null;\n      let traversalTimer = null;\n      let traversalStopped = false;\n\n      // UI elements\n      const modeButtons = {\n        'add-node': document.getElementById('mode-add-node'),\n        'add-edge': document.getElementById('mode-add-edge'),\n        'move': document.getElementById('mode-move'),\n        'delete': document.getElementById('mode-delete')\n      };\n      const statusEl = document.getElementById('status');\n      const globalDirectedCheckbox = document.getElementById('global-directed');\n      const nodeCountEl = document.getElementById('node-count');\n      const edgeCountEl = document.getElementById('edge-count');\n      const adjListEl = document.getElementById('adj-list');\n      const adjMatrixEl = document.getElementById('adj-matrix');\n      const nodeSelect = document.getElementById('node-select');\n      const bfsBtn = document.getElementById('bfs-btn');\n      const dfsBtn = document.getElementById('dfs-btn');\n      const stopBtn = document.getElementById('stop-traversal');\n      const clearBtn = document.getElementById('clear');\n      const randomBtn = document.getElementById('random');\n\n      // Setup buttons\n      Object.entries(modeButtons).forEach(([m,btn])=>{\n        btn.addEventListener('click', ()=> setMode(m));\n      });\n      function setMode(m){\n        mode = m;\n        Object.values(modeButtons).forEach(b => b.classList.remove('active'));\n        modeButtons[m].classList.add('active');\n        statusEl.textContent = 'Mode: ' + (m==='add-node'?'Add Node':m==='add-edge'?'Add Edge':m==='move'?'Move':'Delete');\n        canvas.style.cursor = (m==='move') ? 'grab' : 'crosshair';\n        addEdgeSource = null;\n      }\n\n      globalDirectedCheckbox.addEventListener('change', ()=>{\n        globalDirected = !!globalDirectedCheckbox.checked;\n      });\n\n      function addNode(x,y){\n        const id = String(nextNodeId++);\n        const node = {id, label:id, x, y};\n        nodes.push(node);\n        updateNodeList();\n        draw();\n      }\n\n      function findNodeAt(x,y){\n        for(let i = nodes.length-1; i>=0; i--){\n          const n = nodes[i];\n          const dx = x - n.x;\n          const dy = y - n.y;\n          if(Math.hypot(dx,dy) <= NODE_RADIUS) return n;\n        }\n        return null;\n      }\n\n      function addEdge(fromId,toId,directed = globalDirected){\n        // Avoid duplicate exact same directed edge; allow parallel edges? keep single.\n        if(edges.some(e=> e.from===fromId && e.to===toId && e.directed===directed)) return;\n        edges.push({from:fromId,to:toId,directed});\n        updateCounts();\n        draw();\n      }\n\n      function deleteNode(nodeId){\n        nodes = nodes.filter(n=> n.id !== nodeId);\n        edges = edges.filter(e=> e.from !== nodeId && e.to !== nodeId);\n        updateNodeList();\n        draw();\n      }\n\n      function deleteEdge(edgeIndex){\n        edges.splice(edgeIndex,1);\n        updateCounts();\n        draw();\n      }\n\n      function toggleEdgeDir(edgeIndex){\n        edges[edgeIndex].directed = !edges[edgeIndex].directed;\n        draw();\n      }\n\n      // Event handlers\n      const NODE_RADIUS = 20;\n      let isMouseDown = false;\n\n      canvas.addEventListener('mousedown', (ev)=>{\n        const rect = canvas.getBoundingClientRect();\n        const x = (ev.clientX - rect.left);\n        const y = (ev.clientY - rect.top);\n        isMouseDown = true;\n\n        if(mode === 'add-node'){\n          addNode(x,y);\n        } else if(mode === 'add-edge'){\n          const node = findNodeAt(x,y);\n          if(node){\n            if(!addEdgeSource){\n              addEdgeSource = node;\n              // flash selection\n            } else {\n              addEdge(addEdgeSource.id, node.id, globalDirected);\n              addEdgeSource = null;\n            }\n          }\n        } else if(mode === 'move'){\n          const node = findNodeAt(x,y);\n          if(node){\n            drag = {node, offsetX: x-node.x, offsetY: y-node.y};\n            canvas.style.cursor = 'grabbing';\n          }\n        } else if(mode === 'delete'){\n          const edgeIndex = findEdgeAt(x,y);\n          if(edgeIndex !== null){\n            deleteEdge(edgeIndex);\n            return;\n          }\n          const node = findNodeAt(x,y);\n          if(node) deleteNode(node.id);\n        }\n        draw();\n      });\n\n      canvas.addEventListener('mousemove', (ev)=>{\n        const rect = canvas.getBoundingClientRect();\n        const x = (ev.clientX - rect.left);\n        const y = (ev.clientY - rect.top);\n        if(mode === 'move' && drag && isMouseDown){\n          drag.node.x = x - drag.offsetX;\n          drag.node.y = y - drag.offsetY;\n          draw();\n        }\n      });\n\n      canvas.addEventListener('mouseup', (ev)=>{\n        isMouseDown = false;\n        if(drag){\n          drag = null;\n          canvas.style.cursor = 'grab';\n        }\n      });\n\n      // Double click to rename node\n      canvas.addEventListener('dblclick', (ev)=>{\n        const rect = canvas.getBoundingClientRect();\n        const x = (ev.clientX - rect.left);\n        const y = (ev.clientY - rect.top);\n        const node = findNodeAt(x,y);\n        if(node){\n          const newLabel = prompt('Label for node '+node.id, node.label);\n          if(newLabel != null) { node.label = newLabel; updateNodeList(); draw();}\n        }\n      });\n\n      // Detect edge under point for deletion/toggle\n      function findEdgeAt(x,y){\n        for(let i=0;i<edges.length;i++){\n          const e = edges[i];\n          const n1 = nodes.find(n=> n.id===e.from);\n          const n2 = nodes.find(n=> n.id===e.to);\n          if(!n1 || !n2) continue;\n          if(isPointNearEdge(x,y,n1.x,n1.y,n2.x,n2.y,e)) return i;\n        }\n        return null;\n      }\n\n      function isPointNearEdge(px,py,x1,y1,x2,y2,edge){\n        // handle self-loop separately\n        if(x1===x2 && y1===y2){\n          const loopX = x1 + 0.0*NODE_RADIUS;\n          const loopY = y1 - NODE_RADIUS*1.6;\n          const d = Math.hypot(px-loopX, py-loopY);\n          return d < NODE_RADIUS;\n        } else {\n          // distance from point to segment\n          const A = px - x1;\n          const B = py - y1;\n          const C = x2 - x1;\n          const D = y2 - y1;\n          const dot = A*C + B*D;\n          const len2 = C*C + D*D;\n          let t = len2 ? dot / len2 : -1;\n          t = Math.max(0, Math.min(1, t));\n          const projx = x1 + t*C;\n          const projy = y1 + t*D;\n          const dist = Math.hypot(px-projx, py-projy);\n          return dist < 8;\n        }\n      }\n\n      // Drawing\n      function clearCanvas(){\n        ctx.clearRect(0,0,canvas.width,canvas.height);\n      }\n\n      function draw(){\n        clearCanvas();\n        // edges first\n        edges.forEach((e,i)=>{\n          const n1 = nodes.find(n=> n.id===e.from);\n          const n2 = nodes.find(n=> n.id===e.to);\n          if(!n1 || !n2) return;\n          drawEdge(n1,n2,e.directed);\n        });\n        // nodes on top\n        nodes.forEach(n => drawNode(n));\n        // if in add-edge mode and source selected, draw a highlight\n        if(mode === 'add-edge' && addEdgeSource){\n          ctx.beginPath();\n          ctx.strokeStyle = '#2563EB';\n          ctx.lineWidth = 2;\n          ctx.setLineDash([6,6]);\n          ctx.arc(addEdgeSource.x, addEdgeSource.y, NODE_RADIUS+6, 0, Math.PI*2);\n          ctx.stroke();\n          ctx.setLineDash([]);\n        }\n        updateCounts();\n      }\n\n      function drawNode(n, fill='#fff', stroke='#111827'){\n        // circle\n        ctx.beginPath();\n        ctx.fillStyle = fill;\n        ctx.strokeStyle = stroke;\n        ctx.lineWidth = 2;\n        ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI*2);\n        ctx.fill();\n        ctx.stroke();\n        // label\n        ctx.fillStyle = '#111827';\n        ctx.font = 'bold 13px Inter, Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(n.label, n.x, n.y);\n      }\n\n      function drawEdge(n1,n2,directed){\n        ctx.strokeStyle = '#374151';\n        ctx.lineWidth = 2;\n        ctx.fillStyle = '#374151';\n        if(n1.id === n2.id){\n          // self-loop: draw arc\n          const cx = n1.x;\n          const cy = n1.y;\n          const r = NODE_RADIUS * 1.2;\n          ctx.beginPath();\n          ctx.arc(cx, cy - NODE_RADIUS - r/2, r, 0.2*Math.PI, 1.3*Math.PI);\n          ctx.stroke();\n          if(directed){\n            // draw arrowhead at end of arc\n            const angle = 1.3*Math.PI;\n            const ax = cx + (cy - NODE_RADIUS - r/2 - cy) * 0 + Math.cos(angle)*r;\n            const ay = (cy - NODE_RADIUS - r/2) + Math.sin(angle)*r;\n            drawArrowhead(ax,ay,angle);\n          }\n          return;\n        }\n\n        // compute line endpoints shortened by node radius circles\n        const dx = n2.x - n1.x;\n        const dy = n2.y - n1.y;\n        const len = Math.hypot(dx,dy);\n        const ux = dx / len;\n        const uy = dy / len;\n        const startX = n1.x + ux * NODE_RADIUS;\n        const startY = n1.y + uy * NODE_RADIUS;\n        const endX = n2.x - ux * NODE_RADIUS;\n        const endY = n2.y - uy * NODE_RADIUS;\n\n        ctx.beginPath();\n        ctx.moveTo(startX, startY);\n        ctx.lineTo(endX, endY);\n        ctx.stroke();\n\n        if(directed){\n          // arrowhead pointing to end\n          const angle = Math.atan2(endY - startY, endX - startX);\n          drawArrowhead(endX, endY, angle);\n        } else {\n          // for undirected, optionally draw a small center marker for parallelism - keep simple\n        }\n      }\n\n      function drawArrowhead(x,y,angle){\n        const size = 9;\n        ctx.save();\n        ctx.translate(x,y);\n        ctx.rotate(angle);\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.lineTo(-size, size/2);\n        ctx.lineTo(-size, -size/2);\n        ctx.closePath();\n        ctx.fill();\n        ctx.restore();\n      }\n\n      // UI update helpers\n      function updateCounts(){\n        nodeCountEl.textContent = nodes.length;\n        edgeCountEl.textContent = edges.length;\n        updateAdjList();\n        updateAdjMatrix();\n      }\n\n      function updateNodeList(){\n        // update select and dropdowns\n        nodeSelect.innerHTML = '<option value=\"\">— pick node —</option>';\n        nodes.forEach(n=>{\n          const opt = document.createElement('option');\n          opt.value = n.id;\n          opt.textContent = n.label + ' ('+n.id+')';\n          nodeSelect.appendChild(opt);\n        });\n        updateCounts();\n      }\n\n      function updateAdjList(){\n        // adjacency list grouped by node label\n        const map = new Map();\n        nodes.forEach(n => map.set(n.id, []));\n        edges.forEach(e=>{\n          map.get(e.from).push({to:e.to, directed:e.directed});\n          if(!e.directed){\n            // also add reverse to display adjacency list for undirected\n            map.get(e.to).push({to:e.from, directed:e.directed});\n          }\n        });\n        let html = '';\n        nodes.forEach(n=>{\n          const items = map.get(n.id) || [];\n          html += '<div style=\"margin-bottom:6px\"><strong>'+escapeHtml(n.label+' ('+n.id+')')+'</strong>: ';\n          if(items.length===0) html += '<span class=\"muted\">—</span>';\n          else {\n            html += items.map(it=>{\n              return (it.directed? '&#8594; ' : '') + escapeHtml(displayNodeLabel(it.to));\n            }).join(', ');\n          }\n          html += '</div>';\n        });\n        adjListEl.innerHTML = html || '<div class=\"muted\">No nodes</div>';\n      }\n\n      function updateAdjMatrix(){\n        // nodes ordered by current nodes array\n        if(nodes.length===0){\n          adjMatrixEl.innerHTML = '<div class=\"muted\">No nodes</div>';\n          return;\n        }\n        let html = '<table><thead><tr><th></th>';\n        nodes.forEach(n=> html += '<th>'+escapeHtml(n.label)+'</th>');\n        html += '</tr></thead><tbody>';\n        nodes.forEach((ni, i)=>{\n          html += '<tr><th>'+escapeHtml(ni.label)+'</th>';\n          nodes.forEach((nj,j)=>{\n            const val = adjacencyValue(ni.id,nj.id);\n            html += '<td>'+val+'</td>';\n          });\n          html += '</tr>';\n        });\n        html += '</tbody></table>';\n        adjMatrixEl.innerHTML = html;\n      }\n\n      function adjacencyValue(a,b){\n        // for unweighted: 1 if edge exists from a->b or undirected edge between them\n        for(const e of edges){\n          if(e.from === a && e.to === b) return e.directed ? '1(→)' : '1';\n          if(!e.directed && e.from === b && e.to === a) return '1';\n        }\n        return '0';\n      }\n\n      function displayNodeLabel(id){\n        const n = nodes.find(xx=> xx.id===id);\n        return n? (n.label + ' ('+n.id+')') : id;\n      }\n\n      function escapeHtml(s){ return String(s).replace(/[&<>\"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c])); }\n\n      // Traversal: BFS and DFS (iteration over neighbor lists)\n      function getNeighbors(nodeId){\n        const nbrs = [];\n        edges.forEach(e=>{\n          if(e.from === nodeId) nbrs.push(e.to);\n          if(!e.directed && e.to === nodeId) nbrs.push(e.from);\n        });\n        // unique\n        return [...new Set(nbrs)];\n      }\n\n      function runBFS(startId){\n        stopTraversal();\n        const visited = new Set();\n        const queue = [startId];\n        let order = [];\n        visited.add(startId);\n        while(queue.length){\n          const u = queue.shift();\n          order.push(u);\n          const nbrs = getNeighbors(u);\n          nbrs.forEach(v=>{\n            if(!visited.has(v)){\n              visited.add(v);\n              queue.push(v);\n            }\n          });\n        }\n        animateOrder(order);\n      }\n\n      function runDFS(startId){\n        stopTraversal();\n        const visited = new Set();\n        const order = [];\n        function dfs(u){\n          visited.add(u);\n          order.push(u);\n          const nbrs = getNeighbors(u);\n          for(const v of nbrs){\n            if(!visited.has(v)) dfs(v);\n          }\n        }\n        dfs(startId);\n        animateOrder(order);\n      }\n\n      function animateOrder(order){\n        if(!order || order.length===0) return;\n        traversalStopped = false;\n        let i=0;\n        const originalNodeStates = nodes.map(n=> ({id:n.id, x:n.x, y:n.y}));\n        traversalTimer = setInterval(()=>{\n          if(traversalStopped) { clearInterval(traversalTimer); traversalTimer=null; draw(); return; }\n          if(i>0) draw(); // redraw baseline\n          if(i < order.length){\n            // highlight node order[i]\n            const nid = order[i];\n            const n = nodes.find(x=> x.id===nid);\n            if(n){\n              // draw an overlay highlight\n              draw();\n              ctx.beginPath();\n              ctx.fillStyle = 'rgba(37,99,235,0.18)';\n              ctx.strokeStyle = '#2563EB';\n              ctx.lineWidth = 2;\n              ctx.arc(n.x,n.y,NODE_RADIUS+6,0,Math.PI*2);\n              ctx.fill();\n              ctx.stroke();\n\n              // also highlight edges from previous node to current (if any)\n              if(i>0){\n                const prev = order[i-1];\n                highlightEdgeBetween(prev, nid);\n              }\n            }\n            i++;\n          } else {\n            clearInterval(traversalTimer);\n            traversalTimer = null;\n          }\n        }, 650);\n      }\n\n      function highlightEdgeBetween(a,b){\n        // draw a bright overlay on edges between a and b or b and a for undirected\n        edges.forEach(e=>{\n          if((e.from===a && e.to===b) || (!e.directed && e.from===b && e.to===a)){\n            const n1 = nodes.find(n=> n.id===e.from);\n            const n2 = nodes.find(n=> n.id===e.to);\n            if(!n1 || !n2) return;\n            ctx.beginPath();\n            ctx.strokeStyle = '#10B981';\n            ctx.lineWidth = 4;\n            ctx.moveTo(n1.x, n1.y);\n            ctx.lineTo(n2.x, n2.y);\n            ctx.stroke();\n            // arrow overlay for directed edges\n            if(e.directed){\n              const dx = n2.x - n1.x;\n              const dy = n2.y - n1.y;\n              const len = Math.hypot(dx,dy);\n              const ux = dx/len;\n              const uy = dy/len;\n              const endX = n2.x - ux * NODE_RADIUS;\n              const endY = n2.y - uy * NODE_RADIUS;\n              const angle = Math.atan2(endY - (n1.y + uy*NODE_RADIUS), endX - (n1.x + ux*NODE_RADIUS));\n              drawArrowhead(endX, endY, angle);\n            }\n          }\n        });\n      }\n\n      function stopTraversal(){\n        traversalStopped = true;\n        if(traversalTimer){\n          clearInterval(traversalTimer);\n          traversalTimer = null;\n        }\n      }\n\n      // UI wiring\n      bfsBtn.addEventListener('click', ()=>{\n        const start = nodeSelect.value;\n        if(!start){ alert('Pick a start node first.'); return; }\n        runBFS(start);\n      });\n      dfsBtn.addEventListener('click', ()=>{\n        const start = nodeSelect.value;\n        if(!start){ alert('Pick a start node first.'); return; }\n        runDFS(start);\n      });\n      stopBtn.addEventListener('click', stopTraversal);\n\n      clearBtn.addEventListener('click', ()=>{\n        if(!confirm('Clear all nodes and edges?')) return;\n        nodes = [];\n        edges = [];\n        nextNodeId = 1;\n        updateNodeList();\n        draw();\n      });\n\n      randomBtn.addEventListener('click', ()=>{\n        const n = parseInt(prompt('How many nodes? (1-20)','6')) || 6;\n        const p = parseFloat(prompt('Edge probability (0-1)','0.25')) || 0.25;\n        if(n < 1 || n > 50) { alert('Pick between 1 and 50.'); return; }\n        nodes = [];\n        edges = [];\n        nextNodeId = 1;\n        for(let i=0;i<n;i++){\n          const x = 60 + Math.random()*(canvas.clientWidth-120);\n          const y = 60 + Math.random()*(canvas.clientHeight-120);\n          addNode(x,y);\n        }\n        // create random edges\n        for(let i=0;i<n;i++){\n          for(let j=0;j<n;j++){\n            if(i===j && Math.random() < 0.05) {\n              addEdge(nodes[i].id, nodes[j].id, globalDirected);\n            } else if(i!==j && Math.random() < p){\n              // avoid duplicate when undirected: only add j>i if undirected\n              if(!globalDirected && j < i) continue;\n              addEdge(nodes[i].id, nodes[j].id, globalDirected);\n            }\n          }\n        }\n        draw();\n      });\n\n      // Keyboard shortcuts\n      window.addEventListener('keydown', (ev)=>{\n        if(ev.key === 'Escape'){\n          addEdgeSource = null;\n          draw();\n        }\n      });\n\n      // initial draw\n      draw();\n\n      // Utility to keep canvas responsive initially\n      setTimeout(()=>{ resize(); draw(); }, 100);\n\n      // Simple safety: if user clicks on canvas while in add-edge mode and clicks empty space -> cancel\n      canvas.addEventListener('click', (ev)=>{\n        const rect = canvas.getBoundingClientRect();\n        const x = (ev.clientX - rect.left);\n        const y = (ev.clientY - rect.top);\n        if(mode === 'add-edge'){\n          const node = findNodeAt(x,y);\n          if(!node && addEdgeSource){\n            // clicked empty space; cancel selection\n            addEdgeSource = null;\n            draw();\n          }\n        }\n      });\n\n      // INIT: add an example graph\n      (function seedExample(){\n        const w = canvas.clientWidth, h = canvas.clientHeight;\n        const coords = [\n          {x:w*0.2, y:h*0.25},\n          {x:w*0.5, y:h*0.18},\n          {x:w*0.8, y:h*0.28},\n          {x:w*0.3, y:h*0.6},\n          {x:w*0.6, y:h*0.6}\n        ];\n        coords.forEach(c=> addNode(c.x,c.y));\n        // add edges (undirected default)\n        addEdge('1','2', false);\n        addEdge('2','3', false);\n        addEdge('1','4', false);\n        addEdge('2','4', false);\n        addEdge('4','5', false);\n        draw();\n      })();\n\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": false,
  "hasTest": true
}