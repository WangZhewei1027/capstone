{
  "id": "2bddce50-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:17:12.443Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Linked List",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Interactive Singly Linked List Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#06b6d4;\n      --muted:#94a3b8;\n      --node:#0ea5a3;\n      --node-ink:#042029;\n      --danger:#ef4444;\n      --success:#10b981;\n    }\n    html,body{\n      height:100%;\n      margin:0;\n      background:linear-gradient(180deg,#071026 0%, #071921 100%);\n      color:#e6eef6;\n      font-family:Inter,ui-sans-serif,system-ui,-apple-system,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial;\n      -webkit-font-smoothing:antialiased;\n      -moz-osx-font-smoothing:grayscale;\n    }\n    .app{\n      max-width:1100px;\n      margin:28px auto;\n      padding:20px;\n      border-radius:12px;\n      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));\n      box-shadow: 0 6px 30px rgba(2,6,23,0.6);\n      min-height:540px;\n      display:grid;\n      grid-template-columns:1fr 360px;\n      gap:18px;\n    }\n\n    header{\n      grid-column:1 / -1;\n      display:flex;\n      gap:12px;\n      align-items:center;\n      margin-bottom:4px;\n    }\n    header h1{\n      margin:0;\n      font-size:20px;\n      letter-spacing:0.2px;\n      color:var(--accent);\n    }\n    header p{ margin:0; color:var(--muted); font-size:13px;}\n\n    .canvas{\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:10px;\n      padding:18px;\n      min-height:420px;\n      overflow:auto;\n      position:relative;\n      border:1px solid rgba(255,255,255,0.03);\n    }\n\n    .controls{\n      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));\n      border-radius:10px;\n      padding:16px;\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n      border:1px solid rgba(255,255,255,0.03);\n      height:fit-content;\n    }\n    .controls label{ font-size:13px; color:var(--muted); }\n    .row{ display:flex; gap:8px; align-items:center; }\n    input[type=\"text\"], input[type=\"number\"], select{\n      background:#06121a;\n      border:1px solid rgba(255,255,255,0.03);\n      color:#e6eef6;\n      padding:8px 10px;\n      border-radius:8px;\n      outline:none;\n      min-width:0;\n    }\n    input[type=\"text\"]::placeholder{ color: #475569; }\n    button{\n      background:linear-gradient(180deg, #075b63, #04707a);\n      color:white;\n      border:none;\n      padding:8px 10px;\n      border-radius:8px;\n      cursor:pointer;\n      transition:transform 120ms ease, box-shadow 120ms;\n      font-weight:600;\n    }\n    button.ghost{\n      background:transparent;\n      border:1px solid rgba(255,255,255,0.04);\n      color:var(--muted);\n      font-weight:600;\n    }\n    button.danger{\n      background:linear-gradient(180deg,#ef4444,#dc2626);\n    }\n    .btn-row{ display:flex; gap:8px; flex-wrap:wrap; }\n\n    /* Linked list nodes */\n    .nodes{\n      display:flex;\n      gap:18px;\n      align-items:center;\n      padding:14px;\n      flex-wrap:wrap;\n      min-height:120px;\n    }\n    .node{\n      width:110px;\n      min-width:110px;\n      height:64px;\n      border-radius:10px;\n      background:linear-gradient(180deg,var(--node), #0c9b9a);\n      color:var(--node-ink);\n      display:flex;\n      align-items:center;\n      justify-content:center;\n      position:relative;\n      box-shadow: 0 6px 20px rgba(2,6,23,0.45);\n      font-weight:700;\n      font-size:18px;\n    }\n    .node .value{ z-index:2; }\n    .node .meta{\n      position:absolute; left:8px; top:6px;\n      font-size:11px; color:rgba(0,0,0,0.25); font-weight:700;\n    }\n    .node.head{ box-shadow: 0 8px 28px rgba(3,166,166,0.12); outline:2px solid rgba(6,182,212,0.06); }\n    .node.tail{ outline:2px solid rgba(16,185,129,0.06); }\n    .node.highlight{ transform:scale(1.04); box-shadow:0 10px 30px rgba(6,182,212,0.12); }\n    .node.found{ outline:3px solid rgba(253,224,71,0.16); box-shadow:0 12px 34px rgba(245,158,11,0.08); }\n\n    .label{\n      display:inline-block;\n      padding:6px 10px;\n      background:rgba(255,255,255,0.02);\n      border-radius:8px;\n      color:var(--muted);\n      font-size:13px;\n      margin-right:8px;\n    }\n\n    .status{\n      margin-top:8px;\n      color:var(--muted);\n      font-size:13px;\n    }\n\n    svg.connectors{\n      position:absolute;\n      left:0; top:0;\n      pointer-events:none;\n      overflow:visible;\n    }\n\n    .info{\n      font-size:13px;\n      color:var(--muted);\n      background:rgba(255,255,255,0.01);\n      padding:8px;\n      border-radius:8px;\n    }\n\n    .repr{\n      margin-top:12px;\n      color:#d7eef7;\n      font-weight:600;\n      font-size:14px;\n      word-break:break-all;\n    }\n\n    footer{\n      grid-column:1 / -1;\n      margin-top:12px;\n      font-size:12px;\n      color:var(--muted);\n      display:flex;\n      justify-content:space-between;\n      align-items:center;\n    }\n\n    .small{ font-size:12px; color:var(--muted); }\n    .hint{ color:var(--muted); font-size:12px; margin-top:6px; }\n  </style>\n</head>\n<body>\n  <div class=\"app\" role=\"application\" aria-label=\"Linked List Visualizer\">\n    <header>\n      <div>\n        <h1>Interactive Singly Linked List</h1>\n        <p>Visually build and manipulate a singly linked list. Add, insert, delete, search, reverse, and step through nodes.</p>\n      </div>\n    </header>\n\n    <main class=\"canvas\" id=\"canvas\" aria-live=\"polite\">\n      <div style=\"display:flex;align-items:center;gap:12px;margin-bottom:8px;flex-wrap:wrap;\">\n        <span class=\"label\">Head: <span id=\"head-label\">null</span></span>\n        <span class=\"label\">Tail: <span id=\"tail-label\">null</span></span>\n        <span class=\"label\">Size: <span id=\"size-label\">0</span></span>\n      </div>\n\n      <div id=\"nodes-wrap\" class=\"nodes\" aria-hidden=\"false\" tabindex=\"0\"></div>\n\n      <!-- SVG connectors overlay -->\n      <svg id=\"svg\" class=\"connectors\" width=\"2000\" height=\"800\" aria-hidden=\"true\"></svg>\n\n      <div class=\"repr\" id=\"repr\">Empty list</div>\n      <div class=\"status\" id=\"status\">Use the controls on the right to manipulate the list.</div>\n    </main>\n\n    <aside class=\"controls\">\n      <div>\n        <label for=\"value-input\">Node value</label>\n        <div class=\"row\">\n          <input id=\"value-input\" type=\"text\" placeholder=\"e.g., 42 or hello\" />\n          <button id=\"add-tail\">Push (tail)</button>\n          <button id=\"add-head\" class=\"ghost\">Unshift (head)</button>\n        </div>\n      </div>\n\n      <div>\n        <label>Insert / Remove</label>\n        <div class=\"row\">\n          <input id=\"index-input\" type=\"number\" placeholder=\"index\" min=\"0\" style=\"width:86px;\" />\n          <button id=\"insert-index\" class=\"ghost\">Insert at index</button>\n          <button id=\"remove-index\" class=\"danger\">Remove at index</button>\n        </div>\n        <div class=\"row\" style=\"margin-top:8px;\">\n          <input id=\"value-remove\" type=\"text\" placeholder=\"value to remove\" />\n          <button id=\"remove-value\" class=\"danger\">Remove value</button>\n        </div>\n      </div>\n\n      <div>\n        <label>Operations</label>\n        <div class=\"btn-row\">\n          <button id=\"find\" class=\"ghost\">Find value</button>\n          <button id=\"traverse\" class=\"ghost\">Traverse (step)</button>\n          <button id=\"auto-traverse\" class=\"ghost\">Auto-play</button>\n          <button id=\"reverse\">Reverse</button>\n        </div>\n      </div>\n\n      <div>\n        <label>List actions</label>\n        <div class=\"row\">\n          <button id=\"clear\" class=\"danger\">Clear list</button>\n          <button id=\"fill-sample\" class=\"ghost\">Sample data</button>\n        </div>\n      </div>\n\n      <div class=\"info\">\n        Tip: Use small lists for clarity. Indexing is zero-based. \"Push\" adds to tail; \"Unshift\" adds to head.\n      </div>\n    </aside>\n\n    <footer>\n      <div class=\"small\">Singly Linked List demo â€” interactive learning</div>\n      <div class=\"small\">Visualization updates animate traversal and operations</div>\n    </footer>\n  </div>\n\n<script>\n/*\n  Singly Linked List Visualizer\n  - Single HTML file with inline JS that implements a simple singly linked list and renders nodes.\n  - Supports push (tail), unshift (head), insert at index, remove at index, remove by value, find (search), traverse (step/auto-play), reverse, clear, fill sample.\n  - Visualization uses DOM elements for nodes and an overlaid SVG for arrows.\n*/\n\n(function(){\n  // Basic linked list implementation\n  class ListNode {\n    constructor(value){\n      this.value = value;\n      this.next = null;\n    }\n  }\n\n  class SinglyLinkedList {\n    constructor(){\n      this.head = null;\n      this.tail = null;\n      this.length = 0;\n    }\n\n    push(value){\n      const node = new ListNode(value);\n      if(!this.head){\n        this.head = this.tail = node;\n      } else {\n        this.tail.next = node;\n        this.tail = node;\n      }\n      this.length++;\n      return this;\n    }\n\n    unshift(value){\n      const node = new ListNode(value);\n      if(!this.head){\n        this.head = this.tail = node;\n      } else {\n        node.next = this.head;\n        this.head = node;\n      }\n      this.length++;\n      return this;\n    }\n\n    insertAt(index, value){\n      if(index < 0 || index > this.length) return false;\n      if(index === 0) { this.unshift(value); return true; }\n      if(index === this.length){ this.push(value); return true; }\n      const node = new ListNode(value);\n      let prev = this.head;\n      for(let i=1;i<index;i++) prev = prev.next;\n      node.next = prev.next;\n      prev.next = node;\n      this.length++;\n      return true;\n    }\n\n    removeAt(index){\n      if(index < 0 || index >= this.length || !this.head) return null;\n      let removed;\n      if(index === 0){\n        removed = this.head;\n        this.head = this.head.next;\n        if(this.length === 1) this.tail = null;\n      } else {\n        let prev = this.head;\n        for(let i=1;i<index;i++) prev = prev.next;\n        removed = prev.next;\n        prev.next = removed.next;\n        if(index === this.length - 1) this.tail = prev;\n      }\n      this.length--;\n      removed.next = null;\n      return removed;\n    }\n\n    removeValue(value){\n      if(!this.head) return null;\n      if(this.head.value === value){\n        const node = this.head;\n        this.head = this.head.next;\n        this.length--;\n        if(this.length === 0) this.tail = null;\n        node.next = null;\n        return node;\n      }\n      let prev = this.head;\n      while(prev.next && prev.next.value !== value) prev = prev.next;\n      if(!prev.next) return null;\n      const node = prev.next;\n      prev.next = node.next;\n      if(node === this.tail) this.tail = prev;\n      this.length--;\n      node.next = null;\n      return node;\n    }\n\n    find(value){\n      let idx = 0;\n      let cur = this.head;\n      while(cur){\n        if(cur.value === value) return {node:cur, index:idx};\n        cur = cur.next; idx++;\n      }\n      return null;\n    }\n\n    reverse(){\n      let prev = null;\n      let cur = this.head;\n      this.tail = this.head;\n      while(cur){\n        const nxt = cur.next;\n        cur.next = prev;\n        prev = cur;\n        cur = nxt;\n      }\n      this.head = prev;\n    }\n\n    toArray(){\n      const arr = [];\n      let cur = this.head;\n      while(cur){ arr.push(cur.value); cur = cur.next; }\n      return arr;\n    }\n\n    clear(){\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }\n\n  // DOM references\n  const nodesWrap = document.getElementById('nodes-wrap');\n  const svg = document.getElementById('svg');\n  const headLabel = document.getElementById('head-label');\n  const tailLabel = document.getElementById('tail-label');\n  const sizeLabel = document.getElementById('size-label');\n  const repr = document.getElementById('repr');\n  const status = document.getElementById('status');\n\n  const valueInput = document.getElementById('value-input');\n  const indexInput = document.getElementById('index-input');\n  const valueRemove = document.getElementById('value-remove');\n\n  const addTailBtn = document.getElementById('add-tail');\n  const addHeadBtn = document.getElementById('add-head');\n  const insertIndexBtn = document.getElementById('insert-index');\n  const removeIndexBtn = document.getElementById('remove-index');\n  const removeValueBtn = document.getElementById('remove-value');\n  const findBtn = document.getElementById('find');\n  const traverseBtn = document.getElementById('traverse');\n  const autoTraverseBtn = document.getElementById('auto-traverse');\n  const reverseBtn = document.getElementById('reverse');\n  const clearBtn = document.getElementById('clear');\n  const sampleBtn = document.getElementById('fill-sample');\n\n  // App state\n  const list = new SinglyLinkedList();\n  let traversalIndex = -1;\n  let autoTraverseTimer = null;\n  let traversalNodes = []; // cached DOM nodes during traversal\n\n  // Utilities for rendering\n  function setStatus(text, type){\n    status.textContent = text;\n    if(type === 'ok') status.style.color = 'var(--success)';\n    else if(type === 'err') status.style.color = 'var(--danger)';\n    else status.style.color = 'var(--muted)';\n  }\n\n  function clearSVG(){\n    while(svg.firstChild) svg.removeChild(svg.firstChild);\n  }\n\n  function updateLabels(){\n    headLabel.textContent = list.head ? String(list.head.value) : 'null';\n    tailLabel.textContent = list.tail ? String(list.tail.value) : 'null';\n    sizeLabel.textContent = list.length;\n    const arr = list.toArray();\n    repr.textContent = arr.length ? arr.join('  ->  ') : 'Empty list';\n  }\n\n  function render(){\n    // Clear traversal state\n    stopAutoTraverse();\n    traversalIndex = -1;\n    traversalNodes = [];\n\n    // Clear existing node elements\n    nodesWrap.innerHTML = '';\n    clearSVG();\n\n    // Create node DOM elements\n    let cur = list.head;\n    let idx = 0;\n    while(cur){\n      const el = document.createElement('div');\n      el.className = 'node';\n      el.dataset.index = idx;\n      if(idx === 0) el.classList.add('head');\n      if(idx === list.length - 1) el.classList.add('tail');\n\n      const meta = document.createElement('div');\n      meta.className = 'meta';\n      meta.textContent = '#' + idx;\n\n      const val = document.createElement('div');\n      val.className = 'value';\n      val.textContent = String(cur.value);\n\n      el.appendChild(meta);\n      el.appendChild(val);\n      nodesWrap.appendChild(el);\n\n      // Store a reference of the node for traversal animations\n      el._listNode = cur;\n\n      cur = cur.next;\n      idx++;\n    }\n\n    updateLabels();\n    layoutConnectors();\n  }\n\n  // Draw arrows between nodes using SVG paths\n  function layoutConnectors(){\n    clearSVG();\n    const nodeEls = Array.from(nodesWrap.children);\n    if(nodeEls.length === 0) return;\n\n    // Resize svg to encompass nodesWrap bounding box\n    const wrapRect = nodesWrap.getBoundingClientRect();\n    svg.style.width = Math.max(wrapRect.width + 200, 1000) + 'px';\n    svg.style.height = Math.max(wrapRect.height + 200, 300) + 'px';\n    svg.setAttribute('width', wrapRect.width + 200);\n    svg.setAttribute('height', wrapRect.height + 200);\n\n    // For each consecutive pair, draw a curved arrow\n    nodeEls.forEach((el, i) => {\n      if(i === nodeEls.length - 1) return;\n      const a = el.getBoundingClientRect();\n      const b = nodeEls[i+1].getBoundingClientRect();\n\n      // Coordinates relative to svg (which is positioned at top-left of document)\n      const svgRect = svg.getBoundingClientRect();\n      const startX = a.right - svgRect.left - 6;\n      const startY = a.top + a.height / 2 - svgRect.top;\n      const endX = b.left - svgRect.left + 6;\n      const endY = b.top + b.height / 2 - svgRect.top;\n\n      // Create a path with a gentle cubic curve\n      const dx = Math.max(36, (endX - startX) / 2);\n      const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n      const d = `M ${startX} ${startY} C ${startX + dx} ${startY} ${endX - dx} ${endY} ${endX} ${endY}`;\n      path.setAttribute('d', d);\n      path.setAttribute('fill', 'none');\n      path.setAttribute('stroke', 'rgba(255,255,255,0.08)');\n      path.setAttribute('stroke-width', '2');\n      path.setAttribute('stroke-linecap', 'round');\n\n      // Arrowhead marker\n      const markerId = 'arrowhead';\n      if(!document.getElementById(markerId)){\n        const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');\n        marker.setAttribute('id', markerId);\n        marker.setAttribute('markerWidth', '6');\n        marker.setAttribute('markerHeight', '6');\n        marker.setAttribute('refX', '6');\n        marker.setAttribute('refY', '3');\n        marker.setAttribute('orient', 'auto');\n        marker.setAttribute('markerUnits', 'strokeWidth');\n        const polygon = document.createElementNS('http://www.w3.org/2000/svg','path');\n        polygon.setAttribute('d','M 0 0 L 6 3 L 0 6 z');\n        polygon.setAttribute('fill','rgba(255,255,255,0.12)');\n        marker.appendChild(polygon);\n        // Append to defs\n        let defs = svg.querySelector('defs');\n        if(!defs){ defs = document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.appendChild(defs); }\n        defs.appendChild(marker);\n      }\n      path.setAttribute('marker-end','url(#arrowhead)');\n\n      svg.appendChild(path);\n    });\n  }\n\n  // Helper to animate a node (highlight briefly)\n  function pulseNodeByIndex(ix, klass='highlight', ms=700){\n    const el = nodesWrap.querySelector('.node[data-index=\"'+ix+'\"]');\n    if(!el) return;\n    el.classList.add(klass);\n    setTimeout(()=> el.classList.remove(klass), ms);\n  }\n\n  // Find node DOM by index and scroll into view a bit\n  function focusNode(ix){\n    const el = nodesWrap.querySelector('.node[data-index=\"'+ix+'\"]');\n    if(!el) return;\n    el.scrollIntoView({behavior:'smooth', inline:'center', block:'nearest'});\n  }\n\n  // Operation implementations with UI feedback and rendering\n  function pushValue(val){\n    if(val === ''){ setStatus('Provide a value to push.', 'err'); return; }\n    list.push(val);\n    render();\n    setStatus('Pushed \"'+val+'\" to tail.', 'ok');\n  }\n  function unshiftValue(val){\n    if(val === ''){ setStatus('Provide a value to unshift.', 'err'); return; }\n    list.unshift(val);\n    render();\n    setStatus('Unshifted \"'+val+'\" to head.', 'ok');\n  }\n  function insertAtIndex(idx, val){\n    if(!Number.isFinite(idx) || idx < 0){ setStatus('Provide a valid index.', 'err'); return; }\n    if(val === ''){ setStatus('Provide a value to insert.', 'err'); return; }\n    const success = list.insertAt(idx, val);\n    if(!success){ setStatus('Index out of bounds.', 'err'); return; }\n    render();\n    setStatus('Inserted \"'+val+'\" at index ' + idx + '.', 'ok');\n    pulseNodeByIndex(idx);\n    focusNode(idx);\n  }\n  function removeAtIndex(ix){\n    if(!Number.isFinite(ix) || ix < 0 || ix >= list.length){ setStatus('Invalid index to remove.', 'err'); return; }\n    const node = list.removeAt(ix);\n    render();\n    setStatus('Removed \"'+node.value+'\" at index ' + ix + '.', 'ok');\n  }\n  function removeByValue(v){\n    if(v === ''){ setStatus('Provide a value to remove.', 'err'); return; }\n    const node = list.removeValue(v);\n    if(!node){ setStatus('Value \"'+v+'\" not found.', 'err'); return; }\n    render();\n    setStatus('Removed first occurrence of \"'+v+'\".', 'ok');\n  }\n\n  function findValue(v){\n    if(v === ''){ setStatus('Enter a value to find.', 'err'); return; }\n    const res = list.find(v);\n    if(!res){ setStatus('Value \"'+v+'\" not found.', 'err'); return; }\n    // visually highlight found node\n    render();\n    const el = nodesWrap.querySelector('.node[data-index=\"'+res.index+'\"]');\n    if(el){\n      el.classList.add('found');\n      focusNode(res.index);\n      setTimeout(()=> el.classList.remove('found'), 1400);\n    }\n    setStatus('Found \"'+v+'\" at index ' + res.index + '.', 'ok');\n  }\n\n  // Traversal stepper\n  function startTraverse(){\n    if(list.length === 0){ setStatus('List is empty.', 'err'); return; }\n    traversalIndex = -1;\n    traversalNodes = Array.from(nodesWrap.querySelectorAll('.node'));\n    setStatus('Traversal started. Click \"Traverse (step)\" to move next or Auto-play.', 'ok');\n    // Clear previous highlights\n    traversalNodes.forEach(n => n.classList.remove('highlight'));\n  }\n\n  function stepTraverse(){\n    if(!traversalNodes || traversalNodes.length === 0){\n      setStatus('Start traversal first.', 'err'); return;\n    }\n    traversalIndex++;\n    if(traversalIndex >= traversalNodes.length){\n      setStatus('Traversal finished.', 'ok');\n      traversalIndex = traversalNodes.length - 1;\n      return;\n    }\n    traversalNodes.forEach(n => n.classList.remove('highlight'));\n    const current = traversalNodes[traversalIndex];\n    current.classList.add('highlight');\n    focusNode(traversalIndex);\n    setStatus('Visiting index ' + traversalIndex + ' (value: ' + current.querySelector('.value').textContent + ')', 'ok');\n  }\n\n  function autoTraverse(){\n    if(list.length === 0){ setStatus('List is empty.', 'err'); return; }\n    if(autoTraverseTimer){ stopAutoTraverse(); return; }\n    startTraverse();\n    autoTraverseTimer = setInterval(()=>{\n      stepTraverse();\n      if(traversalIndex >= traversalNodes.length - 1){\n        stopAutoTraverse();\n        setStatus('Auto-traversal finished.', 'ok');\n      }\n    }, 700);\n    autoTraverseBtn.textContent = 'Stop auto';\n    setStatus('Auto-traversal started.', 'ok');\n  }\n\n  function stopAutoTraverse(){\n    if(autoTraverseTimer){\n      clearInterval(autoTraverseTimer);\n      autoTraverseTimer = null;\n    }\n    autoTraverseBtn.textContent = 'Auto-play';\n    traversalIndex = -1;\n  }\n\n  // Reverse\n  function reverseList(){\n    if(list.length <= 1){ setStatus('List too small to reverse.', 'err'); return; }\n    // animate: highlight then reverse\n    const nodeEls = Array.from(nodesWrap.children);\n    nodeEls.forEach((n,i)=> setTimeout(()=> n.classList.add('highlight'), i*80));\n    setTimeout(()=>{\n      list.reverse();\n      render();\n      setStatus('List reversed.', 'ok');\n    }, nodeEls.length * 80 + 220);\n  }\n\n  function clearList(){\n    list.clear();\n    render();\n    setStatus('List cleared.', 'ok');\n  }\n\n  function fillSample(){\n    list.clear();\n    const samples = ['A','B','C','D','E'];\n    samples.forEach(s => list.push(s));\n    render();\n    setStatus('Sample data filled.', 'ok');\n  }\n\n  // Event wiring\n  addTailBtn.addEventListener('click', ()=> {\n    pushValue(valueInput.value.trim());\n    valueInput.focus();\n  });\n\n  addHeadBtn.addEventListener('click', ()=> {\n    unshiftValue(valueInput.value.trim());\n    valueInput.focus();\n  });\n\n  insertIndexBtn.addEventListener('click', ()=> {\n    const idx = Number(indexInput.value);\n    insertAtIndex(idx, valueInput.value.trim());\n    indexInput.value = '';\n    valueInput.focus();\n  });\n\n  removeIndexBtn.addEventListener('click', ()=> {\n    const ix = Number(indexInput.value);\n    if(Number.isNaN(ix)){ setStatus('Enter index to remove.', 'err'); return; }\n    removeAtIndex(ix);\n    indexInput.value = '';\n  });\n\n  removeValueBtn.addEventListener('click', ()=> {\n    removeByValue(valueRemove.value.trim());\n    valueRemove.value = '';\n  });\n\n  findBtn.addEventListener('click', ()=> {\n    const v = valueInput.value.trim();\n    if(v === '') setStatus('Enter a value to find in the top input.', 'err');\n    findValue(v);\n  });\n\n  traverseBtn.addEventListener('click', ()=> {\n    // Start traversal if not started\n    if(traversalIndex === -1 || traversalNodes.length === 0){\n      startTraverse();\n    }\n    stepTraverse();\n  });\n\n  autoTraverseBtn.addEventListener('click', ()=> {\n    autoTraverse();\n  });\n\n  reverseBtn.addEventListener('click', ()=> {\n    reverseList();\n  });\n\n  clearBtn.addEventListener('click', ()=> {\n    clearList();\n  });\n\n  sampleBtn.addEventListener('click', ()=> {\n    fillSample();\n  });\n\n  // Re-layout connectors on window resize to keep arrows consistent\n  let resizeTimer = null;\n  window.addEventListener('resize', ()=> {\n    clearTimeout(resizeTimer);\n    resizeTimer = setTimeout(layoutConnectors, 120);\n  });\n\n  // Initial render\n  render();\n  setStatus('Ready. Try pushing some nodes!', 'ok');\n\n  // Accessibility: allow Enter key to push\n  valueInput.addEventListener('keydown', (e)=> {\n    if(e.key === 'Enter'){\n      pushValue(valueInput.value.trim());\n      e.preventDefault();\n    }\n  });\n\n  // Small helper: animate connector layout whenever DOM changes (MutationObserver)\n  const observer = new MutationObserver(()=> {\n    layoutConnectors();\n  });\n  observer.observe(nodesWrap, {childList:true, subtree:true});\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Linked List"
    }
  ],
  "topic": "Linked List",
  "hasFSM": false,
  "hasTest": true
}