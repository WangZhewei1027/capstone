{
  "id": "be878a82-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:36.899Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Adjacency List",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Adjacency List — Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1724;\n      --panel:#0b1220;\n      --accent:#56b6f7;\n      --muted:#94a3b8;\n      --card:#081023;\n      --good:#16a34a;\n      --danger:#ef4444;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{background:linear-gradient(180deg,#041028 0%, #071428 60%, #07172a 100%);color:#e6eef8;}\n    .container{display:flex;gap:18px;padding:18px;height:100vh;box-sizing:border-box;}\n    .left{width:360px;display:flex;flex-direction:column;gap:12px;}\n    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03);}\n    h1{margin:0;font-size:18px;color:var(--accent);}\n    p.small{margin:6px 0 0 0;color:var(--muted);font-size:12px;}\n    .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;}\n    input[type=\"text\"], input[type=\"number\"], select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:inherit;}\n    button{background:var(--accent);border:none;color:#021027;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;}\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);}\n    .smallbtn{padding:6px 8px;font-size:13px;border-radius:8px;}\n    .muted{color:var(--muted);font-size:13px;}\n    .adj-list{max-height:260px;overflow:auto;margin-top:8px;padding:8px;background:rgba(255,255,255,0.01);border-radius:6px;font-family:monospace;font-size:13px;}\n    .row{display:flex;gap:8px;align-items:center;}\n    label{font-size:13px;color:var(--muted);}\n    .canvas-wrap{flex:1;display:flex;flex-direction:column;gap:12px;}\n    #canvas{background:linear-gradient(180deg,rgba(5,12,24,0.6),rgba(6,14,28,0.3));border-radius:12px;flex:1;box-shadow: inset 0 2px 18px rgba(0,0,0,0.35);cursor:grab;}\n    .legend{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:13px;}\n    .dot{width:12px;height:12px;border-radius:50%;}\n    .node-default{background:#0ea5e9;border:2px solid rgba(255,255,255,0.06);}\n    .node-visited{background:var(--good);}\n    .node-front{background:#f59e0b;}\n    .node-target{background:#ef4444;}\n    .footer-actions{display:flex;gap:8px;align-items:center;}\n    .traversal-controls{display:flex;gap:8px;align-items:center;margin-top:8px;}\n    .smallmuted{font-size:12px;color:var(--muted);}\n    textarea{width:100%;height:80px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);color:inherit;padding:8px;font-family:monospace;}\n    .help{font-size:13px;color:var(--muted);line-height:1.35;}\n    footer{color:var(--muted);font-size:12px;text-align:center;margin-top:6px;}\n    .edge-label{font-size:11px;color:var(--muted);background:rgba(255,255,255,0.02);padding:4px;border-radius:6px;}\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"left\">\n      <div class=\"card\">\n        <h1>Adjacency List — Interactive Demo</h1>\n        <p class=\"small\">An adjacency list represents a graph as a mapping from each node to a list of its neighbors. It's memory-efficient for sparse graphs.</p>\n\n        <div style=\"margin-top:10px\" class=\"row\">\n          <div style=\"flex:1\">\n            <label>Graph type</label><br>\n            <select id=\"directedSelect\">\n              <option value=\"false\">Undirected</option>\n              <option value=\"true\">Directed</option>\n            </select>\n          </div>\n          <div style=\"width:120px\">\n            <label>Max nodes</label><br>\n            <input id=\"maxNodes\" type=\"number\" value=\"12\" min=\"2\" max=\"24\" />\n          </div>\n        </div>\n\n        <div class=\"controls\">\n          <button id=\"addNodeBtn\">Add Node</button>\n          <button id=\"randBtn\" class=\"ghost smallbtn\">Random Graph</button>\n          <button id=\"clearBtn\" class=\"ghost smallbtn\">Clear</button>\n          <button id=\"exportBtn\" class=\"ghost smallbtn\">Export JSON</button>\n          <button id=\"importBtn\" class=\"ghost smallbtn\">Import JSON</button>\n        </div>\n\n        <div style=\"margin-top:8px\" class=\"row\">\n          <div style=\"flex:1\">\n            <label>Add edge</label><br>\n            <input id=\"fromNode\" type=\"text\" placeholder=\"from (e.g., A)\" />\n          </div>\n          <div style=\"flex:1\">\n            <label>&nbsp;</label><br>\n            <input id=\"toNode\" type=\"text\" placeholder=\"to (e.g., B)\" />\n          </div>\n          <div style=\"width:80px;display:flex;align-items:end;\">\n            <button id=\"addEdgeBtn\" style=\"width:100%;\">Add</button>\n          </div>\n        </div>\n\n        <div style=\"margin-top:8px\" class=\"row\">\n          <div style=\"flex:1\">\n            <label>Remove node</label><br>\n            <input id=\"removeNodeInput\" type=\"text\" placeholder=\"Node id\" />\n          </div>\n          <div style=\"width:120px;display:flex;align-items:end;\">\n            <button id=\"removeNodeBtn\" class=\"ghost\" style=\"width:100%;\">Remove</button>\n          </div>\n        </div>\n\n        <div class=\"adj-list\" id=\"adjView\" aria-live=\"polite\"></div>\n\n        <div style=\"margin-top:8px\" class=\"traversal-controls\">\n          <div style=\"flex:1\">\n            <label>Traversal start</label><br>\n            <input id=\"startNode\" type=\"text\" placeholder=\"Start node (e.g., A)\" />\n          </div>\n          <div>\n            <label>&nbsp;</label><br>\n            <select id=\"traversalType\">\n              <option value=\"bfs\">BFS (queue)</option>\n              <option value=\"dfs\">DFS (stack)</option>\n            </select>\n          </div>\n          <div style=\"width:90px;display:flex;align-items:end;\">\n            <button id=\"runTraversal\" class=\"smallbtn\">Run</button>\n          </div>\n        </div>\n\n        <div class=\"row\" style=\"margin-top:10px;\">\n          <div style=\"flex:1;\">\n            <label>Animation speed (ms)</label><br>\n            <input id=\"speed\" type=\"number\" value=\"600\" min=\"50\" max=\"2000\" />\n          </div>\n          <div style=\"width:120px;\">\n            <label>Highlight target</label><br>\n            <input id=\"targetNode\" type=\"text\" placeholder=\"optional\" />\n          </div>\n        </div>\n\n        <div style=\"margin-top:8px;\" class=\"smallmuted\">\n          Tip: Drag nodes on the canvas. Click a node to toggle selection and see its neighbors highlighted.\n        </div>\n      </div>\n\n      <div class=\"card\">\n        <div class=\"row\" style=\"justify-content:space-between;\">\n          <div class=\"legend\">\n            <div style=\"display:flex;gap:6px;align-items:center;\">\n              <div class=\"dot node-default\"></div><div class=\"smallmuted\">Default</div>\n            </div>\n            <div style=\"display:flex;gap:6px;align-items:center;\">\n              <div class=\"dot node-front\"></div><div class=\"smallmuted\">Frontier</div>\n            </div>\n            <div style=\"display:flex;gap:6px;align-items:center;\">\n              <div class=\"dot node-visited\"></div><div class=\"smallmuted\">Visited</div>\n            </div>\n            <div style=\"display:flex;gap:6px;align-items:center;\">\n              <div class=\"dot node-target\"></div><div class=\"smallmuted\">Target</div>\n            </div>\n          </div>\n          <div class=\"edge-label\">Adjacency List — Map(node -> [neighbors])</div>\n        </div>\n        <p class=\"help\" style=\"margin-top:8px;\">\n          In code an adjacency list is usually represented as: { A: ['B', 'C'], B: ['A'], C: [] }.\n          It's efficient for iterating neighbors and uses O(V + E) memory/time for typical traversals.\n        </p>\n      </div>\n\n      <footer>\n        Built for learning • Click nodes to interact • Export/import graph JSON\n      </footer>\n    </div>\n\n    <div class=\"canvas-wrap\">\n      <div class=\"card\" style=\"flex:1;display:flex;flex-direction:column;padding:10px;\">\n        <canvas id=\"canvas\" width=\"1000\" height=\"700\"></canvas>\n      </div>\n\n      <div class=\"card\" style=\"display:flex;gap:8px;align-items:flex-start;flex-wrap:wrap;\">\n        <div style=\"flex:1;\">\n          <label>Raw JSON</label>\n          <textarea id=\"jsonArea\" placeholder='{\"directed\":false,\"nodes\":[\"A\"],\"adj\":{\"A\":[\"B\"]}}'></textarea>\n        </div>\n        <div style=\"width:160px;display:flex;flex-direction:column;gap:8px;\">\n          <button id=\"loadJsonBtn\">Load JSON to Graph</button>\n          <button id=\"copyJsonBtn\" class=\"ghost\">Copy JSON</button>\n          <div style=\"font-size:12px;color:var(--muted);\">Edge weight demo: edges are unweighted here; you can extend adjacency lists to store objects (neighbor, weight).</div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<script>\n(() => {\n  // Simple interactive adjacency list demo\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  const adjView = document.getElementById('adjView');\n  const jsonArea = document.getElementById('jsonArea');\n\n  let directed = false;\n  let maxNodes = parseInt(document.getElementById('maxNodes').value,10) || 12;\n  const nodes = []; // {id,x,y}\n  const adj = {}; // id -> [neighborId,...]\n  let dragging = null;\n  let offset = {x:0,y:0};\n  const radius = 22;\n\n  // UI elements\n  const directedSelect = document.getElementById('directedSelect');\n  const addNodeBtn = document.getElementById('addNodeBtn');\n  const randBtn = document.getElementById('randBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const addEdgeBtn = document.getElementById('addEdgeBtn');\n  const fromNodeInput = document.getElementById('fromNode');\n  const toNodeInput = document.getElementById('toNode');\n  const removeNodeBtn = document.getElementById('removeNodeBtn');\n  const removeNodeInput = document.getElementById('removeNodeInput');\n  const exportBtn = document.getElementById('exportBtn');\n  const importBtn = document.getElementById('importBtn');\n  const startNodeInput = document.getElementById('startNode');\n  const runTraversalBtn = document.getElementById('runTraversal');\n  const traversalType = document.getElementById('traversalType');\n  const speedInput = document.getElementById('speed');\n  const targetNodeInput = document.getElementById('targetNode');\n  const jsonLoadBtn = document.getElementById('loadJsonBtn');\n  const copyJsonBtn = document.getElementById('copyJsonBtn');\n  const maxNodesInput = document.getElementById('maxNodes');\n\n  function randId() {\n    // returns next letter A,B,...Z,AA,AB...\n    const existing = new Set(nodes.map(n=>n.id));\n    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    for (let len=1; len<=3; len++){\n      const total = Math.pow(26,len);\n      for (let i=0;i<total;i++){\n        let x = i;\n        let s = '';\n        for (let j=0;j<len;j++){\n          s = letters[x%26] + s;\n          x = Math.floor(x/26);\n        }\n        if (!existing.has(s)) return s;\n      }\n    }\n    return `N${nodes.length+1}`;\n  }\n\n  function addNode(id, x, y) {\n    if (!id) id = randId();\n    if (Object.keys(adj).length >= maxNodes) { alert('Reached max nodes'); return null; }\n    if (adj[id]) { alert('Node exists: ' + id); return null; }\n    if (typeof x !== 'number') {\n      x = 80 + Math.random()*(canvas.width-160);\n      y = 80 + Math.random()*(canvas.height-160);\n    }\n    nodes.push({id,x,y});\n    adj[id] = [];\n    render();\n    return id;\n  }\n\n  function removeNode(id) {\n    if (!adj[id]) { alert('No such node: ' + id); return; }\n    // remove from nodes array\n    const idx = nodes.findIndex(n=>n.id===id);\n    if (idx>=0) nodes.splice(idx,1);\n    delete adj[id];\n    // remove references\n    for (const k of Object.keys(adj)) {\n      adj[k] = adj[k].filter(n => n !== id);\n    }\n    render();\n  }\n\n  function addEdge(a,b) {\n    if (!adj[a] || !adj[b]) { alert('Both nodes must exist'); return; }\n    if (!adj[a].includes(b)) adj[a].push(b);\n    if (!directed) {\n      if (!adj[b].includes(a)) adj[b].push(a);\n    }\n    render();\n  }\n\n  function removeEdge(a,b) {\n    if (adj[a]) adj[a] = adj[a].filter(x=>x!==b);\n    if (!directed && adj[b]) adj[b] = adj[b].filter(x=>x!==a);\n    render();\n  }\n\n  function adjacencyText() {\n    const keys = Object.keys(adj).sort();\n    if (keys.length===0) return '(empty graph)';\n    return keys.map(k => `${k}: [${adj[k].join(', ')}]`).join('\\n');\n  }\n\n  function updateAdjView() {\n    adjView.textContent = adjacencyText();\n    // set json area also\n    const exportObj = {directed: directed, nodes: nodes.map(n=>n.id), adj: adj};\n    jsonArea.value = JSON.stringify(exportObj, null, 2);\n  }\n\n  function render() {\n    updateAdjView();\n    // clear\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    // draw edges\n    ctx.lineWidth = 2;\n    ctx.font = '12px Inter, Arial';\n    for (const u of nodes) {\n      const neigh = adj[u.id] || [];\n      for (const vId of neigh) {\n        const v = nodes.find(n=>n.id===vId);\n        if (!v) continue;\n        drawEdge(u, v);\n      }\n    }\n    // draw nodes\n    for (const n of nodes) drawNode(n);\n  }\n\n  function drawEdge(a,b,opts={color:'rgba(200,200,220,0.14)'}) {\n    const ax = a.x, ay = a.y, bx = b.x, by = b.y;\n    const dx = bx - ax, dy = by - ay;\n    const dist = Math.hypot(dx,dy);\n    const ux = dx/dist, uy = dy/dist;\n    const startX = ax + ux*radius*0.8;\n    const startY = ay + uy*radius*0.8;\n    const endX = bx - ux*radius*0.8;\n    const endY = by - uy*radius*0.8;\n\n    ctx.strokeStyle = opts.color;\n    ctx.beginPath();\n    ctx.moveTo(startX, startY);\n    // slight curve for readability when undirected and two-way edges exist\n    const mx = (startX + endX)/2 + (-uy)*10;\n    const my = (startY + endY)/2 + (ux)*10;\n    ctx.quadraticCurveTo(mx,my,endX,endY);\n    ctx.stroke();\n\n    if (directed) {\n      // arrowhead at end\n      const angle = Math.atan2(endY - my, endX - mx);\n      const arrowSize = 8;\n      ctx.fillStyle = opts.color;\n      ctx.beginPath();\n      ctx.moveTo(endX, endY);\n      ctx.lineTo(endX - arrowSize*Math.cos(angle - Math.PI/6), endY - arrowSize*Math.sin(angle - Math.PI/6));\n      ctx.lineTo(endX - arrowSize*Math.cos(angle + Math.PI/6), endY - arrowSize*Math.sin(angle + Math.PI/6));\n      ctx.closePath();\n      ctx.fill();\n    }\n  }\n\n  function drawNode(n, opts={color:'#0ea5e9', labelColor:'#021027'}) {\n    ctx.beginPath();\n    ctx.fillStyle = opts.color || '#0ea5e9';\n    ctx.strokeStyle = 'rgba(0,0,0,0.25)';\n    ctx.lineWidth = 2;\n    roundRect(ctx, n.x - radius, n.y - radius, radius*2, radius*2, 100);\n    ctx.fill();\n    ctx.stroke();\n\n    // label\n    ctx.fillStyle = '#021027';\n    ctx.font = 'bold 14px Inter, Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(n.id, n.x, n.y);\n  }\n\n  function roundRect(ctx, x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // Interactions\n  canvas.addEventListener('mousedown', e => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const node = nodes.find(n => Math.hypot(n.x-mx, n.y-my) <= radius);\n    if (node) {\n      dragging = node;\n      offset.x = mx - node.x;\n      offset.y = my - node.y;\n      canvas.style.cursor = 'grabbing';\n    }\n  });\n\n  canvas.addEventListener('mousemove', e => {\n    if (!dragging) return;\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    dragging.x = Math.max(40, Math.min(canvas.width-40, mx - offset.x));\n    dragging.y = Math.max(40, Math.min(canvas.height-40, my - offset.y));\n    render();\n  });\n\n  canvas.addEventListener('mouseup', e => {\n    dragging = null;\n    canvas.style.cursor = 'grab';\n  });\n  canvas.addEventListener('mouseleave', e => { dragging = null; canvas.style.cursor = 'grab'; });\n\n  canvas.addEventListener('click', e => {\n    // click to highlight neighbors\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    const node = nodes.find(n => Math.hypot(n.x-mx, n.y-my) <= radius);\n    if (!node) return;\n    // temporarily paint selected node and its neighbors\n    flashNeighbors(node.id);\n  });\n\n  let flashTimer;\n  function flashNeighbors(id) {\n    clearTimeout(flashTimer);\n    // draw custom overlay\n    render();\n    // draw neighbors highlight\n    const center = nodes.find(n=>n.id===id);\n    if (!center) return;\n    // draw center\n    drawNode(center, {color:'#ef4444'});\n    // draw neighbors\n    const neigh = adj[id] || [];\n    for (const nid of neigh) {\n      const n = nodes.find(x=>x.id===nid);\n      if (n) drawNode(n, {color:'#f59e0b'});\n      // emphasize edge\n      if (n) drawEdge(center, n, {color:'#f59e0b'});\n    }\n    flashTimer = setTimeout(render, 700);\n  }\n\n  // Controls\n  directedSelect.addEventListener('change', e => {\n    directed = (e.target.value === 'true');\n    render();\n  });\n\n  addNodeBtn.addEventListener('click', () => {\n    const id = addNode();\n    if (id) {\n      // center new node label in json\n      render();\n    }\n  });\n\n  randBtn.addEventListener('click', () => {\n    // random small graph\n    clearGraph();\n    maxNodes = parseInt(maxNodesInput.value,10) || 12;\n    const n = Math.min(maxNodes, 3 + Math.floor(Math.random()*6));\n    for (let i=0;i<n;i++) addNode();\n    const ids = nodes.map(n=>n.id);\n    // random edges\n    for (let i=0;i<ids.length;i++){\n      for (let j=i+1;j<ids.length;j++){\n        if (Math.random()<0.35) {\n          addEdge(ids[i], ids[j]);\n        }\n      }\n    }\n    render();\n  });\n\n  clearBtn.addEventListener('click', clearGraph);\n\n  function clearGraph() {\n    nodes.length = 0;\n    for (const k of Object.keys(adj)) delete adj[k];\n    render();\n  }\n\n  addEdgeBtn.addEventListener('click', () => {\n    const a = fromNodeInput.value.trim().toUpperCase();\n    const b = toNodeInput.value.trim().toUpperCase();\n    if (!a || !b) { alert('Enter both node ids'); return; }\n    if (!adj[a] || !adj[b]) {\n      const ok = confirm('One or both nodes do not exist. Create missing nodes?');\n      if (!ok) return;\n      if (!adj[a]) addNode(a);\n      if (!adj[b]) addNode(b);\n    }\n    addEdge(a,b);\n  });\n\n  removeNodeBtn.addEventListener('click', () => {\n    const n = removeNodeInput.value.trim().toUpperCase();\n    if (!n) return alert('Provide node id');\n    removeNode(n);\n  });\n\n  exportBtn.addEventListener('click', () => {\n    const obj = {directed, nodes: nodes.map(n=>n.id), adj};\n    const txt = JSON.stringify(obj, null, 2);\n    navigator.clipboard?.writeText(txt).then(()=> alert('Copied JSON to clipboard')).catch(()=> {\n      jsonArea.value = txt;\n      alert('JSON placed in text area');\n    });\n  });\n\n  importBtn.addEventListener('click', () => {\n    const s = jsonArea.value.trim();\n    if (!s) return alert('Paste JSON into the Raw JSON box first.');\n    try {\n      const obj = JSON.parse(s);\n      loadFromObject(obj);\n    } catch (err) {\n      alert('Invalid JSON: ' + err.message);\n    }\n  });\n\n  jsonLoadBtn.addEventListener('click', () => {\n    const s = jsonArea.value.trim();\n    if (!s) return alert('Paste JSON into the Raw JSON box first.');\n    try {\n      const obj = JSON.parse(s);\n      loadFromObject(obj);\n    } catch (err) {\n      alert('Invalid JSON: ' + err.message);\n    }\n  });\n\n  copyJsonBtn.addEventListener('click', () => {\n    navigator.clipboard?.writeText(jsonArea.value).then(()=>alert('Copied')).catch(()=>alert('Unable to copy'));\n  });\n\n  function loadFromObject(obj) {\n    if (!obj || typeof obj !== 'object') return alert('Invalid object');\n    directed = !!obj.directed;\n    directedSelect.value = directed ? 'true' : 'false';\n    clearGraph();\n    if (Array.isArray(obj.nodes)) {\n      for (const id of obj.nodes) {\n        addNode(id);\n      }\n    }\n    if (obj.adj && typeof obj.adj === 'object') {\n      for (const k of Object.keys(obj.adj)) {\n        if (!adj[k]) addNode(k);\n      }\n      for (const k of Object.keys(obj.adj)) {\n        adj[k] = obj.adj[k].slice();\n      }\n    }\n    render();\n  }\n\n  // Traversal with visualization\n  async function visualizeTraversal(startId, type='bfs', target=null) {\n    if (!adj[startId]) { alert('Start node does not exist'); return; }\n    const delay = ms => new Promise(res => setTimeout(res, ms));\n    const speed = Number(speedInput.value) || 600;\n    const visited = new Set();\n    const order = [];\n    const highlightState = {}; // id -> 'default'|'front'|'visited'|'target'\n    for (const n of nodes) highlightState[n.id] = 'default';\n    if (target && adj[target]) highlightState[target] = 'target';\n\n    // helper to redraw with states\n    function drawWithState() {\n      ctx.clearRect(0,0,canvas.width,canvas.height);\n      // edges: if both ends visited, tint green, if frontier tint orange\n      for (const u of nodes) {\n        for (const vId of adj[u.id]||[]) {\n          const v = nodes.find(x=>x.id===vId);\n          if (!v) continue;\n          let color = 'rgba(200,200,220,0.14)';\n          if (highlightState[u.id] === 'front' || highlightState[vId]==='front') color = '#f59e0b';\n          if (highlightState[u.id] === 'visited' && highlightState[vId] === 'visited') color = '#16a34a88';\n          if (highlightState[vId] === 'target' || highlightState[u.id]==='target') color = '#ef4444';\n          drawEdge(u,v,{color});\n        }\n      }\n      for (const n of nodes) {\n        let col = '#0ea5e9';\n        if (highlightState[n.id]==='visited') col = '#16a34a';\n        if (highlightState[n.id]==='front') col = '#f59e0b';\n        if (highlightState[n.id]==='target') col = '#ef4444';\n        drawNode(n,{color:col});\n      }\n    }\n\n    if (type === 'bfs') {\n      const q = [startId];\n      highlightState[startId] = 'front';\n      drawWithState();\n      await delay(speed);\n      while (q.length) {\n        const cur = q.shift();\n        highlightState[cur] = 'visited';\n        visited.add(cur);\n        order.push(cur);\n        drawWithState();\n        if (cur === target) break;\n        await delay(speed);\n        for (const nb of adj[cur]||[]) {\n          if (!visited.has(nb) && !q.includes(nb)) {\n            q.push(nb);\n            highlightState[nb] = 'front';\n          }\n        }\n        drawWithState();\n        await delay(speed/1.6);\n      }\n    } else { // dfs iterative\n      const stack = [startId];\n      highlightState[startId] = 'front';\n      drawWithState();\n      await delay(speed);\n      while (stack.length) {\n        const cur = stack.pop();\n        if (visited.has(cur)) continue;\n        visited.add(cur);\n        highlightState[cur] = 'visited';\n        order.push(cur);\n        drawWithState();\n        if (cur === target) break;\n        await delay(speed);\n        // push neighbors in reverse so the order is natural\n        const neigh = (adj[cur]||[]).slice().reverse();\n        for (const nb of neigh) {\n          if (!visited.has(nb)) {\n            stack.push(nb);\n            highlightState[nb] = 'front';\n          }\n        }\n        drawWithState();\n        await delay(speed/1.6);\n      }\n    }\n\n    // show final order\n    alert(`${type.toUpperCase()} traversal order:\\n` + order.join(' → '));\n    render();\n  }\n\n  runTraversalBtn.addEventListener('click', () => {\n    const start = startNodeInput.value.trim().toUpperCase();\n    const target = targetNodeInput.value.trim().toUpperCase() || null;\n    if (!start) { alert('Enter start node'); return; }\n    visualizeTraversal(start, traversalType.value, target);\n  });\n\n  // initialize canvas size responsively\n  function resizeCanvas() {\n    const rect = canvas.getBoundingClientRect();\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = Math.floor(rect.width * dpr);\n    canvas.height = Math.floor(rect.height * dpr);\n    ctx.setTransform(dpr,0,0,dpr,0,0);\n    render();\n  }\n\n  // watch for container resize\n  const ro = new ResizeObserver(resizeCanvas);\n  ro.observe(canvas.parentElement);\n\n  // initial demo graph\n  directed = false;\n  directedSelect.value = 'false';\n  addNode('A', 160, 140);\n  addNode('B', 320, 100);\n  addNode('C', 260, 260);\n  addNode('D', 480, 200);\n  addNode('E', 420, 80);\n  addEdge('A','B');\n  addEdge('A','C');\n  addEdge('B','C');\n  addEdge('C','D');\n  addEdge('E','B');\n  render();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency List"
    }
  ],
  "topic": "Adjacency List",
  "hasFSM": false,
  "hasTest": true
}