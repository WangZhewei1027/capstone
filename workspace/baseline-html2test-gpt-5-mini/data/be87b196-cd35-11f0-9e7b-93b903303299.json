{
  "id": "be87b196-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:14:00.032Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Topological Sort Visualizer (Kahn & DFS) — Interactive Demo</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<style>\n  :root{\n    --bg:#0f1724; --panel:#0b1220; --accent:#7c3aed; --muted:#9aa6c1;\n    --ok:#16a34a; --warn:#eab308; --bad:#ef4444;\n  }\n  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#071025 0%, #071122 60%);color:#e6eef8}\n  .app{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box}\n  .left{width:340px;min-width:280px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:16px;box-sizing:border-box;box-shadow:0 6px 18px rgba(0,0,0,0.6)}\n  .right{flex:1;background:transparent;display:flex;flex-direction:column;gap:12px}\n  h1{font-size:18px;margin:0 0 6px 0;color:#dbe7ff}\n  p.lead{margin:0 0 12px 0;color:var(--muted);font-size:13px}\n  .controls{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:8px}\n  button,select,input[type=number]{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}\n  button.primary{background:linear-gradient(90deg,var(--accent),#5b21b6);border:none;color:white}\n  button.danger{background:linear-gradient(90deg,var(--bad),#b91c1c);border:none;color:white}\n  .small{padding:6px 8px;font-size:13px}\n  .mode-indicator{display:inline-block;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--muted);font-size:13px;margin-left:auto}\n  .panel{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;margin-bottom:10px}\n  label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}\n  .row{display:flex;gap:8px;align-items:center}\n  .svg-wrap{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border-radius:12px;flex:1;padding:10px;display:flex;flex-direction:column}\n  svg{width:100%;height:100%;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));touch-action:none}\n  .footer{display:flex;gap:8px;align-items:center}\n  .log{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;height:110px;overflow:auto;font-size:13px;color:var(--muted)}\n  .node { cursor:grab; }\n  .node.dragging{ cursor:grabbing; }\n  .n-label{font-weight:600;fill:#eff6ff}\n  .n-sub{font-size:10px;fill:#bcd4ff}\n  .badge{padding:4px 6px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}\n  .status {font-weight:600}\n  .legend{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}\n  .chip{display:inline-flex;align-items:center;gap:8px;padding:6px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}\n  .arrow-note{font-size:12px;color:var(--muted)}\n  .node-circle{stroke:rgba(255,255,255,0.06);stroke-width:2}\n  .edge-path{stroke:rgba(255,255,255,0.08);stroke-width:2;fill:none}\n  .edge-highlight{stroke:var(--accent);stroke-width:3}\n  .node-zero{stroke:var(--ok);stroke-width:3}\n  .node-processed{fill:rgba(124,58,237,0.12)}\n  .node-current{fill:rgba(124,58,237,0.22);stroke:var(--accent);stroke-width:3}\n  .node-cycle{fill:rgba(239,68,68,0.08);stroke:var(--bad);stroke-width:3}\n  .control-note{font-size:12px;color:var(--muted);margin-top:8px}\n  a{color:#9ad1ff}\n</style>\n</head>\n<body>\n<div class=\"app\">\n  <div class=\"left\">\n    <h1>Topological Sort Visualizer</h1>\n    <p class=\"lead\">Interactive demo of topological sort (Kahn's algorithm and DFS-based). Build a directed graph, then run step-by-step or full run. Detects cycles automatically.</p>\n\n    <div class=\"panel\">\n      <div class=\"row\" style=\"margin-bottom:8px;\">\n        <button id=\"addNodeBtn\" class=\"small primary\">Add Node (click canvas)</button>\n        <button id=\"addEdgeBtn\" class=\"small\">Add Edge (click source & target)</button>\n        <button id=\"deleteBtn\" class=\"small\">Delete (click element)</button>\n        <div class=\"mode-indicator\" id=\"modeLabel\">Mode: Idle</div>\n      </div>\n\n      <div style=\"display:flex;gap:8px;margin-bottom:8px;\">\n        <button id=\"randomDAG\" class=\"small\">Random DAG</button>\n        <input id=\"randN\" type=\"number\" min=\"2\" max=\"20\" value=\"6\" style=\"width:60px\">\n        <button id=\"clearBtn\" class=\"small\">Clear</button>\n      </div>\n\n      <div style=\"display:flex;gap:8px;margin-top:6px;\">\n        <button id=\"kahnRun\" class=\"small primary\">Run Kahn</button>\n        <button id=\"kahnStep\" class=\"small\">Step Kahn</button>\n        <button id=\"kahnReset\" class=\"small\">Reset Kahn</button>\n      </div>\n      <div style=\"display:flex;gap:8px;margin-top:6px;\">\n        <button id=\"dfsRun\" class=\"small primary\">Run DFS</button>\n        <button id=\"dfsStep\" class=\"small\">Step DFS</button>\n        <button id=\"dfsReset\" class=\"small\">Reset DFS</button>\n      </div>\n\n      <div class=\"control-note\">Tip: drag nodes to rearrange. Edges are directed (arrows). The UI shows in-degrees; Kahn prioritizes nodes in queue in insertion order.</div>\n    </div>\n\n    <div class=\"panel\">\n      <label>Algorithm Status</label>\n      <div style=\"display:flex;gap:8px;align-items:center;\">\n        <div class=\"chip\">Kahn order: <span id=\"kahnOrder\" style=\"margin-left:8px;color:#cde7ff;font-weight:700\">[]</span></div>\n        <div class=\"chip\">DFS topo: <span id=\"dfsOrder\" style=\"margin-left:8px;color:#cde7ff;font-weight:700\">[]</span></div>\n      </div>\n      <div class=\"legend\">\n        <div class=\"chip\"><svg width=\"14\" height=\"14\"><circle cx=\"7\" cy=\"7\" r=\"6\" fill=\"#eff6ff\" stroke=\"rgba(255,255,255,0.06)\"/></svg> Node</div>\n        <div class=\"chip\"><svg width=\"14\" height=\"14\"><line x1=\"2\" y1=\"12\" x2=\"12\" y2=\"2\" stroke=\"#7c3aed\" stroke-width=\"3\"/></svg> Current / processed</div>\n        <div class=\"chip\"><svg width=\"14\" height=\"14\"><circle cx=\"7\" cy=\"7\" r=\"6\" fill=\"#fee2e2\" stroke=\"#ef4444\"/></svg> Cycle</div>\n      </div>\n    </div>\n\n    <div>\n      <label>Console / Steps</label>\n      <div id=\"log\" class=\"log\" aria-live=\"polite\"></div>\n    </div>\n  </div>\n\n  <div class=\"right\">\n    <div class=\"svg-wrap\">\n      <svg id=\"svg\" viewBox=\"0 0 1200 800\" preserveAspectRatio=\"xMidYMid meet\">\n        <defs>\n          <marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\" markerWidth=\"8\" markerHeight=\"8\" orient=\"auto-start-reverse\">\n            <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#dbe7ff\"></path>\n          </marker>\n          <marker id=\"arrow-accent\" viewBox=\"0 0 10 10\" refX=\"10\" refY=\"5\" markerWidth=\"8\" markerHeight=\"8\" orient=\"auto-start-reverse\">\n            <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#7c3aed\"></path>\n          </marker>\n          <filter id=\"shadow\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\n            <feDropShadow dx=\"0\" dy=\"6\" stdDeviation=\"6\" flood-color=\"#000\" flood-opacity=\"0.4\"/>\n          </filter>\n        </defs>\n        <g id=\"edges\"></g>\n        <g id=\"nodes\"></g>\n      </svg>\n      <div style=\"display:flex;gap:8px;align-items:center;margin-top:8px;\">\n        <div class=\"arrow-note\">Click a node to select source/target for edges. Use modes above to add/delete.</div>\n        <div style=\"margin-left:auto\" class=\"badge\">Nodes: <span id=\"nodeCount\">0</span></div>\n        <div class=\"badge\">Edges: <span id=\"edgeCount\">0</span></div>\n      </div>\n    </div>\n\n    <div style=\"display:flex;gap:12px;\">\n      <div style=\"flex:1\">\n        <div class=\"panel\">\n          <label>Graph Info</label>\n          <div style=\"display:flex;gap:8px;align-items:center;\">\n            <div class=\"status\" id=\"graphStatus\">No cycle detected</div>\n            <div style=\"margin-left:auto;color:var(--muted)\">In-degrees shown in small text on nodes</div>\n          </div>\n        </div>\n      </div>\n\n      <div style=\"width:260px\">\n        <div class=\"panel\">\n          <label>Selected</label>\n          <div id=\"selectedInfo\" style=\"color:var(--muted)\">None</div>\n          <div style=\"margin-top:8px;display:flex;gap:8px;\">\n            <button id=\"deleteSelected\" class=\"small danger\">Delete Selected</button>\n            <button id=\"centerSelected\" class=\"small\">Center View</button>\n          </div>\n        </div>\n      </div>\n    </div>\n\n  </div>\n</div>\n\n<script>\n/*\nTopological Sort Visualizer\n- Create nodes by clicking the canvas (Add Node mode).\n- Add edges by clicking source then target (Add Edge mode).\n- Delete nodes/edges (Delete mode) or delete selected element.\n- Run Kahn's algorithm (full or step-by-step).\n- Run DFS-based topological sort (full or step-by-step).\n- Detect cycles; highlight nodes involved.\n*/\n\n/* --- Data model --- */\nlet nodes = []; // {id, x, y}\nlet edges = []; // {id, from, to}\nlet nextNodeId = 1, nextEdgeId = 1;\n\n/* --- DOM --- */\nconst svg = document.getElementById('svg');\nconst nodesG = document.getElementById('nodes');\nconst edgesG = document.getElementById('edges');\nconst logEl = document.getElementById('log');\nconst modeLabel = document.getElementById('modeLabel');\nconst nodeCountEl = document.getElementById('nodeCount');\nconst edgeCountEl = document.getElementById('edgeCount');\nconst graphStatusEl = document.getElementById('graphStatus');\nconst kahnOrderEl = document.getElementById('kahnOrder');\nconst dfsOrderEl = document.getElementById('dfsOrder');\nconst selectedInfoEl = document.getElementById('selectedInfo');\n\nconst addNodeBtn = document.getElementById('addNodeBtn');\nconst addEdgeBtn = document.getElementById('addEdgeBtn');\nconst deleteBtn = document.getElementById('deleteBtn');\nconst randomDAGBtn = document.getElementById('randomDAG');\nconst clearBtn = document.getElementById('clearBtn');\n\nconst kahnRunBtn = document.getElementById('kahnRun');\nconst kahnStepBtn = document.getElementById('kahnStep');\nconst kahnResetBtn = document.getElementById('kahnReset');\n\nconst dfsRunBtn = document.getElementById('dfsRun');\nconst dfsStepBtn = document.getElementById('dfsStep');\nconst dfsResetBtn = document.getElementById('dfsReset');\n\nconst deleteSelectedBtn = document.getElementById('deleteSelected');\nconst centerSelectedBtn = document.getElementById('centerSelected');\n\n/* --- Interaction state --- */\nlet mode = 'idle'; // 'idle', 'add-node', 'add-edge', 'delete'\nlet selected = null; // {type:'node'|'edge', id}\nlet edgeSource = null; // node id when in add-edge mode\nlet dragging = null; // node id\nlet pointerOffset = {x:0,y:0};\n\n/* --- Algorithm states --- */\nlet kahnState = null;\nlet dfsState = null;\n\n/* --- Utilities --- */\nfunction log(msg){\n  const div = document.createElement('div');\n  div.textContent = msg;\n  logEl.appendChild(div);\n  logEl.scrollTop = logEl.scrollHeight;\n}\n\nfunction setMode(m){\n  mode = m;\n  modeLabel.textContent = 'Mode: ' + (m==='idle' ? 'Idle' : (m==='add-node' ? 'Add Node' : (m==='add-edge' ? 'Add Edge' : 'Delete')));\n  document.querySelectorAll('button').forEach(b=>b.disabled=false);\n  // leave algorithm buttons enabled; but we'd like to indicate active mode visually\n  addNodeBtn.disabled = (mode==='add-node');\n  addEdgeBtn.disabled = (mode==='add-edge');\n  deleteBtn.disabled = (mode==='delete');\n}\n\n/* --- Graph operations --- */\nfunction addNode(x,y){\n  const id = nextNodeId++;\n  nodes.push({id, x, y});\n  render();\n  log('Added node ' + id);\n  return id;\n}\nfunction removeNode(id){\n  nodes = nodes.filter(n => n.id !== id);\n  const removedEdges = edges.filter(e => e.from === id || e.to === id);\n  edges = edges.filter(e => e.from !== id && e.to !== id);\n  render();\n  log('Removed node ' + id + ' and ' + removedEdges.length + ' incident edges');\n}\nfunction addEdge(from,to){\n  if(from===to){ log('Self-loops are not allowed'); return null; }\n  // disallow duplicate edges\n  if(edges.some(e=>e.from===from && e.to===to)){ log('Edge already exists'); return null;}\n  const id = nextEdgeId++;\n  edges.push({id, from, to});\n  render();\n  log(`Added edge ${from} → ${to}`);\n  return id;\n}\nfunction removeEdge(id){\n  const e = edges.find(x=>x.id===id);\n  if(!e) return;\n  edges = edges.filter(x=>x.id!==id);\n  render();\n  log(`Removed edge ${e.from} → ${e.to}`);\n}\n\n/* --- Render --- */\nfunction computeInDegrees(){\n  const deg = new Map();\n  nodes.forEach(n=>deg.set(n.id,0));\n  edges.forEach(e=>deg.set(e.to, (deg.get(e.to)||0)+1));\n  return deg;\n}\n\nfunction detectCycle(){\n  // Try Kahn: if result length < nodes => cycle\n  const inDeg = computeInDegrees();\n  const q = [];\n  for(const [id,d] of inDeg) if(d===0) q.push(id);\n  const copyEdges = edges.map(e=>({from:e.from,to:e.to}));\n  const order = [];\n  while(q.length){\n    const u = q.shift();\n    order.push(u);\n    // remove outgoing\n    for(let i=copyEdges.length-1;i>=0;i--){\n      const e = copyEdges[i];\n      if(e.from===u){\n        inDeg.set(e.to, inDeg.get(e.to)-1);\n        copyEdges.splice(i,1);\n        if(inDeg.get(e.to)===0) q.push(e.to);\n      }\n    }\n  }\n  if(order.length !== nodes.length) return true;\n  return false;\n}\n\nfunction highlightCycle(){\n  // Use DFS detection to highlight nodes in cycles (back-edges). We'll mark nodes involved in back edges.\n  // We'll perform DFS and collect nodes that are on a back edge.\n  const adj = new Map();\n  nodes.forEach(n=>adj.set(n.id,[]));\n  edges.forEach(e=>adj.get(e.from).push(e.to));\n  const color = new Map(); nodes.forEach(n=>color.set(n.id,'white'));\n  const inCycle = new Set();\n  function dfs(u, stack){\n    color.set(u,'gray'); stack.push(u);\n    for(const v of adj.get(u)){\n      if(color.get(v)==='white') dfs(v, stack);\n      else if(color.get(v)==='gray'){\n        // back edge u -> v, nodes on stack from v..u are in cycle\n        const idx = stack.indexOf(v);\n        if(idx!==-1) for(let i=idx;i<stack.length;i++) inCycle.add(stack[i]);\n        inCycle.add(v); inCycle.add(u);\n      }\n    }\n    stack.pop();\n    color.set(u,'black');\n  }\n  nodes.forEach(n=>{ if(color.get(n.id)==='white') dfs(n.id,[]); });\n  return inCycle;\n}\n\nfunction render(){\n  // Clear\n  edgesG.innerHTML=''; nodesG.innerHTML='';\n  nodeCountEl.textContent = nodes.length;\n  edgeCountEl.textContent = edges.length;\n\n  // compute in-degree\n  const inDeg = computeInDegrees();\n\n  // draw edges first\n  edges.forEach(e=>{\n    const fromNode = nodes.find(n=>n.id===e.from);\n    const toNode = nodes.find(n=>n.id===e.to);\n    if(!fromNode || !toNode) return;\n    const dx = toNode.x - fromNode.x;\n    const dy = toNode.y - fromNode.y;\n    const dist = Math.sqrt(dx*dx + dy*dy) || 1;\n    // line endpoints just outside circle radius 26\n    const r = 26;\n    const fx = fromNode.x + (dx/dist)*r;\n    const fy = fromNode.y + (dy/dist)*r;\n    const tx = toNode.x - (dx/dist)*r;\n    const ty = toNode.y - (dy/dist)*r;\n    // path as straight line (could be curved)\n    const path = document.createElementNS('http://www.w3.org/2000/svg','path');\n    path.setAttribute('d', `M ${fx} ${fy} L ${tx} ${ty}`);\n    path.setAttribute('class','edge-path');\n    path.setAttribute('marker-end', 'url(#arrow)');\n    path.dataset.edgeId = e.id;\n    edgesG.appendChild(path);\n  });\n\n  // detect cycle\n  const hasCycle = detectCycle();\n  if(hasCycle){\n    graphStatusEl.textContent = 'Cycle detected';\n    graphStatusEl.style.color = 'var(--warn)';\n  } else {\n    graphStatusEl.textContent = 'No cycle detected';\n    graphStatusEl.style.color = 'var(--ok)';\n  }\n\n  // build highlight sets from algorithm states\n  const kahnProcessed = (kahnState && kahnState.processed) ? new Set(kahnState.processed) : new Set();\n  const kahnQueue = (kahnState && kahnState.queue) ? new Set(kahnState.queue) : new Set();\n  const kahnCurrent = (kahnState && kahnState.current) ? kahnState.current : null;\n  const dfsVisited = (dfsState && dfsState.color) ? dfsState.color : new Map();\n  const dfsOrderSet = (dfsState && dfsState.order) ? new Set(dfsState.order) : new Set();\n\n  const cycleNodes = hasCycle ? highlightCycle() : new Set();\n\n  // draw nodes on top\n  nodes.forEach(n=>{\n    const g = document.createElementNS('http://www.w3.org/2000/svg','g');\n    g.setAttribute('transform', `translate(${n.x},${n.y})`);\n    g.classList.add('node');\n    g.dataset.nodeId = n.id;\n\n    // outer shadow circle\n    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');\n    circle.setAttribute('r', 26);\n    circle.setAttribute('class', 'node-circle');\n    circle.setAttribute('fill', 'rgba(14,20,31,0.6)');\n    g.appendChild(circle);\n\n    // dynamic classes\n    if(cycleNodes.has(n.id)){\n      circle.classList.add('node-cycle');\n      circle.setAttribute('fill','rgba(239,68,68,0.06)');\n    } else if(n.id === kahnCurrent){\n      circle.classList.add('node-current');\n      circle.setAttribute('fill','rgba(124,58,237,0.22)');\n    } else if(kahnProcessed.has(n.id)){\n      circle.classList.add('node-processed');\n      circle.setAttribute('fill','rgba(124,58,237,0.12)');\n    } else if(kahnQueue.has(n.id)){\n      circle.classList.add('node-zero');\n      circle.setAttribute('fill','rgba(16,185,129,0.02)');\n    } else if(dfsVisited.get(n.id) === 'gray'){\n      circle.classList.add('node-current');\n      circle.setAttribute('fill','rgba(124,58,237,0.18)');\n    } else if(dfsVisited.get(n.id) === 'black'){\n      circle.classList.add('node-processed');\n      circle.setAttribute('fill','rgba(124,58,237,0.08)');\n    }\n\n    // node id label\n    const label = document.createElementNS('http://www.w3.org/2000/svg','text');\n    label.setAttribute('y', 6);\n    label.setAttribute('text-anchor','middle');\n    label.setAttribute('class','n-label');\n    label.textContent = String(n.id);\n    g.appendChild(label);\n\n    // in-degree small label below\n    const sub = document.createElementNS('http://www.w3.org/2000/svg','text');\n    sub.setAttribute('y', 28);\n    sub.setAttribute('text-anchor','middle');\n    sub.setAttribute('class','n-sub');\n    sub.textContent = 'in: ' + (inDeg.get(n.id)||0);\n    g.appendChild(sub);\n\n    nodesG.appendChild(g);\n  });\n\n  // update selected info\n  if(selected){\n    if(selected.type==='node'){\n      const n = nodes.find(x=>x.id===selected.id);\n      if(n) selectedInfoEl.textContent = `Node ${n.id} (in: ${computeInDegrees().get(n.id)})`;\n      else selectedInfoEl.textContent = 'None';\n    } else {\n      const e = edges.find(x=>x.id===selected.id);\n      if(e) selectedInfoEl.textContent = `Edge ${e.from} → ${e.to}`;\n      else selectedInfoEl.textContent = 'None';\n    }\n  } else {\n    selectedInfoEl.textContent = 'None';\n  }\n\n  kahnOrderEl.textContent = kahnState && kahnState.processed ? '[' + kahnState.processed.join(', ') + ']' : '[]';\n  dfsOrderEl.textContent = dfsState && dfsState.order ? '[' + dfsState.order.join(', ') + ']' : '[]';\n}\n\n/* --- Event handlers for SVG interactions --- */\nsvg.addEventListener('pointerdown', e=>{\n  const pt = screenToSvg(e.clientX, e.clientY);\n  if(mode==='add-node'){\n    addNode(pt.x, pt.y);\n    mode='idle'; setMode(mode);\n    return;\n  }\n  // check if clicked on node or edge\n  const target = e.target;\n  const nodeG = findAncestor(target, node => node.dataset && node.dataset.nodeId);\n  const edgePath = findAncestor(target, el => el.dataset && el.dataset.edgeId);\n  if(mode==='add-edge'){\n    if(nodeG){\n      const nid = Number(nodeG.dataset.nodeId);\n      if(edgeSource==null){\n        edgeSource = nid;\n        log('Edge source selected: ' + nid + '. Click target node.');\n      } else {\n        const src = edgeSource;\n        const tgt = nid;\n        edgeSource = null;\n        addEdge(src,tgt);\n        // stay in add-edge mode\n      }\n    }\n    return;\n  }\n  if(mode==='delete'){\n    if(nodeG){\n      const nid = Number(nodeG.dataset.nodeId);\n      removeNode(nid);\n      selected = null;\n      mode='idle'; setMode(mode);\n    } else if(edgePath){\n      const eid = Number(edgePath.dataset.edgeId);\n      removeEdge(eid);\n      selected = null;\n      mode='idle'; setMode(mode);\n    } else {\n      // clicked empty space\n      mode='idle'; setMode(mode);\n    }\n    return;\n  }\n  // default idle: select or start drag\n  if(nodeG){\n    const nid = Number(nodeG.dataset.nodeId);\n    selected = {type:'node', id: nid};\n    dragging = nid;\n    const node = nodes.find(x=>x.id===nid);\n    pointerOffset.x = pt.x - node.x;\n    pointerOffset.y = pt.y - node.y;\n    nodeG.classList.add('dragging');\n    render();\n  } else if(edgePath){\n    const eid = Number(edgePath.dataset.edgeId);\n    selected = {type:'edge', id: eid};\n    render();\n  } else {\n    selected = null;\n    render();\n  }\n});\n\nsvg.addEventListener('pointermove', e=>{\n  if(!dragging) return;\n  const pt = screenToSvg(e.clientX, e.clientY);\n  const node = nodes.find(x=>x.id===dragging);\n  if(node){\n    node.x = pt.x - pointerOffset.x;\n    node.y = pt.y - pointerOffset.y;\n    render();\n  }\n});\n\nsvg.addEventListener('pointerup', e=>{\n  if(dragging){\n    const gels = nodesG.querySelectorAll('g');\n    gels.forEach(g=>g.classList.remove('dragging'));\n    dragging = null;\n    render();\n  }\n});\n\nfunction screenToSvg(clientX, clientY){\n  const pt = svg.createSVGPoint();\n  pt.x = clientX; pt.y = clientY;\n  const ctm = svg.getScreenCTM().inverse();\n  const svgP = pt.matrixTransform(ctm);\n  return {x: svgP.x, y: svgP.y};\n}\nfunction findAncestor(el, predicate){\n  while(el && el!==svg){\n    if(predicate(el)) return el;\n    el = el.parentNode;\n  }\n  return null;\n}\n\n/* --- Buttons & controls --- */\naddNodeBtn.addEventListener('click', ()=>{ setMode('add-node'); log('Click canvas to place new node'); });\naddEdgeBtn.addEventListener('click', ()=>{ edgeSource = null; setMode('add-edge'); log('Click source node then target node to create edge'); });\ndeleteBtn.addEventListener('click', ()=>{ setMode('delete'); log('Click node or edge to delete it'); });\nrandomDAGBtn.addEventListener('click', ()=>{\n  const n = Math.max(2, Math.min(20, Number(document.getElementById('randN').value)||6));\n  generateRandomDAG(n);\n});\nclearBtn.addEventListener('click', ()=>{\n  nodes = []; edges = []; nextNodeId=1; nextEdgeId=1; selected=null; edgeSource=null; kahnState=null; dfsState=null;\n  log('Cleared graph');\n  render();\n});\n\ndeleteSelectedBtn.addEventListener('click', ()=>{\n  if(!selected){ log('Nothing selected'); return; }\n  if(selected.type==='node') removeNode(selected.id);\n  if(selected.type==='edge') removeEdge(selected.id);\n  selected = null;\n  render();\n});\ncenterSelectedBtn.addEventListener('click', ()=>{\n  if(!selected || selected.type!=='node') return;\n  // No view transforms implemented, so just log and maybe highlight\n  log('Centered on node ' + selected.id + '. (Drag to move nodes manually)');\n});\n\n/* --- Random DAG generation --- */\nfunction generateRandomDAG(n){\n  nodes = []; edges = []; nextNodeId=1; nextEdgeId=1;\n  // place nodes in columns left-to-right to encourage acyclicity\n  const w = 1100, h = 700;\n  for(let i=0;i<n;i++){\n    const x = 100 + Math.random()*(w-200);\n    const y = 60 + Math.random()*(h-120);\n    addNode(x,y);\n  }\n  // create random edges but ensure no cycles by only adding edges from lower-index to higher-index after random permutation\n  const perm = nodes.map(n=>n.id).sort(()=>Math.random()-0.5);\n  for(let i=0;i<perm.length;i++){\n    for(let j=i+1;j<perm.length;j++){\n      if(Math.random() < 0.2){\n        addEdge(perm[i], perm[j]);\n      }\n    }\n  }\n  log('Generated random DAG with ' + nodes.length + ' nodes');\n}\n\n/* --- Kahn's algorithm implementation (step-by-step) --- */\nfunction initKahn(){\n  const inDeg = computeInDegrees();\n  const queue = [];\n  for(const [id,d] of inDeg) if(d===0) queue.push(id);\n  kahnState = {inDeg, queue, processed:[], current:null};\n  log('Kahn initialized. Queue: [' + queue.join(', ') + ']');\n  render();\n}\n\nfunction kahnStep(){\n  if(!kahnState){ initKahn(); return; }\n  if(kahnState.queue.length===0){\n    // finished or stuck\n    if(kahnState.processed.length === nodes.length){\n      log('Kahn finished. Topological order: [' + kahnState.processed.join(', ') + ']');\n    } else {\n      log('Kahn cannot proceed: graph has a cycle or no zero in-degree nodes available.');\n      // highlight cycle nodes\n    }\n    kahnState.current = null;\n    render();\n    return;\n  }\n  const u = kahnState.queue.shift();\n  kahnState.current = u;\n  kahnState.processed.push(u);\n  log('Processing node ' + u);\n  // remove outgoing edges from u\n  const outEdges = edges.filter(e => e.from === u);\n  for(const e of outEdges){\n    const v = e.to;\n    kahnState.inDeg.set(v, kahnState.inDeg.get(v)-1);\n    log(`Decrement in-degree of ${v} -> ${kahnState.inDeg.get(v)}`);\n    if(kahnState.inDeg.get(v)===0){\n      kahnState.queue.push(v);\n      log('Enqueued ' + v);\n    }\n  }\n  // (we don't physically remove edges from edges[] here)\n  // if queue empty after this step, next step will complete or detect cycle\n  render();\n}\n\nfunction runKahnFull(){\n  initKahn();\n  while(kahnState.queue.length>0){\n    kahnStep();\n  }\n  // after loop, check cycle\n  if(kahnState.processed.length !== nodes.length){\n    log('Kahn finished but graph has a cycle. Processed ' + kahnState.processed.length + ' of ' + nodes.length);\n    // highlight cycle nodes by marking them via render\n  } else {\n    log('Kahn completed. Topological ordering: [' + kahnState.processed.join(', ') + ']');\n  }\n  kahnState.current = null;\n  render();\n}\nfunction resetKahn(){\n  kahnState = null;\n  log('Kahn state reset');\n  render();\n}\n\n/* --- DFS-based topological sort (step-by-step using explicit stack) --- */\nfunction initDFS(){\n  const color = new Map();\n  const adj = new Map();\n  nodes.forEach(n=>{ color.set(n.id, 'white'); adj.set(n.id, []); });\n  edges.forEach(e=>adj.get(e.from).push(e.to));\n  dfsState = {color, adj, stack:[], iterStack:[], order:[], current:null, foundCycle:false};\n  log('DFS initialized');\n  render();\n}\n\nfunction dfsStep(){\n  if(!dfsState) { initDFS(); return; }\n  const S = dfsState;\n  // If there's an active node in stack, continue exploring it\n  if(S.stack.length===0){\n    // pick a white node to start\n    const start = nodes.find(n=>S.color.get(n.id) === 'white');\n    if(!start){\n      log('DFS finished. Topological order (reverse finish times): [' + S.order.join(', ') + ']');\n      render();\n      return;\n    }\n    log('Start DFS at node ' + start.id);\n    S.stack.push(start.id);\n    S.iterStack.push(0); // index into adjacency\n    S.color.set(start.id, 'gray');\n    S.current = start.id;\n    render();\n    return;\n  }\n  // get top node\n  const u = S.stack[S.stack.length-1];\n  const it = S.iterStack[S.iterStack.length-1];\n  const nbrs = S.adj.get(u);\n  if(it < nbrs.length){\n    const v = nbrs[it];\n    S.iterStack[S.iterStack.length-1] = it+1;\n    if(S.color.get(v) === 'white'){\n      // go deeper\n      S.stack.push(v);\n      S.iterStack.push(0);\n      S.color.set(v,'gray');\n      S.current = v;\n      log('Visit ' + v + ' from ' + u);\n    } else if(S.color.get(v) === 'gray'){\n      // back edge -> cycle\n      S.foundCycle = true;\n      log('Back-edge detected: ' + u + ' → ' + v + '. Graph has a cycle.');\n      // continue to mark\n      S.current = u;\n    } else {\n      // already finished\n    }\n  } else {\n    // finished u\n    S.stack.pop();\n    S.iterStack.pop();\n    S.color.set(u,'black');\n    S.order.unshift(u); // prepend to get topo order by finish time\n    log('Finished ' + u + '. Added to ordering.');\n    S.current = S.stack[S.stack.length-1] || null;\n  }\n  render();\n}\n\nfunction runDFSFull(){\n  initDFS();\n  while(true){\n    // simulate steps until completion\n    const S = dfsState;\n    if(S.stack.length === 0){\n      // start a new component or finish\n      const start = nodes.find(n=>S.color.get(n.id) === 'white');\n      if(!start) break;\n      S.stack.push(start.id);\n      S.iterStack.push(0);\n      S.color.set(start.id,'gray');\n      S.current = start.id;\n      continue;\n    }\n    // do inner step\n    const u = S.stack[S.stack.length-1];\n    const it = S.iterStack[S.iterStack.length-1];\n    const nbrs = S.adj.get(u);\n    if(it < nbrs.length){\n      const v = nbrs[it];\n      S.iterStack[S.iterStack.length-1] = it+1;\n      if(S.color.get(v) === 'white'){\n        S.stack.push(v);\n        S.iterStack.push(0);\n        S.color.set(v,'gray');\n      } else if(S.color.get(v) === 'gray'){\n        S.foundCycle = true;\n      }\n    } else {\n      S.stack.pop();\n      S.iterStack.pop();\n      S.color.set(u,'black');\n      S.order.unshift(u);\n    }\n  }\n  if(dfsState.foundCycle) log('DFS finished: cycle detected');\n  else log('DFS finished. Topological order: [' + dfsState.order.join(', ') + ']');\n  dfsState.current = null;\n  render();\n}\n\nfunction resetDFS(){\n  dfsState = null;\n  log('DFS state reset');\n  render();\n}\n\n/* --- Wire up algorithm buttons --- */\nkahnRunBtn.addEventListener('click', runKahnFull);\nkahnStepBtn.addEventListener('click', kahnStep);\nkahnResetBtn.addEventListener('click', resetKahn);\n\ndfsRunBtn.addEventListener('click', runDFSFull);\ndfsStepBtn.addEventListener('click', dfsStep);\ndfsResetBtn.addEventListener('click', resetDFS);\n\n/* --- Initialize with small example --- */\nfunction seedExample(){\n  nodes = []; edges = []; nextNodeId=1; nextEdgeId=1;\n  addNode(200,150); //1\n  addNode(460,120); //2\n  addNode(720,170); //3\n  addNode(320,320); //4\n  addNode(580,320); //5\n  addEdge(1,2);\n  addEdge(1,4);\n  addEdge(2,3);\n  addEdge(4,5);\n  addEdge(2,5);\n  addEdge(5,3);\n  render();\n  log('Seeded example graph');\n}\nseedExample();\nsetMode('idle');\n\n/* --- Keyboard shortcuts for convenience --- */\ndocument.addEventListener('keydown', (e)=>{\n  if(e.key === 'n') { setMode('add-node'); log('Add node mode'); }\n  if(e.key === 'e') { setMode('add-edge'); log('Add edge mode'); }\n  if(e.key === 'd') { setMode('delete'); log('Delete mode'); }\n  if(e.key === 'Escape') { setMode('idle'); edgeSource=null; log('Idle mode'); }\n});\n\n/* --- Accessibility note --- */\nlog('Keyboard shortcuts: n=add node, e=add edge, d=delete, Esc=idle. Drag nodes to reposition.');\n\n/* End of script */\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": false,
  "hasTest": true
}