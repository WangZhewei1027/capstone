{
  "id": "be876374-cd35-11f0-9e7b-93b903303299",
  "timestamp": "2025-11-29T15:13:40.395Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Heap (Min/Max)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Heap Visualizer (Min / Max)</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root{\n      --bg:#0f1720;\n      --panel:#0b1220;\n      --accent:#60a5fa;\n      --accent2:#7c3aed;\n      --muted:#94a3b8;\n      --node:#111827;\n      --node-border:#374151;\n      --good:#10b981;\n      --danger:#ef4444;\n    }\n    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,\"Helvetica Neue\",Arial;}\n    body{background:linear-gradient(180deg,var(--bg),#071022);color:#e6eef8;padding:18px;}\n    .app{max-width:1100px;margin:0 auto;display:grid;grid-template-columns:360px 1fr;gap:18px;}\n    .card{\n      background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));\n      border:1px solid rgba(255,255,255,0.04);\n      padding:16px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);\n    }\n    h1{font-size:18px;margin:0 0 8px 0;color:#eaf2ff;display:flex;align-items:center;gap:8px}\n    p.muted{color:var(--muted);margin:6px 0 12px;font-size:13px}\n    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}\n    input[type=\"text\"]{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit;min-width:120px}\n    button{background:linear-gradient(180deg,var(--accent),#3b82f6);color:white;border:0;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}\n    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}\n    .small{padding:6px 8px;font-size:13px}\n    .row{display:flex;gap:8px;align-items:center}\n    .array-view{display:flex;flex-wrap:wrap;gap:8px;padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);margin-top:12px}\n    .cell{min-width:44px;height:44px;border-radius:8px;background:var(--node);border:1px solid var(--node-border);display:flex;flex-direction:column;align-items:center;justify-content:center;font-weight:700}\n    .idx{font-size:11px;color:var(--muted);margin-top:4px;font-weight:600}\n    .log{height:130px;overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);margin-top:12px;font-size:13px}\n    .toggle{display:inline-flex;align-items:center;padding:6px 8px;background:rgba(255,255,255,0.02);border-radius:999px;border:1px solid rgba(255,255,255,0.03);gap:8px}\n    .mode{font-weight:800;color:var(--accent2)}\n    /* canvas area */\n    .canvas-wrap{position:relative;height:620px;overflow:hidden}\n    svg{position:absolute;inset:0;width:100%;height:100%}\n    .node-el{position:absolute;width:56px;height:56px;border-radius:28px;background:linear-gradient(180deg,#071331,#08263e);display:flex;align-items:center;justify-content:center;color:white;font-weight:800;border:2px solid rgba(255,255,255,0.06);box-shadow:0 6px 18px rgba(2,6,23,0.6);transition:transform 300ms ease,inset 300ms ease,left 600ms cubic-bezier(.2,.9,.2,1),top 600ms cubic-bezier(.2,.9,.2,1)}\n    .node-el.small{width:44px;height:44px;border-radius:22px;font-size:14px}\n    .node-idx{position:absolute;bottom:-18px;left:50%;transform:translateX(-50%);font-size:12px;color:var(--muted)}\n    .node-highlight{box-shadow:0 10px 30px rgba(96,165,250,0.18);border-color:var(--accent)}\n    .node-swap{border-color:var(--good);box-shadow:0 14px 40px rgba(16,185,129,0.12)}\n    .node-danger{border-color:var(--danger)}\n    .legend{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}\n    .legend .item{display:inline-flex;align-items:center;gap:8px;padding:6px 8px;background:rgba(255,255,255,0.02);border-radius:8px;color:var(--muted);font-weight:600}\n    .footer{margin-top:12px;color:var(--muted);font-size:13px}\n    .hint{font-size:13px;color:var(--muted);margin-top:8px}\n    .codebox{background:#061023;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-family:monospace;font-size:12px;color:#bfe3ff;margin-top:10px}\n  </style>\n</head>\n<body>\n  <div class=\"app\">\n    <div class=\"card\">\n      <h1>Heap Visualizer <span style=\"font-size:12px;color:var(--muted);font-weight:600;margin-left:auto\">Min / Max Heap</span></h1>\n      <p class=\"muted\">Interactive demo showing array & tree representation. Toggle min/max, insert values, extract root, and build from an array. Swaps animate to show heapify up/down.</p>\n\n      <div class=\"controls\">\n        <div class=\"row\">\n          <input id=\"valueInput\" type=\"text\" placeholder=\"value (number or label)\" />\n          <button id=\"insertBtn\" class=\"small\">Insert</button>\n          <button id=\"extractBtn\" class=\"small ghost\">Extract Root</button>\n        </div>\n        <div class=\"row\">\n          <input id=\"arrayInput\" type=\"text\" placeholder=\"e.g. 5,3,8,1,2\" />\n          <button id=\"buildBtn\" class=\"small\">Build Heap</button>\n          <button id=\"randomBtn\" class=\"small ghost\">Random</button>\n        </div>\n        <div class=\"row\">\n          <button id=\"peekBtn\" class=\"small ghost\">Peek Root</button>\n          <button id=\"clearBtn\" class=\"small ghost\">Clear</button>\n          <div style=\"margin-left:auto\" class=\"toggle\">\n            Mode:\n            <button id=\"toggleMode\" class=\"small\" style=\"background:transparent;border:0;color:var(--accent2);font-weight:900\">MIN</button>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"row\" style=\"margin-top:6px;align-items:flex-start\">\n        <div style=\"flex:1\">\n          <div class=\"array-view\" id=\"arrayView\" aria-live=\"polite\"></div>\n          <div class=\"hint\">Array (level order). Index shown below each value.</div>\n        </div>\n      </div>\n\n      <div class=\"legend\">\n        <div class=\"item\"><span style=\"display:inline-block;width:12px;height:12px;background:var(--accent);border-radius:3px\"></span> active</div>\n        <div class=\"item\"><span style=\"display:inline-block;width:12px;height:12px;background:var(--good);border-radius:3px\"></span> swapping</div>\n        <div class=\"item\"><span style=\"display:inline-block;width:12px;height:12px;background:var(--danger);border-radius:3px\"></span> removed/error</div>\n      </div>\n\n      <div class=\"log\" id=\"log\"></div>\n\n      <div class=\"footer\">\n        Complexity: Insert O(log n), Extract/Pop O(log n), Build from array O(n). Toggle between min-heap and max-heap; the comparator flips and the heap is rebuilt to match the new ordering.\n      </div>\n\n      <div class=\"codebox\" id=\"pseudocode\">\n        // Basic heap operations (concept)\n        // insert(x): push to array, siftUp(lastIndex)\n        // extractRoot(): swap root with last, pop last, siftDown(0)\n        // siftUp(i): while parent violates order, swap\n        // siftDown(i): swap with best child until correct\n      </div>\n    </div>\n\n    <div class=\"card\">\n      <h1>Tree View</h1>\n      <p class=\"muted\">Visual binary heap as a binary tree (same array order). Lines connect parents to children. Nodes animate into positions during swaps.</p>\n      <div class=\"canvas-wrap\" id=\"canvasWrap\">\n        <svg id=\"svgLines\" pointer-events=\"none\"></svg>\n        <!-- nodes are positioned absolutely -->\n      </div>\n      <div style=\"margin-top:10px;color:var(--muted);font-size:13px\">Tip: Insert several numbers and step through operations â€” swaps are animated to show heapify direction.</div>\n    </div>\n  </div>\n\n<script>\n/*\n Interactive Heap Visualizer\n - Single-file demo of min/max binary heap\n - Supports insert, extract, peek, build, random, clear, toggle mode\n - Visual: array view + tree view with animated swaps\n*/\n\n// Utilities\nconst el = id => document.getElementById(id);\nconst logBox = el('log');\nfunction log(...args){\n  const line = document.createElement('div');\n  line.textContent = args.join(' ');\n  logBox.prepend(line);\n}\n\n// Heap implementation with comparator (min if comparator(a,b) < 0)\nclass BinaryHeap {\n  constructor(isMin = true){\n    this.data = [];\n    this.isMin = !!isMin;\n    this.cmp = (a,b) => {\n      // numeric when possible, otherwise string compare\n      const na = Number(a), nb = Number(b);\n      const aVal = (isFinite(na) ? na : String(a));\n      const bVal = (isFinite(nb) ? nb : String(b));\n      if (aVal < bVal) return -1;\n      if (aVal > bVal) return 1;\n      return 0;\n    };\n    this.compare = (a,b) => this.isMin ? this.cmp(a,b) : -this.cmp(a,b);\n  }\n\n  size(){ return this.data.length; }\n  isEmpty(){ return this.size() === 0; }\n  peek(){ return this.data[0]; }\n\n  swap(i,j){\n    const tmp = this.data[i]; this.data[i] = this.data[j]; this.data[j] = tmp;\n  }\n\n  insert(value, hooks){\n    this.data.push(value);\n    if (hooks && hooks.onPush) hooks.onPush(this.size()-1);\n    this.siftUp(this.size()-1, hooks);\n  }\n\n  extractRoot(hooks){\n    if (this.isEmpty()) return undefined;\n    const root = this.data[0];\n    const last = this.data.pop();\n    if (this.size() === 0){\n      if (hooks && hooks.onRemove) hooks.onRemove(0);\n      return root;\n    }\n    this.data[0] = last;\n    if (hooks && hooks.onReplace) hooks.onReplace(0);\n    this.siftDown(0, hooks);\n    return root;\n  }\n\n  parent(i){ return Math.floor((i-1)/2); }\n  left(i){ return 2*i + 1; }\n  right(i){ return 2*i + 2; }\n\n  siftUp(i, hooks){\n    let idx = i;\n    while (idx > 0){\n      const p = this.parent(idx);\n      if (this.compare(this.data[idx], this.data[p]) < 0){\n        if (hooks && hooks.onCompare) hooks.onCompare(idx, p);\n        this.swap(idx, p);\n        if (hooks && hooks.onSwap) hooks.onSwap(idx, p);\n        idx = p;\n      } else break;\n    }\n    if (hooks && hooks.onDone) hooks.onDone();\n  }\n\n  siftDown(i, hooks){\n    let idx = i;\n    while (true){\n      const l = this.left(idx), r = this.right(idx);\n      let best = idx;\n      if (l < this.size() && this.compare(this.data[l], this.data[best]) < 0) best = l;\n      if (r < this.size() && this.compare(this.data[r], this.data[best]) < 0) best = r;\n      if (best !== idx){\n        if (hooks && hooks.onCompare) hooks.onCompare(idx, best);\n        this.swap(idx, best);\n        if (hooks && hooks.onSwap) hooks.onSwap(idx, best);\n        idx = best;\n      } else break;\n    }\n    if (hooks && hooks.onDone) hooks.onDone();\n  }\n\n  buildFromArray(arr, hooks){\n    this.data = arr.slice();\n    // heapify bottom-up\n    for (let i = Math.floor(this.size()/2)-1; i >= 0; i--){\n      this.siftDown(i, hooks);\n    }\n  }\n\n  setMode(isMin, hooks){\n    this.isMin = !!isMin;\n    this.compare = (a,b) => this.isMin ? this.cmp(a,b) : -this.cmp(a,b);\n    // rebuild to respect new comparator\n    const copy = this.data.slice();\n    this.data = [];\n    // naive re-insert to animate; use buildFromArray if immediate rebuild desired\n    for (let v of copy) this.insert(v, hooks);\n  }\n}\n\n// Visualizer\nconst svg = el('svgLines');\nconst canvas = el('canvasWrap');\nconst arrayView = el('arrayView');\n\nconst heap = new BinaryHeap(true);\nlet isAnimating = false;\nlet modeMin = true;\n\n// Keep mapping from index to DOM node element for animation\nconst nodeElems = [];\n\nfunction clearNodes(){\n  nodeElems.forEach(n => n.el && n.el.remove());\n  nodeElems.length = 0;\n  svg.innerHTML = '';\n}\n\nfunction createNodeElement(value, index){\n  const div = document.createElement('div');\n  div.className = 'node-el';\n  div.style.position = 'absolute';\n  div.style.left = '0px';\n  div.style.top = '0px';\n  div.style.zIndex = 1000;\n  div.tabIndex = 0;\n  div.textContent = value;\n  const idxLabel = document.createElement('div');\n  idxLabel.className = 'node-idx';\n  idxLabel.textContent = index;\n  div.appendChild(idxLabel);\n  canvas.appendChild(div);\n  return div;\n}\n\nfunction updateArrayView(highlight = {}, swapPair = null){\n  arrayView.innerHTML = '';\n  const data = heap.data;\n  data.forEach((v,i) => {\n    const c = document.createElement('div');\n    c.className = 'cell';\n    if (i === highlight.idx) c.style.boxShadow = '0 8px 20px rgba(96,165,250,0.15)';\n    if (swapPair && (swapPair[0]===i || swapPair[1]===i)) c.style.borderColor = 'var(--good)';\n    const t = document.createElement('div');\n    t.textContent = v;\n    const id = document.createElement('div');\n    id.className = 'idx';\n    id.textContent = i;\n    c.appendChild(t); c.appendChild(id);\n    arrayView.appendChild(c);\n  });\n}\n\n// layout calculation for tree nodes\nfunction calcPositions(){\n  const w = canvas.clientWidth;\n  const h = canvas.clientHeight;\n  const data = heap.data;\n  const positions = [];\n  for (let i = 0; i < data.length; i++){\n    const level = Math.floor(Math.log2(i+1));\n    const firstIndexThisLevel = Math.pow(2, level) - 1;\n    const posInLevel = i - firstIndexThisLevel;\n    const nodesThisLevel = Math.pow(2, level);\n    const margin = 60;\n    const usableW = w - margin*2;\n    const x = margin + ((posInLevel + 1) / (nodesThisLevel + 1)) * usableW;\n    const levelGap = Math.min(100, (h - 60) / (Math.max(1, Math.floor(Math.log2(Math.max(1, data.length))) + 2)));\n    const y = 30 + level * levelGap;\n    positions.push({x,y,level});\n  }\n  return positions;\n}\n\nfunction drawLines(positions){\n  const data = heap.data;\n  const lines = [];\n  for (let i = 0; i < data.length; i++){\n    const l = heap.left(i), r = heap.right(i);\n    if (l < data.length){\n      lines.push({x1: positions[i].x, y1: positions[i].y, x2: positions[l].x, y2: positions[l].y});\n    }\n    if (r < data.length){\n      lines.push({x1: positions[i].x, y1: positions[i].y, x2: positions[r].x, y2: positions[r].y});\n    }\n  }\n  // render into svg\n  svg.innerHTML = '';\n  for (let ln of lines){\n    const line = document.createElementNS('http://www.w3.org/2000/svg','line');\n    line.setAttribute('x1', ln.x1);\n    line.setAttribute('y1', ln.y1);\n    line.setAttribute('x2', ln.x2);\n    line.setAttribute('y2', ln.y2);\n    line.setAttribute('stroke', 'rgba(255,255,255,0.06)');\n    line.setAttribute('stroke-width', '2');\n    svg.appendChild(line);\n  }\n}\n\n// create/update node elements and animate transitions\nfunction renderTree(highlight = {}, swapPair = null){\n  const data = heap.data;\n  const positions = calcPositions();\n\n  // ensure nodeElems length\n  while (nodeElems.length < data.length){\n    const i = nodeElems.length;\n    const elNode = createNodeElement(data[i], i);\n    nodeElems.push({el: elNode, idx: i});\n  }\n  // remove extra\n  while (nodeElems.length > data.length){\n    const n = nodeElems.pop();\n    if (n && n.el) n.el.remove();\n  }\n\n  // update text and positions\n  for (let i = 0; i < data.length; i++){\n    const n = nodeElems[i];\n    n.el.childNodes[0].nodeValue = data[i]; // text node change\n    n.el.querySelector('.node-idx').textContent = i;\n    const {x,y} = positions[i];\n    // center the element\n    const left = x - n.el.offsetWidth/2;\n    const top = y - n.el.offsetHeight/2;\n    n.el.style.left = left + 'px';\n    n.el.style.top = top + 'px';\n    // styling\n    n.el.classList.remove('node-highlight','node-swap','node-danger');\n    if (highlight.idx === i) n.el.classList.add('node-highlight');\n    if (swapPair && (swapPair[0]===i || swapPair[1]===i)) n.el.classList.add('node-swap');\n  }\n  drawLines(positions);\n  updateArrayView(highlight, swapPair);\n}\n\n// animation helpers: animate the sequence of swaps (pairs) for a single heap operation\nfunction animateSwaps(swapsSeq, finalCallback){\n  if (!swapsSeq || swapsSeq.length === 0){ renderTree(); if (finalCallback) finalCallback(); return; }\n  isAnimating = true;\n  let step = 0;\n  function next(){\n    if (step >= swapsSeq.length){\n      isAnimating = false;\n      renderTree();\n      if (finalCallback) finalCallback();\n      return;\n    }\n    const [i,j] = swapsSeq[step];\n    // mark swap pair\n    renderTree({}, [i,j]);\n    // perform swap in model immediately so next layout uses new positions\n    heap.swap(i,j);\n    // re-render with animation (CSS transitions handle movement)\n    setTimeout(() => {\n      renderTree({}, [i,j]);\n      step++;\n      setTimeout(next, 450);\n    }, 150);\n  }\n  next();\n}\n\n// To capture swaps during internal heap operations we provide hooks that record swaps\nfunction trackAndExecute(actionFn, callback){\n  const swaps = [];\n  const hooks = {\n    onPush: (idx) => {},\n    onCompare: (i,j) => { /* optional highlight */ },\n    onSwap: (i,j) => { swaps.push([i,j]); },\n    onReplace: (i) => {},\n    onRemove: (i)=>{},\n    onDone: ()=>{}\n  };\n  actionFn(hooks);\n  // animate swaps\n  animateSwaps(swaps, callback);\n}\n\n// UI bindings\nconst insertBtn = el('insertBtn');\nconst extractBtn = el('extractBtn');\nconst peekBtn = el('peekBtn');\nconst buildBtn = el('buildBtn');\nconst randomBtn = el('randomBtn');\nconst clearBtn = el('clearBtn');\nconst toggleModeBtn = el('toggleMode');\nconst valueInput = el('valueInput');\nconst arrayInput = el('arrayInput');\n\ninsertBtn.addEventListener('click', () => {\n  if (isAnimating) return;\n  const v = valueInput.value.trim();\n  if (v === '') { alert('Enter a value to insert'); return; }\n  // Insert and animate\n  trackAndExecute((hooks)=> heap.insert(v, hooks), () => {\n    log('inserted', v);\n  });\n  valueInput.value = '';\n});\n\nextractBtn.addEventListener('click', () => {\n  if (isAnimating) return;\n  if (heap.isEmpty()){ log('heap empty'); return; }\n  trackAndExecute((hooks)=>{\n    const root = heap.peek();\n    const removed = heap.extractRoot(hooks);\n    // removed returned after operations; but we log later in callback\n  }, ()=> {\n    log('extracted root');\n  });\n});\n\npeekBtn.addEventListener('click', () => {\n  if (heap.isEmpty()){ log('peek: heap empty'); return; }\n  log('peek:', heap.peek());\n});\n\nbuildBtn.addEventListener('click', () => {\n  if (isAnimating) return;\n  const txt = arrayInput.value.trim();\n  if (txt === '') { alert('Enter comma-separated values'); return; }\n  const arr = txt.split(',').map(s => s.trim()).filter(s => s.length>0);\n  // rebuild with hooks capturing swaps during heapify; but buildFromArray uses siftDown which records swaps\n  trackAndExecute((hooks)=> heap.buildFromArray(arr, hooks), ()=> {\n    log('built heap from array');\n  });\n});\n\nrandomBtn.addEventListener('click', () => {\n  if (isAnimating) return;\n  const n = 8 + Math.floor(Math.random()*5);\n  const arr = [];\n  for (let i=0;i<n;i++) arr.push(Math.floor(Math.random()*99));\n  arrayInput.value = arr.join(',');\n  buildBtn.click();\n});\n\nclearBtn.addEventListener('click', () => {\n  if (isAnimating) return;\n  heap.data = [];\n  clearNodes();\n  updateArrayView();\n  log('cleared heap');\n});\n\ntoggleModeBtn.addEventListener('click', () => {\n  if (isAnimating) return;\n  modeMin = !modeMin;\n  toggleModeBtn.textContent = modeMin ? 'MIN' : 'MAX';\n  // rebuild to reflect comparator; use hooks to animate reinsertions\n  const old = heap.data.slice();\n  heap.data = [];\n  // animate re-insertions one by one to show new order\n  let i = 0;\n  function step(){\n    if (i >= old.length){ log('switched to', modeMin ? 'MIN' : 'MAX'); return; }\n    heap.isMin = modeMin;\n    trackAndExecute((hooks)=> heap.insert(old[i], hooks), ()=>{\n      i++; step();\n    });\n  }\n  step();\n});\n\n// responsive: re-render on resize\nwindow.addEventListener('resize', () => {\n  renderTree();\n});\n\n// initial demo data\n(function initDemo(){\n  const demo = [15, 10, 8, 4, 5, 2, 1];\n  heap.buildFromArray(demo);\n  // create nodes and render\n  renderTree();\n  log('demo heap created');\n})();\n\n// expose some helpers to console for debugging\nwindow._heap = heap;\nwindow._render = renderTree;\n\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap (Min/Max)"
    }
  ],
  "topic": "Heap (Min/Max)",
  "hasFSM": false,
  "hasTest": true
}