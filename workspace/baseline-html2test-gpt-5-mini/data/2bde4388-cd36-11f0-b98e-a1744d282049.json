{
  "id": "2bde4388-cd36-11f0-b98e-a1744d282049",
  "timestamp": "2025-11-29T15:16:47.263Z",
  "type": "html-to-test",
  "htmlModel": "gpt-5-mini",
  "playwrightModel": "gpt-5-mini",
  "status": "success",
  "question": "Heap Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<title>Heap Sort Visualization</title>\n<style>\n  :root{\n    --bg:#0f1724;\n    --panel:#0b1220;\n    --muted:#9aa6bf;\n    --accent:#3b82f6;\n    --good:#10b981;\n    --danger:#ef4444;\n    --heap:#f59e0b;\n    --bar-gap:4px;\n  }\n  html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial;color:var(--muted);background:linear-gradient(180deg,#071022,var(--bg));}\n  .app{display:flex;flex-direction:column;gap:16px;padding:18px;max-width:1200px;margin:0 auto;}\n  header{display:flex;align-items:center;gap:12px;}\n  header h1{margin:0;color:#fff;font-size:20px;}\n  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}\n  button{background:linear-gradient(180deg,#111827,#0b1220);color:var(--muted);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;cursor:pointer;}\n  button.primary{background:linear-gradient(180deg,var(--accent),#1558d6);color:white;border:none;box-shadow:0 6px 20px rgba(59,130,246,0.18);}\n  button:active{transform:translateY(1px);}\n  .small{padding:6px 8px;font-size:13px;}\n  .row{display:flex;gap:12px;align-items:center;}\n  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);}\n  .visual{display:flex;gap:12px;}\n  .barsPanel{flex:1;min-height:280px;display:flex;flex-direction:column;gap:8px;}\n  .barsArea{background:rgba(255,255,255,0.01);border-radius:8px;padding:12px;flex:1;display:flex;align-items:end;overflow:hidden;}\n  .bars{display:flex;align-items:end;gap:var(--bar-gap);width:100%;height:100%;}\n  .bar{flex:1 1 auto;background:linear-gradient(180deg,#4b5563,#111827);border-radius:6px 6px 4px 4px;display:flex;align-items:flex-end;justify-content:center;transition:height 0.25s ease, background-color .15s;position:relative;}\n  .barIndex{position:absolute;left:4px;bottom:4px;font-size:11px;color:rgba(255,255,255,0.6);}\n  .barLabel{position:absolute;right:6px;top:4px;font-size:11px;color:rgba(255,255,255,0.6);}\n  .bar.compare{background:linear-gradient(180deg,#f97316,#ea580c);box-shadow:0 4px 16px rgba(249,115,22,0.12);}\n  .bar.swap{background:linear-gradient(180deg,#ef4444,#dc2626);box-shadow:0 6px 20px rgba(239,68,68,0.12);}\n  .bar.heap{background:linear-gradient(180deg,#f59e0b,#b45309);}\n  .bar.sorted{background:linear-gradient(180deg,#10b981,#059669);}\n  .stats{min-width:220px;display:flex;flex-direction:column;gap:8px;}\n  .statRow{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);}\n  .legend{display:flex;gap:8px;flex-wrap:wrap;}\n  .legendItem{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted);}\n  .swatch{width:16px;height:12px;border-radius:4px;background:#ccc;box-shadow:inset 0 -2px 0 rgba(0,0,0,0.12);}\n  .codePanel{width:420px;max-height:520px;overflow:auto;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:12px;border:1px solid rgba(255,255,255,0.02);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, \"Roboto Mono\", monospace;font-size:13px;color:var(--muted);}\n  pre{margin:0;white-space:pre-wrap;}\n  .codeLine{display:block;padding:4px 6px;border-radius:6px;}\n  .lineActive{background:rgba(99,102,241,0.12);color:#e6eefc;}\n  .smallMuted{font-size:13px;color:var(--muted);}\n  .controlsGroup{display:flex;gap:8px;align-items:center;}\n  input[type=range]{width:140px;}\n  footer{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px;margin-top:6px;}\n  .toggle{display:inline-flex;align-items:center;gap:8px;}\n  .btnIcon{display:inline-flex;align-items:center;justify-content:center;width:28px;height:28px;border-radius:6px;background:rgba(255,255,255,0.02);}\n  .smallControl{font-size:13px;color:var(--muted);}\n  @media (max-width:980px){\n    .visual{flex-direction:column;}\n    .codePanel{width:100%;}\n  }\n</style>\n</head>\n<body>\n<div class=\"app\">\n  <header>\n    <h1>Heap Sort — step-by-step visualization</h1>\n    <div class=\"smallMuted\">Learn how Heap Sort builds a max-heap and repeatedly extracts the max.</div>\n  </header>\n\n  <div class=\"controls panel\">\n    <div class=\"row\" style=\"justify-content:space-between;\">\n      <div class=\"controlsGroup\">\n        <button id=\"shuffleBtn\" class=\"small\">Shuffle / New array</button>\n        <button id=\"startBtn\" class=\"primary small\">Start</button>\n        <button id=\"stepBtn\" class=\"small\">Step</button>\n        <button id=\"playPauseBtn\" class=\"small\">Play</button>\n        <button id=\"resetBtn\" class=\"small\">Reset</button>\n      </div>\n      <div style=\"display:flex;gap:12px;align-items:center;\">\n        <label class=\"smallMuted\">Speed</label>\n        <input id=\"speedRange\" type=\"range\" min=\"10\" max=\"1000\" value=\"300\">\n        <div id=\"speedLabel\" class=\"smallMuted\">300 ms</div>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"visual\">\n    <div class=\"barsPanel panel\">\n      <div style=\"display:flex;justify-content:space-between;align-items:center;\">\n        <div class=\"smallMuted\">Array (size: <span id=\"sizeLabel\">30</span>)</div>\n        <div class=\"legend\">\n          <div class=\"legendItem\"><div class=\"swatch\" style=\"background:linear-gradient(180deg,#4b5563,#111827)\"></div> Unseen</div>\n          <div class=\"legendItem\"><div class=\"swatch\" style=\"background:linear-gradient(180deg,#f59e0b,#b45309)\"></div> In heap</div>\n          <div class=\"legendItem\"><div class=\"swatch\" style=\"background:linear-gradient(180deg,#f97316,#ea580c)\"></div> Comparing</div>\n          <div class=\"legendItem\"><div class=\"swatch\" style=\"background:linear-gradient(180deg,#ef4444,#dc2626)\"></div> Swapping</div>\n          <div class=\"legendItem\"><div class=\"swatch\" style=\"background:linear-gradient(180deg,#10b981,#059669)\"></div> Sorted</div>\n        </div>\n      </div>\n\n      <div class=\"barsArea\" id=\"barsArea\">\n        <div class=\"bars\" id=\"bars\"></div>\n      </div>\n\n      <div style=\"display:flex;justify-content:space-between;align-items:center;margin-top:6px;\">\n        <div class=\"smallMuted\">Stage: <strong id=\"stageLabel\">idle</strong></div>\n        <div class=\"smallMuted\">Comparisons: <strong id=\"compCount\">0</strong> &nbsp;|&nbsp; Swaps: <strong id=\"swapCount\">0</strong></div>\n      </div>\n    </div>\n\n    <div class=\"codePanel panel\" id=\"codePanel\">\n      <div style=\"font-weight:600;color:#fff;margin-bottom:8px;\">Pseudocode (highlighted as algorithm runs)</div>\n      <pre id=\"code\">\n<span class=\"codeLine\" data-line=\"1\">1  function heapSort(A):</span>\n<span class=\"codeLine\" data-line=\"2\">2      n = A.length</span>\n<span class=\"codeLine\" data-line=\"3\">3      # Build max-heap</span>\n<span class=\"codeLine\" data-line=\"4\">4      for i = floor(n/2) - 1 downto 0:</span>\n<span class=\"codeLine\" data-line=\"5\">5          siftDown(A, i, n)</span>\n<span class=\"codeLine\" data-line=\"6\">6      # Extract elements</span>\n<span class=\"codeLine\" data-line=\"7\">7      for end = n - 1 downto 1:</span>\n<span class=\"codeLine\" data-line=\"8\">8          swap(A[0], A[end])</span>\n<span class=\"codeLine\" data-line=\"9\">9          siftDown(A, 0, end)</span>\n<span class=\"codeLine\" data-line=\"10\">10     return A</span>\n\n<span class=\"codeLine\" data-line=\"11\"></span>\n<span class=\"codeLine\" data-line=\"12\">11 function siftDown(A, root, n):</span>\n<span class=\"codeLine\" data-line=\"13\">12     while true:</span>\n<span class=\"codeLine\" data-line=\"14\">13         child = 2 * root + 1</span>\n<span class=\"codeLine\" data-line=\"15\">14         if child >= n: break</span>\n<span class=\"codeLine\" data-line=\"16\">15         swapIdx = root</span>\n<span class=\"codeLine\" data-line=\"17\">16         if A[swapIdx] < A[child]: swapIdx = child</span>\n<span class=\"codeLine\" data-line=\"18\">17         if child + 1 < n and A[swapIdx] < A[child + 1]: swapIdx = child + 1</span>\n<span class=\"codeLine\" data-line=\"19\">18         if swapIdx == root: return</span>\n<span class=\"codeLine\" data-line=\"20\">19         swap(A[root], A[swapIdx])</span>\n<span class=\"codeLine\" data-line=\"21\">20         root = swapIdx</span>\n      </pre>\n    </div>\n  </div>\n\n  <footer>\n    <div class=\"smallMuted\">This demo uses a max-heap (0-based array). Building the heap is O(n), full sort is O(n log n).</div>\n    <div class=\"smallMuted\">Data mutated in-place.</div>\n  </footer>\n</div>\n\n<script>\n(function(){\n  // Configuration\n  const DEFAULT_SIZE = 30;\n  const MIN_VAL = 5;\n  const MAX_VAL = 100;\n\n  // DOM elements\n  const barsEl = document.getElementById('bars');\n  const sizeLabel = document.getElementById('sizeLabel');\n  const stageLabel = document.getElementById('stageLabel');\n  const compCountEl = document.getElementById('compCount');\n  const swapCountEl = document.getElementById('swapCount');\n  const startBtn = document.getElementById('startBtn');\n  const shuffleBtn = document.getElementById('shuffleBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const playPauseBtn = document.getElementById('playPauseBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const speedRange = document.getElementById('speedRange');\n  const speedLabel = document.getElementById('speedLabel');\n  const codePanel = document.getElementById('codePanel');\n  const codeLines = Array.from(document.querySelectorAll('.codeLine'));\n  const barsArea = document.getElementById('barsArea');\n\n  // State\n  let values = [];\n  let bars = [];\n  let generator = null;\n  let running = false;\n  let playing = false;\n  let compCount = 0;\n  let swapCount = 0;\n  let heapSize = 0;\n  let delay = parseInt(speedRange.value); // ms\n  let lastAction = null;\n\n  // Utilities\n  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }\n\n  function createArray(n){\n    const arr = [];\n    for(let i=0;i<n;i++) arr.push(randInt(MIN_VAL, MAX_VAL));\n    return arr;\n  }\n\n  function renderBars(){\n    barsEl.innerHTML = '';\n    bars = [];\n    const maxV = Math.max(...values);\n    for(let i=0;i<values.length;i++){\n      const v = values[i];\n      const bar = document.createElement('div');\n      bar.className = 'bar';\n      bar.style.height = (v/maxV*100) + '%';\n      bar.style.transitionDuration = (delay/1000) + 's';\n      bar.dataset.index = i;\n      const idx = document.createElement('div');\n      idx.className = 'barIndex';\n      idx.textContent = i;\n      const lbl = document.createElement('div');\n      lbl.className = 'barLabel';\n      lbl.textContent = v;\n      bar.appendChild(idx);\n      bar.appendChild(lbl);\n      barsEl.appendChild(bar);\n      bars.push(bar);\n    }\n    sizeLabel.textContent = values.length;\n  }\n\n  function updateLabels(){\n    compCountEl.textContent = compCount;\n    swapCountEl.textContent = swapCount;\n  }\n\n  function highlightLine(n){\n    codeLines.forEach(line => {\n      if(parseInt(line.dataset.line) === n) line.classList.add('lineActive');\n      else line.classList.remove('lineActive');\n    });\n  }\n  function clearHighlights(){ codeLines.forEach(l=>l.classList.remove('lineActive')); }\n\n  function markHeapRange(n){\n    heapSize = n;\n    // mark bars in heap range\n    for(let i=0;i<bars.length;i++){\n      bars[i].classList.remove('heap');\n      if(i < n && !bars[i].classList.contains('sorted')){\n        bars[i].classList.add('heap');\n      }\n    }\n  }\n\n  function markSorted(index){\n    bars[index].classList.remove('heap','compare','swap');\n    bars[index].classList.add('sorted');\n  }\n\n  function setCompare(i,j){\n    clearActionMarks();\n    if (bars[i]) bars[i].classList.add('compare');\n    if (bars[j]) bars[j].classList.add('compare');\n  }\n\n  function setSwap(i,j){\n    clearActionMarks();\n    if (bars[i]) bars[i].classList.add('swap');\n    if (bars[j]) bars[j].classList.add('swap');\n  }\n\n  function clearActionMarks(){\n    bars.forEach(b => {\n      b.classList.remove('compare','swap');\n    });\n  }\n\n  function swapValues(i,j){\n    // swap values array\n    const t = values[i]; values[i] = values[j]; values[j] = t;\n    // swap heights and labels (animate via CSS transition)\n    const maxV = Math.max(...values);\n    bars.forEach((bar, idx) => {\n      const v = values[idx];\n      bar.style.height = (v/maxV*100) + '%';\n      const lbl = bar.querySelector('.barLabel');\n      if(lbl) lbl.textContent = v;\n    });\n    // swap DOM order of indices is not necessary; we keep index labels updated.\n  }\n\n  // Heap sort generator: yields descriptive actions\n  function* heapSortSteps(A){\n    const n = A.length;\n    compCount = 0; swapCount = 0;\n    // Build max-heap\n    for(let i=Math.floor(n/2)-1;i>=0;i--){\n      yield {type:'siftStart', root:i, heapSize:n};\n      yield* siftDown(A, i, n);\n    }\n    yield {type:'setHeapRange', heapSize:n};\n\n    // Extract elements\n    for(let end=n-1; end>0; end--){\n      yield {type:'compare', indices:[0,end], line:8};\n      yield {type:'swap', indices:[0,end], line:8};\n      // perform swap\n      [A[0], A[end]] = [A[end], A[0]];\n      yield {type:'afterSwap', indices:[0,end]}; // update UI\n      yield {type:'markSorted', index:end};\n      // sift down root within reduced heap\n      yield {type:'siftStart', root:0, heapSize:end};\n      yield* siftDown(A, 0, end);\n      yield {type:'setHeapRange', heapSize:end};\n    }\n    yield {type:'markSorted', index:0};\n    yield {type:'done'};\n  }\n\n  function* siftDown(A, root, n){\n    // Corresponds to pseudocode lines 11-20\n    while(true){\n      yield {type:'line', line:12};\n      let child = 2*root + 1;\n      yield {type:'line', line:13};\n      if(child >= n) {\n        yield {type:'siftEnd', root, heapSize:n};\n        return;\n      }\n      yield {type:'line', line:15};\n      let swapIdx = root;\n      // compare root and left child\n      yield {type:'compare', indices:[swapIdx, child], line:16};\n      if(A[swapIdx] < A[child]){\n        swapIdx = child;\n      }\n      // maybe right child\n      if(child + 1 < n){\n        yield {type:'compare', indices:[swapIdx, child+1], line:17};\n        if(A[swapIdx] < A[child+1]){\n          swapIdx = child + 1;\n        }\n      }\n      yield {type:'line', line:18};\n      if(swapIdx === root){\n        yield {type:'siftEnd', root, heapSize:n};\n        return;\n      }\n      // perform swap\n      yield {type:'swap', indices:[root, swapIdx], line:19};\n      [A[root], A[swapIdx]] = [A[swapIdx], A[root]];\n      yield {type:'afterSwap', indices:[root, swapIdx], line:19};\n      root = swapIdx;\n      yield {type:'line', line:20};\n    }\n  }\n\n  // Action processor\n  async function processAction(action){\n    lastAction = action;\n    // ensure delays / transition durations are updated\n    bars.forEach(b => b.style.transitionDuration = (delay/1000) + 's');\n\n    switch(action.type){\n      case 'siftStart':\n        stageLabel.textContent = 'sift-down (root='+action.root+')';\n        highlightLine(12);\n        markHeapRange(action.heapSize);\n        break;\n      case 'siftEnd':\n        stageLabel.textContent = 'sift-down complete';\n        clearHighlights();\n        markHeapRange(action.heapSize);\n        clearActionMarks();\n        break;\n      case 'setHeapRange':\n        markHeapRange(action.heapSize);\n        stageLabel.textContent = 'heap size = ' + action.heapSize;\n        clearHighlights();\n        break;\n      case 'compare':\n        compCount++;\n        updateLabels();\n        setCompare(action.indices[0], action.indices[1]);\n        if(action.line) highlightLine(action.line);\n        stageLabel.textContent = 'comparing indices ' + action.indices[0] + ' & ' + action.indices[1];\n        break;\n      case 'swap':\n        swapCount++;\n        updateLabels();\n        setSwap(action.indices[0], action.indices[1]);\n        if(action.line) highlightLine(action.line);\n        stageLabel.textContent = 'swapping ' + action.indices[0] + ' & ' + action.indices[1];\n        break;\n      case 'afterSwap':\n        // apply UI swap (values array should have been swapped by generator)\n        swapValues(action.indices[0], action.indices[1]);\n        clearActionMarks();\n        break;\n      case 'markSorted':\n        markSorted(action.index);\n        stageLabel.textContent = 'marked sorted index ' + action.index;\n        clearHighlights();\n        break;\n      case 'done':\n        stageLabel.textContent = 'done — array sorted';\n        clearHighlights();\n        playing = false;\n        updatePlayPauseButton();\n        break;\n      case 'line':\n        highlightLine(action.line);\n        break;\n      default:\n        console.log('unknown action', action);\n    }\n\n    // Wait a bit after action (except for afterSwap and setHeapRange maybe short)\n    await pauseFor(action);\n  }\n\n  function pauseFor(action){\n    let base = delay;\n    if(action.type === 'afterSwap') base = Math.max(40, delay/1.2);\n    if(action.type === 'setHeapRange' || action.type === 'siftEnd') base = Math.max(40, delay/2);\n    // use promise\n    return new Promise(resolve => setTimeout(resolve, base));\n  }\n\n  // Driver: step once\n  async function stepOnce(){\n    if(!generator) return;\n    const res = generator.next();\n    if(res.done){\n      // finished\n      stageLabel.textContent = 'done';\n      playing = false;\n      updatePlayPauseButton();\n      return;\n    }\n    await processAction(res.value);\n  }\n\n  // Play loop\n  async function playLoop(){\n    while(playing){\n      const res = generator.next();\n      if(res.done){\n        stageLabel.textContent = 'done';\n        playing = false;\n        updatePlayPauseButton();\n        return;\n      }\n      await processAction(res.value);\n      // allow UI to break if play ended mid-wait\n      await new Promise(r => setTimeout(r, 0));\n    }\n  }\n\n  // Controls\n  function resetState(newValues){\n    values = newValues.slice();\n    compCount = 0; swapCount = 0;\n    heapSize = values.length;\n    updateLabels();\n    renderBars();\n    clearHighlights();\n    stageLabel.textContent = 'idle';\n    generator = null;\n    playing = false;\n    updatePlayPauseButton();\n  }\n\n  function startSort(){\n    if(generator) return;\n    // Defensive clone; generator will mutate its own internal array; we want UI to reflect operations.\n    const arrCopy = values.slice();\n    generator = heapSortSteps(arrCopy);\n    // Start first step automatically if play toggled\n    stageLabel.textContent = 'started';\n  }\n\n  function updatePlayPauseButton(){\n    playPauseBtn.textContent = playing ? 'Pause' : 'Play';\n    if(playing) playPauseBtn.classList.add('primary'); else playPauseBtn.classList.remove('primary');\n  }\n\n  // Event listeners\n  shuffleBtn.addEventListener('click', ()=>{\n    const size = values.length;\n    const newArr = createArray(size);\n    resetState(newArr);\n  });\n\n  startBtn.addEventListener('click', ()=>{\n    if(!generator){\n      startSort();\n      // do not auto-run; user chooses Step or Play\n    } else {\n      alert('Sorting already started. Use Step / Play / Reset.');\n    }\n  });\n\n  stepBtn.addEventListener('click', async ()=>{\n    if(!generator) startSort();\n    await stepOnce();\n  });\n\n  playPauseBtn.addEventListener('click', async ()=>{\n    if(!generator) startSort();\n    playing = !playing;\n    updatePlayPauseButton();\n    if(playing){\n      await playLoop();\n    }\n  });\n\n  resetBtn.addEventListener('click', ()=>{\n    // reset to initial random array\n    const newArr = createArray(values.length);\n    resetState(newArr);\n  });\n\n  speedRange.addEventListener('input', ()=>{\n    delay = parseInt(speedRange.value);\n    speedLabel.textContent = delay + ' ms';\n    bars.forEach(b => b.style.transitionDuration = (delay/1000) + 's');\n  });\n\n  // Initialize UI with default array\n  resetState(createArray(DEFAULT_SIZE));\n\n  // Helpful tips on first run (no alert, but instructions in console to keep file compact)\n  console.log('Heap Sort visualizer ready. Use \"Start\" then \"Step\" or \"Play\" to see the algorithm.');\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap Sort"
    }
  ],
  "topic": "Heap Sort",
  "hasFSM": false,
  "hasTest": true
}