{
  "id": "82c2e9a0-d1d0-11f0-b999-357785ae4ede",
  "timestamp": "2025-12-05T11:56:09.963Z",
  "model": "gpt-5-mini",
  "status": "success",
  "question": "Binary Search Tree (BST)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Binary Search Tree (BST) Interactive Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <style>\n    :root {\n      --bg: #0f1724;\n      --panel: #0b1220;\n      --accent: #38bdf8;\n      --muted: #9aa6b2;\n      --good: #34d399;\n      --danger: #fb7185;\n      --node-fill: #0ea5a1;\n      --node-border: #004e4b;\n    }\n    html,body { height:100%; margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial; background: radial-gradient(1200px 600px at 10% 10%, rgba(56,189,248,0.06), transparent), var(--bg); color:#e6eef6; }\n    .container { display:flex; height:100vh; gap:18px; padding:20px; box-sizing:border-box; }\n    .left {\n      width:360px;\n      min-width:260px;\n      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);\n      border:1px solid rgba(255,255,255,0.04);\n      border-radius:12px;\n      padding:18px;\n      box-sizing:border-box;\n      backdrop-filter: blur(6px);\n      display:flex;\n      flex-direction:column;\n      gap:12px;\n    }\n    h1 { margin:0; font-size:18px; letter-spacing:0.2px; color:var(--accent); }\n    p.sub { margin:0; color:var(--muted); font-size:13px; }\n    label { font-size:13px; color:var(--muted); display:block; margin-bottom:6px; }\n    .controls { display:flex; gap:8px; flex-wrap:wrap; }\n    input[type=\"number\"] { padding:10px 12px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; width:120px; }\n    button { padding:9px 12px; border-radius:8px; border:0; background:linear-gradient(180deg,var(--accent), #06a6d8); color:#04202a; font-weight:600; cursor:pointer; }\n    button.ghost { background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--muted); }\n    .small { padding:7px 10px; font-size:13px; }\n    .muted { color:var(--muted); font-size:13px; }\n    .row { display:flex; gap:8px; align-items:center; }\n    .panel { background:rgba(255,255,255,0.02); padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.02); }\n    canvas { background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent); border-radius:12px; border:1px solid rgba(255,255,255,0.03); }\n    .traversal-output { background:#071424; border-radius:8px; padding:8px; font-family:monospace; color:var(--muted); max-height:160px; overflow:auto; }\n    .stats { display:flex; gap:10px; color:var(--muted); font-size:13px; }\n    .stat { background:rgba(255,255,255,0.02); padding:8px 10px; border-radius:8px; }\n    footer { margin-top:auto; color:var(--muted); font-size:12px; text-align:center; }\n    .hint { color:var(--muted); font-size:12px; margin-top:6px; }\n    .btn-wide { flex:1; }\n    .danger { background:linear-gradient(180deg,#fb7185,#f43f5e); color:white; }\n    .controls-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; }\n    .speed { display:flex; align-items:center; gap:8px; }\n    input[type=\"range\"] { width:140px; }\n    @media (max-width:900px) {\n      .container { flex-direction:column; padding:12px; }\n      .left { width:100%; order:2; }\n      .canvas-wrap { order:1; }\n      canvas { width:100%; height:420px; }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"canvas-wrap\" style=\"flex:1; display:flex; flex-direction:column; gap:12px;\">\n      <div style=\"display:flex; align-items:center; gap:12px;\">\n        <h1>Binary Search Tree (BST)</h1>\n        <p class=\"sub\">Interactive visualizer — insert, delete, search, and traverse</p>\n      </div>\n      <canvas id=\"treeCanvas\" width=\"1200\" height=\"640\"></canvas>\n      <div style=\"display:flex; gap:8px; align-items:center; justify-content:space-between;\">\n        <div class=\"muted\">Click node to auto-fill value. Drag canvas to pan. Use mouse wheel or pinch to zoom.</div>\n        <div class=\"stats\">\n          <div class=\"stat\">Size: <span id=\"size\">0</span></div>\n          <div class=\"stat\">Height: <span id=\"height\">0</span></div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"left\">\n      <div>\n        <label for=\"valueInput\">Value (integer)</label>\n        <div style=\"display:flex; gap:8px;\">\n          <input id=\"valueInput\" type=\"number\" placeholder=\"e.g. 42\" />\n          <button id=\"insertBtn\">Insert</button>\n          <button id=\"deleteBtn\" class=\"ghost\">Delete</button>\n        </div>\n        <div style=\"display:flex; gap:8px; margin-top:8px;\">\n          <button id=\"searchBtn\" class=\"ghost\">Search</button>\n          <button id=\"clearBtn\" class=\"ghost\">Clear</button>\n        </div>\n        <div class=\"hint\">Duplicates are ignored. Values are compared as numbers.</div>\n      </div>\n\n      <div>\n        <label>Build / Randomize</label>\n        <div style=\"display:flex; gap:8px;\">\n          <input id=\"randCount\" type=\"number\" min=\"1\" max=\"30\" value=\"8\" style=\"width:90px;\" />\n          <button id=\"randomBtn\" class=\"small ghost\">Random Tree</button>\n          <button id=\"balancedBtn\" class=\"small ghost\">Balanced from Sorted</button>\n        </div>\n        <div class=\"hint\">Random: inserts random integers. Balanced: create a balanced BST from sorted unique values (keeps current values if empty).</div>\n      </div>\n\n      <div>\n        <label>Traversals & Animations</label>\n        <div class=\"controls\">\n          <button id=\"inorderBtn\" class=\"small ghost\">Inorder</button>\n          <button id=\"preorderBtn\" class=\"small ghost\">Preorder</button>\n          <button id=\"postorderBtn\" class=\"small ghost\">Postorder</button>\n          <button id=\"levelBtn\" class=\"small ghost\">Level-order</button>\n        </div>\n        <div style=\"display:flex; gap:8px; margin-top:8px; align-items:center;\">\n          <div class=\"speed panel\" style=\"display:flex; align-items:center;\">\n            <label style=\"margin-right:6px; color:var(--muted); font-size:13px;\">Speed</label>\n            <input id=\"speedRange\" type=\"range\" min=\"100\" max=\"1200\" step=\"50\" value=\"400\" />\n            <span id=\"speedVal\" style=\"width:42px; text-align:right; color:var(--muted); font-size:13px;\">400ms</span>\n          </div>\n          <button id=\"stopAnim\" class=\"ghost small\">Stop</button>\n        </div>\n      </div>\n\n      <div>\n        <label>Traversal Output</label>\n        <div class=\"traversal-output\" id=\"output\">[]</div>\n      </div>\n\n      <div style=\"display:flex; gap:8px;\">\n        <button id=\"exportBtn\" class=\"small ghost btn-wide\">Export Values (JSON)</button>\n        <button id=\"importBtn\" class=\"small ghost btn-wide\">Import JSON</button>\n      </div>\n\n      <footer>\n        Tip: Insert numbers in any order. Deleting a node follows standard BST rules (replace with in-order successor when needed).\n      </footer>\n    </div>\n  </div>\n\n<script>\n/*\n  BST Interactive Demo\n  - Insert/Delete/Search with animations\n  - Traversals with animated highlighting\n  - Canvas pan & zoom, node click to autofill\n  - Balanced build & random tree\n*/\n\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    // for drawing\n    this.x = 0;\n    this.y = 0;\n  }\n}\n\nclass BST {\n  constructor() {\n    this.root = null;\n    this.size = 0;\n  }\n\n  insert(value) {\n    if (this.root === null) {\n      this.root = new Node(value);\n      this.size = 1;\n      return { inserted: true, path: [this.root] };\n    }\n    let cur = this.root;\n    const path = [];\n    while (cur) {\n      path.push(cur);\n      if (value === cur.value) return { inserted: false, path }; // duplicate\n      if (value < cur.value) {\n        if (cur.left) cur = cur.left;\n        else {\n          cur.left = new Node(value);\n          this.size++;\n          path.push(cur.left);\n          return { inserted: true, path };\n        }\n      } else {\n        if (cur.right) cur = cur.right;\n        else {\n          cur.right = new Node(value);\n          this.size++;\n          path.push(cur.right);\n          return { inserted: true, path };\n        }\n      }\n    }\n    return { inserted: false, path };\n  }\n\n  findWithPath(value) {\n    let cur = this.root;\n    const path = [];\n    while (cur) {\n      path.push(cur);\n      if (value === cur.value) return { found: true, node: cur, path };\n      if (value < cur.value) cur = cur.left;\n      else cur = cur.right;\n    }\n    return { found: false, node: null, path };\n  }\n\n  // recursive delete return new subtree and record path visited\n  delete(value) {\n    const path = [];\n    const deleteRec = (node) => {\n      if (!node) return null;\n      path.push(node);\n      if (value < node.value) {\n        node.left = deleteRec(node.left);\n        return node;\n      } else if (value > node.value) {\n        node.right = deleteRec(node.right);\n        return node;\n      } else {\n        // found: three cases\n        if (!node.left && !node.right) {\n          this.size--;\n          return null;\n        } else if (!node.left) {\n          this.size--;\n          return node.right;\n        } else if (!node.right) {\n          this.size--;\n          return node.left;\n        } else {\n          // two children: find inorder successor (smallest in right subtree)\n          let succParent = node;\n          let succ = node.right;\n          while (succ.left) {\n            succParent = succ;\n            succ = succ.left;\n          }\n          // succ is successor\n          node.value = succ.value;\n          // delete successor in right subtree\n          node.right = deleteRecHelper(node.right, succ.value);\n          return node;\n        }\n      }\n    };\n\n    // helper to avoid duplicating path pushes during successor deletion\n    const deleteRecHelper = (node, val) => {\n      if (!node) return null;\n      path.push(node);\n      if (val < node.value) {\n        node.left = deleteRecHelper(node.left, val);\n        return node;\n      } else if (val > node.value) {\n        node.right = deleteRecHelper(node.right, val);\n        return node;\n      } else {\n        if (!node.left && !node.right) {\n          this.size--;\n          return null;\n        } else if (!node.left) {\n          this.size--;\n          return node.right;\n        } else if (!node.right) {\n          this.size--;\n          return node.left;\n        } else {\n          // shouldn't usually happen for successor case, but handle generically\n          let succ = node.right;\n          while (succ.left) succ = succ.left;\n          node.value = succ.value;\n          node.right = deleteRecHelper(node.right, succ.value);\n          return node;\n        }\n      }\n    };\n\n    const beforeSize = this.size;\n    this.root = deleteRec(this.root);\n    const deleted = this.size < beforeSize;\n    return { deleted, path };\n  }\n\n  inorder(node = this.root, arr = []) {\n    if (!node) return arr;\n    this.inorder(node.left, arr);\n    arr.push(node);\n    this.inorder(node.right, arr);\n    return arr;\n  }\n  preorder(node = this.root, arr = []) {\n    if (!node) return arr;\n    arr.push(node);\n    this.preorder(node.left, arr);\n    this.preorder(node.right, arr);\n    return arr;\n  }\n  postorder(node = this.root, arr = []) {\n    if (!node) return arr;\n    this.postorder(node.left, arr);\n    this.postorder(node.right, arr);\n    arr.push(node);\n    return arr;\n  }\n  levelorder() {\n    const arr = [];\n    if (!this.root) return arr;\n    const q = [this.root];\n    while (q.length) {\n      const n = q.shift();\n      arr.push(n);\n      if (n.left) q.push(n.left);\n      if (n.right) q.push(n.right);\n    }\n    return arr;\n  }\n\n  height(node = this.root) {\n    if (!node) return 0;\n    return 1 + Math.max(this.height(node.left), this.height(node.right));\n  }\n\n  toArray() {\n    return this.inorder().map(n => n.value);\n  }\n\n  clear() {\n    this.root = null;\n    this.size = 0;\n  }\n}\n\n// Canvas drawing & UI\nconst canvas = document.getElementById('treeCanvas');\nconst ctx = canvas.getContext('2d', { alpha: false });\n\nlet width = canvas.width;\nlet height = canvas.height;\n\nconst tree = new BST();\n\nconst UI = {\n  valueInput: document.getElementById('valueInput'),\n  insertBtn: document.getElementById('insertBtn'),\n  deleteBtn: document.getElementById('deleteBtn'),\n  searchBtn: document.getElementById('searchBtn'),\n  clearBtn: document.getElementById('clearBtn'),\n  randomBtn: document.getElementById('randomBtn'),\n  balancedBtn: document.getElementById('balancedBtn'),\n  randCount: document.getElementById('randCount'),\n  inorderBtn: document.getElementById('inorderBtn'),\n  preorderBtn: document.getElementById('preorderBtn'),\n  postorderBtn: document.getElementById('postorderBtn'),\n  levelBtn: document.getElementById('levelBtn'),\n  output: document.getElementById('output'),\n  sizeEl: document.getElementById('size'),\n  heightEl: document.getElementById('height'),\n  speedRange: document.getElementById('speedRange'),\n  speedVal: document.getElementById('speedVal'),\n  stopAnim: document.getElementById('stopAnim'),\n  exportBtn: document.getElementById('exportBtn'),\n  importBtn: document.getElementById('importBtn'),\n};\n\nlet animTimers = [];\nlet currentHighlights = new Map();\nlet defaultNodeRadius = 22;\nlet levelYgap = 90;\nlet horizSpacing = 60;\n\n// pan & zoom state\nlet offsetX = 0, offsetY = 0, scale = 1;\nlet isPanning = false, lastPan = null;\n\nfunction clearAnim() {\n  animTimers.forEach(id => clearTimeout(id));\n  animTimers = [];\n  currentHighlights.clear();\n  draw();\n}\n\nfunction setSpeedDisplay() {\n  UI.speedVal.textContent = UI.speedRange.value + 'ms';\n}\nsetSpeedDisplay();\nUI.speedRange.addEventListener('input', () => setSpeedDisplay());\n\nfunction layoutTree() {\n  // assign x by inorder traversal index and y by depth\n  let xIndex = 0;\n  function dfs(node, depth) {\n    if (!node) return;\n    dfs(node.left, depth + 1);\n    node.x = xIndex++ * horizSpacing;\n    node.y = depth * levelYgap;\n    dfs(node.right, depth + 1);\n  }\n  dfs(tree.root, 0);\n\n  // center tree horizontally: compute min and max x\n  if (!tree.root) return;\n  let nodes = tree.inorder();\n  let minX = Math.min(...nodes.map(n => n.x));\n  let maxX = Math.max(...nodes.map(n => n.x));\n  const treeWidth = Math.max(0, maxX - minX);\n  // shift so center is near canvas center (before scale/pan)\n  const canvasCenterX = width / 2 / scale - offsetX;\n  const treeCenter = (minX + maxX) / 2;\n  const shift = canvasCenterX - treeCenter;\n  nodes.forEach(n => n.x += shift);\n}\n\nfunction draw() {\n  // clear background\n  ctx.fillStyle = '#071428';\n  ctx.fillRect(0,0,width,height);\n\n  // set transform for pan/zoom\n  ctx.save();\n  ctx.setTransform(scale,0,0,scale, offsetX*scale, offsetY*scale);\n\n  // helpful background grid\n  drawGrid();\n\n  if (!tree.root) {\n    // draw empty message\n    ctx.restore();\n    ctx.fillStyle = 'rgba(255,255,255,0.06)';\n    ctx.font = '16px Inter, Arial';\n    ctx.fillText('Tree is empty — insert some values to begin', 20, 28);\n    updateStats();\n    return;\n  }\n\n  layoutTree();\n\n  // draw edges\n  ctx.lineWidth = 2 / scale;\n  ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n  function drawEdges(node) {\n    if (!node) return;\n    if (node.left) {\n      drawLine(node, node.left);\n      drawEdges(node.left);\n    }\n    if (node.right) {\n      drawLine(node, node.right);\n      drawEdges(node.right);\n    }\n  }\n  function drawLine(a, b) {\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    ctx.stroke();\n  }\n  drawEdges(tree.root);\n\n  // draw nodes\n  function drawNode(node) {\n    const x = node.x, y = node.y;\n    const radius = defaultNodeRadius;\n\n    // highlight color decisions\n    let fill = 'linear'; // base\n    let highlight = currentHighlights.get(node.value);\n    if (highlight) {\n      // highlight can be {color, fade}\n      ctx.fillStyle = highlight.color || '#ffe082';\n      ctx.strokeStyle = 'rgba(0,0,0,0.35)';\n    } else {\n      ctx.fillStyle = 'rgba(14,165,161,0.96)'; // teal\n      ctx.strokeStyle = 'rgba(0,78,75,0.5)';\n    }\n\n    // shadow / ring\n    ctx.beginPath();\n    ctx.fillStyle = ctx.fillStyle;\n    ctx.arc(x, y, radius, 0, Math.PI*2);\n    ctx.fill();\n\n    ctx.lineWidth = 2 / scale;\n    ctx.strokeStyle = ctx.strokeStyle;\n    ctx.stroke();\n\n    // value text\n    ctx.fillStyle = '#001f1f';\n    ctx.font = (14 / scale) + 'px Inter, Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(node.value), x, y);\n  }\n\n  // draw nodes via traversal so that parents are above children\n  function drawAll(node) {\n    if (!node) return;\n    drawAll(node.left);\n    drawAll(node.right);\n    drawNode(node);\n  }\n  drawAll(tree.root);\n\n  ctx.restore();\n\n  updateStats();\n}\n\nfunction drawGrid() {\n  ctx.save();\n  ctx.setTransform(scale,0,0,scale, offsetX*scale, offsetY*scale);\n  const step = 30;\n  ctx.strokeStyle = 'rgba(255,255,255,0.02)';\n  ctx.lineWidth = 1 / scale;\n  ctx.beginPath();\n  for (let x = -2000; x <= 2000; x += step) {\n    ctx.moveTo(x, -2000);\n    ctx.lineTo(x, 2000);\n  }\n  for (let y = -2000; y <= 2000; y += step) {\n    ctx.moveTo(-2000, y);\n    ctx.lineTo(2000, y);\n  }\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction updateStats() {\n  UI.sizeEl.textContent = tree.size;\n  UI.heightEl.textContent = tree.height();\n  UI.output.textContent = JSON.stringify(tree.toArray());\n}\n\n// UI actions with animation helpers\nfunction animatePath(nodes, color='#ffd54f', cb) {\n  clearAnim();\n  const delay = Number(UI.speedRange.value) || 400;\n  nodes.forEach((node, i) => {\n    const id = setTimeout(() => {\n      currentHighlights.clear();\n      currentHighlights.set(node.value, { color: color });\n      draw();\n      if (i === nodes.length - 1) {\n        if (cb) cb();\n      }\n    }, i * delay);\n    animTimers.push(id);\n  });\n}\n\nfunction animateSequence(nodes, color='#93c5fd', cb) {\n  clearAnim();\n  const delay = Number(UI.speedRange.value) || 400;\n  nodes.forEach((node, i) => {\n    const id = setTimeout(() => {\n      currentHighlights.clear();\n      currentHighlights.set(node.value, { color: color });\n      draw();\n      if (i === nodes.length - 1) {\n        if (cb) cb();\n      }\n    }, i * delay);\n    animTimers.push(id);\n  });\n}\n\nUI.insertBtn.addEventListener('click', () => {\n  const v = Number(UI.valueInput.value);\n  if (!Number.isFinite(v)) {\n    alert('Please enter a valid integer value.');\n    return;\n  }\n  const res = tree.insert(v);\n  if (!res.inserted) {\n    animatePath(res.path, '#fb7185', () => {\n      alert('Value already exists in the tree (duplicates not allowed).');\n      currentHighlights.clear();\n      draw();\n    });\n  } else {\n    animatePath(res.path, '#34d399', () => {\n      currentHighlights.clear();\n      draw();\n    });\n  }\n  draw();\n});\n\nUI.searchBtn.addEventListener('click', () => {\n  const v = Number(UI.valueInput.value);\n  if (!Number.isFinite(v)) {\n    alert('Enter a number to search.');\n    return;\n  }\n  const res = tree.findWithPath(v);\n  if (!res.path.length) {\n    alert('Tree is empty.');\n    return;\n  }\n  animatePath(res.path, res.found ? '#93c5fd' : '#fb7185', () => {\n    if (!res.found) alert('Value not found.');\n    currentHighlights.clear();\n    draw();\n  });\n});\n\nUI.deleteBtn.addEventListener('click', () => {\n  const v = Number(UI.valueInput.value);\n  if (!Number.isFinite(v)) {\n    alert('Enter a number to delete.');\n    return;\n  }\n  const res = tree.findWithPath(v);\n  if (!res.path.length) {\n    alert('Tree is empty.');\n    return;\n  }\n  // animate search first\n  animatePath(res.path, '#fbbf24', () => {\n    // then delete and animate re-layout\n    const del = tree.delete(v);\n    animatePath(del.path, del.deleted ? '#fb7185' : '#fb7185', () => {\n      currentHighlights.clear();\n      draw();\n    });\n  });\n});\n\nUI.clearBtn.addEventListener('click', () => {\n  if (!confirm('Clear the entire tree?')) return;\n  clearAnim();\n  tree.clear();\n  draw();\n});\n\nUI.randomBtn.addEventListener('click', () => {\n  const count = Math.min(40, Math.max(1, Number(UI.randCount.value) || 8));\n  // random unique values\n  const vals = new Set();\n  while (vals.size < count) {\n    vals.add(Math.floor(Math.random() * 200) - 50);\n  }\n  // clear tree then insert\n  tree.clear();\n  const arr = Array.from(vals);\n  // shuffle insertion order a bit\n  for (let v of arr) tree.insert(v);\n  draw();\n});\n\nUI.balancedBtn.addEventListener('click', () => {\n  // if tree empty, ask for values; else balance current values\n  let arr = tree.toArray();\n  if (arr.length === 0) {\n    let raw = prompt('Enter numbers separated by commas (will be deduped & sorted):', '1,2,3,4,5,6,7');\n    if (!raw) return;\n    arr = Array.from(new Set(raw.split(',').map(x => Number(x.trim())).filter(x => Number.isFinite(x))));\n    if (arr.length === 0) return;\n    arr.sort((a,b) => a-b);\n  }\n  tree.clear();\n  function buildBalanced(sorted) {\n    if (!sorted.length) return null;\n    const mid = Math.floor(sorted.length / 2);\n    const node = new Node(sorted[mid]);\n    node.left = buildBalanced(sorted.slice(0, mid));\n    node.right = buildBalanced(sorted.slice(mid+1));\n    return node;\n  }\n  tree.root = buildBalanced(arr);\n  tree.size = arr.length;\n  draw();\n});\n\nUI.inorderBtn.addEventListener('click', () => {\n  const nodes = tree.inorder();\n  UI.output.textContent = JSON.stringify(nodes.map(n => n.value));\n  animateSequence(nodes, '#60a5fa', () => { currentHighlights.clear(); draw(); });\n});\nUI.preorderBtn.addEventListener('click', () => {\n  const nodes = tree.preorder();\n  UI.output.textContent = JSON.stringify(nodes.map(n => n.value));\n  animateSequence(nodes, '#a78bfa', () => { currentHighlights.clear(); draw(); });\n});\nUI.postorderBtn.addEventListener('click', () => {\n  const nodes = tree.postorder();\n  UI.output.textContent = JSON.stringify(nodes.map(n => n.value));\n  animateSequence(nodes, '#fb7185', () => { currentHighlights.clear(); draw(); });\n});\nUI.levelBtn.addEventListener('click', () => {\n  const nodes = tree.levelorder();\n  UI.output.textContent = JSON.stringify(nodes.map(n => n.value));\n  animateSequence(nodes, '#34d399', () => { currentHighlights.clear(); draw(); });\n});\n\nUI.stopAnim.addEventListener('click', () => {\n  clearAnim();\n});\n\nUI.exportBtn.addEventListener('click', () => {\n  const arr = tree.toArray();\n  const json = JSON.stringify(arr, null, 2);\n  prompt('Copy JSON of values (inorder):', json);\n});\n\nUI.importBtn.addEventListener('click', () => {\n  const raw = prompt('Paste JSON array of numbers (e.g. [5,1,7,3])');\n  if (!raw) return;\n  try {\n    const arr = JSON.parse(raw);\n    if (!Array.isArray(arr)) throw new Error('Not array');\n    tree.clear();\n    arr.forEach(v => {\n      if (Number.isFinite(v)) tree.insert(Number(v));\n    });\n    draw();\n  } catch (e) {\n    alert('Invalid JSON array.');\n  }\n});\n\n// canvas interactions: click node to autofill value\ncanvas.addEventListener('click', (ev) => {\n  // compute canvas coords to tree coords\n  const rect = canvas.getBoundingClientRect();\n  const cx = (ev.clientX - rect.left) / scale - offsetX;\n  const cy = (ev.clientY - rect.top) / scale - offsetY;\n  // find nearest node within radius\n  let found = null;\n  const radius = defaultNodeRadius + 4;\n  function checkAll(node) {\n    if (!node) return;\n    const dx = cx - node.x;\n    const dy = cy - node.y;\n    if (dx*dx + dy*dy <= (radius*radius)) {\n      found = node;\n      return;\n    }\n    if (node.left) checkAll(node.left);\n    if (node.right) checkAll(node.right);\n  }\n  checkAll(tree.root);\n  if (found) {\n    UI.valueInput.value = found.value;\n  }\n});\n\n// pan & zoom\ncanvas.addEventListener('wheel', (ev) => {\n  ev.preventDefault();\n  const delta = -ev.deltaY;\n  const zoomFactor = 1 + (delta > 0 ? 0.08 : -0.08);\n  // zoom towards cursor\n  const rect = canvas.getBoundingClientRect();\n  const mx = (ev.clientX - rect.left) / scale - offsetX;\n  const my = (ev.clientY - rect.top) / scale - offsetY;\n  scale = Math.max(0.3, Math.min(3.0, scale * zoomFactor));\n  // adjust offset so point under cursor remains\n  offsetX = (offsetX) - (mx * (zoomFactor - 1));\n  offsetY = (offsetY) - (my * (zoomFactor - 1));\n  draw();\n}, { passive: false });\n\ncanvas.addEventListener('mousedown', (ev) => {\n  isPanning = true;\n  lastPan = { x: ev.clientX, y: ev.clientY };\n  canvas.style.cursor = 'grabbing';\n});\nwindow.addEventListener('mousemove', (ev) => {\n  if (!isPanning || !lastPan) return;\n  const dx = (ev.clientX - lastPan.x) / scale;\n  const dy = (ev.clientY - lastPan.y) / scale;\n  offsetX += dx;\n  offsetY += dy;\n  lastPan = { x: ev.clientX, y: ev.clientY };\n  draw();\n});\nwindow.addEventListener('mouseup', () => {\n  isPanning = false;\n  lastPan = null;\n  canvas.style.cursor = 'default';\n});\n\n// resize handling\nfunction fitCanvasToWindow() {\n  const rect = canvas.getBoundingClientRect();\n  // if style width set by CSS in smaller screens - update canvas pixel size for crisp rendering\n  const dpr = window.devicePixelRatio || 1;\n  const newWidth = Math.max(600, Math.floor(rect.width * dpr));\n  const newHeight = Math.max(320, Math.floor(rect.height * dpr));\n  canvas.width = newWidth;\n  canvas.height = newHeight;\n  width = newWidth;\n  height = newHeight;\n  ctx.setTransform(1,0,0,1,0,0);\n  ctx.imageSmoothingEnabled = true;\n  draw();\n}\nwindow.addEventListener('resize', fitCanvasToWindow);\n\n// keyboard: Enter inserts, Delete key removes\nwindow.addEventListener('keydown', (ev) => {\n  if (ev.key === 'Enter') {\n    UI.insertBtn.click();\n  } else if (ev.key === 'Delete') {\n    UI.deleteBtn.click();\n  }\n});\n\nUI.speedRange.addEventListener('change', () => setSpeedDisplay());\n\n// initial demo tree\n(function seedDemo() {\n  const demoVals = [50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 45];\n  demoVals.forEach(v => tree.insert(v));\n  draw();\n})();\n\nfitCanvasToWindow();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Search Tree (BST)"
    }
  ],
  "topic": "Binary Search Tree (BST)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}