<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Binary Search Tree (BST) Interactive Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #38bdf8;
      --muted: #9aa6b2;
      --good: #34d399;
      --danger: #fb7185;
      --node-fill: #0ea5a1;
      --node-border: #004e4b;
    }
    html,body { height:100%; margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: radial-gradient(1200px 600px at 10% 10%, rgba(56,189,248,0.06), transparent), var(--bg); color:#e6eef6; }
    .container { display:flex; height:100vh; gap:18px; padding:20px; box-sizing:border-box; }
    .left {
      width:360px;
      min-width:260px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border:1px solid rgba(255,255,255,0.04);
      border-radius:12px;
      padding:18px;
      box-sizing:border-box;
      backdrop-filter: blur(6px);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    h1 { margin:0; font-size:18px; letter-spacing:0.2px; color:var(--accent); }
    p.sub { margin:0; color:var(--muted); font-size:13px; }
    label { font-size:13px; color:var(--muted); display:block; margin-bottom:6px; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    input[type="number"] { padding:10px 12px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; width:120px; }
    button { padding:9px 12px; border-radius:8px; border:0; background:linear-gradient(180deg,var(--accent), #06a6d8); color:#04202a; font-weight:600; cursor:pointer; }
    button.ghost { background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--muted); }
    .small { padding:7px 10px; font-size:13px; }
    .muted { color:var(--muted); font-size:13px; }
    .row { display:flex; gap:8px; align-items:center; }
    .panel { background:rgba(255,255,255,0.02); padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.02); }
    canvas { background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent); border-radius:12px; border:1px solid rgba(255,255,255,0.03); }
    .traversal-output { background:#071424; border-radius:8px; padding:8px; font-family:monospace; color:var(--muted); max-height:160px; overflow:auto; }
    .stats { display:flex; gap:10px; color:var(--muted); font-size:13px; }
    .stat { background:rgba(255,255,255,0.02); padding:8px 10px; border-radius:8px; }
    footer { margin-top:auto; color:var(--muted); font-size:12px; text-align:center; }
    .hint { color:var(--muted); font-size:12px; margin-top:6px; }
    .btn-wide { flex:1; }
    .danger { background:linear-gradient(180deg,#fb7185,#f43f5e); color:white; }
    .controls-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .speed { display:flex; align-items:center; gap:8px; }
    input[type="range"] { width:140px; }
    @media (max-width:900px) {
      .container { flex-direction:column; padding:12px; }
      .left { width:100%; order:2; }
      .canvas-wrap { order:1; }
      canvas { width:100%; height:420px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="canvas-wrap" style="flex:1; display:flex; flex-direction:column; gap:12px;">
      <div style="display:flex; align-items:center; gap:12px;">
        <h1>Binary Search Tree (BST)</h1>
        <p class="sub">Interactive visualizer — insert, delete, search, and traverse</p>
      </div>
      <canvas id="treeCanvas" width="1200" height="640"></canvas>
      <div style="display:flex; gap:8px; align-items:center; justify-content:space-between;">
        <div class="muted">Click node to auto-fill value. Drag canvas to pan. Use mouse wheel or pinch to zoom.</div>
        <div class="stats">
          <div class="stat">Size: <span id="size">0</span></div>
          <div class="stat">Height: <span id="height">0</span></div>
        </div>
      </div>
    </div>

    <div class="left">
      <div>
        <label for="valueInput">Value (integer)</label>
        <div style="display:flex; gap:8px;">
          <input id="valueInput" type="number" placeholder="e.g. 42" />
          <button id="insertBtn">Insert</button>
          <button id="deleteBtn" class="ghost">Delete</button>
        </div>
        <div style="display:flex; gap:8px; margin-top:8px;">
          <button id="searchBtn" class="ghost">Search</button>
          <button id="clearBtn" class="ghost">Clear</button>
        </div>
        <div class="hint">Duplicates are ignored. Values are compared as numbers.</div>
      </div>

      <div>
        <label>Build / Randomize</label>
        <div style="display:flex; gap:8px;">
          <input id="randCount" type="number" min="1" max="30" value="8" style="width:90px;" />
          <button id="randomBtn" class="small ghost">Random Tree</button>
          <button id="balancedBtn" class="small ghost">Balanced from Sorted</button>
        </div>
        <div class="hint">Random: inserts random integers. Balanced: create a balanced BST from sorted unique values (keeps current values if empty).</div>
      </div>

      <div>
        <label>Traversals & Animations</label>
        <div class="controls">
          <button id="inorderBtn" class="small ghost">Inorder</button>
          <button id="preorderBtn" class="small ghost">Preorder</button>
          <button id="postorderBtn" class="small ghost">Postorder</button>
          <button id="levelBtn" class="small ghost">Level-order</button>
        </div>
        <div style="display:flex; gap:8px; margin-top:8px; align-items:center;">
          <div class="speed panel" style="display:flex; align-items:center;">
            <label style="margin-right:6px; color:var(--muted); font-size:13px;">Speed</label>
            <input id="speedRange" type="range" min="100" max="1200" step="50" value="400" />
            <span id="speedVal" style="width:42px; text-align:right; color:var(--muted); font-size:13px;">400ms</span>
          </div>
          <button id="stopAnim" class="ghost small">Stop</button>
        </div>
      </div>

      <div>
        <label>Traversal Output</label>
        <div class="traversal-output" id="output">[]</div>
      </div>

      <div style="display:flex; gap:8px;">
        <button id="exportBtn" class="small ghost btn-wide">Export Values (JSON)</button>
        <button id="importBtn" class="small ghost btn-wide">Import JSON</button>
      </div>

      <footer>
        Tip: Insert numbers in any order. Deleting a node follows standard BST rules (replace with in-order successor when needed).
      </footer>
    </div>
  </div>

<script>
/*
  BST Interactive Demo
  - Insert/Delete/Search with animations
  - Traversals with animated highlighting
  - Canvas pan & zoom, node click to autofill
  - Balanced build & random tree
*/

class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
    // for drawing
    this.x = 0;
    this.y = 0;
  }
}

class BST {
  constructor() {
    this.root = null;
    this.size = 0;
  }

  insert(value) {
    if (this.root === null) {
      this.root = new Node(value);
      this.size = 1;
      return { inserted: true, path: [this.root] };
    }
    let cur = this.root;
    const path = [];
    while (cur) {
      path.push(cur);
      if (value === cur.value) return { inserted: false, path }; // duplicate
      if (value < cur.value) {
        if (cur.left) cur = cur.left;
        else {
          cur.left = new Node(value);
          this.size++;
          path.push(cur.left);
          return { inserted: true, path };
        }
      } else {
        if (cur.right) cur = cur.right;
        else {
          cur.right = new Node(value);
          this.size++;
          path.push(cur.right);
          return { inserted: true, path };
        }
      }
    }
    return { inserted: false, path };
  }

  findWithPath(value) {
    let cur = this.root;
    const path = [];
    while (cur) {
      path.push(cur);
      if (value === cur.value) return { found: true, node: cur, path };
      if (value < cur.value) cur = cur.left;
      else cur = cur.right;
    }
    return { found: false, node: null, path };
  }

  // recursive delete return new subtree and record path visited
  delete(value) {
    const path = [];
    const deleteRec = (node) => {
      if (!node) return null;
      path.push(node);
      if (value < node.value) {
        node.left = deleteRec(node.left);
        return node;
      } else if (value > node.value) {
        node.right = deleteRec(node.right);
        return node;
      } else {
        // found: three cases
        if (!node.left && !node.right) {
          this.size--;
          return null;
        } else if (!node.left) {
          this.size--;
          return node.right;
        } else if (!node.right) {
          this.size--;
          return node.left;
        } else {
          // two children: find inorder successor (smallest in right subtree)
          let succParent = node;
          let succ = node.right;
          while (succ.left) {
            succParent = succ;
            succ = succ.left;
          }
          // succ is successor
          node.value = succ.value;
          // delete successor in right subtree
          node.right = deleteRecHelper(node.right, succ.value);
          return node;
        }
      }
    };

    // helper to avoid duplicating path pushes during successor deletion
    const deleteRecHelper = (node, val) => {
      if (!node) return null;
      path.push(node);
      if (val < node.value) {
        node.left = deleteRecHelper(node.left, val);
        return node;
      } else if (val > node.value) {
        node.right = deleteRecHelper(node.right, val);
        return node;
      } else {
        if (!node.left && !node.right) {
          this.size--;
          return null;
        } else if (!node.left) {
          this.size--;
          return node.right;
        } else if (!node.right) {
          this.size--;
          return node.left;
        } else {
          // shouldn't usually happen for successor case, but handle generically
          let succ = node.right;
          while (succ.left) succ = succ.left;
          node.value = succ.value;
          node.right = deleteRecHelper(node.right, succ.value);
          return node;
        }
      }
    };

    const beforeSize = this.size;
    this.root = deleteRec(this.root);
    const deleted = this.size < beforeSize;
    return { deleted, path };
  }

  inorder(node = this.root, arr = []) {
    if (!node) return arr;
    this.inorder(node.left, arr);
    arr.push(node);
    this.inorder(node.right, arr);
    return arr;
  }
  preorder(node = this.root, arr = []) {
    if (!node) return arr;
    arr.push(node);
    this.preorder(node.left, arr);
    this.preorder(node.right, arr);
    return arr;
  }
  postorder(node = this.root, arr = []) {
    if (!node) return arr;
    this.postorder(node.left, arr);
    this.postorder(node.right, arr);
    arr.push(node);
    return arr;
  }
  levelorder() {
    const arr = [];
    if (!this.root) return arr;
    const q = [this.root];
    while (q.length) {
      const n = q.shift();
      arr.push(n);
      if (n.left) q.push(n.left);
      if (n.right) q.push(n.right);
    }
    return arr;
  }

  height(node = this.root) {
    if (!node) return 0;
    return 1 + Math.max(this.height(node.left), this.height(node.right));
  }

  toArray() {
    return this.inorder().map(n => n.value);
  }

  clear() {
    this.root = null;
    this.size = 0;
  }
}

// Canvas drawing & UI
const canvas = document.getElementById('treeCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

let width = canvas.width;
let height = canvas.height;

const tree = new BST();

const UI = {
  valueInput: document.getElementById('valueInput'),
  insertBtn: document.getElementById('insertBtn'),
  deleteBtn: document.getElementById('deleteBtn'),
  searchBtn: document.getElementById('searchBtn'),
  clearBtn: document.getElementById('clearBtn'),
  randomBtn: document.getElementById('randomBtn'),
  balancedBtn: document.getElementById('balancedBtn'),
  randCount: document.getElementById('randCount'),
  inorderBtn: document.getElementById('inorderBtn'),
  preorderBtn: document.getElementById('preorderBtn'),
  postorderBtn: document.getElementById('postorderBtn'),
  levelBtn: document.getElementById('levelBtn'),
  output: document.getElementById('output'),
  sizeEl: document.getElementById('size'),
  heightEl: document.getElementById('height'),
  speedRange: document.getElementById('speedRange'),
  speedVal: document.getElementById('speedVal'),
  stopAnim: document.getElementById('stopAnim'),
  exportBtn: document.getElementById('exportBtn'),
  importBtn: document.getElementById('importBtn'),
};

let animTimers = [];
let currentHighlights = new Map();
let defaultNodeRadius = 22;
let levelYgap = 90;
let horizSpacing = 60;

// pan & zoom state
let offsetX = 0, offsetY = 0, scale = 1;
let isPanning = false, lastPan = null;

function clearAnim() {
  animTimers.forEach(id => clearTimeout(id));
  animTimers = [];
  currentHighlights.clear();
  draw();
}

function setSpeedDisplay() {
  UI.speedVal.textContent = UI.speedRange.value + 'ms';
}
setSpeedDisplay();
UI.speedRange.addEventListener('input', () => setSpeedDisplay());

function layoutTree() {
  // assign x by inorder traversal index and y by depth
  let xIndex = 0;
  function dfs(node, depth) {
    if (!node) return;
    dfs(node.left, depth + 1);
    node.x = xIndex++ * horizSpacing;
    node.y = depth * levelYgap;
    dfs(node.right, depth + 1);
  }
  dfs(tree.root, 0);

  // center tree horizontally: compute min and max x
  if (!tree.root) return;
  let nodes = tree.inorder();
  let minX = Math.min(...nodes.map(n => n.x));
  let maxX = Math.max(...nodes.map(n => n.x));
  const treeWidth = Math.max(0, maxX - minX);
  // shift so center is near canvas center (before scale/pan)
  const canvasCenterX = width / 2 / scale - offsetX;
  const treeCenter = (minX + maxX) / 2;
  const shift = canvasCenterX - treeCenter;
  nodes.forEach(n => n.x += shift);
}

function draw() {
  // clear background
  ctx.fillStyle = '#071428';
  ctx.fillRect(0,0,width,height);

  // set transform for pan/zoom
  ctx.save();
  ctx.setTransform(scale,0,0,scale, offsetX*scale, offsetY*scale);

  // helpful background grid
  drawGrid();

  if (!tree.root) {
    // draw empty message
    ctx.restore();
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.font = '16px Inter, Arial';
    ctx.fillText('Tree is empty — insert some values to begin', 20, 28);
    updateStats();
    return;
  }

  layoutTree();

  // draw edges
  ctx.lineWidth = 2 / scale;
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  function drawEdges(node) {
    if (!node) return;
    if (node.left) {
      drawLine(node, node.left);
      drawEdges(node.left);
    }
    if (node.right) {
      drawLine(node, node.right);
      drawEdges(node.right);
    }
  }
  function drawLine(a, b) {
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
  }
  drawEdges(tree.root);

  // draw nodes
  function drawNode(node) {
    const x = node.x, y = node.y;
    const radius = defaultNodeRadius;

    // highlight color decisions
    let fill = 'linear'; // base
    let highlight = currentHighlights.get(node.value);
    if (highlight) {
      // highlight can be {color, fade}
      ctx.fillStyle = highlight.color || '#ffe082';
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    } else {
      ctx.fillStyle = 'rgba(14,165,161,0.96)'; // teal
      ctx.strokeStyle = 'rgba(0,78,75,0.5)';
    }

    // shadow / ring
    ctx.beginPath();
    ctx.fillStyle = ctx.fillStyle;
    ctx.arc(x, y, radius, 0, Math.PI*2);
    ctx.fill();

    ctx.lineWidth = 2 / scale;
    ctx.strokeStyle = ctx.strokeStyle;
    ctx.stroke();

    // value text
    ctx.fillStyle = '#001f1f';
    ctx.font = (14 / scale) + 'px Inter, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(node.value), x, y);
  }

  // draw nodes via traversal so that parents are above children
  function drawAll(node) {
    if (!node) return;
    drawAll(node.left);
    drawAll(node.right);
    drawNode(node);
  }
  drawAll(tree.root);

  ctx.restore();

  updateStats();
}

function drawGrid() {
  ctx.save();
  ctx.setTransform(scale,0,0,scale, offsetX*scale, offsetY*scale);
  const step = 30;
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1 / scale;
  ctx.beginPath();
  for (let x = -2000; x <= 2000; x += step) {
    ctx.moveTo(x, -2000);
    ctx.lineTo(x, 2000);
  }
  for (let y = -2000; y <= 2000; y += step) {
    ctx.moveTo(-2000, y);
    ctx.lineTo(2000, y);
  }
  ctx.stroke();
  ctx.restore();
}

function updateStats() {
  UI.sizeEl.textContent = tree.size;
  UI.heightEl.textContent = tree.height();
  UI.output.textContent = JSON.stringify(tree.toArray());
}

// UI actions with animation helpers
function animatePath(nodes, color='#ffd54f', cb) {
  clearAnim();
  const delay = Number(UI.speedRange.value) || 400;
  nodes.forEach((node, i) => {
    const id = setTimeout(() => {
      currentHighlights.clear();
      currentHighlights.set(node.value, { color: color });
      draw();
      if (i === nodes.length - 1) {
        if (cb) cb();
      }
    }, i * delay);
    animTimers.push(id);
  });
}

function animateSequence(nodes, color='#93c5fd', cb) {
  clearAnim();
  const delay = Number(UI.speedRange.value) || 400;
  nodes.forEach((node, i) => {
    const id = setTimeout(() => {
      currentHighlights.clear();
      currentHighlights.set(node.value, { color: color });
      draw();
      if (i === nodes.length - 1) {
        if (cb) cb();
      }
    }, i * delay);
    animTimers.push(id);
  });
}

UI.insertBtn.addEventListener('click', () => {
  const v = Number(UI.valueInput.value);
  if (!Number.isFinite(v)) {
    alert('Please enter a valid integer value.');
    return;
  }
  const res = tree.insert(v);
  if (!res.inserted) {
    animatePath(res.path, '#fb7185', () => {
      alert('Value already exists in the tree (duplicates not allowed).');
      currentHighlights.clear();
      draw();
    });
  } else {
    animatePath(res.path, '#34d399', () => {
      currentHighlights.clear();
      draw();
    });
  }
  draw();
});

UI.searchBtn.addEventListener('click', () => {
  const v = Number(UI.valueInput.value);
  if (!Number.isFinite(v)) {
    alert('Enter a number to search.');
    return;
  }
  const res = tree.findWithPath(v);
  if (!res.path.length) {
    alert('Tree is empty.');
    return;
  }
  animatePath(res.path, res.found ? '#93c5fd' : '#fb7185', () => {
    if (!res.found) alert('Value not found.');
    currentHighlights.clear();
    draw();
  });
});

UI.deleteBtn.addEventListener('click', () => {
  const v = Number(UI.valueInput.value);
  if (!Number.isFinite(v)) {
    alert('Enter a number to delete.');
    return;
  }
  const res = tree.findWithPath(v);
  if (!res.path.length) {
    alert('Tree is empty.');
    return;
  }
  // animate search first
  animatePath(res.path, '#fbbf24', () => {
    // then delete and animate re-layout
    const del = tree.delete(v);
    animatePath(del.path, del.deleted ? '#fb7185' : '#fb7185', () => {
      currentHighlights.clear();
      draw();
    });
  });
});

UI.clearBtn.addEventListener('click', () => {
  if (!confirm('Clear the entire tree?')) return;
  clearAnim();
  tree.clear();
  draw();
});

UI.randomBtn.addEventListener('click', () => {
  const count = Math.min(40, Math.max(1, Number(UI.randCount.value) || 8));
  // random unique values
  const vals = new Set();
  while (vals.size < count) {
    vals.add(Math.floor(Math.random() * 200) - 50);
  }
  // clear tree then insert
  tree.clear();
  const arr = Array.from(vals);
  // shuffle insertion order a bit
  for (let v of arr) tree.insert(v);
  draw();
});

UI.balancedBtn.addEventListener('click', () => {
  // if tree empty, ask for values; else balance current values
  let arr = tree.toArray();
  if (arr.length === 0) {
    let raw = prompt('Enter numbers separated by commas (will be deduped & sorted):', '1,2,3,4,5,6,7');
    if (!raw) return;
    arr = Array.from(new Set(raw.split(',').map(x => Number(x.trim())).filter(x => Number.isFinite(x))));
    if (arr.length === 0) return;
    arr.sort((a,b) => a-b);
  }
  tree.clear();
  function buildBalanced(sorted) {
    if (!sorted.length) return null;
    const mid = Math.floor(sorted.length / 2);
    const node = new Node(sorted[mid]);
    node.left = buildBalanced(sorted.slice(0, mid));
    node.right = buildBalanced(sorted.slice(mid+1));
    return node;
  }
  tree.root = buildBalanced(arr);
  tree.size = arr.length;
  draw();
});

UI.inorderBtn.addEventListener('click', () => {
  const nodes = tree.inorder();
  UI.output.textContent = JSON.stringify(nodes.map(n => n.value));
  animateSequence(nodes, '#60a5fa', () => { currentHighlights.clear(); draw(); });
});
UI.preorderBtn.addEventListener('click', () => {
  const nodes = tree.preorder();
  UI.output.textContent = JSON.stringify(nodes.map(n => n.value));
  animateSequence(nodes, '#a78bfa', () => { currentHighlights.clear(); draw(); });
});
UI.postorderBtn.addEventListener('click', () => {
  const nodes = tree.postorder();
  UI.output.textContent = JSON.stringify(nodes.map(n => n.value));
  animateSequence(nodes, '#fb7185', () => { currentHighlights.clear(); draw(); });
});
UI.levelBtn.addEventListener('click', () => {
  const nodes = tree.levelorder();
  UI.output.textContent = JSON.stringify(nodes.map(n => n.value));
  animateSequence(nodes, '#34d399', () => { currentHighlights.clear(); draw(); });
});

UI.stopAnim.addEventListener('click', () => {
  clearAnim();
});

UI.exportBtn.addEventListener('click', () => {
  const arr = tree.toArray();
  const json = JSON.stringify(arr, null, 2);
  prompt('Copy JSON of values (inorder):', json);
});

UI.importBtn.addEventListener('click', () => {
  const raw = prompt('Paste JSON array of numbers (e.g. [5,1,7,3])');
  if (!raw) return;
  try {
    const arr = JSON.parse(raw);
    if (!Array.isArray(arr)) throw new Error('Not array');
    tree.clear();
    arr.forEach(v => {
      if (Number.isFinite(v)) tree.insert(Number(v));
    });
    draw();
  } catch (e) {
    alert('Invalid JSON array.');
  }
});

// canvas interactions: click node to autofill value
canvas.addEventListener('click', (ev) => {
  // compute canvas coords to tree coords
  const rect = canvas.getBoundingClientRect();
  const cx = (ev.clientX - rect.left) / scale - offsetX;
  const cy = (ev.clientY - rect.top) / scale - offsetY;
  // find nearest node within radius
  let found = null;
  const radius = defaultNodeRadius + 4;
  function checkAll(node) {
    if (!node) return;
    const dx = cx - node.x;
    const dy = cy - node.y;
    if (dx*dx + dy*dy <= (radius*radius)) {
      found = node;
      return;
    }
    if (node.left) checkAll(node.left);
    if (node.right) checkAll(node.right);
  }
  checkAll(tree.root);
  if (found) {
    UI.valueInput.value = found.value;
  }
});

// pan & zoom
canvas.addEventListener('wheel', (ev) => {
  ev.preventDefault();
  const delta = -ev.deltaY;
  const zoomFactor = 1 + (delta > 0 ? 0.08 : -0.08);
  // zoom towards cursor
  const rect = canvas.getBoundingClientRect();
  const mx = (ev.clientX - rect.left) / scale - offsetX;
  const my = (ev.clientY - rect.top) / scale - offsetY;
  scale = Math.max(0.3, Math.min(3.0, scale * zoomFactor));
  // adjust offset so point under cursor remains
  offsetX = (offsetX) - (mx * (zoomFactor - 1));
  offsetY = (offsetY) - (my * (zoomFactor - 1));
  draw();
}, { passive: false });

canvas.addEventListener('mousedown', (ev) => {
  isPanning = true;
  lastPan = { x: ev.clientX, y: ev.clientY };
  canvas.style.cursor = 'grabbing';
});
window.addEventListener('mousemove', (ev) => {
  if (!isPanning || !lastPan) return;
  const dx = (ev.clientX - lastPan.x) / scale;
  const dy = (ev.clientY - lastPan.y) / scale;
  offsetX += dx;
  offsetY += dy;
  lastPan = { x: ev.clientX, y: ev.clientY };
  draw();
});
window.addEventListener('mouseup', () => {
  isPanning = false;
  lastPan = null;
  canvas.style.cursor = 'default';
});

// resize handling
function fitCanvasToWindow() {
  const rect = canvas.getBoundingClientRect();
  // if style width set by CSS in smaller screens - update canvas pixel size for crisp rendering
  const dpr = window.devicePixelRatio || 1;
  const newWidth = Math.max(600, Math.floor(rect.width * dpr));
  const newHeight = Math.max(320, Math.floor(rect.height * dpr));
  canvas.width = newWidth;
  canvas.height = newHeight;
  width = newWidth;
  height = newHeight;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.imageSmoothingEnabled = true;
  draw();
}
window.addEventListener('resize', fitCanvasToWindow);

// keyboard: Enter inserts, Delete key removes
window.addEventListener('keydown', (ev) => {
  if (ev.key === 'Enter') {
    UI.insertBtn.click();
  } else if (ev.key === 'Delete') {
    UI.deleteBtn.click();
  }
});

UI.speedRange.addEventListener('change', () => setSpeedDisplay());

// initial demo tree
(function seedDemo() {
  const demoVals = [50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 45];
  demoVals.forEach(v => tree.insert(v));
  draw();
})();

fitCanvasToWindow();
</script>
</body>
</html>