<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kruskal’s Algorithm — Interactive Module</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --control-width: 340px;
      --bg: #fafafa;
      --panel: #fff;
      --muted: #666;
      --accent: #2b7cff;
      --success: #1f9a3b;
      --danger: #d9534f;
      --consider: #ff8a00;
      --edge-stroke: #333;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #fbfdff, #f4f7fb);
      color:#222;
    }
    .app{
      padding:var(--safe-padding);
      box-sizing:border-box;
      min-height:100%;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    header{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size:20px;
      line-height:1.2;
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }
    .main{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      width:100%;
      box-sizing:border-box;
    }
    /* Left control pane */
    .controls{
      width:var(--control-width);
      min-width:280px;
      background:var(--panel);
      border-radius:12px;
      padding:16px;
      box-shadow: 0 4px 14px rgba(25,40,60,0.06);
      box-sizing:border-box;
    }
    .controls .row{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
      margin-bottom:12px;
    }
    .btn{
      background:var(--accent);
      color:white;
      border:none;
      border-radius:8px;
      padding:10px 12px;
      font-size:14px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      transition:transform .08s ease, box-shadow .08s;
      min-height:44px;
    }
    .btn:hover{ transform:translateY(-2px); }
    .btn.secondary{
      background:#f3f6fb;
      color:#213;
      border:1px solid rgba(0,0,0,0.05);
    }
    .btn.warn{ background:var(--consider); color:white; }
    .btn.danger{ background:var(--danger); }
    .small{
      padding:8px 10px; font-size:13px; border-radius:8px;
    }
    .status{
      margin-top:8px;
      padding:10px;
      border-radius:8px;
      background:#fbfeff;
      font-size:13px;
      color:var(--muted);
    }
    .info{
      font-size:13px;
      color:var(--muted);
      line-height:1.4;
    }
    .edge-queue{
      margin-top:12px;
      max-height:260px;
      overflow:auto;
      padding:8px;
      border-radius:8px;
      background:white;
      border:1px solid rgba(0,0,0,0.03);
      font-family:monospace;
      font-size:13px;
    }
    .queue-item{
      padding:6px 8px;
      border-radius:6px;
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:center;
    }
    .queue-item.current{
      background: linear-gradient(90deg, rgba(255,138,0,0.08), rgba(43,124,255,0.03));
      border-left:4px solid var(--consider);
    }
    .tiny{
      font-size:12px;
      color:var(--muted);
    }
    /* Right visual pane */
    .visual{
      flex:1;
      min-height:460px;
      background:transparent;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .toolbar{
      display:flex;
      gap:var(--gap);
      align-items:center;
    }
    .canvas-frame{
      background:var(--panel);
      border-radius:12px;
      box-shadow: 0 6px 20px rgba(18,28,55,0.06);
      flex:1;
      padding:12px;
      display:flex;
      flex-direction:column;
      min-height:360px;
      box-sizing:border-box;
    }
    .canvas{
      flex:1;
      border:1px dashed rgba(0,0,0,0.03);
      border-radius:8px;
      background:linear-gradient(180deg, #ffffff, #f8fcff);
      position:relative;
      overflow:hidden;
      cursor:crosshair;
      display:block;
    }
    /* SVG fills its parent */
    svg{
      width:100%;
      height:100%;
      display:block;
    }
    /* Node styles */
    .node{
      cursor:grab;
      transition: r .12s ease, fill .18s ease, stroke .12s ease;
    }
    .node:active{ cursor:grabbing; }
    .node-label{
      font-size:12px;
      user-select:none;
      pointer-events:none;
      fill:#fff;
    }
    /* Edge styles */
    .edge-line{
      stroke:var(--edge-stroke);
      stroke-width:2;
      stroke-linecap:round;
      transition:stroke .25s ease, stroke-width .18s ease, opacity .18s;
    }
    .edge-weight{
      font-size:12px;
      fill:#111;
      background:white;
      pointer-events:none;
      user-select:none;
    }
    /* Animations */
    @keyframes pulse-edge {
      0% { stroke-width:2; opacity:1; }
      50% { stroke-width:4; opacity:0.9; }
      100% { stroke-width:2; opacity:1; }
    }
    .edge-consider{
      stroke:var(--consider);
      animation: pulse-edge 900ms ease-in-out infinite;
    }
    .edge-accepted{
      stroke:var(--success);
      stroke-width:4;
      filter: drop-shadow(0 2px 8px rgba(31,154,59,0.12));
    }
    .edge-rejected{
      stroke:var(--danger);
      stroke-width:3;
    }
    /* node halo indicating component */
    .node-halo{
      fill-opacity:0.08;
      transition:fill .22s ease;
    }
    /* small footer text */
    .footer{
      font-size:12px;
      color:var(--muted);
    }
    /* Responsive */
    @media (max-width:920px){
      .main{ flex-direction:column; }
      .controls{ width:100%; min-width:unset; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Kruskal's Algorithm interactive module">
    <header>
      <div>
        <h1>Interactive: Kruskal’s Algorithm — Minimum Spanning Tree</h1>
        <p class="lead">Build and visualize an MST by adding nodes and weighted edges, then step through Kruskal's algorithm.</p>
      </div>
    </header>

    <div class="main" role="main">
      <aside class="controls" aria-label="Controls">
        <div class="row">
          <button id="randomBtn" class="btn" aria-label="Generate a random graph">Random Graph</button>
          <button id="clearBtn" class="btn secondary" aria-label="Clear all nodes and edges">Clear Graph</button>
        </div>

        <div class="row" style="align-items:center;">
          <button id="connectToggle" class="btn warn" aria-pressed="false" aria-label="Toggle connect mode">Connect Mode: Off</button>
          <button id="sortBtn" class="btn small" aria-label="Sort edges by weight">Sort Edges</button>
          <button id="resetAlgBtn" class="btn secondary small" aria-label="Reset algorithm state">Reset</button>
        </div>

        <div class="row">
          <button id="stepBtn" class="btn" aria-label="Perform one Kruskal step">Step</button>
          <button id="autoBtn" class="btn secondary" aria-pressed="false" aria-label="Auto run Kruskal">Auto Run</button>
          <button id="pauseBtn" class="btn secondary" aria-label="Pause auto run" disabled>Pause</button>
        </div>

        <div class="status" id="statusBox" aria-live="polite">
          <div><strong id="mstCount">0</strong> edges accepted • MST weight: <strong id="mstWeight">0</strong></div>
          <div class="tiny" id="statusText">No edges considered yet.</div>
        </div>

        <div style="margin-top:12px;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="font-weight:600;">Edge Queue (sorted)</div>
            <div class="tiny">Click "Sort Edges" to refresh</div>
          </div>
          <div class="edge-queue" id="edgeQueue" tabindex="0" aria-label="Sorted edge queue">
            <!-- edge lines populated here -->
          </div>
        </div>

        <div style="margin-top:12px;" class="info">
          Instructions:
          <ul style="margin:6px 0 0 18px; padding:0;">
            <li>Click in the drawing area to add nodes.</li>
            <li>Drag nodes to reposition them.</li>
            <li>Toggle Connect Mode and click two nodes to add a weighted edge.</li>
            <li>Use Step or Auto Run to execute Kruskal’s algorithm.</li>
          </ul>
        </div>
      </aside>

      <section class="visual" aria-label="Graph visual area">
        <div class="toolbar">
          <div class="tiny" style="color:var(--muted);">Canvas: Click to add nodes. Drag to move. Connect Mode to add edges.</div>
        </div>

        <div class="canvas-frame">
          <div id="canvas" class="canvas" role="region" aria-label="Graph drawing canvas" tabindex="0">
            <svg id="svgRoot" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 560" preserveAspectRatio="xMidYMid meet">
              <!-- edges and nodes drawn here -->
            </svg>
          </div>
        </div>

        <div class="footer tiny" aria-hidden="false">
          Visual explanation: Kruskal considers edges from smallest to largest. If an edge connects two different components, it is accepted (green) and components merge; otherwise it is rejected (red).
        </div>
      </section>
    </div>
  </div>

  <script>
    // Kruskal Interactive Module JavaScript
    (function(){
      // DOM references
      const svg = document.getElementById('svgRoot');
      const canvas = document.getElementById('canvas');
      const randomBtn = document.getElementById('randomBtn');
      const clearBtn = document.getElementById('clearBtn');
      const connectToggle = document.getElementById('connectToggle');
      const sortBtn = document.getElementById('sortBtn');
      const resetAlgBtn = document.getElementById('resetAlgBtn');
      const stepBtn = document.getElementById('stepBtn');
      const autoBtn = document.getElementById('autoBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const edgeQueue = document.getElementById('edgeQueue');
      const mstCountLabel = document.getElementById('mstCount');
      const mstWeightLabel = document.getElementById('mstWeight');
      const statusText = document.getElementById('statusText');

      // internal state
      let nodes = [];      // {id,x,y}
      let edges = [];      // {id,a,b,w,accepted,considered,rejected}
      let nodeId = 0, edgeId = 0;
      let width = 800, height = 560;
      const nodeRadius = 18;
      let isConnectMode = false;
      let connectFirst = null;
      let dragging = null;
      let offset = {x:0,y:0};
      let sortedEdges = [];
      let pointer = 0; // index in sortedEdges during Kruskal
      let ufParent = {}; // union-find parent
      let autoInterval = null;

      // helpers: get mouse position relative to SVG viewBox
      function getSvgPoint(clientX, clientY){
        const pt = svg.createSVGPoint();
        pt.x = clientX; pt.y = clientY;
        const ctm = svg.getScreenCTM().inverse();
        const svgP = pt.matrixTransform(ctm);
        return {x: svgP.x, y: svgP.y};
      }

      // rendering utilities
      function clearSvg(){
        while(svg.firstChild) svg.removeChild(svg.firstChild);
      }

      function createSvgElements(){
        // append defs for optional markers (none needed) and a background rect
        const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
        bg.setAttribute('x',0); bg.setAttribute('y',0);
        bg.setAttribute('width','100%'); bg.setAttribute('height','100%');
        bg.setAttribute('fill','transparent');
        svg.appendChild(bg);
      }

      // draw everything
      function render(){
        clearSvg();
        createSvgElements();

        // draw edges behind nodes
        for(const e of edges){
          const a = nodes.find(n=>n.id===e.a);
          const b = nodes.find(n=>n.id===e.b);
          if(!a||!b) continue;
          // line
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1',a.x); line.setAttribute('y1',a.y);
          line.setAttribute('x2',b.x); line.setAttribute('y2',b.y);
          line.setAttribute('class','edge-line');
          line.dataset.edgeId = e.id;
          // classes for state
          if(e.accepted) line.classList.add('edge-accepted');
          else if(e.rejected) line.classList.add('edge-rejected');
          else if(e.considered) line.classList.add('edge-consider');

          svg.appendChild(line);

          // weight label
          const midx = (a.x + b.x)/2;
          const midy = (a.y + b.y)/2;
          const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
          txt.setAttribute('x', midx);
          txt.setAttribute('y', midy - 8);
          txt.setAttribute('text-anchor','middle');
          txt.setAttribute('class','edge-weight');
          txt.textContent = String(e.w);
          svg.appendChild(txt);

          // invisible thick line on top for click target to allow future interactions (not used now)
          // (kept minimal to avoid interfering)
        }

        // draw node halos (component color)
        const componentColors = assignComponentColors();
        for(const n of nodes){
          const halo = document.createElementNS('http://www.w3.org/2000/svg','circle');
          halo.setAttribute('cx', n.x);
          halo.setAttribute('cy', n.y);
          halo.setAttribute('r', nodeRadius + 12);
          halo.setAttribute('class','node-halo');
          halo.setAttribute('fill', componentColors[n.id] || '#0000');
          svg.appendChild(halo);
        }

        // draw nodes on top
        for(const n of nodes){
          const group = document.createElementNS('http://www.w3.org/2000/svg','g');
          group.setAttribute('transform', `translate(${n.x},${n.y})`);
          group.dataset.nodeId = n.id;
          // circle
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('r', nodeRadius);
          c.setAttribute('class','node');
          c.setAttribute('fill','#1f6fbf');
          c.setAttribute('stroke','#0f3d73');
          c.setAttribute('stroke-width','2');
          c.setAttribute('tabindex','0');
          c.setAttribute('role','button');
          c.setAttribute('aria-label', 'Node ' + n.id);
          group.appendChild(c);
          // label
          const label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('class','node-label');
          label.setAttribute('y','5');
          label.setAttribute('x','0');
          label.setAttribute('text-anchor','middle');
          label.textContent = String(n.id);
          group.appendChild(label);

          // event listeners for dragging
          group.addEventListener('pointerdown', nodePointerDown);
          group.addEventListener('pointerup', nodePointerUp);
          group.addEventListener('pointermove', nodePointerMove);
          group.addEventListener('pointerleave', nodePointerUp);
          group.addEventListener('click', nodeClick);

          svg.appendChild(group);
        }
      }

      // assign colors to components for halo; returns map nodeId->color
      function assignComponentColors(){
        const rootMap = {};
        for(const n of nodes){
          rootMap[n.id] = find(n.id);
        }
        // unique roots
        const unique = {};
        for(const k in rootMap) unique[rootMap[k]] = true;
        const roots = Object.keys(unique);
        // generate pastel colors deterministically
        const colors = {};
        for(let i=0;i<roots.length;i++){
          const hue = (i * 67) % 360;
          colors[roots[i]] = `hsl(${hue} 70% 60%)`;
        }
        const out = {};
        for(const n of nodes){
          out[n.id] = colors[rootMap[n.id]];
        }
        return out;
      }

      // node pointer events (dragging)
      function nodePointerDown(evt){
        evt.stopPropagation();
        const id = Number(this.dataset.nodeId);
        dragging = id;
        const pt = getSvgPoint(evt.clientX, evt.clientY);
        const node = nodes.find(n=>n.id===id);
        offset.x = pt.x - node.x;
        offset.y = pt.y - node.y;
        this.setPointerCapture(evt.pointerId);
      }
      function nodePointerMove(evt){
        if(dragging==null) return;
        evt.preventDefault();
        const id = dragging;
        const pt = getSvgPoint(evt.clientX, evt.clientY);
        const node = nodes.find(n=>n.id===id);
        if(!node) return;
        node.x = Math.max(30, Math.min(770, pt.x - offset.x));
        node.y = Math.max(30, Math.min(530, pt.y - offset.y));
        render();
      }
      function nodePointerUp(evt){
        if(dragging==null) return;
        try{ this.releasePointerCapture(evt.pointerId); }catch(e){}
        dragging = null;
      }

      // clicking nodes: used for connect mode and optionally selection
      function nodeClick(evt){
        evt.stopPropagation();
        const id = Number(this.dataset.nodeId);
        if(isConnectMode){
          if(connectFirst==null){
            connectFirst = id;
            statusText.textContent = `Selected node ${id} as first endpoint. Choose second node.`;
          } else if(connectFirst === id){
            statusText.textContent = 'Pick a different node to connect.';
          } else {
            const a = connectFirst, b = id;
            connectFirst = null;
            // prompt for weight
            let w = prompt('Edge weight (positive integer):', '10');
            if(w===null) { statusText.textContent = 'Edge creation canceled.'; return; }
            w = Math.max(0, parseInt(w) || 0);
            if(Number.isNaN(w)) w = 0;
            addEdge(a,b,w);
            statusText.textContent = `Edge ${a}–${b} weight ${w} created.`;
            render();
          }
        } else {
          // non-connect: maybe future extension, show node id
          statusText.textContent = `Node ${id} selected. Toggle Connect Mode to add edges.`;
        }
      }

      // canvas click to add node
      canvas.addEventListener('click', function(evt){
        // if click on node was handled, do not add; we rely on event bubbling, so check target
        if(evt.target.closest('g')) return;
        const rect = canvas.getBoundingClientRect();
        const pt = getSvgPoint(evt.clientX, evt.clientY);
        addNode(pt.x, pt.y);
        render();
      });

      // add node utility
      function addNode(x,y){
        const id = ++nodeId;
        nodes.push({id, x, y});
        // when graph changes, algorithm state resets
        resetAlgorithmState();
        render();
      }

      // add edge utility (undirected)
      function addEdge(a,b,w){
        if(a===b) return;
        // prevent duplicates (same endpoints)
        if(edges.some(e => (e.a===a && e.b===b) || (e.a===b && e.b===a))){
          statusText.textContent = 'Edge already exists.';
          return;
        }
        const id = ++edgeId;
        edges.push({id, a, b, w: Math.max(0, Number(w)||0), accepted:false, considered:false, rejected:false});
        resetAlgorithmState();
      }

      // UI control handlers
      randomBtn.addEventListener('click', ()=>{
        generateRandomGraph(6, 10); // nodes, edges target
        render();
      });
      clearBtn.addEventListener('click', ()=>{
        nodes = []; edges = []; nodeId = 0; edgeId = 0;
        resetAlgorithmState();
        render();
      });
      connectToggle.addEventListener('click', ()=>{
        isConnectMode = !isConnectMode;
        connectFirst = null;
        connectToggle.innerText = `Connect Mode: ${isConnectMode ? 'On' : 'Off'}`;
        connectToggle.setAttribute('aria-pressed', String(isConnectMode));
        if(isConnectMode) connectToggle.classList.add('btn--active');
        statusText.textContent = isConnectMode ? 'Click two nodes to connect them.' : 'Connect mode off.';
      });
      sortBtn.addEventListener('click', ()=>{
        sortEdges();
        statusText.textContent = 'Edges sorted by weight.';
        renderQueue();
      });
      resetAlgBtn.addEventListener('click', ()=>{
        resetAlgorithmState();
        renderQueue();
        render();
      });
      stepBtn.addEventListener('click', ()=>{
        stepKruskal();
      });
      autoBtn.addEventListener('click', ()=>{
        if(autoInterval) return;
        autoBtn.setAttribute('aria-pressed','true');
        autoBtn.disabled = true;
        pauseBtn.disabled = false;
        pauseBtn.focus();
        autoInterval = setInterval(()=>{
          const done = stepKruskal();
          if(done) stopAuto();
        }, 700);
      });
      pauseBtn.addEventListener('click', ()=>{
        stopAuto();
      });

      function stopAuto(){
        if(autoInterval) clearInterval(autoInterval);
        autoInterval = null;
        autoBtn.setAttribute('aria-pressed','false');
        autoBtn.disabled = false;
        pauseBtn.disabled = true;
      }

      function resetAlgorithmState(){
        // reset edge states
        for(const e of edges){
          e.accepted = false;
          e.considered = false;
          e.rejected = false;
        }
        sortedEdges = [];
        pointer = 0;
        ufParent = {};
        for(const n of nodes) ufParent[n.id] = n.id;
        updateMstInfo();
        statusText.textContent = 'Algorithm reset. Sort edges to begin.';
        stopAuto();
        renderQueue();
      }

      // sort edges ascending
      function sortEdges(){
        sortedEdges = edges.slice().sort((a,b)=>{
          if(a.w !== b.w) return a.w - b.w;
          // tie-break: by endpoints to have deterministic order
          if(Math.min(a.a,a.b) !== Math.min(b.a,b.b)) return Math.min(a.a,a.b) - Math.min(b.a,b.b);
          return Math.max(a.a,a.b) - Math.max(b.a,b.b);
        }).map(e => e.id);
        pointer = 0;
        // clear considered flags
        for(const e of edges) { e.considered = false; e.accepted=false; e.rejected=false; }
        // reset union-find
        ufParent = {};
        for(const n of nodes) ufParent[n.id] = n.id;
        updateMstInfo();
        renderQueue();
      }

      // render queue
      function renderQueue(){
        edgeQueue.innerHTML = '';
        if(sortedEdges.length===0){
          edgeQueue.textContent = '(no sorted edges; click "Sort Edges")';
          return;
        }
        for(let i=0;i<sortedEdges.length;i++){
          const id = sortedEdges[i];
          const e = edges.find(x=>x.id===id);
          const div = document.createElement('div');
          div.className = 'queue-item' + (i===pointer ? ' current' : '');
          const left = document.createElement('div');
          left.textContent = `${e.a}—${e.b}`;
          const right = document.createElement('div');
          right.style.display='flex'; right.style.gap='8px'; right.style.alignItems='center';
          const wSpan = document.createElement('div');
          wSpan.textContent = `${e.w}`;
          wSpan.style.color = '#222'; wSpan.style.fontWeight = '600';
          const state = document.createElement('div');
          state.textContent = e.accepted ? 'ACCEPTED' : (e.rejected ? 'rejected' : (e.considered ? 'considering' : ''));
          state.style.color = e.accepted ? 'var(--success)' : (e.rejected ? 'var(--danger)' : 'var(--muted)');
          right.appendChild(wSpan); right.appendChild(state);
          div.appendChild(left); div.appendChild(right);
          edgeQueue.appendChild(div);
        }
      }

      // union-find
      function find(x){
        if(ufParent[x] === undefined) ufParent[x] = x;
        if(ufParent[x] !== x) ufParent[x] = find(ufParent[x]);
        return ufParent[x];
      }
      function union(a,b){
        const ra = find(a), rb = find(b);
        if(ra===rb) return false;
        ufParent[rb] = ra;
        return true;
      }

      // Kruskal step: consider next edge in sortedEdges
      function stepKruskal(){
        if(sortedEdges.length === 0) {
          statusText.textContent = 'No sorted edges. Click "Sort Edges" first.';
          return false;
        }
        if(pointer >= sortedEdges.length){
          statusText.textContent = 'All edges considered. Algorithm complete.';
          return true;
        }
        // mark all edges considered=false except current to highlight only one
        for(const e of edges){ e.considered = false; }
        const edgeIdCurr = sortedEdges[pointer];
        const e = edges.find(x=>x.id===edgeIdCurr);
        if(!e){
          pointer++;
          renderQueue();
          return false;
        }
        e.considered = true;
        // animate consideration
        statusText.textContent = `Considering edge ${e.a}–${e.b} weight ${e.w}...`;
        render();

        // small delay for user to see consideration (synchronous for step button)
        // Perform check
        const ra = find(e.a), rb = find(e.b);
        if(ra !== rb){
          // accept
          e.accepted = true;
          e.rejected = false;
          union(ra, rb);
          statusText.textContent = `Accepted edge ${e.a}–${e.b} (${e.w}). Components merged.`;
        } else {
          e.rejected = true;
          e.accepted = false;
          statusText.textContent = `Rejected edge ${e.a}–${e.b} (${e.w}) — forms a cycle.`;
        }
        e.considered = false;
        pointer++;
        updateMstInfo();
        renderQueue();
        render();

        // check finished
        const acceptedCount = edges.filter(x=>x.accepted).length;
        if(acceptedCount === Math.max(0,nodes.length - 1)){
          statusText.textContent = 'MST complete.';
          return true;
        }
        if(pointer >= sortedEdges.length){
          statusText.textContent = 'All edges considered.';
          return true;
        }
        return false;
      }

      function updateMstInfo(){
        const accepted = edges.filter(x=>x.accepted);
        const total = accepted.reduce((s,e)=>s+Number(e.w||0), 0);
        mstCountLabel.textContent = String(accepted.length);
        mstWeightLabel.textContent = String(total);
      }

      // simple random graph generator
      function generateRandomGraph(nNodes=6, nEdges=10){
        nodes = []; edges = []; nodeId = 0; edgeId = 0;
        // layout nodes in a circle-ish
        const cx = 400, cy = 280, r = Math.min(200, Math.max(120, nNodes*18));
        for(let i=0;i<nNodes;i++){
          const ang = (i / nNodes) * Math.PI * 2;
          const jitter = (Math.random()-0.5) * 40;
          const x = cx + Math.cos(ang) * r + jitter;
          const y = cy + Math.sin(ang) * r + (Math.random()-0.5) * 40;
          addNode(x,y);
        }
        // connect to ensure graph connectivity (chain)
        for(let i=1;i<nNodes;i++){
          const w = Math.floor(Math.random()*20)+1;
          addEdge(i, i+1, w);
        }
        // add random additional edges
        let attempts = 0;
        while(edges.length < Math.min(nEdges, nNodes*(nNodes-1)/2) && attempts < 200){
          attempts++;
          const a = Math.floor(Math.random()*nNodes)+1;
          const b = Math.floor(Math.random()*nNodes)+1;
          if(a===b) continue;
          if(edges.some(e => (e.a===a && e.b===b) || (e.a===b && e.b===a))) continue;
          const w = Math.floor(Math.random()*30)+1;
          addEdge(a,b,w);
        }
        resetAlgorithmState();
        render();
      }

      // initial setup
      (function init(){
        // set SVG viewBox to a fixed internal coordinate system for easy mapping
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        createSvgElements();
        render();
      })();

      // keyboard accessibility: space toggles connect mode when focused on canvas
      canvas.addEventListener('keydown', (evt)=>{
        if(evt.key === 'c' || evt.key === 'C'){
          connectToggle.click();
        } else if(evt.key === 's' || evt.key === 'S'){
          sortBtn.click();
        } else if(evt.key === ' '){
          evt.preventDefault();
          stepBtn.click();
        }
      });

      // initial example
      generateRandomGraph(6, 10);
      sortBtn.click();
    })();
  </script>
</body>
</html>