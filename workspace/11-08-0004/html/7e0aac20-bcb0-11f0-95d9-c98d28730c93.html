<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Divide and Conquer — Interactive Module (Merge Sort)</title>
  <style>
    /* Safe area margins: 24px all sides */
    :root {
      --safe-pad: 24px;
      --gap: 16px;
      --accent: #2563eb;
      --muted: #6b7280;
      --bg: #0f172a;
      --card: #0b1220;
      --success: #16a34a;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.04);
    }

    html,body {
      height: 100%;
      margin: 0;
      padding: var(--safe-pad);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #071029 0%, #021020 100%);
      color: #e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      box-sizing: border-box;
    }
    *,*::before,*::after { box-sizing: inherit; }

    header {
      display: flex;
      gap: var(--gap);
      align-items: center;
      justify-content: space-between;
      margin-bottom: calc(var(--gap) + 8px);
    }
    .title {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    h1 {
      font-size: 1.25rem;
      margin: 0;
      letter-spacing: -0.01em;
    }
    p.lead {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    main {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: var(--gap);
      align-items: start;
    }

    /* Control panel card */
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.012));
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 4px 18px rgba(2,6,23,0.6);
      min-height: 240px;
    }
    .control {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 8px;
    }
    label {
      font-size: 0.88rem;
      color: #cfe3ff;
    }
    input[type="range"] {
      width: 100%;
    }
    .row {
      display:flex;
      gap: var(--gap);
      align-items:center;
    }
    .btn {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      color: #e6eef8;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      min-height: 40px;
      display: inline-flex;
      align-items:center;
      gap: 8px;
      transition: transform .12s ease, box-shadow .12s ease;
      font-size: 0.95rem;
    }
    .btn:active { transform: translateY(1px); }
    .btn.primary {
      background: linear-gradient(180deg, var(--accent), #1e40af);
      box-shadow: 0 6px 18px rgba(37,99,235,0.12);
      border: none;
    }
    .btn.ghost {
      background: transparent;
      border: 1px dashed rgba(255,255,255,0.04);
    }
    .small {
      font-size: 0.86rem;
      padding: 6px 10px;
    }

    .muted {
      color: var(--muted);
      font-size: 0.9rem;
    }

    /* Visual area */
    .visual {
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }
    .vis-card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 18px;
      min-height: 320px;
      box-shadow: 0 6px 30px rgba(3,7,18,0.6);
    }

    /* Array bars */
    .array-area {
      width: 100%;
      height: 220px;
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008));
      display:flex;
      align-items:end;
      gap: 8px;
      padding: 12px;
      overflow: hidden;
    }
    .bar {
      flex: 1 1 auto;
      min-width: 12px;
      background: linear-gradient(180deg,#60a5fa, #2563eb);
      border-radius: 6px 6px 4px 4px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color: rgba(255,255,255,0.95);
      font-weight: 600;
      font-size: 0.78rem;
      transition: height 400ms cubic-bezier(.2,.9,.2,1), transform 240ms ease, background 240ms ease;
      transform-origin: bottom center;
      box-shadow: 0 6px 18px rgba(37,99,235,0.12);
      position: relative;
    }
    .bar.small {
      font-size: 0.65rem;
      color: rgba(255,255,255,0.85);
      font-weight: 600;
    }
    .bar-label {
      position: absolute;
      top: -22px;
      font-size: 0.72rem;
      color: var(--muted);
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
    }

    .bar.highlight {
      background: linear-gradient(180deg,#facc15,#f59e0b);
      transform: translateY(-8px) scale(1.03);
      box-shadow: 0 12px 30px rgba(245,158,11,0.14);
      z-index: 2;
    }

    .range-overlay {
      position: absolute;
      border-radius: 8px;
      pointer-events: none;
      background: linear-gradient(90deg, rgba(37,99,235,0.08), rgba(99,102,241,0.04));
      border: 1px dashed rgba(99,102,241,0.12);
      transition: all 380ms cubic-bezier(.2,.9,.2,1);
      backdrop-filter: blur(3px);
    }

    /* Action log */
    .log {
      margin-top: 8px;
      display:flex;
      gap: var(--gap);
      align-items:center;
      justify-content: space-between;
    }
    .description {
      font-size: 0.95rem;
      color: #dbeafe;
    }
    .small-muted {
      color: var(--muted);
      font-size: 0.85rem;
    }

    /* Recursion stack / tree */
    .stack {
      margin-top: 12px;
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .call {
      background: var(--glass);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 0.86rem;
      color: #cfe3ff;
      border: 1px solid rgba(255,255,255,0.03);
    }
    .call.active {
      background: rgba(20,83,220,0.14);
      border: 1px solid rgba(37,99,235,0.22);
      box-shadow: 0 6px 18px rgba(37,99,235,0.06);
    }

    footer.note {
      margin-top: 12px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    /* Responsive */
    @media (max-width: 880px) {
      main { grid-template-columns: 1fr; }
      .array-area { height: 200px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="title" aria-hidden="false">
      <h1>Divide and Conquer — Interactive Module</h1>
      <p class="lead">Example: Merge Sort — visualize how a problem is split into subproblems, solved, and combined.</p>
    </div>
    <div class="muted" aria-hidden="true">Tip: Space = Play/Pause • ← / → = Step</div>
  </header>

  <main>
    <!-- Left: Plan + Controls -->
    <section style="display:flex;flex-direction:column;gap:var(--gap);">
      <div class="card" aria-labelledby="plan-heading">
        <h2 id="plan-heading" style="margin:0 0 10px 0;font-size:1rem;">Interactive Design Plan</h2>
        <div style="font-size:0.95rem;color:#dbeafe;line-height:1.4;">
          <strong>Concept Title:</strong> Divide and Conquer — Merge Sort visualization.<br/><br/>
          <strong>Learning Objective:</strong>
          After interacting with this module, you should be able to:
          <ul style="margin:8px 0 0 18px;color:var(--muted);font-size:0.92rem;">
            <li>Explain how a problem is recursively divided into smaller subproblems (split).</li>
            <li>Identify the base case when subproblems are small enough to solve directly.</li>
            <li>Describe how solutions are combined (merge) to form the final answer.</li>
          </ul>
        </div>
      </div>

      <div class="card" aria-label="Interaction and layout description">
        <h3 style="margin:0 0 8px 0;font-size:1rem;">Interaction Design</h3>
        <div class="control">
          <div style="color:var(--muted);font-size:0.95rem;line-height:1.45;">
            Interactions:
            <ul style="margin:8px 0 0 18px;color:var(--muted);font-size:0.92rem;">
              <li><strong>Generate</strong> random arrays or type a custom comma-separated list.</li>
              <li><strong>Play/Pause</strong> animation of the divide-and-conquer process. Step forwards/backwards.</li>
              <li><strong>Speed</strong> slider controls animation speed. Size slider adjusts array length.</li>
              <li><strong>Hover</strong> a bar to see its value. Current active subarray is highlighted; merge steps animate bar heights changing to reflect sorted values.</li>
              <li>Keyboard: <kbd>Space</kbd> toggles play/pause. <kbd>←</kbd> and <kbd>→</kbd> step through actions.</li>
            </ul>
            Visual feedback:
            <ul style="margin:8px 0 0 18px;color:var(--muted);font-size:0.92rem;">
              <li>Highlighted ranges animate with a translucent overlay to show "split" boundaries.</li>
              <li>During merges, bars smoothly change height to their new sorted values; merged elements lift slightly and change color.</li>
              <li>A textual description updates describing the current step (split or merge) and the recursion stack displays active calls.</li>
            </ul>
          </div>
        </div>

        <h3 style="margin:10px 0 6px 0;font-size:1rem;">Layout Description</h3>
        <div style="color:var(--muted);font-size:0.95rem;line-height:1.45;">
          Spatial organization:
          <ul style="margin:8px 0 0 18px;color:var(--muted);font-size:0.92rem;">
            <li>Left column (controls & design plan) — fixed-width card stack for inputs and explanation.</li>
            <li>Right column (visual) — large responsive card for the array visualization, action log, and recursion stack.</li>
            <li>Safe area margins of 24px applied to viewport. Minimum spacing of 16px between controls and visual elements. Components use consistent radii and subtle shadows for focus.</li>
            <li>Accessibility: buttons are keyboard operable, labels are present, high-contrast colors used, and layout collapses to a single column on narrow screens.</li>
          </ul>
        </div>
      </div>

      <div class="card" aria-label="Controls">
        <div class="control" role="region" aria-label="controls">
          <div style="display:flex;gap:var(--gap);align-items:center;justify-content:space-between;">
            <label for="size">Array size</label>
            <div class="small-muted" id="size-value">8</div>
          </div>
          <input id="size" type="range" min="4" max="20" value="8" />

          <div style="display:flex;gap:var(--gap);align-items:center;justify-content:space-between;">
            <label for="speed">Speed</label>
            <div class="small-muted" id="speed-value">1x</div>
          </div>
          <input id="speed" type="range" min="0.25" max="3" step="0.25" value="1" />

          <div style="display:flex;gap:var(--gap);align-items:center;">
            <button class="btn primary" id="randomBtn" aria-label="Generate random array">Randomize</button>
            <button class="btn" id="shuffleBtn" aria-label="Shuffle array sample">Shuffle</button>
            <button class="btn ghost" id="resetBtn" aria-label="Reset">Reset</button>
          </div>

          <div style="display:flex;gap:var(--gap);align-items:center;">
            <input id="customInput" type="text" placeholder="Type values e.g. 7,3,9,1" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit" aria-label="Custom array input" />
            <button class="btn small" id="applyBtn" aria-label="Apply custom array">Apply</button>
          </div>

          <div style="display:flex;gap:var(--gap);align-items:center;">
            <button class="btn primary" id="playPause" aria-label="Play or pause animation">Play</button>
            <button class="btn" id="stepBack" aria-label="Step back">◀</button>
            <button class="btn" id="stepForward" aria-label="Step forward">▶</button>
          </div>

          <div class="small-muted">Keyboard: Space = Play/Pause • ← / → = Step</div>
        </div>
      </div>
    </section>

    <!-- Right: Visualization -->
    <section class="visual" aria-live="polite" aria-atomic="true">
      <div class="vis-card" role="application" aria-label="Merge sort visualization">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <div style="font-weight:600;font-size:1rem;">Array View</div>
            <div class="small-muted" style="margin-top:4px;">Watch how the array is split, base cases reached, and sorted chunks merged.</div>
          </div>
          <div class="small-muted" id="stepCounter">Step 0 / 0</div>
        </div>

        <div style="position:relative;margin-top:12px;">
          <div id="arrayArea" class="array-area" aria-hidden="false" tabindex="0" role="listbox" aria-label="Array elements">
            <!-- Bars injected here -->
          </div>
          <!-- overlay for highlighting active range (installed/manipulated by JS) -->
          <div id="overlay" class="range-overlay" style="display:none;"></div>
        </div>

        <div class="log" style="margin-top:12px;">
          <div class="description" id="actionDesc">No actions yet. Generate an array and press Play.</div>
          <div class="small-muted" id="currentRange">—</div>
        </div>

        <div style="margin-top:12px;">
          <div style="font-weight:600;margin-bottom:8px;">Recursion Stack</div>
          <div id="stackArea" class="stack" aria-live="polite">
            <!-- active calls inserted here -->
          </div>
        </div>

        <div class="note" style="margin-top:12px;color:var(--muted);font-size:0.9rem;">
          This interactive uses Merge Sort as an example to illustrate the Divide and Conquer pattern — split, solve, combine.
        </div>
      </div>

      <div style="display:flex;gap:var(--gap);align-items:center;">
        <div class="card" style="flex:1;">
          <div style="font-weight:600;margin-bottom:8px;">Current Action</div>
          <div id="actionDetail" style="color:var(--muted);line-height:1.5;">No action yet.</div>
        </div>
        <div class="card" style="width:220px;">
          <div style="font-weight:600;margin-bottom:8px;">Legend</div>
          <div style="display:flex;flex-direction:column;gap:8px;color:var(--muted);font-size:0.92rem;">
            <div><span style="display:inline-block;width:16px;height:10px;background:linear-gradient(180deg,#60a5fa,#2563eb);border-radius:3px;margin-right:8px;vertical-align:middle"></span> Unsorted element</div>
            <div><span style="display:inline-block;width:16px;height:10px;background:linear-gradient(180deg,#facc15,#f59e0b);border-radius:3px;margin-right:8px;vertical-align:middle"></span> Active / merging</div>
            <div><span style="display:inline-block;width:16px;height:10px;background:rgba(37,99,235,0.08);border-radius:3px;margin-right:8px;vertical-align:middle;border:1px dashed rgba(99,102,241,0.12)"></span> Current split range</div>
          </div>
        </div>
      </div>

    </section>
  </main>

  <script>
    // Self-contained Merge Sort visualization implementing Divide & Conquer concept.
    // Author: interactive module
    // No external libraries.

    (function () {
      // DOM references
      const sizeInput = document.getElementById('size');
      const sizeValue = document.getElementById('size-value');
      const speedInput = document.getElementById('speed');
      const speedValue = document.getElementById('speed-value');
      const randomBtn = document.getElementById('randomBtn');
      const shuffleBtn = document.getElementById('shuffleBtn');
      const resetBtn = document.getElementById('resetBtn');
      const applyBtn = document.getElementById('applyBtn');
      const customInput = document.getElementById('customInput');

      const playPauseBtn = document.getElementById('playPause');
      const stepBackBtn = document.getElementById('stepBack');
      const stepForwardBtn = document.getElementById('stepForward');

      const arrayArea = document.getElementById('arrayArea');
      const overlay = document.getElementById('overlay');
      const actionDesc = document.getElementById('actionDesc');
      const actionDetail = document.getElementById('actionDetail');
      const stackArea = document.getElementById('stackArea');
      const stepCounter = document.getElementById('stepCounter');
      const currentRange = document.getElementById('currentRange');

      // State
      let baseArray = [];
      let bars = [];
      let actions = []; // timeline of actions
      let current = 0; // index into actions
      let playing = false;
      let timer = null;
      let speed = 1; // multiplier (1x default)
      let stepDuration = 800; // base ms per step, adjusted by speed
      let maxBars = 20;

      // Initialize defaults
      function randArray(n) {
        const arr = [];
        for (let i = 0; i < n; i++) arr.push(Math.floor(Math.random() * 90) + 10);
        return arr;
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      function formatRange(l, r) {
        return '[' + l + ', ' + (r - 1) + ']';
      }

      // Build actions by performing merge sort but recording steps
      function recordMergeSort(arr) {
        actions = [];
        const a = arr.slice();

        function push(action) {
          actions.push(JSON.parse(JSON.stringify(action)));
        }

        function ms(l, r) {
          // push split action
          push({ type: 'split', range: [l, r], array: a.slice(), note: `split ${formatRange(l, r)}` });
          if (r - l <= 1) {
            // base case (single element)
            push({ type: 'base', range: [l, r], array: a.slice(), note: `base ${formatRange(l, r)}` });
            return;
          }
          const m = Math.floor((l + r) / 2);
          ms(l, m);
          ms(m, r);

          // merge step
          // perform merge in a temporary way, but record the resulting array snapshot
          const left = a.slice(l, m);
          const right = a.slice(m, r);
          let i = 0, j = 0, k = l;
          while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
              a[k++] = left[i++];
            } else {
              a[k++] = right[j++];
            }
          }
          while (i < left.length) a[k++] = left[i++];
          while (j < right.length) a[k++] = right[j++];

          push({ type: 'merge', range: [l, r], mid: m, array: a.slice(), note: `merge ${formatRange(l, r)}` });
        }

        ms(0, a.length);
        push({ type: 'done', range: [0, a.length], array: a.slice(), note: 'sorted' });
      }

      // Render array bars
      function renderArray(arr) {
        arrayArea.innerHTML = '';
        bars = [];
        const n = arr.length;
        const maxVal = Math.max(...arr, 100);
        for (let i = 0; i < n; i++) {
          const val = arr[i];
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.setAttribute('role', 'option');
          bar.setAttribute('aria-label', 'value ' + val);
          bar.style.height = Math.max(8, (val / maxVal) * 100) + '%';
          bar.dataset.index = i;
          bar.dataset.value = val;
          bar.innerHTML = '<div class="bar-label" aria-hidden="true">' + val + '</div>' + val;
          arrayArea.appendChild(bar);
          bars.push(bar);

          // hover tooltip by title
          bar.title = 'Index ' + i + ' • Value ' + val;

          // accessibility: allow focus for keyboard users
          bar.tabIndex = 0;
          bar.addEventListener('focus', () => {
            bar.classList.add('highlight');
            setTimeout(()=>bar.classList.remove('highlight'), 600);
          });
        }
      }

      // Highlight range with overlay
      function showRangeOverlay(l, r) {
        if (l >= r) { overlay.style.display = 'none'; currentRange.textContent = '—'; return; }
        const children = Array.from(arrayArea.children);
        if (!children[l] || !children[r-1]) { overlay.style.display = 'none'; currentRange.textContent = '—'; return; }
        const rectL = children[l].getBoundingClientRect();
        const rectR = children[r-1].getBoundingClientRect();
        const parentRect = arrayArea.getBoundingClientRect();
        const left = rectL.left - parentRect.left - 6; // account for gaps/padding
        const right = rectR.right - parentRect.left + 6;
        overlay.style.left = left + 'px';
        overlay.style.top = '8px';
        overlay.style.width = Math.max(12, right - left) + 'px';
        overlay.style.height = (arrayArea.clientHeight - 16) + 'px';
        overlay.style.display = 'block';
        currentRange.textContent = 'Active range: ' + formatRange(l, r);
      }

      // Apply an action: update visuals to reflect an action state
      function applyAction(idx, immediate = false) {
        current = clamp(idx, 0, actions.length - 1);
        const act = actions[current];
        stepCounter.textContent = 'Step ' + (current + 1) + ' / ' + actions.length;
        if (!act) {
          actionDesc.textContent = 'No action';
          actionDetail.textContent = '';
          overlay.style.display = 'none';
          return;
        }

        // update description and stack
        actionDesc.textContent = act.note || act.type;
        actionDetail.textContent = (act.type === 'merge') ?
          `Merging ${formatRange(act.range[0], act.range[1])} (mid=${act.mid})` :
          (act.type === 'split') ? `Splitting ${formatRange(act.range[0], act.range[1])}` :
          (act.type === 'base') ? `Base case ${formatRange(act.range[0], act.range[1])}` :
          (act.type === 'done') ? `Complete` : act.type;

        // show recursion stack snapshot (active calls for split actions)
        renderStackForAction(act);

        // show overlay for active range
        showRangeOverlay(act.range[0], act.range[1]);

        if (act.type === 'merge' || act.type === 'done') {
          // animate bars to the snapshot array
          animateToArray(act.array, immediate);
        } else {
          // for split/base actions just highlight range without changing heights
          highlightRange(act.range[0], act.range[1], (act.type === 'base'));
        }
      }

      // Render recursion "stack" heuristically: reconstruct call path up to current action
      function renderStackForAction(action) {
        stackArea.innerHTML = '';
        // We'll build the path from root splitting down to the action's range
        const n = baseArray.length;
        const path = [];
        function discover(l, r) {
          path.push([l, r]);
          if (l >= action.range[0] && r <= action.range[1]) {
            // keep going deeper if possible
          }
          if (r - l <= 1) {
            return;
          }
          const m = Math.floor((l + r) / 2);
          // If the action range intersects left, explore left
          if (!(action.range[1] <= l || action.range[0] >= m)) {
            discover(l, m);
          }
          // If it intersects right, explore right
          if (!(action.range[1] <= m || action.range[0] >= r)) {
            discover(m, r);
          }
        }
        // Simpler approach: list ancestors of the action.range by walking from root and checking containment
        const ancestors = [];
        function collectAncestors(l, r) {
          if (l === action.range[0] && r === action.range[1]) {
            ancestors.push([l, r]);
            return true;
          }
          const m = Math.floor((l + r) / 2);
          // if action range is entirely within this node, it's an ancestor
          if (action.range[0] >= l && action.range[1] <= r) {
            ancestors.push([l, r]);
            if (r - l <= 1) return true;
            // go deeper as appropriate
            if (action.range[1] <= m) return collectAncestors(l, m);
            if (action.range[0] >= m) return collectAncestors(m, r);
            // overlaps both: we still descend both to show structure
            collectAncestors(l, m);
            collectAncestors(m, r);
            return true;
          }
          return false;
        }
        collectAncestors(0, n);

        // Render ancestors as stack nodes
        ancestors.forEach((p, i) => {
          const div = document.createElement('div');
          div.className = 'call';
          if (i === ancestors.length - 1) div.classList.add('active');
          div.textContent = formatRange(p[0], p[1]);
          stackArea.appendChild(div);
        });
        if (ancestors.length === 0) {
          const div = document.createElement('div');
          div.className = 'call active';
          div.textContent = formatRange(action.range[0], action.range[1]);
          stackArea.appendChild(div);
        }
      }

      // Animate bars to match a target array snapshot
      function animateToArray(targetArray, immediate = false) {
        const n = Math.min(bars.length, targetArray.length);
        const maxVal = Math.max(...targetArray, 100);
        for (let i = 0; i < n; i++) {
          const bar = bars[i];
          const newVal = targetArray[i];
          bar.dataset.value = newVal;
          // update label text
          const label = bar.querySelector('.bar-label');
          if (label) label.textContent = newVal;
          // set height with transition
          if (immediate) {
            bar.style.transition = 'none';
            bar.style.height = Math.max(8, (newVal / maxVal) * 100) + '%';
            // force reflow then restore transition
            void bar.offsetWidth;
            bar.style.transition = '';
          } else {
            bar.style.height = Math.max(8, (newVal / maxVal) * 100) + '%';
            // highlight bars in the active merge range
            // if current action is merge, highlight within that range
            const act = actions[current];
            if (act && act.type === 'merge') {
              const l = act.range[0], r = act.range[1];
              if (i >= l && i < r) {
                bar.classList.add('highlight');
                setTimeout(() => bar.classList.remove('highlight'), Math.max(300, 200 / speed));
              }
            }
          }
          bar.title = 'Index ' + i + ' • Value ' + newVal;
          // update visible text
          bar.childNodes.forEach(n => {
            if (n.nodeType === 3) n.nodeValue = newVal; // text node value
          });
        }
      }

      // Highlight a range without changing heights (for split/base)
      function highlightRange(l, r, base = false) {
        bars.forEach((b, i) => {
          b.classList.toggle('highlight', base ? (i >= l && i < r) : false);
        });
      }

      // Playback controls
      function play() {
        if (actions.length === 0) return;
        playing = true;
        playPauseBtn.textContent = 'Pause';
        scheduleNext();
      }

      function pause() {
        playing = false;
        playPauseBtn.textContent = 'Play';
        if (timer) { clearTimeout(timer); timer = null; }
      }

      function scheduleNext() {
        if (!playing) return;
        if (current >= actions.length - 1) {
          pause();
          return;
        }
        timer = setTimeout(() => {
          stepForward();
          scheduleNext();
        }, Math.max(80, stepDuration / speed));
      }

      function stepForward() {
        applyAction(current + 1);
      }
      function stepBack() {
        applyAction(current - 1);
      }

      // Event wiring
      sizeInput.addEventListener('input', () => {
        sizeValue.textContent = sizeInput.value;
      });
      speedInput.addEventListener('input', () => {
        speed = Number(speedInput.value);
        speedValue.textContent = speed + 'x';
      });

      randomBtn.addEventListener('click', () => {
        pause();
        const n = Number(sizeInput.value);
        baseArray = randArray(n);
        renderArray(baseArray);
        recordMergeSort(baseArray);
        applyAction(0);
      });

      shuffleBtn.addEventListener('click', () => {
        pause();
        baseArray = baseArray.slice();
        for (let i = baseArray.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [baseArray[i], baseArray[j]] = [baseArray[j], baseArray[i]];
        }
        renderArray(baseArray);
        recordMergeSort(baseArray);
        applyAction(0);
      });

      resetBtn.addEventListener('click', () => {
        pause();
        baseArray = baseArray.slice().sort((a,b)=>a-b);
        renderArray(baseArray);
        recordMergeSort(baseArray);
        applyAction(0);
      });

      applyBtn.addEventListener('click', () => {
        pause();
        const text = customInput.value.trim();
        if (!text) return;
        const parts = text.split(',').map(s => Number(s.trim())).filter(v => !Number.isNaN(v));
        if (parts.length === 0) return;
        baseArray = parts.slice(0, maxBars);
        sizeInput.value = baseArray.length;
        sizeValue.textContent = baseArray.length;
        renderArray(baseArray);
        recordMergeSort(baseArray);
        applyAction(0);
      });

      playPauseBtn.addEventListener('click', () => {
        if (playing) pause(); else play();
      });
      stepForwardBtn.addEventListener('click', () => {
        pause();
        stepForward();
      });
      stepBackBtn.addEventListener('click', () => {
        pause();
        stepBack();
      });

      // Keyboard controls
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          playPauseBtn.click();
        } else if (e.code === 'ArrowRight') {
          e.preventDefault();
          stepForwardBtn.click();
        } else if (e.code === 'ArrowLeft') {
          e.preventDefault();
          stepBackBtn.click();
        }
      });

      // When resizing or when actions change, re-position overlay
      window.addEventListener('resize', () => {
        if (actions[current]) showRangeOverlay(actions[current].range[0], actions[current].range[1]);
      });

      // Initial setup
      (function init() {
        sizeValue.textContent = sizeInput.value;
        speedValue.textContent = speedInput.value + 'x';
        speed = Number(speedInput.value);

        baseArray = randArray(Number(sizeInput.value));
        renderArray(baseArray);
        recordMergeSort(baseArray);
        applyAction(0);
      })();

      // Expose some functions for debugging (optional)
      window.__mergeViz = {
        actions: () => actions,
        apply: applyAction,
        play: play,
        pause: pause
      };
    })();
  </script>
</body>
</html>