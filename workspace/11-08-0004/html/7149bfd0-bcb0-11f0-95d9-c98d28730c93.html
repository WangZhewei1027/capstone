<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Heap (Min/Max) Interactive Module</title>
  <style>
    :root{
      --safe: 24px;
      --gap: 16px;
      --accent: #1e88e5;
      --accent-2: #f57c00;
      --bg: #f6f8fb;
      --card: #ffffff;
      --text: #0f1724;
      --muted: #556074;
      --success: #2e7d32;
      --danger: #c62828;
      --node-size: 56px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    main{
      padding:var(--safe);
      min-height:100vh;
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      justify-content:center;
    }
    /* Left controls column */
    .panel{
      width:320px;
      min-width:260px;
      background:var(--card);
      border-radius:12px;
      padding:16px;
      box-shadow:0 6px 20px rgba(20,30,50,0.06);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .title{font-size:18px;font-weight:700;}
    .muted{color:var(--muted);font-size:13px;}
    .controls{display:flex;flex-direction:column;gap:12px;}
    .row{display:flex;gap:12px;align-items:center;}
    button, input[type="number"]{
      font-size:14px;
      padding:8px 12px;
      border-radius:8px;
      border:1px solid #e6e9ef;
      background:white;
      color:var(--text);
    }
    button{cursor:pointer}
    button:focus, input:focus{outline:3px solid rgba(30,136,229,0.14)}
    .toggle{
      display:flex;
      gap:8px;
      align-items:center;
      background:#f3f6fb;
      padding:8px;
      border-radius:10px;
    }
    .toggle button{
      border-radius:8px;
      padding:8px 10px;
      background:transparent;
      border:none;
    }
    .toggle button.active{
      background:var(--accent);
      color:white;
      box-shadow:0 6px 14px rgba(30,136,229,0.14);
    }
    .small{font-size:13px;padding:6px 8px;}
    .actions{display:flex;gap:8px;flex-wrap:wrap;}
    .log{
      min-height:56px;
      background:#fafbfd;
      padding:10px;
      border-radius:8px;
      font-size:13px;
      color:var(--muted);
    }
    /* Right visualization */
    .vis{
      flex:1;
      min-width:360px;
      background:linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);
      border-radius:12px;
      padding:16px;
      box-shadow:0 10px 30px rgba(12,25,40,0.06);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .vis-head{display:flex;justify-content:space-between;align-items:center;gap:12px;}
    .vis-card{
      background:transparent;
      border-radius:10px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:320px;
    }
    .tree-area{
      position:relative;
      height:340px;
      background:linear-gradient(180deg, rgba(30,136,229,0.03), transparent 60%);
      border-radius:10px;
      overflow:hidden;
    }
    /* Nodes */
    .node{
      position:absolute;
      width:var(--node-size);
      height:var(--node-size);
      border-radius:50%;
      background:linear-gradient(180deg,#fff,#f7fbff);
      border:2px solid #e1eefb;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      color:var(--accent);
      box-shadow:0 6px 18px rgba(16,24,40,0.08);
      transition: transform 450ms cubic-bezier(.2,.9,.2,1), box-shadow 220ms;
      transform:translate(-50%,-50%);
      z-index:2;
      user-select:none;
    }
    .node.max{color:var(--accent-2); border-color:#fbe6d9;}
    .node.focus{box-shadow:0 10px 26px rgba(30,136,229,0.12); transform: translate(-50%,-50%) scale(1.05);}
    .node.compare{animation: pulse 700ms ease-in-out 1;}
    @keyframes pulse{
      0%{box-shadow:0 6px 18px rgba(30,136,229,0.08); transform:translate(-50%,-50%) scale(1.03)}
      50%{box-shadow:0 14px 36px rgba(30,136,229,0.14); transform:translate(-50%,-50%) scale(1.12)}
      100%{box-shadow:0 6px 18px rgba(30,136,229,0.08); transform:translate(-50%,-50%) scale(1.03)}
    }
    .connector{
      position:absolute;
      left:0;top:0;
      width:100%;height:100%;
      pointer-events:none;
    }
    /* array view */
    .array{
      display:flex;
      gap:12px;
      padding:12px;
      align-items:center;
      overflow:auto;
    }
    .array-box{
      min-width:64px;
      height:56px;
      background:white;
      border-radius:8px;
      border:1px solid #e7eef7;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:4px;
      padding:6px;
      text-align:center;
      transition: transform 400ms, box-shadow 200ms, background 220ms;
    }
    .array-box.index{font-size:12px;color:var(--muted);}
    .array-box.val{font-weight:700;color:var(--accent);}
    .array-box.focus{background:linear-gradient(90deg,#e8f1ff,#ffffff); box-shadow:0 8px 20px rgba(30,136,229,0.08); transform: translateY(-6px);}
    .array-box.compare{animation: pulse 700ms ease-in-out 1}
    .controls-bottom{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .status{
      font-size:13px;
      color:var(--muted);
      padding:6px 8px;
      border-radius:8px;
      background:#fbfdff;
    }
    /* responsive */
    @media (max-width:900px){
      main{flex-direction:column;padding:20px}
      .panel{width:100%}
    }
  </style>
</head>
<body>
  <main>
    <aside class="panel" aria-labelledby="title">
      <div>
        <div id="title" class="title">Heap (Min / Max) Interactive</div>
        <div class="muted">Explore array and tree representations, and step through build-heap.</div>
      </div>

      <div class="controls" aria-live="polite">
        <div>
          <div class="muted" style="margin-bottom:6px">Heap Mode</div>
          <div class="toggle" role="tablist" aria-label="Heap mode">
            <button id="minBtn" class="small active" role="tab" aria-pressed="true">Min-Heap</button>
            <button id="maxBtn" class="small" role="tab" aria-pressed="false">Max-Heap</button>
          </div>
        </div>

        <div>
          <div class="muted" style="margin-bottom:6px">Insert / Extract</div>
          <div class="row">
            <input id="valueInput" type="number" placeholder="value" aria-label="Value to insert">
            <button id="insertBtn" class="small">Insert</button>
            <button id="extractBtn" class="small">Extract Root</button>
          </div>
        </div>

        <div>
          <div class="muted" style="margin-bottom:6px">Array Utilities</div>
          <div class="row actions">
            <button id="randBtn" class="small">Randomize</button>
            <button id="buildBtn" class="small">Prepare Heapify</button>
            <button id="resetBtn" class="small">Reset Heapify</button>
            <button id="clearBtn" class="small">Clear</button>
          </div>
        </div>

        <div>
          <div class="muted" style="margin-bottom:6px">Playback</div>
          <div class="row actions">
            <button id="stepBtn" class="small">Step</button>
            <button id="playBtn" class="small">Play</button>
            <button id="pauseBtn" class="small">Pause</button>
          </div>
        </div>

        <div>
          <div class="muted" style="margin-bottom:6px">Status</div>
          <div id="actionLog" class="log" aria-live="polite">Ready. Insert some numbers or randomize.</div>
        </div>
      </div>

      <div style="margin-top:6px" class="muted">Tip: click an array box to highlight it. Use Play to auto-run recorded heapify actions.</div>
    </aside>

    <section class="vis" aria-label="Heap Visualization">
      <div class="vis-head">
        <div style="font-weight:700">Heap Visualizer</div>
        <div class="status" id="modeLabel">Mode: Min-Heap</div>
      </div>

      <div class="vis-card" role="region" aria-label="Visualization area">
        <div id="tree" class="tree-area" tabindex="0" aria-label="Heap tree visualization">
          <svg class="connector" id="connectorSvg" width="100%" height="100%" aria-hidden="true"></svg>
        </div>

        <div style="display:flex;align-items:center;justify-content:space-between">
          <div class="muted">Array (index: value)</div>
          <div class="muted">Click a box to focus</div>
        </div>

        <div id="array" class="array" aria-label="Heap array representation"></div>
      </div>
    </section>
  </main>

  <script>
    // Module state
    (function(){
      const MIN = 'min', MAX = 'max';
      let mode = MIN;
      let heap = []; // underlying array
      const tree = document.getElementById('tree');
      const arrayEl = document.getElementById('array');
      const connector = document.getElementById('connectorSvg');
      const actionLog = document.getElementById('actionLog');
      const modeLabel = document.getElementById('modeLabel');

      // playback state for heapify
      let actions = [];
      let actionIndex = 0;
      let playing = false;
      let playInterval = null;

      // controls
      const minBtn = document.getElementById('minBtn');
      const maxBtn = document.getElementById('maxBtn');
      const insertBtn = document.getElementById('insertBtn');
      const extractBtn = document.getElementById('extractBtn');
      const valueInput = document.getElementById('valueInput');
      const randBtn = document.getElementById('randBtn');
      const buildBtn = document.getElementById('buildBtn');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const resetBtn = document.getElementById('resetBtn');
      const clearBtn = document.getElementById('clearBtn');

      // visual layout math
      function computePositions(n){
        const rect = tree.getBoundingClientRect();
        const w = Math.max(320, rect.width - 40);
        const h = rect.height;
        const positions = [];
        for(let i=0;i<n;i++){
          const level = Math.floor(Math.log2(i+1));
          const levelStart = Math.pow(2, level) - 1;
          const posInLevel = i - levelStart;
          const nodesInLevel = Math.pow(2, level);
          const x = 20 + (posInLevel + 0.5) * ( (w - 40) / nodesInLevel );
          const vGap = Math.max(72, h / (Math.max(1, Math.floor(Math.log2(n+1))) + 2));
          const y = 20 + level * vGap;
          positions.push({x,y});
        }
        return positions;
      }

      // render functions
      function render(){
        renderTree();
        renderArray();
        modeLabel.textContent = 'Mode: ' + (mode === MIN ? 'Min-Heap' : 'Max-Heap');
      }

      function clearSvg(){
        while(connector.firstChild) connector.removeChild(connector.firstChild);
      }

      function renderTree(){
        const n = heap.length;
        const positions = computePositions(n);
        const existing = Array.from(tree.querySelectorAll('.node'));
        // ensure nodes exist for each index
        for(let i=0;i<n;i++){
          let node = tree.querySelector(`.node[data-idx="${i}"]`);
          if(!node){
            node = document.createElement('div');
            node.className = 'node';
            node.setAttribute('data-idx', i);
            node.setAttribute('role','button');
            node.setAttribute('tabindex','0');
            node.addEventListener('click', ()=>focusIndex(i));
            node.addEventListener('keydown', (e)=>{
              if(e.key === 'Enter' || e.key === ' ') focusIndex(i);
            });
            tree.appendChild(node);
          }
          // update classes and content
          node.textContent = String(heap[i]);
          node.classList.toggle('max', mode === MAX);
        }
        // remove extra nodes
        for(const ex of existing){
          const idx = Number(ex.getAttribute('data-idx'));
          if(idx >= n) ex.remove();
        }
        // position nodes and draw connectors
        clearSvg();
        for(let i=0;i<n;i++){
          const node = tree.querySelector(`.node[data-idx="${i}"]`);
          const pos = positions[i];
          node.style.left = pos.x + 'px';
          node.style.top = pos.y + 'px';
        }
        // draw connectors
        for(let i=1;i<n;i++){
          const parent = Math.floor((i-1)/2);
          const p = positions[parent];
          const c = positions[i];
          drawLine(p.x, p.y + 22, c.x, c.y - 22);
        }
      }

      function drawLine(x1,y1,x2,y2){
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke', '#dbeafc');
        line.setAttribute('stroke-width', '2');
        line.setAttribute('stroke-linecap','round');
        connector.appendChild(line);
      }

      function renderArray(){
        arrayEl.innerHTML = '';
        for(let i=0;i<heap.length;i++){
          const box = document.createElement('div');
          box.className = 'array-box';
          box.setAttribute('data-idx', i);
          box.setAttribute('tabindex','0');
          box.innerHTML = `<div class="index">i=${i}</div><div class="val">${heap[i]}</div>`;
          box.addEventListener('click', ()=>focusIndex(i));
          box.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter' || e.key === ' ') focusIndex(i);
          });
          arrayEl.appendChild(box);
        }
      }

      // focus / highlight
      let focusedIndex = null;
      function focusIndex(i){
        focusedIndex = i;
        // highlight array box and node
        tree.querySelectorAll('.node').forEach(n=>n.classList.toggle('focus', Number(n.getAttribute('data-idx'))===i));
        arrayEl.querySelectorAll('.array-box').forEach(b=>b.classList.toggle('focus', Number(b.getAttribute('data-idx'))===i));
        actionLog.textContent = `Focused index ${i} (value ${heap[i]}).`;
      }

      // low-level helpers for highlighting comparisons and swaps
      function highlightCompare(i,j){
        const ni = tree.querySelector(`.node[data-idx="${i}"]`);
        const nj = tree.querySelector(`.node[data-idx="${j}"]`);
        const bi = arrayEl.querySelector(`.array-box[data-idx="${i}"]`);
        const bj = arrayEl.querySelector(`.array-box[data-idx="${j}"]`);
        if(ni) ni.classList.add('compare');
        if(nj) nj.classList.add('compare');
        if(bi) bi.classList.add('compare');
        if(bj) bj.classList.add('compare');
        setTimeout(()=>{
          if(ni) ni.classList.remove('compare');
          if(nj) nj.classList.remove('compare');
          if(bi) bi.classList.remove('compare');
          if(bj) bj.classList.remove('compare');
        }, 700);
      }

      // swap animation: because nodes are absolutely positioned we can simply swap the data and re-render;
      // the CSS transform transition gives the movement effect.
      function animateSwap(i,j){
        // swap in array and tree by swapping values and re-rendering; transitions animate movement
        const ni = tree.querySelector(`.node[data-idx="${i}"]`);
        const nj = tree.querySelector(`.node[data-idx="${j}"]`);
        const bi = arrayEl.querySelector(`.array-box[data-idx="${i}"]`);
        const bj = arrayEl.querySelector(`.array-box[data-idx="${j}"]`);
        // visual hints
        if(ni) ni.classList.add('focus');
        if(nj) nj.classList.add('focus');
        if(bi) bi.classList.add('focus');
        if(bj) bj.classList.add('focus');

        // swap data
        const tmp = heap[i]; heap[i] = heap[j]; heap[j] = tmp;

        // refresh text content quickly so movement still looks consistent
        if(ni) ni.textContent = heap[i];
        if(nj) nj.textContent = heap[j];
        if(bi) bi.querySelector('.val').textContent = heap[i];
        if(bj) bj.querySelector('.val').textContent = heap[j];

        // re-render to reposition
        renderTree();
        renderArray();

        setTimeout(()=>{
          if(ni) ni.classList.remove('focus');
          if(nj) nj.classList.remove('focus');
          if(bi) bi.classList.remove('focus');
          if(bj) bj.classList.remove('focus');
        }, 500);
      }

      // heap operations used by controls (immediate)
      function compareVals(a,b){
        return mode === MIN ? (a - b) : (b - a);
      }

      function insertValue(v){
        heap.push(v);
        actionLog.textContent = `Insert ${v} â€” percolating up...`;
        render();
        percolateUp(heap.length - 1, true);
      }

      function percolateUp(i, withAnim=false){
        let idx = i;
        const doStep = ()=>{
          if(idx <= 0) {
            actionLog.textContent = 'Insert complete.';
            return;
          }
          const parent = Math.floor((idx - 1)/2);
          actionLog.textContent = `Compare index ${idx} (v=${heap[idx]}) with parent ${parent} (v=${heap[parent]})`;
          highlightCompare(idx,parent);
          if(compareVals(heap[idx], heap[parent]) < 0){
            // swap
            setTimeout(()=>{
              animateSwap(idx, parent);
              idx = parent;
              setTimeout(doStep, 460);
            }, 300);
          } else {
            setTimeout(()=>{ actionLog.textContent = 'Insert complete.' }, 300);
          }
        };
        doStep();
      }

      function extractRoot(){
        if(heap.length === 0){ actionLog.textContent = 'Heap is empty.'; return null; }
        const rootVal = heap[0];
        actionLog.textContent = `Extract ${rootVal}. Replacing root with last element and percolating down.`;
        // pop last to root
        const last = heap.pop();
        if(heap.length === 0){
          render();
          actionLog.textContent = `Extracted ${rootVal}. Heap is now empty.`;
          return rootVal;
        }
        heap[0] = last;
        render();
        // percolate down
        percolateDown(0, true);
        return rootVal;
      }

      function percolateDown(i, withAnim=false){
        let idx = i;
        const n = heap.length;
        const step = ()=>{
          const left = 2*idx + 1;
          const right = left + 1;
          let selected = idx;
          if(left < n){
            actionLog.textContent = `Compare index ${left} (v=${heap[left]}) with ${selected} (v=${heap[selected]})`;
            highlightCompare(left, selected);
            if(compareVals(heap[left], heap[selected]) < 0) selected = left;
          }
          if(right < n){
            actionLog.textContent = `Compare index ${right} (v=${heap[right]}) with ${selected} (v=${heap[selected]})`;
            highlightCompare(right, selected);
            if(compareVals(heap[right], heap[selected]) < 0) selected = right;
          }
          if(selected !== idx){
            setTimeout(()=>{
              animateSwap(selected, idx);
              idx = selected;
              setTimeout(step, 520);
            }, 300);
          } else {
            setTimeout(()=>{ actionLog.textContent = 'Percolate complete.'; }, 300);
          }
        };
        step();
      }

      // prepare heapify: generate action list to play
      function generateHeapifyActions(arr){
        // Simulate bottom-up heapify on a copy and record compare and swap actions
        const a = arr.slice();
        const ops = [];
        const n = a.length;
        function recordCompare(i,j){ ops.push({type:'compare', i, j}); }
        function recordSwap(i,j){ ops.push({type:'swap', i, j}); const tmp = a[i]; a[i]=a[j]; a[j]=tmp; }
        function percolateDownSim(i){
          let idx = i;
          while(true){
            const left = 2*idx + 1;
            const right = left + 1;
            let selected = idx;
            if(left < n){
              recordCompare(left, selected);
              if(compareVals(a[left], a[selected]) < 0) selected = left;
            }
            if(right < n){
              recordCompare(right, selected);
              if(compareVals(a[right], a[selected]) < 0) selected = right;
            }
            if(selected !== idx){
              recordSwap(selected, idx);
              idx = selected;
            } else break;
          }
        }
        for(let i=Math.floor((n-2)/2); i>=0; i--){
          percolateDownSim(i);
        }
        ops.push({type:'done'});
        return ops;
      }

      // playback handlers
      function prepareHeapify(){
        if(heap.length === 0){ actionLog.textContent = 'Heapify: array is empty.'; return; }
        actions = generateHeapifyActions(heap);
        actionIndex = 0;
        playing = false;
        clearInterval(playInterval);
        actionLog.textContent = `Heapify prepared with ${actions.length} action(s). Use Step or Play to run.`;
      }

      function resetHeapifyPlayback(){
        actions = [];
        actionIndex = 0;
        playing = false;
        clearInterval(playInterval);
        actionLog.textContent = 'Heapify playback reset.';
        render();
      }

      async function doStepAction(){
        if(actionIndex >= actions.length){
          actionLog.textContent = 'No more actions.';
          playing = false;
          clearInterval(playInterval);
          return;
        }
        const act = actions[actionIndex++];
        if(!act) return;
        if(act.type === 'compare'){
          actionLog.textContent = `Compare indices ${act.i} and ${act.j}`;
          highlightCompare(act.i, act.j);
        } else if(act.type === 'swap'){
          actionLog.textContent = `Swap indices ${act.i} and ${act.j}`;
          animateSwap(act.i, act.j);
        } else if(act.type === 'done'){
          actionLog.textContent = 'Heapify complete.';
        }
        // small delay to allow animations to show
      }

      function playActions(){
        if(actions.length === 0){ actionLog.textContent = 'No actions prepared; click "Prepare Heapify".'; return; }
        if(playing) return;
        playing = true;
        playInterval = setInterval(()=>{
          if(actionIndex >= actions.length){
            clearInterval(playInterval);
            playing = false;
            actionLog.textContent = 'Playback finished.';
            return;
          }
          doStepAction();
        }, 700);
        actionLog.textContent = 'Playing...';
      }

      function pauseActions(){
        if(playInterval) clearInterval(playInterval);
        playing = false;
        actionLog.textContent = 'Paused.';
      }

      // utilities
      function randomizeArray(){
        heap = [];
        const size = Math.floor(Math.random()*7) + 5;
        for(let i=0;i<size;i++) heap.push(Math.floor(Math.random()*90)+1);
        render();
        actionLog.textContent = 'Random array generated.';
      }

      function clearHeap(){
        heap = [];
        render();
        actionLog.textContent = 'Heap cleared.';
      }

      // event bindings
      minBtn.addEventListener('click', ()=>{
        mode = MIN;
        minBtn.classList.add('active');
        maxBtn.classList.remove('active');
        minBtn.setAttribute('aria-pressed','true');
        maxBtn.setAttribute('aria-pressed','false');
        render();
      });
      maxBtn.addEventListener('click', ()=>{
        mode = MAX;
        maxBtn.classList.add('active');
        minBtn.classList.remove('active');
        maxBtn.setAttribute('aria-pressed','true');
        minBtn.setAttribute('aria-pressed','false');
        render();
      });

      insertBtn.addEventListener('click', ()=>{
        const v = Number(valueInput.value);
        if(!Number.isFinite(v) || valueInput.value===''){ actionLog.textContent = 'Enter a numeric value to insert.'; return; }
        insertValue(v);
      });
      valueInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') insertBtn.click(); });

      extractBtn.addEventListener('click', ()=>{
        const res = extractRoot();
        if(res !== null) {
          actionLog.textContent = `Extracted ${res}.`;
        }
      });

      randBtn.addEventListener('click', randomizeArray);
      buildBtn.addEventListener('click', prepareHeapify);
      stepBtn.addEventListener('click', ()=>{ if(actions.length===0) prepareHeapify(); doStepAction(); });
      playBtn.addEventListener('click', ()=>{ if(actions.length===0) prepareHeapify(); playActions(); });
      pauseBtn.addEventListener('click', pauseActions);
      resetBtn.addEventListener('click', resetHeapifyPlayback);
      clearBtn.addEventListener('click', clearHeap);

      // initial content
      randomizeArray();

      // reflow listeners for responsive recalculation
      let resizeTimer = null;
      window.addEventListener('resize', ()=>{
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(()=>{ renderTree(); }, 200);
      });

      // initial render
      render();

      // Expose for debugging (optional)
      window._heapViz = {
        getHeap: ()=>heap.slice(),
        setMode: (m)=>{ mode = m; render(); }
      };
    })();
  </script>
</body>
</html>