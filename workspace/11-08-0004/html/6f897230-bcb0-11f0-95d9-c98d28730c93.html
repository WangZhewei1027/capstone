<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive: Longest Common Subsequence</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa7bf;
      --accent: #60a5fa;
      --accent-2: #34d399;
      --current: #f97316;
      --match: #10b981;
      --path: #a78bfa;
      --cell-border: rgba(255,255,255,0.06);
      --cell-bg: rgba(255,255,255,0.02);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071024 0%, #071226 60%);
      color: #e6eef8;
    }
    body{
      padding: var(--safe-padding);
      box-sizing: border-box;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      min-height:100vh;
    }
    header{
      display:flex;
      gap: var(--gap);
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .title{
      max-width: 65%;
      min-width: 260px;
    }
    h1{
      margin:0 0 8px 0;
      font-size:1.25rem;
      letter-spacing: -0.2px;
    }
    p.lead{
      margin:0;
      color: var(--muted);
      font-size:0.95rem;
    }
    .controls{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      padding: 14px;
      border-radius: 10px;
      min-width: 260px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      align-items:stretch;
    }
    label{
      display:flex;
      flex-direction:column;
      gap:8px;
      font-size:0.9rem;
      color:var(--muted);
    }
    input[type="text"]{
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background: rgba(0,0,0,0.25);
      color:inherit;
      outline:none;
      font-size:1rem;
    }
    .btnrow{
      display:flex;
      gap: var(--gap);
      flex-wrap:wrap;
    }
    button, .control-btn{
      background:var(--accent);
      color:#02264d;
      border:none;
      padding:10px 12px;
      border-radius:8px;
      font-weight:600;
      cursor:pointer;
      transition:transform .12s ease, box-shadow .12s;
      min-width:90px;
      text-align:center;
    }
    button.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
    }
    button:active{ transform: translateY(1px); }
    .play{ background: linear-gradient(90deg,var(--accent), #3b82f6); color:white; }
    .panel{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      width:100%;
      flex-wrap:wrap;
    }
    .visual{
      flex:1 1 560px;
      min-width:280px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border: 1px solid rgba(255,255,255,0.04);
      padding: var(--gap);
      border-radius:10px;
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      overflow:auto;
    }
    .grid-wrap{
      overflow:auto;
      flex:1 1 420px;
      min-width:200px;
    }
    .explain{
      width:320px;
      min-width:220px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .info{
      background:rgba(255,255,255,0.02);
      border-radius:8px;
      padding:12px;
      color:var(--muted);
      font-size:0.95rem;
    }
    .lcs-result{
      background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding: 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-start;
    }
    .res-box{
      min-height:40px;
      width:100%;
      background:var(--cell-bg);
      border-radius:6px;
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px;
      box-sizing:border-box;
      color:var(--accent-2);
      font-weight:700;
      font-size:1.1rem;
      overflow:auto;
    }
    /* Grid table styles */
    table.dp{
      border-collapse:collapse;
      font-family:monospace;
      min-width: 360px;
      background:transparent;
    }
    table.dp th, table.dp td{
      border:1px solid var(--cell-border);
      width:48px;
      height:48px;
      text-align:center;
      padding:0;
      vertical-align:middle;
      box-sizing:border-box;
      background:var(--cell-bg);
      color: #dbeafe;
      position:relative;
      transition: background-color .22s, transform .14s, box-shadow .12s;
      user-select:none;
    }
    table.dp th.char{
      background:transparent;
      color: var(--muted);
      font-size:0.95rem;
      height:44px;
    }
    .cell-val{
      font-weight:700;
      font-size:1rem;
      transition:opacity .18s;
      display:inline-block;
      min-width:18px;
    }
    .cell-current{
      box-shadow: 0 6px 18px rgba(249,115,22,0.12);
      transform: translateY(-4px);
      background: linear-gradient(180deg, rgba(249,115,22,0.10), rgba(249,115,22,0.04));
      border-color: rgba(249,115,22,0.22);
      color:#fff;
    }
    .header-compare{
      outline: 3px solid rgba(96,165,250,0.12);
      border-radius:6px;
      background: linear-gradient(180deg, rgba(96,165,250,0.02), transparent);
    }
    .match-col{
      background: linear-gradient(180deg, rgba(16,185,129,0.06), rgba(16,185,129,0.02));
      border-color: rgba(16,185,129,0.12);
      color: #dffaf0;
    }
    .cell-match{
      background: linear-gradient(180deg, rgba(16,185,129,0.10), rgba(16,185,129,0.02));
      border-color: rgba(16,185,129,0.14);
      box-shadow: 0 6px 18px rgba(16,185,129,0.06);
      color:#e6fff6;
    }
    .cell-path{
      background: linear-gradient(180deg, rgba(167,139,250,0.10), rgba(167,139,250,0.02));
      border-color: rgba(167,139,250,0.12);
      box-shadow: 0 8px 24px rgba(167,139,250,0.06);
      color:#f7efff;
    }
    .annot{
      font-size:0.85rem;
      color:var(--muted);
    }
    .small{
      font-size:0.88rem;
      color:var(--muted);
    }
    .floating-annotation{
      position: absolute;
      top:-34px;
      left:50%;
      transform:translateX(-50%);
      background: rgba(2,6,23,0.9);
      padding:6px 8px;
      border-radius:6px;
      color:var(--accent);
      font-size:0.82rem;
      border:1px solid rgba(96,165,250,0.12);
      white-space:nowrap;
      box-shadow: 0 8px 20px rgba(2,6,23,0.6);
      z-index:30;
      opacity:0;
      transition:opacity .12s;
      pointer-events:none;
    }
    .floating-annotation.show{ opacity:1; }
    /* responsive tweaks */
    @media (max-width:900px){
      .title{ max-width:100%; }
      .controls{ order:2; width:100%; }
      .visual{ flex-direction:column; }
      .explain{ width:100%; }
    }
    footer{
      color: var(--muted);
      font-size:0.9rem;
    }
    /* focus */
    button:focus, input:focus { outline: 2px solid rgba(96,165,250,0.18); outline-offset:2px; }
  </style>
</head>
<body>
  <header>
    <div class="title" aria-hidden="false">
      <h1>Interactive: Longest Common Subsequence (LCS)</h1>
      <p class="lead">Step through the dynamic programming table and backtrack to build the LCS. Use the controls to play, step, and visualize how each cell is computed.</p>
    </div>

    <div class="controls" role="region" aria-label="Controls">
      <label>
        String A (rows)
        <input id="strA" type="text" aria-label="String A" placeholder="e.g., ABCBDAB" value="ABCBDAB" maxlength="24" />
      </label>
      <label>
        String B (columns)
        <input id="strB" type="text" aria-label="String B" placeholder="e.g., BDCABA" value="BDCABA" maxlength="24" />
      </label>

      <div class="btnrow" role="group" aria-label="Actions">
        <button id="prepare" title="Build DP table from inputs">Compute & Prepare</button>
        <button id="play" class="play" title="Play or pause the table fill">Play</button>
        <button id="step" class="secondary" title="Step forward one computation">Step</button>
        <button id="backtrack" class="secondary" title="Animate backtracking to build LCS">Backtrack</button>
        <button id="reset" class="secondary" title="Reset the visualization">Reset</button>
      </div>

      <div style="display:flex; gap:12px; align-items:center; justify-content:space-between;">
        <label style="flex:1;">
          Speed
          <input id="speed" type="range" min="50" max="1000" value="300" />
        </label>
        <div style="min-width:120px; text-align:right;" class="small">Keys: Space=Play, →=Step</div>
      </div>
    </div>
  </header>

  <section class="panel" aria-live="polite">
    <div class="visual" role="region" aria-label="Visualization area">
      <div class="grid-wrap" id="gridWrap" tabindex="0" aria-label="DP table area">
        <!-- DP table will be injected here -->
        <div style="padding:24px; color:var(--muted)" id="placeholder">Click "Compute & Prepare" to build the DP table from the strings.</div>
      </div>

      <aside class="explain" aria-hidden="false">
        <div class="info">
          <div style="font-weight:700; color:#fff;">How it works</div>
          <div class="small">For each cell (i,j): if A[i-1] == B[j-1] then dp[i][j] = dp[i-1][j-1] + 1, else dp[i][j] = max(dp[i-1][j], dp[i][j-1]). Watch the table fill and backtrack to extract the LCS.</div>
        </div>

        <div class="lcs-result" aria-live="polite" aria-atomic="true">
          <div style="font-weight:700;">LCS Result</div>
          <div class="res-box" id="lcsBox" aria-label="Longest common subsequence"></div>
          <div class="small" id="status">Status: idle</div>
        </div>

      </aside>
    </div>
  </section>

  <footer>
    Tip: Use shorter strings (<= 16 chars) for clearer visualization. The grid is interactive via keyboard and touch.
  </footer>

  <script>
    (function(){
      // DOM references
      const strAInput = document.getElementById('strA');
      const strBInput = document.getElementById('strB');
      const prepareBtn = document.getElementById('prepare');
      const playBtn = document.getElementById('play');
      const stepBtn = document.getElementById('step');
      const backBtn = document.getElementById('backtrack');
      const resetBtn = document.getElementById('reset');
      const speedInput = document.getElementById('speed');
      const gridWrap = document.getElementById('gridWrap');
      const lcsBox = document.getElementById('lcsBox');
      const status = document.getElementById('status');

      let A = '', B = '';
      let m=0, n=0;
      let dp = [];
      let tableEl = null;
      let steps = []; // {i,j, reason, value}
      let stepIndex = -1;
      let playing = false;
      let playTimer = null;
      let backtrackPath = []; // coords for backtrack
      let inBacktrack = false;

      function resetState(){
        if(playTimer) { clearTimeout(playTimer); playTimer = null; }
        playing = false; inBacktrack = false;
        steps = []; stepIndex = -1; dp = [];
        backtrackPath = [];
        lcsBox.textContent = '';
        status.textContent = 'Status: idle';
        playBtn.textContent = 'Play';
        playBtn.classList.remove('secondary'); playBtn.classList.add('play');
      }

      function buildGrid(){
        A = (strAInput.value || '').trim();
        B = (strBInput.value || '').trim();
        if(A.length === 0 || B.length === 0){
          alert('Please enter both strings (non-empty).');
          return;
        }
        if(A.length > 22 || B.length > 22){
          if(!confirm('Long strings may be hard to visualize. Continue?')) return;
        }
        resetState();
        m = A.length; n = B.length;
        // initialize dp
        dp = new Array(m+1);
        for(let i=0;i<=m;i++){
          dp[i] = new Array(n+1).fill(0);
        }
        // build steps array
        steps = [];
        for(let i=1;i<=m;i++){
          for(let j=1;j<=n;j++){
            const equal = (A[i-1] === B[j-1]);
            const diag = dp[i-1][j-1];
            const top = dp[i-1][j];
            const left = dp[i][j-1];
            const val = equal ? diag + 1 : Math.max(top,left);
            dp[i][j] = val;
            const reason = equal ? 'diag+1' : (top >= left ? 'top' : 'left');
            steps.push({i,j, equal, diag, top, left, value: val, reason});
          }
        }
        // rebuild dp zeroed for visualization
        dp = new Array(m+1);
        for(let i=0;i<=m;i++) dp[i] = new Array(n+1).fill(0);

        // create grid element
        renderTable(A,B);
        status.textContent = `Ready: table built (${m} x ${n}). Use Play or Step to animate.`;
      }

      function renderTable(a,b){
        // create table markup
        const table = document.createElement('table');
        table.className = 'dp';
        table.setAttribute('role','grid');
        table.setAttribute('aria-label','DP table');
        // header row (empty top-left)
        const thead = document.createElement('thead');
        const hr = document.createElement('tr');
        hr.appendChild(document.createElement('th')); // top-left corner
        // add B header
        const placeholder = document.createElement('th'); placeholder.className = 'char'; placeholder.textContent = '';
        hr.appendChild(placeholder);
        for(let j=0;j<b.length;j++){
          const th = document.createElement('th');
          th.className = 'char';
          th.textContent = b[j];
          th.setAttribute('data-col', j+1);
          th.setAttribute('aria-label', `B character ${b[j]}`);
          hr.appendChild(th);
        }
        thead.appendChild(hr);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        for(let i=0;i<=a.length;i++){
          const tr = document.createElement('tr');
          // left header for a char (empty for i=0)
          const leftHeader = document.createElement('th');
          leftHeader.className = 'char';
          leftHeader.textContent = i===0 ? '' : a[i-1];
          leftHeader.setAttribute('data-row', i);
          leftHeader.setAttribute('aria-label', `A character ${leftHeader.textContent || ''}`);
          tr.appendChild(leftHeader);
          // cells
          for(let j=0;j<=b.length;j++){
            const td = document.createElement('td');
            td.setAttribute('data-i', i);
            td.setAttribute('data-j', j);
            const span = document.createElement('span');
            span.className = 'cell-val';
            span.textContent = '0';
            td.appendChild(span);

            // floating annotation placeholder
            const annot = document.createElement('div');
            annot.className = 'floating-annotation';
            annot.textContent = '';
            td.appendChild(annot);

            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
        table.appendChild(tbody);

        // replace content
        gridWrap.innerHTML = '';
        gridWrap.appendChild(table);
        tableEl = table;

        // keep dp initial zeros displayed
        updateAllCellValues();
      }

      function updateAllCellValues(){
        if(!tableEl) return;
        const cells = tableEl.querySelectorAll('td');
        cells.forEach(td=>{
          const i = parseInt(td.getAttribute('data-i'));
          const j = parseInt(td.getAttribute('data-j'));
          const span = td.querySelector('.cell-val');
          span.textContent = dp[i][j];
        });
      }

      // animation helpers
      function clearHighlights(){
        if(!tableEl) return;
        tableEl.querySelectorAll('td').forEach(td=>{
          td.classList.remove('cell-current','cell-match','cell-path');
          const annot = td.querySelector('.floating-annotation');
          if(annot) { annot.classList.remove('show'); annot.textContent = ''; }
        });
        tableEl.querySelectorAll('th.char').forEach(th=>{
          th.classList.remove('header-compare','match-col');
        });
      }

      function highlightCell(i,j,opts){
        if(!tableEl) return;
        clearHighlights();
        const td = tableEl.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
        if(!td) return;
        td.classList.add(opts && opts.match ? 'cell-match' : 'cell-current');
        const annot = td.querySelector('.floating-annotation');
        if(annot && opts && opts.text){
          annot.textContent = opts.text;
          annot.classList.add('show');
        }
        // highlight headers
        const rowHeader = tableEl.querySelector(`th[data-row="${i}"]`);
        const colHeader = tableEl.querySelector(`th[data-col="${j}"]`);
        if(rowHeader) rowHeader.classList.add('header-compare');
        if(colHeader) colHeader.classList.add('header-compare');
      }

      function fillStep(idx){
        if(idx < 0 || idx >= steps.length) return;
        const s = steps[idx];
        const {i,j,equal,diag,top,left,value,reason} = s;
        // update dp
        dp[i][j] = value;
        // animate highlight and update
        highlightCell(i,j, { match: equal, text: equal ? 'match → diag+1' : `max(top:${top}, left:${left})` });
        // update DOM value in cell
        const td = tableEl.querySelector(`td[data-i="${i}"][data-j="${j}"]`);
        const span = td.querySelector('.cell-val');
        // small delay for fade-in
        span.style.opacity = 0;
        setTimeout(()=>{ span.textContent = value; span.style.opacity = 1; }, 80);
      }

      function stepForward(){
        if(!tableEl) return;
        if(stepIndex < steps.length - 1){
          stepIndex++;
          fillStep(stepIndex);
          status.textContent = `Filling table: cell ${stepIndex+1}/${steps.length}`;
          if(stepIndex === steps.length - 1){
            status.textContent = 'Finished filling table. You can Backtrack to extract the LCS.';
          }
        } else {
          status.textContent = 'Already at the end of table fill.';
        }
      }

      function stepBackward(){
        if(!tableEl) return;
        if(stepIndex >= 0){
          // revert current step
          const s = steps[stepIndex];
          dp[s.i][s.j] = 0;
          const td = tableEl.querySelector(`td[data-i="${s.i}"][data-j="${s.j}"]`);
          if(td) td.querySelector('.cell-val').textContent = '0';
          stepIndex--;
          clearHighlights();
          status.textContent = `Stepped back. (${Math.max(0,stepIndex+1)}/${steps.length})`;
        }
      }

      function playLoop(){
        if(!playing) return;
        const delay = parseInt(speedInput.value,10);
        if(stepIndex < steps.length - 1){
          stepForward();
          playTimer = setTimeout(playLoop, delay);
        } else {
          playing = false;
          playBtn.textContent = 'Play';
          playBtn.classList.remove('secondary'); playBtn.classList.add('play');
          status.textContent = 'Finished filling table.';
        }
      }

      function togglePlay(){
        if(!tableEl){
          alert('Build the table first by clicking "Compute & Prepare".');
          return;
        }
        if(inBacktrack){
          // ignore play while backtracking
          return;
        }
        playing = !playing;
        if(playing){
          playBtn.textContent = 'Pause';
          playBtn.classList.remove('play'); playBtn.classList.add('secondary');
          status.textContent = 'Playing animation...';
          playLoop();
        } else {
          if(playTimer) { clearTimeout(playTimer); playTimer = null; }
          playBtn.textContent = 'Play';
          playBtn.classList.remove('secondary'); playBtn.classList.add('play');
          status.textContent = 'Paused';
        }
      }

      function animateBacktrack(){
        if(!tableEl) return;
        if(stepIndex < steps.length - 1){
          alert('Finish filling the table before backtracking (Play to end or Step until completion).');
          return;
        }
        if(inBacktrack) return;
        inBacktrack = true;
        lcsBox.textContent = '';
        status.textContent = 'Backtracking to build LCS...';
        // compute dp fully (we already have dp filled from steps)
        // perform standard backtracking from dp[m][n]
        let i = m, j = n;
        const path = [];
        const lcsChars = [];
        while(i > 0 && j > 0){
          path.push({i,j});
          if(A[i-1] === B[j-1]){
            lcsChars.push({i,j,char:A[i-1]});
            i--; j--;
          } else if(dp[i-1][j] >= dp[i][j-1]){
            i--;
          } else {
            j--;
          }
        }
        // animate the path (reverse so start bottom-right)
        let pIndex = 0;
        function animateStep(){
          if(pIndex >= path.length){
            // done, show LCS
            const lcs = lcsChars.map(x=>x.char).reverse().join('');
            lcsBox.textContent = lcs;
            // highlight matched header chars
            lcsChars.forEach(obj=>{
              const thRow = tableEl.querySelector(`th[data-row="${obj.i}"]`);
              const thCol = tableEl.querySelector(`th[data-col="${obj.j}"]`);
              if(thRow) thRow.classList.add('match-col');
              if(thCol) thCol.classList.add('match-col');
            });
            status.textContent = `Backtrack complete. LCS = "${lcs}"`;
            inBacktrack = false;
            return;
          }
          const coord = path[pIndex];
          // mark path cell
          clearHighlights();
          const td = tableEl.querySelector(`td[data-i="${coord.i}"][data-j="${coord.j}"]`);
          if(td){
            td.classList.add('cell-path');
            td.querySelector('.floating-annotation').textContent = '';
            // if this coord is a match (A[i-1] === B[j-1] and used in lcsChars), animate char
            const isMatch = A[coord.i-1] === B[coord.j-1] && dp[coord.i][coord.j] !== dp[coord.i-1][coord.j] && dp[coord.i][coord.j] !== dp[coord.i][coord.j-1];
            if(isMatch){
              td.classList.add('cell-match');
              const ch = A[coord.i-1];
              // append char into lcsBox after a moment (but building in reverse, so collect then show reversed at end)
              // give a small bounce animation
              const tmp = document.createElement('span');
              tmp.textContent = ch;
              tmp.style.transform = 'translateY(-6px)';
              tmp.style.opacity = '0';
              tmp.style.transition = 'transform .26s, opacity .26s';
              lcsBox.appendChild(tmp);
              setTimeout(()=>{ tmp.style.transform='translateY(0)'; tmp.style.opacity='1'; }, 30);
            }
          }
          pIndex++;
          setTimeout(animateStep, Math.max(120, parseInt(speedInput.value,10) / 2));
        }
        animateStep();
      }

      // Event listeners
      prepareBtn.addEventListener('click', ()=>{
        buildGrid();
      });
      stepBtn.addEventListener('click', ()=>{
        if(!tableEl){ alert('Please compute the table first.'); return; }
        if(inBacktrack) return;
        // if at end and not playing, keep as is
        stepForward();
      });
      playBtn.addEventListener('click', togglePlay);
      resetBtn.addEventListener('click', ()=>{
        gridWrap.innerHTML = '<div style="padding:24px; color:var(--muted)" id="placeholder">Click "Compute & Prepare" to build the DP table from the strings.</div>';
        resetState();
      });
      backBtn.addEventListener('click', ()=>{ animateBacktrack(); });

      // keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.code === 'Space'){ e.preventDefault(); togglePlay(); }
        if(e.code === 'ArrowRight'){ e.preventDefault(); stepForward(); }
        if(e.code === 'ArrowLeft'){ e.preventDefault(); stepBackward(); }
      });

      // make grid cells clickable to show explicit info about the cell
      gridWrap.addEventListener('click', (ev)=>{
        const td = ev.target.closest('td');
        if(!td || !tableEl) return;
        const i = parseInt(td.getAttribute('data-i'));
        const j = parseInt(td.getAttribute('data-j'));
        if(isNaN(i) || isNaN(j)) return;
        // show annotation
        const annot = td.querySelector('.floating-annotation');
        if(!annot) return;
        let text = `dp[${i}][${j}] = ${dp[i][j]}`;
        if(i>0 && j>0){
          text += ` (A=${A[i-1] || '-'}, B=${B[j-1] || '-'})`;
        }
        annot.textContent = text;
        annot.classList.add('show');
        setTimeout(()=>{ annot.classList.remove('show'); }, 1800);
      });

      // small helper to keep visual dp values in sync if user resizes
      window.addEventListener('resize', ()=>{ /* reserved for potential responsive updates */ });

      // initial auto-prepare
      document.addEventListener('DOMContentLoaded', ()=>{
        // buildGrid(); // intentionally not auto-build to let user confirm values
      });

    })();
  </script>
</body>
</html>