<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DFS Interactive Module</title>
  <style>
    :root{
      --safe-margin:24px;
      --gap:16px;
      --left-width:260px;
      --right-width:320px;
      --bg:#0f1720;
      --panel:#0b1220;
      --card:#0f1726;
      --muted:#9aa7b2;
      --accent:#ff9f1c;
      --discover:#ff9f1c;
      --finish:#1e90ff;
      --unvisited:#2a3440;
      --edge:#999;
      --edge-active:#ffb86b;
      --radius:8px;
    }
    html,body{height:100%; margin:0;}
    body{
      background:linear-gradient(180deg,#071021 0%, #071425 100%);
      color:#dbe9f3;
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
      padding:var(--safe-margin);
      box-sizing:border-box;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .container{
      display:flex;
      gap:var(--gap);
      height:calc(100% - (var(--safe-margin) * 2));
    }
    /* Left controls */
    .controls{
      width:var(--left-width);
      min-width:220px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
      border-radius:var(--radius);
      padding:16px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .title{
      font-weight:700;
      font-size:18px;
      margin-bottom:4px;
    }
    .subtitle{
      font-size:12px;
      color:var(--muted);
      margin-bottom:8px;
    }
    .modes{display:flex; flex-wrap:wrap; gap:8px;}
    .mode-btn{
      flex:1 1 auto;
      padding:8px 10px;
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      border-radius:8px;
      cursor:pointer;
      min-width:40px;
    }
    .mode-btn[aria-pressed="true"]{
      background:linear-gradient(90deg,#122635,#163043);
      color:#fff;
      border-color:rgba(255,255,255,0.08);
      box-shadow:0 2px 6px rgba(0,0,0,0.5);
    }
    .control-row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    button.btn{
      padding:8px 10px;
      background:linear-gradient(90deg,#132735,#15343e);
      color:#dff3ff;
      border:1px solid rgba(255,255,255,0.06);
      border-radius:8px;
      cursor:pointer;
    }
    button.btn.secondary{
      background:transparent;
      color:var(--muted);
    }
    .small{font-size:13px; padding:6px 8px;}
    .switch{display:flex; gap:8px; align-items:center;}
    label{font-size:13px; color:var(--muted);}
    input[type="range"]{width:120px;}
    select{background:transparent; border:1px solid rgba(255,255,255,0.05); color:var(--muted); padding:6px; border-radius:6px;}
    /* Canvas center */
    .canvas-area{
      flex:1;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02));
      border-radius:var(--radius);
      position:relative;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .canvas-header{
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,0.03);
      display:flex;
      align-items:center;
      gap:12px;
    }
    .canvas-title{font-weight:600; font-size:14px;}
    .canvas{flex:1; position:relative;}
    svg{width:100%; height:100%; display:block; cursor:crosshair;}
    /* Right info */
    .info{
      width:var(--right-width);
      min-width:260px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
      border-radius:var(--radius);
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow:auto;
    }
    .panel{background:linear-gradient(180deg,#071521,#071628); border-radius:8px; padding:10px; border:1px solid rgba(255,255,255,0.02);}
    .panel h4{margin:0 0 8px 0; font-size:13px;}
    .stack{
      min-height:80px;
      max-height:200px;
      overflow:auto;
      display:flex;
      flex-direction:column-reverse;
      gap:8px;
      padding:6px;
    }
    .stack-item{
      background:linear-gradient(90deg,#0e2a3a,#0b2634);
      padding:8px;
      border-radius:6px;
      color:#e6f8ff;
      display:flex;
      justify-content:space-between;
      align-items:center;
      transition:transform 240ms ease, opacity 240ms ease;
    }
    .stack-item.top{box-shadow:0 6px 18px rgba(0,0,0,0.6); transform:translateY(-4px);}
    .pseudocode{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,monospace; font-size:13px; color:var(--muted);}
    .pseudocode .line{padding:4px 6px; border-radius:6px; margin-bottom:6px;}
    .pseudocode .active{background:linear-gradient(90deg,#153445,#0e2b3a); color:#fff; font-weight:600;}
    .log{max-height:200px; overflow:auto; font-size:13px; color:var(--muted); background:transparent;}
    .muted{color:var(--muted); font-size:13px;}
    /* Node styles */
    .node { cursor:grab; }
    .node:active { cursor:grabbing; }
    text.nodelabel{pointer-events:none; font-size:12px; fill:#e6f8ff; font-weight:600; text-anchor:middle; dominant-baseline:central;}
    /* Edge styles */
    .edge{ stroke:var(--edge); stroke-width:2; fill:none; transition:stroke 200ms, stroke-width 200ms; }
    .edge.active{ stroke:var(--edge-active); stroke-width:4; }
    /* Responsive */
    @media (max-width:900px){
      .container{flex-direction:column;}
      .controls,.info{width:100%;}
    }
    /* Focus outlines */
    button:focus, select:focus, input:focus{outline:2px solid rgba(255,255,255,0.06); outline-offset:2px;}
    /* tiny helper */
    .hint{font-size:12px; color:var(--muted);}
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="DFS interactive module">
    <aside class="controls" aria-label="Controls">
      <div>
        <div class="title">Depth-First Search (DFS)</div>
        <div class="subtitle">Interactively build a graph, choose a start node, and step through DFS.</div>
      </div>

      <div class="modes" role="tablist" aria-label="Modes">
        <button id="mode-add" class="mode-btn" aria-pressed="true" title="Add nodes">Add Node</button>
        <button id="mode-connect" class="mode-btn" aria-pressed="false" title="Connect nodes">Connect</button>
        <button id="mode-drag" class="mode-btn" aria-pressed="false" title="Select / Drag">Select/Drag</button>
        <button id="mode-delete" class="mode-btn" aria-pressed="false" title="Delete nodes or edges">Delete</button>
      </div>

      <div class="control-row">
        <button id="btn-run" class="btn" title="Start DFS">Run DFS</button>
        <button id="btn-step" class="btn small" title="Step one action">Step</button>
        <button id="btn-back" class="btn small secondary" title="Undo last step">Back</button>
        <button id="btn-play" class="btn small" title="Play/Pause">Play</button>
      </div>

      <div class="control-row">
        <label class="switch"><input id="directed" type="checkbox" aria-label="Directed edges"> Directed</label>
        <label class="switch"><input id="auto-clear" type="checkbox" aria-label="Auto clear times"> Auto clear after run</label>
      </div>

      <div class="control-row">
        <label class="muted">Speed</label>
        <input id="speed" type="range" min="200" max="1600" step="100" value="800" aria-label="Animation speed">
        <div class="muted" id="speedLabel">800 ms</div>
      </div>

      <div class="control-row">
        <label class="muted">Start Node</label>
        <select id="startSelect" aria-label="Select start node">
          <option value="">(select node)</option>
        </select>
      </div>

      <div style="display:flex; gap:8px; margin-top:6px;">
        <button id="btn-reset-vis" class="btn small secondary" title="Reset visited states">Reset Visit</button>
        <button id="btn-clear" class="btn small secondary" title="Clear graph">Clear</button>
        <button id="btn-random" class="btn small" title="Generate random graph">Random Graph</button>
      </div>

      <div style="margin-top:8px;">
        <div class="hint">Tips: Add nodes, switch to Connect and click two nodes to add an edge. Drag nodes to arrange. Select a start node by clicking it in Select/Drag mode (or choose from the dropdown).</div>
      </div>
    </aside>

    <main class="canvas-area" aria-label="Graph canvas">
      <div class="canvas-header">
        <div class="canvas-title">Graph Canvas</div>
        <div class="muted" style="margin-left:auto;">Click canvas to add nodes</div>
      </div>
      <div class="canvas" id="canvasWrap">
        <svg id="svgCanvas" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Graph visualization">
          <defs>
            <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#999" />
            </marker>
            <marker id="arrowActive" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#ffb86b" />
            </marker>
          </defs>
          <!-- edges and nodes drawn here -->
        </svg>
      </div>
    </main>

    <aside class="info" aria-label="Information panels">
      <div class="panel">
        <h4>Stack (recursion / explicit stack)</h4>
        <div class="stack" id="stackView" aria-live="polite" aria-atomic="true">
          <!-- stack items -->
        </div>
      </div>

      <div class="panel">
        <h4>Pseudocode (highlights current action)</h4>
        <div class="pseudocode" id="pseudocode">
          <div class="line" data-line="1">DFS(v):</div>
          <div class="line" data-line="2">  mark v as discovered</div>
          <div class="line" data-line="3">  for each neighbor u of v:</div>
          <div class="line" data-line="4">    if u not discovered:</div>
          <div class="line" data-line="5">      DFS(u)</div>
          <div class="line" data-line="6">  mark v as finished</div>
        </div>
      </div>

      <div class="panel" style="flex:1;">
        <h4>Action Log</h4>
        <div class="log" id="log"></div>
      </div>
    </aside>
  </div>

  <script>
    // DFS Interactive Module - Vanilla JS
    (function(){
      // DOM references
      const modeAdd = document.getElementById('mode-add');
      const modeConnect = document.getElementById('mode-connect');
      const modeDrag = document.getElementById('mode-drag');
      const modeDelete = document.getElementById('mode-delete');
      const modes = [modeAdd, modeConnect, modeDrag, modeDelete];

      const svg = document.getElementById('svgCanvas');
      const startSelect = document.getElementById('startSelect');
      const btnRun = document.getElementById('btn-run');
      const btnStep = document.getElementById('btn-step');
      const btnBack = document.getElementById('btn-back');
      const btnPlay = document.getElementById('btn-play');
      const btnResetVis = document.getElementById('btn-reset-vis');
      const btnClear = document.getElementById('btn-clear');
      const btnRandom = document.getElementById('btn-random');
      const directedCheck = document.getElementById('directed');
      const speedInput = document.getElementById('speed');
      const speedLabel = document.getElementById('speedLabel');
      const autoClear = document.getElementById('auto-clear');

      const stackView = document.getElementById('stackView');
      const pseudocode = document.getElementById('pseudocode');
      const logEl = document.getElementById('log');

      // state
      let mode = 'add'; // 'add'|'connect'|'drag'|'delete'
      let nodes = []; // {id, x, y, visited:false, discovering:false, finished:false, dtime, ftime}
      let edges = []; // {id, a,b, directed}
      let nodeId = 1, edgeId = 1;
      let selectedNode = null; // for connect mode or start selection
      let dragging = null;
      let dragOffset = {x:0,y:0};
      let animTimer = null;
      let playing = false;
      let speed = parseInt(speedInput.value,10);
      let eventGenerator = null;
      let genIterator = null;
      let historySnapshots = []; // snapshots for back stepping
      // event history states for back
      let snapshots = [];

      // utility
      function pointInSvg(evt){
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX; pt.y = evt.clientY;
        const ctm = svg.getScreenCTM();
        return pt.matrixTransform(ctm.inverse());
      }
      function createEl(tag, attrs){
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for(const k in attrs) el.setAttribute(k, attrs[k]);
        return el;
      }
      function log(msg){
        const d = new Date().toLocaleTimeString();
        const row = document.createElement('div');
        row.textContent = `[${d}] ${msg}`;
        logEl.prepend(row);
      }
      function setMode(m){
        mode = m;
        modes.forEach(b => b.setAttribute('aria-pressed','false'));
        if(m==='add') modeAdd.setAttribute('aria-pressed','true');
        if(m==='connect') modeConnect.setAttribute('aria-pressed','true');
        if(m==='drag') modeDrag.setAttribute('aria-pressed','true');
        if(m==='delete') modeDelete.setAttribute('aria-pressed','true');
        // cursor
        svg.style.cursor = (m==='drag') ? 'grab' : 'crosshair';
      }
      // keep UI updated
      function refreshStartSelect(){
        startSelect.innerHTML = '<option value="">(select node)</option>';
        nodes.forEach(n=>{
          const opt = document.createElement('option');
          opt.value = n.id; opt.textContent = `Node ${n.id}`;
          startSelect.appendChild(opt);
        });
      }
      function clearSvg(){
        Array.from(svg.querySelectorAll('.edge, .node, .nodelabel, .edge-group')).forEach(el=>el.remove());
      }
      // rendering
      function render(){
        clearSvg();
        // draw edges first
        edges.forEach(e=>{
          const a = nodes.find(n=>n.id===e.a);
          const b = nodes.find(n=>n.id===e.b);
          if(!a || !b) return;
          const g = createEl('g', {class:'edge-group', 'data-id':e.id});
          const line = createEl('path', {class:'edge', d: computeEdgePath(a,b), 'stroke-width':2, 'data-id':e.id});
          if(e.active) line.classList.add('active');
          // markers
          if(e.directed){
            line.setAttribute('marker-end', e.active ? 'url(#arrowActive)' : 'url(#arrow)');
          }
          g.appendChild(line);
          // invisible thicker path for easier click
          const hit = createEl('path', {d: computeEdgePath(a,b), fill:'none', stroke:'transparent', 'stroke-width':12, 'data-hit':e.id});
          g.appendChild(hit);
          svg.appendChild(g);
        });
        // draw nodes
        nodes.forEach(n=>{
          const g = createEl('g', {class:'node', 'data-id':n.id, transform:`translate(${n.x},${n.y})`});
          // background circle
          const circle = createEl('circle', {r:20, cx:0, cy:0});
          let fill = 'var(--unvisited)';
          if(n.discovering) fill = 'var(--discover)';
          else if(n.finished) fill = 'var(--finish)';
          circle.setAttribute('fill', fill);
          circle.setAttribute('stroke', 'rgba(255,255,255,0.06)');
          circle.setAttribute('stroke-width', 1.5);
          circle.style.transition = 'fill 320ms, transform 180ms';
          g.appendChild(circle);
          // label
          const label = createEl('text', {class:'nodelabel'});
          label.textContent = n.id;
          g.appendChild(label);
          // times small text
          const t1 = createEl('text', {x:0, y:34, 'font-size':10, fill:'#9fb2c0', 'text-anchor':'middle'});
          t1.textContent = n.dtime ? `d:${n.dtime}` : '';
          g.appendChild(t1);
          const t2 = createEl('text', {x:0, y:46, 'font-size':10, fill:'#9fb2c0', 'text-anchor':'middle'});
          t2.textContent = n.ftime ? `f:${n.ftime}` : '';
          g.appendChild(t2);

          svg.appendChild(g);
        });
      }
      // approximate cubic path between centers (straight will do)
      function computeEdgePath(a,b){
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.hypot(dx,dy);
        if(dist===0) return `M ${a.x} ${a.y} L ${b.x} ${b.y}`;
        // offset endpoints by radius 20
        const ox = (dx / dist) * 22;
        const oy = (dy / dist) * 22;
        const sx = a.x + ox, sy = a.y + oy;
        const ex = b.x - ox, ey = b.y - oy;
        // slight curve
        const mx = (sx+ex)/2 + (dy*0.12);
        const my = (sy+ey)/2 - (dx*0.12);
        return `M ${sx} ${sy} Q ${mx} ${my} ${ex} ${ey}`;
      }

      // add node
      function addNode(x,y){
        const n = {id: nodeId++, x, y, visited:false, discovering:false, finished:false, dtime:null, ftime:null};
        nodes.push(n);
        render();
        refreshStartSelect();
        log(`Added node ${n.id}`);
        saveSnapshot();
        return n;
      }
      // add edge
      function addEdge(aId,bId, directed=false){
        if(aId===bId) return;
        // avoid duplicates
        if(edges.some(e=>e.a===aId && e.b===bId && e.directed===directed)) return;
        if(!directed){
          if(edges.some(e=> ((e.a===aId && e.b===bId) || (e.a===bId && e.b===aId)) && !e.directed )) return;
        }
        const e = {id: edgeId++, a:aId, b:bId, directed};
        edges.push(e);
        render();
        log(`Added edge ${aId} ${directed ? '→' : '—'} ${bId}`);
        saveSnapshot();
        return e;
      }
      // delete node and incident edges
      function deleteNode(id){
        nodes = nodes.filter(n=>n.id!==id);
        edges = edges.filter(e=>e.a!==id && e.b!==id);
        render(); refreshStartSelect();
        log(`Deleted node ${id}`);
        saveSnapshot();
      }
      function deleteEdge(id){
        edges = edges.filter(e=>e.id!==id);
        render();
        log(`Deleted edge ${id}`);
        saveSnapshot();
      }

      // simple random graph generator
      function makeRandomGraph(count=6, density=0.25){
        nodes = []; edges = []; nodeId = 1; edgeId = 1;
        for(let i=0;i<count;i++){
          const x = 200 + Math.random() * 800;
          const y = 120 + Math.random() * 560;
          addNode(x,y);
        }
        const nodeIds = nodes.map(n=>n.id);
        for(let i=0;i<nodeIds.length;i++){
          for(let j=i+1;j<nodeIds.length;j++){
            if(Math.random() < density){
              addEdge(nodeIds[i], nodeIds[j], directedCheck.checked && Math.random()>0.5);
            }
          }
        }
        render();
        log(`Generated random graph (${count} nodes)`);
        saveSnapshot();
      }

      // snapshotting for undo/back
      function saveSnapshot(){
        // deep clone necessary pieces (small arrays)
        const snap = {
          nodes: JSON.parse(JSON.stringify(nodes)),
          edges: JSON.parse(JSON.stringify(edges))
        };
        snapshots.push(snap);
        if(snapshots.length > 200) snapshots.shift();
      }
      function restoreSnapshot(){
        if(snapshots.length<=1) return; // keep at least initial
        snapshots.pop(); // drop current
        const prev = snapshots[snapshots.length-1];
        nodes = JSON.parse(JSON.stringify(prev.nodes));
        edges = JSON.parse(JSON.stringify(prev.edges));
        // need to update nodeId/edgeId
        nodeId = nodes.reduce((m,n)=>Math.max(m,n.id),0) + 1;
        edgeId = edges.reduce((m,e)=>Math.max(m,e.id),0) + 1;
        render(); refreshStartSelect();
      }

      // DFS event generator - yields atomic events and state copies for step/back
      function* dfsGenerator(startId){
        // prepare adjacency
        const adj = new Map();
        nodes.forEach(n=>adj.set(n.id, []));
        edges.forEach(e=>{
          adj.get(e.a).push({to:e.b, edgeId:e.id});
          if(!e.directed) adj.get(e.b).push({to:e.a, edgeId:e.id});
        });
        let time = 0;
        const visited = new Set();
        const stack = [];
        function* visit(v){
          time++; // discovery time
          visited.add(v);
          // mark discover event
          yield {type:'discover', node:v, time};
          stack.push(v);
          yield {type:'push', node:v};
          // iterate neighbors
          for(const nb of adj.get(v) || []){
            yield {type:'examine-edge', from:v, to:nb.to, edgeId:nb.edgeId};
            if(!visited.has(nb.to)){
              // recursive call
              yield* visit(nb.to);
            } else {
              yield {type:'skip', from:v, to:nb.to, edgeId:nb.edgeId};
            }
          }
          // finish
          time++;
          yield {type:'finish', node:v, time};
          stack.pop();
          yield {type:'pop', node:v};
        }
        yield {type:'start', start:startId};
        yield* visit(startId);
        yield {type:'end'};
      }

      // apply event to visual state and record snapshot
      function applyEvent(e){
        // before applying, save snapshot for undo
        saveSnapshot();
        if(e.type==='discover'){
          const n = nodes.find(x=>x.id===e.node);
          if(n){
            n.discovering = true;
            n.finished = false;
            n.dtime = e.time;
            n.visited = true;
            highlightPseudo(2);
            log(`Discover node ${n.id} (d=${n.dtime})`);
          }
        } else if(e.type==='push'){
          pushStackVis(e.node);
        } else if(e.type==='examine-edge'){
          // highlight edge momentarily
          edges.forEach(ed=>{ed.active=false;});
          const ed = edges.find(x=>x.id===e.edgeId);
          if(ed) ed.active = true;
          highlightPseudo(3);
          render();
          log(`Examine edge ${e.from} → ${e.to}`);
        } else if(e.type==='skip'){
          highlightPseudo(3);
          log(`Skip visited ${e.to}`);
        } else if(e.type==='finish'){
          const n = nodes.find(x=>x.id===e.node);
          if(n){
            n.discovering = false;
            n.finished = true;
            n.ftime = e.time;
            highlightPseudo(6);
            log(`Finish node ${n.id} (f=${n.ftime})`);
          }
        } else if(e.type==='pop'){
          popStackVis(e.node);
        } else if(e.type==='start'){
          highlightPseudo(1);
          log(`Start DFS from ${e.start}`);
        } else if(e.type==='end'){
          edges.forEach(ed=>ed.active=false);
          highlightPseudo(null);
          log('DFS complete');
        }
        render();
      }

      // stack view updates
      function pushStackVis(nid){
        const el = document.createElement('div');
        el.className = 'stack-item';
        el.dataset.id = nid;
        el.innerHTML = `<div>Node ${nid}</div><div style="opacity:0.8">push</div>`;
        stackView.prepend(el);
        // mark as top
        updateStackTop();
      }
      function popStackVis(nid){
        // find item with that id (top expected)
        const items = Array.from(stackView.children);
        // find first with dataset.id == nid
        const found = items.find(it => it.dataset.id == nid);
        if(found){
          found.style.opacity = '0';
          found.style.transform = 'translateX(20px)';
          setTimeout(()=>found.remove(), 260);
        }
        updateStackTop();
      }
      function updateStackTop(){
        Array.from(stackView.children).forEach((it,idx,arr)=>{
          it.classList.toggle('top', idx===arr.length-1);
        });
      }
      function clearStackView(){
        stackView.innerHTML = '';
      }

      // pseudocode highlighter
      function highlightPseudo(line){
        Array.from(pseudocode.querySelectorAll('.line')).forEach(el=>{
          el.classList.toggle('active', el.dataset.line == line);
        });
      }

      // stepping mechanism
      function startGenerator(start){
        eventGenerator = dfsGenerator(start);
        genIterator = eventGenerator;
      }
      function stepOnce(){
        if(!genIterator) return;
        const n = genIterator.next();
        if(n.done){
          playing = false; btnPlay.textContent = 'Play';
          return;
        }
        const ev = n.value;
        applyEvent(ev);
        // if end, stop auto
        if(ev.type === 'end'){
          playing = false; btnPlay.textContent = 'Play';
          if(autoClear.checked){
            setTimeout(()=>resetVisitTimes(), 600);
          }
        }
      }
      function playLoop(){
        if(playing){
          stepOnce();
          animTimer = setTimeout(playLoop, speed);
        }
      }
      function stopPlaying(){
        playing = false; if(animTimer) clearTimeout(animTimer);
        btnPlay.textContent = 'Play';
      }

      // Undo/back: restore previous snapshot if available
      function stepBack(){
        restoreSnapshot();
        // rebuild stack view and pseudocode/log may be stale; rebuild stack from nodes with visited but not finished
        rebuildStackFromNodes();
        // reset pseudocode highlight
        highlightPseudo(null);
      }
      function rebuildStackFromNodes(){
        clearStackView();
        // heuristic: nodes visited but not finished are on stack (in discovery order)
        const onStack = nodes.filter(n=>n.visited && !n.finished).sort((a,b)=> (a.dtime||0)-(b.dtime||0));
        onStack.forEach(n=> {
          const el = document.createElement('div');
          el.className = 'stack-item';
          el.dataset.id = n.id;
          el.innerHTML = `<div>Node ${n.id}</div><div style="opacity:0.8">...</div>`;
          stackView.prepend(el);
        });
        updateStackTop();
      }

      // reset visited states
      function resetVisitTimes(){
        nodes.forEach(n=>{
          n.visited=false; n.discovering=false; n.finished=false; n.dtime=null; n.ftime=null;
        });
        edges.forEach(e=>e.active=false);
        clearStackView();
        render();
        log('Reset visited/finish times');
        saveSnapshot();
      }

      // event wiring
      modeAdd.addEventListener('click', ()=>setMode('add'));
      modeConnect.addEventListener('click', ()=>setMode('connect'));
      modeDrag.addEventListener('click', ()=>setMode('drag'));
      modeDelete.addEventListener('click', ()=>setMode('delete'));

      svg.addEventListener('pointerdown', (ev)=>{
        const p = pointInSvg(ev);
        if(mode==='add'){
          addNode(p.x,p.y);
        } else if(mode==='connect' || mode==='delete' || mode==='drag'){
          // hit test nearest node
          const target = hitNodeAt(p.x,p.y);
          if(target){
            if(mode==='connect'){
              if(selectedNode==null){
                selectedNode = target.id;
                highlightNodeSelect(selectedNode);
              } else {
                addEdge(selectedNode, target.id, directedCheck.checked);
                unhighlightNodeSelect(selectedNode);
                selectedNode = null;
              }
            } else if(mode==='delete'){
              deleteNode(target.id);
            } else if(mode==='drag'){
              // begin dragging
              dragging = nodes.find(n=>n.id===target.id);
              dragOffset.x = p.x - dragging.x; dragOffset.y = p.y - dragging.y;
              svg.setPointerCapture(ev.pointerId);
            }
          } else {
            // maybe clicked an edge path
            if(mode==='delete'){
              const edgeHit = hitEdgeAt(p.x,p.y);
              if(edgeHit) deleteEdge(edgeHit.id);
            } else {
              // deselect
              if(mode==='connect' && selectedNode!=null){ unhighlightNodeSelect(selectedNode); selectedNode=null; }
            }
          }
        }
      });
      svg.addEventListener('pointermove', (ev)=>{
        if(dragging && mode==='drag'){
          const p = pointInSvg(ev);
          dragging.x = p.x - dragOffset.x;
          dragging.y = p.y - dragOffset.y;
          render();
        }
      });
      svg.addEventListener('pointerup', (ev)=>{
        if(dragging){
          dragging = null;
          svg.releasePointerCapture(ev.pointerId);
          saveSnapshot();
        }
      });

      function hitNodeAt(x,y){
        // simple radius 24
        return nodes.reduce((best,n)=>{
          const d = Math.hypot(n.x-x, n.y-y);
          if(d<=24) return n; return best;
        }, null);
      }
      function highlightNodeSelect(id){
        // add a ring by adding a circle element near node
        const g = svg.querySelector(`g.node[data-id='${id}']`);
        if(!g) return;
        let ring = g.querySelector('.select-ring');
        if(!ring){
          ring = createEl('circle', {class:'select-ring', r:26, cx:0, cy:0, fill:'none', stroke:'#4ee0c6', 'stroke-width':2});
          g.insertBefore(ring, g.firstChild);
        }
      }
      function unhighlightNodeSelect(id){
        const g = svg.querySelector(`g.node[data-id='${id}']`);
        if(!g) return;
        const ring = g.querySelector('.select-ring');
        if(ring) ring.remove();
      }
      function hitEdgeAt(x,y){
        // pick the first hit path element with data-hit
        const pathHits = Array.from(svg.querySelectorAll('path[data-hit]'));
        for(const p of pathHits){
          if(isPointOnPath(p, x, y)) {
            const id = parseInt(p.getAttribute('data-hit'),10);
            return edges.find(e=>e.id===id);
          }
        }
        return null;
      }
      function isPointOnPath(pathEl, x, y){
        // use SVG API
        try{
          const pt = svg.createSVGPoint(); pt.x = x; pt.y = y;
          const isOn = pathEl.isPointInStroke ? pathEl.isPointInStroke(pt) : false;
          return isOn;
        }catch(e){
          return false;
        }
      }

      // control buttons
      btnRun.addEventListener('click', ()=>{
        const startId = parseInt(startSelect.value,10);
        if(!startId){ alert('Choose a start node from the dropdown or click a node in Select/Drag mode.'); return; }
        // clear prior times if any
        nodes.forEach(n=>{ n.visited=false; n.discovering=false; n.finished=false; n.dtime=null; n.ftime=null; });
        clearStackView();
        render();
        startGenerator(startId);
        playing = true; btnPlay.textContent = 'Pause';
        playLoop();
        log(`Running DFS from ${startId}`);
      });
      btnStep.addEventListener('click', ()=>{ playing=false; btnPlay.textContent='Play'; stepOnce(); });
      btnBack.addEventListener('click', ()=>{ playing=false; btnPlay.textContent='Play'; stepBack(); });
      btnPlay.addEventListener('click', ()=>{
        if(!genIterator){ alert('Start a DFS first.'); return; }
        playing = !playing;
        btnPlay.textContent = playing ? 'Pause' : 'Play';
        if(playing) playLoop(); else if(animTimer) clearTimeout(animTimer);
      });
      btnResetVis.addEventListener('click', ()=>resetVisitTimes());
      btnClear.addEventListener('click', ()=>{
        nodes=[]; edges=[]; nodeId=1; edgeId=1; snapshots=[]; clearStackView(); render(); refreshStartSelect();
        log('Cleared graph');
      });
      btnRandom.addEventListener('click', ()=>{ makeRandomGraph(6,0.3); });

      speedInput.addEventListener('input', (e)=>{ speed = parseInt(e.target.value,10); speedLabel.textContent = `${speed} ms`; });

      startSelect.addEventListener('change', (e)=>{
        const id = parseInt(e.target.value,10);
        // highlight selected start
        Array.from(svg.querySelectorAll('.node')).forEach(g=>g.querySelector('.select-ring')?.remove());
        if(id){
          highlightNodeSelect(id);
        }
      });

      // initial small demo
      makeRandomGraph(5, 0.4);

      // Save initial snapshot
      saveSnapshot();

      // Accessibility: allow clicking a node in select mode to pick start
      svg.addEventListener('click', (ev)=>{
        const p = pointInSvg(ev);
        const target = hitNodeAt(p.x,p.y);
        if(target && mode==='drag'){
          // set start node
          startSelect.value = target.id;
          Array.from(svg.querySelectorAll('.node')).forEach(g=>g.querySelector('.select-ring')?.remove());
          highlightNodeSelect(target.id);
        }
      });

      // keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.key==='1') setMode('add');
        if(e.key==='2') setMode('connect');
        if(e.key==='3') setMode('drag');
        if(e.key==='4') setMode('delete');
        if(e.key===' ') { e.preventDefault(); btnPlay.click(); }
        if(e.key==='ArrowRight') btnStep.click();
        if(e.key==='ArrowLeft') btnBack.click();
      });

      // Cleanup active edge highlight periodically
      setInterval(()=>{ edges.forEach(ed=>{ if(ed.active) { /* leave for visual effect */ } }); }, 1000);

      // end IIFE
    })();
  </script>
</body>
</html>