<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive BST Explorer</title>
  <style>
    /* Safe area margins: 24px on all sides */
    html, body {
      height: 100%;
      margin: 0;
      padding: 24px;
      box-sizing: border-box;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: #f7fafc;
      color: #0f172a;
    }

    /* Layout root */
    .container {
      display: flex;
      flex-direction: column;
      height: calc(100% - 48px); /* account for padding top & bottom */
      gap: 16px; /* minimum spacing between blocks */
    }

    header {
      display: flex;
      align-items: flex-start;
      gap: 16px;
    }

    h1 {
      margin: 0;
      font-size: 20px;
      line-height: 1.1;
    }

    .subtitle {
      color: #475569;
      margin-top: 6px;
      font-size: 13px;
    }

    main {
      display: flex;
      flex: 1;
      gap: 16px; /* spacing between sidebar and canvas area */
      min-height: 0; /* allow children to shrink */
    }

    /* Sidebar controls */
    .sidebar {
      width: 320px;
      background: white;
      border-radius: 10px;
      padding: 16px;
      box-shadow: 0 6px 18px rgba(12, 23, 36, 0.06);
      display: flex;
      flex-direction: column;
      gap: 16px;
      min-height: 0;
      overflow: auto;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    label {
      font-size: 13px;
      color: #334155;
    }

    input[type="number"], input[type="text"], select {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      background: #fcfdff;
      font-size: 14px;
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    button {
      padding: 8px 12px;
      border-radius: 8px;
      border: none;
      background: #0ea5a4;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: background .15s ease;
      min-height: 40px;
    }

    button.secondary {
      background: #64748b;
    }

    button.warn {
      background: #ef4444;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Canvas area */
    .canvas-area {
      flex: 1;
      background: linear-gradient(180deg, rgba(14,165,164,0.03), rgba(14,165,164,0.01));
      border-radius: 10px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
      overflow: hidden;
    }

    .visual {
      flex: 1;
      background: white;
      border-radius: 8px;
      position: relative;
      overflow: auto;
      padding: 12px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.5);
    }

    /* SVG fills the available area */
    svg {
      width: 100%;
      height: 100%;
    }

    /* Node visuals */
    .node-group {
      cursor: default;
      transition: transform 450ms cubic-bezier(.22,.9,.28,1);
    }

    circle.node {
      fill: #f8fafc;
      stroke: #0f172a;
      stroke-width: 1.5px;
      r: 20;
      transition: fill .18s ease, stroke .18s ease, r .18s ease;
      box-shadow: 0 2px 6px rgba(2,6,23,0.08);
    }

    text.node-label {
      font-size: 13px;
      font-weight: 700;
      text-anchor: middle;
      alignment-baseline: middle;
      fill: #0f172a;
      pointer-events: none;
    }

    /* Edge style */
    line.edge {
      stroke: #94a3b8;
      stroke-width: 2;
      stroke-linecap: round;
      transition: stroke .15s ease;
    }

    /* Highlights and animations */
    .highlight {
      fill: #fffbeb !important;
      stroke: #f59e0b !important;
      stroke-width: 2.5px !important;
    }

    .visited {
      fill: #eef2ff !important;
      stroke: #6366f1 !important;
      stroke-width: 2.5px !important;
    }

    .found {
      fill: #dcfce7 !important;
      stroke: #16a34a !important;
      stroke-width: 2.5px !important;
    }

    .edge-highlight {
      stroke: #fb923c !important;
      stroke-width: 3.2px;
    }

    /* Controls area inside canvas */
    .toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .small {
      padding: 6px 10px;
      border-radius: 8px;
      background: #0f172a;
      color: white;
      border: none;
      cursor: pointer;
    }

    /* Info & pseudocode panel */
    .info {
      display: flex;
      gap: 12px;
    }

    .log {
      flex: 1;
      background: white;
      border-radius: 8px;
      padding: 12px;
      min-height: 140px;
      overflow: auto;
      font-size: 13px;
      color: #0f172a;
      box-shadow: 0 6px 18px rgba(12, 23, 36, 0.04);
    }

    .pseudocode {
      width: 320px;
      background: white;
      border-radius: 8px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size: 13px;
      color: #0f172a;
      box-shadow: 0 6px 18px rgba(12, 23, 36, 0.04);
      overflow: auto;
    }

    .line {
      padding: 6px 8px;
      border-radius: 6px;
    }

    .line.active {
      background: #fff7ed;
      border-left: 4px solid #fb923c;
    }

    footer {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }

    .meta {
      font-size: 13px;
      color: #475569;
    }

    /* Accessibility focus */
    button:focus, input:focus, select:focus {
      outline: 3px solid rgba(59,130,246,0.18);
      outline-offset: 2px;
    }

    /* Responsive */
    @media (max-width: 980px) {
      main {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        order: 2;
        max-height: 240px;
      }
      .pseudocode {
        width: 100%;
      }
      .info {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Binary Search Tree interactive module">
    <header>
      <div style="flex:1;">
        <h1>Binary Search Tree (BST) — Interactive Explorer</h1>
        <div class="subtitle">Visualize inserting, deleting, and searching; step through comparisons to learn how BST operations work.</div>
      </div>
      <div style="width: 360px; text-align: right;">
        <strong>Concept:</strong>
        <div>Binary Search Tree properties, insertion/search/delete paths, and traversal order.</div>
      </div>
    </header>

    <main>
      <!-- Sidebar controls and descriptive sections -->
      <aside class="sidebar" aria-label="Controls">
        <div class="control-group" aria-hidden="false">
          <label for="valueInput">Insert / Search / Delete value</label>
          <div class="row">
            <input id="valueInput" type="number" min="-99999" max="99999" aria-label="Value input" />
            <button id="insertBtn" title="Insert value">Insert</button>
            <button id="deleteBtn" class="secondary" title="Delete value">Delete</button>
            <button id="searchBtn" class="secondary" title="Search value">Search</button>
          </div>
        </div>

        <div class="control-group">
          <label>Quick actions</label>
          <div class="row">
            <button id="randomBtn">Randomize (7 values)</button>
            <button id="clearBtn" class="warn">Clear</button>
          </div>

          <div class="row" style="margin-top:8px;">
            <button id="undoBtn" class="secondary" title="Undo last mutation" disabled>Undo</button>
            <button id="redoBtn" class="secondary" title="Redo last undone" disabled>Redo</button>
          </div>
        </div>

        <div class="control-group">
          <label>Traversal animation</label>
          <div class="row">
            <select id="traversalType" aria-label="Traversal type">
              <option value="inorder">In-order</option>
              <option value="preorder">Pre-order</option>
              <option value="postorder">Post-order</option>
              <option value="level">Level-order</option>
            </select>
            <button id="traverseBtn">Animate</button>
            <button id="stepBtn" class="secondary">Step</button>
          </div>
        </div>

        <div class="control-group">
          <label>Animation speed</label>
          <div class="row">
            <input id="speedRange" type="range" min="200" max="1200" step="50" value="500" aria-label="Animation speed" />
            <div id="speedLabel" style="min-width:48px; text-align:right;">500 ms</div>
          </div>
        </div>

        <div style="font-size:13px; color:#475569;">
          <strong>Learning Objective</strong>
          <p style="margin:6px 0 0;">
            After interacting, you will be able to trace how BST maintains ordering, locate how insert/search/delete follow comparison paths,
            and observe traversal orders via step-by-step animations.
          </p>
        </div>
      </aside>

      <!-- Canvas and info -->
      <section class="canvas-area" aria-label="Visualization area">
        <div class="toolbar" role="toolbar" aria-label="Animation controls">
          <button id="playBtn" class="small" title="Play animation">Play</button>
          <button id="pauseBtn" class="small" title="Pause animation" disabled>Pause</button>
          <button id="nextBtn" class="small" title="Next step">Next</button>
          <button id="prevBtn" class="small" title="Previous step">Prev</button>

          <div style="margin-left:auto; font-size:13px; color:#475569;">
            Comparisons: <span id="comparisons">0</span>
          </div>
        </div>

        <div class="visual" id="visual" tabindex="0" aria-label="Binary Search Tree visual canvas">
          <svg id="svg" viewBox="0 0 1200 600" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Binary Search Tree drawing surface">
            <!-- Edges and nodes are inserted dynamically -->
            <g id="edges"></g>
            <g id="nodes"></g>
          </svg>
        </div>

        <div class="info">
          <div class="log" id="log" aria-live="polite" aria-atomic="true">
            <strong>Operation Log</strong>
            <div id="logContent" style="margin-top:8px;">Empty tree. Use the controls to insert values and watch animations.</div>
          </div>

          <div class="pseudocode" aria-hidden="false">
            <strong>Pseudocode (Insert)</strong>
            <pre style="margin-top:8px;">
<span id="line1" class="line">1. if root is null: root = newNode</span>
<span id="line2" class="line">2. cur = root</span>
<span id="line3" class="line">3. while true:</span>
<span id="line4" class="line">4. &nbsp;&nbsp;if value &lt; cur.value:</span>
<span id="line5" class="line">5. &nbsp;&nbsp;&nbsp;&nbsp;if cur.left is null: cur.left = newNode; break</span>
<span id="line6" class="line">6. &nbsp;&nbsp;&nbsp;&nbsp;else cur = cur.left</span>
<span id="line7" class="line">7. &nbsp;&nbsp;else if value &gt; cur.value:</span>
<span id="line8" class="line">8. &nbsp;&nbsp;&nbsp;&nbsp;if cur.right is null: cur.right = newNode; break</span>
<span id="line9" class="line">9. &nbsp;&nbsp;&nbsp;&nbsp;else cur = cur.right</span>
<span id="line10" class="line">10. else: duplicate - ignore/handle as defined</span>
            </pre>
          </div>
        </div>

      </section>
    </main>

    <footer>
      <div class="meta">
        Interaction Design: Click Insert/Delete/Search, then watch animated comparison path highlighting. Use traversal animation to step through node visitation order.
      </div>
      <div style="font-size:13px; color:#64748b;">BST Explorer — Vanilla JS • Accessible • Responsive</div>
    </footer>
  </div>

  <script>
    /*
      Interactive BST Explorer
      - Self-contained: vanilla HTML/CSS/JS
      - Features: insert, delete, search, traversal animations, step controls
      - Visual feedback: animated node movements, highlight path and edges, pseudocode line highlights, logs
    */

    (function () {
      /***********
       * Utilities
       ***********/
      function el(id) { return document.getElementById(id); }
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
      function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
      function makeId() { return 'n' + Math.random().toString(36).slice(2,9); }

      /****************
       * BST Data Model
       ****************/
      class BSTNode {
        constructor(value) {
          this.id = makeId();
          this.value = value;
          this.left = null;
          this.right = null;
        }
      }

      class BST {
        constructor() {
          this.root = null;
          this.history = []; // for undo/redo: store snapshots of root (deep clone)
          this.future = [];
        }

        snapshotPush() {
          // deep clone tree for undo
          const clone = (node) => {
            if (!node) return null;
            const c = new BSTNode(node.value);
            c.id = node.id; // preserve id so visualization persists
            c.left = clone(node.left);
            c.right = clone(node.right);
            return c;
          };
          this.history.push(clone(this.root));
          // limit history length
          if (this.history.length > 30) this.history.shift();
          this.future = [];
        }

        undo() {
          if (this.history.length === 0) return;
          const snapshot = this.history.pop();
          this.future.push(this.cloneRoot());
          this.root = snapshot;
        }

        redo() {
          if (this.future.length === 0) return;
          const snapshot = this.future.pop();
          this.history.push(this.cloneRoot());
          this.root = snapshot;
        }

        cloneRoot() {
          const clone = (node) => {
            if (!node) return null;
            const c = new BSTNode(node.value);
            c.id = node.id;
            c.left = clone(node.left);
            c.right = clone(node.right);
            return c;
          };
          return clone(this.root);
        }

        insert(value) {
          const steps = []; // record comparison path & events for animation
          if (this.root === null) {
            this.snapshotPush();
            const node = new BSTNode(value);
            this.root = node;
            steps.push({ type: 'insert-root', nodeId: node.id, value });
            return { created: node, steps };
          }
          let cur = this.root;
          while (true) {
            steps.push({ type: 'compare', nodeId: cur.id, value, nodeValue: cur.value });
            if (value === cur.value) {
              steps.push({ type: 'duplicate', nodeId: cur.id, value });
              return { created: null, steps }; // ignore duplicate
            }
            if (value < cur.value) {
              if (cur.left === null) {
                this.snapshotPush();
                cur.left = new BSTNode(value);
                steps.push({ type: 'insert', parentId: cur.id, nodeId: cur.left.id, value, direction: 'left' });
                return { created: cur.left, steps };
              } else {
                cur = cur.left;
              }
            } else {
              if (cur.right === null) {
                this.snapshotPush();
                cur.right = new BSTNode(value);
                steps.push({ type: 'insert', parentId: cur.id, nodeId: cur.right.id, value, direction: 'right' });
                return { created: cur.right, steps };
              } else {
                cur = cur.right;
              }
            }
          }
        }

        search(value) {
          const steps = [];
          let cur = this.root;
          while (cur !== null) {
            steps.push({ type: 'compare', nodeId: cur.id, nodeValue: cur.value, value });
            if (value === cur.value) {
              steps.push({ type: 'found', nodeId: cur.id });
              return { found: cur, steps };
            }
            cur = (value < cur.value) ? cur.left : cur.right;
          }
          steps.push({ type: 'notfound', value });
          return { found: null, steps };
        }

        delete(value) {
          // Returns steps that describe the deletion process
          const steps = [];
          // helper to find node and parent
          let parent = null;
          let cur = this.root;
          while (cur !== null && cur.value !== value) {
            steps.push({ type: 'compare', nodeId: cur.id, nodeValue: cur.value, value });
            parent = cur;
            cur = (value < cur.value) ? cur.left : cur.right;
          }
          if (cur === null) {
            steps.push({ type: 'notfound', value });
            return { removed: null, steps };
          }
          steps.push({ type: 'found', nodeId: cur.id, value });

          // push snapshot before mutating
          this.snapshotPush();

          // Three cases
          const removeNode = (parent, cur) => {
            if (!cur.left && !cur.right) {
              // leaf
              steps.push({ type: 'remove-leaf', nodeId: cur.id, parentId: parent ? parent.id : null });
              if (!parent) this.root = null;
              else if (parent.left === cur) parent.left = null;
              else parent.right = null;
              return;
            }
            if (!cur.left || !cur.right) {
              // one child
              steps.push({ type: 'remove-one-child', nodeId: cur.id, parentId: parent ? parent.id : null });
              const child = cur.left ? cur.left : cur.right;
              if (!parent) this.root = child;
              else if (parent.left === cur) parent.left = child;
              else parent.right = child;
              return;
            }
            // two children: replace with inorder successor (min in right subtree)
            steps.push({ type: 'remove-two-children', nodeId: cur.id });
            let succParent = cur;
            let succ = cur.right;
            while (succ.left) {
              steps.push({ type: 'compare', nodeId: succ.id, nodeValue: succ.value, note: 'succ-search' });
              succParent = succ;
              succ = succ.left;
            }
            steps.push({ type: 'successor-found', succId: succ.id, succValue: succ.value });
            // copy successor value to current node
            steps.push({ type: 'replace-value', nodeId: cur.id, newValue: succ.value });
            cur.value = succ.value; // mutate value for model
            // now delete successor (which has at most right child)
            if (succParent.left === succ) {
              succParent.left = succ.right;
            } else {
              succParent.right = succ.right;
            }
            steps.push({ type: 'remove-node', nodeId: succ.id, parentId: succParent.id });
          };

          removeNode(parent, cur);
          return { removed: cur, steps };
        }

        traverse(type = 'inorder') {
          const steps = [];
          if (!this.root) return steps;
          if (type === 'inorder') {
            (function inorder(node) {
              if (!node) return;
              inorder(node.left);
              steps.push({ type: 'visit', nodeId: node.id, value: node.value });
              inorder(node.right);
            })(this.root);
          } else if (type === 'preorder') {
            (function pre(node){
              if (!node) return;
              steps.push({ type: 'visit', nodeId: node.id, value: node.value });
              pre(node.left);
              pre(node.right);
            })(this.root);
          } else if (type === 'postorder') {
            (function post(node){
              if (!node) return;
              post(node.left);
              post(node.right);
              steps.push({ type: 'visit', nodeId: node.id, value: node.value });
            })(this.root);
          } else if (type === 'level') {
            const q = [];
            q.push(this.root);
            while (q.length) {
              const n = q.shift();
              steps.push({ type: 'visit', nodeId: n.id, value: n.value });
              if (n.left) q.push(n.left);
              if (n.right) q.push(n.right);
            }
          }
          return steps;
        }

        collectNodes() {
          const nodes = [];
          (function dfs(n, depth = 0) {
            if (!n) return;
            nodes.push({ id: n.id, value: n.value, depth });
            dfs(n.left, depth + 1);
            dfs(n.right, depth + 1);
          })(this.root);
          return nodes;
        }

        findParentAndNodeById(id) {
          let parent = null;
          let cur = this.root;
          while (cur) {
            if (cur.id === id) return { parent, node: cur };
            parent = cur;
            if (id < cur.id) { // this comparison by id is meaningless, so we search by value instead
              // fallback: do an exhaustive search (not used)
            }
            // We'll do a DFS to find by id
            break;
          }
          let found = null, foundParent = null;
          (function dfs(p, n) {
            if (!n) return;
            if (n.id === id) { found = n; foundParent = p; return; }
            dfs(n, n.left);
            if (found) return;
            dfs(n, n.right);
          })(null, this.root);
          return { parent: foundParent, node: found };
        }
      }

      /**************************
       * Visualization & Layout
       **************************/
      const svg = el('svg');
      const nodesGroup = el('nodes');
      const edgesGroup = el('edges');
      const logContent = el('logContent');
      const comparisonsEl = el('comparisons');
      const speedRange = el('speedRange');
      const speedLabel = el('speedLabel');

      const defaultWidth = 1200;
      const defaultHeight = 600;
      let viewportWidth = defaultWidth;
      let viewportHeight = defaultHeight;

      // visual parameters
      const NODE_R = 20;
      const V_PADDING = 70; // vertical spacing per depth
      const H_GAP = 36; // min horizontal gap between nodes

      function sizeViewport() {
        const rect = el('visual').getBoundingClientRect();
        // Keep the viewBox proportional
        viewportWidth = defaultWidth;
        viewportHeight = defaultHeight;
        svg.setAttribute('viewBox', `0 0 ${viewportWidth} ${viewportHeight}`);
      }

      window.addEventListener('resize', () => {
        sizeViewport();
        layoutAndRender();
      });

      sizeViewport();

      // map nodeId -> {x,y}
      let positions = {};

      function computeLayout(root) {
        // Simple layout: compute inorder x positions, depth -> y
        positions = {};
        let xCounter = 60; // left margin
        const levelXSpacing = 60;

        function dfs(node, depth) {
          if (!node) return;
          dfs(node.left, depth + 1);
          const x = xCounter;
          const y = 40 + depth * V_PADDING;
          positions[node.id] = { x, y, value: node.value };
          xCounter += H_GAP + Math.max(NODE_R * 2, String(node.value).length * 7);
          dfs(node.right, depth + 1);
        }
        dfs(root, 0);

        // If tree is narrow, center it
        const keys = Object.keys(positions);
        if (keys.length === 0) return;
        const minX = Math.min(...keys.map(k => positions[k].x));
        const maxX = Math.max(...keys.map(k => positions[k].x));
        const width = Math.max(600, maxX - minX + 160);
        // set view box horizontal scaling
        svg.setAttribute('viewBox', `0 0 ${Math.max(defaultWidth, width)} ${viewportHeight}`);
      }

      function clearSVG() {
        while (nodesGroup.firstChild) nodesGroup.removeChild(nodesGroup.firstChild);
        while (edgesGroup.firstChild) edgesGroup.removeChild(edgesGroup.firstChild);
      }

      function createNodeElement(node) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('class', 'node-group');
        g.setAttribute('data-id', node.id);
        g.setAttribute('transform', `translate(${positions[node.id].x}, ${positions[node.id].y})`);

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('class', 'node');
        circle.setAttribute('r', NODE_R);
        circle.setAttribute('cx', 0);
        circle.setAttribute('cy', 0);

        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('class', 'node-label');
        text.setAttribute('x', 0);
        text.setAttribute('y', 1);
        text.textContent = node.value;

        g.appendChild(circle);
        g.appendChild(text);

        // accessibility
        g.setAttribute('role', 'img');
        g.setAttribute('aria-label', 'node ' + node.value);

        // click to highlight node
        g.addEventListener('click', () => {
          log(`Clicked node ${node.value}`);
          highlightNode(node.id, 'visited', 700);
        });

        return g;
      }

      function createEdgeElement(parentId, childId) {
        const p = positions[parentId];
        const c = positions[childId];
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('class', 'edge');
        line.setAttribute('x1', p.x);
        line.setAttribute('y1', p.y + NODE_R);
        line.setAttribute('x2', c.x);
        line.setAttribute('y2', c.y - NODE_R);
        line.setAttribute('data-from', parentId);
        line.setAttribute('data-to', childId);
        return line;
      }

      function layoutAndRender() {
        computeLayout(tree.root);
        clearSVG();
        if (!tree.root) return;
        // draw edges first
        (function drawEdges(node) {
          if (!node) return;
          if (node.left) {
            const e = createEdgeElement(node.id, node.left.id);
            edgesGroup.appendChild(e);
            drawEdges(node.left);
          }
          if (node.right) {
            const e = createEdgeElement(node.id, node.right.id);
            edgesGroup.appendChild(e);
            drawEdges(node.right);
          }
        })(tree.root);

        // draw nodes
        (function drawNodes(node) {
          if (!node) return;
          const g = createNodeElement(node);
          nodesGroup.appendChild(g);
          drawNodes(node.left);
          drawNodes(node.right);
        })(tree.root);
      }

      function updatePositionsAnimated(duration = 450) {
        // Update the transform attribute of node groups; edges repositioned
        const nodeGroups = Array.from(nodesGroup.children);
        nodeGroups.forEach(g => {
          const id = g.getAttribute('data-id');
          const p = positions[id];
          if (!p) {
            // removed node: animate shrink then remove
            const circle = g.querySelector('circle.node');
            circle.style.transition = `r ${duration}ms ease, transform ${duration}ms ease`;
            circle.setAttribute('r', 0);
            setTimeout(() => { if (g.parentNode) g.parentNode.removeChild(g); }, duration + 50);
            return;
          }
          // set transition with CSS already established; update transform
          g.style.transition = `transform ${duration}ms cubic-bezier(.22,.9,.28,1)`;
          g.setAttribute('transform', `translate(${p.x}, ${p.y})`);
          // update label text if value changed
          const txt = g.querySelector('text.node-label');
          if (txt && p.value !== undefined) txt.textContent = p.value;
        });

        // edges: remove and re-create to avoid complex path morphing
        while (edgesGroup.firstChild) edgesGroup.removeChild(edgesGroup.firstChild);
        (function drawEdges(node) {
          if (!node) return;
          if (node.left) {
            const e = createEdgeElement(node.id, node.left.id);
            edgesGroup.appendChild(e);
            drawEdges(node.left);
          }
          if (node.right) {
            const e = createEdgeElement(node.id, node.right.id);
            edgesGroup.appendChild(e);
            drawEdges(node.right);
          }
        })(tree.root);
      }

      function findNodeGroupById(id) {
        return nodesGroup.querySelector('g[data-id="' + id + '"]');
      }

      function highlightNode(id, className, duration = 600) {
        const g = findNodeGroupById(id);
        if (!g) return;
        const circle = g.querySelector('circle.node');
        circle.classList.add(className);
        setTimeout(() => circle.classList.remove(className), duration);
      }

      function highlightEdge(fromId, toId, duration = 600) {
        const edge = edgesGroup.querySelector(`line[data-from="${fromId}"][data-to="${toId}"]`);
        if (!edge) return;
        edge.classList.add('edge-highlight');
        setTimeout(() => edge.classList.remove('edge-highlight'), duration);
      }

      function setPseudocodeLine(lineIndex) {
        // lines 1..10
        for (let i = 1; i <= 10; i++) {
          const elLine = el('line' + i);
          if (!elLine) continue;
          if (i === lineIndex) elLine.classList.add('active');
          else elLine.classList.remove('active');
        }
      }

      function log(msg, append = true) {
        const time = new Date().toLocaleTimeString();
        const entry = document.createElement('div');
        entry.style.marginTop = '6px';
        entry.textContent = `[${time}] ${msg}`;
        if (!append) logContent.innerHTML = '';
        logContent.appendChild(entry);
        logContent.parentElement.scrollTop = logContent.parentElement.scrollHeight;
      }

      /*********************
       * Animation Controller
       *********************/
      let stepQueue = []; // array of step objects for current operation
      let playing = false;
      let playInterval = null;
      let stepIndex = -1;
      let comparisonsCount = 0;

      function resetPlayback() {
        stepQueue = [];
        playing = false;
        if (playInterval) { clearInterval(playInterval); playInterval = null; }
        stepIndex = -1;
        el('playBtn').disabled = false;
        el('pauseBtn').disabled = true;
        el('nextBtn').disabled = false;
        el('prevBtn').disabled = false;
      }

      function preparePlayback(steps) {
        stepQueue = steps.slice();
        stepIndex = -1;
        comparisonsCount = 0;
        comparisonsEl.textContent = comparisonsCount;
        el('playBtn').disabled = false;
        el('pauseBtn').disabled = true;
      }

      async function play() {
        if (playing) return;
        playing = true;
        el('playBtn').disabled = true;
        el('pauseBtn').disabled = false;
        const delay = parseInt(speedRange.value, 10) || 500;
        while (playing && stepIndex < stepQueue.length - 1) {
          await nextStep();
          await sleep(delay);
        }
        playing = false;
        el('playBtn').disabled = false;
        el('pauseBtn').disabled = true;
      }

      function pause() {
        playing = false;
        el('playBtn').disabled = false;
        el('pauseBtn').disabled = true;
      }

      async function nextStep() {
        if (stepIndex >= stepQueue.length - 1) return;
        stepIndex++;
        const s = stepQueue[stepIndex];
        await handleStep(s, stepIndex);
      }

      async function prevStep() {
        // For simplicity, just re-run from start to stepIndex-1 (idempotent operations)
        if (stepIndex <= -1) return;
        stepIndex = -1;
        // re-render baseline before re-playing
        layoutAndRender();
        comparisonsCount = 0;
        comparisonsEl.textContent = comparisonsCount;
        // play up to previous index without delays
        for (let i = 0; i < Math.min(stepQueue.length, arguments[0] || (stepIndex)); i++) {
          const s = stepQueue[i];
          await handleStep(s, i, /*silent*/ true);
        }
      }

      async function handleStep(step, idx, silent = false) {
        // Implement various step types
        switch (step.type) {
          case 'compare':
            comparisonsCount++;
            comparisonsEl.textContent = comparisonsCount;
            if (!silent) {
              highlightNode(step.nodeId, 'highlight', 500);
              // pseudocode highlight heuristics
              setPseudocodeLine(3);
              log(`Compare: ${step.nodeValue} with ${step.value}`);
            }
            break;

          case 'insert-root':
            // create new node visual at root center then animate to position
            if (!silent) {
              // render tree first so positions exist
              layoutAndRender();
              updatePositionsAnimated();
              log(`Inserted root ${step.value}`);
              setPseudocodeLine(1);
            }
            break;

          case 'insert':
            if (!silent) {
              // new node already in data model; recompute positions, animate movement
              computeLayout(tree.root);
              // create the new node element starting at parent position
              const parentG = findNodeGroupById(step.parentId);
              let startX = 60, startY = 40;
              if (parentG) {
                const t = parentG.getAttribute('transform');
                const m = t.match(/translate\(([-\d\.]+),\s*([-\d\.]+)\)/);
                if (m) { startX = parseFloat(m[1]); startY = parseFloat(m[2]); }
              }
              // create a temporary g at parent's position and append then animate to final pos
              const tempG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
              tempG.setAttribute('transform', `translate(${startX}, ${startY})`);
              tempG.setAttribute('data-id', step.nodeId);
              tempG.setAttribute('class', 'node-group');
              const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
              circle.setAttribute('class', 'node');
              circle.setAttribute('r', NODE_R);
              const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
              text.setAttribute('class', 'node-label');
              text.setAttribute('x', 0);
              text.setAttribute('y', 1);
              text.textContent = step.value;
              tempG.appendChild(circle);
              tempG.appendChild(text);
              nodesGroup.appendChild(tempG);
              // add edge to parent
              const finalPos = positions[step.nodeId];
              const newEdge = document.createElementNS('http://www.w3.org/2000/svg', 'line');
              newEdge.setAttribute('class', 'edge');
              newEdge.setAttribute('data-from', step.parentId);
              newEdge.setAttribute('data-to', step.nodeId);
              // initially edge from parent to start position
              const ppos = positions[step.parentId] || { x: startX, y: startY };
              newEdge.setAttribute('x1', ppos.x);
              newEdge.setAttribute('y1', ppos.y + NODE_R);
              newEdge.setAttribute('x2', startX);
              newEdge.setAttribute('y2', startY);
              edgesGroup.appendChild(newEdge);

              // force browser to paint, then animate
              await sleep(20);
              tempG.style.transition = `transform ${parseInt(speedRange.value, 10)}ms cubic-bezier(.22,.9,.28,1)`;
              tempG.setAttribute('transform', `translate(${finalPos.x}, ${finalPos.y})`);
              // animate edge to final coordinates
              newEdge.style.transition = `all ${parseInt(speedRange.value, 10)}ms ease`;
              newEdge.setAttribute('x2', finalPos.x);
              newEdge.setAttribute('y2', finalPos.y - NODE_R);

              setPseudocodeLine(5);
              log(`Inserted ${step.value} as ${step.direction} child of node ${step.parentId}`, true);
              await sleep(parseInt(speedRange.value, 10) + 40);
              // switch temp into permanent node group (cleanup)
              tempG.setAttribute('data-id', step.nodeId);
              tempG.addEventListener('click', () => highlightNode(step.nodeId, 'visited', 700));
            }
            break;

          case 'duplicate':
            if (!silent) {
              log(`Duplicate value ${step.value} — insertion ignored`);
              setPseudocodeLine(10);
            }
            break;

          case 'found':
            if (!silent) {
              highlightNode(step.nodeId, 'found', 900);
              log(`Found node with value ${step.value}`);
            }
            break;

          case 'notfound':
            if (!silent) {
              log(`Value ${step.value} not found`);
            }
            break;

          case 'remove-leaf':
            if (!silent) {
              highlightNode(step.nodeId, 'highlight', 600);
              log(`Removing leaf node ${step.nodeId}`);
              // remove visual node (shrink)
              const g1 = findNodeGroupById(step.nodeId);
              if (g1) {
                const circle1 = g1.querySelector('circle.node');
                circle1.setAttribute('r', 0);
                setTimeout(() => { if (g1.parentNode) g1.parentNode.removeChild(g1); }, 600);
              }
              // remove associated edge
              const edge = edgesGroup.querySelector(`line[data-from="${step.parentId}"][data-to="${step.nodeId}"]`);
              if (edge) {
                edge.style.transition = `opacity 400ms ease`;
                edge.style.opacity = 0;
                setTimeout(() => { if (edge.parentNode) edge.parentNode.removeChild(edge); }, 450);
              }
            }
            break;

          case 'remove-one-child':
            if (!silent) {
              log('Removing node with single child; child is promoted.');
              // Just re-layout entire tree and animate
              computeLayout(tree.root);
              updatePositionsAnimated();
            }
            break;

          case 'remove-two-children':
            if (!silent) {
              log('Removing node with two children; will replace with successor.');
            }
            break;

          case 'successor-found':
            if (!silent) {
              log(`Successor found: ${step.succValue}`);
              highlightNode(step.succId, 'visited', 700);
            }
            break;

          case 'replace-value':
            if (!silent) {
              // highlight replaced node and update label
              const g2 = findNodeGroupById(step.nodeId);
              if (g2) {
                const txt = g2.querySelector('text.node-label');
                txt.textContent = step.newValue;
                highlightNode(step.nodeId, 'visited', 800);
              }
              computeLayout(tree.root);
              updatePositionsAnimated();
              log(`Replaced node value with successor ${step.newValue}`);
            }
            break;

          case 'remove-node':
            if (!silent) {
              // remove the successor node visually
              const g3 = findNodeGroupById(step.nodeId);
              if (g3) {
                const c = g3.querySelector('circle.node');
                c.setAttribute('r', 0);
                setTimeout(() => { if (g3.parentNode) g3.parentNode.removeChild(g3); }, 650);
              }
              // remove edge
              const e = edgesGroup.querySelector(`line[data-from="${step.parentId}"][data-to="${step.nodeId}"]`);
              if (e) {
                e.style.transition = 'opacity 420ms ease';
                e.style.opacity = 0;
                setTimeout(() => { if (e.parentNode) e.parentNode.removeChild(e); }, 450);
              }
              computeLayout(tree.root);
              updatePositionsAnimated();
              log('Removed successor node during deletion.');
            }
            break;

          case 'visit':
            if (!silent) {
              highlightNode(step.nodeId, 'visited', 500);
              log(`Visited node ${step.value} during traversal`);
            }
            break;

          default:
            if (!silent) log('Unknown step: ' + JSON.stringify(step));
            break;
        }
      }

      /********************
       * Wiring UI Controls
       ********************/
      const tree = new BST();

      function enableUndoRedoUI() {
        el('undoBtn').disabled = tree.history.length === 0;
        el('redoBtn').disabled = tree.future.length === 0;
      }

      // initial render
      layoutAndRender();

      // Insert button
      el('insertBtn').addEventListener('click', async () => {
        const v = parseInt(el('valueInput').value, 10);
        if (Number.isNaN(v)) { log('Enter a valid number to insert.'); return; }
        const result = tree.insert(v);
        if (result.steps.length === 0) {
          log('No action taken.');
          return;
        }
        preparePlayback(result.steps);
        // render initial tree (so we have parent nodes), then animate steps
        layoutAndRender();
        for (let i = 0; i < result.steps.length; i++) {
          await nextStep();
          await sleep( Math.max(80, parseInt(speedRange.value, 10) / 2) );
        }
        // after operation, update positions and clean up
        computeLayout(tree.root);
        updatePositionsAnimated();
        log(`Insert ${v} complete.`);
        enableUndoRedoUI();
      });

      // Search button
      el('searchBtn').addEventListener('click', async () => {
        const v = parseInt(el('valueInput').value, 10);
        if (Number.isNaN(v)) { log('Enter a valid number to search.'); return; }
        const res = tree.search(v);
        preparePlayback(res.steps);
        for (let i = 0; i < res.steps.length; i++) {
          await nextStep();
          await sleep(Math.max(80, parseInt(speedRange.value, 10) / 2));
        }
      });

      // Delete button
      el('deleteBtn').addEventListener('click', async () => {
        const v = parseInt(el('valueInput').value, 10);
        if (Number.isNaN(v)) { log('Enter a valid number to delete.'); return; }
        const res = tree.delete(v);
        preparePlayback(res.steps);
        // play steps
        for (let i = 0; i < res.steps.length; i++) {
          await nextStep();
          await sleep(Math.max(100, parseInt(speedRange.value, 10) / 2));
        }
        // final layout
        computeLayout(tree.root);
        updatePositionsAnimated();
        log(`Delete ${v} complete.`);
        enableUndoRedoUI();
      });

      // Randomize
      el('randomBtn').addEventListener('click', async () => {
        // generate 7 unique random small integers
        const values = [];
        while (values.length < 7) {
          const n = Math.floor(Math.random() * 41) - 20;
          if (!values.includes(n)) values.push(n);
        }
        // clear tree first
        tree.snapshotPush();
        tree.root = null;
        layoutAndRender();
        log('Randomizing values: ' + values.join(', '));
        for (let v of values) {
          const res = tree.insert(v);
          computeLayout(tree.root);
          updatePositionsAnimated();
          await sleep(120);
        }
        computeLayout(tree.root);
        updatePositionsAnimated();
        enableUndoRedoUI();
      });

      // Clear
      el('clearBtn').addEventListener('click', () => {
        tree.snapshotPush();
        tree.root = null;
        clearSVG();
        log('Cleared tree.');
        enableUndoRedoUI();
      });

      // Traversal
      el('traverseBtn').addEventListener('click', async () => {
        const type = el('traversalType').value;
        const steps = tree.traverse(type);
        if (!steps.length) { log('Tree is empty.'); return; }
        preparePlayback(steps);
        for (let i = 0; i < steps.length; i++) {
          await nextStep();
          await sleep(parseInt(speedRange.value, 10));
        }
        log(`${type} traversal complete.`);
      });

      // Step traversal (one-time step for current traversal selection)
      el('stepBtn').addEventListener('click', async () => {
        const type = el('traversalType').value;
        const steps = tree.traverse(type);
        if (!steps.length) { log('Tree is empty.'); return; }
        preparePlayback(steps);
        await nextStep();
      });

      // Playback controls
      el('playBtn').addEventListener('click', () => { play(); });
      el('pauseBtn').addEventListener('click', () => { pause(); });
      el('nextBtn').addEventListener('click', async () => { await nextStep(); });
      el('prevBtn').addEventListener('click', async () => { /* optional: implement rewind */ layoutAndRender(); });

      // Undo/Redo
      el('undoBtn').addEventListener('click', () => {
        if (tree.history.length === 0) return;
        tree.undo();
        computeLayout(tree.root);
        updatePositionsAnimated();
        log('Undo performed.');
        enableUndoRedoUI();
      });
      el('redoBtn').addEventListener('click', () => {
        if (tree.future.length === 0) return;
        tree.redo();
        computeLayout(tree.root);
        updatePositionsAnimated();
        log('Redo performed.');
        enableUndoRedoUI();
      });

      // Speed label and range
      speedRange.addEventListener('input', () => {
        speedLabel.textContent = speedRange.value + ' ms';
      });

      // keyboard enter to insert
      el('valueInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          el('insertBtn').click();
        }
      });

      // initial example seed
      (function seed() {
        const samples = [8, 3, 10, 1, 6, 14, 4, 7, 13];
        for (let v of samples) tree.insert(v);
        computeLayout(tree.root);
        layoutAndRender();
        log('Seeded tree with sample values: ' + samples.join(', '));
        enableUndoRedoUI();
      })();

      // Ensure accessibility: ARIA live region updates done via log. Focus outline visible by CSS.
    })();
  </script>
</body>
</html>