<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Divide and Conquer — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #3b82f6;
      --muted: #94a3b8;
      --success: #16a34a;
      --danger: #ef4444;
      --card: #071025;
      --glass: rgba(255,255,255,0.03);
      --radius: 10px;
      --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      font-family:var(--font-sans);
      background:linear-gradient(180deg,var(--bg),#051024 60%);
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      box-sizing:border-box;
      padding:var(--safe-margin);
    }
    *{box-sizing:inherit}

    /* Layout */
    .container{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:var(--gap);
      min-height: calc(100vh - calc(var(--safe-margin) * 2));
      align-items:start;
    }

    /* Responsive stack */
    @media (max-width:900px){
      .container{
        grid-template-columns: 1fr;
      }
    }

    .panel{
      background: linear-gradient(180deg,var(--panel),#061226);
      border-radius:var(--radius);
      padding:18px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      min-height: 160px;
    }

    /* Left column: textual content + controls */
    .left{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    h1{
      margin:0 0 6px 0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
      margin:0;
    }

    .objective, .design, .layout-desc{
      background:var(--card);
      border-radius:8px;
      padding:12px;
      font-size:14px;
      line-height:1.35;
      color:#dff1ff;
    }

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .row{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .row.space-between{
      justify-content:space-between;
    }

    label{
      font-size:13px;
      color:var(--muted);
    }
    input[type="range"]{
      width:100%;
    }
    input[type="text"]{
      background:transparent;
      color:inherit;
      border:1px solid rgba(255,255,255,0.06);
      padding:8px 10px;
      border-radius:8px;
      outline:none;
      min-width:0;
    }
    input[type="text"]:focus{box-shadow:0 0 0 3px rgba(59,130,246,0.12);border-color:rgba(59,130,246,0.6)}
    button{
      background:linear-gradient(180deg,var(--accent),#1b6fd6);
      color:white;
      border:0;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      min-width:44px;
      font-weight:600;
      transition:transform .08s ease;
    }
    button.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      font-weight:600;
    }
    button:active{transform:translateY(1px)}
    .controls .btn-row{display:flex; gap:8px; flex-wrap:wrap}

    /* Right: interactive stage */
    .stage{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .stage .visual{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:18px;
      min-height:360px;
      position:relative;
      overflow:hidden;
    }

    /* Array area */
    .array-area{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      height:120px;
      position:relative;
      margin-bottom:6px;
    }
    .bars{
      display:flex;
      align-items:flex-end;
      gap:6px;
      height:100%;
      transition:transform .6s ease;
      user-select:none;
    }
    .bar{
      width:28px;
      background:linear-gradient(180deg,#60a5fa,#2563eb);
      border-radius:6px 6px 3px 3px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:white;
      font-size:12px;
      padding-bottom:6px;
      box-shadow:0 3px 10px rgba(2,6,23,0.5);
      transform-origin:center bottom;
      transition:transform .4s cubic-bezier(.2,.9,.2,1), opacity .3s, box-shadow .2s;
    }
    .bar.small{width:22px}
    .bar .val{
      transform:translateY(2px);
      font-weight:700;
    }
    .bar.highlight{
      box-shadow:0 8px 26px rgba(59,130,246,0.32), 0 0 0 3px rgba(59,130,246,0.06);
      transform:translateY(-6px) scale(1.04);
    }
    .bar.compare{
      background:linear-gradient(180deg,#fb923c,#f97316);
      box-shadow:0 8px 26px rgba(249,115,22,0.24);
    }
    .bar.merged{
      background:linear-gradient(180deg,#34d399,#059669);
      box-shadow:0 8px 26px rgba(16,185,129,0.24);
    }

    /* recursion tree area */
    .tree-area{
      position:relative;
      height:220px;
      overflow:auto;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      border-radius:10px;
      padding:10px;
    }
    .node{
      position:absolute;
      display:flex;
      gap:6px;
      align-items:center;
      transition:transform .45s cubic-bezier(.2,.9,.2,1), opacity .3s;
      cursor:pointer;
      color:#dff1ff;
    }
    .node .mini-bar{
      width:18px;
      height:18px;
      background:linear-gradient(180deg,#60a5fa,#2563eb);
      border-radius:4px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:10px;
      font-weight:700;
      color:white;
      box-shadow:0 4px 10px rgba(2,6,23,0.5);
    }
    .node .label{
      font-size:12px;
      color:var(--muted);
      padding-left:8px;
    }
    .node.active .label{color:#dff1ff}
    .node.dim{opacity:.24; transform:scale(.95)}

    /* log area */
    .log{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:8px;
      padding:10px;
      font-size:13px;
      color:var(--muted);
      height:120px;
      overflow:auto;
      max-height:160px;
    }
    .log .entry{margin-bottom:8px}
    .log .entry strong{color:#eaf6ff}
    .hint{
      font-size:12px;
      color:var(--muted);
      margin-top:6px;
    }

    /* small helpers */
    .kbd{
      background:rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.03);
      padding:6px 8px;
      font-size:12px;
      border-radius:6px;
    }

    /* focus outlines for accessibility */
    button:focus, input:focus, .node:focus{
      outline: 3px solid rgba(59,130,246,0.14);
      outline-offset:2px;
    }

  </style>
</head>
<body>
  <div class="container" role="main">
    <!-- Left column: Title, objectives, controls, design & layout descriptions -->
    <div class="left">
      <div class="panel">
        <h1 id="title">Divide and Conquer — Interactive Exploration</h1>
        <p class="muted">Understand the strategy by watching a problem split into smaller subproblems, solved, and combined.</p>

        <div style="height:var(--gap)"></div>

        <div class="objective" aria-labelledby="objectiveTitle">
          <strong id="objectiveTitle">Learning Objective</strong>
          <p style="margin:8px 0 0 0">
            After interacting with this module you will be able to:
            <ul style="margin:8px 0 0 12px 18px">
              <li>Identify the three phases of divide-and-conquer: Divide, Conquer (solve subproblems), Combine.</li>
              <li>See how recursion decomposes a problem into a tree of subproblems and how solutions merge back.</li>
              <li>Observe the step-by-step operations and performance intuition (smaller subproblems, parallel structure).</li>
            </ul>
          </p>
        </div>

        <div style="height:var(--gap)"></div>

        <div class="controls" aria-label="Controls">
          <div class="row space-between">
            <label for="sizeRange">Array size</label>
            <span id="sizeLabel" class="muted">12</span>
          </div>
          <input id="sizeRange" type="range" min="2" max="32" value="12" aria-label="Array size slider" />

          <div class="row">
            <label for="seedInput">Custom array (comma separated) — optional</label>
          </div>
          <div class="row">
            <input id="seedInput" type="text" placeholder="e.g. 5,2,9,4,8" aria-label="Custom array input" />
            <button id="applyBtn" class="secondary" title="Apply custom array">Apply</button>
          </div>

          <div class="row btn-row">
            <button id="randomBtn">Randomize</button>
            <button id="runBtn" title="Play animation">Play</button>
            <button id="pauseBtn" class="secondary" title="Pause animation">Pause</button>
            <button id="stepBtn" class="secondary">Step</button>
            <button id="backBtn" class="secondary" title="Step backward">Back</button>
            <button id="resetBtn" class="secondary" title="Reset to original">Reset</button>
          </div>

          <div class="row">
            <span class="muted">Shortcuts: </span>
            <div style="display:flex;gap:8px;margin-left:8px">
              <span class="kbd">Space</span>
              <span class="kbd">→</span>
              <span class="kbd">←</span>
            </div>
          </div>

          <div style="height:var(--gap)"></div>

          <div class="design" aria-labelledby="interactionTitle">
            <strong id="interactionTitle">Interaction Design</strong>
            <p style="margin:8px 0 0 0">
              - Use the slider or the input to set the array you'll explore. Click "Randomize" for quick examples.
              <br>- Press "Play" to animate the divide-and-conquer process (split → conquer → merge). The visualization
              breaks the array into subarrays (visual nodes), highlights comparisons during merges, and animates
              the recombination into a sorted result.
              <br>- "Step" advances a single animation step (splitting or merging). "Back" reverses the previous step.
              <br>- Click any node in the recursion tree to focus that subproblem.
              <br>- Visual feedback includes color changes (compare/merged), lift/scale for active nodes, and smooth
              transitions showing movement and regrouping. Logs explain each action in plain language.
            </p>
          </div>

          <div class="layout-desc" aria-labelledby="layoutTitle">
            <strong id="layoutTitle">Layout Description</strong>
            <p style="margin:8px 0 0 0">
              - Spatial organization: Left column contains controls, objectives and descriptive panels. The right column
              contains the interactive stage: top shows the array bars and control status, below is a scrolling recursion
              tree visualization, and the bottom shows an action log.
              <br>- Safe area margins: 24px around the viewport. Elements maintain a minimum 16px gap.
              <br>- Accessibility: focus outlines, ARIA labels, keyboard shortcuts (Space = play/pause, ←/→ = back/step),
              and high-contrast visual states. The design is responsive: narrow screens stack columns and maintain
              readable sizes.
            </p>
          </div>

        </div>
      </div>
    </div>

    <!-- Right column: Interactive stage -->
    <div class="stage">
      <div class="panel visual" aria-live="polite">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div>
            <strong>Visualization</strong>
            <div class="hint">Observe how the problem splits into subproblems and then recombines.</div>
          </div>
          <div class="muted">Mode: <span id="modeLabel">Idle</span></div>
        </div>

        <div class="array-area" aria-hidden="false">
          <div id="barsContainer" class="bars" role="list" aria-label="Array visualization"></div>
        </div>

        <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px">
          <div style="flex:1">
            <label class="muted">Recursion tree (click a node to focus)</label>
            <div id="treeArea" class="tree-area" tabindex="0" aria-label="Recursion tree"></div>
          </div>
          <div style="width:300px">
            <label class="muted">Action log</label>
            <div id="log" class="log" aria-live="assertive"></div>
          </div>
        </div>
        <div class="hint">Tip: use the step controls to slow down and inspect comparisons.</div>
      </div>
    </div>
  </div>

  <script>
    // Divide and Conquer Interactive Module (vanilla JS)
    (function(){
      // Constants & DOM
      const sizeRange = document.getElementById('sizeRange');
      const sizeLabel = document.getElementById('sizeLabel');
      const seedInput = document.getElementById('seedInput');
      const applyBtn = document.getElementById('applyBtn');
      const randomBtn = document.getElementById('randomBtn');
      const runBtn = document.getElementById('runBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const stepBtn = document.getElementById('stepBtn');
      const backBtn = document.getElementById('backBtn');
      const resetBtn = document.getElementById('resetBtn');
      const barsContainer = document.getElementById('barsContainer');
      const treeArea = document.getElementById('treeArea');
      const logEl = document.getElementById('log');
      const modeLabel = document.getElementById('modeLabel');

      // State
      let array = [];
      let originalArray = [];
      let nodes = [];    // recursion nodes (tree)
      let actions = [];  // sequence of animation actions
      let actionIndex = -1;
      let playing = false;
      let animTimer = null;
      let nodeElements = {}; // nodeId -> DOM element

      // UI helpers
      function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

      function log(text, important=false){
        const entry = document.createElement('div');
        entry.className = 'entry';
        entry.innerHTML = important ? '<strong>' + text + '</strong>' : text;
        logEl.prepend(entry);
      }

      function setMode(text){
        modeLabel.textContent = text;
      }

      // Initialize with random array
      function generateRandom(size){
        const a = [];
        for(let i=0;i<size;i++) a.push(randInt(1,99));
        return a;
      }

      function buildArrayFromInput(str){
        const parts = str.split(',').map(s=>s.trim()).filter(s=>s!=='');
        if(parts.length===0) return null;
        const nums = parts.map(s=>Number(s)).filter(n=>!Number.isNaN(n));
        return nums.length>0 ? nums : null;
      }

      // Rendering bars
      function renderBars(arr){
        barsContainer.innerHTML = '';
        array = arr.slice();
        array.forEach((v,idx)=>{
          const b = document.createElement('div');
          b.className = 'bar';
          b.style.height = Math.max(18, Math.min(110, v*1.1)) + 'px';
          b.dataset.index = idx;
          b.setAttribute('role','listitem');
          const val = document.createElement('div');
          val.className='val';
          val.textContent = v;
          b.appendChild(val);
          barsContainer.appendChild(b);
        });
      }

      // Recursion tree node build (Merge Sort conceptual: split to halves)
      let nodeIdCounter = 0;
      function buildNodes(arr){
        nodes = [];
        nodeIdCounter = 0;
        function rec(l,r,depth,parentId=null){
          const id = 'n' + (nodeIdCounter++);
          const node = { id, l, r, depth, parentId, children:[] };
          nodes.push(node);
          if(l < r){
            const m = Math.floor((l + r) / 2);
            const leftId = rec(l, m, depth+1, id);
            const rightId = rec(m+1, r, depth+1, id);
            node.children.push(leftId, rightId);
          }
          return id;
        }
        if(arr.length>0) rec(0, arr.length-1, 0, null);
      }

      // Action recording for animation: We'll record split and merge actions
      function recordActionsForMergeSort(arr){
        actions = [];
        function rec(l,r){
          const id = {l,r};
          actions.push({ type:'focus', l, r, message:`Divide: consider indices [${l},${r}]` });
          if(l < r){
            const m = Math.floor((l + r) / 2);
            rec(l,m);
            rec(m+1,r);
            // merge action: simulate comparisons and placements
            const left = arr.slice(l, m+1);
            const right = arr.slice(m+1, r+1);
            let i=0,j=0,k=l;
            const compareSeq = [];
            while(i<left.length && j<right.length){
              compareSeq.push({ type:'compare', lIdx: l+i, rIdx: m+1+j });
              if(left[i] <= right[j]){
                compareSeq.push({ type:'place', index:k, value:left[i] });
                i++; k++;
              } else {
                compareSeq.push({ type:'place', index:k, value:right[j] });
                j++; k++;
              }
            }
            while(i<left.length){
              compareSeq.push({ type:'place', index:k, value:left[i] }); i++; k++;
            }
            while(j<right.length){
              compareSeq.push({ type:'place', index:k, value:right[j] }); j++; k++;
            }
            actions.push({ type:'merge', l, r, m, steps:compareSeq, message:`Merge [${l},${m}] and [${m+1},${r}]` });
          } else {
            actions.push({ type:'conquer', l, r, message:`Base case reached at index ${l}` });
          }
        }
        rec(0, arr.length-1);
      }

      // Render recursion tree nodes visually
      function renderTree(arr){
        treeArea.innerHTML = '';
        nodeElements = {};

        if(arr.length === 0) return;
        // Build a simple layout: position nodes by depth and by center index
        // We'll compute positions relative to treeArea size
        buildNodes(arr);
        const maxDepth = Math.max(...nodes.map(n=>n.depth));
        // compute centers
        function computeCenter(n){
          return (n.l + n.r) / 2;
        }
        const w = treeArea.clientWidth || 600;
        const h = treeArea.clientHeight || 200;
        const depthGap = Math.max(44, Math.floor((h - 40) / (maxDepth + 1)));
        const minX = 12;
        const maxX = w - 60;
        function xFromCenter(c){
          // map array center in [0, arr.length-1] to [minX,maxX]
          const maxIndex = Math.max(1, arr.length - 1);
          return minX + (c / maxIndex) * (maxX - minX);
        }
        nodes.forEach(n=>{
          const c = computeCenter(n);
          const x = xFromCenter(c);
          const y = 10 + n.depth * depthGap;
          const el = document.createElement('div');
          el.className = 'node';
          el.tabIndex = 0;
          el.style.left = x + 'px';
          el.style.top = y + 'px';
          el.dataset.l = n.l;
          el.dataset.r = n.r;
          el.innerHTML = '<div class="mini-bar">' + (n.r - n.l + 1) + '</div><div class="label">['+n.l+','+n.r+']</div>';
          el.title = 'Focus subarray ['+n.l+','+n.r+']';
          el.addEventListener('click', ()=>focusRange(n.l, n.r));
          el.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); focusRange(n.l, n.r); }
          });
          treeArea.appendChild(el);
          nodeElements[n.l + '-' + n.r] = el;
        });
      }

      // Focus a range in bars and highlight corresponding node
      function focusRange(l,r){
        // highlight bars
        const barEls = Array.from(barsContainer.children);
        barEls.forEach(b=>{
          const idx = Number(b.dataset.index);
          if(idx >= l && idx <= r){
            b.classList.add('highlight');
          } else {
            b.classList.remove('highlight');
          }
        });
        // highlight node
        Object.values(nodeElements).forEach(n=>n.classList.remove('active'));
        const el = nodeElements[l + '-' + r];
        if(el) el.classList.add('active');
        log(`Focused subproblem [${l},${r}]`, true);
      }

      // Apply an action step forward
      function stepForward(){
        if(actionIndex >= actions.length - 1){
          playing = false;
          setMode('Finished');
          return;
        }
        actionIndex++;
        const act = actions[actionIndex];
        executeAction(act, true);
      }

      // Step backward (simple undo for visual state): we will re-render from scratch up to current actionIndex-1
      function stepBackward(){
        if(actionIndex < 0) return;
        actionIndex--;
        // rebuild array and visual state from original, then replay all actions up to actionIndex
        renderBars(originalArray.slice());
        // clear highlights
        Array.from(barsContainer.children).forEach(b=>b.classList.remove('highlight','compare','merged'));
        // replay
        for(let i=0;i<=actionIndex;i++){
          executeAction(actions[i], false);
        }
      }

      // Execute an action; if animate==true, use animations/visual feedback
      function executeAction(action, animate){
        if(action.type === 'focus'){
          setMode('Divide');
          log(action.message);
          focusRange(action.l, action.r);
        } else if(action.type === 'conquer'){
          setMode('Conquer (base case)');
          log(action.message);
          focusRange(action.l, action.r);
          // mark single bar as merged (solved subproblem)
          const b = barsContainer.querySelector(`.bar[data-index="${action.l}"]`);
          if(b){
            b.classList.add('merged');
            b.classList.remove('highlight');
          }
        } else if(action.type === 'merge'){
          setMode('Combine (merge)');
          log(action.message);
          // animate comparisons and placements
          if(animate){
            // process steps with small intervals
            const steps = action.steps;
            let i = 0;
            function processNext(){
              if(i >= steps.length){
                // after merge, briefly highlight merged region
                highlightMerged(action.l, action.r);
                return;
              }
              const s = steps[i++];
              if(s.type === 'compare'){
                // highlight the two bars compared
                clearCompare();
                const leftBar = barsContainer.querySelector(`.bar[data-index="${s.lIdx}"]`);
                const rightBar = barsContainer.querySelector(`.bar[data-index="${s.rIdx}"]`);
                if(leftBar) leftBar.classList.add('compare');
                if(rightBar) rightBar.classList.add('compare');
                log(`Compare values at ${s.lIdx} and ${s.rIdx}`);
              } else if(s.type === 'place'){
                // place value at index -> update DOM value and height
                const target = barsContainer.querySelector(`.bar[data-index="${s.index}"]`);
                if(target){
                  target.querySelector('.val').textContent = s.value;
                  target.style.height = Math.max(18, Math.min(110, s.value*1.1)) + 'px';
                }
                clearCompare();
                log(`Place value ${s.value} at index ${s.index}`);
              }
              // schedule next
              animTimer = setTimeout(processNext, 420);
            }
            processNext();
          } else {
            // Non-animated (replay for backward/fast mode): just apply placements
            action.steps.forEach(s=>{
              if(s.type === 'place'){
                const t = barsContainer.querySelector(`.bar[data-index="${s.index}"]`);
                if(t){
                  t.querySelector('.val').textContent = s.value;
                  t.style.height = Math.max(18, Math.min(110, s.value*1.1)) + 'px';
                }
              }
            });
            highlightMerged(action.l, action.r);
          }
        }
      }

      function clearCompare(){
        Array.from(barsContainer.children).forEach(b=>{
          b.classList.remove('compare');
        });
      }

      function highlightMerged(l,r){
        Array.from(barsContainer.children).forEach(b=>{
          const idx = Number(b.dataset.index);
          if(idx >= l && idx <= r){
            b.classList.add('merged');
            b.classList.remove('highlight','compare');
          } else {
            b.classList.remove('merged');
          }
        });
        // highlight node briefly
        Object.values(nodeElements).forEach(n=>n.classList.remove('active'));
        const el = nodeElements[l + '-' + r];
        if(el){
          el.classList.add('active');
          setTimeout(()=>el.classList.remove('active'), 350);
        }
      }

      // Controls behavior
      sizeRange.addEventListener('input', (e)=>{
        sizeLabel.textContent = e.target.value;
      });

      applyBtn.addEventListener('click', ()=>{
        const parsed = buildArrayFromInput(seedInput.value || '');
        if(parsed && parsed.length >= 1){
          originalArray = parsed.slice();
          initializeFromOriginal();
        } else {
          alert('No valid numbers found in input. Provide comma-separated numbers like "5,2,9".');
        }
      });

      randomBtn.addEventListener('click', ()=>{
        const size = Number(sizeRange.value);
        originalArray = generateRandom(size);
        initializeFromOriginal();
      });

      runBtn.addEventListener('click', ()=>{
        if(playing) return;
        if(actions.length === 0) prepareActions();
        playing = true;
        setMode('Playing');
        playActions();
      });

      pauseBtn.addEventListener('click', ()=>{
        playing = false;
        setMode('Paused');
        if(animTimer) { clearTimeout(animTimer); animTimer = null; }
      });

      stepBtn.addEventListener('click', ()=>{
        if(actions.length === 0) prepareActions();
        playing = false;
        if(animTimer){ clearTimeout(animTimer); animTimer = null; }
        stepForward();
      });

      backBtn.addEventListener('click', ()=>{
        if(actions.length === 0) return;
        playing = false;
        if(animTimer){ clearTimeout(animTimer); animTimer = null; }
        stepBackward();
      });

      resetBtn.addEventListener('click', ()=>{
        playing = false;
        if(animTimer) clearTimeout(animTimer);
        actionIndex = -1;
        actions = [];
        renderBars(originalArray.slice());
        renderTree(originalArray);
        logEl.innerHTML = '';
        setMode('Idle');
        Array.from(barsContainer.children).forEach(b=>b.classList.remove('highlight','compare','merged'));
      });

      // Prepare actions from current originalArray
      function prepareActions(){
        actions = [];
        actionIndex = -1;
        logEl.innerHTML = '';
        renderTree(originalArray);
        recordActionsForMergeSort(originalArray.slice());
      }

      // Play loop
      function playActions(){
        if(!playing) return;
        if(actionIndex >= actions.length - 1){
          playing = false;
          setMode('Finished');
          return;
        }
        stepForward();
        // schedule next step depending on whether current action triggers internal timed steps (merge steps)
        const current = actions[actionIndex];
        let delay = 600;
        if(current && current.type === 'merge'){
          // schedule until the end of the merge (based on number of steps)
          delay = current.steps.length * 420 + 240;
        }
        animTimer = setTimeout(()=>{
          playActions();
        }, delay);
      }

      // Keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.key === ' '){
          e.preventDefault();
          if(playing){
            pauseBtn.click();
          } else {
            runBtn.click();
          }
        } else if(e.key === 'ArrowRight'){
          stepBtn.click();
        } else if(e.key === 'ArrowLeft'){
          backBtn.click();
        }
      });

      // Initialize from original array
      function initializeFromOriginal(){
        actions = [];
        actionIndex = -1;
        playing = false;
        if(animTimer) clearTimeout(animTimer);
        renderBars(originalArray.slice());
        renderTree(originalArray);
        logEl.innerHTML = '';
        setMode('Idle');
      }

      // On load: build initial random array
      function initialSetup(){
        const size = Number(sizeRange.value);
        sizeLabel.textContent = size;
        originalArray = generateRandom(size);
        initializeFromOriginal();
      }

      // Make tree area responsive to window resizing
      window.addEventListener('resize', ()=>{ renderTree(originalArray); });

      initialSetup();

      // Accessibility: reveal instructions in log
      log('Ready. Set an array and press Play to start the divide-and-conquer animation.', true);
      log('This demo demonstrates merge-style divide-and-conquer: the array is repeatedly divided, base cases solved, and subresults merged back together.');

    })();
  </script>
</body>
</html>