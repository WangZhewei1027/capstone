<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>K‑Means Clustering — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --panel-bg: #f7f9fc;
      --accent: #2b8be6;
      --muted: #6b7280;
      --white: #ffffff;
      --shadow: 0 6px 18px rgba(29,41,55,0.08);
      --ui-radius: 10px;
      --min-touch: 44px;
    }

    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      padding:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#fbfdff 0%, #f0f6ff 100%);
      color:#0f1724;
    }

    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    header{
      display:flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--gap);
      flex-wrap:wrap;
    }

    .title {
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .title h1{
      margin:0;
      font-size:20px;
      letter-spacing:-0.2px;
    }
    .subtitle{
      color:var(--muted);
      font-size:13px;
    }

    main.module {
      display:flex;
      gap:var(--gap);
      align-items:stretch;
      width:100%;
    }

    /* Sidebar controls */
    .sidebar{
      min-width:300px;
      max-width:360px;
      background:var(--panel-bg);
      border-radius:var(--ui-radius);
      box-shadow: var(--shadow);
      padding:20px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .section-title{
      font-weight:600;
      font-size:13px;
      margin:0;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
    }

    .controls {
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .row {
      display:flex;
      gap:12px;
      align-items:center;
    }

    label{
      font-size:13px;
    }

    input[type="range"]{
      width:100%;
    }

    input[type="number"]{
      width:70px;
      padding:8px;
      border-radius:8px;
      border:1px solid #e5e7eb;
      background:white;
      font-size:13px;
    }

    select, button {
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #e5e7eb;
      background:var(--white);
      font-size:13px;
      cursor:pointer;
    }

    .btn-primary{
      background:linear-gradient(180deg,var(--accent),#0e66d1);
      color:white;
      border:none;
      box-shadow: 0 6px 18px rgba(43,139,230,0.18);
    }

    .btn-ghost{
      background:transparent;
    }

    .small{
      font-size:12px;
      color:var(--muted);
    }

    .stats{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }
    .stat {
      background:white;
      padding:10px;
      border-radius:8px;
      min-width:90px;
      text-align:center;
      box-shadow: 0 3px 10px rgba(12,18,28,0.04);
    }
    .stat .label{font-size:12px;color:var(--muted)}
    .stat .value{font-weight:700;font-size:14px}

    /* Canvas pane */
    .canvas-pane{
      flex:1;
      min-height:480px;
      background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(250,250,255,0.85));
      border-radius:var(--ui-radius);
      box-shadow: var(--shadow);
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .viz-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:var(--gap);
    }
    .legend{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .legend-item{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }
    .color-swatch{
      width:16px;height:16px;border-radius:4px;border:1px solid rgba(0,0,0,0.06);
    }

    canvas{
      border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.85), rgba(245,249,255,0.85));
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
      cursor:crosshair;
    }

    /* Footer help text */
    .help{
      font-size:13px;
      color:var(--muted);
    }

    /* responsive */
    @media (max-width:900px){
      main.module{flex-direction:column;}
      .sidebar{max-width:none;width:100%;}
      .canvas-pane{min-height:360px;}
    }

    /* minimum spacing for touch targets */
    button, select, input[type="number"]{
      min-height: var(--min-touch);
    }

    /* small accessible focus */
    button:focus, select:focus, input:focus{
      outline:3px solid rgba(43,139,230,0.18);
      outline-offset:2px;
    }
  </style>
</head>
<body>
  <div class="app" role="main">
    <header>
      <div class="title" aria-hidden="false">
        <h1>K‑Means Clustering — Interactive Explorer</h1>
        <div class="subtitle">Visual, step-by-step, and hands-on — add points, move centroids, and watch K‑Means converge.</div>
      </div>
      <div class="muted">Tip: click the canvas to add points. Drag points or centroids to experiment.</div>
    </header>

    <main class="module" aria-live="polite">
      <!-- Sidebar: textual explanations and controls -->
      <aside class="sidebar" aria-labelledby="concept-title">
        <div>
          <h2 id="concept-title" class="section-title">Concept Title</h2>
          <p class="muted small">K‑Means Clustering: partition a set of points into K clusters by minimizing within-cluster variance (L2 distance).</p>
        </div>

        <div>
          <h3 class="section-title">Learning Objective</h3>
          <p class="small muted">Interactively understand how assignments and centroid updates drive convergence. Observe how different K, initialization, and point arrangements affect final clusters and inertia.</p>
        </div>

        <div>
          <h3 class="section-title">Interaction Design</h3>
          <p class="small muted">
            Click to add points. Drag points or centroids to change data. Choose K, initialize centroids (random or kmeans++), then Step to run one iteration or Run to animate until convergence. Visual animations show centroid movement and assignment changes.
          </p>
        </div>

        <div>
          <h3 class="section-title">Layout Description</h3>
          <p class="small muted">
            Left panel: controls, explanations, and stats. Right pane: interactive canvas with legend and runtime info. Safe margins are 24px; controls and elements keep at least 16px spacing. The layout is responsive and accessible.
          </p>
        </div>

        <div class="controls" aria-label="Controls">
          <div>
            <label for="kRange">K (clusters)</label>
            <div class="row" style="align-items:center">
              <input id="kRange" type="range" min="1" max="10" value="3" />
              <input id="kNumber" type="number" min="1" max="10" value="3" aria-label="Number of clusters" />
            </div>
          </div>

          <div>
            <label for="initSelect">Initialization</label>
            <select id="initSelect" aria-label="Initialization method">
              <option value="random">Random</option>
              <option value="kmeans++">KMeans++</option>
            </select>
          </div>

          <div class="row">
            <button id="initBtn">Initialize Centroids</button>
            <button class="btn-primary" id="stepBtn">Step</button>
            <button class="btn-primary" id="runBtn">Run</button>
          </div>

          <div class="row">
            <button id="addRandom">Add 20 Random</button>
            <button id="clearBtn" class="btn-ghost">Clear Points</button>
            <button id="resetBtn" class="btn-ghost">Reset</button>
          </div>

          <div class="row" style="align-items:center">
            <label for="speedRange" class="small">Speed</label>
            <input id="speedRange" type="range" min="100" max="1200" value="600" />
            <div class="small muted">ms per centroid move</div>
          </div>

          <div class="row" style="justify-content:space-between">
            <div class="small muted">Show</div>
            <div style="display:flex;gap:8px;">
              <label class="small"><input id="showLines" type="checkbox" checked /> assignment lines</label>
              <label class="small"><input id="showTrails" type="checkbox" /> centroid trails</label>
            </div>
          </div>

          <div class="stats" aria-hidden="false">
            <div class="stat">
              <div class="label">Iterations</div>
              <div id="iterCount" class="value">0</div>
            </div>
            <div class="stat">
              <div class="label">Inertia</div>
              <div id="inertiaVal" class="value">0</div>
            </div>
            <div class="stat">
              <div class="label">Points</div>
              <div id="pointCount" class="value">0</div>
            </div>
          </div>

          <div class="help small muted">
            Controls also support keyboard: Space = Run/Stop, → = Step, R = Reset. Click to add points. Drag points (yellow outline) or centroids (bold) to experiment.
          </div>
        </div>
      </aside>

      <!-- Visualization pane -->
      <section class="canvas-pane" aria-label="Kmeans visualization">
        <div class="viz-top">
          <div class="legend" id="legend" aria-hidden="true">
            <!-- dynamic color swatches -->
          </div>
          <div class="muted small">Click canvas to add points • Drag to move • Empty cluster will reinitialize</div>
        </div>

        <div style="flex:1; min-height:320px; display:flex; flex-direction:column;">
          <canvas id="vizCanvas" role="img" aria-label="Clustering canvas"></canvas>
        </div>
      </section>
    </main>
  </div>

  <script>
    /* K-Means interactive module
       - Canvas drawing uses normalized coordinates [0,1] for data points so resizing is responsive.
       - Points: {x,y,cluster,flashTime}
       - Centroids: {x,y,color,history:[]}
       - Animation of centroid movement via requestAnimationFrame tweening.
    */

    // Utility: colors
    const COLORS = [
      '#EF4444', '#F97316', '#F59E0B', '#EAB308', '#84CC16',
      '#10B981', '#06B6D4', '#3B82F6', '#6366F1', '#8B5CF6'
    ];

    // DOM elements
    const canvas = document.getElementById('vizCanvas');
    const ctx = canvas.getContext('2d');
    const kRange = document.getElementById('kRange');
    const kNumber = document.getElementById('kNumber');
    const initSelect = document.getElementById('initSelect');
    const initBtn = document.getElementById('initBtn');
    const stepBtn = document.getElementById('stepBtn');
    const runBtn = document.getElementById('runBtn');
    const addRandomBtn = document.getElementById('addRandom');
    const clearBtn = document.getElementById('clearBtn');
    const resetBtn = document.getElementById('resetBtn');
    const speedRange = document.getElementById('speedRange');
    const showLinesCb = document.getElementById('showLines');
    const showTrailsCb = document.getElementById('showTrails');

    const iterCountEl = document.getElementById('iterCount');
    const inertiaValEl = document.getElementById('inertiaVal');
    const pointCountEl = document.getElementById('pointCount');
    const legendEl = document.getElementById('legend');

    // State
    let points = []; // {x,y,cluster,flashUntil}
    let centroids = []; // {x,y,color,history:[]}
    let animation = { running:false, animating:false, requestId:null };
    let iter = 0;
    let lastAssignments = [];
    let inertia = 0;

    // Interaction state
    let dragging = null; // {type:'point'|'centroid', index}
    let dpr = Math.max(1, window.devicePixelRatio || 1);

    // Canvas sizing with normalized coords
    function resizeCanvas(){
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      draw(); // redraw immediately
    }
    window.addEventListener('resize', () => {
      resizeCanvas();
    });

    // Helpers coordinate convert
    function toPixel(pt){
      // pt: normalized {x,y} -> pixel coords in canvas CSS pixels
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      return { x: pt.x * w, y: pt.y * h };
    }
    function toNorm(px, py){
      const rect = canvas.getBoundingClientRect();
      const x = Math.max(0, Math.min(1, (px - rect.left) / rect.width));
      const y = Math.max(0, Math.min(1, (py - rect.top) / rect.height));
      return { x, y };
    }

    // Create legend items based on current K
    function updateLegend(){
      legendEl.innerHTML = '';
      const k = centroids.length;
      for (let i=0;i<k;i++){
        const item = document.createElement('div');
        item.className = 'legend-item';
        const sw = document.createElement('div');
        sw.className = 'color-swatch';
        sw.style.background = centroids[i].color;
        item.appendChild(sw);
        const label = document.createElement('div');
        label.textContent = 'Cluster ' + (i+1);
        item.appendChild(label);
        legendEl.appendChild(item);
      }
    }

    // Drawing
    function draw(){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);

      // background grid faint
      drawGrid();

      // assignment lines
      if (showLinesCb.checked && centroids.length>0) {
        ctx.globalAlpha = 0.15;
        points.forEach(p=>{
          if (p.cluster != null && centroids[p.cluster]){
            const pc = toPixel(p);
            const cc = toPixel(centroids[p.cluster]);
            ctx.beginPath();
            ctx.moveTo(pc.x, pc.y);
            ctx.lineTo(cc.x, cc.y);
            ctx.strokeStyle = centroids[p.cluster].color;
            ctx.lineWidth = 1.2;
            ctx.stroke();
          }
        });
        ctx.globalAlpha = 1.0;
      }

      // trails (centroid history)
      if (showTrailsCb.checked){
        centroids.forEach(c=>{
          if (c.history && c.history.length>1){
            ctx.beginPath();
            for (let i=0;i<c.history.length;i++){
              const hpt = {x:c.history[i].x, y:c.history[i].y};
              const p = toPixel(hpt);
              if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
            }
            ctx.strokeStyle = c.color;
            ctx.lineWidth = 2;
            ctx.setLineDash([6,6]);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        });
      }

      // points
      points.forEach((p, idx)=>{
        const pos = toPixel(p);
        const r = 6;
        // flash if assignment changed recently
        if (p.flashUntil && performance.now() < p.flashUntil){
          ctx.beginPath();
          ctx.arc(pos.x,pos.y,r+2,0,Math.PI*2);
          ctx.fillStyle = 'rgba(255,230,130,0.95)';
          ctx.fill();
        }
        ctx.beginPath();
        ctx.arc(pos.x,pos.y,r,0,Math.PI*2);
        const fill = (p.cluster!=null && centroids[p.cluster]) ? centroids[p.cluster].color : '#94a3b8';
        ctx.fillStyle = fill;
        ctx.fill();

        // stroke
        ctx.lineWidth = 1.6;
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.stroke();
      });

      // centroids
      centroids.forEach((c, i)=>{
        const p = toPixel(c);
        // marker
        ctx.beginPath();
        ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
        ctx.fillStyle = c.color;
        ctx.globalAlpha = 0.95;
        ctx.fill();
        ctx.globalAlpha = 1.0;

        // crosshair
        ctx.beginPath();
        ctx.moveTo(p.x-10, p.y);
        ctx.lineTo(p.x+10, p.y);
        ctx.moveTo(p.x, p.y-10);
        ctx.lineTo(p.x, p.y+10);
        ctx.lineWidth = 2.4;
        ctx.strokeStyle = '#fff';
        ctx.stroke();

        // outline
        ctx.beginPath();
        ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#0f1724';
        ctx.stroke();

        // label
        ctx.font = '12px Inter, Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.fillText('C' + (i+1), p.x, p.y+4);
      });
    }

    function drawGrid(){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.save();
      ctx.globalAlpha = 0.06;
      ctx.strokeStyle = '#0f1724';
      ctx.lineWidth = 1;
      const step = 50;
      for (let x=0;x<=w;x+=step){
        ctx.beginPath();
        ctx.moveTo(x,0);
        ctx.lineTo(x,h);
        ctx.stroke();
      }
      for (let y=0;y<=h;y+=step){
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(w,y);
        ctx.stroke();
      }
      ctx.restore();
    }

    // K-Means algorithm core
    function assignClusters(){
      let changed = 0;
      points.forEach((p, idx)=>{
        let best = null;
        let bestd = Infinity;
        centroids.forEach((c, ci)=>{
          const dx = (p.x - c.x);
          const dy = (p.y - c.y);
          const d2 = dx*dx + dy*dy;
          if (d2 < bestd){ best = ci; bestd = d2; }
        });
        const prev = p.cluster;
        p.cluster = best;
        if (prev !== best){
          changed++;
          p.flashUntil = performance.now() + 350; // flag for visual flash
        }
      });
      return changed;
    }

    function updateCentroids(){
      const k = centroids.length;
      const sums = Array.from({length:k}, () => ({x:0,y:0,n:0}));
      points.forEach(p=>{
        if (p.cluster != null && sums[p.cluster]){
          sums[p.cluster].x += p.x;
          sums[p.cluster].y += p.y;
          sums[p.cluster].n += 1;
        }
      });

      const moves = [];
      for (let i=0;i<k;i++){
        const s = sums[i];
        const c = centroids[i];
        const prev = {x:c.x, y:c.y};
        if (s.n === 0){
          // empty cluster: reinitialize to a random point (random within canvas)
          c.x = Math.random() * 0.98 + 0.01;
          c.y = Math.random() * 0.98 + 0.01;
        } else {
          c.x = s.x / s.n;
          c.y = s.y / s.n;
        }
        // store move for animation
        moves.push({i, from:prev, to:{x:c.x,y:c.y}});
        // record history
        c.history = c.history || [];
        c.history.push({x:c.x, y:c.y});
        if (c.history.length>20) c.history.shift();
      }
      return moves;
    }

    function computeInertia(){
      let sum=0;
      points.forEach(p=>{
        if (p.cluster != null && centroids[p.cluster]){
          const dx = p.x - centroids[p.cluster].x;
          const dy = p.y - centroids[p.cluster].y;
          sum += (dx*dx + dy*dy);
        }
      });
      // scale to pixel^2 approximate for readability
      const scale = Math.min(canvas.clientWidth, canvas.clientHeight);
      inertia = Math.round(sum * scale * scale * 100) / 100;
      inertiaValEl.textContent = inertia;
    }

    // Initialize centroids either random or kmeans++
    function initCentroids(method='random'){
      const k = +kNumber.value;
      centroids = [];
      const usedColors = COLORS.slice(0,k);
      if (method === 'kmeans++' && points.length>0){
        // kmeans++ initialization on normalized points
        // pick first centroid uniformly at random
        const first = points[Math.floor(Math.random()*points.length)];
        centroids.push({x:first.x, y:first.y, color:usedColors[0], history:[{x:first.x,y:first.y}]});
        while (centroids.length < k){
          // compute distance squared to nearest existing centroid
          const d2 = points.map(p=>{
            let best = Infinity;
            centroids.forEach(c=>{
              const dx = p.x - c.x;
              const dy = p.y - c.y;
              const dd = dx*dx + dy*dy;
              if (dd < best) best = dd;
            });
            return best;
          });
          // choose new centroid weighted by d2
          const sum = d2.reduce((a,b)=>a+b,0);
          let r = Math.random()*sum;
          let idx = 0;
          for (let i=0;i<d2.length;i++){
            r -= d2[i];
            if (r <= 0){ idx = i; break; }
          }
          const sel = points[idx];
          centroids.push({x:sel.x, y:sel.y, color: usedColors[centroids.length], history:[{x:sel.x,y:sel.y}]});
        }
      } else {
        // random initialization in uniform canvas area + small margin
        for (let i=0;i<k;i++){
          centroids.push({
            x: Math.random() * 0.98 + 0.01,
            y: Math.random() * 0.98 + 0.01,
            color: usedColors[i],
            history: []
          });
        }
      }
      updateLegend();
      iter = 0;
      iterCountEl.textContent = iter;
      draw();
    }

    // Animated centroid movement helper
    function animateMoves(moves, duration=600){
      if (!moves || moves.length===0) return Promise.resolve();
      const startTime = performance.now();
      const fromPositions = moves.map(m => ({...m.from}));
      const toPositions = moves.map(m => ({...m.to}));
      return new Promise((resolve) => {
        function frame(now){
          const t = Math.min(1, (now - startTime) / duration);
          const eased = easeInOutCubic(t);
          moves.forEach((m, idx)=>{
            const i = m.i;
            centroids[i].x = fromPositions[idx].x + (toPositions[idx].x - fromPositions[idx].x) * eased;
            centroids[i].y = fromPositions[idx].y + (toPositions[idx].y - fromPositions[idx].y) * eased;
          });
          draw();
          if (t < 1){
            requestAnimationFrame(frame);
          } else {
            resolve();
          }
        }
        requestAnimationFrame(frame);
      });
    }

    function easeInOutCubic(t){
      return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
    }

    // Single iteration: assign then update centroids with animation
    async function stepOnce(){
      if (centroids.length === 0) return;
      // assignment
      const changes = assignClusters();
      computeInertia();
      draw();
      // update centroids
      const moves = updateCentroids();
      const duration = +speedRange.value;
      await animateMoves(moves, duration);
      // reassign after movement to ensure consistency
      assignClusters();
      computeInertia();
      iter += 1;
      iterCountEl.textContent = iter;
      pointCountEl.textContent = points.length;
      draw();
      return changes;
    }

    // Run until convergence with animated steps
    async function runUntilConverged(){
      animation.running = true;
      runBtn.textContent = 'Stop';
      while (animation.running){
        const changes = await stepOnce();
        // convergence if no cluster changes
        if (changes === 0) break;
        // small pause between iterations for clarity
        await new Promise(r=>setTimeout(r, 120));
      }
      animation.running = false;
      runBtn.textContent = 'Run';
    }

    // UI bindings
    kRange.addEventListener('input', e => {
      kNumber.value = kRange.value;
    });
    kNumber.addEventListener('input', e => {
      let v = Math.max(1, Math.min(10, +kNumber.value || 1));
      kNumber.value = v;
      kRange.value = v;
    });

    initBtn.addEventListener('click', () => {
      initCentroids(initSelect.value);
    });

    stepBtn.addEventListener('click', async () => {
      await stepOnce();
    });

    runBtn.addEventListener('click', async () => {
      if (animation.running){
        animation.running = false;
        runBtn.textContent = 'Run';
      } else {
        await runUntilConverged();
      }
    });

    addRandomBtn.addEventListener('click', () => {
      for (let i=0;i<20;i++){
        points.push({x: Math.random()*0.9+0.05, y: Math.random()*0.9+0.05, cluster:null, flashUntil:0});
      }
      pointCountEl.textContent = points.length;
      draw();
    });

    clearBtn.addEventListener('click', () => {
      points = [];
      pointCountEl.textContent = 0;
      inertiaValEl.textContent = 0;
      draw();
    });

    resetBtn.addEventListener('click', () => {
      points = [];
      centroids = [];
      iter = 0;
      iterCountEl.textContent = '0';
      inertiaValEl.textContent = '0';
      pointCountEl.textContent = '0';
      legendEl.innerHTML = '';
      draw();
    });

    // Canvas interactions: click to add point, drag points or centroids
    canvas.addEventListener('pointerdown', (ev) => {
      const rect = canvas.getBoundingClientRect();
      const px = ev.clientX;
      const py = ev.clientY;
      const norm = toNorm(px, py);
      // determine if clicking near a centroid
      const clickRadius = 18 / Math.min(canvas.clientWidth, canvas.clientHeight);
      for (let i=0;i<centroids.length;i++){
        const c = centroids[i];
        const dx = norm.x - c.x;
        const dy = norm.y - c.y;
        const d2 = dx*dx + dy*dy;
        if (Math.sqrt(d2) < clickRadius){
          dragging = {type:'centroid', index:i};
          canvas.setPointerCapture(ev.pointerId);
          return;
        }
      }
      // check points proximity
      for (let i=points.length-1;i>=0;i--){
        const p = points[i];
        const dx = norm.x - p.x;
        const dy = norm.y - p.y;
        const d2 = dx*dx + dy*dy;
        const pr = 10 / Math.min(canvas.clientWidth, canvas.clientHeight);
        if (Math.sqrt(d2) < pr){
          dragging = {type:'point', index:i};
          canvas.setPointerCapture(ev.pointerId);
          return;
        }
      }
      // otherwise add a new point
      points.push({x: norm.x, y: norm.y, cluster:null, flashUntil:0});
      pointCountEl.textContent = points.length;
      draw();
    });

    canvas.addEventListener('pointermove', (ev) => {
      if (!dragging) return;
      const norm = toNorm(ev.clientX, ev.clientY);
      if (dragging.type === 'point'){
        const p = points[dragging.index];
        p.x = norm.x;
        p.y = norm.y;
        // update assignments in real-time for immediate feedback
        if (centroids.length>0){
          assignClusters();
          computeInertia();
        }
        draw();
      } else if (dragging.type === 'centroid'){
        const c = centroids[dragging.index];
        c.x = norm.x;
        c.y = norm.y;
        draw();
      }
    });

    canvas.addEventListener('pointerup', (ev) => {
      if (dragging){
        canvas.releasePointerCapture(ev.pointerId);
        dragging = null;
      }
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space'){
        e.preventDefault();
        runBtn.click();
      } else if (e.code === 'ArrowRight'){
        e.preventDefault();
        stepBtn.click();
      } else if (e.key.toLowerCase() === 'r'){
        // reset
        e.preventDefault();
        resetBtn.click();
      }
    });

    // Initialize
    function init(){
      resizeCanvas();
      // default some points
      for (let i=0;i<30;i++){
        const angle = Math.random() * Math.PI * 2;
        const r = Math.random() * 0.28 + 0.02;
        const cx = 0.2 + (Math.random()*0.6);
        const cy = 0.2 + (Math.random()*0.6);
        points.push({x: Math.random()*0.88+0.06, y: Math.random()*0.88+0.06, cluster:null, flashUntil:0});
      }
      pointCountEl.textContent = points.length;
      // initialize centroids
      initCentroids('random');
      // draw loop to animate any flashes
      (function rafLoop(){
        draw();
        requestAnimationFrame(rafLoop);
      })();
    }

    // initial resize after DOM
    requestAnimationFrame(()=>{ init(); });
  </script>
</body>
</html>