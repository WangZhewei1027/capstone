<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kruskal's Algorithm — Interactive Module</title>
  <style>
    /* Safe area margins: 24px all around */
    :root {
      --safe: 24px;
      --gap: 16px; /* minimum spacing between interactive elements */
      --accent: #1e88e5;
      --ok: #2e7d32;
      --warn: #ef6c00;
      --bad: #c62828;
      --bg: #fafafa;
      --panel: #ffffff;
      --muted: #6b7280;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: var(--safe);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #ffffff 0%, #fbfdff 100%);
      color: #111827;
      -webkit-font-smoothing: antialiased;
    }

    /* Layout container */
    .container {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: var(--gap);
      height: calc(100% - (var(--safe) * 2));
      min-height: 640px;
      align-items: start;
    }

    /* Top explanatory panel spans both columns */
    .intro {
      grid-column: 1 / -1;
      background: var(--panel);
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 2px 8px rgba(16,24,40,0.06);
      margin-bottom: var(--gap);
    }

    .intro h1 {
      margin: 0 0 8px 0;
      font-size: 20px;
      color: #0f172a;
    }

    .intro p {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.4;
    }

    .intro .specs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }

    .spec {
      background: #f8fafc;
      border-radius: 8px;
      padding: 10px;
      font-size: 13px;
      color: #111827;
    }
    .spec strong { display:block; margin-bottom:6px; color:#0f172a; }

    /* Main interactive panels */
    .graph-panel {
      background: var(--panel);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 2px 8px rgba(16,24,40,0.04);
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 400px;
    }

    .canvas-wrap {
      flex: 1 1 auto;
      position: relative;
      border: 1px dashed #e6edf3;
      border-radius: 8px;
      overflow: hidden;
    }

    /* SVG will scale to container */
    svg {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      background: linear-gradient(180deg, rgba(30,136,229,0.02), rgba(30,136,229,0.00));
    }

    .controls {
      display: flex;
      gap: var(--gap);
      align-items: center;
      flex-wrap: wrap;
      padding-top: 6px;
    }

    button, .btn {
      background: white;
      border: 1px solid #e6edf3;
      color: #0f172a;
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      min-height: 40px;
      display: inline-flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    button.primary {
      background: linear-gradient(180deg,var(--accent),#1565c0);
      color: white;
      border: none;
      box-shadow: 0 2px 8px rgba(30,136,229,0.12);
    }

    button.warn {
      background: linear-gradient(180deg,#fb8c00,#ef6c00);
      color: white;
      border: none;
    }

    button:focus {
      outline: 3px solid rgba(30,136,229,0.16);
      outline-offset: 2px;
    }

    .sidebar {
      background: var(--panel);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 2px 8px rgba(16,24,40,0.04);
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 400px;
    }

    .panel-section {
      background: #f8fafc;
      border-radius: 8px;
      padding: 10px;
      font-size: 13px;
    }

    .edge-list {
      max-height: 240px;
      overflow: auto;
      display: grid;
      gap: 8px;
      padding-right: 6px;
    }

    .edge-item {
      background: white;
      padding: 8px;
      border-radius: 8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 8px;
      border: 1px solid #e6edf3;
      cursor: pointer;
    }

    .edge-item:focus {
      outline: 3px solid rgba(30,136,229,0.12);
      outline-offset: 1px;
    }

    .edge-label { font-weight:600; color:#0f172a; }
    .edge-weight { background:#e6f2ff; color:var(--accent); padding:6px 8px; border-radius:8px; font-weight:700; }

    .uf-sets {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }

    .set-pill {
      padding:6px 10px;
      border-radius: 999px;
      background: linear-gradient(180deg,#ffffff,#f1f5f9);
      border:1px solid #e6edf3;
      font-size:13px;
      min-width:48px;
      text-align:center;
    }

    .status {
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
    }

    .total {
      font-size:16px;
      font-weight:700;
      color:#0f172a;
    }

    .msg {
      font-size:13px;
      color:var(--muted);
    }

    /* Visual styles for SVG elements */
    .edge {
      stroke: #cbd5e1;
      stroke-width: 3;
      transition: stroke 250ms ease, stroke-width 200ms ease, opacity 200ms ease;
      opacity: 0.9;
      cursor: pointer;
    }

    .edge.candidate {
      stroke: #1e88e5;
      stroke-width: 4.5;
      filter: drop-shadow(0 2px 4px rgba(30,136,229,0.12));
    }

    .edge.added {
      stroke: var(--ok);
      stroke-width: 5;
      opacity: 1;
    }

    .edge.rejected {
      stroke: var(--bad);
      stroke-width: 3.5;
      opacity: 1;
      animation: shake 400ms;
    }

    @keyframes shake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-4px); }
      50% { transform: translateX(4px); }
      75% { transform: translateX(-2px); }
      100% { transform: translateX(0); }
    }

    .node {
      fill: #ffffff;
      stroke: #0f172a;
      stroke-width: 2;
      transition: fill 200ms ease, transform 160ms ease;
      cursor: grab;
    }

    .node:active { cursor: grabbing; }

    .node-set-0 { fill: #fff3e0; stroke: #ef6c00; }
    .node-set-1 { fill: #e3f2fd; stroke: #1e88e5; }
    .node-set-2 { fill: #e8f5e9; stroke: #2e7d32; }
    .node-set-3 { fill: #fff0f6; stroke: #c62828; }
    .node-set-4 { fill: #f3e8ff; stroke: #6a1b9a; }

    .node-label {
      font-size: 12px;
      pointer-events: none;
      fill: #0f172a;
      font-weight:700;
    }

    .weight-label {
      font-size: 12px;
      fill: #0f172a;
      font-weight:600;
      background:transparent;
      pointer-events:none;
    }

    /* Responsive */
    @media (max-width: 980px) {
      .container {
        grid-template-columns: 1fr;
        height: auto;
      }
      .intro { margin-bottom: 0; }
    }
  </style>
</head>
<body>
  <div class="container" role="main">
    <!-- Introductory / explanatory content -->
    <section class="intro" aria-labelledby="title">
      <h1 id="title">Kruskal's Algorithm — Minimum Spanning Tree (Interactive)</h1>

      <div style="display:flex; gap:12px; flex-wrap:wrap; margin-top:8px;">
        <p style="flex:1 1 480px; min-width:240px;">
          Explore Kruskal’s algorithm by selecting edges on a weighted undirected graph. The module
          enforces the algorithm's rule: pick the smallest-weight edges that do not form a cycle, building
          the Minimum Spanning Tree (MST). Drag nodes to see how edges update dynamically.
        </p>

        <div style="min-width:260px;">
          <div class="specs" style="grid-template-columns:1fr;">
            <div class="spec">
              <strong>Concept Title</strong>
              Kruskal's Algorithm — Greedy MST by edge order
            </div>

            <div class="spec" style="margin-top:12px;">
              <strong>Learning Objective</strong>
              After using this module you should be able to: identify the smallest safe edge at each step,
              understand why adding an edge that connects vertices already in the same set creates a cycle,
              and watch how the union-find structure grows as the MST forms.
            </div>
          </div>
        </div>
      </div>

      <hr style="margin:12px 0; border:none; border-top:1px solid #eef2f7">

      <div style="display:flex; gap:12px; flex-wrap:wrap;">
        <div style="flex:1 1 450px;">
          <strong>Interaction Design</strong>
          <p style="margin:6px 0 0 0; color:var(--muted); font-size:13px;">
            - Click an edge to attempt to add it to the MST. The system checks (using union-find) whether the edge is safe.
            <br> - Correct selections animate the edge into the MST (green), nodes update to the same set color, and total weight increases.
            <br> - Incorrect selections animate a red shake and explain the cycle.
            <br> - Use Next / Play to step through Kruskal's canonical order (edges sorted by weight). Use Hint to highlight the next safe edge.
            <br> - Drag nodes to reposition the graph; edges and weights update in real-time.
          </p>
        </div>

        <div style="flex: 260px 0 0;">
          <strong>Layout Description</strong>
          <p style="margin:6px 0 0 0; color:var(--muted); font-size:13px;">
            Two-column layout: left is the interactive canvas (graph) with controls beneath it; right is a sidebar showing the sorted edge list,
            the union-find (set) view, and status. Spacing respects a 24px safe margin and 16px minimum gap between controls. Accessible focus styles and keyboard navigation are included.
          </p>
        </div>
      </div>
    </section>

    <!-- Graph / canvas panel -->
    <section class="graph-panel" aria-label="Interactive graph and controls">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
        <div style="display:flex; gap:12px; align-items:center;">
          <strong style="font-size:16px;">Interactive Graph</strong>
          <span class="msg" style="font-size:13px;">Drag nodes. Click edges to add to MST.</span>
        </div>

        <div style="display:flex; gap:8px; align-items:center;">
          <div class="status" aria-live="polite" aria-atomic="true">
            <div class="total" id="totalWeight">Total: 0</div>
            <div class="msg" id="progress">0 / 0 edges added</div>
          </div>
        </div>
      </div>

      <div class="canvas-wrap" id="canvasWrap">
        <!-- SVG graph inserted here -->
        <svg id="svgCanvas" viewBox="0 0 800 560" role="img" aria-label="Graph canvas">
          <!-- edges and nodes will be created by JS -->
        </svg>
      </div>

      <div class="controls" role="toolbar" aria-label="Controls">
        <button id="nextBtn" class="primary" title="Next step (select next candidate edge)">Next</button>
        <button id="playBtn" title="Play steps automatically">Play</button>
        <button id="hintBtn" title="Highlight next safe edge">Hint</button>
        <button id="shuffleBtn" title="Randomly reposition nodes">Shuffle</button>
        <button id="resetBtn" class="warn" title="Reset algorithm and clear MST">Reset</button>
        <div style="flex:1"></div>
        <div style="font-size:13px; color:var(--muted);">Click any edge to attempt to add it.</div>
      </div>
    </section>

    <!-- Sidebar with edge list, union-find, and explanations -->
    <aside class="sidebar" aria-labelledby="sidebarTitle">
      <h2 id="sidebarTitle" style="margin:0; font-size:16px;">Algorithm State</h2>

      <div class="panel-section" aria-live="polite">
        <strong style="display:block; margin-bottom:8px;">Edge list (sorted ascending)</strong>
        <div class="edge-list" id="edgeList" tabindex="0" role="list">
          <!-- edge items will be added here -->
        </div>
      </div>

      <div class="panel-section" aria-live="polite">
        <strong style="display:block; margin-bottom:8px;">Union-Find (sets)</strong>
        <div class="uf-sets" id="ufSets" aria-hidden="false">
          <!-- set pills -->
        </div>
      </div>

      <div class="panel-section" aria-live="polite">
        <strong style="display:block; margin-bottom:8px;">Feedback</strong>
        <div id="feedback" class="msg">Start by clicking Next or selecting the smallest edge.</div>
      </div>
    </aside>
  </div>

  <script>
    /****************************************************************
     * Kruskal Interactive — Vanilla JS
     * - Single concept: Kruskal's Algorithm (MST by choosing smallest safe edges)
     * - Features:
     *   * Click edges to attempt to add to MST (union-find checks).
     *   * Next / Play / Hint / Shuffle / Reset controls.
     *   * Drag nodes to reposition; edges update.
     *   * Visual feedback & animations for accepted/rejected edges.
     ****************************************************************/

    (function () {
      // Accessibility helpers
      function setFeedback(text) {
        const fb = document.getElementById('feedback');
        fb.textContent = text;
      }

      // Example graph definition: nodes with id and positions, edges as pairs with weight.
      const nodes = [
        { id: 'A', x: 120, y: 120 },
        { id: 'B', x: 300, y: 80 },
        { id: 'C', x: 520, y: 120 },
        { id: 'D', x: 200, y: 300 },
        { id: 'E', x: 420, y: 300 },
        { id: 'F', x: 640, y: 280 },
        { id: 'G', x: 360, y: 460 }
      ];

      const edges = [
        { id: 'e1', a: 'A', b: 'B', w: 4 },
        { id: 'e2', a: 'A', b: 'D', w: 8 },
        { id: 'e3', a: 'B', b: 'C', w: 6 },
        { id: 'e4', a: 'B', b: 'D', w: 3 },
        { id: 'e5', a: 'C', b: 'E', w: 2 },
        { id: 'e6', a: 'D', b: 'E', w: 7 },
        { id: 'e7', a: 'C', b: 'F', w: 9 },
        { id: 'e8', a: 'E', b: 'F', w: 5 },
        { id: 'e9', a: 'D', b: 'G', w: 6 },
        { id: 'e10', a: 'E', b: 'G', w: 4 },
        { id: 'e11', a: 'B', b: 'E', w: 11 }
      ];

      // Derived state
      let nodeMap = new Map();       // id -> node object with position
      let edgeMap = new Map();       // id -> edge object with endpoints & weight
      let svgNS = "http://www.w3.org/2000/svg";

      // Algorithm state
      let sortedEdges = [];    // sorted by weight
      let addedEdges = new Set(); // ids of edges added to MST
      let processedEdges = new Set(); // edges considered (either accepted or rejected)
      let totalWeight = 0;

      // Union-Find (disjoint set) implementation
      class UnionFind {
        constructor(items) {
          this.parent = {};
          this.rank = {};
          items.forEach(i => {
            this.parent[i] = i;
            this.rank[i] = 0;
          });
        }
        find(a) {
          if (this.parent[a] !== a) this.parent[a] = this.find(this.parent[a]);
          return this.parent[a];
        }
        union(a, b) {
          let ra = this.find(a), rb = this.find(b);
          if (ra === rb) return false;
          if (this.rank[ra] < this.rank[rb]) this.parent[ra] = rb;
          else if (this.rank[rb] < this.rank[ra]) this.parent[rb] = ra;
          else { this.parent[rb] = ra; this.rank[ra]++; }
          return true;
        }
        groups() {
          let map = {};
          for (let k in this.parent) {
            let r = this.find(k);
            if (!map[r]) map[r] = [];
            map[r].push(k);
          }
          return Object.values(map);
        }
      }

      let uf = null;

      // DOM elements
      const svg = document.getElementById('svgCanvas');
      const edgeListEl = document.getElementById('edgeList');
      const ufSetsEl = document.getElementById('ufSets');
      const totalWeightEl = document.getElementById('totalWeight');
      const progressEl = document.getElementById('progress');

      const nextBtn = document.getElementById('nextBtn');
      const playBtn = document.getElementById('playBtn');
      const hintBtn = document.getElementById('hintBtn');
      const shuffleBtn = document.getElementById('shuffleBtn');
      const resetBtn = document.getElementById('resetBtn');

      // Playback state
      let playing = false;
      let playInterval = null;

      // Color palette for sets
      const setClasses = ['node-set-0','node-set-1','node-set-2','node-set-3','node-set-4'];

      // Initialize maps and UI
      function init() {
        nodeMap.clear && nodeMap.clear();
        edgeMap.clear && edgeMap.clear();
        nodes.forEach(n => nodeMap.set(n.id, { ...n }));
        edges.forEach(e => edgeMap.set(e.id, { ...e }));

        // Sorted edges
        sortedEdges = Array.from(edgeMap.values()).slice().sort((a,b) => a.w - b.w || a.id.localeCompare(b.id));

        // Reset state
        addedEdges.clear();
        processedEdges.clear();
        totalWeight = 0;
        uf = new UnionFind(nodes.map(n => n.id));

        // Clear SVG
        while (svg.firstChild) svg.removeChild(svg.firstChild);

        // Draw edges (lines) below nodes
        for (let edge of sortedEdges) {
          const { id, a, b, w } = edge;
          const A = nodeMap.get(a), B = nodeMap.get(b);
          // Group for edge (line + weight label)
          const g = document.createElementNS(svgNS, 'g');
          g.setAttribute('data-edge', id);
          g.setAttribute('tabindex', '0');
          g.setAttribute('role','button');
          g.setAttribute('aria-label', `Edge ${a} to ${b}, weight ${w}`);
          g.classList.add('edge-group');
          // Line
          const line = document.createElementNS(svgNS, 'line');
          line.setAttribute('x1', A.x);
          line.setAttribute('y1', A.y);
          line.setAttribute('x2', B.x);
          line.setAttribute('y2', B.y);
          line.setAttribute('class', 'edge');
          line.setAttribute('stroke-linecap', 'round');
          line.setAttribute('data-edge-id', id);
          g.appendChild(line);
          // weight label (center)
          const tx = (A.x + B.x) / 2;
          const ty = (A.y + B.y) / 2 - 8;
          const text = document.createElementNS(svgNS, 'text');
          text.setAttribute('x', tx);
          text.setAttribute('y', ty);
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('class', 'weight-label');
          text.textContent = String(w);
          g.appendChild(text);

          // attach click handlers
          g.addEventListener('click', (evt) => {
            evt.stopPropagation();
            attemptAddEdge(id, true);
          });
          g.addEventListener('keydown', (evt) => {
            if (evt.key === 'Enter' || evt.key === ' ') {
              evt.preventDefault();
              attemptAddEdge(id, true);
            }
          });

          svg.appendChild(g);
        }

        // Draw nodes on top
        for (let node of nodes) {
          const g = document.createElementNS(svgNS, 'g');
          g.setAttribute('data-node', node.id);
          g.style.cursor = 'grab';
          // circle
          const c = document.createElementNS(svgNS, 'circle');
          c.setAttribute('cx', node.x);
          c.setAttribute('cy', node.y);
          c.setAttribute('r', 18);
          c.setAttribute('class', 'node');
          c.setAttribute('data-node-id', node.id);
          g.appendChild(c);
          // label
          const t = document.createElementNS(svgNS, 'text');
          t.setAttribute('x', node.x);
          t.setAttribute('y', node.y + 4);
          t.setAttribute('text-anchor', 'middle');
          t.setAttribute('class', 'node-label');
          t.textContent = node.id;
          g.appendChild(t);

          // Dragging
          makeDraggable(g, node.id);

          svg.appendChild(g);
        }

        // populate edge list panel
        populateEdgeList();

        updateUFDisplay();
        updateTotals();
        setFeedback('Ready. Try clicking the smallest edge or press Next.');
      }

      // Populate right-edge list (sorted)
      function populateEdgeList() {
        edgeListEl.innerHTML = '';
        sortedEdges.forEach(edge => {
          const item = document.createElement('div');
          item.className = 'edge-item';
          item.setAttribute('tabindex', '0');
          item.setAttribute('role','button');
          item.setAttribute('aria-label', `Edge ${edge.a}-${edge.b} weight ${edge.w}`);
          item.dataset.edgeId = edge.id;
          item.innerHTML = '<div style="display:flex; gap:8px; align-items:center;"><div class="edge-label">' +
            edge.a + '—' + edge.b + '</div></div>' +
            '<div class="edge-weight">' + edge.w + '</div>';
          item.addEventListener('click', () => attemptAddEdge(edge.id, true));
          item.addEventListener('keydown', (evt) => {
            if (evt.key === 'Enter' || evt.key === ' ') {
              evt.preventDefault();
              attemptAddEdge(edge.id, true);
            }
          });
          edgeListEl.appendChild(item);
        });
      }

      // Update totals & status
      function updateTotals() {
        totalWeightEl.textContent = `Total: ${totalWeight}`;
        // progress: edges added count and target edges needed (n-1)
        const addedCount = addedEdges.size;
        progressEl.textContent = `${addedCount} / ${nodes.length - 1} edges added`;
      }

      // Update union-find display (sets)
      function updateUFDisplay() {
        ufSetsEl.innerHTML = '';
        const groups = uf.groups();
        groups.forEach((g, idx) => {
          const pill = document.createElement('div');
          pill.className = 'set-pill';
          pill.style.order = idx;
          // color mapping by index
          pill.classList.add(); // nothing
          pill.textContent = g.join(',');
          // color nodes in SVG to indicate set
          g.forEach(nodeId => {
            const nodeGrp = svg.querySelector('[data-node="'+nodeId+'"]');
            if (nodeGrp) {
              const circle = nodeGrp.querySelector('circle');
              circle.classList.remove(...setClasses);
              circle.classList.add(setClasses[idx % setClasses.length]);
            }
          });
          ufSetsEl.appendChild(pill);
        });
      }

      // Attempt to add an edge (user-driven or auto). If 'announce' true, set feedback messages.
      function attemptAddEdge(edgeId, announce) {
        if (processedEdges.has(edgeId)) {
          if (announce) setFeedback('This edge has already been considered.');
          return;
        }
        const edge = edgeMap.get(edgeId);
        if (!edge) return;

        // Visual: highlight candidate
        const el = svg.querySelector('[data-edge-id="' + edgeId + '"]');
        if (el) {
          el.classList.add('candidate');
          setTimeout(() => el.classList.remove('candidate'), 600);
        }

        const a = edge.a, b = edge.b;
        const rootA = uf.find(a), rootB = uf.find(b);

        if (rootA !== rootB) {
          // safe to add
          uf.union(a, b);
          addedEdges.add(edgeId);
          processedEdges.add(edgeId);
          totalWeight += edge.w;
          // animate edge to 'added'
          if (el) el.classList.remove('candidate');
          const group = svg.querySelector('[data-edge="'+edgeId+'"]') || svg.querySelector('[data-edge-id="'+edgeId+'"]')?.parentElement;
          const lineEl = svg.querySelector('[data-edge-id="'+edgeId+'"]');
          if (lineEl) {
            lineEl.classList.add('added');
            // fade weight label color
            const g = lineEl.parentElement;
            const text = g ? g.querySelector('text') : null;
            if (text) {
              text.style.fill = '#2e7d32';
              text.style.transition = 'fill 200ms';
            }
            // reflect in edge list
            const listItem = edgeListEl.querySelector('[data-edge-id="'+edgeId+'"]');
            if (listItem) listItem.style.opacity = 0.6;
          }
          updateUFDisplay();
          updateTotals();
          if (announce) setFeedback(`Edge ${a}-${b} (w=${edge.w}) accepted — connects two components.`);
        } else {
          // would form a cycle -> reject
          processedEdges.add(edgeId);
          // animate rejection (red shake)
          const lineEl = svg.querySelector('[data-edge-id="'+edgeId+'"]');
          if (lineEl) {
            lineEl.classList.add('rejected');
            setTimeout(() => lineEl.classList.remove('rejected'), 500);
          }
          // mark in list
          const listItem = edgeListEl.querySelector('[data-edge-id="'+edgeId+'"]');
          if (listItem) listItem.style.opacity = 0.5;
          if (announce) setFeedback(`Edge ${a}-${b} (w=${edge.w}) rejected — would create a cycle.`);
        }

        // Check for termination (when n-1 edges added)
        if (addedEdges.size === nodes.length - 1) {
          setFeedback(`MST complete! Total weight = ${totalWeight}.`);
          stopPlaying();
        }
      }

      // Find the next candidate edge in Kruskal order that hasn't been processed and highlight it
      function nextCandidateEdge() {
        for (let edge of sortedEdges) {
          if (!processedEdges.has(edge.id)) {
            return edge;
          }
        }
        return null;
      }

      // Next step: highlight next candidate and optionally auto-add if playing
      function stepNext(auto = false) {
        const candidate = nextCandidateEdge();
        if (!candidate) {
          setFeedback('All edges processed.');
          stopPlaying();
          return;
        }
        // highlight in SVG & list
        const lineEl = svg.querySelector('[data-edge-id="'+candidate.id+'"]');
        if (lineEl) {
          lineEl.classList.add('candidate');
          setTimeout(() => lineEl.classList.remove('candidate'), 900);
        }
        const listItem = edgeListEl.querySelector('[data-edge-id="'+candidate.id+'"]');
        if (listItem) {
          listItem.style.boxShadow = '0 6px 18px rgba(30,136,229,0.08)';
          setTimeout(() => listItem.style.boxShadow = '', 900);
        }

        if (auto) {
          // If auto-play, attempt to add it (Kruskal picks the smallest edge in order)
          setTimeout(() => attemptAddEdge(candidate.id, true), 350);
        } else {
          setFeedback(`Next smallest edge is ${candidate.a}-${candidate.b} (w=${candidate.w}). Click it to accept or press Next to auto-check.`);
        }
      }

      // Hint: highlight the next safe edge (smallest safe — not necessarily the next smallest edge overall)
      function hintNextSafe() {
        // We need to find the smallest-weight edge that connects two different components (safe)
        for (let edge of sortedEdges) {
          if (processedEdges.has(edge.id)) continue;
          if (uf.find(edge.a) !== uf.find(edge.b)) {
            // highlight
            const lineEl = svg.querySelector('[data-edge-id="'+edge.id+'"]');
            if (lineEl) {
              lineEl.classList.add('candidate');
              setTimeout(() => lineEl.classList.remove('candidate'), 1200);
            }
            // also highlight list item
            const listItem = edgeListEl.querySelector('[data-edge-id="'+edge.id+'"]');
            if (listItem) {
              listItem.style.boxShadow = '0 8px 20px rgba(46,125,50,0.08)';
              setTimeout(() => listItem.style.boxShadow = '', 1200);
            }
            setFeedback(`Hint: Safe edge to pick next is ${edge.a}-${edge.b} (w=${edge.w}).`);
            return edge;
          }
        }
        setFeedback('No safe edges left (all processed).');
        return null;
      }

      // Dragging implementation for SVG nodes (pointer events)
      function makeDraggable(group, nodeId) {
        const circle = group.querySelector('circle');
        const label = group.querySelector('text');
        let isDown = false;
        let start = { x: 0, y: 0 };
        let orig = { x: 0, y: 0 };

        function onPointerDown(e) {
          isDown = true;
          group.setPointerCapture(e.pointerId);
          start = getPointFromEvent(e);
          const node = nodeMap.get(nodeId);
          orig = { x: node.x, y: node.y };
          group.style.cursor = 'grabbing';
        }
        function onPointerMove(e) {
          if (!isDown) return;
          const pt = getPointFromEvent(e);
          const dx = pt.x - start.x;
          const dy = pt.y - start.y;
          const node = nodeMap.get(nodeId);
          node.x = orig.x + dx;
          node.y = orig.y + dy;
          // update circle & label position
          circle.setAttribute('cx', node.x);
          circle.setAttribute('cy', node.y);
          label.setAttribute('x', node.x);
          label.setAttribute('y', node.y + 4);
          // update edges connected to this node
          updateEdgesForNode(nodeId);
        }
        function onPointerUp(e) {
          if (!isDown) return;
          isDown = false;
          group.releasePointerCapture(e.pointerId);
          group.style.cursor = 'grab';
        }
        group.addEventListener('pointerdown', onPointerDown);
        group.addEventListener('pointermove', onPointerMove);
        group.addEventListener('pointerup', onPointerUp);
        group.addEventListener('pointercancel', onPointerUp);
        group.addEventListener('pointerleave', onPointerUp);
      }

      // Transform mouse/touch event to svg coordinate point
      function getPointFromEvent(e) {
        const pt = svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const ctm = svg.getScreenCTM().inverse();
        const p = pt.matrixTransform(ctm);
        return { x: p.x, y: p.y };
      }

      // Update all edges connected to a node
      function updateEdgesForNode(nodeId) {
        for (let edge of sortedEdges) {
          if (edge.a === nodeId || edge.b === nodeId) {
            const A = nodeMap.get(edge.a);
            const B = nodeMap.get(edge.b);
            const line = svg.querySelector('[data-edge-id="'+edge.id+'"]');
            const g = line ? line.parentElement : null;
            if (line) {
              line.setAttribute('x1', A.x);
              line.setAttribute('y1', A.y);
              line.setAttribute('x2', B.x);
              line.setAttribute('y2', B.y);
            }
            if (g) {
              const text = g.querySelector('text');
              if (text) {
                text.setAttribute('x', (A.x + B.x)/2);
                text.setAttribute('y', (A.y + B.y)/2 - 8);
              }
            }
          }
        }
      }

      // Shuffle nodes (random reposition keeping them in bounds)
      function shuffleNodes() {
        const w = svg.viewBox.baseVal.width || 800;
        const h = svg.viewBox.baseVal.height || 560;
        nodes.forEach(n => {
          const margin = 50;
          n.x = margin + Math.random() * (w - margin*2);
          n.y = margin + Math.random() * (h - margin*2);
          const nodeGrp = svg.querySelector('[data-node="'+n.id+'"]');
          if (nodeGrp) {
            const circle = nodeGrp.querySelector('circle');
            const label = nodeGrp.querySelector('text');
            circle.setAttribute('cx', n.x);
            circle.setAttribute('cy', n.y);
            label.setAttribute('x', n.x);
            label.setAttribute('y', n.y + 4);
          }
        });
        // update all edges
        sortedEdges.forEach(e => updateEdgesForNode(e.a));
      }

      // Reset / restart everything to initial state
      function resetAll() {
        stopPlaying();
        // Reset positions to original starting ones
        nodes.forEach((n, idx) => {
          const orig = nodes[idx];
          // no change here since nodes array already contains the original positions
        });
        // Re-run init
        init();
      }

      // Play (auto-step)
      function startPlaying() {
        if (playing) return;
        playing = true;
        playBtn.textContent = 'Pause';
        playInterval = setInterval(() => {
          // auto-select next candidate and attempt to add if safe else mark rejected and continue (Kruskal would try every edge in order)
          const next = nextCandidateEdge();
          if (!next) {
            stopPlaying();
            return;
          }
          // Attempt to add the next in sorted order (this simulates Kruskal's deterministic check)
          attemptAddEdge(next.id, true);
          // Stop if MST complete
          if (addedEdges.size === nodes.length - 1) stopPlaying();
        }, 900);
      }

      function stopPlaying() {
        if (!playing) return;
        playing = false;
        playBtn.textContent = 'Play';
        clearInterval(playInterval);
        playInterval = null;
      }

      // Event bindings
      nextBtn.addEventListener('click', () => {
        stepNext(false);
      });
      playBtn.addEventListener('click', () => {
        if (playing) stopPlaying(); else startPlaying();
      });
      hintBtn.addEventListener('click', () => {
        hintNextSafe();
      });
      shuffleBtn.addEventListener('click', () => {
        shuffleNodes();
        setFeedback('Nodes shuffled. Drag to fine-tune positions.');
      });
      resetBtn.addEventListener('click', () => {
        if (confirm('Reset the algorithm and clear the current MST?')) {
          resetAll();
        }
      });

      // Initialize on load
      init();

      // Expose some debugging to console (not required)
      window._kruskal = {
        nodes, edges, nodeMap, edgeMap, uf, attemptAddEdge
      };
    })();
  </script>
</body>
</html>