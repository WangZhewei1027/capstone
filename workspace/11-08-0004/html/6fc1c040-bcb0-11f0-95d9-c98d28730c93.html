<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Fibonacci Sequence — Spiral & Numbers</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa6bd;
      --accent: #ffb86b;
      --accent-2: #7bd389;
      --text: #e6eef8;
      --glass: rgba(255,255,255,0.03);
      --radius: 12px;
      --control-height: 40px;
    }
    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,var(--bg) 0%, #071022 100%);
      color:var(--text);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height:100%;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    header {
      display:flex;
      gap: var(--gap);
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .title {
      flex: 1 1 320px;
      min-width: 220px;
    }
    h1{
      margin:0 0 8px 0;
      font-size:20px;
      letter-spacing: -0.02em;
    }
    p.lead {
      margin:0;
      color:var(--muted);
      font-size:14px;
    }

    .meta {
      flex: 0 0 360px;
      min-width: 260px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.6);
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }
    .meta h3 {
      margin:0 0 8px 0;
      color: var(--accent);
      font-size:13px;
      text-transform:uppercase;
      letter-spacing:0.08em;
    }

    main {
      display:flex;
      gap: var(--gap);
      align-items:flex-start;
      justify-content:space-between;
      width:100%;
      box-sizing:border-box;
    }

    /* Left: Canvas panel */
    .canvas-panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding:16px;
      flex: 1 1 640px;
      min-width: 280px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      box-shadow: 0 8px 40px rgba(0,0,0,0.6);
    }
    .canvas-wrap {
      position:relative;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius: 10px;
      padding: 12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
    }
    canvas {
      width:100%;
      height:420px;
      border-radius:8px;
      background: linear-gradient(180deg, rgba(12,18,30,0.6), rgba(6,10,18,0.6));
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    }

    .legend {
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
      width:100%;
      justify-content:space-between;
    }
    .legend .left {
      display:flex;
      gap:12px;
      align-items:center;
    }
    .badge {
      display:inline-flex;
      align-items:center;
      gap:8px;
      background:var(--glass);
      padding:8px 12px;
      border-radius:999px;
      color:var(--muted);
      font-size:13px;
    }
    .badge .dot {
      width:10px;height:10px;border-radius:50%;
      background:var(--accent);
      box-shadow:0 0 10px rgba(255,184,107,0.16);
    }

    /* Right: Controls */
    .controls {
      width:340px;
      min-width:260px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding:16px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      align-items:stretch;
      color:var(--muted);
    }

    .controls .row {
      display:flex;
      gap: var(--gap);
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }

    label {
      font-size:13px;
      color:var(--muted);
    }

    input[type="range"] {
      -webkit-appearance:none;
      appearance:none;
      width:100%;
      height:6px;
      border-radius:999px;
      background: rgba(255,255,255,0.04);
      outline:none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:18px;height:18px;border-radius:50%;
      background:var(--accent);
      box-shadow:0 4px 16px rgba(255,184,107,0.18);
      border:2px solid rgba(0,0,0,0.2);
      cursor:pointer;
      margin-top:-6px;
    }

    .control-buttons {
      display:flex;
      gap: var(--gap);
      align-items:center;
      justify-content:flex-start;
      flex-wrap:wrap;
    }
    button {
      height: var(--control-height);
      min-width: 88px;
      padding: 0 14px;
      border-radius: 10px;
      border: none;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      color: var(--text);
      cursor: pointer;
      font-size:14px;
      transition: transform 90ms ease, box-shadow 120ms ease, opacity 120ms;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }
    button:active { transform: translateY(1px); }
    .btn-primary {
      background: linear-gradient(180deg,var(--accent) 0%, #ff9f4a 100%);
      color:#071022;
      box-shadow: 0 10px 30px rgba(255,158,74,0.18);
    }
    .btn-ghost {
      background: rgba(255,255,255,0.02);
      color: var(--text);
    }

    .list {
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }
    .pill {
      background: rgba(255,255,255,0.03);
      color:var(--muted);
      padding:8px 10px;
      border-radius:999px;
      font-size:13px;
      min-width:44px;
      text-align:center;
    }
    .pill.highlight {
      background: linear-gradient(90deg, rgba(123,211,137,0.18), rgba(255,184,107,0.12));
      color:var(--text);
      font-weight:600;
      box-shadow: 0 6px 18px rgba(0,0,0,0.4);
    }

    .info {
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .ratio {
      font-weight:700;
      color:var(--accent-2);
    }

    footer {
      color:var(--muted);
      font-size:13px;
    }

    /* Responsive */
    @media (max-width:960px){
      main {
        flex-direction:column;
      }
      .controls { width:100%; }
    }

    /* Ensure at least 16px between interactive elements */
    .controls > * { margin-bottom:0; }
    .canvas-panel > * { margin-bottom:0; }

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Fibonacci interactive module">
    <header>
      <div class="title">
        <h1>Fibonacci Sequence — Visual Spiral & Ratios</h1>
        <p class="lead">Explore how Fibonacci numbers grow, tile into squares, and form the familiar spiral that approaches the golden ratio.</p>
      </div>

      <aside class="meta" aria-labelledby="meta-title">
        <h3 id="meta-title">Module Overview</h3>
        <strong>Concept Title:</strong>
        <div style="margin:8px 0 12px 0; color:var(--text); font-weight:600;">Fibonacci Sequence — squares & spiral visualization</div>

        <strong>Learning Objective</strong>
        <div style="margin-top:8px;">
          After interacting with this module you will:
          <ul style="margin:8px 0 0 18px; color:var(--muted); padding:0;">
            <li>See how Fibonacci numbers generate discrete square sizes.</li>
            <li>Watch the squares tile and learn how the spiral is formed with quarter-circles.</li>
            <li>Observe how ratios of consecutive terms converge toward the golden ratio (~1.618).</li>
          </ul>
        </div>

        <strong style="display:block; margin-top:12px;">Interaction Design</strong>
        <div style="margin-top:8px; color:var(--muted);">
          Use the slider or buttons to choose how many terms to show (up to 12). Press Play to animate adding one square at a time and draw the spiral progressively.
          You can Step forward manually or Reset to restart. Visual feedback: squares fade-in and arcs are drawn progressively; the numeric list and ratio update in sync.
        </div>

        <strong style="display:block; margin-top:12px;">Layout Notes</strong>
        <div style="margin-top:8px; color:var(--muted);">
          Left: large drawing canvas with legend and numeric list. Right: controls (slider, play/step/reset, toggles). The layout respects 24px safe margins and 16px minimum spacing between controls. The canvas scales to fit and is accessible via keyboard.
        </div>
      </aside>
    </header>

    <main>
      <section class="canvas-panel" aria-label="Visualization">
        <div class="canvas-wrap" role="region" aria-labelledby="viz-title">
          <div style="display:flex; width:100%; justify-content:space-between; align-items:center;">
            <div>
              <strong id="viz-title">Fibonacci Tiling & Spiral</strong>
              <div style="font-size:13px; color:var(--muted); margin-top:6px;">Squares sized by Fibonacci numbers produce the quarter-circle spiral.</div>
            </div>
            <div class="badge" aria-hidden="true">
              <span class="dot" style="background:var(--accent);"></span>
              <span style="font-weight:600;color:var(--text);">Interactive</span>
            </div>
          </div>

          <canvas id="fibCanvas" role="img" aria-label="Animated Fibonacci tiling" tabindex="0"></canvas>

          <div class="legend" aria-hidden="false">
            <div class="left">
              <div style="display:flex; flex-direction:column;">
                <div style="font-size:13px; color:var(--muted);">Terms shown</div>
                <div style="font-weight:600; color:var(--text);" id="termsLabel">6</div>
              </div>
              <div style="width:1px; height:28px; background:rgba(255,255,255,0.03);"></div>
              <div style="display:flex; flex-direction:column;">
                <div style="font-size:13px; color:var(--muted);">Current ratio</div>
                <div style="font-weight:700; color:var(--accent-2);" id="ratioLabel">—</div>
              </div>
            </div>

            <div style="display:flex; gap:12px; align-items:center;">
              <div style="font-size:13px; color:var(--muted);">Show numbers</div>
              <label style="display:inline-flex; align-items:center; gap:8px;">
                <input id="toggleNumbers" type="checkbox" checked />
                <span style="font-size:13px; color:var(--muted);">On</span>
              </label>
            </div>
          </div>
        </div>

        <div style="display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap;">
          <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
            <div style="font-size:13px; color:var(--muted);">Sequence:</div>
            <div id="sequenceList" class="list" aria-live="polite" aria-atomic="true"></div>
          </div>

          <div class="info" aria-hidden="false">
            <div>Golden ratio ≈ <span class="ratio">1.618</span></div>
            <div style="font-size:13px; color:var(--muted);">Note: ratios converge as terms grow.</div>
          </div>
        </div>
      </section>

      <aside class="controls" aria-label="Controls">
        <div class="row">
          <label for="termRange">Number of terms</label>
          <div style="font-weight:700; color:var(--text);" id="numTermsDisplay">6</div>
        </div>

        <div class="row" style="align-items:center;">
          <input id="termRange" type="range" min="2" max="12" value="6" aria-label="Number of Fibonacci terms" />
        </div>

        <div>
          <label style="display:block; margin-bottom:8px;">Animation controls</label>
          <div class="control-buttons">
            <button id="playBtn" class="btn-primary" aria-pressed="false">Play</button>
            <button id="stepBtn" class="btn-ghost">Step</button>
            <button id="resetBtn" class="btn-ghost">Reset</button>
          </div>
        </div>

        <div>
          <label style="display:block; margin-bottom:8px;">Animation speed</label>
          <div style="display:flex; gap:12px; align-items:center;">
            <select id="speedSelect" style="height:var(--control-height); border-radius:10px; background:rgba(255,255,255,0.02); color:var(--text); border:none; padding:0 10px;">
              <option value="700">Slow</option>
              <option value="400" selected>Normal</option>
              <option value="180">Fast</option>
            </select>
            <div style="font-size:13px; color:var(--muted);">ms / step</div>
          </div>
        </div>

        <div>
          <label style="display:block; margin-bottom:8px;">Rendering options</label>
          <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
            <label style="display:inline-flex; align-items:center; gap:8px;">
              <input id="toggleArcs" type="checkbox" checked />
              <span style="font-size:13px; color:var(--muted);">Show arcs</span>
            </label>
            <label style="display:inline-flex; align-items:center; gap:8px;">
              <input id="toggleFill" type="checkbox" checked />
              <span style="font-size:13px; color:var(--muted);">Fill squares</span>
            </label>
          </div>
        </div>

        <div style="margin-top:auto;">
          <div style="font-size:13px; color:var(--muted); margin-bottom:8px;">Keyboard</div>
          <div style="font-size:13px; color:var(--muted);">
            Slider: Left/Right arrows &middot; Play/Pause: Enter or Space on Play button &middot; Step: S
          </div>
        </div>
      </aside>
    </main>

    <footer>
      Tip: increase the number of terms and watch how the ratio between adjacent Fibonacci numbers approaches the golden ratio (~1.618...).
    </footer>
  </div>

  <script>
    // Interactive Fibonacci Visualization (vanilla JS)
    (function () {
      // DOM elements
      const canvas = document.getElementById('fibCanvas');
      const ctx = canvas.getContext('2d');
      const termRange = document.getElementById('termRange');
      const numTermsDisplay = document.getElementById('numTermsDisplay');
      const termsLabel = document.getElementById('termsLabel');
      const sequenceList = document.getElementById('sequenceList');
      const ratioLabel = document.getElementById('ratioLabel');
      const playBtn = document.getElementById('playBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');
      const speedSelect = document.getElementById('speedSelect');
      const toggleNumbers = document.getElementById('toggleNumbers');
      const toggleArcs = document.getElementById('toggleArcs');
      const toggleFill = document.getElementById('toggleFill');

      // State
      let terms = parseInt(termRange.value, 10) || 6;
      let fibs = [];
      let squares = []; // {x,y,size,index,appearProgress,arcProgress}
      let animRunning = false;
      let currentAnimatingIndex = -1; // index currently animating (0-based)
      let lastStepAt = 0;
      let stepDuration = parseInt(speedSelect.value, 10) || 400;
      let rafId = null;

      // Canvas high-DPI setup
      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const ratio = window.devicePixelRatio || 1;
        canvas.width = Math.max(300, Math.floor(rect.width * ratio));
        canvas.height = Math.max(200, Math.floor(rect.height * ratio));
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
        render();
      }
      window.addEventListener('resize', resizeCanvas);
      // initial resize after DOM content loaded
      setTimeout(resizeCanvas, 50);

      // Utility: generate fib numbers (starting 1,1)
      function generateFibs(n) {
        const a = [1, 1];
        if (n <= 2) return a.slice(0, n);
        for (let i = 2; i < n; i++) {
          a.push(a[i - 1] + a[i - 2]);
        }
        return a;
      }

      // Build squares coordinates using the bounding-box placement algorithm
      // Starts with two 1x1 squares placed side-by-side:
      // square0 at (0,0), square1 at (1,0), then iterate: up,left,down,right...
      function buildSquares(fibs) {
        const items = [];
        if (fibs.length === 0) return items;
        // first two
        items.push({ x: 0, y: 0, s: fibs[0], i: 0 });
        if (fibs.length === 1) return items;
        items.push({ x: fibs[0], y: 0, s: fibs[1], i: 1 });
        // bounding box in logical units
        let minX = 0, minY = 0, maxX = fibs[0] + fibs[1], maxY = Math.max(fibs[0], fibs[1]);
        for (let k = 2; k < fibs.length; k++) {
          const s = fibs[k];
          const dir = (k - 2) % 4; // 0: up, 1: left, 2: down, 3: right
          let x, y;
          if (dir === 0) { // up
            x = minX;
            y = minY - s;
          } else if (dir === 1) { // left
            x = minX - s;
            y = minY;
          } else if (dir === 2) { // down
            x = minX;
            y = maxY;
          } else { // right
            x = maxX;
            y = minY;
          }
          items.push({ x: x, y: y, s: s, i: k });
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x + s);
          maxY = Math.max(maxY, y + s);
        }
        // Attach bounding box values to items for scaling later
        items._bounds = { minX, minY, maxX, maxY };
        return items;
      }

      // Map logical coordinates to canvas coordinates (with padding)
      function computeTransform(bounds, canvasRect) {
        const pad = 20; // px padding inside canvas
        const logicalW = bounds.maxX - bounds.minX;
        const logicalH = bounds.maxY - bounds.minY;
        const availW = canvasRect.width - pad * 2;
        const availH = canvasRect.height - pad * 2;
        const scale = Math.min(availW / logicalW, availH / logicalH);
        const offsetX = pad + (availW - logicalW * scale) / 2 - bounds.minX * scale;
        const offsetY = pad + (availH - logicalH * scale) / 2 - bounds.minY * scale;
        return { scale, offsetX, offsetY, pad };
      }

      // Drawing helpers
      function clear() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      // Draw one square (with optional partial fill/opacity) and its numeric label and arc progress
      function drawSquare(sq, t, transform) {
        // sq: {x,y,s,i,appearProgress,arcProgress}
        const { scale, offsetX, offsetY } = transform;
        const x = sq.x * scale + offsetX;
        const y = sq.y * scale + offsetY;
        const size = sq.s * scale;
        const alpha = Math.max(0, Math.min(1, sq.appearProgress !== undefined ? sq.appearProgress : 1));

        // Fill
        if (toggleFill.checked) {
          ctx.globalAlpha = 0.12 * alpha;
          ctx.fillStyle = '#7bd389';
          ctx.fillRect(x, y, size, size);
        }
        // Stroke border
        ctx.globalAlpha = 0.28 * alpha;
        ctx.strokeStyle = 'rgba(255,255,255,0.16)';
        ctx.lineWidth = Math.max(1, 1.2);
        ctx.strokeRect(x + 0.5, y + 0.5, size - 1, size - 1);

        // Number label
        if (toggleNumbers.checked) {
          ctx.globalAlpha = 0.98 * alpha;
          ctx.fillStyle = '#e6eef8';
          ctx.font = `${Math.max(10, Math.min(16, size * 0.16))}px system-ui, sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const labelX = x + size / 2;
          const labelY = y + size / 2;
          ctx.fillText(String(sq.s), labelX, labelY);
        }

        // Arc (quarter circle) drawn with progress from 0..1
        if (toggleArcs.checked) {
          const arcProgress = sq.arcProgress !== undefined ? sq.arcProgress : 1;
          drawArcForSquare(sq, arcProgress, transform, alpha);
        }

        ctx.globalAlpha = 1;
      }

      // Draw quarter arc for a square with partial progress
      // Using mapping by index modulo 4 to choose arc center & angles
      function drawArcForSquare(sq, progress, transform, globalAlpha = 1) {
        const { scale, offsetX, offsetY } = transform;
        const x = sq.x * scale + offsetX;
        const y = sq.y * scale + offsetY;
        const size = sq.s * scale;

        // We use square index modulo 4 to determine arc orientation.
        // Mapping:
        // i % 4 === 0: center (x+size, y+size) arc from PI to 1.5*PI (lower-left quarter)
        // 1: center (x, y+size) from 1.5*PI to 0 (lower-right quarter)
        // 2: center (x, y) from 0 to 0.5*PI (upper-right quarter)
        // 3: center (x+size, y) from 0.5*PI to PI (upper-left quarter)
        const mod = sq.i % 4;
        let cx, cy, start, end;
        if (mod === 0) {
          cx = x + size; cy = y + size; start = Math.PI; end = 1.5 * Math.PI;
        } else if (mod === 1) {
          cx = x; cy = y + size; start = 1.5 * Math.PI; end = 0;
        } else if (mod === 2) {
          cx = x; cy = y; start = 0; end = 0.5 * Math.PI;
        } else {
          cx = x + size; cy = y; start = 0.5 * Math.PI; end = Math.PI;
        }

        // Interpolate angle by progress (0..1)
        // Handle wrap when end < start (case mod===1)
        let totalDelta = end - start;
        if (totalDelta <= 0) totalDelta += Math.PI * 2;
        const currentEnd = start + totalDelta * progress;

        ctx.beginPath();
        ctx.lineWidth = Math.max(2, Math.min(8, size * 0.03));
        ctx.strokeStyle = `rgba(255,235,205,${0.9 * globalAlpha})`;
        ctx.arc(cx, cy, size, start, currentEnd, false);
        ctx.stroke();
      }

      // Render function draws all squares according to current state
      function render() {
        clear();
        if (!squares || squares.length === 0) return;

        const bounds = squares._bounds || {minX:0,minY:0,maxX:1,maxY:1};
        // canvas rect in CSS pixels for transform computing (not scaled by devicePixelRatio)
        const canvasRect = canvas.getBoundingClientRect();
        const transform = computeTransform(bounds, canvasRect);

        // Draw background subtle grid lines for orientation
        drawBackgroundGrid(transform);

        // Draw squares in order (lowest index first)
        for (let i = 0; i < squares.length; i++) {
          drawSquare(squares[i], null, transform);
        }
      }

      function drawBackgroundGrid(transform) {
        const { scale, offsetX, offsetY, pad } = transform;
        const canvasRect = canvas.getBoundingClientRect();
        const W = canvasRect.width;
        const H = canvasRect.height;
        ctx.save();
        // subtle center crosshair
        ctx.globalAlpha = 0.06;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(offsetX, 0);
        ctx.lineTo(offsetX, H);
        ctx.moveTo(0, offsetY);
        ctx.lineTo(W, offsetY);
        ctx.stroke();
        ctx.restore();
      }

      // Animation loop to update appearProgress and arcProgress
      function animateLoop(ts) {
        if (!lastStepAt) lastStepAt = ts;
        const elapsed = ts - lastStepAt;
        let needsRender = false;

        // Animate currentAnimatingIndex from 0..currentAnimatingIndex
        // If animRunning, ensure we progress to terms-1 sequentially
        for (let i = 0; i < squares.length; i++) {
          const sq = squares[i];
          // appearProgress: grows to 1 when square is added
          if (sq.appearProgress < 1) {
            // if its index > currentAnimatingIndex, don't animate
            if (i <= currentAnimatingIndex) {
              sq.appearProgress = Math.min(1, sq.appearProgress + (elapsed / stepDuration));
              needsRender = true;
            }
          }
          // arcProgress: starts after appearProgress reaches some threshold
          if (sq.appearProgress >= 0.6 && sq.arcProgress < 1) {
            sq.arcProgress = Math.min(1, sq.arcProgress + (elapsed / Math.max(80, stepDuration)));
            needsRender = true;
          }
        }

        // If animRunning, advance to next square when current square finished arcProgress
        if (animRunning) {
          const cur = currentAnimatingIndex;
          if (cur < squares.length - 1) {
            const current = squares[cur];
            if (current && current.arcProgress >= 1 - 1e-6) {
              // move to next
              currentAnimatingIndex++;
              lastStepAt = ts;
            }
          } else {
            // reached last index, stop animating auto-advancement
            animRunning = false;
            playBtn.setAttribute('aria-pressed', 'false');
            playBtn.textContent = 'Play';
          }
        }

        if (needsRender) render();
        rafId = requestAnimationFrame(animateLoop);
      }

      // Controls & state management
      function prepareState() {
        fibs = generateFibs(terms);
        termsLabel.textContent = terms;
        numTermsDisplay.textContent = terms;
        numTermsDisplay.setAttribute('aria-live', 'polite');
        // Build squares layout
        squares = buildSquares(fibs);
        // initialize progress states
        for (let i = 0; i < squares.length; i++) {
          squares[i].appearProgress = i === 0 ? 1 : 0; // show first immediately
          squares[i].arcProgress = i === 0 ? 1 : 0;
        }
        squares._bounds = squares._bounds || {minX:0,minY:0,maxX:1,maxY:1};
        currentAnimatingIndex = 0; // first considered "done" initially
        render();
        updateSequenceList();
        updateRatioLabel();
      }

      function updateSequenceList() {
        // Clear and write pills for each term. Highlight last one.
        sequenceList.innerHTML = '';
        for (let i = 0; i < fibs.length; i++) {
          const pill = document.createElement('div');
          pill.className = 'pill' + (i === fibs.length - 1 ? ' highlight' : '');
          pill.textContent = String(fibs[i]);
          pill.setAttribute('role','listitem');
          pill.setAttribute('aria-label','Term ' + (i+1) + ' : ' + fibs[i]);
          sequenceList.appendChild(pill);
        }
      }

      function updateRatioLabel() {
        const n = fibs.length;
        if (n >= 2) {
          const ratio = (fibs[n - 1] / fibs[n - 2]).toFixed(6);
          ratioLabel.textContent = ratio;
        } else {
          ratioLabel.textContent = '—';
        }
      }

      // Play/Pause toggling
      function togglePlay() {
        if (!animRunning) {
          // Start animation from currentAnimatingIndex+1 if possible
          animRunning = true;
          playBtn.setAttribute('aria-pressed', 'true');
          playBtn.textContent = 'Pause';
          // If last index already, start over
          if (currentAnimatingIndex >= squares.length - 1) {
            // reset progress of all beyond first
            for (let i = 1; i < squares.length; i++) {
              squares[i].appearProgress = 0;
              squares[i].arcProgress = 0;
            }
            currentAnimatingIndex = 0;
          }

          // Ensure RAF loop is running
          if (!rafId) rafId = requestAnimationFrame(animateLoop);
        } else {
          animRunning = false;
          playBtn.setAttribute('aria-pressed', 'false');
          playBtn.textContent = 'Play';
        }
      }

      // Step forward one square (manual)
      function stepForward() {
        // If at last index, do nothing
        if (!squares || squares.length === 0) return;
        if (currentAnimatingIndex >= squares.length - 1) return;
        // Move to next index and set appearProgress to small >0 to start animation
        currentAnimatingIndex++;
        const sq = squares[currentAnimatingIndex];
        sq.appearProgress = Math.max(sq.appearProgress, 0.03);
        sq.arcProgress = Math.max(sq.arcProgress, 0);
        // Render and start RAF if not running
        render();
        if (!rafId) rafId = requestAnimationFrame(animateLoop);
      }

      // Reset all except first
      function resetAll() {
        animRunning = false;
        playBtn.setAttribute('aria-pressed', 'false');
        playBtn.textContent = 'Play';
        for (let i = 1; i < squares.length; i++) {
          squares[i].appearProgress = 0;
          squares[i].arcProgress = 0;
        }
        currentAnimatingIndex = 0;
        render();
      }

      // Event wiring
      termRange.addEventListener('input', (e) => {
        terms = parseInt(e.target.value, 10);
        termRange.value = terms;
        termRange.setAttribute('aria-valuenow', terms);
        numTermsDisplay.textContent = terms;
        termsLabel.textContent = terms;
        prepareState();
      });

      speedSelect.addEventListener('change', (e) => {
        stepDuration = parseInt(e.target.value, 10);
      });

      playBtn.addEventListener('click', togglePlay);
      stepBtn.addEventListener('click', () => {
        animRunning = false;
        playBtn.setAttribute('aria-pressed', 'false');
        playBtn.textContent = 'Play';
        stepForward();
      });
      resetBtn.addEventListener('click', resetAll);

      toggleNumbers.addEventListener('change', () => render());
      toggleArcs.addEventListener('change', () => render());
      toggleFill.addEventListener('change', () => render());

      // Keyboard accessibility
      playBtn.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          togglePlay();
        }
      });
      document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 's') {
          stepBtn.click();
        }
      });

      // Initialize
      prepareState();
      // Kick off RAF loop even if idle to allow animations to run when triggered
      if (!rafId) rafId = requestAnimationFrame(animateLoop);

      // Clean up on page unload
      window.addEventListener('beforeunload', () => {
        if (rafId) cancelAnimationFrame(rafId);
      });

      // Expose a simple programmatic control for testing (not necessary in UI)
      window.__FIB_VIS = { restart: prepareState, render, getState: () => ({ terms, fibs }) };
    })();
  </script>
</body>
</html>