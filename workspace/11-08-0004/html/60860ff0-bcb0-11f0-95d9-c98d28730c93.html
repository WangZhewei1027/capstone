<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Red-Black Tree — Insertion Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-margin: 24px;
      --gap: 16px; /* minimum spacing between interactive elements */
      --bg: #0f1720;
      --panel: #0b1220;
      --card: #0e1624;
      --accent: #3b82f6;
      --muted: #9aa5b1;
      --node-size: 44px;
      --transition: 380ms ease;
    }

    html,body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg, #071021 0%, #071423 100%);
      color: #e6eef6;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    main {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100%;
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: var(--gap);
      align-items: start;
    }

    /* Left column: text + controls */
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 20px;
      box-sizing: border-box;
      min-height: 520px;
      box-shadow: 0 6px 24px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    }

    h1 {
      margin: 0 0 8px 0;
      font-size: 20px;
      line-height: 1.15;
    }
    .muted {
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 14px;
    }

    .objective {
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      padding: 12px;
      font-size: 14px;
      margin-bottom: 16px;
      color: #dbefff;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      margin-bottom: 12px;
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    label {
      font-size: 13px;
      color: var(--muted);
      width: 80px;
    }

    input[type="number"] {
      padding: 10px 12px;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.04);
      color: #e6eef6;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
      width: 160px;
    }
    input[type="number"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px rgba(59,130,246,0.08);
    }

    .button-row {
      display: flex;
      gap: 12px;
      margin-top: 6px;
      flex-wrap: wrap;
    }

    button {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      color: #e6eef6;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: background 180ms ease, transform 120ms ease;
    }
    button[aria-pressed="true"] {
      background: linear-gradient(180deg, rgba(59,130,246,0.16), rgba(59,130,246,0.08));
      border-color: rgba(59,130,246,0.6);
      color: white;
    }
    button:active { transform: translateY(1px); }

    .legend {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .legend .chip {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 13px;
      color: var(--muted);
    }

    .chip .dot {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      display: inline-block;
      border: 2px solid rgba(0,0,0,0.2);
    }

    .dot.red {
      background: #ef4444;
      box-shadow: 0 2px 6px rgba(239,68,68,0.22);
    }
    .dot.black {
      background: #0b0f12;
      border: 2px solid #cbd5e1;
      box-shadow: 0 2px 6px rgba(2,6,23,0.6);
    }

    .info {
      margin-top: 16px;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.4;
    }

    .stepbox {
      margin-top: 14px;
      background: rgba(255,255,255,0.01);
      padding: 12px;
      border-radius: 8px;
      min-height: 62px;
      font-size: 14px;
      color: #dbefff;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    /* Right column: visualization */
    .canvas {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius: 12px;
      padding: 16px;
      box-sizing: border-box;
      min-height: 520px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: hidden;
    }

    .canvas-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    .canvas .small {
      font-size: 13px;
      color: var(--muted);
    }

    .svg-wrap {
      background: rgba(255,255,255,0.01);
      border-radius: 10px;
      flex: 1 1 auto;
      min-height: 420px;
      position: relative;
      overflow: auto;
      padding: 12px;
    }

    svg {
      width: 100%;
      height: 100%;
      min-height: 380px;
    }

    /* Node styles */
    .node {
      cursor: default;
      transition: transform var(--transition), opacity var(--transition);
      will-change: transform, opacity;
    }

    .node circle {
      r: calc(var(--node-size) / 2);
      fill: #000;
      stroke: rgba(255,255,255,0.06);
      stroke-width: 2px;
      transition: fill var(--transition), stroke var(--transition);
    }

    .node .label {
      fill: white;
      font-weight: 600;
      font-size: 14px;
      text-anchor: middle;
      dominant-baseline: central;
      pointer-events: none;
    }

    .node.red circle {
      fill: #ef4444;
      stroke: rgba(20,20,20,0.4);
      filter: drop-shadow(0 6px 14px rgba(239,68,68,0.18));
    }
    .node.black circle {
      fill: #0b0f12;
      stroke: #d1d8e4;
      filter: drop-shadow(0 6px 18px rgba(0,0,0,0.6));
    }

    .edge {
      stroke: rgba(200,215,235,0.16);
      stroke-width: 2px;
      transition: stroke var(--transition), opacity var(--transition);
    }

    .highlight {
      outline: 3px solid rgba(59,130,246,0.12);
      border-radius: 999px;
      box-shadow: 0 6px 22px rgba(59,130,246,0.12);
    }

    .badge {
      background: rgba(255,255,255,0.02);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 13px;
      color: #dbefff;
      border: 1px solid rgba(255,255,255,0.03);
    }

    /* Responsive adjustments */
    @media (max-width: 880px) {
      main {
        grid-template-columns: 1fr;
      }
      .panel { order: 2; }
      .canvas { order: 1; min-height: 520px; }
    }
  </style>
</head>
<body>
  <main>
    <section class="panel" aria-labelledby="title">
      <h1 id="title">Red‑Black Tree — Insertion (Fix‑Up)</h1>
      <div class="muted">Interactive step‑through visualization of a single concept: how insertion keeps Red‑Black Tree properties intact using recoloring and rotations.</div>

      <div class="objective" role="region" aria-label="Learning objective">
        Learning objective: After using this module you will be able to follow each step of the Red‑Black Tree insertion algorithm, recognize the three classic fix‑up cases (recolor, rotate, recolor+rotate), and see how rotations and recoloring restore the tree's invariants.
      </div>

      <div class="controls" role="group" aria-label="Controls">
        <div class="row" style="align-items:center;">
          <label for="keyInput">Insert key</label>
          <input id="keyInput" type="number" aria-label="Value to insert" placeholder="e.g. 42" />
        </div>

        <div class="button-row">
          <button id="insertBtn" title="Insert the value and record the steps">Insert</button>
          <button id="nextBtn" title="Step forward to next recorded state">Next →</button>
          <button id="prevBtn" title="Step backward">← Prev</button>
          <button id="playBtn" aria-pressed="false" title="Auto-play the recorded steps">Play</button>
          <button id="resetBtn" title="Clear the tree and recorded steps">Reset</button>
        </div>

        <div class="row" style="margin-top: 6px;">
          <label style="width:auto;">Speed</label>
          <input id="speed" type="range" min="200" max="1500" step="50" value="700" aria-label="Playback speed" style="flex:1" />
        </div>

        <div class="legend" aria-hidden="false" style="margin-top:8px;">
          <div class="chip"><span class="dot red" aria-hidden="true"></span> Red node</div>
          <div class="chip"><span class="dot black" aria-hidden="true"></span> Black node</div>
          <div class="chip"><span class="dot" style="width:8px;height:8px;background:transparent;border-radius:0;display:inline-block"></span> <span class="muted">Edges connect parents to children</span></div>
        </div>

        <div class="info" aria-live="polite" id="helpText">
          Interaction: type a numeric key and press Insert (or Enter). The module records the insertion and the subsequent fix-up steps. Use Next/Prev to step through each recorded state. Play animates them automatically. Reset clears the tree.
        </div>

        <div class="stepbox" id="actionBox" aria-live="assertive">
          Ready. No recorded steps yet.
        </div>
      </div>
    </section>

    <section class="canvas" aria-label="Visualization area">
      <div class="canvas-header">
        <div class="small">Red‑Black Tree — Insertion visualizer</div>
        <div class="badge" id="nodeCount">Nodes: 0</div>
      </div>

      <div class="svg-wrap" role="img" aria-label="Red black tree visualization">
        <svg id="svgRoot" viewBox="0 0 1200 600" preserveAspectRatio="xMidYMin meet" tabindex="0">
          <!-- Edges and nodes will be injected here -->
        </svg>
      </div>
    </section>
  </main>

  <script>
    /*
      Red-Black Tree Insertion Visualizer
      - Single concept: insertion + fix-up
      - Records a sequence of snapshots (states) with annotations so user can step through
      - Pure vanilla JS + SVG, no external libs
    */

    /***********************
     * Data structures
     ***********************/
    let nodeIdCounter = 1;

    function createNode(key) {
      return {
        id: 'n' + (nodeIdCounter++),
        key: Number(key),
        color: 'red', // newly inserted nodes start red
        left: null,
        right: null,
        parent: null
      };
    }

    // Root reference
    let root = null;

    // Recorded snapshots for playback
    const snapshots = [];
    let currentStep = -1;
    let playing = false;
    let playTimer = null;

    // UI elements
    const svg = document.getElementById('svgRoot');
    const insertBtn = document.getElementById('insertBtn');
    const nextBtn = document.getElementById('nextBtn');
    const prevBtn = document.getElementById('prevBtn');
    const resetBtn = document.getElementById('resetBtn');
    const playBtn = document.getElementById('playBtn');
    const keyInput = document.getElementById('keyInput');
    const actionBox = document.getElementById('actionBox');
    const nodeCountBadge = document.getElementById('nodeCount');
    const speedInput = document.getElementById('speed');

    // Accessibility: Enter triggers insert
    keyInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        insertBtn.click();
      }
    });

    /***********************
     * RB-Tree core + instrumentation
     ***********************/

    // Utility: clone tree into a serializable snapshot
    function captureSnapshot(stepText, highlights = []) {
      // produce a map of nodeId -> {id,key,color,left,right,parent}
      const map = {};
      function dfs(n) {
        if (!n) return null;
        map[n.id] = {
          id: n.id,
          key: n.key,
          color: n.color,
          left: n.left ? n.left.id : null,
          right: n.right ? n.right.id : null,
          parent: n.parent ? n.parent.id : null
        };
        if (n.left) dfs(n.left);
        if (n.right) dfs(n.right);
      }
      dfs(root);
      snapshots.push({
        map: map,
        text: stepText,
        highlights: highlights.slice()
      });
      updateUIControls();
    }

    // Standard BST insert (non-unique keys? We'll treat as <= goes left)
    function bstInsert(z) {
      let y = null;
      let x = root;
      while (x !== null) {
        y = x;
        if (z.key <= x.key) x = x.left;
        else x = x.right;
      }
      z.parent = y;
      if (y === null) {
        root = z;
      } else if (z.key <= y.key) {
        y.left = z;
      } else {
        y.right = z;
      }
    }

    // Left rotate at node x
    function leftRotate(x) {
      const y = x.right;
      if (!y) return;
      x.right = y.left;
      if (y.left) y.left.parent = x;
      y.parent = x.parent;
      if (!x.parent) {
        root = y;
      } else if (x === x.parent.left) {
        x.parent.left = y;
      } else {
        x.parent.right = y;
      }
      y.left = x;
      x.parent = y;
    }

    // Right rotate at node x
    function rightRotate(x) {
      const y = x.left;
      if (!y) return;
      x.left = y.right;
      if (y.right) y.right.parent = x;
      y.parent = x.parent;
      if (!x.parent) {
        root = y;
      } else if (x === x.parent.right) {
        x.parent.right = y;
      } else {
        x.parent.left = y;
      }
      y.right = x;
      x.parent = y;
    }

    // RB insert with recording of steps for visual explanation
    function rbInsert(key) {
      const z = createNode(key);
      // Step: starting insertion (node created)
      captureSnapshot(`Create node ${z.key} (red). Will be inserted into BST.`, [z.id]);

      // BST insert
      bstInsert(z);
      captureSnapshot(`Insert ${z.key} as in a BST.`, [z.id, z.parent ? z.parent.id : null].filter(Boolean));

      // Fix-up to restore RB properties
      fixInsert(z);
      // After fix, root must be black
      root.color = 'black';
      captureSnapshot(`Finished. Root is black.`, [root ? root.id : null].filter(Boolean));
    }

    function fixInsert(z) {
      // We'll follow CLRS pseudocode and record each important action.
      while (z.parent && z.parent.color === 'red') {
        const p = z.parent;
        const g = p.parent;
        if (!g) break; // should not happen if tree properties maintained
        if (p === g.left) {
          const y = g.right; // uncle
          if (y && y.color === 'red') {
            // Case 1: recolor parent and uncle black, grandparent red; move z up
            p.color = 'black';
            y.color = 'black';
            g.color = 'red';
            captureSnapshot(`Case 1: Parent ${p.key} and Uncle ${y.key} are red -> recolor them black and Grandparent ${g.key} red. Move up to ${g.key}.`, [p.id, y.id, g.id]);
            z = g;
          } else {
            if (z === p.right) {
              // Case 2: left-rotate at parent to convert to case 3
              captureSnapshot(`Case 2: Node ${z.key} is right child. Left-rotate at Parent ${p.key} to prepare for Case 3.`, [z.id, p.id, g.id]);
              leftRotate(p);
              captureSnapshot(`After left-rotate at ${p.key}.`, [z.id, p.id, g.id]);
              z = p;
              // update references
            }
            // Case 3:
            p.color = 'black';
            g.color = 'red';
            captureSnapshot(`Case 3: Right-rotate at Grandparent ${g.key}. Parent ${p.key} -> black, Grandparent ${g.key} -> red.`, [p.id, g.id]);
            rightRotate(g);
          }
        } else {
          // symmetric: parent is right child
          const y = g.left; // uncle
          if (y && y.color === 'red') {
            // Case 1 mirror
            p.color = 'black';
            y.color = 'black';
            g.color = 'red';
            captureSnapshot(`Case 1 (mirror): Parent ${p.key} and Uncle ${y.key} red -> recolor them black and Grandparent ${g.key} red. Move up to ${g.key}.`, [p.id, y.id, g.id]);
            z = g;
          } else {
            if (z === p.left) {
              // Case 2 mirror
              captureSnapshot(`Case 2 (mirror): Node ${z.key} is left child. Right-rotate at Parent ${p.key} to prepare for Case 3.`, [z.id, p.id, g.id]);
              rightRotate(p);
              captureSnapshot(`After right-rotate at ${p.key}.`, [z.id, p.id, g.id]);
              z = p;
            }
            // Case 3 mirror
            p.color = 'black';
            g.color = 'red';
            captureSnapshot(`Case 3 (mirror): Left-rotate at Grandparent ${g.key}. Parent ${p.key} -> black, Grandparent ${g.key} -> red.`, [p.id, g.id]);
            leftRotate(g);
          }
        }
      }
    }

    /***********************
     * Rendering
     ***********************/

    // Render current snapshot index (or latest if index omitted)
    function renderStep(index = currentStep) {
      if (index < 0 || index >= snapshots.length) return;
      const snap = snapshots[index];
      actionBox.textContent = snap.text || '';
      // Build nodes from snap.map
      const nodesMap = {};
      Object.values(snap.map).forEach(n => {
        nodesMap[n.id] = {
          id: n.id,
          key: n.key,
          color: n.color,
          left: n.left,
          right: n.right,
          parent: n.parent
        };
      });

      // Build a tree structure from root (find node without parent)
      let rootId = null;
      for (const id in nodesMap) {
        if (!nodesMap[id].parent) {
          rootId = id;
          break;
        }
      }

      // Compute layout: x positions via in-order order, y by depth
      const positions = {};
      let cursorX = 50; // start margin
      const levelHeight = 90;
      const nodeSize = 44;
      function layout(id, depth) {
        if (!id) return;
        const n = nodesMap[id];
        if (n.left) layout(n.left, depth + 1);
        // assign position
        const x = cursorX;
        const y = 30 + depth * levelHeight;
        positions[id] = { x, y };
        cursorX += 100; // horizontal spacing between nodes
        if (n.right) layout(n.right, depth + 1);
      }
      if (rootId) layout(rootId, 0);

      // Adjust viewbox width as needed
      const minW = Math.max(1200, cursorX + 80);
      svg.setAttribute('viewBox', `0 0 ${minW} 600`);

      // Clear existing
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      // Draw edges first
      for (const id in nodesMap) {
        const n = nodesMap[id];
        if (n.left) {
          const p = positions[id];
          const c = positions[n.left];
          if (p && c) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', p.x);
            line.setAttribute('y1', p.y + 22);
            line.setAttribute('x2', c.x);
            line.setAttribute('y2', c.y - 22);
            line.setAttribute('class', 'edge');
            svg.appendChild(line);
          }
        }
        if (n.right) {
          const p = positions[id];
          const c = positions[n.right];
          if (p && c) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', p.x);
            line.setAttribute('y1', p.y + 22);
            line.setAttribute('x2', c.x);
            line.setAttribute('y2', c.y - 22);
            line.setAttribute('class', 'edge');
            svg.appendChild(line);
          }
        }
      }

      // Draw nodes
      for (const id in nodesMap) {
        const n = nodesMap[id];
        const pos = positions[id] || { x: 60, y: 40 };
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);
        g.setAttribute('class', `node ${n.color}`);
        g.setAttribute('data-id', id);
        g.setAttribute('role', 'treeitem');
        g.setAttribute('aria-label', `${n.key} ${n.color} node`);

        // highlight if in snapshot highlights
        if (snap.highlights.includes(id)) {
          // add subtle halo circle behind
          const halo = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          halo.setAttribute('r', 28);
          halo.setAttribute('fill', 'none');
          halo.setAttribute('stroke', 'rgba(59,130,246,0.22)');
          halo.setAttribute('stroke-width', 10);
          halo.setAttribute('opacity', '0.24');
          g.appendChild(halo);
        }

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('r', 22);
        g.appendChild(circle);

        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('class', 'label');
        text.setAttribute('dy', '0.35em');
        text.textContent = n.key;
        g.appendChild(text);

        svg.appendChild(g);
      }

      // Update node count
      nodeCountBadge.textContent = `Nodes: ${Object.keys(nodesMap).length || 0}`;
    }

    /***********************
     * Control logic
     ***********************/
    function clearSnapshots() {
      snapshots.length = 0;
      currentStep = -1;
      playing = false;
      if (playTimer) {
        clearTimeout(playTimer);
        playTimer = null;
      }
      playBtn.setAttribute('aria-pressed', 'false');
      updateUIControls();
    }

    function updateUIControls() {
      // enable/disable based on snapshots
      nextBtn.disabled = currentStep >= snapshots.length - 1;
      prevBtn.disabled = currentStep <= 0;
      insertBtn.disabled = false;
      resetBtn.disabled = false;
    }

    function goToStep(i) {
      if (i < 0) i = 0;
      if (i >= snapshots.length) i = snapshots.length - 1;
      if (i < 0 || i >= snapshots.length) return;
      currentStep = i;
      renderStep(currentStep);
      // update prev/next disabled states
      prevBtn.disabled = currentStep <= 0;
      nextBtn.disabled = currentStep >= snapshots.length - 1;
    }

    insertBtn.addEventListener('click', () => {
      const val = keyInput.value;
      if (val === '' || isNaN(Number(val))) {
        actionBox.textContent = 'Please enter a numeric key to insert.';
        keyInput.focus();
        return;
      }
      // Insert and record
      rbInsert(Number(val));
      // After insertion, go to first step of the newly recorded sequence
      if (snapshots.length > 0) {
        goToStep(snapshots.length - 1); // show finish state
      }
      // After contributing snapshots, step back to the first of the insertion sequence
      // But to be simple, show the last step and user can step back
      actionBox.textContent = 'Insertion recorded. Use Next/Prev to step through recorded states.';
      keyInput.value = '';
      keyInput.focus();
    });

    nextBtn.addEventListener('click', () => {
      if (currentStep < snapshots.length - 1) {
        goToStep(currentStep + 1);
      }
    });

    prevBtn.addEventListener('click', () => {
      if (currentStep > 0) {
        goToStep(currentStep - 1);
      }
    });

    resetBtn.addEventListener('click', () => {
      // clear tree and snapshots
      root = null;
      nodeIdCounter = 1;
      clearSnapshots();
      // empty svg
      while (svg.firstChild) svg.removeChild(svg.firstChild);
      nodeCountBadge.textContent = 'Nodes: 0';
      actionBox.textContent = 'Tree cleared.';
    });

    playBtn.addEventListener('click', () => {
      if (playing) {
        stopPlaying();
      } else {
        startPlaying();
      }
    });

    function startPlaying() {
      if (snapshots.length === 0) return;
      playing = true;
      playBtn.setAttribute('aria-pressed', 'true');
      // start from beginning if at end
      if (currentStep >= snapshots.length - 1) currentStep = -1;
      scheduleNext();
    }

    function stopPlaying() {
      playing = false;
      playBtn.setAttribute('aria-pressed', 'false');
      if (playTimer) {
        clearTimeout(playTimer);
        playTimer = null;
      }
    }

    function scheduleNext() {
      if (!playing) return;
      const delay = Number(speedInput.value) || 700;
      playTimer = setTimeout(() => {
        if (currentStep < snapshots.length - 1) {
          goToStep(currentStep + 1);
          scheduleNext();
        } else {
          stopPlaying();
        }
      }, delay);
    }

    // Initialize empty tree message
    actionBox.textContent = 'Ready. Enter a numeric key and press Insert to start.';

    // Basic keyboard focus for svg to allow arrow keys to navigate steps
    svg.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') nextBtn.click();
      if (e.key === 'ArrowLeft') prevBtn.click();
      if (e.key === ' ') {
        e.preventDefault();
        playBtn.click();
      }
    });

    // Make sure focusable
    svg.tabIndex = 0;

    // Initialize: empty svg with helper text
    (function drawEmptyHint() {
      const hintGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      hintGroup.setAttribute('transform', 'translate(300,160)');
      const t1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      t1.setAttribute('fill', '#9aa5b1');
      t1.setAttribute('font-size', '18');
      t1.setAttribute('font-weight', '600');
      t1.textContent = 'Tree visualization area';
      hintGroup.appendChild(t1);

      const t2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      t2.setAttribute('fill', '#8a98a8');
      t2.setAttribute('font-size', '13');
      t2.setAttribute('dy', '24');
      t2.textContent = 'Insert keys to record insertion + fix-up steps.';
      hintGroup.appendChild(t2);

      svg.appendChild(hintGroup);
    })();

    // Expose some helpers for debugging (console)
    window._rbvis = {
      snapshots,
      root,
      createNode,
      rbInsert,
      snapshotsDump: () => snapshots.map((s, i) => `${i}: ${s.text}`).join('\\n')
    };
  </script>
</body>
</html>