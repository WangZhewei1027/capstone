<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sliding Window — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --card: #071026;
      --success: #10b981;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.03);
      --radius: 12px;
      --transition: 300ms cubic-bezier(.22,.9,.2,1);
    }

    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #071224 0%, #081726 100%);
      color: #e6eef6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .app{
      padding: var(--safe-margin);
      min-height:100vh;
      box-sizing:border-box;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      gap: var(--gap);
    }

    .container{
      width: 1200px;
      max-width: calc(100% - (var(--safe-margin) * 2));
      box-sizing:border-box;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap: var(--gap);
      align-items:start;
    }

    /* Responsive: stack */
    @media (max-width:900px){
      .container{
        grid-template-columns: 1fr;
      }
    }

    /* Left column (explanations & controls) */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      min-height: 220px;
    }

    h1{
      margin:0 0 8px 0;
      font-size:20px;
      letter-spacing: -0.2px;
    }
    .muted{
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 12px;
    }

    .section{
      margin-bottom: 18px;
    }

    label{
      font-size:13px;
      color: #cfe8f3;
      display:block;
      margin-bottom:8px;
    }

    .controls{
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    .row{
      display:flex;
      gap: var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }

    input[type="text"], input[type="number"], select{
      width:100%;
      padding:10px 12px;
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.04);
      color:inherit;
      border-radius:10px;
      outline:none;
      transition: box-shadow var(--transition);
      box-sizing:border-box;
    }

    input[type="range"]{
      width:100%;
    }

    .btnrow{
      display:flex;
      gap: var(--gap);
      align-items:center;
      margin-top:6px;
      flex-wrap:wrap;
    }

    button{
      background:linear-gradient(180deg,#0ea5b780,#06b6d4);
      color:#042024;
      border:none;
      padding:10px 14px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      transition: transform var(--transition), box-shadow var(--transition);
      box-shadow: 0 6px 18px rgba(6,182,212,0.12);
      min-height:40px;
    }
    button.secondary{
      background:transparent;
      color:var(--accent);
      border:1px solid rgba(6,182,212,0.12);
      box-shadow:none;
    }
    button:active{ transform: translateY(1px) }

    .small{
      padding:8px 10px;
      font-size:14px;
      border-radius:8px;
    }

    /* Right column: visualization */
    .vis{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding:20px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }

    .vis-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: var(--gap);
      margin-bottom:14px;
      flex-wrap:wrap;
    }

    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .badge{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 8px;
      background: rgba(255,255,255,0.02);
      border-radius:8px;
      font-size:13px;
    }
    .dot{
      width:12px;
      height:12px;
      border-radius:3px;
    }
    .dot.window{ background: linear-gradient(180deg,#064e57,#06b6d4); }
    .dot.enter{ background: var(--success); }
    .dot.leave{ background: var(--danger); }

    /* array area */
    .array-wrap{
      padding:12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      border-radius:10px;
      position:relative;
      overflow:hidden;
      min-height:120px;
    }

    .array{
      display:flex;
      gap:12px;
      padding:12px;
      align-items:end;
      justify-content:flex-start;
      overflow:auto;
      box-sizing:border-box;
      min-height:80px;
    }

    .cell{
      min-width:56px;
      width:56px;
      background: linear-gradient(180deg,#07182a,#052034);
      border-radius:8px;
      padding:8px;
      color: #dff7fb;
      text-align:center;
      box-shadow: 0 4px 10px rgba(2,6,23,0.5);
      position:relative;
      cursor:default;
      user-select:none;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
    }

    .cell .val{
      font-weight:700;
      font-size:16px;
    }

    .cell .bar{
      width:100%;
      background: rgba(255,255,255,0.03);
      border-radius:4px;
      height:40px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      overflow:hidden;
      position:relative;
    }

    .bar .fill{
      width:100%;
      background: linear-gradient(180deg,#06b6d4,#02828f);
      border-radius:4px 4px 0 0;
      transition: height var(--transition);
      height:10%;
    }

    /* overlay window */
    .window-overlay{
      position:absolute;
      top:0;
      left:0;
      height:100%;
      border-radius:8px;
      pointer-events:auto;
      box-shadow: 0 8px 28px rgba(6,182,212,0.12);
      transition: transform var(--transition), width var(--transition), left var(--transition);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .window-overlay .label{
      background: rgba(3,10,16,0.72);
      padding:6px 10px;
      border-radius:8px;
      color:var(--accent);
      font-weight:700;
      font-size:13px;
      border: 1px solid rgba(6,182,212,0.08);
      box-shadow: 0 6px 18px rgba(2,6,23,0.45);
    }

    /* highlight entering/leaving */
    .entering{
      animation: pulseEnter 700ms ease;
      box-shadow: 0 6px 18px rgba(16,185,129,0.12);
      outline: 2px solid rgba(16,185,129,0.12);
    }
    .leaving{
      animation: pulseLeave 700ms ease;
      box-shadow: 0 6px 18px rgba(239,68,68,0.12);
      outline: 2px solid rgba(239,68,68,0.12);
    }
    @keyframes pulseEnter{
      0%{ transform: translateY(0) scale(1) }
      50%{ transform: translateY(-6px) scale(1.03) }
      100%{ transform: translateY(0) scale(1) }
    }
    @keyframes pulseLeave{
      0%{ transform: translateY(0) scale(1) }
      50%{ transform: translateY(4px) scale(0.99) rotate(-1deg) }
      100%{ transform: translateY(0) scale(1) }
    }

    /* details panel */
    .details{
      margin-top:12px;
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .card{
      background: rgba(255,255,255,0.02);
      padding:12px;
      border-radius:10px;
      min-width:160px;
    }
    .card strong{ display:block; font-size:13px; margin-bottom:6px; color:#cfe8f3 }

    /* explanation text that updates */
    .explain{
      margin-top:12px;
      background: rgba(255,255,255,0.015);
      padding:12px;
      border-radius:10px;
      font-size:14px;
      color:var(--muted);
      line-height:1.4;
    }

    /* small footer note */
    .note{
      font-size:13px;
      color:var(--muted);
      margin-top:10px;
    }

    /* ensure interactive elements spacing minimum */
    .controls > * { margin-bottom: 0; }

    /* focus outlines for accessibility */
    button:focus, input:focus, select:focus { box-shadow: 0 0 0 4px rgba(6,182,212,0.08); outline:none; border-color: rgba(6,182,212,0.18) }

  </style>
</head>
<body>
  <div class="app" role="main">
    <div class="container" >
      <!-- Left column: Title, Objectives, Controls, Interaction & Layout description -->
      <aside class="panel" aria-labelledby="title">
        <h1 id="title">Sliding Window — Live Exploration</h1>
        <div class="muted">Understand how to maintain running results efficiently as a fixed-size window moves through a list.</div>

        <div class="section">
          <label>Learning Objective</label>
          <div class="muted" style="font-size:14px">
            After interacting you'll understand how to compute aggregated values (sum, max, min, average) over every contiguous window of fixed size in O(n) time using incremental updates, and you'll visually see which elements enter and leave the window.
          </div>
        </div>

        <div class="section controls" aria-label="Controls">
          <div>
            <label for="arrayInput">Array (comma-separated numbers)</label>
            <input id="arrayInput" type="text" aria-label="Array input" value="2,5,1,8,4,3,7,2,6" />
            <div class="note" style="margin-top:8px">Tip: press Enter or click Apply to update the visualization.</div>
          </div>

          <div>
            <label for="windowSize">Window size: <span id="windowSizeLabel">3</span></label>
            <input id="windowSize" type="range" min="1" max="9" value="3" aria-label="Window size slider" />
          </div>

          <div>
            <label for="agg">Aggregation</label>
            <select id="agg" aria-label="Aggregation method">
              <option value="sum">Sum</option>
              <option value="max">Max</option>
              <option value="min">Min</option>
              <option value="avg">Average</option>
            </select>
          </div>

          <div class="row btnrow" role="group" aria-label="Play controls">
            <button id="prevBtn" class="small secondary" aria-label="Previous window">◀ Prev</button>
            <button id="playBtn" class="small" aria-pressed="false" aria-label="Play">Play ▶</button>
            <button id="nextBtn" class="small secondary" aria-label="Next window">Next ▶</button>
            <button id="resetBtn" class="small secondary" aria-label="Reset">Reset</button>
            <button id="applyBtn" class="small" aria-label="Apply array">Apply</button>
          </div>

          <div>
            <label for="speed">Speed (ms per step)</label>
            <input id="speed" type="range" min="150" max="1500" step="50" value="600" aria-label="Playback speed" />
          </div>

          <div class="note">Keyboard: Left/Right arrows step windows; Space toggles play/pause. Drag the highlighted window to snap it to an index.</div>
        </div>

        <div class="section">
          <label>Interaction Design</label>
          <div class="muted" style="font-size:13px; line-height:1.4">
            - Edit the array and press Apply (or Enter) to render. Use the Window size slider to choose k. Select aggregation (sum, max, min, average).<br>
            - Click Play to animate the window sliding from left to right. The overlay moves with a smooth transition; entering elements flash green, leaving elements flash red; the aggregated value updates live.<br>
            - Use Prev/Next or Left/Right arrow keys to step manually. Drag the semi-transparent window overlay horizontally to reposition — it snaps to the nearest index on release and updates the computation.<br>
            - A compact explanation box narrates each step (initial compute vs incremental update) and an operation-count comparison shows how many operations a naive algorithm would perform vs the sliding-window incremental approach.
          </div>
        </div>

        <div class="section">
          <label>Layout Description</label>
          <div class="muted" style="font-size:13px; line-height:1.4">
            - The panel is organized into two primary columns: left column (this panel) contains title, objectives, and all controls; right column contains the visualization area (array, moving window, details, and explanation).<br>
            - Safe area margins: 24px on all sides are respected by container padding. Minimum spacing between interactive elements is 16px (CSS gap values).<br>
            - Accessibility: controls include labels and ARIA attributes; keyboard shortcuts (Left/Right/Space) are supported. Responsive: columns stack on narrow viewports with controls above the visualization.
          </div>
        </div>

      </aside>

      <!-- Right column: interactive visualization -->
      <main class="vis" aria-live="polite">
        <div class="vis-header">
          <div>
            <div style="font-weight:700; font-size:16px">Array Visualization</div>
            <div class="muted" style="font-size:13px">Move the window to see how incremental updates reduce work.</div>
          </div>
          <div class="legend" aria-hidden="true">
            <div class="badge"><span class="dot window"></span> Window</div>
            <div class="badge"><span class="dot enter"></span> Enter</div>
            <div class="badge"><span class="dot leave"></span> Leave</div>
          </div>
        </div>

        <div class="array-wrap" id="arrayWrap">
          <div class="array" id="array" tabindex="0" aria-label="Array of numbers">
            <!-- cells inserted here -->
          </div>

          <!-- overlay window -->
          <div class="window-overlay" id="windowOverlay" role="slider" aria-label="Sliding window" aria-valuemin="0" aria-valuemax="8" aria-valuenow="0" draggable="false" style="display:none;">
            <div class="label" id="overlayLabel">k=3 • i=0</div>
          </div>
        </div>

        <div class="details" aria-hidden="false">
          <div class="card" id="resultCard" aria-live="polite">
            <strong>Current result</strong>
            <div id="currentResult" style="font-size:18px">–</div>
            <div style="font-size:13px;color:var(--muted);margin-top:6px" id="indices">Indices: –</div>
          </div>
          <div class="card">
            <strong>Operation counts</strong>
            <div style="font-size:14px" id="opCounts">Naive: – | Sliding: –</div>
            <div style="font-size:12px;color:var(--muted);margin-top:6px">Naive does k ops per position; sliding does constant work per slide.</div>
          </div>
          <div class="card">
            <strong>Step</strong>
            <div id="stepLabel" style="font-size:14px;color:var(--muted)">–</div>
          </div>
        </div>

        <div class="explain" id="explainText">
          Instructions and step narration will appear here as you interact.
        </div>

      </main>
    </div>
  </div>

  <script>
    // Sliding Window Interactive Module
    (function(){
      // DOM elements
      const arrayInput = document.getElementById('arrayInput');
      const applyBtn = document.getElementById('applyBtn');
      const windowRange = document.getElementById('windowSize');
      const windowSizeLabel = document.getElementById('windowSizeLabel');
      const aggSelect = document.getElementById('agg');
      const arrayEl = document.getElementById('array');
      const overlay = document.getElementById('windowOverlay');
      const overlayLabel = document.getElementById('overlayLabel');
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      const playBtn = document.getElementById('playBtn');
      const resetBtn = document.getElementById('resetBtn');
      const currentResultEl = document.getElementById('currentResult');
      const indicesEl = document.getElementById('indices');
      const opCountsEl = document.getElementById('opCounts');
      const stepLabel = document.getElementById('stepLabel');
      const explainText = document.getElementById('explainText');
      const speedRange = document.getElementById('speed');

      // state
      let arr = [];
      let k = parseInt(windowRange.value,10) || 3;
      let agg = aggSelect.value;
      let i = 0; // current window start index
      let playing = false;
      let timer = null;
      let speed = parseInt(speedRange.value,10) || 600;

      // sliding computation state
      let currentValue = null;
      let prevWindowSum = null;
      let naiveOps = 0;
      let slidingOps = 0;

      // initialization
      function parseArray(str){
        if(!str) return [];
        return str.split(',')
          .map(s=>s.trim())
          .filter(s=>s.length>0)
          .map(s=>Number(s))
          .filter(x=>!Number.isNaN(x));
      }

      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

      function renderArray(){
        arrayEl.innerHTML = '';
        const max = Math.max(1, ...arr.map(Math.abs));
        arr.forEach((val, idx) => {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.setAttribute('data-idx', idx);
          cell.setAttribute('role','group');
          cell.setAttribute('aria-label', `Index ${idx}, value ${val}`);
          const valEl = document.createElement('div');
          valEl.className = 'val';
          valEl.textContent = val;

          const bar = document.createElement('div');
          bar.className = 'bar';
          const fill = document.createElement('div');
          fill.className = 'fill';
          const heightPct = Math.max(6, Math.round( (Math.abs(val) / max) * 100 ));
          fill.style.height = heightPct + '%';
          bar.appendChild(fill);

          cell.appendChild(bar);
          cell.appendChild(valEl);
          arrayEl.appendChild(cell);
        });

        // update range max
        windowRange.max = Math.max(1, arr.length);
        if(k > arr.length) k = arr.length;
        windowRange.value = k;
        windowSizeLabel.textContent = k;

        // show/hide overlay based on array length
        if(arr.length === 0){
          overlay.style.display = 'none';
        } else {
          overlay.style.display = 'flex';
        }

        // update overlay attributes for accessibility
        overlay.setAttribute('aria-valuemax', Math.max(0, arr.length - Math.max(1,k)));
      }

      function computeInitial(){
        // naive total operations for full sweep: (arr.length - k + 1) * k
        const positions = Math.max(0, arr.length - k + 1);
        naiveOps = positions * k;
        slidingOps = 0;

        if(positions <= 0){
          currentValue = null;
          prevWindowSum = null;
          i = 0;
          updateUI();
          explainText.textContent = "Window size is larger than array length — no windows to compute.";
          return;
        }

        // compute first window according to aggregation
        const firstWindow = arr.slice(0,k);
        slidingOps += firstWindow.length; // cost to compute initial window
        if(agg === 'sum' || agg === 'avg'){
          const s = firstWindow.reduce((a,b)=>a+b,0);
          currentValue = (agg === 'sum') ? s : (s / k);
          prevWindowSum = s; // keep sum to compute avg later
          stepLabel.textContent = 'Initial compute: summed k elements';
          explainText.textContent = `Initial window [0..${k-1}] computed by summing its ${k} elements. Sliding window will then update in O(1) per step.`;
        } else if(agg === 'max'){
          const m = Math.max(...firstWindow);
          currentValue = m;
          prevWindowSum = null;
          stepLabel.textContent = 'Initial compute: scanned k elements for max';
          explainText.textContent = `Initial window [0..${k-1}] computed by scanning ${k} elements to find the max. For max/min, a common extension is to use a deque to maintain O(1) amortized updates; this demo shows naive incremental updates (recompute when necessary).`;
        } else if(agg === 'min'){
          const m = Math.min(...firstWindow);
          currentValue = m;
          prevWindowSum = null;
          stepLabel.textContent = 'Initial compute: scanned k elements for min';
          explainText.textContent = `Initial window [0..${k-1}] computed by scanning ${k} elements to find the min.`;
        }

        i = 0;
        updateUI();
      }

      function updateUI(highlightEntering=null, highlightLeaving=null){
        // reposition overlay
        if(arr.length === 0){
          overlay.style.display = 'none';
          return;
        }
        overlay.style.display = 'flex';
        // compute left and width relative to array container
        const cells = Array.from(arrayEl.querySelectorAll('.cell'));
        if(cells.length === 0) return;
        const firstCell = cells[0];
        const containerRect = arrayEl.getBoundingClientRect();
        const startIdx = clamp(i, 0, Math.max(0, arr.length - k));
        let left = 0;
        let width = 0;
        // compute position using offsetLeft of start and end cells relative to arrayEl
        const startCell = cells[startIdx];
        const endCell = cells[Math.min(startIdx + k - 1, cells.length -1)];
        const startRect = startCell.getBoundingClientRect();
        const endRect = endCell.getBoundingClientRect();
        left = startCell.offsetLeft - arrayEl.scrollLeft;
        width = (endCell.offsetLeft - startCell.offsetLeft) + endCell.offsetWidth;

        // set overlay transform (use left relative to arrayWrap)
        const wrapRect = arrayEl.getBoundingClientRect();
        overlay.style.width = width + 'px';
        overlay.style.left = (startCell.offsetLeft) + 'px';

        // update label
        overlayLabel.textContent = `k=${k} • i=${startIdx}`;
        overlay.setAttribute('aria-valuenow', startIdx);

        // update cell highlights
        cells.forEach(c=>{
          c.classList.remove('entering','leaving','in-window');
        });
        for(let idx = startIdx; idx < startIdx + k && idx < cells.length; idx++){
          cells[idx].classList.add('in-window');
        }
        if(Number.isFinite(highlightEntering)) {
          const enterCell = cells[highlightEntering];
          if(enterCell) {
            enterCell.classList.add('entering');
          }
        }
        if(Number.isFinite(highlightLeaving)) {
          const leaveCell = cells[highlightLeaving];
          if(leaveCell) leaveCell.classList.add('leaving');
        }

        // update result text
        currentResultEl.textContent = (currentValue === null) ? '–' : (agg === 'avg' ? currentValue.toFixed(3) : String(currentValue));
        indicesEl.textContent = `Indices: [${startIdx} .. ${Math.min(startIdx + k -1, arr.length-1)}]`;

        // update op counts
        opCountsEl.textContent = `Naive: ${naiveOps} ops | Sliding: ${slidingOps} ops (so far)`;
      }

      // helper to recompute full window (used when incremental isn't applicable)
      function recomputeWindow(start){
        const w = arr.slice(start, start + k);
        slidingOps += w.length;
        if(agg === 'sum' || agg === 'avg'){
          const s = w.reduce((a,b)=>a+b,0);
          prevWindowSum = s;
          currentValue = (agg === 'sum') ? s : (s / k);
        } else if(agg === 'max'){
          currentValue = Math.max(...w);
        } else if(agg === 'min'){
          currentValue = Math.min(...w);
        }
      }

      // slide once, direction = +1 or -1
      function slideStep(direction=1, triggeredByUser=false){
        if(arr.length === 0) return;
        const positions = Math.max(0, arr.length - k + 1);
        if(positions <= 0) return;
        const oldIndex = i;
        const newIndex = clamp(i + direction, 0, positions - 1);
        if(newIndex === i) {
          // nothing to do
          if(triggeredByUser) {
            // still show highlight feedback
            updateUI();
          }
          return;
        }

        // determine entering and leaving indices
        let leavingIdx = oldIndex;
        let enteringIdx = newIndex + k - 1;
        if(direction < 0){
          // moving left: leaving is oldIndex + k - 1, entering is newIndex
          leavingIdx = oldIndex + k - 1;
          enteringIdx = newIndex;
        }

        // perform incremental update when possible
        if(agg === 'sum' || agg === 'avg'){
          // use prevWindowSum
          if(prevWindowSum === null){
            // fallback to recompute
            recomputeWindow(newIndex);
            stepLabel.textContent = `Recomputed window [${newIndex}..${newIndex + k -1}] by summing ${k} elements.`;
            explainText.textContent = `No previous sum available (or window changed). Recomputing ${k} elements for this window.`;
          } else {
            // Subtract leaving, add entering
            const leavingVal = arr[leavingIdx];
            const enteringVal = arr[enteringIdx];
            prevWindowSum = prevWindowSum - leavingVal + enteringVal;
            slidingOps += 2; // one subtraction and one addition (constant work)
            currentValue = (agg === 'sum') ? prevWindowSum : (prevWindowSum / k);
            stepLabel.textContent = `Updated by subtracting value (${leavingVal}) leaving and adding (${enteringVal}) entering.`;
            explainText.textContent = `Incremental update: removed arr[${leavingIdx}] = ${leavingVal}, added arr[${enteringIdx}] = ${enteringVal}. This requires O(1) work per slide.`;
          }
        } else if(agg === 'max' || agg === 'min'){
          // For max/min: naive incremental is tricky. We'll attempt optimized case:
          const leavingVal = arr[leavingIdx];
          const enteringVal = arr[enteringIdx];
          // If the old max/min is not affected by leaving, we can update easily; otherwise, recompute.
          if(currentValue !== null && ( (agg === 'max' && arr[enteringIdx] <= currentValue && leavingVal !== currentValue) ||
                                       (agg === 'min' && arr[enteringIdx] >= currentValue && leavingVal !== currentValue) )){
            // old extreme remains or new value doesn't exceed; constant work
            // But we still need to check entering influences (e.g., entering > current max)
            if(agg === 'max'){
              if(enteringVal > currentValue){
                currentValue = enteringVal;
                slidingOps += 1;
                stepLabel.textContent = `Entering value ${enteringVal} becomes the new max.`;
                explainText.textContent = `The new element increased the maximum. Worked in O(1).`;
              } else {
                slidingOps += 0;
                stepLabel.textContent = `Max unchanged (leaving element was not the max).`;
                explainText.textContent = `Leaving element wasn't the max and entering didn't exceed; max remains ${currentValue}.`;
              }
            } else {
              if(enteringVal < currentValue){
                currentValue = enteringVal;
                slidingOps += 1;
                stepLabel.textContent = `Entering value ${enteringVal} becomes the new min.`;
                explainText.textContent = `The new element decreased the minimum. Worked in O(1).`;
              } else {
                slidingOps += 0;
                stepLabel.textContent = `Min unchanged (leaving element was not the min).`;
                explainText.textContent = `Leaving element wasn't the min and entering didn't lower it; min remains ${currentValue}.`;
              }
            }
          } else {
            // must recompute full window
            recomputeWindow(newIndex);
            stepLabel.textContent = `Recomputed ${k} elements because leaving element affected extreme value.`;
            explainText.textContent = `Leaving element was the previous ${agg}; we recomputed the window to find new ${agg}. This demonstrates why a deque is useful to avoid recomputation.`;
          }
        }

        i = newIndex;
        updateUI(enteringIdx, leavingIdx);
      }

      // playback controls
      function startPlay(){
        if(playing) return;
        playing = true;
        playBtn.textContent = 'Pause ⏸';
        playBtn.setAttribute('aria-pressed','true');
        const positions = Math.max(0, arr.length - k + 1);
        if(positions <= 0) return;
        timer = setInterval(()=>{
          if(i >= positions - 1){
            stopPlay();
            return;
          }
          slideStep(1);
        }, speed);
      }

      function stopPlay(){
        playing = false;
        playBtn.textContent = 'Play ▶';
        playBtn.setAttribute('aria-pressed','false');
        if(timer) { clearInterval(timer); timer = null; }
      }

      // event listeners
      applyBtn.addEventListener('click', ()=>{
        const parsed = parseArray(arrayInput.value);
        arr = parsed;
        renderArray();
        computeInitial();
      });

      arrayInput.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){ applyBtn.click(); }
      });

      windowRange.addEventListener('input', ()=>{
        k = parseInt(windowRange.value,10) || 1;
        windowSizeLabel.textContent = k;
        // adjust current index if needed
        const positions = Math.max(0, arr.length - k + 1);
        i = clamp(i, 0, Math.max(0, positions - 1));
        computeInitial();
      });

      aggSelect.addEventListener('change', ()=>{
        agg = aggSelect.value;
        computeInitial();
      });

      prevBtn.addEventListener('click', ()=>{
        stopPlay();
        slideStep(-1, true);
      });

      nextBtn.addEventListener('click', ()=>{
        stopPlay();
        slideStep(1, true);
      });

      playBtn.addEventListener('click', ()=>{
        if(playing) stopPlay();
        else startPlay();
      });

      resetBtn.addEventListener('click', ()=>{
        stopPlay();
        // reset to start
        i = 0;
        computeInitial();
      });

      speedRange.addEventListener('input', ()=>{
        speed = parseInt(speedRange.value,10);
        if(playing){
          stopPlay();
          startPlay();
        }
      });

      // keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
        if(e.key === 'ArrowRight'){ e.preventDefault(); nextBtn.click(); }
        if(e.key === 'ArrowLeft'){ e.preventDefault(); prevBtn.click(); }
        if(e.key === ' ' || e.key === 'Spacebar'){ e.preventDefault(); playBtn.click(); }
      });

      // drag-to-snap overlay
      (function(){
        let dragging = false;
        let startX = 0;
        let startLeft = 0;
        overlay.addEventListener('pointerdown', (e)=>{
          if(arr.length === 0) return;
          dragging = true;
          overlay.setPointerCapture(e.pointerId);
          startX = e.clientX;
          startLeft = overlay.offsetLeft;
          stopPlay();
        });
        overlay.addEventListener('pointermove', (e)=>{
          if(!dragging) return;
          // compute new left relative to array
          const dx = e.clientX - startX;
          const newLeft = clamp(startLeft + dx, 0, Math.max(0, arrayEl.scrollWidth - overlay.offsetWidth));
          overlay.style.left = newLeft + 'px';
        });
        overlay.addEventListener('pointerup', (e)=>{
          if(!dragging) return;
          dragging = false;
          overlay.releasePointerCapture(e.pointerId);
          // snap to nearest index
          const cells = Array.from(arrayEl.querySelectorAll('.cell'));
          if(cells.length === 0) return;
          // compute center x relative to arrayEl
          const overlayCenter = overlay.offsetLeft + overlay.offsetWidth / 2;
          // find nearest cell start
          let nearestIdx = 0;
          let bestDist = Infinity;
          for(let idx = 0; idx < cells.length; idx++){
            const c = cells[idx];
            const center = c.offsetLeft + c.offsetWidth / 2;
            const dist = Math.abs(center - overlayCenter);
            if(dist < bestDist){ bestDist = dist; nearestIdx = idx; }
          }
          // the window start should be nearestIdx clamped so that end fits
          const positions = Math.max(0, arr.length - k + 1);
          let newStart = clamp(nearestIdx, 0, Math.max(0, positions - 1));
          // if nearest corresponds to an index in the middle of window, adjust to start such that center aligns
          // We'll center the window around the overlay center: compute candidate start = nearestIdx - floor(k/2)
          const candidateStart = nearestIdx - Math.floor(k/2);
          newStart = clamp(candidateStart, 0, Math.max(0, positions - 1));
          // update index and recount
          const oldI = i;
          i = newStart;
          // For visual effect: determine entering and leaving indices based on movement direction
          const dir = (i > oldI) ? 1 : (i < oldI ? -1 : 0);
          let enteringIdx = null, leavingIdx = null;
          if(dir !== 0){
            if(dir > 0){
              leavingIdx = oldI;
              enteringIdx = i + k - 1;
            } else {
              leavingIdx = oldI + k - 1;
              enteringIdx = i;
            }
          }
          // recompute using sliding logic (but we don't have history of previous window if jump > 1)
          // If jump is >1 we recompute directly
          if(Math.abs(i - oldI) > 1 || prevWindowSum === null || (agg !== 'sum' && agg !== 'avg' && (leavingIdx !== null && arr[leavingIdx] === currentValue))){
            recomputeWindow(i);
            updateUI(enteringIdx, leavingIdx);
            stepLabel.textContent = `Snapped to index ${i}. Recomputed window due to non-adjacent move.`;
            explainText.textContent = `You jumped more than one step or changed context; demo recomputed the window for correctness.`;
          } else {
            // adjacent move: perform incremental update
            slideStep((i - oldI), true);
          }
        });
      })();

      // initialization on load
      (function init(){
        arr = parseArray(arrayInput.value);
        k = Number(windowRange.value) || 3;
        agg = aggSelect.value;
        renderArray();
        computeInitial();

        // responsive behavior: when window resizes, reposition overlay to match
        window.addEventListener('resize', ()=>{
          updateUI();
        });
      })();

    })();
  </script>
</body>
</html>