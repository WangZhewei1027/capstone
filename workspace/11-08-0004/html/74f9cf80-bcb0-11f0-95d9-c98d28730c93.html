<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Heap (Min/Max) — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #94a3b8;
      --accent: #06b6d4;
      --accent-2: #8b5cf6;
      --card: #071029;
      --success: #16a34a;
      --danger: #ef4444;
      --text: #e6eef8;
      --node-bg: #0ea5a4;
      --node-text: #041124;
      --node-bg-alt: #60a5fa;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071227 0%, #041122 100%);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    /* Safe-area container */
    .safe {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    header{
      display:flex;
      gap:var(--gap);
      align-items:baseline;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size:1.25rem;
      letter-spacing:0.2px;
    }
    .subtitle{
      color:var(--muted);
      font-size:0.95rem;
      margin-left:auto;
    }

    main{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      width:100%;
      box-sizing:border-box;
    }

    /* Left doc column */
    .doc {
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      padding:16px;
      border-radius:10px;
      flex:0 0 360px;
      min-width:280px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }
    .doc h2{
      margin:8px 0;
      font-size:1.05rem;
    }
    .doc p{
      margin:8px 0;
      color:var(--muted);
      line-height:1.4;
    }
    .doc ul{
      margin:8px 0 0 18px;
      color:var(--muted);
    }

    /* Interactive module column */
    .module {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      padding:16px;
      border-radius:10px;
      flex:1 1 auto;
      min-width:320px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.55);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .controls {
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
      align-items:center;
    }

    .control-group{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      padding:10px;
      border-radius:8px;
      display:flex;
      gap:12px;
      align-items:center;
      min-height:48px;
      box-sizing:border-box;
    }

    label{
      font-size:0.9rem;
      color:var(--muted);
    }

    input[type="number"], input[type="text"], select{
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:rgba(255,255,255,0.02);
      color:var(--text);
      min-width:80px;
      outline:none;
    }
    button{
      background:linear-gradient(180deg,var(--accent),var(--accent-2));
      border:none;
      color:white;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      transition:transform .08s ease, box-shadow .08s;
      min-height:40px;
    }
    button.secondary{
      background:transparent;
      color:var(--text);
      border:1px solid rgba(255,255,255,0.06);
    }
    button:active{ transform: translateY(1px); }
    .danger{ background:linear-gradient(180deg,var(--danger),#c93b3b); }
    .success{ background:linear-gradient(180deg,var(--success),#158a3a); }

    /* Visualization area */
    .viz {
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      width:100%;
      min-height:380px;
    }

    .tree-panel{
      flex:1 1 60%;
      min-width:260px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:8px;
      padding:12px;
      box-sizing:border-box;
      position:relative;
      overflow:visible;
      height:360px;
    }
    .tree-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      margin-bottom:6px;
    }
    .tree-canvas{
      position:relative;
      width:100%;
      height:300px;
      border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      overflow:visible;
    }
    .node {
      position:absolute;
      transform: translate(-50%,-50%);
      width:48px;
      height:48px;
      border-radius:50%;
      background:var(--node-bg);
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--node-text);
      font-weight:700;
      box-shadow: 0 6px 14px rgba(2,6,23,0.55);
      transition: transform 400ms cubic-bezier(.2,.9,.2,1), box-shadow 180ms;
      z-index:2;
      user-select:none;
    }
    .node.alt{ background:var(--node-bg-alt); color:var(--node-text); }
    .node.compare { box-shadow:0 0 0 6px rgba(99,102,241,0.08); }
    .node.swap { box-shadow:0 0 0 10px rgba(16,185,129,0.09); transform: translate(-50%,-50%) scale(1.06); }
    .edge{
      position:absolute;
      width:2px;
      background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      transform-origin:top left;
      z-index:1;
      transition: background 200ms;
      opacity:0.9;
    }

    /* Array panel */
    .array-panel{
      flex:0 0 320px;
      min-width:240px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:8px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .array-list{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .arr-box{
      min-width:44px;
      height:44px;
      border-radius:8px;
      background:rgba(255,255,255,0.02);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:6px;
      font-weight:700;
      color:var(--text);
      border:1px solid rgba(255,255,255,0.03);
      transition: transform 200ms, box-shadow 200ms;
    }
    .arr-box.highlight { background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:white; transform:translateY(-6px); box-shadow:0 12px 30px rgba(6,182,212,0.12); }
    .arr-index{ font-size:0.8rem; color:var(--muted); margin-top:6px; text-align:center; }

    /* controls at bottom: playback */
    .playback{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }
    .playback-left{ display:flex; gap:12px; align-items:center; }
    .speed{ display:flex; gap:8px; align-items:center; color:var(--muted); font-size:0.9rem; }
    .log{
      background:rgba(0,0,0,0.18);
      padding:10px;
      border-radius:8px;
      color:var(--muted);
      font-size:0.9rem;
      min-height:64px;
      overflow:auto;
    }

    /* Responsive */
    @media (max-width:980px){
      main{ flex-direction:column; }
      .doc { order:2; }
      .module{ order:1; }
      .tree-panel{ height:320px; }
    }
    /* Accessibility focus */
    button:focus, input:focus, select:focus { outline: 2px solid rgba(99,102,241,0.28); outline-offset:3px; border-radius:8px; }
  </style>
</head>
<body>
  <div class="safe" role="main">
    <header>
      <h1>Heap (Min/Max) — Interactive Explorer</h1>
      <div class="subtitle">Visualize insert, extract, and heapify with step-by-step animations</div>
    </header>

    <main>
      <section class="doc" aria-labelledby="doc-title">
        <h2 id="doc-title">Concept Title</h2>
        <p><strong>Heap (Min/Max)</strong> — a binary heap data structure where each node satisfies the heap property relative to its children: for a min-heap, every parent ≤ children; for a max-heap, every parent ≥ children.</p>

        <h2>Learning Objective</h2>
        <p>After interacting with this module, you should be able to:</p>
        <ul>
          <li>Explain how min-heaps and max-heaps differ and why the heap property matters.</li>
          <li>See how insert (bubble-up) and extract (sift-down) maintain the heap property through comparisons and swaps.</li>
          <li>Relate the array representation with the tree layout and understand heapify (build-heap) behavior.</li>
        </ul>

        <h2>Interaction Design</h2>
        <p>Primary interactions:</p>
        <ul>
          <li>Toggle between Min and Max heap modes to change comparison behavior.</li>
          <li>Insert values (manual or random) and watch an animated bubble-up: comparisons highlight nodes; swaps animate node positions.</li>
          <li>Extract the root (remove-min or remove-max) to see sift-down: root swaps with a child until heap property restored, with visual highlights.</li>
          <li>Build-heap from an arbitrary array (heapify) to observe multiple sift-down operations in sequence.</li>
          <li>Playback controls: Play/Pause, Step forward/back to inspect each compare/swap; speed slider to adjust animation tempo.</li>
          <li>Array view syncs with the tree view; clicking an array cell allows modifying values and rebuilding.</li>
        </ul>
        <p>Visual and animated feedback:</p>
        <ul>
          <li>Nodes being compared glow; swaps produce a brief scale animation and shadow; edges connect parent-child in the tree for spatial reasoning.</li>
          <li>Operation log narrates steps for accessibility (aria-live) and for learning reflection.</li>
        </ul>

        <h2>Layout Description</h2>
        <p>Spatial organization (safe margins 24px, min spacing 16px):</p>
        <ul>
          <li>Left column: textual explanation and objectives (fixed width ~360px) to provide context near the interactive module.</li>
          <li>Right column: the interactive module — top area contains controls; the main visualization area splits into a large tree canvas (left) and an array & log panel (right).</li>
          <li>Playback controls and speed slider located beneath the visualization to provide temporal control without cluttering the canvas.</li>
          <li>Design maintains visual focus by using a darker background and bright accent colors for active highlights. All interactive elements have a minimum spacing of 16px and accessible focus outlines; layout is responsive and stacks vertically on narrow screens.</li>
        </ul>
      </section>

      <section class="module" aria-labelledby="module-title">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <h2 id="module-title" style="margin:0;font-size:1rem;">Interactive Heap Playground</h2>
          <div style="color:var(--muted);font-size:0.9rem;">Accessible | Keyboard-ready</div>
        </div>

        <div class="controls" role="region" aria-label="controls">
          <div class="control-group" style="min-width:220px;">
            <label for="heap-mode">Mode</label>
            <select id="heap-mode" aria-label="Heap mode" title="Choose Min or Max heap" style="margin-left:6px;">
              <option value="min">Min-Heap</option>
              <option value="max">Max-Heap</option>
            </select>
          </div>

          <div class="control-group">
            <label for="val-input">Value</label>
            <input id="val-input" type="number" placeholder="e.g., 42" aria-label="Value to insert" />
            <button id="insert-btn" title="Insert value">Insert</button>
            <button id="extract-btn" title="Extract root" class="danger">Extract Root</button>
          </div>

          <div class="control-group">
            <label for="rand-count">Random</label>
            <input id="rand-count" type="number" min="1" max="15" value="7" style="width:72px;" aria-label="Number of random elements" />
            <button id="rand-btn" title="Generate random heap" class="secondary">Generate</button>
            <button id="build-btn" title="Build heap from array" class="secondary">Build-Heap</button>
            <button id="reset-btn" title="Reset heap" class="secondary">Reset</button>
          </div>
        </div>

        <div class="viz" aria-hidden="false">
          <div class="tree-panel" aria-label="Heap tree visualization">
            <div class="tree-header">
              <div style="color:var(--muted);font-size:0.95rem;">Tree View (positions animate)</div>
              <div style="color:var(--muted);font-size:0.9rem;">Nodes: <span id="heap-size">0</span></div>
            </div>
            <div id="tree-canvas" class="tree-canvas" aria-live="polite" aria-atomic="true"></div>
          </div>

          <div class="array-panel" aria-label="Array representation and log">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div style="color:var(--muted);font-size:0.95rem;">Array (index 0..)</div>
              <div style="color:var(--muted);font-size:0.85rem;">Click value to edit</div>
            </div>
            <div id="array-list" class="array-list" role="list"></div>

            <div style="display:flex;gap:8px;align-items:center;">
              <button id="toggle-view" class="secondary">Toggle Array ↔ Tree</button>
              <div style="flex:1;"></div>
              <div style="font-size:0.85rem;color:var(--muted);">Comparisons: <span id="comp-count">0</span></div>
            </div>

            <div class="log" id="op-log" aria-live="polite" role="log">Operation log will appear here.</div>
          </div>
        </div>

        <div class="playback" aria-label="Playback controls">
          <div class="playback-left">
            <button id="step-back" class="secondary">◀︎ Step</button>
            <button id="play-pause">Play</button>
            <button id="step-forward" class="secondary">Step ▶︎</button>
            <div class="speed">
              <label for="speed">Speed</label>
              <input id="speed" type="range" min="0.2" max="2.0" value="1.0" step="0.1" aria-label="Animation speed" />
            </div>
          </div>
          <div style="display:flex;gap:12px;align-items:center;">
            <div style="color:var(--muted);font-size:0.9rem;">Step <span id="current-step">0</span>/<span id="total-steps">0</span></div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script>
    /*
      Interactive Heap Explorer (Min/Max)
      - Self-contained vanilla JS implementation.
      - Implements animated insert (bubble-up), extract (sift-down), and build-heap with step recording.
      - Tree positions are computed for each node; nodes animate via CSS transform.
      - Playback supports Play/Pause, Step forward/back and speed control.
    */

    (function(){
      // DOM refs
      const modeSel = document.getElementById('heap-mode');
      const valInput = document.getElementById('val-input');
      const insertBtn = document.getElementById('insert-btn');
      const extractBtn = document.getElementById('extract-btn');
      const randBtn = document.getElementById('rand-btn');
      const randCount = document.getElementById('rand-count');
      const buildBtn = document.getElementById('build-btn');
      const resetBtn = document.getElementById('reset-btn');
      const treeCanvas = document.getElementById('tree-canvas');
      const arrayList = document.getElementById('array-list');
      const opLog = document.getElementById('op-log');
      const compCountEl = document.getElementById('comp-count');
      const heapSizeEl = document.getElementById('heap-size');
      const playBtn = document.getElementById('play-pause');
      const stepForward = document.getElementById('step-forward');
      const stepBack = document.getElementById('step-back');
      const speedRange = document.getElementById('speed');
      const currentStepEl = document.getElementById('current-step');
      const totalStepsEl = document.getElementById('total-steps');
      const toggleViewBtn = document.getElementById('toggle-view');

      // State
      let heap = [];                       // current data array
      let steps = [];                      // recorded animation steps for current operation(s)
      let stepIndex = 0;
      let playing = false;
      let timer = null;
      let speed = 1.0;
      let comparisons = 0;
      let viewArray = true;

      // Utility comparator based on mode
      function cmp(a,b){
        const mode = modeSel.value;
        return mode === 'min' ? (a - b) : (b - a);
      }

      // Logging
      function log(msg){
        const time = new Date().toLocaleTimeString();
        opLog.textContent = time + ' — ' + msg + '\\n' + opLog.textContent;
      }

      // Render tree and array
      function render(){
        // update sizes
        heapSizeEl.textContent = heap.length;
        compCountEl.textContent = comparisons;

        renderArray();
        renderTree();
      }

      function renderArray(){
        arrayList.innerHTML = '';
        heap.forEach((v,i) => {
          const box = document.createElement('div');
          box.className = 'arr-box';
          box.tabIndex = 0;
          box.setAttribute('role','button');
          box.setAttribute('aria-label', 'Index ' + i + ' value ' + v);
          box.innerHTML = '<div>'+v+'</div>';
          // index caption
          const cap = document.createElement('div');
          cap.className = 'arr-index';
          cap.textContent = i;
          box.appendChild(cap);
          box.addEventListener('click', ()=> editArrayValue(i));
          box.addEventListener('keydown', (e)=>{ if(e.key==='Enter') editArrayValue(i); });
          arrayList.appendChild(box);
        });
      }

      function editArrayValue(index){
        const newVal = prompt('Edit value at index ' + index + ':', String(heap[index]));
        if(newVal === null) return;
        const parsed = Number(newVal);
        if(Number.isNaN(parsed)){ alert('Please provide a numeric value.'); return; }
        heap[index] = parsed;
        log('Edited index ' + index + ' -> ' + parsed);
        render();
      }

      // Tree rendering: create node elements and edges; nodes positioned by index
      function renderTree(highlights = {}){
        // clear canvas elements
        treeCanvas.innerHTML = '';
        const W = treeCanvas.clientWidth;
        const H = treeCanvas.clientHeight;
        const nodeSize = 48;
        const levelHeight = Math.max(80, Math.floor(H / (Math.floor(Math.log2(Math.max(1,heap.length))) + 2)));

        const positions = []; // store center positions for edge drawing

        // compute positions
        for(let i=0;i<heap.length;i++){
          const level = Math.floor(Math.log2(i + 1));
          const levelStart = (1 << level) - 1;
          const posInLevel = i - levelStart;
          const widthDivs = (1 << level);
          const x = Math.round((posInLevel + 0.5) * (W / widthDivs));
          const y = Math.round(20 + level * levelHeight);
          positions.push({x,y});
        }

        // draw edges first
        for(let i=0;i<heap.length;i++){
          const left = 2*i + 1;
          const right = 2*i + 2;
          const p = positions[i];
          if(left < heap.length){
            drawEdge(p, positions[left]);
          }
          if(right < heap.length){
            drawEdge(p, positions[right]);
          }
        }

        // draw nodes
        for(let i=0;i<heap.length;i++){
          const p = positions[i];
          const node = document.createElement('div');
          node.className = 'node' + ((i%2) ? ' alt' : '');
          node.style.left = p.x + 'px';
          node.style.top = p.y + 'px';
          node.textContent = heap[i];
          node.dataset.index = i;
          node.title = 'Index ' + i + ', value ' + heap[i];
          // highlight classes
          if(highlights.compare && highlights.compare.includes(i)) node.classList.add('compare');
          if(highlights.swap && highlights.swap.includes(i)) node.classList.add('swap');

          treeCanvas.appendChild(node);
        }
      }

      function drawEdge(p1,p2){
        const x1 = p1.x;
        const y1 = p1.y;
        const x2 = p2.x;
        const y2 = p2.y;
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        const el = document.createElement('div');
        el.className = 'edge';
        el.style.left = x1 + 'px';
        el.style.top = y1 + 'px';
        el.style.height = length + 'px';
        el.style.transform = 'rotate(' + angle + 'deg)';
        treeCanvas.appendChild(el);
      }

      // Recording steps for animated operations.
      // Step format examples:
      // {type:'compare',i,j}
      // {type:'swap',i,j,heap:[...]}
      // {type:'set',i,value,heap:[...]}
      // {type:'note',text}
      function recordCompare(i,j){
        comparisons++;
        steps.push({type:'compare',i,j});
      }
      function recordSwap(i,j){
        steps.push({type:'swap',i,j,heap:heap.slice()});
      }
      function recordNote(text){
        steps.push({type:'note',text});
      }

      // Heap operations that record steps rather than directly animate
      function heapInsert(value){
        // push at end, bubble-up
        heap.push(value);
        const n = heap.length;
        recordNote('Insert ' + value + ' at index ' + (n-1));
        let i = n-1;
        while(i > 0){
          const parent = Math.floor((i-1)/2);
          recordCompare(i,parent);
          if(cmp(heap[i], heap[parent]) < 0){
            // swap
            [heap[i], heap[parent]] = [heap[parent], heap[i]];
            recordSwap(i,parent);
            i = parent;
          } else break;
        }
      }

      function heapExtractRoot(){
        if(heap.length === 0){
          recordNote('Heap is empty.');
          return null;
        }
        const root = heap[0];
        recordNote('Extract root ' + root);
        if(heap.length === 1){
          heap.pop();
          recordSwap(0,0);
          return root;
        }
        // move last to root and sift-down
        heap[0] = heap.pop();
        recordSwap(0, heap.length); // note: heap length already decreased, recorded with previous array
        let i = 0;
        while(true){
          const left = 2*i + 1;
          const right = 2*i + 2;
          if(left >= heap.length) break;
          // pick child to compare with
          let chosen = left;
          if(right < heap.length){
            recordCompare(left, right);
            if(cmp(heap[right], heap[left]) < 0) chosen = right;
          }
          recordCompare(chosen, i);
          if(cmp(heap[chosen], heap[i]) < 0){
            [heap[i], heap[chosen]] = [heap[chosen], heap[i]];
            recordSwap(i, chosen);
            i = chosen;
          } else break;
        }
        return root;
      }

      // Build heap (heapify) using bottom-up sift-down; record steps
      function buildHeapFromArray(arr){
        heap = arr.slice();
        const n = heap.length;
        recordNote('Build-heap (heapify) from array');
        for(let i = Math.floor(n/2) - 1; i >= 0; i--){
          siftDownRecord(i);
        }
      }
      function siftDownRecord(i){
        const n = heap.length;
        let idx = i;
        while(true){
          const left = 2*idx + 1;
          const right = 2*idx + 2;
          if(left >= n) break;
          let chosen = left;
          if(right < n){
            recordCompare(left, right);
            if(cmp(heap[right], heap[left]) < 0) chosen = right;
          }
          recordCompare(chosen, idx);
          if(cmp(heap[chosen], heap[idx]) < 0){
            [heap[idx], heap[chosen]] = [heap[chosen], heap[idx]];
            recordSwap(idx, chosen);
            idx = chosen;
          } else break;
        }
      }

      // Playback engine
      function play(){
        if(playing) return;
        playing = true;
        playBtn.textContent = 'Pause';
        scheduleNext();
      }
      function pause(){
        playing = false;
        playBtn.textContent = 'Play';
        if(timer) { clearTimeout(timer); timer = null; }
      }
      function stop(){
        pause();
        stepIndex = 0;
        currentStepEl.textContent = stepIndex;
        render();
      }
      function scheduleNext(){
        if(!playing) return;
        if(stepIndex >= steps.length){
          pause();
          return;
        }
        const baseDelay = 600; // ms
        const nextDelay = Math.max(120, baseDelay / speed);
        timer = setTimeout(()=> {
          stepForwardOnce();
          scheduleNext();
        }, nextDelay);
      }

      function applyStep(s){
        // s may be compare/swap/note; highlight appropriate nodes and update DOM
        if(!s) return;
        if(s.type === 'note'){
          log(s.text);
        } else if(s.type === 'compare'){
          render({compare:[s.i,s.j]});
          log('Compare index ' + s.i + ' (val=' + (heap[s.i] ?? 'n/a') + ') vs index ' + s.j + ' (val=' + (heap[s.j] ?? 'n/a') + ')');
        } else if(s.type === 'swap'){
          // apply snapshot if provided
          if(s.heap) heap = s.heap.slice();
          render({swap:[s.i,s.j]});
          log('Swap index ' + s.i + ' and ' + s.j);
        }
        // update array highlights
        highlightArray(s);
      }

      function highlightArray(s){
        // temporarily highlight array elements (handled in renderArray by applying classes)
        // We'll add class to arr-box elements matching indices
        const boxes = Array.from(arrayList.children);
        boxes.forEach(b => b.classList.remove('highlight'));
        if(s && s.type === 'compare'){
          [s.i,s.j].forEach(idx => { if(boxes[idx]) boxes[idx].classList.add('highlight'); });
        } else if(s && s.type === 'swap'){
          [s.i,s.j].forEach(idx => { if(boxes[idx]) boxes[idx].classList.add('highlight'); });
        }
      }

      function stepForwardOnce(){
        if(stepIndex >= steps.length) return;
        const s = steps[stepIndex];
        applyStep(s);
        stepIndex++;
        currentStepEl.textContent = stepIndex;
        totalStepsEl.textContent = steps.length;
      }
      function stepBackOnce(){
        // Recompute from scratch up to previous step to ensure consistent state.
        // We'll rebuild heap from initial snapshot and replay steps up to (stepIndex-1).
        if(stepIndex <= 0) return;
        // Need to reconstruct initial heap state. To simplify, store initialHeap in session for each recorded steps series.
        if(!steps.initialHeap){
          // no initial snapshot: we can't go back. Just reset to end state.
          stepIndex = steps.length;
          render();
          return;
        }
        const initial = steps.initialHeap.slice();
        heap = initial.slice();
        comparisons = 0;
        const target = stepIndex - 1;
        let i=0;
        while(i < target){
          const s = steps[i];
          if(s.type === 'note') { /* ignore */ }
          else if(s.type === 'compare'){ comparisons++; }
          else if(s.type === 'swap'){ if(s.heap) heap = s.heap.slice(); }
          i++;
        }
        stepIndex = target;
        render();
        currentStepEl.textContent = stepIndex;
      }

      // Public actions wired to buttons
      insertBtn.addEventListener('click', ()=> {
        const v = Number(valInput.value);
        if(Number.isNaN(v)){ alert('Enter a numeric value to insert.'); return; }
        prepareSteps();
        heapInsert(v);
        finalizeSteps();
      });
      extractBtn.addEventListener('click', ()=> {
        prepareSteps();
        heapExtractRoot();
        finalizeSteps();
      });
      randBtn.addEventListener('click', ()=> {
        const count = Math.max(1, Math.min(15, Number(randCount.value) || 7));
        const arr = Array.from({length:count}, ()=> Math.floor(Math.random()*100));
        heap = arr.slice();
        comparisons = 0;
        log('Generated random array: [' + heap.join(', ') + ']');
        render();
      });
      buildBtn.addEventListener('click', ()=> {
        const arr = heap.slice(); // use current array
        prepareSteps();
        buildHeapFromArray(arr);
        finalizeSteps();
      });
      resetBtn.addEventListener('click', ()=> {
        heap = [];
        steps = [];
        stepIndex = 0;
        comparisons = 0;
        render();
        log('Reset heap.');
      });

      playBtn.addEventListener('click', ()=> {
        if(playing) pause();
        else play();
      });
      stepForward.addEventListener('click', ()=> {
        pause();
        if(stepIndex < steps.length) stepForwardOnce();
      });
      stepBack.addEventListener('click', ()=> {
        pause();
        stepBackOnce();
      });
      speedRange.addEventListener('input', ()=> {
        speed = Number(speedRange.value);
      });

      toggleViewBtn.addEventListener('click', ()=> {
        viewArray = !viewArray;
        // For demo: collapse array or tree by toggling visibility
        document.querySelector('.tree-panel').style.display = viewArray ? 'block' : 'none';
        document.querySelector('.array-panel').style.display = viewArray ? 'block' : 'block'; // keep both visible but user may use toggling if extended
      });

      // Prepare steps capture: store initial snapshot
      function prepareSteps(){
        pause();
        steps = [];
        stepIndex = 0;
        steps.initialHeap = heap.slice(); // snapshot for back-stepping
      }

      // Finalize and start playing sequence
      function finalizeSteps(){
        totalStepsEl.textContent = steps.length;
        currentStepEl.textContent = stepIndex;
        if(steps.length === 0){
          render();
          return;
        }
        // start playing automatically one step at a time
        comparisons = 0;
        // For consistent animation progression, reset heap to initial and then replay steps gradually.
        heap = steps.initialHeap.slice();
        render();
        play();
      }

      // On mode change: simple visual note
      modeSel.addEventListener('change', ()=>{
        log('Switched to ' + (modeSel.value === 'min' ? 'Min-Heap' : 'Max-Heap'));
      });

      // initial render
      render();

      // Accessibility: Enter on valInput inserts
      valInput.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter') insertBtn.click();
      });

      // Some demo initial content
      (function seedDemo(){
        heap = [40, 20, 30, 10, 18, 25];
        render();
        log('Demo seed placed in heap (array form). Try Build-Heap to see heapify or insert new values.');
      })();

      // Expose limited API for testing in console (not required)
      window.__heap = {
        getHeap: ()=> heap.slice(),
        insert: (v)=> { valInput.value = v; insertBtn.click(); },
        extract: ()=> extractBtn.click(),
        build: ()=> buildBtn.click()
      };

    })();
  </script>
</body>
</html>