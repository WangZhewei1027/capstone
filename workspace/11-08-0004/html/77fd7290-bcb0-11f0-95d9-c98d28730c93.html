<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Module — Priority Queue</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --bg:#0f1724;
      --card:#0b1220;
      --muted:#94a3b8;
      --accent:#48b0f7;
      --accent-2:#7ee787;
      --danger:#fb7185;
      --glass: rgba(255,255,255,0.03);
      --node-size:56px;
    }
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#071029 0%, #041426 100%);
      color:#e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    /* Safe area margins */
    .app{
      padding:var(--safe-padding);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      gap:var(--gap);
      flex-direction:column;
    }

    header{
      display:flex;
      gap:var(--gap);
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .title{
      display:flex;
      gap:12px;
      align-items:baseline;
    }
    h1{
      margin:0;
      font-size:20px;
      font-weight:600;
      letter-spacing:0.2px;
    }
    .subtitle{
      color:var(--muted);
      font-size:13px;
      margin-top:4px;
    }

    main{
      display:flex;
      gap:var(--gap);
      margin-top:8px;
      flex:1 1 auto;
      min-height:360px;
      align-items:flex-start;
      flex-wrap:wrap;
    }

    /* Left column: text plan */
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      padding:18px;
      border-radius:12px;
      min-width:320px;
      max-width:420px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }
    .panel h3{
      margin:0 0 8px 0;
      font-size:14px;
    }
    .panel p, .muted{
      margin:6px 0;
      color:var(--muted);
      font-size:13px;
      line-height:1.45;
    }
    .list{
      margin:8px 0 0 0;
      padding-left:18px;
      color:var(--muted);
      font-size:13px;
    }

    /* Right column: interactive area */
    .interactive{
      flex:1 1 640px;
      min-width:320px;
      background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:18px;
      border:1px solid rgba(255,255,255,0.04);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      box-shadow: 0 6px 18px rgba(0,0,0,0.5);
    }

    /* Controls */
    .controls{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    .control-group{
      display:flex;
      gap:8px;
      align-items:center;
    }
    label{font-size:13px;color:var(--muted)}
    input[type="text"], input[type="number"], select{
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:var(--glass);
      color:var(--muted);
      min-width:90px;
      outline:none;
    }
    input[type="text"]:focus, input[type="number"]:focus, select:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 4px rgba(72,176,247,0.06);
      color:var(--accent-2);
    }
    button{
      padding:8px 12px;
      border-radius:10px;
      border: none;
      background:linear-gradient(180deg,var(--accent), #1e90c9);
      color:#052025;
      font-weight:600;
      cursor:pointer;
      min-height:40px;
    }
    button.ghost{
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      font-weight:600;
    }
    button.warn{
      background:linear-gradient(180deg,#ffb4b4,#fb7185);
      color:#1b021b;
    }
    .small{
      padding:6px 8px;
      min-height:36px;
      font-size:13px;
    }

    /* Visual area: heap tree and array */
    .visual{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .tree-wrap{
      flex:1 1 560px;
      min-height:220px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:10px;
      padding:12px;
      position:relative;
      overflow:hidden;
    }
    .tree-area{
      position:relative;
      height:220px;
      width:100%;
    }
    .node{
      position:absolute;
      width:var(--node-size);
      height:var(--node-size);
      border-radius:50%;
      background:linear-gradient(180deg,#0b293b,#05202f);
      border:2px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--accent-2);
      font-weight:700;
      transition: left 420ms cubic-bezier(.2,.9,.25,1), top 420ms cubic-bezier(.2,.9,.25,1), transform 220ms ease, box-shadow 220ms;
      box-shadow: 0 6px 14px rgba(6,14,22,0.6);
      cursor:pointer;
      user-select:none;
      font-size:14px;
    }
    .node .p{
      display:block;
      font-size:11px;
      color:var(--muted);
      font-weight:600;
      position:absolute;
      bottom:-18px;
      width:120px;
      left:50%;
      transform:translateX(-50%);
      text-align:center;
    }
    .node.highlight{
      box-shadow:0 12px 26px rgba(72,176,247,0.16);
      transform:scale(1.06);
      border-color:var(--accent);
    }
    .node.new{
      animation:pop 420ms ease forwards;
    }
    @keyframes pop{
      0%{transform:scale(0.6);opacity:0}
      60%{transform:scale(1.08);opacity:1}
      100%{transform:scale(1)}
    }

    /* lines connecting nodes (simple) */
    .connector{
      position:absolute;
      width:2px;
      background:linear-gradient(180deg,rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      transform-origin:top left;
      transition:all 420ms cubic-bezier(.2,.9,.25,1);
    }

    /* array representation */
    .array{
      min-width:260px;
      max-width:420px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:10px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .array .row{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .cell{
      min-width:64px;
      height:56px;
      background:rgba(255,255,255,0.02);
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--muted);
      font-weight:700;
      border:1px solid rgba(255,255,255,0.03);
      transition:transform 260ms ease, box-shadow 220ms;
      position:relative;
    }
    .cell .sub{
      display:block;
      font-size:11px;
      color:var(--muted);
      position:absolute;
      bottom:-18px;
      width:100%;
      text-align:center;
      left:0;
    }
    .cell.hi{
      box-shadow:0 10px 18px rgba(72,176,247,0.06);
      transform:scale(1.03);
      color:var(--accent-2);
      border-color:var(--accent);
    }

    /* log */
    .log{
      max-height:140px;
      overflow:auto;
      font-size:13px;
      color:var(--muted);
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
      padding:10px;
      background:rgba(255,255,255,0.01);
    }
    .log .item{margin-bottom:6px}
    .muted-cap{color:var(--muted);font-size:12px}

    /* responsive */
    @media (max-width:980px){
      main{flex-direction:column}
      .interactive{order:2}
    }
    @media (max-width:560px){
      .array{min-width:100%}
    }

  </style>
</head>
<body>
  <div class="app" role="application" aria-labelledby="module-title">
    <header>
      <div class="title">
        <h1 id="module-title">Priority Queue — Visual Heap Playground</h1>
        <div class="subtitle">Hands-on: insert, extract, change priority, and watch heap operations animate</div>
      </div>

      <div style="display:flex;gap:12px;align-items:center;">
        <div class="muted-cap">Heap type</div>
        <select id="heapType" aria-label="Choose heap type">
          <option value="min">Min-Heap (smaller priority = higher)</option>
          <option value="max">Max-Heap (larger priority = higher)</option>
        </select>
      </div>
    </header>

    <main>
      <!-- Left: Design Plan and Learning Objectives -->
      <section class="panel" aria-labelledby="concept-title">
        <h3 id="concept-title">Concept Title</h3>
        <p><strong>Priority Queue (implemented with a binary heap)</strong></p>

        <h3>Learning Objective</h3>
        <p>After interacting with this module, you should be able to:</p>
        <ul class="list">
          <li>Describe how a priority queue orders items by priority (min- or max-first).</li>
          <li>Understand how binary-heap insert and extract operations rearrange nodes (bubble-up and bubble-down).</li>
          <li>See the relationship between the array representation and tree structure of a heap.</li>
        </ul>

        <h3>Interaction Design</h3>
        <p class="muted">
          Interact by inserting items (with numeric priorities), extracting the top-priority element, and editing a node's priority by clicking it.
          Animations show nodes moving; the array and the heap tree update synchronously, reinforcing the mapping between array indices and tree positions.
          Controls:
        </p>
        <ul class="list">
          <li>Insert: type a label (optional) and a numeric priority, then click Insert. New node will "pop" and bubble up if needed.</li>
          <li>Extract: removes the top-priority element and animates bubble-down to restore the heap.</li>
          <li>Click a node in the tree to select it and change its priority (promote/demote), which triggers bubble-up/down as appropriate.</li>
          <li>Toggle Min/Max heap to see different ordering semantics; build random heap to explore behavior.</li>
        </ul>

        <h3>Layout Description</h3>
        <p class="muted">Spatial organization ensures clarity and focus while respecting accessibility and spacing guidelines:</p>
        <ul class="list">
          <li>Safe area: 24px padding around the viewport; all interactive elements have at least 16px spacing.</li>
          <li>Left column contains the concept text and objectives (max width 420px) for quick reference.</li>
          <li>Right column is the interactive canvas: controls on top, visual heap tree in the center-left, array and logs on the center-right. This balances visuals and controls so users can perform actions then immediately observe outcomes.</li>
          <li>All UI elements are keyboard-focusable and responsive; node positions animate via CSS transitions to provide visual feedback when the heap state changes.</li>
        </ul>
      </section>

      <!-- Right: Interactive Module -->
      <section class="interactive" aria-label="Priority queue interactive">
        <div class="controls" role="region" aria-label="Controls">
          <div class="control-group">
            <label for="labelInput">Label</label>
            <input id="labelInput" type="text" placeholder="Optional label (A,B,..)" aria-label="node label">
          </div>
          <div class="control-group">
            <label for="priorityInput">Priority</label>
            <input id="priorityInput" type="number" aria-label="node priority" value="0">
          </div>
          <div class="control-group">
            <button id="insertBtn">Insert</button>
            <button id="extractBtn" class="small">Extract Top</button>
            <button id="peekBtn" class="small ghost">Peek</button>
            <button id="clearBtn" class="small ghost">Clear</button>
          </div>
          <div class="control-group" style="margin-left:auto">
            <button id="randomBtn" class="small ghost">Randomize</button>
            <button id="hintBtn" class="small ghost">How it works</button>
          </div>
        </div>

        <div class="visual" role="region" aria-label="Heap visualization">
          <div class="tree-wrap" aria-hidden="false">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
              <div style="display:flex;flex-direction:column;">
                <div style="font-weight:700">Heap Tree</div>
                <div class="muted" style="font-size:12px">Click nodes to edit priority</div>
              </div>
              <div style="display:flex;gap:8px;align-items:center;">
                <div class="muted-cap">Top:</div>
                <div id="topBadge" style="min-width:90px;text-align:center;padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--muted);font-weight:700">—</div>
              </div>
            </div>

            <div class="tree-area" id="treeArea" aria-live="polite"></div>
          </div>

          <aside class="array" aria-label="Array and log">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div style="font-weight:700">Array (underlying)</div>
              <div style="font-size:12px;color:var(--muted)">Index 0 → root</div>
            </div>
            <div class="row" id="arrayRow" role="list"></div>

            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div style="font-weight:700">Operation Log</div>
              <div style="font-size:12px;color:var(--muted)">(latest first)</div>
            </div>
            <div class="log" id="log" role="log" aria-live="polite"></div>
          </aside>
        </div>
      </section>
    </main>
  </div>

  <script>
    /* Priority Queue visualizer (binary heap) - Vanilla JS
       - Min or Max heap (select)
       - Insert, Extract, Peek, Clear, Randomize
       - Click node to change priority
       - Animated positions via absolute positioning with CSS transitions
    */

    (function(){
      // Utilities
      const $ = (s, root=document) => root.querySelector(s);
      const $$ = (s, root=document) => Array.from(root.querySelectorAll(s));

      const treeArea = $('#treeArea');
      const arrayRow = $('#arrayRow');
      const logEl = $('#log');
      const topBadge = $('#topBadge');
      const heapTypeSelect = $('#heapType');
      const labelInput = $('#labelInput');
      const priorityInput = $('#priorityInput');
      const insertBtn = $('#insertBtn');
      const extractBtn = $('#extractBtn');
      const peekBtn = $('#peekBtn');
      const clearBtn = $('#clearBtn');
      const randomBtn = $('#randomBtn');
      const hintBtn = $('#hintBtn');

      // State
      let heap = []; // elements: {id, label, priority}
      let idCounter = 1;
      let animInProgress = false;

      function cmp(a,b){
        if (heapTypeSelect.value === 'min') return a.priority - b.priority;
        return b.priority - a.priority; // reverse for max
      }

      function log(msg){
        const it = document.createElement('div');
        it.className = 'item';
        it.textContent = `${new Date().toLocaleTimeString()} — ${msg}`;
        logEl.prepend(it);
      }

      function render(){
        // Render array
        arrayRow.innerHTML = '';
        heap.forEach((el, idx) => {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.setAttribute('role','listitem');
          cell.dataset.idx = idx;
          cell.tabIndex = 0;
          if (idx === 0) cell.classList.add('hi');
          cell.innerHTML = `<div>${el.label}</div><span class="sub">p:${el.priority}</span>`;
          arrayRow.appendChild(cell);
        });
        if (heap.length === 0){
          const slot = document.createElement('div');
          slot.className = 'cell';
          slot.style.opacity = 0.6;
          slot.style.minWidth = '100%';
          slot.textContent = 'Heap is empty';
          arrayRow.appendChild(slot);
        }

        // Render tree nodes with absolute positions
        treeArea.innerHTML = '';
        const width = treeArea.clientWidth;
        const height = treeArea.clientHeight;
        const levelHeight = Math.max(48, Math.floor(height / (Math.floor(Math.log2(Math.max(2,heap.length))) + 2)));

        // compute positions for each index
        const positions = heap.map((_,i) => {
          const level = Math.floor(Math.log2(i+1));
          const indexInLevel = i - (2**level - 1);
          const nodesInLevel = 2**level;
          const levelY = level * levelHeight + 10;
          // horizontal spread: divide width into nodesInLevel+1 segments
          const gap = width / (nodesInLevel + 1);
          const x = gap * (indexInLevel + 1) - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-size')) || 56)/2;
          return {left: Math.max(6, Math.min(width-70, Math.round(x))), top: Math.round(levelY)};
        });

        // Add connectors first (so they sit beneath nodes)
        for (let i=1;i<heap.length;i++){
          const parentIdx = Math.floor((i-1)/2);
          const a = positions[parentIdx];
          const b = positions[i];
          // draw a thin rotated rectangle from parent center to child center
          const parentCenter = {x: a.left + 28, y: a.top + 28};
          const childCenter = {x: b.left + 28, y: b.top + 28};
          const dx = childCenter.x - parentCenter.x;
          const dy = childCenter.y - parentCenter.y;
          const length = Math.sqrt(dx*dx + dy*dy);
          const angle = Math.atan2(dy,dx) * 180 / Math.PI;
          const connector = document.createElement('div');
          connector.className = 'connector';
          connector.style.width = Math.max(2, length) + 'px';
          connector.style.left = parentCenter.x + 'px';
          connector.style.top = parentCenter.y + 'px';
          connector.style.transform = `translate(-0px, -0px) rotate(${angle}deg)`;
          treeArea.appendChild(connector);
        }

        // Add nodes
        heap.forEach((el, idx) => {
          const pos = positions[idx];
          const node = document.createElement('div');
          node.className = 'node';
          node.dataset.idx = idx;
          node.setAttribute('role','button');
          node.setAttribute('aria-label', `Node ${el.label}, priority ${el.priority}, index ${idx}`);
          node.tabIndex = 0;
          node.style.left = pos.left + 'px';
          node.style.top = pos.top + 'px';
          node.innerHTML = `<div>${el.label}</div><span class="p">p:${el.priority}</span>`;
          // highlight root
          if (idx===0) node.classList.add('highlight');
          treeArea.appendChild(node);

          // click handler
          node.addEventListener('click', (e) => {
            if (animInProgress) return;
            editNodePriority(idx);
          });
          node.addEventListener('keydown', (e) => {
            if (animInProgress) return;
            if (e.key === 'Enter' || e.key === ' ') { editNodePriority(idx); e.preventDefault(); }
          });
        });

        // Top badge
        topBadge.textContent = heap.length ? `${heap[0].label} (p:${heap[0].priority})` : '—';
      }

      // Heap operations (no animation step-by-step; we animate by re-rendering positions)
      function swap(i,j){
        const t = heap[i];
        heap[i] = heap[j];
        heap[j] = t;
      }

      // bubbleUp with animation between intermediate states
      async function bubbleUp(idx){
        animInProgress = true;
        while (idx > 0){
          const parent = Math.floor((idx-1)/2);
          if (cmp(heap[idx], heap[parent]) < 0){
            swap(idx, parent);
            render();
            await wait(420);
            idx = parent;
          } else break;
        }
        animInProgress = false;
      }

      async function bubbleDown(idx){
        animInProgress = true;
        const n = heap.length;
        while (true){
          const left = idx*2+1;
          const right = idx*2+2;
          let candidate = idx;
          if (left < n && cmp(heap[left], heap[candidate]) < 0) candidate = left;
          if (right < n && cmp(heap[right], heap[candidate]) < 0) candidate = right;
          if (candidate !== idx){
            swap(idx, candidate);
            render();
            await wait(420);
            idx = candidate;
          } else break;
        }
        animInProgress = false;
      }

      function wait(ms){ return new Promise(res => setTimeout(res, ms)); }

      // Public actions
      async function doInsert(label, priority){
        if (animInProgress) return;
        const el = {
          id: idCounter++,
          label: label || `N${idCounter}`,
          priority: Number(priority)
        };
        heap.push(el);
        render();
        // mark last node as new briefly (find element in tree)
        const nodes = $$('.node', treeArea);
        const lastNode = nodes.find(n => n.dataset.idx == (heap.length-1));
        if (lastNode){
          lastNode.classList.add('new');
          setTimeout(()=>lastNode.classList.remove('new'), 600);
        }
        log(`Inserted ${el.label} with priority ${el.priority}`);
        await bubbleUp(heap.length-1);
      }

      async function doExtract(){
        if (animInProgress) return;
        if (!heap.length){ log('Extract attempted on empty heap'); return; }
        const top = heap[0];
        const last = heap.pop();
        if (heap.length > 0){
          heap[0] = last;
        }
        render();
        log(`Extracted ${top.label} (p:${top.priority})`);
        if (heap.length>0){
          await bubbleDown(0);
        }
      }

      function doPeek(){
        if (!heap.length){ log('Peek: heap is empty'); return; }
        log(`Peek: ${heap[0].label} (p:${heap[0].priority})`);
      }

      function doClear(){
        if (animInProgress) return;
        heap = [];
        idCounter = 1;
        render();
        log('Cleared heap');
      }

      function randomize(n=7){
        if (animInProgress) return;
        heap = [];
        idCounter = 1;
        for (let i=0;i<n;i++){
          const p = Math.floor(Math.random()*100) - 40;
          heap.push({id:idCounter++, label:String.fromCharCode(65 + (i%26)), priority:p});
        }
        // heapify in-place: build-heap
        for (let i=Math.floor(heap.length/2); i>=0; i--){
          // use iterative bubbleDown (no animation)
          let idx = i;
          while (true){
            const left = idx*2+1;
            const right = idx*2+2;
            let candidate = idx;
            if (left < heap.length && cmp(heap[left], heap[candidate]) < 0) candidate = left;
            if (right < heap.length && cmp(heap[right], heap[candidate]) < 0) candidate = right;
            if (candidate !== idx){
              swap(idx, candidate);
              idx = candidate;
            } else break;
          }
        }
        render();
        log(`Randomized ${n} items`);
      }

      // Edit node priority via prompt (simpler than inline editor, accessible)
      async function editNodePriority(idx){
        const node = heap[idx];
        const newStr = prompt(`Change priority for ${node.label} (current p:${node.priority})`, String(node.priority));
        if (newStr === null) return;
        const newP = Number(newStr);
        if (Number.isNaN(newP)) { alert('Please enter a numeric priority'); return; }
        const old = node.priority;
        node.priority = newP;
        render();
        log(`Changed ${node.label} priority ${old} → ${newP}`);
        // after changing, decide to bubble up or down
        if (heapTypeSelect.value === 'min'){
          if (newP < old) await bubbleUp(idx);
          else if (newP > old) await bubbleDown(idx);
        } else {
          if (newP > old) await bubbleUp(idx);
          else if (newP < old) await bubbleDown(idx);
        }
      }

      // Event bindings
      insertBtn.addEventListener('click', () => {
        const label = labelInput.value.trim() || null;
        const pri = Number(priorityInput.value);
        if (Number.isNaN(pri)){ alert('Please enter a numeric priority'); return; }
        doInsert(label, pri);
      });

      extractBtn.addEventListener('click', () => { doExtract(); });
      peekBtn.addEventListener('click', () => { doPeek(); });
      clearBtn.addEventListener('click', () => {
        if (!confirm('Clear the heap?')) return;
        doClear();
      });
      randomBtn.addEventListener('click', () => {
        const n = parseInt(prompt('How many nodes to generate?', '7') || '7', 10);
        if (!Number.isInteger(n) || n<=0 || n>40){ alert('Enter an integer 1..40'); return; }
        randomize(n);
      });

      heapTypeSelect.addEventListener('change', () => {
        // Rebuild heap according to new comparator
        // Simple: re-run heapify
        for (let i=Math.floor(heap.length/2); i>=0; i--){
          let idx = i;
          while (true){
            const left = idx*2+1;
            const right = idx*2+2;
            let candidate = idx;
            if (left < heap.length && cmp(heap[left], heap[candidate]) < 0) candidate = left;
            if (right < heap.length && cmp(heap[right], heap[candidate]) < 0) candidate = right;
            if (candidate !== idx){
              swap(idx, candidate);
              idx = candidate;
            } else break;
          }
        }
        render();
        log(`Switched heap type to ${heapTypeSelect.value}`);
      });

      hintBtn.addEventListener('click', () => {
        alert('A priority queue returns the element with the highest priority.\n\nThis module uses a binary heap: an array-backed complete binary tree. Insertion appends to the array and then "bubbles up" to restore heap order. Extraction removes the root, replaces it with the last element, and "bubbles down" to restore order. Toggle between Min-Heap and Max-Heap to change which priority is considered highest.');
      });

      // keyboard shortcut: Enter in priority field inserts
      priorityInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') insertBtn.click();
      });

      // initial render
      render();
      log('Module loaded — ready');

      // accessibility: ensure tree area is focusable
      treeArea.tabIndex = -1;

      // Resize observer to re-render positions when tree area changes
      const ro = new ResizeObserver(() => render());
      ro.observe(treeArea);

      // Prepopulate small example
      randomize(5);

    })();
  </script>
</body>
</html>