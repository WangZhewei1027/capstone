<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bellman-Ford Interactive Module</title>
  <style>
    /* Safe area margins: 24px */
    :root {
      --safe-pad: 24px;
      --gap: 16px; /* minimum spacing between interactive elements */
      --panel-bg: #fbfbff;
      --accent: #1e88e5;
      --accent-2: #8e24aa;
      --danger: #d32f2f;
      --muted: #6b7280;
      --node-radius: 22;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#ffffff 0%, #f6f8ff 100%);
      color: #0f172a;
    }
    /* Container */
    .app {
      padding: var(--safe-pad);
      box-sizing: border-box;
      min-height: 100%;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    /* Header info sections */
    .intro {
      background: var(--panel-bg);
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 4px 18px rgba(19,24,39,0.06);
      display:flex;
      gap: 24px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .intro .title {
      font-size: 20px;
      font-weight: 700;
      color: #0b1220;
      margin-bottom: 6px;
    }
    .meta {
      font-size: 13px;
      color: var(--muted);
      line-height:1.4;
    }
    .meta b { color: #0b1220; }

    /* Main layout */
    .main {
      display: grid;
      grid-template-columns: 280px 1fr 320px;
      gap: var(--gap);
      align-items: start;
    }

    /* Left controls */
    .controls {
      background: white;
      padding: 16px;
      border-radius: 10px;
      box-shadow: 0 6px 20px rgba(16,24,40,0.04);
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      min-height: 340px;
    }
    .controls h3 {
      margin:0;
      font-size:15px;
    }
    .btn-row {
      display:flex;
      gap: var(--gap);
      flex-wrap:wrap;
    }
    button, select, input[type="number"], .small {
      font-size: 14px;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid rgba(15,23,42,0.08);
      background: white;
      cursor: pointer;
    }
    button.primary {
      background: linear-gradient(90deg,var(--accent), #3b82f6);
      color: white;
      border: none;
    }
    button.ghost {
      background: transparent;
      border: 1px dashed rgba(15,23,42,0.06);
    }
    .small {
      padding: 8px;
    }
    .control-group {
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    label { font-size: 13px; color: var(--muted); }

    /* Canvas area */
    .canvas-card {
      background: white;
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 6px 28px rgba(16,24,40,0.06);
      min-height: 480px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .canvas-top {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      padding: 6px 8px;
    }
    .canvas-area {
      border-radius:10px;
      background: linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);
      border: 1px solid rgba(15,23,42,0.04);
      flex:1;
      min-height: 420px;
      position:relative;
      overflow:hidden;
    }

    /* Right panel */
    .panel {
      background: white;
      border-radius: 10px;
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap: 12px;
      box-shadow: 0 6px 20px rgba(16,24,40,0.04);
    }
    .panel h4 { margin:0; font-size:14px; }
    .dist-list {
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .dist-item {
      display:flex;
      justify-content:space-between;
      padding:8px;
      border-radius:8px;
      background: #fbfbff;
      font-size:14px;
      align-items:center;
    }
    .muted { color:var(--muted); font-size:13px; }

    /* SVG elements (graph) */
    svg {
      width: 100%;
      height: 100%;
      display:block;
    }
    .edge {
      stroke: #a3b4d8;
      stroke-width: 2.2;
      fill: none;
      transition: stroke 0.24s, stroke-width 0.24s;
    }
    .edge .label {
      font-size:12px;
      fill: #0b1220;
      user-select:none;
      pointer-events:none;
    }
    .edge.active {
      stroke: var(--accent);
      stroke-width: 3.3;
      filter: drop-shadow(0 6px 12px rgba(30,136,229,0.12));
      animation: pulse 1s infinite ease-in-out;
    }
    @keyframes pulse {
      0% { stroke-width: 3.3; opacity: 1; }
      50% { stroke-width: 4.8; opacity: 0.85; }
      100% { stroke-width: 3.3; opacity: 1; }
    }
    .node {
      cursor:pointer;
      transition: transform 0.14s, box-shadow 0.14s;
    }
    .node circle {
      fill: linear-gradient(180deg, #ffffff, #f3f6ff);
      stroke: #e6eefb;
      stroke-width: 2;
      r: var(--node-radius);
      transition: fill 0.18s, stroke 0.18s;
    }
    .node .n-fill {
      fill: #ffffff;
      transition: fill 0.2s;
    }
    .node.active circle {
      transform: scale(1.06);
      filter: drop-shadow(0 8px 18px rgba(30,136,229,0.12));
      stroke: var(--accent);
    }
    .node-label {
      font-weight:700;
      font-size:13px;
      pointer-events:none;
      fill: #0b1220;
    }
    .dist-label {
      font-size:12px;
      fill: #003366;
      font-weight:700;
    }
    .pred-label {
      font-size:11px;
      fill: #6b7280;
    }

    /* small helper elements */
    .hint {
      font-size:12px;
      color:var(--muted);
    }
    .log {
      font-size:13px;
      color:#0b1220;
      max-height: 220px;
      overflow:auto;
      padding:8px;
      background:#fafbff;
      border-radius:8px;
    }

    /* responsive */
    @media (max-width: 1000px) {
      .main {
        grid-template-columns: 1fr;
      }
      .controls, .panel {
        order:2;
      }
      .canvas-card {
        order:1;
      }
    }
  </style>
</head>
<body>
  <div class="app" role="main">
    <div class="intro" aria-labelledby="title">
      <div style="flex:1; min-width:260px;">
        <div class="title" id="title">Bellman-Ford Algorithm — Single-Source Shortest Paths (step-by-step)</div>
        <div class="meta">
          Concept Title: <b>Bellman-Ford Relaxation & Negative-Cycle Detection</b><br>
          Learning Objective: <b>Understand iterative edge relaxation, distance propagation (including negative weights), and how Bellman-Ford detects negative cycles.</b>
        </div>
      </div>

      <div style="min-width:320px;">
        <div class="meta"><b>Interaction Design</b> — Click "Add Node" then click canvas to place nodes. Click "Add Edge" then click source node then target node and enter a weight (negative allowed). Drag nodes to arrange. Choose a source node, then run step-by-step: "Next" highlights each edge relaxation and updates distances with a brief animation. "Auto" plays iterations. After n-1 iterations, the module performs a final pass and reports negative-cycle detection. Visual feedback includes edge highlighting (pulsing), node highlight, and animated distance updates. Use "Reset" to clear or "Clear Steps" to reconfigure.</div>
      </div>
    </div>

    <div class="main" role="region" aria-label="Bellman-Ford interactive module">
      <!-- Controls -->
      <aside class="controls" aria-label="Controls">
        <h3>Graph Controls</h3>
        <div class="control-group">
          <div class="btn-row">
            <button id="addNodeBtn" class="small" aria-pressed="false">Add Node</button>
            <button id="addEdgeBtn" class="small" aria-pressed="false">Add Edge</button>
            <button id="dragBtn" class="small" aria-pressed="true">Drag Nodes</button>
          </div>
          <div class="hint">Minimum spacing between controls: 16px. Click "Add Node" then click canvas to place. Drag toggles node dragging mode.</div>
        </div>

        <div class="control-group">
          <label for="sourceSelect">Select Source Node</label>
          <select id="sourceSelect" aria-label="Source node selection">
            <option value="">(none)</option>
          </select>
        </div>

        <div class="control-group">
          <h3>Algorithm Controls</h3>
          <div class="btn-row">
            <button id="prepareBtn" class="small">Prepare Run</button>
            <button id="nextBtn" class="small" disabled>Next</button>
            <button id="prevBtn" class="small" disabled>Prev</button>
            <button id="autoBtn" class="small">Auto</button>
          </div>
          <div class="btn-row">
            <button id="resetBtn" class="small ghost">Reset Graph</button>
            <button id="clearStepsBtn" class="small ghost">Clear Steps</button>
          </div>
          <div class="hint">Prepare Run builds step-by-step snapshots from current graph and chosen source. Then step through or auto-play.</div>
        </div>

        <div class="control-group">
          <label>Status</label>
          <div id="status" class="muted">Idle. Add nodes and edges to begin.</div>
        </div>
      </aside>

      <!-- Canvas -->
      <section class="canvas-card" aria-label="Graph canvas">
        <div class="canvas-top">
          <div class="muted">Canvas — Click to add nodes while in Add Node mode. Drag to reposition when Drag Nodes is active.</div>
          <div class="muted">Nodes: <span id="nodeCount">0</span> • Edges: <span id="edgeCount">0</span> • Steps: <span id="stepCount">0</span></div>
        </div>
        <div class="canvas-area" id="canvasArea" tabindex="0" aria-label="Graph drawing area">
          <!-- SVG for drawing -->
          <svg id="graphSvg" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet" aria-hidden="false">
            <defs>
              <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#9fb0d8"></path>
              </marker>
              <marker id="arrow-active" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="9" markerHeight="9" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#1e88e5"></path>
              </marker>
            </defs>
            <!-- edges and nodes get inserted here -->
            <g id="edgesLayer"></g>
            <g id="nodesLayer"></g>
          </svg>
        </div>
      </section>

      <!-- Right panel -->
      <aside class="panel" aria-label="Algorithm output">
        <div>
          <h4>Distances & Predecessors</h4>
          <div id="distanceList" class="dist-list" aria-live="polite">
            <div class="muted">No data yet. Prepare run to compute steps.</div>
          </div>
        </div>

        <div>
          <h4>Iteration & Step</h4>
          <div class="muted">Iteration: <span id="iterationLabel">—</span> • Current Edge: <span id="currentEdgeLabel">—</span></div>
          <div class="log" id="logArea" aria-live="polite">Log output will appear here.</div>
        </div>
      </aside>
    </div>
  </div>

  <script>
    /* Bellman-Ford Interactive Module (vanilla JS)
       - Single-file, self-contained.
       - Allows adding nodes, edges (directed), negative weights, dragging nodes.
       - Builds step snapshots for Bellman-Ford (n-1 iterations + negative cycle check)
       - Step forward/back with animations and edge highlight.
    */

    /* --- Data models --- */
    const nodes = []; // {id: 'A', x, y}
    const edges = []; // {from:'A', to:'B', w: number}
    let nodeCounter = 0;

    /* --- DOM references --- */
    const svg = document.getElementById('graphSvg');
    const edgesLayer = document.getElementById('edgesLayer');
    const nodesLayer = document.getElementById('nodesLayer');

    const addNodeBtn = document.getElementById('addNodeBtn');
    const addEdgeBtn = document.getElementById('addEdgeBtn');
    const dragBtn = document.getElementById('dragBtn');
    const prepareBtn = document.getElementById('prepareBtn');
    const nextBtn = document.getElementById('nextBtn');
    const prevBtn = document.getElementById('prevBtn');
    const autoBtn = document.getElementById('autoBtn');
    const resetBtn = document.getElementById('resetBtn');
    const clearStepsBtn = document.getElementById('clearStepsBtn');

    const sourceSelect = document.getElementById('sourceSelect');
    const statusEl = document.getElementById('status');
    const nodeCountEl = document.getElementById('nodeCount');
    const edgeCountEl = document.getElementById('edgeCount');
    const stepCountEl = document.getElementById('stepCount');

    const distanceList = document.getElementById('distanceList');
    const iterationLabel = document.getElementById('iterationLabel');
    const currentEdgeLabel = document.getElementById('currentEdgeLabel');
    const logArea = document.getElementById('logArea');

    const canvasArea = document.getElementById('canvasArea');

    /* --- Interaction state --- */
    let mode = 'drag'; // 'addNode' | 'addEdge' | 'drag'
    let addEdgeFrom = null;
    let draggingNode = null;
    let dragOffset = {x:0,y:0};
    let svgRect = svg.getBoundingClientRect();

    /* --- Bellman-Ford step data --- */
    let snapshots = []; // array of {dist: {...}, pred: {...}, iteration, edgeIndex}
    let steps = []; // meta steps: {iteration, edgeIndex, u, v, w, relaxed:boolean}
    let currentSnapshotIndex = 0;
    let autoTimer = null;

    /* Utility: generate label (A,B,C... Z, A1, B1...) */
    function genNodeLabel(i){
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      const base = letters[i % letters.length];
      const suffix = Math.floor(i / letters.length);
      return suffix===0 ? base : base + suffix;
    }

    function setMode(m){
      mode = m;
      addNodeBtn.classList.toggle('primary', m==='addNode');
      addEdgeBtn.classList.toggle('primary', m==='addEdge');
      dragBtn.classList.toggle('primary', m==='drag');
      addNodeBtn.setAttribute('aria-pressed', m==='addNode');
      addEdgeBtn.setAttribute('aria-pressed', m==='addEdge');
      dragBtn.setAttribute('aria-pressed', m==='drag');
      status('Mode: ' + m);
    }

    function status(s){
      statusEl.textContent = s;
    }

    /* --- Graph rendering --- */
    function render(){
      edgesLayer.innerHTML = '';
      nodesLayer.innerHTML = '';

      // draw edges
      edges.forEach((e, i) => {
        const u = findNode(e.from);
        const v = findNode(e.to);
        if(!u || !v) return;

        // compute line from u to v with some offset for circle radius
        const dx = v.x - u.x;
        const dy = v.y - u.y;
        const dist = Math.hypot(dx,dy) || 1;
        const r = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--node-radius')) || 22;

        const ux = u.x + (dx/dist) * r;
        const uy = u.y + (dy/dist) * r;
        const vx = v.x - (dx/dist) * r * 1.05;
        const vy = v.y - (dy/dist) * r * 1.05;

        // edge group
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('data-edge-index', i);
        g.classList.add('edge-group');

        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', `M ${ux} ${uy} L ${vx} ${vy}`);
        path.setAttribute('class','edge');
        path.setAttribute('id','edge-'+i);

        // choose arrow marker based on active class applied later
        path.setAttribute('marker-end','url(#arrow)');

        g.appendChild(path);

        // weight label near middle
        const midx = (ux+vx)/2 + (-dy/dist)*14;
        const midy = (uy+vy)/2 + (dx/dist)*-12;

        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.setAttribute('x', midx);
        text.setAttribute('y', midy);
        text.setAttribute('class', 'label edge-label');
        text.setAttribute('text-anchor','middle');
        text.textContent = String(e.w);
        g.appendChild(text);

        // add clickable path area
        edgesLayer.appendChild(g);

        // allow clicking edge to highlight (optional)
        g.addEventListener('click', (ev) => {
          ev.stopPropagation();
          highlightEdge(i);
          log(`Edge clicked (${e.from} → ${e.to}, w=${e.w})`);
        });
      });

      // draw nodes (top)
      nodes.forEach((n) => {
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('transform', `translate(${n.x},${n.y})`);
        g.setAttribute('class','node');
        g.setAttribute('data-node-id', n.id);

        const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circ.setAttribute('r', '22');
        circ.setAttribute('class','n-fill');
        g.appendChild(circ);

        const label = document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('y', 5);
        label.setAttribute('text-anchor','middle');
        label.setAttribute('class','node-label');
        label.textContent = n.id;
        g.appendChild(label);

        // distance and pred labels (populated from snapshots view)
        const dlabel = document.createElementNS('http://www.w3.org/2000/svg','text');
        dlabel.setAttribute('y', 40);
        dlabel.setAttribute('text-anchor','middle');
        dlabel.setAttribute('class','dist-label');
        dlabel.setAttribute('data-dist-label', n.id);
        dlabel.textContent = '';
        g.appendChild(dlabel);

        const plabel = document.createElementNS('http://www.w3.org/2000/svg','text');
        plabel.setAttribute('y', 55);
        plabel.setAttribute('text-anchor','middle');
        plabel.setAttribute('class','pred-label');
        plabel.setAttribute('data-pred-label', n.id);
        plabel.textContent = '';
        g.appendChild(plabel);

        // events for interaction
        g.addEventListener('mousedown', (ev) => onNodeMouseDown(ev, n));
        g.addEventListener('touchstart', (ev) => onNodeMouseDown(ev, n), {passive:false});
        g.addEventListener('click', (ev) => onNodeClick(ev, n));
        nodesLayer.appendChild(g);
      });

      updateCounts();
      refreshSourceOptions();
    }

    function updateCounts(){
      nodeCountEl.textContent = nodes.length;
      edgeCountEl.textContent = edges.length;
      stepCountEl.textContent = steps.length;
    }

    function findNode(id){
      return nodes.find(n => n.id === id);
    }

    /* --- Mouse/Touch interactions --- */
    function getSvgPoint(evt){
      const rect = svg.getBoundingClientRect();
      const x = (evt.clientX || (evt.touches && evt.touches[0].clientX)) - rect.left;
      const y = (evt.clientY || (evt.touches && evt.touches[0].clientY)) - rect.top;
      // Map to SVG coordinates: our viewBox is 1000x700
      const svgW = rect.width, svgH = rect.height;
      const viewW = 1000, viewH = 700;
      return {
        x: (x / svgW) * viewW,
        y: (y / svgH) * viewH
      };
    }

    canvasArea.addEventListener('click', (ev) => {
      // convert to svg coords
      const pt = getSvgPoint(ev);
      if(mode === 'addNode'){
        addNode(pt.x, pt.y);
      } else {
        // clicking empty area clears pending addEdgeFrom
        addEdgeFrom = null;
      }
    });

    function onNodeMouseDown(ev, node){
      ev.stopPropagation();
      if(mode === 'drag'){
        draggingNode = node;
        const pt = getSvgPoint(ev);
        dragOffset.x = node.x - pt.x;
        dragOffset.y = node.y - pt.y;
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        document.addEventListener('touchmove', onTouchMove, {passive:false});
        document.addEventListener('touchend', onMouseUp);
      }
    }

    function onNodeClick(ev, node){
      ev.stopPropagation();
      if(mode === 'addEdge'){
        if(!addEdgeFrom){
          addEdgeFrom = node.id;
          status(`Select target node for edge from ${node.id}.`);
        } else {
          const from = addEdgeFrom;
          const to = node.id;
          addEdgeFrom = null;
          // prompt for weight
          const w = prompt(`Weight for edge ${from} → ${to} (can be negative):`, "1");
          if(w !== null){
            const num = Number(w);
            if(Number.isFinite(num)){
              edges.push({from, to, w: num});
              render();
              status(`Added edge ${from}→${to} (w=${num}).`);
            } else {
              status('Invalid weight. Edge not added.');
            }
          } else {
            status('Edge creation canceled.');
          }
        }
      } else {
        // select node as source if running not prepared
        // also highlight briefly
        highlightNode(node.id);
      }
    }

    function onMouseMove(ev){
      if(!draggingNode) return;
      const pt = getSvgPoint(ev);
      draggingNode.x = pt.x + dragOffset.x;
      draggingNode.y = pt.y + dragOffset.y;
      // clamp within viewbox
      draggingNode.x = Math.max(40, Math.min(960, draggingNode.x));
      draggingNode.y = Math.max(40, Math.min(660, draggingNode.y));
      render();
    }
    function onTouchMove(ev){
      ev.preventDefault();
      onMouseMove(ev.touches[0]);
    }
    function onMouseUp(){
      draggingNode = null;
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      document.removeEventListener('touchmove', onTouchMove);
      document.removeEventListener('touchend', onMouseUp);
    }

    /* --- Node / Edge management --- */
    function addNode(x = 500, y = 350){
      const id = genNodeLabel(nodeCounter++);
      nodes.push({id, x, y});
      render();
      status(`Added node ${id}.`);
      updateSourceOptions();
    }

    function clearGraph(){
      nodes.length = 0;
      edges.length = 0;
      nodeCounter = 0;
      snapshots = [];
      steps = [];
      currentSnapshotIndex = 0;
      stopAuto();
      render();
      refreshDisplaySnapshot();
      status('Graph reset.');
      updateSourceOptions();
      log('Cleared graph.');
    }

    function resetStepsOnly(){
      snapshots = [];
      steps = [];
      currentSnapshotIndex = 0;
      stopAuto();
      refreshDisplaySnapshot();
      status('Steps cleared. You can modify graph or prepare again.');
      log('Cleared steps.');
      updateCounts();
    }

    /* --- UI updates --- */
    function refreshSourceOptions(){
      // Save selection
      const prev = sourceSelect.value;
      sourceSelect.innerHTML = '<option value="">(none)</option>';
      nodes.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n.id;
        opt.textContent = n.id;
        sourceSelect.appendChild(opt);
      });
      if(nodes.find(n => n.id === prev)){
        sourceSelect.value = prev;
      }
    }
    function updateSourceOptions(){
      refreshSourceOptions();
    }

    /* --- Highlight helpers --- */
    function highlightEdge(index){
      // clear others
      document.querySelectorAll('.edge').forEach(el => {
        el.classList.remove('active');
        el.setAttribute('marker-end','url(#arrow)');
      });
      const path = document.getElementById('edge-'+index);
      if(path){
        path.classList.add('active');
        path.setAttribute('marker-end','url(#arrow-active)');
      }
      const e = edges[index];
      currentEdgeLabel.textContent = e ? `${e.from}→${e.to} (w=${e.w})` : '—';
    }

    function highlightNode(id){
      document.querySelectorAll('.node').forEach(el => el.classList.remove('active'));
      const g = nodesLayer.querySelector(`[data-node-id="${id}"]`);
      if(g) g.classList.add('active');
      status('Selected node: ' + id);
    }

    function clearHighlights(){
      document.querySelectorAll('.edge').forEach(el => {
        el.classList.remove('active');
        el.setAttribute('marker-end','url(#arrow)');
      });
      document.querySelectorAll('.node').forEach(el => el.classList.remove('active'));
      currentEdgeLabel.textContent = '—';
      iterationLabel.textContent = '—';
    }

    /* --- Logging --- */
    function log(msg){
      const now = new Date().toLocaleTimeString();
      logArea.innerHTML = `<div style="margin-bottom:6px"><b>[${now}]</b> ${escapeHtml(msg)}</div>` + logArea.innerHTML;
    }
    function escapeHtml(s){
      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    /* --- Bellman-Ford snapshot builder --- */
    function prepareBellmanFord(){
      snapshots = [];
      steps = [];
      currentSnapshotIndex = 0;
      stopAuto();
      clearHighlights();

      if(nodes.length === 0){
        status('No nodes to run algorithm.');
        return;
      }
      const source = sourceSelect.value;
      if(!source){
        status('Please select a source node.');
        return;
      }

      const INF = Number.POSITIVE_INFINITY;
      // initialize
      const dist = {};
      const pred = {};
      nodes.forEach(n => { dist[n.id] = INF; pred[n.id] = null; });
      dist[source] = 0;

      // initial snapshot (iteration 0)
      snapshots.push({dist: clone(dist), pred: {...pred}, iteration: 0, edgeIndex: -1});
      log(`Prepared Bellman-Ford with source ${source}. Nodes=${nodes.length}, Edges=${edges.length}`);

      const n = nodes.length;
      // perform n-1 iterations
      for(let iter = 1; iter <= n-1; iter++){
        // for each edge
        edges.forEach((e, ei) => {
          const u = e.from, v = e.to, w = e.w;
          const old = dist[v];
          let relaxed = false;
          if(dist[u] !== INF && dist[u] + w < dist[v]){
            dist[v] = dist[u] + w;
            pred[v] = u;
            relaxed = true;
          }
          // record this edge check as a step with snapshot after applying (if applied)
          snapshots.push({dist: clone(dist), pred: {...pred}, iteration: iter, edgeIndex: ei});
          steps.push({iteration: iter, edgeIndex: ei, u, v, w, relaxed});
        });
      }

      // final pass to detect negative cycles (if any edge can still relax)
      let negCycleDetected = false;
      edges.forEach((e, ei) => {
        const u = e.from, v = e.to, w = e.w;
        let relaxed = false;
        if(dist[u] !== INF && dist[u] + w < dist[v]){
          relaxed = true;
          negCycleDetected = true;
        }
        snapshots.push({dist: clone(dist), pred: {...pred}, iteration: n, edgeIndex: ei});
        steps.push({iteration: n, edgeIndex: ei, u, v, w, relaxed});
      });

      // summary snapshot
      snapshots.push({dist: clone(dist), pred: {...pred}, iteration: n+1, edgeIndex: -1, negCycleDetected});
      stepCountEl.textContent = steps.length;

      if(negCycleDetected){
        log('Negative cycle detected during final check.');
        status('Prepared. Negative cycle may exist (see final pass).');
      } else {
        log('Prepared. No negative cycle detected in final check.');
        status('Prepared. No negative cycle detected.');
      }

      // enable step controls
      nextBtn.disabled = false;
      prevBtn.disabled = false;
      currentSnapshotIndex = 0;
      refreshDisplaySnapshot();
    }

    function clone(obj){
      return JSON.parse(JSON.stringify(obj));
    }

    /* --- Step controls --- */
    function refreshDisplaySnapshot(){
      // clamp index
      currentSnapshotIndex = Math.max(0, Math.min(snapshots.length - 1, currentSnapshotIndex));
      const snap = snapshots[currentSnapshotIndex];
      if(!snap){
        // nothing to display
        distanceList.innerHTML = '<div class="muted">No snapshots. Prepare run.</div>';
        iterationLabel.textContent = '—';
        currentEdgeLabel.textContent = '—';
        clearHighlights();
        return;
      }
      // update distance panel
      distanceList.innerHTML = '';
      nodes.forEach(n => {
        const d = snap.dist[n.id];
        const p = snap.pred[n.id];
        const item = document.createElement('div');
        item.className = 'dist-item';
        item.innerHTML = `<div><b>${n.id}</b></div><div>${d === Infinity ? '∞' : d} ${p ? '• pred=' + p : ''}</div>`;
        distanceList.appendChild(item);
      });

      iterationLabel.textContent = snap.iteration;
      if(snap.edgeIndex >= 0){
        const e = edges[snap.edgeIndex];
        currentEdgeLabel.textContent = `${e.from}→${e.to} (w=${e.w})`;
      } else {
        currentEdgeLabel.textContent = '—';
      }

      // update node labels on canvas
      nodes.forEach(n => {
        const dtext = svg.querySelector(`[data-dist-label="${n.id}"]`);
        const ptext = svg.querySelector(`[data-pred-label="${n.id}"]`);
        if(dtext) dtext.textContent = (snap.dist[n.id] === Infinity ? '∞' : snap.dist[n.id]);
        if(ptext) ptext.textContent = (snap.pred[n.id] ? 'pred: '+snap.pred[n.id] : '');
      });

      // highlight current edge in SVG
      if(snap.edgeIndex >= 0){
        highlightEdge(snap.edgeIndex);
      } else {
        clearHighlights();
      }

      // write to log an informative line for current step
      if(currentSnapshotIndex === 0){
        log('Initial distances set. Click Next to begin iterations.');
      } else if(currentSnapshotIndex <= steps.length){
        const step = steps[currentSnapshotIndex - 1];
        const msg = `Iteration ${step.iteration}: checking edge ${step.u}→${step.v} (w=${step.w}) — ${step.relaxed ? 'relaxed' : 'no change'}`;
        log(msg);
      } else {
        // final summary
        const last = snapshots[snapshots.length - 1];
        if(last.negCycleDetected){
          log('Final: Negative cycle detected in graph.');
        } else {
          log('Final: No negative cycle detected. Distances finalized.');
        }
      }
    }

    function stepNext(){
      if(snapshots.length === 0) return;
      if(currentSnapshotIndex < snapshots.length - 1){
        currentSnapshotIndex++;
        refreshDisplaySnapshot();
      } else {
        status('Reached last snapshot.');
      }
    }
    function stepPrev(){
      if(snapshots.length === 0) return;
      if(currentSnapshotIndex > 0){
        currentSnapshotIndex--;
        refreshDisplaySnapshot();
      } else {
        status('At initial snapshot.');
      }
    }

    /* --- Auto-run --- */
    function startAuto(){
      if(autoTimer) return;
      autoBtn.textContent = 'Auto: ON';
      autoTimer = setInterval(() => {
        if(currentSnapshotIndex < snapshots.length - 1){
          stepNext();
        } else {
          stopAuto();
        }
      }, 700);
      status('Auto-play started.');
    }
    function stopAuto(){
      if(autoTimer){
        clearInterval(autoTimer);
        autoTimer = null;
        autoBtn.textContent = 'Auto';
        status('Auto-play stopped.');
      }
    }

    /* --- Event wiring --- */
    addNodeBtn.addEventListener('click', () => setMode('addNode'));
    addEdgeBtn.addEventListener('click', () => setMode('addEdge'));
    dragBtn.addEventListener('click', () => setMode('drag'));

    prepareBtn.addEventListener('click', () => {
      prepareBellmanFord();
    });
    nextBtn.addEventListener('click', () => {
      stepNext();
    });
    prevBtn.addEventListener('click', () => {
      stepPrev();
    });
    autoBtn.addEventListener('click', () => {
      if(autoTimer) stopAuto(); else startAuto();
    });
    resetBtn.addEventListener('click', () => {
      if(confirm('Reset graph? This clears nodes, edges, and steps.')){
        clearGraph();
      }
    });
    clearStepsBtn.addEventListener('click', () => {
      resetStepsOnly();
    });

    // Resize handler to keep svgRect updated
    window.addEventListener('resize', () => {
      svgRect = svg.getBoundingClientRect();
    });

    // Keyboard shortcuts for convenience
    window.addEventListener('keydown', (ev) => {
      if(ev.key === ' '){ ev.preventDefault(); stepNext(); }
      if(ev.key === 'ArrowRight') stepNext();
      if(ev.key === 'ArrowLeft') stepPrev();
      if(ev.key === 'a') setMode('addNode');
      if(ev.key === 'e') setMode('addEdge');
      if(ev.key === 'd') setMode('drag');
    });

    /* --- Initialization --- */
    function initDemo(){
      setMode('drag');
      // create small default graph for exploration
      addNode(260,200); // A
      addNode(420,140); // B
      addNode(420,320); // C
      addNode(600,200); // D
      // sample edges including negative weight
      edges.push({from:'A',to:'B',w:4});
      edges.push({from:'A',to:'C',w:5});
      edges.push({from:'B',to:'C',w:-6});
      edges.push({from:'C',to:'D',w:2});
      edges.push({from:'B',to:'D',w:3});
      render();
      status('Sample graph loaded. Select a source and click "Prepare Run". Tip: negative weights present.');
    }

    initDemo();
  </script>
</body>
</html>