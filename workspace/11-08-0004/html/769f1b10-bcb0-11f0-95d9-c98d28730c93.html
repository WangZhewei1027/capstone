<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quick Sort Interactive Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-margin: 24px;
      --min-gap: 16px;
      --item-width: 56px;
      --item-height: 56px;
      --item-gap: 12px;
      --bg: #0f172a;
      --panel: #0b1220;
      --accent: #60a5fa;
      --accent-2: #34d399;
      --muted: #94a3b8;
      --danger: #fb7185;
      --text: #e6eef8;
      --rounded: 10px;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071025 0%, #071428 60%);
      color:var(--text);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app {
      padding: var(--safe-margin);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      gap:var(--min-gap);
      align-items:flex-start;
    }

    /* Left column: instructions and controls */
    .column {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--rounded);
      padding:18px;
      min-width:300px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      flex:0 0 360px;
    }
    .column h1{
      margin:0 0 8px 0;
      font-size:20px;
      letter-spacing: -0.2px;
    }
    .subtitle {
      color:var(--muted);
      font-size:13px;
      margin-bottom:12px;
    }

    .section {
      background: rgba(255,255,255,0.02);
      border-radius:8px;
      padding:12px;
      margin-bottom:16px;
    }
    .section p{
      margin:8px 0;
      font-size:13px;
      line-height:1.4;
    }
    .section .label {
      font-size:12px;
      color:var(--muted);
      margin-bottom:8px;
      display:block;
    }

    /* Controls layout */
    .controls {
      display:flex;
      flex-direction:column;
      gap:var(--min-gap);
    }
    .row {
      display:flex;
      gap:var(--min-gap);
      align-items:center;
      flex-wrap:wrap;
    }
    .select, .input, .button, .small-button {
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      padding:8px 12px;
      background:transparent;
      color:var(--text);
      font-size:13px;
    }
    .select, .input { min-width:0; }
    .button {
      background: linear-gradient(90deg,var(--accent), #4f46e5);
      border: none;
      color:white;
      cursor:pointer;
    }
    .button:disabled { opacity:.5; cursor:not-allowed; }
    .small-button {
      padding:8px;
      background: rgba(255,255,255,0.035);
      cursor:pointer;
      border:1px solid rgba(255,255,255,0.03);
    }
    .controls .control-row {
      display:flex;
      gap:var(--min-gap);
      align-items:center;
    }
    .hint {
      font-size:12px;
      color:var(--muted);
    }

    /* Right column: visualization */
    .visual {
      flex:1 1 auto;
      min-width:320px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
      border-radius: var(--rounded);
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:16px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.5);
    }
    .visual .top-row {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:var(--min-gap);
    }
    .visual .title {
      font-size:16px;
      margin:0;
    }
    .status {
      color:var(--muted);
      font-size:13px;
    }

    .canvas {
      position:relative;
      height:250px;
      border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      padding:18px;
      overflow:hidden;
    }

    /* Array items positioned absolutely for smooth swapping animation */
    .array {
      position:relative;
      height:100%;
      width:100%;
      user-select:none;
    }
    .item {
      position:absolute;
      width:var(--item-width);
      height:var(--item-height);
      line-height:var(--item-height);
      border-radius:10px;
      background:linear-gradient(180deg, #0b1220, #07142a);
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      text-align:center;
      font-weight:600;
      color:var(--text);
      transition: transform 300ms cubic-bezier(.2,.8,.2,1), left 400ms cubic-bezier(.2,.8,.2,1), top 300ms, background 200ms, box-shadow 200ms;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:grab;
      font-size:14px;
      border:1px solid rgba(255,255,255,0.03);
    }
    .item:active { cursor:grabbing; }
    .item .val { pointer-events:none; }
    .idx {
      position:absolute;
      bottom:-18px;
      font-size:11px;
      color:var(--muted);
      text-align:center;
      width:100%;
    }

    .pivot {
      outline:3px solid rgba(96,165,250,0.18);
      box-shadow: 0 8px 28px rgba(96,165,250,0.08);
    }
    .comparing {
      background: linear-gradient(180deg,#1e293b,#0f1724);
      outline:2px solid rgba(255,255,255,0.06);
      transform:scale(1.05);
    }
    .swapping {
      background: linear-gradient(180deg,#4f46e5,#7c3aed);
      color:white;
      transform:scale(1.08);
      box-shadow: 0 12px 30px rgba(79,70,229,0.16);
    }
    .sorted {
      background: linear-gradient(180deg,#064e3b,#065f46);
      border:1px solid rgba(72,187,120,0.12);
      box-shadow: 0 8px 20px rgba(6,95,70,0.08);
    }

    /* Playback controls */
    .playback {
      display:flex;
      gap:var(--min-gap);
      align-items:center;
    }
    .speed {
      display:flex;
      gap:8px;
      align-items:center;
    }
    input[type="range"] { -webkit-appearance:none; height:6px; border-radius:10px; background: rgba(255,255,255,0.05); }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none; width:14px; height:14px; border-radius:50%; background:var(--accent); box-shadow: 0 3px 8px rgba(79,70,229,0.28); cursor:pointer; }

    .footer-note { font-size:12px; color:var(--muted); margin-top:8px; }

    /* Accessibility: focus outlines */
    .button:focus, .small-button:focus, .select:focus, .input:focus { outline: 2px solid rgba(96,165,250,0.14); outline-offset:2px; }

    /* Responsive adjustments */
    @media (max-width:900px){
      .app { flex-direction:column; padding:16px; }
      .column { width:100%; flex:unset; min-width:unset; }
    }
  </style>
</head>
<body>
  <div class="app" role="main" aria-label="Quick Sort interactive module">
    <!-- Left panel: Explanations and Controls -->
    <div class="column" aria-labelledby="concept-title">
      <h1 id="concept-title">Quick Sort â€” Partition & Pivot Dynamics</h1>
      <div class="subtitle">Interactive exploration of Quick Sort partitioning, pivot selection, and recursive sorting.</div>

      <div class="section" aria-hidden="false">
        <span class="label">Learning Objective</span>
        <p>Understand how Quick Sort partitions an array around a pivot, how comparisons and swaps move elements into place, and how different pivot strategies affect the process. Observe step-by-step animations and try feeding custom input.</p>
      </div>

      <div class="section" aria-hidden="false">
        <span class="label">Interaction Design</span>
        <p>Before starting: drag array tiles to reorder values, or type a comma-separated list to define a custom array. Choose a pivot strategy (first / last / middle / random). Click Play to animate the algorithm (comparisons highlighted, swaps animated, pivot placements indicated). Controls: Play/Pause, Step Forward, Reset, Speed slider.</p>
      </div>

      <div class="section controls" aria-hidden="false">
        <div class="control-row">
          <label for="pivot" class="hint">Pivot strategy</label>
          <select id="pivot" class="select" aria-label="Select pivot strategy">
            <option value="last">Last element (Lomuto)</option>
            <option value="first">First element</option>
            <option value="middle">Middle element</option>
            <option value="random">Random element</option>
          </select>
        </div>

        <div class="control-row">
          <label for="arrInput" class="hint">Custom array (max 15 values)</label>
          <input id="arrInput" class="input" placeholder="e.g. 8,3,7,1,9" aria-label="Custom array input" />
          <button id="setArray" class="button" title="Set custom array">Set</button>
        </div>

        <div class="control-row">
          <button id="randomize" class="small-button" title="Randomize array">Randomize</button>
          <button id="shuffle" class="small-button" title="Reverse order">Reverse</button>
          <div style="flex:1"></div>
          <label class="hint" style="margin-right:8px;">Elements:</label>
          <select id="size" class="select" aria-label="Array size">
            <option>6</option>
            <option selected>8</option>
            <option>10</option>
            <option>12</option>
            <option>14</option>
          </select>
        </div>

        <div class="control-row">
          <div class="playback" role="group" aria-label="Playback controls">
            <button id="play" class="button" title="Play">Play</button>
            <button id="pause" class="small-button" title="Pause" disabled>Pause</button>
            <button id="step" class="small-button" title="Step forward">Step</button>
            <button id="reset" class="small-button" title="Reset">Reset</button>
          </div>
          <div style="flex:1"></div>
          <div class="speed" aria-hidden="false" title="Animation speed">
            <label class="hint">Speed</label>
            <input id="speed" type="range" min="100" max="2000" value="700" />
          </div>
        </div>

        <div class="footer-note">Tip: You can drag tiles to reorder the array before starting. During animation dragging is disabled.</div>
      </div>
    </div>

    <!-- Right panel: Visualization -->
    <div class="visual" aria-live="polite">
      <div class="top-row">
        <h2 class="title">Array Visualization</h2>
        <div class="status" id="status">Idle</div>
      </div>

      <div class="canvas" id="canvas" aria-label="Quick sort visualization canvas">
        <div class="array" id="array" role="list" aria-label="Sortable array"></div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
        <div class="hint">Legend:
          <span style="display:inline-block;width:12px;height:12px;background:#3b82f6;margin-left:8px;border-radius:3px;vertical-align:middle"></span> Pivot
          <span style="display:inline-block;width:12px;height:12px;background:#7c3aed;margin-left:8px;border-radius:3px;vertical-align:middle"></span> Swapping
          <span style="display:inline-block;width:12px;height:12px;background:#064e3b;margin-left:8px;border-radius:3px;vertical-align:middle"></span> Sorted
        </div>
        <div class="hint" id="stepInfo"></div>
      </div>
    </div>
  </div>

  <script>
    // Quick Sort Interactive Module (vanilla JS)
    // - Records algorithm actions and animates them.
    // - Drag to reorder before execution.
    // - Safe constraints: max elements 15.
    (function () {
      // DOM elements
      const arrContainer = document.getElementById('array');
      const playBtn = document.getElementById('play');
      const pauseBtn = document.getElementById('pause');
      const stepBtn = document.getElementById('step');
      const resetBtn = document.getElementById('reset');
      const randomizeBtn = document.getElementById('randomize');
      const shuffleBtn = document.getElementById('shuffle');
      const sizeSelect = document.getElementById('size');
      const pivotSelect = document.getElementById('pivot');
      const speedRange = document.getElementById('speed');
      const statusEl = document.getElementById('status');
      const stepInfo = document.getElementById('stepInfo');
      const setArrayBtn = document.getElementById('setArray');
      const arrInput = document.getElementById('arrInput');

      // State
      let data = [];               // current numeric array
      let nodes = [];              // DOM nodes mapping to items
      let animations = [];         // recorded actions
      let playing = false;
      let curAction = 0;
      let speed = Number(speedRange.value); // ms per action
      let allowDrag = true;
      const maxItems = 15;

      // Visual params
      const itemW = 56;
      const itemH = 56;
      const gap = 12;
      const canvasPadding = 18; // matches CSS

      // Initialize with random data
      function randArray(n) {
        const arr = [];
        for (let i = 0; i < n; i++) arr.push(Math.floor(Math.random() * 90) + 5);
        return arr;
      }

      function clampSize(n) {
        return Math.max(2, Math.min(maxItems, Math.floor(n)));
      }

      // Render array items as absolutely positioned tiles
      function renderArray() {
        arrContainer.innerHTML = '';
        nodes = [];
        data.forEach((v, i) => {
          const el = document.createElement('div');
          el.className = 'item';
          el.setAttribute('role','listitem');
          el.setAttribute('draggable', allowDrag);
          el.dataset.index = i;
          el.innerHTML = '<span class="val">' + v + '</span><div class="idx">' + i + '</div>';
          arrContainer.appendChild(el);
          nodes.push(el);
        });
        layoutItems(true);
        attachDragHandlers();
      }

      // Compute left positions and apply transforms
      function layoutItems(noTransition=false) {
        const canvasWidth = arrContainer.clientWidth;
        const totalW = data.length * itemW + (data.length - 1) * gap;
        // center horizontally
        let startLeft = Math.max(8, (canvasWidth - totalW) / 2);
        nodes.forEach((el, i) => {
          el.style.transition = noTransition ? 'none' : '';
          const left = startLeft + i * (itemW + gap);
          el.style.left = left + 'px';
          // vertical center
          el.style.top = Math.max(12, (arrContainer.clientHeight - itemH) / 2) + 'px';
          el.querySelector('.idx').textContent = i;
          el.dataset.index = i;
        });
        // re-enable transitions after layout
        if (noTransition) {
          requestAnimationFrame(() => {
            nodes.forEach(n => n.style.transition = '');
          });
        }
      }

      // Attach drag handlers for reordering (only when not playing)
      function attachDragHandlers() {
        nodes.forEach(node => {
          node.addEventListener('dragstart', onDragStart);
          node.addEventListener('dragover', onDragOver);
          node.addEventListener('drop', onDrop);
          node.addEventListener('dragend', onDragEnd);
          node.addEventListener('keydown', (e)=> {
            // allow keyboard reordering with arrow keys when not playing
            if (!allowDrag) return;
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
              e.preventDefault();
              const idx = Number(node.dataset.index);
              const newIdx = e.key === 'ArrowLeft' ? Math.max(0, idx-1) : Math.min(data.length-1, idx+1);
              if (newIdx !== idx) {
                const val = data.splice(idx,1)[0];
                data.splice(newIdx,0,val);
                renderArray();
              }
            }
          });
        });
      }

      let dragSrcIdx = null;
      function onDragStart(e) {
        if (!allowDrag) { e.preventDefault(); return; }
        this.classList.add('dragging');
        dragSrcIdx = Number(this.dataset.index);
        e.dataTransfer.effectAllowed = 'move';
      }
      function onDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      }
      function onDrop(e) {
        e.stopPropagation();
        if (!allowDrag) return;
        const tgt = Number(this.dataset.index);
        if (dragSrcIdx === null || dragSrcIdx === tgt) return;
        const val = data.splice(dragSrcIdx, 1)[0];
        data.splice(tgt, 0, val);
        renderArray();
      }
      function onDragEnd(e) {
        dragSrcIdx = null;
        nodes.forEach(n => n.classList.remove('dragging'));
      }

      // Utility: record actions with snapshots
      function record(action) {
        animations.push(action);
      }

      // Quick Sort (Lomuto-style) with pivot strategy selection; records actions.
      function quickSortRecord(arr) {
        animations = [];
        const a = arr.slice();

        function choosePivotIndex(l, r) {
          const strategy = pivotSelect.value;
          if (strategy === 'last') return r;
          if (strategy === 'first') return l;
          if (strategy === 'middle') return Math.floor((l + r) / 2);
          // random
          return l + Math.floor(Math.random() * (r - l + 1));
        }

        function partition(l, r) {
          let pivotIdx = choosePivotIndex(l, r);
          record({type:'choosePivot', index: pivotIdx});
          // move pivot to end if needed
          if (pivotIdx !== r) {
            record({type:'swap', i: pivotIdx, j: r});
            const tmp = a[pivotIdx]; a[pivotIdx] = a[r]; a[r] = tmp;
          }
          const pivotVal = a[r];
          let i = l - 1;
          for (let j = l; j < r; j++) {
            record({type:'compare', i: j, pivotIndex: r});
            if (a[j] <= pivotVal) {
              i++;
              if (i !== j) {
                record({type:'swap', i: i, j: j});
                const tmp = a[i]; a[i] = a[j]; a[j] = tmp;
              }
            }
          }
          const finalPos = i + 1;
          if (finalPos !== r) {
            record({type:'swap', i: finalPos, j: r});
            const tmp = a[finalPos]; a[finalPos] = a[r]; a[r] = tmp;
          }
          record({type:'pivotPlaced', index: finalPos});
          return finalPos;
        }

        function qs(l, r) {
          if (l >= r) {
            if (l === r) record({type:'sorted', index:l});
            return;
          }
          const p = partition(l, r);
          // left
          qs(l, p - 1);
          // right
          qs(p + 1, r);
          // mark entire segment as sorted only at top-level? We'll mark single indices on pivotPlaced or base-case.
        }

        if (a.length > 0) qs(0, a.length - 1);
        return animations;
      }

      // Playback engine: apply actions with animations
      function applyAction(action, instant=false) {
        // clear previous transient classes
        nodes.forEach(n => n.classList.remove('comparing','swapping','pivot','sorted'));
        stepInfo.textContent = `${curAction+1} / ${animations.length}`;
        if (!action) return;
        if (action.type === 'choosePivot') {
          const idx = action.index;
          const node = nodes[idx];
          if (node) node.classList.add('pivot');
          statusEl.textContent = `Pivot chosen at index ${idx}`;
        } else if (action.type === 'compare') {
          const ni = nodes[action.i], np = nodes[action.pivotIndex];
          if (ni) ni.classList.add('comparing');
          if (np) np.classList.add('pivot');
          statusEl.textContent = `Comparing index ${action.i} with pivot`;
        } else if (action.type === 'swap') {
          // animate swap: swap data array and move nodes
          const i = action.i, j = action.j;
          statusEl.textContent = `Swapping index ${i} and ${j}`;
          const nodeI = nodes[i], nodeJ = nodes[j];
          if (!nodeI || !nodeJ) return;
          nodeI.classList.add('swapping');
          nodeJ.classList.add('swapping');

          // Swap data array
          const tmp = data[i]; data[i] = data[j]; data[j] = tmp;
          // swap nodes in nodes array to keep mapping (we'll reassign)
          nodes[i] = nodeJ;
          nodes[j] = nodeI;

          // After swapping nodes array, re-layout so they animate to new positions.
          // Slightly longer transition for swap effects
          layoutItems();
        } else if (action.type === 'pivotPlaced') {
          const idx = action.index;
          const node = nodes[idx];
          if (node) {
            node.classList.remove('pivot');
            node.classList.add('sorted');
          }
          statusEl.textContent = `Pivot placed at index ${idx}`;
        } else if (action.type === 'sorted') {
          const idx = action.index;
          const node = nodes[idx];
          if (node) node.classList.add('sorted');
        }
      }

      // Playback loop
      let playTimer = null;
      function play() {
        if (playing || curAction >= animations.length) return;
        playing = true;
        playBtn.disabled = true;
        pauseBtn.disabled = false;
        allowDrag = false;
        disablePrestartControls(true);
        statusEl.textContent = 'Playing';
        scheduleNext();
      }

      function scheduleNext() {
        if (!playing) return;
        if (curAction >= animations.length) {
          finishPlayback();
          return;
        }
        const action = animations[curAction];
        applyAction(action);
        curAction++;
        // schedule next step
        playTimer = setTimeout(() => {
          // clear transient comparison/swapping styles after a short fraction to show action
          nodes.forEach(n => n.classList.remove('comparing','swapping'));
          // continue playing
          scheduleNext();
        }, speed);
        stepInfo.textContent = `${curAction} / ${animations.length}`;
      }

      function pause() {
        if (!playing) return;
        playing = false;
        playBtn.disabled = false;
        pauseBtn.disabled = true;
        clearTimeout(playTimer);
        statusEl.textContent = 'Paused';
      }

      function finishPlayback() {
        playing = false;
        playBtn.disabled = true;
        pauseBtn.disabled = true;
        allowDrag = false;
        disablePrestartControls(true);
        statusEl.textContent = 'Completed';
        stepInfo.textContent = `${animations.length} / ${animations.length}`;
      }

      function stepForward() {
        if (curAction >= animations.length) return;
        // apply single action (and mark)
        const action = animations[curAction];
        applyAction(action);
        curAction++;
        // clear transient styles shortly after
        setTimeout(()=> nodes.forEach(n=>n.classList.remove('comparing','swapping')), Math.max(150, speed/3));
        if (curAction >= animations.length) finishPlayback();
      }

      function resetToInitial(initialData) {
        pause();
        data = initialData.slice();
        allowDrag = true;
        disablePrestartControls(false);
        renderArray();
        animations = [];
        curAction = 0;
        statusEl.textContent = 'Idle';
        stepInfo.textContent = '';
        playBtn.disabled = false;
        pauseBtn.disabled = true;
      }

      // Some controls should be disabled once algorithm started
      function disablePrestartControls(disable) {
        sizeSelect.disabled = disable;
        randomizeBtn.disabled = disable;
        shuffleBtn.disabled = disable;
        setArrayBtn.disabled = disable;
        arrInput.disabled = disable;
        pivotSelect.disabled = disable;
      }

      // UI event bindings
      playBtn.addEventListener('click', ()=> {
        // If no recorded animations, record from current data
        if (!animations.length) {
          // record fresh actions
          const copy = data.slice();
          animations = quickSortRecord(copy);
        }
        play();
      });

      pauseBtn.addEventListener('click', ()=> {
        pause();
      });

      stepBtn.addEventListener('click', ()=> {
        if (!animations.length) {
          animations = quickSortRecord(data.slice());
        }
        if (curAction < animations.length) {
          stepForward();
        }
      });

      resetBtn.addEventListener('click', ()=> {
        // reset to initial unsorted array (recreate from current DOM values)
        // We'll reconstruct from nodes' values in their current order in dataSavedAtStart
        // For simplicity, set to the current data as it was at page load/randomize time
        resetToInitial(initialDataAtStart.slice());
      });

      randomizeBtn.addEventListener('click', ()=> {
        const n = clampSize(Number(sizeSelect.value));
        data = randArray(n);
        initialDataAtStart = data.slice();
        renderArray();
        animations = [];
        curAction = 0;
        statusEl.textContent = 'Array randomized';
        allowDrag = true;
        disablePrestartControls(false);
        playBtn.disabled = false;
      });

      shuffleBtn.addEventListener('click', ()=> {
        data.reverse();
        initialDataAtStart = data.slice();
        renderArray();
        animations = [];
        curAction = 0;
        statusEl.textContent = 'Array reversed';
        allowDrag = true;
        disablePrestartControls(false);
        playBtn.disabled = false;
      });

      sizeSelect.addEventListener('change', ()=> {
        const n = clampSize(Number(sizeSelect.value));
        data = randArray(n);
        initialDataAtStart = data.slice();
        renderArray();
        animations = [];
        curAction = 0;
        statusEl.textContent = 'Array size changed';
      });

      pivotSelect.addEventListener('change', ()=> {
        // small feedback
        statusEl.textContent = 'Pivot strategy: ' + pivotSelect.value;
      });

      speedRange.addEventListener('input', ()=> {
        speed = Number(speedRange.value);
      });

      setArrayBtn.addEventListener('click', ()=> {
        const raw = arrInput.value.trim();
        if (!raw) return;
        const parts = raw.split(',').map(s => Number(s.trim())).filter(n => !Number.isNaN(n));
        if (parts.length === 0) return alert('Please enter comma-separated numbers.');
        if (parts.length > maxItems) return alert('Max ' + maxItems + ' elements allowed.');
        data = parts.slice();
        initialDataAtStart = data.slice();
        renderArray();
        animations = [];
        curAction = 0;
        statusEl.textContent = 'Custom array set';
      });

      // Keep an initial copy to reset to
      let initialDataAtStart = [];
      // Initialize default
      function init() {
        const n = clampSize(Number(sizeSelect.value));
        data = randArray(n);
        initialDataAtStart = data.slice();
        renderArray();
        statusEl.textContent = 'Ready';
        playBtn.disabled = false;
        pauseBtn.disabled = true;
      }

      // Basic responsiveness: re-layout on resize
      window.addEventListener('resize', ()=> layoutItems(true));

      // Start
      init();

      // Expose minimal keyboard shortcuts for convenience
      window.addEventListener('keydown', (e)=>{
        if (e.key === ' ' && document.activeElement.tagName !== 'INPUT') {
          e.preventDefault();
          if (playing) pause(); else play();
        } else if (e.key === 'ArrowRight' && document.activeElement.tagName !== 'INPUT') {
          e.preventDefault(); stepForward();
        } else if (e.key === 'r' && document.activeElement.tagName !== 'INPUT') {
          e.preventDefault(); randomizeBtn.click();
        }
      });

      // Accessibility: announce step state
      const live = document.getElementById('status');
      function announce(text) { live.textContent = text; }

    })();
  </script>
</body>
</html>