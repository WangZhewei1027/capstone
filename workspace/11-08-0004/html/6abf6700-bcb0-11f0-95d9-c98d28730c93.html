<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>K‑Means Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --control-bg: #f7f9fc;
      --accent: #2b8cff;
      --muted: #6b7280;
      --bg: #ffffff;
      --max-width: 1200px;
      --panel-radius: 12px;
      --transition: 300ms cubic-bezier(.2,.9,.2,1);
    }

    /* Page layout & safe area */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#fbfdff,#ffffff);
      color:#0f172a;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .wrap{
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      justify-content:center;
    }

    .container{
      width:100%;
      max-width:var(--max-width);
      display:flex;
      gap:var(--gap);
      align-items:stretch;
    }

    /* Left column: documentation + controls */
    .side{
      width:320px;
      min-width:250px;
      background:var(--control-bg);
      border-radius:var(--panel-radius);
      padding:20px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      box-shadow:0 6px 18px rgba(12,18,36,0.06);
    }

    .title{
      font-size:20px;
      font-weight:700;
      margin:0;
    }
    .subtitle{
      font-size:13px;
      color:var(--muted);
      margin-top:4px;
    }

    .section{
      background:transparent;
      border-radius:8px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .section h3{
      margin:0;
      font-size:13px;
      color:#0f172a;
    }
    .section p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .row{
      display:flex;
      gap:12px;
      align-items:center;
    }

    label{
      font-size:13px;
      color:#0f172a;
      min-width:56px;
    }

    input[type="range"]{
      -webkit-appearance:none;
      appearance:none;
      height:6px;
      border-radius:6px;
      background:#e6eefc;
      outline:none;
      flex:1;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:18px;height:18px;border-radius:50%;
      background:var(--accent);box-shadow:0 2px 6px rgba(43,140,255,0.35);
      cursor:pointer;
    }

    .btn-row{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }

    button{
      border:0;
      background:var(--accent);
      color:white;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
      transition:transform var(--transition), box-shadow var(--transition);
    }
    button.secondary{
      background:transparent;
      color:var(--accent);
      border:1px solid rgba(43,140,255,0.12);
      box-shadow:none;
    }
    button:active{ transform:translateY(1px); }
    button[aria-pressed="true"]{
      background:#0b63e6;
      box-shadow:0 6px 18px rgba(11,99,230,0.12);
    }

    input[type="number"]{
      width:72px;
      padding:8px;
      border-radius:8px;
      border:1px solid #e6eefc;
      background:white;
      font-size:13px;
    }

    .muted{
      color:var(--muted);
      font-size:13px;
    }

    .metrics{
      display:flex;
      gap:12px;
      align-items:center;
    }

    .metric{
      background:white;
      padding:8px 10px;
      border-radius:8px;
      min-width:84px;
      text-align:center;
      box-shadow:0 4px 10px rgba(12,18,36,0.04);
    }
    .metric .value{
      font-weight:700;
      font-size:15px;
    }
    .legend{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .legend .key{
      display:flex;gap:8px;align-items:center;background:white;padding:6px 8px;border-radius:8px;
      font-size:13px;color:#0f172a;
    }
    .swatch{ width:14px;height:14px;border-radius:4px;box-shadow:inset 0 0 0 1px rgba(0,0,0,0.04); }

    /* Right column: visualization */
    .canvas-panel{
      flex:1;
      background:linear-gradient(180deg,#ffffff,#fbfdff);
      border-radius:var(--panel-radius);
      padding:16px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:460px;
      box-shadow:0 8px 26px rgba(12,18,36,0.06);
    }

    .vis-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    .vis-top .hint{ color:var(--muted); font-size:13px; }

    /* Responsive svg area */
    .vis-area{
      flex:1;
      min-height:360px;
      border-radius:10px;
      background:linear-gradient(180deg, #ffffff, #f6fbff);
      position:relative;
      overflow:hidden;
      border:1px solid rgba(15,23,42,0.04);
    }

    svg {
      width:100%;
      height:100%;
      display:block;
      user-select:none;
      touch-action:none;
    }

    /* Points and centroids styles */
    .point{
      transition: transform var(--transition), fill var(--transition), opacity 200ms;
      cursor:pointer;
    }
    .centroid{
      stroke:#fff;
      stroke-width:2px;
      transition: transform 600ms cubic-bezier(.2,.9,.2,1), opacity 180ms;
      cursor:grab;
    }
    .centroid:active{ cursor:grabbing; }

    .assignment-line{
      stroke:rgba(15,23,42,0.06);
      stroke-dasharray:3 4;
      transition:opacity 300ms;
    }

    /* Small helper text */
    .small{
      font-size:12px;
      color:var(--muted);
    }

    /* Responsive: stack columns on narrow screens */
    @media (max-width:880px){
      .container{ flex-direction:column; }
      .side{ width:100%; }
    }

    /* Accessibility focus outlines */
    button:focus, input:focus, svg:focus{
      outline:3px solid rgba(43,140,255,0.14);
      outline-offset:2px;
      border-radius:8px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="container" role="application" aria-label="K-Means interactive module">
      <!-- LEFT: documentation + controls -->
      <aside class="side" aria-labelledby="module-title">
        <div>
          <h1 id="module-title" class="title">K‑Means Clustering — Interactive</h1>
          <div class="subtitle">Visual, hands-on exploration of assignment and centroid updates</div>
        </div>

        <div class="section" aria-labelledby="learning-heading">
          <h3 id="learning-heading">Learning Objective</h3>
          <p>After using this module you will understand how K‑Means alternates between assigning points to the nearest centroid and updating centroids as the mean of their assigned points, and how this process reduces the sum of squared errors (SSE) over iterations.</p>
        </div>

        <div class="section" aria-labelledby="interaction-heading">
          <h3 id="interaction-heading">Interaction Design</h3>
          <p class="small">
            - Click on the plot to add points (or drag existing points).<br>
            - Use "Add random" to scatter points automatically.<br>
            - Set K with the slider or number box. Click "Init centroids" to place K centroids randomly. <br>
            - "Step" performs one K‑Means iteration (assign → update). "Run" auto-steps. <br>
            - Drag centroids to see immediate reassignments and SSE changes. Animations show assignments and centroid movements to reinforce the algorithm's two phases.
          </p>
        </div>

        <div class="section" aria-labelledby="layout-heading">
          <h3 id="layout-heading">Layout Description</h3>
          <p class="small">
            Left column contains controls and explanations (safe margins 24px). Controls are vertically stacked with 16px gaps. Right column is the visualization: a responsive SVG scatterplot with animated points, centroid markers, and assignment guides. On small screens the columns stack to preserve clarity and focus.
          </p>
        </div>

        <div class="section" aria-labelledby="controls-heading">
          <h3 id="controls-heading">Controls</h3>

          <div class="controls" role="region" aria-label="K‑Means controls">
            <div class="row" style="align-items:center;">
              <label for="kRange">K</label>
              <input id="kRange" type="range" min="1" max="8" value="3" step="1" aria-label="Number of clusters">
              <input id="kNumber" type="number" min="1" max="8" value="3" aria-label="Number of clusters numeric">
            </div>

            <div class="row">
              <button id="addRandom">Add random</button>
              <button id="clear" class="secondary">Clear</button>
            </div>

            <div class="btn-row">
              <button id="initBtn" class="secondary">Init centroids</button>
              <button id="stepBtn">Step</button>
              <button id="runBtn" aria-pressed="false">Run</button>
              <button id="resetBtn" class="secondary">Reset</button>
            </div>

            <div class="row">
              <label>Speed</label>
              <input id="speed" type="range" min="200" max="1500" value="700" step="100" aria-label="Animation speed"> 
            </div>

            <div class="metrics" aria-live="polite">
              <div class="metric">
                <div class="muted">Points</div>
                <div id="count" class="value">0</div>
              </div>
              <div class="metric">
                <div class="muted">SSE</div>
                <div id="sse" class="value">0</div>
              </div>
            </div>

            <div>
              <div class="muted" style="margin-bottom:8px;">Legend</div>
              <div class="legend" id="legend"></div>
            </div>

            <div class="small muted" style="margin-top:6px;">
              Tip: Drag centroids to explore how assignments and SSE respond immediately.
            </div>
          </div>
        </div>

      </aside>

      <!-- RIGHT: visualization -->
      <main class="canvas-panel" role="main" aria-label="Visualization panel">
        <div class="vis-top">
          <div>
            <strong>Scatterplot</strong>
            <div class="small muted">Click to add points. Drag any point or centroid.</div>
          </div>
          <div class="hint muted small">Assignment = nearest centroid • Centroid = mean of assigned points</div>
        </div>

        <div class="vis-area" id="visArea" aria-label="Scatterplot area">
          <!-- SVG will be injected here -->
          <svg id="svg" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet" tabindex="0" role="img" aria-label="K-Means plot">
            <!-- grid -->
            <defs>
              <linearGradient id="bgGrad" x1="0" x2="0" y1="0" y2="1">
                <stop offset="0%" stop-color="#fff"/>
                <stop offset="100%" stop-color="#f6fbff"/>
              </linearGradient>
            </defs>

            <rect width="100%" height="100%" fill="url(#bgGrad)"></rect>

            <g id="assignment-lines"></g>
            <g id="points-layer"></g>
            <g id="centroids-layer"></g>
          </svg>
        </div>

      </main>
    </div>
  </div>

  <script>
    /* ===== K-MEANS INTERACTIVE MODULE (vanilla JS) =====
       - All code is self-contained and avoids external libraries.
       - Coordinates are normalized to the SVG viewBox (800x600).
       - Safe margins and spacing are enforced via CSS.
    */

    // DOM elements
    const svg = document.getElementById('svg');
    const pointsLayer = document.getElementById('points-layer');
    const centroidsLayer = document.getElementById('centroids-layer');
    const linesLayer = document.getElementById('assignment-lines');
    const kRange = document.getElementById('kRange');
    const kNumber = document.getElementById('kNumber');
    const addRandomBtn = document.getElementById('addRandom');
    const clearBtn = document.getElementById('clear');
    const initBtn = document.getElementById('initBtn');
    const stepBtn = document.getElementById('stepBtn');
    const runBtn = document.getElementById('runBtn');
    const resetBtn = document.getElementById('resetBtn');
    const countEl = document.getElementById('count');
    const sseEl = document.getElementById('sse');
    const legendEl = document.getElementById('legend');
    const speedInput = document.getElementById('speed');

    // Config / state
    const viewW = 800, viewH = 600;
    let points = []; // {id, x(0..1), y(0..1), cluster}
    let centroids = []; // {id, x,y, color}
    let running = false;
    let autoTimer = null;
    let nextId = 1;
    const colors = [
      '#2b8cff','#ff7a59','#7be495','#ffd166','#a78bfa','#61c0ff','#ffb3e6','#9ee6a0'
    ];

    // Utilities
    function uid(){ return nextId++; }
    function clamp01(v){ return Math.max(0, Math.min(1, v)); }
    function toViewX(nx){ return nx * viewW; }
    function toViewY(ny){ return ny * viewH; }
    function fromViewXY(px,py){
      const rect = svg.getBoundingClientRect();
      const vb = svg.viewBox.baseVal;
      // Map client coords to viewBox coordinates
      const x = ((px - rect.left) / rect.width) * vb.width + vb.x;
      const y = ((py - rect.top) / rect.height) * vb.height + vb.y;
      return {x: clamp01(x / viewW), y: clamp01(y / viewH)};
    }

    function distance2(a,b){
      const dx = a.x - b.x, dy = a.y - b.y;
      return dx*dx + dy*dy;
    }

    function updateMetrics(){
      countEl.textContent = points.length;
      sseEl.textContent = Math.round(calculateSSE()*100)/100;
    }

    function calculateSSE(){
      let sse = 0;
      for(const p of points){
        if(p.cluster==null) continue;
        const c = centroids[p.cluster];
        if(!c) continue;
        sse += distance2(p, c);
      }
      return sse;
    }

    // Render legend
    function renderLegend(){
      legendEl.innerHTML = '';
      for(let i=0;i<centroids.length;i++){
        const key = document.createElement('div');
        key.className='key';
        const sw = document.createElement('span');
        sw.className='swatch';
        sw.style.background = centroids[i].color;
        key.appendChild(sw);
        const label = document.createElement('span');
        label.textContent = 'C' + (i+1);
        key.appendChild(label);
        legendEl.appendChild(key);
      }
    }

    // Create DOM elements for points and centroids
    function renderAll(){
      // Points
      pointsLayer.innerHTML = '';
      for(const p of points){
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('transform', `translate(${toViewX(p.x)},${toViewY(p.y)})`);
        g.setAttribute('data-id', p.id);
        g.classList.add('point');
        g.setAttribute('role','img');
        g.setAttribute('aria-label', `Point ${p.id}`);

        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('r', 6);
        circle.setAttribute('fill', p.cluster==null ? '#cbd5e1' : centroids[p.cluster].color);
        circle.setAttribute('opacity', 0.95);
        g.appendChild(circle);

        // subtle border
        const border = document.createElementNS('http://www.w3.org/2000/svg','circle');
        border.setAttribute('r', 11);
        border.setAttribute('fill','transparent');
        border.setAttribute('stroke','transparent');
        g.appendChild(border);

        pointsLayer.appendChild(g);
      }

      // Centroids
      centroidsLayer.innerHTML = '';
      for(let i=0;i<centroids.length;i++){
        const c = centroids[i];
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('transform', `translate(${toViewX(c.x)},${toViewY(c.y)})`);
        g.setAttribute('data-id', i);
        g.classList.add('centroid');
        g.setAttribute('role','img');
        g.setAttribute('aria-label', `Centroid ${i+1}`);

        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rect.setAttribute('x', -10);
        rect.setAttribute('y', -10);
        rect.setAttribute('width', 20);
        rect.setAttribute('height', 20);
        rect.setAttribute('rx',4);
        rect.setAttribute('fill', c.color);
        rect.setAttribute('opacity', 0.95);
        g.appendChild(rect);

        const label = document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x', 16);
        label.setAttribute('y', 6);
        label.setAttribute('font-size','12');
        label.setAttribute('fill','#0f172a');
        label.textContent = 'C' + (i+1);
        g.appendChild(label);

        centroidsLayer.appendChild(g);
      }

      renderLegend();
      updateMetrics();
      attachPointHandlers();
      attachCentroidHandlers();
    }

    // Event handling: add points via clicking
    svg.addEventListener('pointerdown', (evt) => {
      // Ignore clicks on existing draggable items (they will have separate handlers)
      const target = evt.target;
      if(target.closest('.point') || target.closest('.centroid')) return;
      // Add a point at click location
      const pos = fromViewXY(evt.clientX, evt.clientY);
      addPoint(pos.x, pos.y);
    });

    function addPoint(nx, ny){
      const p = {id: uid(), x: nx, y: ny, cluster: null};
      points.push(p);
      // When a point is added, optionally assign to nearest centroid if exist
      if(centroids.length>0){
        assignPointToNearest(p);
      }
      renderAll();
    }

    // Add random points
    addRandomBtn.addEventListener('click', ()=>{
      const n = 15;
      for(let i=0;i<n;i++){
        const nx = Math.random()*0.86 + 0.07;
        const ny = Math.random()*0.86 + 0.07;
        addPoint(nx,ny);
      }
      renderAll();
    });

    // Clear points and centroids
    clearBtn.addEventListener('click', ()=>{
      points = [];
      centroids = [];
      running = false;
      setRun(false);
      renderAll();
    });

    resetBtn.addEventListener('click', ()=>{
      // same as clear centroids but keep points
      centroids = [];
      running = false;
      setRun(false);
      for(const p of points) p.cluster = null;
      renderAll();
    });

    // K controls sync
    function setK(val){
      kRange.value = val;
      kNumber.value = val;
    }
    kRange.addEventListener('input', ()=> setK(kRange.value) );
    kNumber.addEventListener('change', ()=>{
      let v = parseInt(kNumber.value) || 1;
      v = Math.max(1, Math.min(8, v));
      setK(v);
    });

    // Initialize centroids randomly
    initBtn.addEventListener('click', ()=>{
      initCentroids();
      renderAll();
    });

    function initCentroids(){
      const k = parseInt(kRange.value);
      centroids = [];
      for(let i=0;i<k;i++){
        // Randomly pick a point if exists, otherwise random location
        let nx, ny;
        if(points.length>0 && Math.random() > 0.4){
          const p = points[Math.floor(Math.random()*points.length)];
          nx = p.x + (Math.random()-0.5)*0.08;
          ny = p.y + (Math.random()-0.5)*0.08;
        } else {
          nx = Math.random()*0.8 + 0.1;
          ny = Math.random()*0.8 + 0.1;
        }
        centroids.push({x: clamp01(nx), y: clamp01(ny), color: colors[i % colors.length]});
      }
      // Clear cluster assignments
      for(const p of points) p.cluster = null;
      renderAll();
    }

    // Assignment step: assign all points to nearest centroid
    function assignAll(){
      if(centroids.length===0) return;
      for(const p of points){
        assignPointToNearest(p);
      }
      renderAssignments(true);
      updateMetrics();
    }

    function assignPointToNearest(p){
      let best = null;
      let bestD = Infinity;
      centroids.forEach((c,i)=>{
        const d = distance2(p,c);
        if(d < bestD){ bestD = d; best = i; }
      });
      p.cluster = best;
    }

    // Render assignments: color points and draw subtle lines to centroids
    function renderAssignments(showLines=false){
      // color points
      for(const g of pointsLayer.children){
        const id = parseInt(g.getAttribute('data-id'));
        const p = points.find(x=>x.id===id);
        const circle = g.querySelector('circle');
        circle.setAttribute('fill', p.cluster==null ? '#cbd5e1' : centroids[p.cluster].color);
      }

      // lines
      linesLayer.innerHTML = '';
      if(!showLines) return;
      for(const p of points){
        if(p.cluster==null) continue;
        const c = centroids[p.cluster];
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', toViewX(p.x));
        line.setAttribute('y1', toViewY(p.y));
        line.setAttribute('x2', toViewX(c.x));
        line.setAttribute('y2', toViewY(c.y));
        line.classList.add('assignment-line');
        line.setAttribute('stroke-width', 1);
        line.setAttribute('opacity', 0.9);
        linesLayer.appendChild(line);
      }
      // fade out lines after 700ms
      setTimeout(()=> {
        for(const l of linesLayer.children) l.setAttribute('opacity', 0.05);
        setTimeout(()=> linesLayer.innerHTML = '', 700);
      }, 400);
    }

    // Update step: move centroids to mean of assigned points
    function updateCentroidsAnimated(){
      // calculate new means
      const newPositions = centroids.map(()=>({x:0,y:0,count:0}));
      for(const p of points){
        if(p.cluster==null) continue;
        const c = p.cluster;
        newPositions[c].x += p.x;
        newPositions[c].y += p.y;
        newPositions[c].count++;
      }
      // Update centroids with animation: set new coordinates, DOM will transition
      for(let i=0;i<centroids.length;i++){
        const data = newPositions[i];
        if(data.count>0){
          const nx = data.x / data.count;
          const ny = data.y / data.count;
          centroids[i].x = nx;
          centroids[i].y = ny;
        } // else if no points, keep position
      }

      // animate centroid DOM positions
      for(const g of centroidsLayer.children){
        const id = parseInt(g.getAttribute('data-id'));
        const c = centroids[id];
        g.style.transition = `transform ${speedInput.value}ms cubic-bezier(.2,.9,.2,1)`;
        g.setAttribute('transform', `translate(${toViewX(c.x)},${toViewY(c.y)})`);
      }
      // After animation completes, update point colors again (they may remain same or change)
      setTimeout(()=> {
        renderAssignments(false);
        updateMetrics();
      }, parseInt(speedInput.value)+40);
    }

    // One full K-Means iteration: assign → update
    async function stepIteration(){
      if(centroids.length===0 || points.length===0) return;
      assignAll();
      // Pause briefly to show assignments
      await new Promise(resolve => setTimeout(resolve, 300));
      updateCentroidsAnimated();
    }

    stepBtn.addEventListener('click', ()=> stepIteration() );

    // Run / auto-step
    runBtn.addEventListener('click', ()=>{
      setRun(!running);
    });

    function setRun(flag){
      running = flag;
      runBtn.setAttribute('aria-pressed', String(flag));
      if(flag){
        runBtn.textContent = 'Pause';
        // repeat with delay based on speed input
        autoTimer = setInterval(()=>{
          stepIteration();
        }, Math.max(400, parseInt(speedInput.value) + 200));
      } else {
        runBtn.textContent = 'Run';
        clearInterval(autoTimer);
        autoTimer = null;
      }
    }

    // Attach drag handlers for points
    function attachPointHandlers(){
      for(const g of pointsLayer.children){
        g.onpointerdown = (evt) => {
          evt.stopPropagation();
          const id = parseInt(g.getAttribute('data-id'));
          const p = points.find(x=>x.id===id);
          g.setPointerCapture(evt.pointerId);
          const onMove = (ev) => {
            const pos = fromViewXY(ev.clientX, ev.clientY);
            p.x = pos.x; p.y = pos.y;
            g.setAttribute('transform', `translate(${toViewX(p.x)},${toViewY(p.y)})`);
            if(centroids.length>0){
              assignPointToNearest(p);
              renderAssignments(false);
              updateMetrics();
            }
          };
          const onUp = (ev) => {
            g.releasePointerCapture(evt.pointerId);
            window.removeEventListener('pointermove', onMove);
            window.removeEventListener('pointerup', onUp);
          };
          window.addEventListener('pointermove', onMove);
          window.addEventListener('pointerup', onUp);
        };
        // Right-click or double-click to remove point
        g.ondblclick = (e) => {
          const id = parseInt(g.getAttribute('data-id'));
          points = points.filter(pp=>pp.id!==id);
          renderAll();
        };
      }
    }

    // Drag centroids: interactive exploration
    function attachCentroidHandlers(){
      for(const g of centroidsLayer.children){
        g.onpointerdown = (evt) => {
          evt.stopPropagation();
          g.setPointerCapture(evt.pointerId);
          const id = parseInt(g.getAttribute('data-id'));
          const c = centroids[id];
          // reduce transition while dragging
          g.style.transition = 'none';
          const onMove = (ev) => {
            const pos = fromViewXY(ev.clientX, ev.clientY);
            c.x = pos.x; c.y = pos.y;
            g.setAttribute('transform', `translate(${toViewX(c.x)},${toViewY(c.y)})`);
            // immediate reassign on drag for live feedback
            if(points.length>0){
              for(const p of points){ assignPointToNearest(p); }
              renderAssignments(false);
              updateMetrics();
            }
          };
          const onUp = (ev) => {
            g.releasePointerCapture(evt.pointerId);
            // restore transition
            g.style.transition = `transform ${speedInput.value}ms cubic-bezier(.2,.9,.2,1)`;
            window.removeEventListener('pointermove', onMove);
            window.removeEventListener('pointerup', onUp);
          };
          window.addEventListener('pointermove', onMove);
          window.addEventListener('pointerup', onUp);
        };
      }
    }

    // Keyboard accessibility: allow pressing Space to init centroids when focused on button
    [initBtn, stepBtn, runBtn, addRandomBtn, clearBtn, resetBtn].forEach(b=>{
      b.addEventListener('keydown', (e)=> {
        if(e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          b.click();
        }
      });
    });

    // Initial demo state
    (function seedDemo(){
      // Add some points
      for(let i=0;i<30;i++){
        const nx = Math.random()*0.8 + 0.1;
        const ny = Math.random()*0.8 + 0.1;
        points.push({id: uid(), x: nx, y: ny, cluster: null});
      }
      // initialize k centroids
      initCentroids();
      // assign initially
      assignAll();
      renderAll();
    })();

    // Accessibility: keyboard arrow keys move the first centroid when svg is focused
    svg.addEventListener('keydown', (e)=>{
      if(centroids.length===0) return;
      const c = centroids[0];
      const step = 0.02;
      if(e.key === 'ArrowUp'){ c.y = clamp01(c.y - step); }
      if(e.key === 'ArrowDown'){ c.y = clamp01(c.y + step); }
      if(e.key === 'ArrowLeft'){ c.x = clamp01(c.x - step); }
      if(e.key === 'ArrowRight'){ c.x = clamp01(c.x + step); }
      renderAll();
    });

    // Prevent accidental text selection during drag
    svg.addEventListener('dragstart', (e)=> e.preventDefault() );

    // Keep UI consistent on window resize
    window.addEventListener('resize', ()=> {
      // svg viewBox keeps everything responsive; no extra handling needed
    });

    // Extra: clicking on a centroid in legend recenters view (small demonstration)
    legendEl.addEventListener('click', (e)=>{
      const key = e.target.closest('.key');
      if(!key) return;
      const idx = Array.from(legendEl.children).indexOf(key);
      if(idx>=0 && centroids[idx]){
        // highlight centroid briefly
        const g = centroidsLayer.querySelector(`[data-id="${idx}"]`);
        if(g){
          const orig = g.style.transform;
          g.style.transition = 'transform 260ms';
          g.style.transform = g.getAttribute('transform') + ' scale(1.08)';
          setTimeout(()=> g.style.transform = g.getAttribute('transform'), 260);
        }
      }
    });

  </script>
</body>
</html>