<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Recursion — Call Stack Visualizer (Factorial)</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe: 24px;
      --gap: 16px; /* minimum spacing between interactive elements */
      --accent: #2255ff;
      --muted: #6b7280;
      --bg: #0f172a;
      --card: #0b1220;
      --glass: rgba(255,255,255,0.03);
      --success: #16a34a;
      --danger: #ef4444;
    }

    html,body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg, #071027 0%, #041126 100%);
      color: #e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    main {
      padding: var(--safe);
      box-sizing: border-box;
      min-height: 100%;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--gap);
      flex-wrap: wrap;
    }

    .title-block {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 260px;
    }

    h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: -0.02em;
    }

    p.lead {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
    }

    .container {
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: calc(var(--gap) * 1.5);
      align-items: start;
    }

    /* Responsive: single column under 880px */
    @media (max-width: 880px) {
      .container {
        grid-template-columns: 1fr;
      }
    }

    /* Left panel: explanation and meta */
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: calc(var(--gap) * 1.25);
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      min-height: 220px;
    }

    .section {
      margin-bottom: var(--gap);
    }

    .section h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #dbeafe;
    }

    .section p, .section ul {
      margin: 0;
      color: #cfe2ff;
      font-size: 13px;
      line-height: 1.45;
    }

    .muted {
      color: var(--muted);
      font-size: 13px;
    }

    /* Right panel: interactive area */
    .interactive {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: calc(var(--gap) * 1);
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }

    /* pseudo-code area */
    .code {
      display: flex;
      gap: 12px;
      align-items: flex-start;
    }

    pre {
      margin: 0;
      padding: 12px;
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size: 13px;
      color: #dbeafe;
      line-height: 1.45;
      width: 100%;
      box-sizing: border-box;
      overflow: auto;
    }

    .code-line {
      display: block;
      padding: 3px 8px;
      border-radius: 6px;
    }

    .code-line.highlight {
      background: linear-gradient(90deg, rgba(34,85,255,0.16), rgba(34,85,255,0.08));
      box-shadow: 0 1px 0 rgba(34,85,255,0.08) inset;
      color: #eaf2ff;
    }

    /* Visualization area */
    .viz {
      display: flex;
      gap: calc(var(--gap) * 1);
      align-items: stretch;
      min-height: 320px;
    }

    .stack-area {
      flex: 1;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius: 10px;
      padding: 12px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 280px;
      position: relative;
    }

    .stack-title {
      font-size: 13px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .stack-canvas {
      flex: 1;
      display: flex;
      flex-direction: column-reverse; /* bottom = top of stack visually */
      gap: 12px;
      padding: 8px;
      overflow-y: auto;
      scroll-behavior: smooth;
    }

    .frame {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 8px;
      padding: 10px 12px;
      min-height: 56px;
      box-shadow: 0 8px 20px rgba(2,6,23,0.5);
      display: flex;
      gap: 12px;
      align-items: center;
      transform-origin: center;
      transition: transform 320ms cubic-bezier(.2,.9,.2,1), opacity 240ms ease, box-shadow 200ms ease;
      border: 1px solid rgba(255,255,255,0.03);
    }

    .frame.pushed {
      transform: translateY(6px) scale(1.01);
      box-shadow: 0 14px 28px rgba(2,6,23,0.6);
    }

    .frame .label {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size: 14px;
      color: #e6eef8;
      min-width: 120px;
    }

    .frame .details {
      display: flex;
      gap: 12px;
      align-items: center;
      color: #cfe2ff;
      font-size: 13px;
    }

    .result-bubble {
      margin-left: auto;
      background: rgba(255,255,255,0.03);
      color: #e6eef8;
      padding: 6px 10px;
      border-radius: 999px;
      font-family: ui-monospace, monospace;
      font-size: 13px;
      min-width: 48px;
      text-align: center;
      border: 1px solid rgba(255,255,255,0.03);
    }

    .result-bubble.empty {
      color: var(--muted);
      background: transparent;
      border: 1px dashed rgba(255,255,255,0.03);
    }

    /* Controls */
    .controls {
      display: flex;
      gap: var(--gap);
      align-items: center;
      flex-wrap: wrap;
    }

    .controls .group {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    button, input[type="number"], input[type="range"] {
      background: rgba(255,255,255,0.03);
      color: #e6eef8;
      border: 1px solid rgba(255,255,255,0.04);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
    }

    button[aria-pressed="true"] {
      background: linear-gradient(90deg, rgba(34,85,255,0.15), rgba(34,85,255,0.08));
      box-shadow: 0 4px 12px rgba(34,85,255,0.08);
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    input[type="range"] {
      -webkit-appearance: none;
      height: 8px;
      background: rgba(255,255,255,0.03);
      border-radius: 999px;
      padding: 0;
      width: 160px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: var(--accent);
      border-radius: 50%;
      box-shadow: 0 4px 10px rgba(34,85,255,0.24);
      border: 2px solid rgba(255,255,255,0.06);
    }

    .info {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 13px;
      color: var(--muted);
    }

    .small {
      font-size: 12px;
      color: var(--muted);
    }

    /* Accessibility focus */
    button:focus, input:focus {
      outline: 3px solid rgba(34,85,255,0.16);
      outline-offset: 2px;
    }

    /* Footer hints */
    .hints {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    /* Tiny indicators */
    .badge {
      font-size: 12px;
      color: #cfe2ff;
      background: rgba(255,255,255,0.02);
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.03);
    }

  </style>
</head>
<body>
  <main>
    <header>
      <div class="title-block">
        <h1>Recursion — Visualizing the Call Stack (factorial)</h1>
        <p class="lead">Explore how recursive calls are made and how results flow back up the stack.</p>
      </div>
      <div class="small muted">Safe margins: 24px • Min spacing: 16px • Keyboard accessible</div>
    </header>

    <div class="container" role="main">
      <!-- Left: Explanations -->
      <aside class="panel" aria-labelledby="concept-title">
        <div class="section">
          <h3 id="concept-title">Concept Title</h3>
          <p>Recursion: Understanding how a function calls itself, forms activation frames on the call stack, reaches a base case, and returns values back through the stack.</p>
        </div>

        <div class="section">
          <h3>Learning Objective</h3>
          <p>After interacting with this module you will be able to:</p>
          <ul>
            <li>Describe how recursive calls build a stack of activation records.</li>
            <li>Identify the base case and see where computation happens.</li>
            <li>Observe how return values propagate back through previous frames.</li>
          </ul>
        </div>

        <div class="section">
          <h3>Interaction Design</h3>
          <p>This interactive demonstrates the factorial function recursively. You can:</p>
          <ul>
            <li>Adjust the input n (0–10) using the slider or number input.</li>
            <li>Step forward and backward through each "event" (call push, calculate return value, pop).</li>
            <li>Play an automatic animation with adjustable speed to see calls pushed and popped in sequence.</li>
            <li>Watch the pseudo-code highlight the currently executing line and the stack update animations.</li>
          </ul>
          <p class="muted">Animations: frames slide and highlight when pushed/popped; return values appear in result bubbles. Controls are keyboard-accessible; focus will move to the active control.</p>
        </div>

        <div class="section">
          <h3>Layout Description</h3>
          <p>The page is split into two columns (responsive to one column on small screens):</p>
          <ul>
            <li>Left panel: concise explanations — concept title, objective, interaction design, and layout description.</li>
            <li>Right panel: the interactive module — a pseudo-code area, a visual call-stack canvas, and control bar with inputs and play/step buttons.</li>
          </ul>
          <p class="muted">Design constraints: 24px safe margins; at least 16px spacing between interactive elements; clear visual hierarchy; semantic roles and ARIA labels ensure accessibility.</p>
        </div>
      </aside>

      <!-- Right: Interactive module -->
      <section class="interactive" aria-label="Recursion interactive module">
        <div class="card" aria-hidden="false">
          <!-- Pseudo-code & highlights -->
          <div class="code" aria-hidden="false">
            <pre id="pseudocode" aria-label="Pseudo code for factorial" role="region">
<span class="code-line" data-line="1">function factorial(n) {</span>
<span class="code-line" data-line="2">  if (n === 0) {</span>
<span class="code-line" data-line="3">    return 1;                // base case</span>
<span class="code-line" data-line="4">  }</span>
<span class="code-line" data-line="5">  const result = n * factorial(n - 1);</span>
<span class="code-line" data-line="6">  return result;</span>
<span class="code-line" data-line="7">}</span>
            </pre>
          </div>
        </div>

        <div class="viz card" role="region" aria-label="Visualization and controls">
          <div class="stack-area" aria-live="polite">
            <div class="stack-title">
              <div class="badge" aria-hidden="true">Call Stack</div>
              <div class="muted" style="margin-left:8px">Bottom = most recent call</div>
            </div>
            <div id="stackCanvas" class="stack-canvas" tabindex="0" aria-label="Call stack canvas"></div>
          </div>

          <div style="width:320px; display:flex; flex-direction:column; gap:12px;">
            <div class="card" style="padding:12px;">
              <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
                <div>
                  <label for="nInput" class="small">Input n</label>
                  <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
                    <input id="nInput" type="number" min="0" max="10" value="5" aria-label="Number input for n" />
                    <input id="nRange" type="range" min="0" max="10" value="5" aria-label="Slider for n" />
                  </div>
                </div>
                <div style="text-align:right">
                  <div class="small muted">Events:</div>
                  <div id="eventCount" class="badge" aria-live="polite">0</div>
                </div>
              </div>
            </div>

            <div class="card" style="padding:12px;">
              <div class="controls" role="toolbar" aria-label="Animation controls">
                <div class="group">
                  <button id="btnStepBack" title="Step backward (undo event)" aria-label="Step back">&larr; Step</button>
                  <button id="btnStep" title="Step forward (next event)" aria-label="Step forward">Step &rarr;</button>
                  <button id="btnPlay" aria-pressed="false" title="Play / pause" aria-label="Play or pause">Play</button>
                  <button id="btnReset" title="Reset visualization" aria-label="Reset">Reset</button>
                </div>

                <div class="group" style="margin-left:auto">
                  <div class="small muted" style="margin-right:8px">Speed</div>
                  <input id="speedRange" type="range" min="0.25" max="2.5" step="0.25" value="1" aria-label="Playback speed" />
                </div>
              </div>

              <div class="hints" aria-hidden="true">Tip: Use Step to see each call pushed and when values are returned. Play animates the entire process.</div>
            </div>

            <div class="card" style="padding:12px; display:flex; flex-direction:column; gap:8px;">
              <div style="display:flex; justify-content:space-between; align-items:center;">
                <div class="small muted">Current event</div>
                <div id="currentEvent" class="badge">—</div>
              </div>
              <div class="small muted">Pseudo-code highlights the currently executing line; frames animate when pushed and when returning values are placed.</div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </main>

  <script>
    /*
      Recursion Visualizer (factorial)
      - Generates a linear sequence of events representing recursive calls and returns.
      - Events: {type: 'push', k}, {type:'setResult', k, value}, {type:'pop', k}
      - The UI can step forward/backward; stepping re-renders up to the current index.
    */

    (function () {
      // DOM references
      const nInput = document.getElementById('nInput');
      const nRange = document.getElementById('nRange');
      const btnStep = document.getElementById('btnStep');
      const btnStepBack = document.getElementById('btnStepBack');
      const btnPlay = document.getElementById('btnPlay');
      const btnReset = document.getElementById('btnReset');
      const stackCanvas = document.getElementById('stackCanvas');
      const pseudocode = document.getElementById('pseudocode');
      const eventCountBadge = document.getElementById('eventCount');
      const currentEventBadge = document.getElementById('currentEvent');
      const speedRange = document.getElementById('speedRange');

      // Visual state
      let events = [];
      let pointer = 0; // how many events have been applied (0..events.length)
      let playing = false;
      let playTimer = null;

      // Ensure inputs mirrored
      function setN(value) {
        value = Math.max(0, Math.min(10, Math.floor(value)));
        nInput.value = value;
        nRange.value = value;
        rebuildEvents();
        resetVisualization();
      }

      nInput.addEventListener('change', e => setN(Number(e.target.value)));
      nRange.addEventListener('input', e => setN(Number(e.target.value)));

      // Build events for factorial(n)
      function buildEventsForFactorial(n) {
        const list = [];
        // recursive generator
        function rec(k) {
          list.push({type:'push', k});
          if (k === 0) {
            list.push({type:'setResult', k, value:1});
            list.push({type:'pop', k});
            return 1;
          } else {
            const sub = rec(k - 1); // events recorded during recursion
            const value = k * sub;
            list.push({type:'setResult', k, value});
            list.push({type:'pop', k});
            return value;
          }
        }
        rec(n);
        return list;
      }

      function rebuildEvents() {
        const n = Number(nInput.value);
        events = buildEventsForFactorial(n);
        eventCountBadge.textContent = events.length;
      }

      // Rendering: apply events up to pointer by re-building stack state
      function renderUpTo(index) {
        // index: number of events to apply (0..events.length)
        // Clear canvas
        stackCanvas.innerHTML = '';
        // We'll reconstruct frames by simulating events and maintaining a stack map
        const stack = [];
        let currentLine = null;
        for (let i = 0; i < index && i < events.length; i++) {
          const ev = events[i];
          if (ev.type === 'push') {
            // create frame object
            const frame = {k: ev.k, result: null};
            stack.push(frame);
            currentLine = 5; // line number where function calls factorial(...)
          } else if (ev.type === 'setResult') {
            // find topmost frame with matching k (should be top)
            const top = stack[stack.length - 1];
            if (top && top.k === ev.k) {
              top.result = ev.value;
            } else {
              // fallback: set the last matching
              for (let j = stack.length - 1; j >= 0; j--) {
                if (stack[j].k === ev.k) {
                  stack[j].result = ev.value;
                  break;
                }
              }
            }
            currentLine = (ev.k === 0) ? 3 : 5; // base case return line or compute line
          } else if (ev.type === 'pop') {
            // pop the top
            stack.pop();
            currentLine = 6; // return result line
          }
        }

        // Build DOM frames from stack (bottom-first visually)
        // Note: our stack array is in call order (bottom[0] .. top[last])
        for (let i = 0; i < stack.length; i++) {
          const frame = stack[i];
          const el = createFrameElement(frame.k, frame.result);
          // For subtle animation feel when rendering via stepping, mark as pushed if it was recently pushed
          el.classList.add('pushed');
          stackCanvas.appendChild(el);
          // trigger remove of 'pushed' so CSS animation returns to normal
          (function (el) {
            requestAnimationFrame(() => {
              setTimeout(() => el.classList.remove('pushed'), 350);
            });
          })(el);
        }

        // Update pseudocode highlight and current event badge
        // Map currentLine to highlight
        highlightLine(currentLine);
        currentEventBadge.textContent = index === 0 ? '—' : describeEvent(events[index - 1]);
      }

      function createFrameElement(k, result) {
        const div = document.createElement('div');
        div.className = 'frame';
        div.setAttribute('role','group');
        div.setAttribute('aria-label', 'frame factorial ' + k);

        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = `factorial(${k})`;

        const details = document.createElement('div');
        details.className = 'details';
        details.innerHTML = `<div>n = ${k}</div>`;

        const resultBubble = document.createElement('div');
        resultBubble.className = 'result-bubble ' + (result == null ? 'empty' : '');
        resultBubble.textContent = result == null ? '…' : String(result);

        div.appendChild(label);
        div.appendChild(details);
        div.appendChild(resultBubble);
        return div;
      }

      function describeEvent(ev) {
        if (!ev) return '—';
        if (ev.type === 'push') return `push factorial(${ev.k})`;
        if (ev.type === 'setResult') return `set result ${ev.value} for ${ev.k}`;
        if (ev.type === 'pop') return `pop factorial(${ev.k})`;
        return String(ev.type);
      }

      // Pseudo-code highlighting
      function highlightLine(line) {
        const lines = pseudocode.querySelectorAll('.code-line');
        lines.forEach(l => l.classList.remove('highlight'));
        if (!line) return;
        const target = pseudocode.querySelector('.code-line[data-line="' + line + '"]');
        if (target) target.classList.add('highlight');
      }

      // Controls behavior
      btnStep.addEventListener('click', () => {
        stepForward();
      });

      btnStepBack.addEventListener('click', () => {
        stepBack();
      });

      btnReset.addEventListener('click', () => {
        resetVisualization();
      });

      btnPlay.addEventListener('click', () => {
        togglePlay();
      });

      speedRange.addEventListener('input', () => {
        if (playing) {
          startPlayTimer();
        }
      });

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.key === ' ' && e.target.tagName !== 'INPUT') {
          e.preventDefault();
          togglePlay();
        } else if (e.key === 'ArrowRight') {
          stepForward();
        } else if (e.key === 'ArrowLeft') {
          stepBack();
        }
      });

      function stepForward() {
        if (pointer < events.length) {
          pointer++;
          renderUpTo(pointer);
          updateButtons();
          // scroll stack canvas to bottom to show most recent frames
          stackCanvas.scrollTop = stackCanvas.scrollHeight;
        }
      }

      function stepBack() {
        if (pointer > 0) {
          pointer--;
          renderUpTo(pointer);
          updateButtons();
        }
      }

      function resetVisualization() {
        pointer = 0;
        renderUpTo(pointer);
        stopPlaying();
        updateButtons();
      }

      function updateButtons() {
        btnStep.disabled = pointer >= events.length;
        btnStepBack.disabled = pointer <= 0;
        btnPlay.setAttribute('aria-pressed', playing ? 'true' : 'false');
      }

      function togglePlay() {
        if (playing) {
          stopPlaying();
        } else {
          startPlaying();
        }
      }

      function startPlaying() {
        if (events.length === 0 || pointer >= events.length) {
          pointer = 0; // restart if we're at the end
          renderUpTo(pointer);
        }
        playing = true;
        startPlayTimer();
        updateButtons();
      }

      function startPlayTimer() {
        stopPlayingTimer();
        const speed = Number(speedRange.value) || 1;
        const baseDelay = 700; // ms per event
        const delay = Math.max(80, baseDelay / speed);
        playTimer = setInterval(() => {
          if (pointer < events.length) {
            pointer++;
            renderUpTo(pointer);
            // scroll to show most recent
            stackCanvas.scrollTop = stackCanvas.scrollHeight;
          } else {
            stopPlaying();
          }
          updateButtons();
        }, delay);
      }

      function stopPlayingTimer() {
        if (playTimer) {
          clearInterval(playTimer);
          playTimer = null;
        }
      }

      function stopPlaying() {
        playing = false;
        stopPlayingTimer();
        updateButtons();
      }

      // Initialize
      setN(Number(nInput.value || 5));
      resetVisualization();
      updateButtons();

      // Expose for accessibility testing (not necessary, but convenient)
      window.recursionVisualizer = {
        rebuildEvents,
        renderUpTo,
        get events() { return events; },
      };
    })();
  </script>
</body>
</html>