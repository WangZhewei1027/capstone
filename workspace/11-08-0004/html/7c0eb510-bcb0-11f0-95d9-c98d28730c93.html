<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive: Prim’s Algorithm — Hands-on Module</title>
  <style>
    :root{
      --safe-pad: 24px;
      --gap: 16px;
      --panel-width: 360px;
      --accent: #0b6efd;
      --muted: #666;
      --bg: #f7f9fc;
      --card: #ffffff;
      --success: #16a34a;
      --warning: #f59e0b;
      --danger: #ef4444;
    }

    /* Safe area margins on all sides */
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      color:#0b2545;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      box-sizing:border-box;
    }
    * { box-sizing: inherit; }

    .app {
      padding: var(--safe-pad);
      min-height:100dvh;
      display:flex;
      gap: var(--gap);
      align-items:stretch;
      justify-content:stretch;
    }

    /* Left panel contains descriptive sections + controls */
    .left {
      width: var(--panel-width);
      min-width: 260px;
      max-width: 420px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    .card {
      background:var(--card);
      border-radius:10px;
      padding:18px;
      box-shadow:0 4px 14px rgba(10,20,40,0.06);
    }

    h1 {
      margin:0 0 8px 0;
      font-size:18px;
      line-height:1.15;
    }
    p { margin:0 0 12px 0; color:var(--muted); font-size:13px; }

    /* Controls grouped */
    .controls {
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    .row {
      display:flex;
      gap: var(--gap);
      align-items:center;
    }
    button {
      background:linear-gradient(180deg,#0b6efd,#0659d6);
      color:white;
      border:0;
      padding:10px 12px;
      border-radius:8px;
      font-weight:600;
      cursor:pointer;
      box-shadow:0 6px 18px rgba(11,110,253,0.18);
    }
    button.secondary {
      background:transparent;
      color:var(--accent);
      border:1px solid rgba(11,110,253,0.12);
      box-shadow:none;
      font-weight:600;
    }
    button.ghost {
      background:transparent;
      color:var(--muted);
      border:1px dashed rgba(0,0,0,0.06);
    }
    button.danger {
      background:linear-gradient(180deg,#ff5a5a,#e43b3b);
      box-shadow:0 6px 18px rgba(228,59,59,0.18);
    }

    input[type="number"], input[type="text"], select {
      padding:8px 10px;
      border-radius:8px;
      border:1px solid #e6eef8;
      min-width:60px;
      font-size:14px;
    }

    label { font-size:13px; color:var(--muted); }

    /* Right area: visualization */
    .right {
      flex:1;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      min-width:0;
    }

    .canvas-card {
      flex:1;
      background:linear-gradient(180deg,white, #fbfdff);
      border-radius:12px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
      box-shadow:0 6px 20px rgba(7,18,36,0.06);
      min-height:380px;
    }

    /* SVG grows to container */
    .graph-area {
      flex:1;
      border-radius:8px;
      background:repeating-linear-gradient(45deg,#fcfeff 0 1px, transparent 1px 20px);
      position:relative;
      overflow:hidden;
    }

    svg {
      width:100%;
      height:100%;
      display:block;
    }

    /* Node/edge styling */
    .edge {
      stroke:#cbd5e1;
      stroke-width:2;
      transition: stroke 300ms, stroke-width 300ms, opacity 300ms;
      opacity:0.95;
    }
    .edge.considered {
      stroke:var(--warning);
      stroke-width:3;
      filter: drop-shadow(0 3px 8px rgba(245,158,11,0.16));
    }
    .edge.mst {
      stroke:var(--success);
      stroke-width:4;
      filter: drop-shadow(0 6px 18px rgba(22,163,74,0.14));
    }
    .node {
      fill:white;
      stroke:#0b6efd;
      stroke-width:2;
      r:18;
      cursor:pointer;
      transition: transform 160ms, stroke 160ms, filter 160ms;
    }
    .node.visited {
      fill:linear-gradient(0deg,#e6fbf0,#dff6e7);
      fill:#e9fff0;
      stroke:var(--success);
    }
    .node.start {
      stroke: #f59e0b;
    }
    .node-label {
      font-size:12px;
      text-anchor:middle;
      dominant-baseline:middle;
      pointer-events:none;
      fill:#0b2545;
      font-weight:600;
    }

    .weight-label {
      font-size:12px;
      fill:#0b2545;
      text-anchor:middle;
      dominant-baseline:middle;
      pointer-events:none;
      background:transparent;
      font-weight:600;
    }

    /* UI footer showing state */
    .state-bar {
      display:flex;
      gap:var(--gap);
      align-items:center;
      justify-content:space-between;
    }
    .state-item {
      background:#f8fafc;
      border-radius:10px;
      padding:8px 10px;
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:8px;
      align-items:center;
    }

    .pq-list {
      max-height:160px;
      overflow:auto;
      padding:8px;
      border-radius:8px;
      background:#fff;
      border:1px solid #eef6ff;
      font-size:13px;
    }
    .pq-item { padding:6px; border-bottom:1px solid #f3f7ff; display:flex; justify-content:space-between; }
    .pq-item:last-child { border-bottom:0; }
    .pq-item small { color:var(--muted); }

    /* Responsive adjustments */
    @media (max-width:980px){
      .app { flex-direction:column; }
      .left { width:100%; max-width:none; }
      .right { width:100%; }
    }

    /* Tooltip for helper text */
    .hint {
      font-size:12px;
      color:var(--muted);
    }

    /* Minimum spacing enforcement for interactive elements */
    .controls > * { margin-bottom: var(--gap); }
    .controls > *:last-child { margin-bottom:0; }
  </style>
</head>
<body>
  <div class="app" role="main">
    <!-- LEFT: Planning & Controls -->
    <div class="left" aria-label="Module information and controls">
      <div class="card" aria-hidden="false">
        <h1>Prim’s Algorithm — Minimum Spanning Tree (MST)</h1>
        <p>Explore Prim’s greedy strategy for building a Minimum Spanning Tree on a connected weighted graph.</p>
        <div class="hint"><strong>Tip:</strong> Click the canvas to add nodes. Click one node then another to connect them. Use controls below to run Prim step-by-step.</div>
      </div>

      <div class="card" aria-labelledby="learning-objective">
        <h2 id="learning-objective" style="font-size:15px; margin-bottom:6px;">Learning Objective</h2>
        <p>After interacting, you will understand how Prim’s algorithm grows an MST from a start node by repeatedly adding the smallest-weight edge connecting the visited set to the unvisited nodes. You'll see how the priority (frontier) changes and why the algorithm picks specific edges.</p>
      </div>

      <div class="card" aria-labelledby="interaction-design">
        <h2 id="interaction-design" style="font-size:15px; margin-bottom:6px;">Interaction Design</h2>
        <p>Interactive controls and visual feedback:</p>
        <ul style="margin:8px 0 0 18px; color:var(--muted); font-size:13px;">
          <li>Canvas: Click to add nodes. Drag nodes to reposition.</li>
          <li>Edge creation: Click one node to select (orange), then click another to create an edge. Enter a weight or use random weight.</li>
          <li>Start node: Click a node and press "Set Start". The algorithm highlights visited nodes (green) and chosen MST edges (thick green).</li>
          <li>Step controls: "Step" advances one edge selection; "Play" auto-steps; "Reset" restarts the algorithm retaining the graph.</li>
          <li>Priority queue shows candidate edges ordered by weight and updates live. Animations emphasize edges considered and chosen.</li>
        </ul>
      </div>

      <div class="card controls" aria-labelledby="controls">
        <h2 id="controls" style="font-size:15px; margin-bottom:6px;">Controls</h2>

        <div class="row" style="align-items:center;">
          <label for="edge-weight" style="min-width:120px;">Edge Weight (when creating):</label>
          <input id="edge-weight" type="number" min="1" step="1" placeholder="auto" aria-label="Edge weight" />
          <button id="rand-weight" class="secondary" title="Use random weight for next edge">Random</button>
        </div>

        <div class="row">
          <button id="btn-step" aria-live="polite">Step</button>
          <button id="btn-play" class="secondary" aria-pressed="false">Play</button>
          <button id="btn-reset" class="ghost" title="Reset algorithm state">Reset</button>
        </div>

        <div class="row">
          <button id="btn-clear" class="danger">Clear Graph</button>
          <button id="btn-random-graph" class="secondary">Generate Random Graph</button>
        </div>

        <div class="row" style="align-items:center;">
          <button id="btn-set-start" class="secondary">Set Start</button>
          <label style="margin-left:8px;"><input id="auto-weight-checkbox" type="checkbox" /> auto-edge-weight</label>
        </div>

        <div class="row" style="align-items:center;">
          <label for="speed">Play speed</label>
          <input id="speed" type="range" min="200" max="2000" step="100" value="800" aria-label="Playback speed" />
          <span id="speed-value" style="font-size:13px; color:var(--muted); margin-left:6px;">800ms</span>
        </div>

        <div style="font-size:12px;color:var(--muted); margin-top:6px;">Keyboard: Esc cancels edge creation; Space = Step; Enter = Play/Pause.</div>
      </div>

      <div class="card" aria-labelledby="layout-desc">
        <h2 id="layout-desc" style="font-size:15px; margin-bottom:6px;">Layout Description</h2>
        <p>The interface uses a two-column responsive layout: a left column for explanations and controls, and a right, flexible canvas area for the graph and algorithm visualization. Spacing rules: 24px safe margins, 16px minimum spacing between interactive elements. SVG nodes and edges are keyboard and pointer accessible. Controls have clear labels and sufficient contrast for accessibility.</p>
      </div>
    </div>

    <!-- RIGHT: Interactive visualization -->
    <div class="right" aria-label="Interactive visualization area">
      <div class="canvas-card" role="region" aria-label="Graph canvas and algorithm controls">
        <div style="display:flex; gap:12px; align-items:center; justify-content:space-between;">
          <div style="display:flex; gap:8px; align-items:center;">
            <div style="display:flex; align-items:center; gap:8px;">
              <div style="width:12px; height:12px; background:var(--success); border-radius:3px;"></div><div style="font-size:13px;color:var(--muted)">MST edge</div>
              <div style="width:12px; height:12px; background:var(--warning); border-radius:3px; margin-left:8px;"></div><div style="font-size:13px;color:var(--muted)">Frontier</div>
            </div>
          </div>
          <div style="font-size:13px;color:var(--muted)">Canvas: click to add nodes • drag nodes to reposition</div>
        </div>

        <div class="graph-area" id="graph-area" tabindex="0" aria-label="Graph drawing area">
          <svg id="svg" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Graph visualization"></svg>
        </div>

        <div class="state-bar">
          <div class="state-item" aria-live="polite">Visited: <strong id="visited-count">0</strong></div>
          <div class="state-item">MST Weight: <strong id="mst-weight">0</strong></div>
          <div style="flex:1;"></div>
          <div style="width:320px;">
            <div style="font-size:13px; margin-bottom:8px; color:var(--muted)">Priority Queue (frontier) — smallest first</div>
            <div class="pq-list" id="pq-list" aria-live="polite" role="log" aria-label="Priority queue of frontier edges"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Prim's Algorithm Interactive Module (vanilla JS, no external libs)
    (function(){
      // Constants & DOM refs
      const svg = document.getElementById('svg');
      const graphArea = document.getElementById('graph-area');
      const btnStep = document.getElementById('btn-step');
      const btnPlay = document.getElementById('btn-play');
      const btnReset = document.getElementById('btn-reset');
      const btnClear = document.getElementById('btn-clear');
      const btnRandomGraph = document.getElementById('btn-random-graph');
      const btnSetStart = document.getElementById('btn-set-start');
      const randWeightBtn = document.getElementById('rand-weight');
      const edgeWeightInput = document.getElementById('edge-weight');
      const autoWeightCheckbox = document.getElementById('auto-weight-checkbox');
      const speedInput = document.getElementById('speed');
      const speedValue = document.getElementById('speed-value');

      const visitedCountEl = document.getElementById('visited-count');
      const mstWeightEl = document.getElementById('mst-weight');
      const pqListEl = document.getElementById('pq-list');

      // Data structures
      let nodes = []; // {id, x, y}
      let edges = []; // {id, u, v, w, element (line), labelEl}
      let nodeIdCounter = 0;
      let edgeIdCounter = 0;

      // Algorithm state
      let visited = new Set();
      let mstEdges = new Set();
      let frontier = []; // array of candidate edges {edgeId, w, from, to}
      let startNode = null;
      let autoPlay = false;
      let playTimer = null;

      // Interaction state
      let creatingEdgeFrom = null;
      let draggingNode = null;
      let dragOffset = {x:0,y:0};
      let useRandomWeightNext = false;

      // Viewbox size
      const VB_W = 1200, VB_H = 700;

      // Utility: create SVG elements
      function svgEl(tag, attrs = {}) {
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const k in attrs) {
          el.setAttribute(k, attrs[k]);
        }
        return el;
      }

      // Coordinate helpers (convert client coords to SVG viewBox coords)
      function clientToSVGCoords(clientX, clientY) {
        const pt = svg.createSVGPoint();
        pt.x = clientX;
        pt.y = clientY;
        const ctm = svg.getScreenCTM().inverse();
        return pt.matrixTransform(ctm);
      }

      // Add node at viewBox coords
      function addNode(x, y, label) {
        const id = ++nodeIdCounter;
        const nodeGroup = svgEl('g', {class:'node-group', 'data-id': id});
        const circle = svgEl('circle', {
          class:'node',
          cx:x, cy:y, r:18,
          tabindex:0,
          role:'button',
          'aria-label': 'Graph node ' + (label || id)
        });
        const text = svgEl('text', {class:'node-label', x:x, y:y});
        text.textContent = label || id;
        nodeGroup.appendChild(circle);
        nodeGroup.appendChild(text);
        svg.appendChild(nodeGroup);

        const node = {id, x, y, el:nodeGroup, circleEl:circle, labelEl:text};
        nodes.push(node);

        // Event listeners for node interactions
        circle.addEventListener('mousedown', (ev)=> {
          ev.stopPropagation();
          draggingNode = node;
          const pt = clientToSVGCoords(ev.clientX, ev.clientY);
          dragOffset.x = pt.x - node.x;
          dragOffset.y = pt.y - node.y;
        });
        circle.addEventListener('touchstart', (ev)=> {
          if(ev.touches && ev.touches[0]){
            ev.stopPropagation();
            draggingNode = node;
            const pt = clientToSVGCoords(ev.touches[0].clientX, ev.touches[0].clientY);
            dragOffset.x = pt.x - node.x;
            dragOffset.y = pt.y - node.y;
          }
        }, {passive:true});

        circle.addEventListener('click', (ev)=> {
          ev.stopPropagation();
          handleNodeClick(node);
        });

        circle.addEventListener('keydown', (ev)=> {
          if(ev.key === 'Enter' || ev.key === ' ') {
            ev.preventDefault();
            handleNodeClick(node);
          }
        });

        updateGraph();
        return node;
      }

      // Add edge between node objects u and v with weight w
      function addEdge(u, v, w) {
        // prevent duplicate edges (undirected)
        const exists = edges.find(e => (e.u===u.id && e.v===v.id) || (e.u===v.id && e.v===u.id));
        if (exists) {
          exists.w = w;
          exists.labelEl.textContent = w;
          return exists;
        }

        const id = ++edgeIdCounter;
        const line = svgEl('line', {
          class:'edge',
          x1:u.x, y1:u.y, x2:v.x, y2:v.y,
          'data-id': id
        });
        // weight label at midpoint
        const midx = (u.x+v.x)/2, midy = (u.y+v.y)/2;
        const label = svgEl('text', {class:'weight-label', x:midx, y:midy});
        label.textContent = w;
        // put edge before nodes (so edges are under nodes)
        svg.insertBefore(line, svg.firstChild);
        svg.appendChild(label);

        const edge = {id, u: u.id, v: v.id, w, el: line, labelEl: label, considered:false, inMST:false};
        edges.push(edge);

        // Click to toggle highlight or remove?
        line.addEventListener('click', (ev)=> {
          ev.stopPropagation();
          // highlight on click briefly
          pulseEdge(edge);
        });

        updateGraph();
        return edge;
      }

      function pulseEdge(edge) {
        edge.el.classList.add('considered');
        setTimeout(()=>{ edge.el.classList.remove('considered'); }, 600);
      }

      // Update positions of svg elements when nodes move
      function updateGraph() {
        // Update edges positions & label positions
        for (const e of edges) {
          const u = nodes.find(n=>n.id===e.u);
          const v = nodes.find(n=>n.id===e.v);
          if (!u || !v) continue;
          e.el.setAttribute('x1', u.x);
          e.el.setAttribute('y1', u.y);
          e.el.setAttribute('x2', v.x);
          e.el.setAttribute('y2', v.y);
          const mx = (u.x+v.x)/2, my = (u.y+v.y)/2;
          e.labelEl.setAttribute('x', mx);
          e.labelEl.setAttribute('y', my - 6);
          // classes for visual state
          e.el.classList.toggle('mst', e.inMST);
          e.el.classList.toggle('considered', e.considered && !e.inMST);
        }

        // Update nodes coordinates
        for (const n of nodes) {
          n.circleEl.setAttribute('cx', n.x);
          n.circleEl.setAttribute('cy', n.y);
          n.labelEl.setAttribute('x', n.x);
          n.labelEl.setAttribute('y', n.y+1);
          n.circleEl.classList.toggle('visited', visited.has(n.id));
          n.circleEl.classList.toggle('start', startNode && startNode.id === n.id);
        }
        // Update counters & PQ display
        visitedCountEl.textContent = visited.size;
        mstWeightEl.textContent = computeMSTWeight();
        renderPQ();
      }

      function computeMSTWeight() {
        let total = 0;
        for (const e of edges) if (e.inMST) total += e.w;
        return total;
      }

      // Node click behavior: create edge or set start depending on mode
      function handleNodeClick(node) {
        if (creatingEdgeFrom && creatingEdgeFrom.id === node.id) {
          // cancel creating
          creatingEdgeFrom = null;
          highlightTempNode(null);
          return;
        }
        if (creatingEdgeFrom) {
          // create edge between creatingEdgeFrom and node
          const weight = getNextEdgeWeight();
          addEdge(creatingEdgeFrom, node, weight);
          creatingEdgeFrom = null;
          highlightTempNode(null);
          return;
        }
        // else, begin creating edge from this node
        creatingEdgeFrom = node;
        highlightTempNode(node);
      }

      function highlightTempNode(node) {
        // visual: stroke change
        nodes.forEach(n => {
          if (node && n.id === node.id) {
            n.circleEl.style.filter = 'drop-shadow(0 6px 18px rgba(11,110,253,0.16))';
            n.circleEl.setAttribute('stroke','#f59e0b');
          } else {
            n.circleEl.style.filter = '';
            n.circleEl.setAttribute('stroke','#0b6efd');
          }
        });
      }

      function getNextEdgeWeight() {
        if (useRandomWeightNext) {
          return 1 + Math.floor(Math.random()*20);
        }
        const val = parseInt(edgeWeightInput.value);
        if (!isNaN(val) && val>0) return val;
        // fallback to random
        return 1 + Math.floor(Math.random()*20);
      }

      // Canvas interactions: add node on click when clicking empty space
      svg.addEventListener('click', (ev)=> {
        // if clicking on empty area (not on a node)
        if (ev.target === svg || ev.target === svg.querySelector('rect')) {
          const pt = clientToSVGCoords(ev.clientX, ev.clientY);
          const label = String(nodes.length + 1);
          addNode(Math.max(50, Math.min(VB_W-50, pt.x)), Math.max(50, Math.min(VB_H-50, pt.y)), label);
          creatingEdgeFrom = null;
          highlightTempNode(null);
        }
      });

      // Pointer/touch move for node dragging
      function clearDrag() {
        draggingNode = null;
      }
      document.addEventListener('mousemove', (ev)=> {
        if (!draggingNode) return;
        const pt = clientToSVGCoords(ev.clientX, ev.clientY);
        draggingNode.x = Math.max(40, Math.min(VB_W-40, pt.x - dragOffset.x));
        draggingNode.y = Math.max(40, Math.min(VB_H-40, pt.y - dragOffset.y));
        updateGraph();
      });
      document.addEventListener('mouseup', ()=> { clearDrag(); });

      document.addEventListener('touchmove', (ev)=> {
        if (!draggingNode || !ev.touches || !ev.touches[0]) return;
        const pt = clientToSVGCoords(ev.touches[0].clientX, ev.touches[0].clientY);
        draggingNode.x = Math.max(40, Math.min(VB_W-40, pt.x - dragOffset.x));
        draggingNode.y = Math.max(40, Math.min(VB_H-40, pt.y - dragOffset.y));
        updateGraph();
      }, {passive:true});
      document.addEventListener('touchend', ()=> { clearDrag(); });

      // Keyboard shortcuts
      document.addEventListener('keydown', (ev)=> {
        if (ev.key === 'Escape') {
          creatingEdgeFrom = null;
          highlightTempNode(null);
        } else if (ev.code === 'Space') {
          ev.preventDefault();
          stepPrim();
        } else if (ev.key === 'Enter') {
          togglePlay();
        }
      });

      // Prim's algorithm steps
      function initPrim() {
        visited.clear();
        frontier = [];
        mstEdges.clear();
        edges.forEach(e => { e.inMST = false; e.considered = false; });
        if (!startNode && nodes.length>0) startNode = nodes[0];
        if (startNode) {
          visited.add(startNode.id);
          // add all edges from start to frontier
          for (const e of edges) {
            if (e.u === startNode.id || e.v === startNode.id) {
              const candidate = makeCandidate(e);
              frontier.push(candidate);
              e.considered = true;
            }
          }
        }
        updateGraph();
      }

      function makeCandidate(edge) {
        // candidate always represented from visited node to unvisited node
        const from = visited.has(edge.u) ? edge.u : edge.v;
        const to = (from===edge.u) ? edge.v : edge.u;
        return {edgeId: edge.id, w: edge.w, from, to};
      }

      function renderPQ() {
        // sort frontier by weight
        frontier.sort((a,b)=>a.w - b.w || a.edgeId - b.edgeId);
        pqListEl.innerHTML = '';
        if (frontier.length === 0) {
          pqListEl.textContent = '(empty)';
          return;
        }
        frontier.forEach(c => {
          const e = edges.find(x=>x.id === c.edgeId);
          const fromN = nodes.find(n=>n.id===c.from);
          const toN = nodes.find(n=>n.id===c.to);
          const div = document.createElement('div');
          div.className = 'pq-item';
          div.innerHTML = '<div><strong>' + c.w + '</strong> <small>('+ (fromN?fromN.labelEl.textContent:'?') +'→'+ (toN?toN.labelEl.textContent:'?') +')</small></div>';
          pqListEl.appendChild(div);
        });
      }

      function stepPrim() {
        if (nodes.length === 0) return;
        if (!startNode) {
          // ask user to set start: default to first node
          startNode = nodes[0];
        }
        // If first step init visited set
        if (visited.size === 0) {
          initPrim();
          updateGraph();
          return;
        }

        // Clean frontier of edges that no longer cross visited/unvisited (both visited)
        frontier = frontier.filter(c => {
          const toVisited = visited.has(c.to);
          const bothVisited = visited.has(c.from) && visited.has(c.to);
          return !bothVisited;
        });

        // If frontier empty and there are unvisited nodes, add edges from visited nodes to their neighbors
        if (frontier.length === 0) {
          // gather edges that connect visited to unvisited
          for (const e of edges) {
            const a = visited.has(e.u), b = visited.has(e.v);
            if (a !== b && !e.considered) {
              e.considered = true;
              frontier.push(makeCandidate(e));
            }
          }
        }

        // If still empty, algorithm finished (either disconnected graph or done)
        if (frontier.length === 0) {
          // mark finished
          stopPlay();
          return;
        }

        // Pick min weight candidate (tie-break by id)
        frontier.sort((a,b)=> a.w - b.w || a.edgeId - b.edgeId);
        const pick = frontier.shift();
        const edge = edges.find(e => e.id === pick.edgeId);
        // Visual: mark edge as considered briefly then mark as MST
        // We'll animate: show considered then after 400ms set inMST true
        edge.considered = true;
        updateGraph();
        setTimeout(()=> {
          edge.inMST = true;
          visited.add(pick.to);
          // after adding node, add newly outgoing edges to frontier
          for (const e of edges) {
            if (!e.considered) {
              if (e.u === pick.to || e.v === pick.to) {
                e.considered = true;
                frontier.push(makeCandidate(e));
              }
            }
          }
          updateGraph();
        }, 450);
      }

      function startPlay() {
        if (autoPlay) return;
        autoPlay = true;
        btnPlay.setAttribute('aria-pressed','true');
        btnPlay.classList.toggle('secondary', false);
        btnPlay.textContent = 'Pause';
        const interval = parseInt(speedInput.value);
        playTimer = setInterval(()=> {
          // stop if finished
          if (isPrimFinished()) {
            stopPlay();
            return;
          }
          stepPrim();
        }, interval);
      }

      function stopPlay() {
        autoPlay = false;
        btnPlay.setAttribute('aria-pressed','false');
        btnPlay.classList.toggle('secondary', true);
        btnPlay.textContent = 'Play';
        if (playTimer) { clearInterval(playTimer); playTimer = null; }
      }

      function togglePlay() {
        if (autoPlay) stopPlay();
        else startPlay();
      }

      function isPrimFinished() {
        // finished if all nodes are visited or no frontier edges and no more edges possible
        if (nodes.length === 0) return true;
        if (visited.size === nodes.length) return true;
        // If frontier empty and no edges connecting visited to unvisited
        const possible = edges.some(e => (visited.has(e.u) && !visited.has(e.v)) || (visited.has(e.v) && !visited.has(e.u)));
        return !possible;
      }

      // Reset algorithm state but keep graph
      function resetAlgorithm() {
        visited.clear();
        frontier = [];
        edges.forEach(e => { e.inMST = false; e.considered = false; });
        startNode = null;
        stopPlay();
        updateGraph();
      }

      // Clear entire graph
      function clearGraph() {
        nodes = [];
        edges = [];
        nodeIdCounter = 0;
        edgeIdCounter = 0;
        visited.clear();
        mstEdges.clear();
        frontier = [];
        startNode = null;
        stopPlay();
        // clear svg contents
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        updateGraph();
      }

      // Random graph generation for demo
      function generateRandomGraph(count=7, density=0.35) {
        clearGraph();
        // place nodes in a loose grid
        for (let i=0;i<count;i++) {
          const x = 100 + (VB_W - 200) * Math.random();
          const y = 80 + (VB_H - 160) * Math.random();
          addNode(x,y, String(i+1));
        }
        // connect edges probabilistically
        for (let i=0;i<nodes.length;i++){
          for (let j=i+1;j<nodes.length;j++){
            if (Math.random() < density || (j===i+1)) {
              const w = 1 + Math.floor(Math.random()*20);
              addEdge(nodes[i], nodes[j], w);
            }
          }
        }
        resetAlgorithm();
      }

      // Attach UI handlers
      btnStep.addEventListener('click', ()=> stepPrim());
      btnPlay.addEventListener('click', ()=> togglePlay());
      btnReset.addEventListener('click', ()=> resetAlgorithm());
      btnClear.addEventListener('click', ()=> clearGraph());
      btnRandomGraph.addEventListener('click', ()=> generateRandomGraph(7,0.28));
      btnSetStart.addEventListener('click', ()=> {
        // if creatingEdgeFrom set start to that node
        if (creatingEdgeFrom) {
          startNode = creatingEdgeFrom;
          creatingEdgeFrom = null;
          highlightTempNode(null);
        } else if (nodes.length>0) {
          // allow click to choose start: pick first node
          startNode = nodes[0];
        }
        resetAlgorithm();
        initPrim();
        updateGraph();
      });
      randWeightBtn.addEventListener('click', ()=> {
        useRandomWeightNext = !useRandomWeightNext;
        randWeightBtn.classList.toggle('secondary', useRandomWeightNext);
      });
      edgeWeightInput.addEventListener('input', ()=> {
        useRandomWeightNext = false;
        randWeightBtn.classList.remove('secondary');
      });
      autoWeightCheckbox.addEventListener('change', (ev)=> {
        useRandomWeightNext = ev.target.checked;
      });
      speedInput.addEventListener('input', ()=> {
        speedValue.textContent = speedInput.value + 'ms';
        if (autoPlay) {
          stopPlay();
          startPlay();
        }
      });

      // Small helper: pulse animation when algorithm finished
      function flashMessage(text) {
        // simple alert-like chrome
        const m = document.createElement('div');
        m.textContent = text;
        m.style.position = 'fixed';
        m.style.left = '50%';
        m.style.top = '24px';
        m.style.transform = 'translateX(-50%)';
        m.style.background = 'rgba(11,110,253,0.95)';
        m.style.color = 'white';
        m.style.padding = '10px 16px';
        m.style.borderRadius = '12px';
        m.style.zIndex = 9999;
        document.body.appendChild(m);
        setTimeout(()=> m.style.opacity = '0', 2000);
        setTimeout(()=> document.body.removeChild(m), 2500);
      }

      // Initialization: add instructions overlay text inside svg, and create sample graph
      function boot() {
        // draw background rect for click capturing
        const bg = svgEl('rect', {x:0,y:0,width:VB_W,height:VB_H, fill:'transparent'});
        svg.appendChild(bg);
        // sample graph
        generateRandomGraph(6,0.32);
      }

      // Start
      boot();
    })();
  </script>
</body>
</html>