<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Breadth-First Search (BFS) Interactive Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-margin: 24px;
      --gap: 16px; /* minimum spacing */
      --panel-width: 320px;
      --node-radius: 22;
      --accent: #2b7cff;
      --muted: #6b7280;
      --bg: #0f1724;
      --card: #0b1220;
      --success: #16a34a;
      --danger: #ef4444;
      --neutral: #111827;
      --glass: rgba(255,255,255,0.03);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg, #071027 0%, #071027 60%, #03101a 100%);
      color: #e6eef8;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      padding: var(--safe-margin);
      box-sizing: border-box;
    }

    /* Layout container */
    .container {
      display: grid;
      grid-template-columns: var(--panel-width) 1fr;
      gap: var(--gap);
      height: calc(100% - calc(var(--safe-margin) * 2));
      min-height: 480px;
    }

    /* Left panel - info / controls */
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-width: 220px;
      max-width: 420px;
    }

    .title {
      font-size: 20px;
      font-weight: 600;
      color: #e6f0ff;
      margin-bottom: 4px;
    }

    .subtitle {
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 8px;
    }

    .panel .section {
      background: rgba(255,255,255,0.01);
      border-radius: 8px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .small {
      font-size: 13px;
      color: #dbeafe;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    button, .toggle {
      background: rgba(255,255,255,0.03);
      color: #e6efff;
      border: 1px solid rgba(255,255,255,0.03);
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      min-height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    button:active { transform: translateY(1px); }
    button[disabled] { opacity: 0.5; cursor: not-allowed; }

    .mode-indicator {
      font-size: 12px;
      color: var(--muted);
    }

    .toggle.active {
      background: linear-gradient(90deg,var(--accent), #7cc0ff);
      color: #01264a;
      border: none;
      box-shadow: 0 4px 14px rgba(43,124,255,0.18);
    }

    .controls .wide {
      width: 100%;
    }

    .hint {
      font-size: 13px;
      color: var(--muted);
      background: rgba(255,255,255,0.01);
      padding: 8px;
      border-radius: 6px;
    }

    /* Right area - canvas and queue visualization */
    .canvas-area {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      min-height: 0;
    }

    .graph-card {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius: 12px;
      padding: 12px;
      height: 100%;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      min-height: 320px;
    }

    .graph-top {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }

    .info-inline {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .legend {
      display:flex;
      gap: 8px;
      align-items:center;
      color: var(--muted);
      font-size: 13px;
    }

    /* SVG stage */
    .stage {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius: 8px;
      flex: 1 1 auto;
      position: relative;
      min-height: 320px;
      overflow: hidden;
      border: 1px dashed rgba(255,255,255,0.03);
    }

    svg {
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
    }

    /* Node & edge styling */
    .edge {
      stroke: rgba(255,255,255,0.12);
      stroke-width: 2;
      pointer-events: stroke;
      transition: stroke 220ms;
    }

    .edge.highlight {
      stroke: rgba(124,200,255,0.96);
      stroke-width: 3.5;
      filter: drop-shadow(0 6px 10px rgba(43,124,255,0.12));
    }

    .node-group {
      cursor: grab;
      touch-action: none;
    }

    .node {
      fill: linear-gradient(180deg,#16324b,#0b2232);
      stroke: rgba(255,255,255,0.06);
      stroke-width: 1;
      transition: r 160ms, fill 220ms, transform 160ms;
    }

    .node-bg {
      fill: #021426;
      stroke: rgba(255,255,255,0.04);
    }

    .label {
      font-size: 13px;
      fill: #e6f0ff;
      pointer-events: none;
      font-weight: 600;
    }

    .sub {
      font-size: 11px;
      fill: rgba(255,255,255,0.8);
      pointer-events: none;
    }

    /* states */
    .node.unvisited circle { fill: #072238; }
    .node.frontier circle { fill: var(--accent); transform: scale(1.08); }
    .node.visited circle { fill: #0ea5a8; transform: scale(1.02); }
    .node.start circle { fill: #10b981; }
    .node.target circle { fill: #ef4444; }
    .node.path circle { fill: #f59e0b; }

    .node text.value { font-size: 11px; fill: #e6eef8; }

    .queue-visual {
      display: flex;
      gap: 8px;
      align-items: center;
      overflow: auto;
      padding: 6px;
      border-radius: 8px;
      background: rgba(255,255,255,0.01);
      border: 1px dashed rgba(255,255,255,0.03);
    }

    .queue-item {
      min-width: 36px;
      height: 36px;
      border-radius: 8px;
      background: rgba(255,255,255,0.03);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #e6f0ff;
      font-weight: 700;
      font-size: 13px;
      padding: 6px;
      border: 1px solid rgba(255,255,255,0.03);
      transition: transform 180ms, background 160ms;
    }

    .queue-item.current {
      background: linear-gradient(90deg,var(--accent),#7cc0ff);
      color: #01264a;
      transform: translateY(-6px);
      box-shadow: 0 8px 24px rgba(43,124,255,0.12);
    }

    /* Footer controls */
    .run-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .status {
      font-size: 13px;
      color: var(--muted);
    }

    /* Responsiveness */
    @media (max-width: 920px) {
      .container {
        grid-template-columns: 1fr;
        grid-auto-rows: auto;
      }
      .panel { order: 2; }
      .canvas-area { order: 1; }
      .panel { max-width: none; width: 100%; }
    }

    /* small helper */
    .kbd {
      background: rgba(255,255,255,0.02);
      padding: 4px 6px;
      border-radius: 6px;
      font-size: 12px;
      color: var(--muted);
      border: 1px solid rgba(255,255,255,0.02);
    }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="BFS interactive module">
    <aside class="panel" aria-labelledby="module-title">
      <div>
        <div id="module-title" class="title">Breadth-First Search (BFS)</div>
        <div class="subtitle">Explore level-order traversal and shortest paths in an unweighted graph</div>
      </div>

      <div class="section" aria-labelledby="learning-objective">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div style="font-weight:600">Learning Objective</div>
          <div style="font-size:12px;color:var(--muted)">Single concept focus</div>
        </div>
        <div id="learning-objective" class="small">
          After interacting you will understand how BFS explores nodes by layers (distance),
          how the queue evolves, and how BFS finds shortest paths in an unweighted graph.
          Use the canvas to create graphs, set a start and target node, and step through BFS.
        </div>
      </div>

      <div class="section" aria-labelledby="interaction-design">
        <div style="font-weight:600">Interaction Design</div>
        <div class="small" id="interaction-design">
          - Click on the stage to add a node.<br>
          - Drag nodes to reposition.<br>
          - Toggle "Connect" mode then click two nodes to add an edge.<br>
          - Click a node and press "Set Start" / "Set Target" to mark them.<br>
          - Use "Step" to execute BFS one action at a time, "Play" to animate.<br>
          Visual feedback: nodes change color when discovered/visited, edges highlight as traversed, and the queue panel animates current/explored elements.
        </div>
      </div>

      <div class="section" aria-labelledby="layout-desc">
        <div style="font-weight:600">Layout Description</div>
        <div id="layout-desc" class="small">
          The module uses a two-column layout: left control panel (320px) and right interactive canvas.
          Safe margins are 24px and 16px spacing between interactive elements. The canvas contains an SVG stage for crisp, animated nodes/edges.
          Controls include accessible buttons, mode toggles, and a queue visualization. The design is responsive and keyboard-friendly.
        </div>
      </div>

      <div class="section">
        <div style="font-weight:600">Controls & Shortcuts</div>
        <div class="small">
          <div style="display:flex;flex-direction:column;gap:6px;">
            <div><span class="kbd">Click stage</span> - add node</div>
            <div><span class="kbd">Drag node</span> - move node</div>
            <div><span class="kbd">Connect mode</span> - create edges by clicking pairs</div>
            <div><span class="kbd">Set Start / Target</span> - mark nodes for BFS</div>
            <div><span class="kbd">Step / Play</span> - advance BFS</div>
          </div>
        </div>
      </div>
    </aside>

    <main class="canvas-area" aria-label="BFS canvas area">
      <div class="graph-card" role="region" aria-label="Graph stage and controls">
        <div class="graph-top">
          <div class="info-inline">
            <div class="legend">
              <div class="mode-indicator"><strong>Mode:</strong></div>
              <div id="modeDisplay" style="font-weight:600;color:var(--muted);">Edit</div>
            </div>
          </div>

          <div style="display:flex;gap:8px;align-items:center;">
            <button id="clearBtn" title="Clear graph" aria-label="Clear graph">Clear</button>
            <button id="undoBtn" title="Undo last" aria-label="Undo last">Undo</button>
            <button id="resetRunBtn" title="Reset run state" aria-label="Reset run">Reset Run</button>
          </div>
        </div>

        <div class="stage" id="stageContainer" aria-label="Drag to move nodes. Click to add nodes.">
          <svg id="svg" role="img" aria-label="Graph drawing area"></svg>
        </div>

        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
          <div style="display:flex;gap:8px;flex-direction:column;">
            <div style="display:flex;gap:8px;align-items:center;" class="controls">
              <button id="addNodeBtn">Add Node</button>
              <button id="connectBtn" class="toggle">Connect</button>
              <button id="directedBtn" class="toggle">Directed</button>
              <button id="setStartBtn">Set Start</button>
              <button id="setTargetBtn">Set Target</button>
            </div>
            <div style="display:flex;gap:8px;align-items:center;" class="controls">
              <button id="stepBtn">Step</button>
              <button id="playBtn" class="toggle">Play</button>
              <button id="fastBtn">Speed x2</button>
            </div>
          </div>

          <div style="display:flex;flex-direction:column;align-items:flex-end;gap:6px;">
            <div class="status" id="statusText">No start node set.</div>
            <div style="font-size:12px;color:var(--muted)">Queue</div>
          </div>
        </div>

        <div style="display:flex;gap:8px;align-items:center;">
          <div class="queue-visual" id="queueVisual" aria-live="polite" aria-atomic="true" style="min-width: 0; flex: 1;"></div>
          <div style="min-width:120px; text-align:right;">
            <div style="font-size:12px;color:var(--muted)">Visited order</div>
            <div id="orderText" style="font-weight:600; font-size:13px; color:#dbeafe; min-width:120px;"></div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    /*
      BFS Interactive Module
      - Single file, vanilla JS
      - Edit mode: add nodes (click), move nodes (drag), connect nodes (toggle), set start/target (buttons)
      - Run mode: step or play BFS; visual queue; edge highlighting; distances and parents tracked
    */

    (function(){
      // Config
      const NODE_RADIUS = 22;
      const SVG_NS = "http://www.w3.org/2000/svg";

      // State
      let nodes = []; // {id, x, y}
      let edges = []; // {id, a, b, directed}
      let nextNodeId = 1;
      let connectMode = false;
      let directedMode = false;
      let connectBuffer = null; // holds first selected node id
      let dragState = null; // {id, offsetX, offsetY}
      let startNode = null;
      let targetNode = null;
      let runState = null; // BFS state

      // Playback
      let playing = false;
      let playInterval = 700;
      let playTimer = null;

      // Elements
      const svg = document.getElementById('svg');
      const stageContainer = document.getElementById('stageContainer');
      const addNodeBtn = document.getElementById('addNodeBtn');
      const connectBtn = document.getElementById('connectBtn');
      const directedBtn = document.getElementById('directedBtn');
      const setStartBtn = document.getElementById('setStartBtn');
      const setTargetBtn = document.getElementById('setTargetBtn');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const fastBtn = document.getElementById('fastBtn');
      const clearBtn = document.getElementById('clearBtn');
      const undoBtn = document.getElementById('undoBtn');
      const resetRunBtn = document.getElementById('resetRunBtn');
      const queueVisual = document.getElementById('queueVisual');
      const statusText = document.getElementById('statusText');
      const orderText = document.getElementById('orderText');
      const modeDisplay = document.getElementById('modeDisplay');

      // Utility
      function createSVG(name, attrs = {}) {
        const el = document.createElementNS(SVG_NS, name);
        for (const k in attrs) el.setAttribute(k, attrs[k]);
        return el;
      }

      function setModeDisplay() {
        modeDisplay.textContent = connectMode ? 'Connect' : 'Edit';
      }

      // Rendering
      function render() {
        // Clear
        while (svg.firstChild) svg.removeChild(svg.firstChild);

        // Draw edges first
        edges.forEach(e => {
          const a = nodes.find(n => n.id === e.a);
          const b = nodes.find(n => n.id === e.b);
          if (!a || !b) return;
          const line = createSVG('line', {
            class: 'edge',
            x1: a.x, y1: a.y, x2: b.x, y2: b.y,
            'data-id': e.id
          });
          svg.appendChild(line);

          if (e.directed) {
            // draw simple arrowhead triangle
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const ang = Math.atan2(dy, dx);
            const arrowLen = 12;
            const arrowWidth = 6;
            const tipX = b.x - Math.cos(ang) * (NODE_RADIUS + 4);
            const tipY = b.y - Math.sin(ang) * (NODE_RADIUS + 4);
            const p1x = tipX - Math.cos(ang - Math.PI/2) * arrowWidth;
            const p1y = tipY - Math.sin(ang - Math.PI/2) * arrowWidth;
            const p2x = tipX - Math.cos(ang + Math.PI/2) * arrowWidth;
            const p2y = tipY - Math.sin(ang + Math.PI/2) * arrowWidth;
            const arrow = createSVG('polygon', {
              points: `${tipX},${tipY} ${p1x},${p1y} ${p2x},${p2y}`,
              fill: 'rgba(255,255,255,0.12)',
              'data-id': e.id
            });
            svg.appendChild(arrow);
          }
        });

        // Draw nodes after
        nodes.forEach(n => {
          const g = createSVG('g',{ class:'node-group', transform:`translate(${n.x},${n.y})`, 'data-id': n.id });
          // Node circle
          const circle = createSVG('circle', { r: NODE_RADIUS, class: 'node-bg' });
          // Outer wrapper for state classes
          const wrapper = createSVG('g', { class: 'node' });
          wrapper.appendChild(circle);
          g.appendChild(wrapper);

          // Label: id
          const label = createSVG('text', { x: 0, y: 5, 'text-anchor': 'middle', class: 'label' });
          label.textContent = n.id;
          g.appendChild(label);

          // Sub label: distance if runState available
          if (runState && runState.dist.has(n.id)) {
            const d = runState.dist.get(n.id);
            const sub = createSVG('text', { x: 0, y: 36, 'text-anchor': 'middle', class: 'sub' });
            sub.textContent = d === Infinity ? '∞' : d;
            g.appendChild(sub);
          }

          // Add classes
          let nodeClass = 'unvisited';
          if (startNode === n.id) nodeClass = 'start';
          if (targetNode === n.id) nodeClass = 'target';
          if (runState) {
            if (runState.foundPath && runState.pathSet && runState.pathSet.has(n.id)) nodeClass = 'path';
            else if (runState.visited.has(n.id)) nodeClass = 'visited';
            else if (runState.inQueue.has(n.id)) nodeClass = 'frontier';
            else if (nodeClass === 'start' || nodeClass === 'target') {}
            else nodeClass = 'unvisited';
          }

          g.classList.add(nodeClass + '-group');
          wrapper.classList.add(nodeClass);

          svg.appendChild(g);
        });

        // Attach events to nodes (after drawn)
        attachNodeEvents();
        // Update edge classes for highlighting
        updateEdgeHighlights();
        // Update status
        updateStatus();
        // Update queue visual and visited order
        renderQueue();
        renderOrder();
      }

      function attachNodeEvents() {
        const groups = svg.querySelectorAll('.node-group');
        groups.forEach(g => {
          g.onpointerdown = onNodePointerDown;
          g.onpointerup = onNodePointerUp;
          g.onpointermove = null; // will be handled globally during drag
          g.ondblclick = onNodeDblClick;
          g.tabIndex = 0;
          g.setAttribute('role','button');
          g.setAttribute('aria-label','Node ' + g.getAttribute('data-id'));
        });
      }

      // Event handlers
      function getMousePos(evt) {
        const rect = svg.getBoundingClientRect();
        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
      }

      // Stage click: add node
      svg.addEventListener('click', (e) => {
        // If clicked on node, ignore (handled separately)
        if (e.target.closest('.node-group')) return;
        const pos = getMousePos(e);
        addNode(pos.x, pos.y);
      });

      function addNode(x, y) {
        const id = String(nextNodeId++);
        nodes.push({ id, x, y });
        pushHistory({ type: 'addNode', id });
        render();
      }

      // Undo/History (simple)
      const history = [];
      function pushHistory(entry) {
        history.push(entry);
        if (history.length > 100) history.shift();
      }

      function undoLast() {
        const entry = history.pop();
        if (!entry) return;
        if (entry.type === 'addNode') {
          const idx = nodes.findIndex(n => n.id === entry.id);
          if (idx >= 0) {
            // remove edges connected
            edges = edges.filter(e => e.a !== entry.id && e.b !== entry.id);
            nodes.splice(idx,1);
            if (startNode === entry.id) startNode = null;
            if (targetNode === entry.id) targetNode = null;
          }
        } else if (entry.type === 'addEdge') {
          edges = edges.filter(e => e.id !== entry.id);
        }
        render();
      }

      undoBtn.onclick = () => {
        undoLast();
      };

      clearBtn.onclick = () => {
        nodes = [];
        edges = [];
        nextNodeId = 1;
        startNode = null;
        targetNode = null;
        runState = null;
        history.length = 0;
        stopPlay();
        render();
      };

      // Node pointer drag
      function onNodePointerDown(evt) {
        evt.stopPropagation();
        const g = evt.currentTarget;
        const id = g.getAttribute('data-id');
        const pos = getMousePos(evt);
        const node = nodes.find(n => n.id === id);
        if (!node) return;

        // For connect mode: handle selection
        if (connectMode && !evt.shiftKey) {
          if (!connectBuffer) {
            connectBuffer = id;
            g.classList.add('selected');
            modeDisplay.textContent = 'Connect: selected ' + id;
            return;
          } else {
            if (connectBuffer !== id) {
              addEdge(connectBuffer, id, directedMode);
              // clear
              const prev = svg.querySelector('.node-group.selected');
              if (prev) prev.classList.remove('selected');
              connectBuffer = null;
              modeDisplay.textContent = 'Connect';
              render();
            }
            return;
          }
        }

        // Normal drag
        dragState = { id, offsetX: pos.x - node.x, offsetY: pos.y - node.y };
        g.setPointerCapture(evt.pointerId);
        g.style.cursor = 'grabbing';

        // If in set start/target mode: handled by button toggles
      }

      function onNodePointerUp(evt) {
        const g = evt.currentTarget;
        if (dragState) {
          g.releasePointerCapture(evt.pointerId);
          g.style.cursor = 'grab';
          dragState = null;
        } else {
          // Clicked node - used for setting start/target if their modes active
          // (Handled by dedicated buttons - they set a one-time pending action)
        }
      }

      // For drag, listen globally to pointermove
      svg.addEventListener('pointermove', (evt) => {
        if (!dragState) return;
        const pos = getMousePos(evt);
        const node = nodes.find(n => n.id === dragState.id);
        if (!node) return;
        node.x = pos.x - dragState.offsetX;
        node.y = pos.y - dragState.offsetY;
        // clamp to box
        const rect = svg.getBoundingClientRect();
        node.x = Math.max(NODE_RADIUS + 4, Math.min(rect.width - NODE_RADIUS - 4, node.x));
        node.y = Math.max(NODE_RADIUS + 4, Math.min(rect.height - NODE_RADIUS - 4, node.y));
        render();
      });

      // Double click to quick set start or target (optional)
      function onNodeDblClick(evt) {
        const g = evt.currentTarget;
        const id = g.getAttribute('data-id');
        // Double click sets start by default
        startNode = id;
        runState = null;
        render();
      }

      // Edges
      function addEdge(a, b, directed=false) {
        const id = 'e' + (edges.length + 1) + '_' + Date.now();
        edges.push({ id, a, b, directed });
        pushHistory({ type: 'addEdge', id });
        render();
      }

      // Controls wiring
      connectBtn.onclick = () => {
        connectMode = !connectMode;
        connectBtn.classList.toggle('active', connectMode);
        if (!connectMode) {
          connectBuffer = null;
          const prev = svg.querySelector('.node-group.selected');
          if (prev) prev.classList.remove('selected');
        }
        setModeDisplay();
      };

      directedBtn.onclick = () => {
        directedMode = !directedMode;
        directedBtn.classList.toggle('active', directedMode);
      };

      addNodeBtn.onclick = () => {
        // add node near center
        const rect = svg.getBoundingClientRect();
        addNode(rect.width / 2, rect.height / 2);
      };

      // Set Start / Target modes (single click to pick)
      let pendingSet = null; // 'start' | 'target'
      setStartBtn.onclick = () => {
        enterPendingSet('start');
      };
      setTargetBtn.onclick = () => {
        enterPendingSet('target');
      };

      function enterPendingSet(type) {
        pendingSet = type;
        statusText.textContent = 'Click a node to set ' + type + '.';
        // Temporarily attach a one-time click handler on SVG nodes
        const handler = (e) => {
          const g = e.currentTarget;
          const id = g.getAttribute('data-id');
          if (type === 'start') startNode = id;
          else targetNode = id;
          pendingSet = null;
          svg.querySelectorAll('.node-group').forEach(n => n.removeEventListener('click', handler));
          runState = null;
          render();
        };
        svg.querySelectorAll('.node-group').forEach(n => n.addEventListener('click', handler));
      }

      // BFS implementation (unweighted)
      function prepareBFS() {
        if (!startNode) {
          alert('Set a start node before running BFS.');
          return null;
        }
        // adjacency list
        const adj = new Map();
        nodes.forEach(n => adj.set(n.id, []));
        edges.forEach(e => {
          adj.get(e.a).push(e.b);
          if (!e.directed) adj.get(e.b).push(e.a);
        });

        const visited = new Set();
        const inQueue = new Set();
        const dist = new Map();
        const parent = new Map();
        nodes.forEach(n => dist.set(n.id, Infinity));

        const q = [];
        q.push(startNode);
        inQueue.add(startNode);
        dist.set(startNode, 0);
        parent.set(startNode, null);

        return { adj, visited, inQueue, dist, parent, q, step: 0, current: null, foundPath: false, pathSet: null, finished: false };
      }

      // Step BFS: returns {done, message}
      function bfsStep(state) {
        if (!state) return {done:true};
        if (state.finished) return {done:true};
        // If queue empty, finish
        if (state.q.length === 0) {
          state.finished = true;
          return {done:true};
        }
        // Pop front
        const u = state.q.shift();
        state.inQueue.delete(u);
        state.current = u;
        // Explore u
        state.visited.add(u);
        // If target check
        if (targetNode && u === targetNode) {
          // found; reconstruct path
          const path = new Set();
          let cur = u;
          while (cur) {
            path.add(cur);
            cur = state.parent.get(cur);
          }
          state.foundPath = true;
          state.pathSet = path;
          state.finished = true;
          return {done:true, found:true};
        }

        // enqueue neighbors
        const neighbors = state.adj.get(u) || [];
        for (const v of neighbors) {
          if (!state.visited.has(v) && !state.inQueue.has(v)) {
            state.q.push(v);
            state.inQueue.add(v);
            state.parent.set(v, u);
            state.dist.set(v, state.dist.get(u) + 1);
            // Each neighbor addition is considered a mini-step for visualization
            return {done:false, added: v, current: u};
          }
        }

        // If no neighbors added, continue next node
        return {done:false, progressed:true};
      }

      // Run control handlers
      stepBtn.onclick = () => {
        if (!runState) runState = prepareBFS();
        const res = bfsStep(runState);
        if (res) {
          if (res.found) {
            // highlight path
          }
        }
        render();
        if (runState && runState.finished) {
          statusText.textContent = 'BFS complete.' + (runState.foundPath ? ' Path found.' : '');
        }
      };

      playBtn.onclick = () => {
        if (playing) stopPlay();
        else startPlay();
      };

      function startPlay() {
        if (!runState) runState = prepareBFS();
        playing = true;
        playBtn.classList.add('active');
        stepPlay();
      }

      function stepPlay() {
        if (!playing) return;
        const res = bfsStep(runState);
        render();
        if (runState.finished) {
          stopPlay();
          statusText.textContent = 'BFS complete.' + (runState.foundPath ? ' Path found.' : '');
          return;
        }
        playTimer = setTimeout(stepPlay, playInterval);
      }

      function stopPlay() {
        playing = false;
        playBtn.classList.remove('active');
        if (playTimer) { clearTimeout(playTimer); playTimer = null; }
      }

      fastBtn.onclick = () => {
        playInterval = playInterval === 700 ? 300 : 700;
        fastBtn.textContent = playInterval === 700 ? 'Speed x2' : 'Speed x1';
      };

      resetRunBtn.onclick = () => {
        runState = null;
        stopPlay();
        render();
      };

      // Helper: update edge highlights based on runState parents or traversed edges
      function updateEdgeHighlights() {
        // First clear
        svg.querySelectorAll('.edge, polygon').forEach(el => el.classList.remove('highlight'));
        if (!runState) return;
        // highlight edges used in parent pointers for path (if found) or recently traversed
        if (runState.foundPath && runState.pathSet) {
          // highlight every parent->child in path
          for (const v of runState.pathSet) {
            const p = runState.parent.get(v);
            if (!p) continue;
            const e = findEdgeBetween(p, v, true);
            if (e) highlightEdge(e.id);
          }
        } else {
          // highlight parent pointers for visited nodes
          runState.visited.forEach(v => {
            const p = runState.parent.get(v);
            if (!p) return;
            const e = findEdgeBetween(p, v, true);
            if (e) highlightEdge(e.id);
          });
        }
      }

      function highlightEdge(id) {
        svg.querySelectorAll('[data-id="'+id+'"]').forEach(el => {
          el.classList.add('highlight');
        });
      }

      function findEdgeBetween(a,b, respectDirected=false) {
        for (const e of edges) {
          if (e.a === a && e.b === b) return e;
          if (!respectDirected && !e.directed && e.a === b && e.b === a) return e;
        }
        return null;
      }

      // Queue visual
      function renderQueue() {
        queueVisual.innerHTML = '';
        if (!runState) return;
        const q = runState.q;
        q.forEach((id, idx) => {
          const div = document.createElement('div');
          div.className = 'queue-item' + (idx === 0 ? ' current' : '');
          div.textContent = id;
          queueVisual.appendChild(div);
        });
      }

      function renderOrder() {
        if (!runState) {
          orderText.textContent = '';
          return;
        }
        const arr = Array.from(runState.visited);
        orderText.textContent = arr.join(', ');
      }

      function updateStatus() {
        if (!startNode) {
          statusText.textContent = 'No start node set.';
          return;
        }
        if (!runState) {
          statusText.textContent = 'Ready. Start: ' + startNode + (targetNode ? ' • Target: ' + targetNode : '');
        } else {
          statusText.textContent = 'Running. Current: ' + (runState.current || '-') + ' • Queue: ' + runState.q.length;
        }
      }

      // Keyboard accessibility: space to step, p to play
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') { e.preventDefault(); stepBtn.click(); }
        if (e.key === 'p' || e.key === 'P') { playBtn.click(); }
      });

      // Initial render
      render();

      // Expose some helper methods via console for testing (optional)
      window.BFSInteractive = {
        addNode(x,y){ addNode(x,y); },
        addEdge(a,b,d=false){ addEdge(a,b,d); },
        nodes, edges
      };
    })();
  </script>
</body>
</html>