<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Radix Sort — Interactive Module</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #38bdf8;
      --accent-2: #7c3aed;
      --muted: #98a3b8;
      --surface: #0b1220;
      --success: #16a34a;
      --danger: #ef4444;
      --white: #e6eef8;
      --transition: 400ms cubic-bezier(.2,.9,.3,1);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    /* Page safe margins */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071023 0%, #07121a 100%);
      color:var(--white);
      padding:var(--safe-padding);
      box-sizing:border-box;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .container{
      max-width:1100px;
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:var(--gap);
    }
    .title-group{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    h1{
      margin:0;
      font-size:1.4rem;
      letter-spacing: -0.02em;
      color:var(--white);
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:0.95rem;
    }

    main{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      flex-wrap:wrap;
    }

    /* Controls column */
    .controls{
      min-width:280px;
      max-width:360px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      padding:16px;
      border-radius:12px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:16px;
      box-sizing:border-box;
    }
    .controls label{ font-size:0.85rem; color:var(--muted); display:block; margin-bottom:6px;}
    input[type="text"], select{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--white);
      padding:10px 12px;
      border-radius:8px;
      width:100%;
      box-sizing:border-box;
      outline:none;
    }
    .row{ display:flex; gap:12px; align-items:center; }
    .row > * { flex:1; }
    button{
      background:linear-gradient(90deg,var(--accent),var(--accent-2));
      border:none;
      color:#04202a;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      transition:transform var(--transition), opacity 180ms;
    }
    button.secondary{
      background:transparent;
      color:var(--white);
      border:1px solid rgba(255,255,255,0.06);
      font-weight:600;
    }
    button:active{ transform:translateY(1px) }
    .small{ padding:8px 10px; font-size:0.95rem; }

    .control-group{
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    /* Visualization area */
    .vis{
      flex:1 1 620px;
      min-height:360px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.0));
      border-radius:12px;
      padding:16px;
      border:1px solid rgba(255,255,255,0.03);
      box-shadow: 0 8px 30px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
      box-sizing:border-box;
    }

    .meta-bar{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }
    .meta-left{ display:flex; gap:10px; align-items:center; }
    .badge{
      background:rgba(255,255,255,0.03);
      color:var(--muted);
      padding:6px 10px;
      border-radius:999px;
      font-size:0.86rem;
    }

    .visualization-area{
      position:relative;
      flex:1;
      border-radius:8px;
      background:linear-gradient(180deg, rgba(11,17,32,0.5), rgba(7,10,18,0.5));
      padding:16px;
      overflow:hidden;
    }

    /* array slots */
    .array-row{
      display:flex;
      gap:12px;
      justify-content:center;
      align-items:flex-start;
      margin-bottom:16px;
    }
    .slot{
      width:56px;
      height:56px;
      border-radius:10px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px dashed rgba(255,255,255,0.03);
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--white);
      font-weight:700;
      position:relative;
      box-sizing:border-box;
      user-select:none;
    }
    .slot.empty{
      color:var(--muted);
      font-weight:600;
      font-size:0.85rem;
    }

    /* moving items (absolute) */
    .item{
      position:absolute;
      width:56px;
      height:56px;
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:800;
      color:#04202a;
      background:linear-gradient(180deg,#fff 0%, #f3f4f6 100%);
      box-shadow:0 10px 30px rgba(6,11,26,0.5);
      transition: transform var(--transition), box-shadow var(--transition);
      z-index:10;
      cursor:grab;
    }
    .item:active{ cursor:grabbing; transform:scale(0.98); }

    /* buckets */
    .buckets{
      display:flex;
      gap:12px;
      justify-content:center;
      margin-top:8px;
      flex-wrap:nowrap;
      overflow-x:auto;
      padding-bottom:4px;
    }
    .bucket{
      min-width:68px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border:1px solid rgba(255,255,255,0.02);
      border-radius:10px;
      padding:8px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:center;
    }
    .bucket .label{
      font-size:0.85rem;
      color:var(--muted);
      background:transparent;
    }
    .bucket .stack{
      min-height:40px;
      width:100%;
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:center;
      justify-content:flex-start;
    }

    .controls-footer{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:flex-end;
    }

    .info{
      margin-top:6px;
      color:var(--muted);
      font-size:0.9rem;
    }

    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:10px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.02);
      color:var(--muted);
      font-size:0.9rem;
    }

    /* responsive */
    @media (max-width:900px){
      main{ flex-direction:column; }
      .controls{ width:100%; max-width:none; }
    }

    /* Small helpers */
    .muted{ color:var(--muted); font-size:0.9rem; }
    .status{
      font-size:0.95rem;
      color:var(--muted);
    }
    .highlight{
      color:var(--accent);
      font-weight:700;
    }
    /* accessibility focus */
    button:focus, input:focus, select:focus { outline:2px solid rgba(56,189,248,0.18); outline-offset:2px; }

    /* keyboard hint */
    .kbd {
      display:inline-block;
      padding:2px 8px;
      border-radius:6px;
      background:rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.02);
      color:var(--muted);
      font-size:0.85rem;
    }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Radix Sort Interactive Module">
    <header>
      <div class="title-group">
        <h1>Radix Sort — Visual, Step-by-Step (LSD, base 10)</h1>
        <p class="lead">Interactive demonstration showing how Least Significant Digit (LSD) Radix Sort distributes numbers into buckets per digit and collects them back until sorted.</p>
      </div>
      <div style="min-width:220px; text-align:right;">
        <div class="badge">Concept: Radix Sort (LSD)</div>
        <div class="muted" style="margin-top:8px; font-size:0.9rem;">Elements: limited to 12 for clarity • Accessible controls • Animations</div>
      </div>
    </header>

    <main>
      <aside class="controls" aria-label="Controls">
        <div class="control-group">
          <label for="inputArray">Initial array (comma separated integers, ≥0)</label>
          <input id="inputArray" type="text" aria-label="Array input" value="170,45,75,90,802,24,2,66">
          <div class="info">Tip: press <span class="kbd">Enter</span> after editing to load the array.</div>
        </div>

        <div class="row">
          <div>
            <label for="maxDigits">Max digits (optional)</label>
            <input id="maxDigits" type="text" aria-label="Maximum digits" placeholder="Auto (computed from values)">
          </div>
          <div style="min-width:90px;">
            <label for="base">Base (radix)</label>
            <select id="base" aria-label="Radix base">
              <option value="10">10 (decimal)</option>
              <option value="2">2 (binary)</option>
              <option value="16">16 (hex)</option>
            </select>
          </div>
        </div>

        <div class="row">
          <button id="randomBtn" class="secondary small" title="Randomize array">Randomize</button>
          <button id="loadBtn" class="small" title="Load array from input">Load</button>
        </div>

        <div class="control-group">
          <label>Playback</label>
          <div class="row">
            <button id="playBtn" class="small" title="Play automatically">Play</button>
            <button id="stepBtn" class="secondary small" title="Advance one step">Step</button>
            <button id="resetBtn" class="secondary small" title="Reset to initial">Reset</button>
          </div>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
            <label class="muted" style="min-width:70px;">Speed</label>
            <input id="speed" type="range" min="200" max="1400" step="50" value="600" aria-label="Animation speed">
            <div style="width:44px;text-align:right;color:var(--muted);font-size:0.9rem;" id="speedLabel">600ms</div>
          </div>
        </div>

        <div class="panel" id="docPanel" aria-hidden="false">
          <strong>Concept Title</strong>
          <div class="muted" style="margin-top:6px;">Radix Sort (Least Significant Digit)</div>

          <div style="margin-top:12px;">
            <strong>Learning Objective</strong>
            <div class="muted" style="margin-top:6px;">
              After interacting, you'll be able to explain how LSD Radix Sort repeatedly distributes numbers into digit buckets (0–base-1),
              collects them in order, and repeats for more significant digits until the list is sorted.
            </div>
          </div>

          <div style="margin-top:12px;">
            <strong>Interaction Design</strong>
            <div class="muted" style="margin-top:6px;">
              - Edit the array or randomize it, then Load.<br>
              - Use Step to perform the next action (distribute one element or collect one bucket).<br>
              - Play performs full passes automatically with adjustable speed.<br>
              - Visual items animate to buckets and back to array slots to reinforce the distribution and collection phases.<br>
              - Live status text and color highlights identify the active digit and pass.
            </div>
          </div>

          <div style="margin-top:12px;">
            <strong>Layout Description</strong>
            <div class="muted" style="margin-top:6px;">
              The interface uses a left control panel and a right visualization area. Safe padding is 24px. Controls and visual elements keep at least
              16px gaps for clarity. The visualization shows the main array at top and buckets below; controls remain accessible and responsive.
            </div>
          </div>
        </div>

        <div class="controls-footer" style="margin-top:8px;">
          <div class="muted" style="flex:1">Status: <span id="statusText" class="highlight">Idle</span></div>
          <div style="min-width:160px; text-align:right;">
            <div class="muted" style="font-size:0.85rem;">Keyboard: <span class="kbd">Space</span> Play/Pause • <span class="kbd">S</span> Step</div>
          </div>
        </div>
      </aside>

      <section class="vis" aria-label="Visualization">
        <div class="meta-bar">
          <div class="meta-left">
            <div class="badge">Pass <span id="passNum">0</span></div>
            <div class="badge">Digit: <span id="digitPos">-</span></div>
            <div class="badge">Base: <span id="baseBadge">10</span></div>
          </div>
          <div style="text-align:right;">
            <div class="muted" id="explainLine">Load an array and press Play or Step to begin.</div>
          </div>
        </div>

        <div class="visualization-area" id="viz" aria-live="polite">
          <div id="arrayRow" class="array-row" aria-label="Main array slots"></div>
          <div id="bucketsRow" class="buckets" aria-label="Buckets"></div>
        </div>
      </section>
    </main>

    <footer style="margin-top:6px;">
      <div style="color:var(--muted); font-size:0.9rem;">
        Note: This module implements Least Significant Digit (LSD) Radix Sort. It supports different bases to show how buckets change. All animations are client-side and accessible.
      </div>
    </footer>
  </div>

  <script>
    // Radix Sort Visualizer (LSD)
    (function(){
      // DOM references
      const input = document.getElementById('inputArray');
      const loadBtn = document.getElementById('loadBtn');
      const randomBtn = document.getElementById('randomBtn');
      const playBtn = document.getElementById('playBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');
      const speedRange = document.getElementById('speed');
      const speedLabel = document.getElementById('speedLabel');
      const baseSelect = document.getElementById('base');
      const maxDigitsInput = document.getElementById('maxDigits');

      const passNumEl = document.getElementById('passNum');
      const digitPosEl = document.getElementById('digitPos');
      const baseBadge = document.getElementById('baseBadge');
      const explainLine = document.getElementById('explainLine');
      const statusText = document.getElementById('statusText');

      const viz = document.getElementById('viz');
      const arrayRow = document.getElementById('arrayRow');
      const bucketsRow = document.getElementById('bucketsRow');

      // State
      let initialArray = [];
      let items = []; // objects {id, value, el}
      let base = parseInt(baseSelect.value,10);
      let maxDigits = null;
      let pass = 0;
      let playing = false;
      let speed = parseInt(speedRange.value,10);
      let animationDuration = speed;
      let currentPhase = 'idle'; // 'distribute' | 'collect' | 'idle'
      let stopRequested = false;

      // Config
      const maxElements = 12;
      const itemSize = 56;
      const gap = 12;

      // Utility
      function parseArrayInput(str){
        if(!str.trim()) return [];
        const arr = str.split(',').map(s=>s.trim()).filter(s=>s!=='').map(s=>Number(s));
        if(arr.some(v=>Number.isNaN(v) || v<0 || !Number.isFinite(v))) return null;
        if(arr.length === 0) return [];
        if(arr.length > maxElements) return arr.slice(0,maxElements);
        return arr;
      }

      function setStatus(text){
        statusText.textContent = text;
      }

      // Create DOM items for array
      function renderInitialArray(arr){
        // clear
        arrayRow.innerHTML = '';
        bucketsRow.innerHTML = '';

        items = arr.map((v,i) => {
          const slot = document.createElement('div');
          slot.className = 'slot';
          slot.setAttribute('data-index', i);
          slot.textContent = v;
          arrayRow.appendChild(slot);

          const el = document.createElement('div');
          el.className = 'item';
          el.textContent = v;
          el.setAttribute('data-id', i);
          el.setAttribute('role', 'button');
          el.tabIndex = 0;

          // initial position: will be positioned absolutely later
          viz.appendChild(el);

          return { id: i, value: v, el: el, homeIndex: i, inBucket: null };
        });

        // make buckets container for base
        for(let b=0;b<base;b++){
          const bucket = document.createElement('div');
          bucket.className = 'bucket';
          bucket.setAttribute('data-bucket', b);
          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = b;
          const stack = document.createElement('div');
          stack.className = 'stack';
          bucket.appendChild(label);
          bucket.appendChild(stack);
          bucketsRow.appendChild(bucket);
        }

        // position items absolutely over their slots
        placeItemsAtSlots();
      }

      function placeItemsAtSlots(){
        // compute slot centers relative to viz
        const vizRect = viz.getBoundingClientRect();
        const slots = Array.from(arrayRow.children);
        slots.forEach((slot, idx) => {
          const slotRect = slot.getBoundingClientRect();
          const centerX = slotRect.left - vizRect.left + slotRect.width/2;
          const centerY = slotRect.top - vizRect.top + slotRect.height/2;
          const itm = items[idx];
          if(!itm) return;
          itm.el.style.transition = 'none';
          itm.el.style.transform = `translate(${centerX - itemSize/2}px, ${centerY - itemSize/2}px)`;
          // small delay to ensure transition will apply next time
          requestAnimationFrame(()=> { itm.el.style.transition = `transform ${animationDuration}ms cubic-bezier(.2,.9,.3,1)`; });
          itm.homeX = centerX - itemSize/2;
          itm.homeY = centerY - itemSize/2;
          itm.inBucket = null;
        });
      }

      // compute target positions for bucket stacking
      function getBucketPosition(bucketIndex, stackIndex){
        const vizRect = viz.getBoundingClientRect();
        const bucketEl = bucketsRow.querySelector(`[data-bucket="${bucketIndex}"]`);
        const stackEl = bucketEl.querySelector('.stack');
        const bucketRect = bucketEl.getBoundingClientRect();
        const stackRect = stackEl.getBoundingClientRect();
        const x = bucketRect.left - vizRect.left + (bucketRect.width - itemSize)/2;
        const y = stackRect.top - vizRect.top + stackIndex*(itemSize + 6); // stack downwards
        return {x,y};
      }

      // animate moving an item to a bucket
      function animateToBucket(itemObj, bucketIndex, stackIndex){
        return new Promise(resolve=>{
          const pos = getBucketPosition(bucketIndex, stackIndex);
          itemObj.inBucket = bucketIndex;
          itemObj.el.style.zIndex = 100 + stackIndex;
          // set transform
          requestAnimationFrame(()=>{
            itemObj.el.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
          });
          setTimeout(()=>{ resolve(); }, animationDuration + 20);
        });
      }

      // animate moving an item back to array slot at position idx
      function animateToArrayPosition(itemObj, targetIndex){
        return new Promise(resolve=>{
          // compute target slot position
          const slot = arrayRow.children[targetIndex];
          const vizRect = viz.getBoundingClientRect();
          const slotRect = slot.getBoundingClientRect();
          const x = slotRect.left - vizRect.left + (slotRect.width - itemSize)/2;
          const y = slotRect.top - vizRect.top + (slotRect.height - itemSize)/2;
          itemObj.inBucket = null;
          itemObj.el.style.zIndex = 50 + targetIndex;
          requestAnimationFrame(()=>{
            itemObj.el.style.transform = `translate(${x}px, ${y}px)`;
          });
          setTimeout(()=>{ resolve(); }, animationDuration + 20);
        });
      }

      // helper to clear bucket stacks DOM (for accessibility)
      function updateBucketStacksDOM(bucketStacks){
        // bucketStacks is array of arrays of itemObjs per bucket
        const buckets = Array.from(bucketsRow.children);
        buckets.forEach((bucketEl, b)=>{
          const stackEl = bucketEl.querySelector('.stack');
          stackEl.innerHTML = '';
          const arr = bucketStacks[b] || [];
          arr.forEach(it=> {
            const mini = document.createElement('div');
            mini.className = 'slot empty';
            mini.style.width='100%';
            mini.style.height='28px';
            mini.style.border='none';
            mini.style.background='transparent';
            mini.style.color='var(--muted)';
            mini.style.fontWeight='600';
            mini.style.fontSize='0.9rem';
            mini.textContent = it.value;
            stackEl.appendChild(mini);
          });
        });
      }

      // Main algorithmic animation: perform one pass (distribute then collect)
      async function performPass(passIndex){
        currentPhase = 'distribute';
        pass = passIndex;
        passNumEl.textContent = passIndex + 1;
        digitPosEl.textContent = passIndex;

        setStatus(`Distributing by digit ${passIndex}`);
        explainLine.textContent = `Distribute each element to the bucket for digit position ${passIndex}.`;

        // prepare buckets arrays
        let bucketStacks = Array.from({length: base}, ()=>[]);

        // distribute items in current order (items array reflects current order)
        for(let i=0;i<items.length;i++){
          if(stopRequested) throw new Error('stopped');
          const itm = items[i];
          const digit = getDigit(itm.value, passIndex, base);
          // animate moving to bucket digit
          const stackIndex = bucketStacks[digit].length;
          bucketStacks[digit].push(itm);
          updateBucketStacksDOM(bucketStacks);
          await animateToBucket(itm, digit, stackIndex);
        }

        // short pause
        await wait(200);

        // collect phase: create new array order by concatenating buckets 0..base-1
        currentPhase = 'collect';
        setStatus(`Collecting buckets`);
        explainLine.textContent = `Collect buckets in order 0 → ${base-1} to form the new array order.`;
        const newOrder = [];
        for(let b=0;b<base;b++){
          const stack = bucketStacks[b];
          for(let s=0;s<stack.length;s++){
            if(stopRequested) throw new Error('stopped');
            const itm = stack[s];
            // target index = newOrder.length
            await animateToArrayPosition(itm, newOrder.length);
            newOrder.push(itm);
          }
        }

        // update items array and their homeIndices
        items = newOrder;
        items.forEach((it, idx)=> it.homeIndex = idx );

        // ensure DOM slot text reflect new values
        arrayRow.innerHTML = '';
        items.forEach((it,idx)=>{
          const slot = document.createElement('div');
          slot.className = 'slot';
          slot.setAttribute('data-index', idx);
          slot.textContent = it.value;
          arrayRow.appendChild(slot);
        });

        // reposition items over new slots (they are already animated above,
        // but ensure their stored home coords update)
        placeItemsAtSlots();

        updateBucketStacksDOM([]); // clear stacks

        setStatus(`Completed pass ${passIndex+1}`);
        explainLine.textContent = `Pass ${passIndex+1} complete.`;
        currentPhase = 'idle';
        await wait(220);
      }

      // Utility wait
      function wait(ms){ return new Promise(resolve=> setTimeout(resolve, ms)); }

      function getDigit(value, pos, base){
        return Math.floor(value / Math.pow(base, pos)) % base;
      }

      // Compute max digits
      function computeMaxDigits(arr){
        if(!arr.length) return 0;
        let max = Math.max(...arr);
        let digits = 0;
        while(max>0){ digits++; max = Math.floor(max/base); }
        return Math.max(1,digits);
      }

      // public controls
      function loadFromInput(){
        const parsed = parseArrayInput(input.value);
        if(parsed === null){
          alert('Invalid input. Provide comma-separated non-negative integers.');
          return;
        }
        if(parsed.length === 0){
          alert('Provide at least one number.');
          return;
        }
        initialArray = parsed.slice(0, maxElements);
        // update UI
        base = parseInt(baseSelect.value,10);
        baseBadge.textContent = base;
        const md = parseInt(maxDigitsInput.value,10);
        maxDigits = Number.isFinite(md) && md>0 ? md : null;
        // compute auto max digits if needed
        if(!maxDigits) maxDigits = computeMaxDigits(initialArray);
        pass = 0;
        playing = false;
        stopRequested = false;
        playBtn.textContent = 'Play';
        statusText.textContent = 'Loaded';
        renderInitialArray(initialArray);
        setTimeout(()=>{ placeItemsAtSlots(); }, 40);
      }

      function randomize(){
        const len = Math.floor(Math.random()* (maxElements-3))+4; // 4..maxElements
        const maxVal = 999;
        const arr = Array.from({length:len}, ()=> Math.floor(Math.random()* (maxVal+1)));
        input.value = arr.join(', ');
        loadFromInput();
      }

      async function playAll(){
        if(items.length===0) return;
        playing = true;
        stopRequested = false;
        playBtn.textContent = 'Pause';
        setStatus('Playing');
        // recompute maxDigits
        maxDigits = parseInt(maxDigitsInput.value,10);
        if(!Number.isFinite(maxDigits) || maxDigits<=0) maxDigits = computeMaxDigits(items.map(it=>it.value));
        try{
          for(let p=0;p<maxDigits;p++){
            if(stopRequested) break;
            await performPass(p);
            // after each pass, check if sorted early
            const values = items.map(it=>it.value);
            if(isSorted(values)){
              setStatus('Array sorted early');
              explainLine.textContent = 'Array is sorted. Stopping early.';
              break;
            }
          }
        }catch(e){
          // stopped
        }
        playing = false;
        stopRequested = false;
        playBtn.textContent = 'Play';
      }

      function isSorted(arr){
        for(let i=1;i<arr.length;i++){
          if(arr[i-1] > arr[i]) return false;
        }
        return true;
      }

      // Step-wise execution: perform one atomic action (we choose to step per full pass for clarity)
      let stepInProgress = false;
      async function stepOnce(){
        if(stepInProgress) return;
        if(items.length===0) return;
        stepInProgress = true;
        try{
          const currentPass = pass;
          maxDigits = parseInt(maxDigitsInput.value,10);
          if(!Number.isFinite(maxDigits) || maxDigits<=0) maxDigits = computeMaxDigits(items.map(it=>it.value));
          if(currentPass >= maxDigits){
            setStatus('All passes complete');
            explainLine.textContent = 'Finished all required passes.';
            stepInProgress = false;
            return;
          }
          await performPass(currentPass);
          pass = currentPass+1;
        }catch(e){
          // canceled
        } finally{
          stepInProgress = false;
        }
      }

      // Reset to initial
      function reset(){
        playing = false;
        stopRequested = true;
        playBtn.textContent = 'Play';
        setStatus('Reset');
        input.value = initialArray.join(', ');
        loadFromInput();
      }

      // Event listeners
      loadBtn.addEventListener('click', ()=> {
        loadFromInput();
      });

      randomBtn.addEventListener('click', ()=> {
        randomize();
      });

      playBtn.addEventListener('click', async ()=> {
        if(playing){
          // request stop
          stopRequested = true;
          playing = false;
          playBtn.textContent = 'Play';
          setStatus('Paused');
        } else {
          // start playing
          base = parseInt(baseSelect.value,10);
          baseBadge.textContent = base;
          animationDuration = parseInt(speedRange.value,10);
          speedLabel.textContent = animationDuration + 'ms';
          // if nothing loaded, load current input
          if(items.length===0) loadFromInput();
          await playAll();
        }
      });

      stepBtn.addEventListener('click', ()=> {
        stepOnce();
      });

      resetBtn.addEventListener('click', ()=> {
        reset();
      });

      speedRange.addEventListener('input', ()=>{
        animationDuration = parseInt(speedRange.value,10);
        speedLabel.textContent = animationDuration + 'ms';
        // adjust transition durations
        items.forEach(it=> {
          it.el.style.transition = `transform ${animationDuration}ms cubic-bezier(.2,.9,.3,1)`;
        });
      });

      baseSelect.addEventListener('change', ()=>{
        base = parseInt(baseSelect.value,10);
        baseBadge.textContent = base;
        // re-render buckets only
        if(items.length > 0){
          // re-create bucket DOM
          const arr = items.map(it=>it.value);
          input.value = arr.join(', ');
          loadFromInput();
        }
      });

      input.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){
          loadFromInput();
        }
      });

      // keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT')) return;
        if(e.code === 'Space'){
          e.preventDefault();
          playBtn.click();
        } else if(e.key.toLowerCase() === 's'){
          stepBtn.click();
        }
      });

      // responsive recalculation
      let resizeRaf = null;
      window.addEventListener('resize', ()=>{
        if(resizeRaf) cancelAnimationFrame(resizeRaf);
        resizeRaf = requestAnimationFrame(()=> {
          placeItemsAtSlots();
        });
      });

      // Initialize defaults
      (function init(){
        // initial load from input value
        const parsed = parseArrayInput(input.value);
        if(parsed && parsed.length>0){
          initialArray = parsed;
        } else {
          initialArray = [170,45,75,90,802,24,2,66];
          input.value = initialArray.join(', ');
        }
        base = parseInt(baseSelect.value,10);
        baseBadge.textContent = base;
        loadFromInput();
      })();

      // Expose for debugging (not necessary)
      window.RadixVis = {
        loadFromInput, randomize, playAll, stepOnce, reset
      };

    })();
  </script>
</body>
</html>