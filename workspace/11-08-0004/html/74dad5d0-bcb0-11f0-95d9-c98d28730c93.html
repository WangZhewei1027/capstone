<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>K-Nearest Neighbors (KNN) Interactive Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa4b2;
      --accent: #22c1c3;
      --white: #e7eef6;
      --danger: #ff6b6b;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg, #071020 0%, #081521 100%);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: var(--white);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .root {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100%;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .title {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: -0.01em;
    }

    .subtitle {
      font-size: 13px;
      color: var(--muted);
    }

    main {
      display: flex;
      gap: var(--gap);
      align-items: stretch;
      justify-content: stretch;
      flex: 1 1 auto;
    }

    /* Layout: left canvas, right panel */
    .canvas-panel {
      flex: 2 1 0%;
      min-width: 320px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 16px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.03);
    }

    .controls-panel {
      flex: 1 0 320px;
      min-width: 260px;
      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(0,0,0,0.02));
      border-radius: 12px;
      padding: 16px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 12px;
      border: 1px solid rgba(255,255,255,0.03);
    }

    /* Canvas header */
    .canvas-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .canvas-title {
      font-weight: 600;
      font-size: 14px;
    }

    .canvas-desc {
      color: var(--muted);
      font-size: 12px;
    }

    /* SVG area */
    .plot-area {
      flex: 1 1 auto;
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 320px;
    }

    /* Controls styling */
    .control-group {
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      border: 1px solid rgba(255,255,255,0.02);
    }

    label {
      font-size: 13px;
      color: var(--muted);
      display: block;
    }

    input[type="range"] {
      width: 100%;
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .row .small {
      font-size: 13px;
      color: var(--muted);
    }

    select, input[type="number"] {
      background: rgba(255,255,255,0.02);
      color: var(--white);
      border: 1px solid rgba(255,255,255,0.03);
      padding: 8px;
      border-radius: 8px;
      font-size: 13px;
    }

    button {
      background: linear-gradient(180deg, rgba(34,193,195,0.18), rgba(17,111,116,0.18));
      color: var(--white);
      border: 1px solid rgba(34,193,195,0.25);
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }

    button.ghost {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.03);
      color: var(--muted);
      font-weight: 600;
    }

    .color-palette {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .color-swatch {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      border: 2px solid rgba(255,255,255,0.04);
      box-shadow: 0 1px 0 rgba(0,0,0,0.4) inset;
      cursor: pointer;
      display: inline-block;
    }

    .color-swatch.selected {
      outline: 3px solid rgba(255,255,255,0.05);
      transform: translateY(-2px);
    }

    /* Info area */
    .info {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 8px;
      border-radius: 8px;
      background: rgba(255,255,255,0.01);
      border: 1px solid rgba(255,255,255,0.02);
    }

    .badge {
      display: inline-block;
      padding: 6px 8px;
      border-radius: 999px;
      font-weight: 700;
      color: #071421;
      background: linear-gradient(90deg, #ffd86b, #ffb86b);
      font-size: 13px;
    }

    .result {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      padding: 8px;
      border-radius: 8px;
      background: linear-gradient(90deg, rgba(34,193,195,0.06), rgba(34,139,140,0.03));
    }

    .legend {
      display: flex;
      gap: 12px;
      align-items: center;
      font-size: 13px;
      color: var(--muted);
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .dot {
      width: 12px;
      height: 12px;
      border-radius: 3px;
    }

    /* Neighbor list */
    .neighbors {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
      color: var(--muted);
    }

    .neighbor-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(255,255,255,0.01);
      border: 1px solid rgba(255,255,255,0.015);
    }

    /* Accessibility focus */
    button:focus, select:focus, input:focus {
      outline: 3px solid rgba(34,193,195,0.12);
      outline-offset: 2px;
      border-radius: 8px;
    }

    /* Responsive */
    @media (max-width: 920px) {
      main {
        flex-direction: column;
      }
      .controls-panel {
        min-width: unset;
        width: 100%;
      }
      .canvas-panel {
        min-width: unset;
        width: 100%;
      }
    }

    /* SVG styling helpers */
    svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .point {
      stroke: rgba(0,0,0,0.35);
      stroke-width: 1.2px;
      cursor: pointer;
      transition: transform 0.12s ease, r 0.12s ease;
    }

    .point:hover {
      transform: translateY(-2px);
    }

    .query {
      stroke: #fff;
      stroke-width: 1.6px;
      filter: drop-shadow(0 2px 8px rgba(34,193,195,0.24));
    }

    .neighbor-line {
      stroke: rgba(255,255,255,0.5);
      stroke-width: 1.2;
      stroke-linecap: round;
      stroke-dasharray: 8 6;
      opacity: 0.9;
    }

    .expanding-circle {
      fill: none;
      stroke: rgba(255,255,255,0.08);
      stroke-width: 2;
      transition: r 0.4s ease;
    }

    .highlight {
      stroke-width: 2.4px;
      transform-origin: center;
      transition: transform 0.12s ease;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.5));
    }

    .prob-bar {
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.03);
      overflow: hidden;
    }

    .prob-fill {
      height: 100%;
      transition: width 0.4s ease;
    }

    /* Tiny helper for subtle animation when neighbor selected */
    @keyframes pop {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .pop {
      animation: pop 220ms ease;
    }

    /* Small hint area */
    .hint {
      font-size: 12px;
      color: var(--muted);
    }

  </style>
</head>
<body>
  <div class="root">
    <header>
      <div class="title">K-Nearest Neighbors (KNN) — Interactive Exploration</div>
      <div class="subtitle">Explore classification by placing points, moving a query, and adjusting K, distance, and weighting.</div>
    </header>

    <main>
      <!-- Left: Interactive Canvas -->
      <section class="canvas-panel" aria-label="Interactive plot area">
        <div class="canvas-header" role="region" aria-label="Canvas header">
          <div>
            <div class="canvas-title">2D Scatter / Classification Space</div>
            <div class="canvas-desc">Click to add points of the selected class. Drag the orange point to change the query location.</div>
          </div>
          <div class="legend" aria-hidden="true" id="legendTop">
            <div class="legend-item"><span class="dot" style="background:#3b82f6"></span><span class="small">Class A</span></div>
            <div class="legend-item"><span class="dot" style="background:#ef4444"></span><span class="small">Class B</span></div>
            <div class="legend-item"><span class="dot" style="background:#f59e0b"></span><span class="small">Class C</span></div>
            <div class="legend-item"><span class="dot" style="background:#ffb86b"></span><span class="small">Query</span></div>
          </div>
        </div>

        <div class="plot-area" id="plotArea" role="application" aria-label="KNN plot. Click to add points.">
          <svg id="svg" viewBox="0 0 640 480" preserveAspectRatio="xMinYMin meet" tabindex="0" aria-hidden="false">
            <!-- background grid -->
            <defs>
              <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
                <path d="M 40 0 L 0 0 0 40" fill="none" stroke="rgba(255,255,255,0.02)" stroke-width="1"/>
              </pattern>
            </defs>
            <rect width="100%" height="100%" fill="url(#grid)"></rect>

            <!-- dynamic group for visualization -->
            <g id="viz"></g>
          </svg>
        </div>

        <div class="info" aria-live="polite">
          <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
            <div style="display:flex;gap:12px;flex-direction:column;">
              <div class="small" style="color:var(--muted)">Classification result</div>
              <div class="result" id="resultBox">
                <div style="display:flex;gap:10px;align-items:center;">
                  <div id="resultColor" style="width:18px;height:18px;border-radius:4px;background:#ffb86b"></div>
                  <div style="font-weight:700" id="resultLabel">Unknown</div>
                </div>
                <div id="resultProb" style="color:var(--muted);font-size:13px">—</div>
              </div>
            </div>

            <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end;">
              <div class="badge" id="kBadge">K = 3</div>
              <div class="hint">Tip: Press 'A' to toggle Add mode, 'D' to delete nearest, 'R' to randomize</div>
            </div>
          </div>
        </div>
      </section>

      <!-- Right: Controls & Explanation -->
      <aside class="controls-panel" aria-label="Controls and explanation">
        <div class="control-group" role="region" aria-labelledby="learningTitle">
          <div id="learningTitle" style="font-weight:700;">Learning Objective</div>
          <div style="color:var(--muted);font-size:13px">
            Understand how the K-Nearest Neighbors algorithm classifies a query by inspecting the nearest training points, how the parameter K and choice of distance metric affect decision boundaries, and the effect of weighting neighbors by distance.
          </div>
        </div>

        <div class="control-group" role="region" aria-labelledby="interactionTitle">
          <div id="interactionTitle" style="font-weight:700;">Interaction Design</div>
          <div style="color:var(--muted);font-size:13px;display:flex;flex-direction:column;gap:8px">
            <div><strong>Click</strong> on the plot to add a training point of the selected class.</div>
            <div><strong>Drag</strong> the orange query point to see live classification changes.</div>
            <div><strong>Use controls</strong> to change K, distance metric (Euclidean / Manhattan / Chebyshev), and toggle weighting. Press "Animate neighbor search" to visualize neighbor discovery order and expanding radius.</div>
          </div>
        </div>

        <div class="control-group" role="region" aria-labelledby="controlsTitle" aria-describedby="controlsDesc">
          <div id="controlsTitle" style="font-weight:700">Controls</div>

          <label for="kRange">K (<span id="kVal">3</span>)</label>
          <input id="kRange" type="range" min="1" max="15" value="3" aria-label="Select K value">

          <div class="row" style="align-items:center;">
            <div style="flex:1">
              <label for="metric">Distance metric</label>
              <select id="metric" aria-label="Choose distance metric">
                <option value="euclidean">Euclidean (L2)</option>
                <option value="manhattan">Manhattan (L1)</option>
                <option value="chebyshev">Chebyshev (L∞)</option>
              </select>
            </div>
            <div style="width:14px"></div>
            <div style="display:flex;flex-direction:column;gap:6px;">
              <label for="weighted" style="color:var(--muted);font-size:13px">Weighted</label>
              <input id="weighted" type="checkbox" aria-label="Toggle weighted voting">
            </div>
          </div>

          <div style="display:flex;gap:8px;align-items:center;justify-content:space-between;">
            <div style="display:flex;flex-direction:column;">
              <label style="color:var(--muted);font-size:13px">Add mode</label>
              <div class="color-palette" role="radiogroup" aria-label="Select class color">
                <button class="color-swatch selected" id="swA" data-class="A" title="Class A" style="background:#3b82f6" aria-checked="true"></button>
                <button class="color-swatch" id="swB" data-class="B" title="Class B" style="background:#ef4444" aria-checked="false"></button>
                <button class="color-swatch" id="swC" data-class="C" title="Class C" style="background:#f59e0b" aria-checked="false"></button>
              </div>
            </div>

            <div style="display:flex;flex-direction:column;gap:8px;">
              <label style="color:var(--muted);font-size:13px">Point controls</label>
              <div style="display:flex;gap:8px;">
                <button id="clearBtn" class="ghost" title="Clear all points">Clear</button>
                <button id="randomBtn" title="Scatter random points">Randomize</button>
              </div>
            </div>
          </div>

          <div style="display:flex;gap:8px;align-items:center;justify-content:space-between;">
            <button id="animateBtn" title="Visualize neighbor search">Animate neighbor search</button>
            <button id="deleteNearestBtn" class="ghost" title="Delete nearest training point to query">Delete nearest</button>
          </div>

        </div>

        <div class="control-group" id="neighborsGroup" role="region" aria-labelledby="neighborsTitle">
          <div id="neighborsTitle" style="font-weight:700">Neighbors & Probabilities</div>
          <div id="neighborList" class="neighbors" aria-live="polite"></div>
        </div>

        <div class="control-group" role="region" aria-labelledby="layoutTitle">
          <div id="layoutTitle" style="font-weight:700">Layout Description</div>
          <div style="color:var(--muted);font-size:13px;display:flex;flex-direction:column;gap:8px">
            <div>Safe area margins: 24px on all sides. Minimum spacing between interactive elements: 16px.</div>
            <div>Left: interactive SVG plot with grid, training points, query point, expanding radius and neighbor lines. Right: controls (K slider, metric, weighted), class palette, action buttons, and explanatory text. On narrow screens, controls stack under the plot for responsiveness.</div>
            <div>Accessibility: controls are keyboard-focusable, result updates announced via live regions, and color choices are paired with labels.</div>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <script>
    /*****************************************************************************
     * K-Nearest Neighbors Interactive Module (vanilla JS)
     * Features:
     * - Click to add points of selected class
     * - Drag the query point to update classification live
     * - K slider (1-15), distance metric (Euclidean, Manhattan, Chebyshev)
     * - Weighted/unweighted voting toggle
     * - Animate neighbor search: expanding circle and lines drawn sequentially
     * - Neighbor list with computed distances and probability bars
     * - Accessible controls and keyboard shortcuts
     *****************************************************************************/

    (function () {
      // Constants and DOM
      const svg = document.getElementById('svg');
      const viz = document.getElementById('viz');
      const plotArea = document.getElementById('plotArea');

      const kRange = document.getElementById('kRange');
      const kVal = document.getElementById('kVal');
      const kBadge = document.getElementById('kBadge');
      const metricSelect = document.getElementById('metric');
      const weightedCheckbox = document.getElementById('weighted');
      const neighborList = document.getElementById('neighborList');
      const resultLabel = document.getElementById('resultLabel');
      const resultColor = document.getElementById('resultColor');
      const resultProb = document.getElementById('resultProb');
      const animateBtn = document.getElementById('animateBtn');
      const clearBtn = document.getElementById('clearBtn');
      const randomBtn = document.getElementById('randomBtn');
      const deleteNearestBtn = document.getElementById('deleteNearestBtn');

      const swatches = {
        A: document.getElementById('swA'),
        B: document.getElementById('swB'),
        C: document.getElementById('swC')
      };

      const COLORS = {
        A: '#3b82f6',
        B: '#ef4444',
        C: '#f59e0b',
        QUERY: '#ffb86b'
      };

      // Internal state
      let points = []; // {x:0..1, y:0..1, cls: 'A'|'B'|'C', id}
      let query = { x: 0.5, y: 0.5 };
      let selectedClass = 'A';
      let draggingQuery = false;
      let svgBBox = { width: 640, height: 480 };
      let animating = false;
      let idCounter = 1;

      // Utilities: coordinate conversions between svg viewBox (0..640,0..480) and normalized 0..1
      function updateSVGSize() {
        const viewBox = svg.viewBox.baseVal;
        svgBBox.width = viewBox.width;
        svgBBox.height = viewBox.height;
      }
      updateSVGSize();

      function toSVGC(coords) {
        return { sx: coords.x * svgBBox.width, sy: coords.y * svgBBox.height };
      }
      function fromSVGC(sx, sy) {
        return { x: Math.max(0, Math.min(1, sx / svgBBox.width)), y: Math.max(0, Math.min(1, sy / svgBBox.height)) };
      }

      // Distance metrics
      function dist(a, b, metric) {
        const dx = a.x - b.x, dy = a.y - b.y;
        if (metric === 'euclidean') return Math.hypot(dx, dy);
        if (metric === 'manhattan') return Math.abs(dx) + Math.abs(dy);
        if (metric === 'chebyshev') return Math.max(Math.abs(dx), Math.abs(dy));
        return Math.hypot(dx, dy);
      }

      // Rendering functions
      function clearViz() {
        while (viz.firstChild) viz.removeChild(viz.firstChild);
      }

      function renderAll(highlightedIds = []) {
        clearViz();
        updateSVGSize();

        // Draw training points
        points.forEach(p => {
          const { sx, sy } = toSVGC(p);
          const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          g.setAttribute('data-id', p.id);

          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', sx);
          circle.setAttribute('cy', sy);
          circle.setAttribute('r', 8);
          circle.setAttribute('fill', COLORS[p.cls]);
          circle.setAttribute('class', 'point');
          circle.setAttribute('aria-label', `Training point class ${p.cls}, id ${p.id}`);
          circle.style.opacity = highlightedIds.includes(p.id) ? 1 : 0.95;

          g.appendChild(circle);
          viz.appendChild(g);

          // allow clicking a point to remove (delete mode could be implemented) -
          circle.addEventListener('click', evt => {
            evt.stopPropagation();
            // remove point on Ctrl+click or Alt+click
            if (evt.ctrlKey || evt.altKey || evt.metaKey) {
              points = points.filter(pt => pt.id !== p.id);
              renderAll();
            }
          });
        });

        // Draw neighbor lines and expanding circle if animating (managed separately)
        // Draw query point
        const q = toSVGC(query);
        const ring = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        ring.setAttribute('cx', q.sx);
        ring.setAttribute('cy', q.sy);
        ring.setAttribute('r', 14);
        ring.setAttribute('class', 'query');
        ring.setAttribute('fill', COLORS.QUERY);
        ring.setAttribute('opacity', '1');
        ring.setAttribute('aria-hidden', 'false');
        viz.appendChild(ring);

        // allow dragging the query
        ring.addEventListener('pointerdown', startQueryDrag);

        // Update neighbors and result
        computeAndDisplayNeighbors();
      }

      // Compute neighbors according to current settings, update neighbor list and classification
      function computeAndDisplayNeighbors() {
        if (points.length === 0) {
          resultLabel.textContent = 'No points';
          resultColor.style.background = '#ccc';
          resultProb.textContent = '—';
          neighborList.innerHTML = '<div style="color:var(--muted)">No training points. Add some by clicking the plot.</div>';
          return;
        }

        const metric = metricSelect.value;
        const k = Math.min(points.length, parseInt(kRange.value, 10));
        const weighted = weightedCheckbox.checked;

        // compute distances
        const dlist = points.map(p => {
          const d = dist(p, query, metric);
          return { id: p.id, cls: p.cls, d, p };
        });

        dlist.sort((a, b) => a.d - b.d);

        const neighbors = dlist.slice(0, k);

        // compute class votes
        const votes = {};
        neighbors.forEach(n => {
          if (!votes[n.cls]) votes[n.cls] = 0;
          // handle exact zero distance (query coincides with training)
          const eps = 1e-9;
          if (weighted) {
            votes[n.cls] += 1 / (n.d + eps);
          } else {
            votes[n.cls] += 1;
          }
        });

        // Normalize to probabilities
        const total = Object.values(votes).reduce((s, v) => s + v, 0);
        const probs = {};
        Object.keys(votes).forEach(c => { probs[c] = votes[c] / total; });

        // Determine winner
        let winner = null;
        let best = -Infinity;
        Object.entries(votes).forEach(([c, v]) => {
          if (v > best) { best = v; winner = c; }
        });

        if (!winner) {
          resultLabel.textContent = 'Unknown';
          resultColor.style.background = '#888';
          resultProb.textContent = '—';
        } else {
          resultLabel.textContent = `Class ${winner}`;
          resultColor.style.background = COLORS[winner] || '#fff';
          resultProb.textContent = Object.keys(probs).map(c => `${c}: ${(probs[c]*100).toFixed(0)}%`).join(' • ');
        }

        // Render neighbor list UI
        neighborList.innerHTML = '';
        neighbors.forEach((n, idx) => {
          const row = document.createElement('div');
          row.className = 'neighbor-row';
          row.setAttribute('role', 'button');
          row.tabIndex = 0;
          row.setAttribute('aria-label', `Neighbor ${idx+1}, class ${n.cls}, distance ${(n.d*100).toFixed(1)}% of plot`);
          row.innerHTML = `
            <div style="display:flex;gap:10px;align-items:center;">
              <div style="width:12px;height:12px;border-radius:3px;background:${COLORS[n.cls]}"></div>
              <div style="min-width:60px;font-weight:700;color:var(--white)">#${n.p.id}</div>
              <div style="color:var(--muted);font-size:12px">d=${(n.d*100).toFixed(1)}%</div>
            </div>
            <div style="width:120px;display:flex;flex-direction:column;gap:6px;">
              <div class="prob-bar"><div class="prob-fill" style="width:${( (weighted ? (1/(n.d+1e-9)) : 1) / (weighted ? (1/(neighbors[0].d+1e-9)) : 1) * 100 )}% ; background:${COLORS[n.cls]}"></div></div>
            </div>
          `;
          neighborList.appendChild(row);

          // clicking neighbor highlights it on the plot
          row.addEventListener('click', () => {
            highlightSingleNeighbor(n.p.id);
          });
          row.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              highlightSingleNeighbor(n.p.id);
            }
          });
        });
      }

      function highlightSingleNeighbor(pid) {
        // visually pop a point; brief animation
        const el = viz.querySelector(`g[data-id='${pid}'] circle`);
        if (!el) return;
        el.classList.add('highlight', 'pop');
        setTimeout(() => el.classList.remove('pop'), 300);
      }

      // Interaction: click to add point (of selected class), drag to move query
      function onPlotClick(evt) {
        // If click near the query (within 18px), start dragging query instead
        const pt = getPointerSvgCoords(evt);
        const q = toSVGC(query);
        const dx = q.sx - pt.sx, dy = q.sy - pt.sy;
        const distToQuery = Math.hypot(dx, dy);
        if (distToQuery <= 16) {
          // start dragging query
          startQueryDrag(evt);
          return;
        }

        // else add a point of selectedClass
        const norm = fromSVGC(pt.sx, pt.sy);
        points.push({ x: norm.x, y: norm.y, cls: selectedClass, id: idCounter++ });
        renderAll();
      }

      function getPointerSvgCoords(evt) {
        const rect = svg.getBoundingClientRect();
        const clientX = evt.clientX !== undefined ? evt.clientX : (evt.touches && evt.touches[0].clientX);
        const clientY = evt.clientY !== undefined ? evt.clientY : (evt.touches && evt.touches[0].clientY);
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        // map to viewBox scale
        const scaleX = svg.viewBox.baseVal.width / rect.width;
        const scaleY = svg.viewBox.baseVal.height / rect.height;
        return { sx: x * scaleX, sy: y * scaleY };
      }

      function startQueryDrag(evt) {
        evt.preventDefault();
        draggingQuery = true;
        svg.setPointerCapture(evt.pointerId);
        document.addEventListener('pointermove', onQueryDrag);
        document.addEventListener('pointerup', endQueryDrag);
      }

      function onQueryDrag(evt) {
        if (!draggingQuery) return;
        const pt = getPointerSvgCoords(evt);
        const norm = fromSVGC(pt.sx, pt.sy);
        query.x = norm.x;
        query.y = norm.y;
        renderAll();
      }

      function endQueryDrag(evt) {
        draggingQuery = false;
        try {
          svg.releasePointerCapture(evt.pointerId);
        } catch (_) {}
        document.removeEventListener('pointermove', onQueryDrag);
        document.removeEventListener('pointerup', endQueryDrag);
      }

      // Animation: expand a circle until k-th neighbor distance, draw lines sequentially
      async function animateNeighborSearch() {
        if (animating) return;
        if (points.length === 0) return;
        animating = true;

        const metric = metricSelect.value;
        const k = Math.min(points.length, parseInt(kRange.value, 10));

        // compute sorted distances
        const dlist = points.map(p => {
          const d = dist(p, query, metric);
          return { id: p.id, cls: p.cls, d, p };
        }).sort((a, b) => a.d - b.d);

        const neighbors = dlist.slice(0, k);
        const kthDist = neighbors[neighbors.length - 1].d;

        // scale to svg coordinates radius
        const q = toSVGC(query);
        // draw expanding circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', q.sx);
        circle.setAttribute('cy', q.sy);
        circle.setAttribute('r', 2);
        circle.setAttribute('class', 'expanding-circle');
        circle.style.stroke = 'rgba(255,255,255,0.12)';
        viz.appendChild(circle);

        // animate radius in steps
        const steps = 24;
        for (let s = 1; s <= steps; s++) {
          const frac = s / steps;
          const r = radiusFromNormalizedDistance(kthDist * frac);
          circle.setAttribute('r', r);
          await wait(16);
        }

        // draw lines to neighbors sequentially
        for (let i = 0; i < neighbors.length; i++) {
          const n = neighbors[i];
          const pSV = toSVGC(n.p);
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', q.sx);
          line.setAttribute('y1', q.sy);
          line.setAttribute('x2', q.sx);
          line.setAttribute('y2', q.sy);
          line.setAttribute('class', 'neighbor-line');
          line.style.stroke = colorWithAlpha(COLORS[n.cls], 0.9);
          viz.appendChild(line);

          // animate drawing
          const stepsLine = 16;
          for (let t = 1; t <= stepsLine; t++) {
            const fx = t / stepsLine;
            line.setAttribute('x2', q.sx + (pSV.sx - q.sx) * fx);
            line.setAttribute('y2', q.sy + (pSV.sy - q.sy) * fx);
            await wait(16);
          }

          // briefly highlight the neighbor point
          highlightSingleNeighbor(n.p.id);
          await wait(180);
        }

        // fade out circle and lines
        await wait(400);
        const extras = Array.from(viz.querySelectorAll('.expanding-circle, .neighbor-line'));
        extras.forEach(el => el.remove());
        animating = false;
      }

      function radiusFromNormalizedDistance(nd) {
        // nd is normalized in [0, sqrt(2)] potentially but we treat it as ratio of box diagonal?
        // Simpler: create radius proportional to normalized euclidean distance relative to diagonal
        // We'll map normalized world distance (0..1) to svg width (use hypotenuse 1.0 corresponds to diag)
        // Use scaling: maxDist ~ sqrt(1^2 + 1^2) = 1.414
        const diag = Math.hypot(1, 1);
        const ratio = nd / diag; // 0..1
        const maxR = Math.hypot(svgBBox.width, svgBBox.height) / 2;
        return ratio * maxR;
      }

      function wait(ms) {
        return new Promise(res => setTimeout(res, ms));
      }

      function colorWithAlpha(hex, a) {
        // convert hex to rgba string
        const c = hex.replace('#', '');
        const bigint = parseInt(c, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return `rgba(${r},${g},${b},${a})`;
      }

      // Controls wiring
      kRange.addEventListener('input', () => {
        kVal.textContent = kRange.value;
        kBadge.textContent = `K = ${kRange.value}`;
        renderAll();
      });

      metricSelect.addEventListener('change', () => renderAll());
      weightedCheckbox.addEventListener('change', () => renderAll());

      Object.keys(swatches).forEach(cls => {
        const btn = swatches[cls];
        btn.addEventListener('click', () => {
          selectedClass = cls;
          Object.values(swatches).forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
        });
      });

      animateBtn.addEventListener('click', async () => {
        animateNeighborSearch();
      });

      clearBtn.addEventListener('click', () => {
        points = [];
        renderAll();
      });

      randomBtn.addEventListener('click', () => {
        scatterRandom();
      });

      deleteNearestBtn.addEventListener('click', () => {
        if (points.length === 0) return;
        const metric = metricSelect.value;
        // find nearest to query
        let best = null;
        points.forEach(p => {
          const d = dist(p, query, metric);
          if (best === null || d < best.d) best = { p, d };
        });
        if (best) {
          points = points.filter(pt => pt.id !== best.p.id);
          renderAll();
        }
      });

      // Plot click listeners
      plotArea.addEventListener('pointerdown', onPlotClick);

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.key === 'a' || e.key === 'A') {
          // toggle between classes quickly
          const order = ['A', 'B', 'C'];
          const idx = order.indexOf(selectedClass);
          const next = order[(idx + 1) % order.length];
          selectedClass = next;
          Object.values(swatches).forEach(b => b.classList.remove('selected'));
          swatches[selectedClass].classList.add('selected');
        } else if (e.key === 'r' || e.key === 'R') {
          scatterRandom();
        } else if (e.key === 'd' || e.key === 'D') {
          // delete nearest
          deleteNearestBtn.click();
        }
      });

      // Scatter random helper
      function scatterRandom() {
        points = [];
        const classes = ['A', 'B', 'C'];
        for (let c = 0; c < classes.length; c++) {
          // create a cluster near different quadrants
          const cx = 0.2 + c * 0.4;
          const cy = 0.25 + (c % 2) * 0.5;
          for (let i = 0; i < 8; i++) {
            const nx = Math.min(1, Math.max(0, cx + (Math.random() - 0.5) * 0.14));
            const ny = Math.min(1, Math.max(0, cy + (Math.random() - 0.5) * 0.14));
            points.push({ x: nx, y: ny, cls: classes[c], id: idCounter++ });
          }
        }
        // move query slightly
        query.x = 0.5 + (Math.random() - 0.5) * 0.12;
        query.y = 0.5 + (Math.random() - 0.5) * 0.12;
        renderAll();
      }

      // initial demo scatter
      scatterRandom();

      // Re-render on window resize
      window.addEventListener('resize', () => {
        renderAll();
      });

      // Expose a few functions for accessibility/keyboard control (not necessary but helpful)
      window.KNNInteractive = {
        addPoint: (x, y, cls = 'A') => {
          points.push({ x, y, cls, id: idCounter++ });
          renderAll();
        },
        setQuery: (x, y) => {
          query.x = x; query.y = y; renderAll();
        },
        getState: () => ({ points: points.slice(), query: { ...query } })
      };

      // Final render
      renderAll();

    })();
  </script>
</body>
</html>