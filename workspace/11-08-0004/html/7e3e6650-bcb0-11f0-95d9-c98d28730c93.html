<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Insertion Sort — Interactive Module</title>
  <style>
    /* Safe area margins */
    :root {
      --safe-margin: 24px;
      --gap: 16px;               /* minimum spacing between interactive elements */
      --control-height: 40px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa4b2;
      --accent: #2dd4bf;         /* teal */
      --accent-2: #60a5fa;       /* blue */
      --danger: #fb7185;
      --success: #34d399;
      --surface: #071028;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg, var(--bg) 0%, #03060a 100%);
      color: #e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI",
                   Roboto, "Helvetica Neue", Arial;
      font-size: 16px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Page safe area */
    .page {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100vh;
      display: flex;
      gap: var(--gap);
      flex-direction: column;
    }

    /* Header text area: Concept Title and Objective */
    .header {
      display: flex;
      gap: var(--gap);
      flex-direction: column;
      max-width: 1100px;
      margin: 0 auto;
    }

    h1 {
      margin: 0;
      font-size: 1.6rem;
      line-height: 1.1;
      color: #e6f6f2;
    }

    .meta {
      display: flex;
      gap: var(--gap);
      flex-wrap: wrap;
      align-items: center;
    }

    .objective {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      padding: 12px;
      border-radius: 8px;
      color: var(--muted);
      font-size: 0.95rem;
      max-width: 900px;
    }

    /* Main interactive module container */
    .module {
      max-width: 1100px;
      margin: 0 auto;
      display: grid;
      gap: var(--gap);
      grid-template-columns: 1fr 380px;
      align-items: start;
    }

    @media (max-width: 980px) {
      .module {
        grid-template-columns: 1fr;
      }
    }

    /* Left: visualization and controls */
    .visual-panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      border-radius: 10px;
      padding: 16px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      min-height: 320px;
    }

    .controls {
      display: flex;
      gap: var(--gap);
      flex-wrap: wrap;
      align-items: center;
    }

    .controls > * {
      min-height: var(--control-height);
    }

    button, input[type="number"], input[type="text"], select {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      color: #eaf6f2;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.95rem;
      transition: box-shadow 160ms ease, transform 120ms ease;
    }

    button:active { transform: translateY(1px); }
    button:focus, input:focus { outline: 3px solid rgba(96,165,250,0.14); }

    .primary {
      background: linear-gradient(90deg, rgba(45,212,191,0.12), rgba(96,165,250,0.08));
      border: 1px solid rgba(96,165,250,0.14);
      color: #e6f6f6;
      font-weight: 600;
    }

    .danger {
      background: linear-gradient(90deg, rgba(251,113,133,0.06), rgba(255,255,255,0.01));
      border: 1px solid rgba(251,113,133,0.10);
    }

    .controls .spacer {
      flex: 1 1 auto;
      min-width: 8px;
    }

    /* Visualization area */
    .viz {
      background: var(--surface);
      border-radius: 8px;
      padding: 16px;
      position: relative;
      overflow: hidden;
      min-height: 220px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: stretch;
    }

    .bar-wrap {
      position: relative;
      height: 140px;
      border-radius: 6px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      display: block;
      overflow: visible;
    }

    /* Bars are absolutely positioned and animated by transform */
    .bar {
      position: absolute;
      bottom: 8px;
      width: 56px; /* will be updated by JS for responsiveness */
      border-radius: 6px;
      background: linear-gradient(180deg,#60a5fa11,#2dd4bf19);
      color: #071028;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 6px;
      box-sizing: border-box;
      font-weight: 700;
      transition: transform 280ms cubic-bezier(.2,.9,.2,1), box-shadow 200ms ease, background 200ms ease;
      box-shadow: 0 6px 16px rgba(2,6,23,0.5);
      min-height: 32px;
      text-shadow: 0 1px 0 rgba(255,255,255,0.05);
    }

    .bar .value {
      color: #042029;
      font-size: 0.95rem;
    }

    .bar.status-sorted {
      background: linear-gradient(180deg, rgba(52,211,153,0.18), rgba(96,165,250,0.02));
      box-shadow: 0 6px 18px rgba(52,211,153,0.06);
      transform: none;
    }

    .bar.status-key {
      background: linear-gradient(180deg, rgba(96,165,250,0.22), rgba(45,212,191,0.12));
      box-shadow: 0 10px 24px rgba(96,165,250,0.06);
      z-index: 5;
      transform: translateY(-30px);
    }

    .bar.status-comparing {
      outline: 3px solid rgba(255,255,255,0.04);
      background: linear-gradient(180deg, rgba(251,113,133,0.12), rgba(255,255,255,0.02));
    }

    .bar.small {
      font-size: 0.9rem;
    }

    .legend {
      display: flex;
      gap: 12px;
      align-items: center;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .legend .item {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .legend .swatch {
      width: 18px;
      height: 10px;
      border-radius: 4px;
      background: var(--muted);
    }

    .legend .swatch.key { background: linear-gradient(90deg,#60a5fa,#2dd4bf); }
    .legend .swatch.sorted { background: linear-gradient(90deg,#34d399,#60a5fa); }
    .legend .swatch.compare { background: linear-gradient(90deg,#fb7185,#f97316); }

    /* Right side: controls, pseudo-code, explanation */
    .info-panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      border-radius: 10px;
      padding: 16px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      min-height: 320px;
    }

    .section-title {
      margin: 0;
      font-size: 0.99rem;
      color: #dff3ef;
      font-weight: 700;
    }

    .pseudo {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius: 8px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.45;
    }

    .pseudo .line {
      padding: 6px 8px;
      border-radius: 6px;
      display: block;
      transition: background 160ms ease, color 160ms ease;
    }

    .pseudo .line.active {
      background: linear-gradient(90deg, rgba(96,165,250,0.12), rgba(45,212,191,0.06));
      color: #e8f9ff;
      font-weight: 700;
    }

    .explain {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius: 8px;
      padding: 12px;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .status-row {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .speed-row {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      border-radius: 8px;
      background: linear-gradient(90deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      width: 160px;
    }

    /* small annotations */
    .small {
      font-size: 0.9rem;
      color: var(--muted);
    }

    /* Footer small note */
    .note {
      color: var(--muted);
      font-size: 0.9rem;
    }

    /* Responsive adjustments for bar width calculation */
    @media (max-width: 600px) {
      .bar { width: 44px; }
    }
  </style>
</head>
<body>
  <div class="page" role="main">
    <!-- Header / Planning Text (required by design plan) -->
    <div class="header" aria-hidden="false">
      <h1>Insertion Sort — Interactive Demonstration</h1>

      <div class="meta">
        <div class="objective" aria-label="Learning Objective">
          <strong>Learning Objective:</strong>
          After interacting with this module you should be able to:
          - describe how insertion sort builds a sorted subarray by picking a "key" and shifting larger elements to the right; and
          - visualize comparisons, shifts, and final placement of the key step-by-step.
        </div>
      </div>

      <div class="small" style="color:var(--muted);">
        Interaction Design & Layout Summary available in the right-hand panel below.
      </div>
    </div>

    <!-- Interactive Module -->
    <div class="module" aria-label="Insertion Sort module">
      <!-- Left: Visualization + Controls -->
      <div class="visual-panel" aria-live="polite">
        <!-- Controls -->
        <div class="controls" role="toolbar" aria-label="Controls">
          <button id="btn-random" class="primary" title="Create a random array">Random Array</button>

          <label style="display:flex;align-items:center;gap:8px;">
            <span class="small" style="color:var(--muted);">Size</span>
            <input id="input-size" type="number" min="3" max="12" value="8" aria-label="Array size" />
          </label>

          <label style="display:flex;align-items:center;gap:8px;">
            <span class="small" style="color:var(--muted);">Values</span>
            <input id="input-values" type="text" placeholder="e.g. 5,2,9,1" aria-label="Comma separated values" />
          </label>

          <button id="btn-set" title="Set array from values">Set Values</button>

          <div class="spacer" role="none"></div>

          <button id="btn-step-back" title="Step backward (Shift/Compare previous)">⟲ Step Back</button>
          <button id="btn-step" title="Step forward">Step →</button>
          <button id="btn-play" class="primary" title="Play / Pause">Play</button>
          <button id="btn-reset" class="danger" title="Reset to original array">Reset</button>
        </div>

        <!-- Visualization -->
        <div class="viz" aria-label="Array visualization">
          <div class="bar-wrap" id="bar-wrap" tabindex="0" aria-label="Array bars">
            <!-- Bars inserted by JS -->
          </div>

          <div class="legend" aria-hidden="false" style="margin-top:6px;">
            <div class="item"><span class="swatch key"></span><span class="small">Current key</span></div>
            <div class="item"><span class="swatch compare"></span><span class="small">Comparing / shifting</span></div>
            <div class="item"><span class="swatch sorted"></span><span class="small">Sorted prefix</span></div>
          </div>
        </div>

        <div class="status-row" aria-live="polite">
          <div class="small" id="status-step">Step: 0 / 0</div>
          <div class="small" id="status-desc">Idle — create an array to begin.</div>
        </div>
      </div>

      <!-- Right: Pseudocode + Explanation + Interaction Design / Layout Description -->
      <aside class="info-panel" aria-label="Information panel">
        <div>
          <h2 class="section-title">Pseudo-code (Insertion Sort)</h2>
          <div class="pseudo" id="pseudo">
            <div class="line" data-line="1">for i = 1 to n-1</div>
            <div class="line" data-line="2">  key = A[i]</div>
            <div class="line" data-line="3">  j = i - 1</div>
            <div class="line" data-line="4">  while j >= 0 and A[j] > key</div>
            <div class="line" data-line="5">    A[j+1] = A[j]   // shift right</div>
            <div class="line" data-line="6">    j = j - 1</div>
            <div class="line" data-line="7">  A[j+1] = key     // insert key</div>
          </div>
        </div>

        <div>
          <h3 class="section-title">Explanation</h3>
          <div class="explain" id="explain">
            Make or choose an array, then use Step → to advance the algorithm one recorded action at a time.
            "Key" is picked up from the unsorted portion; comparisons show which element is being compared,
            and shifts animate elements moving to the right to make space for the key. The highlighted pseudo-code
            line updates with each action.
          </div>
        </div>

        <div>
          <h3 class="section-title">Interaction Design</h3>
          <div class="explain">
            - Click "Random Array" to generate values; or type comma-separated values and press "Set Values".<br>
            - Use "Step →" and "⟲ Step Back" to move one action forward or back (comparison, shift, insert).<br>
            - "Play" runs steps automatically; adjust speed via the slider. Animations show items translating
              horizontally and the key lifted vertically to emphasize movement.<br>
            - The right panel shows pseudo-code with the currently executing line highlighted and a short textual
              explanation of the current action. All interactive controls are keyboard accessible.
          </div>
        </div>

        <div>
          <h3 class="section-title">Layout Description</h3>
          <div class="explain">
            The page uses a two-column layout on wide screens (visualization left, controls and text right).
            Safe area margins are 24px. Interactive elements have at least 16px gap and consistent vertical rhythm.
            The bar visualization is responsive; bar width adjusts based on container and array size.
            Colors and focus outlines ensure accessibility; aria-live regions announce step progress.
          </div>
        </div>

        <div>
          <div class="speed-row" style="justify-content:space-between;">
            <div class="small">Speed:</div>
            <div style="display:flex;align-items:center;gap:8px;">
              <input id="speed" type="range" min="0.3" max="2.4" step="0.1" value="1" aria-label="Playback speed" />
              <div class="small" id="speed-label">1.0x</div>
            </div>
          </div>
        </div>

        <div class="note">
          Tip: Try arrays with repeated numbers and see how insertion sort preserves relative order (stable sort).
        </div>
      </aside>
    </div>
  </div>

  <script>
    /*
      Insertion Sort Interactive Module
      - Vanilla JS, self-contained
      - Precomputes a sequence of "steps" describing actions:
          - pick key, compare, shift, place key
      - Each step stores metadata to drive animations and UI updates
    */

    (function () {
      /* Utilities */
      function el(id) { return document.getElementById(id); }
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      /* DOM elements */
      const btnRandom = el('btn-random');
      const btnSet = el('btn-set');
      const btnStep = el('btn-step');
      const btnBack = el('btn-step-back');
      const btnPlay = el('btn-play');
      const btnReset = el('btn-reset');
      const inputSize = el('input-size');
      const inputValues = el('input-values');
      const barWrap = el('bar-wrap');
      const pseudo = el('pseudo');
      const explain = el('explain');
      const statusStep = el('status-step');
      const statusDesc = el('status-desc');
      const speedInput = el('speed');
      const speedLabel = el('speed-label');

      /* State */
      let baseArray = [];         // original array of values (objects with id & value)
      let steps = [];             // computed steps
      let stepIndex = -1;         // current step index
      let playing = false;
      let playTimer = null;
      let playSpeed = 1.0;

      /* Visual sizing config */
      const GAP = 14;            // gap between bars (visual), smaller than overall UI gap
      const BAR_MIN_WIDTH = 44;
      const BAR_MAX_WIDTH = 84;

      /* Initialize with default random array */
      function randArray(n = 8) {
        const a = [];
        for (let i = 0; i < n; i++) {
          a.push({ id: 'v' + i + '-' + Math.random().toString(36).slice(2,6), value: Math.floor(Math.random()*30)+1 });
        }
        return a;
      }

      function setBaseArrayFromValuesString(str) {
        const parts = str.split(',').map(s => s.trim()).filter(s => s.length > 0);
        if (parts.length === 0) return null;
        const vals = parts.map((p, i) => {
          const num = Number(p);
          return { id: 'v' + i + '-' + Math.random().toString(36).slice(2,6), value: isNaN(num) ? p : num };
        });
        return vals;
      }

      /* Build steps by simulating insertion sort and capturing states */
      function buildStepsFromArray(arr) {
        // working copy of elements
        const n = arr.length;
        const working = arr.map(x => ({ id: x.id, value: x.value }));
        const recorded = [];
        // helper to snapshot current working array with statuses
        function snap(meta) {
          // meta: { i, j, action, desc, highlightLine }
          const snapshot = {
            items: working.map((it, idx) => ({ id: it.id, value: it.value, index: idx, status: 'normal' })),
            meta: Object.assign({}, meta || {})
          };
          recorded.push(snapshot);
        }

        // initial snapshot
        snap({ action: 'start', desc: 'Initial array', line: 0 });

        for (let i = 1; i < n; i++) {
          const key = { id: working[i].id, value: working[i].value };
          let j = i - 1;

          // mark key picked up (status key)
          // snapshot where key is highlighted at index i (lifted)
          snap({ action: 'pick-key', desc: `Pick key = ${key.value} at index ${i}`, i: i, j: j, line: 2 });

          // comparison loop
          let moved = false;
          while (j >= 0 && numberCompare(working[j].value, key.value) > 0) {
            // mark comparing item
            snap({ action: 'compare', desc: `Compare A[${j}] (${working[j].value}) > key (${key.value}) → shift`, i: i, j: j, line: 4 });

            // perform shift: A[j+1] = A[j]
            working[j+1] = { id: working[j].id, value: working[j].value };
            // record snapshot after shift
            snap({ action: 'shift', desc: `Shift A[${j}] to index ${j+1}`, i: i, j: j, line: 5 });

            j = j - 1;
            moved = true;
          }

          // when loop ends, either j < 0 or working[j].value <= key.value
          if (!moved) {
            // Even if no move, we still record the comparison check (A[j] <= key)
            snap({ action: 'compare-false', desc: `No shift needed; place key at index ${j+1}`, i: i, j: j, line: 4 });
          } else {
            // one more comparison check that fails (or j < 0)
            snap({ action: 'compare-end', desc: `Finished shifting. Place key at index ${j+1}`, i: i, j: j, line: 6 });
          }

          // place key to position j+1
          working[j+1] = { id: key.id, value: key.value };
          // mark sorted prefix 0..i
          snap({ action: 'place-key', desc: `Insert key = ${key.value} at index ${j+1}`, i: i, j: j, line: 7, sortedUpto: i });

        }

        // final step: fully sorted
        snap({ action: 'done', desc: 'Array sorted', line: 0, sortedUpto: n-1 });

        // Post-process: annotate statuses per snapshot
        const enhanced = recorded.map((s, k) => {
          // set statuses
          const items = s.items.map(it => Object.assign({}, it));
          // default statuses
          if (s.meta && typeof s.meta.i === 'number') {
            const i = s.meta.i;
            const j = s.meta.j;
            const action = s.meta.action;
            if (action === 'pick-key') {
              items.forEach(it => { if (it.index === i) it.status = 'key'; if (it.index <= i-1) it.status = 'sorted'; });
            } else if (action === 'compare' || action === 'compare-false' || action === 'compare-end') {
              // comparing j with key; key will be implied at position i (but possibly moved later)
              items.forEach(it => {
                if (typeof i === 'number' && it.index === i) it.status = 'key';
                if (typeof j === 'number' && it.index === j) it.status = 'comparing';
                if (typeof s.meta.sortedUpto === 'number') {
                  if (it.index <= s.meta.sortedUpto) it.status = 'sorted';
                } else {
                  // sorted prefix up to i-1
                  if (typeof i === 'number' && it.index <= Math.max(0, i-1)) it.status = 'sorted';
                }
              });
            } else if (action === 'shift') {
              items.forEach(it => {
                if (typeof j === 'number' && it.index === j+1) it.status = 'shifted';
                if (it.index <= i) it.status = (it.index <= (s.meta.sortedUpto || i)) ? 'sorted' : it.status;
                // the item at j+1 just received the shifted element
              });
            } else if (action === 'place-key') {
              const upto = s.meta.sortedUpto || i;
              items.forEach(it => {
                if (it.index <= upto) it.status = 'sorted';
              });
            } else if (action === 'start') {
              // nothing
            } else if (action === 'done') {
              items.forEach(it => it.status = 'sorted');
            }
          }
          // enhance descriptions with fallback
          return { items: items, meta: s.meta || {} };
        });

        return enhanced;
      }

      /* Support numeric or string compare (if values are numbers compare numerically) */
      function numberCompare(a, b) {
        const na = Number(a), nb = Number(b);
        if (!isFinite(na) || !isFinite(nb)) {
          // fallback to string compare
          const sa = String(a), sb = String(b);
          if (sa === sb) return 0;
          return sa > sb ? 1 : -1;
        } else {
          if (na === nb) return 0;
          return na > nb ? 1 : -1;
        }
      }

      /* Render functions */
      function computeBarLayout(n) {
        const wrapRect = barWrap.getBoundingClientRect();
        const totalWidth = Math.max(200, wrapRect.width - 12); // guard
        // choose bar width to fit n items with GAP spacing
        const maxTotalGaps = (n - 1) * GAP;
        let barWidth = Math.floor((totalWidth - maxTotalGaps) / n);
        barWidth = clamp(barWidth, BAR_MIN_WIDTH, BAR_MAX_WIDTH);
        // recompute starting left to center the bars
        const usedWidth = barWidth * n + (n - 1) * GAP;
        const startX = Math.max(8, (totalWidth - usedWidth) / 2) + 6; // +6 for wrap padding
        return { barWidth, gap: GAP, startX };
      }

      function renderInitialBars(arr) {
        barWrap.innerHTML = '';
        const n = arr.length;
        const layout = computeBarLayout(n);
        arr.forEach((item, idx) => {
          const div = document.createElement('div');
          div.className = 'bar';
          div.setAttribute('data-id', item.id);
          div.setAttribute('data-index', idx);
          div.setAttribute('role', 'img');
          div.setAttribute('aria-label', 'Value ' + item.value + ' at index ' + idx);
          div.style.width = layout.barWidth + 'px';
          const height = 28 + Math.round((item.value / (Math.max(...arr.map(x => x.value)) + 1)) * 92);
          div.style.height = Math.max(32, height) + 'px';
          div.style.left = (layout.startX + idx * (layout.barWidth + layout.gap)) + 'px';
          div.style.transform = 'translateY(0px)';
          div.innerHTML = '<span class="value">' + item.value + '</span>';
          barWrap.appendChild(div);
        });
      }

      function applyStepVisual(step) {
        // step.items: array with index and status
        const items = step.items;
        const n = items.length;
        const layout = computeBarLayout(n);

        // Update each bar DOM element or create if missing
        items.forEach(it => {
          let node = barWrap.querySelector('[data-id="' + it.id + '"]');
          if (!node) {
            // create fallback
            node = document.createElement('div');
            node.className = 'bar';
            node.setAttribute('data-id', it.id);
            node.innerHTML = '<span class="value">' + it.value + '</span>';
            barWrap.appendChild(node);
          }
          // position
          const left = layout.startX + it.index * (layout.barWidth + layout.gap);
          node.style.width = layout.barWidth + 'px';
          node.style.left = left + 'px';
          // height based on actual value relative to maximum in this snapshot
          const maxVal = Math.max(...items.map(x => Number(x.value) || 0), 1);
          const h = 28 + Math.round((Number(it.value) / (maxVal + 1)) * 92);
          node.style.height = Math.max(32, h) + 'px';
          // statuses
          node.classList.remove('status-key', 'status-comparing', 'status-sorted', 'status-shifted');
          if (it.status === 'key') node.classList.add('status-key');
          if (it.status === 'comparing') node.classList.add('status-comparing');
          if (it.status === 'sorted') node.classList.add('status-sorted');
          if (it.status === 'shifted') node.classList.add('status-comparing');
          // update value text in case it's changed (shouldn't change)
          const span = node.querySelector('.value');
          if (span) span.textContent = it.value;
          node.style.transition = 'transform 260ms cubic-bezier(.2,.9,.2,1), left 260ms ease';
          // compute transform for "lifted" key: status-key uses translateY(-30px) already via CSS
          node.style.transform = 'translateY(0px)';
          if (it.status === 'key') {
            node.style.transform = 'translateY(-30px)';
            node.style.zIndex = 40;
          } else {
            node.style.zIndex = 10;
          }
        });

        // update pseudo-code highlighting and explanation
        updatePseudoAndExplanation(step.meta || {});
      }

      function updatePseudoAndExplanation(meta) {
        // clear highlights
        const lines = pseudo.querySelectorAll('.line');
        lines.forEach(l => l.classList.remove('active'));
        // highlight line if present
        if (meta && typeof meta.line === 'number' && meta.line > 0) {
          const target = pseudo.querySelector('.line[data-line="' + meta.line + '"]');
          if (target) target.classList.add('active');
        }
        // update explain text and status bar
        const desc = (meta && meta.desc) ? meta.desc : (meta.action || 'Stepping');
        statusDesc.textContent = desc;
        statusStep.textContent = 'Step: ' + (stepIndex + 1) + ' / ' + steps.length;
        // accessible announcement
        const live = document.createElement('div');
        live.setAttribute('aria-live', 'polite');
        live.style.position = 'absolute';
        live.style.left = '-9999px';
        live.textContent = desc;
        document.body.appendChild(live);
        setTimeout(() => { document.body.removeChild(live); }, 700);
      }

      /* Playback / stepping */
      function goToStep(idx) {
        stepIndex = clamp(idx, 0, Math.max(0, steps.length - 1));
        applyStepVisual(steps[stepIndex]);
        // update play controls state
        btnPlay.textContent = playing ? 'Pause' : 'Play';
      }

      function stepForward() {
        if (steps.length === 0) return;
        if (stepIndex < steps.length - 1) {
          goToStep(stepIndex + 1);
        } else {
          // already at end
          playing = false;
          clearInterval(playTimer);
          btnPlay.textContent = 'Play';
        }
      }

      function stepBackward() {
        if (steps.length === 0) return;
        if (stepIndex > 0) {
          goToStep(stepIndex - 1);
        }
      }

      function play() {
        if (playing) {
          // pause
          playing = false;
          clearInterval(playTimer);
          btnPlay.textContent = 'Play';
          return;
        }
        if (steps.length === 0) return;
        playing = true;
        btnPlay.textContent = 'Pause';
        const interval = clamp(700 / playSpeed, 120, 1200);
        clearInterval(playTimer);
        playTimer = setInterval(() => {
          if (stepIndex >= steps.length - 1) {
            clearInterval(playTimer);
            playing = false;
            btnPlay.textContent = 'Play';
          } else {
            stepForward();
          }
        }, interval);
      }

      /* Public actions */
      function createRandom() {
        const n = clamp(Number(inputSize.value) || 8, 3, 12);
        baseArray = randArray(n);
        buildAndRender(baseArray);
      }

      function buildAndRender(arr) {
        // recalc steps
        steps = buildStepsFromArray(arr);
        // initial render of bars using base array current order (first snapshot)
        renderInitialBars(arr);
        // go to initial snapshot (index 0)
        stepIndex = -1;
        stepForward();
      }

      function setFromInput() {
        const s = inputValues.value.trim();
        if (!s) return;
        const vals = setBaseArrayFromValuesString(s);
        if (!vals) {
          alert('Please provide a comma-separated list of values.');
          return;
        }
        baseArray = vals;
        inputSize.value = baseArray.length;
        buildAndRender(baseArray);
      }

      function resetToOriginal() {
        // rebuild steps from current baseArray
        buildAndRender(baseArray);
        playing = false;
        clearInterval(playTimer);
        btnPlay.textContent = 'Play';
      }

      /* Event listeners wiring */
      btnRandom.addEventListener('click', () => {
        createRandom();
      });

      btnSet.addEventListener('click', () => {
        setFromInput();
      });

      btnStep.addEventListener('click', () => {
        playing = false; clearInterval(playTimer); btnPlay.textContent = 'Play';
        stepForward();
      });

      btnBack.addEventListener('click', () => {
        playing = false; clearInterval(playTimer); btnPlay.textContent = 'Play';
        stepBackward();
      });

      btnPlay.addEventListener('click', () => {
        play();
      });

      btnReset.addEventListener('click', () => {
        resetToOriginal();
      });

      speedInput.addEventListener('input', (e) => {
        playSpeed = Number(e.target.value) || 1;
        speedLabel.textContent = playSpeed.toFixed(1) + 'x';
      });

      // Allow pressing Space to step forward when the visualization is focused
      barWrap.addEventListener('keydown', (e) => {
        if (e.key === ' ' || e.key === 'Spacebar') {
          e.preventDefault();
          stepForward();
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          stepForward();
        } else if (e.key === 'ArrowLeft') {
          e.preventDefault();
          stepBackward();
        }
      });

      // Responsive: recalc bar layout on resize, and re-apply current step visually
      let resizeTimer = null;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          if (steps.length > 0 && stepIndex >= 0) applyStepVisual(steps[stepIndex]);
        }, 150);
      });

      // Keyboard shortcuts for control buttons (global)
      window.addEventListener('keydown', (e) => {
        if (e.target && ['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return; // ignore while typing
        if (e.key === 'p') { e.preventDefault(); play(); }
        if (e.key === 'ArrowRight') { e.preventDefault(); stepForward(); }
        if (e.key === 'ArrowLeft') { e.preventDefault(); stepBackward(); }
        if (e.key === 'r') { e.preventDefault(); createRandom(); }
      });

      /* Initialize default content */
      (function init() {
        baseArray = randArray(Number(inputSize.value) || 8);
        renderInitialBars(baseArray);
        steps = buildStepsFromArray(baseArray);
        stepIndex = -1;
        stepForward();
        // show speed default
        speedLabel.textContent = speedInput.value + 'x';
      })();

    })();
  </script>
</body>
</html>