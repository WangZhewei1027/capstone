<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fibonacci Interactive Module</title>
<style>
  :root{
    --pad: 24px;
    --gap: 16px;
    --bg: #0f1724;
    --panel: #0b1220;
    --accent: #ffb86b;
    --accent-2: #7ee7c9;
    --muted: #9aa4b2;
    --white: #f8fafc;
    --danger: #ff6b6b;
  }
  /* Safe area margins */
  html,body{height:100%;}
  body{
    margin:0;
    padding:var(--pad);
    background:linear-gradient(180deg,#071025 0%, #07187a 100%);
    color:var(--white);
    font-family:Inter, Roboto, "Helvetica Neue", Arial, sans-serif;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    box-sizing:border-box;
  }
  *{box-sizing:inherit;}
  /* Layout */
  .container{
    display:flex;
    gap:var(--gap);
    align-items:flex-start;
    justify-content:stretch;
    min-height: calc(100vh - calc(var(--pad) * 2));
  }
  /* Left column controls */
  .panel{
    flex:0 0 380px;
    max-width:420px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px;
    padding:18px;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
  }
  h1{
    margin:0 0 8px 0;
    font-size:20px;
    line-height:1.15;
  }
  p.lead{
    margin:0 0 12px 0;
    color:var(--muted);
    font-size:13px;
  }
  .controls{display:flex;flex-direction:column;gap:var(--gap);margin-top:8px;}
  label.small{font-size:12px;color:var(--muted);display:block;margin-bottom:6px;}
  .row{display:flex;gap:12px;align-items:center;}
  input[type="range"]{
    width:100%;
    appearance:none;
    height:6px;
    background:linear-gradient(90deg,var(--accent),var(--accent-2));
    border-radius:6px;
    outline:none;
  }
  .btn{
    background:linear-gradient(180deg,#1b2430,#0f1724);
    color:var(--white);
    border:1px solid rgba(255,255,255,0.06);
    padding:8px 12px;
    border-radius:8px;
    cursor:pointer;
    font-size:14px;
  }
  .btn:focus{outline:2px solid rgba(255,184,107,0.25);}
  .btn.small{padding:6px 8px;font-size:13px;}
  .btn.primary{
    background:linear-gradient(180deg,#ffb86b,#ff9f3f);
    color:#071026;
    border:none;
  }
  .btn.secondary{
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    color:var(--white);
  }
  .controls .actions{display:flex;gap:8px;flex-wrap:wrap;}
  input[type="number"]{
    width:84px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);
    background:transparent;color:var(--white);
  }
  .formula{
    font-family:monospace;
    background:rgba(255,255,255,0.02);
    padding:10px;border-radius:8px;color:var(--accent-2);
    font-size:14px;
  }
  .list{
    margin-top:8px;
    background:rgba(255,255,255,0.01);
    padding:10px;border-radius:8px;
    color:var(--muted);
    font-size:13px;
  }
  .list .term{display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px dashed rgba(255,255,255,0.02);}
  .list .term:last-child{border-bottom:none;}
  .ratio{
    display:flex;gap:8px;align-items:center;
  }
  .ratio .barbg{background:#091019;border-radius:10px;height:10px;flex:1;overflow:hidden;}
  .ratio .bar{height:10px;background:linear-gradient(90deg,var(--accent),var(--accent-2));width:0%;transition:width 600ms ease;}
  /* Right visual stage */
  .stage{
    flex:1 1 auto;
    min-width:0;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px;
    padding:18px;
    display:flex;
    flex-direction:column;
    gap:var(--gap);
    align-items:stretch;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
  }
  .stage-header{display:flex;justify-content:space-between;align-items:baseline;gap:12px;}
  .stage h2{margin:0;font-size:16px;}
  .visual{
    display:flex;
    gap:var(--gap);
    align-items:flex-start;
    justify-content:center;
    flex-wrap:wrap;
  }
  .combine{
    flex:1 1 420px;
    min-height:320px;
    max-width:720px;
    background:linear-gradient(180deg,#081325 0%,#051024 100%);
    border-radius:10px;
    padding:14px;
    position:relative;
    overflow:hidden;
    border:1px solid rgba(255,255,255,0.02);
  }
  .combine .stage-title{color:var(--muted);font-size:13px;margin-bottom:8px;}
  /* square container */
  .square-area{
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    pointer-events:none;
  }
  .sq{
    position:absolute;
    box-sizing:border-box;
    display:flex;
    align-items:center;
    justify-content:center;
    color:#072024;
    font-weight:700;
    border-radius:6px;
    transition:transform 650ms cubic-bezier(.2,.9,.2,1), opacity 350ms ease;
    transform-origin:center center;
  }
  .sq.small{border-radius:6px;}
  .sq.label{pointer-events:auto;}
  .sq .num{font-family:monospace;color:rgba(7,32,36,0.95);font-weight:700;}
  .sq.col-1{background:linear-gradient(180deg,#ffdab2,#ffd29a);border:1px solid rgba(255,184,107,0.4);}
  .sq.col-2{background:linear-gradient(180deg,#bfffe8,#8ef0d3);border:1px solid rgba(126,231,201,0.25);}
  .sq.col-new{background:linear-gradient(180deg,#ffe2bb,#ffd78e);border:2px solid rgba(255,159,63,0.15);}
  /* Bar chart */
  .chart{
    flex:1 1 280px;
    min-width:240px;
    background:linear-gradient(180deg,#071423,#031226);
    border-radius:8px;
    padding:12px;
    color:var(--muted);
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .chart .bars{display:flex;align-items:end;gap:8px;height:160px;padding:8px 6px;background:transparent;border-radius:6px;}
  .bar{
    width:28px;background:linear-gradient(180deg,#ffb86b,#ffd79e);
    border-radius:6px 6px 4px 4px;display:flex;align-items:flex-end;justify-content:center;
    transition:height 700ms cubic-bezier(.2,.9,.2,1), transform 300ms ease, opacity 300ms ease;
    position:relative;cursor:pointer;
  }
  .bar:focus{outline:2px solid rgba(255,184,107,0.2);}
  .bar .vlabel{position:absolute;bottom:100%;font-size:12px;padding:4px 6px;margin-bottom:6px;border-radius:6px;background:rgba(4,8,12,0.8);color:var(--white);white-space:nowrap;transform:translateY(-6px);opacity:0;transition:opacity 180ms, transform 180ms;}
  .bar:hover .vlabel,.bar:focus .vlabel{opacity:1;transform:translateY(0);}
  .bar.latest{box-shadow:0 6px 18px rgba(255,184,107,0.12);transform:scale(1.04);}
  .chart .axis{font-size:12px;color:var(--muted);display:flex;justify-content:space-between;}
  /* small helper */
  .muted{color:var(--muted);font-size:13px;}
  /* responsive */
  @media (max-width:880px){
    .container{flex-direction:column;}
    .panel{max-width:100%;}
    .stage{max-width:100%;}
  }
</style>
</head>
<body>
  <div class="container" role="main">
    <aside class="panel" aria-labelledby="title">
      <h1 id="title">Fibonacci Sequence — Build & Explore</h1>
      <p class="lead">Watch two previous Fibonacci squares combine to form the next term, observe growth in a bar chart, and see how consecutive ratios approach the golden ratio.</p>

      <div class="controls" aria-label="Controls">
        <div>
          <label class="small" for="countRange">Number of terms (2–12)</label>
          <input id="countRange" type="range" min="2" max="12" value="6" aria-valuemin="2" aria-valuemax="12" />
        </div>

        <div class="actions" role="group" aria-label="Playback controls">
          <button class="btn small" id="stepBack" title="Previous term" aria-label="Previous term">◀ Prev</button>
          <button class="btn primary small" id="stepForward" title="Next term" aria-label="Next term">Next ▶</button>
          <button class="btn small" id="playPause" aria-pressed="false" aria-label="Play or pause autoplay">Play ▶</button>
          <button class="btn small" id="resetBtn" aria-label="Reset">Reset</button>
          <label class="small" style="margin-left:auto;">Go to:</label>
          <input id="gotoInput" type="number" min="2" max="12" value="6" aria-label="Jump to term" />
        </div>

        <div>
          <div class="formula" aria-hidden="false">
            Recurrence: a(n) = a(n‑1) + a(n‑2) — starting with a(1)=1, a(2)=1
          </div>
        </div>

        <div class="list" aria-live="polite">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
            <strong>Sequence & Ratios</strong>
            <span class="muted">latest ratio → golden ratio</span>
          </div>
          <div id="sequenceList" class="seq-list" role="list" style="max-height:220px;overflow:auto;"></div>
        </div>
      </div>
    </aside>

    <section class="stage" aria-labelledby="stageTitle">
      <div class="stage-header">
        <h2 id="stageTitle">Visual Demonstration</h2>
        <div class="muted">Interactive demonstration of the recurrence and convergence</div>
      </div>

      <div class="visual" role="region" aria-label="Visualizations">
        <div class="combine" aria-live="polite" aria-atomic="true">
          <div class="stage-title">Combine Animation</div>
          <div class="square-area" id="squareArea" aria-hidden="false">
            <!-- dynamic squares will be injected here -->
          </div>
        </div>

        <div class="chart" aria-label="Bar chart and ratios">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div><strong>Bar Chart</strong></div>
            <div class="muted">Heights ∝ term value</div>
          </div>
          <div class="bars" id="barsArea" role="list" aria-label="Fibonacci bars"></div>
          <div class="axis" aria-hidden="false">
            <div id="ratioText">Ratio: —</div>
            <div style="display:flex;gap:12px;align-items:center;width:50%;">
              <div class="muted">Convergence</div>
              <div style="flex:1;">
                <div class="barbg" aria-hidden="true"><div id="convBar" class="bar" style="width:0%"></div></div>
              </div>
            </div>
          </div>
        </div>
      </div>

    </section>
  </div>

<script>
(function(){
  // Utility & state
  const MAX_TERMS = 12;
  const MIN_TERMS = 2;
  let fib = [1,1];
  for(let i=2;i<MAX_TERMS;i++) fib[i]=fib[i-1]+fib[i-2];

  let state = {
    count: 6,
    playing: false,
    intervalId: null,
    phi: (1+Math.sqrt(5))/2
  };

  // Elements
  const countRange = document.getElementById('countRange');
  const gotoInput = document.getElementById('gotoInput');
  const stepForward = document.getElementById('stepForward');
  const stepBack = document.getElementById('stepBack');
  const playPause = document.getElementById('playPause');
  const resetBtn = document.getElementById('resetBtn');
  const sequenceList = document.getElementById('sequenceList');
  const barsArea = document.getElementById('barsArea');
  const ratioText = document.getElementById('ratioText');
  const convBar = document.getElementById('convBar');
  const squareArea = document.getElementById('squareArea');

  // Initialize controls
  function syncControls() {
    countRange.value = state.count;
    gotoInput.value = state.count;
  }

  // Render the sequence list and bar chart
  function renderAll() {
    renderList();
    renderBars();
    renderCombineStageInitial();
    updateRatioDisplay();
  }

  function renderList() {
    sequenceList.innerHTML = '';
    for(let i=0;i<state.count;i++){
      const item = document.createElement('div');
      item.className = 'term';
      item.setAttribute('role','listitem');
      const idx = document.createElement('div');
      idx.textContent = 'a(' + (i+1) + ')';
      const val = document.createElement('div');
      val.textContent = fib[i];
      item.appendChild(idx);
      item.appendChild(val);
      sequenceList.appendChild(item);
    }
  }

  function renderBars() {
    barsArea.innerHTML = '';
    // compute maximum for scaling
    const visible = fib.slice(0, state.count);
    const maxVal = Math.max(...visible);
    visible.forEach((v, i) => {
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.setAttribute('tabindex','0');
      bar.setAttribute('role','button');
      const label = document.createElement('div');
      label.className = 'vlabel';
      label.textContent = 'a(' + (i+1) + ') = ' + v;
      bar.appendChild(label);
      // scale height to max 100%
      const frac = v / maxVal;
      bar.style.height = (frac * 100) + '%';
      if(i === state.count-1) bar.classList.add('latest');
      // accessible click
      bar.addEventListener('click',()=> {
        flashBar(bar);
      });
      bar.addEventListener('keydown',(e)=>{
        if(e.key==='Enter' || e.key === ' ') { e.preventDefault(); flashBar(bar); }
      });
      barsArea.appendChild(bar);
    });
  }

  function flashBar(bar){
    bar.classList.add('latest');
    setTimeout(()=>bar.classList.remove('latest'),800);
  }

  // Ratio display update
  function updateRatioDisplay() {
    if(state.count >= 2) {
      const last = fib[state.count-1];
      const prev = fib[state.count-2];
      const ratio = last/prev;
      ratioText.textContent = 'Ratio a(n)/a(n-1): ' + ratio.toFixed(6);
      // compute closeness to phi on [0..1] via 1/(1+abs(diff)) normalized to percent
      const diff = Math.abs(ratio - state.phi);
      // transform diff to a simple convergence metric: small diff -> larger %
      const conv = Math.max(0, Math.min(1, 1 - Math.min(1, diff / 1.0)));
      convBar.style.width = Math.round(conv * 100) + '%';
    } else {
      ratioText.textContent = 'Ratio a(n)/a(n-1): —';
      convBar.style.width = '0%';
    }
  }

  // Combine animation: illustrate a(n) = a(n-1) + a(n-2)
  function renderCombineStageInitial() {
    squareArea.innerHTML = '';
    // Show the last two as stacked smaller views if count<=2
    const N = state.count;
    // For the initial static view, show up to last three squares for context:
    const showIndex = Math.max(0, N-1);
    const sizes = fib.slice(0, N);
    // Draw the most recent square centered
    const s = sizes[showIndex];
    const MAX_STAGE = Math.min(squareArea.clientWidth, squareArea.clientHeight) - 24;
    const scale = Math.max(1, Math.floor(MAX_STAGE / Math.max(s, 1)));
    // create a simple prominent square representing a(n)
    const sq = document.createElement('div');
    sq.className = 'sq col-new label';
    const sizePx = Math.max(48, s * 6); // friendly minimal
    sq.style.width = sizePx + 'px';
    sq.style.height = sizePx + 'px';
    sq.style.opacity = '1';
    sq.style.transform = 'translate(0,0) scale(1)';
    const num = document.createElement('div');
    num.className = 'num';
    num.textContent = s;
    sq.appendChild(num);
    squareArea.appendChild(sq);

    // show the two previous below for context
    if(N >= 2) {
      const s1 = sizes[N-2], s2 = sizes[N-1];
      // smaller visuals to the left and right
      const left = document.createElement('div');
      left.className = 'sq col-1';
      left.style.width = Math.max(36, s1*4) + 'px';
      left.style.height = Math.max(36, s1*4) + 'px';
      left.style.left = '20%';
      left.style.top = '60%';
      left.style.transform = 'translate(-50%,-50%)';
      left.style.opacity = '0.95';
      left.innerHTML = '<div class="num">' + s1 + '</div>';
      left.style.position = 'absolute';
      const right = document.createElement('div');
      right.className = 'sq col-2';
      right.style.width = Math.max(36, s2*4) + 'px';
      right.style.height = Math.max(36, s2*4) + 'px';
      right.style.right = '20%';
      right.style.top = '60%';
      right.style.transform = 'translate(50%,-50%)';
      right.style.position = 'absolute';
      right.innerHTML = '<div class="num">' + s2 + '</div>';
      squareArea.appendChild(left);
      squareArea.appendChild(right);
    }
  }

  // Animate the addition of the next term (combine two previous squares into new)
  let animating = false;
  function animateAddNext() {
    if(animating) return;
    if(state.count >= MAX_TERMS) return;
    animating = true;
    // Prepare sizes
    const a = fib[state.count-2];
    const b = fib[state.count-1];
    const next = a + b;
    // compute scale to fit in squareArea
    const pad = 20;
    const areaW = squareArea.clientWidth - pad*2;
    const areaH = squareArea.clientHeight - pad*2;
    const maxSide = Math.min(areaW, areaH);
    const unit = Math.max(2, Math.floor(maxSide / next)); // pixels per unit
    const maxSidePx = next * unit;

    squareArea.innerHTML = '';

    // Container to center everything
    const container = document.createElement('div');
    container.style.position = 'absolute';
    container.style.left = '50%';
    container.style.top = '50%';
    container.style.transform = 'translate(-50%,-50%)';
    container.style.width = maxSidePx + 'px';
    container.style.height = maxSidePx + 'px';
    container.style.display = 'block';
    container.style.pointerEvents = 'none';
    squareArea.appendChild(container);

    // create new square (hidden) as background
    const newSq = document.createElement('div');
    newSq.className = 'sq col-new';
    newSq.style.width = maxSidePx + 'px';
    newSq.style.height = maxSidePx + 'px';
    newSq.style.left = '0px';
    newSq.style.top = '0px';
    newSq.style.position = 'absolute';
    newSq.style.opacity = '0';
    newSq.style.display = 'flex';
    newSq.style.alignItems = 'center';
    newSq.style.justifyContent = 'center';
    newSq.innerHTML = '<div class="num">' + next + '</div>';
    container.appendChild(newSq);

    // Create small square representing b (a(n-1)) and a (a(n-2))
    const sqB = document.createElement('div');
    sqB.className = 'sq col-2';
    const bPx = b * unit;
    sqB.style.width = bPx + 'px';
    sqB.style.height = bPx + 'px';
    sqB.style.position = 'absolute';
    // start off-left slightly outside
    sqB.style.left = (-bPx - 30) + 'px';
    sqB.style.top = Math.round((maxSidePx - bPx) / 2) + 'px';
    sqB.innerHTML = '<div class="num">' + b + '</div>';
    container.appendChild(sqB);

    const sqA = document.createElement('div');
    sqA.className = 'sq col-1';
    const aPx = a * unit;
    sqA.style.width = aPx + 'px';
    sqA.style.height = aPx + 'px';
    sqA.style.position = 'absolute';
    // start off-right slightly outside
    sqA.style.left = (maxSidePx + 30) + 'px';
    sqA.style.top = Math.round((maxSidePx - aPx) / 2) + 'px';
    sqA.innerHTML = '<div class="num">' + a + '</div>';
    container.appendChild(sqA);

    // Force reflow then animate: slide them into positions inside new square to visually fill left & right
    requestAnimationFrame(()=> {
      // target positions inside newSq: place B on left at x=0, A on right at x=bPx
      sqB.style.transition = 'transform 700ms cubic-bezier(.2,.9,.2,1), left 700ms cubic-bezier(.2,.9,.2,1), top 700ms';
      sqA.style.transition = 'transform 700ms cubic-bezier(.2,.9,.2,1), left 700ms cubic-bezier(.2,.9,.2,1), top 700ms';

      // Move them to inside container
      sqB.style.left = '0px';
      sqB.style.top = Math.round((maxSidePx - bPx) / 2) + 'px';
      sqA.style.left = bPx + 'px';
      sqA.style.top = Math.round((maxSidePx - aPx) / 2) + 'px';
      // fade in new square after a short delay
      setTimeout(()=> {
        newSq.style.transition = 'opacity 420ms ease, transform 420ms ease';
        newSq.style.opacity = '1';
        // briefly pulse the new square
        newSq.style.transform = 'scale(0.98)';
        setTimeout(()=> newSq.style.transform = 'scale(1)', 420);
      }, 260);

      // After animation completes: finalize state and rebuild visuals
      setTimeout(()=> {
        // increment the count
        state.count++;
        syncControls();
        renderList();
        renderBars();
        updateRatioDisplay();
        // cleanup and show final single square centered (use newSq as main)
        squareArea.innerHTML = '';
        const final = document.createElement('div');
        final.className = 'sq col-new label';
        final.style.width = (Math.max(48, next*6)) + 'px';
        final.style.height = (Math.max(48, next*6)) + 'px';
        final.style.margin = 'auto';
        final.style.position = 'relative';
        final.style.left = '0';
        final.style.top = '0';
        final.style.opacity = '1';
        final.innerHTML = '<div class="num">' + next + '</div>';
        squareArea.appendChild(final);

        animating = false;
      }, 1000);
    });
  }

  function animateRemoveLast() {
    // remove last term visually with small fade out
    if(animating) return;
    if(state.count <= MIN_TERMS) return;
    animating = true;
    // update state
    state.count--;
    syncControls();
    // quick animation: reduce bar, fade square
    renderBars();
    squareArea.querySelectorAll('.sq').forEach(s=> {
      s.style.transition = 'opacity 300ms ease, transform 300ms ease';
      s.style.opacity = '0';
      s.style.transform = 'scale(0.96)';
    });
    setTimeout(()=> {
      renderCombineStageInitial();
      renderList();
      updateRatioDisplay();
      animating = false;
    }, 360);
  }

  // Event handlers
  countRange.addEventListener('input', (e)=>{
    const v = parseInt(e.target.value,10);
    state.count = Math.min(MAX_TERMS, Math.max(MIN_TERMS, v));
    syncControls();
    renderAll();
  });

  gotoInput.addEventListener('change', (e)=>{
    let v = parseInt(e.target.value,10);
    if(isNaN(v)) v = state.count;
    v = Math.max(MIN_TERMS, Math.min(MAX_TERMS, v));
    // animate forward/back to reach v
    (async function(){
      // If jump is forward, step with animation
      while(state.count < v){
        await performStepForwardWithPromise();
      }
      while(state.count > v){
        animateRemoveLast();
        // wait a little
        await new Promise(r=>setTimeout(r,380));
      }
    })();
  });

  function performStepForwardWithPromise(){
    return new Promise(resolve=>{
      // attach temporary listener to detect animating finished
      const before = state.count;
      // We wrap animateAddNext and then set interval to check when state.count increased
      animateAddNext();
      const id = setInterval(()=>{
        if(state.count > before) {
          clearInterval(id);
          resolve();
        }
      },120);
    });
  }

  stepForward.addEventListener('click', ()=>{
    if(state.count >= MAX_TERMS) return;
    animateAddNext();
  });
  stepBack.addEventListener('click', ()=>{
    animateRemoveLast();
  });

  playPause.addEventListener('click', ()=>{
    state.playing = !state.playing;
    playPause.setAttribute('aria-pressed', String(state.playing));
    playPause.textContent = state.playing ? 'Pause ❚❚' : 'Play ▶';
    if(state.playing){
      state.intervalId = setInterval(()=>{
        if(state.count >= MAX_TERMS){ clearInterval(state.intervalId); state.playing=false; playPause.textContent='Play ▶'; playPause.setAttribute('aria-pressed','false'); return; }
        animateAddNext();
      }, 1100);
    } else {
      clearInterval(state.intervalId);
      state.intervalId = null;
    }
  });

  resetBtn.addEventListener('click', ()=>{
    if(animating) return;
    state.count = 2;
    syncControls();
    renderAll();
  });

  // keyboard shortcuts
  window.addEventListener('keydown',(e)=>{
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON')) return;
    if(e.key === 'ArrowRight') stepForward.click();
    if(e.key === 'ArrowLeft') stepBack.click();
    if(e.key === ' ') { e.preventDefault(); playPause.click(); }
  });

  // Initial render
  syncControls();
  renderAll();

  // Small resize handler to re-render visuals to keep sizes appropriate
  let resizeTimer;
  window.addEventListener('resize', ()=>{
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=> renderCombineStageInitial(), 160);
  });

})();
</script>
</body>
</html>