<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Huffman Coding — Interactive Module</title>
  <style>
    :root{
      --safe: 24px;
      --gap: 16px;
      --bg: #0f1720;
      --card: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --surface: #0b1220;
      --white: #e6eef6;
      --maxwidth: 1200px;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#071426 0%, #071827 60%);
      color:var(--white);
    }
    .app{
      box-sizing: border-box;
      padding: var(--safe);
      min-height:100%;
      display:flex;
      justify-content:center;
    }
    .frame{
      width:100%;
      max-width: var(--maxwidth);
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    header{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    h1{
      font-size:20px;
      margin:0;
      color:var(--accent);
      letter-spacing:0.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    .panel{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      flex-wrap:wrap;
    }

    /* Left column controls and descriptions */
    .left{
      flex:1 1 360px;
      min-width:320px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      padding:16px;
      border-radius:8px;
      box-shadow: 0 2px 10px rgba(2,6,23,0.6);
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      padding:12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
    }
    label{
      display:block;
      font-size:13px;
      color:var(--muted);
      margin-bottom:8px;
    }
    textarea,input[type="text"]{
      width:100%;
      box-sizing:border-box;
      padding:10px;
      font-size:14px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.06);
      background:rgba(255,255,255,0.01);
      color:var(--white);
      resize:vertical;
    }
    .controls-row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    button{
      background:linear-gradient(180deg, var(--accent), #0295a8);
      color:#042127;
      border:none;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      min-height:40px;
      box-shadow: 0 6px 18px rgba(5,150,162,0.12);
    }
    button.ghost{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--white);
      box-shadow:none;
    }
    .hint{
      font-size:13px;
      color:var(--muted);
    }

    /* Right column visualization */
    .right{
      flex:1 1 480px;
      min-width:360px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      padding:12px;
      border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      border:1px solid rgba(255,255,255,0.03);
    }

    .viz-top{
      display:flex;
      gap:var(--gap);
      align-items:center;
      justify-content:space-between;
    }
    .queue{
      background:rgba(255,255,255,0.02);
      padding:12px;
      border-radius:8px;
      min-height:84px;
      display:flex;
      align-items:end;
      gap:12px;
      overflow-x:auto;
      scrollbar-width:thin;
    }
    .bar{
      width:48px;
      min-width:40px;
      background:linear-gradient(180deg,#14424a,#0b2d33);
      border-radius:6px 6px 4px 4px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:var(--white);
      font-size:13px;
      padding:6px 4px;
      box-sizing:border-box;
      transition: transform 400ms ease, opacity 300ms ease;
      position:relative;
    }
    .bar .label{
      position:absolute;
      top:6px;
      font-weight:700;
      font-size:12px;
      color:var(--accent);
    }
    .bar .freq{
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
    }
    .bar.merged{
      background:linear-gradient(180deg,#3b82f6,#1e40af);
      box-shadow:0 6px 20px rgba(59,130,246,0.12);
      color:#f8fbff;
    }

    /* Tree SVG area */
    .treebox{
      background:rgba(255,255,255,0.01);
      border-radius:8px;
      padding:8px;
      flex:1 1 auto;
      min-height:280px;
      position:relative;
      overflow:auto;
    }
    svg{
      width:100%;
      height:100%;
    }
    .node{
      cursor:pointer;
      transition: transform 250ms ease, opacity 200ms;
    }
    .node circle{
      fill:#032a2f;
      stroke:var(--accent);
      stroke-width:1.5px;
    }
    .node text{
      fill:var(--white);
      font-size:12px;
      pointer-events:none;
    }
    .edge{
      stroke:rgba(255,255,255,0.06);
      stroke-width:1.6px;
    }
    .edge.label{
      fill:var(--muted);
      font-size:12px;
    }

    /* Codes table */
    .codes{
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height:200px;
      overflow:auto;
      padding:8px;
      border-radius:6px;
      background:rgba(255,255,255,0.01);
    }
    .code-item{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      padding:8px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.02);
      transition: background 180ms;
    }
    .code-item:hover{ background: rgba(255,255,255,0.01); }
    .code-symbol{
      font-weight:700;
      color:var(--accent);
      min-width:28px;
    }
    .stats{
      font-size:13px;
      color:var(--muted);
    }

    /* Small screen adjustments */
    @media (max-width:880px){
      .panel{ flex-direction:column; }
      .right{ order: -1; }
    }

    /* Simple focus outlines for accessibility */
    button:focus, input:focus, textarea:focus{
      outline:3px solid rgba(6,182,212,0.12);
      outline-offset:2px;
    }

    /* subtle animation classes */
    .pulse{
      animation: pulse 900ms ease-in-out;
    }
    @keyframes pulse{
      0%{ transform:scale(1); }
      50%{ transform:scale(1.06); }
      100%{ transform:scale(1); }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Huffman Coding interactive module">
    <div class="frame" role="region">
      <header>
        <h1>Huffman Coding — Build and Visualize Optimal Prefix Codes</h1>
        <p class="subtitle">Interactively build a Huffman tree from input text or custom frequencies. Step through merges, watch the tree form, and inspect resulting prefix codes and compression stats.</p>
      </header>

      <!-- Explanatory planning sections -->
      <section class="panel" aria-labelledby="plan-heading">
        <div class="left card" id="plan" style="gap:16px;">
          <div>
            <strong>Concept Title</strong>
            <p class="hint">Huffman Coding — greedy construction of optimal prefix-free binary codes</p>
          </div>

          <div>
            <strong>Learning Objective</strong>
            <p class="hint">After using this module, you will understand how Huffman's greedy merge of least-frequent symbols forms a binary tree that assigns short codes to common symbols, how codes are derived from tree paths, and how that produces compression.</p>
          </div>

          <div>
            <strong>Interaction Design</strong>
            <p class="hint">
              - Enter a piece of text or provide frequency pairs. The module computes symbol frequencies and displays them as an animated priority queue (bars).
              <br>- Use Step / Play controls to animate successive merges: the two smallest bars fade/move and a new merged bar appears; simultaneously, parent nodes are added to the SVG tree with a brief grow animation.
              <br>- After the tree is complete, a codes table shows the binary code for each symbol. Click any symbol to highlight its path in the tree and to see its code animate.
              <br>- The Encode box shows the encoded bitstring and compression stats; paste a bitstring and use the Decode button to walk the bits down the built tree to retrieve the original symbols.
              <br>- Visual feedback includes fading, pulsing merged nodes, animated tree node additions, and path highlighting to reinforce greedy selection and code derivation.
            </p>
          </div>

          <div>
            <strong>Layout Description</strong>
            <p class="hint">
              Safe area margins: 24px on all sides. Minimum spacing between interactive elements: 16px. The page uses two main columns: left for controls/explanations and right for visualization. Controls (input, buttons) are vertically stacked with at least 16px gaps. Visualization area contains the priority queue bars at the top and an SVG tree below. A codes list and encode/decode panels are beneath the tree. The design is responsive: two columns on wide screens, stacked on narrow screens. All actionable controls include clear labels and keyboard focus styles for accessibility.
            </p>
          </div>
        </div>

        <!-- Right visualization column -->
        <div class="right" aria-live="polite">
          <div class="card" style="display:flex;flex-direction:column;gap:12px;">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div>
                <label for="inputText"><strong>Input text</strong></label>
                <div style="display:flex;gap:12px;align-items:center;">
                  <textarea id="inputText" rows="3" aria-label="Input text for frequency analysis">this is an example for huffman encoding</textarea>
                </div>
              </div>
              <div style="text-align:right;">
                <div class="hint">Controls</div>
                <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px;">
                  <div style="display:flex;gap:8px;">
                    <button id="analyzeBtn">Analyze</button>
                    <button id="randomBtn" class="ghost" title="Fill with a random sample">Sample</button>
                  </div>
                  <div style="display:flex;gap:8px;">
                    <button id="stepBack" class="ghost" title="Step backward">⟵ Step</button>
                    <button id="playPause" class="ghost" title="Play / Pause">▶ Play</button>
                    <button id="stepForward" class="ghost" title="Step forward">Step ⟶</button>
                  </div>
                </div>
              </div>
            </div>

            <div class="viz-top">
              <div>
                <label class="hint">Priority Queue (smallest on left)</label>
                <div class="queue" id="queue" role="list" aria-label="Priority queue visual"></div>
              </div>
              <div style="min-width:220px; text-align:right;">
                <div class="stats" id="freqStats">Symbols: 0 • Total freq: 0</div>
                <div style="height:8px"></div>
                <label class="hint">Animation speed</label>
                <input id="speed" type="range" min="0.3" max="2.0" step="0.1" value="1" aria-label="Animation speed slider">
              </div>
            </div>

            <div class="treebox" id="treebox" aria-label="Huffman tree visualization" style="min-height:300px;">
              <svg id="treeSVG" viewBox="0 0 1200 420" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Huffman tree"></svg>
            </div>

            <div style="display:flex;gap:16px;flex-wrap:wrap;align-items:flex-start;">
              <div style="flex:1 1 240px; min-width:200px;">
                <label class="hint">Codes (click to highlight)</label>
                <div class="codes" id="codesList" aria-live="polite"></div>
              </div>

              <div style="flex:1 1 260px; min-width:220px;">
                <label class="hint">Encode / Decode</label>
                <div style="display:flex;flex-direction:column;gap:8px;">
                  <input id="encodeInput" type="text" placeholder="Text to encode (optional)" aria-label="Text to encode">
                  <div style="display:flex;gap:8px;">
                    <button id="encodeBtn" class="ghost">Encode</button>
                    <button id="decodeBtn" class="ghost">Decode bitstring</button>
                    <button id="copyBtn" class="ghost" title="Copy encoded bits">Copy</button>
                  </div>
                  <textarea id="encodeOutput" rows="2" placeholder="Encoded bitstring / Decoded text" aria-label="Encoded output"></textarea>
                </div>
              </div>
            </div>

          </div>
        </div>
      </section>

      <footer style="display:flex;justify-content:space-between;align-items:center;">
        <div class="hint">Tip: Use short sample texts and try repeated characters to see how Huffman gives them short codes.</div>
        <div class="hint">This module is self-contained, accessible, and responsive.</div>
      </footer>
    </div>
  </div>

  <script>
    // Self-contained Huffman interactive module (vanilla JS)
    (function(){
      // Utilities
      function $(sel){ return document.querySelector(sel); }
      function el(tag, attrs){ const e=document.createElement(tag); for(let k in attrs) e.setAttribute(k, attrs[k]); return e; }

      const inputText = $('#inputText');
      const analyzeBtn = $('#analyzeBtn');
      const randomBtn = $('#randomBtn');
      const queueEl = $('#queue');
      const treeSVG = $('#treeSVG');
      const codesList = $('#codesList');
      const freqStats = $('#freqStats');
      const stepBack = $('#stepBack');
      const playPause = $('#playPause');
      const stepForward = $('#stepForward');
      const speedControl = $('#speed');
      const encodeInput = $('#encodeInput');
      const encodeBtn = $('#encodeBtn');
      const decodeBtn = $('#decodeBtn');
      const encodeOutput = $('#encodeOutput');
      const copyBtn = $('#copyBtn');

      let nodesById = {};   // id -> node
      let steps = [];       // snapshots of queue for animation
      let currentStep = -1;
      let playing = false;
      let playTimer = null;
      let playInterval = 900; // ms adapt by speed
      let root = null;
      let codes = {};
      let nextId = 1;

      function sampleText(){
        const samples = [
          "aaaaabbbbcccdde",
          "the quick brown fox jumps over the lazy dog",
          "huffman huffman huffman code code code code",
          "mississippi",
          "hello hello hello hello hi hi",
          "this is an example for huffman encoding"
        ];
        inputText.value = samples[Math.floor(Math.random()*samples.length)];
      }

      randomBtn.addEventListener('click', ()=>{
        sampleText();
      });

      // Frequency analysis
      function analyzeText(txt){
        const freqs = new Map();
        for (let ch of txt){
          if (ch === '\n' || ch === '\r') continue;
          const key = ch;
          freqs.set(key, (freqs.get(key)||0)+1);
        }
        if (freqs.size === 0){
          // provide a tiny sample default
          freqs.set('a',3); freqs.set('b',2); freqs.set('c',1);
        }
        return freqs;
      }

      // Build Huffman steps and nodes
      function buildHuffman(freqMap){
        nodesById = {};
        steps = [];
        nextId = 1;
        // create initial nodes
        const queue = [];
        for (let [sym,f] of freqMap.entries()){
          const id = nextId++;
          const node = { id, symbols: [sym], symbol: sym, weight: f, left:null, right:null };
          nodesById[id] = node;
          queue.push(node);
        }
        // sort ascending by weight, then by symbol for determinism
        const cmp = (a,b) => a.weight - b.weight || String(a.symbols).localeCompare(String(b.symbols));
        queue.sort(cmp);
        // snapshot
        steps.push(snapshotQueue(queue));

        // build
        while (queue.length > 1){
          // pick two smallest
          const a = queue.shift();
          const b = queue.shift();
          const id = nextId++;
          const parent = { id, symbols: a.symbols.concat(b.symbols), weight: a.weight + b.weight, left:a, right:b };
          nodesById[id] = parent;
          // push back and re-sort
          queue.push(parent);
          queue.sort(cmp);
          steps.push({ action: 'merge', pick: [a.id,b.id], newId: parent.id, queue: snapshotQueue(queue) });
        }

        // final root
        root = queue[0];
        assignCodes(root);
        return { root, steps, nodesById };
      }

      function snapshotQueue(queue){
        // return minimal info array for visualization
        return queue.map(n => ({ id: n.id, symbols: n.symbols.slice(), weight: n.weight, isLeaf: !!n.symbol }));
      }

      function assignCodes(node, prefix=''){
        if (!node) return;
        if (!node.left && !node.right){
          // leaf: symbol
          codes[node.symbol] = prefix || '0'; // single node edge case
        } else {
          assignCodes(node.left, prefix + '0');
          assignCodes(node.right, prefix + '1');
        }
      }

      // Render queue bars
      function renderQueue(snapshot){
        queueEl.innerHTML = '';
        if (!snapshot || snapshot.length === 0) return;
        const maxW = Math.max(...snapshot.map(s=>s.weight));
        for (let s of snapshot){
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.style.height = (40 + (s.weight / maxW) * 120) + 'px';
          bar.setAttribute('data-id', s.id);
          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = s.symbols.length === 1 ? s.symbols[0] : s.symbols.join(',');
          const freq = document.createElement('div');
          freq.className = 'freq';
          freq.textContent = s.weight;
          bar.appendChild(label);
          bar.appendChild(freq);
          queueEl.appendChild(bar);
        }
      }

      // Animation and stepping
      function setStep(index){
        if (index < 0) index = 0;
        if (index >= steps.length) index = steps.length - 1;
        currentStep = index;
        const snap = steps[index];
        if (!snap) return;
        // snap can be either initial snapshot or merge objects; show its queue
        if (snap.queue) renderQueue(snap.queue);
        else renderQueue(snap);

        // Update stats
        const total = (snap.queue || snap).reduce((a,b)=>a+b.weight?a+b.weight:a + b.weight, 0); // fallback
        const syms = (snap.queue || snap).reduce((a,b)=> a + b.symbols.length, 0);
        freqStats.textContent = `Symbols: ${syms} • Total freq: ${(snap.queue || snap).reduce((a,b)=>a+b.weight,0)}`;

        // If this step is a merge, animate merging bars
        if (snap.action === 'merge'){
          animateMerge(snap);
        } else {
          // initial snapshot - brief pulse
          const bars = queueEl.querySelectorAll('.bar');
          bars.forEach(b => b.classList.add('pulse'));
          setTimeout(()=> bars.forEach(b => b.classList.remove('pulse')), 600);
        }

        // If final step, build tree SVG
        if (index === steps.length - 1){
          buildTreeSVG(root);
          renderCodes();
        } else {
          // clear tree until final
          clearTreeSVG();
          clearCodes();
        }
      }

      function animateMerge(snap){
        // highlight the two picked bars (IDs)
        const ids = snap.pick;
        const bars = Array.from(queueEl.querySelectorAll('.bar'));
        bars.forEach(b => {
          const id = Number(b.getAttribute('data-id'));
          if (ids.includes(id)){
            b.style.opacity = '0.18';
            b.style.transform = 'translateY(-8px) scale(0.98)';
          } else {
            b.style.opacity = '0.5';
          }
        });
        // After a short delay, render the new queue (which includes merged node)
        setTimeout(()=>{
          renderQueue(snap.queue);
          // pulse the newly created bar
          const newBar = queueEl.querySelector(`.bar[data-id="${snap.newId}"]`);
          if (newBar){
            newBar.classList.add('merged','pulse');
            setTimeout(()=>newBar.classList.remove('pulse'), 900);
          }
        }, Math.max(180, 600 / Number(speedControl.value)));
      }

      // Build tree SVG when finished
      function clearTreeSVG(){
        treeSVG.innerHTML = '';
      }

      function buildTreeSVG(rootNode){
        treeSVG.innerHTML = '';
        if (!rootNode) return;
        // compute layout: leaves horizontally spaced
        const leaves = [];
        function collectLeaves(node){
          if (!node.left && !node.right){
            leaves.push(node);
          } else {
            if (node.left) collectLeaves(node.left);
            if (node.right) collectLeaves(node.right);
          }
        }
        collectLeaves(rootNode);
        const width = 1100, height = 380;
        const marginX = 40, marginY = 20;
        const leafCount = leaves.length;
        const xStep = (width - marginX*2) / Math.max(1, leafCount - 1);
        const positions = {}; // id -> {x,y}
        // assign leaf positions
        leaves.forEach((leaf,i)=>{
          positions[leaf.id] = { x: marginX + i * xStep, y: height - marginY - 10 };
        });
        // assign internal nodes by averaging child x; y by depth
        function setPositions(node, depth){
          if (!node.left && !node.right){
            return positions[node.id];
          }
          const leftPos = setPositions(node.left, depth+1);
          const rightPos = setPositions(node.right, depth+1);
          const x = (leftPos.x + rightPos.x) / 2;
          const y = marginY + depth * 60;
          positions[node.id] = { x, y };
          return positions[node.id];
        }
        setPositions(rootNode, 0);

        // Draw edges (parent to child) and nodes
        function drawEdges(node){
          if (!node.left && !node.right) return;
          const p = positions[node.id];
          [node.left, node.right].forEach((child,i)=>{
            const c = positions[child.id];
            const line = document.createElementNS('http://www.w3.org/2000/svg','line');
            line.setAttribute('x1', p.x);
            line.setAttribute('y1', p.y + 8);
            line.setAttribute('x2', c.x);
            line.setAttribute('y2', c.y - 10);
            line.setAttribute('class','edge');
            treeSVG.appendChild(line);
            // label 0/1 near the child
            const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
            lbl.setAttribute('x', (p.x + c.x)/2 + (i===0? -8:8));
            lbl.setAttribute('y', (p.y + c.y)/2 - 4);
            lbl.setAttribute('class','edge label');
            lbl.textContent = i===0 ? '0' : '1';
            treeSVG.appendChild(lbl);
            drawEdges(child);
          });
        }
        drawEdges(rootNode);

        // Draw nodes (circles with labels)
        function drawNodes(node){
          const pos = positions[node.id];
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('class','node');
          g.setAttribute('data-id', node.id);
          g.setAttribute('transform', `translate(${pos.x},${pos.y})`);
          // circle
          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circle.setAttribute('r', 18);
          circle.setAttribute('fill', node.left||node.right ? '#032a2f' : '#042b2f');
          circle.setAttribute('stroke', node.left||node.right ? '#06b6d4' : '#7ee3d9');
          circle.setAttribute('stroke-width', node.left||node.right ? 1.6 : 1.4);
          g.appendChild(circle);
          // text: either weight or symbol
          const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
          txt.setAttribute('y', 4);
          txt.setAttribute('text-anchor','middle');
          txt.textContent = node.left||node.right ? node.weight : node.symbol;
          g.appendChild(txt);
          treeSVG.appendChild(g);

          // clicking a leaf highlights path
          if (!node.left && !node.right){
            g.style.cursor = 'pointer';
            g.addEventListener('click', ()=> highlightSymbol(node.symbol));
            g.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') highlightSymbol(node.symbol); });
            g.setAttribute('tabindex','0');
          }
          if (node.left) drawNodes(node.left);
          if (node.right) drawNodes(node.right);
        }
        drawNodes(rootNode);

        // subtle entrance animation
        const allNodes = treeSVG.querySelectorAll('.node');
        allNodes.forEach((n,i)=>{ n.style.opacity=0; n.style.transform='translateY(8px)'; setTimeout(()=>{ n.style.transition='opacity 480ms ease, transform 480ms ease'; n.style.opacity=1; n.style.transform='translateY(0)'; }, i*60); });
      }

      // Render codes list
      function renderCodes(){
        codesList.innerHTML = '';
        const entries = Object.entries(codes).sort((a,b)=> b[1].length - a[1].length ? a[1].length - b[1].length : String(a[0]).localeCompare(b[0]));
        for (let [sym,code] of entries){
          const item = document.createElement('div');
          item.className = 'code-item';
          const left = document.createElement('div');
          left.style.display='flex';
          left.style.gap='8px';
          const sspan = document.createElement('div');
          sspan.className = 'code-symbol';
          sspan.textContent = sym === ' ' ? '␣' : sym;
          const sc = document.createElement('div');
          sc.style.color = 'var(--muted)';
          sc.textContent = `freq: ${getFreq(sym)}`;
          left.appendChild(sspan);
          left.appendChild(sc);
          const right = document.createElement('div');
          right.style.fontFamily = 'monospace';
          right.style.color = 'var(--white)';
          right.textContent = code;
          item.appendChild(left);
          item.appendChild(right);
          item.addEventListener('click', ()=>{ highlightSymbol(sym); animateCodeBits(code); });
          item.setAttribute('role','button');
          item.setAttribute('tabindex','0');
          codesList.appendChild(item);
        }
      }

      function clearCodes(){ codesList.innerHTML=''; codes = {}; }

      function getFreq(sym){
        const txt = inputText.value;
        let c=0;
        for (let ch of txt) if (ch===sym) c++;
        return c;
      }

      // Highlight path in tree for a symbol
      function highlightSymbol(sym){
        if (!root) return;
        // find leaf node id for symbol
        let leafId = null;
        for (let id in nodesById){
          const node = nodesById[id];
          if (!node.left && !node.right && node.symbol === sym){ leafId = node.id; break; }
        }
        if (!leafId) return;
        // clear previous highlights
        treeSVG.querySelectorAll('.node circle').forEach(c=> c.setAttribute('stroke','#06b6d4'));
        treeSVG.querySelectorAll('line').forEach(l=> l.setAttribute('stroke','rgba(255,255,255,0.06)'));
        // walk from leaf up to root by searching parents (we don't have parent pointers)
        function findPath(node, targetId, path){
          if (!node) return null;
          if (node.id === targetId) return path.concat(node);
          if (!node.left && !node.right) return null;
          const left = findPath(node.left, targetId, path.concat(node));
          if (left) return left;
          const right = findPath(node.right, targetId, path.concat(node));
          if (right) return right;
          return null;
        }
        const pathNodes = findPath(root, leafId, []);
        if (!pathNodes) return;
        // highlight nodes and edges along path
        pathNodes.forEach((nd,i)=>{
          const g = treeSVG.querySelector(`.node[data-id="${nd.id}"]`);
          if (g){
            const circ = g.querySelector('circle');
            circ.setAttribute('stroke','#f59e0b');
            circ.setAttribute('fill','#08323a');
            g.style.transform = 'scale(1.06)';
            setTimeout(()=> g.style.transform = 'scale(1)', 600);
          }
        });
        // highlight edges between consecutive nodes
        for (let i=0;i<pathNodes.length-1;i++){
          const parent = pathNodes[i];
          const child = pathNodes[i+1];
          // find line that connects parent to child (by coordinates)
          const ppos = getPositionOfNode(parent.id);
          const cpos = getPositionOfNode(child.id);
          if (!ppos||!cpos) continue;
          const lines = Array.from(treeSVG.querySelectorAll('line'));
          for (let ln of lines){
            const x1 = +ln.getAttribute('x1'), y1=+ln.getAttribute('y1'), x2=+ln.getAttribute('x2'), y2=+ln.getAttribute('y2');
            // compare endpoints (approx)
            if ((approxEqual(x1,ppos.x) && approxEqual(y1,ppos.y+8) && approxEqual(x2,cpos.x) && approxEqual(y2,cpos.y-10)) ||
                (approxEqual(x2,ppos.x) && approxEqual(y2,ppos.y+8) && approxEqual(x1,cpos.x) && approxEqual(y1,cpos.y-10))){
              ln.setAttribute('stroke','#f59e0b');
              ln.setAttribute('stroke-width','2.4');
            }
          }
        }
      }

      function approxEqual(a,b,eps=1.6){
        return Math.abs(a-b) < eps;
      }

      function getPositionOfNode(id){
        // find transform translate in SVG node
        const g = treeSVG.querySelector(`.node[data-id="${id}"]`);
        if (!g) return null;
        const tr = g.getAttribute('transform'); // translate(x,y)
        const m = /translate\(([-\d.]+),\s*([-\d.]+)\)/.exec(tr);
        if (!m) return null;
        return { x: +m[1], y: +m[2] };
      }

      // animate code bits: show each bit highlight along tree (quick)
      function animateCodeBits(code){
        if (!root) return;
        // start at root; for each bit, find edge labelled 0/1 and flash it
        let node = root;
        let delay = 0;
        for (let b of code){
          setTimeout(((n,bit)=>{
            return ()=>{
              // find child for bit
              const child = bit === '0' ? n.left : n.right;
              if (!child) return;
              // find line between n and child and flash
              const ppos = getPositionOfNode(n.id);
              const cpos = getPositionOfNode(child.id);
              const lines = Array.from(treeSVG.querySelectorAll('line'));
              for (let ln of lines){
                const x1 = +ln.getAttribute('x1'), y1=+ln.getAttribute('y1'), x2=+ln.getAttribute('x2'), y2=+ln.getAttribute('y2');
                if ((approxEqual(x1,ppos.x) && approxEqual(y1,ppos.y+8) && approxEqual(x2,cpos.x) && approxEqual(y2,cpos.y-10)) ||
                    (approxEqual(x2,ppos.x) && approxEqual(y2,ppos.y+8) && approxEqual(x1,cpos.x) && approxEqual(y1,cpos.y-10))){
                  ln.setAttribute('stroke','#7c3aed');
                  ln.setAttribute('stroke-width','2.6');
                  setTimeout(()=>{ ln.setAttribute('stroke','rgba(255,255,255,0.06)'; ln.setAttribute('stroke-width','1.6'); }, 400);
                }
              }
            };
          })(node,b), delay);
          node = (b==='0' ? node.left : node.right) || node;
          delay += 460;
        }
      }

      // Encode and Decode
      function encodeText(txt){
        let out = '';
        for (let ch of txt){
          if (codes[ch] == null){
            // if symbol not present, skip or encode as '?'
            continue;
          }
          out += codes[ch];
        }
        return out;
      }
      function decodeBits(bits){
        if (!root) return '';
        let node = root;
        let out = '';
        for (let b of bits.trim()){
          if (b !== '0' && b !== '1') continue;
          if (b === '0') node = node.left;
          else node = node.right;
          if (!node) return out + '  (invalid bitstream)';
          if (!node.left && !node.right){
            out += node.symbol;
            node = root;
          }
        }
        return out;
      }

      // Button handlers
      analyzeBtn.addEventListener('click', ()=>{
        const txt = inputText.value;
        const freqs = analyzeText(txt);
        const build = buildHuffman(freqs);
        // set initial step to 0
        setStep(0);
      });

      stepForward.addEventListener('click', ()=>{
        if (currentStep < steps.length - 1){
          setStep(currentStep + 1);
        }
      });
      stepBack.addEventListener('click', ()=>{
        if (currentStep > 0){
          setStep(currentStep - 1);
        }
      });

      playPause.addEventListener('click', ()=>{
        if (playing){ stopPlay(); }
        else startPlay();
      });

      function startPlay(){
        if (steps.length === 0) return;
        playing = true;
        playPause.textContent = '⏸ Pause';
        const speed = Number(speedControl.value);
        playInterval = 900 / speed;
        playTimer = setInterval(()=> {
          if (currentStep >= steps.length - 1){ stopPlay(); return; }
          setStep(currentStep + 1);
        }, playInterval);
      }
      function stopPlay(){
        playing = false;
        playPause.textContent = '▶ Play';
        if (playTimer) clearInterval(playTimer);
        playTimer = null;
      }

      speedControl.addEventListener('input', ()=>{
        if (playing){
          stopPlay();
          startPlay();
        }
      });

      encodeBtn.addEventListener('click', ()=>{
        const txt = encodeInput.value || inputText.value;
        const bits = encodeText(txt);
        encodeOutput.value = bits;
      });
      decodeBtn.addEventListener('click', ()=>{
        const bits = encodeInput.value || encodeOutput.value;
        const decoded = decodeBits(bits);
        encodeOutput.value = decoded;
      });

      copyBtn.addEventListener('click', ()=>{
        const val = encodeOutput.value;
        if (!val) return;
        navigator.clipboard && navigator.clipboard.writeText(val).then(()=> {
          copyBtn.textContent = 'Copied!';
          setTimeout(()=> copyBtn.textContent = 'Copy', 1200);
        }).catch(()=>{ /* ignore */ });
      });

      // initial sample
      sampleText();
      // run initial analysis
      analyzeBtn.click();

      // Accessibility: keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        if (e.key === ' ') { e.preventDefault(); playPause.click(); }
        if (e.key === 'ArrowRight') stepForward.click();
        if (e.key === 'ArrowLeft') stepBack.click();
      });

    })();
  </script>
</body>
</html>