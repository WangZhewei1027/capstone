<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Selection Sort — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1722;
      --panel: #0b1220;
      --muted: #94a3b8;
      --accent: #7c5cff;
      --accent-2: #16a34a;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.04);
      --bar-color: #2563eb;
      --bar-compare: #f59e0b;
      --bar-min: #ef4444;
      --bar-fixed: #059669;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    /* Safe area + base layout */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071028,#071025 40%);
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    body{
      padding:var(--safe-margin);
      box-sizing:border-box;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }

    /* Main container */
    .module{
      width:100%;
      max-width:1100px;
      min-height:640px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:24px;
      box-shadow: 0 8px 30px rgba(2,6,23,0.7);
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:24px;
    }

    /* Left column: explanations + controls */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:8px;
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:16px;
      min-height:320px;
    }
    h1{
      font-size:18px;
      margin:0;
      color:#e6eef8;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }
    .section-title{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:600;
      color:#f1f5f9;
      font-size:13px;
    }
    .card{
      background: var(--glass);
      border-radius:8px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .controls{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
    }
    button{
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      color:#e6eef8;
      border:1px solid rgba(255,255,255,0.04);
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
      min-height:44px;
      min-width:64px;
    }
    button.primary{
      background: linear-gradient(90deg, var(--accent), #5b8bff 80%);
      border: none;
      box-shadow: 0 6px 18px rgba(124,92,255,0.14);
      font-weight:600;
    }
    button.ghost{
      background:transparent;
      border:1px dashed rgba(255,255,255,0.04);
    }
    button:disabled{
      opacity:.45;
      cursor:not-allowed;
    }
    .row{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    input[type=number], input[type=text]{
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:transparent;
      color: #e6eef8;
      min-width:80px;
    }
    label{
      font-size:13px;
      color:var(--muted);
    }
    .small{
      font-size:13px;
      color:var(--muted);
    }
    .stats{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .stat{
      background:rgba(255,255,255,0.02);
      padding:8px 10px;
      border-radius:8px;
      font-weight:600;
      color:#e6eef8;
      min-width:86px;
      text-align:center;
    }

    /* Right column: visualization */
    .visual{
      display:flex;
      flex-direction:column;
      gap:16px;
      padding:12px;
      min-height:320px;
    }
    .viz-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    .pseudocode{
      background:rgba(0,0,0,0.15);
      border-radius:8px;
      padding:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
      color:var(--muted);
      line-height:1.6;
      max-width:520px;
      min-width:260px;
    }
    .pseudocode .line{
      padding:6px 8px;
      border-radius:6px;
    }
    .pseudocode .active{
      background:linear-gradient(90deg, rgba(124,92,255,0.14), rgba(6,182,212,0.02));
      color:#fff;
      box-shadow: inset 0 -1px 0 rgba(255,255,255,0.02);
    }
    /* Canvas area */
    .canvas{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015));
      border-radius:10px;
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:320px;
      align-items:stretch;
      justify-content:flex-start;
    }
    .bars{
      position:relative;
      height:300px;
      display:flex;
      align-items:end;
      gap:12px;
      padding:8px;
      border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));
    }
    .bar{
      flex:1 1 0;
      max-width:64px;
      min-width:28px;
      background:var(--bar-color);
      height:60px;
      border-radius:6px 6px 4px 4px;
      display:flex;
      align-items:end;
      justify-content:center;
      position:relative;
      transition: transform 350ms cubic-bezier(.2,.9,.3,1), height 300ms ease, background 200ms ease, box-shadow 200ms ease;
      box-shadow: 0 6px 20px rgba(2,6,23,0.45);
      cursor:grab;
      user-select:none;
    }
    .bar:active{ cursor:grabbing; }
    .bar .label{
      font-size:13px;
      color:#fff;
      padding:6px 8px;
      transform:translateY(-8px);
      background:rgba(0,0,0,0.25);
      border-radius:6px;
      margin-bottom:6px;
      pointer-events:none;
    }
    .bar.index{
      font-size:11px;
      color:var(--muted);
      position:absolute;
      top:-20px;
      transform:translateY(0);
      left:50%;
      transform:translateX(-50%);
    }

    /* Bar states */
    .bar.compare{ background: var(--bar-compare); transform:scale(1.03); }
    .bar.min{ background: var(--bar-min); transform: translateY(-6px) scale(1.05); box-shadow: 0 14px 30px rgba(239,68,68,0.16); }
    .bar.fixed{ background: var(--bar-fixed); box-shadow: 0 10px 26px rgba(5,150,105,0.12); transform: translateY(-4px); }

    /* hint row */
    .hint{
      color:var(--muted);
      font-size:13px;
      display:flex;
      gap:12px;
      align-items:center;
    }

    /* Legend */
    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }
    .swatch{
      width:12px;
      height:12px;
      border-radius:3px;
      display:inline-block;
      margin-right:8px;
    }

    /* footer small text */
    .footer{
      color:var(--muted);
      font-size:12px;
      margin-top:auto;
    }

    /* Responsive */
    @media (max-width:980px){
      .module{ grid-template-columns:1fr; }
      .panel{ order:2; }
      .visual{ order:1; }
    }
  </style>
</head>
<body>
  <main class="module" role="application" aria-label="Selection Sort interactive module">
    <!-- LEFT: Explanation + Controls -->
    <aside class="panel" aria-labelledby="title">
      <div>
        <h1 id="title">Selection Sort — Find & place minimums</h1>
        <p class="muted">A hands-on interactive explanation of Selection Sort. Use the controls to step through comparisons and swaps, or try your own arrays.</p>
      </div>

      <div class="card" aria-live="polite">
        <div class="section-title">Learning objective</div>
        <div class="small">After interacting with this module, you will be able to:</div>
        <ul class="muted" style="margin:8px 0 0 16px; padding:0;">
          <li>Explain how Selection Sort scans for the minimum element and swaps it into place.</li>
          <li>Visually follow comparisons and swaps as each iteration fixes one element.</li>
          <li>Estimate time complexity (comparisons and swaps) for a given input size.</li>
        </ul>
      </div>

      <div class="card" id="controls">
        <div class="section-title">Interaction design</div>
        <div class="muted" style="font-size:13px;">
          Interact using:
          <ul style="margin:8px 0 0 16px;">
            <li>Buttons: Step, Play/Pause, Run to End, Reset.</li>
            <li>Generate a random array, paste a custom comma-separated list, or double-click a bar to edit its value.</li>
            <li>Drag bars horizontally to reorder the initial array (click and drag on a bar).</li>
            <li>Visual feedback: bars highlight during comparisons (amber), current minimum (red), and fixed positions (green). Pseudocode highlights the active line.</li>
          </ul>
          These interactions reinforce the algorithm: compare-to-find-min, then swap once per pass, repeating for each position.
        </div>

        <div class="row" style="margin-top:8px;">
          <button id="randBtn" class="primary" title="Generate a new random array">Random array</button>
          <button id="shuffleBtn" title="Shuffle current array">Shuffle</button>
          <button id="resetBtn" title="Reset to initial">Reset</button>
        </div>

        <div style="display:flex; gap:12px; margin-top:8px; align-items:center;">
          <input id="customInput" type="text" placeholder="e.g. 5,3,8,1,7" aria-label="Custom array input" />
          <button id="loadBtn">Load</button>
        </div>

        <div style="display:flex; gap:12px; margin-top:12px; align-items:center; flex-wrap:wrap;">
          <button id="stepBtn">Step</button>
          <button id="playBtn" class="primary">Play</button>
          <button id="endBtn">Run to End</button>
          <label style="display:flex; align-items:center; gap:8px; margin-left:auto;">
            Speed
            <input id="speed" type="range" min="0.25" max="2" step="0.25" value="1" aria-label="Animation speed" />
          </label>
        </div>

        <div style="display:flex; gap:12px; margin-top:12px; align-items:center; flex-wrap:wrap;">
          <div class="stat" aria-live="polite">Comparisons: <span id="comp">0</span></div>
          <div class="stat" aria-live="polite">Swaps: <span id="swaps">0</span></div>
          <div class="stat">i (pass): <span id="pass">0</span></div>
        </div>

        <div style="margin-top:8px;" class="small muted">
          Tips: Double-click a bar to edit its value. Click+drag a bar horizontally to reorder the initial array. Use keyboard: Space toggles Play/Pause; Right Arrow performs a Step.
        </div>
      </div>

      <div class="card" aria-hidden="false">
        <div class="section-title">Layout description</div>
        <div class="muted small">
          Spatial organization:
          <ul style="margin:8px 0 0 16px;">
            <li>Left column (control panel): title, learning objective, controls, and stats — vertically stacked for focused interaction.</li>
            <li>Right column (visualization): pseudocode on top, canvas with bars below; both update live. The canvas uses a horizontal bar layout so comparisons and swaps are easy to follow.</li>
            <li>Spacing: safe area margin of 24px around the viewport; minimum 16px gap between interactive items. The layout is responsive and collapses to a single column on narrow screens.</li>
            <li>Accessibility: keyboard shortcuts, ARIA labels, and contrast-conscious color choices.</li>
          </ul>
        </div>
      </div>

      <div class="footer small">Only selection sort is demonstrated here. The algorithm repeatedly selects the smallest remaining item and places it at the current front.</div>
    </aside>

    <!-- RIGHT: Visualization -->
    <section class="visual" aria-label="Visualization area">
      <div class="viz-top" role="region" aria-label="Pseudocode">
        <div class="pseudocode" id="pseudocode" aria-hidden="false">
          <div class="line" data-line="1">for i from 0 to n-2</div>
          <div class="line" data-line="2">  minIndex = i</div>
          <div class="line" data-line="3">  for j from i+1 to n-1</div>
          <div class="line" data-line="4">    if A[j] < A[minIndex] then</div>
          <div class="line" data-line="5">      minIndex = j</div>
          <div class="line" data-line="6">  swap A[i] and A[minIndex]</div>
        </div>

        <div style="display:flex; flex-direction:column; gap:8px; min-width:180px;">
          <div class="legend">
            <span class="swatch" style="background:var(--bar-compare)"></span> Comparing
            <span class="swatch" style="background:var(--bar-min); margin-left:12px;"></span> Current minimum
            <span class="swatch" style="background:var(--bar-fixed); margin-left:12px;"></span> Fixed
          </div>
          <div class="hint" id="hint">Hint: Selection sort does at most n-1 swaps.</div>
        </div>
      </div>

      <div class="canvas" role="region" aria-label="Array visualization">
        <div class="bars" id="bars" tabindex="0" aria-label="Array bars (drag to reorder)">
          <!-- Bars are generated by JS -->
        </div>

        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div class="muted small">Double-click a bar to edit. Drag to reorder before running.</div>
          <div class="muted small">Array length: <span id="length">0</span></div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Selection Sort Interactive Module
    (function(){
      // Utilities
      const q = s => document.querySelector(s);
      const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;

      // DOM elements
      const barsEl = q('#bars');
      const randBtn = q('#randBtn');
      const shuffleBtn = q('#shuffleBtn');
      const resetBtn = q('#resetBtn');
      const loadBtn = q('#loadBtn');
      const customInput = q('#customInput');
      const stepBtn = q('#stepBtn');
      const playBtn = q('#playBtn');
      const endBtn = q('#endBtn');
      const speedCtrl = q('#speed');
      const compEl = q('#comp');
      const swapEl = q('#swaps');
      const passEl = q('#pass');
      const hintEl = q('#hint');
      const pseudocode = q('#pseudocode');
      const lengthEl = q('#length');

      // State
      let initialArray = [64, 25, 12, 22, 11];
      let A = [];
      let n = 0;
      let animationSpeed = 1; // multiplier (1x)
      let comps = 0;
      let swaps = 0;
      let pass = 0;

      // Control state for algorithm execution
      let running = false;
      let paused = true;
      let autoPlayId = null;
      let stepResolver = null;
      let currentLine = null;

      // Dragging state
      let dragging = null; // {index, node, clone, startX}
      let dragOverlay = null;

      // Accessibility: keyboard controls
      window.addEventListener('keydown', (e) => {
        if(e.code === 'Space'){ e.preventDefault(); togglePlay(); }
        if(e.code === 'ArrowRight'){ e.preventDefault(); step(); }
      });

      // Initialize
      function init(){
        loadArray(initialArray.slice());
        attachEvents();
        updateStats();
        renderPseudocode();
      }

      // Attach UI events
      function attachEvents(){
        randBtn.addEventListener('click', () => {
          const len = randInt(5,9);
          const arr = Array.from({length:len}, ()=> randInt(1,99));
          initialArray = arr.slice();
          loadArray(arr);
        });

        shuffleBtn.addEventListener('click', () => {
          initialArray = shuffle(initialArray.slice());
          loadArray(initialArray.slice());
        });

        resetBtn.addEventListener('click', () => {
          loadArray(initialArray.slice());
        });

        loadBtn.addEventListener('click', () => {
          const val = customInput.value.trim();
          if(!val) return alert('Enter comma-separated numbers.');
          const parts = val.split(',').map(s=>s.trim()).filter(s=>s.length);
          const parsed = [];
          for(const p of parts){
            const num = Number(p);
            if(Number.isNaN(num)){ alert('Invalid number: '+p); return; }
            parsed.push(num);
          }
          initialArray = parsed.slice();
          loadArray(parsed);
        });

        speedCtrl.addEventListener('input', ()=> {
          animationSpeed = Number(speedCtrl.value);
        });

        stepBtn.addEventListener('click', step);
        playBtn.addEventListener('click', togglePlay);
        endBtn.addEventListener('click', runToEnd);

        // Delegated events for bars: double click to edit
        barsEl.addEventListener('dblclick', (e) => {
          const bar = e.target.closest('.bar');
          if(!bar) return;
          const idx = Number(bar.dataset.index);
          const cur = A[idx];
          const newVal = prompt('Edit value for position '+idx, String(cur));
          if(newVal === null) return;
          const num = Number(newVal);
          if(Number.isNaN(num)){ alert('Must be a number.'); return; }
          A[idx] = num;
          initialArray = A.slice(); // change initial sequence
          renderBars();
        });

        // Drag handling
        barsEl.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);

        // Prevent text selection while dragging
        window.addEventListener('dragstart', e => e.preventDefault());
      }

      // Load an array into the visualization
      function loadArray(arr){
        stopExecution();
        A = arr.slice();
        n = A.length;
        initialArray = arr.slice();
        comps = 0; swaps = 0; pass = 0;
        updateStats();
        renderBars();
        lengthEl.textContent = n;
        hintEl.textContent = 'Ready. Click Play or Step to begin selection sort.';
        highlightPseudocode(null);
      }

      // Render bars
      function renderBars(){
        barsEl.innerHTML = '';
        const max = Math.max(...A, 1);
        A.forEach((val,i)=>{
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.style.height = Math.max(36, (val / max) * 260) + 'px';
          bar.dataset.index = String(i);
          bar.setAttribute('role','button');
          bar.setAttribute('tabindex','0');
          bar.setAttribute('aria-label', `index ${i}, value ${val}`);
          bar.innerHTML = `
            <div class="index">[${i}]</div>
            <div class="label">${val}</div>
          `;
          barsEl.appendChild(bar);
        });
      }

      // Pseudocode highlighting
      function renderPseudocode(){
        // lines are already in DOM. Nothing dynamic yet until running.
      }
      function highlightPseudocode(lineNum){
        const lines = pseudocode.querySelectorAll('.line');
        lines.forEach(l => l.classList.toggle('active', l.dataset.line === String(lineNum)));
        currentLine = lineNum;
      }

      // Update stats display
      function updateStats(){
        compEl.textContent = String(comps);
        swapEl.textContent = String(swaps);
        passEl.textContent = String(pass);
      }

      // Helpers for algorithm animation
      function delay(ms){ return new Promise(res => setTimeout(res, ms)); }
      function animDelay(baseMs = 500){
        // speed: lower means faster
        const ms = baseMs / animationSpeed;
        return delay(ms);
      }

      // Execution control
      function stopExecution(){
        running = false;
        paused = true;
        if(stepResolver) { stepResolver(); stepResolver = null; }
        playBtn.textContent = 'Play';
      }
      function togglePlay(){
        if(running){
          paused = !paused;
          playBtn.textContent = paused ? 'Play' : 'Pause';
        } else {
          play();
        }
      }

      async function play(){
        if(running){ paused = false; playBtn.textContent = 'Pause'; return; }
        running = true;
        paused = false;
        playBtn.textContent = 'Pause';
        hintEl.textContent = 'Playing...';
        try {
          await selectionSortAnimated();
        } catch(e){
          // aborted or ended
        } finally {
          running = false;
          paused = true;
          playBtn.textContent = 'Play';
        }
      }

      async function runToEnd(){
        if(!running) {
          running = true;
          paused = false;
        }
        try {
          await selectionSortAnimated(true); // fast-run to end: no delays
        } finally {
          running = false;
          paused = true;
          playBtn.textContent = 'Play';
        }
      }

      // Step: perform a single logical step in the algorithm (either one comparison or swap)
      // For simplicity, stepping advances by "action units" implemented via a generator-like approach.
      let algorithmGenerator = null;

      async function step(){
        if(!algorithmGenerator){
          algorithmGenerator = selectionSortGenerator();
        }
        const {value, done} = algorithmGenerator.next();
        if(done){
          algorithmGenerator = null;
          highlightPseudocode(null);
          hintEl.textContent = 'Completed.';
          return;
        }
        // value is a promise or an immediate action
        if(value instanceof Promise){
          await value;
        }
      }

      // The main "animated" selection sort that can be paused
      async function selectionSortAnimated(fast=false){
        // Generator-based approach used to allow step-by-step; here we run continuously
        algorithmGenerator = selectionSortGenerator(fast);
        while(true){
          if(paused) {
            // Wait until unpaused
            await new Promise(res => {
              stepResolver = res;
            });
            stepResolver = null;
          }
          const {done, value} = algorithmGenerator.next();
          if(done) break;
          if(value instanceof Promise) await value;
        }
        algorithmGenerator = null;
        highlightPseudocode(null);
        hintEl.textContent = 'Sorting complete.';
      }

      // Selection sort generator yields Promise objects representing animation of elementary actions.
      function* selectionSortGenerator(fast=false){
        const nLocal = A.length;
        highlightPseudocode('1');
        for(let i=0;i<nLocal-1;i++){
          pass = i;
          updateStats();
          let minIndex = i;
          highlightPseudocode('2');
          markFixed(i-1); // previous ones fixed
          // inner loop
          highlightPseudocode('3');
          for(let j=i+1;j<nLocal;j++){
            // compare A[j] vs A[minIndex]
            highlightBar(j,'compare');
            highlightBar(minIndex,'min');
            highlightPseudocode('4');
            comps++; updateStats();
            yield fast ? Promise.resolve() : animDelay(420);
            if(A[j] < A[minIndex]){
              // update min
              highlightPseudocode('5');
              unhighlightBar(minIndex);
              minIndex = j;
              highlightBar(minIndex,'min');
              yield fast ? Promise.resolve() : animDelay(260);
            }
            unhighlightBar(j,'compare');
            // keep min highlighted until the end of inner loop
          }
          // swap A[i] and A[minIndex]
          highlightPseudocode('6');
          if(minIndex !== i){
            swaps++; updateStats();
            yield animateSwap(i, minIndex, fast);
          } else {
            // nothing to swap, just mark fixed
            markFixed(i);
            yield fast ? Promise.resolve() : animDelay(200);
          }
        }
        // mark all fixed
        for(let k=0;k<nLocal;k++) markFixed(k);
        highlightPseudocode(null);
        return;
      }

      // Animate swap between indices i and j
      async function animateSwap(i,j,fast=false){
        const nodeI = barsEl.querySelector(`.bar[data-index="${i}"]`);
        const nodeJ = barsEl.querySelector(`.bar[data-index="${j}"]`);
        if(!nodeI || !nodeJ) return;

        // Visually mark
        nodeI.classList.add('compare');
        nodeJ.classList.add('min');

        // Create placeholders and animate transform based on positions
        const rectI = nodeI.getBoundingClientRect();
        const rectJ = nodeJ.getBoundingClientRect();
        const containerRect = barsEl.getBoundingClientRect();

        // distance to move horizontally
        const dx = rectJ.left - rectI.left;

        // Apply transforms
        nodeI.style.transition = 'transform 450ms cubic-bezier(.2,.9,.3,1)';
        nodeJ.style.transition = 'transform 450ms cubic-bezier(.2,.9,.3,1)';
        nodeI.style.zIndex = 100;
        nodeJ.style.zIndex = 100;

        nodeI.style.transform = `translateX(${dx}px) scale(1.02)`;
        nodeJ.style.transform = `translateX(${ -dx }px) scale(1.02)`;

        if(!fast) await animDelay(480);
        // Swap values in array
        const tmp = A[i]; A[i] = A[j]; A[j] = tmp;
        initialArray = A.slice();

        // Reset transforms and re-render to update heights/labels and indices
        nodeI.style.transform = '';
        nodeJ.style.transform = '';
        nodeI.style.transition = '';
        nodeJ.style.transition = '';
        nodeI.style.zIndex = '';
        nodeJ.style.zIndex = '';

        await animDelay(80);
        renderBars();
        // After re-render, mark fixed i
        markFixed(i);
      }

      // Visual helpers
      function highlightBar(index, kind){
        const node = barsEl.querySelector(`.bar[data-index="${index}"]`);
        if(!node) return;
        node.classList.remove('compare','min','fixed');
        if(kind === 'compare') node.classList.add('compare');
        if(kind === 'min') node.classList.add('min');
      }
      function unhighlightBar(index){
        const node = barsEl.querySelector(`.bar[data-index="${index}"]`);
        if(!node) return;
        node.classList.remove('compare','min');
      }
      function markFixed(index){
        const node = barsEl.querySelector(`.bar[data-index="${index}"]`);
        if(!node) return;
        node.classList.remove('compare','min');
        node.classList.add('fixed');
      }

      // Shuffle
      function shuffle(arr){
        for(let i=arr.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [arr[i],arr[j]] = [arr[j],arr[i]];
        }
        return arr;
      }

      // Dragging functions
      function onPointerDown(e){
        const target = e.target.closest('.bar');
        if(!target) return;
        // start dragging
        dragging = {};
        dragging.index = Number(target.dataset.index);
        dragging.node = target;
        dragging.startX = e.clientX;
        dragging.startY = e.clientY;
        // create clone overlay
        const clone = target.cloneNode(true);
        clone.style.position = 'fixed';
        const r = target.getBoundingClientRect();
        clone.style.left = r.left + 'px';
        clone.style.top = r.top + 'px';
        clone.style.width = r.width + 'px';
        clone.style.pointerEvents = 'none';
        clone.style.zIndex = 9999;
        clone.style.opacity = 0.95;
        clone.style.transform = 'scale(1.02)';
        document.body.appendChild(clone);
        dragging.clone = clone;
        // visually mark original
        target.style.visibility = 'hidden';
        e.preventDefault();
      }

      function onPointerMove(e){
        if(!dragging) return;
        // move clone
        const cx = e.clientX;
        const cy = e.clientY;
        dragging.clone.style.left = (cx - dragging.clone.offsetWidth/2) + 'px';
        dragging.clone.style.top = (cy - dragging.clone.offsetHeight/2) + 'px';

        // determine target index based on pointer x relative to bars container
        const containerRect = barsEl.getBoundingClientRect();
        const relX = Math.max(0, Math.min(containerRect.width - 1, e.clientX - containerRect.left));
        // compute approximate index: each bar occupies (width + gap). We'll compute by element centers.
        const barNodes = Array.from(barsEl.querySelectorAll('.bar'));
        let closestIdx = dragging.index;
        let minDist = Infinity;
        barNodes.forEach((b, idx) => {
          const br = b.getBoundingClientRect();
          const center = br.left + br.width/2 - containerRect.left;
          const d = Math.abs(center - relX);
          if(d < minDist){ minDist = d; closestIdx = idx; }
        });
        // highlight position by temporarily rearranging DOM
        highlightDropPosition(dragging.index, closestIdx);
      }

      function onPointerUp(e){
        if(!dragging) return;
        // finalize
        const clone = dragging.clone;
        const originalIndex = dragging.index;
        // compute drop index
        const containerRect = barsEl.getBoundingClientRect();
        const relX = Math.max(0, Math.min(containerRect.width - 1, e.clientX - containerRect.left));
        const barNodes = Array.from(barsEl.querySelectorAll('.bar'));
        let closestIdx = originalIndex;
        let minDist = Infinity;
        barNodes.forEach((b, idx) => {
          const br = b.getBoundingClientRect();
          const center = br.left + br.width/2 - containerRect.left;
          const d = Math.abs(center - relX);
          if(d < minDist){ minDist = d; closestIdx = idx; }
        });
        // remove clone
        clone.remove();
        // unhide originals
        const origNode = barsEl.querySelector(`.bar[data-index="${originalIndex}"]`);
        if(origNode) origNode.style.visibility = '';

        // perform reorder in array
        if(closestIdx !== originalIndex){
          const val = A.splice(originalIndex,1)[0];
          A.splice(closestIdx,0,val);
          initialArray = A.slice();
          renderBars();
        } else {
          // clear any temporary highlighting
          renderBars();
        }
        dragging = null;
      }

      function highlightDropPosition(fromIdx, toIdx){
        // rearrange visually without changing data by reordering DOM nodes
        const nodes = Array.from(barsEl.querySelectorAll('.bar'));
        if(nodes.length === 0) return;
        // create new order array of nodes
        const nodeList = nodes.slice();
        const node = nodeList.splice(fromIdx,1)[0];
        nodeList.splice(toIdx,0,node);
        // apply to DOM
        barsEl.innerHTML = '';
        nodeList.forEach((nd, idx)=>{
          nd.dataset.index = String(idx); // temporary index update
          barsEl.appendChild(nd);
        });
      }

      // Selection sort generator (detailed)
      function* selectionSortGenerator(fast=false){
        const nLocal = A.length;
        highlightPseudocode('1');
        for(let i=0;i<nLocal-1;i++){
          pass = i+1;
          updateStats();
          let minIndex = i;
          highlightPseudocode('2');
          // mark fixed for previous elements
          for(let k=0;k<i;k++) markFixed(k);
          // inner loop
          highlightPseudocode('3');
          for(let j=i+1;j<nLocal;j++){
            // highlight comparison
            highlightBar(j,'compare');
            highlightBar(minIndex,'min');
            highlightPseudocode('4');
            comps++; updateStats();
            yield fast ? Promise.resolve() : animDelay(420);
            if(A[j] < A[minIndex]){
              highlightPseudocode('5');
              unhighlightBar(minIndex);
              minIndex = j;
              highlightBar(minIndex,'min');
              yield fast ? Promise.resolve() : animDelay(220);
            }
            unhighlightBar(j);
            // continue
          }
          // swap
          highlightPseudocode('6');
          if(minIndex !== i){
            swaps++; updateStats();
            yield animateSwap(i, minIndex, fast);
          } else {
            markFixed(i);
            yield fast ? Promise.resolve() : animDelay(180);
          }
        }
        // finish: mark all fixed
        for(let k=0;k<nLocal;k++) markFixed(k);
        highlightPseudocode(null);
        return;
      }

      // Expose initial launch
      init();

    })();
  </script>
</body>
</html>