<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merge Sort Interactive Module</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #071020;
      --muted: #9aa7b2;
      --accent: #3dd3c1;
      --danger: #ff6b6b;
      --text: #e6eef6;
      --bar-gap: 8px;
    }
    *{box-sizing: border-box; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    html,body{height:100%; margin:0; background: linear-gradient(180deg,#071021,#071826 60%); color:var(--text);}
    .safe-area{
      padding:var(--safe-padding);
      min-height:100vh;
    }
    .grid{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
    }
    /* Left panel: info + controls */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      padding:18px;
      border-radius:10px;
      width:360px;
      min-width:260px;
    }
    h1{margin:0 0 8px 0; font-size:20px;}
    p{margin:0 0 12px 0; color:var(--muted); font-size:13px; line-height:1.35;}
    label{display:block; font-size:13px; color:var(--muted); margin-bottom:6px;}
    .controls{display:flex; gap:var(--gap); flex-wrap:wrap; margin-bottom:12px;}
    .controls > *{flex:1 1 auto;}
    .btn{
      background:linear-gradient(180deg,#0e2b34,#072226);
      color:var(--text);
      border:none;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      min-width:80px;
      text-align:center;
    }
    .btn:active{transform:translateY(1px);}
    .btn.secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
    }
    .row {display:flex; gap:12px; align-items:center; margin-bottom:12px;}
    .slider{
      -webkit-appearance:none; width:100%;
      height:6px; border-radius:6px; background:rgba(255,255,255,0.06);
      outline:none;
    }
    .small{font-size:12px; color:var(--muted);}
    input[type="text"]{
      background:transparent; border:1px solid rgba(255,255,255,0.04);
      padding:8px 10px; border-radius:8px; color:var(--text); width:100%;
    }
    .pseudo{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.007));
      border:1px solid rgba(255,255,255,0.03);
      padding:10px; border-radius:8px; font-family:monospace; font-size:13px; color:var(--muted);
    }
    .pseudo .line{padding:4px 6px; border-radius:6px;}
    .highlight{background:linear-gradient(90deg, rgba(61,211,193,0.12), rgba(61,211,193,0.04)); color:var(--accent); font-weight:600;}
    /* Right panel: visualization */
    .viz-wrap{
      flex:1 1 auto;
      min-width:280px;
    }
    .viz{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.007));
      border:1px solid rgba(255,255,255,0.03);
      border-radius:10px;
      padding:16px;
      position:relative;
      overflow:hidden;
    }
    .controls-row{
      display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap;
    }
    .bar-area{
      position:relative;
      height:320px;
      background: linear-gradient(180deg, rgba(255,255,255,0.002), rgba(255,255,255,0.004));
      border-radius:8px;
      overflow:visible;
      margin-bottom:12px;
      border:1px dashed rgba(255,255,255,0.02);
    }
    .bars{
      position:absolute; left:12px; right:12px; top:12px; bottom:12px;
      display:block;
    }
    .bar{
      position:absolute;
      bottom:0;
      width:48px;
      background:linear-gradient(180deg,#3dd3c1,#2ab3a0);
      border-radius:6px 6px 4px 4px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:#082623;
      font-weight:700;
      cursor:grab;
      box-shadow: 0 6px 14px rgba(3,8,15,0.5);
      transition: transform 300ms cubic-bezier(.2,.8,.2,1), box-shadow 200ms;
      user-select:none;
      touch-action: none;
    }
    .bar.dragging{opacity:0.9; cursor:grabbing; box-shadow: 0 12px 26px rgba(0,0,0,0.6); transform:scale(1.03);}
    .bar .label{
      background:rgba(255,255,255,0.9);
      padding:4px 6px;
      border-radius:6px;
      margin-bottom:8px;
      font-size:13px;
    }
    .bar.hilight{outline:3px solid rgba(61,211,193,0.18); box-shadow:0 8px 20px rgba(61,211,193,0.06);}
    .bar.compare{outline:3px solid rgba(255,255,255,0.08); background:linear-gradient(180deg,#ffd166,#ffb74d);}
    .ghost{
      position:absolute; pointer-events:none; z-index:60; opacity:0.95;
      transform-origin:center bottom;
    }
    .range-outline{
      position:absolute; border-radius:6px; border:2px dashed rgba(255,255,255,0.06);
      background: linear-gradient(180deg, rgba(61,211,193,0.02), rgba(61,211,193,0.01));
      pointer-events:none;
      transition:opacity 240ms;
    }
    .log{
      font-size:13px; color:var(--muted);
      max-height:56px; overflow:auto; padding:8px; border-radius:6px; border:1px solid rgba(255,255,255,0.02);
    }
    .footer-hint{font-size:12px; color:var(--muted); margin-top:10px;}
    /* Responsive */
    @media (max-width:980px){
      .grid{flex-direction:column;}
      .panel{width:100%;}
      .viz-wrap{width:100%;}
    }
  </style>
</head>
<body>
  <div class="safe-area">
    <div style="display:flex; align-items:center; gap:12px; margin-bottom:16px;">
      <h1>Merge Sort — Interactive Module</h1>
      <div style="font-size:13px; color:var(--muted);">Split, compare, and merge — step through each action.</div>
    </div>

    <div class="grid" role="main">
      <div class="panel" aria-labelledby="panelTitle">
        <h2 id="panelTitle" style="font-size:16px; margin-bottom:8px;">Quick Overview</h2>
        <p>Merge Sort is a divide-and-conquer algorithm: recursively split the array into halves, then merge sorted halves. Use the controls to step through comparisons and observe how elements move into place.</p>

        <div class="row">
          <label class="small" style="flex:1 1 100%;">Array size: <span id="sizeVal">8</span></label>
          <input id="sizeSlider" class="slider" type="range" min="2" max="12" value="8" aria-label="Array size slider" />
        </div>

        <div class="controls" role="group" aria-label="Primary controls">
          <button id="randomBtn" class="btn">Randomize</button>
          <button id="startBtn" class="btn">Start</button>
          <button id="stepBtn" class="btn secondary">Step</button>
          <button id="pauseBtn" class="btn secondary">Pause</button>
          <button id="resetBtn" class="btn secondary">Reset</button>
        </div>

        <div class="row" style="align-items:flex-start;">
          <div style="flex:1;">
            <label class="small">Speed</label>
            <input id="speedSlider" class="slider" min="0.25" max="2" step="0.05" value="1" type="range" />
            <div class="small" style="margin-top:6px;">Lower = slower, Higher = faster</div>
          </div>
        </div>

        <div style="margin-top:10px;">
          <label class="small">Custom array (comma separated)</label>
          <input id="arrayInput" type="text" placeholder="e.g. 5,3,8,1,4" aria-label="Custom array input" />
          <div style="display:flex; gap:12px; margin-top:8px;">
            <button id="applyBtn" class="btn">Apply</button>
            <button id="clearBtn" class="btn secondary">Clear</button>
          </div>
        </div>

        <div style="margin-top:12px; display:flex; justify-content:space-between; align-items:center;">
          <label style="display:flex; align-items:center; gap:8px;">
            <input id="recToggle" type="checkbox" /> <span class="small">Show recursion ranges</span>
          </label>
          <div class="small">Shortcuts: Space = Play/Pause • ←/→ Step</div>
        </div>

        <hr style="border:none; height:1px; background:rgba(255,255,255,0.02); margin:12px 0;">

        <div>
          <h3 style="font-size:14px; margin:0 0 8px 0;">Pseudocode</h3>
          <div class="pseudo" id="pseudocode" aria-hidden="false">
            <div class="line" id="line1">function mergeSort(A):</div>
            <div class="line" id="line2">  if len(A) &lt;= 1: return A</div>
            <div class="line" id="line3">  mid = len(A) // 2</div>
            <div class="line" id="line4">  L = mergeSort(A[:mid])</div>
            <div class="line" id="line5">  R = mergeSort(A[mid:])</div>
            <div class="line" id="line6">  return merge(L, R)</div>
            <div class="line" id="line7" style="margin-top:6px;">merge(L,R): compare heads, append smaller, repeat</div>
          </div>
        </div>
      </div>

      <div class="viz-wrap">
        <div class="viz" role="application" aria-label="Merge sort visualization">
          <div class="controls-row">
            <div style="display:flex; gap:8px;">
              <button id="dragHint" class="btn secondary" title="You can drag bars to reorder">Drag to reorder</button>
              <button id="toggleLog" class="btn secondary">Toggle Log</button>
            </div>
            <div style="margin-left:auto; color:var(--muted); font-size:13px;">Watch the compare highlights and merge motion</div>
          </div>

          <div class="bar-area" id="barArea" tabindex="0" aria-label="Array bar area">
            <div class="bars" id="bars"></div>
            <!-- range outlines container -->
            <div id="rangesContainer" style="position:absolute; left:12px; right:12px; top:12px; bottom:12px; pointer-events:none;"></div>
          </div>

          <div style="display:flex; gap:12px;">
            <div style="flex:1;">
              <div class="small" style="margin-bottom:6px;">Action log</div>
              <div class="log" id="log"></div>
            </div>
            <div style="width:160px;">
              <div class="small">Current action</div>
              <div class="pseudo" id="actionBox" style="margin-top:6px; min-height:56px;">Idle</div>
            </div>
          </div>

          <div class="footer-hint">Tip: use Step to inspect each comparison. Use reset to try again.</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Merge Sort Interactive Module
    (function(){
      // UI elements
      const sizeSlider = document.getElementById('sizeSlider');
      const sizeVal = document.getElementById('sizeVal');
      const randomBtn = document.getElementById('randomBtn');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');
      const speedSlider = document.getElementById('speedSlider');
      const arrayInput = document.getElementById('arrayInput');
      const applyBtn = document.getElementById('applyBtn');
      const clearBtn = document.getElementById('clearBtn');
      const recToggle = document.getElementById('recToggle');
      const barsContainer = document.getElementById('bars');
      const barArea = document.getElementById('barArea');
      const logBox = document.getElementById('log');
      const actionBox = document.getElementById('actionBox');
      const pseudocode = {
        line1: document.getElementById('line1'),
        line2: document.getElementById('line2'),
        line3: document.getElementById('line3'),
        line4: document.getElementById('line4'),
        line5: document.getElementById('line5'),
        line6: document.getElementById('line6'),
        line7: document.getElementById('line7')
      };
      const rangesContainer = document.getElementById('rangesContainer');
      const toggleLog = document.getElementById('toggleLog');

      // State
      let array = [];
      let initialArray = [];
      let actions = []; // recorded actions for playback
      let actionIndex = 0;
      let playing = false;
      let timer = null;
      let animationSpeed = 1; // multiplier
      let barWidth = 48;
      let gap = 8;
      let dragging = null;
      let barPositions = []; // current x positions for indices
      let showLog = true;

      // Accessibility: keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
        if (e.code === 'ArrowRight') { e.preventDefault(); step(); }
        if (e.code === 'ArrowLeft') { e.preventDefault(); prevStep(); }
      });

      // Init
      sizeVal.textContent = sizeSlider.value;
      sizeSlider.addEventListener('input', ()=>{
        sizeVal.textContent = sizeSlider.value;
      });

      function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

      function generateRandom(n){
        const arr = [];
        for (let i=0;i<n;i++) arr.push(randInt(1,99));
        return arr;
      }

      function createBars(arr){
        barsContainer.innerHTML = '';
        barPositions = [];
        const n = arr.length;
        const containerRect = barsContainer.getBoundingClientRect();
        const availableWidth = containerRect.width || (n*(barWidth+gap)+24);
        // compute widths and gaps adaptively for small screens
        const totalGap = gap*(n-1);
        let computedBarWidth = Math.max(32, Math.min(64, Math.floor((availableWidth - totalGap)/n)));
        barWidth = computedBarWidth;
        for (let i=0;i<n;i++){
          const val = arr[i];
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.dataset.index = i;
          bar.dataset.value = val;
          bar.style.width = barWidth+'px';
          const heightPct = Math.max(8, Math.round((val/100)*92));
          bar.style.height = (heightPct)+'%';
          // position
          const left = i*(barWidth+gap);
          bar.style.transform = `translate3d(${left}px,0,0)`;
          bar.style.zIndex = 10 + i;
          bar.innerHTML = '<div class="label" aria-hidden="true">'+val+'</div>';
          bar.tabIndex = 0;
          barsContainer.appendChild(bar);
          barPositions.push(left);
          makeDraggable(bar);
        }
        updateContainerWidth(n);
      }

      function updateContainerWidth(n){
        const width = Math.max(300, n*(barWidth+gap)-gap);
        barsContainer.style.width = width+'px';
        barsContainer.style.height = '100%';
      }

      function renderArray(arr){
        array = arr.slice();
        initialArray = arr.slice();
        createBars(array);
        clearActions();
        log('Array set: ['+array.join(', ')+']');
      }

      // Draggable bars to reorder initial array
      function makeDraggable(bar){
        let startX=0, startLeft=0, idx=0;
        const onPointerDown = (e)=> {
          if (playing) return;
          dragging = bar;
          bar.classList.add('dragging');
          bar.setPointerCapture(e.pointerId);
          startX = e.clientX;
          startLeft = parseFloat(bar.style.transform.replace(/translate3d\(([-\d.]+)px.*\)/,'$1')) || 0;
          idx = parseInt(bar.dataset.index,10);
        };
        const onPointerMove = (e)=>{
          if (!dragging) return;
          const dx = e.clientX - startX;
          const newLeft = startLeft + dx;
          bar.style.transform = `translate3d(${newLeft}px,0,0)`;
          // determine new index visually by center
          const center = newLeft + barWidth/2;
          const newIndex = Math.max(0, Math.min(array.length-1, Math.round(center / (barWidth+gap))));
          // highlight target
        };
        const onPointerUp = (e)=>{
          if (!dragging) return;
          const finalLeft = parseFloat(bar.style.transform.replace(/translate3d\(([-\d.]+)px.*\)/,'$1')) || 0;
          const newIndex = Math.max(0, Math.min(array.length-1, Math.round(finalLeft / (barWidth+gap))));
          const oldIndex = parseInt(bar.dataset.index,10);
          if (newIndex !== oldIndex){
            // reorder array
            const val = array.splice(oldIndex,1)[0];
            array.splice(newIndex,0,val);
            // re-render bars to reflect new order
            createBars(array);
            log('Reordered: ['+array.join(', ')+']');
            clearActions();
          } else {
            // snap back
            createBars(array);
          }
          bar.classList.remove('dragging');
          dragging = null;
        };
        // pointer events for mouse and touch
        bar.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
      }

      // Merge sort algorithm that logs actions
      // Actions: {type:'range', from, to, depth}
      // {type:'compare', i, j, leftIndex, rightIndex}
      // {type:'take', fromIndex, toIndex, value, source:'L'|'R'}
      // {type:'overwrite', index, value}
      // We'll log ranges when splitting and merging to support outlines.
      function recordMergeSort(arr){
        actions = [];
        function mergeSortHelper(a, l){
          if (a.length <= 1) return a.slice();
          const mid = Math.floor(a.length/2);
          const L = a.slice(0,mid);
          const R = a.slice(mid);
          const globalL = l;
          const globalMid = l+mid;
          const globalR = l+a.length;
          const depth = 0;
          actions.push({type:'range', from:globalL, to:globalMid-1, phase:'split'});
          actions.push({type:'range', from:globalMid, to:globalR-1, phase:'split'});
          const sortedL = mergeSortHelper(L, globalL);
          const sortedR = mergeSortHelper(R, globalMid);
          // merging sortedL and sortedR
          actions.push({type:'range', from:globalL, to:globalR-1, phase:'merge'});
          let i=0,j=0,k=globalL;
          while(i<sortedL.length && j<sortedR.length){
            actions.push({type:'compare', leftIndex:globalL+i, rightIndex:globalMid+j, i:i, j:j});
            if (sortedL[i] <= sortedR[j]){
              actions.push({type:'take', fromIndex:globalL+i, toIndex:k, value:sortedL[i], source:'L'});
              i++; k++;
            } else {
              actions.push({type:'take', fromIndex:globalMid+j, toIndex:k, value:sortedR[j], source:'R'});
              j++; k++;
            }
          }
          while(i<sortedL.length){
            actions.push({type:'take', fromIndex:globalL+i, toIndex:k, value:sortedL[i], source:'L'});
            i++; k++;
          }
          while(j<sortedR.length){
            actions.push({type:'take', fromIndex:globalMid+j, toIndex:k, value:sortedR[j], source:'R'});
            j++; k++;
          }
          // produce merged array
          const merged = [];
          let p=0,q=0;
          while(p<sortedL.length && q<sortedR.length){
            merged.push(sortedL[p] <= sortedR[q] ? sortedL[p++] : sortedR[q++]);
          }
          while(p<sortedL.length) merged.push(sortedL[p++]);
          while(q<sortedR.length) merged.push(sortedR[q++]);
          // at end, we may also log final overwrite actions for visualization brightness
          for (let t=0;t<merged.length;t++){
            actions.push({type:'overwrite', index:globalL+t, value:merged[t]});
          }
          return merged;
        }
        mergeSortHelper(arr.slice(), 0);
      }

      function clearActions(){
        actions = [];
        actionIndex = 0;
        playing = false;
        if (timer) { clearTimeout(timer); timer = null; }
        actionBox.innerText = 'Idle';
        log('Actions cleared.');
        clearHighlights();
        rangesContainer.innerHTML = '';
      }

      function log(msg){
        if (!showLog) return;
        const now = new Date();
        const li = document.createElement('div');
        li.textContent = `[${now.toLocaleTimeString().split(' ')[0]}] ${msg}`;
        logBox.prepend(li);
      }

      // Playback engine
      function play(){
        if (actionIndex >= actions.length) { playing=false; return; }
        playing = true;
        step(); // start first step immediately
      }

      function togglePlay(){
        if (playing) { pause(); } else { if (actions.length===0){ recordMergeSort(array); } play(); }
      }
      function pause(){
        playing = false;
        if (timer){ clearTimeout(timer); timer=null; }
        actionBox.innerText = 'Paused';
      }

      function step(){
        if (actionIndex >= actions.length){
          actionBox.innerText = 'Done';
          playing=false;
          return;
        }
        const act = actions[actionIndex++];
        performAction(act).then(()=>{
          if (playing){
            const delay = 500 / animationSpeed;
            timer = setTimeout(()=> step(), delay);
          }
        });
      }

      function prevStep(){
        // Not implementing backward playback to keep complexity low.
        log('Backward stepping not supported. Use Reset + Step forward.');
      }

      function performAction(act){
        return new Promise(resolve=>{
          actionBox.innerText = JSON.stringify(act);
          clearPseudocodeHighlights();
          switch(act.type){
            case 'range':
              highlightRange(act.from, act.to, act.phase);
              pseudocode.line3.classList.add('highlight');
              setTimeout(resolve, 320/animationSpeed);
              break;
            case 'compare':
              highlightCompare(act.leftIndex, act.rightIndex);
              pseudocode.line7.classList.add('highlight');
              setTimeout(resolve, 380/animationSpeed);
              break;
            case 'take':
              animateTake(act.fromIndex, act.toIndex, act.value, act.source).then(resolve);
              pseudocode.line7.classList.add('highlight');
              break;
            case 'overwrite':
              overwriteIndex(act.index, act.value);
              pseudocode.line6.classList.add('highlight');
              setTimeout(resolve, 240/animationSpeed);
              break;
            default:
              setTimeout(resolve, 150);
          }
        });
      }

      function clearPseudocodeHighlights(){
        for (let k in pseudocode) pseudocode[k].classList.remove('highlight');
      }

      function clearHighlights(){
        const bars = barsContainer.querySelectorAll('.bar');
        bars.forEach(b => b.classList.remove('compare','hilight'));
        rangesContainer.innerHTML = '';
      }

      function highlightRange(from, to, phase){
        rangesContainer.innerHTML = '';
        if (!recToggle.checked) return;
        const bars = barsContainer.querySelectorAll('.bar');
        if (bars.length===0) return;
        const first = bars[from];
        const last = bars[to];
        if (!first || !last) return;
        const rect1 = first.getBoundingClientRect();
        const rect2 = last.getBoundingClientRect();
        const containerRect = barsContainer.getBoundingClientRect();
        const left = rect1.left - containerRect.left;
        const right = rect2.left - containerRect.left + barWidth;
        const top = 8; const bottom = barsContainer.clientHeight - 8;
        const outline = document.createElement('div');
        outline.className = 'range-outline';
        outline.style.left = left + 'px';
        outline.style.top = (top + (phase==='merge'?24:0)) + 'px';
        outline.style.width = (Math.max(0, right-left)) + 'px';
        outline.style.height = (bottom - top - (phase==='merge'?20:0)) + 'px';
        rangesContainer.appendChild(outline);
        setTimeout(()=> {
          outline.style.opacity = '0.85';
        }, 20);
        setTimeout(()=> {
          outline.style.opacity = '0.35';
        }, 800/animationSpeed);
      }

      function highlightCompare(i, j){
        clearHighlights();
        const bars = barsContainer.querySelectorAll('.bar');
        if (bars[i]) bars[i].classList.add('compare');
        if (bars[j]) bars[j].classList.add('compare');
        log(`Compare indices ${i} & ${j} -> values ${array[i]} vs ${array[j]}`);
      }

      function animateTake(fromIndex, toIndex, value, source){
        return new Promise(resolve=>{
          // Create ghost at source bar's position
          const bars = barsContainer.querySelectorAll('.bar');
          const sourceBar = bars[fromIndex];
          const targetBar = bars[toIndex];
          if (!sourceBar || !targetBar){
            // fallback: set array value and update bars
            array[toIndex] = value;
            updateBarValue(toIndex, value);
            setTimeout(resolve, 180/animationSpeed);
            return;
          }
          const srcRect = sourceBar.getBoundingClientRect();
          const tgtRect = targetBar.getBoundingClientRect();
          const containerRect = barsContainer.getBoundingClientRect();
          const ghost = sourceBar.cloneNode(true);
          ghost.className = 'ghost';
          ghost.style.width = barWidth+'px';
          ghost.style.height = sourceBar.style.height;
          ghost.style.left = (srcRect.left - containerRect.left) + 'px';
          ghost.style.top = (srcRect.top - containerRect.top) + 'px';
          ghost.style.transform = 'translate3d(0,0,0)';
          barsContainer.appendChild(ghost);
          // highlight source
          sourceBar.classList.add('hilight');
          const dx = (tgtRect.left - srcRect.left);
          const dy = (tgtRect.top - srcRect.top);
          const dur = Math.max(220, 420 / animationSpeed);
          ghost.style.transition = `transform ${dur}ms cubic-bezier(.2,.8,.2,1), opacity ${dur}ms`;
          ghost.style.transform = `translate3d(${dx}px, ${dy}px, 0) scale(1)`;
          setTimeout(()=> {
            // overwrite target bar with new value
            array[toIndex] = value;
            updateBarValue(toIndex, value);
            // remove ghost
            ghost.style.opacity = '0';
            sourceBar.classList.remove('hilight');
            setTimeout(()=> {
              if (ghost && ghost.parentNode) ghost.parentNode.removeChild(ghost);
              resolve();
            }, 80/animationSpeed);
          }, dur + 10);
        });
      }

      function updateBarValue(index, value){
        array[index] = value;
        const bars = barsContainer.querySelectorAll('.bar');
        const bar = bars[index];
        if (!bar) return;
        bar.dataset.value = value;
        const heightPct = Math.max(8, Math.round((value/100)*92));
        bar.style.height = heightPct + '%';
        const label = bar.querySelector('.label');
        if (label) label.textContent = value;
        // color flash
        bar.classList.add('hilight');
        setTimeout(()=> bar.classList.remove('hilight'), 380/animationSpeed);
      }

      function overwriteIndex(index, value){
        updateBarValue(index, value);
        log(`Overwrite index ${index} with ${value}`);
      }

      // Buttons
      randomBtn.addEventListener('click', ()=>{
        const n = parseInt(sizeSlider.value,10);
        const arr = generateRandom(n);
        renderArray(arr);
      });

      startBtn.addEventListener('click', ()=>{
        if (actions.length===0) recordMergeSort(array);
        play();
      });
      pauseBtn.addEventListener('click', ()=> pause());
      stepBtn.addEventListener('click', ()=> {
        if (actions.length===0) recordMergeSort(array);
        step();
      });
      resetBtn.addEventListener('click', ()=>{
        renderArray(initialArray.slice());
      });

      applyBtn.addEventListener('click', ()=>{
        const txt = arrayInput.value.trim();
        if (!txt) return;
        const parts = txt.split(',').map(s=>parseInt(s.trim(),10)).filter(x=>!isNaN(x));
        if (parts.length===0) return;
        renderArray(parts);
      });
      clearBtn.addEventListener('click', ()=>{
        arrayInput.value = '';
      });

      speedSlider.addEventListener('input', ()=>{
        animationSpeed = parseFloat(speedSlider.value);
      });

      recToggle.addEventListener('change', ()=>{
        if (!recToggle.checked) rangesContainer.innerHTML = '';
      });

      toggleLog.addEventListener('click', ()=>{
        showLog = !showLog;
        logBox.style.display = showLog ? 'block' : 'none';
        toggleLog.textContent = showLog ? 'Hide Log' : 'Show Log';
      });

      // initial render
      renderArray(generateRandom(parseInt(sizeSlider.value,10)));

      // record actions from current array
      function recordMergeSort(arrayCopy){
        recordMergeSortAction(arrayCopy);
      }
      // To avoid naming collision: wrapper to call our recorder
      function recordMergeSortAction(arr){
        recordMergeSort(arr);
        actionIndex = 0;
        log('Recorded '+actions.length+' actions.');
      }

      // Expose togglePlay for keyboard
      window.togglePlay = togglePlay;

      // small helpful initializer: ensure barsContainer has reasonable width after layout
      window.addEventListener('resize', ()=>{
        createBars(array);
      });

    })();
  </script>
</body>
</html>