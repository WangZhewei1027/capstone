<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Adjacency Matrix — Interactive Module</title>
  <style>
    :root{
      --safe: 24px;
      --gap: 16px;
      --bg: #0f1720;
      --card: #0b1220;
      --accent: #38bdf8;
      --muted: #94a3b8;
      --good: #34d399;
      --danger:#fb7185;
      --glass: rgba(255,255,255,0.03);
      --radius: 12px;
      --max-nodes: 8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    /* Safe-area and responsive layout */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071027 0%, #051226 100%);
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .app{
      box-sizing:border-box;
      padding:var(--safe);
      min-height:100%;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      align-items:stretch;
    }

    header{
      display:flex;
      flex-direction:column;
      gap:8px;
      max-width:1100px;
      margin:0 auto;
    }

    .title{
      display:flex;
      align-items:center;
      gap:12px;
    }

    .title h1{
      margin:0;
      font-size:20px;
      letter-spacing:-0.2px;
    }

    .sub{
      color:var(--muted);
      font-size:13px;
    }

    main.module{
      display:grid;
      grid-template-columns: 1fr 420px;
      gap:var(--gap);
      max-width:1100px;
      margin:0 auto;
      align-items:start;
    }

    /* Stack on narrow screens */
    @media (max-width:900px){
      main.module{
        grid-template-columns: 1fr;
      }
    }

    /* Left: interactive canvas card */
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:18px;
      box-shadow: 0 4px 30px rgba(2,6,23,0.6);
      border: 1px solid rgba(255,255,255,0.03);
    }

    .canvas-wrap{
      height:420px;
      min-height:240px;
      position:relative;
      border-radius:10px;
      overflow:hidden;
      background: linear-gradient(180deg, rgba(15,23,32,0.6), rgba(2,6,23,0.6));
      display:flex;
      align-items:stretch;
      justify-content:stretch;
      gap:12px;
      padding:12px;
    }

    svg#graph{
      width:100%;
      height:100%;
      touch-action:none;
      cursor:crosshair;
    }

    .instructions{
      margin-top:12px;
      color:var(--muted);
      font-size:13px;
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }

    .controls{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:12px;
    }

    button, .toggle{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      padding:8px 12px;
      font-size:13px;
      border-radius:8px;
      min-height:40px;
      cursor:pointer;
    }
    button:focus{ outline:2px solid rgba(56,189,248,0.15); outline-offset:2px;}
    .primary{
      background: linear-gradient(90deg, rgba(56,189,248,0.12), rgba(52,211,153,0.06));
      border-color: rgba(56,189,248,0.18);
      color:var(--accent);
    }

    .toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
    }

    label.switch{
      display:inline-flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      user-select:none;
    }

    input[type="checkbox"]{
      width:44px;
      height:24px;
      -webkit-appearance:none;
      appearance:none;
      background:rgba(255,255,255,0.06);
      border-radius:20px;
      position:relative;
      outline:none;
      transition:background 180ms ease;
    }
    input[type="checkbox"]::after{
      content:"";
      position:absolute;
      width:18px;
      height:18px;
      background:white;
      border-radius:50%;
      top:3px;
      left:3px;
      transform:translateX(0);
      transition:transform 180ms cubic-bezier(.2,.9,.3,1);
    }
    input[type="checkbox"]:checked{
      background:linear-gradient(90deg,var(--accent),var(--good));
    }
    input[type="checkbox"]:checked::after{
      transform:translateX(20px);
    }

    .meta{
      margin-top:8px;
      color:var(--muted);
      font-size:13px;
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
    }

    /* Right: matrix and explanation */
    .side{
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .matrix-container{
      overflow:auto;
      border-radius:8px;
      padding:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      min-width:260px;
    }

    table.matrix{
      border-collapse:collapse;
      font-size:13px;
      color:var(--muted);
      min-width:240px;
    }
    table.matrix th, table.matrix td{
      border:1px solid rgba(255,255,255,0.03);
      padding:8px;
      text-align:center;
      min-width:36px;
      height:36px;
    }
    table.matrix th{
      background:rgba(255,255,255,0.02);
      color:#cfe9ff;
      font-weight:600;
      position:sticky;
      top:0;
      z-index:1;
      font-size:12px;
    }

    td.cell{
      cursor:pointer;
      transition:background 160ms, transform 160ms;
      background:transparent;
      color:var(--muted);
    }
    td.cell:hover{
      background:rgba(56,189,248,0.06);
      transform:scale(1.02);
    }
    td.cell.on{
      background:linear-gradient(90deg, rgba(56,189,248,0.14), rgba(52,211,153,0.06));
      color:var(--accent);
      font-weight:700;
    }

    .legend{
      color:var(--muted);
      font-size:13px;
    }

    .explain{
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    .live{
      margin-top:8px;
      min-height:22px;
      color:#cde9ff;
      font-size:13px;
    }

    /* Node style in svg */
    .node{
      cursor:pointer;
      transition:transform 120ms ease, filter 120ms;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.6));
    }
    .node circle{
      fill: linear-gradient(180deg,#0ea5e9,#036769);
      fill:#0ea5e9;
      stroke:#042a38;
      stroke-width:2px;
      transition: r 160ms ease, stroke 160ms;
    }
    .node .label{
      font-size:12px;
      text-anchor:middle;
      dominant-baseline:middle;
      fill:white;
      pointer-events:none;
      font-weight:600;
    }
    .node.selected circle{
      stroke: #fef3c7;
      stroke-width:3px;
      transform-origin:center;
      transform:scale(1.05);
    }

    .edge{
      stroke:rgba(255,255,255,0.08);
      stroke-width:3;
      fill:none;
      transition:stroke 160ms;
    }
    .edge.highlight{
      stroke:var(--accent);
      stroke-width:4;
      transition:stroke 120ms;
    }

    /* animation for drawing edges */
    .draw{
      stroke-dasharray: 1000;
      stroke-dashoffset: 1000;
      animation: draw 480ms forwards ease;
    }
    @keyframes draw{
      to{ stroke-dashoffset: 0; }
    }

    /* small utility */
    .muted{
      color:var(--muted);
    }

    footer{
      margin-top:12px;
      color:var(--muted);
      font-size:12px;
      text-align:center;
    }

    /* Accessibility focus ring for table cells */
    td.cell:focus{
      outline:2px solid rgba(56,189,248,0.18);
      outline-offset:2px;
    }

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Adjacency Matrix interactive module">
    <header>
      <div class="title">
        <h1>Adjacency Matrix — Visualizing Graphs as Matrices</h1>
      </div>
      <div class="sub">See how a graph maps to its adjacency matrix. Create nodes, add edges, drag nodes — the matrix updates live. Click matrix cells to highlight the corresponding edge.</div>
    </header>

    <main class="module" id="main-module">
      <!-- Interactive canvas / graph -->
      <section class="card" aria-labelledby="concept-title">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <strong id="concept-title">Interactive Graph</strong>
            <div class="muted" style="font-size:13px;margin-top:4px;">Click inside the area to add a node (max 8). Click one node then another to toggle an edge.</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;">
            <div class="muted" style="font-size:13px;">Nodes: <span id="node-count">0</span>/8</div>
          </div>
        </div>

        <div class="canvas-wrap" aria-hidden="false">
          <svg id="graph" role="img" aria-label="Graph canvas" tabindex="0"></svg>
        </div>

        <div class="controls" role="toolbar" aria-label="Graph controls">
          <button id="clear" class="toggle" title="Remove all nodes and edges">Clear</button>
          <button id="random" class="toggle" title="Generate a random graph">Random Graph</button>

          <label class="switch" title="Switch between undirected and directed">
            <input id="directed" type="checkbox" aria-checked="false" />
            <span style="font-size:13px;color:var(--muted)">Directed</span>
          </label>

          <button id="auto-arrange" class="toggle" title="Arrange nodes in a circle">Arrange</button>
          <div style="flex:1"></div>
          <div class="muted" style="font-size:13px">Tip: Tab to focus nodes or matrix cells, Enter toggles edge.</div>
        </div>

        <div class="instructions" aria-hidden="false">
          <div><strong>Interaction</strong></div>
          <div class="muted">- Add node: click blank area</div>
          <div class="muted">- Add/remove edge: click one node, then another</div>
          <div class="muted">- Matrix cell: click to toggle edge and highlight nodes</div>
          <div class="muted">- Drag nodes to change layout (matrix unchanged)</div>
        </div>

        <div class="meta">
          <div class="live" id="live-announcer" aria-live="polite" aria-atomic="true"></div>
        </div>
      </section>

      <!-- Side: matrix and explanation -->
      <aside class="side" aria-labelledby="learning-objective">
        <div class="card matrix-container" role="region" aria-label="Adjacency matrix panel">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div>
              <strong id="learning-objective">Learning Objective</strong>
              <div class="muted" style="font-size:13px;margin-top:4px;">Understand how a graph's edges correspond to entries in an adjacency matrix. Observe symmetry for undirected graphs and asymmetry for directed graphs.</div>
            </div>
          </div>

          <div style="margin-top:12px;overflow:auto;">
            <div id="matrix-area" tabindex="0">
              <!-- Matrix table is injected here -->
            </div>
          </div>

          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px;">
            <div class="legend">Cell = 1 if an edge exists from row-node -> column-node</div>
            <div style="color:var(--muted);font-size:13px">Click a cell to toggle and highlight</div>
          </div>
        </div>

        <div class="card" role="region" aria-label="Explanation">
          <div>
            <strong>Interaction Design</strong>
            <div class="explain" style="margin-top:8px;">
              - The left area is an interactive graph. Adding and connecting nodes updates the matrix on the right in real time.<br/>
              - When the graph is undirected, the matrix is symmetric: toggling edge (A,B) sets both M[A][B] and M[B][A].<br/>
              - Clicking a matrix cell highlights the corresponding edge and nodes in the graph with a brief animation, reinforcing the correspondence.
            </div>
          </div>

          <div style="margin-top:12px;">
            <strong>Layout Description</strong>
            <div class="explain" style="margin-top:8px;">
              - Safe area: 24px padding around the viewport. Elements use at least 16px spacing via CSS gaps.<br/>
              - Two-column layout on wider screens: left shows graph canvas (primary focus), right shows matrix and guidance.<br/>
              - Responsive: stacked on small screens; interactive elements are large enough for touch and keyboard accessible (tabindex on nodes and cells, Enter toggles).
            </div>
          </div>

        </div>

      </aside>
    </main>

    <footer>
      Built with plain HTML, CSS and JavaScript — no libraries. Explore adjacency matrices by experimenting with small graphs.
    </footer>
  </div>

  <script>
    // Adjacency Matrix Interactive Module
    // Self-contained vanilla JS implementation

    (function(){
      // Configuration
      const MAX_NODES = 8;
      const SVG = document.getElementById('graph');
      const matrixArea = document.getElementById('matrix-area');
      const directedCheckbox = document.getElementById('directed');
      const clearBtn = document.getElementById('clear');
      const randomBtn = document.getElementById('random');
      const autoArrangeBtn = document.getElementById('auto-arrange');
      const nodeCountEl = document.getElementById('node-count');
      const liveAnnouncer = document.getElementById('live-announcer');

      // State
      let nodes = []; // {id, x, y, label, elGroup}
      let edges = []; // {id, from, to, elPath}
      let adj = []; // 2D array NxN of 0/1
      let nextId = 0;
      let selectedNode = null;
      let svgRect = null;

      // Setup SVG defs for arrow marker
      function setupSVGDefs() {
        const ns = "http://www.w3.org/2000/svg";
        let defs = SVG.querySelector('defs');
        if (defs) defs.remove();
        defs = document.createElementNS(ns,'defs');
        const marker = document.createElementNS(ns,'marker');
        marker.setAttribute('id','arrow');
        marker.setAttribute('markerWidth','10');
        marker.setAttribute('markerHeight','10');
        marker.setAttribute('refX','10');
        marker.setAttribute('refY','5');
        marker.setAttribute('orient','auto');
        marker.setAttribute('markerUnits','strokeWidth');
        const path = document.createElementNS(ns,'path');
        path.setAttribute('d','M0,0 L10,5 L0,10 z');
        path.setAttribute('fill','#38bdf8');
        marker.appendChild(path);
        defs.appendChild(marker);
        SVG.appendChild(defs);
      }

      // Initialize
      function init(){
        setupSVGDefs();
        resizeSVG();
        window.addEventListener('resize', resizeSVG);
        SVG.addEventListener('click', onSVGClick);
        SVG.addEventListener('keydown', svgKeyDown);
        clearBtn.addEventListener('click', clearAll);
        randomBtn.addEventListener('click', randomGraph);
        autoArrangeBtn.addEventListener('click', arrangeCircle);
        directedCheckbox.addEventListener('change', onDirectedToggle);
        renderMatrix();
        announce("Module ready. Click inside the canvas to add a node.");
      }

      function resizeSVG(){
        const r = SVG.getBoundingClientRect();
        svgRect = r;
      }

      function onDirectedToggle(){
        // When toggling undirected->directed, nothing else changes.
        renderMatrix();
        announce(directedCheckbox.checked ? "Directed mode" : "Undirected mode");
      }

      function announce(msg){
        liveAnnouncer.textContent = msg;
      }

      function onSVGClick(evt){
        // If clicked on empty space, add node (unless max)
        if (nodes.length >= MAX_NODES) {
          announce("Maximum nodes reached ("+MAX_NODES+"). Remove some to add more.");
          return;
        }
        // Only add if target is the svg itself (not clicking nodes)
        if (evt.target === SVG || evt.target === SVG.querySelector('defs') ) {
          const rect = SVG.getBoundingClientRect();
          const x = evt.clientX - rect.left;
          const y = evt.clientY - rect.top;
          addNode(x, y);
        }
      }

      function addNode(x,y){
        const id = nextId++;
        const label = String.fromCharCode(65 + (nodes.length % 26)); // A,B,C...
        const node = { id, x, y, label, elGroup: null };
        nodes.push(node);
        // expand adjacency matrix
        adj.forEach(row => row.push(0));
        adj.push(new Array(nodes.length).fill(0));
        renderNode(node);
        nodeCountEl.textContent = nodes.length;
        renderMatrix();
        announce("Added node " + label);
      }

      function renderNode(node){
        const ns = "http://www.w3.org/2000/svg";
        const g = document.createElementNS(ns,'g');
        g.classList.add('node');
        g.setAttribute('data-id', node.id);
        g.setAttribute('tabindex', '0');
        g.setAttribute('role', 'button');
        g.setAttribute('aria-label', 'Node ' + node.label);
        // circle
        const circ = document.createElementNS(ns,'circle');
        circ.setAttribute('cx', node.x);
        circ.setAttribute('cy', node.y);
        circ.setAttribute('r', 18);
        circ.setAttribute('fill','#0ea5e9');
        circ.setAttribute('stroke','#042a38');
        // label
        const text = document.createElementNS(ns,'text');
        text.setAttribute('x', node.x);
        text.setAttribute('y', node.y + 1);
        text.classList.add('label');
        text.textContent = node.label;
        g.appendChild(circ);
        g.appendChild(text);
        SVG.appendChild(g);

        node.elGroup = g;

        // Events: click selects/toggles edge; drag to move
        g.addEventListener('click', function(e){
          e.stopPropagation();
          onNodeClick(node);
        });
        g.addEventListener('keydown', function(e){
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            onNodeClick(node);
          }
        });

        // Dragging
        let dragging = false;
        let start = null;

        function onPointerDown(e){
          e.preventDefault();
          dragging = true;
          start = getPoint(e);
          g.setPointerCapture(e.pointerId);
        }
        function onPointerMove(e){
          if (!dragging) return;
          const p = getPoint(e);
          const dx = p.x - start.x;
          const dy = p.y - start.y;
          node.x += dx; node.y += dy;
          start = p;
          updateNodePosition(node);
          updateAllEdgesVisual();
        }
        function onPointerUp(e){
          dragging = false;
          try{ g.releasePointerCapture(e.pointerId); }catch(err){}
        }

        g.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
      }

      function getPoint(e){
        const rect = SVG.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }

      function onNodeClick(node){
        if (selectedNode == null){
          // select this node
          selectNode(node);
          announce("Selected node " + node.label + ". Click another node to toggle an edge.");
        } else if (selectedNode.id === node.id){
          // Deselect
          deselectNode();
          announce("Deselected node " + node.label);
        } else {
          // Toggle edge between selectedNode and this node
          toggleEdge(selectedNode, node);
          deselectNode();
        }
      }

      function selectNode(node){
        deselectNode();
        selectedNode = node;
        if (node.elGroup) node.elGroup.classList.add('selected');
      }
      function deselectNode(){
        if (selectedNode && selectedNode.elGroup) selectedNode.elGroup.classList.remove('selected');
        selectedNode = null;
      }

      function toggleEdge(a, b){
        const i = nodes.findIndex(n => n.id === a.id);
        const j = nodes.findIndex(n => n.id === b.id);
        if (i < 0 || j < 0) return;
        const directed = directedCheckbox.checked;
        // If edge exists from i->j then remove, else add
        const exists = adj[i][j] === 1;
        if (exists){
          // remove
          adj[i][j] = 0;
          if (!directed) adj[j][i] = 0;
          removeEdgeVisual(a.id, b.id, directed);
          announce("Removed edge " + a.label + (directed ? " → " : " — ") + b.label);
        } else {
          // add
          adj[i][j] = 1;
          if (!directed) adj[j][i] = 1;
          addEdgeVisual(a.id, b.id, directed);
          announce("Added edge " + a.label + (directed ? " → " : " — ") + b.label);
        }
        renderMatrix(true, { from: i, to: j });
      }

      function addEdgeVisual(fromId, toId, directed){
        // For undirected, ensure single visual; for directed, a separate edge for direction
        // Use string id "e-from-to"
        const id = `e-${fromId}-${toId}`;
        // Remove any existing path for the same directed pair
        removeEdgeVisual(fromId, toId, true);
        const ns = "http://www.w3.org/2000/svg";
        const path = document.createElementNS(ns,'path');
        path.setAttribute('class','edge draw');
        path.setAttribute('data-from', fromId);
        path.setAttribute('data-to', toId);
        if (directed) path.setAttribute('marker-end','url(#arrow)');
        path.setAttribute('stroke-linecap','round');
        SVG.insertBefore(path, SVG.firstChild); // behind nodes
        // compute d
        const a = nodes.find(n=>n.id===fromId);
        const b = nodes.find(n=>n.id===toId);
        if (!a || !b) return;
        const d = linePath(a.x, a.y, b.x, b.y, directed);
        path.setAttribute('d', d);
        // store
        edges.push({ id, from: fromId, to: toId, elPath: path });
        // Flash matrix cell handled elsewhere
      }

      function removeEdgeVisual(fromId, toId, directedOnly){
        // Remove edges matching from->to
        for (let k = edges.length-1; k>=0; k--){
          const e = edges[k];
          if (e.from === fromId && e.to === toId){
            e.elPath.remove();
            edges.splice(k,1);
          }
        }
        if (!directedOnly){
          // also try reversed for undirected toggles
          for (let k = edges.length-1; k>=0; k--){
            const e = edges[k];
            if (e.from === toId && e.to === fromId){
              e.elPath.remove();
              edges.splice(k,1);
            }
          }
        }
      }

      function linePath(x1,y1,x2,y2,directed){
        // Simple straight or slightly curved for overlapping nodes
        // Return SVG path string
        const dx = x2 - x1;
        const dy = y2 - y1;
        const dist = Math.hypot(dx,dy) || 1;
        // offset ends to not overlap the circles (radius 18)
        const r = 20;
        const ux = dx/dist;
        const uy = dy/dist;
        const sx = x1 + ux*r;
        const sy = y1 + uy*r;
        const ex = x2 - ux*r;
        const ey = y2 - uy*r;
        // For self-loop
        if (dist < 2){
          const loopR = 28;
          return `M ${x1} ${y1} C ${x1 - loopR} ${y1 - loopR}, ${x1 + loopR} ${y1 - loopR}, ${x1} ${y1}`;
        }
        // Slight curve: control point midpoint offset perpendicular
        const mx = (sx + ex) / 2;
        const my = (sy + ey) / 2;
        const perpX = -uy;
        const perpY = ux;
        const curve = 18;
        const c1x = mx + perpX*curve;
        const c1y = my + perpY*curve;
        return `M ${sx} ${sy} Q ${c1x} ${c1y} ${ex} ${ey}`;
      }

      function updateNodePosition(node){
        const g = node.elGroup;
        if (!g) return;
        const circ = g.querySelector('circle');
        const text = g.querySelector('text');
        circ.setAttribute('cx', node.x);
        circ.setAttribute('cy', node.y);
        text.setAttribute('x', node.x);
        text.setAttribute('y', node.y + 1);
      }

      function updateAllEdgesVisual(){
        edges.forEach(e => {
          const a = nodes.find(n=>n.id===e.from);
          const b = nodes.find(n=>n.id===e.to);
          if (!a || !b) return;
          const directed = directedCheckbox.checked;
          const d = linePath(a.x,a.y,b.x,b.y,directed);
          e.elPath.setAttribute('d', d);
        });
      }

      function renderMatrix(flash=false, flashCell=null){
        // Build table with headers A.. up to current nodes
        matrixArea.innerHTML = '';
        const n = nodes.length;
        if (n === 0){
          matrixArea.innerHTML = '<div class="muted">No nodes yet. Add nodes by clicking the canvas.</div>';
          return;
        }
        const table = document.createElement('table');
        table.className = 'matrix';
        table.setAttribute('role','grid');

        // header row
        const thead = document.createElement('thead');
        const trh = document.createElement('tr');
        const thBlank = document.createElement('th');
        thBlank.textContent = '';
        trh.appendChild(thBlank);
        nodes.forEach((node, idx) => {
          const th = document.createElement('th');
          th.textContent = node.label;
          trh.appendChild(th);
        });
        thead.appendChild(trh);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        nodes.forEach((rowNode, i) => {
          const tr = document.createElement('tr');
          const rowHead = document.createElement('th');
          rowHead.textContent = rowNode.label;
          tr.appendChild(rowHead);
          for (let j=0;j<n;j++){
            const td = document.createElement('td');
            td.className = 'cell';
            td.setAttribute('role','gridcell');
            td.setAttribute('tabindex','0');
            td.setAttribute('data-row', i);
            td.setAttribute('data-col', j);
            const val = adj[i][j] || 0;
            td.textContent = val;
            if (val === 1) td.classList.add('on');
            td.addEventListener('click', onCellClick);
            td.addEventListener('keydown', function(e){
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                onCellClick.call(this, e);
              }
            });
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        matrixArea.appendChild(table);

        // Optionally flash a specific cell (from, to index)
        if (flash && flashCell){
          const cells = matrixArea.querySelectorAll('td.cell');
          cells.forEach(td => {
            const r = parseInt(td.getAttribute('data-row'),10);
            const c = parseInt(td.getAttribute('data-col'),10);
            if (r === flashCell.from && c === flashCell.to){
              td.animate([
                { background: 'rgba(56,189,248,0.24)', transform: 'scale(1.02)'},
                { background: 'transparent', transform: 'scale(1)'}
              ], { duration: 420 });
            }
          });
        }
      }

      function onCellClick(e){
        // Toggle edge corresponding to row->col
        const td = e.currentTarget || e.target;
        const r = parseInt(td.getAttribute('data-row'),10);
        const c = parseInt(td.getAttribute('data-col'),10);
        if (isNaN(r) || isNaN(c)) return;
        const a = nodes[r];
        const b = nodes[c];
        if (!a || !b) return;

        // If clicking the same row/col for undirected, it's toggling self-edge/other
        const directed = directedCheckbox.checked;
        // Toggle using same logic as clicking nodes
        const exists = adj[r][c] === 1;
        if (exists){
          adj[r][c] = 0;
          if (!directed) adj[c][r] = 0;
          removeEdgeVisual(a.id, b.id, directed);
          announce("Removed edge from " + a.label + " to " + b.label);
        } else {
          adj[r][c] = 1;
          if (!directed) adj[c][r] = 1;
          addEdgeVisual(a.id, b.id, directed);
          announce("Added edge from " + a.label + " to " + b.label);
        }
        // Visual highlight: flash the path and nodes
        highlightEdgeVisual(a.id, b.id);
        renderMatrix(true, { from: r, to: c });
      }

      function highlightEdgeVisual(fromId, toId){
        // Find path(s) that correspond and add highlight class temporarily; if not found, create a transient path for animation
        let found = false;
        edges.forEach(e => {
          if (e.from === fromId && e.to === toId){
            found = true;
            e.elPath.classList.add('highlight');
            setTimeout(()=> e.elPath.classList.remove('highlight'), 600);
          }
        });
        // Highlight nodes
        const na = nodes.find(n => n.id === fromId);
        const nb = nodes.find(n => n.id === toId);
        [na, nb].forEach(n => {
          if (!n || !n.elGroup) return;
          n.elGroup.classList.add('selected');
          setTimeout(()=> n.elGroup.classList.remove('selected'), 600);
        });

        // If no actual visual edge exists yet (newly added or graph empty), create a transient dashed line animation to show correspondence
        if (!found){
          const ns = "http://www.w3.org/2000/svg";
          const tmp = document.createElementNS(ns,'path');
          tmp.setAttribute('class','edge highlight draw');
          tmp.setAttribute('stroke-dasharray','6 6');
          tmp.setAttribute('stroke-linecap','round');
          SVG.insertBefore(tmp, SVG.firstChild);
          const a = nodes.find(n=>n.id===fromId);
          const b = nodes.find(n=>n.id===toId);
          if (!a || !b) return;
          tmp.setAttribute('d', linePath(a.x,a.y,b.x,b.y, directedCheckbox.checked));
          setTimeout(()=> tmp.remove(), 700);
        }
      }

      function clearAll(){
        // Clear nodes, edges, matrix
        nodes.forEach(n => {
          if (n.elGroup) n.elGroup.remove();
        });
        edges.forEach(e => e.elPath.remove());
        nodes = [];
        edges = [];
        adj = [];
        nextId = 0;
        selectedNode = null;
        nodeCountEl.textContent = '0';
        renderMatrix();
        announce("Cleared all nodes and edges.");
      }

      function randomGraph(){
        clearAll();
        const n = Math.max(2, Math.min(MAX_NODES, Math.floor(Math.random()* (MAX_NODES-1)) + 2));
        // create nodes arranged in a circle
        const w = SVG.clientWidth;
        const h = SVG.clientHeight;
        const cx = w/2;
        const cy = h/2;
        const radius = Math.min(w,h) / 3;
        for (let i=0;i<n;i++){
          const ang = (i / n) * Math.PI * 2;
          addNode(cx + Math.cos(ang)*radius, cy + Math.sin(ang)*radius);
        }
        // random edges
        const directed = Math.random() < 0.5;
        directedCheckbox.checked = directed;
        for (let i=0;i<n;i++){
          for (let j=0;j<n;j++){
            if (i===j) continue;
            if (Math.random() < 0.3){
              adj[i][j] = 1;
              addEdgeVisual(nodes[i].id, nodes[j].id, directed);
            }
          }
        }
        // if undirected, symmetrize
        if (!directed){
          for (let i=0;i<n;i++){
            for (let j=i+1;j<n;j++){
              if (adj[i][j] || adj[j][i]){
                adj[i][j] = adj[j][i] = 1;
              }
            }
          }
        }
        renderMatrix();
        announce("Generated a random " + (directed ? "directed" : "undirected") + " graph with " + n + " nodes.");
      }

      function arrangeCircle(){
        const n = nodes.length;
        if (n === 0) return;
        const w = SVG.clientWidth;
        const h = SVG.clientHeight;
        const cx = w/2;
        const cy = h/2;
        const radius = Math.min(w,h) / 3;
        nodes.forEach((node, idx) => {
          const ang = (idx / n) * Math.PI * 2;
          node.x = cx + Math.cos(ang)*radius;
          node.y = cy + Math.sin(ang)*radius;
          updateNodePosition(node);
        });
        updateAllEdgesVisual();
        announce("Nodes arranged in a circle.");
      }

      // keyboard support for svg: create nodes with Enter opens add? We'll keep Enter triggers selection on focused node group.
      function svgKeyDown(e){
        // If svg focused and Enter pressed, add node at center
        if (e.target === SVG && (e.key === 'Enter' || e.key === ' ')){
          e.preventDefault();
          const x = SVG.clientWidth / 2;
          const y = SVG.clientHeight / 2;
          addNode(x,y);
        }
      }

      // initialize on page load
      init();

    })();
  </script>
</body>
</html>