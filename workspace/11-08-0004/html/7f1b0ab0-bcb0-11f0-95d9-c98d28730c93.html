<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive DFS Explorer</title>
  <style>
    :root{
      --safe:24px;
      --gap:16px;
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#2dd4bf;
      --muted:#94a3b8;
      --node:#e2e8f0;
      --node-visited:#10b981;
      --node-active:#3b82f6;
      --node-start:#f59e0b;
      --edge:#475569;
      --edge-active:#7c3aed;
      --glass: rgba(255,255,255,0.03);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,var(--bg),#071029 85%);
      color:var(--node);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      padding:var(--safe);
      box-sizing:border-box;
      height:100%;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:var(--gap);
    }
    .title{
      font-size:20px;
      font-weight:700;
      letter-spacing:-0.02em;
    }
    .subtitle{
      color:var(--muted);
      font-size:13px;
    }

    main.module{
      display:grid;
      grid-template-columns: 300px 1fr 340px;
      gap:var(--gap);
      align-items:start;
    }

    /* Responsive single-column fallback */
    @media (max-width:1100px){
      main.module{
        grid-template-columns: 1fr;
      }
    }

    /* Left controls panel */
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:18px;
      min-height:160px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.5);
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    .panel h3{
      margin:0;
      font-size:15px;
      color:var(--node);
    }
    .panel p{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    .controls-row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }

    .btn{
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.04);
      color:var(--node);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }
    .btn:focus{outline:3px solid rgba(59,130,246,0.25); outline-offset:2px;}
    .btn.primary{
      background:linear-gradient(90deg,var(--accent),#60a5fa);
      color:#042029;
      font-weight:600;
    }
    .btn.ghost{
      background:transparent;
      border:1px dashed rgba(255,255,255,0.06);
    }
    .toggle{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .toggle input[type="checkbox"]{display:none;}
    .switch{
      width:48px;
      height:28px;
      background:rgba(255,255,255,0.05);
      border-radius:999px;
      padding:3px;
      box-sizing:border-box;
      display:inline-block;
      position:relative;
      cursor:pointer;
    }
    .knob{
      width:22px;
      height:22px;
      background:white;
      border-radius:50%;
      position:absolute;
      transition:transform 200ms cubic-bezier(.2,.9,.3,1);
      transform:translateX(0);
      top:50%;
      left:3px;
      transform:translate(0,-50%);
    }
    input:checked + .switch .knob{
      transform:translate(20px,-50%);
    }

    /* Canvas area */
    .canvas-wrap{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      border-radius:12px;
      min-height:560px;
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:12px;
      box-shadow: 0 8px 30px rgba(2,6,23,0.5);
    }
    .canvas-toolbar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .hint{
      color:var(--muted);
      font-size:13px;
    }

    /* SVG canvas styles */
    #svgCanvas{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      flex:1;
      border-radius:8px;
      overflow:visible;
      touch-action:none;
      cursor:grab;
    }
    #svgCanvas:active{cursor:grabbing;}
    .edge{
      stroke:var(--edge);
      stroke-width:3;
      stroke-linecap:round;
      transition:stroke 240ms ease, stroke-width 160ms ease, opacity 220ms;
      opacity:0.95;
    }
    .edge.active{
      stroke:var(--edge-active);
      stroke-width:4;
      filter:drop-shadow(0 4px 10px rgba(124,58,237,0.18));
    }
    .node{
      cursor:pointer;
      transition:fill 220ms ease, transform 160ms ease, stroke 160ms ease;
    }
    .node circle{
      fill:var(--node);
      r:22;
      stroke:transparent;
      stroke-width:3;
    }
    .node .label{
      font-size:12px;
      fill:#071029;
      font-weight:700;
      pointer-events:none;
    }
    .node.start circle{
      stroke:var(--node-start);
      stroke-width:3.5;
      filter:drop-shadow(0 6px 14px rgba(245,158,11,0.12));
    }
    .node.active circle{
      fill:var(--node-active);
      color:white;
    }
    .node.visited circle{
      fill:var(--node-visited);
      transform:scale(0.98);
    }
    .node.backtracked circle{
      fill:rgba(226,232,240,0.16);
      stroke:rgba(255,255,255,0.02);
    }

    /* Right panel: state visualization */
    .state-panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:12px;
      min-height:160px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .stack-view{
      background:rgba(255,255,255,0.02);
      border-radius:10px;
      padding:10px;
      min-height:140px;
      max-height:240px;
      overflow:auto;
    }
    .stack-item{
      background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:8px 10px;
      margin-bottom:10px;
      border-radius:8px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      color:var(--node);
      transform-origin:center;
      transition:transform 220ms ease, opacity 220ms ease;
    }
    .stack-item.push{
      transform:translateX(10px);
      opacity:0;
      animation:pushIn 260ms forwards;
    }
    .stack-item.pop{
      animation:popOut 220ms forwards;
    }
    @keyframes pushIn{
      to{transform:translateX(0); opacity:1;}
    }
    @keyframes popOut{
      to{transform:translateX(12px); opacity:0;}
    }

    .visited-list{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      padding:6px;
      min-height:32px;
      align-items:center;
    }
    .visited-chip{
      padding:6px 8px;
      border-radius:999px;
      background:rgba(255,255,255,0.03);
      color:var(--node);
      font-weight:600;
      font-size:13px;
    }

    .pseudocode{
      background:linear-gradient(180deg, rgba(7,10,15,0.5), rgba(0,0,0,0.2));
      padding:10px;
      border-radius:10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
      color:var(--muted);
      min-height:120px;
    }
    .code-line{
      padding:6px;
      border-radius:6px;
    }
    .code-line.current{
      background:linear-gradient(90deg, rgba(99,102,241,0.12), rgba(59,130,246,0.04));
      color:var(--node);
      font-weight:600;
    }

    .legend{
      display:flex;
      gap:8px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
      flex-wrap:wrap;
    }
    .legend .swatch{
      width:12px;
      height:12px;
      border-radius:3px;
      display:inline-block;
      margin-right:6px;
      vertical-align:middle;
    }

    footer{
      color:var(--muted);
      font-size:13px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }

    /* Minor UI niceties */
    select,input[type=range]{
      background:transparent;
      color:var(--node);
      border:1px solid rgba(255,255,255,0.04);
      padding:8px;
      border-radius:8px;
      font-size:13px;
    }
    label{font-size:13px; color:var(--muted); display:block; margin-bottom:6px;}
    small{color:var(--muted); font-size:12px;}

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Depth First Search interactive module">
    <header>
      <div>
        <div class="title">Depth‑First Search (DFS) — Explorer</div>
        <div class="subtitle">Interactively step through DFS, watch the stack/call‑stack and edge traversal animations.</div>
      </div>
      <div style="display:flex;gap:12px;align-items:center;">
        <div style="color:var(--muted);font-size:13px;">Tip: Click canvas to add nodes. Drag nodes to reposition. Toggle Connect to link nodes.</div>
        <button class="btn ghost" id="resetGraphBtn" title="Reset graph (keeps nodes)">&orarr; Reset Traversal</button>
      </div>
    </header>

    <main class="module" >
      <!-- LEFT PANEL -->
      <aside class="panel" aria-label="Controls and instructions">
        <h3>Learning Objective</h3>
        <p>Explore how DFS explores nodes deeply then backtracks. Compare recursive vs iterative stack behavior and control traversal order.</p>

        <div style="display:flex;flex-direction:column;gap:10px;">
          <div class="controls-row">
            <button class="btn primary" id="playPauseBtn" aria-label="Play or pause traversal">Play</button>
            <button class="btn" id="stepBtn" aria-label="Step forward one micro-step">Step</button>
            <button class="btn" id="resetBtn" aria-label="Reset traversal and clear visited">Reset</button>
          </div>

          <div style="display:flex;gap:12px;align-items:center;">
            <div style="flex:1;">
              <label for="speedRange">Speed</label>
              <input id="speedRange" type="range" min="100" max="1500" value="600" />
              <div style="color:var(--muted);font-size:12px;margin-top:6px;">Delay between steps (ms)</div>
            </div>
          </div>

          <div style="display:flex;flex-direction:column;gap:8px;">
            <label>Algorithm Mode</label>
            <div style="display:flex;gap:8px;">
              <button class="btn ghost" id="modeIter">Iterative</button>
              <button class="btn ghost" id="modeRec">Recursive</button>
            </div>
          </div>

          <div style="display:flex;flex-direction:column;gap:8px;">
            <label>Neighbor Order</label>
            <div style="display:flex;gap:8px;">
              <button class="btn ghost" id="orderId">By ID</button>
              <button class="btn ghost" id="orderAngle">By Angle</button>
            </div>
            <small class="hint">Angle order uses clockwise angle around node (visual exploration order).</small>
          </div>

          <div style="display:flex;flex-direction:column;gap:8px;">
            <label>Editing</label>
            <div style="display:flex;gap:8px;align-items:center;">
              <button class="btn ghost" id="toggleAdd">Add Nodes</button>
              <button class="btn ghost" id="toggleConnect">Connect</button>
            </div>
            <small class="hint">Add: click empty canvas. Connect: click two nodes to create an undirected edge.</small>
          </div>

          <div style="display:flex;flex-direction:column;gap:6px;">
            <label for="startSelect">Start Node</label>
            <select id="startSelect" aria-label="Select starting node"></select>
          </div>
        </div>
      </aside>

      <!-- CANVAS -->
      <section class="canvas-wrap" aria-label="Graph canvas and editor">
        <div class="canvas-toolbar">
          <div class="hint">Canvas: click to add nodes (Add mode). Drag nodes to move. Use Connect mode to link nodes.</div>
          <div style="display:flex;gap:8px;align-items:center;">
            <button class="btn" id="clearGraphBtn" title="Clear entire graph">Clear Graph</button>
            <button class="btn" id="sampleBtn" title="Load sample graph">Load Sample</button>
          </div>
        </div>

        <svg id="svgCanvas" viewBox="0 0 900 600" role="img" aria-label="Graph canvas">
          <defs>
            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
              <feMerge>
                <feMergeNode in="coloredBlur"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          <g id="edges"></g>
          <g id="nodes"></g>
        </svg>

        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div style="color:var(--muted);font-size:13px;">State: <span id="statusMsg">Idle</span></div>
          <div style="color:var(--muted);font-size:13px;">Shortcuts: Space=Play/Pause · → = Step · Esc = Reset</div>
        </div>
      </section>

      <!-- RIGHT PANEL -->
      <aside class="state-panel" aria-label="State visualization">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <h3 style="margin:0;font-size:15px;">Stack / Call Stack</h3>
          <div style="color:var(--muted);font-size:13px;">Mode: <strong id="modeLabel">Iterative</strong></div>
        </div>

        <div class="stack-view" id="stackView" aria-live="polite"></div>

        <div>
          <h4 style="margin:0;font-size:14px;">Visited Order</h4>
          <div class="visited-list" id="visitedList" aria-live="polite"></div>
        </div>

        <div>
          <h4 style="margin:0;font-size:14px;">Pseudocode</h4>
          <div class="pseudocode" id="pseudocode">
            <div class="code-line" data-line="1">1. DFS(node):</div>
            <div class="code-line" data-line="2">2.   mark node as visited</div>
            <div class="code-line" data-line="3">3.   for each neighbor in neighbors(node):</div>
            <div class="code-line" data-line="4">4.     if neighbor not visited:</div>
            <div class="code-line" data-line="5">5.       DFS(neighbor)</div>
            <div style="height:8px"></div>
            <div style="font-size:12px;color:var(--muted);">Iterative uses a stack to push neighbors and pop to visit. Lines mapped approximately.</div>
          </div>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div class="legend">
            <div><span class="swatch" style="background:var(--node-start)"></span>Start</div>
            <div><span class="swatch" style="background:var(--node-active)"></span>Active/On Stack</div>
            <div><span class="swatch" style="background:var(--node-visited)"></span>Visited</div>
          </div>
          <div style="color:var(--muted);font-size:12px;">DFS Explorer · Vanilla JS</div>
        </div>
      </aside>
    </main>

    <footer>
      <div>Interactions: Add/Connect nodes, choose start node, step/play DFS.</div>
      <div style="color:var(--muted);">Accessible and responsive. No external libraries.</div>
    </footer>
  </div>

  <script>
    // Self-contained DFS interactive module
    (function(){
      // Utilities
      const $ = (s, r=document) => r.querySelector(s);
      const $$ = (s, r=document) => Array.from(r.querySelectorAll(s));
      // DOM elements
      const svg = $('#svgCanvas');
      const edgesGroup = $('#edges');
      const nodesGroup = $('#nodes');
      const startSelect = $('#startSelect');
      const playPauseBtn = $('#playPauseBtn');
      const stepBtn = $('#stepBtn');
      const resetBtn = $('#resetBtn');
      const resetGraphBtn = $('#resetGraphBtn');
      const speedRange = $('#speedRange');
      const modeIter = $('#modeIter');
      const modeRec = $('#modeRec');
      const modeLabel = $('#modeLabel');
      const orderId = $('#orderId');
      const orderAngle = $('#orderAngle');
      const toggleAdd = $('#toggleAdd');
      const toggleConnect = $('#toggleConnect');
      const statusMsg = $('#statusMsg');
      const stackView = $('#stackView');
      const visitedList = $('#visitedList');
      const pseudocode = $('#pseudocode');
      const sampleBtn = $('#sampleBtn');
      const clearGraphBtn = $('#clearGraphBtn');

      // Internal state
      let nodes = []; // {id,x,y}
      let edges = []; // {id,a,b}
      let nodeIdCounter = 1;
      let edgeIdCounter = 1;

      let addMode = false;
      let connectMode = false;
      let selectedForConnect = null;
      let dragging = null;
      let dragOffset = {x:0,y:0};
      let playing = false;
      let timer = null;
      let delay = parseInt(speedRange.value);
      let algorithm = 'iterative'; // 'iterative' or 'recursive'
      let neighborOrder = 'id'; // 'id' or 'angle'
      let traversal = null; // generator producing micro-steps
      let visitedSet = new Set();
      let stackState = []; // representation of stack frames for view
      let visitedSequence = [];

      function logStatus(t){ statusMsg.textContent = t; }

      // Graph manipulation
      function addNode(x,y, id=null){
        const nid = id || nodeIdCounter++;
        const node = {id:nid, x, y};
        nodes.push(node);
        renderGraph();
        refreshStartSelect();
        return node;
      }
      function addEdge(a,b){
        // prevent duplicates
        if (edges.some(e=> (e.a===a && e.b===b) || (e.a===b && e.b===a))) return null;
        const eid = edgeIdCounter++;
        edges.push({id:eid,a,b});
        renderGraph();
        return eid;
      }
      function clearGraph(){
        nodes=[];
        edges=[];
        nodeIdCounter=1;
        edgeIdCounter=1;
        resetTraversalState();
        renderGraph();
        refreshStartSelect();
      }
      function loadSample(){
        clearGraph();
        // sample layout
        addNode(160,150,1);
        addNode(320,90,2);
        addNode(360,240,3);
        addNode(220,320,4);
        addNode(480,140,5);
        addNode(620,200,6);
        addNode(540,340,7);
        addEdge(1,2);
        addEdge(1,3);
        addEdge(2,3);
        addEdge(3,4);
        addEdge(2,5);
        addEdge(5,6);
        addEdge(6,7);
        renderGraph();
        refreshStartSelect();
      }

      // Render: nodes and edges
      function renderGraph(){
        // clear groups
        edgesGroup.innerHTML='';
        nodesGroup.innerHTML='';

        // draw edges
        for (const e of edges){
          const a = nodes.find(n=>n.id===e.a);
          const b = nodes.find(n=>n.id===e.b);
          if (!a || !b) continue;
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', a.x);
          line.setAttribute('y1', a.y);
          line.setAttribute('x2', b.x);
          line.setAttribute('y2', b.y);
          line.setAttribute('class','edge');
          line.dataset.id = e.id;
          line.dataset.a = e.a;
          line.dataset.b = e.b;
          edgesGroup.appendChild(line);
        }

        // draw nodes
        for (const n of nodes){
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('transform',`translate(${n.x},${n.y})`);
          g.setAttribute('class','node');
          g.dataset.id = n.id;

          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circle.setAttribute('r',22);
          g.appendChild(circle);

          const label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('class','label');
          label.setAttribute('text-anchor','middle');
          label.setAttribute('dy','4');
          label.textContent = n.id;
          g.appendChild(label);

          // interactions
          g.addEventListener('mousedown', onNodeMouseDown);
          g.addEventListener('touchstart', onNodeTouchStart, {passive:false});
          g.addEventListener('click', (ev)=> {
            ev.stopPropagation();
            onNodeClick(n.id);
          });

          nodesGroup.appendChild(g);
        }

        applyTraversalVisuals();
      }

      // Visual state update
      function applyTraversalVisuals(){
        // clear classes
        $$('.node', nodesGroup).forEach(el=>{
          el.classList.remove('active','visited','backtracked','start');
          const id = parseInt(el.dataset.id,10);
          if (visitedSet.has(id)){
            el.classList.add('visited');
          }
        });
        // start highlight
        const startVal = parseInt(startSelect.value,10);
        if (!isNaN(startVal)) {
          const nEl = $(`.node[data-id="${startVal}"]`);
          if (nEl) nEl.classList.add('start');
        }
        // active stack items highlight
        for (const s of stackState){
          const el = $(`.node[data-id="${s.node}"]`);
          if (el) el.classList.add('active');
        }
        // edges active class handled during step animations
      }

      function refreshStartSelect(){
        const sel = startSelect;
        const cur = sel.value;
        sel.innerHTML='';
        for (const n of nodes){
          const opt = document.createElement('option');
          opt.value = n.id;
          opt.textContent = 'Node ' + n.id;
          sel.appendChild(opt);
        }
        if (nodes.length>0){
          if (nodes.some(x=>String(x.id)===cur)) sel.value=cur;
          else sel.value = nodes[0].id;
        }
      }

      // Node interactions
      function clientToSvgPoint(clientX, clientY){
        const pt = svg.createSVGPoint();
        pt.x = clientX; pt.y = clientY;
        const ctm = svg.getScreenCTM();
        const global = pt.matrixTransform(ctm.inverse());
        return {x:global.x, y:global.y};
      }

      function onNodeMouseDown(e){
        e.stopPropagation();
        const id = parseInt(this.dataset.id,10);
        const node = nodes.find(n=>n.id===id);
        if (!node) return;
        dragging = node;
        const p = clientToSvgPoint(e.clientX, e.clientY);
        dragOffset.x = node.x - p.x;
        dragOffset.y = node.y - p.y;
        window.addEventListener('mousemove', onWindowMouseMove);
        window.addEventListener('mouseup', onWindowMouseUp);
      }
      function onWindowMouseMove(e){
        if (!dragging) return;
        const p = clientToSvgPoint(e.clientX, e.clientY);
        dragging.x = p.x + dragOffset.x;
        dragging.y = p.y + dragOffset.y;
        renderGraph();
      }
      function onWindowMouseUp(e){
        dragging = null;
        window.removeEventListener('mousemove', onWindowMouseMove);
        window.removeEventListener('mouseup', onWindowMouseUp);
      }

      function onNodeTouchStart(e){
        e.preventDefault();
        const touch = e.touches[0];
        const id = parseInt(this.dataset.id,10);
        const node = nodes.find(n=>n.id===id);
        if (!node) return;
        dragging = node;
        const p = clientToSvgPoint(touch.clientX, touch.clientY);
        dragOffset.x = node.x - p.x;
        dragOffset.y = node.y - p.y;
        window.addEventListener('touchmove', onWindowTouchMove, {passive:false});
        window.addEventListener('touchend', onWindowTouchEnd);
      }
      function onWindowTouchMove(e){
        if (!dragging) return;
        e.preventDefault();
        const touch = e.touches[0];
        const p = clientToSvgPoint(touch.clientX, touch.clientY);
        dragging.x = p.x + dragOffset.x;
        dragging.y = p.y + dragOffset.y;
        renderGraph();
      }
      function onWindowTouchEnd(e){
        dragging = null;
        window.removeEventListener('touchmove', onWindowTouchMove);
        window.removeEventListener('touchend', onWindowTouchEnd);
      }

      function onNodeClick(nodeId){
        if (addMode){
          // ignore
          return;
        }
        if (connectMode){
          if (!selectedForConnect){
            selectedForConnect = nodeId;
            statusMsg.textContent = 'Select node to connect with Node ' + nodeId;
          } else if (selectedForConnect === nodeId){
            selectedForConnect = null;
            statusMsg.textContent = 'Connect cancelled';
          } else {
            addEdge(selectedForConnect, nodeId);
            selectedForConnect = null;
            statusMsg.textContent = 'Edge added';
          }
          return;
        }
        // set start node
        startSelect.value = nodeId;
        statusMsg.textContent = 'Start set to Node ' + nodeId;
        renderGraph();
      }

      // Canvas click to add node when in addMode
      svg.addEventListener('click', function(e){
        if (!addMode) return;
        const p = clientToSvgPoint(e.clientX, e.clientY);
        addNode(p.x, p.y);
        statusMsg.textContent = 'Node added';
      });

      // controls
      toggleAdd.addEventListener('click', ()=>{
        addMode = !addMode;
        toggleAdd.classList.toggle('primary', addMode);
        if (addMode){
          connectMode = false;
          toggleConnect.classList.remove('primary');
          statusMsg.textContent = 'Add mode: click canvas to add nodes.';
        } else {
          statusMsg.textContent = 'Add mode off';
        }
      });
      toggleConnect.addEventListener('click', ()=>{
        connectMode = !connectMode;
        toggleConnect.classList.toggle('primary', connectMode);
        if (connectMode){
          addMode = false;
          toggleAdd.classList.remove('primary');
          statusMsg.textContent = 'Connect mode: click two nodes to create an edge.';
        } else {
          selectedForConnect = null;
          statusMsg.textContent = 'Connect mode off';
        }
      });

      // sample and clear
      sampleBtn.addEventListener('click', ()=> { loadSample(); statusMsg.textContent='Sample graph loaded'; });
      clearGraphBtn.addEventListener('click', ()=> { if(confirm('Clear entire graph?')){ clearGraph(); statusMsg.textContent='Graph cleared'; } });

      // start select change
      startSelect.addEventListener('change', ()=> renderGraph());

      // modes
      function setAlgorithm(a){
        algorithm = a;
        modeIter.classList.toggle('primary', a==='iterative');
        modeRec.classList.toggle('primary', a==='recursive');
        modeLabel.textContent = a === 'iterative' ? 'Iterative' : 'Recursive';
      }
      modeIter.addEventListener('click', ()=> setAlgorithm('iterative'));
      modeRec.addEventListener('click', ()=> setAlgorithm('recursive'));
      setAlgorithm('iterative');

      orderId.addEventListener('click', ()=> { neighborOrder='id'; orderId.classList.add('primary'); orderAngle.classList.remove('primary'); });
      orderAngle.addEventListener('click', ()=> { neighborOrder='angle'; orderAngle.classList.add('primary'); orderId.classList.remove('primary'); });
      orderId.classList.add('primary');

      // Reset traversal (clears visited, stack)
      resetBtn.addEventListener('click', ()=> { resetTraversalState(); renderGraph(); statusMsg.textContent='Traversal reset'; });
      resetGraphBtn.addEventListener('click', ()=> { resetTraversalState(); renderGraph(); statusMsg.textContent='Traversal reset'; });
      function resetTraversalState(){
        stopPlaying();
        visitedSet.clear();
        stackState=[];
        visitedSequence=[];
        updateStackView();
        updateVisitedView();
        highlightPseudocode(null);
        traversal = null;
        logStatus('Idle');
      }

      // Play/Pause and Step
      playPauseBtn.addEventListener('click', togglePlayPause);
      stepBtn.addEventListener('click', stepOnce);

      speedRange.addEventListener('input', ()=> { delay = parseInt(speedRange.value); });

      function togglePlayPause(){
        if (playing) stopPlaying();
        else startPlaying();
      }
      function startPlaying(){
        if (!traversal){
          const start = parseInt(startSelect.value,10);
          if (isNaN(start)){
            alert('Choose a start node first.');
            return;
          }
          prepareTraversal(start);
        }
        playing = true;
        playPauseBtn.textContent='Pause';
        playPauseBtn.classList.add('primary');
        scheduleNext();
      }
      function stopPlaying(){
        playing = false;
        playPauseBtn.textContent='Play';
        playPauseBtn.classList.remove('primary');
        if (timer) { clearTimeout(timer); timer = null; }
      }
      function scheduleNext(){
        if (!playing) return;
        timer = setTimeout(async ()=>{
          const done = await stepTraversal();
          if (done) { stopPlaying(); statusMsg.textContent='Traversal complete'; }
          else scheduleNext();
        }, delay);
      }

      // Step
      function stepOnce(){
        if (!traversal){
          const start = parseInt(startSelect.value,10);
          if (isNaN(start)){
            alert('Choose a start node first.');
            return;
          }
          prepareTraversal(start);
        }
        stepTraversal().then(done=>{
          if (done) statusMsg.textContent='Traversal complete';
        });
      }

      // Setup traversal (generator)
      function prepareTraversal(startNodeId){
        visitedSet.clear();
        visitedSequence=[];
        stackState=[];
        updateStackView();
        updateVisitedView();
        traversal = (algorithm === 'iterative') ? iterativeDFSGenerator(startNodeId) : recursiveDFSGenerator(startNodeId);
      }

      // Step runner: executes next micro-step of generator
      async function stepTraversal(){
        if (!traversal) return true;
        const res = traversal.next();
        if (res.done){
          traversal = null;
          return true;
        } else {
          const step = res.value;
          // Step handler: step is an object describing action
          await handleStep(step);
          return false;
        }
      }

      // Helper: get neighbors sorted
      function neighborsOf(nodeId){
        const n = nodes.find(x=>x.id===nodeId);
        if (!n) return [];
        let nbrs = edges.reduce((acc,e)=>{
          if (e.a===nodeId) acc.push(e.b);
          if (e.b===nodeId) acc.push(e.a);
          return acc;
        },[]);
        // unique
        nbrs = Array.from(new Set(nbrs));
        if (neighborOrder === 'id') {
          nbrs.sort((a,b)=>a-b);
        } else {
          // by angle relative to node
          nbrs.sort((a,b)=>{
            const na = nodes.find(xx=>xx.id===a);
            const nb = nodes.find(xx=>xx.id===b);
            const angA = Math.atan2(na.y - n.y, na.x - n.x);
            const angB = Math.atan2(nb.y - n.y, nb.x - n.x);
            return angA - angB;
          });
        }
        return nbrs;
      }

      // Iterative DFS generator: yields micro-steps
      function* iterativeDFSGenerator(start){
        // micro-step objects: {type:'push'|'pop'|'visit'|'edge'|'mark','node':id, ...}
        const stack = [];
        stack.push(start);
        yield {type:'push', node:start, info:'push start'};
        while(stack.length){
          const cur = stack.pop();
          yield {type:'pop', node:cur, info:'pop to visit'};
          if (!visitedSet.has(cur)){
            // visiting
            yield {type:'visit', node:cur, info:'visit node'};
            visitedSet.add(cur);
            visitedSequence.push(cur);
            // push neighbors in reverse order so smallest order polled first if using stack
            const nbrs = neighborsOf(cur).slice().reverse();
            for (const nb of nbrs){
              yield {type:'edge', a:cur, b:nb, info:'consider edge'};
              if (!visitedSet.has(nb)){
                stack.push(nb);
                yield {type:'push', node:nb, info:'push neighbor'};
              } else {
                yield {type:'skip', node:nb, info:'neighbor already visited'};
              }
            }
          } else {
            yield {type:'skipvisited', node:cur, info:'already visited'};
          }
        }
        return;
      }

      // Recursive DFS: simulate call stack as generator
      function* recursiveDFSGenerator(start){
        // We'll implement DFS using an explicit stack of frames to be able to step through
        // Each frame: {node, iterNeighbors, state} state: 'enter'|'loop'|'exit'
        function* frameDFS(node){
          yield {type:'enter', node, info:'enter function'};
          if (!visitedSet.has(node)){
            yield {type:'mark', node, info:'mark visited'};
            visitedSet.add(node);
            visitedSequence.push(node);
            const nbrs = neighborsOf(node);
            for (const nb of nbrs){
              yield {type:'edge', a:node, b:nb, info:'consider neighbor'};
              if (!visitedSet.has(nb)){
                yield* frameDFS(nb);
                yield {type:'aftercall', node, from:nb, info:'returned from recursive call'};
              } else {
                yield {type:'skip', node:nb, info:'neighbor already visited'};
              }
            }
          } else {
            yield {type:'already', node, info:'already visited'};
          }
          yield {type:'exit', node, info:'exit function'};
        }
        yield* frameDFS(start);
      }

      // Handle a single micro-step with animations
      async function handleStep(step){
        // Clear previous pseudocode highlight
        applyTraversalVisuals();
        // Determine pseudocode mapping
        let codeLine = null;
        switch(step.type){
          case 'enter': codeLine = 1; break;
          case 'mark': codeLine = 2; break;
          case 'edge': codeLine = 3; break;
          case 'skip': codeLine = 4; break;
          case 'push': codeLine = algorithm==='iterative'?3:1; break;
          case 'pop': codeLine = algorithm==='iterative'?2:4; break;
          case 'visit': codeLine = 2; break;
          case 'exit': codeLine = 4; break;
          case 'aftercall': codeLine = 5; break;
        }
        highlightPseudocode(codeLine);

        switch(step.type){
          case 'push':
            stackState.push({node:step.node});
            updateStackView('push', step.node);
            statusMsg.textContent = 'Push Node ' + step.node;
            applyTraversalVisuals();
            await animateNodePulse(step.node, 'active');
            break;
          case 'pop':
            // remove last matching node from stack (in iterative each pop uses last pushed)
            // For visualization, show pop of that node if present
            const idx = stackState.map(s=>s.node).lastIndexOf(step.node);
            if (idx>=0){
              const removed = stackState.splice(idx,1)[0];
              updateStackView('pop', step.node);
            } else {
              // nothing in stack, still animate node as active
            }
            statusMsg.textContent = 'Pop Node ' + step.node;
            applyTraversalVisuals();
            await animateNodePulse(step.node, 'pop');
            break;
          case 'visit':
            // mark node as visited
            visitedSet.add(step.node);
            visitedSequence.push(step.node);
            statusMsg.textContent = 'Visit Node ' + step.node;
            applyTraversalVisuals();
            updateVisitedView();
            await animateNodeVisit(step.node);
            break;
          case 'mark':
            visitedSet.add(step.node);
            visitedSequence.push(step.node);
            statusMsg.textContent = 'Mark visited ' + step.node;
            applyTraversalVisuals();
            updateVisitedView();
            await animateNodeVisit(step.node);
            break;
          case 'edge':
            statusMsg.textContent = 'Consider edge ' + step.a + ' → ' + step.b;
            await animateEdgePulse(step.a, step.b);
            break;
          case 'skip':
            statusMsg.textContent = 'Neighbor ' + step.node + ' already visited';
            await animateEdgePulse(step.node, step.node, {skip:true});
            break;
          case 'aftercall':
            statusMsg.textContent = 'Returned to Node ' + step.node + ' from ' + step.from;
            await flashNode(step.node);
            break;
          case 'exit':
            statusMsg.textContent = 'Return from ' + step.node;
            await flashNode(step.node);
            break;
          case 'skipvisited':
            statusMsg.textContent = 'Already visited ' + step.node;
            await flashNode(step.node);
            break;
          default:
            statusMsg.textContent = step.info || 'Processing...';
            await delayMs(120);
        }
        applyTraversalVisuals();
      }

      // Visual helpers: animations using CSS classes and temporarily toggling edge classes
      function animateEdgePulse(a,b, opts={}){
        return new Promise(resolve=>{
          // find edge between a and b (undirected)
          const el = $$('line.edge').find(l=>{
            const A = parseInt(l.dataset.a,10), B = parseInt(l.dataset.b,10);
            return (A===a && B===b) || (A===b && B===a);
          });
          if (!el){
            // small pause to show step
            setTimeout(resolve, 200);
            return;
          }
          el.classList.add('active');
          // use a short pulse and then remove
          setTimeout(()=>{ el.classList.remove('active'); resolve(); }, 360);
        });
      }
      function animateNodeVisit(id){
        return new Promise(resolve=>{
          const el = $(`.node[data-id="${id}"]`);
          if (!el){ setTimeout(resolve,150); return; }
          el.classList.add('visited');
          setTimeout(resolve,260);
        });
      }
      function animateNodePulse(id, type){
        return new Promise(resolve=>{
          const el = $(`.node[data-id="${id}"]`);
          if (!el){ setTimeout(resolve,160); return; }
          el.classList.add('active');
          setTimeout(()=>{ el.classList.remove('active'); resolve(); }, 300);
        });
      }
      function flashNode(id){
        return new Promise(resolve=>{
          const el = $(`.node[data-id="${id}"]`);
          if (!el){ setTimeout(resolve,140); return; }
          el.classList.add('active');
          setTimeout(()=>{ el.classList.remove('active'); resolve(); }, 220);
        });
      }

      // Stack view update
      function updateStackView(effect=null, node=null){
        stackView.innerHTML='';
        // show stack top at top -> display reversed
        const arr = stackState.slice().reverse();
        for (const s of arr){
          const d = document.createElement('div');
          d.className = 'stack-item push';
          d.textContent = 'Node ' + s.node;
          d.dataset.node = s.node;
          stackView.appendChild(d);
        }
        // if effect is pop, animate removed one by adding a pop item then removing
        if (effect === 'pop' && node!=null){
          // simulate pop animation by briefly inserting a pop item (optional)
          const popItem = document.createElement('div');
          popItem.className = 'stack-item pop';
          popItem.textContent = 'Popped ' + node;
          stackView.insertBefore(popItem, stackView.firstChild);
          setTimeout(()=>{ if(popItem.parentNode) popItem.parentNode.removeChild(popItem); }, 380);
        }
      }

      function updateVisitedView(){
        visitedList.innerHTML='';
        for (const id of visitedSequence){
          const chip = document.createElement('div');
          chip.className='visited-chip';
          chip.textContent = id;
          visitedList.appendChild(chip);
        }
      }

      // pseudocode highlight
      function highlightPseudocode(line){
        $$('.code-line', pseudocode).forEach(el=>{
          el.classList.remove('current');
          if (line && el.dataset.line === String(line)) el.classList.add('current');
        });
      }

      // Helpers
      function delayMs(ms){ return new Promise(r=>setTimeout(r,ms)); }

      // Keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if (e.code === 'Space'){ e.preventDefault(); togglePlayPause(); }
        if (e.code === 'ArrowRight'){ e.preventDefault(); stepOnce(); }
        if (e.code === 'Escape'){ e.preventDefault(); resetTraversalState(); statusMsg.textContent='Reset'; }
      });

      // initialize with sample
      loadSample();

      // Expose some debug on window (optional)
      window._dfsExplorer = {
        nodes, edges, addNode, addEdge, loadSample, clearGraph
      };
    })();
  </script>
</body>
</html>