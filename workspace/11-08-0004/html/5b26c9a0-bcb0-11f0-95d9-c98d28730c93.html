<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hash Table — Separate Chaining (Interactive)</title>
  <style>
    :root{
      --safe-padding:24px;
      --gap:16px;
      --bg:#f7f9fb;
      --panel:#ffffff;
      --muted:#6b7280;
      --accent:#2563eb; /* blue */
      --success:#16a34a;
      --danger:#dc2626;
      --warn:#d97706;
      --node-bg:#eef2ff;
      --bucket-bg:#ffffff;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:var(--bg);
      color:#111827;
      padding:var(--safe-padding);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:var(--gap);
      align-items:start;
      min-height:100vh;
    }
    @media (max-width:900px){
      .app{grid-template-columns:1fr}
    }
    /* Control Panel */
    .panel{
      background:var(--panel);
      padding:20px;
      border-radius:10px;
      box-shadow: 0 1px 3px rgba(12,16,25,0.06);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    h1{
      margin:0;
      font-size:18px;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .subtitle{color:var(--muted); font-size:13px}
    .controls{display:flex; flex-direction:column; gap:12px}
    label{font-size:13px; color:var(--muted)}
    .input-row{
      display:flex;
      gap:12px;
      align-items:center;
    }
    input[type="text"]{
      flex:1;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #e6e9ee;
      font-size:14px;
      outline:none;
    }
    input[type="text"]:focus{box-shadow:0 0 0 3px rgba(37,99,235,0.12); border-color:var(--accent)}
    button{
      padding:10px 12px;
      border-radius:8px;
      border:none;
      background:var(--accent);
      color:white;
      font-weight:600;
      cursor:pointer;
      font-size:14px;
    }
    button.secondary{
      background:#eef3ff;
      color:var(--accent);
      border:1px solid #dbeafe;
      font-weight:600;
    }
    .small-btn{padding:8px 10px; font-size:13px}
    .row{display:flex; gap:12px; align-items:center}
    .muted{color:var(--muted); font-size:13px}
    .status{
      background:#fbfdff;
      border:1px solid #e6eefc;
      padding:10px;
      border-radius:8px;
      font-size:13px;
      color:#0f172a;
      min-height:44px;
    }
    .controls .control-group{display:flex; flex-direction:column; gap:8px}
    .slider{width:100%}
    /* Visualization */
    .vis{
      padding:18px;
      background:transparent;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .board{
      background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.85));
      border-radius:12px;
      padding:18px;
      min-height:260px;
      box-shadow:0 1px 4px rgba(12,16,25,0.06);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .buckets-wrapper{
      overflow:auto;
      padding-bottom:8px;
    }
    .buckets{
      display:flex;
      gap:16px;
      /* allow horizontal scroll on small screens */
      padding-bottom:6px;
    }
    .bucket{
      width:120px;
      min-width:120px;
      background:var(--bucket-bg);
      border-radius:10px;
      border:1px solid #e6eefc;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:center;
      position:relative;
      transition:transform .18s ease, box-shadow .18s ease;
      box-shadow: 0 1px 2px rgba(12,16,25,0.03);
    }
    .bucket:focus-within, .bucket:hover{transform:translateY(-4px); box-shadow:0 6px 18px rgba(12,16,25,0.06)}
    .bidx{font-weight:700; font-size:13px}
    .chain{
      width:100%;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:36px;
      align-items:center;
    }
    .node{
      background:var(--node-bg);
      border-radius:8px;
      padding:6px 8px;
      min-width:88%;
      text-align:center;
      font-weight:600;
      color:#1f2937;
      border:1px solid rgba(37,99,235,0.08);
      box-shadow: 0 1px 1px rgba(12,16,25,0.02);
      opacity:1;
      transition:transform .25s ease, opacity .18s ease, background-color .18s ease, box-shadow .18s ease;
    }
    .node.found{background:linear-gradient(90deg,#dcfce7,#bbf7d0); border-color:rgba(16,185,129,0.25); box-shadow:0 6px 18px rgba(16,185,129,0.06)}
    .node.searching{background:linear-gradient(90deg,#fff7ed,#ffedd5); border-color:rgba(217,119,6,0.12)}
    .node.removing{opacity:0; transform:scale(.92)}
    .bucket.highlight{box-shadow:0 10px 30px rgba(37,99,235,0.08); border-color:rgba(37,99,235,0.12)}
    .bucket.notfound{box-shadow:0 10px 30px rgba(217,119,6,0.08); border-color:rgba(217,119,6,0.12)}
    .legend{display:flex; gap:12px; align-items:center; color:var(--muted); font-size:13px}
    .dot{width:10px;height:10px;border-radius:50%}
    .dot.insert{background:var(--accent)}
    .dot.search{background:var(--warn)}
    .dot.found{background:var(--success)}
    .instruction{color:var(--muted); font-size:13px}
    /* floating token used for animation */
    .token{
      position:fixed;
      left:0; top:0;
      padding:8px 10px;
      background:linear-gradient(180deg,#eef2ff,#e0e7ff);
      border:1px solid rgba(37,99,235,0.12);
      border-radius:8px;
      font-weight:700;
      pointer-events:none;
      z-index:9999;
      transition:transform .6s cubic-bezier(.2,.9,.2,1), opacity .2s ease;
      box-shadow:0 12px 30px rgba(12,16,25,0.08);
    }
    .vis-footer{display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap}
    /* focus styles */
    button:focus, .bucket:focus, input:focus { outline: 3px solid rgba(37,99,235,0.12); }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Hash table interactive demo">
    <aside class="panel" aria-labelledby="title">
      <div>
        <h1 id="title">Hash Table — Separate Chaining</h1>
        <div class="subtitle">Visual, interactive demo of collision handling using separate chaining</div>
      </div>

      <div class="controls" aria-live="polite">
        <div class="control-group">
          <label for="keyInput">Key (text or number)</label>
          <div class="input-row">
            <input id="keyInput" type="text" placeholder="e.g., alice or 42" aria-label="Key to insert, search, or delete" />
            <button id="insertBtn" title="Insert (Enter)" aria-label="Insert key">Insert</button>
          </div>
        </div>

        <div class="row">
          <button id="searchBtn" class="secondary small-btn" aria-label="Search key">Search</button>
          <button id="deleteBtn" class="secondary small-btn" aria-label="Delete key">Delete</button>
          <button id="clearBtn" class="secondary small-btn" aria-label="Clear table">Clear</button>
        </div>

        <div class="control-group">
          <label for="sizeRange">Table size: <span id="sizeVal">11</span> buckets</label>
          <input id="sizeRange" class="slider" type="range" min="5" max="23" value="11" step="2" aria-label="Table size">
          <div class="muted">Changing table size will rebuild (clear) the table to demonstrate remapping.</div>
        </div>

        <div class="control-group">
          <label for="speedRange">Animation speed</label>
          <input id="speedRange" class="slider" type="range" min="0.3" max="1.6" value="1" step="0.1" aria-label="Animation speed">
        </div>

        <div class="control-group">
          <label>Status</label>
          <div class="status" id="status" role="status" aria-live="polite">Ready. Insert a key to begin.</div>
        </div>
      </div>
    </aside>

    <main class="vis" role="main">
      <div class="board" aria-hidden="false">
        <div class="buckets-wrapper" tabindex="0">
          <div class="buckets" id="buckets" role="list" aria-label="Hash table buckets"></div>
        </div>

        <div class="vis-footer">
          <div class="legend" aria-hidden="false">
            <div style="display:flex;align-items:center;gap:8px"><span class="dot insert"></span><span>Insert</span></div>
            <div style="display:flex;align-items:center;gap:8px"><span class="dot search"></span><span>Search (scanning chain)</span></div>
            <div style="display:flex;align-items:center;gap:8px"><span class="dot found"></span><span>Found</span></div>
          </div>
          <div class="instruction">Type a key and press Insert. Use Search to step through a chain; Delete removes found keys.</div>
        </div>
      </div>
    </main>
  </div>

  <script>
    (function(){
      // Basic configuration
      const state = {
        size: 11,
        speed: 1,
        table: [], // array of arrays (chains)
      };

      // Elements
      const keyInput = document.getElementById('keyInput');
      const insertBtn = document.getElementById('insertBtn');
      const searchBtn = document.getElementById('searchBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const clearBtn = document.getElementById('clearBtn');
      const sizeRange = document.getElementById('sizeRange');
      const sizeVal = document.getElementById('sizeVal');
      const speedRange = document.getElementById('speedRange');
      const statusEl = document.getElementById('status');
      const bucketsEl = document.getElementById('buckets');

      // Initialize table
      function initTable(sz){
        state.size = sz;
        state.table = Array.from({length:sz}, ()=> []);
        renderBuckets();
        announce('Table created with ' + sz + ' buckets.');
      }

      function announce(msg){
        statusEl.textContent = msg;
      }

      function simpleHash(key){
        // deterministic: sum of UTF-16 code units
        let s = 0;
        for (let i = 0; i < key.length; i++) s = (s + key.charCodeAt(i));
        return Math.abs(s) % state.size;
      }

      // Rendering functions
      function renderBuckets(){
        bucketsEl.innerHTML = '';
        for (let i = 0; i < state.size; i++){
          const b = document.createElement('div');
          b.className = 'bucket';
          b.setAttribute('data-idx', i);
          b.setAttribute('role','listitem');
          b.innerHTML = `
            <div class="bidx">Bucket ${i}</div>
            <div class="chain" aria-live="polite"></div>
          `;
          bucketsEl.appendChild(b);
        }
      }

      function renderChain(idx){
        const bucket = bucketsEl.querySelector('.bucket[data-idx="'+idx+'"]');
        const chainEl = bucket.querySelector('.chain');
        chainEl.innerHTML = '';
        const chain = state.table[idx];
        for (let i = 0; i < chain.length; i++){
          const node = document.createElement('div');
          node.className = 'node';
          node.textContent = chain[i];
          node.setAttribute('data-key', chain[i]);
          chainEl.appendChild(node);
        }
      }

      // Create floating token for animation
      function createToken(text){
        const t = document.createElement('div');
        t.className = 'token';
        t.textContent = text;
        document.body.appendChild(t);
        return t;
      }

      function getAnimationDuration(){
        // base duration scales with speed setting
        // lower speed value -> faster (we invert)
        const speed = state.speed; // e.g., 1
        return 600 * speed; // ms
      }

      function animateInsertVisual(text, targetBucketIdx, callback){
        const token = createToken(text);
        // start position: near input field
        const inputRect = keyInput.getBoundingClientRect();
        token.style.left = (inputRect.left + 8) + 'px';
        token.style.top = (inputRect.top + 8) + 'px';
        token.style.opacity = '1';
        token.style.transform = 'translate3d(0,0,0)';

        // compute destination: bucket center
        const targetBucket = bucketsEl.querySelector('.bucket[data-idx="'+targetBucketIdx+'"]');
        if (!targetBucket){
          // fallback: remove token after brief moment
          setTimeout(()=>{ token.remove(); if (callback) callback(); }, 400);
          return;
        }
        const bucketRect = targetBucket.getBoundingClientRect();
        const destX = bucketRect.left + bucketRect.width/2 - 24; // align
        const destY = bucketRect.top + bucketRect.height/2 - 12;

        // trigger highlight
        targetBucket.classList.add('highlight');
        setTimeout(()=>targetBucket.classList.remove('highlight'), Math.max(400, getAnimationDuration()));

        // Use transform to animate (perform a layout read)
        const dx = destX - inputRect.left - 8;
        const dy = destY - inputRect.top - 8;
        // apply transform after a tick
        requestAnimationFrame(()=>{
          token.style.transition = `transform ${getAnimationDuration()/1000}s cubic-bezier(.2,.9,.2,1), opacity .2s ease`;
          token.style.transform = `translate3d(${dx}px, ${dy}px, 0) scale(1)`;
        });

        // After animation end, remove token and append node to chain with fade-in
        setTimeout(()=>{
          token.style.opacity = '0';
          setTimeout(()=>{ token.remove(); 
            // append node to chain
            state.table[targetBucketIdx].push(text);
            renderChain(targetBucketIdx);
            if (callback) callback();
          }, 120);
        }, getAnimationDuration()+30);
      }

      // Search visualization: highlight bucket, then each node sequentially
      async function visualizeSearch(key){
        const idx = simpleHash(key);
        announce(`Hash("${key}") = ${idx}. Searching bucket ${idx}...`);
        const targetBucket = bucketsEl.querySelector('.bucket[data-idx="'+idx+'"]');
        const chainEl = targetBucket.querySelector('.chain');
        const nodes = Array.from(chainEl.querySelectorAll('.node'));
        // highlight bucket
        targetBucket.classList.add('highlight');
        await wait(getAnimationDuration()/2);
        if (nodes.length === 0){
          targetBucket.classList.remove('highlight');
          targetBucket.classList.add('notfound');
          announce(`Bucket ${idx} is empty. "${key}" not found.`);
          await wait(getAnimationDuration()/1.8);
          targetBucket.classList.remove('notfound');
          return {found:false, idx, nodeEl:null, position:-1};
        }
        // scan nodes
        for (let i = 0; i < nodes.length; i++){
          const n = nodes[i];
          n.classList.add('searching');
          announce(`Checking node ${i} in bucket ${idx}: "${n.textContent}"`);
          await wait(getAnimationDuration()/1.6);
          if (n.getAttribute('data-key') === key){
            n.classList.remove('searching');
            n.classList.add('found');
            announce(`Found "${key}" in bucket ${idx} at position ${i}.`);
            targetBucket.classList.remove('highlight');
            await wait(getAnimationDuration()/1.8);
            return {found:true, idx, nodeEl:n, position:i};
          }
          n.classList.remove('searching');
        }
        // not found after scanning
        targetBucket.classList.remove('highlight');
        targetBucket.classList.add('notfound');
        announce(`Scanned bucket ${idx} — "${key}" not found.`);
        await wait(getAnimationDuration()/1.8);
        targetBucket.classList.remove('notfound');
        return {found:false, idx, nodeEl:null, position:-1};
      }

      function wait(ms){
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      // Operations
      async function handleInsert(){
        const raw = keyInput.value.trim();
        if (!raw){ announce('Please enter a non-empty key to insert.'); keyInput.focus(); return; }
        const idx = simpleHash(raw);
        announce(`Hash("${raw}") = ${idx}. Inserting...`);
        // animate token moving to bucket and then append
        insertBtn.disabled = true;
        await new Promise(resolve => animateInsertVisual(raw, idx, resolve));
        renderChain(idx);
        announce(`Inserted "${raw}" into bucket ${idx}.`);
        insertBtn.disabled = false;
        keyInput.focus();
      }

      async function handleSearch(){
        const raw = keyInput.value.trim();
        if (!raw){ announce('Please enter a key to search.'); keyInput.focus(); return; }
        searchBtn.disabled = true;
        const res = await visualizeSearch(raw);
        if (res.found){
          // leave found highlight for a bit then clear
          await wait(600 * state.speed);
          if (res.nodeEl) res.nodeEl.classList.remove('found');
        }
        searchBtn.disabled = false;
        keyInput.focus();
      }

      async function handleDelete(){
        const raw = keyInput.value.trim();
        if (!raw){ announce('Please enter a key to delete.'); keyInput.focus(); return; }
        deleteBtn.disabled = true;
        const res = await visualizeSearch(raw);
        if (res.found){
          // fade out node and remove from state, then re-render chain
          const bucketIdx = res.idx;
          const pos = res.position;
          const nodeEl = res.nodeEl;
          nodeEl.classList.add('removing');
          announce(`Removing "${raw}" from bucket ${bucketIdx}.`);
          await wait(220 * state.speed);
          // remove from state
          state.table[bucketIdx].splice(pos,1);
          renderChain(bucketIdx);
        }
        deleteBtn.disabled = false;
        keyInput.focus();
      }

      // Event wiring
      insertBtn.addEventListener('click', handleInsert);
      searchBtn.addEventListener('click', handleSearch);
      deleteBtn.addEventListener('click', handleDelete);
      clearBtn.addEventListener('click', ()=>{
        initTable(state.size);
        announce('Table cleared.');
      });

      sizeRange.addEventListener('input', (e)=>{
        const val = parseInt(e.target.value,10) || 11;
        // force odd sizes (optional): we keep step=2 so it's odd; but ensure parity
        sizeVal.textContent = val;
      });
      sizeRange.addEventListener('change', (e)=>{
        const val = parseInt(e.target.value,10) || 11;
        initTable(val);
      });

      speedRange.addEventListener('input', (e)=>{
        const val = parseFloat(e.target.value);
        state.speed = val;
      });

      // Helper: pressing Enter in input triggers Insert
      keyInput.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter'){
          e.preventDefault();
          handleInsert();
        }
      });

      // Initialize UI
      initTable(state.size);

      // Pre-populate with a few example keys for demo
      const demoKeys = ['alice','bob','carol','dave','123','77','zeta'];
      (async function preload(){
        for (let k of demoKeys){
          // small delay so user sees them appear
          await new Promise(res => setTimeout(res, 220));
          state.table[simpleHash(k)].push(k);
          renderChain(simpleHash(k));
        }
        announce('Demo: preloaded several keys. Try inserting new keys or searching for existing ones (e.g., "alice").');
      })();

      // Accessibility: expose a small API to screen readers when actions happen
      // statusEl already is aria-live region

    })();
  </script>
</body>
</html>