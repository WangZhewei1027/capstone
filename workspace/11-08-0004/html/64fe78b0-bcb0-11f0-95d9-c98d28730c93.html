<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Module — Array (Indexed Collection)</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #22c1c3;
      --muted: #94a3b8;
      --tile-bg: linear-gradient(180deg,#0f1724,#08101a);
      --success: #16a34a;
      --danger: #ef4444;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color-scheme: dark;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071021 0%, #07101b 100%);
      color: #e6eef6;
    }

    /* Safe area margins */
    .app{
      padding: var(--safe-margin);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      gap: var(--gap);
    }

    /* Layout: left info, right interactive */
    .card{
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 18px;
      box-sizing:border-box;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }

    .left{
      width: 360px;
      min-width: 280px;
      max-height: calc(100vh - 2 * var(--safe-margin));
      overflow:auto;
    }

    .right{
      flex:1;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    h1{
      font-size: 20px;
      margin:0 0 8px 0;
      color: #e7f8fb;
    }
    p.lead{
      margin:0 0 12px 0;
      color: var(--muted);
      font-size: 13px;
    }

    .section-title{
      font-size: 13px;
      color: var(--accent);
      margin: 8px 0;
      font-weight: 600;
    }

    .meta-list{
      font-size: 13px;
      line-height: 1.4;
      color: #cfefff;
    }

    /* Interactive area */
    .controls{
      display:flex;
      gap: var(--gap);
      flex-wrap:wrap;
      align-items:center;
    }

    .input, .small{
      background: #05101a;
      border: 1px solid rgba(255,255,255,0.04);
      color: #e6eef6;
      padding: 10px 12px;
      border-radius: 8px;
      font-size: 14px;
      min-width: 120px;
      box-sizing:border-box;
    }
    .small{
      padding:8px 10px;
      min-width:80px;
    }

    button.btn{
      background: linear-gradient(180deg,#06303b,#042a35);
      border: 1px solid rgba(255,255,255,0.04);
      color: #e6f9f9;
      padding: 10px 14px;
      border-radius: 8px;
      cursor:pointer;
      font-weight:600;
      font-size: 14px;
    }
    button.btn:active{ transform: translateY(1px); }
    button.ghost{
      background: transparent;
      border: 1px dashed rgba(255,255,255,0.04);
      color: var(--muted);
    }

    .visual{
      background: linear-gradient(180deg,#06111a,#031018);
      border-radius: 10px;
      padding: 18px;
      min-height: 220px;
      display:flex;
      flex-direction:column;
      gap: 16px;
      align-items:stretch;
      box-sizing:border-box;
      border: 1px solid rgba(255,255,255,0.03);
    }

    /* Array row */
    .array-row{
      display:flex;
      gap: 12px;
      align-items:flex-end;
      overflow:auto;
      padding: 8px;
      min-height: 96px;
    }

    .tile{
      --w: 88px;
      width: var(--w);
      min-width: var(--w);
      height: 72px;
      background: linear-gradient(180deg,#07202a,#04151a);
      border-radius: 10px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      box-shadow: 0 8px 18px rgba(2,8,14,0.6);
      border: 1px solid rgba(255,255,255,0.03);
      color:#e6f9f9;
      position:relative;
      transition: transform 250ms cubic-bezier(.2,.9,.3,1), opacity 180ms ease, box-shadow 180ms ease;
      cursor:grab;
      user-select:none;
    }

    .tile[draggable="true"]{ cursor:grab; }
    .tile:active{ cursor:grabbing; }

    .tile .value{
      font-weight:700;
      font-size:18px;
      letter-spacing: .2px;
    }
    .tile .index{
      font-size:12px;
      color:var(--muted);
      margin-top:6px;
    }

    .tile.selected{
      box-shadow: 0 12px 30px rgba(34,193,195,0.12);
      outline: 2px solid rgba(34,193,195,0.18);
      transform: translateY(-6px) scale(1.02);
    }

    .tile.enter{
      animation: enter 260ms cubic-bezier(.2,.9,.3,1);
    }
    @keyframes enter{
      0%{ transform: translateY(-20px) scale(.98); opacity:0; }
      100%{ transform: translateY(0) scale(1); opacity:1; }
    }

    .tile.removing{
      animation: remove 220ms ease forwards;
    }
    @keyframes remove{
      0%{ opacity:1; transform:scale(1); }
      100%{ opacity:0; transform:scale(.9); height:0; margin:0; padding:0; }
    }

    /* info / controls below visual */
    .status-row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: var(--gap);
    }

    .code{
      background: rgba(0,0,0,0.25);
      border-radius:8px;
      padding:10px 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size: 13px;
      color:#d9f7f7;
      min-width:220px;
      word-break:break-all;
    }

    .panel{
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .log{
      margin-top:8px;
      background: rgba(255,255,255,0.02);
      padding:10px;
      border-radius:10px;
      max-height:140px;
      overflow:auto;
      font-size:13px;
      color:var(--muted);
    }

    /* small helper text */
    .hint{
      font-size:12px;
      color:var(--muted);
    }

    /* responsive */
    @media (max-width:980px){
      .app{ flex-direction:column; }
      .left{ width:100%; max-height:none; }
    }
    /* accessibility focus */
    .tile:focus{
      outline: 3px dashed rgba(34,193,195,0.14);
      outline-offset: 3px;
    }

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Array interactive module">
    <!-- Left: Design plan / textual sections -->
    <aside class="card left" aria-labelledby="title">
      <h1 id="title">Array — Indexed Collection</h1>
      <p class="lead">Explore arrays visually: indexing, dynamic size, access, insertion, removal, and reordering.</p>

      <div class="section">
        <div class="section-title">Learning Objective</div>
        <div class="meta-list">
          After interacting with this module, you will be able to:
          <ul>
            <li>Understand arrays as ordered, indexed collections of values.</li>
            <li>See how operations (push, insert, remove, pop) change order and length.</li>
            <li>Access and edit elements by index and visually observe how indices update.</li>
          </ul>
        </div>
      </div>

      <div class="section" style="margin-top:10px;">
        <div class="section-title">Interaction Design</div>
        <div class="meta-list">
          Interactions included:
          <ul>
            <li>Type a value and click "Push" to append — tile animates into the array.</li>
            <li>Insert at a specific index using "Insert at" — tiles shift and indices update.</li>
            <li>Remove by index or use "Pop" to remove the last; removal fades out and array compresses.</li>
            <li>Click a tile to select it; edit inline in the inspector and save to mutate the array.</li>
            <li>Drag a tile onto another to swap positions; animations use a FLIP technique for smooth visual motion.</li>
            <li>Keyboard: arrow keys move selection; Enter starts edit; Escape cancels.</li>
          </ul>
          Visual feedback: add/remove animations, selection elevation, index highlight, and operation log with live array representation.
        </div>
      </div>

      <div class="section" style="margin-top:10px;">
        <div class="section-title">Layout Description</div>
        <div class="meta-list">
          - Left column: module explanation (this panel). Safe margins: 24px around viewport. <br>
          - Right column: interactive panel containing controls on top, visual array center, inspector and live code below. <br>
          - Spacing: at least 16px between interactive elements (using gap variables). <br>
          - Accessibility: buttons and tiles have labels, keyboard focus styles, and an aria-live log for screen readers. <br>
          - Responsive: stacks vertically on narrow screens and keeps controls reachable.
        </div>
      </div>
    </aside>

    <!-- Right: Interactive module -->
    <main class="card right" aria-live="polite">
      <!-- Controls -->
      <div style="display:flex;flex-direction:column;gap:var(--gap);">
        <div class="controls" role="region" aria-label="Array controls">
          <input id="valueInput" class="input" type="text" placeholder="Value (string or number)" aria-label="Value to add or insert" />
          <input id="indexInput" class="small" type="number" min="0" placeholder="Index" aria-label="Index for insert or remove" />
          <button id="pushBtn" class="btn" title="Push to end">Push</button>
          <button id="insertBtn" class="btn" title="Insert at index">Insert at</button>
          <button id="popBtn" class="btn ghost" title="Remove last">Pop</button>
          <button id="removeBtn" class="btn ghost" title="Remove at index">Remove at</button>
          <button id="clearBtn" class="btn ghost" title="Clear array">Clear</button>
        </div>

        <!-- Visual -->
        <div class="visual" role="region" aria-label="Array visual representation">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div style="display:flex;flex-direction:column;">
              <div style="font-weight:700">Array (visual)</div>
              <div class="hint">Click tiles to select. Drag a tile onto another to swap.</div>
            </div>
            <div style="display:flex;gap:12px;align-items:center;">
              <div class="hint" style="color:var(--muted);">Length:</div>
              <div id="lengthBadge" class="code" aria-live="polite">0</div>
            </div>
          </div>

          <div id="arrayRow" class="array-row" tabindex="0" aria-label="Array elements">
            <!-- tiles will be rendered here -->
          </div>

          <div class="status-row" style="margin-top:6px;">
            <div class="panel" style="flex:1;">
              <div style="display:flex;align-items:center;gap:12px;">
                <div style="font-size:13px;font-weight:700">Inspector</div>
                <div class="hint">Selected element details</div>
              </div>
              <div id="inspector" style="display:flex;gap:8px;align-items:center;margin-top:6px;">
                <div style="flex:1">
                  <div id="inspectorText" class="hint">No item selected</div>
                </div>
                <div id="inspectorControls" style="display:none;gap:8px;">
                  <input id="editValue" class="input" type="text" aria-label="Edit selected value" />
                  <button id="saveEdit" class="btn">Save</button>
                </div>
              </div>
            </div>

            <div style="min-width:260px;">
              <div style="font-size:13px;font-weight:700">Live Array</div>
              <div id="liveArray" class="code" aria-live="polite">[]</div>
            </div>
          </div>
        </div>

        <div>
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div style="font-weight:700">Operation Log</div>
            <div class="hint">Recent actions</div>
          </div>
          <div id="log" class="log" aria-live="polite" role="log"></div>
        </div>
      </div>
    </main>
  </div>

  <script>
    // Self-contained interactive array module
    (function(){
      // Configuration
      const SAFE_GAP = 16;

      // DOM references
      const arrayRow = document.getElementById('arrayRow');
      const valueInput = document.getElementById('valueInput');
      const indexInput = document.getElementById('indexInput');
      const pushBtn = document.getElementById('pushBtn');
      const insertBtn = document.getElementById('insertBtn');
      const popBtn = document.getElementById('popBtn');
      const removeBtn = document.getElementById('removeBtn');
      const clearBtn = document.getElementById('clearBtn');
      const lengthBadge = document.getElementById('lengthBadge');
      const liveArray = document.getElementById('liveArray');
      const logEl = document.getElementById('log');
      const inspector = document.getElementById('inspector');
      const inspectorText = document.getElementById('inspectorText');
      const inspectorControls = document.getElementById('inspectorControls');
      const editValue = document.getElementById('editValue');
      const saveEdit = document.getElementById('saveEdit');

      // State
      let arr = ['alpha', 'beta', 'gamma'];
      let selectedIndex = -1;

      // Utility: log
      function log(msg){
        const time = new Date().toLocaleTimeString();
        const entry = document.createElement('div');
        entry.textContent = `[${time}] ${msg}`;
        logEl.prepend(entry);
      }

      // Serialize array for display
      function arrayToCode(a){
        const items = a.map(v => {
          const asNum = Number(v);
          // if string looks like number keep quotes? We'll show strings with quotes otherwise numbers as-is
          if(String(v) === String(asNum) && v !== '' && !Number.isNaN(asNum)) return String(asNum);
          return JSON.stringify(String(v));
        });
        return `[ ${items.join(', ')} ]`;
      }

      // FLIP helper: animate changes by computing bounding rectangles
      function flipUpdate(renderFn){
        // capture positions
        const before = [];
        const children = Array.from(arrayRow.children);
        children.forEach(el => before.push(el.getBoundingClientRect()));
        // call render function that will mutate DOM (synchronously)
        renderFn();
        // after positions
        const afterChildren = Array.from(arrayRow.children);
        afterChildren.forEach((el, i) => {
          const b = before.find(rect => rect && rect.left === rect.left && rect.width === rect.width); // fallback
          // compute delta from matching by data-index attribute (value before update)
        });
        // More robust: match by data-key attribute (we assign unique ids)
        const after = Array.from(arrayRow.children).map(el => el.getBoundingClientRect());
        // For each element, find its corresponding old rect by matching data-key
        const keyToBefore = {};
        children.forEach((el, i) => { const k = el.dataset.key; if(k) keyToBefore[k] = before[i]; });
        afterChildren.forEach((el, i) => {
          const key = el.dataset.key;
          const prev = keyToBefore[key];
          if(!prev) return;
          const next = el.getBoundingClientRect();
          const dx = prev.left - next.left;
          const dy = prev.top - next.top;
          if(dx || dy){
            el.style.transition = 'none';
            el.style.transform = `translate(${dx}px, ${dy}px)`;
            requestAnimationFrame(() => {
              el.style.transition = 'transform 260ms cubic-bezier(.2,.9,.3,1)';
              el.style.transform = '';
              // clean up after transition
              const cleanup = () => { el.style.transition = ''; el.removeEventListener('transitionend', cleanup); };
              el.addEventListener('transitionend', cleanup);
            });
          }
        });
      }

      // Render array visually
      function renderArray(animate=true){
        // We'll perform FLIP if animate is true
        if(animate){
          // capture before keys and rects
          const before = Array.from(arrayRow.children).map(el => ({key: el.dataset.key, rect: el.getBoundingClientRect()}));
          // create new DOM fragment
          const frag = document.createDocumentFragment();
          arr.forEach((val, idx) => {
            const tile = makeTile(val, idx);
            frag.appendChild(tile);
          });
          // replace children quickly
          while(arrayRow.firstChild) arrayRow.removeChild(arrayRow.firstChild);
          arrayRow.appendChild(frag);

          // After inserting new nodes, try FLIP: map keys to before rects by key
          const afterChildren = Array.from(arrayRow.children);
          const beforeMap = {};
          before.forEach(b => { beforeMap[b.key] = b.rect; });
          afterChildren.forEach(el => {
            const key = el.dataset.key;
            const prev = beforeMap[key];
            if(prev){
              const next = el.getBoundingClientRect();
              const dx = prev.left - next.left;
              const dy = prev.top - next.top;
              if(dx || dy){
                el.style.transition = 'none';
                el.style.transform = `translate(${dx}px, ${dy}px)`;
                requestAnimationFrame(() => {
                  el.style.transition = 'transform 260ms cubic-bezier(.2,.9,.3,1)';
                  el.style.transform = '';
                  const cleanup = () => { el.style.transition = ''; el.removeEventListener('transitionend', cleanup); };
                  el.addEventListener('transitionend', cleanup);
                });
              }
            } else {
              // new element: quick enter animation class
              el.classList.add('enter');
              setTimeout(()=> el.classList.remove('enter'), 400);
            }
          });

        } else {
          // simple render (no animation)
          arrayRow.innerHTML = '';
          arr.forEach((val, idx) => arrayRow.appendChild(makeTile(val, idx)));
        }

        // Update length and live code
        lengthBadge.textContent = String(arr.length);
        liveArray.textContent = arrayToCode(arr);

        // maintain selection if possible
        if(selectedIndex < 0 || selectedIndex >= arr.length){
          selectedIndex = -1;
          updateInspector();
        } else {
          highlightSelected();
        }
      }

      // Unique key generator to help FLIP mapping
      let _uid = 1;
      function makeTile(value, idx){
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.tabIndex = 0;
        // assign a stable-ish key: value + unique counter per index to allow mapping across operations
        // We'll maintain a data-key map based on current timestamp + idx to keep uniqueness
        tile.dataset.key = `${_uid++}-${String(value)}`;
        tile.setAttribute('role','button');
        tile.setAttribute('aria-label', `Element index ${idx} value ${value}`);
        tile.draggable = true;

        const v = document.createElement('div');
        v.className = 'value';
        v.textContent = String(value);

        const i = document.createElement('div');
        i.className = 'index';
        i.textContent = `idx ${idx}`;

        tile.appendChild(v);
        tile.appendChild(i);

        // click to select
        tile.addEventListener('click', (e) => {
          selectedIndex = idx;
          updateInspector();
          highlightSelected();
        });

        // keyboard support
        tile.addEventListener('keydown', (e) => {
          if(e.key === 'Enter'){
            selectedIndex = idx; updateInspector(); highlightSelected();
          } else if(e.key === 'ArrowLeft' || e.key === 'ArrowUp'){
            e.preventDefault();
            selectedIndex = Math.max(0, idx - 1);
            updateInspector(); highlightSelected(); focusSelected();
          } else if(e.key === 'ArrowRight' || e.key === 'ArrowDown'){
            e.preventDefault();
            selectedIndex = Math.min(arr.length - 1, idx + 1);
            updateInspector(); highlightSelected(); focusSelected();
          }
        });

        // Drag and drop: on dragstart store the source index and key
        tile.addEventListener('dragstart', (ev) => {
          try{ ev.dataTransfer.setData('text/plain', String(idx)); }catch(e){}
          tile.classList.add('dragging');
        });
        tile.addEventListener('dragend', (ev) => {
          tile.classList.remove('dragging');
        });

        // Allow drop on tiles
        tile.addEventListener('dragover', (ev) => {
          ev.preventDefault();
          tile.style.outline = '2px dashed rgba(255,255,255,0.06)';
        });
        tile.addEventListener('dragleave', (ev) => {
          tile.style.outline = '';
        });
        tile.addEventListener('drop', (ev) => {
          ev.preventDefault();
          tile.style.outline = '';
          const srcIdx = Number(ev.dataTransfer.getData('text/plain'));
          const destIdx = idx;
          if(Number.isInteger(srcIdx) && srcIdx >= 0 && srcIdx < arr.length && destIdx >=0 && destIdx < arr.length){
            if(srcIdx === destIdx) return;
            // swap elements
            const before = arr.slice();
            const a = arr.slice();
            [a[srcIdx], a[destIdx]] = [a[destIdx], a[srcIdx]];
            arr = a;
            selectedIndex = destIdx;
            log(`Swapped index ${srcIdx} and ${destIdx}`);
            renderArray(true);
            updateInspector();
          }
        });

        return tile;
      }

      function highlightSelected(){
        Array.from(arrayRow.children).forEach((child, i) => {
          if(i === selectedIndex) child.classList.add('selected');
          else child.classList.remove('selected');
        });
      }

      function focusSelected(){
        const el = arrayRow.children[selectedIndex];
        if(el) el.focus();
      }

      function updateInspector(){
        if(selectedIndex >= 0 && selectedIndex < arr.length){
          inspectorText.style.display = 'none';
          inspectorControls.style.display = 'flex';
          editValue.value = String(arr[selectedIndex]);
          inspectorText.textContent = `Index ${selectedIndex}: ${arr[selectedIndex]}`;
          inspectorText.style.display = 'none';
        } else {
          inspectorText.style.display = 'block';
          inspectorText.textContent = 'No item selected';
          inspectorControls.style.display = 'none';
        }
      }

      // Button actions
      pushBtn.addEventListener('click', () => {
        const v = valueInput.value;
        if(v === '') { flash(valueInput); return; }
        arr.push(v);
        log(`Pushed ${JSON.stringify(String(v))}`);
        valueInput.value = '';
        renderArray(true);
      });

      insertBtn.addEventListener('click', () => {
        const v = valueInput.value;
        const idx = parseInt(indexInput.value,10);
        if(v === '') { flash(valueInput); return; }
        if(!Number.isInteger(idx) || idx < 0 || idx > arr.length){
          flash(indexInput);
          return;
        }
        arr.splice(idx,0,v);
        log(`Inserted ${JSON.stringify(String(v))} at index ${idx}`);
        valueInput.value = '';
        indexInput.value = '';
        renderArray(true);
      });

      popBtn.addEventListener('click', () => {
        if(arr.length === 0){ flash(popBtn); return; }
        const removed = arr.pop();
        log(`Popped ${JSON.stringify(String(removed))}`);
        selectedIndex = -1;
        renderArray(true);
      });

      removeBtn.addEventListener('click', () => {
        const idx = parseInt(indexInput.value,10);
        if(!Number.isInteger(idx) || idx < 0 || idx >= arr.length){
          flash(indexInput);
          return;
        }
        const removed = arr.splice(idx,1)[0];
        log(`Removed ${JSON.stringify(String(removed))} at index ${idx}`);
        indexInput.value = '';
        selectedIndex = -1;
        renderArray(true);
      });

      clearBtn.addEventListener('click', () => {
        if(arr.length === 0) { flash(clearBtn); return; }
        arr = [];
        selectedIndex = -1;
        log('Cleared array');
        renderArray(true);
      });

      // Inspector save
      saveEdit.addEventListener('click', () => {
        if(selectedIndex < 0 || selectedIndex >= arr.length) return;
        arr[selectedIndex] = editValue.value;
        log(`Edited index ${selectedIndex} -> ${JSON.stringify(String(editValue.value))}`);
        renderArray(true);
      });

      // Keyboard in inputs: Enter acts like the primary action
      valueInput.addEventListener('keydown', (e) => {
        if(e.key === 'Enter') pushBtn.click();
      });
      indexInput.addEventListener('keydown', (e) => {
        if(e.key === 'Enter') insertBtn.click();
      });
      editValue.addEventListener('keydown', (e) => {
        if(e.key === 'Enter') saveEdit.click();
        if(e.key === 'Escape'){ updateInspector(); }
      });

      // visual flash for invalid input
      function flash(el){
        const orig = el.style.boxShadow;
        el.style.boxShadow = '0 0 0 4px rgba(239,68,68,0.12)';
        el.style.borderColor = 'rgba(239,68,68,0.35)';
        setTimeout(()=>{ el.style.boxShadow = orig; el.style.borderColor = ''; }, 420);
      }

      // Initial render
      renderArray(false);
      updateInspector();
      log('Module ready — initial array loaded');

      // Ensure minimum spacing of interactive elements (CSS handles gap) — for accessibility we attach aria-live to log
      // Ensure the array row is focusable and supports keyboard selection
      arrayRow.addEventListener('keydown', (e) => {
        if(selectedIndex < 0 && arr.length > 0) { selectedIndex = 0; updateInspector(); highlightSelected(); focusSelected(); }
      });

      // Make live updates accessible on small screens: ensure scroll into view when adding items
      function ensureVisible(idx){
        const el = arrayRow.children[idx];
        if(!el) return;
        el.scrollIntoView({behavior:'smooth', inline:'center', block:'nearest'});
      }

      // Observe when render occurs to scroll selected into view
      const observer = new MutationObserver(() => {
        if(selectedIndex >= 0) ensureVisible(selectedIndex);
      });
      observer.observe(arrayRow, {childList:true, subtree:false});

    })();
  </script>
</body>
</html>