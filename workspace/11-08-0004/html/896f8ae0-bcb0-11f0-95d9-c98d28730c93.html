<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Recursion Explorer — Calls & Returns</title>
  <style>
    /* Safe area and spacing variables */
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --accent: #0b79d0;
      --muted: #6b7280;
      --bg: #0f172a;
      --card: #0b1220;
      --success: #10b981;
      --danger: #ef4444;
      --surface: linear-gradient(180deg,#071025 0%, #031323 100%);
      --radius: 10px;
      --transition: 240ms cubic-bezier(.2,.9,.2,1);
    }

    /* Page reset */
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 400px at 10% 10%, rgba(11,121,208,0.06), transparent 6%),
                  radial-gradient(900px 300px at 90% 90%, rgba(16,185,129,0.03), transparent 6%),
                  var(--bg);
      color: #e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Outer container with safe area margins */
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    header {
      display:flex;
      gap: var(--gap);
      align-items: center;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .title {
      display:flex;
      gap:12px;
      align-items: baseline;
    }

    .title h1{
      font-size:20px;
      margin:0;
      letter-spacing: -0.2px;
    }
    .subtitle {
      color: var(--muted);
      font-size: 13px;
      margin:0;
    }

    /* Layout: two-column interactive module */
    .module {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: var(--gap);
      align-items: start;
    }

    /* Left column: text, controls */
    .panel {
      background: var(--card);
      padding: 18px;
      border-radius: var(--radius);
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      min-width: 280px;
    }

    .panel h2{
      margin:0 0 8px 0;
      font-size:16px;
    }
    .panel p {
      margin:0 0 12px 0;
      color: var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    .controls {
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      margin-top: 6px;
    }

    .control-row {
      display:flex;
      gap: 12px;
      align-items:center;
    }

    label {
      font-size:13px;
      min-width: 86px;
      color:#cfe7ff;
    }

    input[type="number"], select {
      flex:1;
      padding:8px 10px;
      border-radius:8px;
      background: rgba(255,255,255,0.03);
      color: #e6eef8;
      border: 1px solid rgba(255,255,255,0.03);
      font-size:14px;
    }

    input[type="range"] {
      width:100%;
    }

    .buttons {
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }

    button {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      color: #eaffff;
      border:1px solid rgba(255,255,255,0.04);
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      font-size:13px;
      transition: transform var(--transition), box-shadow var(--transition);
    }
    button:active { transform:translateY(1px) scale(.997); }
    button.primary {
      background: linear-gradient(180deg, var(--accent), #0476c4);
      box-shadow: 0 6px 18px rgba(11,121,208,0.16), 0 1px 0 rgba(255,255,255,0.02) inset;
      border: 0;
    }
    button.ghost {
      background: transparent;
      border: 1px dashed rgba(255,255,255,0.04);
    }

    /* Right column: visualization area */
    .visual {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 18px;
      min-height: 560px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      box-shadow: 0 8px 28px rgba(2,6,23,0.65);
    }

    .visual-top {
      display:flex;
      gap: var(--gap);
      align-items:center;
      justify-content: space-between;
    }

    .legend {
      color: var(--muted);
      font-size:13px;
    }

    /* Visualization panes */
    .viz-area {
      flex:1;
      display:flex;
      gap: var(--gap);
      min-height:380px;
      align-items:stretch;
    }

    .tree {
      flex:1;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent 40%);
      border-radius: 8px;
      padding:12px;
      position: relative;
      overflow:auto;
      border: 1px solid rgba(255,255,255,0.03);
    }

    .stack {
      width: 260px;
      background: linear-gradient(180deg, rgba(0,0,0,0.14), rgba(255,255,255,0.01));
      border-radius: 8px;
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap:12px;
      border: 1px solid rgba(255,255,255,0.03);
    }

    .stack h3 {
      margin:0;
      font-size:13px;
      color:#d8f0ff;
    }

    .stack-frame {
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      padding: 8px;
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap:8px;
      font-size:13px;
      border:1px solid rgba(255,255,255,0.02);
      transform-origin: center;
      transition: transform var(--transition), box-shadow var(--transition), opacity var(--transition);
    }

    .frame-current {
      box-shadow: 0 6px 18px rgba(11,121,208,0.12);
      transform: translateY(-4px) scale(1.01);
      border-color: rgba(11,121,208,0.4);
      background: linear-gradient(180deg, rgba(11,121,208,0.06), rgba(11,121,208,0.02));
    }

    .frame-returned {
      opacity: 0.6;
      background: linear-gradient(180deg, rgba(16,185,129,0.06), rgba(16,185,129,0.02));
      border-color: rgba(16,185,129,0.12);
    }

    /* SVG node styling */
    svg.node {
      overflow: visible;
    }

    .node-circle {
      fill: rgba(255,255,255,0.04);
      stroke: rgba(255,255,255,0.06);
      stroke-width: 1;
      transition: transform var(--transition), fill var(--transition), stroke var(--transition), opacity var(--transition);
    }
    .node-label {
      font-size:12px;
      fill: #dff2ff;
      pointer-events: none;
    }

    .node-current .node-circle {
      transform-origin: center;
      transform: scale(1.08);
      fill: rgba(11,121,208,0.12);
      stroke: rgba(11,121,208,0.7);
      filter: drop-shadow(0 8px 20px rgba(11,121,208,0.08));
    }

    .node-returned .node-circle {
      fill: rgba(16,185,129,0.06);
      stroke: rgba(16,185,129,0.22);
      opacity: 0.9;
    }

    /* small helper texts and hints */
    .hint {
      font-size:12px;
      color:var(--muted);
    }

    /* Responsive behavior: stack vertically on small viewports */
    @media (max-width: 880px){
      .module {
        grid-template-columns: 1fr;
      }
      .panel { order:2; }
      .visual { order:1; min-height: 640px; }
      .stack { width: 100%; }
    }

    /* Focus outlines for accessibility */
    button:focus, input:focus, select:focus {
      outline: 3px solid rgba(11,121,208,0.14);
      outline-offset: 2px;
      border-radius: 8px;
    }

    /* Small utility */
    .muted {
      color: var(--muted);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-labelledby="main-title">
    <header>
      <div class="title">
        <h1 id="main-title">Recursion Explorer</h1>
        <div class="subtitle">Visualize function calls, the call stack, and how returns propagate</div>
      </div>
      <div class="muted">Safe margins: 24px • Spacing: ≥16px • Vanilla HTML/CSS/JS</div>
    </header>

    <div class="module" aria-live="polite">
      <!-- Left panel: descriptions and controls -->
      <aside class="panel" aria-label="Controls and explanation">
        <h2>Concept</h2>
        <p><strong>Recursion:</strong> A function calling itself. This module demonstrates how recursive calls stack up, reach a base case, and then return values back down the call chain.</p>

        <h2>Learning Objective</h2>
        <p>After using this module you will be able to:
          <ul style="margin:6px 0 0 18px; padding:0; color:var(--muted); font-size:13px;">
            <li>See each recursive call as a stack frame (activation record)</li>
            <li>Observe execution order: calling (descending) vs returning (ascending)</li>
            <li>Understand base case and how return values flow back</li>
          </ul>
        </p>

        <div class="controls" role="region" aria-label="Interactive controls">
          <div class="control-row">
            <label for="example">Example</label>
            <select id="example" aria-describedby="example-desc">
              <option value="factorial">Factorial (linear recursion)</option>
              <option value="fibonacci">Fibonacci (branching recursion)</option>
            </select>
          </div>

          <div class="control-row" style="align-items:center;">
            <label for="input-n">Input n</label>
            <input id="input-n" type="number" min="0" max="12" value="5" aria-describedby="input-desc" />
          </div>

          <div class="control-row">
            <label for="speed">Speed</label>
            <input id="speed" type="range" min="200" max="1600" step="100" value="700" />
          </div>

          <div class="control-row">
            <label>Options</label>
            <div style="display:flex; gap:8px; align-items:center;">
              <label style="display:flex; gap:8px; align-items:center; font-size:13px;">
                <input id="show-returns" type="checkbox" checked /> Show return values
              </label>
              <label style="display:flex; gap:8px; align-items:center; font-size:13px;">
                <input id="auto-expand" type="checkbox" /> Auto-expand tree
              </label>
            </div>
          </div>

          <div class="buttons" role="group" aria-label="Playback controls">
            <button id="btn-run" class="primary" title="Run full animation">Run</button>
            <button id="btn-step" title="Step forward">Step ▶</button>
            <button id="btn-back" title="Step back">◀ Back</button>
            <button id="btn-reset" class="ghost" title="Reset visualization">Reset</button>
          </div>

          <div style="margin-top:6px;">
            <div class="hint">Tip: Use Step to carefully observe push (call) and pop (return) events. Toggle examples to compare single-branch and branching recursion.</div>
          </div>
        </div>
      </aside>

      <!-- Right panel: visualization -->
      <section class="visual" aria-label="Visualization">
        <div class="visual-top">
          <div class="legend">Visualization: calls appear in the tree (left) and as stack frames (right). Current active frame is highlighted.</div>
          <div class="muted" id="status" aria-live="polite">Ready</div>
        </div>

        <div class="viz-area">
          <div class="tree" id="tree" role="img" aria-label="Recursive call tree">
            <!-- SVG will be injected here -->
            <svg id="svg-tree" width="100%" height="100%" preserveAspectRatio="xMinYMin meet"></svg>
          </div>

          <aside class="stack" aria-label="Call stack">
            <h3>Call Stack</h3>
            <div id="stack-frames" aria-live="polite" style="display:flex; flex-direction:column; gap:12px;">
              <!-- Stack frames inserted here -->
            </div>
            <div class="muted" style="font-size:12px;">Base frames appear at bottom (LIFO top at top).</div>
          </aside>
        </div>
      </section>
    </div>
  </div>

  <script>
    /*
      Recursion Explorer
      - Single interactive module that visualizes recursion calls and returns.
      - Uses vanilla JS and SVG. No external assets.
      - Accessible controls and keyboard support where reasonable.

      Author: interactive module by assistant
    */

    (function(){
      // Layout constants
      const svg = document.getElementById('svg-tree');
      const stackContainer = document.getElementById('stack-frames');
      const exampleSelect = document.getElementById('example');
      const inputN = document.getElementById('input-n');
      const btnRun = document.getElementById('btn-run');
      const btnStep = document.getElementById('btn-step');
      const btnBack = document.getElementById('btn-back');
      const btnReset = document.getElementById('btn-reset');
      const speedRange = document.getElementById('speed');
      const statusEl = document.getElementById('status');
      const showReturnsCheckbox = document.getElementById('show-returns');
      const autoExpandCheckbox = document.getElementById('auto-expand');

      // Simulation state
      let events = []; // list of events produced by generator
      let nodes = {};  // node id -> node object for tree drawing
      let currentIndex = -1;
      let playingInterval = null;
      let treeRoot = null;
      let nodeCounter = 0;

      // Utility: unique id
      function uid(prefix='n'){ return prefix + (++nodeCounter); }

      // Generate events for factorial (linear) or fibonacci (branching)
      // Events model:
      // { type: 'call', id, label, parentId|null }
      // { type: 'return', id, value }
      function generateFactorialEvents(n){
        nodeCounter = 0;
        events = [];
        nodes = {};
        function callFact(k, parentId){
          const id = uid('f');
          events.push({type:'call', id, label:`fact(${k})`, parentId});
          if(k <= 1){
            // base case
            events.push({type:'return', id, value:1});
          } else {
            callFact(k-1, id);
            // After child returns, compute return value: value = k * childValue
            // But we can compute actual value by simulating stack; we'll resolve returns during event playback
            events.push({type:'return', id, value:null, compute: (child)=> k * child});
          }
        }
        callFact(n, null);
        return events;
      }

      // Generate events for fibonacci (branching)
      function generateFibonacciEvents(n){
        nodeCounter = 0;
        events = [];
        nodes = {};
        // For branching, we produce nodes with left/right child ids
        function callFib(k, parentId){
          const id = uid('b');
          events.push({type:'call', id, label:`fib(${k})`, parentId});
          if(k <= 1){
            events.push({type:'return', id, value:k});
            return id;
          }
          // left
          const leftId = callFib(k-1, id);
          // right
          const rightId = callFib(k-2, id);
          // after both, return value is sum of left and right
          events.push({type:'return', id, value:null, compute: (left, right) => left + right, children: [leftId, rightId]});
          return id;
        }
        callFib(n, null);
        return events;
      }

      // Build a tree structure for tree drawing by scanning events and creating nodes
      function buildTreeStructure(events){
        nodes = {};
        let rootId = null;
        for(const ev of events){
          if(ev.type === 'call'){
            nodes[ev.id] = Object.assign({}, ev, {children: []});
            if(ev.parentId) {
              if(nodes[ev.parentId]) nodes[ev.parentId].children.push(ev.id);
              else {
                // parent not yet defined — create placeholder
                nodes[ev.parentId] = {id:ev.parentId, label:'?', children:[ev.id], parentId:null};
              }
            } else {
              rootId = ev.id;
            }
          }
        }
        // Ensure children arrays exist
        Object.values(nodes).forEach(n => { n.children = n.children || []; });
        return rootId;
      }

      // Rendering: draw tree nodes and links as SVG
      // We'll compute positions by simple top-down layout:
      // - compute levels by BFS
      // - for each level, place nodes equally spaced horizontally
      function renderTreeStructure(rootId){
        const padding = 18;
        const width = Math.max(600, svg.clientWidth || 800);
        const height = Math.max(360, svg.clientHeight || 520);
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        while(svg.firstChild) svg.removeChild(svg.firstChild);

        if(!rootId) return;

        // Compute levels: BFS along nodes tree (only using nodes map)
        const levels = [];
        const q = [{id:rootId, depth:0}];
        const visited = new Set();
        while(q.length){
          const cur = q.shift();
          if(visited.has(cur.id)) continue;
          visited.add(cur.id);
          const depth = cur.depth;
          if(!levels[depth]) levels[depth] = [];
          levels[depth].push(cur.id);
          const n = nodes[cur.id];
          if(n && n.children) {
            for(const cid of n.children) q.push({id:cid, depth: depth+1});
          }
        }

        // For each level compute x positions
        const nodePositions = {};
        const levelHeight = Math.max(80, Math.floor((height - padding*2) / Math.max(1, levels.length)));
        levels.forEach((level, i) => {
          const y = padding + i * levelHeight + 28;
          const count = level.length;
          level.forEach((id, j) => {
            const x = padding + Math.floor( (width - padding*2) * ( (j+0.5) / count) );
            nodePositions[id] = {x,y};
          });
        });

        // Draw links first
        for(const id in nodes){
          const n = nodes[id];
          if(n.children && n.children.length){
            const p = nodePositions[id];
            if(!p) continue;
            for(const cid of n.children){
              const c = nodePositions[cid];
              if(!c) continue;
              const path = document.createElementNS('http://www.w3.org/2000/svg','path');
              const dx = c.x - p.x;
              const midx = p.x + dx * 0.5;
              const pathD = `M ${p.x} ${p.y + 14} C ${midx} ${p.y + 14}, ${midx} ${c.y - 14}, ${c.x} ${c.y - 14}`;
              path.setAttribute('d', pathD);
              path.setAttribute('stroke', 'rgba(255,255,255,0.04)');
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke-width', '1.6');
              svg.appendChild(path);
            }
          }
        }

        // Draw nodes
        for(const id in nodes){
          const n = nodes[id];
          const pos = nodePositions[id];
          if(!pos) continue;
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('transform', `translate(${pos.x},${pos.y})`);
          g.setAttribute('data-node-id', id);
          g.classList.add('node-group');

          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circle.setAttribute('r', '28');
          circle.setAttribute('class', 'node-circle');
          circle.setAttribute('cx', '0');
          circle.setAttribute('cy', '0');

          const label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('class', 'node-label');
          label.setAttribute('x', '0');
          label.setAttribute('y', '4');
          label.setAttribute('text-anchor','middle');
          label.textContent = n.label || '';

          // return value text (hidden until returned)
          const retText = document.createElementNS('http://www.w3.org/2000/svg','text');
          retText.setAttribute('class','node-label');
          retText.setAttribute('x','0');
          retText.setAttribute('y','22');
          retText.setAttribute('text-anchor','middle');
          retText.setAttribute('data-ret','true');
          retText.style.opacity = 0;
          retText.style.fontSize = '11px';
          retText.textContent = '';

          g.appendChild(circle);
          g.appendChild(label);
          g.appendChild(retText);

          svg.appendChild(g);
        }

        // Auto expand scroll: bring root centered if option on
        if(autoExpandCheckbox.checked){
          // scroll tree container so root is visible roughly
          setTimeout(()=>{
            const svgContainer = svg.ownerSVGElement ? svg.ownerSVGElement : svg;
            const treeDiv = document.getElementById('tree');
            treeDiv.scrollLeft = Math.max(0, svg.clientWidth/2 - treeDiv.clientWidth/2);
            treeDiv.scrollTop = 0;
          }, 40);
        }

        // Save node positions for later access
        svg._positions = nodePositions;
      }

      // Playback: apply events up to index i (inclusive) to update stack and node visuals
      function applyEventsToIndex(index){
        // Reset stack and node states
        stackContainer.innerHTML = '';
        const callValues = {}; // map id -> returned value
        const activeStack = []; // stack of ids

        // initial render: mark all nodes neutral
        const nodeGroups = svg.querySelectorAll('g.node-group');
        nodeGroups.forEach(g=> {
          g.classList.remove('node-current','node-returned');
          const ret = g.querySelector('[data-ret]');
          if(ret) {
            ret.textContent = '';
            ret.style.opacity = 0;
          }
        });

        // We'll process events sequentially up to 'index' and update structures
        for(let i=0;i<=index;i++){
          const ev = events[i];
          if(!ev) continue;
          if(ev.type === 'call'){
            // push this id on stack
            activeStack.unshift(ev.id);
            // create stack frame element (on top)
            const frame = document.createElement('div');
            frame.className = 'stack-frame frame-current';
            frame.setAttribute('data-frame-id', ev.id);
            frame.innerHTML = `<div style="font-weight:600;">${ev.label}</div><div style="min-width:38px; text-align:right;" data-val>…</div>`;
            // mark previous frame as non-current
            const prev = stackContainer.querySelector('.stack-frame.frame-current');
            if(prev && prev !== frame) prev.classList.remove('frame-current');
            stackContainer.insertBefore(frame, stackContainer.firstChild);
            // highlight node in tree
            const g = svg.querySelector(`g.node-group[data-node-id="${ev.id}"]`);
            if(g){
              g.classList.add('node-current');
            }
          } else if(ev.type === 'return'){
            // compute value:
            let value = ev.value;
            if(value === null && typeof ev.compute === 'function'){
              // if compute expects children values, gather them
              if(ev.children && Array.isArray(ev.children)){
                const childVals = ev.children.map(cid => callValues[cid] || 0);
                value = ev.compute(...childVals);
              } else {
                // single child: the next event before this return should be the last returned child's id
                // attempt to find most recently returned child among previously processed events
                // as a fallback we try stack top (below frame)
                const childVal = (() => {
                  // look at events before i to find a return of a child of this id
                  for(let k=i-1;k>=0;k--){
                    const pe = events[k];
                    if(pe.type === 'return' && pe.id !== ev.id && events.some(q=> q.type==='call' && q.id === pe.id && events.slice(0,i+1).some(r=> r.type==='call' && r.id===pe.id))){
                      if(pe.value !== null) return callValues[pe.id] ?? pe.value;
                      // else skip
                    }
                  }
                  return null;
                })();
                value = ev.compute(childVal);
              }
            }

            // record returned value
            callValues[ev.id] = (value === null || value === undefined) ? 0 : value;

            // update stack UI: find frame for this id
            const frameEl = stackContainer.querySelector(`.stack-frame[data-frame-id="${ev.id}"]`);
            if(frameEl){
              const valDiv = frameEl.querySelector('[data-val]');
              if(valDiv){
                valDiv.textContent = (showReturnsCheckbox.checked ? String(callValues[ev.id]) : '…');
              }
              frameEl.classList.add('frame-returned');
              frameEl.classList.remove('frame-current');
            }

            // update tree node returned text
            const g = svg.querySelector(`g.node-group[data-node-id="${ev.id}"]`);
            if(g){
              g.classList.remove('node-current');
              g.classList.add('node-returned');
              const ret = g.querySelector('[data-ret]');
              if(ret){
                ret.textContent = (showReturnsCheckbox.checked ? ('= ' + String(callValues[ev.id])) : '');
                ret.style.transition = 'opacity 260ms ease';
                ret.style.opacity = 1;
              }
            }

            // pop from activeStack if present
            const idx = activeStack.indexOf(ev.id);
            if(idx !== -1) activeStack.splice(idx,1);

            // set new current frame (the one at top of stack)
            const topFrame = stackContainer.querySelector('.stack-frame:not(.frame-returned)');
            // remove current class from all
            const allFrames = stackContainer.querySelectorAll('.stack-frame');
            allFrames.forEach(f => f.classList.remove('frame-current'));
            if(topFrame){
              topFrame.classList.add('frame-current');
            } else {
              // if none left, maybe last one returned — optionally highlight nothing
            }
          }
        }

        // final: highlight the current node in tree (top of stack)
        const currentFrame = stackContainer.querySelector('.stack-frame.frame-current');
        const currentId = currentFrame ? currentFrame.getAttribute('data-frame-id') : null;
        // clear all node-current classes
        const allNodes = svg.querySelectorAll('g.node-group');
        allNodes.forEach(g => g.classList.remove('node-current'));

        if(currentId){
          const gcur = svg.querySelector(`g.node-group[data-node-id="${currentId}"]`);
          if(gcur) gcur.classList.add('node-current');
        }
      }

      // Step functions
      function stepForward(){
        if(currentIndex < events.length - 1){
          currentIndex++;
          statusEl.textContent = `Step ${currentIndex+1} / ${events.length}`;
          applyEventsToIndex(currentIndex);
        } else {
          statusEl.textContent = 'End of events';
          stopPlaying();
        }
      }
      function stepBack(){
        if(currentIndex > -1){
          currentIndex--;
          statusEl.textContent = `Step ${Math.max(0, currentIndex+1)} / ${events.length}`;
          applyEventsToIndex(currentIndex);
        }
      }

      function startPlaying(){
        stopPlaying();
        const interval = parseInt(speedRange.value, 10) || 700;
        playingInterval = setInterval(() => {
          if(currentIndex >= events.length - 1){
            stopPlaying();
            statusEl.textContent = 'Finished';
            return;
          }
          stepForward();
        }, interval);
        statusEl.textContent = 'Playing...';
      }
      function stopPlaying(){
        if(playingInterval) clearInterval(playingInterval);
        playingInterval = null;
      }

      // Build events and render tree
      function prepareSimulation(){
        stopPlaying();
        currentIndex = -1;
        events = [];
        nodes = {};
        nodeCounter = 0;
        const choice = exampleSelect.value;
        const n = Math.max(0, Math.min(12, parseInt(inputN.value, 10) || 0));
        inputN.value = n;
        if(choice === 'factorial'){
          events = generateFactorialEvents(n);
        } else {
          // For fibonacci, be cautious with too large n (exponential)
          const maxFib = Math.min(10, n);
          if(n > 10){
            statusEl.textContent = 'Input too large for Fibonacci; limited to n=10';
          }
          events = generateFibonacciEvents(maxFib);
        }
        // Build node map and root id
        const rootId = buildTreeStructure(events);
        // Render SVG tree
        renderTreeStructure(rootId);

        statusEl.textContent = `Prepared ${events.length} events`;
        // Reset stack UI
        stackContainer.innerHTML = '';
      }

      // Initial preparation
      prepareSimulation();

      // Event handlers
      btnRun.addEventListener('click', ()=>{
        prepareSimulation();
        startPlaying();
      });

      btnStep.addEventListener('click', ()=>{
        if(playingInterval) { stopPlaying(); }
        if(currentIndex >= events.length - 1){
          // already finished, reset to start if desired
          // no-op or reset? we'll do nothing
        } else {
          stepForward();
        }
      });

      btnBack.addEventListener('click', ()=>{
        if(playingInterval) { stopPlaying(); }
        stepBack();
      });

      btnReset.addEventListener('click', ()=>{
        stopPlaying();
        currentIndex = -1;
        // clear highlights
        const all = svg.querySelectorAll('g.node-group');
        all.forEach(g => {
          g.classList.remove('node-current','node-returned');
          const ret = g.querySelector('[data-ret]');
          if(ret) { ret.style.opacity = 0; ret.textContent = ''; }
        });
        stackContainer.innerHTML = '';
        statusEl.textContent = 'Reset';
      });

      exampleSelect.addEventListener('change', ()=>{
        // If switching example, reprepare
        prepareSimulation();
      });

      inputN.addEventListener('change', ()=>{
        prepareSimulation();
      });

      speedRange.addEventListener('input', ()=>{
        if(playingInterval) {
          startPlaying(); // restart with new speed
        }
      });

      showReturnsCheckbox.addEventListener('change', ()=>{
        // Update current rendered return texts (if any)
        const show = showReturnsCheckbox.checked;
        const retEls = svg.querySelectorAll('[data-ret]');
        retEls.forEach(el => {
          if(el.textContent && el.textContent.trim()){
            el.style.opacity = show ? 1 : 0;
          }
        });
        // Also update stack frames display values
        const frames = stackContainer.querySelectorAll('.stack-frame');
        frames.forEach(f => {
          const valDiv = f.querySelector('[data-val]');
          if(valDiv && valDiv.textContent && valDiv.textContent !== '…'){
            valDiv.textContent = show ? valDiv.textContent : '…';
          }
        });
      });

      autoExpandCheckbox.addEventListener('change', ()=>{
        // nothing critical; render will use this option
      });

      // Keyboard shortcuts: Space to run/pause, ArrowRight step, ArrowLeft back
      document.addEventListener('keydown', (e)=>{
        if(e.key === ' '){
          e.preventDefault();
          if(playingInterval) stopPlaying();
          else startPlaying();
        } else if(e.key === 'ArrowRight'){
          e.preventDefault();
          if(playingInterval) stopPlaying();
          stepForward();
        } else if(e.key === 'ArrowLeft'){
          e.preventDefault();
          if(playingInterval) stopPlaying();
          stepBack();
        }
      });

      // Resize handling: re-render tree positions on container resize
      let resizeTimer = null;
      window.addEventListener('resize', ()=>{
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(()=> {
          // rebuild tree with same events
          const rootId = buildTreeStructure(events);
          renderTreeStructure(rootId);
          // reapply current index to refresh node states
          applyEventsToIndex(currentIndex);
        }, 150);
      });

      // Accessibility: focus first interactive control
      exampleSelect.focus();

      // Expose a tiny hint for screen readers
      svg.setAttribute('role','img');
      svg.setAttribute('aria-label','SVG tree of recursive calls; nodes are labeled with function and parameter. Watch stack panel for active frames.');

    })();
  </script>
</body>
</html>