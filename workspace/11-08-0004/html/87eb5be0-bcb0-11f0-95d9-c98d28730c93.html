<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Red-Black Tree — Interactive Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe: 24px;
      --gap: 16px; /* minimum spacing between interactive elements */
      --node-radius: 20;
      --level-gap: 90;
      --h-gap: 36; /* minimum horizontal gap for layout */
    }
    html,body {
      height:100%;
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: #f7f9fc;
      color:#0b1a2b;
    }
    .wrap {
      padding: var(--safe);
      box-sizing: border-box;
      min-height:100%;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    header {
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    h1 {
      margin:0;
      font-size:1.4rem;
      letter-spacing: -0.2px;
    }
    .meta {
      display:flex;
      gap: var(--gap);
      flex-wrap:wrap;
      align-items:center;
    }
    .chip {
      background:white;
      border-radius:8px;
      padding:8px 12px;
      box-shadow:0 1px 2px rgba(12,20,30,0.06);
      font-size:0.95rem;
    }

    /* Layout: controls + workspace + info */
    .module {
      display: grid;
      grid-template-columns: 320px 1fr 320px;
      gap: var(--gap);
      align-items:start;
    }

    /* Responsive adjustments */
    @media (max-width:1100px) {
      .module {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background:white;
      border-radius:12px;
      padding:16px;
      box-shadow:0 6px 18px rgba(12,20,30,0.06);
      min-height: 160px;
    }

    /* Controls panel (left) */
    .controls {
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .controls label {
      font-weight:600;
      font-size:0.95rem;
    }
    .inline {
      display:flex;
      gap:12px;
      align-items:center;
    }
    input[type="number"] {
      width:100%;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid #e2e8f0;
      font-size:1rem;
      box-sizing:border-box;
    }
    button {
      background:linear-gradient(180deg,#0f62fe,#0053d6);
      color:white;
      border:none;
      padding:10px 14px;
      border-radius:8px;
      font-weight:600;
      cursor:pointer;
      box-shadow: 0 4px 10px rgba(15,98,254,0.12);
    }
    button.secondary {
      background: white;
      color:#0b1a2b;
      border:1px solid #e6eef8;
      box-shadow:none;
    }
    .row {
      display:flex;
      gap:var(--gap);
    }
    .small {
      padding:8px 10px;
      font-size:0.95rem;
    }
    .muted {
      color:#475569;
      font-size:0.95rem;
    }

    /* Workspace center */
    .workspace {
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .canvas-wrap {
      background:linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);
      border-radius:12px;
      padding:12px;
      min-height:420px;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      position:relative;
      overflow:auto;
    }
    /* SVG tree scales responsively */
    svg {
      max-width:100%;
      height:auto;
      overflow:visible;
    }

    /* Node styles via classes */
    .node-group {
      cursor:default;
      transition: transform 450ms cubic-bezier(.2,.9,.25,1);
      transform-origin:center center;
    }
    .node-circle {
      stroke:#102a43;
      stroke-width:2px;
      transition: fill 300ms, stroke 300ms, r 300ms;
    }
    .node-text {
      font-weight:700;
      fill:white;
      font-size:14px;
      pointer-events:none;
      text-anchor:middle;
      dominant-baseline:central;
    }
    .edge {
      stroke:#9fb4cf;
      stroke-width:2;
      transition: stroke 300ms;
      fill:none;
    }

    /* Highlight classes */
    .highlight {
      filter: drop-shadow(0 4px 12px rgba(12,20,30,0.12));
    }
    .pulse {
      animation: pulse 900ms ease-in-out;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.12); }
      100% { transform: scale(1); }
    }

    /* Info panel (right) */
    .info {
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .log {
      font-size:0.95rem;
      color:#0b1a2b;
      background:#fbfdff;
      border-radius:8px;
      padding:12px;
      max-height:260px;
      overflow:auto;
    }
    .pseudocode {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
      background:#0b1a2b;
      color:#dbeafe;
      padding:12px;
      border-radius:8px;
      font-size:0.9rem;
      line-height:1.4;
      max-height:260px;
      overflow:auto;
    }
    .legend {
      display:flex;
      gap:12px;
      align-items:center;
      font-size:0.95rem;
      color:#475569;
    }
    .legend .box {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 8px;
      border-radius:8px;
      background:white;
      box-shadow:0 1px 2px rgba(12,20,30,0.04);
    }

    footer {
      font-size:0.9rem;
      color:#475569;
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }

    /* spacing rules to ensure minimum spacing between interactive elements */
    .controls > * { margin-bottom: 0; }
    .controls .row > * { min-width:0; }

    /* Accessibility focus */
    button:focus, input:focus {
      outline: 3px solid rgba(2,132,199,0.18);
      outline-offset: 2px;
    }

    /* small helper */
    .muted-note { font-size:0.9rem; color:#6b7280; }
  </style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Red-Black Tree interactive learning module">
    <header>
      <h1>Red-Black Tree — Insertion and Fix-Up (step-by-step)</h1>
      <div class="meta">
        <div class="chip" aria-hidden="true"><strong>Concept:</strong> Balanced BST with coloring & rotations</div>
        <div class="chip" aria-hidden="true"><strong>Focus:</strong> Insert cases, recolor, left/right rotations</div>
      </div>
      <!-- Descriptive sections required by design plan -->
      <div style="display:flex;gap:16px;flex-wrap:wrap;">
        <div style="background:#ffffff;padding:12px;border-radius:8px;box-shadow:0 1px 2px rgba(12,20,30,0.04);flex:1;min-width:240px;">
          <strong>Learning Objective</strong>
          <div style="margin-top:6px;color:#475569;">
            After interacting with this module, you will be able to: insert a key into a red-black tree and observe the algorithm's fix-up steps (recoloring and rotations) that restore the tree's invariants.
          </div>
        </div>
        <div style="background:#ffffff;padding:12px;border-radius:8px;box-shadow:0 1px 2px rgba(12,20,30,0.04);flex:1;min-width:240px;">
          <strong>Interaction Design</strong>
          <div style="margin-top:6px;color:#475569;">
            Enter a numeric value and click "Insert". The module performs the BST insert, colors the new node red, and generates a sequence of fix-up snapshots. Use "Next Step" to step through each snapshot (or Auto Play) to see recoloring, rotations, and messages. Visual feedback includes animated node movements, color transitions, and highlighted nodes/edges during each operation.
          </div>
        </div>
        <div style="background:#ffffff;padding:12px;border-radius:8px;box-shadow:0 1px 2px rgba(12,20,30,0.04);flex:1;min-width:240px;">
          <strong>Layout Description</strong>
          <div style="margin-top:6px;color:#475569;">
            Left: controls (input, action buttons, presets). Center: SVG visualization (tree, edges) with animated transitions. Right: textual log and pseudocode with current step highlighted. Safe margins: 24px on all sides; minimum spacing between interactive elements: 16px. Responsive: panels stack on narrow viewports. Keyboard accessible: Enter to insert, space for play/pause.
          </div>
        </div>
      </div>
    </header>

    <main class="module" role="main" aria-live="polite">
      <!-- Controls Panel -->
      <section class="panel controls" aria-label="Controls">
        <div>
          <label for="value-input">Insert value (integer)</label>
          <div class="inline" style="margin-top:8px;">
            <input id="value-input" type="number" aria-label="Value to insert" placeholder="e.g. 30" />
            <button id="insert-btn" class="small">Insert</button>
          </div>
          <div class="muted-note" style="margin-top:8px;">No duplicates allowed. Use integers; negative allowed.</div>
        </div>

        <div>
          <label>Stepping / Playback</label>
          <div class="row" style="margin-top:8px;">
            <button id="next-btn" class="secondary small">Next Step</button>
            <button id="play-btn" class="small">Auto Play</button>
            <button id="reset-btn" class="secondary small">Reset</button>
          </div>
          <div style="margin-top:8px;" class="muted">Tip: Press Enter to insert, press Space to toggle Auto Play.</div>
        </div>

        <div>
          <label>Presets</label>
          <div class="row" style="margin-top:8px;">
            <select id="preset" style="flex:1;padding:8px;border-radius:8px;border:1px solid #e2e8f0;">
              <option value="">-- Choose preset sequence --</option>
              <option value="10,20,30">Simple Rotate (10,20,30)</option>
              <option value="41,38,31,12,19,8">Complex (41,38,31,12,19,8)</option>
              <option value="7,3,18,10,22,8,11,26">Classic demo</option>
              <option value="1,2,3,4,5,6">Ascending insert</option>
            </select>
            <button id="load-preset" class="small">Load</button>
          </div>
        </div>

        <div>
          <label>Controls help</label>
          <div style="margin-top:8px;color:#475569;">
            Use "Next Step" to advance one snapshot at a time. "Auto Play" animates through steps automatically. The log on the right explains each change and highlights the pseudocode line being executed.
          </div>
        </div>
      </section>

      <!-- Visualization Workspace -->
      <section class="panel workspace" aria-label="Tree visualization">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div style="font-weight:700;">Tree Visualization</div>
          <div class="legend" aria-hidden="true">
            <div class="box"><svg width="18" height="18"><circle cx="9" cy="9" r="8" fill="#ef4444" stroke="#081024" stroke-width="1.5"/></svg> Red node</div>
            <div class="box"><svg width="18" height="18"><circle cx="9" cy="9" r="8" fill="#0b1223" stroke="#0b1223" stroke-width="1.5"/></svg> Black node</div>
          </div>
        </div>

        <div class="canvas-wrap" id="canvas-wrap" tabindex="0">
          <!-- SVG inserted here -->
          <svg id="tree-svg" width="1000" height="600" viewBox="0 0 1000 600" role="img" aria-label="Red-Black tree visualization"></svg>
        </div>
      </section>

      <!-- Info Panel -->
      <aside class="panel info" aria-label="Info and pseudocode">
        <div>
          <strong>Log (operation messages)</strong>
          <div id="log" class="log" aria-live="polite" role="log"></div>
        </div>

        <div>
          <strong>Pseudocode (insert & fixup)</strong>
          <pre id="pseudocode" class="pseudocode" aria-hidden="false">
RB-Insert(T, z)
  Insert z like in BST; color(z) = RED
  while z != root and color(parent(z)) == RED
    if parent(z) is left child of grandparent(z)
      y = uncle(z)
      if color(y) == RED                  # Case 1
        color(parent(z)) = BLACK
        color(y) = BLACK
        color(grandparent(z)) = RED
        z = grandparent(z)
      else
        if z is right child               # Case 2
          z = parent(z)
          LEFT-ROTATE(T, z)
        color(parent(z)) = BLACK         # Case 3
        color(grandparent(z)) = RED
        RIGHT-ROTATE(T, grandparent(z))
    else (mirror)
  color(root) = BLACK
          </pre>
        </div>
      </aside>
    </main>

    <footer>
      <div class="muted">This interactive focuses only on Red-Black Tree insertion and fixup visualized step-by-step.</div>
      <div class="muted">Accessible, responsive, and self-contained (vanilla HTML/CSS/JS).</div>
    </footer>
  </div>

  <script>
    /* Red-Black Tree interactive module (vanilla JS)
       - Implements BST insert + RB fixup
       - Records snapshots after each meaningful action
       - Renders tree as SVG; animates transitions via CSS transforms & transitions
    */

    (function() {
      // Utility
      function $(sel) { return document.querySelector(sel); }
      function htmlEscape(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

      // DOM elements
      const input = $('#value-input');
      const insertBtn = $('#insert-btn');
      const nextBtn = $('#next-btn');
      const playBtn = $('#play-btn');
      const resetBtn = $('#reset-btn');
      const logEl = $('#log');
      const svg = $('#tree-svg');
      const presetSel = $('#preset');
      const loadPresetBtn = $('#load-preset');
      const canvasWrap = $('#canvas-wrap');
      const pseudocodeEl = $('#pseudocode');

      // App state
      let idCounter = 1;
      function mkId(){ return idCounter++; }

      // Node class
      function Node(value) {
        this.id = mkId();
        this.value = value;
        this.color = 'red'; // new nodes start red
        this.left = null;
        this.right = null;
        this.parent = null;
      }

      // Root
      let root = null;

      // Snapshots array
      let snapshots = [];
      let currentStep = -1;
      let autoplay = false;
      let autoplayTimer = null;

      // Render params
      const levelGap = 90;
      const nodeRadius = 20;
      const baseWidth = 1000;

      // Insert API
      insertBtn.addEventListener('click', () => {
        const v = parseInt(input.value,10);
        if (Number.isNaN(v)) {
          alert('Enter an integer value to insert.');
          input.focus();
          return;
        }
        insertValue(v);
        input.value = '';
        input.focus();
      });

      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { insertBtn.click(); e.preventDefault(); }
        if (e.key === ' ' || e.key === 'Spacebar') { // toggle autoplay
          e.preventDefault();
          playBtn.click();
        }
      });

      nextBtn.addEventListener('click', stepNext);
      playBtn.addEventListener('click', togglePlay);
      resetBtn.addEventListener('click', resetTree);
      loadPresetBtn.addEventListener('click', loadPreset);

      // Helper to push log
      function pushLog(message) {
        const item = document.createElement('div');
        item.innerHTML = htmlEscape(message);
        logEl.prepend(item);
      }

      // Reset
      function resetTree() {
        root = null;
        snapshots = [];
        currentStep = -1;
        autoplay = false;
        clearInterval(autoplayTimer);
        playBtn.textContent = 'Auto Play';
        renderSnapshotEmpty();
        logEl.innerHTML = '';
        pushLog('Tree reset.');
      }

      // Initialize
      resetTree();

      // Insert sequence for presets
      function loadPreset() {
        const val = presetSel.value;
        if (!val) return;
        const arr = val.split(',').map(s => parseInt(s,10));
        if (!arr.length) return;
        // Reset then insert sequentially with small delays
        resetTree();
        pushLog('Loading preset: ' + val);
        let i=0;
        function nextInsert() {
          if (i>=arr.length) return;
          insertValue(arr[i++]);
          // auto-play through steps for each insertion
          autoplay = true;
          playBtn.textContent = 'Pause';
          if (i < arr.length) {
            setTimeout(nextInsert, 700); // small delay between insertions
          }
        }
        nextInsert();
      }

      // Insert value high-level
      function insertValue(value) {
        // check duplicates
        if (findNode(value)) {
          pushLog('Duplicate value ignored: ' + value);
          return;
        }
        clearSnapshotsAndStart();
        const z = new Node(value);
        // regular BST insert
        if (!root) {
          root = z;
          root.color = 'black'; // root must be black
          captureSnapshot(`Inserted ${value} as root (colored black)`, {highlight: [root.id]});
          finalizeSnapshots();
          return;
        }
        let cur = root;
        while (true) {
          if (value < cur.value) {
            if (!cur.left) {
              cur.left = z;
              z.parent = cur;
              break;
            } else cur = cur.left;
          } else {
            if (!cur.right) {
              cur.right = z;
              z.parent = cur;
              break;
            } else cur = cur.right;
          }
        }
        // z is red by default
        captureSnapshot(`Inserted ${value} as red leaf`, {highlight: [z.id]});
        // Run RB-Insert-Fixup and capture snapshots along the way
        rbInsertFixup(z);
        // After fixup ensure root black
        root.color = 'black';
        captureSnapshot(`Ensure root is black (root=${root.value})`, {highlight: [root.id]});
        finalizeSnapshots();
      }

      // Find node by value
      function findNode(v) {
        let p = root;
        while (p) {
          if (v === p.value) return p;
          p = v < p.value ? p.left : p.right;
        }
        return null;
      }

      // Snapshot helpers
      function clearSnapshotsAndStart(){
        snapshots = [];
        currentStep = -1;
      }

      function finalizeSnapshots(){
        if (snapshots.length === 0) {
          renderSnapshotEmpty();
          return;
        }
        // start at step 0
        currentStep = 0;
        renderSnapshot(currentStep);
      }

      function captureSnapshot(message, opts = {}) {
        // clone tree structure with colors and ids (we keep ids)
        const clone = cloneTree(root);
        snapshots.push({
          tree: clone,
          message: message || '',
          highlight: (opts.highlight || []).slice()
        });
      }

      function cloneTree(node, parentCloned=null, map = new Map()) {
        if (!node) return null;
        const copy = { id: node.id, value: node.value, color: node.color, left: null, right: null, parentId: parentCloned ? parentCloned.id : null };
        map.set(node.id, copy);
        if (node.left) copy.left = cloneTree(node.left, copy, map);
        if (node.right) copy.right = cloneTree(node.right, copy, map);
        return copy;
      }

      // RB-Fixup implementation with snapshots captured at key places
      function rbInsertFixup(z) {
        while (z !== root && colorOf(parentOf(z)) === 'red') {
          const p = parentOf(z);
          const g = parentOf(p);
          if (!g) break;
          if (p === g.left) {
            const y = g.right; // uncle
            if (colorOf(y) === 'red') {
              // Case 1
              p.color = 'black';
              if (y) y.color = 'black';
              g.color = 'red';
              captureSnapshot(`Case 1: parent and uncle are red — recolor parent(${p.value}) and uncle(${y?y.value:'null'}) to black, grandparent(${g.value}) to red`, {highlight: [p.id, (y&&y.id)||-1, g.id]});
              z = g;
            } else {
              if (z === p.right) {
                // Case 2
                captureSnapshot(`Case 2: node is right child — left-rotate at parent(${p.value})`, {highlight: [z.id, p.id]});
                rotateLeft(p);
                // after rotation, p and z swap roles; update p,g references
                z = p;
              }
              // Case 3
              const p2 = parentOf(z);
              const g2 = parentOf(p2);
              if (p2) p2.color = 'black';
              if (g2) g2.color = 'red';
              captureSnapshot(`Case 3: recolor parent(${p2? p2.value:'?'}) black, grandparent(${g2? g2.value:'?'}) red, then right-rotate at grandparent`, {highlight: [ (p2&&p2.id)||-1, (g2&&g2.id)||-1 ]});
              if (g2) rotateRight(g2);
            }
          } else {
            // mirror: p is right child of g
            const y = g.left; // uncle
            if (colorOf(y) === 'red') {
              // Case 1 mirror
              p.color = 'black';
              if (y) y.color = 'black';
              g.color = 'red';
              captureSnapshot(`Mirror Case 1: parent and uncle are red — recolor parent(${p.value}) and uncle(${y?y.value:'null'}) to black, grandparent(${g.value}) to red`, {highlight: [p.id, (y&&y.id)||-1, g.id]});
              z = g;
            } else {
              if (z === p.left) {
                // Case 2 mirror
                captureSnapshot(`Mirror Case 2: node is left child — right-rotate at parent(${p.value})`, {highlight: [z.id, p.id]});
                rotateRight(p);
                z = p;
              }
              // Case 3 mirror
              const p2 = parentOf(z);
              const g2 = parentOf(p2);
              if (p2) p2.color = 'black';
              if (g2) g2.color = 'red';
              captureSnapshot(`Mirror Case 3: recolor parent(${p2? p2.value:'?'}) black, grandparent(${g2? g2.value:'?'}) red, then left-rotate at grandparent`, {highlight: [ (p2&&p2.id)||-1, (g2&&g2.id)||-1 ]});
              if (g2) rotateLeft(g2);
            }
          }
        }
      }

      // Utility helpers to get parent/node by value or id in current live tree
      function parentOf(node) {
        if (!node) return null;
        // node may be live (Node instance) or a snapshot node (object)
        return node.parent || node.parentNode || null;
      }

      function colorOf(node) {
        if (!node) return 'black'; // null considered black
        return node.color || 'black';
      }

      // But we mixed live Node instances and snapshots clones.
      // For rotations we must operate on live tree (Node instances). parentOf should work on live nodes.
      // So we need helper that given a Node-like object finds parent (for live objects it's property)
      function parentOf(node) {
        if (!node) return null;
        return node.parent || null;
      }
      function colorOf(node) {
        if (!node) return 'black';
        return node.color;
      }

      // Rotation functions operate on live Node instances and update 'root' if necessary
      function rotateLeft(x) {
        const y = x.right;
        if (!y) return;
        x.right = y.left;
        if (y.left) y.left.parent = x;
        y.parent = x.parent;
        if (!x.parent) { root = y; }
        else if (x === x.parent.left) { x.parent.left = y; }
        else { x.parent.right = y; }
        y.left = x;
        x.parent = y;
        captureSnapshot(`Performed left-rotate at node ${x.value}`, {highlight: [x.id, y.id]});
      }

      function rotateRight(x) {
        const y = x.left;
        if (!y) return;
        x.left = y.right;
        if (y.right) y.right.parent = x;
        y.parent = x.parent;
        if (!x.parent) { root = y; }
        else if (x === x.parent.right) { x.parent.right = y; }
        else { x.parent.left = y; }
        y.right = x;
        x.parent = y;
        captureSnapshot(`Performed right-rotate at node ${x.value}`, {highlight: [x.id, y.id]});
      }

      // Rendering snapshots
      function renderSnapshotEmpty() {
        svg.innerHTML = '';
      }

      function renderSnapshot(index) {
        if (index < 0 || index >= snapshots.length) return;
        const snap = snapshots[index];
        logEl.prepend(createLogEntry(snap.message));
        // Render snap.tree (cloned tree)
        const tree = snap.tree;
        svg.innerHTML = ''; // reset
        // Build layout positions
        const nodes = [];
        // inorder traversal to compute x
        let xCounter = 0;
        function layout(n, depth) {
          if (!n) return;
          layout(n.left, depth+1);
          const x = ++xCounter;
          nodes.push({ id: n.id, value: n.value, color: n.color, depth, order: x, raw: n });
          layout(n.right, depth+1);
        }
        layout(tree, 0);
        if (nodes.length === 0) return;
        // Compute canvas width based on number of leaf positions
        const spacingX = Math.max(40, Math.floor((baseWidth - 80) / nodes.length));
        const totalWidth = Math.max(baseWidth, nodes.length * spacingX + 120);
        const maxDepth = Math.max(...nodes.map(n => n.depth));
        const neededHeight = Math.max(200, (maxDepth+2) * levelGap + 80);
        svg.setAttribute('viewBox', `0 0 ${totalWidth} ${neededHeight}`);
        // map id->pos
        const pos = new Map();
        nodes.forEach(n => {
          const px = 60 + (n.order-1) * spacingX;
          const py = 40 + n.depth * levelGap;
          pos.set(n.id, {x:px, y:py, value:n.value, color:n.color});
        });

        // Edges: draw as paths from parent to child using the tree clones
        function drawEdges(n) {
          if (!n) return;
          if (n.left) {
            const p = pos.get(n.id);
            const c = pos.get(n.left.id);
            const path = createEdgePath(p.x, p.y, c.x, c.y);
            svg.appendChild(path);
            drawEdges(n.left);
          }
          if (n.right) {
            const p = pos.get(n.id);
            const c = pos.get(n.right.id);
            const path = createEdgePath(p.x, p.y, c.x, c.y);
            svg.appendChild(path);
            drawEdges(n.right);
          }
        }
        drawEdges(tree);

        // Nodes
        nodes.forEach(n => {
          const p = pos.get(n.id);
          const g = createNodeGroup(n.id, p.x, p.y, n.value, n.color, snap.highlight || []);
          svg.appendChild(g);
        });

        // update pseudocode highlight heuristically based on message
        highlightPseudocode(snap.message);
      }

      function createLogEntry(msg) {
        const el = document.createElement('div');
        el.textContent = msg;
        return el;
      }

      function createEdgePath(x1,y1,x2,y2) {
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        const dx = Math.abs(x2 - x1);
        const midx = (x1 + x2) / 2;
        const controlY = (y1 + y2) / 2;
        // simple cubic curve
        const d = `M ${x1} ${y1+nodeRadius} C ${x1} ${y1+controlY/2} ${x2} ${y2-controlY/2} ${x2} ${y2-nodeRadius}`;
        path.setAttribute('d', `M ${x1} ${y1+20} Q ${midx} ${(y1+y2)/2} ${x2} ${y2-20}`);
        path.setAttribute('class','edge');
        return path;
      }

      function createNodeGroup(id, x, y, value, color, highlightList) {
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('class','node-group');
        g.setAttribute('transform', `translate(${x}, ${y})`);
        g.setAttribute('data-id', id);
        g.setAttribute('role','img');
        g.setAttribute('aria-label', `node ${value} ${color}`);
        // circle
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('r', nodeRadius);
        c.setAttribute('class','node-circle');
        c.setAttribute('fill', color === 'red' ? '#ef4444' : '#0b1223');
        c.setAttribute('stroke', '#0b1223');
        g.appendChild(c);
        // text
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('class','node-text');
        t.textContent = value;
        g.appendChild(t);

        // highlight if included
        if (highlightList && highlightList.indexOf(id) !== -1) {
          c.style.stroke = '#ffd166';
          c.style.strokeWidth = '3px';
          g.classList.add('highlight');
          // pulse
          g.classList.add('pulse');
          setTimeout(()=> g.classList.remove('pulse'), 900);
        }

        return g;
      }

      // Step control
      function stepNext() {
        if (currentStep < 0 || currentStep >= snapshots.length-1) {
          // if there are snapshots left but not started
          if (snapshots.length > 0 && currentStep === -1) {
            currentStep = 0; renderSnapshot(currentStep);
            return;
          }
          // end
          autoplay = false;
          playBtn.textContent = 'Auto Play';
          return;
        }
        currentStep++;
        renderSnapshot(currentStep);
      }

      function togglePlay() {
        if (autoplay) {
          autoplay = false;
          playBtn.textContent = 'Auto Play';
          clearInterval(autoplayTimer);
        } else {
          autoplay = true;
          playBtn.textContent = 'Pause';
          if (currentStep === -1 && snapshots.length>0) {
            currentStep = 0;
            renderSnapshot(currentStep);
          }
          autoplayTimer = setInterval(() => {
            if (currentStep >= snapshots.length-1) {
              clearInterval(autoplayTimer);
              autoplay = false;
              playBtn.textContent = 'Auto Play';
              return;
            }
            currentStep++;
            renderSnapshot(currentStep);
          }, 900);
        }
      }

      // Heuristic pseudocode highlight
      function highlightPseudocode(message) {
        const pcText = pseudocodeEl.textContent;
        // Remove existing highlight by resetting innerHTML (simple)
        let html = pcText.replace(/</g,'&lt;').replace(/>/g,'&gt;');
        // Highlight keywords based on message
        const lower = (message||'').toLowerCase();
        let highlightPhrase = '';
        if (lower.includes('case 1')) highlightPhrase = 'Case 1';
        else if (lower.includes('case 2')) highlightPhrase = 'Case 2';
        else if (lower.includes('case 3')) highlightPhrase = 'Case 3';
        else if (lower.includes('left-rotate')) highlightPhrase = 'LEFT-ROTATE';
        else if (lower.includes('right-rotate')) highlightPhrase = 'RIGHT-ROTATE';
        // Apply simple emphasis by replacing phrase occurrences
        if (highlightPhrase) {
          const re = new RegExp(highlightPhrase.replace(/[-\/\\^$*+?.()|[\]{}]/g,'\\$&'), 'g');
          html = html.replace(re, `<span style="background:#062c55;color:#c7f3ff;padding:2px 4px;border-radius:4px;">${highlightPhrase}</span>`);
        }
        pseudocodeEl.innerHTML = html;
      }

      // For demonstration, render empty message
      function initialRenderEmpty() {
        svg.innerHTML = '';
        // draw placeholder text
        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.setAttribute('x', 20);
        text.setAttribute('y', 40);
        text.setAttribute('fill','#94a3b8');
        text.setAttribute('font-size', '14');
        text.textContent = 'Insert nodes to visualize the Red-Black Tree (BST insert → fix-up snapshots).';
        svg.appendChild(text);
      }
      initialRenderEmpty();

      // Accessibility: keyboard for space toggling autoplay
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          // but avoid interfering with typing into input
          if (document.activeElement === input) return;
          e.preventDefault();
          togglePlay();
        }
      });

      // Some initial hints in log
      pushLog('Welcome! Enter values and click Insert. Use Next Step or Auto Play to step through the RB insert fix-up.');
    })();
  </script>
</body>
</html>