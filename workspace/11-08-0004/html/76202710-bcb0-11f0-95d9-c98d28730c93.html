<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Adjacency Matrix — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #98a8c7;
      --accent: #60a5fa;
      --accent-2: #7ee787;
      --danger: #fb7185;
      --cell-size: 36px;
      --node-radius: 22;
      --max-width: 1200px;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071026 0%, #081229 100%);
      color: #e6eef8;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .container{
      max-width: var(--max-width);
      margin: var(--safe-margin) auto;
      padding: var(--safe-margin);
      box-sizing: border-box;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
      min-height: calc(100vh - calc(var(--safe-margin) * 2));
      display: grid;
      grid-template-columns: 1fr 420px;
      gap: var(--gap);
    }

    /* Responsive: stack columns on narrow screens */
    @media (max-width: 920px){
      .container{
        grid-template-columns: 1fr;
      }
    }

    header{
      grid-column: 1 / -1;
      margin-bottom: calc(var(--gap));
    }

    h1{
      margin:0 0 8px 0;
      font-size:20px;
      letter-spacing: -0.2px;
      color: #eaffff;
    }

    .subtitle{
      margin:0;
      color: var(--muted);
      font-size:13px;
    }

    .left-panel, .right-panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
      border-radius:10px;
      padding:16px;
      min-height: 360px;
      box-sizing:border-box;
      border: 1px solid rgba(255,255,255,0.03);
    }

    /* Left: Graph canvas and controls */
    .controls{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
      align-items:center;
      margin-bottom:var(--gap);
    }

    .controls > *{
      min-width: 0;
    }

    button, .toggle{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      color: #e6eef8;
      padding: 8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }

    button:hover{ transform: translateY(-2px); box-shadow: 0 6px 18px rgba(3,7,18,0.5); }
    button:active{ transform: translateY(0); }

    .toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px;
    }

    .toggle input{ width:14px; height:14px; accent-color: var(--accent); }

    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      margin-left:auto;
      color:var(--muted);
      font-size:13px;
    }

    .canvas-wrap{
      border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border:1px solid rgba(255,255,255,0.03);
      padding:12px;
      min-height:360px;
      box-sizing:border-box;
      position:relative;
      overflow:hidden;
    }

    svg{
      width:100%;
      height:100%;
      touch-action:none;
    }

    .help{
      margin-top:12px;
      color:var(--muted);
      font-size:13px;
    }

    /* Right: Explanations and Matrix */
    .right-panel .section{
      margin-bottom:16px;
    }

    .section h3{
      margin:0 0 8px 0;
      font-size:15px;
      color:#e8f4ff;
    }

    .section p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    /* Matrix */
    .matrix-wrap{
      overflow:auto;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      padding:8px;
      margin-top:12px;
      background: rgba(10,14,20,0.4);
    }

    table.matrix{
      border-collapse:collapse;
      font-family: monospace;
      background:transparent;
    }

    table.matrix th, table.matrix td{
      width: var(--cell-size);
      height: var(--cell-size);
      text-align:center;
      font-size:13px;
      padding:0;
      margin:0;
      border: 1px solid rgba(255,255,255,0.02);
      color: #cfe8ff;
    }

    table.matrix th{
      background: rgba(255,255,255,0.02);
      color: var(--muted);
      font-weight:600;
    }

    .cell-button{
      display:flex;
      align-items:center;
      justify-content:center;
      width:100%;
      height:100%;
      background:transparent;
      border:none;
      color:#cfe8ff;
      cursor:pointer;
      font-weight:700;
      transition: background 0.12s ease, color 0.12s ease;
    }

    .cell-button[aria-pressed="true"]{
      background: linear-gradient(90deg, rgba(96,165,250,0.12), rgba(126,231,135,0.06));
      color: var(--accent-2);
    }

    .cell-button:focus{
      outline: 2px solid rgba(96,165,250,0.25);
      outline-offset: -2px;
      border-radius:4px;
    }

    /* Node styles */
    .node{
      cursor:pointer;
      stroke: rgba(255,255,255,0.06);
      stroke-width:1.5;
      transition: transform 0.12s ease;
    }

    .node:hover{ transform: scale(1.06); }

    .node-label{
      font-size:12px;
      pointer-events:none;
      fill:#0b1220;
      font-weight:700;
    }

    .edge{
      fill:none;
      stroke: rgba(255,255,255,0.09);
      stroke-width:2;
      transition: stroke 0.18s ease, opacity 0.18s ease;
      stroke-linecap:round;
    }

    .edge.active{
      stroke: url(#edgeGrad);
      opacity:1;
      stroke-width:3;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.6));
    }

    .edge.hidden{
      opacity:0.08;
    }

    /* Highlights */
    .highlight{
      stroke: rgba(126,231,135,0.9) !important;
      stroke-width:3 !important;
    }

    /* small helper */
    .muted{
      color:var(--muted);
      font-size:13px;
    }

    footer{
      grid-column: 1 / -1;
      margin-top:8px;
      color:var(--muted);
      font-size:13px;
    }

    /* ensure spacing between interactive elements >=16px */
    .controls > * { margin-right: 0; margin-bottom:0; }
    .controls > button + button { margin-left: 0; }
    .controls > * { gap:0; }

    /* Simple tooltip */
    .tooltip{
      position:absolute;
      background:#071026;
      color:var(--muted);
      padding:8px 10px;
      border-radius:8px;
      font-size:12px;
      border:1px solid rgba(255,255,255,0.03);
      pointer-events:none;
      transform:translate(-50%, -140%);
      white-space:nowrap;
      display:none;
    }

    /* Small screens adjust matrix cell size */
    @media (max-width:520px){
      :root{ --cell-size:30px; }
      .right-panel{ padding:12px; }
    }
  </style>
</head>
<body>
  <div class="container" role="main" aria-label="Adjacency Matrix interactive module">
    <header>
      <h1>Adjacency Matrix — Visual & Interactive Exploration</h1>
      <p class="subtitle">Interactively build a graph and observe its adjacency matrix (and vice versa). Drag nodes, toggle edges, and watch the matrix update in real time.</p>
    </header>

    <section class="left-panel" aria-labelledby="graph-title">
      <div class="controls" aria-hidden="false">
        <button id="add-node-btn" title="Add a new node">Add Node</button>
        <button id="del-node-btn" title="Delete selected node">Delete Node</button>
        <button id="clear-btn" title="Clear graph">Clear</button>
        <button id="random-btn" title="Random sample graph">Random Graph</button>

        <label class="toggle" title="Toggle directed/undirected graph">
          <input type="checkbox" id="directed-toggle" aria-label="Directed graph toggle">
          Directed
        </label>

        <div class="legend" aria-hidden="true">
          <span class="muted">Edge = 1 (active)</span>
        </div>
      </div>

      <div class="canvas-wrap" id="canvas-wrap">
        <svg id="svg-canvas" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Graph canvas">
          <defs>
            <linearGradient id="edgeGrad" x1="0" x2="1">
              <stop offset="0%" stop-color="#60a5fa" stop-opacity="1"></stop>
              <stop offset="100%" stop-color="#7ee787" stop-opacity="1"></stop>
            </linearGradient>
            <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#7ee787" />
            </marker>
          </defs>
          <!-- edges and nodes will be injected here -->
        </svg>
        <div class="tooltip" id="tooltip" role="status" aria-live="polite"></div>
      </div>

      <p class="help" id="graph-title">
        How to interact: Click "Add Node" to create nodes. Click one node then another to toggle an edge (shift-click to create directed edge regardless of toggle). Drag nodes to rearrange. You can also click matrix cells on the right to toggle edges.
      </p>
    </section>

    <aside class="right-panel" aria-labelledby="matrix-title">
      <div class="section">
        <h3 id="matrix-title">Learning Objective</h3>
        <p>After interacting, you'll understand how a graph's adjacency matrix encodes which vertices are connected: each row/column pair corresponds to source/target, and a cell value of 1 means an edge exists between the two vertices.</p>
      </div>

      <div class="section">
        <h3>Interaction Design (summary)</h3>
        <p class="muted">Click nodes to toggle edges; click or keyboard-focus matrix cells to toggle the corresponding adjacency entry. The graph and matrix update instantly and highlight corresponding nodes/cells during mouse hover. In undirected mode, toggling one cell updates the symmetric cell.</p>
      </div>

      <div class="section">
        <h3>Adjacency Matrix (click cells to toggle)</h3>
        <div class="matrix-wrap" id="matrix-wrap" aria-live="polite" aria-atomic="true">
          <div id="matrix-container" style="min-width:200px;"></div>
        </div>
      </div>

      <div class="section">
        <h3>Layout Description</h3>
        <p class="muted">Canvas at left shows the graph; controls above canvas; matrix and explanatory text on the right. Safe margins are 24px, and interactive elements maintain a minimum 16px spacing to ensure clarity. The interface is responsive — on narrow screens the matrix stacks below the canvas.</p>
      </div>
    </aside>

    <footer>
      Interaction tips: Use keyboard to focus matrix cells (Tab), press Space/Enter to toggle. Use Shift-click on nodes to force directed edge creation even when "Directed" is off.
    </footer>
  </div>

  <script>
    /* Adjacency Matrix Interactive Module (vanilla JS)
       - Nodes: draggable circles on SVG
       - Edges: SVG paths with arrows if directed
       - Matrix: HTML table showing 0/1; clicking toggles edges
       - Interactions:
         * Add node: adds node with label A,B,C...
         * Click node then another to toggle edge (shift-click forces directed)
         * Drag nodes to reposition
         * Toggle Directed checkbox switches behavior (matrix updates symmetrically if undirected)
    */

    (function(){
      // Constants & state
      const svg = document.getElementById('svg-canvas');
      const matrixContainer = document.getElementById('matrix-container');
      const addBtn = document.getElementById('add-node-btn');
      const delBtn = document.getElementById('del-node-btn');
      const clearBtn = document.getElementById('clear-btn');
      const randomBtn = document.getElementById('random-btn');
      const directedToggle = document.getElementById('directed-toggle');
      const tooltip = document.getElementById('tooltip');
      const canvasWrap = document.getElementById('canvas-wrap');

      const NODE_R = 22;
      const WIDTH = 800, HEIGHT = 600;

      let nodes = []; // {id, label, x, y}
      let edges = {}; // key "i-j" => {i,j,active,elem}
      let adj = []; // 2D array of 0/1
      let nextId = 0;
      let selectedNode = null; // for creating edges
      let selectedGraphNode = null; // for deletion selection
      let dragging = null;

      // Helpers
      function letterLabel(n){
        // A,B,...,Z,AA,AB...
        let s = '';
        n++;
        while(n>0){
          let rem = (n-1)%26;
          s = String.fromCharCode(65+rem) + s;
          n = Math.floor((n-1)/26);
        }
        return s;
      }

      function resetState(){
        nodes = [];
        edges = {};
        adj = [];
        nextId = 0;
        selectedNode = null;
        selectedGraphNode = null;
        clearSVG();
        rebuildMatrix();
      }

      function clearSVG(){
        while(svg.lastChild){
          svg.removeChild(svg.lastChild);
        }
        // re-add defs (edgeGrad & marker) for styling
        const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
        defs.innerHTML = `
          <linearGradient id="edgeGrad" x1="0" x2="1">
            <stop offset="0%" stop-color="#60a5fa" stop-opacity="1"></stop>
            <stop offset="100%" stop-color="#7ee787" stop-opacity="1"></stop>
          </linearGradient>
          <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#7ee787" />
          </marker>
        `;
        svg.appendChild(defs);
      }

      function addNodeAt(x,y){
        const id = nextId++;
        const label = letterLabel(id);
        nodes.push({id,label,x,y});
        // expand adjacency
        for(let r=0;r<adj.length;r++) adj[r].push(0);
        adj.push(new Array(nodes.length).fill(0));
        drawNode(id);
        rebuildMatrix();
      }

      function addNodeAuto(){
        const margin = 60;
        const angle = (nodes.length) * 0.9;
        const r = Math.min(WIDTH, HEIGHT) / 3;
        const cx = WIDTH/2 + Math.cos(angle)*r*0.6;
        const cy = HEIGHT/2 + Math.sin(angle)*r*0.6;
        addNodeAt(cx, cy);
      }

      function drawNode(id){
        const node = nodes.find(n=>n.id===id);
        if(!node) return;
        // group
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('data-id',id);
        g.setAttribute('class','node-group');
        g.setAttribute('transform',`translate(${node.x},${node.y})`);
        // circle
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('r', NODE_R);
        c.setAttribute('fill','#dbeafe');
        c.setAttribute('class','node');
        c.setAttribute('stroke','#0b1220');
        c.setAttribute('stroke-width','1.2');
        c.setAttribute('aria-label','Node '+node.label);
        // label
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('class','node-label');
        t.setAttribute('text-anchor','middle');
        t.setAttribute('dy','4');
        t.textContent = node.label;
        g.appendChild(c);
        g.appendChild(t);
        svg.appendChild(g);

        // event listeners
        g.addEventListener('pointerdown', onNodePointerDown);
        g.addEventListener('click', onNodeClick);
        g.addEventListener('pointerup', onNodePointerUp);
        g.addEventListener('pointerover', onNodePointerOver);
        g.addEventListener('pointerout', onNodePointerOut);

        // update edges (none to start)
        redrawAllEdges();
      }

      function removeNode(id){
        const idx = nodes.findIndex(n=>n.id===id);
        if(idx<0) return;
        nodes.splice(idx,1);
        // remove adjacency row/col
        adj.splice(idx,1);
        adj.forEach(row=>row.splice(idx,1));
        // fix labels & redraw nodes with new labels and ids? We'll keep ids consistent but update labels array mapping to indices.
        // For simplicity, rebuild everything:
        rebuildAll();
      }

      function rebuildAll(){
        // rebuild adjacency to match nodes.length (ensured)
        // Clear svg and re-create nodes and edges
        clearSVG();
        // re-add nodes in order
        nodes.forEach((n, i)=>{
          n.label = letterLabel(i);
        });
        nodes.forEach(n=>drawNode(n.id));
        rebuildMatrix();
      }

      // Edge key helpers: by indices in node order (0..n-1)
      function edgeKey(i,j){ return i+'-'+j; }

      function setEdge(i,j,active){
        if(!adj[i] || typeof adj[i][j] === 'undefined') return;
        adj[i][j] = active?1:0;
        // if undirected, mirror
        if(!directedToggle.checked && i!==j){
          adj[j][i] = active?1:0;
        }
        rebuildMatrix();
        redrawAllEdges();
      }

      function toggleEdge(i,j){
        const cur = adj[i][j] || 0;
        setEdge(i,j, !cur);
      }

      function redrawAllEdges(){
        // Remove existing edge elems except defs
        // Remove all path/marker elements except defs
        // But preserve nodes (g elements)
        // First remove existing path elements
        const existingEdges = Array.from(svg.querySelectorAll('.edge'));
        existingEdges.forEach(e => e.parentNode && e.parentNode.removeChild(e));

        // Create edges based on current adj
        const n = nodes.length;
        for(let i=0;i<n;i++){
          for(let j=0;j<n;j++){
            if(adj[i][j]){
              createEdgeElement(i,j, true);
            } else {
              // For visual clarity, we may draw faint edges for inactive? skip
            }
          }
        }
        // redraw node groups to top
        const groups = Array.from(svg.querySelectorAll('.node-group'));
        groups.forEach(g => svg.appendChild(g));
      }

      function createEdgeElement(i,j, active){
        const ni = nodes[i];
        const nj = nodes[j];
        if(!ni || !nj) return;
        // path from ni to nj, curved slightly
        const dx = nj.x - ni.x;
        const dy = nj.y - ni.y;
        const dist = Math.sqrt(dx*dx+dy*dy);
        const offset = Math.min(40, dist*0.2);
        // perpendicular
        const nx = -dy/dist;
        const ny = dx/dist;
        // control point
        const cx = (ni.x + nj.x)/2 + nx*offset;
        const cy = (ni.y + nj.y)/2 + ny*offset;
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        const d = `M ${ni.x} ${ni.y} Q ${cx} ${cy} ${nj.x} ${nj.y}`;
        path.setAttribute('d', d);
        path.setAttribute('class','edge active');
        path.setAttribute('data-from', i);
        path.setAttribute('data-to', j);
        path.setAttribute('fill','none');
        // arrow marker if directed
        path.setAttribute('marker-end', directedToggle.checked ? 'url(#arrow)' : '');
        svg.appendChild(path);

        // animate stroke dash
        path.style.strokeDasharray = '0 200';
        window.requestAnimationFrame(()=>{
          path.style.transition = 'stroke-dasharray 360ms ease, opacity 260ms ease';
          path.style.strokeDasharray = '180 200';
        });

        // click toggles
        path.addEventListener('click', (ev)=>{
          ev.stopPropagation();
          const si = parseInt(path.getAttribute('data-from'));
          const sj = parseInt(path.getAttribute('data-to'));
          toggleEdge(si,sj);
          pulseNode(si);
          pulseNode(sj);
        });

        // hover highlight matrix
        path.addEventListener('pointerover', (ev)=>{
          highlightMatrixCell(i,j);
          showTooltipAt(ev.clientX, ev.clientY, `Edge ${nodes[i].label} → ${nodes[j].label}`);
        });
        path.addEventListener('pointerout', (ev)=>{
          clearMatrixHighlight();
          hideTooltip();
        });

        return path;
      }

      function rebuildMatrix(){
        // Build HTML table from adj and nodes
        const n = nodes.length;
        // create table
        const table = document.createElement('table');
        table.className = 'matrix';
        const thead = document.createElement('thead');
        const trh = document.createElement('tr');
        const topLeft = document.createElement('th');
        topLeft.textContent = '';
        trh.appendChild(topLeft);
        nodes.forEach((nd, j)=>{
          const th = document.createElement('th');
          th.textContent = nd.label;
          trh.appendChild(th);
        });
        thead.appendChild(trh);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        for(let i=0;i<n;i++){
          const tr = document.createElement('tr');
          const rowLabel = document.createElement('th');
          rowLabel.textContent = nodes[i].label;
          tr.appendChild(rowLabel);
          for(let j=0;j<n;j++){
            const td = document.createElement('td');
            const btn = document.createElement('button');
            btn.className = 'cell-button';
            btn.setAttribute('aria-pressed', (adj[i] && adj[i][j]) ? 'true' : 'false');
            btn.setAttribute('data-i', i);
            btn.setAttribute('data-j', j);
            btn.setAttribute('title', `(${nodes[i].label}, ${nodes[j].label})`);
            btn.textContent = (adj[i] && adj[i][j]) ? '1' : '0';
            btn.tabIndex = 0;

            btn.addEventListener('click', (ev)=>{
              ev.preventDefault();
              ev.stopPropagation();
              const ii = parseInt(btn.getAttribute('data-i'));
              const jj = parseInt(btn.getAttribute('data-j'));
              toggleEdge(ii,jj);
              pulseNode(ii);
              pulseNode(jj);
            });
            btn.addEventListener('focus', (ev)=>{
              const ii = parseInt(btn.getAttribute('data-i'));
              const jj = parseInt(btn.getAttribute('data-j'));
              highlightGraphEdge(ii,jj);
            });
            btn.addEventListener('blur', (ev)=>{
              clearGraphHighlight();
            });
            btn.addEventListener('pointerover', (ev)=>{
              const ii = parseInt(btn.getAttribute('data-i'));
              const jj = parseInt(btn.getAttribute('data-j'));
              highlightGraphEdge(ii,jj);
              showTooltipAt(ev.clientX, ev.clientY, `Cell [${nodes[ii].label},${nodes[jj].label}] = ${adj[ii] ? adj[ii][jj] : 0}`);
              highlightTableRowCol(ii,jj);
            });
            btn.addEventListener('pointerout', (ev)=>{
              clearGraphHighlight();
              hideTooltip();
              clearTableRowColHighlight();
            });

            td.appendChild(btn);
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        matrixContainer.innerHTML = '';
        matrixContainer.appendChild(table);

        // redraw edges to ensure markers updated
        redrawAllEdges();
      }

      // Node events
      function onNodePointerDown(ev){
        ev.stopPropagation();
        const g = ev.currentTarget;
        const id = parseInt(g.getAttribute('data-id'));
        // start drag
        dragging = {id, startX: ev.clientX, startY: ev.clientY, origX: nodes.find(n=>n.id===id).x, origY: nodes.find(n=>n.id===id).y};
        g.setPointerCapture(ev.pointerId);
      }

      function onNodePointerUp(ev){
        const g = ev.currentTarget;
        try{ g.releasePointerCapture(ev.pointerId); } catch(e){}
        dragging = null;
      }

      function onNodePointerOver(ev){
        const g = ev.currentTarget;
        const id = parseInt(g.getAttribute('data-id'));
        showTooltipAt(ev.clientX, ev.clientY, 'Node ' + nodes.find(n=>n.id===id).label);
      }
      function onNodePointerOut(ev){
        hideTooltip();
      }

      function onNodeClick(ev){
        ev.stopPropagation();
        const g = ev.currentTarget;
        const id = parseInt(g.getAttribute('data-id'));
        // find index of node in nodes array
        const idx = nodes.findIndex(n=>n.id===id);
        if(selectedNode === null){
          selectedNode = idx;
          highlightNode(idx, true);
        } else {
          // create or toggle edge selectedNode -> idx
          const src = selectedNode;
          const dst = idx;
          // if user held shift, create directed regardless
          const forceDirected = ev.shiftKey;
          if(forceDirected){
            directedToggle.checked = true;
          }
          toggleEdge(src,dst);
          highlightNode(src, false);
          selectedNode = null;
        }
      }

      // global pointermove to handle dragging
      window.addEventListener('pointermove', (ev)=>{
        if(!dragging) return;
        const dx = ev.clientX - dragging.startX;
        const dy = ev.clientY - dragging.startY;
        const node = nodes.find(n=>n.id===dragging.id);
        node.x = dragging.origX + dx * (WIDTH / canvasWrap.clientWidth);
        node.y = dragging.origY + dy * (HEIGHT / canvasWrap.clientHeight);
        // clamp
        node.x = Math.max(NODE_R+8, Math.min(WIDTH-NODE_R-8, node.x));
        node.y = Math.max(NODE_R+8, Math.min(HEIGHT-NODE_R-8, node.y));
        // update group transform
        const g = svg.querySelector('.node-group[data-id="'+dragging.id+'"]');
        if(g) g.setAttribute('transform', `translate(${node.x},${node.y})`);
        // also adjust edges in real time
        redrawAllEdges();
      });

      // click on empty canvas clears selectedNode
      svg.addEventListener('click', (ev)=>{
        selectedNode = null;
        clearMatrixHighlight();
      });

      // Buttons
      addBtn.addEventListener('click', ()=>{
        addNodeAuto();
      });

      delBtn.addEventListener('click', ()=>{
        // delete last node for simplicity or selectedGraphNode if any
        if(nodes.length===0) return;
        // delete last
        removeNode(nodes[nodes.length-1].id);
      });

      clearBtn.addEventListener('click', ()=>{
        resetState();
      });

      randomBtn.addEventListener('click', ()=>{
        // create between 3 and 7 nodes with random edges
        resetState();
        const count = 3 + Math.floor(Math.random()*5);
        for(let i=0;i<count;i++){
          addNodeAuto();
        }
        // add random edges
        for(let i=0;i<nodes.length;i++){
          for(let j=0;j<nodes.length;j++){
            if(i===j) continue;
            if(Math.random() < 0.35) adj[i][j] = 1;
          }
        }
        // if undirected, symmetrize
        if(!directedToggle.checked){
          for(let i=0;i<nodes.length;i++){
            for(let j=i+1;j<nodes.length;j++){
              const v = adj[i][j] || adj[j][i];
              adj[i][j] = adj[j][i] = v?1:0;
            }
          }
        }
        rebuildMatrix();
      });

      directedToggle.addEventListener('change', ()=>{
        // if toggling off (becoming undirected), symmetrize the matrix
        if(!directedToggle.checked){
          // make symmetric: if either i,j is 1, set both to 1
          for(let i=0;i<nodes.length;i++){
            for(let j=i+1;j<nodes.length;j++){
              const v = (adj[i][j]||adj[j][i])?1:0;
              adj[i][j] = adj[j][i] = v;
            }
          }
          rebuildMatrix();
        } else {
          // directed mode: just redraw to show arrowheads
          redrawAllEdges();
        }
      });

      // Utility: highlight matrix cell when hovering edge
      function highlightMatrixCell(i,j){
        const table = matrixContainer.querySelector('table');
        if(!table) return;
        const row = table.tBodies[0].rows[i];
        if(!row) return;
        const cell = row.cells[j+1]; // +1 because first is header
        if(cell){
          const btn = cell.firstChild;
          if(btn) btn.style.background = 'rgba(126,231,135,0.12)';
        }
      }
      function clearMatrixHighlight(){
        const table = matrixContainer.querySelector('table');
        if(!table) return;
        const buttons = table.querySelectorAll('.cell-button');
        buttons.forEach(b => b.style.background = '');
      }

      function highlightNode(idx, on){
        const g = svg.querySelectorAll('.node-group')[idx];
        if(g){
          const circle = g.querySelector('circle');
          if(circle){
            circle.setAttribute('stroke', on ? '#7ee787' : '#0b1220');
            circle.setAttribute('stroke-width', on ? '2.4' : '1.2');
          }
        }
      }

      function pulseNode(idx){
        const g = svg.querySelectorAll('.node-group')[idx];
        if(!g) return;
        const circle = g.querySelector('circle');
        if(!circle) return;
        circle.animate([
          { transform: 'scale(1)' },
          { transform: 'scale(1.18)' },
          { transform: 'scale(1)' }
        ], { duration: 360, easing: 'cubic-bezier(.2,.9,.3,1)'});
      }

      // Highlight a graph edge path corresponding to matrix cell
      function highlightGraphEdge(i,j){
        // find path with data-from i, data-to j
        const edges = svg.querySelectorAll(`.edge`);
        edges.forEach(e => {
          const fi = parseInt(e.getAttribute('data-from'));
          const fj = parseInt(e.getAttribute('data-to'));
          if(fi===i && fj===j){
            e.classList.add('highlight');
            // spotlight
            e.style.opacity = 1;
          } else {
            e.classList.remove('highlight');
          }
        });
      }
      function clearGraphHighlight(){
        const edges = svg.querySelectorAll(`.edge`);
        edges.forEach(e => {
          e.classList.remove('highlight');
          e.style.opacity = '';
        });
      }

      // Table row/col highlight on hover
      function highlightTableRowCol(i,j){
        const table = matrixContainer.querySelector('table');
        if(!table) return;
        // row
        const row = table.tBodies[0].rows[i];
        if(row){
          row.style.background = 'linear-gradient(90deg, rgba(96,165,250,0.02), rgba(126,231,135,0.02))';
        }
        // col
        const headerCells = table.tHead.rows[0].cells;
        for(let r=0;r<table.tBodies[0].rows.length;r++){
          const cell = table.tBodies[0].rows[r].cells[j+1];
          if(cell) cell.style.background = 'rgba(96,165,250,0.03)';
        }
      }
      function clearTableRowColHighlight(){
        const table = matrixContainer.querySelector('table');
        if(!table) return;
        table.tBodies[0].rows.forEach(r => r.style.background = '');
        const cells = table.querySelectorAll('td');
        cells.forEach(c => c.firstChild && (c.firstChild.style.background=''));
      }

      // tooltip
      function showTooltipAt(x,y,txt){
        tooltip.style.display = 'block';
        tooltip.textContent = txt;
        // position relative to canvas container
        const rect = canvasWrap.getBoundingClientRect();
        const cx = Math.min(rect.right-24, Math.max(rect.left+24, x));
        tooltip.style.left = (cx - rect.left) + 'px';
        tooltip.style.top = (y - rect.top) + 'px';
      }
      function hideTooltip(){
        tooltip.style.display = 'none';
      }

      // Initialize with small sample
      resetState();
      for(let i=0;i<4;i++) addNodeAuto();
      adj[0][1] = 1;
      adj[1][2] = 1;
      adj[2][3] = 1;
      adj[3][0] = 1;
      // if undirected initial? leave directed off by default
      rebuildMatrix();

      // Accessibility: keyboard toggling for matrix cells handled via button click already

      // Prevent double tap zoom on mobile interfering with pointer events
      document.addEventListener('touchstart', function(){}, {passive:true});
    })();
  </script>
</body>
</html>