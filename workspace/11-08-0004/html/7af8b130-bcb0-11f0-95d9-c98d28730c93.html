<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Linked List Module</title>
  <style>
    :root{
      --safe-pad: 24px;
      --gap: 16px;
      --node-w: 120px;
      --node-h: 64px;
      --accent: #0b84ff;
      --muted: #6b7280;
      --bg: #f7fafc;
      --card: #ffffff;
      --danger: #ef4444;
      --success: #10b981;
      --shadow: 0 6px 18px rgba(11, 20, 40, 0.06);
    }

    html,body{
      height:100%;
      margin:0;
      padding:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#f6fbff 0%, #fbfcff 100%);
      color:#0f172a;
    }

    /* safe area margins: 24px */
    .app {
      padding: var(--safe-pad);
      box-sizing: border-box;
      min-height: 100%;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    header {
      display:flex;
      flex-direction:column;
      gap:8px;
      max-width:1200px;
      margin: 0 auto;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing: -0.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:14px;
    }

    main {
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      width:100%;
      max-width:1200px;
      margin:0 auto;
    }

    /* Left column: description */
    .info {
      flex: 0 0 360px;
      min-width:280px;
      background: var(--card);
      border-radius:12px;
      padding:16px;
      box-shadow: var(--shadow);
      line-height:1.45;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .section-title{
      font-weight:600;
      font-size:13px;
      color:#0f172a;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
    }
    .small {
      font-size:13px;
    }
    .code-like {
      background:#f3f4f6;
      padding:8px;
      border-radius:8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
      overflow:auto;
    }

    /* Right column: interactive canvas */
    .module {
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .controls {
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
      background:var(--card);
      padding:12px;
      border-radius:12px;
      box-shadow:var(--shadow);
    }
    .controls > * { min-width:0; }
    .form-group {
      display:flex;
      gap:8px;
      align-items:center;
    }
    label{
      font-weight:600;
      font-size:13px;
      color:#0f172a;
    }
    input[type="text"]{
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #e6edf3;
      width:160px;
      font-size:14px;
      outline:none;
    }
    input[type="text"]:focus{
      box-shadow:0 0 0 4px rgba(11,132,255,0.08);
      border-color:var(--accent);
    }

    .btn {
      padding:10px 12px;
      border-radius:8px;
      border: none;
      background:var(--accent);
      color:white;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      transition:transform .12s ease, box-shadow .12s ease;
    }
    .btn:active{ transform:translateY(1px); }
    .btn.secondary {
      background: #eef2ff;
      color: #1f2937;
      border:1px solid #e6e9f8;
      font-weight:600;
    }
    .btn.warn {
      background: var(--danger);
      color: white;
    }
    .btn.ghost {
      background: transparent;
      border: 1px dashed #e6edf3;
      color: #0f172a;
    }

    .status {
      margin-left:auto;
      font-size:13px;
      color:var(--muted);
    }

    /* canvas area */
    .canvas-wrap {
      position:relative;
      background: linear-gradient(180deg, #ffffff 0%, #fbfdff 100%);
      border-radius:12px;
      box-shadow:var(--shadow);
      padding: var(--gap);
      min-height: 320px;
      overflow: hidden;
    }

    .list-area {
      padding: var(--gap);
      border-radius:8px;
      background: linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);
      display:flex;
      gap:32px; /* visual space between nodes - > min spacing is 16px */
      align-items:center;
      overflow:auto;
      min-height: var(--node-h);
      scroll-behavior: smooth;
    }

    .node {
      min-width: var(--node-w);
      height: var(--node-h);
      border-radius:10px;
      background: linear-gradient(180deg,#ffffff 0%, #f8fbff 100%);
      border:1px solid #e6edf3;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      box-shadow: 0 6px 12px rgba(11,20,40,0.04);
      transition: transform .28s cubic-bezier(.2,.9,.2,1), opacity .22s ease;
      user-select:none;
      cursor:pointer;
    }

    .node.selected {
      box-shadow: 0 8px 24px rgba(11,132,255,0.12);
      transform: translateY(-6px) scale(1.02);
      border-color: rgba(11,132,255,0.22);
    }

    .node .value {
      font-size:18px;
      font-weight:700;
      color:#0f172a;
    }

    .node .addr {
      position:absolute;
      bottom:6px;
      right:8px;
      font-size:11px;
      color:var(--muted);
      background: rgba(15,23,42,0.04);
      padding:4px 6px;
      border-radius:6px;
    }

    .head-label {
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      color:var(--muted);
      margin-right:12px;
      min-width:80px;
      justify-content:flex-end;
    }

    .pointer {
      width:18px;
      height:18px;
      border-radius:50%;
      background:var(--accent);
      box-shadow:0 6px 18px rgba(11,132,255,0.18);
      position:absolute;
      transform: translate(-50%,-140%);
      transition: transform .45s cubic-bezier(.2,.9,.2,1), opacity .2s ease;
      display:flex;
      align-items:center;
      justify-content:center;
      color:white;
      font-size:11px;
      font-weight:700;
      pointer-events:none;
    }

    .live-readout {
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:12px;
      align-items:center;
    }
    .readout-chip {
      background:#f3f4f6;
      padding:8px 10px;
      border-radius:10px;
      font-weight:700;
      color:#0f172a;
    }

    /* svg overlay for arrows */
    .svg-overlay {
      position:absolute;
      left:0;
      top:0;
      width:100%;
      height:100%;
      pointer-events:none;
      overflow:visible;
    }

    /* small screens: stack */
    @media (max-width:880px){
      main { flex-direction:column; }
      .info{ order:2; }
      .module{ order:1; }
      .controls{ flex-direction:column; align-items:stretch; }
      .list-area { padding:16px; gap:20px; }
    }

  </style>
</head>
<body>
  <div class="app" role="application" aria-labelledby="title">
    <header>
      <h1 id="title">Linked List — interactive exploration</h1>
      <p class="subtitle">A focused, hands-on module to learn a singly linked list: structure, insertion, deletion, and traversal with animated visual feedback.</p>
    </header>

    <main>
      <aside class="info" aria-label="Module description">
        <div>
          <div class="section-title">Concept Title</div>
          <div class="muted small">Singly Linked List — nodes and next pointers</div>
        </div>

        <div>
          <div class="section-title">Learning Objective</div>
          <div class="small muted">
            After interacting with this module you will be able to:
            <ul style="margin:8px 0 0 18px;padding:0;color:#374151">
              <li>Visualize nodes and how 'next' pointers link them.</li>
              <li>Perform insertions at head/tail and after a chosen node.</li>
              <li>Delete a node and observe pointer updates.</li>
              <li>Step through traversal and watch a pointer follow links.</li>
            </ul>
          </div>
        </div>

        <div>
          <div class="section-title">Interaction Design</div>
          <div class="small muted">
            - Click nodes to select them (used for "Insert After" and "Delete").<br>
            - Type a value and click an operation button to mutate the list.<br>
            - "Traverse" animates a pointer moving node to node, highlighting each step.<br>
            - Visual feedback: nodes animate on insert/delete; arrows redraw smoothly; pointer travels along links.<br>
            - Live status (screen-reader friendly) announces each operation.
          </div>
        </div>

        <div>
          <div class="section-title">Layout Description</div>
          <div class="small muted">
            - Left column: this information panel (fixed width) explains the module.<br>
            - Right column: control bar on top, canvas below with the list visualization.<br>
            - Safe area margins: 24px on all sides. Minimum spacing between interactive elements: 16px.<br>
            - Responsive: columns stack on small screens; the list area scrolls horizontally when long.<br>
            - Accessibility: semantic controls, focus styles, and a live region for dynamic announcements.
          </div>
        </div>

        <div>
          <div class="section-title">Quick Tips</div>
          <div class="muted small">
            - To insert after a node: click the target node to select it (blue lift), enter a value, then "Insert After".<br>
            - Selected node is used for delete and insert-after operations.
          </div>
        </div>
      </aside>

      <section class="module" aria-label="Interactive linked list module">
        <div class="controls" role="toolbar" aria-label="List controls">
          <div class="form-group">
            <label for="valueInput">Value</label>
            <input id="valueInput" type="text" inputmode="text" aria-label="Value to insert" placeholder="e.g. 42" />
          </div>

          <button id="insertHeadBtn" class="btn" title="Insert at head">Insert Head</button>
          <button id="insertTailBtn" class="btn secondary" title="Insert at tail">Insert Tail</button>
          <button id="insertAfterBtn" class="btn" title="Insert after selected node">Insert After</button>
          <button id="deleteBtn" class="btn warn" title="Delete selected node">Delete Node</button>

          <button id="traverseBtn" class="btn ghost" title="Traverse the list">Traverse</button>
          <button id="resetBtn" class="btn secondary" title="Clear the list">Reset</button>

          <div class="status" id="statusText" aria-live="polite">Ready</div>
        </div>

        <div class="canvas-wrap" id="canvas" aria-hidden="false">
          <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px;">
            <div class="head-label" aria-hidden="true">
              <strong>Head:</strong>
              <span id="headIndicator" style="color:var(--accent);font-weight:700">—</span>
            </div>

            <div class="live-readout" aria-hidden="true">
              <div class="readout-chip" id="nodeCount">0 nodes</div>
              <div id="traverseStep" style="color:var(--muted)">Traversal: idle</div>
            </div>
          </div>

          <div style="position:relative;min-height:140px;">
            <svg class="svg-overlay" id="arrowSvg" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <defs>
                <marker id="arrowhead" viewBox="0 0 6 6" refX="6" refY="3" markerWidth="6" markerHeight="6" orient="auto">
                  <path d="M0,0 L6,3 L0,6 z" fill="#0b84ff"></path>
                </marker>
              </defs>
              <!-- dynamic paths are inserted here -->
            </svg>

            <div style="display:flex;align-items:center;gap:8px;">
              <div class="list-area" id="listArea" role="list" aria-label="Linked list visual">
                <!-- nodes inserted here -->
              </div>

              <!-- moving pointer (animated during traversal) -->
              <div class="pointer" id="pointer" style="opacity:0" aria-hidden="true">P</div>
            </div>
          </div>

          <!-- visually-hidden live region for screen readers -->
          <div id="liveRegion" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;" aria-live="polite" aria-atomic="true"></div>
        </div>
      </section>
    </main>
  </div>

  <script>
    /* Linked List Interactive Module (vanilla JS)
       - Maintains a simple array to represent node order.
       - Renders node elements in .list-area and draws arrows between them using SVG.
       - Supports insertion at head, tail, after selected node, deletion, traversal animation.
       - Accessible status updates via #liveRegion and #statusText.
    */

    (function () {
      // DOM references
      const valueInput = document.getElementById('valueInput');
      const insertHeadBtn = document.getElementById('insertHeadBtn');
      const insertTailBtn = document.getElementById('insertTailBtn');
      const insertAfterBtn = document.getElementById('insertAfterBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const traverseBtn = document.getElementById('traverseBtn');
      const resetBtn = document.getElementById('resetBtn');

      const listArea = document.getElementById('listArea');
      const arrowSvg = document.getElementById('arrowSvg');
      const pointer = document.getElementById('pointer');
      const headIndicator = document.getElementById('headIndicator');
      const nodeCount = document.getElementById('nodeCount');
      const traverseStep = document.getElementById('traverseStep');
      const statusText = document.getElementById('statusText');
      const liveRegion = document.getElementById('liveRegion');

      // state
      let nodes = []; // array of {id, value, el}
      let selectedId = null;
      let idCounter = 1;
      let traversing = false;

      // utility: announce status
      function announce(text, polite = true) {
        statusText.textContent = text;
        liveRegion.textContent = text;
      }

      // update head indicator and node count
      function refreshInfo() {
        headIndicator.textContent = nodes.length ? nodes[0].value : '—';
        nodeCount.textContent = nodes.length + (nodes.length === 1 ? ' node' : ' nodes');
      }

      // create a DOM node element and attach events
      function createNodeElement(nodeObj) {
        const el = document.createElement('div');
        el.className = 'node';
        el.setAttribute('role','listitem');
        el.tabIndex = 0;
        el.dataset.id = nodeObj.id;

        const val = document.createElement('div');
        val.className = 'value';
        val.textContent = nodeObj.value;
        el.appendChild(val);

        const addr = document.createElement('div');
        addr.className = 'addr';
        addr.textContent = `id:${nodeObj.id}`;
        el.appendChild(addr);

        // click to select
        function selectHandler(e) {
          if (traversing) return; // disable during traversal
          const did = nodeObj.id;
          if (selectedId === did) {
            selectedId = null;
            el.classList.remove('selected');
            announce('Selection cleared');
          } else {
            // clear previous
            const prev = listArea.querySelector('.node.selected');
            if (prev) prev.classList.remove('selected');
            selectedId = did;
            el.classList.add('selected');
            announce('Selected node ' + nodeObj.value);
          }
        }

        el.addEventListener('click', selectHandler);
        el.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            selectHandler();
          }
        });

        nodeObj.el = el;
        return el;
      }

      // render nodes in the list area
      function renderList() {
        // clear current
        listArea.innerHTML = '';
        // add head spacer (label area occupies outside, nodes align left)
        nodes.forEach(n => {
          listArea.appendChild(n.el);
        });
        refreshArrows();
        refreshInfo();
      }

      // compute positions and draw arrows between consecutive nodes
      function refreshArrows() {
        // clear old arrows
        while (arrowSvg.lastChild) {
          arrowSvg.removeChild(arrowSvg.lastChild);
        }
        // re-add defs marker
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = '<marker id="arrowhead" viewBox="0 0 6 6" refX="6" refY="3" markerWidth="6" markerHeight="6" orient="auto"><path d="M0,0 L6,3 L0,6 z" fill="#0b84ff"></path></marker>';
        arrowSvg.appendChild(defs);

        if (nodes.length < 2) return;

        // for each pair, draw a curved path from right edge of node i to left edge of node i+1
        for (let i = 0; i < nodes.length - 1; i++) {
          const a = nodes[i].el;
          const b = nodes[i+1].el;
          const aRect = a.getBoundingClientRect();
          const bRect = b.getBoundingClientRect();
          const svgRect = arrowSvg.getBoundingClientRect();

          // compute coordinates relative to svg
          const startX = aRect.right - svgRect.left - 8;
          const startY = aRect.top + aRect.height/2 - svgRect.top;
          const endX = bRect.left - svgRect.left + 8;
          const endY = bRect.top + bRect.height/2 - svgRect.top;

          // create a smooth cubic bezier path
          const dx = Math.max(20, (endX - startX) / 2);
          const pathD = `M ${startX} ${startY} C ${startX + dx} ${startY} ${endX - dx} ${endY} ${endX} ${endY}`;

          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', pathD);
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke', '#0b84ff');
          path.setAttribute('stroke-width', '2');
          path.setAttribute('stroke-opacity', '0.9');
          path.setAttribute('marker-end', 'url(#arrowhead)');
          path.style.transition = 'd 300ms ease';
          arrowSvg.appendChild(path);
        }
      }

      // animate insertion: slide from above and fade in
      function animateInsert(nodeObj, positionIndex) {
        const el = nodeObj.el;
        el.style.opacity = '0';
        el.style.transform = 'translateY(-18px) scale(.98)';
        // insert DOM at correct index
        if (positionIndex >= listArea.children.length) {
          listArea.appendChild(el);
        } else {
          listArea.insertBefore(el, listArea.children[positionIndex]);
        }
        // allow layout then transition
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            el.style.transition = 'transform .34s cubic-bezier(.2,.9,.2,1), opacity .26s ease';
            el.style.opacity = '1';
            el.style.transform = 'translateY(0) scale(1)';
            // after animation, refresh arrows
            setTimeout(() => {
              refreshArrows();
              refreshInfo();
            }, 320);
          });
        });
      }

      // animate deletion: fade & shrink, then remove
      function animateDelete(nodeObj) {
        const el = nodeObj.el;
        el.style.transition = 'transform .28s ease, opacity .22s ease';
        el.style.opacity = '0';
        el.style.transform = 'translateY(8px) scale(.96)';
        setTimeout(() => {
          if (el && el.parentElement === listArea) {
            listArea.removeChild(el);
            refreshArrows();
            refreshInfo();
          }
        }, 260);
      }

      // helper: find node index by id
      function indexOfId(id) {
        return nodes.findIndex(n => n.id === id);
      }

      // insert functions
      function insertHead(value) {
        const node = { id: idCounter++, value: String(value) };
        node.el = createNodeElement(node);
        nodes.unshift(node);
        animateInsert(node, 0);
        announce('Inserted ' + node.value + ' at head');
        // clear selection
        clearSelection();
        setTimeout(() => scrollIntoView(node.el), 200);
      }

      function insertTail(value) {
        const node = { id: idCounter++, value: String(value) };
        node.el = createNodeElement(node);
        const pos = nodes.length;
        nodes.push(node);
        animateInsert(node, pos);
        announce('Inserted ' + node.value + ' at tail');
        clearSelection();
        setTimeout(() => scrollIntoView(node.el), 200);
      }

      function insertAfter(value, afterId) {
        const idx = indexOfId(afterId);
        if (idx === -1) {
          announce('No node selected to insert after', true);
          return;
        }
        const node = { id: idCounter++, value: String(value) };
        node.el = createNodeElement(node);
        nodes.splice(idx+1, 0, node);
        animateInsert(node, idx+1);
        announce('Inserted ' + node.value + ' after node ' + nodes[idx].value);
        clearSelection();
        setTimeout(() => scrollIntoView(node.el), 200);
      }

      function deleteNode(id) {
        const idx = indexOfId(id);
        if (idx === -1) {
          announce('No node selected to delete', true);
          return;
        }
        const node = nodes[idx];
        nodes.splice(idx, 1);
        animateDelete(node);
        announce('Deleted node ' + node.value);
        selectedId = null;
        setTimeout(() => refreshInfo(), 300);
      }

      // clear any node selection visually and logically
      function clearSelection() {
        selectedId = null;
        const prev = listArea.querySelector('.node.selected');
        if (prev) prev.classList.remove('selected');
      }

      // scroll an element into view inside listArea's scroll
      function scrollIntoView(el) {
        if (!el) return;
        el.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
      }

      // traversal animation: move pointer along paths and highlight nodes
      async function traverseList() {
        if (traversing) return;
        if (nodes.length === 0) {
          announce('List is empty. Nothing to traverse.');
          return;
        }
        traversing = true;
        announce('Starting traversal');
        traverseStep.textContent = 'Traversal: 0 / ' + nodes.length;
        pointer.style.opacity = '1';
        pointer.style.transition = 'transform 450ms cubic-bezier(.2,.9,.2,1), opacity .2s ease';

        // helper to position pointer above a node (center)
        function positionPointerAt(el) {
          const svgRect = arrowSvg.getBoundingClientRect();
          const rect = el.getBoundingClientRect();
          // compute center relative to the canvas container
          const x = rect.left + rect.width/2 - svgRect.left;
          const y = rect.top - svgRect.top; // top of node
          // place pointer slightly above node center
          const px = x;
          const py = y; // we use transform translate from pointer center
          // move pointer element to (px, py) relative to svg container
          pointer.style.transform = `translate(${px}px, ${py}px) translate(-50%, -140%)`;
        }

        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          // highlight node
          node.el.classList.add('selected');
          positionPointerAt(node.el);
          traverseStep.textContent = `Traversal: ${i+1} / ${nodes.length}`;
          announce('Visiting node ' + node.value);
          // small pulse animation on node
          node.el.style.transition = 'box-shadow .26s ease, transform .26s ease';
          node.el.style.transform = 'translateY(-6px)';
          await delay(650);
          // reset highlight
          node.el.style.transform = 'translateY(0)';
          node.el.classList.remove('selected');
        }

        pointer.style.opacity = '0';
        traverseStep.textContent = 'Traversal: complete';
        announce('Traversal complete');
        traversing = false;
      }

      // small promise-based delay
      function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      // event handlers for controls
      insertHeadBtn.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (v === '') { announce('Please enter a value to insert'); return; }
        insertHead(v);
        valueInput.value = '';
      });

      insertTailBtn.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (v === '') { announce('Please enter a value to insert'); return; }
        insertTail(v);
        valueInput.value = '';
      });

      insertAfterBtn.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (v === '') { announce('Please enter a value to insert'); return; }
        if (!selectedId) { announce('Select a node to insert after'); return; }
        insertAfter(v, selectedId);
        valueInput.value = '';
      });

      deleteBtn.addEventListener('click', () => {
        if (!selectedId) { announce('Select a node to delete'); return; }
        deleteNode(selectedId);
      });

      traverseBtn.addEventListener('click', () => {
        traverseList();
      });

      resetBtn.addEventListener('click', () => {
        // clear nodes with animation
        if (nodes.length === 0) { announce('List already empty'); return; }
        nodes.forEach(n => {
          if (n.el && n.el.parentElement === listArea) {
            n.el.style.transition = 'transform .28s ease, opacity .22s ease';
            n.el.style.opacity = '0';
            n.el.style.transform = 'translateY(12px) scale(.96)';
          }
        });
        setTimeout(() => {
          nodes = [];
          selectedId = null;
          idCounter = 1;
          listArea.innerHTML = '';
          arrowSvg.innerHTML = ''; // clears all arrows
          // reinsert defs for marker so future arrows work
          const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          defs.innerHTML = '<marker id="arrowhead" viewBox="0 0 6 6" refX="6" refY="3" markerWidth="6" markerHeight="6" orient="auto"><path d="M0,0 L6,3 L0,6 z" fill="#0b84ff"></path></marker>';
          arrowSvg.appendChild(defs);
          refreshInfo();
          announce('List reset');
        }, 260);
      });

      // keep arrows updated on resize / scroll / layout changes
      let resizeObserver = new ResizeObserver(() => {
        refreshArrows();
      });
      resizeObserver.observe(listArea);
      window.addEventListener('resize', () => refreshArrows());
      // also update arrows after images/fonts/layout settle
      window.addEventListener('load', () => refreshArrows());

      // keyboard accessibility: Enter on value input triggers Insert Head
      valueInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          insertHeadBtn.click();
        }
      });

      // initial demo: create a small list
      function seedDemo() {
        insertTail('A');
        setTimeout(() => insertTail('B'), 250);
        setTimeout(() => insertTail('C'), 500);
        setTimeout(() => announce('Demo list created: A -> B -> C'), 800);
      }
      seedDemo();

      // expose some functions to console for debugging
      window._ll = {
        nodes,
        renderList,
        refreshArrows
      };

    })();
  </script>
</body>
</html>