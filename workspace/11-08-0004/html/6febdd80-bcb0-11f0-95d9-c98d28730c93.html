<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive: Longest Common Subsequence (LCS)</title>
  <style>
    :root{
      --safe-pad: 24px;
      --gap: 16px;
      --panel-bg: #fafafa;
      --accent: #2563eb;
      --accent-2: #10b981;
      --muted: #6b7280;
      --cell-size: 44px;
      --cell-font: 16px;
      --shadow: 0 6px 18px rgba(16,24,40,0.06);
    }
    /* Safe margins */
    html,body{height:100%;}
    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      color: #111827;
      background: linear-gradient(180deg,#ffffff 0%, #f7fbff 100%);
      padding: var(--safe-pad);
      box-sizing: border-box;
      -webkit-font-smoothing:antialiased;
    }

    /* Layout */
    .module{
      display:flex;
      gap: var(--gap);
      align-items: flex-start;
      min-height: 60vh;
    }
    .panel{
      background: var(--panel-bg);
      border-radius: 12px;
      padding: 20px;
      box-shadow: var(--shadow);
    }

    .left{
      width: 360px;
      min-width: 280px;
      display:flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .right{
      flex:1;
      display:flex;
      flex-direction: column;
      gap: var(--gap);
    }

    h1{
      margin:0;
      font-size: 20px;
      letter-spacing: -0.2px;
    }
    .sub{
      color: var(--muted);
      font-size: 13px;
      margin-top:4px;
    }

    /* Info boxes */
    .info{
      font-size: 14px;
      color:#0f172a;
      line-height:1.4;
    }
    .card{
      padding:14px;
      border-radius:10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.2));
      border: 1px solid rgba(15,23,42,0.04);
    }

    /* Form */
    label{display:block;font-weight:600;font-size:13px;margin-bottom:8px}
    input[type="text"]{
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #e6e9ee;
      font-size:15px;
      box-sizing:border-box;
    }
    .controls{
      display:flex;
      gap: var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    button{
      background: linear-gradient(180deg,var(--accent), #1e40af);
      color:white;
      border: none;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      box-shadow: 0 6px 14px rgba(37,99,235,0.12);
    }
    button.secondary{
      background: white;
      color: var(--accent);
      border:1px solid rgba(37,99,235,0.12);
      box-shadow:none;
    }
    .small{
      padding:8px 10px;
      font-size:13px;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
    }

    /* Matrix area */
    .matrix-wrap{
      overflow:auto;
      padding:12px;
      border-radius:10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(250,250,255,0.6));
      border: 1px solid rgba(15,23,42,0.04);
    }
    .grid{
      display:grid;
      gap:6px;
      align-items:center;
      justify-items:center;
      padding:10px;
    }

    .grid .cell{
      width: var(--cell-size);
      height: var(--cell-size);
      min-width: var(--cell-size);
      min-height: var(--cell-size);
      background: white;
      border-radius:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      color:#0f172a;
      box-shadow: 0 2px 6px rgba(2,6,23,0.04);
      border:1px solid rgba(2,6,23,0.06);
      position:relative;
      transition: transform 220ms cubic-bezier(.2,.9,.2,1), background 220ms, box-shadow 200ms;
      font-size: var(--cell-font);
      user-select:none;
    }

    .grid .cell.char{
      background: transparent;
      border: none;
      font-weight:700;
      color: #374151;
      font-size: 16px;
      box-shadow:none;
    }

    .grid .cell.header{
      background: transparent;
      border:none;
      font-weight:600;
      color: #111827;
    }

    .grid .cell.zero{
      color: var(--muted);
      font-weight:600;
    }

    .cell .dir{
      position:absolute;
      bottom:4px;
      right:6px;
      font-size:12px;
      color: rgba(15,23,42,0.5);
    }

    .cell.match{
      background: linear-gradient(180deg, rgba(16,185,129,0.12), rgba(16,185,129,0.06));
      border: 1px solid rgba(16,185,129,0.18);
      color:#065f46;
    }
    .cell.active{
      transform: translateY(-6px) scale(1.02);
      box-shadow: 0 10px 26px rgba(2,6,23,0.12);
    }

    .cell.computed{
      background: linear-gradient(180deg, rgba(37,99,235,0.08), rgba(37,99,235,0.04));
      border:1px solid rgba(37,99,235,0.12);
    }

    .cell.path{
      background: linear-gradient(90deg, rgba(37,99,235,0.12), rgba(16,185,129,0.08));
      border:1px solid rgba(16,185,129,0.18);
      color:#042a2b;
      transform: translateY(-4px);
    }

    /* characters row/col styling */
    .strings{
      display:flex;
      gap: var(--gap);
      align-items:center;
      justify-content: space-between;
    }
    .strings .row{
      font-size:15px;
      color:#0f172a;
      font-weight:600;
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .strings .char{
      width: var(--cell-size);
      height: var(--cell-size);
      border-radius:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      background: #fff;
      border:1px solid rgba(2,6,23,0.06);
      box-shadow: 0 2px 6px rgba(2,6,23,0.04);
      font-weight:700;
    }

    /* Explanation area */
    .explain{
      font-size:14px;
      line-height:1.45;
      color:#111827;
    }
    .line{
      margin:0 0 8px 0;
    }

    /* Speed slider */
    input[type="range"]{
      width:160px;
    }

    /* Responsive */
    @media (max-width: 920px){
      .module{flex-direction:column;}
      .left{width:100%;}
      .right{width:100%;}
    }

    /* Tooltip for cell detail */
    .tooltip{
      position: absolute;
      background: #111827;
      color: white;
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      transform: translate(-50%, -120%);
      white-space:nowrap;
      box-shadow: 0 8px 26px rgba(2,6,23,0.18);
      z-index:50;
      pointer-events:none;
      opacity:0;
      transition: opacity 160ms, transform 160ms;
    }
    .tooltip.show{
      opacity:1;
      transform: translate(-50%, -140%);
    }

    /* footer small */
    .meta{
      font-size:13px;
      color:var(--muted);
    }

    /* keyboard focus */
    button:focus, input:focus, .cell:focus{
      outline:3px solid rgba(37,99,235,0.12);
      outline-offset:2px;
    }
  </style>
</head>
<body>
  <div class="module" role="region" aria-label="Interactive Longest Common Subsequence module">
    <div class="panel left" aria-hidden="false">
      <div>
        <h1>Longest Common Subsequence</h1>
        <div class="sub">Hands-on DP visualization with step-through computation and backtracking.</div>
      </div>

      <div class="card info" aria-labelledby="objective">
        <div id="objective" style="font-weight:700;margin-bottom:8px">Learning Objective</div>
        <div class="info">
          After interacting with this module you will:
          <ul style="margin:8px 0 0 18px;padding:0;">
            <li>Understand how the dynamic programming table for LCS is filled.</li>
            <li>See why matches follow diagonal transitions and mismatches choose the larger neighbor.</li>
            <li>Watch backtracking to construct an LCS and identify which characters contribute to it.</li>
          </ul>
        </div>
      </div>

      <div class="card">
        <div style="font-weight:700;margin-bottom:8px">Interaction Design</div>
        <div class="info">
          - Type or pick example strings (max 20 chars).<br>
          - Click "Compute" to animate filling the DP table row-by-row.<br>
          - Use Play / Pause / Step to control the animation speed.<br>
          - Click any computed cell to see how its value was derived (shows top, left, diag).<br>
          - Click "Show LCS" to animate backtracking and highlight the subsequence characters.
          <div style="margin-top:8px;" class="muted">Keyboard: Tab between controls. Use Step button for keyboard-driven exploration.</div>
        </div>
      </div>

      <div class="card">
        <div style="font-weight:700;margin-bottom:8px">Layout Description</div>
        <div class="info">
          - Left column (this panel): controls, explanations and examples.<br>
          - Right column: interactive DP matrix and live explanation area.<br>
          - Safe area margins: 24px (applied to body). Minimum spacing: 16px between interactive elements.<br>
          - Responsive: columns stack on narrow screens; interactive elements remain keyboard-accessible.
        </div>
      </div>

      <div class="card" aria-label="Controls">
        <label for="aInput">String A (vertical)</label>
        <input id="aInput" type="text" maxlength="20" value="AGGTAB" aria-describedby="aDesc" />
        <div id="aDesc" class="muted" style="margin-top:6px">Characters shown down the left of the grid.</div>

        <div style="height:12px"></div>

        <label for="bInput">String B (horizontal)</label>
        <input id="bInput" type="text" maxlength="20" value="GXTXAYB" aria-describedby="bDesc" />
        <div id="bDesc" class="muted" style="margin-top:6px">Characters shown across the top of the grid.</div>

        <div style="height:12px"></div>

        <div class="controls" style="margin-top:6px">
          <button id="computeBtn" class="small" title="Compute table (animated)">Compute</button>
          <button id="stepBtn" class="secondary small" title="Step one cell">Step</button>
          <button id="playBtn" class="small" title="Play/pause animation">Play</button>
          <button id="resetBtn" class="secondary small" title="Reset grid">Reset</button>
        </div>

        <div style="height:12px"></div>

        <div class="controls" aria-hidden="false">
          <button id="showPathBtn" class="small" title="Animate backtracking and show LCS">Show LCS</button>
          <button id="explainBtn" class="secondary small" title="Toggle cell explanation tooltip">Toggle cell explain</button>
          <div style="flex:1"></div>
          <label class="muted" for="speed">Speed</label>
          <input id="speed" type="range" min="50" max="900" value="260" aria-label="Animation speed" />
        </div>

        <div style="height:10px"></div>

        <div class="muted" style="font-size:13px">Examples:
          <select id="examples" aria-label="Choose example inputs" style="margin-left:8px;padding:6px 8px;border-radius:6px;border:1px solid #e6e9ee;">
            <option value="AGGTAB|GXTXAYB">AGGTAB / GXTXAYB</option>
            <option value="ABCBDAB|BDCAB">ABCBDAB / BDCAB</option>
            <option value="XMJYAUZ|MZJAWXU">XMJYAUZ / MZJAWXU</option>
            <option value="ABCDEF|FBDAMN">ABCDEF / FBDAMN</option>
          </select>
        </div>

      </div>

      <div class="card meta">
        Tip: Matches add 1 to the diagonal; otherwise a cell takes max(top,left). Click a cell to inspect.
      </div>

    </div>

    <div class="panel right" aria-live="polite">
      <div style="display:flex;gap:12px;align-items:flex-start;justify-content:space-between;">
        <div>
          <div style="font-weight:700">DP Matrix</div>
          <div class="muted" style="font-size:13px">Grid cells show LCS length for prefixes. Arrows indicate chosen direction.</div>
        </div>
        <div style="display:flex;gap:12px;align-items:center;">
          <div class="muted">Current LCS length: <span id="lcsLen">0</span></div>
        </div>
      </div>

      <div class="matrix-wrap" id="matrixWrap" tabindex="0" aria-label="Dynamic programming matrix area">
        <!-- Grid will be injected here -->
        <div id="grid" class="grid" role="grid" aria-hidden="false"></div>
      </div>

      <div class="card explain" id="explainArea" role="region" aria-live="polite">
        <div style="font-weight:700;margin-bottom:6px">Step Explanation</div>
        <div id="stepText" class="line">Press Compute to start animating the table fill. Use Step for fine control.</div>
        <div id="lcsText" class="line" style="margin-top:8px;font-weight:700"></div>
      </div>

    </div>
  </div>

  <!-- Tooltip element -->
  <div id="tooltip" class="tooltip" role="status" aria-hidden="true">Tooltip</div>

  <script>
    (function(){
      // References
      const aInput = document.getElementById('aInput');
      const bInput = document.getElementById('bInput');
      const computeBtn = document.getElementById('computeBtn');
      const playBtn = document.getElementById('playBtn');
      const stepBtn = document.getElementById('stepBtn');
      const resetBtn = document.getElementById('resetBtn');
      const showPathBtn = document.getElementById('showPathBtn');
      const explainBtn = document.getElementById('explainBtn');
      const gridEl = document.getElementById('grid');
      const stepText = document.getElementById('stepText');
      const lcsText = document.getElementById('lcsText');
      const lcsLenEl = document.getElementById('lcsLen');
      const speedInput = document.getElementById('speed');
      const examples = document.getElementById('examples');
      const tooltip = document.getElementById('tooltip');
      const matrixWrap = document.getElementById('matrixWrap');

      // State
      let A = [];
      let B = [];
      let m = 0, n = 0;
      let dp = [];    // (m+1)x(n+1) numbers
      let dir = [];   // direction: 0 none, 1 diag(match), 2 up, 3 left
      let computed = false;
      let animating = false;
      let autoPlay = false;
      let showCellExplain = true;
      let speed = Number(speedInput.value);
      let computeQueue = [];
      let currentStepIndex = 0;
      let backtrackPath = [];
      let limitChars = 20;

      // Utility
      function clamp(v,a,b){return Math.max(a, Math.min(b,v));}

      function resetState(){
        computed = false;
        animating = false;
        autoPlay = false;
        computeQueue = [];
        currentStepIndex = 0;
        backtrackPath = [];
        lcsText.textContent = '';
        lcsLenEl.textContent = '0';
        stepText.textContent = 'Ready. Edit strings, then click Compute.';
        clearTooltip();
      }

      // Build grid
      function buildGrid(){
        gridEl.innerHTML = '';
        A = (aInput.value || '').split('');
        B = (bInput.value || '').split('');
        if (A.length > limitChars) A = A.slice(0,limitChars), aInput.value = A.join('');
        if (B.length > limitChars) B = B.slice(0,limitChars), bInput.value = B.join('');
        m = A.length;
        n = B.length;

        // Create CSS grid columns
        gridEl.style.gridTemplateColumns = `repeat(${n+1+1}, ${getComputedStyle(document.documentElement).getPropertyValue('--cell-size') || '44px'})`;
        // We'll create (m+1+1) rows implicitly by placing elements.

        // Add top-left empty corner
        addCell('', 'header', -1, -1);

        // Top header characters (B)
        for (let j=0;j<n;j++){
          addCell(B[j] || '', 'char header', -1, j);
        }

        // For each row: char header then cells
        for (let i=0;i<m;i++){
          addCell(A[i] || '', 'char header', i, -1); // left char
          for (let j=0;j<n;j++){
            addCell('', 'cell zero', i, j); // dp cell placeholders
          }
        }

        // initialize dp and dir
        dp = Array.from({length:m+1}, ()=>Array(n+1).fill(0));
        dir = Array.from({length:m+1}, ()=>Array(n+1).fill(0));
        computed = false;
      }

      function addCell(text, classes, i, j){
        const el = document.createElement('div');
        el.className = classes;
        el.tabIndex = (classes.includes('cell') ? 0 : -1);
        el.setAttribute('data-i', i);
        el.setAttribute('data-j', j);
        el.setAttribute('role','gridcell');
        el.setAttribute('aria-label', `cell ${i+1},${j+1}`);
        el.innerHTML = text ? escapeHtml(text) : '';
        gridEl.appendChild(el);

        if (classes.includes('cell')){
          el.addEventListener('click', onCellClick);
          el.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter' || e.key === ' '){
              e.preventDefault();
              onCellClick.call(el,e);
            }
          });
          el.addEventListener('mouseenter', onCellHover);
          el.addEventListener('mouseleave', clearTooltip);
        }
      }

      function getCellEl(i,j){
        return gridEl.querySelector(`.cell[data-i="${i}"][data-j="${j}"]`);
      }

      function onCellClick(e){
        if (!computed){
          stepText.textContent = 'Cell details appear after the table has been computed.';
          return;
        }
        const el = e.currentTarget || this;
        const i = Number(el.getAttribute('data-i'));
        const j = Number(el.getAttribute('data-j'));
        showCellDetail(i+1,j+1); // show detail for dp index (1-based)
      }

      function onCellHover(e){
        if (!showCellExplain) return;
        const el = e.currentTarget || this;
        const i = Number(el.getAttribute('data-i'));
        const j = Number(el.getAttribute('data-j'));
        if (!computed) return;
        showCellHover(i,j,el);
      }

      function showCellHover(i,j,el){
        // dp indices are i+1, j+1
        const top = dp[i][j+1];
        const left = dp[i+1][j];
        const diag = dp[i][j];
        const text = `diag(${diag}) ${i>0&&j>0?'+1 if match':''} • top ${top} • left ${left}`;
        showTooltipAt(text, el);
      }

      function showCellDetail(i1,j1){
        // i1,j1 are dp indexes (1..m,1..n) relative to prefixes
        const i = i1-1; // 0..m-1 for characters
        const j = j1-1;
        // compute indexes in dp
        const diag = dp[i][j];
        const top = dp[i][j+1];
        const left = dp[i+1][j];
        const chA = A[i] || '';
        const chB = B[j] || '';
        const match = (chA === chB);
        const explanation = match ?
          `A[${i+1}]='${chA}' matches B[${j+1}]='${chB}'. So value = diag + 1 = ${diag} + 1 = ${dp[i+1][j+1]}` :
          `No match. Choose max(top, left) = max(${top}, ${left}) = ${dp[i+1][j+1]}. Direction: ${dirText(dir[i+1][j+1])}.`;
        stepText.textContent = explanation;
      }

      function dirText(d){
        if(d===1) return 'diagonal (match)';
        if(d===2) return 'up (from A prefix)';
        if(d===3) return 'left (from B prefix)';
        return 'none';
      }

      // Tooltip positioning
      function showTooltipAt(text, targetEl){
        tooltip.textContent = text;
        tooltip.classList.add('show');
        tooltip.setAttribute('aria-hidden','false');
        const rect = targetEl.getBoundingClientRect();
        const wrapRect = matrixWrap.getBoundingClientRect();
        tooltip.style.left = (rect.left + rect.width/2 - wrapRect.left) + 'px';
        tooltip.style.top = (rect.top - wrapRect.top) + 'px';
      }
      function clearTooltip(){
        tooltip.classList.remove('show');
        tooltip.setAttribute('aria-hidden','true');
      }

      // Compute queue for animated fill
      function planComputation(){
        computeQueue = [];
        for (let i=1;i<=m;i++){
          for (let j=1;j<=n;j++){
            computeQueue.push({i,j});
          }
        }
        currentStepIndex = 0;
      }

      function computeNextStep(){
        if (currentStepIndex >= computeQueue.length){
          finishComputation();
          return false;
        }
        const {i,j} = computeQueue[currentStepIndex];
        currentStepIndex++;
        computeCell(i,j);
        return true;
      }

      function computeCell(i,j){
        // compute dp[i][j] based on A[i-1], B[j-1]
        const aCh = A[i-1];
        const bCh = B[j-1];
        const el = getCellEl(i-1,j-1);
        // highlight
        highlightCell(el);
        setTimeout(()=> {
          // compute values
          const top = dp[i-1][j];
          const left = dp[i][j-1];
          const diagv = dp[i-1][j-1];
          if (aCh === bCh){
            dp[i][j] = diagv + 1;
            dir[i][j] = 1;
            markCellMatch(el, dp[i][j]);
            stepText.textContent = `Match at A[${i}]='${aCh}',B[${j}]='${bCh}'. Set dp[${i}][${j}] = dp[${i-1}][${j-1}] + 1 = ${diagv} + 1 = ${dp[i][j]}.`;
          } else {
            if (top >= left){
              dp[i][j] = top;
              dir[i][j] = 2;
            } else {
              dp[i][j] = left;
              dir[i][j] = 3;
            }
            markCellComputed(el, dp[i][j], dir[i][j]);
            stepText.textContent = `No match at A[${i}]='${aCh}',B[${j}]='${bCh}'. Set dp[${i}][${j}] = max(dp[${i-1}][${j}]=${top}, dp[${i}][${j-1}]=${left}) = ${dp[i][j]}.`;
          }
          lcsLenEl.textContent = dp[m][n];
          // small delay before unhighlight
          setTimeout(()=>unhighlightCell(el), clamp(speed/4,40,220));
        }, clamp(speed/3,60,600));
      }

      function highlightCell(el){
        el.classList.add('active');
      }
      function unhighlightCell(el){
        el.classList.remove('active');
      }
      function markCellMatch(el, value){
        el.textContent = value;
        el.classList.remove('zero');
        el.classList.add('match','computed');
        addDirectionMark(el, '↖');
      }
      function markCellComputed(el, value, d){
        el.textContent = value;
        el.classList.remove('zero');
        el.classList.add('computed');
        addDirectionMark(el, d===1?'↖':d===2?'↑':'←');
      }
      function addDirectionMark(el, ch){
        let dirEl = el.querySelector('.dir');
        if (!dirEl){
          dirEl = document.createElement('div');
          dirEl.className = 'dir';
          el.appendChild(dirEl);
        }
        dirEl.textContent = ch;
      }

      function finishComputation(){
        computed = true;
        animating = false;
        autoPlay = false;
        stepText.textContent = `Computation complete. LCS length = ${dp[m][n]}. Click "Show LCS" to backtrack. Click a cell to inspect.`;
        lcsLenEl.textContent = dp[m][n];
      }

      // Animation loop
      let animTimer = null;
      function startAutoPlay(){
        if (animating) return;
        animating = true;
        autoPlay = true;
        playBtn.textContent = 'Pause';
        runAnimLoop();
      }
      function pauseAutoPlay(){
        animating = false;
        autoPlay = false;
        playBtn.textContent = 'Play';
        if (animTimer) {
          clearTimeout(animTimer);
          animTimer = null;
        }
      }

      function runAnimLoop(){
        if (!animating) return;
        const next = computeNextStep();
        if (!next){
          pauseAutoPlay();
          finishComputation();
          return;
        }
        // schedule next based on speed
        animTimer = setTimeout(runAnimLoop, speed);
      }

      // Backtracking
      function planBacktrack(){
        backtrackPath = [];
        let i = m, j = n;
        while (i>0 && j>0){
          backtrackPath.push({i,j});
          if (dir[i][j] === 1){ // match diag
            i--; j--;
          } else if (dir[i][j] === 2){
            i--;
          } else {
            j--;
          }
        }
        // reverse to get path from start to end
        backtrackPath = backtrackPath.reverse();
      }

      function animateBacktrack(){
        if (!computed){
          stepText.textContent = 'Compute the table before backtracking.';
          return;
        }
        planBacktrack();
        if (backtrackPath.length === 0){
          lcsText.textContent = 'LCS: (empty)';
          return;
        }
        // build LCS by following matches where dir==1
        let lcsChars = [];
        let idx = 0;
        function stepPath(){
          if (idx >= backtrackPath.length){
            lcsText.textContent = 'LCS: ' + lcsChars.join('');
            stepText.textContent = 'Backtracking complete.';
            return;
          }
          const {i,j} = backtrackPath[idx];
          const el = getCellEl(i-1,j-1);
          el.classList.add('path');
          el.classList.remove('computed');
          // highlight matching characters in strings if direction is diag (match)
          if (dir[i][j] === 1){
            lcsChars.push(A[i-1]);
            // flash the character boxes in headers
            flashHeaderChar('top', j-1);
            flashHeaderChar('left', i-1);
          }
          idx++;
          setTimeout(stepPath, speed/1.2);
        }
        lcsText.textContent = 'LCS: ...';
        stepText.textContent = 'Animating backtracking...';
        stepPath();
      }

      function flashHeaderChar(where, idx){
        // where 'top' refers to B (top row), 'left' to A (left column)
        // top: find header cell with data-i = -1 and data-j = idx
        const sel = where === 'top' ? `.header[data-i="-1"][data-j="${idx}"]` : `.header[data-i="${idx}"][data-j="-1"]`;
        const el = gridEl.querySelector(sel);
        if (!el) return;
        el.classList.add('active');
        setTimeout(()=>el.classList.remove('active'), speed/2);
      }

      // Controls event handlers
      computeBtn.addEventListener('click', ()=>{
        // build grid first
        resetHighlights();
        buildGrid();
        planComputation();
        computed = false;
        currentStepIndex = 0;
        // start auto-play
        startAutoPlay();
      });

      playBtn.addEventListener('click', ()=>{
        if (!computed && currentStepIndex === 0){
          // if not started, trigger compute
          computeBtn.click();
          return;
        }
        if (autoPlay){
          pauseAutoPlay();
        } else {
          startAutoPlay();
        }
      });

      stepBtn.addEventListener('click', ()=>{
        if (!computed && currentStepIndex === 0){
          // initialize grid if not already
          resetHighlights();
          buildGrid();
          planComputation();
        }
        const has = computeNextStep();
        if (!has){
          finishComputation();
        }
      });

      resetBtn.addEventListener('click', ()=>{
        resetHighlights();
        buildGrid();
        resetState();
      });

      showPathBtn.addEventListener('click', ()=>{
        if (!computed){
          stepText.textContent = 'Please compute the table first (Compute).';
          return;
        }
        // clear any previous path highlights
        clearPathHighlights();
        animateBacktrack();
      });

      explainBtn.addEventListener('click', ()=>{
        showCellExplain = !showCellExplain;
        explainBtn.textContent = showCellExplain ? 'Hide explain' : 'Show explain';
      });

      speedInput.addEventListener('input', ()=>{
        speed = Number(speedInput.value);
      });

      examples.addEventListener('change', ()=>{
        const val = examples.value.split('|');
        aInput.value = val[0];
        bInput.value = val[1];
      });

      // Helpers
      function resetHighlights(){
        // clear grid cells entirely
        const all = gridEl.querySelectorAll('.cell');
        all.forEach(c=>{
          c.className = 'cell zero';
          c.textContent = '0';
          const d = c.querySelector('.dir');
          if (d) d.remove();
        });
      }

      function clearPathHighlights(){
        gridEl.querySelectorAll('.cell.path').forEach(c=>c.classList.remove('path'));
        // restore computed class
        gridEl.querySelectorAll('.cell').forEach(c=>{
          if (c.textContent && c.textContent !== '0') c.classList.add('computed');
        });
      }

      // Small initial build
      buildGrid();
      resetState();

      // Accessibility: keyboard support for Play via space on focused playBtn
      playBtn.addEventListener('keydown', (e)=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); playBtn.click(); }});

      // Escape to clear tooltip
      document.addEventListener('keydown', (e)=>{
        if (e.key === 'Escape') clearTooltip();
      });

      // Utility: escape html
      function escapeHtml(s){
        return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      }

      // Expose some debug (not necessary)
      window._lcsModule = {
        buildGrid, resetState
      };
    })();
  </script>
</body>
</html>