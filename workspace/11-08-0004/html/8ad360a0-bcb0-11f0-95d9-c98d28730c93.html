<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Union-Find (Disjoint Set) — Interactive Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-margin: 24px;
      --gap: 16px; /* minimum spacing */
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #2dd4bf;
      --muted: #94a3b8;
      --danger: #fb7185;
      --glass: rgba(255,255,255,0.03);
      --card: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    }
    html,body {
      height: 100%;
      margin: 0;
      padding: var(--safe-margin);
      font-family: Inter, Roboto, system-ui, -apple-system, "Segoe UI", "Helvetica Neue", Arial;
      background: radial-gradient(1000px 400px at 10% 10%, rgba(45,212,191,0.06), transparent),
                  radial-gradient(800px 300px at 90% 90%, rgba(99,102,241,0.04), transparent),
                  var(--bg);
      color: #e6eef8;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      box-sizing: border-box;
    }
    * { box-sizing: inherit; }
    h1,h2,h3 { margin: 0 0 8px 0; }
    p { margin: 0 0 12px 0; color: var(--muted); line-height: 1.4; }

    /* Layout: two-column / single-column responsive */
    .container {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: var(--gap);
      align-items: start;
      min-height: calc(100vh - calc(var(--safe-margin) * 2));
    }
    @media (max-width: 880px) {
      .container {
        grid-template-columns: 1fr;
      }
    }

    /* Left panel: Title and controls */
    .panel {
      background: var(--panel);
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
      min-width: 0;
    }
    .title {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .logo {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg,var(--accent),#6366f1);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      color: #021022;
      font-size: 20px;
      box-shadow: 0 4px 12px rgba(2,6,23,0.6);
    }
    .meta { margin-top: 12px; }

    .controls {
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }
    label { font-size: 13px; color: var(--muted); }
    input[type="number"], select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      background: var(--glass);
      color: #e6eef8;
      border: 1px solid rgba(255,255,255,0.04);
      outline: none;
    }
    .btn-row {
      display: flex;
      gap: var(--gap);
      flex-wrap: wrap;
    }
    button {
      padding: 10px 12px;
      border-radius: 8px;
      border: none;
      background: linear-gradient(180deg,#1f2937,#111827);
      color: #e6eef8;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease, opacity 120ms;
      box-shadow: 0 6px 14px rgba(2,6,23,0.6);
      min-height: 44px;
      min-width: 0;
    }
    button.primary {
      background: linear-gradient(180deg,var(--accent),#06b6d4);
      color: #021022;
      font-weight: 600;
    }
    button:active { transform: translateY(1px) scale(0.998); }
    button.icon {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .small {
      font-size: 13px;
      padding: 8px 10px;
      min-height: 40px;
    }

    .toggles {
      display:flex;
      gap: var(--gap);
      flex-wrap: wrap;
    }
    .toggle {
      display:flex;
      align-items:center;
      gap:8px;
      background: rgba(255,255,255,0.02);
      padding:8px 10px;
      border-radius:8px;
    }
    .toggle input[type="checkbox"] { transform: scale(1.15); }

    /* Right panel: visualization */
    .visual {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 18px;
      min-height: 300px;
      display:flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .canvas-wrap {
      background: rgba(255,255,255,0.01);
      border-radius: 10px;
      padding: 14px;
      display:flex;
      gap: var(--gap);
      align-items: stretch;
      min-height: 340px;
    }

    /* SVG area and info area */
    .svg-area {
      flex: 1 1 0%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      min-width: 0;
    }
    svg { width:100%; height:100%; max-height:560px; border-radius:8px; overflow:visible; }

    .info-area {
      width: 320px;
      min-width: 220px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      padding-left: 8px;
    }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
      border-radius: 10px;
      padding: 12px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
      color: var(--muted);
      font-size: 13px;
    }

    /* nodes and lines */
    .node {
      cursor: pointer;
      transition: transform 220ms cubic-bezier(.2,.8,.2,1), fill 200ms;
      transform-origin: center;
    }
    .node:hover { transform: translateY(-6px); }
    .node .label {
      fill: #e6eef8;
      font-size: 13px;
      font-weight: 600;
      pointer-events: none;
    }
    .edge {
      stroke: rgba(255,255,255,0.12);
      stroke-width: 2.2;
      transition: stroke 220ms, stroke-width 220ms, opacity 220ms;
      vector-effect: non-scaling-stroke;
    }
    .edge.highlight {
      stroke: rgba(45,212,191,0.95);
      stroke-width: 3.2;
      opacity: 1;
    }
    .pulse {
      animation: pulse 1100ms ease-in-out infinite;
    }
    @keyframes pulse {
      0% { filter: drop-shadow(0 0 0 rgba(45,212,191,0.18)); }
      50% { filter: drop-shadow(0 0 12px rgba(45,212,191,0.18)); transform: translateY(-2px); }
      100% { filter: drop-shadow(0 0 0 rgba(45,212,191,0.18)); }
    }

    /* array view */
    .table {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      align-items: center;
      font-size: 13px;
    }
    .row { display:flex; gap:8px; align-items:center; }
    .chip {
      background: rgba(255,255,255,0.02);
      padding:6px 8px;
      border-radius:8px;
      min-width:36px;
      text-align:center;
    }

    /* footer small */
    .muted {
      color: var(--muted);
      font-size: 13px;
    }

    /* spacing enforcement (ensures 16px between interactive elements) */
    .controls > * { margin-bottom: 0 !important; }

    /* accessibility focus */
    button:focus, input:focus, select:focus {
      outline: 2px solid rgba(45,212,191,0.25);
      outline-offset: 2px;
    }

    /* small helpers */
    .kbd {
      background: rgba(255,255,255,0.03);
      border-radius:6px;
      padding:6px 8px;
      font-weight:600;
      color: var(--muted);
      font-size:12px;
    }
  </style>
</head>
<body>
  <div class="container" role="main">
    <aside class="panel" aria-label="Module controls and description">
      <div class="title">
        <div class="logo" aria-hidden="true">UF</div>
        <div>
          <h1 style="font-size:18px">Union-Find (Disjoint Set)</h1>
          <div class="muted">Interactive visualization of find, union, and path compression</div>
        </div>
      </div>

      <div class="meta">
        <h3 style="font-size:14px">Learning Objective</h3>
        <p>
          After interacting with this module you will be able to:
          understand how Union-Find keeps track of components, perform
          union and find operations, and visualize path compression and union-by-size.
        </p>
      </div>

      <div class="controls" aria-hidden="false">
        <div>
          <label for="node-count">Number of nodes</label>
          <input id="node-count" type="number" min="2" max="12" value="8" aria-label="Number of nodes" />
        </div>

        <div class="btn-row">
          <button id="generate" class="primary small" title="Generate nodes">Generate nodes</button>
          <button id="reset" class="small" title="Reset structure">Reset</button>
        </div>

        <div>
          <label>Operation Mode</label>
          <div class="btn-row">
            <button id="select-mode" class="small" title="Select nodes by clicking">Select by Click</button>
            <button id="choose-mode" class="small" title="Choose nodes from dropdowns">Choose from List</button>
          </div>
        </div>

        <div id="selector-area" aria-live="polite">
          <div id="dropdowns" style="display:none;">
            <label for="a-select">Node A</label>
            <select id="a-select" aria-label="Select node A"></select>
            <label for="b-select">Node B</label>
            <select id="b-select" aria-label="Select node B"></select>
            <div class="btn-row" style="margin-top:8px;">
              <button id="union-btn" class="primary small">Union A ∪ B</button>
              <button id="find-btn" class="small">Find A</button>
            </div>
          </div>

          <div id="instructions" style="margin-top:8px;">
            <div class="card">
              <strong>Interaction quick tips</strong>
              <ul style="margin-top:8px; padding-left:16px; color:var(--muted);">
                <li>Click nodes to select (two for union, one for find).</li>
                <li>Use toggles to enable path compression and union-by-size.</li>
                <li>Watch edges and arrays update with animations.</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="toggles" style="margin-top:6px;">
          <label class="toggle" title="Toggle path compression">
            <input id="pc-toggle" type="checkbox" checked aria-label="Enable path compression" />
            <div style="font-size:13px">Path Compression</div>
          </label>
          <label class="toggle" title="Toggle union by size/rank">
            <input id="ub-toggle" type="checkbox" checked aria-label="Enable union by size" />
            <div style="font-size:13px">Union by Size</div>
          </label>
        </div>

        <div style="margin-top:6px;">
          <label>Speed</label>
          <select id="speed" aria-label="Animation speed">
            <option value="600">Slow</option>
            <option value="350" selected>Normal</option>
            <option value="160">Fast</option>
          </select>
        </div>

        <div style="margin-top:6px;">
          <button id="step-btn" class="small">Step-through Mode</button>
        </div>

        <div style="margin-top:12px;" class="card" id="explain">
          <h3 style="font-size:14px">Interaction Design</h3>
          <p style="font-size:13px; color:var(--muted)">
            Click nodes to select two for union or one for find. Visual highlights show the path of parent pointers from node to root.
            When path compression is enabled, find will animate updating parent pointers directly to the root.
            Union-by-size chooses the larger root as the parent — you can see sizes change in the array view.
          </p>
        </div>
        <div style="margin-top:12px;" class="card">
          <h3 style="font-size:14px">Layout Description</h3>
          <p style="font-size:13px; color:var(--muted)">
            Controls on the left (safe margin 24px). Visualization to the right with an SVG canvas and an information panel showing the parent/size arrays.
            Spacing and touch targets follow minimum 16px spacing for clarity and accessibility. Responsive layout stacks vertically on small screens.
          </p>
        </div>

      </div>
    </aside>

    <section class="visual" aria-label="Visualization area">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <h2 style="font-size:16px; margin-bottom:2px;">Structure Visualization</h2>
          <div class="muted">Click nodes (or use dropdowns) to operate. Hover for details.</div>
        </div>
        <div style="display:flex; gap:12px; align-items:center;">
          <div class="muted">Selected:
            <span id="selected-status" style="font-weight:700; margin-left:8px;">None</span>
          </div>
          <div class="kbd" title="Keyboard hint">Esc to clear</div>
        </div>
      </div>

      <div class="canvas-wrap" role="region" aria-label="Union-Find visualization canvas">
        <div class="svg-area" id="svg-area" tabindex="0">
          <!-- SVG is injected by JS -->
          <svg id="svg" viewBox="0 0 1000 520" preserveAspectRatio="xMidYMid meet" aria-hidden="false"></svg>
        </div>

        <aside class="info-area" aria-label="State panels">
          <div class="card" aria-live="polite">
            <h3 style="font-size:14px">Parent & Size Arrays</h3>
            <div style="margin-top:8px;">
              <div style="font-size:13px; color:var(--muted); margin-bottom:6px;">Parent</div>
              <div id="parent-row" class="table" role="table" aria-label="Parent array"></div>
            </div>
            <div style="margin-top:10px;">
              <div style="font-size:13px; color:var(--muted); margin-bottom:6px;">Size</div>
              <div id="size-row" class="table" role="table" aria-label="Size array"></div>
            </div>
          </div>

          <div class="card">
            <h3 style="font-size:14px">Console</h3>
            <div id="console" style="font-size:13px; color:var(--muted); min-height:72px; margin-top:8px; max-height:160px; overflow:auto;"></div>
          </div>

          <div class="card muted">
            <div><strong>Accessibility</strong></div>
            <div style="margin-top:6px;">All buttons and inputs are keyboard accessible. SVG nodes are clickable and focusable.</div>
          </div>
        </aside>
      </div>
    </section>
  </div>

  <script>
    /****************************************************************
     * Union-Find Interactive Module (vanilla JS)
     * - Supports: generate nodes, select/click nodes, union, find
     * - Visualizes parent pointers (edges) and arrays
     * - Animates highlights and path compression
     ****************************************************************/

    (function () {
      // Constants and DOM references
      const svg = document.getElementById('svg');
      const generateBtn = document.getElementById('generate');
      const resetBtn = document.getElementById('reset');
      const nodeCountInput = document.getElementById('node-count');
      const pcToggle = document.getElementById('pc-toggle');
      const ubToggle = document.getElementById('ub-toggle');
      const speedSelect = document.getElementById('speed');
      const selectModeBtn = document.getElementById('select-mode');
      const chooseModeBtn = document.getElementById('choose-mode');
      const dropdowns = document.getElementById('dropdowns');
      const aSelect = document.getElementById('a-select');
      const bSelect = document.getElementById('b-select');
      const unionBtn = document.getElementById('union-btn');
      const findBtn = document.getElementById('find-btn');
      const selectedStatus = document.getElementById('selected-status');
      const parentRow = document.getElementById('parent-row');
      const sizeRow = document.getElementById('size-row');
      const consoleBox = document.getElementById('console');
      const stepBtn = document.getElementById('step-btn');
      const svgArea = document.getElementById('svg-area');

      // State
      let N = parseInt(nodeCountInput.value, 10) || 8;
      let parent = [];
      let size = [];
      let nodePositions = [];
      let nodes = []; // node objects with svg elements
      let edges = []; // edges as svg lines (child -> parent)
      let selected = []; // indices selected for operations
      let selectionMode = 'click'; // or 'dropdown'
      let stepping = false;
      let speed = 350;
      let animTimer = null;

      // Utilities
      function log(msg) {
        const line = document.createElement('div');
        line.textContent = msg;
        consoleBox.appendChild(line);
        consoleBox.scrollTop = consoleBox.scrollHeight;
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      // Union-Find model functions
      function ufInit(n) {
        N = n;
        parent = new Array(N);
        size = new Array(N);
        for (let i = 0; i < N; i++) {
          parent[i] = i;
          size[i] = 1;
        }
      }

      function ufFind(i, trace = false) {
        // Return root and optionally the trace path from i to root
        const path = [];
        let x = i;
        while (parent[x] !== x) {
          path.push(x);
          x = parent[x];
        }
        path.push(x);
        if (trace) return { root: x, path };
        return x;
      }

      function ufUnion(a, b) {
        a = ufFind(a);
        b = ufFind(b);
        if (a === b) return false;
        // union by size if enabled
        if (ubToggle.checked) {
          if (size[a] < size[b]) {
            parent[a] = b;
            size[b] += size[a];
          } else {
            parent[b] = a;
            size[a] += size[b];
          }
        } else {
          parent[b] = a;
          size[a] += size[b];
        }
        return true;
      }

      // Visualization creation and updates
      function clearSVG() {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        nodes = [];
        edges = [];
      }

      function layoutPositions(n) {
        nodePositions = [];
        // Place nodes on a gentle curve to avoid line overlaps
        const w = 960;
        const h = 400;
        const margin = 60;
        for (let i = 0; i < n; i++) {
          const t = i / (Math.max(1, n - 1));
          const x = margin + t * (w - margin * 2);
          const y = h / 2 + Math.sin(t * Math.PI * 1.2) * 36;
          nodePositions.push({ x, y });
        }
      }

      function makeSVG(tag, attrs = {}) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        for (const k in attrs) el.setAttribute(k, attrs[k]);
        return el;
      }

      function render() {
        clearSVG();
        svg.setAttribute('viewBox', '0 0 1000 520');
        layoutPositions(N);

        // Draw edges (child -> parent) first for z-order
        for (let i = 0; i < N; i++) {
          const g = makeSVG('g');
          const line = makeSVG('path', {
            d: edgePathD(i, parent[i]),
            class: 'edge',
            'data-child': i,
            'data-parent': parent[i],
            stroke: 'rgba(255,255,255,0.12)',
            fill: 'none'
          });
          g.appendChild(line);
          svg.appendChild(g);
          edges[i] = line;
        }

        // Draw nodes
        for (let i = 0; i < N; i++) {
          const pos = nodePositions[i];
          const nodeG = makeSVG('g', { class: 'node', tabindex: 0, role: 'button', 'aria-label': 'Node ' + i });
          nodeG.style.cursor = 'pointer';
          nodeG.setAttribute('data-index', i);

          const circle = makeSVG('circle', {
            cx: pos.x,
            cy: pos.y,
            r: 22,
            fill: '#081123',
            stroke: 'rgba(255,255,255,0.06)',
            'stroke-width': 1.5
          });
          const ring = makeSVG('circle', {
            cx: pos.x,
            cy: pos.y,
            r: 26,
            fill: 'transparent',
            stroke: 'rgba(255,255,255,0.02)',
            'stroke-width': 1
          });
          const label = makeSVG('text', {
            x: pos.x,
            y: pos.y + 5,
            'text-anchor': 'middle',
            class: 'label'
          });
          label.textContent = i;

          nodeG.appendChild(ring);
          nodeG.appendChild(circle);
          nodeG.appendChild(label);

          svg.appendChild(nodeG);

          // store references
          nodes[i] = { g: nodeG, circle, label, ring };

          // event handlers
          nodeG.addEventListener('click', () => onNodeClick(i));
          nodeG.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              onNodeClick(i);
            }
          });

          // tooltip-like accessible title
          const titleEl = makeSVG('title');
          titleEl.textContent = `Node ${i}`;
          nodeG.appendChild(titleEl);
        }

        updateArrays();
        updateEdgesInstant();
      }

      function edgePathD(childIdx, parentIdx) {
        // path from child to parent: small curved path
        const c = nodePositions[childIdx];
        const p = nodePositions[parentIdx];
        if (!c || !p) return '';
        const midX = (c.x + p.x) / 2;
        const midY = (c.y + p.y) / 2 - 24;
        return `M ${c.x} ${c.y} Q ${midX} ${midY} ${p.x} ${p.y}`;
      }

      function updateEdgesInstant() {
        for (let i = 0; i < N; i++) {
          const line = edges[i];
          if (!line) continue;
          line.setAttribute('d', edgePathD(i, parent[i]));
          line.setAttribute('data-parent', parent[i]);
        }
      }

      function updateArrays(highlightPath = []) {
        // parent array
        parentRow.innerHTML = '';
        sizeRow.innerHTML = '';
        for (let i = 0; i < N; i++) {
          const idx = document.createElement('div');
          idx.className = 'row';
          idx.style.gridColumn = '1 / 2';
          const chip = document.createElement('div');
          chip.className = 'chip';
          chip.textContent = i;
          idx.appendChild(chip);
          parentRow.appendChild(idx);

          const val = document.createElement('div');
          val.className = 'row';
          val.style.gridColumn = '2 / 3';
          const pchip = document.createElement('div');
          pchip.className = 'chip';
          pchip.textContent = parent[i];
          if (highlightPath.includes(i)) {
            pchip.style.background = 'linear-gradient(90deg, rgba(45,212,191,0.12), rgba(99,102,241,0.06))';
            pchip.style.border = '1px solid rgba(45,212,191,0.18)';
            pchip.style.color = '#2dd4bf';
          }
          val.appendChild(pchip);
          parentRow.appendChild(val);

          // size row
          const sIdx = document.createElement('div');
          sIdx.className = 'row';
          sIdx.style.gridColumn = '1 / 2';
          const sChip = document.createElement('div');
          sChip.className = 'chip';
          sChip.textContent = i;
          sizeRow.appendChild(sIdx);
          const sVal = document.createElement('div');
          sVal.className = 'row';
          sVal.style.gridColumn = '2 / 3';
          const sValueChip = document.createElement('div');
          sValueChip.className = 'chip';
          sValueChip.textContent = size[i];
          sVal.appendChild(sValueChip);
          sizeRow.appendChild(sVal);
        }
      }

      // Selection handling
      function clearSelection() {
        selected = [];
        selectedStatus.textContent = 'None';
        nodes.forEach((n) => {
          n.circle.setAttribute('fill', '#081123');
          n.ring.setAttribute('stroke', 'rgba(255,255,255,0.02)');
          n.g.classList.remove('pulse');
        });
      }

      function setSelectedDisplay() {
        if (selected.length === 0) {
          selectedStatus.textContent = 'None';
        } else {
          selectedStatus.textContent = selected.join(' ↔ ');
        }
      }

      function onNodeClick(i) {
        if (selectionMode === 'dropdown') {
          // do nothing in click mode disabled
          return;
        }
        if (selected.length === 0) {
          selected.push(i);
        } else if (selected.length === 1) {
          // allow same index as both (will be handled)
          selected.push(i);
        } else {
          selected = [i];
        }
        // highlight selected
        nodes.forEach((n, idx) => {
          if (selected.includes(idx)) {
            n.circle.setAttribute('fill', '#083237');
            n.ring.setAttribute('stroke', 'rgba(45,212,191,0.3)');
            n.g.classList.add('pulse');
          } else {
            n.circle.setAttribute('fill', '#081123');
            n.ring.setAttribute('stroke', 'rgba(255,255,255,0.02)');
            n.g.classList.remove('pulse');
          }
        });
        setSelectedDisplay();

        // auto-action: if two selected and step mode off, run union
        if (selected.length === 2 && !stepping) {
          handleUnion(selected[0], selected[1]);
        }
      }

      // Dropdown mode management
      function populateDropdowns() {
        aSelect.innerHTML = '';
        bSelect.innerHTML = '';
        for (let i = 0; i < N; i++) {
          const o1 = document.createElement('option');
          o1.value = i;
          o1.textContent = i;
          aSelect.appendChild(o1);
          const o2 = document.createElement('option');
          o2.value = i;
          o2.textContent = i;
          bSelect.appendChild(o2);
        }
      }

      // Animation helpers
      function highlightPathAnimation(path, color = 'rgba(45,212,191,0.95)') {
        // path: array of node indices from node to root
        // highlight nodes and edges along path sequentially
        return new Promise((resolve) => {
          const delay = parseInt(speedSelect.value, 10);
          let i = 0;
          function step() {
            if (i >= path.length - 1) {
              // last highlight the root node
              const root = path[path.length - 1];
              nodes[root].circle.setAttribute('fill', '#06363a');
              nodes[root].g.classList.add('pulse');
              setTimeout(() => resolve(), delay);
              return;
            }
            const cur = path[i];
            const nxt = path[i + 1];
            // highlight node cur and edge cur->parent
            nodes[cur].circle.setAttribute('fill', '#07363a');
            nodes[cur].g.classList.add('pulse');
            const edge = edges[cur];
            if (edge) edge.classList.add('highlight');
            i++;
            setTimeout(step, Math.max(120, delay / 2));
          }
          step();
        });
      }

      function clearHighlights() {
        for (let i = 0; i < N; i++) {
          if (nodes[i]) {
            nodes[i].circle.setAttribute('fill', '#081123');
            nodes[i].g.classList.remove('pulse');
          }
          if (edges[i]) edges[i].classList.remove('highlight');
        }
      }

      function animateEdgeRedirect(childIdx, newParentIdx) {
        // short fade-out, update path, fade-in
        return new Promise((resolve) => {
          const edge = edges[childIdx];
          if (!edge) return resolve();
          edge.style.transition = `opacity ${speedSelect.value}ms ease`;
          edge.style.opacity = '0';
          setTimeout(() => {
            parent[childIdx] = newParentIdx;
            updateEdgesInstant();
            edge.style.opacity = '1';
            setTimeout(() => {
              edge.style.transition = '';
              resolve();
            }, parseInt(speedSelect.value, 10));
          }, Math.max(80, parseInt(speedSelect.value, 10) / 2));
        });
      }

      // Core operations with animations
      async function handleFind(nodeIdx) {
        clearHighlights();
        const { root, path } = ufFind(nodeIdx, true);
        log(`Find(${nodeIdx}) -> root ${root}. Path: [${path.join(', ')}]`);
        updateArrays(path);
        await highlightPathAnimation(path);

        // path compression if enabled
        if (pcToggle.checked && path.length > 2) {
          log(`Applying path compression for nodes: [${path.slice(0, -1).join(', ')}]`);
          // compress every intermediate to point to root one-by-one with animation
          for (let k = 0; k < path.length - 1; k++) {
            const child = path[k];
            await animateEdgeRedirect(child, root);
            updateArrays();
          }
          log('Path compression complete.');
        }

        // final refresh
        updateArrays();
        setTimeout(() => clearHighlights(), 600);
      }

      async function handleUnion(a, b) {
        clearHighlights();
        // show traces
        const ta = ufFind(a, true).path;
        const tb = ufFind(b, true).path;
        log(`Union(${a}, ${b}) — paths to roots: A:[${ta.join(', ')}], B:[${tb.join(', ')}]`);
        updateArrays([...ta, ...tb]);

        // highlight both paths sequentially
        await highlightPathAnimation(ta);
        await highlightPathAnimation(tb);

        const rootA = ta[ta.length - 1];
        const rootB = tb[tb.length - 1];

        if (rootA === rootB) {
          log('They are already connected (same root).');
          setTimeout(() => clearHighlights(), 500);
          return;
        }

        // perform union with animation
        // visually indicate which root will become parent
        let newParent, childRoot;
        if (ubToggle.checked) {
          if (size[rootA] < size[rootB]) {
            newParent = rootB;
            childRoot = rootA;
          } else {
            newParent = rootA;
            childRoot = rootB;
          }
        } else {
          newParent = rootA;
          childRoot = rootB;
        }

        // highlight chosen parent
        nodes[newParent].circle.setAttribute('fill', '#064247');
        nodes[newParent].g.classList.add('pulse');

        // animate redirecting the child's root edge to the new parent
        await animateEdgeRedirect(childRoot, newParent);
        // update sizes
        if (ubToggle.checked) {
          const sBefore = size[newParent];
          size[newParent] += size[childRoot];
          size[childRoot] = 0; // not meaningful after parent updated, but show it
          log(`Union: root ${childRoot} -> ${newParent}. New size(${newParent}) = ${size[newParent]} (was ${sBefore}).`);
        } else {
          size[newParent] += size[childRoot];
          size[childRoot] = 0;
          log(`Union performed. New parent is ${newParent}.`);
        }

        updateEdgesInstant();
        updateArrays();
        setTimeout(() => clearHighlights(), 500);
      }

      // UI wiring
      generateBtn.addEventListener('click', () => {
        const n = clamp(parseInt(nodeCountInput.value, 10) || 8, 2, 12);
        nodeCountInput.value = n;
        startNew(n);
      });

      resetBtn.addEventListener('click', () => {
        ufInit(N);
        render();
        log('Reset structure.');
      });

      selectModeBtn.addEventListener('click', () => {
        selectionMode = 'click';
        selectModeBtn.classList.add('primary');
        chooseModeBtn.classList.remove('primary');
        dropdowns.style.display = 'none';
        clearSelection();
        log('Switched to click selection mode.');
      });

      chooseModeBtn.addEventListener('click', () => {
        selectionMode = 'dropdown';
        chooseModeBtn.classList.add('primary');
        selectModeBtn.classList.remove('primary');
        dropdowns.style.display = '';
        populateDropdowns();
        clearSelection();
        log('Switched to dropdown selection mode.');
      });

      unionBtn.addEventListener('click', () => {
        const a = parseInt(aSelect.value, 10);
        const b = parseInt(bSelect.value, 10);
        handleUnion(a, b);
      });

      findBtn.addEventListener('click', () => {
        const a = parseInt(aSelect.value, 10);
        handleFind(a);
      });

      speedSelect.addEventListener('change', () => {
        log('Animation speed set to ' + speedSelect.value + 'ms steps.');
      });

      pcToggle.addEventListener('change', () => {
        log('Path compression ' + (pcToggle.checked ? 'enabled' : 'disabled'));
      });
      ubToggle.addEventListener('change', () => {
        log('Union by size ' + (ubToggle.checked ? 'enabled' : 'disabled'));
      });

      stepBtn.addEventListener('click', () => {
        stepping = !stepping;
        stepBtn.classList.toggle('primary', stepping);
        stepBtn.textContent = stepping ? 'Step-through Mode (On)' : 'Step-through Mode';
        log('Step-through mode ' + (stepping ? 'enabled' : 'disabled') + '.');
      });

      // Keyboard global clear
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          clearSelection();
        }
      });

      // Dropdowns mirror selection
      aSelect.addEventListener('change', () => {
        const v = parseInt(aSelect.value, 10);
        selected = [v];
        setSelectedDisplay();
      });
      bSelect.addEventListener('change', () => {
        // only update display
        const v = parseInt(aSelect.value, 10);
        const w = parseInt(bSelect.value, 10);
        selected = [v, w];
        setSelectedDisplay();
      });

      // init
      function startNew(n) {
        ufInit(n);
        render();
        populateDropdowns();
        clearSelection();
        consoleBox.innerHTML = '';
        log('Generated ' + n + ' nodes.');
      }

      // initial UI states
      selectModeBtn.classList.add('primary');
      startNew(N);

      // Expose some global debugging if needed
      window._uf = {
        get parent() { return parent.slice(); },
        get size() { return size.slice(); },
        find: (x) => ufFind(x),
        union: (a,b) => ufUnion(a,b),
        render: () => render()
      };

    })();
  </script>
</body>
</html>