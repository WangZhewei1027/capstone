<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Selection Sort Visual Explorer</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa7b2;
      --accent: #3b82f6;
      --sorted: #16a34a;
      --mincolor: #f97316;
      --compare: #f59e0b;
      --bar-bg: #1f2937;
      --bar-front: linear-gradient(180deg,#60a5fa,#1e40af);
      --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071029 0%, #071b2a 50%);
      color: #e6eef6;
      font-family: var(--font-sans);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app {
      padding: var(--safe-margin);
      min-height: 100vh;
      box-sizing: border-box;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    header {
      display:flex;
      flex-direction:column;
      gap: 8px;
      max-width: 1100px;
    }
    h1{
      margin:0;
      font-size: clamp(18px, 2.6vw, 28px);
      letter-spacing: -0.4px;
    }
    p.lead {
      margin:0;
      color: var(--muted);
      font-size: 14px;
      max-width: 1000px;
    }

    /* Controls */
    .controls {
      display:flex;
      flex-wrap:wrap;
      gap: var(--gap);
      align-items:center;
      max-width: 1100px;
    }
    .btn {
      background: linear-gradient(180deg,#0f1724,#12202b);
      color: #e6eef6;
      border: 1px solid rgba(255,255,255,0.06);
      padding: 10px 14px;
      border-radius: 8px;
      cursor: pointer;
      min-width: 72px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      font-size: 14px;
    }
    .btn:focus { outline: 3px solid rgba(59,130,246,0.26); outline-offset:2px; }
    .btn.secondary {
      background: rgba(255,255,255,0.02);
      color: var(--muted);
    }

    .controls-right {
      margin-left:auto;
      display:flex;
      gap: var(--gap);
      align-items:center;
    }
    .control-group {
      display:flex;
      gap:8px;
      align-items:center;
      color: var(--muted);
      font-size:13px;
    }
    input[type="range"]{
      -webkit-appearance: none;
      width: 160px;
      height: 6px;
      background: rgba(255,255,255,0.06);
      border-radius: 6px;
      outline:none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:14px;height:14px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(59,130,246,0.12);
    }

    /* Main area */
    .main {
      display:flex;
      gap: var(--gap);
      max-width: 1100px;
      width: 100%;
      align-items:flex-start;
    }
    .visual {
      flex:1 1 60%;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 16px;
      min-height:220px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .bars {
      display:flex;
      align-items:end;
      height: 320px;
      gap:12px;
      padding: 12px;
      background: rgba(0,0,0,0.03);
      border-radius:8px;
      overflow:hidden;
      user-select:none;
    }
    .bar {
      flex:1 1 0;
      min-width: 24px;
      display:flex;
      align-items:end;
      justify-content:center;
      cursor: ns-resize;
      position:relative;
    }
    .bar .rect {
      width:100%;
      border-radius:6px;
      background: linear-gradient(180deg,#334155,#0f1724);
      transition: height 400ms cubic-bezier(.2,.9,.3,1), background-color 180ms;
      box-shadow: 0 4px 10px rgba(2,6,23,0.6), inset 0 -6px 12px rgba(255,255,255,0.02);
      height: 40%;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding-bottom:6px;
      color: rgba(255,255,255,0.95);
      font-size: 11px;
      user-select:none;
    }
    .bar .label {
      font-size:11px;
      color: rgba(230,238,246,0.95);
      transform: translateY(-6px);
      pointer-events:none;
    }
    .bar.sorted .rect{ background: linear-gradient(180deg,#16a34a,#065f46); }
    .bar.min .rect{ background: linear-gradient(180deg,#fb923c,#b45309); }
    .bar.compare .rect{ background: linear-gradient(180deg,#f59e0b,#92400e); }
    .bar.swap .rect{ box-shadow: 0 6px 18px rgba(245,158,11,0.12); border: 1px solid rgba(255,255,255,0.06); }

    .status {
      display:flex;
      gap: 12px;
      align-items:center;
      justify-content:space-between;
      color: var(--muted);
      font-size: 13px;
    }
    .counters {
      display:flex;
      gap:12px;
      align-items:center;
    }
    .counter {
      background: rgba(255,255,255,0.02);
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      color: var(--muted);
    }

    .pseudocode {
      flex:1 1 40%;
      min-width:260px;
      background: rgba(6,10,15,0.4);
      border-radius: 12px;
      padding: 12px;
      color: var(--muted);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
      font-size:13px;
      line-height:1.45;
    }
    .pseudocode pre {
      margin:0;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .line {
      display:block;
      padding:6px 8px;
      border-radius:6px;
      margin-bottom:4px;
    }
    .line.active {
      background: rgba(96,165,250,0.12);
      color: #dbeafe;
      border-left: 4px solid var(--accent);
    }
    .note {
      color: var(--muted);
      font-size:12px;
      margin-top:8px;
    }

    /* Responsive */
    @media (max-width: 900px){
      .main { flex-direction:column; }
      .pseudocode{ order:2; width:100%; }
      .visual{ order:1; width:100%; }
      .bars{ height: 240px; }
    }

    /* Accessible focus for bars */
    .bar:focus { outline: 3px solid rgba(59,130,246,0.18); outline-offset:4px; }
    .sr-only {
      position:absolute!important;
      height:1px;width:1px;overflow:hidden;
      clip:rect(1px,1px,1px,1px);white-space:nowrap;
    }
  </style>
</head>
<body>
  <div class="app" role="main">
    <header>
      <h1>Selection Sort — Step-by-step Visual Explorer</h1>
      <p class="lead">Watch how Selection Sort repeatedly finds the smallest element from the unsorted portion and swaps it into the correct place. Use the controls to play, step, or edit the array manually to gain intuition.</p>
    </header>

    <div class="controls" aria-label="Algorithm controls">
      <button id="shuffleBtn" class="btn" aria-label="Shuffle the array">Shuffle</button>
      <button id="resetBtn" class="btn secondary" aria-label="Reset to initial array">Reset</button>
      <button id="startBtn" class="btn" aria-label="Start or pause the sort">Start</button>
      <button id="stepBtn" class="btn" aria-label="Advance one step">Step</button>

      <div class="controls-right">
        <div class="control-group" title="Speed of animation">
          <label for="speedRange">Speed</label>
          <input id="speedRange" type="range" min="50" max="1000" step="10" value="350" aria-label="Animation speed">
        </div>

        <div class="control-group" title="Number of elements">
          <label for="sizeRange">Size</label>
          <input id="sizeRange" type="range" min="4" max="14" step="1" value="8" aria-label="Array size">
        </div>
      </div>
    </div>

    <div class="main">
      <section class="visual" aria-label="Visualization panel">
        <div class="bars" id="bars" role="list" aria-live="polite"></div>

        <div class="status" aria-hidden="false">
          <div class="counters" role="status" aria-live="polite">
            <div class="counter">Comparisons: <span id="compCount">0</span></div>
            <div class="counter">Swaps: <span id="swapCount">0</span></div>
          </div>
          <div style="margin-left:auto;color:var(--muted);font-size:13px;" id="statusText">Ready</div>
        </div>
      </section>

      <aside class="pseudocode" aria-label="Pseudocode and algorithm state">
        <strong style="color:#fff">Pseudocode</strong>
        <pre id="pseudocodeBlock">
<span class="line" data-line="1">for i from 0 to n-2</span>
<span class="line" data-line="2">  minIndex = i</span>
<span class="line" data-line="3">  for j from i+1 to n-1</span>
<span class="line" data-line="4">    if A[j] < A[minIndex]</span>
<span class="line" data-line="5">      minIndex = j</span>
<span class="line" data-line="6">  if minIndex != i</span>
<span class="line" data-line="7">    swap A[i] and A[minIndex]</span>
        </pre>
        <div class="note" id="pcNote">Line: -</div>
      </aside>
    </div>
  </div>

  <script>
    (function(){
      // Elements
      const barsEl = document.getElementById('bars');
      const shuffleBtn = document.getElementById('shuffleBtn');
      const resetBtn = document.getElementById('resetBtn');
      const startBtn = document.getElementById('startBtn');
      const stepBtn = document.getElementById('stepBtn');
      const speedRange = document.getElementById('speedRange');
      const sizeRange = document.getElementById('sizeRange');
      const compCountEl = document.getElementById('compCount');
      const swapCountEl = document.getElementById('swapCount');
      const statusText = document.getElementById('statusText');
      const pseudocodeBlock = document.getElementById('pseudocodeBlock');
      const pcNote = document.getElementById('pcNote');

      // State
      let array = [];
      let initialArray = [];
      let n = parseInt(sizeRange.value,10);
      let comparisons = 0;
      let swaps = 0;
      let isPlaying = false;
      let delay = parseInt(speedRange.value,10);
      let stepRunner = null;

      // Algorithm indices for stepper
      let i = 0, j = 1, minIndex = 0;
      let phase = 'idle'; // 'scanning', 'swap', 'done', 'idle'
      let done = false;

      // Pseudocode lines
      const lines = Array.from(pseudocodeBlock.querySelectorAll('.line'));

      // Utilities
      function randInt(min, max) {
        return Math.floor(Math.random()*(max-min+1)) + min;
      }
      function sleep(ms){
        return new Promise(r => setTimeout(r, ms));
      }

      // Rendering
      function renderBars(){
        barsEl.innerHTML = '';
        // compute max for scaling
        const maxVal = Math.max(...array, 10);
        for (let idx=0; idx<array.length; idx++){
          const val = array[idx];
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.setAttribute('role','listitem');
          bar.setAttribute('tabindex','0');
          bar.dataset.index = idx;
          // state classes
          if (idx < i && phase !== 'scanning' && !done) {
            // elements before i are considered sorted after they have been placed; but we mark sorted only when we confirm
          }
          if (done || idx < i) bar.classList.add('sorted');
          if (idx === minIndex && !done && (phase === 'scanning' || phase === 'compare')) bar.classList.add('min');
          if (phase === 'compare' && (idx === j || idx === minIndex)) bar.classList.add('compare');

          const rect = document.createElement('div');
          rect.className = 'rect';
          const hPct = Math.max(6, Math.round((val / maxVal) * 100));
          rect.style.height = hPct + '%';
          // label inside bar
          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = val;
          rect.appendChild(label);
          bar.appendChild(rect);

          // ARIA for screen readers
          bar.setAttribute('aria-label', `Index ${idx}, value ${val}${ idx === minIndex ? ', current minimum' : '' }${ idx < i || done ? ', sorted' : '' }`);
          // Event: click to edit
          bar.addEventListener('click', (e)=>{
            // prevent interfering with drag
            if (e.detail === 0) return; // some pointer events
            editBarValue(idx);
          });
          // keyboard arrow up/down to adjust
          bar.addEventListener('keydown', (ev)=>{
            if (ev.key === 'ArrowUp'){ array[idx] = Math.min(200, array[idx] + 1); resetAlgorithmStateOnManualChange(); renderBars(); }
            if (ev.key === 'ArrowDown'){ array[idx] = Math.max(1, array[idx] - 1); resetAlgorithmStateOnManualChange(); renderBars(); }
            if (ev.key === 'Enter'){ editBarValue(idx); }
          });

          // pointer drag to change height (value)
          let dragging = false;
          let startY = 0;
          let startVal = array[idx];
          bar.addEventListener('pointerdown', (ev)=>{
            ev.preventDefault();
            bar.setPointerCapture(ev.pointerId);
            dragging = true;
            startY = ev.clientY;
            startVal = array[idx];
            bar.classList.add('dragging');
          });
          bar.addEventListener('pointermove', (ev)=>{
            if (!dragging) return;
            const dy = startY - ev.clientY;
            const delta = Math.round(dy/6); // scale factor
            array[idx] = Math.max(1, startVal + delta);
            resetAlgorithmStateOnManualChange();
            renderBars();
          });
          bar.addEventListener('pointerup', (ev)=>{
            if (!dragging) return;
            dragging = false;
            bar.releasePointerCapture(ev.pointerId);
            bar.classList.remove('dragging');
          });
          bar.addEventListener('pointercancel', ()=>{
            dragging = false;
          });

          barsEl.appendChild(bar);
        }
      }

      function updateCounters(){
        compCountEl.textContent = comparisons;
        swapCountEl.textContent = swaps;
      }
      function setStatus(text){
        statusText.textContent = text;
      }
      function highlightLine(num){
        lines.forEach(l => {
          if (parseInt(l.dataset.line,10) === num) l.classList.add('active');
          else l.classList.remove('active');
        });
        pcNote.textContent = 'Line: ' + (num || '-');
      }

      // Initialization
      function initRandom(size){
        n = size || parseInt(sizeRange.value,10);
        array = [];
        for (let k=0;k<n;k++) array.push(randInt(5, 100));
        initialArray = array.slice();
        comparisons = 0; swaps = 0;
        i = 0; j = 1; minIndex = 0; phase = 'idle'; done = false;
        updateCounters();
        setStatus('Ready');
        highlightLine(null);
        renderBars();
      }

      function resetAlgorithmStateOnManualChange(){
        // When user edits the array, stop the animation and reset algorithm
        stop();
        initialArray = array.slice();
        comparisons = 0; swaps = 0;
        i = 0; j = 1; minIndex = 0; phase = 'idle'; done = false;
        setStatus('Manual edit — ready');
        updateCounters();
      }

      // Controls
      shuffleBtn.addEventListener('click', ()=>{
        stop();
        initRandom(parseInt(sizeRange.value,10));
      });
      resetBtn.addEventListener('click', ()=>{
        stop();
        array = initialArray.slice();
        comparisons = 0; swaps = 0;
        i = 0; j = 1; minIndex = 0; phase = 'idle'; done = false;
        updateCounters();
        setStatus('Reset to initial array');
        renderBars();
      });
      sizeRange.addEventListener('input', (e)=>{
        const newSize = parseInt(e.target.value,10);
        stop();
        initRandom(newSize);
      });
      speedRange.addEventListener('input', (e)=>{
        delay = parseInt(e.target.value,10);
      });

      startBtn.addEventListener('click', ()=>{
        if (isPlaying) stop();
        else start();
      });

      stepBtn.addEventListener('click', ()=>{
        stop();
        stepOnce();
      });

      // Keyboard support: space toggles start/pause
      document.addEventListener('keydown', (e)=>{
        if (e.code === 'Space' && document.activeElement === document.body) {
          e.preventDefault();
          startBtn.click();
        }
      });

      // Algorithm stepper: one atomic action = one comparison OR one swap OR marking sorted
      async function stepOnce(){
        if (done) {
          setStatus('Already sorted');
          highlightLine(null);
          renderBars();
          return;
        }
        // If phase is idle, initialize
        if (phase === 'idle'){
          minIndex = i;
          j = i + 1;
          phase = 'scanning';
          setStatus(`Start scanning from i=${i}`);
          highlightLine(2);
          renderBars();
          return;
        }

        if (phase === 'scanning'){
          // if j within range, compare A[j] with A[minIndex]
          if (j < array.length){
            phase = 'compare';
            comparisons++;
            updateCounters();
            setStatus(`Comparing A[${j}] (${array[j]}) with A[minIndex=${minIndex}] (${array[minIndex]})`);
            highlightLine(4);
            renderBars();
            // mark compare briefly (render done)
            return;
          } else {
            // finished inner loop: maybe swap
            if (minIndex !== i){
              phase = 'swap';
              setStatus(`Swap A[${i}] (${array[i]}) with A[${minIndex}] (${array[minIndex]})`);
              highlightLine(6);
              renderBars();
              return;
            } else {
              // no swap, mark i as sorted and advance i
              i++;
              if (i >= array.length-1){
                done = true;
                phase = 'done';
                setStatus('Array sorted');
                highlightLine(null);
                renderBars();
                return;
              }
              // prepare next iteration
              minIndex = i;
              j = i + 1;
              phase = 'scanning';
              setStatus(`Element at i=${i} is now being considered`);
              highlightLine(2);
              renderBars();
              return;
            }
          }
        } else if (phase === 'compare'){
          // Handle comparison conclusion: possibly update minIndex
          if (array[j] < array[minIndex]){
            minIndex = j;
            setStatus(`New minimum found at index ${minIndex} (value ${array[minIndex]})`);
            highlightLine(5);
          } else {
            setStatus(`No change; minIndex remains ${minIndex}`);
          }
          // advance j
          j++;
          phase = 'scanning';
          renderBars();
          return;
        } else if (phase === 'swap'){
          // perform swap
          await doSwap(i, minIndex);
          swaps++;
          updateCounters();
          // mark i sorted and advance
          i++;
          if (i >= array.length-1){
            done = true;
            phase = 'done';
            setStatus('Array sorted');
            renderBars();
            return;
          }
          minIndex = i;
          j = i + 1;
          phase = 'scanning';
          setStatus(`Continue with i=${i}`);
          renderBars();
          return;
        }
      }

      // Swap with visual animation (height transition handles visual)
      async function doSwap(a,b){
        // add swap class to bars temporarily
        const bars = Array.from(barsEl.querySelectorAll('.bar'));
        const barA = bars[a];
        const barB = bars[b];
        barA.classList.add('swap');
        barB.classList.add('swap');
        // swap values in array
        const tmp = array[a];
        array[a] = array[b];
        array[b] = tmp;
        renderBars();
        // pulse time
        await sleep(Math.max(80, delay/2));
        barA.classList.remove('swap');
        barB.classList.remove('swap');
      }

      // Play control
      function start(){
        if (done){
          setStatus('Already sorted');
          return;
        }
        if (isPlaying) return;
        isPlaying = true;
        startBtn.textContent = 'Pause';
        startBtn.setAttribute('aria-pressed','true');
        stepRunner = playLoop();
      }

      function stop(){
        isPlaying = false;
        startBtn.textContent = 'Start';
        startBtn.setAttribute('aria-pressed','false');
        if (stepRunner && stepRunner.cancel) stepRunner.cancel();
        stepRunner = null;
      }

      // Async loop that steps automatically
      function playLoop(){
        let cancelled = false;
        (async ()=>{
          // initialize if needed
          if (phase === 'idle'){
            minIndex = i;
            j = i + 1;
            phase = 'scanning';
            highlightLine(2);
            renderBars();
            await sleep( Math.max(60, delay/4) );
          }
          while (!cancelled && !done && isPlaying){
            // If we are in 'compare' or 'swap' phases we want to allow them to display
            if (phase === 'scanning' && j < array.length){
              // trigger a compare
              phase = 'compare';
              comparisons++;
              updateCounters();
              highlightLine(4);
              setStatus(`Comparing A[${j}] (${array[j]}) with A[minIndex=${minIndex}] (${array[minIndex]})`);
              renderBars();
              await sleep(delay);
              // after delay handle result
              if (array[j] < array[minIndex]){
                minIndex = j;
                highlightLine(5);
                setStatus(`New min at ${minIndex} (${array[minIndex]})`);
                renderBars();
                await sleep(Math.max(60, delay/3));
              } else {
                setStatus(`No change; minIndex remains ${minIndex}`);
                await sleep(Math.max(60, delay/4));
              }
              j++;
              phase = 'scanning';
            } else if (phase === 'scanning' && j >= array.length){
              // inner loop complete: maybe swap
              if (minIndex !== i){
                phase = 'swap';
                highlightLine(6);
                setStatus(`Swapping A[${i}] and A[${minIndex}]`);
                renderBars();
                await sleep(Math.max(60, delay/3));
                await doSwap(i,minIndex);
                swaps++;
                updateCounters();
                await sleep(Math.max(60, delay/3));
                i++;
                if (i >= array.length-1){
                  done=true;
                  phase='done';
                  setStatus('Array sorted');
                  highlightLine(null);
                  renderBars();
                  break;
                }
                minIndex = i;
                j = i+1;
                phase = 'scanning';
                setStatus(`Proceeding to i=${i}`);
                renderBars();
                await sleep(Math.max(60, delay/5));
              } else {
                // no swap needed
                setStatus(`No swap needed for i=${i}`);
                await sleep(Math.max(60, delay/4));
                i++;
                if (i >= array.length-1){
                  done=true;
                  phase='done';
                  setStatus('Array sorted');
                  highlightLine(null);
                  renderBars();
                  break;
                }
                minIndex = i;
                j = i+1;
                phase = 'scanning';
                setStatus(`Proceeding to i=${i}`);
                renderBars();
                await sleep(Math.max(60, delay/5));
              }
            } else {
              // fallback step to avoid infinite loops
              await sleep(50);
            }
          }
          isPlaying = false;
          startBtn.textContent = 'Start';
          startBtn.setAttribute('aria-pressed','false');
        })();
        return {
          cancel(){
            cancelled = true;
          }
        };
      }

      // Edit bar prompt
      function editBarValue(idx){
        const newVal = prompt('Set value for index ' + idx + ' (1 - 200):', String(array[idx]));
        if (newVal === null) return;
        let v = Number(newVal);
        if (isNaN(v)) return;
        v = Math.max(1, Math.min(200, Math.round(v)));
        array[idx] = v;
        resetAlgorithmStateOnManualChange();
        renderBars();
      }

      // Initialize and render initial
      initRandom(n);
      renderBars();
    })();
  </script>
</body>
</html>