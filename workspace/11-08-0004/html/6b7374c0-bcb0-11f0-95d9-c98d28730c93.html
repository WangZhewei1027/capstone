<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Radix Sort Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --accent-2: #7dd3fc;
      --card: #e6eef9;
      --card-text: #071029;
      --success: #34d399;
      --danger: #fb7185;
      --transition: 600ms cubic-bezier(.2,.9,.2,1);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071126 0%, #071026 100%);
      color: #e6eef9;
    }

    /* Safe area margins */
    .app {
      box-sizing: border-box;
      padding: var(--safe-margin);
      min-height: 100vh;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    /* Header */
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: var(--gap);
      flex-wrap:wrap;
    }
    .title {
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .title h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    .subtitle{
      margin:0;
      font-size:13px;
      color:var(--muted);
    }

    /* Main layout: left control panel, right visualization */
    .main {
      display:flex;
      gap: var(--gap);
      align-items:flex-start;
      width:100%;
    }
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }

    .controls {
      width:360px;
      min-width:260px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    .visual {
      flex:1;
      min-height:420px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    /* Form elements */
    label{
      display:block;
      font-size:13px;
      color:var(--muted);
      margin-bottom:8px;
    }
    input[type="text"], textarea {
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background: rgba(255,255,255,0.02);
      color:var(--card);
      font-size:14px;
      outline:none;
    }
    input[type="range"]{
      width:100%;
      accent-color:var(--accent);
    }

    .row {
      display:flex;
      gap:var(--gap);
      align-items:center;
    }
    .btn {
      background: linear-gradient(180deg,var(--accent),var(--accent-2));
      color:#021024;
      border:none;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      box-shadow: 0 6px 18px rgba(96,165,250,0.12);
      transition: transform 120ms ease;
      min-height:40px;
    }
    .btn:active{ transform:translateY(1px); }
    .btn.secondary {
      background: transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--card);
      box-shadow:none;
    }
    .btn.ghost {
      background: transparent;
      border: none;
      color:var(--muted);
      padding:8px;
    }

    .small {
      font-size:13px;
      padding:8px 10px;
      border-radius:8px;
      background: rgba(255,255,255,0.02);
    }

    /* Visualization workspace */
    .workspace {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015));
      border-radius:12px;
      padding:16px;
      min-height:420px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      position:relative;
      overflow:hidden;
    }

    .info-strip {
      display:flex;
      gap:var(--gap);
      align-items:center;
      justify-content:space-between;
      color:var(--muted);
      font-size:13px;
    }

    /* Input area and buckets */
    .lane {
      background: rgba(255,255,255,0.02);
      border-radius:10px;
      padding:12px;
      display:flex;
      gap:12px;
      min-height:84px;
      align-items:center;
      flex-wrap:nowrap;
      overflow:visible;
      position:relative;
    }

    .lane-title {
      font-size:13px;
      color:var(--muted);
      margin-bottom:8px;
    }

    /* Cards */
    .card {
      min-width:60px;
      height:44px;
      border-radius:8px;
      background:var(--card);
      color:var(--card-text);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      box-shadow: 0 8px 18px rgba(2,6,23,0.4);
      user-select:none;
      position:absolute; /* we will position them inside the workspace */
      transition: transform var(--transition), opacity 180ms ease;
      z-index:10;
    }
    .card .digit {
      position:absolute;
      right:6px;
      top:6px;
      background: rgba(2,6,23,0.06);
      color: #0b1220;
      border-radius:6px;
      padding:2px 6px;
      font-size:11px;
      font-weight:700;
    }

    /* Buckets row */
    .buckets {
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:flex-start;
      flex-wrap:wrap;
    }

    .bucket {
      min-width:84px;
      min-height:120px;
      background: rgba(255,255,255,0.01);
      border-radius:8px;
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:center;
      border:1px dashed rgba(255,255,255,0.03);
      position:relative;
    }
    .bucket .label {
      background: rgba(255,255,255,0.02);
      padding:6px 8px;
      border-radius:8px;
      color:var(--muted);
      font-weight:700;
      width:100%;
      text-align:center;
      font-size:13px;
    }
    .bucket .slot {
      flex:1;
      width:100%;
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:center;
      padding:4px;
      overflow:visible;
      position:relative;
    }

    /* status pill */
    .pill{
      background: rgba(255,255,255,0.02);
      padding:8px 10px;
      border-radius:999px;
      font-weight:700;
      font-size:13px;
      color:var(--muted);
      display:inline-flex;
      gap:8px;
      align-items:center;
    }

    /* responsive */
    @media (max-width:980px){
      .main { flex-direction:column; }
      .controls{ width:100%; }
      .visual{ width:100%; }
    }

    /* Focus outlines */
    button:focus, input:focus {
      outline: 3px solid rgba(96,165,250,0.12);
      outline-offset:2px;
    }

    /* subtle helper text */
    .muted {
      color:var(--muted);
      font-size:13px;
    }

    /* code box */
    pre {
      background: rgba(255,255,255,0.02);
      padding:12px;
      border-radius:8px;
      color:var(--muted);
      overflow:auto;
      max-height:160px;
      font-size:13px;
    }

    /* accessibility: hidden but readable */
    .sr-only {
      position:absolute;
      left:-10000px;
      top:auto;
      width:1px;
      height:1px;
      overflow:hidden;
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Radix Sort interactive module">
    <header>
      <div class="title">
        <h1>Radix Sort — Visual, Interactive (LSD)</h1>
        <p class="subtitle">Stable, digit-by-digit sorting using buckets (least-significant-digit first).</p>
      </div>
      <div style="display:flex;gap:12px;align-items:center;">
        <div class="pill" aria-hidden="true">Concept: Radix Sort</div>
        <div class="pill" aria-hidden="true">Mode: LSD</div>
      </div>
    </header>

    <main class="main" id="main">
      <!-- Controls -->
      <section class="panel controls" aria-labelledby="controls-heading">
        <h2 id="controls-heading" style="margin:0 0 8px 0;font-size:15px;">Learning Objective</h2>
        <div class="muted" style="margin-bottom:8px;">
          After interacting with this module, you will understand how Radix Sort
          processes numbers digit-by-digit using stable bucket collection (LSD variant),
          and how stability is essential to get a fully sorted result.
        </div>

        <div style="display:flex;flex-direction:column;gap:12px;">
          <label for="input-array">Array (comma or space separated numbers)</label>
          <input id="input-array" type="text" class="small" value="329, 457, 657, 839, 436, 720, 355" aria-label="Array of numbers" />
        </div>

        <div class="row" style="margin-top:6px;">
          <button id="btn-generate" class="btn secondary" aria-label="Generate random numbers">Random</button>
          <button id="btn-load" class="btn" aria-label="Load and create cards">Load</button>
          <button id="btn-reset" class="btn secondary" aria-label="Reset visualization">Reset</button>
        </div>

        <div style="display:flex;gap:var(--gap);align-items:center;justify-content:space-between;">
          <div>
            <label for="speed">Auto play speed</label>
            <input id="speed" type="range" min="200" max="2000" step="100" value="900" aria-label="Animation speed" />
          </div>
          <div style="min-width:120px;">
            <label style="visibility:hidden">placeholder</label>
            <div style="display:flex;gap:12px;">
              <button id="btn-play" class="btn" aria-label="Play / Pause">Play</button>
              <button id="btn-step" class="btn secondary" aria-label="Step one move">Step</button>
            </div>
          </div>
        </div>

        <div style="display:flex;gap:var(--gap);align-items:center;justify-content:space-between;">
          <div class="muted">Pass: <strong id="pass-counter">0</strong></div>
          <div class="muted">Digits: <strong id="digit-count">0</strong></div>
        </div>

        <details style="margin-top:8px;">
          <summary style="cursor:pointer;color:var(--muted);font-weight:700;">How interaction works</summary>
          <div class="muted" style="margin-top:8px;line-height:1.4;">
            - "Load" reads your numbers and creates visual cards. <br/>
            - "Step" advances a single action: moving one number to a bucket or collecting one bucket item. <br/>
            - "Play" runs the full algorithm pass-by-pass, animating stable placement into buckets and collection back in order. <br/>
            - You can change speed and input new arrays. Only non-negative integers are supported here.
          </div>
        </details>

        <details style="margin-top:8px;">
          <summary style="cursor:pointer;color:var(--muted);font-weight:700;">Radix Sort (LSD) pseudo-code</summary>
          <pre>
function radixSortLSD(array):
  maxDigits = number of digits in the largest value
  for digit from 0 to maxDigits-1:
    buckets = array of 10 queues (0..9)
    for each value in array (left to right):
      key = digitValue(value, digit)
      enqueue value into buckets[key]
    array = concatenate buckets[0] .. buckets[9] (each in queue order)
  return array
          </pre>
        </details>

      </section>

      <!-- Visualization -->
      <section class="panel visual" aria-labelledby="visual-heading">
        <h2 id="visual-heading" style="margin:0 0 8px 0;font-size:15px;">Visualization</h2>
        <div class="workspace" id="workspace" role="region" aria-label="Radix sort workspace">
          <div class="info-strip">
            <div class="muted">Drag not required — use controls. Keyboard: Space = Step, Enter = Play/Pause</div>
            <div class="muted">Stable placement is shown by preserved left-to-right order inside buckets.</div>
          </div>

          <!-- Input lane -->
          <div>
            <div class="lane-title">Input Array</div>
            <div class="lane" id="input-lane" style="height:96px;"></div>
          </div>

          <!-- Buckets -->
          <div>
            <div class="lane-title">Buckets (0 .. 9)</div>
            <div class="buckets" id="buckets-row"></div>
          </div>

          <!-- Visually used for absolute-positioned cards -->
          <div id="overlay" aria-hidden="true" style="position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;"></div>
        </div>
      </section>
    </main>

    <footer style="display:flex;gap:12px;align-items:center;justify-content:space-between;color:var(--muted);font-size:13px;">
      <div>Interaction design: click Play / Step to observe each stable bucket placement and collection.</div>
      <div>Accessible, responsive, vanilla JS demo</div>
    </footer>
  </div>

  <script>
    // Radix Sort Interactive (LSD) — Vanilla JS implementation and UI behavior.
    // Structure:
    // - Cards are DOM elements positioned absolutely in the workspace overlay.
    // - There is an input lane (visual row) and buckets (10 columns).
    // - Each step either moves one card to the appropriate bucket or moves one card from buckets back to the input array.
    // - Stable ordering is achieved by enqueueing (pushing) to bucket arrays and collecting in order.

    (function(){
      // DOM refs
      const inputField = document.getElementById('input-array');
      const btnLoad = document.getElementById('btn-load');
      const btnReset = document.getElementById('btn-reset');
      const btnGenerate = document.getElementById('btn-generate');
      const btnPlay = document.getElementById('btn-play');
      const btnStep = document.getElementById('btn-step');
      const speedRange = document.getElementById('speed');
      const passCounterLabel = document.getElementById('pass-counter');
      const digitCountLabel = document.getElementById('digit-count');

      const workspace = document.getElementById('workspace');
      const overlay = document.getElementById('overlay');
      const inputLane = document.getElementById('input-lane');
      const bucketsRow = document.getElementById('buckets-row');

      // State
      let array = []; // sequence of integers (order)
      let cards = []; // objects: {value, el, index}
      let buckets = []; // array of arrays, each contains card objects indices
      let pass = 0;
      let maxDigits = 0;
      let phase = 'idle'; // 'placing', 'collecting', 'done', 'idle'
      let auto = false;
      let autoTimer = null;
      let moveQueue = []; // sequence of atomic moves for step/play. Each move is a function returning a Promise that resolves after animation.
      let animSpeed = parseInt(speedRange.value,10); // ms
      const transitionMs = 600;

      // Visual constants
      let workspaceRect = null;
      window.addEventListener('resize', ()=> workspaceRect = workspace.getBoundingClientRect());

      // Helpers
      function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

      // Parse input
      function parseInput(text){
        const tokens = text.split(/[\s,]+/).filter(Boolean);
        const out = [];
        for (const t of tokens){
          if (!/^-?\d+$/.test(t)) continue;
          const n = Number(t);
          if (!Number.isSafeInteger(n)) continue;
          if (n < 0) continue; // our demo simplifies to non-negative integers
          out.push(n);
        }
        return out;
      }

      // Create bucket elements 0..9
      function createBuckets(){
        bucketsRow.innerHTML = '';
        buckets = [];
        for (let i=0;i<10;i++){
          const b = document.createElement('div');
          b.className = 'bucket';
          b.setAttribute('data-bucket', String(i));
          b.innerHTML = `<div class="label">${i}</div><div class="slot" aria-hidden="true"></div>`;
          bucketsRow.appendChild(b);
          buckets.push([]);
        }
      }

      // Create card DOMs in overlay based on array
      function renderCards(){
        overlay.innerHTML = '';
        cards = [];
        workspaceRect = workspace.getBoundingClientRect();
        const laneRect = inputLane.getBoundingClientRect();
        // initial layout: left-to-right in input lane, spaced evenly
        const totalWidth = Math.max(120, Math.min(workspaceRect.width - 120, array.length * 80));
        const startX = (workspaceRect.width - totalWidth) / 2;
        const y = laneRect.top + (laneRect.height/2) - workspaceRect.top - 22; // center vertical (card height 44)
        for (let i=0;i<array.length;i++){
          const v = array[i];
          const el = document.createElement('div');
          el.className = 'card';
          el.textContent = String(v);
          const digitBadge = document.createElement('span');
          digitBadge.className = 'digit';
          digitBadge.textContent = '';
          el.appendChild(digitBadge);
          overlay.appendChild(el);
          // compute initial x
          const spacing = totalWidth / Math.max(1,array.length);
          const x = startX + (i * spacing) + 6; // +6 padding
          el.style.transform = `translate(${x}px, ${y}px)`;
          el.style.opacity = '1';
          cards.push({value:v, el, x, y, pos:'input'}); // pos: 'input', 'bucket'
        }
        // reset buckets DOM slots
        const bucketSlots = bucketsRow.querySelectorAll('.slot');
        bucketSlots.forEach(s => s.innerHTML = '');
      }

      // Utility to get digit value at position d (0 = ones)
      function digitAt(num, d){
        return Math.floor(num / Math.pow(10,d)) % 10;
      }

      // Build move queue for a full pass (placing phase then collecting)
      function buildMovesForPass(passIndex){
        const moves = [];
        // Placing phase: for each card left-to-right in current 'array order', determine its bucket and animate move into that bucket,
        // enqueue into buckets[dig]. We want stable order: existing order inside bucket preserved by pushing.
        // We'll consider "array" as current order of cards (cards array order).
        for (let i=0;i<cards.length;i++){
          const c = cards[i];
          moves.push(()=> moveCardToBucket(c, passIndex));
        }
        // After placing all, collecting: for bucket 0..9, collect their items in order and move them back to input lane left-to-right
        moves.push(()=> collectBuckets());
        return moves;
      }

      // Move a card to its bucket (animate)
      function moveCardToBucket(cardObj, digitIndex){
        return new Promise(resolve=>{
          const k = digitAt(cardObj.value, digitIndex);
          // target bucket DOM
          const bucketEl = bucketsRow.querySelector(`.bucket[data-bucket="${k}"]`);
          const slot = bucketEl.querySelector('.slot');
          // compute target x,y inside workspace relative
          // place stacked vertically, but maintain left-to-right inner order by counting how many already in bucket
          const orderIndex = buckets[k].length;
          buckets[k].push(cardObj); // logically enqueue (stable)
          cardObj.pos = `bucket-${k}`;
          // find coordinates
          const bucketRect = bucketEl.getBoundingClientRect();
          workspaceRect = workspace.getBoundingClientRect();
          const targetX = bucketRect.left - workspaceRect.left + 12; // padding
          const targetY = bucketRect.top - workspaceRect.top + 40 + (orderIndex * 48);
          // update digit badge for clarity
          const badge = cardObj.el.querySelector('.digit');
          badge.textContent = String(k);
          // animate by setting transform
          requestAnimationFrame(()=>{
            cardObj.el.style.transition = `transform ${animSpeed}ms cubic-bezier(.2,.9,.2,1), opacity 160ms ease`;
            cardObj.el.style.transform = `translate(${targetX}px, ${targetY}px)`;
            // slight scale to indicate placement
            cardObj.el.style.boxShadow = '0 10px 24px rgba(2,6,23,0.55)';
          });
          // resolve after transition
          setTimeout(()=> {
            // ensure stable stacking visually (left margin bump by index)
            cardObj.el.style.transition = `transform 120ms ease`;
            // keep final transform (no change)
            resolve();
          }, animSpeed + 30);
        });
      }

      // Collect buckets: move everything back to input lane in bucket order
      function collectBuckets(){
        return new Promise(resolve=>{
          // Compute the new order by concatenating buckets 0..9
          const collected = [];
          for (let b=0;b<10;b++){
            for (const item of buckets[b]) collected.push(item);
          }
          // compute target positions in input lane: centered row
          workspaceRect = workspace.getBoundingClientRect();
          const laneRect = inputLane.getBoundingClientRect();
          const totalWidth = Math.max(120, Math.min(workspaceRect.width - 120, collected.length * 80));
          const startX = (workspaceRect.width - totalWidth) / 2;
          const y = laneRect.top + (laneRect.height/2) - workspaceRect.top - 22;
          // animate each element to its new slot with small stagger for clarity
          collected.forEach((c, idx) => {
            const targetX = startX + (idx * (totalWidth / Math.max(1,collected.length))) + 6;
            const targetY = y;
            // update badges to show current digit for pass
            const badge = c.el.querySelector('.digit');
            badge.textContent = ''; // clearing
            setTimeout(()=>{
              c.el.style.transition = `transform ${animSpeed}ms cubic-bezier(.2,.9,.2,1)`;
              c.el.style.transform = `translate(${targetX}px, ${targetY}px)`;
            }, idx * 80); // slight stagger
          });
          // Wait for final animation to finish before resolving
          const totalWait = animSpeed + (collected.length * 80) + 50;
          setTimeout(()=>{
            // update internal cards array order to reflect collection
            cards = collected.slice();
            // clear bucket arrays
            for (let b=0;b<10;b++) buckets[b] = [];
            resolve();
          }, totalWait);
        });
      }

      // Build entire moveQueue for the rest of sorting from current pass onward
      function buildEntireMoveQueue(){
        moveQueue = [];
        for (let d = pass; d < maxDigits; d++){
          const moves = buildMovesForPass(d);
          moveQueue.push(...moves);
          // after collection, increment pass (we'll push a function to bump the pass counter)
          moveQueue.push(()=> {
            return new Promise(r=>{ pass++; updateStatus(); setTimeout(r,80); });
          });
        }
        // mark done
        moveQueue.push(()=> new Promise(r=>{ phase='done'; updateStatus(); r(); }));
      }

      // Step: execute next move if any
      function stepOnce(){
        if (moveQueue.length === 0) return;
        const move = moveQueue.shift();
        // execute move (a function returning a Promise)
        move().catch(()=>{}).then(()=>{
          // no-op here; external loop handles further steps if autoplay
        });
      }

      // Play / auto-run: consume moveQueue sequentially
      async function autoPlay(){
        if (auto) return;
        auto = true;
        btnPlay.textContent = 'Pause';
        btnPlay.setAttribute('aria-pressed','true');
        while (auto && moveQueue.length > 0){
          const move = moveQueue.shift();
          await move();
          // minor inter-move delay to respect speed slider
          await new Promise(r=>setTimeout(r, 80));
        }
        auto = false;
        btnPlay.textContent = 'Play';
        btnPlay.setAttribute('aria-pressed','false');
        updateStatus();
      }

      // Update labels
      function updateStatus(){
        passCounterLabel.textContent = String(pass);
        digitCountLabel.textContent = String(maxDigits);
      }

      // Reset everything
      function resetAll(){
        array = [];
        cards = [];
        buckets = [];
        pass = 0;
        maxDigits = 0;
        phase = 'idle';
        moveQueue = [];
        auto = false;
        btnPlay.textContent = 'Play';
        btnPlay.setAttribute('aria-pressed','false');
        overlay.innerHTML = '';
        createBuckets();
        updateStatus();
      }

      // Validate and load array from input
      function loadFromInput(){
        const parsed = parseInput(inputField.value);
        if (parsed.length === 0){
          alert('Please enter one or more non-negative integers (e.g., 329,457,657).');
          return;
        }
        array = parsed.slice();
        pass = 0;
        maxDigits = Math.max(...array).toString().length;
        updateStatus();
        createBuckets();
        renderCards();
        moveQueue = [];
        // Build moveQueue from scratch for LSD passes
        buildEntireMoveQueue();
        phase = 'placing';
      }

      // Random generate
      function generateRandom(){
        const n = 7;
        const arr = [];
        for (let i=0;i<n;i++){
          // produce 1..3 digit random numbers
          const digits = Math.random() < 0.4 ? 3 : 2;
          const val = Math.floor(Math.random() * Math.pow(10,digits));
          arr.push(val);
        }
        inputField.value = arr.join(', ');
      }

      // Event handlers
      btnGenerate.addEventListener('click', () => {
        generateRandom();
      });

      btnLoad.addEventListener('click', ()=>{
        loadFromInput();
      });

      btnReset.addEventListener('click', ()=>{
        resetAll();
      });

      btnStep.addEventListener('click', ()=>{
        // On first step, if queue empty but cards exist, rebuild
        if (moveQueue.length === 0 && cards.length>0 && pass < maxDigits){
          buildEntireMoveQueue();
        }
        stepOnce();
      });

      btnPlay.addEventListener('click', ()=>{
        if (!auto){
          // start
          if (moveQueue.length === 0 && cards.length>0 && pass < maxDigits){
            buildEntireMoveQueue();
          }
          autoPlay();
        } else {
          // pause
          auto = false;
          btnPlay.textContent = 'Play';
          btnPlay.setAttribute('aria-pressed','false');
        }
      });

      speedRange.addEventListener('input', ()=>{
        animSpeed = parseInt(speedRange.value,10);
      });

      // Keyboard: Space = step, Enter = play/pause
      window.addEventListener('keydown', (e)=>{
        if (e.code === 'Space'){
          e.preventDefault();
          btnStep.focus();
          btnStep.click();
        } else if (e.code === 'Enter'){
          e.preventDefault();
          btnPlay.focus();
          btnPlay.click();
        }
      });

      // Initialize
      resetAll();
      generateRandom();
      // auto-load initial example
      loadFromInput();

      // Accessibility: ensure button labels
      document.querySelectorAll('button').forEach(b=>{
        if (!b.getAttribute('aria-label')){
          b.setAttribute('aria-label', b.textContent.trim());
        }
      });

      // Add small visual hint: when sorting is finished, pulse cards
      const observer = new MutationObserver(()=>{ /* placeholder for future */ });
      observer.observe(overlay, {childList:true, subtree:true});

      // Notes:
      // - For a real production version you'd add robust error handling,
      //   support negative numbers, MSD option, drag-to-reorder, and
      //   step-by-step explanations for each animation. This module keeps
      //   focus on LSD radix sort and demonstrates stability visually.
    })();
  </script>
</body>
</html>