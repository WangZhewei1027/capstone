<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hash Map (Separate Chaining) Visualizer</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa4b2;
      --accent: #4fd1c5;
      --accent-2: #60a5fa;
      --danger: #fb7185;
      --success: #34d399;
      --node-bg: #111827;
      --node-border: #1f2937;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071126 0%, #031025 100%);
      color: #e6eef6;
    }
    body{
      padding: var(--safe-padding);
      box-sizing: border-box;
    }
    /* Layout */
    .root{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      min-height: calc(100vh - calc(var(--safe-padding) * 2));
    }
    /* Left controls column */
    .controls{
      flex: 0 0 360px;
      max-width: 42%;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:20px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      min-width: 280px;
    }
    h1{
      margin:0 0 8px 0;
      font-size:20px;
      line-height:1.1;
    }
    p.short{
      margin:0 0 12px 0;
      color:var(--muted);
      font-size:13px;
    }
    label{
      display:block;
      font-size:13px;
      color:var(--muted);
      margin-bottom:6px;
    }
    .row{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .field{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-bottom:12px;
    }
    input[type="text"], input[type="number"]{
      background: #061223;
      border:1px solid #122135;
      color: #e6eef6;
      padding:10px 12px;
      border-radius:8px;
      font-size:14px;
      outline:none;
    }
    input[type="text"]:focus, input[type="number"]:focus{
      box-shadow:0 0 0 3px rgba(79,209,197,0.08);
      border-color: var(--accent);
    }
    .button-bar{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }
    button{
      background:linear-gradient(180deg,#0ea5a5 0%, #06b6d4 100%);
      color:#022;
      border:0;
      padding:10px 12px;
      border-radius:8px;
      font-weight:600;
      cursor:pointer;
      box-shadow: 0 6px 18px rgba(6,10,19,0.5);
      transition:transform .12s ease, opacity .12s;
      min-width:84px;
    }
    button:hover{ transform: translateY(-2px); }
    button.secondary{
      background: linear-gradient(180deg,#111827 0%, #0b1220 100%);
      color: var(--muted);
      border:1px solid #18212b;
      box-shadow:none;
    }
    button.danger{
      background: linear-gradient(180deg,#fb7185 0%, #f43f5e 100%);
      color:#fff;
    }
    .small{
      font-size:13px;
      color:var(--muted);
    }
    .panel{
      background: rgba(255,255,255,0.02);
      border-radius:8px;
      padding:12px;
      margin-top:12px;
      border:1px solid rgba(255,255,255,0.02);
    }
    /* Right visualization column */
    .visual{
      flex:1 1 auto;
      min-width:0;
      background: rgba(255,255,255,0.01);
      border-radius:12px;
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      overflow:hidden;
    }
    .controls-top{
      display:flex;
      gap:var(--gap);
      align-items:center;
      justify-content:space-between;
    }
    .stats{
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .stat{
      background: rgba(255,255,255,0.02);
      padding:8px 10px;
      border-radius:8px;
      min-width:110px;
      text-align:center;
    }
    .table-wrap{
      overflow:auto;
      padding:8px;
      border-radius:8px;
      border:1px dashed rgba(255,255,255,0.03);
      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    }
    .table{
      display:flex;
      gap:16px;
      padding:12px;
      min-height:180px;
      align-items:flex-start;
    }
    .bucket{
      min-width:120px;
      width:120px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border:1px solid rgba(255,255,255,0.03);
      border-radius:10px;
      padding:8px;
      box-sizing:border-box;
      position:relative;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .bucket-label{
      font-size:12px;
      color:var(--muted);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .chain{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:30px;
      margin-top:4px;
    }
    .node{
      background: linear-gradient(180deg, #061826, #041024);
      border:1px solid var(--node-border);
      padding:8px;
      border-radius:8px;
      color:#e6f3f2;
      font-weight:600;
      font-size:13px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      box-shadow: 0 6px 14px rgba(2,6,23,0.6);
      transform-origin:center;
    }
    .node .kv{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .node .key{
      color:var(--accent);
      font-weight:700;
      background: rgba(79,209,197,0.06);
      padding:4px 8px;
      border-radius:6px;
    }
    .node .value{
      color:var(--muted);
      font-weight:600;
      font-size:12px;
    }
    .node.highlight{
      box-shadow: 0 0 0 6px rgba(96,165,250,0.06), 0 10px 30px rgba(2,6,23,0.6);
      transform: translateY(-4px) scale(1.01);
    }
    .node.found{
      box-shadow: 0 0 0 8px rgba(52,211,153,0.08), 0 12px 34px rgba(2,6,23,0.6);
      transform: translateY(-6px) scale(1.02);
    }
    .node.removing{
      opacity:0;
      transform: translateY(8px) scale(.98);
      transition: opacity .3s ease, transform .3s ease;
    }
    .bucket.hilite{
      box-shadow: inset 0 0 40px rgba(96,165,250,0.02), 0 8px 24px rgba(2,6,23,0.6);
      border-color: rgba(96,165,250,0.2);
    }
    /* floating token animation element */
    .floating{
      position:fixed;
      pointer-events:none;
      z-index:9999;
      transition: transform 700ms cubic-bezier(.2,.9,.25,1), opacity 300ms linear;
      will-change: transform, opacity;
      transform-origin:center;
      background: linear-gradient(180deg,#0ea5a5 0%, #06b6d4 100%);
      color:#022;
      padding:8px 10px;
      border-radius:8px;
      font-weight:700;
      box-shadow: 0 10px 30px rgba(2,6,23,0.6);
    }
    .hash-calc{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
      color:var(--muted);
      background: rgba(255,255,255,0.01);
      padding:8px;
      border-radius:6px;
    }
    .message{
      color:var(--muted);
      font-size:13px;
      padding-top:6px;
      min-height:20px;
    }
    /* Focus and accessibility */
    button:focus, input:focus { outline: 3px solid rgba(79,209,197,0.08); outline-offset:2px; }
    /* responsive */
    @media (max-width:900px){
      .root{ flex-direction:column; }
      .controls{ max-width:100%; width:100%; }
    }
    @media (prefers-reduced-motion: reduce){
      .floating{ transition:none !important; }
      .node, .node.highlight, .node.found{ transition:none !important; transform:none !important; }
    }
  </style>
</head>
<body>
  <div class="root" role="application" aria-label="Hash Map visualizer">
    <section class="controls" aria-labelledby="title">
      <h1 id="title">Hash Map — Separate Chaining</h1>
      <p class="short">Type keys (strings) and values, then Insert / Search / Delete. Watch hashing and collisions.</p>

      <form id="actionForm" onsubmit="return false;">
        <div class="field">
          <label for="keyInput">Key</label>
          <input id="keyInput" type="text" placeholder="e.g., apple" aria-label="Key" required />
        </div>

        <div class="field">
          <label for="valueInput">Value (optional)</label>
          <input id="valueInput" type="text" placeholder="e.g., 42 or some data" aria-label="Value" />
        </div>

        <div class="button-bar" role="group" aria-label="Actions">
          <button id="insertBtn" type="button">Insert</button>
          <button id="searchBtn" type="button" class="secondary">Search</button>
          <button id="deleteBtn" type="button" class="danger">Delete</button>
          <button id="resetBtn" type="button" class="secondary">Reset</button>
        </div>

        <div class="panel" style="margin-top:12px;">
          <label for="sizeRange">Table size: <span id="sizeLabel">8</span></label>
          <input id="sizeRange" type="range" min="4" max="32" value="8" aria-label="Table size" />
          <p class="small" style="margin-top:8px;">Table size determines number of buckets (modulo). Changing it will reset the table.</p>
        </div>

        <div class="panel" style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <label style="margin:0;">Hash Calculation</label>
            <button id="calcToggle" type="button" class="secondary" style="font-size:12px;padding:6px 8px;">Copy</button>
          </div>
          <pre id="hashCalc" class="hash-calc" aria-live="polite" style="margin-top:8px;">--</pre>
        </div>

      </form>

      <div class="panel" style="margin-top:12px;">
        <div class="small" style="display:flex;justify-content:space-between;">
          <span>Items</span><strong id="totalItems">0</strong>
        </div>
        <div class="small" style="display:flex;justify-content:space-between;margin-top:8px;">
          <span>Collisions</span><strong id="collisions">0</strong>
        </div>
        <div class="small" style="display:flex;justify-content:space-between;margin-top:8px;">
          <span>Load factor</span><strong id="loadFactor">0.00</strong>
        </div>
        <p class="message" id="msg" aria-live="polite"></p>
      </div>

    </section>

    <section class="visual" aria-label="Visualization">
      <div class="controls-top">
        <div>
          <div style="font-size:14px;font-weight:700;">Buckets</div>
          <div class="small" style="margin-top:4px;">Separate chaining: each bucket holds a vertical chain of nodes.</div>
        </div>
        <div class="stats" aria-hidden="false">
          <div class="stat"><div class="small">Table Size</div><div id="statSize">8</div></div>
          <div class="stat"><div class="small">Max Chain</div><div id="maxChain">0</div></div>
          <div class="stat"><div class="small">Comparisons</div><div id="lastComparisons">0</div></div>
        </div>
      </div>

      <div class="table-wrap" id="tableWrap" tabindex="0" aria-label="Hash table buckets">
        <div class="table" id="table" role="list"></div>
      </div>
    </section>
  </div>

  <!-- Floating element container will be created dynamically -->
  <script>
    // Hash Map visualizer script (separate chaining)
    (function(){
      // Elements
      const keyInput = document.getElementById('keyInput');
      const valueInput = document.getElementById('valueInput');
      const insertBtn = document.getElementById('insertBtn');
      const searchBtn = document.getElementById('searchBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const resetBtn = document.getElementById('resetBtn');
      const sizeRange = document.getElementById('sizeRange');
      const sizeLabel = document.getElementById('sizeLabel');
      const hashCalc = document.getElementById('hashCalc');
      const msg = document.getElementById('msg');
      const tableEl = document.getElementById('table');
      const statSize = document.getElementById('statSize');
      const collisionsEl = document.getElementById('collisions');
      const totalItemsEl = document.getElementById('totalItems');
      const loadFactorEl = document.getElementById('loadFactor');
      const maxChainEl = document.getElementById('maxChain');
      const lastComparisonsEl = document.getElementById('lastComparisons');
      const tableWrap = document.getElementById('tableWrap');
      const calcToggle = document.getElementById('calcToggle');

      // State
      let tableSize = parseInt(sizeRange.value,10);
      let table = []; // array of arrays (chains)
      let collisions = 0;
      let totalItems = 0;

      // Init
      function initTable(n){
        tableSize = n;
        table = new Array(tableSize).fill(null).map(()=>[]);
        renderTable();
        collisions = 0;
        totalItems = 0;
        updateStats();
        msg.textContent = 'New table created. Ready.';
      }

      function updateStats(){
        sizeLabel.textContent = tableSize;
        statSize.textContent = tableSize;
        collisionsEl.textContent = collisions;
        totalItemsEl.textContent = totalItems;
        loadFactorEl.textContent = (totalItems / tableSize).toFixed(2);
        const maxChain = table.reduce((m,chain)=>Math.max(m,chain.length),0);
        maxChainEl.textContent = maxChain;
      }

      // Simple hash: sum of char codes (UTF-16) mod tableSize
      function computeHashDetail(key){
        if(typeof key !== 'string') key = String(key);
        const codes = [];
        let sum = 0;
        for(let i=0;i<key.length;i++){
          const c = key.charCodeAt(i);
          codes.push(c);
          sum += c;
        }
        const mod = ((sum % tableSize)+tableSize) % tableSize;
        return {codes, sum, mod};
      }

      function showHashCalc(key){
        if(!key){
          hashCalc.textContent = '--';
          return;
        }
        const {codes,sum,mod} = computeHashDetail(key);
        const parts = codes.map((c,i)=>`${key[i]}:${c}`).join(' + ');
        const text = `${parts}\nSum = ${sum}\nIndex = Sum mod ${tableSize} = ${mod}`;
        hashCalc.textContent = text;
      }

      // Rendering
      function renderTable(){
        tableEl.innerHTML = '';
        for(let i=0;i<tableSize;i++){
          const bucket = document.createElement('div');
          bucket.className = 'bucket';
          bucket.setAttribute('data-index', i);
          bucket.setAttribute('role','listitem');
          const label = document.createElement('div');
          label.className = 'bucket-label';
          label.textContent = 'idx ' + i;
          const chain = document.createElement('div');
          chain.className = 'chain';
          chain.setAttribute('data-chain', i);
          // fill nodes
          table[i].forEach(item => {
            const node = createNodeElement(item.key, item.value);
            chain.appendChild(node);
          });
          bucket.appendChild(label);
          bucket.appendChild(chain);
          tableEl.appendChild(bucket);
        }
      }

      function createNodeElement(key, value){
        const n = document.createElement('div');
        n.className = 'node';
        n.setAttribute('data-key', key);
        const kv = document.createElement('div');
        kv.className = 'kv';
        const kspan = document.createElement('div');
        kspan.className = 'key';
        kspan.textContent = key;
        const vspan = document.createElement('div');
        vspan.className = 'value';
        vspan.textContent = value === undefined || value === null || value === '' ? '(no value)' : String(value);
        kv.appendChild(kspan);
        kv.appendChild(vspan);
        n.appendChild(kv);
        return n;
      }

      // Utility: create floating token and animate from source to target
      function animateToken(text, fromRect, toRect){
        return new Promise(resolve=>{
          const token = document.createElement('div');
          token.className = 'floating';
          token.textContent = text;
          document.body.appendChild(token);
          // start position
          const startX = fromRect.left + fromRect.width/2;
          const startY = fromRect.top + fromRect.height/2;
          token.style.left = startX + 'px';
          token.style.top = startY + 'px';
          token.style.transform = 'translate(-50%,-50%) scale(1)';
          // force layout
          token.getBoundingClientRect();
          // compute end center
          const endX = toRect.left + toRect.width/2;
          const endY = toRect.top + toRect.height/2 - 6; // slight offset
          const dx = endX - startX;
          const dy = endY - startY;
          // apply transform
          requestAnimationFrame(()=>{
            token.style.transform = `translate(${dx}px,${dy}px) translate(-50%,-50%) scale(.96)`;
          });
          // cleanup after transition
          const onEnd = (ev)=>{
            token.removeEventListener('transitionend', onEnd);
            // small fade
            token.style.opacity = '0';
            setTimeout(()=>{ token.remove(); resolve(); }, 200);
          };
          token.addEventListener('transitionend', onEnd);
          // safety: if reduced motion or transition didn't fire
          setTimeout(()=>{ if(document.body.contains(token)){ token.remove(); resolve(); } }, 1200);
        });
      }

      // Insert logic
      async function insertKey(key, value){
        if(!key) { msg.textContent = 'Please enter a key.'; return; }
        showHashCalc(key);
        const {mod} = computeHashDetail(key);
        const bucketChain = table[mod];
        const bucketEl = tableEl.querySelector('.bucket[data-index="'+mod+'"]');
        const chainEl = bucketEl.querySelector('.chain');

        // animate token from insert button
        const fromRect = insertBtn.getBoundingClientRect();
        const toRect = bucketEl.getBoundingClientRect();
        await animateToken(key, fromRect, toRect);

        // Check for duplicates: for demonstration, allow duplicates but highlight if duplicate exists.
        const existingIndex = bucketChain.findIndex(x=>x.key === key);
        if(existingIndex !== -1){
          // We'll append duplicates to tail but show message
          msg.textContent = `Duplicate key detected — appending new node to chain at bucket ${mod}.`;
          collisions += 1;
        } else if(bucketChain.length > 0){
          // collision since chain already exists
          msg.textContent = `Collision: bucket ${mod} already has ${bucketChain.length} item(s).`;
          collisions += 1;
        } else {
          msg.textContent = `Inserted into empty bucket ${mod}.`;
        }

        // update model
        bucketChain.push({key,value});
        totalItems += 1;
        // update DOM: append node with small fade-in
        const node = createNodeElement(key,value);
        node.style.opacity = '0';
        node.style.transform = 'translateY(-6px)';
        chainEl.appendChild(node);
        // force layout then animate
        requestAnimationFrame(()=>{
          node.style.transition = 'opacity 260ms ease, transform 260ms ease';
          node.style.opacity = '1';
          node.style.transform = 'translateY(0)';
        });
        updateStats();
      }

      // Search logic with sequential highlighting
      async function searchKey(key, action='search'){
        if(!key){ msg.textContent = 'Please enter a key to search.'; return; }
        showHashCalc(key);
        const {mod} = computeHashDetail(key);
        const bucketChain = table[mod];
        const bucketEl = tableEl.querySelector('.bucket[data-index="'+mod+'"]');
        const chainEls = bucketEl.querySelectorAll('.chain .node');
        // highlight bucket
        bucketEl.classList.add('hilite');
        msg.textContent = `Searching bucket ${mod}...`;
        let found = false;
        let comparisons = 0;
        for(let i=0;i<chainEls.length;i++){
          const n = chainEls[i];
          // highlight
          n.classList.add('highlight');
          comparisons++;
          lastComparisonsEl.textContent = comparisons;
          await new Promise(res=>setTimeout(res, 550));
          const k = n.getAttribute('data-key');
          if(k === key){
            found = true;
            n.classList.remove('highlight');
            n.classList.add('found');
            msg.textContent = `Found key in bucket ${mod} after ${comparisons} comparison(s).`;
            // if delete action, animate removal
            if(action === 'delete'){
              await new Promise(res=>setTimeout(res, 420));
              n.classList.add('removing');
              // update model
              const idx = table[mod].findIndex(x=>x.key === key);
              if(idx !== -1){
                table[mod].splice(idx,1);
                totalItems -= 1;
                if(table[mod].length >= 1) {
                  // if deletion of a node in a chain >1, decrease collisions
                  collisions = Math.max(0, collisions - 1);
                }
              }
              // remove element after animation
              setTimeout(()=>{
                n.remove();
                updateStats();
              }, 320);
            }
            break;
          } else {
            // not match: remove highlight
            n.classList.remove('highlight');
          }
        }
        if(!found){
          msg.textContent = `Key not found in bucket ${mod}. Comparisons: ${comparisons}.`;
        } else {
          updateStats();
        }
        // cleanup
        bucketEl.classList.remove('hilite');
        setTimeout(()=>{ lastComparisonsEl.textContent = '0'; }, 600);
      }

      // Events
      insertBtn.addEventListener('click', ()=>{ insertKey(keyInput.value.trim(), valueInput.value.trim()); keyInput.focus(); });
      searchBtn.addEventListener('click', ()=>{ searchKey(keyInput.value.trim(),'search'); keyInput.focus(); });
      deleteBtn.addEventListener('click', ()=>{ searchKey(keyInput.value.trim(),'delete'); keyInput.focus(); });

      resetBtn.addEventListener('click', ()=>{
        if(!confirm('Reset table? All data will be cleared.')) return;
        initTable(tableSize);
      });

      sizeRange.addEventListener('input', (e)=>{
        const v = parseInt(e.target.value,10);
        sizeLabel.textContent = v;
      });
      sizeRange.addEventListener('change', (e)=>{
        const v = parseInt(e.target.value,10);
        if(!confirm('Changing table size will reset the table. Continue?')) {
          // revert display
          sizeRange.value = tableSize;
          sizeLabel.textContent = tableSize;
          return;
        }
        initTable(v);
      });

      // hash calc copy button
      calcToggle.addEventListener('click', ()=>{
        const text = hashCalc.textContent || '';
        if(!text || text === '--') { msg.textContent = 'No calculation to copy.'; return; }
        navigator.clipboard?.writeText(text).then(()=>{ msg.textContent = 'Hash calculation copied to clipboard.'; }, ()=>{ msg.textContent = 'Copy not supported.'; });
      });

      // keyboard: Enter triggers insert
      document.getElementById('actionForm').addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){
          e.preventDefault();
          insertBtn.click();
        }
      });

      // show calc live on key input
      keyInput.addEventListener('input', (e)=> showHashCalc(e.target.value));

      // initialize default
      initTable(tableSize);

      // For accessibility: allow focusing table-wrap to announce sizes
      tableWrap.addEventListener('focus', ()=>{ msg.textContent = `Table: ${tableSize} buckets, ${totalItems} items.`; });

      // Expose for debug (optional)
      window._hashMapVisualizer = {
        computeHashDetail,
        tableState: ()=>table
      };
    })();
  </script>
</body>
</html>