<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Module — Set (Venn Diagram & Operations)</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #3dd5ff;
      --muted: #94a3b8;
      --success: #9AE6B4;
      --danger: #FF9AA2;
      --glass: rgba(255,255,255,0.04);
      --token-size: 44px;
      --circle-size: min(43vmin, 360px);
      --transition: 300ms cubic-bezier(.2,.9,.25,1);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI",
                   Roboto, "Helvetica Neue", Arial;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071225 0%, #071223 60%, #031018 100%);
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding: var(--safe-margin);
      box-sizing: border-box;
    }

    /* Layout */
    .app {
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: var(--gap);
      height: calc(100% - calc(var(--safe-margin) * 2));
      min-height: 520px;
    }

    @media (max-width: 900px){
      .app { grid-template-columns: 1fr; grid-auto-rows: auto; }
    }

    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      min-height: 220px;
    }

    .info {
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .title {
      display:flex;
      gap:12px;
      align-items:center;
    }
    .logo {
      width:44px;height:44px;border-radius:10px;background:
      conic-gradient(from 120deg, var(--accent), #8defff, #8be7ff 70%); 
      box-shadow: 0 6px 18px rgba(60,200,255,0.08);
      display:flex;align-items:center;justify-content:center;font-weight:700;color:#022;
      font-size:20px;
    }
    h1 { margin:0;font-size:18px;line-height:1.05; }
    p.lead { margin:0;color:var(--muted);font-size:13px; }

    /* Controls */
    .controls { display:flex;flex-direction:column;gap:12px;margin-top:6px; }
    .row { display:flex;gap:12px;align-items:center;flex-wrap:wrap; }
    label.small { font-size:12px;color:var(--muted); }

    .btn {
      background: var(--glass);
      border:1px solid rgba(255,255,255,0.03);
      color:var(--accent);
      padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer;
      transition: all var(--transition);
      min-width:120px;text-align:center;
    }
    .btn:hover{ transform: translateY(-3px); box-shadow: 0 8px 28px rgba(3,100,140,0.12) }
    .btn.active { background: linear-gradient(90deg,#052936,#04303a); color:#bff7ff; border-color: rgba(80,220,255,0.12) }

    .op-grid { display:flex;gap:8px;flex-wrap:wrap; }
    .op { background:transparent;border:1px dashed rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer;min-width:110px;text-align:center; }
    .op:hover{ border-style:solid;color:var(--accent); }
    .op.active { border-style:solid;color:#022;background:linear-gradient(90deg,#8defff20,#8be7ff10); font-weight:700; }

    /* Venn area */
    .stage {
      position:relative;
      overflow:hidden;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));
      border-radius:12px;
      padding: 18px;
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      justify-content:center;
    }

    .venn-wrap{
      width:100%;
      min-height:520px;
      display:flex;
      justify-content:center;
      align-items:center;
      position:relative;
    }

    .circle {
      --c-size: var(--circle-size);
      width: var(--c-size);
      height: var(--c-size);
      border-radius:50%;
      position:absolute;
      top:50%;
      transform:translateY(-50%);
      box-shadow: inset 0 -30px 50px rgba(0,0,0,0.25);
      transition: box-shadow var(--transition);
      display:flex;align-items:center;justify-content:center;
      pointer-events: none;
    }
    .circle.A {
      left: 32%;
      background: radial-gradient(600px circle at 30% 30%, rgba(61,213,255,0.16), rgba(61,213,255,0.06) 45%, transparent 60%);
      border: 2px solid rgba(61,213,255,0.12);
    }
    .circle.B {
      left: 48%;
      background: radial-gradient(600px circle at 70% 25%, rgba(152,105,255,0.14), rgba(152,105,255,0.06) 45%, transparent 60%);
      border: 2px solid rgba(152,105,255,0.12);
    }

    .circle-label {
      position:absolute; top:12px; left:12px; font-weight:700; color:var(--muted);
      background:rgba(0,0,0,0.18); padding:6px 10px; border-radius:8px; font-size:13px;
      pointer-events:auto;
    }

    /* Tokens */
    .token {
      position:absolute;
      width:var(--token-size); height:var(--token-size); border-radius:10px;
      display:flex; align-items:center; justify-content:center;
      color:#071223; font-weight:700;
      cursor:grab; touch-action:none;
      user-select:none;
      transition: transform var(--transition), box-shadow var(--transition), opacity var(--transition);
      box-shadow: 0 6px 14px rgba(0,0,0,0.5);
      font-size:14px;
    }
    .token:active{ cursor:grabbing; transform:scale(1.02); }
    .token.fade { opacity:0.18; transform: scale(0.98); filter:grayscale(60%); }

    /* result area */
    .result {
      margin-top:12px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .pill {
      background: rgba(255,255,255,0.03);
      padding:8px 10px;border-radius:999px;color:var(--muted);
      font-size:13px;border:1px solid rgba(255,255,255,0.02);
    }

    /* pulse highlight */
    @keyframes pulse {
      0% { box-shadow: 0 8px 18px rgba(61,213,255,0.14), 0 0 0 0 rgba(61,213,255,0.0); transform:translateZ(0) scale(1); }
      50% { box-shadow: 0 18px 36px rgba(61,213,255,0.18), 0 0 0 8px rgba(61,213,255,0.04); transform: translateY(-4px) scale(1.03); }
      100% { box-shadow: 0 8px 18px rgba(61,213,255,0.14), 0 0 0 0 rgba(61,213,255,0.0); transform: translateZ(0) scale(1); }
    }
    .highlight {
      animation: pulse 900ms ease infinite;
      z-index: 30 !important;
      transform-origin: center;
    }

    /* small help */
    .help { font-size:13px; color:var(--muted); line-height:1.4; }

    /* accessible focus */
    button:focus, .op:focus { outline:3px solid rgba(61,213,255,0.08); outline-offset:3px; border-radius:8px; }

    /* responsive tuning */
    @media (max-width:900px){
      .venn-wrap{ min-height:420px; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Set interactive module">
    <!-- Left panel: explanation + controls -->
    <aside class="panel info" aria-labelledby="module-title">
      <div class="title">
        <div class="logo" aria-hidden="true">S</div>
        <div>
          <h1 id="module-title">Set — Venn Diagram & Operations</h1>
          <p class="lead">Interactively explore membership and set operations (union, intersection, difference) using draggable elements.</p>
        </div>
      </div>

      <div class="controls" aria-hidden="false">
        <div>
          <div class="row" style="align-items:flex-start;">
            <div style="flex:1">
              <label class="small" for="setAname">Set A name</label>
              <input id="setAname" type="text" value="A" style="width:100%;margin-top:6px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);" />
            </div>
            <div style="width:12px"></div>
            <div style="flex:1">
              <label class="small" for="setBname">Set B name</label>
              <input id="setBname" type="text" value="B" style="width:100%;margin-top:6px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted)" />
            </div>
          </div>
        </div>

        <div>
          <label class="small">Operations (click to highlight)</label>
          <div class="op-grid" role="tablist" aria-label="Set operations">
            <button class="op active" data-op="members" role="tab" aria-selected="true">Members</button>
            <button class="op" data-op="union" role="tab">A ∪ B (Union)</button>
            <button class="op" data-op="intersection" role="tab">A ∩ B (Intersection)</button>
            <button class="op" data-op="AdiffB" role="tab">A \ B (Difference)</button>
            <button class="op" data-op="BdiffA" role="tab">B \ A (Difference)</button>
            <button class="op" data-op="symdiff" role="tab">A △ B (Symm. Diff)</button>
          </div>
        </div>

        <div>
          <label class="small">Tokens — create or randomize</label>
          <div class="row" style="margin-top:8px;">
            <input id="newTokenLabel" type="text" placeholder="Label (e.g., x1)" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);flex:1" />
            <button class="btn" id="addToken">Add</button>
            <button class="btn" id="randomize">Shuffle</button>
          </div>
          <div class="help" style="margin-top:8px;">
            Drag tokens into the left circle (A), right circle (B), or the overlapping area to control membership. Keyboard: Tab to focus a token, arrow keys to nudge.
          </div>
        </div>

        <div>
          <div class="row" style="margin-top:6px;">
            <button class="btn" id="reset">Reset</button>
            <button class="btn" id="showResult">Show Result</button>
          </div>
          <div class="result" id="resultPills" aria-live="polite" style="margin-top:8px;">
            <div class="pill">Members: <span id="membersCount">0</span></div>
            <div class="pill">A: <span id="countA">0</span></div>
            <div class="pill">B: <span id="countB">0</span></div>
            <div class="pill">A ∩ B: <span id="countAB">0</span></div>
          </div>
        </div>
      </div>
    </aside>

    <!-- Right panel: interactive venn -->
    <main class="panel stage" role="main" aria-label="Interactive Venn diagram area">
      <div style="width:100%;display:flex;flex-direction:column;gap:12px;height:100%;">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div style="display:flex;gap:12px;flex-direction:column;">
            <div style="font-weight:700">Venn Diagram</div>
            <div style="font-size:13px;color:var(--muted)">Drag elements into circles to define set membership.</div>
          </div>
          <div style="display:flex;gap:10px;align-items:center;">
            <div class="pill" id="status" style="background:transparent;border:none;color:var(--muted);">Drag tokens into regions</div>
            <div class="pill" id="focusedToken" style="display:none;"></div>
          </div>
        </div>

        <div class="venn-wrap" id="venn" tabindex="0" aria-label="Venn diagram with draggable elements">
          <!-- Circles (A and B) -->
          <div class="circle A" id="circleA" aria-hidden="true">
            <div class="circle-label" id="labelA">A</div>
          </div>
          <div class="circle B" id="circleB" aria-hidden="true">
            <div class="circle-label" id="labelB">B</div>
          </div>

          <!-- tokens will be appended here by JS -->
        </div>

        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
          <div style="color:var(--muted);font-size:13px;">
            Tip: Elements belong to a set if their center lies inside the set circle. Overlap region = both.
          </div>
          <div style="display:flex;gap:10px;">
            <button class="btn" id="explain">Explain selection</button>
            <button class="btn" id="toggleLabels">Toggle token labels</button>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    // Self-contained interactive module for Set (Venn diagram + operations).
    (function(){
      // Utilities
      const qs = (s,ctx=document)=>ctx.querySelector(s);
      const qsa = (s,ctx=document)=>Array.from(ctx.querySelectorAll(s));
      const venn = qs('#venn');
      const circleA = qs('#circleA');
      const circleB = qs('#circleB');
      const labelA = qs('#labelA');
      const labelB = qs('#labelB');
      const setAname = qs('#setAname');
      const setBname = qs('#setBname');
      const ops = qsa('.op');
      const status = qs('#status');
      const resultCountA = qs('#countA');
      const resultCountB = qs('#countB');
      const resultCountAB = qs('#countAB');
      const membersCount = qs('#membersCount');
      const addTokenBtn = qs('#addToken');
      const randomizeBtn = qs('#randomize');
      const resetBtn = qs('#reset');
      const newTokenLabel = qs('#newTokenLabel');
      const showResultBtn = qs('#showResult');
      const explainBtn = qs('#explain');
      const toggleLabelsBtn = qs('#toggleLabels');
      const focusedTokenPill = qs('#focusedToken');

      let tokens = [];
      let currentOp = 'members';
      let showLabels = true;

      // ensure circles sized & positioned right relative to container
      function updateCircles(){
        const wrapRect = venn.getBoundingClientRect();
        // compute size based on CSS var --circle-size which was responsive
        const style = getComputedStyle(circleA);
        const size = parseFloat(style.width);
        const leftA = venn.offsetLeft + venn.clientWidth * 0.32;
        const leftB = venn.offsetLeft + venn.clientWidth * 0.48;
        // Position set labels
        labelA.textContent = setAname.value || 'A';
        labelB.textContent = setBname.value || 'B';
      }
      // membership check: is token center inside circle?
      function pointInCircle(px, py, circle){
        const rect = circle.getBoundingClientRect();
        const cx = rect.left + rect.width/2;
        const cy = rect.top + rect.height/2;
        const radius = rect.width/2;
        const dx = px - cx;
        const dy = py - cy;
        return dx*dx + dy*dy <= (radius*radius);
      }

      function computeMembership(tokenEl){
        const rect = tokenEl.getBoundingClientRect();
        const cx = rect.left + rect.width/2;
        const cy = rect.top + rect.height/2;
        const inA = pointInCircle(cx, cy, circleA);
        const inB = pointInCircle(cx, cy, circleB);
        return {inA, inB};
      }

      function updateCounts(){
        let a=0,b=0,ab=0,total=0;
        tokens.forEach(t=>{
          const m = computeMembership(t.el);
          if(m.inA) a++;
          if(m.inB) b++;
          if(m.inA && m.inB) ab++;
          if(m.inA || m.inB) total++;
        });
        resultCountA.textContent = a;
        resultCountB.textContent = b;
        resultCountAB.textContent = ab;
        membersCount.textContent = total;
      }

      // Highlight tokens according to currentOp
      function highlightForOp(op){
        currentOp = op;
        ops.forEach(o=>o.classList.toggle('active', o.dataset.op === op) );
        tokens.forEach(t=>{
          const {inA, inB} = computeMembership(t.el);
          let included=false;
          switch(op){
            case 'members':
              included = inA || inB;
              break;
            case 'union':
              included = inA || inB;
              break;
            case 'intersection':
              included = inA && inB;
              break;
            case 'AdiffB':
              included = inA && !inB;
              break;
            case 'BdiffA':
              included = inB && !inA;
              break;
            case 'symdiff':
              included = (inA && !inB) || (inB && !inA);
              break;
          }
          if(included){
            t.el.classList.remove('fade');
            t.el.classList.add('highlight');
          } else {
            t.el.classList.remove('highlight');
            t.el.classList.add('fade');
          }
        });
        updateCounts();
      }

      // Create a token
      function createToken(label, color, xPercent, yPercent){
        const el = document.createElement('button');
        el.className = 'token';
        el.type = 'button';
        el.textContent = showLabels ? label : '';
        el.setAttribute('aria-label', 'Element ' + label);
        el.style.background = color;
        el.style.left = (xPercent*100) + '%';
        el.style.top = (yPercent*100) + '%';
        el.style.transform = 'translate(-50%,-50%)';
        // set z-index based on creation order
        el.style.zIndex = 20 + tokens.length;
        // accessible focus
        el.tabIndex = 0;
        venn.appendChild(el);

        const token = {label, color, el};
        tokens.push(token);

        // pointer drag
        let isDragging = false;
        let offset = {x:0,y:0};

        function onPointerDown(e){
          e.preventDefault();
          isDragging = true;
          el.setPointerCapture(e.pointerId);
          const rect = el.getBoundingClientRect();
          offset.x = e.clientX - rect.left - rect.width/2;
          offset.y = e.clientY - rect.top - rect.height/2;
          el.style.transition = 'none';
          el.style.cursor = 'grabbing';
        }
        function onPointerMove(e){
          if(!isDragging) return;
          const parentRect = venn.getBoundingClientRect();
          let left = ((e.clientX - parentRect.left - offset.x) / parentRect.width) * 100;
          let top = ((e.clientY - parentRect.top - offset.y) / parentRect.height) * 100;
          // clamp to 3%..97%
          left = Math.max(3, Math.min(97, left));
          top = Math.max(3, Math.min(97, top));
          el.style.left = left + '%';
          el.style.top = top + '%';
          updateCounts();
        }
        function onPointerUp(e){
          if(!isDragging) return;
          isDragging = false;
          el.releasePointerCapture && el.releasePointerCapture(e.pointerId);
          el.style.transition = '';
          el.style.cursor = 'grab';
          updateCounts();
          highlightForOp(currentOp); // refresh highlight
        }

        // keyboard nudge
        function onKeyDown(e){
          // allow delete/backspace to remove
          if(e.key === 'Delete' || e.key === 'Backspace'){
            removeToken(token);
            return;
          }
          const step = e.shiftKey ? 4 : 2;
          const parentRect = venn.getBoundingClientRect();
          const elRect = el.getBoundingClientRect();
          let left = (elRect.left + elRect.width/2 - parentRect.left) / parentRect.width * 100;
          let top = (elRect.top + elRect.height/2 - parentRect.top) / parentRect.height * 100;
          if(e.key === 'ArrowLeft'){ left -= step; }
          if(e.key === 'ArrowRight'){ left += step; }
          if(e.key === 'ArrowUp'){ top -= step; }
          if(e.key === 'ArrowDown'){ top += step; }
          left = Math.max(3, Math.min(97, left));
          top = Math.max(3, Math.min(97, top));
          el.style.left = left + '%';
          el.style.top = top + '%';
          updateCounts();
          highlightForOp(currentOp);
        }

        el.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
        el.addEventListener('keydown', onKeyDown);

        // focus/blur showing which token is focused
        el.addEventListener('focus', ()=>{
          focusedTokenPill.style.display = 'inline-block';
          focusedTokenPill.textContent = label;
        });
        el.addEventListener('blur', ()=>{
          focusedTokenPill.style.display = 'none';
        });

        // initial highlight state
        highlightForOp(currentOp);
        updateCounts();
        return token;
      }

      function removeToken(token){
        token.el.remove();
        tokens = tokens.filter(t=>t!==token);
        updateCounts();
        highlightForOp(currentOp);
      }

      // initial seeds
      const colors = ['#8DEFFF','#9AE6B4','#FFBE7D','#FF9AA2','#C8B6FF','#FFD97D','#7BE0FF'];
      function seedTokens(){
        // remove existing
        tokens.slice().forEach(t=>removeToken(t));
        const initial = ['a','b','c','d','e','f'];
        for(let i=0;i<initial.length;i++){
          const x = 30 + Math.random()*40;
          const y = 30 + Math.random()*30;
          createToken(initial[i].toUpperCase(), colors[i % colors.length], x/100, y/100);
        }
        // reposition a couple into overlap area for demonstration
        // set some positions within overlap area (center)
        const centerX = 40 + Math.random()*10;
        const centerY = 45 + Math.random()*12;
        // move 'C' and 'D' into overlap
        const found = tokens.slice(0,2);
        found.forEach((t, idx)=>{
          t.el.style.left = (45 + idx*6) + '%';
          t.el.style.top = (46 + idx*4) + '%';
        });

        highlightForOp(currentOp);
      }

      // operation buttons
      ops.forEach(op=>{
        op.addEventListener('click', ()=>{
          highlightForOp(op.dataset.op);
        });
      });

      // add token
      addTokenBtn.addEventListener('click', ()=>{
        const label = newTokenLabel.value.trim() || ('x' + (tokens.length + 1));
        const color = colors[Math.floor(Math.random()*colors.length)];
        // default spawn near center
        createToken(label, color, 48 + (Math.random()-0.5)*10, 48 + (Math.random()-0.5)*10);
        newTokenLabel.value = '';
        highlightForOp(currentOp);
      });

      // randomize/shuffle placement
      randomizeBtn.addEventListener('click', ()=>{
        tokens.forEach((t,i)=>{
          const left = 20 + Math.random()*60;
          const top = 20 + Math.random()*60;
          t.el.style.left = left + '%';
          t.el.style.top = top + '%';
        });
        updateCounts();
        highlightForOp(currentOp);
      });

      // reset
      resetBtn.addEventListener('click', ()=>{
        seedTokens();
      });

      // show result: animate tokens that belong to operation into a result row (brief)
      showResultBtn.addEventListener('click', ()=>{
        const op = currentOp;
        // Build result list
        const members = tokens.filter(t=>{
          const m = computeMembership(t.el);
          if(op==='members' || op==='union') return m.inA || m.inB;
          if(op==='intersection') return m.inA && m.inB;
          if(op==='AdiffB') return m.inA && !m.inB;
          if(op==='BdiffA') return m.inB && !m.inA;
          if(op==='symdiff') return (m.inA && !m.inB) || (m.inB && !m.inA);
          return false;
        });
        if(members.length === 0){
          status.textContent = 'Result: ∅ (empty set)';
          return;
        }
        status.textContent = 'Animating result...';
        // animate each member outward slightly and back to emphasize
        members.forEach((t,idx)=>{
          setTimeout(()=>{
            t.el.style.transition = 'transform 420ms cubic-bezier(.2,.9,.25,1), box-shadow 420ms';
            t.el.style.transform += ' translateY(-14px) scale(1.06)';
            t.el.style.boxShadow = '0 20px 40px rgba(0,0,0,0.6)';
            setTimeout(()=>{
              t.el.style.transform = t.el.style.transform.replace(' translateY(-14px) scale(1.06)','');
              t.el.style.boxShadow = '';
            }, 420);
          }, idx * 90);
        });
        setTimeout(()=>{ status.textContent = 'Result: ' + members.map(m=>m.label).join(', '); }, members.length*90 + 420);
      });

      // explanatory button toggles a quick explanation
      explainBtn.addEventListener('click', ()=>{
        alert('Membership is determined by the center of a token lying inside a circle.\n\n- Put a token inside A to belong to A.\n- Put it in B to belong to B.\n- Put it in the overlap to belong to both (A ∩ B).\n\nUse the operation buttons to highlight which elements satisfy each operation.');
      });

      toggleLabelsBtn.addEventListener('click', ()=>{
        showLabels = !showLabels;
        tokens.forEach(t=>t.el.textContent = showLabels ? t.label : '');
      });

      // name inputs update labels
      setAname.addEventListener('input', ()=>{ labelA.textContent = setAname.value || 'A'; });
      setBname.addEventListener('input', ()=>{ labelB.textContent = setBname.value || 'B'; });

      // On load
      window.addEventListener('resize', ()=>{ updateCircles(); highlightForOp(currentOp); });
      window.addEventListener('load', ()=>{
        updateCircles();
        seedTokens();
        highlightForOp('members');
        // subtle initial animation
        setTimeout(()=>{ venn.animate([{opacity:0.96},{opacity:1}],{duration:600,fill:'forwards'}); }, 150);
      });

      // accessibility: keyboard focus on venn area to move tokens via tab
      // Also allow double-press of Enter on focused token to toggle label visibility (as example)
      venn.addEventListener('keydown', (e)=>{
        if(e.key === 'Tab') return;
      });

      // Basic collision prevention (soft): when two tokens very close, nudge
      function avoidOverlap(){
        for(let i=0;i<tokens.length;i++){
          for(let j=i+1;j<tokens.length;j++){
            const a = tokens[i].el.getBoundingClientRect();
            const b = tokens[j].el.getBoundingClientRect();
            const dx = (a.left + a.width/2) - (b.left + b.width/2);
            const dy = (a.top + a.height/2) - (b.top + b.height/2);
            const dist = Math.sqrt(dx*dx + dy*dy);
            const minDist = a.width * 0.9;
            if(dist < minDist){
              // push them apart slightly
              const ux = dx / (dist || 1);
              const uy = dy / (dist || 1);
              const parentRect = venn.getBoundingClientRect();
              let leftA = (a.left + a.width/2 - parentRect.left) / parentRect.width * 100;
              let topA = (a.top + a.height/2 - parentRect.top) / parentRect.height * 100;
              let leftB = (b.left + b.width/2 - parentRect.left) / parentRect.width * 100;
              let topB = (b.top + b.height/2 - parentRect.top) / parentRect.height * 100;
              leftA += ux * 2;
              topA += uy * 2;
              leftB -= ux * 2;
              topB -= uy * 2;
              leftA = Math.max(3, Math.min(97, leftA));
              topA = Math.max(3, Math.min(97, topA));
              leftB = Math.max(3, Math.min(97, leftB));
              topB = Math.max(3, Math.min(97, topB));
              tokens[i].el.style.left = leftA + '%';
              tokens[i].el.style.top = topA + '%';
              tokens[j].el.style.left = leftB + '%';
              tokens[j].el.style.top = topB + '%';
            }
          }
        }
      }
      // run avoidOverlap occasionally while dragging
      setInterval(()=>{ avoidOverlap(); updateCounts(); }, 400);

    })();
  </script>
</body>
</html>