<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Adjacency Matrix — Interactive Module</title>
  <style>
    :root{
      --safe-pad: 24px;
      --gap: 16px;
      --accent: #1e88e5;
      --muted: #6b7280;
      --bg: #f7fafc;
      --card: #ffffff;
      --success: #16a34a;
      --danger: #ef4444;
      --cell-size: 44px;
      --node-size: 44px;
    }

    /* Safe area margins */
    html,body{height:100%}
    body{
      margin:0;
      padding:var(--safe-pad);
      box-sizing:border-box;
      font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#fbfdff 0%, #f0f6fb 100%);
      color:#0f172a;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Layout */
    .container{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
    }

    /* Left column: description and controls */
    .panel{
      width:360px;
      min-width:280px;
      background:var(--card);
      border-radius:12px;
      padding:20px;
      box-shadow:0 6px 18px rgba(14,30,37,0.06);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      flex-shrink:0;
    }

    h1{
      margin:0;
      font-size:18px;
      line-height:1.2;
    }

    .muted{
      color:var(--muted);
      font-size:13px;
    }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:var(--gap);
    }

    button, .segmented button{
      background:transparent;
      border:1px solid #e6eef8;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
      color:#0b1220;
      transition:all .18s ease;
    }
    button:hover{ transform: translateY(-2px); box-shadow:0 6px 14px rgba(30,136,229,0.09); }
    button.primary{
      background:linear-gradient(180deg,var(--accent), #1565c0);
      color:white;
      border:0;
    }

    .segmented{
      display:flex;
      gap:8px;
      background: #f8fbff;
      padding:6px;
      border-radius:10px;
      border:1px solid #edf5ff;
    }

    label.switch{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      cursor:pointer;
      user-select:none;
    }
    input[type="checkbox"]{ width:18px;height:18px; }

    .info{
      background:#fbfdff;
      padding:12px;
      border-radius:10px;
      font-size:13px;
      border:1px solid #eef6ff;
    }

    /* Right column: interactive canvas and matrix */
    .workspace{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      min-width:0;
    }

    .canvas-card{
      background:var(--card);
      border-radius:12px;
      padding:16px;
      box-shadow:0 6px 18px rgba(14,30,37,0.04);
      display:flex;
      gap:var(--gap);
      align-items:stretch;
      min-height:240px;
    }

    /* Graph area + side info */
    .graph-area{
      flex:1;
      display:flex;
      gap:var(--gap);
      align-items:stretch;
      min-height:200px;
    }

    .svg-area{
      background:linear-gradient(180deg,#ffffff,#fbfdff);
      border-radius:10px;
      border:1px dashed #e6eef8;
      padding:12px;
      flex:1;
      position:relative;
      min-height:220px;
      overflow:hidden;
    }

    svg{ width:100%; height:100%; display:block; }

    .side-meta{
      width:200px;
      min-width:160px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .meta-block{
      background:#fff;
      padding:12px;
      border-radius:10px;
      border:1px solid #f1f5f9;
      font-size:13px;
    }

    .matrix-card{
      background:var(--card);
      border-radius:12px;
      padding:12px;
      box-shadow:0 6px 14px rgba(14,30,37,0.03);
      overflow:auto;
    }

    table.adj{
      border-collapse:collapse;
      margin:8px 0;
      user-select:none;
    }

    table.adj th{
      padding:6px;
      text-align:center;
      color:var(--muted);
      font-size:12px;
      min-width:var(--cell-size);
    }

    table.adj td{
      padding:0;
      margin:0;
    }

    .cell-btn{
      width:var(--cell-size);
      height:var(--cell-size);
      border:1px solid #eef2f7;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:13px;
      cursor:pointer;
      background:transparent;
      transition:background .16s ease,transform .08s ease;
    }
    .cell-btn:focus{ outline:2px solid rgba(30,136,229,0.18); transform:translateY(-2px); }
    .cell-btn.active{
      background:linear-gradient(90deg, rgba(30,136,229,0.08), rgba(30,136,229,0.04));
      border-color:rgba(30,136,229,0.22);
      box-shadow:0 6px 12px rgba(30,136,229,0.06);
      color:var(--accent);
    }

    .cell-weight{
      font-size:12px;
      color:#0b1220;
    }

    /* matrix flash animation */
    @keyframes flash {
      0%{ background: #fff8b3; }
      100%{ background: transparent; }
    }

    .flash{ animation: flash .8s ease forwards; }

    /* node styling inside SVG */
    .node{
      cursor:grab;
      transition:transform .12s ease;
    }
    .node:active{ cursor:grabbing; transform:scale(1.03); }

    .node-circle{
      fill: #ffffff;
      stroke:#1e293b;
      stroke-width:1.4;
      filter: drop-shadow(0 6px 12px rgba(2,6,23,0.06));
    }
    .node-label{ font-size:12px; fill:#0b1220; pointer-events:none; font-weight:600; }

    .edge-line{
      stroke:#93c5fd;
      stroke-width:2.2;
      fill:none;
      transition:stroke .16s ease, stroke-width .16s ease, opacity .16s ease;
      opacity:0.95;
    }

    .edge-line.strong{
      stroke:#1e90ff;
      stroke-width:3.6;
    }

    .edge-weight{
      font-size:11px;
      fill:#08306b;
      font-weight:600;
      pointer-events:none;
    }

    .highlight{
      stroke:#f59e0b !important;
      stroke-width:3.6 !important;
    }

    /* responsive layout */
    @media (max-width:980px){
      .container{ flex-direction:column; }
      .panel{ width:100%; min-width:0; }
      .side-meta{ width:140px; }
    }

    /* accessibility helpers */
    .sr-only{ position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }
    .status{ font-size:13px; color:var(--muted); }
    .small{ font-size:12px; color:var(--muted); }
    input[type="number"]{ padding:8px; border-radius:8px; border:1px solid #eef2f7; width:100%; }
    .modal{
      position:fixed;
      left:0; right:0; top:0; bottom:0;
      display:flex; align-items:center; justify-content:center;
      background:rgba(2,6,23,0.4);
      z-index:30;
    }
    .modal-card{
      background:white; padding:18px; border-radius:10px; min-width:280px;
      box-shadow:0 10px 30px rgba(2,6,23,0.2);
    }

  </style>
</head>
<body>
  <div class="container" role="main">

    <!-- Left Panel: Description and Controls -->
    <aside class="panel" aria-labelledby="title">
      <h1 id="title">Adjacency Matrix — Interactive Module</h1>
      <div class="muted">Explore how a graph is represented as an adjacency matrix and how changes in the graph reflect in its matrix — and vice versa.</div>

      <div class="info" aria-live="polite">
        <strong>Concept:</strong> Adjacency Matrix — a square matrix used to represent edges between nodes in a graph. Cells show presence (and optionally weight) of an edge between row node and column node.
      </div>

      <!-- Learning Objective -->
      <div>
        <strong>Learning Objective</strong>
        <div class="small" style="margin-top:8px;">
          After interacting you should be able to:
          <ul style="margin:8px 0 0 18px; padding:0;">
            <li>Map between a visual graph and its adjacency matrix.</li>
            <li>Understand how directed vs undirected graphs affect symmetry.</li>
            <li>See how weights alter numeric entries.</li>
          </ul>
        </div>
      </div>

      <!-- Interaction Design explanation -->
      <div>
        <strong>Interaction Design</strong>
        <div class="small" style="margin-top:8px;">
          - Drag nodes to rearrange the graph. <br />
          - Click cells in the adjacency matrix to toggle connections (or set weight). <br />
          - Click nodes to select them for quick edge creation. <br />
          - Toggle Directed / Weighted modes. <br />
          Visual highlights and smooth animations show corresponding changes.
        </div>
      </div>

      <!-- Controls -->
      <div>
        <strong>Controls</strong>
        <div class="controls" style="margin-top:8px;">
          <button id="addNodeBtn" title="Add a node">Add Node</button>
          <button id="removeNodeBtn" title="Remove last node">Remove Node</button>
          <button id="randomBtn" title="Randomize">Random</button>
          <div class="segmented" role="toolbar" aria-label="modes">
            <label class="switch" title="Toggle directed">
              <input type="checkbox" id="directedToggle" />
              Directed
            </label>
            <label class="switch" title="Toggle weighted">
              <input type="checkbox" id="weightedToggle" />
              Weighted
            </label>
          </div>
          <button id="resetBtn" title="Reset">Reset</button>
        </div>

        <div style="margin-top:12px; display:flex; gap:12px;">
          <button id="exportBtn" title="Export adjacency matrix">Export</button>
          <button id="clearEdgesBtn" title="Clear edges">Clear Edges</button>
        </div>
      </div>

      <div class="meta-block" aria-live="polite">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div><strong>Graph stats</strong></div>
          <div class="small" id="nodeCount">Nodes: 0</div>
        </div>
        <div style="margin-top:8px;">
          <div class="small" id="edgeCount">Edges: 0</div>
          <div class="small" id="modeInfo" style="margin-top:6px;"></div>
        </div>
      </div>

      <div class="meta-block">
        <strong>How to use</strong>
        <div class="small" style="margin-top:8px;">
          - Click a matrix cell to toggle an edge. If Weighted is on, you'll be asked for a weight. <br />
          - Hover a node or matrix row/column to highlight associated edges. <br />
          - Select a node, then click another node to create an edge quickly.
        </div>
      </div>

    </aside>

    <!-- Right: Interactive Workspace -->
    <section class="workspace" aria-label="Interactive adjacency matrix module">
      <div class="canvas-card" role="region" aria-label="Graph area">
        <div class="graph-area">
          <div class="svg-area" id="svgArea" tabindex="0" aria-label="Graph canvas. Drag nodes to move them.">
            <!-- SVG will be injected here -->
            <svg id="graphSvg" viewBox="0 0 800 480" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Graph visualization"></svg>
          </div>

          <aside class="side-meta" aria-hidden="false">
            <div class="meta-block">
              <strong>Selection</strong>
              <div id="selectionInfo" style="margin-top:8px;" class="small">None</div>
            </div>

            <div class="meta-block">
              <strong>Node degrees</strong>
              <div id="degreeList" style="margin-top:8px;" class="small">—</div>
            </div>
          </aside>
        </div>
      </div>

      <div class="matrix-card" role="region" aria-label="Adjacency matrix">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div><strong>Adjacency Matrix</strong><span class="small" style="margin-left:8px" id="matrixMode"> (unweighted)</span></div>
          <div class="status" id="matrixStatus">Click a cell to toggle an edge</div>
        </div>

        <div id="matrixContainer" style="margin-top:12px; overflow:auto;"></div>
      </div>
    </section>

  </div>

  <!-- Weight modal -->
  <div id="weightModal" class="modal" style="display:none;" role="dialog" aria-modal="true" aria-labelledby="weightTitle">
    <div class="modal-card">
      <div id="weightTitle"><strong>Set edge weight</strong></div>
      <div style="margin-top:12px;">
        <input id="weightInput" type="number" min="0" step="1" value="1" aria-label="weight" />
      </div>
      <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:12px;">
        <button id="weightCancel">Cancel</button>
        <button id="weightOk" class="primary">OK</button>
      </div>
    </div>
  </div>

  <script>
    /*
      Adjacency Matrix Interactive Module
      - Vanilla JS, self-contained
      - Draggable nodes, click matrix to toggle edge
      - Directed / Weighted modes
      - Accessible and responsive
    */

    // State
    const state = {
      nodes: [], // {id, x, y}
      adj: [], // 2D array: null or weight (1 for unweighted)
      directed: false,
      weighted: false,
      selectedNode: null, // id
      svgSize: {w:800, h:480}
    };

    // DOM refs
    const svg = document.getElementById('graphSvg');
    const svgArea = document.getElementById('svgArea');
    const matrixContainer = document.getElementById('matrixContainer');
    const nodeCount = document.getElementById('nodeCount');
    const edgeCount = document.getElementById('edgeCount');
    const modeInfo = document.getElementById('modeInfo');
    const matrixMode = document.getElementById('matrixMode');
    const matrixStatus = document.getElementById('matrixStatus');
    const selectionInfo = document.getElementById('selectionInfo');
    const degreeList = document.getElementById('degreeList');

    // Controls
    const addNodeBtn = document.getElementById('addNodeBtn');
    const removeNodeBtn = document.getElementById('removeNodeBtn');
    const resetBtn = document.getElementById('resetBtn');
    const randomBtn = document.getElementById('randomBtn');
    const exportBtn = document.getElementById('exportBtn');
    const clearEdgesBtn = document.getElementById('clearEdgesBtn');
    const directedToggle = document.getElementById('directedToggle');
    const weightedToggle = document.getElementById('weightedToggle');

    // Weight modal
    const weightModal = document.getElementById('weightModal');
    const weightInput = document.getElementById('weightInput');
    const weightOk = document.getElementById('weightOk');
    const weightCancel = document.getElementById('weightCancel');

    // Constants
    const NODE_SIZE = 44;
    const PADDING = 20;
    const MIN_SPACING = 16;
    const MAX_NODES = 12;

    // Initialize
    function init(){
      // Start with 4 nodes in a circle
      for(let i=0;i<4;i++) addNode();
      renderAll();
      attachListeners();
      updateModeInfo();
    }

    // Add node
    function addNode(){
      if(state.nodes.length >= MAX_NODES) return alert('Max nodes: ' + MAX_NODES);
      const id = state.nodes.length;
      const w = state.svgSize.w;
      const h = state.svgSize.h;
      // place nodes in a circle
      const a = (state.nodes.length / Math.max(4, state.nodes.length+1)) * Math.PI * 2;
      const r = Math.min(w,h) * 0.32;
      const cx = w/2 + Math.cos(a) * r * (0.9 - Math.random()*0.2);
      const cy = h/2 + Math.sin(a) * r * (0.9 - Math.random()*0.2);
      state.nodes.push({id, x: cx, y: cy});
      // expand adj
      state.adj.forEach(row => row.push(null));
      const newRow = new Array(state.nodes.length).fill(null);
      state.adj.push(newRow);
      renderAll();
    }

    // Remove last node
    function removeNode(){
      if(state.nodes.length === 0) return;
      const id = state.nodes.length -1;
      state.nodes.pop();
      state.adj.pop();
      state.adj.forEach(row => row.splice(id,1));
      if(state.selectedNode === id) state.selectedNode = null;
      renderAll();
    }

    // Clear edges
    function clearEdges(){
      for(let i=0;i<state.adj.length;i++){
        for(let j=0;j<state.adj.length;j++){
          state.adj[i][j] = null;
        }
      }
      renderAll(true);
    }

    // Reset full
    function reset(){
      state.nodes = [];
      state.adj = [];
      state.selectedNode = null;
      for(let i=0;i<4;i++) addNode();
      renderAll();
    }

    // Randomize edges
    function randomize(){
      clearEdges();
      for(let i=0;i<state.nodes.length;i++){
        for(let j=0;j<state.nodes.length;j++){
          if(i===j) continue;
          if(Math.random() < 0.3){
            const w = state.weighted ? Math.ceil(Math.random()*9) : 1;
            state.adj[i][j] = w;
            if(!state.directed) state.adj[j][i] = w;
          }
        }
      }
      renderAll();
    }

    // Toggle edge via indices (from matrix or programmatic)
    function toggleEdge(i,j, setWeight=null){
      // If weighted and setWeight is null, ask
      if(state.weighted && setWeight === null){
        openWeightModal((val)=>{
          applyEdge(i,j,val);
        }, ()=>{
          // cancelled
        });
      } else {
        applyEdge(i,j,setWeight);
      }
    }

    function applyEdge(i,j, weight){
      const exists = !!state.adj[i][j];
      if(exists){
        // remove
        state.adj[i][j] = null;
        if(!state.directed) state.adj[j][i] = null;
      } else {
        const w = state.weighted ? (weight || 1) : 1;
        state.adj[i][j] = w;
        if(!state.directed) state.adj[j][i] = w;
      }
      renderAll(true, {highlightCell:[i,j]});
    }

    // Export adjacency matrix text
    function exportMatrix(){
      let lines = [];
      for(let i=0;i<state.adj.length;i++){
        lines.push(state.adj[i].map(v => v === null ? 0 : v).join(' '));
      }
      const text = lines.join('\n');
      prompt('Adjacency matrix (rows = source, columns = target):', text);
    }

    // Create/update SVG
    function renderGraph(){
      // clear
      while(svg.firstChild) svg.removeChild(svg.firstChild);

      const n = state.nodes.length;
      // defs for arrow marker
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
      marker.setAttribute('id','arrowhead');
      marker.setAttribute('markerWidth','10');
      marker.setAttribute('markerHeight','8');
      marker.setAttribute('refX','10');
      marker.setAttribute('refY','4');
      marker.setAttribute('orient','auto');
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d','M0,0 L10,4 L0,8 z');
      path.setAttribute('fill','#1e90ff');
      marker.appendChild(path);
      defs.appendChild(marker);
      svg.appendChild(defs);

      // Edges: create lines first so nodes are on top
      for(let i=0;i<n;i++){
        for(let j=0;j<n;j++){
          const w = state.adj[i][j];
          if(w === null) continue;
          const a = state.nodes[i];
          const b = state.nodes[j];
          const line = document.createElementNS('http://www.w3.org/2000/svg','path');
          line.classList.add('edge-line');
          if(state.weighted && w > 1) line.classList.add('strong');
          const d = linePath(a.x, a.y, b.x, b.y, NODE_SIZE/2);
          line.setAttribute('d', d);
          line.dataset.from = i;
          line.dataset.to = j;
          if(state.directed){
            line.setAttribute('marker-end','url(#arrowhead)');
          }
          // add click to select edge
          line.addEventListener('mouseenter', ()=> highlightMatrixCell(i,j));
          line.addEventListener('mouseleave', ()=> clearHighlights());
          line.addEventListener('click', (e)=>{
            e.stopPropagation();
            // toggle via click
            toggleEdge(i,j);
          });
          svg.appendChild(line);

          if(state.weighted){
            const mid = midPointOnPath(a.x, a.y, b.x, b.y, 0.5);
            const text = document.createElementNS('http://www.w3.org/2000/svg','text');
            text.classList.add('edge-weight');
            text.setAttribute('x', mid.x);
            text.setAttribute('y', mid.y - 8);
            text.setAttribute('text-anchor','middle');
            text.textContent = w;
            svg.appendChild(text);
          }
        }
      }

      // Nodes
      state.nodes.forEach(node => {
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('transform', `translate(${node.x},${node.y})`);
        g.dataset.id = node.id;
        g.classList.add('node');
        g.setAttribute('role','button');
        g.setAttribute('tabindex','0');
        g.setAttribute('aria-label','Node ' + node.id);

        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('r', NODE_SIZE/2 - 2);
        circle.classList.add('node-circle');

        const label = document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('y',4);
        label.setAttribute('text-anchor','middle');
        label.classList.add('node-label');
        label.textContent = node.id;

        g.appendChild(circle);
        g.appendChild(label);

        // Events: drag, click
        makeDraggable(g, node);

        g.addEventListener('click', (e)=>{
          e.stopPropagation();
          onNodeClick(node.id);
        });

        g.addEventListener('mouseenter', ()=>{
          highlightNode(node.id);
          highlightMatrixRowCol(node.id);
        });
        g.addEventListener('mouseleave', ()=> clearHighlights());

        svg.appendChild(g);
      });

      // update counts
      nodeCount.textContent = 'Nodes: ' + state.nodes.length;
      const edges = countEdges();
      edgeCount.textContent = 'Edges: ' + edges;
      updateDegreeList();
    }

    // Create path between two nodes with small offset to avoid node overlap
    function linePath(x1,y1,x2,y2,offset){
      // Straight line for simplicity. We shorten endpoints by offset.
      const dx = x2-x1, dy = y2-y1, L = Math.hypot(dx,dy) || 1;
      const ux = dx / L, uy = dy / L;
      const sx = x1 + ux*offset, sy = y1 + uy*offset;
      const ex = x2 - ux*offset, ey = y2 - uy*offset;
      return `M ${sx} ${sy} L ${ex} ${ey}`;
    }

    function midPointOnPath(x1,y1,x2,y2,t){
      const x = x1 + (x2-x1)*t;
      const y = y1 + (y2-y1)*t;
      return {x,y};
    }

    // Matrix rendering
    function renderMatrix(highlightCell = null){
      const n = state.nodes.length;
      matrixContainer.innerHTML = ''; // clear

      const table = document.createElement('table');
      table.classList.add('adj');
      table.setAttribute('role','grid');
      table.setAttribute('aria-label','Adjacency matrix');

      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      const cornerTh = document.createElement('th');
      cornerTh.textContent = '';
      headRow.appendChild(cornerTh);
      for(let j=0;j<n;j++){
        const th = document.createElement('th');
        th.textContent = j;
        th.setAttribute('scope','col');
        headRow.appendChild(th);
      }
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      for(let i=0;i<n;i++){
        const tr = document.createElement('tr');
        const rowTh = document.createElement('th');
        rowTh.textContent = i;
        rowTh.setAttribute('scope','row');
        tr.appendChild(rowTh);
        for(let j=0;j<n;j++){
          const td = document.createElement('td');
          const btn = document.createElement('button');
          btn.classList.add('cell-btn');
          btn.setAttribute('tabindex','0');
          btn.setAttribute('aria-label',`Cell ${i}, ${j}`);
          const val = state.adj[i][j];
          if(val !== null){
            btn.classList.add('active');
            btn.innerHTML = `<span class="cell-weight">${val}</span>`;
          } else {
            btn.innerHTML = `<span class="cell-weight">0</span>`;
          }
          btn.addEventListener('click', (e)=>{
            e.stopPropagation();
            // toggle or set
            if(state.weighted){
              openWeightModal((w)=>{
                toggleCellWithWeight(i,j,w);
              }, ()=>{/*cancel*/});
            } else {
              toggleEdge(i,j);
            }
          });
          btn.addEventListener('mouseenter', ()=>{
            highlightMatrixRowCol(i,j);
            highlightEdgeSvg(i,j);
          });
          btn.addEventListener('mouseleave', ()=> clearHighlights());

          // keyboard: Enter toggles
          btn.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter' || e.key === ' '){
              e.preventDefault();
              btn.click();
            }
          });

          // store coords
          btn.dataset.i = i; btn.dataset.j = j;

          td.appendChild(btn);
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      matrixContainer.appendChild(table);

      // flash highlight if requested
      if(highlightCell){
        const [i,j] = highlightCell;
        setTimeout(()=> flashCell(i,j), 20);
      }
    }

    function toggleCellWithWeight(i,j,w){
      const exists = !!state.adj[i][j];
      if(exists){
        // remove
        state.adj[i][j] = null;
        if(!state.directed) state.adj[j][i] = null;
      } else {
        const val = Number(w) || 1;
        state.adj[i][j] = val;
        if(!state.directed) state.adj[j][i] = val;
      }
      renderAll(true, {highlightCell:[i,j]});
    }

    // Flash cell animation
    function flashCell(i,j){
      const table = matrixContainer.querySelector('table');
      if(!table) return;
      const row = table.tBodies[0].rows[i];
      const cell = row.cells[j];
      const btn = cell.firstChild;
      btn.classList.add('flash');
      setTimeout(()=> btn.classList.remove('flash'), 900);
    }

    // Highlight helpers
    function highlightMatrixRowCol(i,j){
      const table = matrixContainer.querySelector('table');
      if(!table) return;
      // highlight row and column by adding class to corresponding buttons
      for(let r=0;r<table.tBodies[0].rows.length;r++){
        for(let c=0;c<table.tBodies[0].rows[r].cells.length;c++){
          const btn = table.tBodies[0].rows[r].cells[c].firstChild;
          btn.style.outline = '';
          if(r === i || c === j || r===j || c===i){
            btn.style.outline = '2px dashed rgba(30,136,229,0.12)';
          } else {
            btn.style.outline = '';
          }
        }
      }
    }

    function highlightMatrixCell(i,j){
      const table = matrixContainer.querySelector('table');
      if(!table) return;
      const btn = table.tBodies[0].rows[i].cells[j].firstChild;
      btn.style.boxShadow = '0 10px 22px rgba(30,136,229,0.08)';
    }

    function highlightEdgeSvg(i,j){
      Array.from(svg.querySelectorAll('.edge-line')).forEach(line=>{
        if(Number(line.dataset.from) === i && Number(line.dataset.to) === j){
          line.classList.add('highlight');
          setTimeout(()=> line.classList.remove('highlight'), 700);
        }
      });
    }

    function highlightNode(nodeId){
      Array.from(svg.querySelectorAll('.node')).forEach(g=>{
        if(Number(g.dataset.id) === nodeId){
          g.querySelector('circle').classList.add('highlight');
          setTimeout(()=> g.querySelector('circle').classList.remove('highlight'), 600);
        }
      });
    }

    function clearHighlights(){
      // clear matrix outlines
      const table = matrixContainer.querySelector('table');
      if(table){
        for(let r=0;r<table.tBodies[0].rows.length;r++){
          for(let c=0;c<table.tBodies[0].rows[r].cells.length;c++){
            const btn = table.tBodies[0].rows[r].cells[c].firstChild;
            btn.style.outline = '';
            btn.style.boxShadow = '';
          }
        }
      }
      // clear svg highlights
      Array.from(svg.querySelectorAll('.edge-line.highlight')).forEach(el=> el.classList.remove('highlight'));
    }

    // Edge count
    function countEdges(){
      let c=0;
      for(let i=0;i<state.adj.length;i++){
        for(let j=0;j<state.adj.length;j++){
          if(state.adj[i][j] !== null) c++;
        }
      }
      if(!state.directed) c = c/2;
      return c;
    }

    // Degrees
    function updateDegreeList(){
      const n = state.nodes.length;
      if(n === 0){ degreeList.textContent = '—'; return; }
      let lines = [];
      for(let i=0;i<n;i++){
        if(state.directed){
          let indeg = 0, outdeg = 0;
          for(let j=0;j<n;j++){
            if(state.adj[j][i] !== null) indeg++;
            if(state.adj[i][j] !== null) outdeg++;
          }
          lines.push(`Node ${i}: in ${indeg}, out ${outdeg}`);
        } else {
          let deg = 0;
          for(let j=0;j<n;j++) if(state.adj[i][j] !== null) deg++;
          lines.push(`Node ${i}: degree ${deg}`);
        }
      }
      degreeList.innerHTML = lines.join('<br/>');
    }

    // Node click: select then clicking another node creates edge
    function onNodeClick(id){
      if(state.selectedNode === null){
        state.selectedNode = id;
        selectionInfo.textContent = 'Selected: ' + id + ' — click another node to connect';
      } else if(state.selectedNode === id){
        // deselect
        state.selectedNode = null;
        selectionInfo.textContent = 'None';
      } else {
        // connect selected -> id (direction based on directed toggle)
        const from = state.selectedNode;
        const to = id;
        if(state.weighted){
          openWeightModal((w)=>{
            if(state.directed){
              state.adj[from][to] = Number(w) || 1;
            } else {
              const v = Number(w) || 1;
              state.adj[from][to] = v;
              state.adj[to][from] = v;
            }
            state.selectedNode = null;
            selectionInfo.textContent = 'None';
            renderAll(true, {highlightCell:[from,to]});
          }, ()=>{
            // cancel keep selection
          });
        } else {
          if(state.directed){
            state.adj[from][to] = 1;
          } else {
            state.adj[from][to] = 1;
            state.adj[to][from] = 1;
          }
          state.selectedNode = null;
          selectionInfo.textContent = 'None';
          renderAll(true, {highlightCell:[from,to]});
        }
      }
    }

    // Helper: find node by id
    function nodeById(id){ return state.nodes.find(n=>n.id === id); }

    // Make an SVG group draggable
    function makeDraggable(g, node){
      let start = null;
      function onPointerDown(e){
        e.preventDefault();
        start = {x: e.clientX, y: e.clientY, nodeX: node.x, nodeY: node.y};
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
      }
      function onPointerMove(e){
        if(!start) return;
        const dx = e.clientX - start.x;
        const dy = e.clientY - start.y;
        node.x = start.nodeX + dx;
        node.y = start.nodeY + dy;
        // keep inside svg area margins
        const w = svg.clientWidth;
        const h = svg.clientHeight;
        node.x = Math.max(NODE_SIZE/2 + 8, Math.min(w - NODE_SIZE/2 - 8, node.x));
        node.y = Math.max(NODE_SIZE/2 + 8, Math.min(h - NODE_SIZE/2 - 8, node.y));
        g.setAttribute('transform', `translate(${node.x},${node.y})`);
        // update edges dynamically
        updateEdgesPositions();
      }
      function onPointerUp(){
        start = null;
        window.removeEventListener('pointermove', onPointerMove);
        window.removeEventListener('pointerup', onPointerUp);
        // re-render to update everything precisely
        renderAll();
      }
      g.addEventListener('pointerdown', onPointerDown);
    }

    // Recompute edge paths when nodes move
    function updateEdgesPositions(){
      Array.from(svg.querySelectorAll('.edge-line')).forEach(line=>{
        const i = Number(line.dataset.from), j = Number(line.dataset.to);
        const a = nodeById(i), b = nodeById(j);
        if(a && b){
          const d = linePath(a.x, a.y, b.x, b.y, NODE_SIZE/2);
          line.setAttribute('d', d);
        }
      });
      // update weights positions
      Array.from(svg.querySelectorAll('text.edge-weight')).forEach(text=>{
        // attempt to align based on nearby path (approx by scanning parent? simpler skip)
        // For simplicity, re-render on release; dynamic update not necessary for small moves.
      });
      // update node group positions
      Array.from(svg.querySelectorAll('.node')).forEach(g=>{
        const id = Number(g.dataset.id);
        const n = nodeById(id);
        if(n) g.setAttribute('transform', `translate(${n.x},${n.y})`);
      });
    }

    // Update both graph and matrix
    function renderAll(soft=false, opts={}){
      // soft: when true, animate update with highlight for changed cell
      renderGraph();
      renderMatrix(opts.highlightCell || null);
      updateModeInfo();
    }

    // Event listeners
    function attachListeners(){
      addNodeBtn.addEventListener('click', addNode);
      removeNodeBtn.addEventListener('click', removeNode);
      resetBtn.addEventListener('click', ()=>{ if(confirm('Reset graph?')) reset(); });
      randomBtn.addEventListener('click', randomize);
      exportBtn.addEventListener('click', exportMatrix);
      clearEdgesBtn.addEventListener('click', ()=>{ if(confirm('Clear all edges?')) clearEdges(); });

      directedToggle.addEventListener('change', (e)=>{
        state.directed = e.target.checked;
        // If switched to undirected, mirror upper triangle
        if(!state.directed){
          for(let i=0;i<state.adj.length;i++){
            for(let j=0;j<state.adj.length;j++){
              if(state.adj[i][j] !== null) state.adj[j][i] = state.adj[i][j];
              else if(state.adj[j][i] !== null) state.adj[i][j] = state.adj[j][i];
            }
          }
        }
        renderAll();
      });

      weightedToggle.addEventListener('change', (e)=>{
        state.weighted = e.target.checked;
        renderAll();
      });

      // Matrix area keyboard navigation: ESC clears selection
      document.addEventListener('keydown', (e)=>{
        if(e.key === 'Escape'){
          state.selectedNode = null;
          selectionInfo.textContent = 'None';
        }
      });

      // Click on background deselect
      svgArea.addEventListener('click', ()=>{
        state.selectedNode = null;
        selectionInfo.textContent = 'None';
      });

      // Weight modal
      weightOk.addEventListener('click', ()=>{
        weightModal.style.display = 'none';
        if(weightModal._callbackOk) weightModal._callbackOk(weightInput.value);
      });
      weightCancel.addEventListener('click', ()=>{
        weightModal.style.display = 'none';
        if(weightModal._callbackCancel) weightModal._callbackCancel();
      });

      // responsive resize: update svg viewBox size
      window.addEventListener('resize', ()=> {
        // no-op for now; nodes use coordinates relative to SVG viewBox 800x480
      });
    }

    // Open weight modal
    function openWeightModal(ok, cancel){
      weightModal.style.display = 'flex';
      weightInput.value = 1;
      weightInput.focus();
      weightModal._callbackOk = ok;
      weightModal._callbackCancel = cancel;
    }

    function updateModeInfo(){
      matrixMode.textContent = state.weighted ? ' (weighted)' : ' (unweighted)';
      modeInfo.textContent = (state.directed ? 'Directed' : 'Undirected') + (state.weighted ? ' · Weighted' : ' · Unweighted');
      matrixStatus.textContent = state.directed ? 'Rows → Columns (directed)' : 'Symmetric (undirected)';
    }

    // Highlight matrix cell when mouseover line
    function highlightMatrixCell(i,j){
      const table = matrixContainer.querySelector('table');
      if(!table) return;
      const btn = table.tBodies[0].rows[i].cells[j].firstChild;
      btn.style.boxShadow = '0 10px 22px rgba(245,158,11,0.08)';
      setTimeout(()=> btn.style.boxShadow = '', 700);
    }

    // Initialize adjacency arrays (helper already used)
    // Start
    init();

  </script>
</body>
</html>