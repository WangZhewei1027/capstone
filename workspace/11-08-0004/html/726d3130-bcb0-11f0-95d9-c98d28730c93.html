<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Counting Sort Module</title>
  <style>
    /* Safe area margins: 24px around viewport */
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --control-height: 40px;
      --accent: #0b79d0;
      --muted: #666;
      --bg: #fbfbfd;
      --card: #ffffff;
      --success: #17a673;
      --danger: #d9534f;
      --animation-duration: 500ms;
    }

    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #f7f9fc 0%, #fbfbfd 100%);
      color: #111;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100vh;
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 1100px;
    }

    .title-row {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: -0.2px;
    }

    .subtitle {
      color: var(--muted);
      font-size: 13px;
      margin: 0;
    }

    .meta {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      color: var(--muted);
      font-size: 13px;
    }

    /* Layout: controls & visual area */
    .container {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: var(--gap);
      align-items: start;
    }

    /* Left panel controls and explanations */
    .panel {
      background: var(--card);
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 1px 4px rgba(12,20,30,0.06);
      min-width: 0;
    }

    .panel h3 {
      margin: 0 0 8px 0;
      font-size: 15px;
    }

    .panel p {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 12px;
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    label {
      font-size: 13px;
      color: var(--muted);
      min-width: 120px;
    }

    input[type="text"] {
      flex: 1;
      height: var(--control-height);
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #e2e6ef;
      font-size: 14px;
    }

    .small {
      font-size: 13px;
      color: var(--muted);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 8px 12px;
      height: var(--control-height);
      border-radius: 6px;
      background: var(--accent);
      color: #fff;
      border: none;
      cursor: pointer;
      font-weight: 600;
      gap: 8px;
    }

    .btn.secondary {
      background: #eceff6;
      color: #111;
      border: 1px solid #e2e6ef;
      font-weight: 600;
    }

    .btn:disabled { opacity: 0.6; cursor: not-allowed; }

    .controls .group {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: #fff;
    }

    input[type="range"] {
      width: 100%;
    }

    /* Right panel - visual area */
    .visual {
      background: var(--card);
      border-radius: 8px;
      padding: 18px;
      box-shadow: 0 1px 4px rgba(12,20,30,0.06);
      min-height: 420px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
    }

    .visual .stage-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .stage-title h4 {
      margin: 0;
      font-size: 15px;
    }

    .visual-grid {
      display: grid;
      grid-template-rows: auto auto 1fr;
      gap: 12px;
      align-items: start;
      min-height: 320px;
    }

    /* Arrays representation */
    .array-row {
      display: flex;
      align-items: center;
      gap: 12px;
      min-height: 56px;
      padding: 10px;
      border-radius: 8px;
      border: 1px dashed #eef2f7;
      background: linear-gradient(180deg,#fff,#fbfdff);
    }

    .label {
      width: 120px;
      color: var(--muted);
      font-size: 13px;
      flex-shrink: 0;
    }

    .array {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 6px;
      min-height: 56px;
    }

    .cell {
      min-width: 48px;
      height: 48px;
      border-radius: 8px;
      background: linear-gradient(180deg,#ffffff,#f3f7fb);
      border: 1px solid #e4ecf7;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      color: #0b2a44;
      position: relative;
      box-shadow: 0 1px 0 rgba(12,20,30,0.03);
      user-select: none;
      flex: 0 0 48px;
    }

    .cell.small {
      min-width: 36px;
      height: 36px;
      font-weight: 600;
    }

    .cell.index {
      font-size: 11px;
      color: var(--muted);
      font-weight: 600;
    }

    .count-box {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;
      min-width: 48px;
      min-height: 56px;
    }

    .count-num {
      font-weight: 700;
    }

    .count-label {
      font-size: 12px;
      color: var(--muted);
    }

    .highlight {
      outline: 3px solid rgba(11,121,208,0.12);
      transform: translateY(-4px);
    }

    .emphasis {
      background: linear-gradient(180deg,#e8f5ff,#ffffff);
      border-color: #bfe6ff;
      box-shadow: 0 4px 14px rgba(11,121,208,0.08);
    }

    .status {
      display: flex;
      gap: 8px;
      align-items: center;
      color: var(--muted);
      font-size: 13px;
    }

    .controls-bottom {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      margin-top: 8px;
    }

    /* Pseudocode area */
    .pseudocode {
      background: #f7f9fc;
      border-radius: 6px;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size: 13px;
      color: #0b2a44;
      line-height: 1.5;
      white-space: pre;
    }

    .pseudocode .line {
      padding: 2px 6px;
      border-radius: 4px;
    }

    .pseudocode .active {
      background: linear-gradient(90deg, rgba(11,121,208,0.08), rgba(11,121,208,0.02));
      border-left: 3px solid var(--accent);
    }

    /* clone animation element that moves */
    .anim-layer {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
      width: 100%;
      height: 100%;
      overflow: visible;
    }

    /* responsive adjustments */
    @media (max-width: 980px) {
      .container {
        grid-template-columns: 1fr;
      }
      .label { width: 100px; }
    }

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Counting Sort interactive module">
    <header>
      <div class="title-row">
        <h1>Counting Sort — Interactive Walkthrough</h1>
        <div class="meta">
          <div class="subtitle">Stable, non-comparative integer sorting using counts and prefix sums.</div>
        </div>
      </div>

      <!-- Learning Objective & Design Description -->
      <div style="display:flex; gap:var(--gap); flex-wrap:wrap;">
        <div class="panel" style="flex:1; min-width:280px;">
          <h3>Learning Objective</h3>
          <p>After interacting with this module you will be able to:
            (1) understand how Counting Sort counts occurrences,
            (2) compute prefix sums to derive positions,
            and (3) see how stability is achieved by placing items in a specific order.
          Use step controls or autoplay to observe each operation with animation.</p>
        </div>

        <div class="panel" style="flex:1; min-width:280px;">
          <h3>Interaction Design</h3>
          <p>This module supports:
            - typing or pasting a comma-separated array of non-negative integers,
            - random array generation with adjustable length and max value,
            - toggling stable mode (stable vs. unstable placement),
            - stepping through each internal operation (counting, prefix sums, placing) or autoplaying at adjustable speed.
            Visual feedback includes animated element movement, highlighted counts as they change, and a live pseudocode highlight showing which line is active.</p>
        </div>
      </div>
    </header>

    <main class="container" role="main">
      <!-- Left controls -->
      <section class="panel" aria-labelledby="controls-heading">
        <h3 id="controls-heading">Controls</h3>
        <div class="controls" role="region" aria-label="controls region">
          <div style="display:flex; gap:12px; align-items:center;">
            <label for="input-array">Input array</label>
            <input id="input-array" type="text" placeholder="e.g. 3,1,2,3,0,2" aria-label="array input">
          </div>

          <div class="row">
            <label for="max-value">Maximum value</label>
            <input id="max-value" type="number" min="0" step="1" value="5" style="width:120px;" aria-label="maximum value">
          </div>

          <div class="row">
            <label>Randomize</label>
            <div class="group" style="flex:1;">
              <input id="rand-length" type="number" min="1" max="50" value="8" aria-label="random length" style="width:100px;">
              <button class="btn secondary" id="btn-random" aria-label="randomize array">Generate</button>
            </div>
          </div>

          <div class="row" style="align-items:center;">
            <label for="stable-toggle">Stable</label>
            <div style="display:flex; gap:8px; align-items:center;">
              <input id="stable-toggle" type="checkbox" checked aria-label="toggle stability">
              <span class="small">When checked, preserves original relative order.</span>
            </div>
          </div>

          <div class="row">
            <label for="speed-range">Animation speed</label>
            <input id="speed-range" type="range" min="0.25" max="2" step="0.25" value="1" aria-label="animation speed">
          </div>

          <div class="row">
            <label>Mode</label>
            <div class="group">
              <button class="btn" id="btn-step" aria-label="step forward">Step</button>
              <button class="btn secondary" id="btn-play" aria-label="play">Play</button>
              <button class="btn secondary" id="btn-reset" aria-label="reset">Reset</button>
            </div>
          </div>

          <div class="row">
            <label>Example</label>
            <div class="group">
              <button class="btn secondary" id="btn-example1">Example: [4,2,2,8,3,3,1]</button>
            </div>
          </div>

          <div class="row">
            <label>Notes</label>
            <div class="small">Input must be non-negative integers. Values above Maximum value will expand the count array automatically.</div>
          </div>

          <div class="controls-bottom" style="margin-top:12px;">
            <div class="status" id="status-text" aria-live="polite">Idle</div>
          </div>
        </div>
      </section>

      <!-- Right visual module -->
      <section class="visual" aria-labelledby="visual-heading">
        <div class="stage-title">
          <h4 id="visual-heading">Execution Stages</h4>
          <div class="status" style="gap:12px;">
            <div class="small">Speed: <span id="speed-label">1x</span></div>
            <div class="small">Mode: <span id="mode-label">Ready</span></div>
          </div>
        </div>

        <div class="visual-grid">
          <!-- Original array -->
          <div class="array-row" aria-label="original array area">
            <div class="label">Original</div>
            <div class="array" id="original-array" tabindex="0" aria-live="polite"></div>
          </div>

          <!-- Count / histogram / prefix -->
          <div class="array-row" aria-label="counts area">
            <div class="label">Counts → Prefix sums</div>
            <div id="counts-container" class="array" aria-live="polite"></div>
          </div>

          <!-- Output array -->
          <div class="array-row" aria-label="output array area" style="min-height:120px;">
            <div class="label">Output</div>
            <div class="array" id="output-array" aria-live="polite"></div>
          </div>
        </div>

        <div style="display:flex; gap:12px; align-items:flex-start; margin-top:8px;">
          <div style="flex:1;">
            <div class="pseudocode" id="pseudocode" aria-hidden="false">
<span class="line" data-line="1">1. Initialize count[0..k] = 0</span>
<span class="line" data-line="2">2. For each value v in input: count[v]++</span>
<span class="line" data-line="3">3. For i = 1..k: count[i] += count[i-1]   (prefix sums)</span>
<span class="line" data-line="4">4. For stability: iterate input from end to start</span>
<span class="line" data-line="5">5. For each v: output[ count[v]-1 ] = v; count[v]--</span>
            </div>
          </div>

          <div style="width:240px;">
            <div style="font-size:13px; color:var(--muted); margin-bottom:6px;">Step controls</div>
            <div style="display:flex; gap:8px;">
              <button class="btn" id="btn-prev" aria-label="step backward">◀ Prev</button>
              <button class="btn" id="btn-next" aria-label="step forward">Next ▶</button>
            </div>
            <div style="margin-top:12px;">
              <div class="small">Animation preview area (cloned elements move between original and output).</div>
            </div>
          </div>
        </div>

        <!-- animation layer for absolute clones -->
        <div class="anim-layer" id="anim-layer" aria-hidden="true"></div>
      </section>
    </main>
  </div>

  <script>
    // Counting Sort Interactive Module (vanilla JS)
    (function () {
      // DOM references
      const inputEl = document.getElementById('input-array');
      const maxEl = document.getElementById('max-value');
      const randLenEl = document.getElementById('rand-length');
      const btnRandom = document.getElementById('btn-random');
      const stableEl = document.getElementById('stable-toggle');
      const speedRange = document.getElementById('speed-range');
      const speedLabel = document.getElementById('speed-label');
      const statusText = document.getElementById('status-text');

      const btnStep = document.getElementById('btn-step');
      const btnPlay = document.getElementById('btn-play');
      const btnReset = document.getElementById('btn-reset');
      const btnExample = document.getElementById('btn-example1');

      const originalContainer = document.getElementById('original-array');
      const countsContainer = document.getElementById('counts-container');
      const outputContainer = document.getElementById('output-array');

      const pseudocodeEl = document.getElementById('pseudocode');
      const animLayer = document.getElementById('anim-layer');

      const btnPrev = document.getElementById('btn-prev');
      const btnNext = document.getElementById('btn-next');

      let state = {
        input: [],
        k: 5,
        counts: [],
        output: [],
        steps: [], // queued logical steps for stepping or autoplay
        stepIndex: 0,
        playing: false,
        speed: 1,
        stable: true,
      };

      const ANIM_TIME_BASE = 500; // ms; scaled by speed

      // Utility
      function parseInput(text) {
        if (!text.trim()) return [];
        return text.split(',').map(s => s.trim()).filter(s => s.length)
          .map(v => {
            const n = Number(v);
            if (!Number.isFinite(n) || n < 0 || Math.floor(n) !== n) {
              throw new Error('Invalid input: only non-negative integers allowed.');
            }
            return n;
          });
      }

      function setStatus(msg) {
        statusText.textContent = msg;
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      // Rendering helpers
      function clearChildren(el) {
        while (el.firstChild) el.removeChild(el.firstChild);
      }

      function createCell(content, extraClass = '') {
        const div = document.createElement('div');
        div.className = 'cell ' + extraClass;
        div.textContent = content;
        return div;
      }

      function renderOriginal() {
        clearChildren(originalContainer);
        state.input.forEach((v, idx) => {
          const el = createCell(v.toString());
          el.setAttribute('data-index', idx);
          el.setAttribute('data-value', v);
          el.setAttribute('aria-label', 'value ' + v + ' at index ' + idx);
          originalContainer.appendChild(el);
        });
      }

      function renderCounts() {
        clearChildren(countsContainer);
        for (let i = 0; i <= state.k; i++) {
          const box = document.createElement('div');
          box.className = 'count-box';
          box.setAttribute('data-count-index', i);
          box.innerHTML = '<div class="count-num" data-count="'+i+'">' + (state.counts[i] ?? 0) + '</div>'
                        + '<div class="count-label">' + i + '</div>';
          countsContainer.appendChild(box);
        }
      }

      function renderOutput() {
        clearChildren(outputContainer);
        state.output.forEach((v, idx) => {
          const el = createCell(v === null ? '' : v.toString());
          if (v !== null) el.setAttribute('data-value', v);
          el.setAttribute('data-output-index', idx);
          outputContainer.appendChild(el);
        });
      }

      function highlightPseudocode(lineIndex) {
        const lines = pseudocodeEl.querySelectorAll('.line');
        lines.forEach(l => l.classList.toggle('active', Number(l.getAttribute('data-line')) === lineIndex));
      }

      // Initialize from input
      function initialize() {
        try {
          const arr = parseInput(inputEl.value || '');
          state.input = arr.slice();
        } catch (e) {
          alert(e.message);
          return;
        }
        state.k = Math.max(0, Number(maxEl.value) || 0);
        // ensure count array covers all values present
        const maxInInput = state.input.length ? Math.max(...state.input) : -1;
        if (maxInInput > state.k) state.k = maxInInput;
        state.counts = new Array(state.k + 1).fill(0);
        state.output = new Array(state.input.length).fill(null);
        state.steps = buildSteps();
        state.stepIndex = 0;
        state.playing = false;
        renderOriginal();
        renderCounts();
        renderOutput();
        highlightPseudocode(1);
        setStatus('Ready — ' + state.input.length + ' items, k=' + state.k);
      }

      // Build logical steps (no animations) to iterate with stepping/autoplay.
      // Steps are objects: {type: 'count'|'prefix'|'place', index: i, value: v, info:...}
      function buildSteps() {
        const steps = [];
        // Step 1: initialize counts (conceptual)
        steps.push({ type: 'init_counts' });

        // Step 2: counting each input value
        state.input.forEach((v, idx) => {
          steps.push({ type: 'count', index: idx, value: v });
        });

        // Step 3: prefix sums
        steps.push({ type: 'prefix_start' });
        for (let i = 1; i <= state.k; i++) {
          steps.push({ type: 'prefix', index: i });
        }

        // Step 4: placing
        steps.push({ type: 'place_start' });
        // For stable requirement, iterate from end to start. If not stable, iterate start..end.
        const iterateIndices = state.stable ? [...state.input.keys()].reverse() : [...state.input.keys()];
        for (const idx of iterateIndices) {
          steps.push({ type: 'place', index: idx, value: state.input[idx] });
        }

        steps.push({ type: 'done' });
        return steps;
      }

      // Animation helpers: move clone from source element to dest element
      function animateMove(sourceEl, destEl, labelText, duration) {
        return new Promise(resolve => {
          const srcRect = sourceEl.getBoundingClientRect();
          const dstRect = destEl.getBoundingClientRect();
          const layerRect = animLayer.getBoundingClientRect();

          // create clone
          const clone = createCell(labelText);
          clone.style.position = 'absolute';
          clone.style.left = (srcRect.left - layerRect.left) + 'px';
          clone.style.top = (srcRect.top - layerRect.top) + 'px';
          clone.style.margin = '0';
          clone.style.transition = `transform ${duration}ms ease, left ${duration}ms ease, top ${duration}ms ease, opacity ${duration/1.6}ms ease`;
          clone.style.zIndex = 999;
          animLayer.appendChild(clone);

          // compute translation
          const dx = (dstRect.left - srcRect.left);
          const dy = (dstRect.top - srcRect.top);
          // use transform rather than changing left/top for smoother motion
          requestAnimationFrame(() => {
            clone.style.transform = `translate(${dx}px, ${dy}px) scale(1.02)`;
            clone.style.opacity = '0.95';
          });

          // finish after duration
          setTimeout(() => {
            animLayer.removeChild(clone);
            resolve();
          }, duration + 20);
        });
      }

      // Update displayed count value and highlight that box
      function updateCountDisplay(i, highlight = true) {
        const el = countsContainer.querySelector('[data-count-index="'+i+'"]');
        if (!el) return;
        const num = el.querySelector('[data-count="'+i+'"]');
        num.textContent = state.counts[i];
        if (highlight) {
          el.classList.add('emphasis');
          setTimeout(() => el.classList.remove('emphasis'), 600 / state.speed);
        }
      }

      // Step execution (single logical step)
      async function executeStep(step) {
        const speedFactor = state.speed;
        const base = ANIM_TIME_BASE;
        const animMs = base / speedFactor;

        switch (step.type) {
          case 'init_counts':
            highlightPseudocode(1);
            setStatus('Initializing count array to zeros');
            // already zeroed in initialize
            for (let i = 0; i <= state.k; i++) updateCountDisplay(i, false);
            await wait(250 / speedFactor);
            break;

          case 'count':
            highlightPseudocode(2);
            setStatus('Counting value ' + step.value + ' at index ' + step.index);
            // visually highlight input cell
            const inputCell = originalContainer.querySelector('[data-index="'+step.index+'"]');
            if (inputCell) {
              inputCell.classList.add('highlight');
            }
            // increment count
            state.counts[step.value] = (state.counts[step.value] || 0) + 1;
            updateCountDisplay(step.value, true);
            await wait(animMs);
            if (inputCell) inputCell.classList.remove('highlight');
            break;

          case 'prefix_start':
            setStatus('Computing prefix sums (counts → positions)');
            highlightPseudocode(3);
            await wait(250 / speedFactor);
            break;

          case 'prefix':
            highlightPseudocode(3);
            setStatus('Prefix sum at index ' + step.index);
            // visually highlight count[i-1] and count[i]
            const i = step.index;
            const boxPrev = countsContainer.querySelector('[data-count-index="'+(i-1)+'"]');
            const boxI = countsContainer.querySelector('[data-count-index="'+i+'"]');
            if (boxPrev) boxPrev.classList.add('highlight');
            if (boxI) boxI.classList.add('highlight');
            // compute prefix
            state.counts[i] = (state.counts[i] || 0) + (state.counts[i-1] || 0);
            updateCountDisplay(i, true);
            await wait(animMs);
            if (boxPrev) boxPrev.classList.remove('highlight');
            if (boxI) boxI.classList.remove('highlight');
            break;

          case 'place_start':
            highlightPseudocode(4);
            setStatus('Placing elements into output array');
            await wait(250 / speedFactor);
            break;

          case 'place':
            // step.index refers to original index to place
            highlightPseudocode(5);
            setStatus('Placing value ' + step.value + ' from index ' + step.index);
            // identify source element and target position
            const src = originalContainer.querySelector('[data-index="'+step.index+'"]');
            const value = step.value;
            const currentCount = state.counts[value];
            // target index is count[value]-1
            const targetIdx = currentCount - 1;
            // ensure output has that many slots
            if (targetIdx < 0 || targetIdx >= state.output.length) {
              // safety: expand output
              console.warn('target out of range', targetIdx);
            }
            // animate clone from source to target cell
            const targetCell = outputContainer.querySelector('[data-output-index="'+targetIdx+'"]');
            if (src && targetCell) {
              src.classList.add('highlight');
              await animateMove(src, targetCell, String(value), animMs);
              src.classList.remove('highlight');
            } else if (src && !targetCell) {
              // create temporary dest position visual at end
              const lastRect = outputContainer.getBoundingClientRect();
              const fakeDest = {
                getBoundingClientRect: () => ({ left: lastRect.left + targetIdx*54, top: lastRect.top })
              };
              await animateMove(src, fakeDest, String(value), animMs);
            } else {
              await wait(animMs);
            }
            // place value into output and decrement count
            state.output[targetIdx] = value;
            state.counts[value] = state.counts[value] - 1;
            renderOutput();
            updateCountDisplay(value, true);
            await wait(80 / speedFactor);
            break;

          case 'done':
            highlightPseudocode(5);
            setStatus('Done — output ready');
            highlightFinalOutput();
            break;

          default:
            console.warn('unknown step', step);
        }
      }

      function highlightFinalOutput() {
        const cells = outputContainer.querySelectorAll('.cell');
        cells.forEach((c, i) => {
          if (c.textContent) {
            c.classList.add('emphasis');
            setTimeout(() => c.classList.remove('emphasis'), 1000);
          }
        });
      }

      // helper delay
      function wait(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      // Play loop
      async function play() {
        if (state.playing) return;
        state.playing = true;
        btnPlay.textContent = 'Pause';
        document.getElementById('mode-label').textContent = 'Playing';
        while (state.playing && state.stepIndex < state.steps.length) {
          const step = state.steps[state.stepIndex];
          await executeStep(step);
          state.stepIndex++;
          if (!state.playing) break;
        }
        state.playing = false;
        btnPlay.textContent = 'Play';
        document.getElementById('mode-label').textContent = 'Ready';
      }

      // Pause
      function pause() {
        state.playing = false;
        btnPlay.textContent = 'Play';
        document.getElementById('mode-label').textContent = 'Paused';
      }

      // Step forward or backward
      async function stepForward() {
        if (state.stepIndex >= state.steps.length) {
          setStatus('Already at end');
          return;
        }
        await executeStep(state.steps[state.stepIndex]);
        state.stepIndex++;
      }

      async function stepBackward() {
        // A full implementation of backward stepping would require reversing all state changes.
        // For clarity and simplicity we will reinitialize and replay up to the desired step.
        if (state.stepIndex <= 0) {
          setStatus('Already at start');
          return;
        }
        const target = state.stepIndex - 1;
        // Reinitialize base state and replay up to target-1
        const savedStable = state.stable;
        initialize(); // reinitializes and rebuilds steps with current stable value
        state.stable = savedStable;
        // replay steps up to target
        for (let i = 0; i < target; i++) {
          await executeStep(state.steps[i]);
          state.stepIndex = i + 1;
        }
        setStatus('Stepped backward');
      }

      // UI Event bindings
      btnRandom.addEventListener('click', () => {
        const len = clamp(Number(randLenEl.value) || 8, 1, 50);
        const maxVal = clamp(Number(maxEl.value) || 5, 0, 200);
        const arr = Array.from({length: len}, () => Math.floor(Math.random() * (maxVal + 1)));
        inputEl.value = arr.join(',');
        initialize();
      });

      btnExample.addEventListener('click', () => {
        inputEl.value = '4,2,2,8,3,3,1';
        maxEl.value = '8';
        initialize();
      });

      btnReset.addEventListener('click', () => {
        pause();
        initialize();
      });

      btnStep.addEventListener('click', async () => {
        pause();
        await stepForward();
      });

      btnPlay.addEventListener('click', async () => {
        if (state.playing) {
          pause();
        } else {
          // ensure steps built reflect latest stable setting
          state.stable = stableEl.checked;
          state.steps = buildSteps();
          // ensure outputs and counts are reset for play from current position
          if (state.stepIndex >= state.steps.length) {
            // restart if already finished
            initialize();
          }
          play();
        }
      });

      btnNext.addEventListener('click', async () => {
        pause();
        await stepForward();
      });

      btnPrev.addEventListener('click', async () => {
        pause();
        await stepBackward();
      });

      // when input changed manually
      inputEl.addEventListener('change', () => {
        initialize();
      });

      maxEl.addEventListener('change', () => {
        initialize();
      });

      stableEl.addEventListener('change', () => {
        state.stable = stableEl.checked;
        state.steps = buildSteps();
        setStatus('Stable set to ' + (state.stable ? 'ON' : 'OFF'));
      });

      speedRange.addEventListener('input', () => {
        const s = Number(speedRange.value);
        state.speed = s;
        speedLabel.textContent = s + 'x';
      });

      // initial set up
      (function setup() {
        // put an initial array
        inputEl.value = '3,1,2,3,0,2';
        maxEl.value = '3';
        state.speed = Number(speedRange.value);
        state.stable = stableEl.checked;
        initialize();
      })();

      // Expose for debugging (optional)
      window._countingSortState = state;

    })();
  </script>
</body>
</html>