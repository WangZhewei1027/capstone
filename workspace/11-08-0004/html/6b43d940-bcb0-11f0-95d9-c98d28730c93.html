<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Deque — Interactive Module</title>
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --card:#0e1a2b;
      --accent:#38bdf8;
      --accent-2:#60a5fa;
      --muted:#94a3b8;
      --success:#34d399;
      --danger:#fb7185;
      --glass: rgba(255,255,255,0.03);
      --max-width:1100px;
      --safe-margin:24px;
      --gap:16px;
      --rounded:10px;
    }

    /* Safe area margins and layout basics */
    html,body{
      height:100%;
      margin:0;
      padding:var(--safe-margin);
      background:
        linear-gradient(180deg, rgba(14,20,35,1) 0%, rgba(7,9,15,1) 100%);
      font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .container{
      max-width:var(--max-width);
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      min-height:calc(100vh - (var(--safe-margin)*2));
    }

    header{
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-start;
    }

    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
      color:var(--accent);
    }

    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* Main module: two-column responsive */
    .module{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      width:100%;
      flex:1 1 auto;
    }

    .col{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--rounded);
      padding:18px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }

    .left{
      flex:0 0 360px;
      min-width:260px;
    }

    .center{
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      gap:20px;
      min-width:320px;
    }

    .right{
      flex:0 0 280px;
      min-width:220px;
    }

    /* Explanatory text list */
    .spec{
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .spec h2{
      margin:0;
      font-size:15px;
      color:var(--accent-2);
    }

    .spec p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
    }

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      margin-top:6px;
    }

    .input-row{
      display:flex;
      gap:12px;
      align-items:center;
    }

    input[type="text"]{
      flex:1;
      min-width:0;
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.04);
      padding:10px 12px;
      color:inherit;
      border-radius:8px;
      outline:none;
    }

    input[type="text"]:focus{
      border-color:var(--accent);
      box-shadow:0 4px 16px rgba(56,189,248,0.08);
    }

    .btn-row{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
    }

    button{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      color:var(--muted);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      transition:all 180ms ease;
      font-size:13px;
    }

    button.primary{
      background:linear-gradient(180deg, var(--accent), var(--accent-2));
      color:#03203a;
      border:none;
      box-shadow: 0 8px 24px rgba(56,189,248,0.12);
    }

    button.warn{
      background:linear-gradient(180deg, rgba(251,113,133,0.12), rgba(251,113,133,0.08));
      color:var(--danger);
      border:1px solid rgba(251,113,133,0.12);
    }

    button:active{ transform:translateY(1px); }

    .meta{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:13px;
    }

    .meta .pill{
      background:var(--glass);
      padding:8px 10px;
      border-radius:8px;
    }

    /* Deque visualization */
    .deque-area{
      width:100%;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
    }

    .deque-line{
      width:100%;
      max-width:900px;
      min-height:120px;
      background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:18px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    }

    .slots{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:center;
      flex-wrap:nowrap;
      overflow:auto;
      padding-bottom:6px;
      min-height:72px;
    }

    .slot{
      min-width:72px;
      height:56px;
      background:rgba(255,255,255,0.03);
      border-radius:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--muted);
      font-weight:600;
      font-size:14px;
      position:relative;
      border:1px dashed rgba(255,255,255,0.03);
      flex:0 0 auto;
    }

    .slot.empty{
      opacity:0.35;
    }

    .node{
      background:linear-gradient(180deg, rgba(56,189,248,0.12), rgba(96,165,250,0.12));
      border:1px solid rgba(56,189,248,0.18);
      color:var(--accent);
      padding:8px 12px;
      border-radius:6px;
      font-weight:700;
      display:inline-block;
      transform-origin:center;
      transition:transform 250ms cubic-bezier(.2,.9,.2,1), box-shadow 200ms;
      box-shadow:0 6px 18px rgba(3,32,58,0.12);
    }

    .node.new{
      animation:flyIn 360ms ease forwards;
    }

    .node.removing{
      animation:flyOut 280ms ease forwards;
    }

    @keyframes flyIn{
      from{ transform: translateY(-28px) scale(0.96); opacity:0; }
      to{ transform: translateY(0) scale(1); opacity:1; }
    }

    @keyframes flyOut{
      from{ transform: translateY(0) scale(1); opacity:1; }
      to{ transform: translateY(18px) scale(.96); opacity:0; }
    }

    /* Front/back markers */
    .marker{
      position:absolute;
      top:8px;
      font-size:12px;
      padding:6px 8px;
      background:rgba(2,6,23,0.7);
      color:var(--muted);
      border-radius:8px;
      display:flex;
      gap:8px;
      align-items:center;
    }

    .marker.front{
      left:18px;
    }

    .marker.back{
      right:18px;
    }

    .pointer{
      font-size:12px;
      color:var(--accent);
      font-weight:700;
    }

    /* Drop zone outlines */
    .drop-zone{
      position:absolute;
      top:0;
      bottom:0;
      width:84px;
      border-radius:12px;
      pointer-events:none;
    }

    .drop-zone.front {
      left:12px;
    }
    .drop-zone.back {
      right:12px;
    }

    .drop-zone.active{
      box-shadow:inset 0 0 0 2px rgba(56,189,248,0.18);
      pointer-events:auto;
    }

    /* Right column log */
    .log{
      max-height:320px;
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:8px;
    }

    .log .entry{
      font-size:13px;
      color:var(--muted);
      background:rgba(255,255,255,0.02);
      padding:8px 10px;
      border-radius:8px;
      border-left:3px solid rgba(255,255,255,0.02);
    }

    .log .entry.ok{ border-left-color:var(--success); color:#c6f6e8; }
    .log .entry.warn{ border-left-color:var(--danger); color:#ffd6de; }

    /* Small helpers */
    .legend{
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .legend .item{ display:flex; gap:6px; align-items:center; }
    .chip{ width:12px; height:12px; border-radius:4px; display:inline-block; }

    /* Responsive: stack columns */
    @media (max-width:980px){
      .module{ flex-direction:column; }
      .left,.right{ flex:1 1 auto; width:100%; }
    }

    /* Accessibility focus outlines */
    button:focus, input:focus { outline:3px solid rgba(56,189,248,0.15); outline-offset:2px; }
  </style>
</head>
<body>
  <div class="container" role="main">
    <header>
      <h1>Deque — Double-Ended Queue (Interactive)</h1>
      <p class="subtitle">Explore operations at both ends: add/remove from front or back. Try clicking buttons, using keyboard, or dragging your value into the front/back targets.</p>
    </header>

    <div class="module" aria-label="Deque interactive module">

      <!-- LEFT: Concept + Controls -->
      <aside class="col left" aria-labelledby="concept-title">
        <div class="spec">
          <h2 id="concept-title">Concept Title</h2>
          <p>Deque (Double-Ended Queue): a linear data structure that allows insertion and removal of elements from both the front and the back.</p>

          <h2>Learning Objective</h2>
          <p>After interacting with this module you should be able to:
            visualize the deque contents, perform enqueue/dequeue at both ends, and understand how front/back pointers and size change with each operation.
          </p>

          <h2>Interaction Design</h2>
          <p>
            Interact by:
            <ul>
              <li>Typing a value and clicking "Add Front" or "Add Back" to enqueue (animated insert).</li>
              <li>Clicking "Remove Front" or "Remove Back" to dequeue (animated removal).</li>
              <li>Dragging the typed value to the front/back drop target (drag & drop enqueues).</li>
              <li>Using keyboard: press Enter in the input to add to back; Tab to navigate buttons and press Space/Enter to activate.</li>
            </ul>
            Visual feedback includes sliding animations for insert/remove, pointer labels for front/back, a live operations log, and the array-style representation for clarity.
          </p>

          <h2>Layout Description</h2>
          <p>
            Left column: explanatory text and controls (value input, operation buttons, meta info).
            Center column: the visual deque canvas (slots, nodes, front/back markers, drop targets).
            Right column: live operation log and array visualization.
            Spacing rules: 24px safe margins around viewport; minimum 16px gap between interactive elements; layout is responsive and keyboard accessible.
          </p>
        </div>

        <div style="height:12px;"></div>

        <div class="controls" aria-label="Controls">
          <div class="input-row" aria-hidden="false">
            <input type="text" id="valueInput" aria-label="Value to insert" placeholder="Enter value (e.g., A, 42, foo)" />
            <button id="toPool" title="Create draggable chip" aria-label="Create draggable chip">Create Chip</button>
          </div>

          <div class="btn-row" role="group" aria-label="Deque operations">
            <button id="addFront" class="primary" aria-label="Add to front">Add Front</button>
            <button id="addBack" class="primary" aria-label="Add to back">Add Back</button>
            <button id="removeFront" class="warn" aria-label="Remove from front">Remove Front</button>
            <button id="removeBack" class="warn" aria-label="Remove from back">Remove Back</button>
            <button id="peekFront" aria-label="Peek front">Peek Front</button>
            <button id="peekBack" aria-label="Peek back">Peek Back</button>
          </div>

          <div class="meta" aria-hidden="false" style="margin-top:8px;">
            <div class="pill" id="sizePill" aria-live="polite">Size: 0</div>
            <div class="pill" id="capacityPill">Capacity: 12</div>
            <div class="pill" id="statusPill">Status: idle</div>
          </div>

          <div style="display:flex; gap:12px; margin-top:8px;">
            <button id="clear" aria-label="Clear deque">Clear</button>
            <button id="fillDemo" aria-label="Fill demo deque">Fill Demo</button>
          </div>

          <div style="margin-top:10px;" class="legend" aria-hidden="true">
            <div class="item"><span class="chip" style="background:var(--accent)"></span> Node</div>
            <div class="item"><span style="width:10px"></span> Front / Back markers</div>
          </div>
        </div>

      </aside>

      <!-- CENTER: Deque visualization -->
      <section class="col center" aria-label="Deque visualization">
        <div class="deque-area" role="region" aria-label="Deque canvas">

          <div class="deque-line" id="dequeLine" aria-live="polite">
            <div class="marker front" id="markerFront"><span class="pointer">Front</span></div>
            <div class="marker back" id="markerBack"><span class="pointer">Back</span></div>

            <div class="drop-zone front" id="dropFront" title="Drop here to add to front" aria-hidden="false"></div>
            <div class="drop-zone back" id="dropBack" title="Drop here to add to back" aria-hidden="false"></div>

            <div class="slots" id="slots" tabindex="0" role="list" aria-label="Deque slots">
              <!-- slots/nodes rendered here -->
            </div>
          </div>

          <div style="display:flex; gap:12px; align-items:center; width:100%; justify-content:center;">
            <div style="color:var(--muted); font-size:13px;">Tip: Drag the chip (below) to the front/back pads to insert.</div>
          </div>

          <div id="chipArea" style="display:flex; gap:12px; flex-wrap:wrap; justify-content:center; margin-top:6px;"></div>

        </div>
      </section>

      <!-- RIGHT: Log & representation -->
      <aside class="col right" aria-label="Status and log">
        <h2 style="margin-top:0; font-size:15px; color:var(--accent-2);">Operations Log</h2>
        <div id="log" class="log" aria-live="polite" aria-atomic="true"></div>

        <h2 style="margin-top:10px; font-size:15px; color:var(--accent-2);">Array Representation</h2>
        <div id="arrayRep" style="color:var(--muted); font-family:monospace; font-size:13px; padding:10px; background:rgba(255,255,255,0.02); border-radius:8px; margin-top:8px;">[]</div>
      </aside>

    </div>
  </div>

  <script>
    (function(){
      // Configuration
      const CAPACITY = 12;
      const slotsEl = document.getElementById('slots');
      const sizePill = document.getElementById('sizePill');
      const capacityPill = document.getElementById('capacityPill');
      const statusPill = document.getElementById('statusPill');
      capacityPill.textContent = 'Capacity: ' + CAPACITY;

      const logEl = document.getElementById('log');
      const arrayRep = document.getElementById('arrayRep');

      const valueInput = document.getElementById('valueInput');
      const chipArea = document.getElementById('chipArea');

      // Buttons
      const addFrontBtn = document.getElementById('addFront');
      const addBackBtn = document.getElementById('addBack');
      const removeFrontBtn = document.getElementById('removeFront');
      const removeBackBtn = document.getElementById('removeBack');
      const peekFrontBtn = document.getElementById('peekFront');
      const peekBackBtn = document.getElementById('peekBack');
      const clearBtn = document.getElementById('clear');
      const fillDemo = document.getElementById('fillDemo');
      const toPool = document.getElementById('toPool');

      const dropFront = document.getElementById('dropFront');
      const dropBack = document.getElementById('dropBack');

      // Data model for deque: front is index 0
      let deque = [];

      // Utility: update UI
      function render(){
        // Clear slots
        slotsEl.innerHTML = '';
        // Determine how many slots to show: capacity or actual + some padding
        const count = deque.length;
        // Render nodes
        for (let i = 0; i < count; i++){
          const node = document.createElement('div');
          node.className = 'slot';
          node.setAttribute('role','listitem');
          const inner = document.createElement('div');
          inner.className = 'node';
          inner.textContent = deque[i];
          // Attach remove-on-click for quick removal (alt-click)
          inner.tabIndex = 0;
          inner.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || (e.key === 'Backspace')) {
              // Remove this element (search index)
              const idx = Array.from(slotsEl.children).indexOf(node);
              if (idx === 0){
                removeFront();
              } else if (idx === deque.length - 1){
                removeBack();
              } else {
                // Removing middle element: not part of deque typical ops; highlight message
                addLog('Cannot remove middle element via node key. Use front/back removes.', 'warn');
              }
            }
          });
          node.appendChild(inner);
          slotsEl.appendChild(node);
        }

        // Fill remaining capacity with empty slots for visual guidance
        const fillerCount = Math.max(0, Math.min(CAPACITY, Math.max(6, count)) - count);
        for (let i = 0; i < fillerCount; i++){
          const slot = document.createElement('div');
          slot.className = 'slot empty';
          slot.textContent = '';
          slotsEl.appendChild(slot);
        }

        // Update markers visibility and pointer positions (front/back labels always visible)
        const markerFront = document.getElementById('markerFront');
        const markerBack = document.getElementById('markerBack');

        // Update size display
        sizePill.textContent = 'Size: ' + deque.length;
        arrayRep.textContent = JSON.stringify(deque);

        // Disable/enable buttons based on state
        const isEmpty = deque.length === 0;
        const isFull = deque.length >= CAPACITY;

        removeFrontBtn.disabled = isEmpty;
        removeBackBtn.disabled = isEmpty;
        peekFrontBtn.disabled = isEmpty;
        peekBackBtn.disabled = isEmpty;

        addFrontBtn.disabled = isFull;
        addBackBtn.disabled = isFull;
        toPool.disabled = (valueInput.value.trim().length === 0);

        // Update status aria
        statusPill.textContent = isEmpty ? 'Status: empty' : 'Status: has elements';

        // Update pointer highlight
        if (!isEmpty){
          // show front/back labels near slots
          const slotElements = slotsEl.children;
          if (slotElements.length > 0){
            // Compute approximate position for markers using left-most and right-most slot
            try {
              const firstSlot = slotElements[0].getBoundingClientRect();
              const lastSlot = slotElements[Math.min(deque.length - 1, slotElements.length - 1)].getBoundingClientRect();
              const parentRect = slotsEl.getBoundingClientRect();
              // Position markers relative to dequeLine (absolute)
              const dequeLine = document.getElementById('dequeLine');
              const offsetLeft = firstSlot.left - dequeLine.getBoundingClientRect().left;
              const offsetRight = dequeLine.getBoundingClientRect().right - lastSlot.right;
              markerFront.style.left = Math.max(8, offsetLeft + 8) + 'px';
              markerBack.style.right = Math.max(8, offsetRight + 8) + 'px';
            } catch(e){ /* ignore if DOM measurement fails */ }
          }
        } else {
          // default positions
          markerFront.style.left = '18px';
          markerBack.style.right = '18px';
        }
      }

      // Logs
      function addLog(text, kind = 'ok'){
        const e = document.createElement('div');
        e.className = 'entry ' + (kind === 'ok' ? 'ok' : 'warn');
        e.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
        logEl.prepend(e);
      }

      // Operation implementations
      function addFront(value){
        if (!value && value !== 0) return;
        if (deque.length >= CAPACITY){
          addLog('Add Front failed — deque is full', 'warn');
          return;
        }
        deque.unshift(value);
        addLog(`Added '${value}' to front`);
        // Visual animation: create element and mark as new
        render();
        // Find the new node element at index 0 and add .new class to animate (applies to inner node)
        setTimeout(() => {
          const firstSlot = slotsEl.children[0];
          if (firstSlot){
            const inner = firstSlot.querySelector('.node');
            if (inner) inner.classList.add('new');
          }
        }, 10);
      }

      function addBack(value){
        if (!value && value !== 0) return;
        if (deque.length >= CAPACITY){
          addLog('Add Back failed — deque is full', 'warn');
          return;
        }
        deque.push(value);
        addLog(`Added '${value}' to back`);
        render();
        setTimeout(() => {
          const lastIndex = deque.length - 1;
          const lastSlot = slotsEl.children[lastIndex];
          if (lastSlot){
            const inner = lastSlot.querySelector('.node');
            if (inner) inner.classList.add('new');
          }
        }, 10);
      }

      function removeFront(){
        if (deque.length === 0){
          addLog('Remove Front failed — deque is empty', 'warn');
          return;
        }
        // Animate removal
        const firstSlot = slotsEl.children[0];
        if (firstSlot){
          const inner = firstSlot.querySelector('.node');
          if (inner){
            inner.classList.add('removing');
            inner.addEventListener('animationend', () => {
              const val = deque.shift();
              addLog(`Removed '${val}' from front`);
              render();
            }, { once: true });
            return;
          }
        }
        // Fallback if no animation
        const val = deque.shift();
        addLog(`Removed '${val}' from front`);
        render();
      }

      function removeBack(){
        if (deque.length === 0){
          addLog('Remove Back failed — deque is empty', 'warn');
          return;
        }
        const lastIndex = deque.length - 1;
        const lastSlot = slotsEl.children[lastIndex];
        if (lastSlot){
          const inner = lastSlot.querySelector('.node');
          if (inner){
            inner.classList.add('removing');
            inner.addEventListener('animationend', () => {
              const val = deque.pop();
              addLog(`Removed '${val}' from back`);
              render();
            }, { once: true });
            return;
          }
        }
        const val = deque.pop();
        addLog(`Removed '${val}' from back`);
        render();
      }

      function peekFront(){
        if (deque.length === 0){
          addLog('Peek Front failed — deque is empty', 'warn');
          return;
        }
        addLog(`Front item: '${deque[0]}'`);
        // visual highlight
        const slot = slotsEl.children[0];
        if (slot){
          const node = slot.querySelector('.node');
          node.style.boxShadow = '0 12px 32px rgba(56,189,248,0.18)';
          setTimeout(()=> node.style.boxShadow = '', 600);
        }
      }

      function peekBack(){
        if (deque.length === 0){
          addLog('Peek Back failed — deque is empty', 'warn');
          return;
        }
        addLog(`Back item: '${deque[deque.length - 1]}'`);
        const slot = slotsEl.children[deque.length - 1];
        if (slot){
          const node = slot.querySelector('.node');
          node.style.boxShadow = '0 12px 32px rgba(96,165,250,0.18)';
          setTimeout(()=> node.style.boxShadow = '', 600);
        }
      }

      function clearDeque(){
        if (deque.length === 0){
          addLog('Clear called — deque already empty', 'warn');
        } else {
          deque = [];
          addLog('Cleared deque');
          render();
        }
      }

      function fillDemoValues(){
        clearDeque();
        const demo = ['A','B','C','D','E'];
        demo.forEach(v => deque.push(v));
        addLog('Filled demo values: ' + JSON.stringify(demo));
        render();
      }

      // Event wiring
      addFrontBtn.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (v === '') { addLog('No value to add — enter a value first', 'warn'); return; }
        addFront(v);
      });

      addBackBtn.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (v === '') { addLog('No value to add — enter a value first', 'warn'); return; }
        addBack(v);
      });

      removeFrontBtn.addEventListener('click', removeFront);
      removeBackBtn.addEventListener('click', removeBack);
      peekFrontBtn.addEventListener('click', peekFront);
      peekBackBtn.addEventListener('click', peekBack);
      clearBtn.addEventListener('click', clearDeque);
      fillDemo.addEventListener('click', fillDemoValues);

      // Enter key: add to back (conventional)
      valueInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter'){
          const v = valueInput.value.trim();
          if (v === '') { addLog('No value to add — enter a value first', 'warn'); return; }
          addBack(v);
        }
      });

      // Chip creation (draggable)
      toPool.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (v === '') { addLog('No value to create chip from', 'warn'); return; }
        const chip = document.createElement('div');
        chip.className = 'node';
        chip.textContent = v;
        chip.setAttribute('draggable','true');
        chip.style.cursor = 'grab';
        chip.title = 'Drag to front/back to add';
        chip.addEventListener('dragstart', (ev) => {
          ev.dataTransfer.setData('text/plain', v);
          // small UI cue
          chip.style.opacity = '0.6';
        });
        chip.addEventListener('dragend', (ev) => {
          chip.style.opacity = '';
        });
        // allow removing chip on click
        chip.addEventListener('click', () => {
          chip.remove();
        });
        chipArea.appendChild(chip);
        addLog(`Created draggable chip '${v}'`);
        // clear input for convenience
        valueInput.value = '';
        toPool.disabled = true;
      });

      valueInput.addEventListener('input', () => {
        toPool.disabled = valueInput.value.trim().length === 0;
      });

      // Drag & drop on front/back
      function makeDropZone(zoneEl, onDropFn){
        zoneEl.addEventListener('dragenter', (e) => {
          e.preventDefault();
          zoneEl.classList.add('active');
        });
        zoneEl.addEventListener('dragover', (e) => {
          e.preventDefault();
        });
        zoneEl.addEventListener('dragleave', (e) => {
          zoneEl.classList.remove('active');
        });
        zoneEl.addEventListener('drop', (e) => {
          e.preventDefault();
          zoneEl.classList.remove('active');
          const data = e.dataTransfer.getData('text/plain');
          if (data){
            onDropFn(data);
          } else {
            addLog('Drop contained no data', 'warn');
          }
        });
      }

      makeDropZone(dropFront, (val) => addFront(val));
      makeDropZone(dropBack, (val) => addBack(val));

      // Initialize with empty render
      render();
      addLog('Deque module ready');

      // Accessibility: keyboard visual focus guidance for drop zones
      dropFront.tabIndex = 0;
      dropBack.tabIndex = 0;
      dropFront.addEventListener('focus', () => dropFront.classList.add('active'));
      dropFront.addEventListener('blur', () => dropFront.classList.remove('active'));
      dropBack.addEventListener('focus', () => dropBack.classList.add('active'));
      dropBack.addEventListener('blur', () => dropBack.classList.remove('active'));

      // Expose for debugging in console (optional)
      window._dequeModule = {
        deque,
        addFront, addBack, removeFront, removeBack, peekFront, peekBack, render
      };

    })();
  </script>
</body>
</html>