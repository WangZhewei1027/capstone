<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Deque Interactive Module</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #60a5fa;
      --accent-2: #34d399;
      --muted: #94a3b8;
      --danger: #fb7185;
      --box: #1f2937;
      --glass: rgba(255,255,255,0.02);
      --radius: 10px;
      --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg, #071025 0%, #071a2a 100%);
      color: #e6eef8;
      font-family: var(--font-sans);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Safe area margins: 24px */
    .safe-area{
      padding: var(--safe-padding);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      gap: var(--gap);
      align-items:flex-start;
    }

    /* Layout - responsive columns */
    .left-column{
      width: 360px;
      min-width: 280px;
      max-width: 420px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius: var(--radius);
      padding: 20px;
      box-sizing: border-box;
      box-shadow: 0 6px 24px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      gap: 16px;
      min-height: 420px;
    }

    .right-column{
      flex:1;
      min-width: 300px;
      background: linear-gradient(180deg, rgba(255,255,255,0.015), transparent);
      border-radius: var(--radius);
      padding: 20px;
      box-sizing: border-box;
      display:flex;
      flex-direction:column;
      gap: 16px;
      border: 1px solid rgba(255,255,255,0.03);
    }

    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    h2{
      margin:0;
      font-size:14px;
      color:var(--muted);
      font-weight:600;
    }

    /* Info blocks */
    .section{
      background: rgba(255,255,255,0.02);
      padding: 12px;
      border-radius: 8px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .small{
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
    }

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .row{
      display:flex;
      gap: var(--gap);
      align-items:center;
    }

    label{
      font-size:13px;
      color:var(--muted);
    }

    input[type="text"], input[type="number"]{
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.04);
      color: #e6eef8;
      padding:8px 10px;
      border-radius:8px;
      min-width:0;
      outline:none;
    }
    input[type="text"]::placeholder{ color: #8290a6; }

    button{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.006));
      border: 1px solid rgba(255,255,255,0.06);
      color: #e6eef8;
      padding: 8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      transition: transform 120ms ease, box-shadow 120ms;
      display:inline-flex;
      gap:8px;
      align-items:center;
      justify-content:center;
    }
    button:active{ transform: translateY(1px); }
    button:focus{ box-shadow: 0 0 0 3px rgba(96,165,250,0.12); outline:none; }
    button.secondary{
      background:transparent;
      border:1px dashed rgba(255,255,255,0.04);
      color:var(--muted);
      font-weight:600;
    }
    button.positive{
      background: linear-gradient(90deg, var(--accent), #3b82f6);
      border:none;
      box-shadow: 0 6px 18px rgba(96,165,250,0.12);
      color: #031026;
    }
    button.warn{
      background: linear-gradient(90deg, #fbbf24, #fb923c);
      border:none;
      color:#08111a;
    }
    button.danger{
      background: linear-gradient(90deg, #fb7185, #f97316);
      border:none;
      color:#08111a;
    }
    button:disabled{
      opacity:0.45;
      cursor:not-allowed;
      transform:none;
      box-shadow:none;
    }

    /* Visual deque area */
    .deque-area{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:stretch;
      justify-content:flex-start;
    }

    .deque-canvas{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.0));
      border-radius: 10px;
      padding: 18px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height: 220px;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.03);
    }

    .deque-wrapper{
      width:100%;
      overflow:auto;
      padding: 8px 12px;
      box-sizing:border-box;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:120px;
    }

    .deque {
      display:flex;
      gap:12px;
      align-items:center;
      padding:8px;
      min-height:84px;
      transition:all 300ms ease;
      will-change:transform;
    }

    /* Each node */
    .node{
      width:84px;
      min-width:84px;
      height:84px;
      border-radius:10px;
      background:linear-gradient(180deg, var(--box), rgba(255,255,255,0.02));
      box-shadow: 0 8px 20px rgba(2,6,23,0.6);
      display:flex;
      align-items:center;
      justify-content:center;
      color:#e6eef8;
      font-weight:700;
      font-size:18px;
      position:relative;
      border: 1px solid rgba(255,255,255,0.03);
      transition: transform 300ms cubic-bezier(.2,.9,.2,1), opacity 260ms ease;
    }

    .node .index{
      position:absolute;
      bottom:6px;
      right:8px;
      font-size:11px;
      color:var(--muted);
      font-weight:600;
    }

    /* Front/back markers */
    .marker{
      font-size:12px;
      color:var(--accent);
      font-weight:700;
      display:flex;
      gap:6px;
      align-items:center;
      padding:6px 8px;
      border-radius:6px;
      background: rgba(96,165,250,0.08);
      border: 1px solid rgba(96,165,250,0.08);
    }

    .marker.back{ color: var(--accent-2); background: rgba(52,211,153,0.06); border-color: rgba(52,211,153,0.06); }

    /* Animations for adding/removing */
    .adding-left{ transform: translateX(-140%) scale(0.96); opacity:0; animation: slideInLeft 350ms forwards cubic-bezier(.16,.84,.24,1); }
    .adding-right{ transform: translateX(140%) scale(0.96); opacity:0; animation: slideInRight 350ms forwards cubic-bezier(.16,.84,.24,1); }
    .removing-left{ animation: slideOutLeft 300ms forwards cubic-bezier(.3,.0,.4,1); }
    .removing-right{ animation: slideOutRight 300ms forwards cubic-bezier(.3,.0,.4,1); }

    @keyframes slideInLeft{
      from{ transform: translateX(-140%) scale(0.96); opacity:0; }
      to{ transform: translateX(0) scale(1); opacity:1; }
    }
    @keyframes slideInRight{
      from{ transform: translateX(140%) scale(0.96); opacity:0; }
      to{ transform: translateX(0) scale(1); opacity:1; }
    }
    @keyframes slideOutLeft{
      from{ transform: translateX(0) scale(1); opacity:1; }
      to{ transform: translateX(-140%) scale(0.9); opacity:0; }
    }
    @keyframes slideOutRight{
      from{ transform: translateX(0) scale(1); opacity:1; }
      to{ transform: translateX(140%) scale(0.9); opacity:0; }
    }

    /* Drag overlay for drop targets */
    .drop-target{
      position:absolute;
      left:0; right:0; top:0; bottom:0;
      pointer-events:none;
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:18px;
      box-sizing:border-box;
    }
    .drop-zone{
      width:80px;
      height:80px;
      border-radius:10px;
      border:2px dashed rgba(255,255,255,0.03);
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--muted);
      pointer-events:auto;
      transition: background 160ms, border-color 160ms, color 160ms;
      background: rgba(255,255,255,0.01);
    }
    .drop-zone.active-front{ background: rgba(96,165,250,0.06); color:var(--accent); border-color: rgba(96,165,250,0.12); }
    .drop-zone.active-back{ background: rgba(52,211,153,0.06); color:var(--accent-2); border-color: rgba(52,211,153,0.12); }

    /* Palette */
    .palette{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .chip{
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      padding:6px 10px;
      border-radius:8px;
      cursor:grab;
      user-select:none;
      color:#dbeafe;
      font-weight:700;
    }
    .chip:active{ cursor:grabbing; }

    /* Log / hints */
    .log{
      max-height:140px;
      overflow:auto;
      background: rgba(255,255,255,0.01);
      padding:10px;
      border-radius:8px;
      font-size:13px;
      color:var(--muted);
      border: 1px dashed rgba(255,255,255,0.02);
    }

    /* Footer area */
    .footer{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }

    /* Responsive */
    @media (max-width:980px){
      .safe-area{ flex-direction:column; padding:18px; gap:12px; }
      .left-column{ width:100%; max-width:none; min-width:0; }
      .right-column{ width:100%; }
    }

  </style>
</head>
<body>
  <main class="safe-area" role="main" aria-labelledby="title">
    <!-- LEFT COLUMN: Info + Controls -->
    <aside class="left-column" aria-label="Module controls and overview">
      <div>
        <h1 id="title">Deque ‚Äî Double-Ended Queue (Interactive)</h1>
        <h2>Explore push/pop at both ends</h2>
      </div>

      <div class="section" aria-labelledby="objective">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <strong>Learning Objective</strong>
          <span style="font-size:12px;color:var(--muted)">Interactive</span>
        </div>
        <p class="small" id="objective">
          After using this module you should understand how to add and remove items from both the front and back of a deque, recognize its behavior visually, and see how order and indices change with each operation.
        </p>
      </div>

      <div class="section" aria-labelledby="interact">
        <strong id="interact">Interaction Design</strong>
        <p class="small">
          - Type a value or drag any palette chip into the front/back drop area to add. <br>
          - Use buttons to pushFront, pushBack, popFront, popBack, peek, clear, or fill randomly. <br>
          - Visual animations slide items in/out from the side you operate on. <br>
          - A live log records operations and shows current indices and the front/back positions.
        </p>
      </div>

      <div class="section" aria-labelledby="layout">
        <strong id="layout">Layout Description (Responsive & Accessible)</strong>
        <p class="small">
          Safe margins are 24px. Controls are grouped in the left panel with 16px gaps. The right panel contains the visual deque canvas centered horizontally and scrollable when deque grows. All controls are keyboard-accessible and labeled for screen readers.
        </p>
      </div>

      <div class="section controls" aria-label="controls">
        <div style="display:flex;gap:12px;align-items:center;">
          <input id="valueInput" type="text" placeholder="Enter value (e.g. A, 42, hello)" aria-label="Value to enqueue" />
          <button id="pushFrontBtn" title="Push to front (Left)" aria-label="Push front">Push Front</button>
          <button id="pushBackBtn" title="Push to back (Right)" aria-label="Push back">Push Back</button>
        </div>

        <div class="row">
          <button id="popFrontBtn" class="secondary" aria-label="Pop front">Pop Front</button>
          <button id="popBackBtn" class="secondary" aria-label="Pop back">Pop Back</button>
          <button id="peekBtn" class="secondary" aria-label="Peek both ends">Peek</button>
        </div>

        <div class="row">
          <button id="clearBtn" class="danger" aria-label="Clear deque">Clear</button>
          <button id="fillBtn" class="positive" aria-label="Fill with random">Fill Random</button>
        </div>

        <div style="display:flex;align-items:center;gap:12px;">
          <label for="capacity">Capacity</label>
          <input id="capacity" type="number" min="1" max="20" value="9" aria-label="Maximum capacity" style="width:84px" />
          <div style="flex:1;color:var(--muted);font-size:13px;text-align:right;">Current size: <span id="sizeLabel">0</span></div>
        </div>

        <div>
          <label style="display:block;margin-bottom:6px;color:var(--muted);font-size:13px;">Drag Palette (or type then push)</label>
          <div class="palette" role="list" aria-label="draggable sample values">
            <div class="chip" draggable="true" tabindex="0">1</div>
            <div class="chip" draggable="true" tabindex="0">A</div>
            <div class="chip" draggable="true" tabindex="0">42</div>
            <div class="chip" draggable="true" tabindex="0">X</div>
            <div class="chip" draggable="true" tabindex="0">hello</div>
            <div class="chip" draggable="true" tabindex="0">!?</div>
          </div>
        </div>

      </div>

      <div style="display:flex;flex-direction:column;gap:8px;">
        <div class="small" style="color:var(--muted);">Keyboard tips</div>
        <div class="small" style="color:var(--muted);">Focus the input and press Enter to pushBack. Use the buttons with Tab then Space/Enter.</div>
      </div>
    </aside>

    <!-- RIGHT COLUMN: Visualization and logs -->
    <section class="right-column" aria-label="Visualization">
      <div style="display:flex;align-items:center;justify-content:space-between;">
        <div>
          <h2>Deque Visualizer</h2>
          <div style="font-size:13px;color:var(--muted);">Animated nodes show pushes/pops at either end.</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <div class="marker" id="frontMarker" aria-hidden="true" title="Front pointer">Front</div>
          <div class="marker back" id="backMarker" aria-hidden="true" title="Back pointer">Back</div>
        </div>
      </div>

      <div class="deque-area">
        <div class="deque-canvas" id="canvas" aria-live="polite">
          <div class="deque-wrapper">
            <div class="deque" id="deque" role="list" aria-label="Deque contents">
              <!-- Nodes rendered here -->
            </div>
          </div>

          <!-- Drop overlay with front/back drop zones -->
          <div class="drop-target" id="dropTarget" aria-hidden="true">
            <div class="drop-zone" id="dropFront" data-end="front" tabindex="0" aria-label="Drop here to push front">Front</div>
            <div style="flex:1"></div>
            <div class="drop-zone" id="dropBack" data-end="back" tabindex="0" aria-label="Drop here to push back">Back</div>
          </div>
        </div>

        <div style="display:flex;gap:16px;align-items:flex-start;">
          <div style="flex:1">
            <div class="section" style="padding:10px;">
              <strong style="font-size:13px">Operations Log</strong>
              <div class="log" id="log" aria-live="polite" role="log" tabindex="0"></div>
            </div>
          </div>

          <div style="width:220px;">
            <div class="section" style="padding:10px;">
              <strong style="font-size:13px">Quick Peek</strong>
              <div id="peekView" class="small" style="margin-top:8px;color:var(--muted);">Front: ‚Äî  ‚Ä¢  Back: ‚Äî</div>
              <div style="margin-top:12px;font-size:13px;color:var(--muted);">Time complexity: O(1) for push/pop at both ends.</div>
            </div>
          </div>
        </div>

        <div class="footer">
          <div style="color:var(--muted);font-size:13px;">Note: Drag chips or type a value; empty values are ignored.</div>
          <div style="color:var(--muted);font-size:13px;">Indices are shown per current layout (0-based, left-to-right)</div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Deque Interactive Module JS
    (function(){
      // DOM elements
      const valueInput = document.getElementById('valueInput');
      const pushFrontBtn = document.getElementById('pushFrontBtn');
      const pushBackBtn = document.getElementById('pushBackBtn');
      const popFrontBtn = document.getElementById('popFrontBtn');
      const popBackBtn = document.getElementById('popBackBtn');
      const peekBtn = document.getElementById('peekBtn');
      const clearBtn = document.getElementById('clearBtn');
      const fillBtn = document.getElementById('fillBtn');
      const dequeEl = document.getElementById('deque');
      const sizeLabel = document.getElementById('sizeLabel');
      const capacityInput = document.getElementById('capacity');
      const logEl = document.getElementById('log');
      const peekView = document.getElementById('peekView');
      const frontMarker = document.getElementById('frontMarker');
      const backMarker = document.getElementById('backMarker');
      const dropFront = document.getElementById('dropFront');
      const dropBack = document.getElementById('dropBack');
      const dropTarget = document.getElementById('dropTarget');
      const palette = document.querySelectorAll('.chip');

      // Model
      let deque = []; // simple array where left is front (index 0), right is back (end)
      let capacity = parseInt(capacityInput.value, 10) || 9;

      // Utilities
      function log(message){
        const time = new Date().toLocaleTimeString();
        const p = document.createElement('div');
        p.textContent = `[${time}] ${message}`;
        logEl.prepend(p);
      }

      function updateControls(){
        const size = deque.length;
        sizeLabel.textContent = size;
        const full = size >= capacity;
        pushFrontBtn.disabled = full;
        pushBackBtn.disabled = full;
        fillBtn.disabled = full;
        popFrontBtn.disabled = size === 0;
        popBackBtn.disabled = size === 0;
        peekBtn.disabled = size === 0;
      }

      function updatePeek(){
        const front = deque.length ? deque[0] : '‚Äî';
        const back = deque.length ? deque[deque.length -1] : '‚Äî';
        peekView.textContent = `Front: ${front}  ‚Ä¢  Back: ${back}`;
      }

      function render(){
        // Efficient re-render: clear and rebuild nodes
        dequeEl.innerHTML = '';
        deque.forEach((val, idx) => {
          const node = document.createElement('div');
          node.className = 'node';
          node.setAttribute('role','listitem');
          node.setAttribute('tabindex','0');
          node.innerHTML = `<span>${String(val)}</span><div class="index">${idx}</div>`;
          dequeEl.appendChild(node);
        });

        // update markers visual positions: front is left-most, back right-most
        // We keep markers static above canvas, but can highlight first/last nodes briefly
        updatePeek();
        updateControls();
      }

      // Animation helpers: add node with animation class, then finalize
      function animateAdd(value, end = 'back'){
        if (deque.length >= capacity) {
          log(`Cannot push: capacity (${capacity}) reached.`);
          return;
        }
        // Prepare node element separately to animate
        const node = document.createElement('div');
        node.className = 'node ' + (end === 'front' ? 'adding-left' : 'adding-right');
        node.setAttribute('role','listitem');
        node.setAttribute('tabindex','0');
        node.innerHTML = `<span>${String(value)}</span><div class="index">-</div>`;

        // Insert to DOM in the right spot (so animation direction looks correct)
        if (end === 'front'){
          dequeEl.insertBefore(node, dequeEl.firstChild);
        } else {
          dequeEl.appendChild(node);
        }

        // After short timeout, finalize by updating model and re-render indices
        requestAnimationFrame(() => {
          // Force reflow to ensure animation starts
          node.getBoundingClientRect();
          // After animation completes, commit to model and re-render to get stable state and indices
          setTimeout(() => {
            if (end === 'front'){
              deque.unshift(value);
            } else {
              deque.push(value);
            }
            renderFadeNodes();
            log(`push${capitalize(end)}("${value}") ‚Äî size now ${deque.length}`);
          }, 360);
        });
      }

      function animateRemove(end = 'front'){
        if (!deque.length) {
          log('Cannot pop: deque is empty.');
          return;
        }
        // target element in DOM
        const targetNode = (end === 'front') ? dequeEl.firstElementChild : dequeEl.lastElementChild;
        if (!targetNode) { return; }

        // mark it as removing
        targetNode.classList.add(end === 'front' ? 'removing-left' : 'removing-right');

        // remember the value and remove from model after animation
        const removed = (end === 'front') ? deque.shift() : deque.pop();
        setTimeout(() => {
          // remove the DOM node after animation and re-render
          renderFadeNodes();
          log(`pop${capitalize(end)}() -> "${removed}" ‚Äî size now ${deque.length}`);
        }, 320);
      }

      // Re-render but with a small fade/shift to reduce visual jump after animation
      function renderFadeNodes(){
        // temporary: create nodes based on current model and swap with a small fade
        const existing = Array.from(dequeEl.children);
        // clear and rebuild fresh nodes
        dequeEl.innerHTML = '';
        deque.forEach((val, idx) => {
          const node = document.createElement('div');
          node.className = 'node';
          node.setAttribute('role','listitem');
          node.setAttribute('tabindex','0');
          node.innerHTML = `<span>${String(val)}</span><div class="index">${idx}</div>`;
          // initial subtle scale for entrance
          node.style.transform = 'translateY(-6px) scale(.995)';
          node.style.opacity = '0';
          dequeEl.appendChild(node);
          // animate to normal
          requestAnimationFrame(() => {
            node.style.transition = 'transform 260ms ease, opacity 260ms ease';
            node.style.transform = '';
            node.style.opacity = '';
            setTimeout(()=> {
              node.style.transition = '';
            }, 320);
          });
        });
        updatePeek();
        updateControls();
      }

      // Helpers for UI events
      function capitalize(s){ return s.charAt(0).toUpperCase() + s.slice(1); }

      // Event listeners
      pushFrontBtn.addEventListener('click', () => {
        const val = valueInput.value.trim();
        if (!val){ log('Ignored empty value.'); return; }
        animateAdd(val, 'front');
        valueInput.value = '';
      });
      pushBackBtn.addEventListener('click', () => {
        const val = valueInput.value.trim();
        if (!val){ log('Ignored empty value.'); return; }
        animateAdd(val, 'back');
        valueInput.value = '';
      });

      popFrontBtn.addEventListener('click', () => animateRemove('front'));
      popBackBtn.addEventListener('click', () => animateRemove('back'));

      peekBtn.addEventListener('click', () => {
        if (!deque.length) { log('Peek: deque is empty.'); return; }
        log(`Peek -> front="${deque[0]}", back="${deque[deque.length-1]}"`);
      });

      clearBtn.addEventListener('click', () => {
        const removed = deque.slice();
        deque = [];
        render();
        log(`Cleared deque (removed ${removed.length} items).`);
      });

      fillBtn.addEventListener('click', () => {
        const samples = ['Œ±','Œ≤','Œ≥','7','K','42','Z','üçÄ','hi','X'];
        while (deque.length < capacity){
          const v = samples[Math.floor(Math.random()*samples.length)];
          // animate add at back for visual clarity
          animateAdd(v, 'back');
          // wait a little between inserts to avoid overwhelming animations
          // but since animateAdd uses timeouts we don't need to throttle here strictly.
        }
        log('Fill requested.');
      });

      capacityInput.addEventListener('change', () => {
        let v = parseInt(capacityInput.value,10);
        if (!v || v < 1) v = 1;
        if (v > 20) v = 20;
        capacity = v;
        capacityInput.value = v;
        if (deque.length > capacity) {
          // truncate tail to fit capacity
          deque = deque.slice(0, capacity);
          render();
          log(`Capacity reduced to ${capacity}. Truncated deque to fit.`);
        } else {
          log(`Capacity set to ${capacity}.`);
        }
        updateControls();
      });

      // Keyboard: pressing Enter in input will pushBack
      valueInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          pushBackBtn.click();
        }
      });

      // Drag and drop support from palette to drop zones
      palette.forEach(chip => {
        chip.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', chip.textContent.trim());
          // show drop overlay
          dropTarget.style.pointerEvents = 'auto';
          dropTarget.style.opacity = '1';
        });
        chip.addEventListener('dragend', () => {
          dropTarget.style.pointerEvents = 'none';
          dropFront.classList.remove('active-front');
          dropBack.classList.remove('active-back');
        });
        // also support keyboard "drag" by Enter/Space to pushBack for accessibility
        chip.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            valueInput.value = chip.textContent.trim();
            pushBackBtn.click();
          }
        });
      });

      // Drop zone handling
      function onDragOverEnd(e, end){
        e.preventDefault();
        if (end === 'front'){
          dropFront.classList.add('active-front');
        } else {
          dropBack.classList.add('active-back');
        }
      }
      function onDragLeaveEnd(e, end){
        if (end === 'front'){
          dropFront.classList.remove('active-front');
        } else {
          dropBack.classList.remove('active-back');
        }
      }
      function onDropEnd(e, end){
        e.preventDefault();
        const txt = e.dataTransfer.getData('text/plain') || '';
        const value = txt.trim();
        if (!value){
          log('Dropped empty value ignored.');
        } else {
          animateAdd(value, end);
        }
        dropFront.classList.remove('active-front');
        dropBack.classList.remove('active-back');
        dropTarget.style.pointerEvents = 'none';
      }

      ['dragover'].forEach(evt => {
        dropFront.addEventListener(evt, (e)=> onDragOverEnd(e, 'front'));
        dropBack.addEventListener(evt, (e)=> onDragOverEnd(e, 'back'));
      });
      dropFront.addEventListener('dragleave', (e) => onDragLeaveEnd(e, 'front'));
      dropBack.addEventListener('dragleave', (e) => onDragLeaveEnd(e, 'back'));
      dropFront.addEventListener('drop', (e) => onDropEnd(e, 'front'));
      dropBack.addEventListener('drop', (e) => onDropEnd(e, 'back'));

      // Also allow clicking drop zones to push current input value
      dropFront.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (!v){ log('No value in input to push front.'); return; }
        animateAdd(v, 'front');
        valueInput.value = '';
      });
      dropBack.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (!v){ log('No value in input to push back.'); return; }
        animateAdd(v, 'back');
        valueInput.value = '';
      });

      // Initial render
      render();
      log('Deque interactive module ready.');

      // Expose for debugging (optional)
      window.__dequeModule = {
        get deque(){ return deque.slice(); },
        pushFront: (v) => animateAdd(v, 'front'),
        pushBack: (v) => animateAdd(v, 'back'),
        popFront: () => animateRemove('front'),
        popBack: () => animateRemove('back'),
        clear: () => { deque = []; render(); },
      };

    })();
  </script>
</body>
</html>