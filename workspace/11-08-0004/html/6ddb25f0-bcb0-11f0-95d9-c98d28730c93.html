<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Binary Search Tree — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #f7fbff;
      --card: #ffffff;
      --accent: #2b6cb0;
      --accent-2: #2c7a7b;
      --muted: #666e75;
      --danger: #e53e3e;
      --ok: #2f855a;
      --node-fill: #fff;
      --node-border: #2b6cb0;
      --node-highlight: #ffd54f;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#f2f8ff 0%, #f7fbff 100%);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:#102a43;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Safe area container */
    .container{
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    header{
      display:flex;
      flex-direction:column;
      gap:8px;
      max-width:900px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    .meta{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:14px;
    }
    .card{
      background:var(--card);
      border-radius:10px;
      box-shadow: 0 6px 18px rgba(39,54,72,0.06);
      padding:18px;
    }
    .split{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      width:100%;
      flex-wrap:wrap;
    }

    /* Left column: controls & info */
    .panel{
      flex: 0 1 350px;
      min-width:300px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .panel .section-title{
      font-weight:600;
      font-size:14px;
      color:#0b3b57;
      margin-bottom:6px;
    }
    .text-small{
      font-size:13px;
      color:var(--muted);
      line-height:1.35;
    }

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }

    input[type="number"], input[type="text"]{
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #dfe7ef;
      outline:none;
      font-size:14px;
      min-width:0;
    }
    input[type="number"]:focus, input[type="text"]:focus{
      box-shadow:0 0 0 3px rgba(43,108,176,0.08);
      border-color:var(--accent);
    }
    button{
      background:var(--accent);
      color:white;
      border:none;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      font-size:14px;
    }
    button.secondary{
      background:transparent;
      color:var(--accent);
      border:1px solid #cfe6ff;
    }
    button.warn{
      background:var(--danger);
    }
    button:disabled{
      opacity:0.5;
      cursor:not-allowed;
    }
    .muted-note{
      font-size:13px;
      color:var(--muted);
    }

    /* Right column: visualization */
    .visual{
      flex:1 1 600px;
      min-width:280px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .canvas-card{
      flex:1 1 auto;
      background:linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);
      border-radius:10px;
      padding:12px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .svg-wrap{
      flex:1 1 auto;
      min-height:360px;
      position:relative;
      overflow:auto;
      border-radius:8px;
      background:
        radial-gradient(ellipse at 10% 10%, rgba(43,108,176,0.02), transparent 10%),
        radial-gradient(ellipse at 90% 90%, rgba(44,122,123,0.02), transparent 10%);
      padding:8px;
    }
    svg{
      width:100%;
      height:100%;
      overflow:visible;
      display:block;
    }

    /* Node styles */
    .node-group{
      transition: transform 600ms cubic-bezier(.2,.9,.3,1);
      cursor:pointer;
    }
    .node-circle{
      fill: var(--node-fill);
      stroke: var(--node-border);
      stroke-width:2px;
      transition: r 220ms ease, fill 220ms ease, stroke 220ms ease;
      box-shadow: 0 2px 4px rgba(16,42,67,0.06);
    }
    .node-text{
      font-size:12px;
      fill:#102a43;
      font-weight:600;
      pointer-events:none;
    }

    /* highlighted (search path / active) */
    .node-group.active .node-circle{
      fill: var(--node-highlight);
      stroke: #b97300;
      r: 22px;
    }
    .node-group.found .node-circle{
      fill: var(--ok);
      stroke: #1b6b3f;
    }
    .node-group.removing .node-circle{
      opacity:0.02;
      transform-origin:center center;
      transform:scale(0.2);
      transition: transform 400ms ease, opacity 300ms ease;
    }

    /* Edge styles */
    .edge{
      stroke:#c7d9ea;
      stroke-width:2px;
      fill:none;
      transition: stroke 240ms ease;
    }
    .edge.active{
      stroke: #7aa7d6;
      stroke-width:3px;
    }

    /* info footer */
    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }
    .legend .dot{
      width:12px;height:12px;border-radius:50%;
      display:inline-block;margin-right:6px;
    }
    .dot.path{ background: var(--node-highlight); border:2px solid #b97300; }
    .dot.found{ background: var(--ok); border:2px solid #1b6b3f; }

    /* responsive */
    @media (max-width:900px){
      .split{ flex-direction:column; }
      .panel{ order:2; }
      .visual{ order:1; }
    }

    /* small helper */
    .muted-small{ font-size:12px;color:var(--muted); }
  </style>
</head>
<body>
  <div class="container" role="main">
    <header>
      <h1>Binary Search Tree — Interactive Explorer</h1>
      <div class="meta">
        <div class="muted-small">One interactive module: explore BST structure, insertion, search, and traversal animations.</div>
        <div style="flex:1"></div>
        <div class="muted-small">Safe margins: 24px • Min spacing: 16px</div>
      </div>
    </header>

    <!-- Planning & design (required sections) -->
    <section class="card" aria-labelledby="plan-title">
      <h2 id="plan-title" style="margin:0 0 8px 0;font-size:15px;">Design Plan</h2>

      <div style="display:flex;gap:24px;flex-wrap:wrap;">
        <div style="flex:1 1 320px; min-width:260px;">
          <strong>Concept Title</strong>
          <div class="muted-note" style="margin-top:6px;">
            Binary Search Tree (BST) — visualizing insertion, search (comparison path), and in-order traversal.
          </div>
        </div>

        <div style="flex:1 1 320px; min-width:260px;">
          <strong>Learning Objective</strong>
          <div class="muted-note" style="margin-top:6px;">
            After using this module, you will be able to:
            1) Describe the BST ordering property, 2) Insert nodes and predict their position, 3) Visually follow the search path and understand why in-order traversal yields sorted keys.
          </div>
        </div>

        <div style="flex:1 1 100%; min-width:260px;">
          <strong>Interaction Design</strong>
          <div class="muted-note" style="margin-top:6px;">
            Users interact via typed inputs and clickable nodes:
            - Insert a numeric key (or use sample buttons). When inserting, the module animates comparisons by highlighting visited nodes in sequence, then animates the new node sliding into its final slot.
            - Search for a key: nodes along the comparison path are highlighted in order; if found, the node flashes green.
            - Click any node to remove it: deletion is animated (fade/scale) and the tree restructures (in-order successor replacement for two-child deletions).
            - Run an in-order traversal to animate visiting nodes left-to-right and show the resulting sorted list.
            Visual feedback uses color, size and motion to reinforce comparisons, success, and structural changes.
          </div>
        </div>

        <div style="flex:1 1 100%; min-width:260px;">
          <strong>Layout Description</strong>
          <div class="muted-note" style="margin-top:6px;">
            Layout maintains a clear two-column balance:
            - Left column (controls & descriptions) width ~350px; placed first on wide screens (panel).
            - Right column is the visualization canvas (SVG) which expands to fill remaining space.
            - Controls are stacked with a minimum spacing of 16px; the whole page keeps 24px safe-area padding.
            - Accessible controls (labels, keyboard-friendly). SVG elements are focusable via pointer; nodes respond to click/tap.
            - The SVG scales horizontally and scrolls if the tree becomes wide; node positions depend on in-order layout so structure remains readable across sizes.
          </div>
        </div>
      </div>
    </section>

    <!-- Interactive Module -->
    <section class="split">
      <!-- Controls & information -->
      <aside class="panel card" aria-labelledby="controls-title">
        <div>
          <div class="section-title" id="controls-title">Controls</div>
          <div class="text-small muted-note">Use the controls below to build and explore a Binary Search Tree. Values are numbers and must be unique.</div>
        </div>

        <div class="controls" aria-hidden="false">
          <div class="row" style="align-items:center;">
            <label for="input-value" class="muted-small" style="min-width:72px;">Value</label>
            <input id="input-value" type="number" inputmode="numeric" aria-label="Value to insert" placeholder="e.g. 42" />
            <button id="btn-insert" title="Insert value">Insert</button>
            <button id="btn-insert-rand" class="secondary" title="Insert a random value">Insert random</button>
          </div>

          <div class="row">
            <label for="search-value" class="muted-small" style="min-width:72px;">Search</label>
            <input id="search-value" type="number" inputmode="numeric" aria-label="Value to search" placeholder="e.g. 42" />
            <button id="btn-search" title="Search value">Search</button>
            <button id="btn-clear-search" class="secondary" title="Clear highlights">Clear</button>
          </div>

          <div class="row">
            <label class="muted-small" style="min-width:72px;">Traverse</label>
            <select id="traversal-type" aria-label="Traversal type">
              <option value="inorder">In-order (sorted)</option>
              <option value="preorder">Pre-order</option>
              <option value="postorder">Post-order</option>
            </select>
            <button id="btn-traverse">Animate</button>
            <button id="btn-sample" class="secondary" title="Load a sample tree">Load sample</button>
          </div>

          <div class="row">
            <button id="btn-reset" class="secondary" title="Reset tree">Reset</button>
            <button id="btn-clear" class="warn" title="Remove all nodes">Clear tree</button>
            <div style="flex:1"></div>
            <div class="muted-note">Click a node to delete it (animated).</div>
          </div>
        </div>

        <div>
          <div class="section-title">Notes & Accessibility</div>
          <div class="muted-note">
            - Buttons are keyboard operable. Press Enter in the value box to insert. <br />
            - Nodes are drawn using SVG and animate into place. Comparison path highlights help connect code-level comparisons to structure.
          </div>
        </div>

        <div>
          <div class="section-title">Mini-pseudocode (Insertion)</div>
          <div class="muted-note">
            Start at root. Compare key:
            if key &lt; node.key go left, else go right. Repeat until a null child; insert new node there. The animation mirrors these comparisons.
          </div>
        </div>

      </aside>

      <!-- Visualization area -->
      <div class="visual">
        <div class="canvas-card" aria-label="BST visualization card">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div style="font-weight:600">Visualization</div>
            <div class="muted-small">Click nodes to delete • Drag not required</div>
          </div>

          <div class="svg-wrap card" id="svg-wrap" role="img" aria-label="Binary search tree visualization">
            <svg id="svg" viewBox="0 0 1200 600" preserveAspectRatio="xMidYMid meet" tabindex="0">
              <defs>
                <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                  <feDropShadow dx="0" dy="6" stdDeviation="8" flood-color="#213B62" flood-opacity="0.06" />
                </filter>
              </defs>
              <g id="edges"></g>
              <g id="nodes"></g>
            </svg>
          </div>

          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div class="legend">
              <div><span class="dot path"></span> comparison path</div>
              <div><span class="dot found"></span> found</div>
            </div>
            <div class="muted-note" id="status">Tree empty</div>
          </div>
        </div>
      </div>
    </section>

    <footer style="display:flex;justify-content:center;padding-top:6px;">
      <div class="muted-small">Built with vanilla HTML/CSS/JS • Animations illustrate BST operations</div>
    </footer>
  </div>

  <script>
    (function () {
      /* ========= Utilities ========= */
      function el(id){ return document.getElementById(id); }
      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
      function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

      /* ========= BST Data Structure ========= */
      class BSTNode {
        constructor(key){
          this.key = key;
          this.left = null;
          this.right = null;
          this.parent = null;
          // UI id
          this.id = 'n' + Math.random().toString(36).slice(2,9);
        }
      }

      class BST {
        constructor(){
          this.root = null;
          this.size = 0;
        }

        insert(key){
          if(this.root === null){
            this.root = new BSTNode(key);
            this.size = 1;
            return this.root;
          }
          let cur = this.root;
          while(true){
            if(key === cur.key) return null; // duplicates not allowed
            if(key < cur.key){
              if(cur.left === null){
                cur.left = new BSTNode(key);
                cur.left.parent = cur;
                this.size++;
                return cur.left;
              } else cur = cur.left;
            } else {
              if(cur.right === null){
                cur.right = new BSTNode(key);
                cur.right.parent = cur;
                this.size++;
                return cur.right;
              } else cur = cur.right;
            }
          }
        }

        findPath(key){
          // returns array of nodes visited (path), last is where the search stopped
          let path = [];
          let cur = this.root;
          while(cur !== null){
            path.push(cur);
            if(key === cur.key) return path;
            cur = (key < cur.key) ? cur.left : cur.right;
          }
          return path;
        }

        contains(key){
          let cur = this.root;
          while(cur !== null){
            if(key === cur.key) return true;
            cur = key < cur.key ? cur.left : cur.right;
          }
          return false;
        }

        // deletion: returns the removed node object (not UI-safe) or null
        delete(key){
          let node = this._findNode(key);
          if(!node) return null;
          // Case 1: no children
          if(!node.left && !node.right){
            this._replaceNodeInParent(node, null);
          } else if(node.left && !node.right){
            this._replaceNodeInParent(node, node.left);
          } else if(!node.left && node.right){
            this._replaceNodeInParent(node, node.right);
          } else {
            // two children: find in-order successor (smallest in right subtree)
            let successor = node.right;
            while(successor.left) successor = successor.left;
            node.key = successor.key; // copy value
            // recursively remove successor node (which has at most right child)
            if(successor.right){
              this._replaceNodeInParent(successor, successor.right);
            } else {
              this._replaceNodeInParent(successor, null);
            }
            // size adjusted below
            this.size--;
            return node;
          }
          this.size--;
          return node;
        }

        _findNode(key){
          let cur = this.root;
          while(cur){
            if(key === cur.key) return cur;
            cur = key < cur.key ? cur.left : cur.right;
          }
          return null;
        }

        _replaceNodeInParent(node, replacement){
          if(node.parent){
            if(node === node.parent.left) node.parent.left = replacement;
            else node.parent.right = replacement;
            if(replacement) replacement.parent = node.parent;
          } else {
            this.root = replacement;
            if(replacement) replacement.parent = null;
          }
        }

        // traversals returning array of nodes
        inorder(){
          const res = [];
          function dfs(n){
            if(!n) return;
            dfs(n.left);
            res.push(n);
            dfs(n.right);
          }
          dfs(this.root);
          return res;
        }
        preorder(){
          const res = [];
          function dfs(n){
            if(!n) return;
            res.push(n);
            dfs(n.left);
            dfs(n.right);
          }
          dfs(this.root);
          return res;
        }
        postorder(){
          const res = [];
          function dfs(n){
            if(!n) return;
            dfs(n.left);
            dfs(n.right);
            res.push(n);
          }
          dfs(this.root);
          return res;
        }
      }

      /* ========= Rendering ========= */
      const svg = el('svg');
      const gNodes = el('nodes');
      const gEdges = el('edges');
      const status = el('status');

      const H_SPACING = 80;
      const V_SPACING = 96;
      let tree = new BST();

      function updateStatus(){
        status.textContent = (tree.size === 0) ? 'Tree empty' : `Nodes: ${tree.size}`;
      }

      function computePositions(){
        // assign x based on in-order index, y based on depth
        let xIndex = 0;
        const positions = new Map();

        function dfs(node, depth){
          if(!node) return;
          dfs(node.left, depth+1);
          const x = xIndex * H_SPACING;
          const y = depth * V_SPACING;
          positions.set(node, {x, y});
          xIndex++;
          dfs(node.right, depth+1);
        }
        dfs(tree.root, 0);

        // if empty, center the view
        return positions;
      }

      function clearSVG(){
        while(gNodes.firstChild) gNodes.removeChild(gNodes.firstChild);
        while(gEdges.firstChild) gEdges.removeChild(gEdges.firstChild);
      }

      function drawTree(animated = true){
        const pos = computePositions();
        clearSVG();

        if(tree.root === null){
          updateStatus();
          return;
        }

        // compute width needed
        const totalNodes = pos.size;
        const svgWidth = Math.max(600, totalNodes * H_SPACING + 120);
        const svgHeight = Math.max(240, Math.max(...Array.from(pos.values()).map(p => p.y)) + 180);
        svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

        // draw edges first
        function drawEdges(n){
          if(!n) return;
          const p = pos.get(n);
          if(n.left){
            const c = pos.get(n.left);
            const line = document.createElementNS('http://www.w3.org/2000/svg','path');
            const d = `M ${p.x+60} ${p.y+36} C ${p.x+60} ${(p.y + c.y)/2} ${c.x+60} ${(p.y + c.y)/2} ${c.x+60} ${c.y+12}`;
            line.setAttribute('d', d);
            line.setAttribute('class','edge');
            line.dataset.from = n.id;
            line.dataset.to = n.left.id;
            gEdges.appendChild(line);
          }
          if(n.right){
            const c = pos.get(n.right);
            const p2 = p;
            const line = document.createElementNS('http://www.w3.org/2000/svg','path');
            const d = `M ${p2.x+60} ${p2.y+36} C ${p2.x+60} ${(p2.y + c.y)/2} ${c.x+60} ${(p2.y + c.y)/2} ${c.x+60} ${c.y+12}`;
            line.setAttribute('d', d);
            line.setAttribute('class','edge');
            line.dataset.from = n.id;
            line.dataset.to = n.right.id;
            gEdges.appendChild(line);
          }
          drawEdges(n.left);
          drawEdges(n.right);
        }
        drawEdges(tree.root);

        // draw nodes
        for(const [node, p] of pos.entries()){
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('class','node-group');
          g.setAttribute('data-id', node.id);
          g.setAttribute('tabindex','0');
          g.setAttribute('role','button');
          g.setAttribute('aria-label', 'Node ' + node.key);
          // initial position slightly different for animation
          g.style.transform = `translate(${p.x}px, ${p.y}px)`;
          g.style.transformOrigin = '0 0';

          // circle
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('class','node-circle');
          c.setAttribute('cx', 60);
          c.setAttribute('cy', 24);
          c.setAttribute('r', 20);
          c.setAttribute('filter', 'url(#shadow)');

          // text
          const text = document.createElementNS('http://www.w3.org/2000/svg','text');
          text.setAttribute('x', 60);
          text.setAttribute('y', 28);
          text.setAttribute('text-anchor','middle');
          text.setAttribute('class','node-text');
          text.textContent = node.key;

          g.appendChild(c);
          g.appendChild(text);

          // event handling: delete on click
          g.addEventListener('click', async (ev) => {
            ev.stopPropagation();
            await animateDelete(node.key, g);
          });
          // keyboard support
          g.addEventListener('keydown', async (ev) => {
            if(ev.key === 'Enter' || ev.key === ' ') {
              ev.preventDefault();
              await animateDelete(node.key, g);
            }
          });

          gNodes.appendChild(g);
        }
        updateStatus();
      }

      /* ========= Animations & Interaction ========= */

      // Highlight sequence for path (search animation or insertion comparisons).
      // nodesParam is array of node objects
      async function animatePath(nodesParam, foundNode = null, speed = 450){
        // clear previous highlights
        clearHighlights();

        for(let i=0;i<nodesParam.length;i++){
          const node = nodesParam[i];
          const g = findNodeGroup(node);
          const edge = i>0 ? findEdgeBetween(nodesParam[i-1], node) : null;
          if(edge) edge.classList.add('active');
          if(g){
            g.classList.add('active');
            await sleep(speed);
            g.classList.remove('active');
            if(edge) edge.classList.remove('active');
          }
        }
        if(foundNode){
          const foundGroup = findNodeGroup(foundNode);
          if(foundGroup){
            foundGroup.classList.add('found');
            await sleep(700);
            foundGroup.classList.remove('found');
          }
        }
      }

      function clearHighlights(){
        gNodes.querySelectorAll('.node-group.active, .node-group.found').forEach(n => {
          n.classList.remove('active','found');
        });
        gEdges.querySelectorAll('.edge.active').forEach(e => e.classList.remove('active'));
      }

      function findNodeGroup(node){
        if(!node) return null;
        return gNodes.querySelector(`.node-group[data-id="${node.id}"]`);
      }

      function findEdgeBetween(a,b){
        if(!a || !b) return null;
        return gEdges.querySelector(`.edge[data-from="${a.id}"][data-to="${b.id}"]`);
      }

      async function animateInsert(key){
        // simulate comparisons while inserting, highlight path
        const path = tree.findPath(key);
        if(path.length === 0){
          // empty tree: create root
          const newNode = tree.insert(key);
          drawTree(true);
          // pop animation (scale)
          const g = findNodeGroup(newNode);
          if(g){
            g.classList.add('active');
            await sleep(300);
            g.classList.remove('active');
          }
          updateStatus();
          return;
        }

        // highlight path step by step, then insert
        for(let i=0;i<path.length;i++){
          const node = path[i];
          const g = findNodeGroup(node);
          const edge = i>0 ? findEdgeBetween(path[i-1], node) : null;
          if(edge) edge.classList.add('active');
          if(g) g.classList.add('active');
          await sleep(420);
          if(edge) edge.classList.remove('active');
          if(g) g.classList.remove('active');
        }

        // try to insert
        const inserted = tree.insert(key);
        if(!inserted){
          // duplicate
          flashStatus('Duplicate key — not inserted', 1200, true);
          return;
        }

        // re-render; show the inserted node as found
        drawTree(true);
        const gNew = findNodeGroup(inserted);
        if(gNew){
          // briefly animate a slide/pop: set scale via transform
          gNew.classList.add('active');
          await sleep(500);
          gNew.classList.remove('active');
        }
        flashStatus(`Inserted ${key}`, 900, false);
      }

      async function animateSearch(key){
        clearHighlights();
        if(tree.root === null){
          flashStatus('Tree empty', 800, true);
          return;
        }
        const path = tree.findPath(key);
        const last = path[path.length-1];
        // if last matches key -> found
        const found = (last && last.key === key);
        await animatePath(path, found ? last : null, 500);
        if(found) flashStatus(`Found ${key}`, 900, false);
        else flashStatus(`${key} not found`, 900, true);
      }

      async function animateDelete(key, groupElement){
        // visual delete: mark removing, then perform data deletion and re-render
        const nodeObj = tree._findNode(key);
        if(!nodeObj) {
          flashStatus('Node not found', 700, true);
          return;
        }
        // mark UI removal
        const g = groupElement || findNodeGroup(nodeObj);
        if(g){
          g.classList.add('removing');
          await sleep(360);
        }
        // perform deletion in data model
        const removed = tree.delete(key);
        if(!removed){
          flashStatus('Deletion failed', 700, true);
          return;
        }
        drawTree(true);
        flashStatus(`Deleted ${key}`, 900, false);
      }

      async function animateTraversal(type){
        clearHighlights();
        let nodes;
        if(type === 'inorder') nodes = tree.inorder();
        else if(type === 'preorder') nodes = tree.preorder();
        else nodes = tree.postorder();

        if(nodes.length === 0){
          flashStatus('Tree empty', 900, true);
          return;
        }

        // animate nodes visited in order; also show sorted keys for inorder
        for(const node of nodes){
          const g = findNodeGroup(node);
          if(g){
            g.classList.add('active');
            await sleep(300);
            g.classList.remove('active');
            await sleep(120);
          }
        }

        if(type === 'inorder'){
          const keys = nodes.map(n => n.key).join(', ');
          flashStatus('In-order -> [' + keys + ']', 2200, false);
        } else {
          flashStatus(type.replace(/^\w/,(s)=>s.toUpperCase()) + ' traversal complete', 1200, false);
        }
      }

      /* ========= UI helpers ========= */
      const inputValue = el('input-value');
      const btnInsert = el('btn-insert');
      const btnInsertRand = el('btn-insert-rand');
      const inputSearch = el('search-value');
      const btnSearch = el('btn-search');
      const btnClearSearch = el('btn-clear-search');
      const btnTraverse = el('btn-traverse');
      const traversalType = el('traversal-type');
      const btnReset = el('btn-reset');
      const btnClear = el('btn-clear');
      const btnSample = el('btn-sample');

      function flashStatus(msg, ms=1000, isError=false){
        status.textContent = msg;
        status.style.color = isError ? 'var(--danger)' : 'var(--muted)';
        setTimeout(() => {
          updateStatus();
          status.style.color = '';
        }, ms);
      }

      btnInsert.addEventListener('click', async () => {
        const v = Number(inputValue.value);
        if(!Number.isFinite(v) || inputValue.value.trim()===''){ flashStatus('Enter a valid number',800,true); return; }
        await animateInsert(v);
        inputValue.value = '';
        inputValue.focus();
      });

      inputValue.addEventListener('keydown', async (ev) => {
        if(ev.key === 'Enter') { ev.preventDefault(); btnInsert.click(); }
      });

      btnInsertRand.addEventListener('click', async () => {
        // pick random not-yet-used small number
        let tries = 0;
        let v;
        do {
          v = Math.floor(Math.random() * 99) + 1;
          tries++;
        } while(tree.contains(v) && tries < 200);
        await animateInsert(v);
      });

      btnSearch.addEventListener('click', async () => {
        const v = Number(inputSearch.value);
        if(!Number.isFinite(v) || inputSearch.value.trim()===''){ flashStatus('Enter number to search',800,true); return; }
        await animateSearch(v);
      });

      inputSearch.addEventListener('keydown', async (ev) => {
        if(ev.key === 'Enter') { ev.preventDefault(); btnSearch.click(); }
      });

      btnClearSearch.addEventListener('click', () => { clearHighlights(); });

      btnTraverse.addEventListener('click', async () => {
        await animateTraversal(traversalType.value);
      });

      btnReset.addEventListener('click', () => {
        tree = new BST();
        drawTree();
        flashStatus('Reset tree', 800, false);
      });

      btnClear.addEventListener('click', async () => {
        tree = new BST();
        drawTree();
        flashStatus('Cleared all nodes', 900, false);
      });

      btnSample.addEventListener('click', async () => {
        tree = new BST();
        const sample = [50, 30, 70, 20, 40, 60, 80, 35, 45, 55, 75];
        for(const v of sample) tree.insert(v);
        drawTree();
        flashStatus('Loaded sample tree', 1100, false);
      });

      // click background to clear highlights
      document.getElementById('svg-wrap').addEventListener('click', (ev) => {
        if(ev.target === svg || ev.currentTarget === ev.target) clearHighlights();
      });

      // initial draw
      drawTree();

      // keyboard shortcut: 'r' -> insert random, 'c' -> clear highlights
      window.addEventListener('keydown', (ev) => {
        if(ev.target && (ev.target.tagName === 'INPUT' || ev.target.tagName === 'SELECT')) return;
        if(ev.key === 'r') btnInsertRand.click();
        if(ev.key === 'c') clearHighlights();
      });

      // Expose some functions for debugging in console (optional)
      window._bst = tree;
      window._drawTree = drawTree;

    })();
  </script>
</body>
</html>