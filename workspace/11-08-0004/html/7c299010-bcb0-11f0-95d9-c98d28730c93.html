<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bellman–Ford Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #3dd9a8;
      --muted: #9aa7b2;
      --danger: #ff6b6b;
      --glass: rgba(255,255,255,0.03);
      --card: #071022;
      --radius: 10px;
      --transition: 180ms ease;
    }
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#071226 0%, #04101a 100%);
      color:#e6f0f2;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    /* Safe area margins */
    .app{
      box-sizing:border-box;
      padding:var(--safe-margin);
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:var(--gap);
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .title h1{
      margin:0;
      font-size:18px;
      letter-spacing:0.2px;
    }
    .subtitle{
      margin:0;
      font-size:13px;
      color:var(--muted);
    }

    main{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      flex:1 1 auto;
      min-height:480px;
    }

    /* Left: canvas area */
    .canvas-card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:12px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.6);
      flex:1 1 66%;
      min-width:280px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .canvas-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .controls-row{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }
    button, select{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--accent);
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      min-height:38px;
      min-width:44px;
      transition:all var(--transition);
    }
    button.primary{
      background:linear-gradient(90deg,var(--accent), #2bc7f5);
      color:#02221b;
      border:0;
      font-weight:600;
    }
    button:focus{
      outline:3px solid rgba(61,217,168,0.14);
      outline-offset:2px;
    }
    .mode-indicator{
      color:var(--muted);
      font-size:13px;
      padding-left:8px;
      min-width:160px;
    }

    .svg-wrap{
      background:transparent;
      border-radius:8px;
      border:1px dashed rgba(255,255,255,0.03);
      height:480px;
      position:relative;
      overflow:hidden;
    }
    svg{
      width:100%;
      height:100%;
      display:block;
      user-select:none;
      touch-action:none;
    }

    /* Right: info & table */
    .info-card{
      width:360px;
      max-width:44%;
      min-width:260px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.55);
    }
    .panel-title{
      font-size:14px;
      margin:0;
      color:var(--muted);
    }
    .description{
      font-size:13px;
      margin:0;
      color:#cfe3e7;
      line-height:1.35;
    }

    .table{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:8px;
      border-radius:8px;
      background:rgba(255,255,255,0.02);
    }
    .row{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px;
      border-radius:8px;
      transition:background 220ms;
    }
    .row .node-label{
      width:36px;
      height:36px;
      border-radius:8px;
      background:rgba(255,255,255,0.03);
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--accent);
      font-weight:600;
    }
    .row .meta{
      display:flex;
      justify-content:space-between;
      width:100%;
      color:var(--muted);
      font-size:13px;
    }
    .row.updated{
      background:linear-gradient(90deg, rgba(61,217,168,0.06), rgba(43,199,245,0.03));
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.02);
    }
    .footer{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }
    .status{
      color:var(--muted);
      font-size:13px;
    }
    .message{
      padding:8px 10px;
      background:rgba(255,255,255,0.02);
      border-radius:8px;
      color:#d6eef0;
      font-size:13px;
    }

    /* Animations for edge flash */
    .edge-highlight{
      stroke-width:4px !important;
      stroke-opacity:1 !important;
      filter:drop-shadow(0 4px 10px rgba(61,217,168,0.18));
      transition:stroke 220ms, stroke-width 220ms, filter 220ms;
    }
    .edge-down{
      stroke:rgba(200,80,80,0.9);
    }
    .edge-up{
      stroke:rgba(61,217,168,0.95);
    }

    /* Helper */
    .muted-small{ color:var(--muted); font-size:12px; }
    input[type="number"]{
      width:72px;
      padding:6px 8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:transparent;
      color:var(--muted);
    }

    @media (max-width:980px){
      main{ flex-direction:column; }
      .info-card{ width:100%; max-width:100%;}
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Bellman-Ford interactive tutorial">
    <header>
      <div class="title">
        <h1>Bellman–Ford Algorithm — Interactive Exploration</h1>
        <p class="subtitle">Step-by-step relaxation, negative-edge handling and negative-cycle detection</p>
      </div>

      <div style="display:flex;gap:12px;align-items:center;">
        <div class="muted-small">Safe margins: 24px — Spacing ≥ 16px</div>
        <button id="helpToggle" aria-pressed="false" title="Show explanation" style="background:transparent;border:0;color:var(--muted);">What this is</button>
      </div>
    </header>

    <main>
      <!-- LEFT: Canvas & Controls -->
      <section class="canvas-card" aria-label="Graph area">
        <div class="canvas-top">
          <div class="controls-row" role="toolbar" aria-label="Graph controls" style="align-items:center">
            <button id="presetSelectBtn" title="Load example" aria-haspopup="listbox">Load preset</button>
            <select id="presetSelect" aria-label="Choose preset graph" style="min-width:200px;">
              <option value="simple">Simple positive weights</option>
              <option value="negEdge">Negative edge (no negative cycle)</option>
              <option value="negCycle">Negative cycle</option>
            </select>

            <button id="addNodeBtn" title="Click canvas to add nodes">Add node</button>
            <button id="addEdgeBtn" title="Click a source node then a target node">Add edge</button>
            <button id="setSourceBtn" title="Click a node to mark it as source">Set source</button>

            <button id="clearBtn" title="Reset graph">Clear</button>
          </div>

          <div style="display:flex; align-items:center; gap:10px;">
            <div class="mode-indicator" id="modeIndicator">Mode: <strong id="modeText">Idle</strong></div>
          </div>
        </div>

        <div class="svg-wrap" id="svgWrap" tabindex="0" aria-label="Graph drawing area">
          <svg id="svg" viewBox="0 0 1200 720" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Graph SVG canvas">
            <defs>
              <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#cfe3e7"></path>
              </marker>
            </defs>
            <!-- edges group -->
            <g id="edges"></g>
            <!-- nodes group -->
            <g id="nodes"></g>
            <!-- weight labels -->
            <g id="edgeLabels"></g>
            <!-- interactive overlay to capture clicks when in add-node mode -->
            <rect id="overlay" x="0" y="0" width="1200" height="720" fill="transparent" style="pointer-events:none"></rect>
          </svg>
        </div>

        <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
          <div style="display:flex;gap:8px;align-items:center;">
            <button id="stepBtn" class="primary" title="Perform one relaxation step">Step</button>
            <button id="autoBtn" title="Auto-run iterations">Auto</button>
            <button id="fastRangeBtn" title="Toggle fast animation">Toggle fast</button>
          </div>

          <div style="display:flex;gap:12px;align-items:center;">
            <div class="muted-small">Iteration: <strong id="iterLabel">0</strong> / <span id="iterMax">0</span></div>
            <div class="muted-small">Edge idx: <strong id="edgeIdx">—</strong></div>
          </div>
        </div>
      </section>

      <!-- RIGHT: Info & Table -->
      <aside class="info-card" aria-label="Explanation and distance table">
        <div>
          <h3 class="panel-title">Concept Title</h3>
          <p class="description"><strong>Bellman–Ford Algorithm:</strong> single-source shortest paths on graphs that may contain negative-weight edges. It relaxes edges repeatedly and detects negative cycles reachable from the source.</p>
        </div>

        <div>
          <h4 class="panel-title">Learning Objective</h4>
          <p class="description">After interacting, you will understand how Bellman–Ford performs V−1 full passes of edge relaxations, how distances and predecessors update over time, and how the algorithm detects negative cycles by seeing a relaxation in an extra pass.</p>
        </div>

        <div>
          <h4 class="panel-title">Interaction Design</h4>
          <p class="description">
            - Add nodes by entering Add mode and clicking the canvas. Drag nodes to reposition.<br>
            - Add edges by selecting source then target; enter a numeric weight. <br>
            - Set the source node, then use Step to walk one edge relaxation at a time. Auto runs all iterations. <br>
            Visual feedback: edges flash when relaxed; distance rows highlight when updated; negative-cycle edges are shown in red.
          </p>
        </div>

        <div>
          <h4 class="panel-title">Layout Description</h4>
          <p class="description">
            Left: large, interactive SVG canvas for graph building and animation. Right: explanation and the distance table showing current distances and predecessors. Controls are placed above the canvas for quick access. Layout uses 24px margins and 16px minimum spacing for clarity and touch friendliness.
          </p>
        </div>

        <div>
          <h4 class="panel-title">Distance Table</h4>
          <div class="table" id="distTable" role="list" aria-label="Distances list">
            <!-- rows generated by JS -->
          </div>
        </div>

        <div style="display:flex;flex-direction:column;gap:8px;">
          <div class="status" id="statusMsg">Status: idle</div>
          <div class="message" id="messageBox" aria-live="polite">Tip: load a preset to get started or build your own graph.</div>
        </div>
      </aside>
    </main>
  </div>

  <script>
    /************************************************************************
     * Bellman-Ford Interactive Module
     * - Single-file vanilla JS implementation
     * - Supports adding nodes/edges, dragging nodes, step/auto execution,
     *   and negative-cycle detection.
     *
     * Accessibility notes:
     * - Buttons have labels.
     * - SVG canvas has tabindex for keyboard focus.
     *
     * Visual feedback:
     * - Edges flash green on improving relaxations; red when detecting negative cycle.
     * - Distance rows highlight on update.
     *
     * Layout guidelines respected: safe margins 24px, min spacing 16px.
     ************************************************************************/

    // Basic data structures
    let nodes = []; // {id,label,x,y,elem}
    let edges = []; // {id, from, to, weight, lineElem, labelElem}
    let sourceNode = null;

    // Alg. state
    let distances = {}; // nodeId -> number (Infinity)
    let preds = {};     // nodeId -> predecessor nodeId or null
    let iter = 0;
    let edgeIndex = 0;
    let autoTimer = null;
    let fastMode = false;

    // Modes: 'idle','addNode','addEdge','setSource','dragging'
    let mode = 'idle';
    let selectedForEdge = null;

    // DOM
    const svg = document.getElementById('svg');
    const nodesG = document.getElementById('nodes');
    const edgesG = document.getElementById('edges');
    const edgeLabelsG = document.getElementById('edgeLabels');
    const overlay = document.getElementById('overlay');

    const addNodeBtn = document.getElementById('addNodeBtn');
    const addEdgeBtn = document.getElementById('addEdgeBtn');
    const setSourceBtn = document.getElementById('setSourceBtn');
    const clearBtn = document.getElementById('clearBtn');
    const stepBtn = document.getElementById('stepBtn');
    const autoBtn = document.getElementById('autoBtn');
    const iterLabel = document.getElementById('iterLabel');
    const iterMax = document.getElementById('iterMax');
    const edgeIdxLabel = document.getElementById('edgeIdx');
    const distTable = document.getElementById('distTable');
    const statusMsg = document.getElementById('statusMsg');
    const messageBox = document.getElementById('messageBox');
    const presetSelect = document.getElementById('presetSelect');
    const presetSelectBtn = document.getElementById('presetSelectBtn');
    const modeText = document.getElementById('modeText');
    const fastRangeBtn = document.getElementById('fastRangeBtn');

    // Initialization
    function init(){
      attachListeners();
      loadPreset('simple');
      updateUI();
    }

    function attachListeners(){
      // Mode buttons
      addNodeBtn.addEventListener('click', () => setMode(mode === 'addNode' ? 'idle' : 'addNode'));
      addEdgeBtn.addEventListener('click', () => setMode(mode === 'addEdge' ? 'idle' : 'addEdge'));
      setSourceBtn.addEventListener('click', () => setMode(mode === 'setSource' ? 'idle' : 'setSource'));
      clearBtn.addEventListener('click', () => {
        if (confirm('Clear the graph?')) clearGraph();
      });

      // Canvas click: add node or handle overlay interactions
      svg.addEventListener('click', (ev) => {
        const pt = svgPoint(ev.clientX, ev.clientY);
        if (mode === 'addNode'){
          addNode(pt.x, pt.y);
          message('Added node at ('+Math.round(pt.x)+','+Math.round(pt.y)+')');
        }
      });

      // drag handling delegated to node circles
      // Step / Auto
      stepBtn.addEventListener('click', stepOnce);
      autoBtn.addEventListener('click', () => {
        if (autoTimer) stopAuto();
        else startAuto();
      });

      // presets
      presetSelectBtn.addEventListener('click', () => {
        loadPreset(presetSelect.value);
      });

      // fast toggle
      fastRangeBtn.addEventListener('click', () => {
        fastMode = !fastMode;
        message('Fast mode ' + (fastMode ? 'on' : 'off'));
      });

      // keyboard: space for step, a for auto
      document.addEventListener('keydown', (e) => {
        if (e.key === ' ') { e.preventDefault(); stepOnce(); }
        if (e.key.toLowerCase() === 'a') { e.preventDefault(); autoBtn.click(); }
      });

      // keep svg responsive: update overlay size on resize
      window.addEventListener('resize', () => {
        // viewBox is fixed; overlay is a rectangle inside svg already spanning viewBox.
      });
    }

    function setMode(m){
      mode = m;
      modeText.textContent = (m === 'idle') ? 'Idle' : (m === 'addNode') ? 'Add Node' : (m === 'addEdge') ? 'Add Edge' : (m === 'setSource') ? 'Set Source' : m;
      // update pointer behavior
      overlay.style.pointerEvents = (m === 'addNode') ? 'auto' : 'none';
      // clear any intermediate selection
      selectedForEdge = null;
      updateUI();
    }

    function updateUI(){
      addNodeBtn.style.borderColor = (mode === 'addNode') ? 'rgba(61,217,168,0.35)' : 'rgba(255,255,255,0.06)';
      addEdgeBtn.style.borderColor = (mode === 'addEdge') ? 'rgba(61,217,168,0.35)' : 'rgba(255,255,255,0.06)';
      setSourceBtn.style.borderColor = (mode === 'setSource') ? 'rgba(61,217,168,0.35)' : 'rgba(255,255,255,0.06)';
      iterMax.textContent = Math.max(0, nodes.length - 1);
      iterLabel.textContent = iter;
      edgeIdxLabel.textContent = (edges.length > 0) ? edgeIndex : '—';
      autoBtn.textContent = (autoTimer ? 'Stop' : 'Auto');
      statusMsg.textContent = 'Status: ' + (autoTimer ? 'Auto-running' : (mode === 'idle' ? 'Idle' : 'Mode: '+mode));
    }

    // Helper: convert client coords to SVG viewBox coords
    function svgPoint(clientX, clientY){
      const pt = svg.createSVGPoint();
      pt.x = clientX; pt.y = clientY;
      const ctm = svg.getScreenCTM().inverse();
      const sp = pt.matrixTransform(ctm);
      return { x: sp.x, y: sp.y };
    }

    // Node / Edge creation + rendering
    let nodeCounter = 0;
    let edgeCounter = 0;

    function addNode(x,y,label){
      const id = 'n' + (++nodeCounter);
      const lab = label || id.toUpperCase();
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('data-id', id);
      g.style.cursor = 'pointer';

      // circle
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('cx', x);
      circle.setAttribute('cy', y);
      circle.setAttribute('r', 26);
      circle.setAttribute('fill', 'rgba(255,255,255,0.02)');
      circle.setAttribute('stroke', 'rgba(255,255,255,0.04)');
      circle.setAttribute('stroke-width', 1.5);
      g.appendChild(circle);

      // label
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x', x);
      text.setAttribute('y', y + 5);
      text.setAttribute('text-anchor','middle');
      text.setAttribute('fill', '#bff3e7');
      text.setAttribute('font-size', 14);
      text.setAttribute('font-weight', 700);
      text.textContent = lab;
      g.appendChild(text);

      nodesG.appendChild(g);

      const nodeObj = { id, label: lab, x, y, g, circle, text };
      nodes.push(nodeObj);

      // Attach node interactions: click, drag
      g.addEventListener('mousedown', (ev) => nodeMouseDown(ev, nodeObj));
      g.addEventListener('click', (ev) => nodeClick(ev, nodeObj));

      // update distances table and UI
      resetAlgorithmState();
      renderDistanceTable();
      updateUI();
    }

    function addEdge(fromId, toId, weight){
      const id = 'e' + (++edgeCounter);
      const fromNode = nodes.find(n => n.id === fromId);
      const toNode = nodes.find(n => n.id === toId);
      if (!fromNode || !toNode) return;

      // line (use path for offset)
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('fill','none');
      path.setAttribute('stroke','#cfe3e7');
      path.setAttribute('stroke-width',2);
      path.setAttribute('marker-end','url(#arrow)');
      path.style.transition = 'stroke 220ms, stroke-width 220ms';
      edgesG.appendChild(path);

      // label
      const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
      lbl.setAttribute('fill','#d8f7ef');
      lbl.setAttribute('font-size',13);
      lbl.setAttribute('text-anchor','middle');
      lbl.textContent = weight;
      edgeLabelsG.appendChild(lbl);

      const eObj = { id, from: fromId, to: toId, weight: Number(weight), path, lbl, fromNode, toNode };
      edges.push(eObj);
      positionEdge(eObj);

      // click on edge to edit weight
      path.addEventListener('click', (ev) => {
        ev.stopPropagation();
        const w = prompt('Edge weight (number):', '' + eObj.weight);
        if (w !== null){
          const num = Number(w);
          if (!Number.isFinite(num)){ alert('Please enter a valid number'); }
          else { eObj.weight = num; eObj.lbl.textContent = num; resetAlgorithmState(); renderDistanceTable(); }
        }
      });

      resetAlgorithmState();
      renderDistanceTable();
      updateUI();
    }

    function positionEdge(e){
      const fx = e.fromNode.x, fy = e.fromNode.y;
      const tx = e.toNode.x, ty = e.toNode.y;

      // compute a line with small offset so arrow appears outside circle
      const dx = tx - fx, dy = ty - fy;
      const len = Math.hypot(dx,dy) || 0.0001;
      const r = 28; // node radius + pad
      const sx = fx + (dx/len) * r;
      const sy = fy + (dy/len) * r;
      const ex = tx - (dx/len) * r;
      const ey = ty - (dy/len) * r;

      const d = `M ${sx} ${sy} L ${ex} ${ey}`;
      e.path.setAttribute('d', d);
      // label midpoint
      const mx = (sx + ex)/2, my = (sy + ey)/2;
      e.lbl.setAttribute('x', mx);
      e.lbl.setAttribute('y', my - 8);
      e.lbl.textContent = e.weight;
    }

    // Node interactions
    let dragState = null;
    function nodeMouseDown(ev, node){
      ev.stopPropagation();
      if (mode === 'addEdge' || mode === 'setSource'){
        // no drag in these modes
        return;
      }
      // start drag
      dragState = { node, startX: ev.clientX, startY: ev.clientY, origX: node.x, origY: node.y };
      document.addEventListener('mousemove', nodeMouseMove);
      document.addEventListener('mouseup', nodeMouseUp);
    }

    function nodeMouseMove(ev){
      if (!dragState) return;
      const dx = ev.clientX - dragState.startX;
      const dy = ev.clientY - dragState.startY;
      const pt = svgPoint(ev.clientX, ev.clientY);
      const nx = pt.x;
      const ny = pt.y;
      dragState.node.x = nx;
      dragState.node.y = ny;
      // update DOM
      dragState.node.circle.setAttribute('cx', nx);
      dragState.node.circle.setAttribute('cy', ny);
      dragState.node.text.setAttribute('x', nx);
      dragState.node.text.setAttribute('y', ny + 5);
      // reposition all edges connected to this node
      edges.forEach(e => {
        if (e.from === dragState.node.id || e.to === dragState.node.id){
          positionEdge(e);
        }
      });
    }
    function nodeMouseUp(){
      if (!dragState) return;
      dragState = null;
      document.removeEventListener('mousemove', nodeMouseMove);
      document.removeEventListener('mouseup', nodeMouseUp);
      resetAlgorithmState(); // moving nodes doesn't affect weights but stops any running auto
      updateUI();
    }

    function nodeClick(ev, node){
      ev.stopPropagation();
      if (mode === 'addEdge'){
        if (!selectedForEdge){
          selectedForEdge = node;
          message('Selected source ' + node.label + '. Now click target node.');
        } else {
          if (selectedForEdge.id === node.id){
            message('Cannot add self-loop in this demo.');
            selectedForEdge = null;
            return;
          }
          const weightStr = prompt('Edge weight (number):', '1');
          if (weightStr === null){ selectedForEdge = null; return; }
          const w = Number(weightStr);
          if (!Number.isFinite(w)){ alert('Please enter a valid number'); selectedForEdge = null; return; }
          addEdge(selectedForEdge.id, node.id, w);
          message('Added edge ' + selectedForEdge.label + ' → ' + node.label + ' (weight '+w+')');
          selectedForEdge = null;
        }
      } else if (mode === 'setSource'){
        sourceNode = node.id;
        message('Source set to ' + node.label);
        resetAlgorithmState();
        updateUI();
      } else {
        // in idle: clicking does nothing special
      }
    }

    // Distance table UI
    function renderDistanceTable(){
      distTable.innerHTML = '';
      // Ensure distances/preds include all nodes
      nodes.forEach(n => {
        if (!(n.id in distances)) distances[n.id] = Infinity;
        if (!(n.id in preds)) preds[n.id] = null;
      });
      nodes.forEach(n => {
        const row = document.createElement('div');
        row.className = 'row';
        row.setAttribute('role','listitem');
        const label = document.createElement('div');
        label.className = 'node-label';
        label.textContent = n.label;
        const meta = document.createElement('div');
        meta.className = 'meta';
        const left = document.createElement('div');
        left.innerHTML = '<strong>dist:</strong> <span style="color:#dffaf0">' + (isFinite(distances[n.id]) ? distances[n.id] : '∞') + '</span>';
        const right = document.createElement('div');
        right.innerHTML = '<strong>pred:</strong> <span style="color:#cfe3e7">' + (preds[n.id] ? nodeLabel(preds[n.id]) : '—') + '</span>';
        meta.appendChild(left);
        meta.appendChild(right);
        row.appendChild(label);
        row.appendChild(meta);
        distTable.appendChild(row);
      });

      // highlight source
      if (sourceNode){
        const idx = nodes.findIndex(n => n.id === sourceNode);
        if (idx >= 0){
          const r = distTable.children[idx];
          r.style.background = 'linear-gradient(90deg, rgba(61,217,168,0.04), rgba(43,199,245,0.02))';
        }
      }
    }
    function nodeLabel(id){
      const n = nodes.find(x => x.id === id);
      return n ? n.label : id;
    }

    // Algorithm control
    function resetAlgorithmState(){
      stopAuto();
      // reset distances and preds
      distances = {};
      preds = {};
      nodes.forEach(n => {
        distances[n.id] = Infinity;
        preds[n.id] = null;
      });
      iter = 0;
      edgeIndex = 0;
      if (sourceNode){
        distances[sourceNode] = 0;
      } else {
        // If no source, choose first node by default (but algorithm expects explicit source)
        if (nodes[0]) distances[nodes[0].id] = Infinity;
      }
      // clean edge styling
      edges.forEach(e => {
        e.path.style.stroke = '#cfe3e7';
        e.path.classList.remove('edge-highlight','edge-up','edge-down');
      });
      renderDistanceTable();
      updateUI();
    }

    function stepOnce(){
      if (!sourceNode){
        message('Set a source node before running the algorithm.');
        return;
      }
      if (edges.length === 0){
        message('No edges to relax.');
        return;
      }
      // If we've already done V-1 iterations and detection step, do nothing or indicate finished
      const maxIters = Math.max(0, nodes.length - 1);
      if (iter < maxIters){
        // perform one edge relaxation (in sequence)
        if (edgeIndex >= edges.length){
          // finished a full pass
          iter++;
          edgeIndex = 0;
          updateUI();
          if (iter < maxIters) message('Starting iteration ' + (iter + 1));
          else message('Finished V-1 iterations; next step performs negative-cycle detection pass.');
          return;
        }
        relaxEdgeAt(edgeIndex, /*detectionMode=*/false).then((improved) => {
          edgeIndex++;
          updateUI();
        });
      } else if (iter === maxIters){
        // perform final detection pass: if any relaxation happens now, negative cycle exists
        if (edgeIndex >= edges.length){
          // finished detection fully
          iter++;
          edgeIndex = 0;
          updateUI();
          message('Negative cycle detection pass complete.');
          return;
        }
        relaxEdgeAt(edgeIndex, /*detectionMode=*/true).then((improved) => {
          edgeIndex++;
          updateUI();
        });
      } else {
        message('Algorithm finished. Reset or modify graph to run again.');
      }
    }

    // Returns a Promise that resolves once animation completes
    function relaxEdgeAt(i, detectionMode){
      return new Promise((resolve) => {
        const e = edges[i];
        if (!e) { resolve(false); return; }
        // Visual flash
        animateEdgeFlash(e, detectionMode ? 'detect' : 'relax');

        const u = e.from;
        const v = e.to;
        const w = Number(e.weight);
        const du = distances[u];
        const dv = distances[v];
        // Only relax if reachable
        if (isFinite(du) && du + w < dv){
          if (detectionMode){
            // Negative cycle edge
            highlightNegativeCycleEdge(e);
            message('Negative cycle detected (edge ' + nodeLabel(u) + ' → ' + nodeLabel(v) + ' can still relax).');
            resolve(true);
            return;
          } else {
            // Perform relaxation
            distances[v] = du + w;
            preds[v] = u;
            // Update UI (distance table)
            renderDistanceTable();
            flashDistanceRow(v);
            message('Relaxed edge ' + nodeLabel(u) + ' → ' + nodeLabel(v) + ': dist['+nodeLabel(v)+'] = ' + distances[v]);
            resolve(true);
            return;
          }
        } else {
          // no change
          resolve(false);
          return;
        }
      });
    }

    function animateEdgeFlash(e, type){
      // type: 'relax' = green pulse, 'detect' = red pulse
      const color = (type === 'detect') ? '#ff7b7b' : '#3dd9a8';
      e.path.style.stroke = color;
      e.path.style.strokeWidth = 4;
      e.path.classList.add('edge-highlight', (type === 'detect') ? 'edge-down' : 'edge-up');
      // return to normal after short delay
      const dur = fastMode ? 200 : 700;
      setTimeout(() => {
        // only reset if not in detection red highlight state
        if (type === 'relax'){
          e.path.style.stroke = '#cfe3e7';
          e.path.style.strokeWidth = 2;
          e.path.classList.remove('edge-highlight','edge-up');
        }
        // detection edges remain red (handled separately)
      }, dur);
    }

    function highlightNegativeCycleEdge(e){
      e.path.style.stroke = '#ff6b6b';
      e.path.style.strokeWidth = 4;
      e.path.classList.add('edge-down','edge-highlight');
    }

    function flashDistanceRow(nodeId){
      // find row corresponding to node
      const idx = nodes.findIndex(n => n.id === nodeId);
      if (idx < 0) return;
      const row = distTable.children[idx];
      row.classList.add('updated');
      setTimeout(() => row.classList.remove('updated'), fastMode ? 300 : 1000);
    }

    function startAuto(){
      if (!sourceNode){ message('Set source first.'); return; }
      if (autoTimer) return;
      autoBtn.textContent = 'Stop';
      const delay = fastMode ? 80 : 700;
      autoTimer = setInterval(() => {
        // stop if finished
        const finished = (iter > nodes.length); // iter > V means fully done
        if (finished){
          stopAuto();
          message('Auto-run complete.');
          return;
        }
        stepOnce();
      }, delay);
      updateUI();
    }
    function stopAuto(){
      if (autoTimer) clearInterval(autoTimer);
      autoTimer = null;
      autoBtn.textContent = 'Auto';
      updateUI();
    }

    // Graph management
    function clearGraph(){
      // Remove DOM elements
      nodesG.innerHTML = '';
      edgesG.innerHTML = '';
      edgeLabelsG.innerHTML = '';
      nodes = [];
      edges = [];
      nodeCounter = 0;
      edgeCounter = 0;
      sourceNode = null;
      resetAlgorithmState();
      message('Graph cleared.');
      updateUI();
    }

    // Presets
    function loadPreset(name){
      clearGraph();
      if (name === 'simple'){
        addNode(220,160,'A'); // n1
        addNode(420,160,'B'); // n2
        addNode(620,160,'C'); // n3
        addEdge('n1','n2',6);
        addEdge('n1','n3',7);
        addEdge('n2','n3',8);
        addEdge('n2','n1',-2);
        sourceNode = 'n1';
        message('Loaded simple positive-weights example.');
      } else if (name === 'negEdge'){
        addNode(200,160,'s'); // n1
        addNode(420,120,'u'); // n2
        addNode(420,240,'v'); // n3
        addNode(640,160,'x'); // n4
        addEdge('n1','n2',1);
        addEdge('n1','n3',4);
        addEdge('n2','n3',-3); // negative edge but no negative cycle
        addEdge('n3','n4',2);
        addEdge('n2','n4',2);
        sourceNode = 'n1';
        message('Loaded negative-edge (no negative cycle) example.');
      } else if (name === 'negCycle'){
        // classic negative cycle reachable from source
        addNode(180,160,'s'); // n1
        addNode(420,80,'a');  // n2
        addNode(420,240,'b'); // n3
        addNode(640,160,'c'); // n4
        addEdge('n1','n2',1);
        addEdge('n2','n3',-2);
        addEdge('n3','n4',-1);
        addEdge('n4','n2',-1); // creates negative cycle a->b->c->a total -4
        sourceNode = 'n1';
        message('Loaded negative-cycle example (cycle reachable from source).');
      }
      resetAlgorithmState();
      updateUI();
    }

    // Utility
    function message(text){
      messageBox.textContent = text;
    }

    // Initialize
    init();
  </script>
</body>
</html>