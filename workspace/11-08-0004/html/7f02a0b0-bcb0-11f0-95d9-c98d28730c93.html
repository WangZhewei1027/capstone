<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Huffman Coding — Interactive Module</title>
  <style>
    :root{
      --pad: 24px;         /* safe area padding */
      --gap: 16px;         /* minimum spacing */
      --bg: #0f1724;
      --card: #0b1220;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --accent-2: #34d399;
      --danger: #fb7185;
      --panel-radius: 10px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg, #071025 0%, #061426 100%);
      color: #e6eef8;
      font-family: Inter, Roboto, system-ui, -apple-system, "Segoe UI", Arial, sans-serif;
    }
    .app{
      padding: var(--pad);
      box-sizing: border-box;
      min-height:100%;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    /* Top descriptive area */
    .info {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      padding: 18px;
      border-radius: var(--panel-radius);
      display:flex;
      flex-direction: column;
      gap: 12px;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .title h1{
      margin:0;
      font-size:20px;
      letter-spacing: -0.2px;
    }
    .objective{
      color: var(--muted);
      font-size:13px;
      margin:0;
    }
    .meta{
      display:flex;
      gap: var(--gap);
      flex-wrap:wrap;
      color: var(--muted);
      font-size:13px;
    }
    .meta .meta-card{
      background: rgba(255,255,255,0.02);
      padding:12px;
      border-radius:8px;
      min-width:240px;
      flex:1;
    }

    /* Main interactive layout */
    .main {
      display:flex;
      gap: var(--gap);
      align-items:stretch;
    }
    .col {
      background: rgba(255,255,255,0.02);
      border-radius: var(--panel-radius);
      padding: 16px;
      box-sizing: border-box;
      min-width:0;
    }
    .left {
      width: 380px;
      max-width: 42%;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }
    .right {
      flex:1;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    /* Inputs and controls */
    textarea{
      width:100%;
      min-height:100px;
      resize:vertical;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.03);
      color: #e6eef8;
      padding:10px;
      border-radius:8px;
      font-family: var(--mono);
      font-size:13px;
    }
    .row {
      display:flex;
      gap: 12px;
      flex-wrap:wrap;
    }
    button{
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.04);
      color: #e6eef8;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }
    button.primary{
      background: linear-gradient(180deg, var(--accent), #2b79d8);
      border: none;
      color: #04202a;
      font-weight:600;
    }
    button.ghost{
      background: transparent;
      border: 1px dashed rgba(255,255,255,0.04);
    }
    button:focus { outline: 3px solid rgba(96,165,250,0.18); }
    .controls {
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }

    /* Queue area */
    .queue{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .node-button{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      padding:10px;
      background: linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));
      border-radius:8px;
      border: 1px solid rgba(255,255,255,0.03);
      cursor:pointer;
      transition: transform 180ms ease, box-shadow 180ms ease;
    }
    .node-button[aria-pressed="true"]{
      box-shadow: 0 6px 18px rgba(52,211,153,0.08);
      transform: translateY(-3px);
      border-color: rgba(52,211,153,0.18);
    }
    .node-left{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .symbol-box{
      min-width:38px;
      min-height:38px;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,0.02);
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.03);
      font-family: var(--mono);
      font-size:14px;
    }
    .node-meta{
      color: var(--muted);
      font-size:13px;
    }
    .node-weight{
      font-weight:700;
      font-size:14px;
      color: var(--accent-2);
    }
    .hint{
      color: var(--accent);
      font-size:13px;
    }

    /* SVG tree */
    .svg-wrap{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));
      border-radius:8px;
      padding:8px;
      min-height:280px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    svg{
      width:100%;
      height:320px;
      overflow:visible;
    }
    .codes{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }
    .code-item{
      background: rgba(255,255,255,0.02);
      padding:8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      min-width:120px;
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:center;
    }
    .bits{
      font-family: var(--mono);
      font-size:13px;
      color: #dbeafe;
    }

    /* encoded output */
    .encoded{
      background: rgba(0,0,0,0.12);
      padding:8px;
      border-radius:6px;
      font-family: var(--mono);
      font-size:13px;
      color: #e6eef8;
      max-height:120px;
      overflow:auto;
    }

    /* messages */
    .status{
      color: var(--muted);
      font-size:13px;
    }
    .live {
      position:relative;
    }
    .shake {
      animation: shake 360ms ease;
    }
    @keyframes shake {
      0% { transform: translateX(0) }
      20% { transform: translateX(-6px) }
      40% { transform: translateX(6px) }
      60% { transform: translateX(-4px) }
      80% { transform: translateX(4px) }
      100% { transform: translateX(0) }
    }

    /* small screens: stack layout */
    @media (max-width: 920px){
      .main { flex-direction:column; }
      .left { width:100%; max-width:100%; }
      svg { height:260px; }
    }

    /* small helper visuals in svg nodes */
    .node-circle { fill: #0b1220; stroke: rgba(255,255,255,0.06); stroke-width:1.5; }
    .node-text { fill: #e6eef8; font-size:13px; font-family: var(--mono); }
    .edge { stroke: rgba(255,255,255,0.06); stroke-width:1.6; fill:none; }
    .edge-anim { stroke-dasharray: 200; stroke-dashoffset: 200; animation: draw 600ms ease forwards; }
    @keyframes draw { to { stroke-dashoffset: 0; } }

    .highlight { stroke: rgba(96,165,250,0.9) !important; stroke-width:2.2 !important; }
    .node-circle.highlight { stroke: rgba(96,165,250,0.9) !important; box-shadow: 0 0 0 4px rgba(96,165,250,0.06); }
  </style>
</head>
<body>
  <div class="app" role="main">
    <div class="info" aria-labelledby="title">
      <div class="title">
        <h1 id="title">Huffman Coding — Build the Prefix Tree</h1>
        <div class="objective">Interactively construct a Huffman tree from symbol frequencies, derive binary codes, and observe compression effects.</div>
      </div>

      <div class="meta" aria-hidden="false">
        <div class="meta-card">
          <strong>Interaction Design (summary)</strong>
          <div style="margin-top:8px; color:var(--muted); font-size:13px;">
            Type or paste text, Analyze to get symbol frequencies, then build the Huffman tree by selecting two smallest nodes and merging (or auto-step). Watch animated merges and tree drawing. Encode/decode sample text and inspect codes.
          </div>
        </div>
        <div class="meta-card">
          <strong>Layout description</strong>
          <div style="margin-top:8px; color:var(--muted); font-size:13px;">
            Left column: controls and priority queue (selectable nodes). Right column: dynamic SVG tree, code table, and encoded output. Minimum spacing: 16px; safe padding: 24px.
          </div>
        </div>
      </div>
    </div>

    <div class="main" aria-live="polite">
      <!-- Left column: controls and queue -->
      <div class="col left" aria-label="Controls and priority queue">
        <label for="inputText" style="font-weight:600;">Sample text</label>
        <textarea id="inputText" aria-label="Sample text input">this is an example for huffman coding</textarea>
        <div class="row controls">
          <button id="analyzeBtn" class="primary" title="Analyze text">Analyze</button>
          <button id="resetBtn" class="ghost" title="Reset everything">Reset</button>
          <button id="hintBtn" title="Highlight smallest two">Hint</button>
        </div>

        <div>
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <strong>Priority queue (select 2 to merge)</strong>
            <div class="hint" id="queueHint">Greedy: merge the two smallest</div>
          </div>
          <div id="queue" class="queue" aria-label="Priority queue of nodes" tabindex="0"></div>
        </div>

        <div class="row controls">
          <button id="mergeBtn" title="Merge selected nodes">Merge Selected</button>
          <button id="autoStepBtn" title="Auto step merge">Auto Step</button>
          <button id="autoFinishBtn" title="Finish automatically">Auto-Finish</button>
        </div>

        <div>
          <strong>Encode / Decode</strong>
          <div style="margin-top:8px; display:flex; gap:8px;">
            <button id="encodeBtn">Encode text</button>
            <button id="decodeBtn">Decode bits</button>
            <input id="bitsInput" placeholder="bits to decode (optional)" style="flex:1; min-width:120px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit;" aria-label="Bits input for decoding" />
          </div>
        </div>

        <div aria-live="polite" class="live">
          <div id="status" class="status" style="margin-top:8px;">Awaiting analysis.</div>
          <div style="margin-top:8px; color:var(--muted); font-size:13px;">
            <strong>Tip:</strong> You can press Tab to focus nodes and Enter to select them.
          </div>
        </div>
      </div>

      <!-- Right column: SVG + codes -->
      <div class="col right" aria-label="Visualization and codes">
        <div class="svg-wrap" aria-hidden="false">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <strong>Huffman tree (evolving)</strong>
            <div id="treeNote" style="color:var(--muted); font-size:13px;">Empty until first merge</div>
          </div>
          <svg id="treeSvg" viewBox="0 0 800 320" role="img" aria-label="Huffman tree visualization"></svg>
        </div>

        <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:12px;">
          <div style="flex:1">
            <strong>Codes</strong>
            <div id="codes" class="codes" style="margin-top:8px;"></div>
          </div>
          <div style="flex:1">
            <strong>Encoded (bitstring)</strong>
            <div id="encoded" class="encoded" style="margin-top:8px;">—</div>
          </div>
        </div>

        <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
          <div style="color:var(--muted); font-size:13px;" id="metrics">Original: — bits · Encoded: — bits · Ratio: —</div>
          <div style="color:var(--muted); font-size:13px;">Hover code to highlight path</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function(){
      /* Simple Huffman interactive implementation */
      const el = {
        inputText: document.getElementById('inputText'),
        analyzeBtn: document.getElementById('analyzeBtn'),
        resetBtn: document.getElementById('resetBtn'),
        hintBtn: document.getElementById('hintBtn'),
        queue: document.getElementById('queue'),
        mergeBtn: document.getElementById('mergeBtn'),
        autoStepBtn: document.getElementById('autoStepBtn'),
        autoFinishBtn: document.getElementById('autoFinishBtn'),
        treeSvg: document.getElementById('treeSvg'),
        codes: document.getElementById('codes'),
        encoded: document.getElementById('encoded'),
        encodeBtn: document.getElementById('encodeBtn'),
        decodeBtn: document.getElementById('decodeBtn'),
        bitsInput: document.getElementById('bitsInput'),
        status: document.getElementById('status'),
        treeNote: document.getElementById('treeNote'),
        metrics: document.getElementById('metrics'),
        queueHint: document.getElementById('queueHint')
      };

      // State
      let nodes = []; // current queue nodes (objects)
      let allNodes = []; // includes internal nodes for id reference
      let selected = new Set();
      let nextId = 1;
      let originalText = '';
      let finalRoot = null;
      let autoFinishAbort = false;

      // Utilities
      function uid(){ return nextId++; }
      function clearState(){
        nodes = [];
        allNodes = [];
        selected.clear();
        finalRoot = null;
        nextId = 1;
        autoFinishAbort = false;
        el.treeSvg.innerHTML = '';
        el.codes.innerHTML = '';
        el.encoded.textContent = '—';
        el.metrics.textContent = 'Original: — bits · Encoded: — bits · Ratio: —';
        el.treeNote.textContent = 'Empty until first merge';
        el.status.textContent = 'Awaiting analysis.';
        el.queue.innerHTML = '';
      }

      // Create initial nodes from text
      function analyzeText(){
        originalText = el.inputText.value || '';
        if(originalText.length === 0){
          el.status.textContent = 'Please enter some text to analyze.';
          return;
        }
        const freq = {};
        for(const ch of originalText){
          freq[ch] = (freq[ch] || 0) + 1;
        }
        // create nodes
        nodes = [];
        allNodes = [];
        for(const [sym, w] of Object.entries(freq)){
          const n = {
            id: uid(),
            symbol: sym,
            weight: w,
            left: null,
            right: null,
            createdAt: Date.now() + Math.random(),
          };
          nodes.push(n);
          allNodes.push(n);
        }
        // sort ascending by weight then createdAt
        sortQueue();
        renderQueue();
        el.status.textContent = `Analyzed "${originalText.length}" chars → ${nodes.length} distinct symbols. Select two smallest to merge (or use Auto Step).`;
        el.treeNote.textContent = 'Start merging to build the tree';
        finalRoot = null;
        el.encoded.textContent = '—';
        el.codes.innerHTML = '';
        updateMetrics();
      }

      function sortQueue(){
        nodes.sort((a,b)=>{
          if(a.weight !== b.weight) return a.weight - b.weight;
          return a.createdAt - b.createdAt;
        });
      }

      function renderQueue(){
        el.queue.innerHTML = '';
        for(const n of nodes){
          const item = document.createElement('button');
          item.className = 'node-button';
          item.setAttribute('role','button');
          item.setAttribute('aria-pressed', selected.has(n.id) ? 'true' : 'false');
          item.tabIndex = 0;
          item.dataset.id = n.id;
          item.title = `weight ${n.weight} ${n.symbol ? 'symbol: ' + JSON.stringify(n.symbol) : '(internal)'}`;
          item.innerHTML = `
            <div class="node-left">
              <div class="symbol-box">${n.symbol ? escapeHtml(n.symbol) : '∑'}</div>
              <div style="display:flex; flex-direction:column;">
                <div style="font-weight:600;">${n.symbol ? printSymbol(n.symbol) : 'Internal'}</div>
                <div class="node-meta">${n.symbol ? 'symbol' : 'composite'}</div>
              </div>
            </div>
            <div class="node-weight">${n.weight}</div>
          `;
          item.addEventListener('click', ()=> toggleSelect(n.id));
          item.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter' || e.key === ' '){
              e.preventDefault();
              toggleSelect(n.id);
            }
          });
          el.queue.appendChild(item);
        }
      }

      function escapeHtml(s){
        return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
      }
      function printSymbol(s){
        if(s === ' ') return "'space'";
        if(s === '\n') return "'\\n'";
        return JSON.stringify(s);
      }

      function toggleSelect(id){
        if(selected.has(id)) selected.delete(id);
        else {
          if(selected.size >= 2){
            // keep max 2
            return;
          }
          selected.add(id);
        }
        updateSelectionVisuals();
        if(selected.size === 2){
          el.status.textContent = 'Two nodes selected. Press "Merge Selected" or use Auto Step.';
        } else {
          el.status.textContent = 'Select two nodes to merge.';
        }
      }
      function updateSelectionVisuals(){
        for(const btn of el.queue.querySelectorAll('.node-button')){
          const id = Number(btn.dataset.id);
          btn.setAttribute('aria-pressed', selected.has(id) ? 'true' : 'false');
        }
      }

      // Merge operation: enforce greedy rule (must be two smallest)
      function canMerge(selectedIds){
        if(selectedIds.length !== 2) return false;
        const smallest = nodes.slice(0,2).map(n => n.id).sort();
        return selectedIds.slice().sort().toString() === smallest.toString();
      }

      function mergeSelected(manualOrder = null){
        if(selected.size !== 2){
          el.status.textContent = 'Please select two nodes to merge.';
          flash(el.queue, 'shake');
          return;
        }
        const selectedIds = Array.from(selected);
        if(!canMerge(selectedIds)){
          // instruct and give hint
          el.status.textContent = 'Huffman greedy rule: you must merge the two currently smallest-weight nodes first.';
          flash(el.queue, 'shake');
          // highlight two smallest temporarily
          highlightSmallest(900);
          return;
        }
        // find nodes
        const a = nodes.find(n => n.id === selectedIds[0]);
        const b = nodes.find(n => n.id === selectedIds[1]);
        // Determine left/right: if manualOrder is provided (array of ids) use that order; else use order by weight (stable)
        let left,right;
        if(manualOrder && manualOrder.length===2){
          left = nodes.find(n=>n.id===manualOrder[0]);
          right = nodes.find(n=>n.id===manualOrder[1]);
        } else {
          // prefer smaller createdAt as left if same weight; otherwise smaller weight left
          if(a.weight < b.weight || (a.weight===b.weight && a.createdAt <= b.createdAt)){
            left=a; right=b;
          } else {
            left=b; right=a;
          }
        }
        const parent = {
          id: uid(),
          symbol: null,
          weight: left.weight + right.weight,
          left: left,
          right: right,
          createdAt: Date.now()+Math.random(),
        };
        // animate: fade out children, insert parent
        animateMerge(left.id, right.id, parent, ()=> {
          // remove a and b from nodes
          nodes = nodes.filter(n => n.id !== left.id && n.id !== right.id);
          nodes.push(parent);
          allNodes.push(parent);
          sortQueue();
          selected.clear();
          renderQueue();
          renderTree();
          el.status.textContent = `Merged nodes (weights ${left.weight} + ${right.weight} → ${parent.weight}).`;
          updateMetrics();
        });
      }

      function animateMerge(idA, idB, parentNode, onComplete){
        const btnA = el.queue.querySelector(`[data-id="${idA}"]`);
        const btnB = el.queue.querySelector(`[data-id="${idB}"]`);
        if(!btnA || !btnB){
          onComplete();
          return;
        }
        // simple animate: fade & scale out, then create parent visual fade in
        btnA.style.transition = 'transform 320ms ease, opacity 320ms ease';
        btnB.style.transition = 'transform 320ms ease, opacity 320ms ease';
        btnA.style.transform = 'translateY(-10px) scale(0.9)';
        btnB.style.transform = 'translateY(-10px) scale(0.9)';
        btnA.style.opacity = '0.0';
        btnB.style.opacity = '0.0';
        setTimeout(()=>{
          // call completion (which updates queue)
          onComplete();
          // show parent entry visually by flashing the queue
          const newBtn = el.queue.querySelector(`[data-id="${parentNode.id}"]`);
          if(newBtn){
            newBtn.style.transform = 'scale(0.88)';
            newBtn.style.opacity = '0.0';
            setTimeout(()=> {
              newBtn.style.transition = 'transform 380ms cubic-bezier(.2,.9,.3,1), opacity 380ms ease';
              newBtn.style.transform = 'scale(1)';
              newBtn.style.opacity = '1.0';
            }, 60);
          }
        }, 340);
      }

      function flash(elm, cls){
        elm.classList.remove(cls);
        void elm.offsetWidth;
        elm.classList.add(cls);
        setTimeout(()=> elm.classList.remove(cls), 420);
      }

      // Hint: highlight the two smallest in the queue
      function highlightSmallest(duration = 1200){
        const smallest = nodes.slice(0,2);
        if(smallest.length<2) return;
        // add css highlight by toggling class on node buttons
        const btns = [];
        for(const n of smallest){
          const b = el.queue.querySelector(`[data-id="${n.id}"]`);
          if(b){ btns.push(b); b.classList.add('shake'); }
        }
        setTimeout(()=> {
          for(const b of btns) b.classList.remove('shake');
        }, duration);
      }

      // Auto Step: merge two smallest automatically
      function autoStep(){
        if(nodes.length <= 1){
          el.status.textContent = 'Tree already complete.';
          return;
        }
        // pick two smallest
        sortQueue();
        const left = nodes[0], right = nodes[1];
        // ensure selected is those two for visual consistency
        selected.clear();
        selected.add(left.id); selected.add(right.id);
        updateSelectionVisuals();
        // do merge
        mergeSelected();
      }

      async function autoFinish(){
        autoFinishAbort = false;
        while(nodes.length > 1 && !autoFinishAbort){
          autoStep();
          // wait for animation and queue update
          await sleep(420);
        }
        if(!autoFinishAbort) el.status.textContent = 'Auto-Finish complete: final tree built.';
      }
      function abortAutoFinish(){ autoFinishAbort = true; }

      function sleep(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }

      /* Tree rendering in SVG */
      function renderTree(){
        // find any node that is composite and not present in queue? The root is the only node when nodes.length===1; but also internal nodes have left/right
        const root = nodes.length === 1 ? nodes[0] : null;
        finalRoot = root;
        const svg = el.treeSvg;
        svg.innerHTML = '';
        if(!root){
          // draw small note
          el.treeNote.textContent = nodes.length === 0 ? 'No nodes' : 'Partial forest (not a single root)';
          return;
        }
        el.treeNote.textContent = 'Final tree complete';
        // compute positions — simple layout: inorder index gives x
        const layout = [];
        let cursor = 0;
        function dfs(n, depth){
          if(!n.left && !n.right){
            // leaf: position index
            const x = cursor++;
            layout.push({n, depth, x});
            return;
          }
          // for internal: traverse left, node, right to compute x between children
          if(n.left) dfs(n.left, depth+1);
          // place current for visual (but we'll place internal nodes at average x)
          const midIndex = cursor;
          // traverse right
          if(n.right) dfs(n.right, depth+1);
          // compute x as average of subtree leaves
          const leaves = collectLeaves(n);
          const xs = leaves.map(l => layout.find(p=>p.n===l).x);
          const avg = xs.reduce((a,b)=>a+b,0)/xs.length;
          layout.push({n, depth, x: avg});
        }
        function collectLeaves(node){
          const out = [];
          (function rec(m){
            if(!m.left && !m.right) out.push(m);
            else {
              if(m.left) rec(m.left);
              if(m.right) rec(m.right);
            }
          })(node);
          return out;
        }
        // Instead of above complex approach, do a simpler way: compute inorder positions by assigning x to leaves then compute internal x as mean of leaves
        cursor = 0;
        function assignLeaves(n){
          if(!n.left && !n.right){
            n._leafIndex = cursor++;
          } else {
            if(n.left) assignLeaves(n.left);
            if(n.right) assignLeaves(n.right);
            // internal: store, will compute later
          }
        }
        assignLeaves(root);
        // Now compute coordinates
        function computeCoords(n, depth){
          const depthGap = 80;
          const xGap = 60;
          let x;
          if(!n.left && !n.right){
            x = n._leafIndex * xGap + 40;
          } else {
            const leaves = collectLeaves(n);
            const xs = leaves.map(l => l._leafIndex * xGap + 40);
            x = xs.reduce((a,b)=>a+b,0) / xs.length;
          }
          const y = depth * depthGap + 40;
          n._x = x;
          n._y = y;
          if(n.left) computeCoords(n.left, depth+1);
          if(n.right) computeCoords(n.right, depth+1);
        }
        computeCoords(root, 0);
        // compute viewBox width adaptively
        const minX = 0;
        const maxX = (cursor-1)*60 + 80;
        const width = Math.max(780, maxX+40);
        svg.setAttribute('viewBox', `0 0 ${width} 360`);
        // draw edges first
        const edgesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        svg.appendChild(edgesGroup);
        function drawEdges(n){
          if(n.left){
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = `M ${n._x} ${n._y} C ${n._x} ${n._y+20}, ${n.left._x} ${n.left._y-20}, ${n.left._x} ${n.left._y}`;
            line.setAttribute('d', d);
            line.setAttribute('class','edge edge-anim');
            line.setAttribute('stroke','rgba(255,255,255,0.06)');
            line.setAttribute('fill','none');
            edgesGroup.appendChild(line);
            // label left edge '0'
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t.setAttribute('x', (n._x + n.left._x)/2 - 8);
            t.setAttribute('y', (n._y + n.left._y)/2 - 6);
            t.setAttribute('class','node-text');
            t.textContent = '0';
            edgesGroup.appendChild(t);
            drawEdges(n.left);
          }
          if(n.right){
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = `M ${n._x} ${n._y} C ${n._x} ${n._y+20}, ${n.right._x} ${n.right._y-20}, ${n.right._x} ${n.right._y}`;
            line.setAttribute('d', d);
            line.setAttribute('class','edge edge-anim');
            line.setAttribute('stroke','rgba(255,255,255,0.06)');
            line.setAttribute('fill','none');
            edgesGroup.appendChild(line);
            // label right edge '1'
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t.setAttribute('x', (n._x + n.right._x)/2 + 4);
            t.setAttribute('y', (n._y + n.right._y)/2 - 6);
            t.setAttribute('class','node-text');
            t.textContent = '1';
            edgesGroup.appendChild(t);
            drawEdges(n.right);
          }
        }
        drawEdges(root);

        // draw nodes
        const nodesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        svg.appendChild(nodesGroup);
        function drawNode(n){
          const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          g.setAttribute('transform', `translate(${n._x}, ${n._y})`);
          g.dataset.id = n.id;
          const circ = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circ.setAttribute('r', 22);
          circ.setAttribute('class','node-circle');
          circ.setAttribute('fill','#071020');
          g.appendChild(circ);
          const t1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          t1.setAttribute('y', -6);
          t1.setAttribute('text-anchor','middle');
          t1.setAttribute('class','node-text');
          t1.textContent = n.symbol ? n.symbol : '';
          g.appendChild(t1);
          const t2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          t2.setAttribute('y', 14);
          t2.setAttribute('text-anchor','middle');
          t2.setAttribute('class','node-text');
          t2.textContent = n.weight;
          g.appendChild(t2);
          g.addEventListener('mouseenter', ()=> {
            g.querySelector('circle').classList.add('highlight');
          });
          g.addEventListener('mouseleave', ()=> {
            g.querySelector('circle').classList.remove('highlight');
          });
          nodesGroup.appendChild(g);
          if(n.left) drawNode(n.left);
          if(n.right) drawNode(n.right);
        }
        drawNode(root);

        // Animate nodes appearing (scale from 0.85)
        const circles = svg.querySelectorAll('g > circle');
        circles.forEach((c,i) => {
          c.style.transformOrigin = 'center';
          c.style.transform = 'scale(0.85)';
          c.style.transition = 'transform 420ms cubic-bezier(.2,.9,.3,1) ' + (i*20) + 'ms';
          requestAnimationFrame(()=> c.style.transform = 'scale(1)');
        });

        // When tree present, compute codes as well
        computeCodesAndRender(root);
      }

      function computeCodesAndRender(root){
        if(!root) return;
        const codes = {};
        function rec(n, prefix){
          if(!n.left && !n.right){
            codes[n.symbol] = prefix || '0'; // if only one symbol, give it code '0'
            return;
          }
          if(n.left) rec(n.left, prefix + '0');
          if(n.right) rec(n.right, prefix + '1');
        }
        rec(root, '');
        // render codes
        el.codes.innerHTML = '';
        const entries = Object.entries(codes).sort((a,b) => a[0].localeCompare(b[0]));
        for(const [sym, bits] of entries){
          const div = document.createElement('div');
          div.className = 'code-item';
          div.innerHTML = `<div style="font-family:var(--mono);">${printSymbol(sym)}</div><div class="bits">${bits}</div>`;
          div.addEventListener('mouseenter', ()=> highlightPathForSymbol(sym, true));
          div.addEventListener('mouseleave', ()=> highlightPathForSymbol(sym, false));
          el.codes.appendChild(div);
        }
        // save for encoding
        finalRoot = root;
        el.status.textContent = `Codes computed for ${entries.length} symbols. You can now Encode the text.`;
        updateMetrics();
      }

      // highlight path in SVG for a given symbol
      function highlightPathForSymbol(sym, on){
        if(!finalRoot) return;
        // find path bits by traversing
        const path = [];
        function rec(n, prefix){
          if(!n) return null;
          if(!n.left && !n.right){
            if(n.symbol === sym) return prefix;
            return null;
          }
          let r = rec(n.left, prefix+'0');
          if(r !== null) return r;
          r = rec(n.right, prefix+'1');
          return r;
        }
        const bits = rec(finalRoot, '');
        if(bits == null) return;
        // traverse bits and highlight edges/nodes along path
        const svg = el.treeSvg;
        // simplistic approach: highlight nodes whose ids are on path — we need to identify nodes visited while walking bits
        let cur = finalRoot;
        // first highlight root
        highlightNodeInSvg(cur.id, on);
        for(const b of bits){
          if(b === '0') cur = cur.left;
          else cur = cur.right;
          if(!cur) break;
          highlightNodeInSvg(cur.id, on);
          // highlight the edge between parent and cur by searching for path element near midpoints — simple: highlight any path that connects approx coords
          highlightEdgeBetween(cur, on);
        }
      }
      function highlightNodeInSvg(id, on){
        const svg = el.treeSvg;
        const g = svg.querySelector(`g[data-id="${id}"]`);
        if(g){
          const c = g.querySelector('circle');
          if(c) {
            if(on) c.classList.add('highlight'); else c.classList.remove('highlight');
          }
        }
      }
      function highlightEdgeBetween(node, on){
        // find path elements and compare their endpoints to node coords
        const svg = el.treeSvg;
        const paths = Array.from(svg.querySelectorAll('path.edge'));
        for(const p of paths){
          const d = p.getAttribute('d');
          // crude: if d string contains the node._x and node._y coordinates (rounded), then highlight
          const nx = Math.round(node._x);
          const ny = Math.round(node._y);
          if(d.includes(String(nx)) && d.includes(String(ny))){
            if(on) p.classList.add('highlight'); else p.classList.remove('highlight');
          }
        }
      }

      // Encoding / Decoding
      function encodeText(){
        if(!finalRoot){
          el.status.textContent = 'Build the final tree first (one node remaining) to encode.';
          flash(el.treeSvg, 'shake');
          return;
        }
        // compute codes
        const codes = {};
        function rec(n, prefix){
          if(!n.left && !n.right){
            codes[n.symbol] = prefix || '0';
            return;
          }
          if(n.left) rec(n.left, prefix + '0');
          if(n.right) rec(n.right, prefix + '1');
        }
        rec(finalRoot, '');
        // build encoded string
        let bits = '';
        for(const ch of originalText){
          bits += codes[ch];
        }
        el.encoded.textContent = bits || '—';
        const origBits = originalText.length * 8;
        const encBits = bits.length;
        const ratio = origBits ? ( (encBits / origBits) * 100 ).toFixed(1) : '—';
        el.metrics.textContent = `Original: ${origBits} bits · Encoded: ${encBits} bits · Ratio: ${ratio}%`;
        el.status.textContent = 'Encoding complete. Hover codes to inspect tree paths.';
      }

      function decodeBits(){
        const bits = el.bitsInput.value.trim() || el.encoded.textContent || '';
        if(!bits || bits === '—'){
          el.status.textContent = 'No bits to decode.';
          return;
        }
        if(!finalRoot){
          el.status.textContent = 'Need a final tree to decode bits.';
          return;
        }
        // traverse bits
        let output = '';
        let cur = finalRoot;
        let i = 0;
        // for visualization, highlight traversal step by step
        function step(){
          if(i >= bits.length) {
            // finished reading bits; if cur is leaf add symbol
            if(!cur.left && !cur.right){
              output += cur.symbol;
            }
            el.status.textContent = 'Decoding finished.';
            el.inputText.value = output;
            el.encoded.textContent = el.encoded.textContent || '—';
            el.status.textContent = `Decoded to text (length ${output.length}).`;
            el.bitsInput.value = bits;
            el.inputText.focus();
            return;
          }
          const b = bits[i++];
          if(b !== '0' && b !== '1'){
            el.status.textContent = 'Invalid bitstring (only 0/1 allowed).';
            return;
          }
          cur = b === '0' ? cur.left : cur.right;
          // if reached leaf, append and reset cur to root
          if(!cur.left && !cur.right){
            output += cur.symbol;
            cur = finalRoot;
          }
          // highlight nodes visited briefly
          highlightTraversalStep(i, cur);
          setTimeout(step, 140);
        }
        step();
      }

      function highlightTraversalStep(stepIndex, node){
        // flash node
        const svg = el.treeSvg;
        svg.querySelectorAll('circle').forEach(c=> c.classList.remove('highlight'));
        if(node){
          const g = svg.querySelector(`g[data-id="${node.id}"]`);
          if(g){
            const c = g.querySelector('circle');
            if(c) c.classList.add('highlight');
          }
        }
      }

      // Metrics update when intermediate tree present
      function updateMetrics(){
        if(!originalText) {
          el.metrics.textContent = 'Original: — bits · Encoded: — bits · Ratio: —';
          return;
        }
        // if codes known compute encoded length
        if(finalRoot){
          // compute codes size
          const codes = {};
          function rec(n, prefix){
            if(!n.left && !n.right){ codes[n.symbol] = prefix || '0'; return; }
            if(n.left) rec(n.left, prefix + '0');
            if(n.right) rec(n.right, prefix + '1');
          }
          rec(finalRoot, '');
          let encBits = 0;
          for(const ch of originalText) encBits += (codes[ch] || '').length;
          const origBits = originalText.length * 8;
          const ratio = origBits ? ((encBits / origBits) * 100).toFixed(1) : '—';
          el.metrics.textContent = `Original: ${origBits} bits · Encoded: ${encBits} bits · Ratio: ${ratio}%`;
        } else {
          const origBits = originalText.length * 8;
          el.metrics.textContent = `Original: ${origBits} bits · Encoded: — bits · Ratio: —`;
        }
      }

      // Event bindings
      el.analyzeBtn.addEventListener('click', analyzeText);
      el.resetBtn.addEventListener('click', ()=> {
        clearState();
        el.inputText.value = 'this is an example for huffman coding';
      });
      el.hintBtn.addEventListener('click', ()=> highlightSmallest(1200));
      el.mergeBtn.addEventListener('click', ()=> mergeSelected());
      el.autoStepBtn.addEventListener('click', ()=> autoStep());
      el.autoFinishBtn.addEventListener('click', ()=> {
        if(autoFinishAbort){ abortAutoFinish(); el.autoFinishBtn.textContent='Auto-Finish'; }
        else { autoFinish(); el.autoFinishBtn.textContent='Abort'; }
      });
      el.encodeBtn.addEventListener('click', encodeText);
      el.decodeBtn.addEventListener('click', decodeBits);

      // allow clicking a queue item to select; also clicking order determines left/right if merging allowed
      // We already allow selection; to support order determinism, store selection order in an array when merging
      document.addEventListener('keydown', (e)=>{
        if(e.key === 'Escape'){ selected.clear(); updateSelectionVisuals(); }
      });

      // Initialize
      clearState();
      // Provide initial analysis automatically
      analyzeText();

    })();
  </script>
</body>
</html>