<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Weighted Graph — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #60a5fa;
      --muted: #94a3b8;
      --success: #34d399;
      --danger: #fb7185;
      --glass: rgba(255,255,255,0.03);
      --node-size: 40;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg, #071029 0%, #071b2a 60%);
      color: #e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Safe area margins */
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: var(--gap);
    }

    h1 {
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
      color: #eaf2ff;
    }

    .subtitle {
      color:var(--muted);
      font-size:13px;
      margin-top:4px;
    }

    /* Main layout: left info, right canvas */
    .main {
      display:flex;
      gap: var(--gap);
      align-items:flex-start;
      min-height: 60vh;
    }

    /* Left panel: text and controls */
    .panel {
      width:340px;
      min-width:260px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:20px;
      box-sizing:border-box;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    .section-title {
      font-weight:600;
      font-size:13px;
      color:#dff1ff;
      letter-spacing:0.3px;
    }

    .text {
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
    }

    .controls {
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .row {
      display:flex;
      gap:12px;
      align-items:center;
    }

    button, .btn {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      color: #e6eef8;
      padding:8px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      cursor:pointer;
      font-size:13px;
      transition: transform .08s ease, box-shadow .08s;
    }

    button:active, .btn:active { transform:translateY(1px) scale(.998); }
    button.primary {
      background: linear-gradient(90deg,#2563eb,#60a5fa 120%);
      box-shadow: 0 6px 18px rgba(96,165,250,0.12);
      border: none;
    }

    .small {
      padding:6px 10px;
      font-size:12px;
    }

    .hint {
      color:var(--muted);
      font-size:12px;
    }

    /* Canvas panel */
    .canvas-wrap {
      flex:1;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:420px;
      align-items:stretch;
    }

    .toolbar {
      display:flex;
      align-items:center;
      gap:12px;
      justify-content:space-between;
    }

    .tools-left {
      display:flex;
      gap:8px;
      align-items:center;
    }

    .mode-toggle {
      display:flex;
      gap:8px;
      border-radius:8px;
      padding:6px;
      background:var(--glass);
    }

    .mode-toggle button {
      background:transparent;
      border-radius:6px;
      padding:6px 10px;
      border:1px solid transparent;
      color:var(--muted);
      font-size:13px;
    }

    .mode-toggle button.active {
      background:rgba(255,255,255,0.03);
      color:var(--accent);
      box-shadow: inset 0 -3px 0 rgba(96,165,250,0.08);
      border-color:rgba(255,255,255,0.04);
    }

    .svg-container {
      background:linear-gradient(180deg, rgba(10,20,30,0.6), rgba(5,10,15,0.6));
      border-radius:8px;
      padding:8px;
      position:relative;
      flex:1;
      min-height:320px;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
      overflow:hidden;
      box-shadow: 0 12px 36px rgba(4,9,20,0.6);
    }

    svg {
      width:100%;
      height:100%;
      display:block;
      touch-action: none;
      user-select:none;
    }

    /* Node styles are set in JS as attributes, but fallback CSS: */
    .node-label {
      pointer-events:none;
      font-size:12px;
      fill: #001021;
      font-weight:600;
    }

    .sidebar {
      width:260px;
      min-width:200px;
      background:transparent;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .panel-card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:10px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.02);
      color:var(--muted);
      font-size:13px;
    }

    .status {
      display:flex;
      gap:8px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }

    .node {
      cursor:pointer;
      transition: transform .08s;
    }

    .node:active { transform: scale(.98); }

    .edge {
      stroke-linecap: round;
      transition: stroke-width .15s, stroke .15s, opacity .12s;
      cursor:pointer;
    }

    .edge-label {
      pointer-events:all;
      font-size:12px;
      fill: #e6eef8;
      background:transparent;
    }

    .floating-input {
      position:absolute;
      z-index:10;
      display:flex;
      gap:8px;
      align-items:center;
      background:rgba(2,6,23,0.9);
      padding:8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
      color:#e6eef8;
      font-size:13px;
    }

    input[type="number"] {
      -moz-appearance: textfield;
      -webkit-appearance: none;
      background:transparent;
      color: #e6eef8;
      border: 1px solid rgba(255,255,255,0.04);
      padding:6px 8px;
      border-radius:6px;
      width:80px;
    }

    input[type="text"] {
      background:transparent;
      color: #e6eef8;
      border: 1px solid rgba(255,255,255,0.04);
      padding:6px 8px;
      border-radius:6px;
    }

    .log {
      font-family: monospace;
      font-size:13px;
      color:var(--muted);
      white-space:pre-wrap;
      max-height:120px;
      overflow:auto;
    }

    /* small responsive tweaks */
    @media (max-width: 900px) {
      .main { flex-direction:column; }
      .panel { width:100%; order:2; }
      .canvas-wrap { order:1; }
      .sidebar { width:100%; flex-direction:row; justify-content:space-between; }
    }

    /* Accessibility focus */
    button:focus, input:focus {
      outline: 2px dashed rgba(96,165,250,0.28);
      outline-offset: 3px;
    }

    /* Tooltip for help */
    .help {
      color:var(--muted);
      font-size:12px;
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Weighted graph interactive module">
    <header>
      <div>
        <h1>Weighted Graph — Visual & Interactive Explorer</h1>
        <div class="subtitle">Create nodes & weighted edges, then explore how weights affect paths</div>
      </div>
      <div style="display:flex;gap:12px;align-items:center">
        <div class="hint">Safe margins: 24px • Spacing: ≥16px</div>
      </div>
    </header>

    <div class="main" role="main">
      <aside class="panel" aria-labelledby="overview-title">
        <div>
          <div class="section-title" id="overview-title">Learning Objective</div>
          <div class="text">
            After interacting with this module you will understand how a weighted graph represents
            distances or costs on edges and how weights influence route selection. You will be able to:
            add/remove nodes and edges with weights, drag nodes to change geometry, and see Dijkstra's
            shortest path algorithm animate using edge weights.
          </div>
        </div>

        <div>
          <div class="section-title">Interaction Design</div>
          <div class="text">
            - Click empty space on the canvas to add a node. Drag nodes to reposition them.<br>
            - Click a node, then another node to create an edge. Enter a numerical weight when prompted.<br>
            - Click an edge label to edit its weight. Select a node as "Start" and another as "End", then run
            the shortest-path animation (Dijkstra). Watch nodes/edges highlight as distances update.
          </div>
        </div>

        <div>
          <div class="section-title">Layout Description</div>
          <div class="text">
            The page has a left control panel (text, modes, buttons) and a large interactive canvas on the right.
            Controls are spaced at least 16px apart and all content sits inside a 24px safe margin. The canvas contains
            an SVG for crisp visuals and accessible DOM controls for weight editing. Responsive rules stack panels on small screens.
          </div>
        </div>

        <div class="controls" aria-hidden="false">
          <div class="section-title">Quick Actions</div>
          <div class="row">
            <button id="btn-add-sample" class="btn small">Load Sample Graph</button>
            <button id="btn-clear" class="btn small">Clear</button>
            <button id="btn-reset" class="btn small">Reset View</button>
          </div>

          <div class="section-title">Algorithm</div>
          <div class="row">
            <button id="mode-select" class="btn">Select</button>
            <button id="mode-add-edge" class="btn">Add Edge</button>
            <button id="mode-delete" class="btn">Delete</button>
          </div>

          <div class="row">
            <button id="set-start" class="btn">Set Start</button>
            <button id="set-end" class="btn">Set End</button>
            <button id="run-dijkstra" class="btn primary">Run Dijkstra</button>
          </div>

          <div class="row">
            <div class="hint">Tip: edit edge weights to change the shortest path outcome.</div>
          </div>
        </div>
      </aside>

      <section class="canvas-wrap" aria-label="Graph canvas and controls">
        <div class="toolbar" role="toolbar" aria-label="Canvas toolbar">
          <div class="tools-left">
            <div class="mode-toggle" role="tablist" aria-label="interaction modes">
              <button id="modeBtn_select" class="active" role="tab" aria-selected="true">Select</button>
              <button id="modeBtn_addEdge" role="tab">Add Edge</button>
              <button id="modeBtn_delete" role="tab">Delete</button>
            </div>
            <div class="status">
              <div id="status-mode">Mode: Select</div>
            </div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <div class="hint">Start: <span id="start-label">—</span></div>
            <div class="hint">End: <span id="end-label">—</span></div>
            <button id="zoom-in" class="btn small" title="Zoom in">＋</button>
            <button id="zoom-out" class="btn small" title="Zoom out">－</button>
          </div>
        </div>

        <div class="svg-container" id="svgWrap">
          <!-- Floating input for weight creation/edit -->
          <div id="floatInput" class="floating-input" style="display:none;">
            <label style="font-size:13px">Weight</label>
            <input id="edgeWeightInput" type="number" step="0.1" min="0" value="1" aria-label="edge weight input">
            <button id="edgeWeightOk" class="btn small">OK</button>
            <button id="edgeWeightCancel" class="btn small">Cancel</button>
          </div>

          <svg id="svg" aria-label="Graph drawing area" tabindex="0">
            <defs>
              <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="4" result="coloredBlur"></feGaussianBlur>
                <feMerge>
                  <feMergeNode in="coloredBlur"></feMergeNode>
                  <feMergeNode in="SourceGraphic"></feMergeNode>
                </feMerge>
              </filter>
            </defs>
            <!-- Edges and nodes inserted by JS -->
          </svg>
        </div>

        <div style="display:flex;gap:12px;align-items:flex-start">
          <div class="sidebar">
            <div class="panel-card">
              <div style="display:flex;justify-content:space-between;align-items:center">
                <div style="font-weight:600;color:#dff1ff">Algorithm Log</div>
                <div class="hint" id="distance-sum">Total: —</div>
              </div>
              <div class="log" id="logArea" aria-live="polite"></div>
            </div>

            <div class="panel-card">
              <div style="font-weight:600;color:#dff1ff">Graph Summary</div>
              <div class="text" id="summary">
                Nodes: 0<br>Edges: 0
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <footer style="display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px">
      <div>Interactive module demonstrating Weighted Graphs — Single concept focused</div>
      <div class="help">Keyboard: TAB to focus, Enter to confirm, Delete to remove selected</div>
    </footer>
  </div>

  <script>
    /*
      Weighted Graph Interactive Module (single-file, vanilla JS)
      - Supports adding nodes, creating weighted edges, editing weights, dragging nodes.
      - Visualizes Dijkstra's algorithm with animated steps and edge highlights.
      - Maintains spacing and safe area constraints as per design.
      - Accessible controls and keyboard support for basic operations.
    */

    (function(){
      const svg = document.getElementById('svg');
      const svgWrap = document.getElementById('svgWrap');
      const floatInput = document.getElementById('floatInput');
      const weightInput = document.getElementById('edgeWeightInput');
      const weightOk = document.getElementById('edgeWeightOk');
      const weightCancel = document.getElementById('edgeWeightCancel');
      const logArea = document.getElementById('logArea');
      const summary = document.getElementById('summary');
      const statusMode = document.getElementById('status-mode');
      const startLabel = document.getElementById('start-label');
      const endLabel = document.getElementById('end-label');
      const distanceSum = document.getElementById('distance-sum');

      let state = {
        nodes: [], // {id, x, y, elemGroup, labelElem, circleElem}
        edges: [], // {id, aId, bId, weight, lineElem, labelElem}
        mode: 'select', // 'select' | 'addEdge' | 'delete'
        nextNodeId: 1,
        selectedNode: null,
        selectedEdge: null,
        addingEdgeFrom: null,
        startNode: null,
        endNode: null,
        zoom: 1
      };

      /* Utility */
      function createSVG(name){
        return document.createElementNS('http://www.w3.org/2000/svg', name);
      }

      function log(msg){
        const time = new Date().toLocaleTimeString();
        logArea.textContent = time + " — " + msg + "\n" + logArea.textContent;
      }

      function updateSummary(){
        summary.innerHTML = `Nodes: ${state.nodes.length}<br>Edges: ${state.edges.length}`;
      }

      function setMode(newMode){
        state.mode = newMode;
        statusMode.textContent = 'Mode: ' + (newMode === 'select' ? 'Select' : newMode === 'addEdge' ? 'Add Edge' : 'Delete');
        // update toggle buttons
        document.querySelectorAll('#modeBtn_select, #modeBtn_addEdge, #modeBtn_delete').forEach(btn=>{
          btn.classList.remove('active');
          btn.setAttribute('aria-selected','false');
        });
        if(newMode === 'select'){ document.getElementById('modeBtn_select').classList.add('active'); document.getElementById('modeBtn_select').setAttribute('aria-selected','true'); }
        if(newMode === 'addEdge'){ document.getElementById('modeBtn_addEdge').classList.add('active'); document.getElementById('modeBtn_addEdge').setAttribute('aria-selected','true'); }
        if(newMode === 'delete'){ document.getElementById('modeBtn_delete').classList.add('active'); document.getElementById('modeBtn_delete').setAttribute('aria-selected','true'); }
      }

      /* Node creation and rendering */
      function addNode(x,y,label){
        const id = state.nextNodeId++;
        const group = createSVG('g');
        group.classList.add('node');
        group.setAttribute('data-id', id);
        // circle
        const circle = createSVG('circle');
        circle.setAttribute('r', String(Number(getComputedStyle(document.documentElement).getPropertyValue('--node-size') || 40)/2 || 20));
        circle.setAttribute('fill', '#e6eef8');
        circle.setAttribute('stroke', '#0b1220');
        circle.setAttribute('stroke-width', '2');
        circle.style.transformOrigin = 'center';
        circle.style.transition = 'fill .12s, transform .08s';
        // label
        const t = createSVG('text');
        t.setAttribute('class','node-label');
        t.setAttribute('text-anchor','middle');
        t.setAttribute('dy','.38em');
        t.textContent = label || String(id);
        t.style.pointerEvents = 'none';
        // group translate
        group.appendChild(circle);
        group.appendChild(t);
        // place group
        group.setAttribute('transform', `translate(${x},${y})`);
        svg.appendChild(group);

        const node = {
          id, x, y,
          elem: group,
          circleElem: circle,
          labelElem: t
        };
        state.nodes.push(node);

        // event handlers
        group.addEventListener('pointerdown', onNodePointerDown);
        group.addEventListener('click', (e)=>{ e.stopPropagation(); onNodeClick(node, e); });

        updateSummary();
        return node;
      }

      function removeNode(node){
        // remove edges incident
        const incidents = state.edges.filter(e => e.aId === node.id || e.bId === node.id);
        incidents.forEach(e => removeEdge(e));
        // remove element
        if(node.elem && node.elem.parentNode) node.elem.parentNode.removeChild(node.elem);
        state.nodes = state.nodes.filter(n => n.id !== node.id);
        if(state.startNode && state.startNode.id === node.id) { state.startNode = null; startLabel.textContent = '—'; }
        if(state.endNode && state.endNode.id === node.id) { state.endNode = null; endLabel.textContent = '—'; }
        updateSummary();
        log(`Node ${node.id} removed.`);
      }

      /* Edge creation and rendering */
      function addEdge(aId, bId, weight){
        if(aId === bId) return null;
        // prevent duplicate edges (undirected) between same pair
        const exists = state.edges.find(e => (e.aId === aId && e.bId === bId) || (e.aId === bId && e.bId === aId));
        if(exists) return null;

        const a = state.nodes.find(n=>n.id===aId);
        const b = state.nodes.find(n=>n.id===bId);
        if(!a || !b) return null;

        const line = createSVG('line');
        line.classList.add('edge');
        line.setAttribute('stroke-linecap','round');
        line.setAttribute('stroke-width','6');
        line.setAttribute('x1', a.x);
        line.setAttribute('y1', a.y);
        line.setAttribute('x2', b.x);
        line.setAttribute('y2', b.y);
        // label group (to enable clicking)
        const label = createSVG('text');
        label.classList.add('edge-label');
        label.setAttribute('text-anchor','middle');
        label.setAttribute('dy', '-6');
        label.textContent = String(weight);
        label.style.cursor = 'pointer';
        // set dynamic styling based on weight
        function updateVisual(){
          const w = Number(weight);
          const thickness = Math.max(2, Math.min(18, 6 + Math.log10(1 + w)*6));
          line.setAttribute('stroke-width', thickness);
          // map weight to color: small weights greenish, large weights reddish
          const t = Math.max(0, Math.min(1, (Math.log10(1 + w) / 2.3)));
          const r = Math.round(240*t + 50*(1-t));
          const g = Math.round(60*(1-t) + 200*t);
          const bcol = Math.round(160*(1-t));
          line.setAttribute('stroke', `rgb(${r},${g},${bcol})`);
          label.textContent = String(w);
        }
        updateVisual();

        svg.insertBefore(line, svg.firstChild); // edges behind nodes
        svg.appendChild(label); // labels above

        const id = `e${state.edges.length+1}`;
        const edge = { id, aId, bId, weight: Number(weight), lineElem: line, labelElem: label, updateVisual };
        state.edges.push(edge);

        // label pointer events for editing
        label.addEventListener('click', (ev) => { ev.stopPropagation(); openWeightEditor(edge, ev.clientX, ev.clientY); });

        // clicking line selects it
        line.addEventListener('click',(ev)=>{
          ev.stopPropagation();
          setSelectedEdge(edge);
        });

        updateSummary();
        return edge;
      }

      function removeEdge(edge){
        if(edge.lineElem && edge.lineElem.parentNode) edge.lineElem.parentNode.removeChild(edge.lineElem);
        if(edge.labelElem && edge.labelElem.parentNode) edge.labelElem.parentNode.removeChild(edge.labelElem);
        state.edges = state.edges.filter(e => e !== edge);
        if(state.selectedEdge && state.selectedEdge.id === edge.id) state.selectedEdge = null;
        updateSummary();
        log(`Edge ${edge.id} removed.`);
      }

      function setSelectedNode(node){
        if(state.selectedNode && state.selectedNode.elem) {
          state.selectedNode.circleElem.setAttribute('stroke-width','2');
        }
        state.selectedNode = node;
        if(node){
          node.circleElem.setAttribute('stroke-width','4');
        }
      }

      function setSelectedEdge(edge){
        if(state.selectedEdge && state.selectedEdge.lineElem){
          state.selectedEdge.lineElem.setAttribute('opacity','1');
        }
        state.selectedEdge = edge;
        if(edge){
          edge.lineElem.setAttribute('opacity','0.6');
        }
      }

      /* Node pointer drag handling */
      let drag = { active:false, node:null, offsetX:0, offsetY:0 };
      function onNodePointerDown(e){
        e.stopPropagation();
        const id = Number(this.getAttribute('data-id'));
        const node = state.nodes.find(n=>n.id===id);
        if(!node) return;
        if(state.mode === 'delete'){
          removeNode(node);
          return;
        } else if(state.mode === 'addEdge'){
          // start edge creation
          state.addingEdgeFrom = node;
          highlightTemp(node);
          return;
        }
        // otherwise start drag
        drag.active = true;
        drag.node = node;
        const pt = getSVGPoint(e);
        drag.offsetX = node.x - pt.x;
        drag.offsetY = node.y - pt.y;
        svg.setPointerCapture(e.pointerId);
      }

      /* pointer move on document to move node */
      svg.addEventListener('pointermove', (e)=>{
        if(!drag.active || !drag.node) return;
        const pt = getSVGPoint(e);
        const nx = pt.x + drag.offsetX;
        const ny = pt.y + drag.offsetY;
        drag.node.x = nx;
        drag.node.y = ny;
        drag.node.elem.setAttribute('transform', `translate(${nx},${ny})`);
        // update edges incident
        updateEdgesForNode(drag.node);
      });

      svg.addEventListener('pointerup', (e)=>{
        if(drag.active){
          drag.active = false;
          drag.node = null;
        }
      });

      /* clicking on empty space adds node (in select mode) */
      svg.addEventListener('click', (e)=>{
        const pt = getSVGPoint(e);
        if(state.mode === 'select'){
          addNode(pt.x, pt.y);
          log(`Node added at (${Math.round(pt.x)}, ${Math.round(pt.y)})`);
        } else if(state.mode === 'addEdge'){
          // clicking empty cancels adding
          cancelEdgeAdding();
        }
      });

      /* Node click behavior */
      function onNodeClick(node,e){
        if(state.mode === 'delete'){
          removeNode(node);
          return;
        }
        if(state.mode === 'addEdge'){
          if(!state.addingEdgeFrom){
            state.addingEdgeFrom = node;
            highlightTemp(node);
            log(`Pick target node to create edge from ${node.id}`);
          } else if(state.addingEdgeFrom && state.addingEdgeFrom.id === node.id){
            // clicked same node -> cancel
            cancelEdgeAdding();
          } else {
            // create edge
            openWeightEditorForNewEdge(state.addingEdgeFrom, node, e.clientX, e.clientY);
            clearHighlights();
          }
          return;
        }
        // select node for start/end assignment or general selection
        setSelectedNode(node);
      }

      /* Edge creation flow: open float input near click */
      function openWeightEditorForNewEdge(aNode, bNode, clientX, clientY){
        const pos = floatPosition(clientX, clientY);
        showFloat(pos.x,pos.y);
        weightInput.value = 1;
        const commit = () => {
          const val = Number(weightInput.value) || 1;
          const e = addEdge(aNode.id, bNode.id, val);
          if(e){
            log(`Edge ${e.id} added between ${aNode.id} – ${bNode.id} weight=${val}`);
            positionEdgeLabel(e);
          } else {
            log('Edge exists or invalid; creation skipped.');
          }
          hideFloat();
          cancelEdgeAdding();
        };
        weightOk.onclick = commit;
        weightCancel.onclick = () => { hideFloat(); cancelEdgeAdding(); };
        weightInput.onkeydown = function(evt){
          if(evt.key === 'Enter') commit();
          if(evt.key === 'Escape') { hideFloat(); cancelEdgeAdding(); }
        };
        weightInput.focus();
      }

      function openWeightEditor(edge, clientX, clientY){
        const pos = floatPosition(clientX, clientY);
        showFloat(pos.x,pos.y);
        weightInput.value = edge.weight;
        const commit = () => {
          const val = Number(weightInput.value);
          if(!isFinite(val) || val < 0) return;
          edge.weight = val;
          edge.updateVisual();
          positionEdgeLabel(edge);
          hideFloat();
          log(`Edge ${edge.id} weight set to ${val}`);
        };
        weightOk.onclick = commit;
        weightCancel.onclick = () => { hideFloat(); };
        weightInput.onkeydown = function(evt){
          if(evt.key === 'Enter') commit();
          if(evt.key === 'Escape') hideFloat();
        };
        weightInput.focus();
      }

      function showFloat(x,y){
        floatInput.style.left = x + 'px';
        floatInput.style.top = y + 'px';
        floatInput.style.display = 'flex';
      }
      function hideFloat(){ floatInput.style.display = 'none'; }

      function floatPosition(clientX, clientY){
        // compute position relative to svgWrap
        const rect = svgWrap.getBoundingClientRect();
        // clamp inside
        let x = clientX - rect.left;
        let y = clientY - rect.top;
        x = Math.max(8, Math.min(rect.width - 160, x));
        y = Math.max(8, Math.min(rect.height - 40, y));
        return {x,y};
      }

      function cancelEdgeAdding(){
        state.addingEdgeFrom = null;
        clearHighlights();
      }

      function highlightTemp(node){
        clearHighlights();
        if(node && node.circleElem) node.circleElem.setAttribute('stroke','#ffd166');
      }
      function clearHighlights(){
        state.nodes.forEach(n=>{ if(n.circleElem) n.circleElem.setAttribute('stroke','#0b1220'); });
      }

      /* Update edges coordinates and labels when nodes move */
      function updateEdgesForNode(node){
        state.edges.forEach(edge=>{
          if(edge.aId === node.id || edge.bId === node.id){
            const a = state.nodes.find(n=>n.id===edge.aId);
            const b = state.nodes.find(n=>n.id===edge.bId);
            if(a && b){
              edge.lineElem.setAttribute('x1', a.x);
              edge.lineElem.setAttribute('y1', a.y);
              edge.lineElem.setAttribute('x2', b.x);
              edge.lineElem.setAttribute('y2', b.y);
              positionEdgeLabel(edge);
            }
          }
        });
      }

      function positionEdgeLabel(edge){
        const a = state.nodes.find(n=>n.id===edge.aId);
        const b = state.nodes.find(n=>n.id===edge.bId);
        if(!a||!b) return;
        const mx = (a.x + b.x)/2;
        const my = (a.y + b.y)/2;
        edge.labelElem.setAttribute('x', mx);
        edge.labelElem.setAttribute('y', my - 8);
      }

      /* Dijkstra algorithm with animation */
      function runDijkstraAnimated(){
        if(!state.startNode || !state.endNode){
          log('Set both start and end nodes before running Dijkstra.');
          return;
        }
        log(`Running Dijkstra from ${state.startNode.id} to ${state.endNode.id}...`);
        // Build adjacency list
        const adj = new Map();
        state.nodes.forEach(n => adj.set(n.id, []));
        state.edges.forEach(e => {
          adj.get(e.aId).push({to: e.bId, w: e.weight, edge: e});
          adj.get(e.bId).push({to: e.aId, w: e.weight, edge: e});
        });

        // Initialize
        const dist = {};
        const prev = {};
        const visited = new Set();
        state.nodes.forEach(n=>{ dist[n.id] = Infinity; prev[n.id] = null; });
        dist[state.startNode.id] = 0;

        // Visual: reset styles
        state.nodes.forEach(n=>{
          n.circleElem.setAttribute('fill', '#e6eef8');
        });
        state.edges.forEach(e=>{
          e.lineElem.style.filter = '';
          e.lineElem.style.opacity = '1';
        });

        // Priority queue simple implementation
        const pq = new Map(); // id -> dist
        pq.set(state.startNode.id, 0);

        const order = []; // for animation frames (events)
        // We'll create events: {type: 'visit'|'relax'|'found', nodeId, edge, dist}
        while(pq.size){
          // get smallest
          let curId = null;
          let curDist = Infinity;
          pq.forEach((d,id)=>{ if(d<curDist){ curDist=d; curId=id; }});
          pq.delete(curId);
          if(visited.has(curId)) continue;
          visited.add(curId);
          order.push({type:'visit', nodeId:curId, dist: dist[curId]});
          if(curId === state.endNode.id) break;
          // relax neighbors
          const neighbors = adj.get(curId) || [];
          for(const nb of neighbors){
            if(visited.has(nb.to)) continue;
            const nd = dist[curId] + nb.w;
            if(nd < dist[nb.to]){
              dist[nb.to] = nd;
              prev[nb.to] = {from: curId, edge: nb.edge};
              pq.set(nb.to, nd);
              order.push({type:'relax', nodeId:nb.to, from:curId, edge:nb.edge, dist:nd});
            } else {
              order.push({type:'check', nodeId:nb.to, from:curId, edge:nb.edge, dist:nd});
            }
          }
        }

        // Reconstruct path
        const path = [];
        let cur = state.endNode.id;
        if(prev[cur] || cur === state.startNode.id){
          while(cur !== null){
            const p = prev[cur];
            path.unshift(cur);
            cur = p ? p.from : null;
          }
        }

        // Animate order
        const speed = 420; // ms per event
        let step = 0;
        function animateStep(){
          if(step >= order.length){
            // final highlight path
            highlightPath(path, dist[state.endNode.id]);
            return;
          }
          const ev = order[step];
          if(ev.type === 'visit'){
            const node = state.nodes.find(n=>n.id===ev.nodeId);
            if(node) {
              // pulse
              node.circleElem.setAttribute('fill','#60a5fa');
              node.circleElem.style.filter = 'url(#glow)';
              node.circleElem.setAttribute('r', String(Number(getComputedStyle(document.documentElement).getPropertyValue('--node-size') || 40)/2 || 20));
              // show in log
              log(`Visited node ${ev.nodeId} (dist=${ev.dist.toFixed(2)})`);
            }
          } else if(ev.type === 'relax'){
            // highlight edge that caused relax
            if(ev.edge){
              ev.edge.lineElem.setAttribute('stroke', '#f472b6');
              ev.edge.lineElem.style.filter = 'url(#glow)';
              ev.edge.lineElem.setAttribute('opacity','1');
            }
            log(`Relax: node ${ev.nodeId} new dist=${ev.dist.toFixed(2)} via ${ev.from}`);
          } else if(ev.type === 'check'){
            // subtle fade of edge
            if(ev.edge){
              ev.edge.lineElem.setAttribute('opacity','0.28');
            }
          }
          step++;
          setTimeout(animateStep, speed);
        }
        animateStep();

        function highlightPath(pathArr, totalWeight){
          if(!pathArr || pathArr.length === 0 || !isFinite(totalWeight)){
            log('No path found.');
            distanceSum.textContent = 'Total: ∞';
            return;
          }
          // highlight nodes and edges along path sequentially
          distanceSum.textContent = 'Total: ' + totalWeight.toFixed(2);
          const toHighlightEdges = [];
          for(let i=0;i<pathArr.length-1;i++){
            const a = pathArr[i], b = pathArr[i+1];
            const edge = state.edges.find(e => (e.aId===a && e.bId===b) || (e.aId===b && e.bId===a));
            if(edge) toHighlightEdges.push(edge);
          }
          let idx = 0;
          function stepHL(){
            if(idx < pathArr.length){
              const nid = pathArr[idx];
              const n = state.nodes.find(x=>x.id===nid);
              if(n) {
                n.circleElem.setAttribute('fill', '#34d399'); // green for path
                n.circleElem.style.filter = 'url(#glow)';
              }
              if(idx > 0){
                const e = toHighlightEdges[idx-1];
                if(e){
                  e.lineElem.setAttribute('stroke', '#10b981');
                  e.lineElem.setAttribute('stroke-width', Math.max(6, Number(e.lineElem.getAttribute('stroke-width')) + 4));
                }
              }
              idx++;
              setTimeout(stepHL, 280);
            } else {
              log(`Shortest path highlighted (total weight ${totalWeight.toFixed(2)})`);
            }
          }
          stepHL();
        }
      }

      /* Helper: get mouse pointer in SVG coordinates */
      function getSVGPoint(e){
        const pt = svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const ctm = svg.getScreenCTM().inverse();
        const loc = pt.matrixTransform(ctm);
        return {x: loc.x, y: loc.y};
      }

      /* UI wiring */
      document.getElementById('btn-clear').addEventListener('click', ()=>{
        // remove all nodes and edges
        state.edges.forEach(e => { if(e.lineElem.parentNode) e.lineElem.parentNode.removeChild(e.lineElem); if(e.labelElem.parentNode) e.labelElem.parentNode.removeChild(e.labelElem); });
        state.nodes.forEach(n => { if(n.elem.parentNode) n.elem.parentNode.removeChild(n.elem); });
        state.nodes = []; state.edges = []; state.nextNodeId = 1;
        state.startNode = null; state.endNode = null;
        startLabel.textContent = '—'; endLabel.textContent = '—';
        distanceSum.textContent = 'Total: —';
        updateSummary();
        log('Cleared graph.');
      });

      document.getElementById('btn-add-sample').addEventListener('click', ()=>{
        // Create a sample weighted graph
        // Clear first
        document.getElementById('btn-clear').click();
        const w = svg.getBoundingClientRect().width;
        const h = svg.getBoundingClientRect().height;
        const center = {x:w/2, y:h/2};
        const n1 = addNode(center.x-160, center.y-30); // 1
        const n2 = addNode(center.x-60, center.y-120); // 2
        const n3 = addNode(center.x+60, center.y-120); // 3
        const n4 = addNode(center.x+160, center.y-30); // 4
        const n5 = addNode(center.x+20, center.y+80); // 5

        function e(a,b,w){
          const edge = addEdge(a.id,b.id,w);
          if(edge) positionEdgeLabel(edge);
        }
        e(n1,n2,7);
        e(n2,n3,2);
        e(n3,n4,3);
        e(n1,n5,2);
        e(n5,n4,10);
        e(n2,n5,1.5);
        e(n3,n5,5);
        log('Sample graph loaded.');
      });

      // Mode buttons
      document.getElementById('modeBtn_select').addEventListener('click', ()=> setMode('select'));
      document.getElementById('modeBtn_addEdge').addEventListener('click', ()=> setMode('addEdge'));
      document.getElementById('modeBtn_delete').addEventListener('click', ()=> setMode('delete'));
      document.getElementById('mode-select').addEventListener('click', ()=> setMode('select'));
      document.getElementById('mode-add-edge').addEventListener('click', ()=> setMode('addEdge'));
      document.getElementById('mode-delete').addEventListener('click', ()=> setMode('delete'));

      // set start / end
      document.getElementById('set-start').addEventListener('click', ()=>{
        if(!state.selectedNode) { log('Select a node first to set as Start.'); return; }
        state.startNode = state.selectedNode;
        startLabel.textContent = String(state.startNode.id);
        log(`Start node set to ${state.startNode.id}`);
      });
      document.getElementById('set-end').addEventListener('click', ()=>{
        if(!state.selectedNode) { log('Select a node first to set as End.'); return; }
        state.endNode = state.selectedNode;
        endLabel.textContent = String(state.endNode.id);
        log(`End node set to ${state.endNode.id}`);
      });

      document.getElementById('run-dijkstra').addEventListener('click', ()=> runDijkstraAnimated());

      // Zoom
      document.getElementById('zoom-in').addEventListener('click', ()=>{
        state.zoom = Math.min(2, state.zoom + 0.1);
        svg.setAttribute('transform', `scale(${state.zoom})`);
        svg.style.transform = `scale(${state.zoom})`;
      });
      document.getElementById('zoom-out').addEventListener('click', ()=>{
        state.zoom = Math.max(0.6, state.zoom - 0.1);
        svg.style.transform = `scale(${state.zoom})`;
      });

      // Keyboard delete removal
      window.addEventListener('keydown', (e)=>{
        if(e.key === 'Delete' || e.key === 'Backspace'){
          if(state.selectedNode) removeNode(state.selectedNode);
          else if(state.selectedEdge) removeEdge(state.selectedEdge);
        }
      });

      // Make sure labels are positioned when window resize
      window.addEventListener('resize', () => {
        state.edges.forEach(positionEdgeLabel);
      });

      // initial sample
      document.getElementById('btn-add-sample').click();
      setMode('select');
    })();
  </script>
</body>
</html>