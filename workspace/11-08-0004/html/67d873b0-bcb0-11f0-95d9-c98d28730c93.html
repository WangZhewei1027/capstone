<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Singly Linked List — Insertion & Deletion (Interactive)</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --success: #10b981;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.03);
      --node-bg: linear-gradient(180deg,#111827,#0b1220);
      --node-border: rgba(255,255,255,0.06);
    }
    * { box-sizing: border-box; }
    html,body { height:100%; }
    body{
      margin:0;
      padding: var(--safe-margin);
      background: linear-gradient(180deg,#071021 0%, #041022 100%);
      color: #e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      min-height:100vh;
      display:flex;
      align-items:flex-start;
      justify-content:center;
    }

    /* Main layout container */
    .module {
      width: min(1150px, 98vw);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:24px;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:24px;
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
      min-height: 520px;
    }

    /* Left panel: descriptive text & controls */
    .info {
      padding:20px;
      border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    .title {
      font-size:18px;
      font-weight:600;
      color:var(--accent);
      display:flex;
      gap:10px;
      align-items:center;
    }
    .subtitle {
      font-size:14px;
      color:var(--muted);
      margin-top:2px;
    }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.014), rgba(255,255,255,0.01));
      border-radius:8px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .section-title { font-size:13px; color:#cfeff6; font-weight:600; margin-bottom:8px; }

    /* Controls */
    .controls {
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    label { font-size:13px; color:var(--muted); min-width:80px; }
    input[type="text"], input[type="number"], select {
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.04);
      color: #e6eef8;
      padding:8px 10px;
      border-radius:8px;
      font-size:14px;
      min-width:0;
    }
    .btn {
      appearance:none;
      border:0;
      padding:10px 12px;
      border-radius:8px;
      background:var(--accent);
      color:#042026;
      font-weight:600;
      cursor:pointer;
      transition:transform .12s ease, box-shadow .12s ease;
      box-shadow: 0 6px 14px rgba(6,182,212,0.12);
    }
    .btn.secondary {
      background: rgba(255,255,255,0.04);
      color: #e6eef8;
      border: 1px solid rgba(255,255,255,0.03);
      box-shadow: none;
    }
    .btn.warn { background: var(--danger); color:#fff; box-shadow: 0 6px 14px rgba(239,68,68,0.12); }
    .btn:active { transform: translateY(1px); }

    .small { font-size:13px; color:var(--muted); }

    /* Right panel: visualization area */
    .visual {
      padding:18px;
      border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .stage {
      background: linear-gradient(90deg, rgba(6,9,13,0.2), rgba(1,6,12,0.2));
      border-radius:8px;
      padding:18px;
      min-height:240px;
      display:flex;
      align-items:center;
      justify-content:flex-start;
      overflow:auto;
      gap:20px;
      position:relative;
      border: 1px dashed rgba(255,255,255,0.02);
    }

    /* Node styles */
    .node {
      display:flex;
      align-items:center;
      gap:8px;
      min-width:88px;
      background: var(--node-bg);
      border:1px solid var(--node-border);
      padding:8px;
      border-radius:8px;
      color:#e6eef8;
      position:relative;
      transition: transform .35s cubic-bezier(.2,.9,.25,1), opacity .25s ease;
      box-shadow: 0 6px 18px rgba(2,6,23,0.45);
      flex-shrink:0;
    }
    .node .value {
      min-width:44px;
      text-align:center;
      padding:6px 10px;
      border-radius:6px;
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      font-weight:700;
      color:#dff8fb;
    }
    .node .ptr {
      width:36px;
      height:36px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--muted);
      position:relative;
    }

    /* Arrow line between nodes (SVG) */
    .arrow {
      width:60px;
      height:10px;
      display:block;
      flex-shrink:0;
    }

    /* Highlight states */
    .node.current {
      box-shadow: 0 8px 26px rgba(6,182,212,0.18), 0 0 0 4px rgba(6,182,212,0.06);
      transform: translateY(-6px) scale(1.03);
    }
    .node.target {
      box-shadow: 0 8px 26px rgba(16,185,129,0.14), 0 0 0 4px rgba(16,185,129,0.06);
      transform: translateY(-4px);
    }
    .node.removing {
      opacity:0;
      transform: scale(.8) translateY(6px);
    }
    .node.inserting {
      opacity:0;
      transform: scale(.6) translateY(-20px);
      animation: popIn .36s forwards cubic-bezier(.2,.9,.25,1);
    }
    @keyframes popIn {
      to { opacity:1; transform: scale(1) translateY(0); }
    }

    /* moving pointer dot */
    .pointer-dot {
      width:14px;
      height:14px;
      background: var(--accent);
      border-radius:50%;
      position:absolute;
      top:-14px;
      left:0;
      transform: translate(-50%, 0);
      transition: left .45s cubic-bezier(.2,.9,.25,1), top .45s cubic-bezier(.2,.9,.25,1);
      box-shadow: 0 6px 18px rgba(6,182,212,0.18);
      display:flex;
      align-items:center;
      justify-content:center;
      color:#042026;
      font-size:11px;
      font-weight:700;
      z-index:40;
    }

    /* bottom help / legend */
    .legend {
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .legend .key { display:inline-flex; gap:8px; align-items:center; padding:6px 8px; border-radius:8px; background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.02); }

    /* responsive */
    @media (max-width:900px){
      .module { grid-template-columns: 1fr; padding:16px; gap:16px; }
      .info { order:2; }
      .visual { order:1; }
    }

    /* small helper for inputs spacing */
    .gap16 { gap:16px; display:flex; align-items:center; flex-wrap:wrap; }
    .flexcol { display:flex; flex-direction:column; gap:8px; }

    /* accessibility focus */
    button:focus, input:focus, select:focus { outline: 3px solid rgba(6,182,212,0.12); outline-offset:2px; }
  </style>
</head>
<body>
  <main class="module" role="main" aria-labelledby="main-title">
    <!-- Left: Info and Controls -->
    <aside class="info" aria-label="Module information and controls">
      <div>
        <div class="title" id="main-title">Singly Linked List — Insertion & Deletion</div>
        <div class="subtitle">Interactive exploration of how nodes and pointers change during insert and delete operations.</div>
      </div>

      <div class="card" aria-hidden="false">
        <div class="section-title">Learning Objective</div>
        <div class="small">
          After interacting with this module you will be able to:
          <ul style="margin:8px 0 0 18px; color:var(--muted);">
            <li>Visualize how a singly linked list stores values and "next" pointers.</li>
            <li>Perform insertions (head, tail, index) and deletions (by index) while seeing pointer updates.</li>
            <li>Understand traversal required to find insertion/deletion points.</li>
          </ul>
        </div>
      </div>

      <div class="card">
        <div class="section-title">Interaction Design</div>
        <div class="small" style="color:var(--muted);">
          Controls:
          <ul style="margin:8px 0 0 18px;">
            <li>Type a value and choose where to insert (Head, Tail, Index) → Click Insert.</li>
            <li>To delete, choose an index and click Delete (0-based).</li>
            <li>Animations show a pointer dot traversing nodes. Nodes are highlighted during traversal. Inserted nodes animate into place; deleted nodes fade out.</li>
          </ul>
          User actions are via clicking and typing. Visual feedback:
          <ul style="margin:8px 0 0 18px;">
            <li>Pointer dot moves and highlights current node (animation).</li>
            <li>Arrows and node emphasis update after each operation to reflect the new links.</li>
            <li>Controls disabled while an animation runs, preventing conflicting changes.</li>
          </ul>
        </div>
      </div>

      <div class="card">
        <div class="section-title">Layout Description</div>
        <div class="small" style="color:var(--muted);">
          Two-column layout: left column contains title, objectives, and controls; right column contains the interactive visualization ("stage") with a draggable-like flow. Safe area margins are 24px; spacing between interactive elements is at least 16px. The stage scrolls horizontally when list grows. All interactive controls have visible focus outlines for accessibility and controls are keyboard reachable.
        </div>
      </div>

      <div class="card">
        <div class="section-title">Controls</div>
        <form id="controls" class="controls" onsubmit="return false;">
          <div class="row gap16">
            <div style="flex:1;" class="flexcol">
              <label for="valueInput">Value</label>
              <input id="valueInput" type="text" inputmode="text" placeholder="e.g., 42" aria-label="Node value" />
            </div>
            <div style="width:150px;" class="flexcol">
              <label for="positionSelect">Where</label>
              <select id="positionSelect" aria-label="Insertion position">
                <option value="head">Head (0)</option>
                <option value="tail">Tail</option>
                <option value="index">Index</option>
              </select>
            </div>
          </div>

          <div class="row gap16" style="align-items:flex-end;">
            <div style="width:120px;" class="flexcol">
              <label for="indexInput">Index (0-based)</label>
              <input id="indexInput" type="number" min="0" placeholder="index" aria-label="Index" />
            </div>

            <div style="display:flex; gap:12px; margin-left:auto;">
              <button id="insertBtn" class="btn" type="button">Insert</button>
              <button id="deleteBtn" class="btn warn" type="button">Delete</button>
            </div>
          </div>

          <div class="row" style="justify-content:space-between; margin-top:6px;">
            <div class="small">Animations: <strong id="status">idle</strong></div>
            <div style="display:flex; gap:8px;">
              <button id="resetBtn" class="btn secondary" type="button">Reset</button>
              <button id="randomBtn" class="btn secondary" type="button">Random List</button>
            </div>
          </div>
        </form>
      </div>

    </aside>

    <!-- Right: Visualization -->
    <section class="visual" aria-label="Interactive visualization area">
      <div class="card" style="padding:12px;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="display:flex; flex-direction:column;">
            <div class="section-title">Stage</div>
            <div class="small" style="color:var(--muted);">Nodes laid out left-to-right. Arrows point to the next node or to null.</div>
          </div>
          <div class="legend" aria-hidden="true">
            <div class="key"><div style="width:12px;height:12px;background:var(--accent);border-radius:3px;"></div> current pointer</div>
            <div class="key"><div style="width:12px;height:12px;background:#10b981;border-radius:3px;"></div> insert target</div>
          </div>
        </div>
      </div>

      <div class="stage" id="stage" tabindex="0" aria-live="polite" aria-label="Linked list visualization stage">
        <!-- pointer dot -->
        <div id="pointerDot" class="pointer-dot" aria-hidden="true" style="display:none;">P</div>
        <!-- nodes inserted here by JS -->
      </div>

      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div class="small" style="color:var(--muted);">Tip: Use index 0 to operate on the head. Empty list shown as (null).</div>
        <div class="small" style="color:var(--muted);">List length: <strong id="lengthDisplay">0</strong></div>
      </div>
    </section>
  </main>

  <script>
    (function () {
      // DOM references
      const stage = document.getElementById('stage');
      const pointer = document.getElementById('pointerDot');
      const valueInput = document.getElementById('valueInput');
      const positionSelect = document.getElementById('positionSelect');
      const indexInput = document.getElementById('indexInput');
      const insertBtn = document.getElementById('insertBtn');
      const deleteBtn = document.getElementById('deleteBtn');
      const resetBtn = document.getElementById('resetBtn');
      const randomBtn = document.getElementById('randomBtn');
      const statusLabel = document.getElementById('status');
      const lengthDisplay = document.getElementById('lengthDisplay');

      // Data model: array of {id, value}
      let list = [];
      let animating = false;
      let nodeId = 0;

      // Accessibility: ensure min spacing - already in CSS via gap variables.

      // Utilities
      function setStatus(text) { statusLabel.textContent = text; }

      function disableControls(disabled) {
        animating = disabled;
        [insertBtn, deleteBtn, resetBtn, randomBtn].forEach(b => b.disabled = disabled);
        positionSelect.disabled = disabled;
        valueInput.disabled = disabled;
        indexInput.disabled = disabled;
        if (disabled) setStatus('animating...');
        else setStatus('idle');
      }

      function renderList() {
        // Clear stage and re-create nodes and arrows
        stage.querySelectorAll('.node, .arrow-svg, .null-box').forEach(n => n.remove());

        if (list.length === 0) {
          const nullBox = document.createElement('div');
          nullBox.className = 'null-box';
          nullBox.style.color = 'var(--muted)';
          nullBox.style.padding = '10px';
          nullBox.style.borderRadius = '8px';
          nullBox.style.border = '1px dashed rgba(255,255,255,0.03)';
          nullBox.textContent = '(null)';
          stage.appendChild(nullBox);
        }

        list.forEach((item, i) => {
          const node = document.createElement('div');
          node.className = 'node';
          node.dataset.index = i;
          node.dataset.id = item.id;

          const value = document.createElement('div');
          value.className = 'value';
          value.textContent = item.value;

          const ptr = document.createElement('div');
          ptr.className = 'ptr';
          ptr.setAttribute('aria-hidden', 'true');
          ptr.innerHTML = indexToText(i === list.length - 1 ? null : i + 1);

          node.appendChild(value);
          node.appendChild(ptr);

          stage.appendChild(node);

          if (i < list.length - 1) {
            // Add arrow svg between nodes
            const svg = makeArrowSVG();
            svg.classList.add('arrow-svg');
            svg.setAttribute('aria-hidden', 'true');
            stage.appendChild(svg);
          } else {
            // Last node points to null: small "⋯" or null arrow
            const svg = makeArrowSVG(true);
            svg.classList.add('arrow-svg');
            svg.setAttribute('aria-hidden', 'true');
            stage.appendChild(svg);
          }
        });

        lengthDisplay.textContent = String(list.length);
      }

      function indexToText(i) {
        return i === null ? '<span style="opacity:.6;font-size:12px">null</span>' : ('▶');
      }

      function makeArrowSVG(isTail=false) {
        // Simple arrow using SVG, slight transparency
        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        svg.setAttribute('width', 60);
        svg.setAttribute('height', 24);
        svg.setAttribute('viewBox', '0 0 60 24');
        svg.style.flexShrink = '0';
        svg.style.margin = '0 4px';
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', '2');
        line.setAttribute('y1', '12');
        line.setAttribute('x2', '44');
        line.setAttribute('y2', '12');
        line.setAttribute('stroke', 'rgba(255,255,255,0.06)');
        line.setAttribute('stroke-width', '2');
        line.setAttribute('stroke-linecap', 'round');
        svg.appendChild(line);
        const poly = document.createElementNS(svgNS, 'polygon');
        poly.setAttribute('points', isTail ? '50,6 58,12 50,18' : '46,6 54,12 46,18');
        poly.setAttribute('fill', isTail ? 'rgba(255,255,255,0.04)' : 'rgba(255,255,255,0.06)');
        svg.appendChild(poly);
        return svg;
      }

      // Traversal animation: move pointer dot to node index sequentially
      function traverseToIndex(targetIndex) {
        // Returns a promise resolved when pointer reaches the target (or starts at head)
        return new Promise(async (resolve) => {
          if (list.length === 0) {
            // nothing to traverse
            resolve(-1);
            return;
          }
          pointer.style.display = 'block';
          const nodes = Array.from(stage.querySelectorAll('.node'));
          let current = 0;
          // If targetIndex is -1 (meaning tail insertion when list empty) treat as -1
          for (current = 0; current <= Math.min(targetIndex, list.length - 1); current++) {
            const nodeEl = nodes[current];
            highlightNode(nodeEl, 'current');
            await movePointerTo(nodeEl);
            // small pause
            await pause(240);
            unhighlightNode(nodeEl, 'current');
          }
          resolve(Math.min(targetIndex, list.length - 1));
        });
      }

      function highlightNode(nodeEl, cls) {
        nodeEl.classList.add(cls);
      }
      function unhighlightNode(nodeEl, cls) {
        nodeEl.classList.remove(cls);
      }

      function movePointerTo(nodeEl) {
        return new Promise((resolve) => {
          const rect = nodeEl.getBoundingClientRect();
          const stageRect = stage.getBoundingClientRect();
          const left = rect.left + rect.width / 2 - stageRect.left;
          const top = rect.top - stageRect.top - 18; // place above node
          pointer.style.left = left + 'px';
          pointer.style.top = top + 'px';
          // wait for transition to complete
          setTimeout(resolve, 480);
        });
      }

      function pause(ms) { return new Promise((r) => setTimeout(r, ms)); }

      // Insert operation with animation
      async function insertAt(position, index, value) {
        disableControls(true);
        try {
          if (position === 'head') index = 0;
          if (position === 'tail') index = list.length;
          if (index < 0) index = 0;
          if (index > list.length) index = list.length;

          // If we need to traverse to index-1 (to show pointer moving to predecessor)
          let targetTraverse = Math.max(0, index - 1);
          if (list.length === 0 && index === 0) {
            // nothing to traverse - insert directly
            pointer.style.display = 'none';
          } else {
            await traverseToIndex(targetTraverse);
          }

          // Insert a placeholder element visually
          const newItem = { id: ++nodeId, value: String(value) };
          // Insert into data model at index
          list.splice(index, 0, newItem);

          // Render with insertion animation
          renderList();
          // Find the newly created DOM node
          const newNode = stage.querySelector(`.node[data-id="${newItem.id}"]`);
          if (newNode) {
            newNode.classList.add('inserting', 'target');
            // Wait for it to pop in
            await pause(420);
            newNode.classList.remove('inserting', 'target');
          }
          await pause(220);
          pointer.style.display = 'none';
        } finally {
          disableControls(false);
        }
      }

      // Delete operation with animation
      async function deleteAt(index) {
        disableControls(true);
        try {
          if (list.length === 0) return;
          if (index < 0 || index >= list.length) {
            // invalid index, simple flash
            flashStage();
            return;
          }

          // Traverse to index (show pointer going through list)
          await traverseToIndex(index);

          // Highlight node to remove
          const nodeEl = stage.querySelector(`.node[data-index="${index}"]`);
          if (nodeEl) {
            nodeEl.classList.add('removing');
            await pause(360);
          }

          // Remove from data and re-render
          list.splice(index, 1);
          renderList();
          pointer.style.display = 'none';
          await pause(180);
        } finally {
          disableControls(false);
        }
      }

      function flashStage() {
        const orig = stage.style.boxShadow;
        stage.style.boxShadow = '0 0 0 4px rgba(239,68,68,0.12)';
        setTimeout(() => stage.style.boxShadow = orig, 380);
      }

      // Reset / random helpers
      function resetList() {
        list = [];
        nodeId = 0;
        renderList();
      }

      function randomList() {
        resetList();
        const n = Math.floor(Math.random() * 5) + 2;
        for (let i = 0; i < n; i++) {
          list.push({ id: ++nodeId, value: String(Math.floor(Math.random() * 99) + 1) });
        }
        renderList();
      }

      // Event listeners
      insertBtn.addEventListener('click', async () => {
        if (animating) return;
        const pos = positionSelect.value;
        let idx = parseInt(indexInput.value, 10);
        if (Number.isNaN(idx)) idx = 0;
        const val = valueInput.value.trim();
        if (val === '') {
          valueInput.focus();
          flashStage();
          return;
        }
        await insertAt(pos, idx, val);
      });

      deleteBtn.addEventListener('click', async () => {
        if (animating) return;
        let idx = parseInt(indexInput.value, 10);
        if (Number.isNaN(idx)) {
          // default to head
          idx = 0;
        }
        await deleteAt(idx);
      });

      resetBtn.addEventListener('click', () => {
        if (animating) return;
        resetList();
      });

      randomBtn.addEventListener('click', () => {
        if (animating) return;
        randomList();
      });

      // Initialize
      resetList();

      // Keyboard shortcuts: Enter to insert
      document.getElementById('controls').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          insertBtn.click();
        }
      });

      // Keep pointer hidden initially
      pointer.style.display = 'none';

      // Ensure stage is focusable for accessibility
      stage.addEventListener('focus', () => {
        stage.style.outline = 'none';
      });

      // Recompute indexes on render: keep data-index attributes in sync
      const observer = new MutationObserver(() => {
        const nodes = Array.from(stage.querySelectorAll('.node'));
        nodes.forEach((n, i) => n.dataset.index = i);
      });
      observer.observe(stage, { childList: true, subtree: true });

      // Hint: clicking a node sets index input to that node index
      stage.addEventListener('click', (ev) => {
        const node = ev.target.closest('.node');
        if (node) {
          const i = parseInt(node.dataset.index, 10);
          if (!Number.isNaN(i)) indexInput.value = String(i);
        }
      });

      // Small accessibility: announce changes via ARIA live region (stage has aria-live)
      // renderList already updates DOM and stage is live.

      // Prevent accidental text selection during pointer anims
      stage.addEventListener('mousedown', (e) => e.preventDefault());
    })();
  </script>
</body>
</html>