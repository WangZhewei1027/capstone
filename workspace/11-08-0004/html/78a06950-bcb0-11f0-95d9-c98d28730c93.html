<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Topological Sort — Kahn's Algorithm Visualizer</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1723;
      --panel: #0b1220;
      --accent: #60a5fa;
      --accent-2: #7dd3fc;
      --success: #10b981;
      --danger: #ef4444;
      --muted: #94a3b8;
      --card: #07111a;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#051022 0%, #071427 60%);
      color:#e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    .app {
      box-sizing: border-box;
      padding: var(--safe-margin);
      min-height:100%;
      display:flex;
      gap:var(--gap);
    }
    /* Left column controls */
    .left {
      width:380px;
      max-width:42%;
      min-width:280px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .title {
      font-size:20px;
      font-weight:700;
      letter-spacing: -0.2px;
      margin-bottom:6px;
    }
    .subtitle { color:var(--muted); font-size:13px; margin-top: -6px; }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:14px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      border:1px solid rgba(255,255,255,0.03);
    }
    .controls { display:flex; flex-direction:column; gap:12px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .btn {
      background: linear-gradient(180deg, var(--accent), #3b82f6);
      color:white;
      border:none;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      min-width:90px;
    }
    .btn.secondary {
      background: linear-gradient(180deg,#111827,#0b1220);
      border:1px solid rgba(255,255,255,0.04);
      color:var(--accent-2);
    }
    .btn.ghost {
      background: transparent;
      border:1px dashed rgba(255,255,255,0.04);
      color:var(--muted);
    }
    .small {
      padding:6px 10px;
      font-size:13px;
      min-width:56px;
    }
    .muted { color:var(--muted); font-size:13px; }
    .label { font-size:13px; color:#dbeafe; font-weight:600; }
    input[type="range"] {
      -webkit-appearance:none;
      width:160px;
      background:transparent;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height:6px; background:rgba(255,255,255,0.06); border-radius:6px;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; margin-top:-6px;
      height:18px;width:18px;border-radius:50%; background:var(--accent);
      box-shadow:0 3px 8px rgba(59,130,246,0.35);
    }
    .badge {
      display:inline-flex; align-items:center; justify-content:center;
      min-width:30px; height:30px; border-radius:8px;
      background:rgba(255,255,255,0.02); color:var(--muted); font-weight:700;
      border:1px solid rgba(255,255,255,0.02);
    }
    .queue {
      display:flex; gap:8px; align-items:center; flex-wrap:wrap; min-height:44px;
      padding:8px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border:1px solid rgba(255,255,255,0.02);
    }
    .queue .node-pill {
      background:linear-gradient(180deg,#082a49,#063056); padding:6px 10px; border-radius:999px; color:var(--accent-2);
      display:inline-flex; align-items:center; gap:8px; font-weight:700;
      box-shadow: 0 4px 8px rgba(2,6,23,0.5);
      transition: transform 220ms ease;
    }
    .queue .node-pill.glow { box-shadow:0 6px 18px rgba(96,165,250,0.25); transform:translateY(-4px); }
    .order {
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      min-height:44px; padding:8px; border-radius:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border:1px solid rgba(255,255,255,0.02);
    }
    .order .node-pill {
      background:linear-gradient(180deg,#13233a,#0d1e2d); padding:8px 12px; border-radius:10px; color:#dbeafe;
      display:inline-flex; align-items:center; gap:10px; font-weight:800;
    }
    .status {
      font-size:13px; color:var(--muted); min-height:36px;
    }

    /* Right column canvas */
    .right {
      flex:1;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      min-width:0;
    }
    .canvas-wrap {
      flex:1;
      border-radius:12px;
      padding:12px;
      min-height:420px;
      background: repeating-linear-gradient(45deg, rgba(255,255,255,0.01) 0px, rgba(255,255,255,0.01) 1px, transparent 1px, transparent 28px);
      border:1px solid rgba(255,255,255,0.03);
      position:relative;
      overflow:hidden;
    }
    svg.graph {
      width:100%;
      height:100%;
      display:block;
    }
    .node {
      cursor:grab;
      transition: transform 180ms ease, opacity 360ms ease;
    }
    .node.dragging { cursor:grabbing; transform:scale(1.02); }
    .node .label { font-size:13px; fill:#e6eef6; pointer-events:none; text-anchor:middle; dominant-baseline:central; font-weight:700; }
    .node .circle {
      fill: linear-gradient(180deg,#0b3b5a,#063047);
      stroke: rgba(255,255,255,0.04);
      transition: stroke-width 160ms ease, filter 160ms ease, opacity 300ms ease;
    }
    .node.ready .circle { filter: drop-shadow(0 8px 18px rgba(96,165,250,0.18)); stroke-width:2px; stroke: rgba(96,165,250,0.6); }
    .node.removed { opacity:0.12; pointer-events:none; }
    .indegree {
      font-size:11px; fill:#ffffff; pointer-events:none; text-anchor:middle; dominant-baseline:central; font-weight:800;
    }
    .edge {
      stroke:#60a5fa; stroke-width:2.4; fill:none; opacity:0.9;
      transition: opacity 300ms ease;
    }
    .edge.removed { opacity:0.06; stroke-dasharray:2 6; }
    .edge.cycle { stroke: #ef4444; }
    /* Arrow marker */
    marker#arrow { fill: #60a5fa; }
    .cycle-indicator { color:var(--danger); font-weight:800; }

    /* Responsive */
    @media (max-width:900px){
      .left { max-width:44%; min-width:220px; }
    }
    @media (max-width:720px){
      .app { flex-direction:column; padding:16px; }
      .left { width:100%; max-width:none; min-width:0; order:2; }
      .right { order:1; min-height:320px; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Topological Sort Visualizer">
    <div class="left">
      <div>
        <div class="title">Topological Sort — Kahn's Algorithm</div>
        <div class="subtitle">Interactive visualization: build a graph, then step through Kahn's algorithm to see a valid topological order or detect cycles.</div>
      </div>

      <div class="card controls" aria-hidden="false">
        <div class="row" style="justify-content:space-between; align-items:center;">
          <div class="label">Graph Editor</div>
          <div class="muted">Nodes are draggable · Edges are directed</div>
        </div>

        <div class="row">
          <button id="addNode" class="btn">Add Node</button>
          <button id="createEdge" class="btn secondary small">Create Edge</button>
          <button id="deleteMode" class="btn ghost small">Delete</button>
          <button id="randomDag" class="btn small">Random DAG</button>
          <button id="resetGraph" class="btn ghost small">Reset</button>
        </div>

        <div class="row" style="align-items:center;">
          <div class="label">Random DAG › Size</div>
          <input id="dagSize" type="range" min="3" max="12" value="6" />
          <div class="badge" id="sizeBadge">6</div>
        </div>

      </div>

      <div class="card controls">
        <div class="row" style="justify-content:space-between; align-items:center;">
          <div class="label">Algorithm Controls</div>
          <div class="muted">Kahn's algorithm (step-by-step)</div>
        </div>

        <div class="row">
          <button id="stepBtn" class="btn">Step</button>
          <button id="playBtn" class="btn secondary">Play</button>
          <button id="restartBtn" class="btn ghost">Restart</button>
        </div>

        <div class="row" style="align-items:center;">
          <div class="label">Speed</div>
          <input id="speed" type="range" min="200" max="1600" value="800" />
          <div class="muted" id="speedLabel">800 ms</div>
        </div>

        <div class="row" style="flex-direction:column; gap:8px;">
          <div class="label">Zero in-degree Queue</div>
          <div id="queue" class="queue" aria-live="polite" aria-relevant="additions removals"></div>
        </div>

        <div style="display:flex; flex-direction:column; gap:8px;">
          <div class="label">Topological Order (output)</div>
          <div id="order" class="order" aria-live="polite"></div>
        </div>

        <div class="status" id="status" role="status">No algorithm run yet.</div>
      </div>

      <div class="card">
        <div class="label">Instructions</div>
        <div class="muted" style="margin-top:6px; line-height:1.4;">
          • Add nodes and connect them with Create Edge. Drag nodes to lay out the graph.<br>
          • Use Step to move one node from the zero in-degree queue into the output. Play runs steps automatically.<br>
          • If the algorithm stops with nodes remaining and no zero in-degree node, a cycle is present.<br>
          • Use Random DAG to generate an acyclic example instantly.
        </div>
      </div>

    </div>

    <div class="right">
      <div class="canvas-wrap card" tabindex="0">
        <svg id="svg" class="graph" viewBox="0 0 1200 720" preserveAspectRatio="xMidYMid meet" aria-label="Graph canvas">
          <defs>
            <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" />
            </marker>
            <marker id="arrow-red" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#ef4444"/>
            </marker>
          </defs>

          <!-- edges go here -->
          <g id="edges" aria-hidden="true"></g>
          <!-- nodes go here -->
          <g id="nodes" aria-hidden="true"></g>
        </svg>
      </div>
    </div>
  </div>

  <script>
    // Simple interactive Topological Sort visualizer (Kahn's algorithm)
    // No external libraries.
    (function(){
      // Utilities
      const svg = document.getElementById('svg');
      const nodesG = document.getElementById('nodes');
      const edgesG = document.getElementById('edges');
      const addNodeBtn = document.getElementById('addNode');
      const createEdgeBtn = document.getElementById('createEdge');
      const deleteModeBtn = document.getElementById('deleteMode');
      const randomDagBtn = document.getElementById('randomDag');
      const resetGraphBtn = document.getElementById('resetGraph');
      const dagSizeRange = document.getElementById('dagSize');
      const sizeBadge = document.getElementById('sizeBadge');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const restartBtn = document.getElementById('restartBtn');
      const queueDiv = document.getElementById('queue');
      const orderDiv = document.getElementById('order');
      const statusDiv = document.getElementById('status');
      const speedRange = document.getElementById('speed');
      const speedLabel = document.getElementById('speedLabel');

      sizeBadge.textContent = dagSizeRange.value;
      dagSizeRange.addEventListener('input', ()=> sizeBadge.textContent = dagSizeRange.value);
      speedLabel.textContent = speedRange.value + ' ms';

      // Model
      let nodes = []; // {id, label, x,y, element, removed}
      let edges = []; // {id, from, to, element, removed}
      let nextNodeCharCode = 65; // 'A'
      let mode = null; // 'create-edge' or 'delete' or null
      let pendingEdgeSource = null;

      // Kahn algorithm state
      let indeg = {}; // id -> number
      let adj = {}; // id -> [toIds]
      let queue = []; // ids of zero in-degree nodes
      let output = []; // final order
      let algorithmRunning = false;
      let autoplay = false;
      let autoplayTimer = null;

      // SVG viewbox size
      const VW = 1200, VH = 720;

      // Create node
      function addNodeAt(x, y, label){
        const id = 'n' + Date.now() + Math.random().toString(36).slice(2,6);
        label = label || String.fromCharCode(nextNodeCharCode++);
        const nodeG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        nodeG.classList.add('node');
        nodeG.setAttribute('data-id', id);

        // circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('r', 28);
        circle.classList.add('circle');
        circle.setAttribute('cx',0);
        circle.setAttribute('cy',0);
        circle.setAttribute('fill','#07263b');

        // label
        const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
        txt.classList.add('label');
        txt.textContent = label;
        txt.setAttribute('x', 0);
        txt.setAttribute('y', 0);

        // indegree badge (small)
        const indeTxt = document.createElementNS('http://www.w3.org/2000/svg','text');
        indeTxt.classList.add('indegree');
        indeTxt.textContent = '0';
        indeTxt.setAttribute('x', 18);
        indeTxt.setAttribute('y', -18);

        nodeG.appendChild(circle);
        nodeG.appendChild(txt);
        nodeG.appendChild(indeTxt);

        // transform group
        nodeG.setAttribute('transform', `translate(${x} ${y})`);
        nodesG.appendChild(nodeG);

        const node = { id, label, x, y, element: nodeG, removed:false, indeText: indeTxt, circle };
        nodes.push(node);
        attachNodeEvents(node);
        layout();
        scheduleUpdate();
        return node;
      }

      function attachNodeEvents(node){
        const g = node.element;
        let isDragging = false;
        let start = null;

        const onPointerDown = (e) => {
          e.preventDefault();
          if (mode === 'create-edge'){
            // Select edge endpoints
            if (!pendingEdgeSource){
              pendingEdgeSource = node;
              g.classList.add('ready'); // highlight as source
              status('Selected source ' + node.label + ' — click target.');
            } else if (pendingEdgeSource === node) {
              status('Cannot create self-loop. Choose another target.');
            } else {
              // create directed edge pendingEdgeSource -> node
              createEdge(pendingEdgeSource, node);
              pendingEdgeSource.element.classList.remove('ready');
              pendingEdgeSource = null;
              status('Edge created.');
            }
            return;
          }
          if (mode === 'delete'){
            // delete node and its edges
            removeNode(node);
            status('Node ' + node.label + ' deleted.');
            return;
          }
          // otherwise dragging
          isDragging = true;
          g.classList.add('dragging');
          start = getPointerPosition(e);
          g.setPointerCapture(e.pointerId);
        };
        const onPointerMove = (e) => {
          if (!isDragging) return;
          const p = getPointerPosition(e);
          const dx = p.x - start.x, dy = p.y - start.y;
          start = p;
          node.x += dx; node.y += dy;
          node.element.setAttribute('transform', `translate(${node.x} ${node.y})`);
          updateEdgesForNode(node.id);
        };
        const onPointerUp = (e) => {
          if (isDragging){
            isDragging = false;
            g.classList.remove('dragging');
            try { g.releasePointerCapture(e.pointerId);} catch(e){}
          }
        };

        g.addEventListener('pointerdown', onPointerDown);
        g.addEventListener('pointermove', onPointerMove);
        g.addEventListener('pointerup', onPointerUp);
        g.addEventListener('pointerleave', onPointerUp);

        // right-click to delete edge from node (optional)
      }

      function createEdge(fromNode, toNode){
        if (fromNode.id === toNode.id) return;
        // Make sure not duplicate
        if (edges.some(e => e.from === fromNode.id && e.to === toNode.id && !e.removed)) {
          status('Edge already exists.');
          return;
        }
        const id = 'e' + Date.now() + Math.random().toString(36).slice(2,6);
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        path.classList.add('edge');
        path.setAttribute('data-id', id);
        path.setAttribute('marker-end', 'url(#arrow)');
        edgesG.appendChild(path);

        const edge = { id, from: fromNode.id, to: toNode.id, element: path, removed:false };
        edges.push(edge);
        updateEdgePath(edge);
        attachEdgeEvents(edge);
      }

      function attachEdgeEvents(edge){
        const el = edge.element;
        el.addEventListener('click', (ev)=>{
          if (mode === 'delete'){
            removeEdge(edge);
            status('Edge deleted.');
            ev.stopPropagation();
          }
        });
      }

      function updateEdgePath(edge){
        const from = nodes.find(n=>n.id===edge.from);
        const to = nodes.find(n=>n.id===edge.to);
        if (!from || !to) return;
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const dist = Math.hypot(dx,dy);
        const r = 28; // node radius
        // start and end offset so arrow doesn't overlap nodes
        const sx = from.x + (dx/dist)*(r-2);
        const sy = from.y + (dy/dist)*(r-2);
        const ex = to.x - (dx/dist)*(r+6);
        const ey = to.y - (dy/dist)*(r+6);
        // simple straight path
        const d = 'M '+sx+' '+sy+' L '+ex+' '+ey;
        edge.element.setAttribute('d', d);
      }

      function updateEdgesForNode(nodeId){
        edges.filter(e=>!e.removed && (e.from===nodeId || e.to===nodeId)).forEach(updateEdgePath);
      }

      function removeNode(node){
        node.removed = true;
        // mark element visually
        node.element.classList.add('removed');
        // remove edges connected
        edges.filter(e=>e.from===node.id || e.to===node.id).forEach(removeEdge);
        try{ node.element.remove(); }catch(e){}
        nodes = nodes.filter(n=>n.id!==node.id);
        scheduleUpdate();
      }

      function removeEdge(edge){
        if (edge.removed) return;
        edge.removed = true;
        edge.element.classList.add('removed');
        try{ edge.element.remove(); }catch(e){}
        edges = edges.filter(e=>e.id!==edge.id);
        scheduleUpdate();
      }

      function layout(){
        // nothing fancy—keep current positions; if new with no pos, place randomly
        nodes.forEach((n,i)=>{
          if (isNaN(n.x)||isNaN(n.y)){
            n.x = 160 + (i%4)*160 + Math.random()*40;
            n.y = 120 + Math.floor(i/4)*140 + Math.random()*40;
            n.element.setAttribute('transform', `translate(${n.x} ${n.y})`);
          }
        });
        edges.forEach(updateEdgePath);
      }

      // Graph helpers
      function clearGraph(){
        nodesG.innerHTML = ''; edgesG.innerHTML = '';
        nodes = []; edges = []; nextNodeCharCode = 65;
        pendingEdgeSource = null;
        scheduleUpdate();
      }

      // Random DAG generator (edges from lower index to higher index to prevent cycles)
      function generateRandomDAG(n, density){
        clearGraph();
        const pad = 120;
        for(let i=0;i<n;i++){
          const x = pad + (i%6)*160 + (Math.random()*40-20);
          const y = 120 + Math.floor(i/6)*160 + (Math.random()*40-20);
          addNodeAt(x, y, String.fromCharCode(65+i));
        }
        // add edges only from lower index to higher index
        for(let i=0;i<n;i++){
          for(let j=i+1;j<n;j++){
            if (Math.random() < density) createEdge(nodes[i], nodes[j]);
          }
        }
        status('Random DAG generated. Try running Kahn\'s algorithm.');
      }

      // Kahn's algorithm implementation (step-by-step)
      function computeIndegAndAdj(){
        indeg = {}; adj = {};
        nodes.forEach(n => { indeg[n.id] = 0; adj[n.id] = []; });
        edges.forEach(e=>{
          if (e.removed) return;
          if (!(e.from in indeg) || !(e.to in indeg)) return;
          indeg[e.to] = (indeg[e.to]||0) + 1;
          adj[e.from].push(e.to);
        });
      }

      function prepareAlgorithm(){
        computeIndegAndAdj();
        queue = [];
        output = [];
        // UI: reset visual
        nodes.forEach(n=>{ n.element.classList.remove('ready'); n.element.classList.remove('removed'); });
        edges.forEach(e=>{ if (e.element) e.element.classList.remove('removed','cycle'); });
        nodes.forEach(n=>{
          const v = indeg[n.id]||0;
          if (n.indeText) n.indeText.textContent = v;
          n.removed = false;
        });
        edges.forEach(e => e.removed = false);
        // populate initial queue
        for(const id in indeg) if (indeg[id] === 0) queue.push(id);
        queue = queue.sort((a,b)=>nodeLabel(a).localeCompare(nodeLabel(b))); // stable order by label
        output = [];
        algorithmRunning = true;
        renderQueue();
        renderOrder();
        status('Initialized. ' + queue.length + ' node(s) have zero in-degree.');
      }

      function nodeLabel(id){
        const n = nodes.find(x=>x.id===id);
        return n ? n.label : '';
      }

      function renderQueue(){
        queueDiv.innerHTML = '';
        queue.forEach(id=>{
          const pill = document.createElement('div');
          pill.className = 'node-pill glow';
          pill.textContent = nodeLabel(id);
          queueDiv.appendChild(pill);
          // highlight svg node
          const n = nodes.find(x=>x.id===id);
          if (n) n.element.classList.add('ready');
        });
        // remove ready from nodes not in queue
        nodes.forEach(n=>{ if (!queue.includes(n.id)) n.element.classList.remove('ready'); });
      }

      function renderOrder(){
        orderDiv.innerHTML = '';
        output.forEach(id=>{
          const pill = document.createElement('div');
          pill.className = 'node-pill';
          pill.textContent = nodeLabel(id);
          orderDiv.appendChild(pill);
        });
      }

      function stepAlgorithm(){
        if (!algorithmRunning) {
          prepareAlgorithm();
        }
        // find next zero-in-degree node
        if (queue.length === 0){
          // if nodes still remaining, cycle
          const remaining = Object.keys(indeg).filter(id => !output.includes(id));
          if (remaining.length > 0){
            // cycle detected
            // mark cycle edges red
            status('Cycle detected — algorithm cannot proceed.', true);
            // highlight remaining nodes/edges
            remaining.forEach(id=>{
              const n = nodes.find(x=>x.id===id);
              if (n) n.element.classList.add('removed');
            });
            edges.forEach(e=>{
              if (remaining.includes(e.from) && remaining.includes(e.to)){
                if (e.element) e.element.classList.add('cycle');
              }
            });
            algorithmRunning = false;
          } else {
            status('Algorithm complete. Topological order found.');
            algorithmRunning = false;
          }
          renderQueue();
          return;
        }

        // pop first
        const id = queue.shift();
        // animate removal
        animateRemoveNode(id);
        output.push(id);
        // decrement indegrees of neighbors after a slight delay to allow animation
        setTimeout(()=>{
          (adj[id]||[]).forEach(nei=>{
            indeg[nei]--;
            const n = nodes.find(x=>x.id===nei);
            if (n && n.indeText) {
              n.indeText.textContent = indeg[nei];
            }
            if (indeg[nei] === 0){
              queue.push(nei);
              // sort to keep stable label ordering
              queue = queue.sort((a,b)=>nodeLabel(a).localeCompare(nodeLabel(b)));
            }
          });
          renderQueue();
          renderOrder();
          status('Removed ' + nodeLabel(id) + '. ' + queue.length + ' node(s) now in queue.');
        }, 320);
      }

      function animateRemoveNode(id){
        const node = nodes.find(n=>n.id===id);
        if (!node) return;
        // visually fade the node and its outgoing edges
        node.element.classList.add('removed');
        // fade edges out
        edges.filter(e=>e.from===id && !e.removed).forEach(e=>{
          if (e.element) e.element.classList.add('removed');
        });
      }

      function status(msg, important){
        statusDiv.textContent = msg;
        if (important){
          statusDiv.classList.add('cycle-indicator');
          setTimeout(()=> statusDiv.classList.remove('cycle-indicator'), 1400);
        }
      }

      // Controls wiring
      addNodeBtn.addEventListener('click', ()=>{
        const x = 220 + Math.random()*640;
        const y = 120 + Math.random()*420;
        addNodeAt(x,y);
      });

      createEdgeBtn.addEventListener('click', ()=>{
        if (mode === 'create-edge'){
          mode = null; createEdgeBtn.classList.remove('active'); createEdgeBtn.textContent = 'Create Edge';
          if (pendingEdgeSource){ pendingEdgeSource.element.classList.remove('ready'); pendingEdgeSource=null; }
          status('Create edge canceled.');
        } else {
          mode = 'create-edge';
          createEdgeBtn.textContent = 'Cancel';
          status('Click a source node then a target node.');
        }
        // visually indicate
      });

      deleteModeBtn.addEventListener('click', ()=>{
        if (mode === 'delete'){
          mode = null; deleteModeBtn.classList.remove('active'); deleteModeBtn.textContent = 'Delete';
          status('Delete mode disabled.');
        } else {
          mode = 'delete';
          deleteModeBtn.textContent = 'Cancel';
          status('Delete mode enabled. Click a node or edge to delete.');
        }
      });

      resetGraphBtn.addEventListener('click', ()=>{
        clearGraph();
        status('Graph cleared.');
      });

      randomDagBtn.addEventListener('click', ()=>{
        const n = parseInt(dagSizeRange.value,10) || 6;
        // density heuristic: between 0.15 and 0.45 depending on size
        const dens = Math.max(0.12, Math.min(0.5, 0.25 + (n-6)*0.03));
        generateRandomDAG(n, dens);
      });

      dagSizeRange.addEventListener('input', ()=> {
        sizeBadge.textContent = dagSizeRange.value;
      });

      // Step/Play controls
      stepBtn.addEventListener('click', ()=>{
        stepAlgorithm();
      });

      function autoplayTick(){
        stepAlgorithm();
        if (!algorithmRunning) {
          stopAutoplay();
        } else {
          autoplayTimer = setTimeout(autoplayTick, parseInt(speedRange.value,10));
        }
      }

      function startAutoplay(){
        if (autoplay) return;
        autoplay = true;
        playBtn.textContent = 'Pause';
        // ensure algorithm prepared
        if (!algorithmRunning) prepareAlgorithm();
        autoplayTimer = setTimeout(autoplayTick, parseInt(speedRange.value,10));
      }
      function stopAutoplay(){
        autoplay = false;
        playBtn.textContent = 'Play';
        if (autoplayTimer) { clearTimeout(autoplayTimer); autoplayTimer = null; }
      }
      playBtn.addEventListener('click', ()=>{
        if (autoplay) stopAutoplay(); else startAutoplay();
      });

      restartBtn.addEventListener('click', ()=>{
        prepareAlgorithm();
      });

      speedRange.addEventListener('input', ()=>{
        speedLabel.textContent = speedRange.value + ' ms';
      });

      // keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if (e.code === 'Space'){ e.preventDefault(); stepAlgorithm(); }
        if (e.key === 'r'){ prepareAlgorithm(); }
      });

      // helpers
      function getPointerPosition(e){
        // transform mouse coordinates into svg viewbox coordinates
        const pt = svg.createSVGPoint();
        pt.x = e.clientX; pt.y = e.clientY;
        const ctm = svg.getScreenCTM().inverse();
        const p = pt.matrixTransform(ctm);
        return { x: p.x, y: p.y };
      }

      // Click on canvas to add node at point on double-click
      svg.addEventListener('dblclick', (e)=>{
        const p = getPointerPosition(e);
        addNodeAt(p.x, p.y);
      });

      // click on empty area cancels edge creation
      svg.addEventListener('click', (e)=>{
        if (mode === 'create-edge' && !pendingEdgeSource) return;
        // clicking on background cancels pending edge source
        if (mode === 'create-edge' && pendingEdgeSource){
          pendingEdgeSource.element.classList.remove('ready');
          pendingEdgeSource = null;
          status('Create edge canceled.');
        }
      });

      // window resize -> layout adjust
      window.addEventListener('resize', ()=> layout());

      // schedule update for indegree badges and edges
      let refreshScheduled = false;
      function scheduleUpdate(){
        if (refreshScheduled) return;
        refreshScheduled = true;
        requestAnimationFrame(()=>{
          nodes.forEach(n=>{
            if (n.indeText) {
              // ensure displayed indegree is not stale
              if (n.indeText.textContent === '') n.indeText.textContent = '0';
            }
            // update transform pos
            n.element.setAttribute('transform', `translate(${n.x} ${n.y})`);
          });
          edges.forEach(updateEdgePath);
          refreshScheduled = false;
        });
      }

      // initialize with a small example
      generateRandomDAG(6, 0.3);
      prepareAlgorithm();

      // expose some helper functions for dev console (optional)
      window._topo = {
        nodes, edges, prepareAlgorithm, stepAlgorithm, generateRandomDAG, clearGraph
      };
    })();
  </script>
</body>
</html>