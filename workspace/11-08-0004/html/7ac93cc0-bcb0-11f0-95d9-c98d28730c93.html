<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Breadth-First Search — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #081020;
      --accent: #38bdf8;
      --accent-2: #60a5fa;
      --good: #34d399;
      --warn: #f59e0b;
      --muted: #9ca3af;
      --text: #e6eef6;
      --danger: #fb7185;
      --node-radius: 22;
      --control-height: 40px;
    }

    /* Safe area & layout */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071027 0%, #041225 100%);
      color:var(--text);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app{
      padding:var(--safe-margin);
      box-sizing:border-box;
      min-height:100%;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:var(--gap);
    }
    .title{
      font-size:20px;
      font-weight:600;
      letter-spacing:0.2px;
    }
    .subtitle{
      color:var(--muted);
      font-size:13px;
    }

    /* Main layout: left info/controls, right canvas */
    .main{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:var(--gap);
      align-items:start;
    }

    /* Info panel */
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      border-radius:12px;
      padding:18px;
      box-sizing:border-box;
      min-height:120px;
    }
    .section-title{
      font-weight:600;
      font-size:13px;
      margin-bottom:8px;
      color:var(--accent-2);
    }
    .muted{
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    /* Controls */
    .controls{
      margin-top:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .ctrl-row{
      display:flex;
      gap:12px;
      align-items:center;
    }
    button, .toggle {
      height:var(--control-height);
      min-width:80px;
      padding:0 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      color:var(--text);
      cursor:pointer;
      font-weight:600;
      font-size:13px;
    }
    button[aria-pressed="true"], .toggle.active{
      outline:2px solid rgba(56,189,248,0.12);
      box-shadow:0 6px 18px rgba(8,145,178,0.06);
    }
    .small{
      height:36px;
      min-width:48px;
      font-size:13px;
      padding:0 10px;
    }

    .controls .row {
      display:flex;
      gap:12px;
    }

    /* Canvas area */
    .stage{
      border-radius:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border:1px solid rgba(255,255,255,0.03);
      padding:12px;
      min-height:520px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .toolbar{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }

    /* Graph container */
    .graph-wrap{
      flex:1 1 auto;
      background: linear-gradient(180deg, rgba(8,18,36,0.6), rgba(6,14,28,0.6));
      border-radius:8px;
      position:relative;
      overflow:hidden;
      min-height:420px;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
    }

    svg{
      width:100%;
      height:100%;
      display:block;
      touch-action: none;
      user-select:none;
    }

    /* Node & edge styles (SVG classes) */
    .edge {
      stroke: rgba(255,255,255,0.06);
      stroke-width:3;
      transition: stroke 220ms, stroke-width 220ms, opacity 220ms;
      opacity:0.9;
    }
    .edge.highlight {
      stroke: var(--accent);
      stroke-width:5;
      opacity:1;
      filter: drop-shadow(0 6px 12px rgba(56,189,248,0.12));
      transition: stroke 180ms, stroke-width 180ms;
    }
    .edge.pulse {
      animation: pulseEdge 420ms ease-out;
    }
    @keyframes pulseEdge{
      from { stroke-width:5; opacity:1; }
      to { stroke-width:3; opacity:0.9; }
    }

    .node-group { cursor:pointer; }
    .node-circle{
      fill: linear-gradient(#ffffff, #ffffff);
      fill: #072a3b;
      stroke: rgba(255,255,255,0.06);
      stroke-width:2;
      transition: fill 180ms, stroke 180ms, transform 180ms;
    }
    .node-label{
      font-size:13px;
      fill: var(--text);
      text-anchor:middle;
      dominant-baseline:central;
      pointer-events:none;
      font-weight:700;
    }
    .node-start { stroke: var(--good); stroke-width:3.5; box-shadow:0 6px 12px rgba(52,211,153,0.08); }
    .node-target { stroke: var(--danger); stroke-width:3.5; }
    .node-visited { fill: rgba(56,189,248,0.12); stroke: rgba(56,189,248,0.6); }
    .node-frontier { fill: rgba(96,165,250,0.12); stroke: rgba(96,165,250,0.6); transform-origin:center; }
    .node-path { fill: rgba(52,211,153,0.12); stroke: var(--good); }

    /* Queue visualization */
    .queue-panel{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      padding:8px;
      background: rgba(255,255,255,0.01);
      border-radius:8px;
      min-height:52px;
    }
    .queue-item{
      padding:6px 10px;
      border-radius:999px;
      background:rgba(255,255,255,0.03);
      color:var(--text);
      font-weight:700;
      font-size:13px;
      min-width:34px;
      text-align:center;
      transition: transform 220ms, background 220ms;
    }
    .queue-item.enqueue{
      background: linear-gradient(90deg, rgba(56,189,248,0.16), rgba(96,165,250,0.12));
      transform: translateY(-6px);
      box-shadow:0 10px 18px rgba(8,145,178,0.06);
    }
    .queue-item.dequeue{
      transform: translateY(8px) scale(0.95);
      opacity:0.65;
    }

    /* Log area */
    .log{
      margin-top:8px;
      font-family:monospace;
      font-size:12px;
      color:var(--muted);
      max-height:120px;
      overflow:auto;
      padding:8px;
      border-radius:8px;
      background: rgba(255,255,255,0.01);
      border:1px solid rgba(255,255,255,0.02);
    }

    /* Footer small hints */
    .hint{
      color:var(--muted);
      font-size:12px;
      margin-top:6px;
    }

    /* Responsive adjustments */
    @media (max-width:980px){
      .main{ grid-template-columns: 1fr; }
      .panel{ order:2; }
      .stage{ order:1; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Breadth First Search interactive module">
    <header>
      <div>
        <div class="title">Breadth-First Search (BFS) — Interactive Explorer</div>
        <div class="subtitle">Build a graph, set a start & target, watch BFS explore breadth-first.</div>
      </div>
      <div class="subtitle" aria-hidden="true">Safe margins: 24px • Spacing: 16px • Vanilla JS + SVG</div>
    </header>

    <div class="main" role="main">
      <!-- Left info and controls -->
      <aside class="panel" aria-labelledby="conceptTitle">
        <div id="conceptTitle" class="section-title">Concept Title</div>
        <div class="muted" style="margin-bottom:10px;">
          Breadth-First Search (BFS): an algorithm that explores a graph level by level, discovering all nodes at distance d from the start before moving to distance d+1. Use it to find shortest path in unweighted graphs and to discover connected components.
        </div>

        <div class="section-title">Learning Objective</div>
        <div class="muted">
          After interacting with this module you will:
          <ul style="margin:8px 0 0 18px;line-height:1.5;color:var(--muted)">
            <li>Understand how BFS visits nodes level-by-level using a queue.</li>
            <li>See how nodes move from frontier (queue) to visited and how parents form a shortest path.</li>
            <li>Use controls to step, run, and observe queue/edge animations that reinforce BFS order.</li>
          </ul>
        </div>

        <div class="section-title" style="margin-top:12px;">Interaction Design</div>
        <div class="muted">
          Interactions:
          <ul style="margin:8px 0 0 18px;line-height:1.5;color:var(--muted)">
            <li>Click the canvas to add a node. Drag nodes to reposition them.</li>
            <li>Toggle "Add Edge", then click a source node and a target node to create an edge (undirected).</li>
            <li>Use "Set Start" and "Set Target" then click nodes to mark them.</li>
            <li>Run BFS to animate the exploration. Use "Step" to execute one queue operation at a time.</li>
            <li>Queue visualization shows items being enqueued/dequeued. Edges pulse when traversed. Final shortest path highlights in green.</li>
          </ul>
          These animations and controls provide immediate visual feedback of BFS mechanics: queue order, frontier expansion, and path reconstruction.
        </div>

        <div class="section-title" style="margin-top:12px;">Layout Description</div>
        <div class="muted">
          Spatial organization:
          <ul style="margin:8px 0 0 18px;color:var(--muted);line-height:1.4">
            <li>Left column: explanatory text and stacked controls (fixed-width 360px). Ensures focus on learning & controls.</li>
            <li>Right column: large SVG graph area with toolbar on top and queue + log below. Visuals occupy the majority of horizontal space for clarity.</li>
            <li>Safe margins of 24px and minimum spacing of 16px between interactive elements are applied using CSS variables and flex gaps. The UI is responsive and accessible (buttons have ARIA attributes, large clickable targets, descriptive labels).</li>
          </ul>
        </div>
      </aside>

      <!-- Right interactive stage -->
      <section class="stage" aria-label="BFS interactive stage">
        <div class="toolbar" role="toolbar" aria-label="Graph controls">
          <div>
            <button id="btnAddNode" title="Click canvas to add node">Add Node</button>
            <button id="btnAddEdge" class="toggle" title="Click source then target to create edge" aria-pressed="false">Add Edge</button>
            <button id="btnSetStart" class="toggle" aria-pressed="false">Set Start</button>
            <button id="btnSetTarget" class="toggle" aria-pressed="false">Set Target</button>
          </div>

          <div style="display:flex;gap:8px;align-items:center;">
            <button id="btnRun" style="background:linear-gradient(90deg,#34d399,#60a5fa);">Run BFS</button>
            <button id="btnStep" class="small">Step</button>
            <button id="btnReset" class="small">Reset</button>
            <button id="btnClear" class="small" title="Clear graph">Clear</button>
          </div>

          <div style="margin-left:auto;display:flex;gap:10px;align-items:center;">
            <label style="font-size:13px;color:var(--muted)">Speed</label>
            <input id="speed" type="range" min="0.4" max="2.0" step="0.1" value="1" aria-label="Animation speed" />
          </div>
        </div>

        <div class="graph-wrap" id="graphWrap" tabindex="0" aria-label="Graph canvas. Click to add nodes.">
          <!-- SVG goes here -->
          <svg id="svg" viewBox="0 0 960 540" role="img" aria-label="Graph drawing area">
            <defs>
              <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="3.5" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            <g id="edges"></g>
            <g id="nodes"></g>
          </svg>
        </div>

        <div style="display:flex;gap:12px;flex-direction:column;">
          <div class="queue-panel" aria-live="polite" aria-label="BFS queue">
            <div style="color:var(--muted);font-weight:700;font-size:13px;">Queue:</div>
            <div id="queueList" style="display:flex;gap:8px;flex-wrap:wrap;"></div>
            <div style="margin-left:auto;color:var(--muted);font-size:13px;">Front →</div>
          </div>

          <div class="log" id="log" aria-live="polite">Log messages will appear here.</div>
          <div class="hint">Hints: Click canvas to add nodes. Toggle "Add Edge" then click two nodes to connect. Drag nodes to reposition. Use "Run BFS" or "Step".</div>
        </div>
      </section>
    </div>
  </div>

  <script>
    // BFS Interactive Module — Vanilla JS + SVG
    (function(){
      // Constants and state
      const svg = document.getElementById('svg');
      const nodesGroup = document.getElementById('nodes');
      const edgesGroup = document.getElementById('edges');
      const graphWrap = document.getElementById('graphWrap');

      const btnAddNode = document.getElementById('btnAddNode');
      const btnAddEdge = document.getElementById('btnAddEdge');
      const btnSetStart = document.getElementById('btnSetStart');
      const btnSetTarget = document.getElementById('btnSetTarget');
      const btnRun = document.getElementById('btnRun');
      const btnStep = document.getElementById('btnStep');
      const btnReset = document.getElementById('btnReset');
      const btnClear = document.getElementById('btnClear');
      const queueList = document.getElementById('queueList');
      const logEl = document.getElementById('log');
      const speedInput = document.getElementById('speed');

      let nodes = []; // {id,label,x,y,element, circle, text}
      let edges = []; // {id,a,b,element,line}
      let nextId = 0;
      const NODE_R = 22;

      // Modes
      let mode = null; // 'addEdge'|'setStart'|'setTarget'|null
      let pendingEdgeSource = null;

      // BFS state
      let startNode = null;
      let targetNode = null;
      let bfsState = null; // holds generator-style state if stepping
      let running = false;
      let animationTimer = null;

      // Helpers
      function log(msg){
        const line = document.createElement('div');
        line.textContent = msg;
        logEl.prepend(line);
      }
      function setMode(m){
        mode = m;
        btnAddEdge.classList.toggle('active', m === 'addEdge');
        btnSetStart.classList.toggle('active', m === 'setStart');
        btnSetTarget.classList.toggle('active', m === 'setTarget');
        btnAddEdge.setAttribute('aria-pressed', String(m === 'addEdge'));
        btnSetStart.setAttribute('aria-pressed', String(m === 'setStart'));
        btnSetTarget.setAttribute('aria-pressed', String(m === 'setTarget'));
        pendingEdgeSource = null;
      }

      // Create a node at coordinates (SVG coordinates)
      function addNode(x,y, label){
        const id = String(nextId++);
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.classList.add('node-group');
        g.setAttribute('data-id', id);
        g.setAttribute('tabindex', 0);
        g.setAttribute('role','button');
        g.setAttribute('aria-label', 'Graph node ' + (label || id));
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.classList.add('node-circle');
        circle.setAttribute('r', NODE_R);
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);

        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.classList.add('node-label');
        text.setAttribute('x', x);
        text.setAttribute('y', y);
        text.textContent = label || String.fromCharCode(65 + (nodes.length % 26));

        g.appendChild(circle);
        g.appendChild(text);
        nodesGroup.appendChild(g);

        const node = { id, label: text.textContent, x, y, element: g, circle, text };
        nodes.push(node);

        // Interactions: click, drag
        g.addEventListener('mousedown', onNodeMouseDown);
        g.addEventListener('click', onNodeClick);
        g.addEventListener('keydown', e => {
          if(e.key === 'Enter') onNodeClick(e);
        });

        return node;
      }

      function createEdge(aId,bId){
        if(aId === bId) return null;
        // Avoid duplicate edges (undirected)
        if(edges.some(e => (e.a === aId && e.b === bId) || (e.a === bId && e.b === aId))) return null;
        const a = findNode(aId), b = findNode(bId);
        if(!a || !b) return null;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.classList.add('edge');
        line.setAttribute('x1', a.x);
        line.setAttribute('y1', a.y);
        line.setAttribute('x2', b.x);
        line.setAttribute('y2', b.y);
        line.setAttribute('data-a', aId);
        line.setAttribute('data-b', bId);
        edgesGroup.appendChild(line);
        const id = `${aId}-${bId}`;
        const edge = { id, a: aId, b: bId, element: line, line };
        edges.push(edge);
        return edge;
      }

      function findNode(id){ return nodes.find(n => n.id === id); }

      function onNodeClick(e){
        e.stopPropagation();
        const g = e.currentTarget;
        const id = g.getAttribute('data-id');

        if(mode === 'addEdge'){
          if(!pendingEdgeSource){
            pendingEdgeSource = id;
            highlightNode(pendingEdgeSource, true);
            log('Edge source selected: ' + findNode(id).label);
            return;
          } else {
            if(pendingEdgeSource === id){
              // cancelled
              highlightNode(pendingEdgeSource, false);
              pendingEdgeSource = null;
              return;
            }
            // create edge
            const edge = createEdge(pendingEdgeSource, id);
            if(edge){
              log('Edge created: ' + nodeLabel(pendingEdgeSource) + ' — ' + nodeLabel(id));
            } else {
              log('Edge already exists or invalid.');
            }
            highlightNode(pendingEdgeSource, false);
            pendingEdgeSource = null;
            return;
          }
        }

        if(mode === 'setStart'){
          setStartNode(id);
          setMode(null);
          return;
        }
        if(mode === 'setTarget'){
          setTargetNode(id);
          setMode(null);
          return;
        }
        // Default click toggles nothing; selection could be extended
      }

      function highlightNode(id, on){
        const n = findNode(id);
        if(!n) return;
        if(on) n.circle.classList.add('node-frontier');
        else n.circle.classList.remove('node-frontier');
      }

      function nodeLabel(id){ const n=findNode(id); return n? n.label : id; }

      // Drag behavior
      let dragging = null;
      let dragOffset = {x:0,y:0};
      function onNodeMouseDown(e){
        e.preventDefault();
        e.stopPropagation();
        const g = e.currentTarget;
        const id = g.getAttribute('data-id');
        dragging = findNode(id);
        const pt = clientToSvg(e.clientX, e.clientY);
        dragOffset.x = dragging.x - pt.x;
        dragOffset.y = dragging.y - pt.y;
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
      }
      function onMouseMove(e){
        if(!dragging) return;
        const pt = clientToSvg(e.clientX, e.clientY);
        const nx = Math.max(NODE_R+6, Math.min(960 - NODE_R - 6, pt.x + dragOffset.x));
        const ny = Math.max(NODE_R+6, Math.min(540 - NODE_R - 6, pt.y + dragOffset.y));
        dragging.x = nx; dragging.y = ny;
        dragging.circle.setAttribute('cx', nx);
        dragging.circle.setAttribute('cy', ny);
        dragging.text.setAttribute('x', nx);
        dragging.text.setAttribute('y', ny);
        // update connected edges
        edges.forEach(e => {
          if(e.a === dragging.id){
            e.element.setAttribute('x1', nx);
            e.element.setAttribute('y1', ny);
          } else if(e.b === dragging.id){
            e.element.setAttribute('x2', nx);
            e.element.setAttribute('y2', ny);
          }
        });
      }
      function onMouseUp(){
        dragging = null;
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
      }
      function clientToSvg(clientX, clientY){
        const pt = svg.createSVGPoint();
        pt.x = clientX; pt.y = clientY;
        const ctm = svg.getScreenCTM().inverse();
        const sp = pt.matrixTransform(ctm);
        return { x: sp.x, y: sp.y };
      }

      // Buttons
      btnAddNode.addEventListener('click', () => {
        setMode(null);
        // Next click on canvas will add node. Provide brief instruction and set a temporary listener.
        graphWrap.style.outline = '2px dashed rgba(255,255,255,0.04)';
        log('Click on canvas to add a node.');
        const clickOnce = (e) => {
          const p = clientToSvg(e.clientX, e.clientY);
          addNode(p.x, p.y);
          log('Node added.');
          graphWrap.style.outline = '';
          graphWrap.removeEventListener('click', clickOnce);
        };
        graphWrap.addEventListener('click', clickOnce);
      });

      btnAddEdge.addEventListener('click', () => {
        if(mode === 'addEdge') setMode(null);
        else setMode('addEdge');
      });
      btnSetStart.addEventListener('click', () => {
        if(mode === 'setStart') setMode(null);
        else setMode('setStart');
      });
      btnSetTarget.addEventListener('click', () => {
        if(mode === 'setTarget') setMode(null);
        else setMode('setTarget');
      });

      btnClear.addEventListener('click', () => {
        clearGraph();
        log('Graph cleared.');
      });

      btnReset.addEventListener('click', () => {
        stopRun();
        resetVisualState();
        log('Visual state reset.');
      });

      btnRun.addEventListener('click', () => {
        if(!startNode){
          alert('Please set a start node first (Toggle "Set Start" then click a node).');
          return;
        }
        stopRun();
        resetVisualState();
        runBFS(startNode.id, targetNode ? targetNode.id : null);
      });

      btnStep.addEventListener('click', () => {
        if(!startNode){
          alert('Please set a start node first.');
          return;
        }
        if(!bfsState){
          resetVisualState();
          bfsState = createBFSState(startNode.id, targetNode ? targetNode.id : null);
        }
        stepBFS();
      });

      // Clear graph
      function clearGraph(){
        nodes.forEach(n => n.element.remove());
        edges.forEach(e => e.element.remove());
        nodes = [];
        edges = [];
        nextId = 0;
        startNode = null;
        targetNode = null;
        resetVisualState();
      }

      // Set start/target
      function setStartNode(id){
        startNode = findNode(id);
        // clear any existing start visual
        nodes.forEach(n => n.circle.classList.remove('node-start'));
        if(startNode) {
          startNode.circle.classList.add('node-start');
          log('Start set to ' + startNode.label);
        }
      }
      function setTargetNode(id){
        targetNode = findNode(id);
        nodes.forEach(n => n.circle.classList.remove('node-target'));
        if(targetNode){
          targetNode.circle.classList.add('node-target');
          log('Target set to ' + targetNode.label);
        }
      }

      // Visual reset
      function resetVisualState(){
        running = false;
        bfsState = null;
        clearQueueUI();
        // remove classes
        nodes.forEach(n => {
          n.circle.classList.remove('node-visited','node-frontier','node-path');
        });
        edges.forEach(e => {
          e.element.classList.remove('highlight','pulse');
        });
      }

      // BFS Implementation with animation
      function createBFSState(startId, targetId){
        // We'll create a simple state machine rather than generator
        const visited = new Set();
        const parent = {};
        const q = [];
        q.push(startId);
        visited.add(startId);
        parent[startId] = null;
        return { visited, parent, q, startId, targetId, done: false };
      }

      function runBFS(startId, targetId){
        bfsState = createBFSState(startId, targetId);
        running = true;
        log('BFS started from ' + nodeLabel(startId) + (targetId ? (' to ' + nodeLabel(targetId)) : '') + '.');
        // Kick off animation loop
        scheduleNextStep();
      }

      function scheduleNextStep(){
        if(!running || !bfsState) return;
        const delay = 600 / Number(speedInput.value || 1);
        animationTimer = setTimeout(() => {
          const cont = performBFSStep();
          if(cont) scheduleNextStep();
        }, delay);
      }

      function stopRun(){
        running = false;
        if(animationTimer) { clearTimeout(animationTimer); animationTimer = null; }
      }

      function performBFSStep(){
        const state = bfsState;
        if(!state || state.done) return false;
        if(state.q.length === 0){
          finalizeNoPath();
          state.done = true;
          return false;
        }
        // dequeue
        const cur = state.q.shift();
        animateDequeue(cur);

        // mark visited (if not already visually)
        const curNode = findNode(cur);
        if(curNode) curNode.circle.classList.add('node-visited');

        log('Visited ' + nodeLabel(cur));

        // check goal
        if(state.targetId && cur === state.targetId){
          // found target — reconstruct path
          reconstructPath(state.parent, cur);
          state.done = true;
          running = false;
          return false;
        }

        // enqueue neighbors
        const neighbors = neighborsOf(cur).filter(nid => !state.visited.has(nid));
        neighbors.forEach(nid => {
          state.visited.add(nid);
          state.parent[nid] = cur;
          state.q.push(nid);
          animateEnqueue(nid);
          // pulse edge between cur and nid
          const e = findEdgeBetween(cur, nid);
          if(e){
            pulseEdge(e);
          }
        });

        // Continue if queue not empty
        if(state.q.length === 0 && (!state.targetId)){
          // exploration complete
          state.done = true;
          running = false;
          log('BFS complete. All reachable nodes visited.');
          return false;
        }

        // schedule to continue
        return true;
      }

      function stepBFS(){
        if(!bfsState || bfsState.done) {
          bfsState = createBFSState(startNode.id, targetNode ? targetNode.id : null);
        }
        // single step only
        performBFSStep();
      }

      // Helpers: neighbors, findEdge
      function neighborsOf(nodeId){
        const list = [];
        edges.forEach(e => {
          if(e.a === nodeId) list.push(e.b);
          else if(e.b === nodeId) list.push(e.a);
        });
        return list;
      }
      function findEdgeBetween(a,b){
        return edges.find(e => (e.a === a && e.b === b) || (e.a === b && e.b === a));
      }

      // Visual queue animation
      function clearQueueUI(){
        queueList.innerHTML = '';
      }
      function animateEnqueue(nodeId){
        const item = document.createElement('div');
        item.className = 'queue-item enqueue';
        item.textContent = nodeLabel(nodeId);
        item.setAttribute('data-id', nodeId);
        queueList.appendChild(item);
        // Also mark node as frontier visually
        const n = findNode(nodeId); if(n) n.circle.classList.add('node-frontier');
        setTimeout(() => {
          item.classList.remove('enqueue');
        }, 420);
      }
      function animateDequeue(nodeId){
        // find first matching item
        const items = Array.from(queueList.children);
        const idx = items.findIndex(it => it.getAttribute('data-id') === nodeId);
        if(idx >= 0){
          const it = items[idx];
          it.classList.add('dequeue');
          setTimeout(() => it.remove(), 320);
        } else {
          // if not present, create a transient removed item
          const tmp = document.createElement('div');
          tmp.className = 'queue-item dequeue';
          tmp.textContent = nodeLabel(nodeId);
          queueList.appendChild(tmp);
          setTimeout(()=>tmp.remove(),320);
        }
        // frontier -> visited
        const n = findNode(nodeId); if(n){
          n.circle.classList.remove('node-frontier');
          n.circle.classList.add('node-visited');
        }
      }

      // Edge pulse and highlight
      function pulseEdge(edge){
        edge.element.classList.add('pulse','highlight');
        setTimeout(()=>{ edge.element.classList.remove('pulse'); }, 520);
      }

      // If BFS finishes without finding a target
      function finalizeNoPath(){
        log('BFS complete. Target not found.');
        running = false;
      }

      // Path reconstruction & highlight
      function reconstructPath(parent, targetId){
        const path = [];
        let cur = targetId;
        while(cur !== null && cur !== undefined){
          path.push(cur);
          cur = parent[cur];
        }
        path.reverse();
        log('Path found: ' + path.map(nodeLabel).join(' → '));
        // Visualize path
        for(let i=0;i<path.length;i++){
          const nid = path[i];
          const n = findNode(nid);
          if(n) n.circle.classList.add('node-path');
          if(i < path.length - 1){
            const e = findEdgeBetween(path[i], path[i+1]);
            if(e) e.element.classList.add('highlight');
          }
        }
      }

      // Utility: reset CSS & event wiring when SVG resized or scaled — simple demo doesn't require heavy handling
      // Initialize with a simple sample graph for convenience
      function seedSample(){
        const baseX=180, baseY=140, gapX=120, gapY=90;
        const a=addNode(baseX, baseY, 'A');
        const b=addNode(baseX+gapX, baseY, 'B');
        const c=addNode(baseX+2*gapX, baseY, 'C');
        const d=addNode(baseX, baseY+gapY, 'D');
        const e=addNode(baseX+gapX, baseY+gapY, 'E');
        const f=addNode(baseX+2*gapX, baseY+gapY, 'F');
        createEdge(a.id,b.id); createEdge(b.id,c.id);
        createEdge(a.id,d.id); createEdge(b.id,e.id); createEdge(c.id,f.id);
        createEdge(d.id,e.id); createEdge(e.id,f.id);
        setStartNode(a.id);
        setTargetNode(f.id);
      }

      // Setup: seed and small accessibility hints
      seedSample();
      log('Sample graph loaded. Set start/target or modify graph and press Run or Step.');

      // Keyboard accessibility: space toggles pause/run
      document.addEventListener('keydown', e => {
        if(e.code === 'Space'){
          e.preventDefault();
          if(running) stopRun();
          else {
            if(!startNode){
              alert('Please set a start node first.');
            } else {
              runBFS(startNode.id, targetNode ? targetNode.id : null);
            }
          }
        }
      });

      // Make SVG clickable to support adding nodes quickly
      svg.addEventListener('dblclick', (e) => {
        const p = clientToSvg(e.clientX, e.clientY);
        addNode(p.x, p.y);
        log('Node added (double-click).');
      });

      // Final notes: ensure minimum spacing between controls is maintained by CSS gaps (16px)
    })();
  </script>
</body>
</html>