<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Queue Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --card: #0f1728;
      --accent: #4f46e5;
      --accent-2: #06b6d4;
      --muted: #94a3b8;
      --success: #10b981;
      --danger: #ef4444;
      --white: #eef2ff;
      --slot-border: rgba(255,255,255,0.06);
      --max-width: 1100px;
    }
    /* Page safe area */
    html,body{
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg, #071022 0%, #041022 100%);
      color: var(--white);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    .page {
      box-sizing: border-box;
      padding: var(--safe-margin);
      max-width: var(--max-width);
      margin: 0 auto;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    header {
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
      color:var(--accent);
    }
    p.lead {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    main {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: var(--gap);
      align-items: start;
    }

    /* Responsive: stack columns */
    @media (max-width: 880px){
      main {
        grid-template-columns: 1fr;
      }
    }

    /* Left control panel */
    .controls {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 16px;
      min-height: 220px;
      box-shadow: 0 6px 18px rgba(3,7,18,0.6);
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }
    .controls h2{
      margin:0;
      font-size:16px;
      color:var(--white);
    }
    .row {
      display:flex;
      gap: var(--gap);
      align-items: center;
    }
    .col {
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    label {
      font-size:13px;
      color:var(--muted);
    }
    input[type="text"], select {
      background: transparent;
      border: 1px solid var(--slot-border);
      border-radius:8px;
      padding:10px 12px;
      color: var(--white);
      outline: none;
      min-width: 0;
    }
    input[type="text"]:focus, select:focus {
      box-shadow: 0 0 0 3px rgba(79,70,229,0.12);
      border-color: var(--accent);
    }

    /* Buttons */
    .buttons {
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
    }
    button {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid var(--slot-border);
      color: var(--white);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: transform .12s ease, box-shadow .12s ease, background .12s;
      display:inline-flex;
      align-items:center;
      gap:8px;
      min-height:40px;
    }
    button:active { transform: translateY(1px); }
    button.primary {
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      border: none;
      box-shadow: 0 8px 24px rgba(79,70,229,0.12);
    }
    button.warn {
      background: linear-gradient(90deg, #fb923c, #f97316);
      border: none;
    }
    button.ghost {
      background: transparent;
      border: 1px dashed rgba(255,255,255,0.04);
    }
    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      transform: none;
    }

    /* Visualization area */
    .visual {
      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 20px;
      min-height: 300px;
      box-shadow: 0 6px 18px rgba(3,7,18,0.6);
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    .vis-top {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:var(--gap);
    }
    .legend {
      color:var(--muted);
      font-size:13px;
      display:flex;
      gap:12px;
      align-items:center;
    }
    .legend .chip {
      display:inline-flex;
      gap:8px;
      align-items:center;
      background: rgba(255,255,255,0.02);
      padding:6px 8px;
      border-radius:8px;
      font-size:13px;
      color:var(--muted);
    }
    .queue-stage {
      position: relative;
      height: 180px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.02);
      padding: 18px;
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow: hidden;
    }

    /* slots row */
    .slot-row {
      position: relative;
      display:block;
      width:100%;
      height:64px;
      margin-top:6px;
    }

    /* Static slot visuals (just an underlying grid) */
    .slot {
      position:absolute;
      top: 0;
      height:64px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:10px;
      border: 1px dashed var(--slot-border);
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--muted);
      font-weight:600;
      font-size:13px;
      transition: border-color .18s ease;
      box-sizing:border-box;
      user-select:none;
    }

    /* Moving node (the actual queued element) */
    .node {
      position:absolute;
      top: calc(50% - 22px);
      height:44px;
      min-width:72px;
      padding: 8px 12px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      border-radius:8px;
      color: #021124;
      background: linear-gradient(90deg,#fff 0%, #f8fafc 100%);
      font-weight:700;
      box-shadow: 0 8px 22px rgba(2,6,23,0.45);
      transform: translateZ(0);
      transition: left 420ms cubic-bezier(.18,.9,.4,1), opacity 260ms ease, transform 260ms ease;
      z-index: 10;
    }
    .node.small {
      min-width:54px;
      height:36px;
      top: calc(50% - 18px);
      font-size:13px;
    }

    /* Head/Tail badges */
    .label-badge {
      position:absolute;
      top:-22px;
      background: rgba(255,255,255,0.04);
      padding:6px 8px;
      border-radius:8px;
      font-size:12px;
      color:var(--muted);
      border: 1px solid rgba(255,255,255,0.03);
      transform-origin:center;
    }

    /* status area */
    .status {
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .status .pill {
      background: rgba(255,255,255,0.02);
      padding:6px 10px;
      border-radius: 999px;
      font-weight:700;
      color:var(--white);
      border:1px solid rgba(255,255,255,0.03);
    }

    /* animations for error/fill */
    .flash-error {
      animation: flashError 520ms ease;
    }
    @keyframes flashError {
      0% { box-shadow: 0 0 0 0 rgba(239,68,68,0.0); transform: translateY(0); }
      20% { box-shadow: 0 0 0 8px rgba(239,68,68,0.08); transform: translateY(-2px); }
      100% { box-shadow: none; transform: translateY(0); }
    }
    .shake {
      animation: shakeX 420ms cubic-bezier(.36,.07,.19,.97);
    }
    @keyframes shakeX {
      10%, 90% { transform: translateX(-2px); }
      20%, 80% { transform: translateX(4px); }
      30%, 50%, 70% { transform: translateX(-6px); }
      40%, 60% { transform: translateX(6px); }
      100% { transform: translateX(0); }
    }

    /* Footer explanation cards */
    .explain {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:12px;
      padding:16px;
      color:var(--muted);
      font-size:14px;
      line-height:1.5;
      border:1px solid rgba(255,255,255,0.02);
    }
    .explain h3 { margin:6px 0 10px 0; color:var(--accent); font-size:15px; }
    details summary {
      cursor: pointer;
      list-style:none;
      outline:none;
    }

    footer {
      color:var(--muted);
      font-size:13px;
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:center;
    }

    /* small responsive tweaks */
    @media (max-width: 520px){
      .node { min-width:60px; padding:6px 8px; }
      .controls { padding:12px; }
    }
  </style>
</head>
<body>
  <div class="page" role="main">
    <header>
      <h1>Queue — FIFO (First-In, First-Out)</h1>
      <p class="lead">Interactively explore how a queue behaves: enqueue elements at the rear, dequeue from the front, and watch animated state changes.</p>
    </header>

    <main>
      <!-- Controls / Interaction -->
      <section class="controls" aria-labelledby="controls-title">
        <h2 id="controls-title">Controls</h2>

        <div class="col" style="gap:8px;">
          <label for="valueInput">Value to enqueue</label>
          <input id="valueInput" type="text" aria-label="Value to enqueue" placeholder="Type a value and press Enter or Enqueue" />
        </div>

        <div class="row">
          <div class="buttons">
            <button id="enqueueBtn" class="primary" aria-label="Enqueue value">Enqueue</button>
            <button id="dequeueBtn" aria-label="Dequeue value">Dequeue</button>
            <button id="peekBtn" class="ghost" aria-label="Peek at front">Peek</button>
            <button id="clearBtn" class="warn" aria-label="Clear queue">Clear</button>
          </div>
        </div>

        <div class="row" style="align-items:center;">
          <div class="col" style="flex:1; min-width:160px;">
            <label for="capacityRange">Capacity: <span id="capValue">7</span></label>
            <input id="capacityRange" type="range" min="3" max="12" value="7" aria-label="Queue capacity slider" />
          </div>

          <div style="width:110px;">
            <label for="autoToggle">Auto Add</label>
            <select id="autoToggle" aria-label="Auto enqueue mode">
              <option value="off">Off</option>
              <option value="random">Auto Random</option>
              <option value="seq">Auto Sequence</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div class="status" aria-live="polite" id="statusRegion" role="status">
            <div>Size: <span class="pill" id="sizePill">0</span></div>
            <div>Front: <span class="pill" id="frontPill">-</span></div>
            <div>Rear: <span class="pill" id="rearPill">-</span></div>
          </div>
        </div>

        <div style="font-size:13px; color:var(--muted); margin-top:4px;">
          Tip: Press Enter in the input to enqueue. Use capacity to see full-queue behavior.
        </div>
      </section>

      <!-- Visualization -->
      <section class="visual" aria-labelledby="visual-title">
        <div class="vis-top">
          <div>
            <h2 id="visual-title" style="margin:0; font-size:16px; color:var(--white);">Queue Visualization</h2>
            <div style="color:var(--muted); font-size:13px; margin-top:4px;">Slots represent positions; nodes animate as they enter or leave.</div>
          </div>

          <div class="legend" aria-hidden="true">
            <div class="chip"><svg width="10" height="10" viewBox="0 0 10 10" fill="none"><rect width="10" height="10" rx="2" fill="#fff"/></svg> Node</div>
            <div class="chip"><svg width="10" height="10" viewBox="0 0 10 10" fill="none"><rect width="10" height="10" rx="2" fill="#0000" stroke="#ffffff" stroke-opacity="0.06"/></svg> Slot</div>
          </div>
        </div>

        <div class="queue-stage" id="queueStage" role="region" aria-label="Queue visualization area">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="color:var(--muted); font-size:13px;">Front is left; Rear is right</div>
            <div id="message" style="color:var(--muted); font-size:13px;"></div>
          </div>

          <div class="slot-row" id="slotRow" aria-hidden="false">
            <!-- slots are created dynamically -->
          </div>
        </div>

        <div style="display:flex; gap:16px; align-items:center; justify-content:flex-end;">
          <button id="stepEnq" class="ghost" title="Enqueue test items">Enqueue Test</button>
          <button id="stepDeq" class="ghost">Dequeue Test</button>
        </div>
      </section>
    </main>

    <section class="explain" aria-labelledby="explain-title">
      <h3 id="explain-title">Interactive Design Plan</h3>
      <strong>Concept Title:</strong> Queue (FIFO) — Enqueue at rear, Dequeue from front.<br><br>

      <strong>Learning Objective:</strong>
      After interacting with this module, you should be able to:
      - Visually understand how elements enter (enqueue) and leave (dequeue) a queue in FIFO order.
      - Observe capacity limits and FIFO behavior through animation and state indicators.
      - Predict how front and rear positions change as operations occur.<br><br>

      <strong>Interaction Design:</strong>
      - Enqueue: Type a value and press Enter or click "Enqueue". A node will animate from the right into the rear slot. If the queue is full, the UI gives a red flash and shake to signal overflow.
      - Dequeue: Click "Dequeue". The front node animates left and fades out. Remaining nodes smoothly slide left to fill the front, reinforcing FIFO movement.
      - Peek: Click "Peek" to highlight the element at the front without modifying the queue.
      - Capacity: Adjust the slider to change number of slots. The visualization reflows and shows empty slots. This demonstrates how fixed-size queues behave.
      - Auto Add: Use the dropdown to let the module add items automatically (random or sequential) to observe rate of filling and overflow behavior.
      - Visual feedback: Animations (fly-in, slide, fade), head/tail badges, status pills, and live region messages reinforce conceptual state changes.
      - Accessibility: All controls are keyboard-accessible; status is announced via ARIA live regions; contrast and focus styles are provided.<br><br>

      <strong>Layout Description:</strong>
      - Overall safe area: 24px padding on all sides to prevent cramped UI.
      - Two-column layout: left column (controls) fixed width 360px; right column (visualization) flexible to maximize visual space. On narrow screens the layout stacks vertically.
      - Minimum spacing of 16px between interactive elements (gap/gutters).
      - Controls are grouped: input, operation buttons, capacity, and auto-mode. The visualization area contains:
        - Top row: textual hints and legend.
        - Middle: slot-row with dynamically sized slots; nodes are absolutely positioned and animated into slot coordinates.
        - Bottom: quick test buttons and status messages.
      - Responsiveness: slot size and positions recalc on window resize. Elements remain legible on small screens.
    </section>

    <footer>
      <div>Queue module • FIFO behavior • Animations show state mutations</div>
      <div style="color:var(--muted);">Built with vanilla HTML/CSS/JS</div>
    </footer>
  </div>

  <script>
    (function(){
      // DOM elements
      const valueInput = document.getElementById('valueInput');
      const enqueueBtn = document.getElementById('enqueueBtn');
      const dequeueBtn = document.getElementById('dequeueBtn');
      const peekBtn = document.getElementById('peekBtn');
      const clearBtn = document.getElementById('clearBtn');
      const capacityRange = document.getElementById('capacityRange');
      const capValue = document.getElementById('capValue');
      const slotRow = document.getElementById('slotRow');
      const stage = document.getElementById('queueStage');
      const sizePill = document.getElementById('sizePill');
      const frontPill = document.getElementById('frontPill');
      const rearPill = document.getElementById('rearPill');
      const message = document.getElementById('message');
      const statusRegion = document.getElementById('statusRegion');
      const autoToggle = document.getElementById('autoToggle');
      const stepEnq = document.getElementById('stepEnq');
      const stepDeq = document.getElementById('stepDeq');

      let capacity = parseInt(capacityRange.value,10);
      capValue.textContent = capacity;
      let queue = []; // values
      let nodeElements = []; // DOM nodes mapped to values
      let autoInterval = null;
      let nextSeq = 1;

      // Slot layout metrics
      let slotPositions = []; // left offsets for each slot relative to slotRow

      // Accessibility helper
      function announce(msg){
        message.textContent = msg;
      }

      // Render empty slots
      function renderSlots(){
        slotRow.innerHTML = '';
        slotPositions = [];
        const width = slotRow.clientWidth;
        const gap = 12; // visual gap between slots
        const totalGap = gap * (capacity - 1);
        const slotW = Math.max(60, Math.floor((width - totalGap) / capacity));
        for(let i=0;i<capacity;i++){
          const slot = document.createElement('div');
          slot.className = 'slot';
          slot.style.width = slotW + 'px';
          slot.style.left = (i * (slotW + gap)) + 'px';
          slot.dataset.index = i;
          slot.innerHTML = '';
          // add subtle index label
          const idxLabel = document.createElement('div');
          idxLabel.style.fontSize = '12px';
          idxLabel.style.color = 'var(--muted)';
          idxLabel.style.position = 'absolute';
          idxLabel.style.top = '8px';
          idxLabel.style.right = '8px';
          idxLabel.textContent = i;
          slot.appendChild(idxLabel);

          slotRow.appendChild(slot);
          slotPositions.push( (i * (slotW + gap)) );
        }
      }

      // Initialize
      function init(){
        renderSlots();
        updateStatus();
        window.addEventListener('resize', () => {
          // recalc positions and reposition nodes
          renderSlots();
          repositionAllNodes(true);
        });
      }

      // Reposition all node elements to corresponding slot positions
      function repositionAllNodes(noAnimation){
        for(let i=0;i<nodeElements.length;i++){
          const el = nodeElements[i];
          const left = slotPositions[i];
          if(noAnimation){
            // disable transition temporarily
            el.style.transition = 'none';
            el.style.left = left + 'px';
            // force reflow then restore
            void el.offsetWidth;
            el.style.transition = 'left 420ms cubic-bezier(.18,.9,.4,1), opacity 260ms ease, transform 260ms ease';
          } else {
            el.style.left = left + 'px';
          }
        }
        updateHeadTailBadges();
      }

      // Update footer status pills
      function updateStatus(){
        sizePill.textContent = queue.length;
        frontPill.textContent = queue.length ? queue[0] : '-';
        rearPill.textContent = queue.length ? queue[queue.length-1] : '-';
      }

      // Update head/tail badges drawn above the corresponding slots
      function updateHeadTailBadges(){
        // remove existing badges
        const existing = slotRow.querySelectorAll('.label-badge');
        existing.forEach(b => b.remove());

        if(queue.length === 0) return;

        // head badge above slot 0
        const headBadge = document.createElement('div');
        headBadge.className = 'label-badge';
        headBadge.textContent = 'Front';
        const headSlot = slotRow.children[0];
        headSlot.appendChild(headBadge);

        // tail badge above slot queue.length-1
        const tailBadge = document.createElement('div');
        tailBadge.className = 'label-badge';
        tailBadge.textContent = 'Rear';
        const tailSlot = slotRow.children[queue.length-1];
        tailSlot.appendChild(tailBadge);
      }

      // Enqueue logic with animation
      function enqueueValue(val){
        if(queue.length >= capacity){
          // overflow visual
          stage.classList.add('flash-error');
          setTimeout(()=>stage.classList.remove('flash-error'), 520);
          announce('Queue is full — overflow prevented');
          return;
        }
        if(val === '') {
          // empty input flash
          valueInput.classList.add('flash-error');
          setTimeout(()=>valueInput.classList.remove('flash-error'), 520);
          return;
        }
        queue.push(val);
        // create node element
        const node = document.createElement('div');
        node.className = 'node';
        node.textContent = String(val);
        node.setAttribute('role','listitem');
        node.setAttribute('aria-label', 'Queue element ' + String(val));
        node.style.opacity = '0';
        node.style.left = (slotRow.clientWidth + 40) + 'px'; // start off to the right
        slotRow.appendChild(node);
        nodeElements.push(node);

        // force reflow then animate to slot
        requestAnimationFrame(()=> {
          const targetLeft = slotPositions[ queue.length - 1 ];
          node.style.opacity = '1';
          node.style.left = targetLeft + 'px';
        });

        updateStatus();
        announce(`Enqueued ${val}`);
        updateHeadTailBadges();
        // focus input for quick entry
        valueInput.focus();
      }

      // Dequeue logic with animation
      function dequeueValue(){
        if(queue.length === 0){
          stage.classList.add('shake');
          setTimeout(()=>stage.classList.remove('shake'), 420);
          announce('Queue is empty — underflow prevented');
          return null;
        }
        const removedValue = queue.shift();
        const removedNode = nodeElements.shift();
        // animate out to left and fade
        removedNode.style.left = (-removedNode.offsetWidth - 40) + 'px';
        removedNode.style.opacity = '0';
        removedNode.style.transform = 'translateY(-8px)';
        // remove element after transition
        setTimeout(()=> {
          if(removedNode && removedNode.parentNode) removedNode.parentNode.removeChild(removedNode);
        }, 460);

        // shift remaining nodes smoothly by setting their left to new slot positions
        setTimeout(()=> {
          repositionAllNodes(false);
        }, 20);

        updateStatus();
        announce(`Dequeued ${removedValue}`);
        updateHeadTailBadges();
        return removedValue;
      }

      // Peek at front (highlight)
      function peekFront(){
        if(queue.length === 0){
          announce('Queue is empty');
          return;
        }
        const frontNode = nodeElements[0];
        frontNode.style.transform = 'scale(1.06)';
        frontNode.style.boxShadow = '0 14px 36px rgba(6,95,70,0.12)';
        setTimeout(()=> {
          frontNode.style.transform = '';
          frontNode.style.boxShadow = '';
        }, 600);
        announce('Peek: ' + queue[0]);
      }

      // Clear queue
      function clearQueue(){
        queue = [];
        nodeElements.forEach(el => { if(el.parentNode) el.parentNode.removeChild(el); });
        nodeElements = [];
        updateStatus();
        updateHeadTailBadges();
        announce('Queue cleared');
      }

      // Event bindings
      enqueueBtn.addEventListener('click', ()=> {
        enqueueValue(valueInput.value.trim());
        valueInput.value = '';
      });
      valueInput.addEventListener('keydown', (e) => {
        if(e.key === 'Enter') {
          enqueueValue(valueInput.value.trim());
          valueInput.value = '';
        }
      });
      dequeueBtn.addEventListener('click', ()=> {
        dequeueValue();
      });
      peekBtn.addEventListener('click', ()=> {
        peekFront();
      });
      clearBtn.addEventListener('click', ()=> {
        clearQueue();
      });

      capacityRange.addEventListener('input', (e) => {
        capacity = parseInt(e.target.value,10);
        capValue.textContent = capacity;
        // If new capacity is smaller than current size, truncate the queue visually and logically
        if(queue.length > capacity){
          // show a quick warning
          announce('Capacity reduced: dropping items from rear to fit new capacity');
          // remove from rear until fits
          const dropCount = queue.length - capacity;
          for(let i=0;i<dropCount;i++){
            queue.pop();
            const removedNode = nodeElements.pop();
            if(removedNode && removedNode.parentNode) removedNode.parentNode.removeChild(removedNode);
          }
        }
        renderSlots();
        repositionAllNodes(true);
        updateStatus();
      });

      // Auto add mode
      autoToggle.addEventListener('change', (e)=> {
        const mode = e.target.value;
        if(autoInterval) {
          clearInterval(autoInterval);
          autoInterval = null;
        }
        if(mode === 'off') {
          announce('Auto add disabled');
          return;
        }
        if(mode === 'random'){
          autoInterval = setInterval(()=> {
            const val = Math.floor(Math.random()*100);
            enqueueValue(String(val));
            if(queue.length >= capacity && autoInterval){
              // stop auto on full
              clearInterval(autoInterval);
              autoInterval = null;
              autoToggle.value = 'off';
              announce('Auto stopped: queue full');
            }
          }, 900);
          announce('Auto random enqueue started');
        } else if(mode === 'seq'){
          autoInterval = setInterval(()=> {
            enqueueValue(String(nextSeq++));
            if(queue.length >= capacity && autoInterval){
              clearInterval(autoInterval);
              autoInterval = null;
              autoToggle.value = 'off';
              announce('Auto stopped: queue full');
            }
          }, 700);
          announce('Auto sequence enqueue started');
        }
      });

      // Quick test buttons (demo values)
      stepEnq.addEventListener('click', ()=> {
        const testVals = ['A','B','C','D','E'];
        for(let i=0;i<testVals.length;i++){
          setTimeout(()=> enqueueValue(testVals[i]), i*160);
        }
      });
      stepDeq.addEventListener('click', ()=> {
        if(queue.length === 0) {
          announce('Queue empty — nothing to dequeue');
          return;
        }
        // Dequeue three times with delay
        for(let i=0;i<3;i++){
          setTimeout(()=> dequeueValue(), i*420);
        }
      });

      // expose some keyboard shortcuts for convenience
      document.addEventListener('keydown', (e) => {
        if(e.key === 'e' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          enqueueValue(valueInput.value.trim());
          valueInput.value = '';
        }
        if(e.key === 'd' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          dequeueValue();
        }
      });

      // Initial render
      init();

      // Make sure the input is focused ready
      valueInput.focus();
    })();
  </script>
</body>
</html>