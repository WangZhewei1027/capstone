<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Module — Weighted Graph</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa7bb;
      --accent: #34d399; /* green */
      --accent-2: #60a5fa; /* blue */
      --danger: #fb7185;
      --glass: rgba(255,255,255,0.04);
      --node-radius: 20;
      --node-fill: #111827;
      --node-stroke: #475569;
      --edge-stroke: #1f2937;
      --text-on-dark: #e6eef8;
    }

    /* Page safe area and responsive layout */
    html,body{
      margin:0;
      height:100%;
      background: linear-gradient(180deg,#041025 0%, #071227 60%);
      color:var(--text-on-dark);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .app {
      box-sizing:border-box;
      padding:var(--safe-margin);
      min-height:100vh;
      display:flex;
      gap:var(--gap);
      align-items:stretch;
    }

    /* Layout: left info column, center canvas, right controls for wide screens */
    .left {
      width:320px;
      min-width:260px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:20px;
      box-shadow: 0 6px 24px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
      flex-shrink:0;
    }

    .center {
      flex:1;
      min-width:320px;
      min-height:480px;
      background:var(--panel);
      border-radius:12px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
      box-shadow: 0 10px 30px rgba(2,6,23,0.6);
      position:relative;
    }

    .right {
      width:300px;
      min-width:240px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
      flex-shrink:0;
    }

    /* Responsive stacking for small screens */
    @media (max-width:1000px){
      .app { flex-direction:column; padding:var(--safe-margin); }
      .left, .right { width:100%; min-width:0; }
      .center { order:2; min-height:420px; }
    }

    h1{
      margin:0;
      font-size:18px;
      letter-spacing:0.2px;
    }

    p.small {
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    .section-title{
      font-weight:600;
      font-size:13px;
      color:var(--accent-2);
      margin-top:6px;
      display:inline-block;
    }

    /* Canvas area (SVG) */
    .canvas-wrap{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:8px;
      flex:1;
      display:flex;
      position:relative;
      overflow:hidden;
      min-height:320px;
      align-items:stretch;
      justify-content:stretch;
      padding:8px;
    }

    svg {
      width:100%;
      height:100%;
      display:block;
      cursor:crosshair;
      user-select:none;
      touch-action:none;
    }

    /* Controls */
    .controls {
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .button-row{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
    }

    button, select, input[type="number"]{
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.04);
      color:var(--text-on-dark);
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      cursor:pointer;
      min-height:40px;
    }

    button.primary{
      background:linear-gradient(90deg,var(--accent-2), var(--accent));
      color:#042029;
      font-weight:600;
      border:none;
    }

    button.ghost{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
    }

    .muted{
      color:var(--muted);
      font-size:13px;
    }

    .legend{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }

    .legend .item{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
    }

    .node-label{
      fill:var(--text-on-dark);
      font-size:12px;
      pointer-events:none;
      text-anchor:middle;
      dominant-baseline:central;
    }

    /* Edge weight label */
    .weight-label{
      fill:var(--text-on-dark);
      font-size:11px;
      pointer-events:none;
      text-anchor:middle;
      dominant-baseline:central;
      background:rgba(0,0,0,0.2);
    }

    .hidden { display:none; }

    /* Visual states */
    .node {
      stroke:var(--node-stroke);
      stroke-width:2px;
      transition:transform 0.12s ease, stroke 0.12s ease;
    }

    .node.hover { transform:scale(1.06); stroke:var(--accent-2); }

    .node.selected { stroke:var(--accent); transform:scale(1.08); }

    .edge {
      stroke:var(--edge-stroke);
      stroke-width:3px;
      transition:stroke 0.12s ease, stroke-width 0.12s ease;
    }

    .edge.highlight { stroke:var(--accent-2); stroke-width:5px; }

    .edge.path { stroke:var(--accent); stroke-width:6px; }

    .visited {
      stroke: #fbbf24;
      stroke-width:5px;
    }

    /* animation for discovered path weight */
    @keyframes pulse {
      0% { transform:scale(1); opacity:1; }
      50% { transform:scale(1.12); opacity:0.9; }
      100% { transform:scale(1); opacity:1; }
    }

    .pulse {
      animation: pulse 700ms ease-in-out infinite;
    }

    /* small overlay for inputting weight */
    .weight-input {
      position:absolute;
      background:var(--panel);
      border:1px solid rgba(255,255,255,0.05);
      padding:8px;
      border-radius:8px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      z-index:30;
      display:flex;
      gap:8px;
      align-items:center;
      min-width:140px;
    }

    .note {
      font-size:12px;
      color:var(--muted);
    }

    footer {
      margin-top:auto;
      font-size:12px;
      color:var(--muted);
    }

    /* ensure gap/min spacing for interactive elements */
    .left > *, .right > *, .controls > * { margin-bottom:0; }

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Weighted Graph interactive module">
    <!-- Left: Explanations -->
    <aside class="left" aria-hidden="false">
      <h1>Weighted Graph</h1>
      <p class="small">An interactive playground for building undirected weighted graphs, editing edge weights, and visualizing how weights influence shortest paths.</p>

      <div>
        <div class="section-title">Learning Objective</div>
        <p class="small" style="margin-top:8px;">
          After interacting you will understand how weights on edges change which routes are optimal between nodes,
          how weights are represented, and how to explore alternative paths visually.
        </p>
      </div>

      <div>
        <div class="section-title">How to use</div>
        <ol style="margin:8px 0 0 16px; color:var(--muted); font-size:13px; line-height:1.6;">
          <li>Click on the canvas to create nodes.</li>
          <li>Choose "Add Edge", click one node then another to connect; enter a weight.</li>
          <li>Drag nodes to rearrange the layout. Double-click an edge to edit weight.</li>
          <li>Select Start and End nodes, then press "Find Shortest Path" to animate comparison.</li>
        </ol>
      </div>

      <div style="margin-top:8px;">
        <div class="section-title">Interaction Design</div>
        <p class="small" style="margin-top:8px;">
          Modes: Add Node, Add Edge, Move, Select. Visual feedback includes highlight on hover, animation for visited nodes/edges during the shortest-path sweep, and a distinct color for the final shortest path. Edge weights are visible at midpoints and editable.
        </p>
      </div>

      <footer>
        Tip: Try creating two paths between nodes with different total weights to see how the algorithm favors lower-sum weights even when a path has more edges.
      </footer>
    </aside>

    <!-- Center: Canvas -->
    <main class="center" id="main">
      <div style="display:flex; gap:12px; align-items:center; justify-content:space-between;">
        <div style="display:flex; gap:12px; align-items:center;">
          <div class="legend">
            <div class="item"><svg width="14" height="14"><circle cx="7" cy="7" r="6" fill="#111827" stroke="#475569" stroke-width="2"></circle></svg><span class="muted">Node</span></div>
            <div class="item"><svg width="28" height="14"><line x1="2" y1="7" x2="26" y2="7" stroke="#1f2937" stroke-width="4" stroke-linecap="round"></line></svg><span class="muted">Edge</span></div>
            <div class="item"><svg width="28" height="14"><line x1="2" y1="7" x2="26" y2="7" stroke="#34d399" stroke-width="6" stroke-linecap="round"></line></svg><span class="muted">Shortest path</span></div>
          </div>
        </div>
        <div class="muted" id="status">Mode: <strong id="modeLabel">Add Node</strong></div>
      </div>

      <div class="canvas-wrap" id="canvasWrap" role="region" aria-label="Graph canvas">
        <!-- SVG goes here -->
        <svg id="svg" tabindex="0" aria-label="Graph drawing area"></svg>

        <!-- Weight input overlay (hidden by default) -->
        <div id="weightInput" class="weight-input hidden" role="dialog" aria-hidden="true">
          <label for="edgeWeight" class="muted">Weight</label>
          <input id="edgeWeight" type="number" step="0.1" min="0" value="1" style="width:80px;" />
          <button id="weightOk" class="primary">OK</button>
          <button id="weightCancel" class="ghost">Cancel</button>
        </div>

      </div>
    </main>

    <!-- Right: Controls -->
    <aside class="right" aria-hidden="false">
      <div class="controls">
        <div style="display:flex; gap:var(--gap); align-items:center; justify-content:space-between;">
          <div style="font-weight:600;">Controls</div>
          <div class="muted" style="font-size:12px;">Spacing: 16px</div>
        </div>

        <div class="button-row">
          <button id="modeAddNode" class="primary" aria-pressed="true">Add Node</button>
          <button id="modeAddEdge" class="ghost">Add Edge</button>
          <button id="modeMove" class="ghost">Move</button>
          <button id="modeSelect" class="ghost">Select</button>
        </div>

        <div style="display:flex; gap:8px;">
          <button id="btnShortest" class="primary">Find Shortest Path</button>
          <button id="btnReset" class="ghost">Reset</button>
        </div>

        <div style="display:flex; gap:8px;">
          <select id="startSelect" aria-label="Start node">
            <option value="">Start</option>
          </select>
          <select id="endSelect" aria-label="End node">
            <option value="">End</option>
          </select>
        </div>

        <div>
          <div class="section-title">Graph Info</div>
          <p class="muted" style="margin-top:8px;">
            Nodes: <span id="nodeCount">0</span> &nbsp; • &nbsp; Edges: <span id="edgeCount">0</span>
          </p>
          <p class="muted" id="pathInfo" style="margin-top:6px;"></p>
        </div>

        <div>
          <div class="section-title">Accessibility</div>
          <p class="small" style="margin-top:8px;">
            Use keyboard Tab to focus buttons. On the canvas: Enter key will add a node at focus point (if Add Node mode). Nodes are focusable for selection.
          </p>
        </div>
      </div>
    </aside>
  </div>

  <script>
    /*
      Interactive Weighted Graph Module
      - Users can add nodes, add edges with weights, drag nodes, and compute shortest path (Dijkstra).
      - Implementation uses SVG for crisp visuals. No external libraries.
      - Spacing: safe margin 24px on page, minimum spacing 16px between interactive elements maintained in layout CSS.
    */

    // Basic state
    const state = {
      nodes: [], // {id, x, y}
      edges: [], // {id, a, b, weight}
      nextNodeId: 1,
      nextEdgeId: 1,
      mode: 'add-node', // 'add-node' | 'add-edge' | 'move' | 'select'
      edgeCreating: null, // node id of first endpoint when creating
      selectedStart: null,
      selectedEnd: null,
      animating: false
    };

    // DOM elements
    const svg = document.getElementById('svg');
    const modeLabel = document.getElementById('modeLabel');
    const status = document.getElementById('status');
    const btnAddNode = document.getElementById('modeAddNode');
    const btnAddEdge = document.getElementById('modeAddEdge');
    const btnMove = document.getElementById('modeMove');
    const btnSelect = document.getElementById('modeSelect');
    const weightInput = document.getElementById('weightInput');
    const edgeWeightInput = document.getElementById('edgeWeight');
    const weightOk = document.getElementById('weightOk');
    const weightCancel = document.getElementById('weightCancel');
    const canvasWrap = document.getElementById('canvasWrap');
    const btnShortest = document.getElementById('btnShortest');
    const btnReset = document.getElementById('btnReset');
    const startSelect = document.getElementById('startSelect');
    const endSelect = document.getElementById('endSelect');
    const nodeCount = document.getElementById('nodeCount');
    const edgeCount = document.getElementById('edgeCount');
    const pathInfo = document.getElementById('pathInfo');

    // Utility: create SVG element
    function svgEl(tag, attrs = {}) {
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (const [k, v] of Object.entries(attrs)) {
        if (k === 'class') el.setAttribute('class', v);
        else el.setAttribute(k, v);
      }
      return el;
    }

    // Render entire graph
    function render() {
      // Clear svg
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      // Draw edges first
      state.edges.forEach(e => {
        const a = state.nodes.find(n => n.id === e.a);
        const b = state.nodes.find(n => n.id === e.b);
        if (!a || !b) return;
        const group = svgEl('g', { 'data-edge-id': e.id });
        const line = svgEl('line', {
          class: 'edge',
          x1: a.x, y1: a.y, x2: b.x, y2: b.y,
          stroke: '#1f2937', 'stroke-linecap': 'round'
        });
        group.appendChild(line);

        // weight label background (a small rect via foreignObject not necessary; instead a circle + text)
        const mx = (a.x + b.x) / 2;
        const my = (a.y + b.y) / 2;
        const weightBg = svgEl('rect', {
          x: mx - 18, y: my - 14, width: 36, height: 24, rx: 6, ry: 6,
          fill: 'rgba(0,0,0,0.35)', 'pointer-events': 'none'
        });
        group.appendChild(weightBg);

        const text = svgEl('text', { class: 'weight-label', x: mx, y: my });
        text.textContent = e.weight.toString();
        group.appendChild(text);

        // Interaction: clicking on edge to edit weight
        line.addEventListener('dblclick', (ev) => {
          ev.stopPropagation();
          openWeightEditor(e, mx, my);
        });

        svg.appendChild(group);
      });

      // Draw nodes on top
      state.nodes.forEach(n => {
        const g = svgEl('g', { class: 'node-group', 'data-node-id': n.id, tabindex:0 });
        const circle = svgEl('circle', {
          class: 'node',
          cx: n.x, cy: n.y, r: 20, fill: 'var(--node-fill)'
        });
        const label = svgEl('text', { class: 'node-label', x: n.x, y: n.y });
        label.textContent = n.id.toString();

        // highlight start/end
        if (state.selectedStart === n.id) {
          circle.setAttribute('stroke', 'var(--accent)');
          circle.setAttribute('stroke-width', '3');
        } else if (state.selectedEnd === n.id) {
          circle.setAttribute('stroke', 'var(--accent-2)');
          circle.setAttribute('stroke-width', '3');
        } else {
          circle.setAttribute('stroke', 'var(--node-stroke)');
          circle.setAttribute('stroke-width', '2');
        }

        g.appendChild(circle);
        g.appendChild(label);

        // events
        g.addEventListener('mouseenter', () => circle.classList.add('hover'));
        g.addEventListener('mouseleave', () => circle.classList.remove('hover'));
        g.addEventListener('mousedown', nodeMouseDown);
        g.addEventListener('click', nodeClick);
        g.addEventListener('dblclick', nodeDoubleClick); // for quick selection
        g.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter' && state.mode === 'add-node') {
            // Add a new node near this one if in add-node mode
            const nx = n.x + 40;
            const ny = n.y + 0;
            addNode(nx, ny);
          }
        });

        svg.appendChild(g);
      });

      updateCounts();
      refreshNodeSelects();
    }

    // Add node at x,y (page coordinates relative to svg)
    function addNode(x, y) {
      const rect = svg.getBoundingClientRect();
      // constrain inside svg area with padding
      const px = Math.min(Math.max(30, x), rect.width - 30);
      const py = Math.min(Math.max(30, y), rect.height - 30);
      const node = { id: state.nextNodeId++, x: px, y: py };
      state.nodes.push(node);
      render();
    }

    // Add edge between node ids a and b with weight
    function addEdge(a, b, weight = 1) {
      if (a === b) return;
      // prevent duplicate undirected edges
      const exists = state.edges.find(e => (e.a === a && e.b === b) || (e.a === b && e.b === a));
      if (exists) {
        // update weight instead
        exists.weight = weight;
      } else {
        state.edges.push({ id: state.nextEdgeId++, a, b, weight: Number(weight) });
      }
      render();
    }

    // Remove all
    function resetGraph() {
      state.nodes = [];
      state.edges = [];
      state.nextNodeId = 1;
      state.nextEdgeId = 1;
      state.edgeCreating = null;
      state.selectedStart = null;
      state.selectedEnd = null;
      state.animating = false;
      render();
    }

    // Update counts
    function updateCounts() {
      nodeCount.textContent = state.nodes.length;
      edgeCount.textContent = state.edges.length;
    }

    // Node events
    let dragInfo = null; // {id, offsetX, offsetY}
    function nodeMouseDown(ev) {
      if (state.mode !== 'move') return;
      ev.stopPropagation();
      const g = ev.currentTarget;
      const id = Number(g.getAttribute('data-node-id'));
      const rect = svg.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const node = state.nodes.find(n => n.id === id);
      dragInfo = { id, offsetX: x - node.x, offsetY: y - node.y };
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
    }

    function onMouseMove(ev) {
      if (!dragInfo) return;
      const rect = svg.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const node = state.nodes.find(n => n.id === dragInfo.id);
      if (!node) return;
      node.x = Math.min(Math.max(30, x - dragInfo.offsetX), rect.width - 30);
      node.y = Math.min(Math.max(30, y - dragInfo.offsetY), rect.height - 30);
      render();
    }

    function onMouseUp() {
      dragInfo = null;
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
    }

    // Click on node depending on mode
    function nodeClick(ev) {
      ev.stopPropagation();
      const g = ev.currentTarget;
      const id = Number(g.getAttribute('data-node-id'));

      if (state.mode === 'add-edge') {
        if (state.edgeCreating == null) {
          state.edgeCreating = id;
          flashNode(id);
          status.textContent = 'Select second node for edge';
        } else {
          if (state.edgeCreating === id) {
            // cancel
            state.edgeCreating = null;
            status.textContent = 'Edge creation cancelled';
          } else {
            // create edge, prompt weight input at midpoint
            const a = state.nodes.find(n => n.id === state.edgeCreating);
            const b = state.nodes.find(n => n.id === id);
            openWeightEditorForNewEdge(a, b);
          }
        }
      } else if (state.mode === 'select') {
        // toggle start/end selection
        if (!state.selectedStart) {
          state.selectedStart = id;
        } else if (!state.selectedEnd && id !== state.selectedStart) {
          state.selectedEnd = id;
        } else {
          // reset selection
          state.selectedStart = id;
          state.selectedEnd = null;
        }
        render();
      } else if (state.mode === 'add-node') {
        // clicking a node in add-node mode does nothing.
      }
    }

    // Double-click node: quick set start/end when in select mode
    function nodeDoubleClick(ev) {
      ev.stopPropagation();
      if (state.mode === 'select') {
        const id = Number(ev.currentTarget.getAttribute('data-node-id'));
        if (!state.selectedStart) state.selectedStart = id;
        else if (!state.selectedEnd && id !== state.selectedStart) state.selectedEnd = id;
        else {
          state.selectedStart = id;
          state.selectedEnd = null;
        }
        render();
      }
    }

    // Flash node for feedback
    function flashNode(id) {
      const circle = svg.querySelector(`g[data-node-id="${id}"] circle`);
      if (!circle) return;
      circle.classList.add('pulse');
      setTimeout(() => circle.classList.remove('pulse'), 900);
    }

    // Canvas click: add node in add-node mode
    svg.addEventListener('click', (ev) => {
      // compute coordinates relative to svg
      const rect = svg.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      if (state.mode === 'add-node') {
        addNode(x, y);
      } else {
        // if in other modes and user clicks empty space, cancel edge creation
        if (state.edgeCreating != null) {
          state.edgeCreating = null;
          status.textContent = '';
        }
      }
    });

    // Mode buttons
    function setMode(m) {
      state.mode = m;
      modeLabel.textContent = m === 'add-node' ? 'Add Node' :
                              m === 'add-edge' ? 'Add Edge' :
                              m === 'move' ? 'Move' : 'Select';
      // update button styles / aria-pressed
      [btnAddNode, btnAddEdge, btnMove, btnSelect].forEach(b => b.classList.remove('primary'));
      btnAddNode.classList.remove('primary'); btnAddEdge.classList.remove('primary'); btnMove.classList.remove('primary'); btnSelect.classList.remove('primary');
      btnAddNode.classList.add('ghost'); btnAddEdge.classList.add('ghost'); btnMove.classList.add('ghost'); btnSelect.classList.add('ghost');

      if (m === 'add-node') { btnAddNode.classList.add('primary'); btnAddNode.classList.remove('ghost'); }
      if (m === 'add-edge') { btnAddEdge.classList.add('primary'); btnAddEdge.classList.remove('ghost'); }
      if (m === 'move') { btnMove.classList.add('primary'); btnMove.classList.remove('ghost'); }
      if (m === 'select') { btnSelect.classList.add('primary'); btnSelect.classList.remove('ghost'); }

      // clear any in-progress edge creation
      state.edgeCreating = null;
      status.textContent = '';
    }

    btnAddNode.addEventListener('click', () => setMode('add-node'));
    btnAddEdge.addEventListener('click', () => setMode('add-edge'));
    btnMove.addEventListener('click', () => setMode('move'));
    btnSelect.addEventListener('click', () => setMode('select'));

    // Open weight editor for existing edge at coordinates (mx,my)
    function openWeightEditor(edge, mx, my) {
      const wrapRect = canvasWrap.getBoundingClientRect();
      // position overlay
      weightInput.style.left = (wrapRect.left + mx - 70) + 'px';
      weightInput.style.top = (wrapRect.top + my - 34) + 'px';
      weightInput.classList.remove('hidden');
      weightInput.setAttribute('aria-hidden', 'false');
      edgeWeightInput.value = edge.weight;
      edgeWeightInput.focus();

      const onOk = () => {
        edge.weight = Number(edgeWeightInput.value) || 0;
        closeEditor();
        render();
      };
      const onCancel = () => {
        closeEditor();
      };

      weightOk.onclick = onOk;
      weightCancel.onclick = onCancel;
      // clicking outside should close
      const outside = (ev) => {
        if (!weightInput.contains(ev.target)) {
          closeEditor();
        }
      };
      setTimeout(() => window.addEventListener('mousedown', outside));
      function closeEditor() {
        weightInput.classList.add('hidden');
        weightInput.setAttribute('aria-hidden', 'true');
        weightOk.onclick = null;
        weightCancel.onclick = null;
        window.removeEventListener('mousedown', outside);
      }
    }

    // For creating a new edge, open editor; after OK addEdge
    function openWeightEditorForNewEdge(aNode, bNode) {
      const mx = (aNode.x + bNode.x) / 2;
      const my = (aNode.y + bNode.y) / 2;
      const wrapRect = canvasWrap.getBoundingClientRect();
      weightInput.style.left = (wrapRect.left + mx - 70) + 'px';
      weightInput.style.top = (wrapRect.top + my - 34) + 'px';
      weightInput.classList.remove('hidden');
      weightInput.setAttribute('aria-hidden', 'false');
      edgeWeightInput.value = 1;
      edgeWeightInput.focus();

      const onOk = () => {
        const w = Number(edgeWeightInput.value) || 0;
        addEdge(aNode.id, bNode.id, w);
        state.edgeCreating = null;
        closeEditor();
      };
      const onCancel = () => {
        state.edgeCreating = null;
        closeEditor();
      };

      weightOk.onclick = onOk;
      weightCancel.onclick = onCancel;
      const outside = (ev) => {
        if (!weightInput.contains(ev.target)) {
          state.edgeCreating = null;
          closeEditor();
        }
      };
      setTimeout(() => window.addEventListener('mousedown', outside));
      function closeEditor() {
        weightInput.classList.add('hidden');
        weightInput.setAttribute('aria-hidden', 'true');
        weightOk.onclick = null;
        weightCancel.onclick = null;
        window.removeEventListener('mousedown', outside);
        render();
      }
    }

    // Refresh start/end selects
    function refreshNodeSelects() {
      const prevStart = startSelect.value;
      const prevEnd = endSelect.value;
      // remove existing options except first
      startSelect.innerHTML = '<option value="">Start</option>';
      endSelect.innerHTML = '<option value="">End</option>';
      state.nodes.forEach(n => {
        const o1 = document.createElement('option');
        o1.value = n.id;
        o1.textContent = 'Node ' + n.id;
        const o2 = o1.cloneNode(true);
        startSelect.appendChild(o1);
        endSelect.appendChild(o2);
      });
      startSelect.value = state.selectedStart || '';
      endSelect.value = state.selectedEnd || '';
    }

    startSelect.addEventListener('change', () => {
      const v = startSelect.value ? Number(startSelect.value) : null;
      state.selectedStart = v;
      render();
    });
    endSelect.addEventListener('change', () => {
      const v = endSelect.value ? Number(endSelect.value) : null;
      state.selectedEnd = v;
      render();
    });

    // Shortest path (Dijkstra) with visual animation
    btnShortest.addEventListener('click', async () => {
      if (state.animating) return;
      const s = state.selectedStart;
      const t = state.selectedEnd;
      if (!s || !t) {
        alert('Select both a Start and End node (use Select mode or the dropdowns).');
        return;
      }
      // Build adjacency
      const adj = new Map();
      state.nodes.forEach(n => adj.set(n.id, []));
      state.edges.forEach(e => {
        adj.get(e.a).push({ to: e.b, w: e.weight, edgeId: e.id });
        adj.get(e.b).push({ to: e.a, w: e.weight, edgeId: e.id });
      });

      // Dijkstra
      const dist = new Map();
      const prev = new Map();
      const prevEdge = new Map();
      state.nodes.forEach(n => dist.set(n.id, Infinity));
      dist.set(s, 0);
      const visited = new Set();
      const pq = new MinHeap((a,b) => a.dist - b.dist);
      pq.push({ id: s, dist: 0 });

      // Animation: visited order
      const visitOrder = [];
      while (!pq.empty()) {
        const cur = pq.pop();
        if (visited.has(cur.id)) continue;
        visited.add(cur.id);
        visitOrder.push(cur.id);
        if (cur.id === t) break;
        for (const nei of adj.get(cur.id)) {
          if (visited.has(nei.to)) continue;
          const nd = dist.get(cur.id) + nei.w;
          if (nd < dist.get(nei.to)) {
            dist.set(nei.to, nd);
            prev.set(nei.to, cur.id);
            prevEdge.set(nei.to, nei.edgeId);
            pq.push({ id: nei.to, dist: nd });
          }
        }
      }

      if (!prev.has(t) && s !== t) {
        alert('No path found between selected nodes.');
        return;
      }

      // Build final path
      const pathNodes = [];
      const pathEdges = [];
      let cur = t;
      while (cur !== undefined) {
        pathNodes.push(cur);
        const e = prevEdge.get(cur);
        if (e) pathEdges.push(e);
        cur = prev.get(cur);
      }
      pathNodes.reverse(); pathEdges.reverse();

      // Animate: highlight visited nodes/edges then highlight path
      state.animating = true;
      // First, clear any previous highlights by re-rendering
      render();
      // Highlight visited sequence
      for (let i = 0; i < visitOrder.length; i++) {
        const nid = visitOrder[i];
        const g = svg.querySelector(`g[data-node-id="${nid}"]`);
        if (g) {
          const c = g.querySelector('circle');
          c.classList.add('visited');
          setTimeout(() => c.classList.remove('visited'), 400);
        }
        // small pause
        await sleep(150);
      }

      // Then highlight final path edges and nodes
      // Reset render
      render();
      // edges first
      for (const eid of pathEdges) {
        const edgeGroup = svg.querySelector(`g[data-edge-id="${eid}"]`);
        if (edgeGroup) {
          const line = edgeGroup.querySelector('line');
          line.classList.add('path');
        }
        await sleep(120);
      }
      // nodes
      for (const nid of pathNodes) {
        const g = svg.querySelector(`g[data-node-id="${nid}"]`);
        if (g) {
          const c = g.querySelector('circle');
          c.classList.add('selected');
          setTimeout(() => c.classList.remove('selected'), 900);
        }
        await sleep(80);
      }

      // Show total weight
      const total = dist.get(t);
      pathInfo.textContent = `Shortest path weight: ${Number.isFinite(total) ? total : '∞'}; Nodes: ${pathNodes.length}`;
      state.animating = false;
    });

    // Reset button
    btnReset.addEventListener('click', () => {
      if (!confirm('Clear the entire graph?')) return;
      resetGraph();
      pathInfo.textContent = '';
    });

    // Helpers
    function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

    // Minimal binary heap for Dijkstra
    class MinHeap {
      constructor(compare) {
        this.data = [];
        this.compare = compare || ((a,b)=>a-b);
      }
      size(){ return this.data.length; }
      empty(){ return this.data.length === 0; }
      push(item){
        this.data.push(item);
        this._siftUp(this.data.length-1);
      }
      pop(){
        if(this.data.length===0) return null;
        const top = this.data[0];
        const last = this.data.pop();
        if(this.data.length>0) {
          this.data[0]=last;
          this._siftDown(0);
        }
        return top;
      }
      _siftUp(i){
        while(i>0){
          const p = Math.floor((i-1)/2);
          if(this.compare(this.data[i], this.data[p]) < 0){
            [this.data[i], this.data[p]] = [this.data[p], this.data[i]];
            i = p;
          } else break;
        }
      }
      _siftDown(i){
        const n = this.data.length;
        while(true){
          let l = 2*i + 1;
          let r = 2*i + 2;
          let m = i;
          if(l<n && this.compare(this.data[l], this.data[m]) < 0) m=l;
          if(r<n && this.compare(this.data[r], this.data[m]) < 0) m=r;
          if(m!==i){ [this.data[i], this.data[m]] = [this.data[m], this.data[i]]; i=m; }
          else break;
        }
      }
    }

    // Delete edge or node? Not implemented as separate control to keep focus on one concept.

    // Initialize with a small sample graph to illustrate weights vs path choices
    function initSampleGraph() {
      addNode(120, 120); //1
      addNode(320, 120); //2
      addNode(120, 320); //3
      addNode(320, 320); //4
      // paths between 1 and 4: direct vs via 2&3
      addEdge(1,4,10); // direct heavy edge
      addEdge(1,2,2);
      addEdge(2,4,2);
      addEdge(1,3,2);
      addEdge(3,4,2);
      // Another alternative with mixed weights
      addNode(520, 220); //5
      addEdge(2,5,5);
      addEdge(5,4,1);
      render();
      // preselect start and end for convenience
      state.selectedStart = 1;
      state.selectedEnd = 4;
      refreshNodeSelects();
    }

    // Simple editing: double clicking an edge opens weight editor implemented in render

    // Start
    setMode('add-node');
    initSampleGraph();
    render();

    // Keyboard support: Enter to add node at center if Add Node mode
    document.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter' && state.mode === 'add-node') {
        const rect = svg.getBoundingClientRect();
        addNode(rect.width / 2, rect.height / 2);
      }
    });

    // Make sure weight input overlay stays positioned on resize/scroll
    window.addEventListener('resize', () => {
      weightInput.classList.add('hidden');
    });

    // Allow pressing Escape to cancel weight input
    window.addEventListener('keydown', (ev) => {
      if (ev.key === 'Escape') {
        weightInput.classList.add('hidden');
        state.edgeCreating = null;
      }
    });
  </script>
</body>
</html>