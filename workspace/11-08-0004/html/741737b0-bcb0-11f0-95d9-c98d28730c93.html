<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive: Red-Black Tree — Insertion Fixup (Recoloring & Rotations)</title>
  <style>
    :root{
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #f7f8fb;
      --panel: #ffffff;
      --muted: #6b7280;
      --accent: #0ea5a2;
      --round: 10px;
      --node-size: 40px;
    }

    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#f7fbff 0%, #f7f8fb 100%);
      color:#111827;
    }

    /* Safe area margins: 24px on all sides */
    body{
      padding: var(--safe-padding);
      box-sizing: border-box;
    }

    main{
      max-width:1200px;
      margin: 0 auto;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    header{
      background: var(--panel);
      border-radius: var(--round);
      padding: 20px;
      box-shadow: 0 6px 18px rgba(15,23,42,0.06);
    }

    h1{
      margin:0 0 8px 0;
      font-size:1.25rem;
    }
    .muted{
      color:var(--muted);
      font-size: 0.95rem;
    }

    /* Layout: top textual plan, below interactive module */
    .layout{
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    /* Interactive module container */
    .module{
      display:flex;
      flex-direction:row;
      gap: var(--gap);
      align-items:flex-start;
    }

    /* Left panel: controls & textual plan */
    .left{
      min-width:320px;
      width: 360px;
      background: var(--panel);
      padding:16px;
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(15,23,42,0.04);
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    .section-title{
      font-weight:600;
      font-size:0.95rem;
      margin-bottom:4px;
    }

    .small{
      font-size:0.9rem;
      color:var(--muted);
    }

    .controls{
      display:flex;
      gap: var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }

    input[type="number"]{
      padding:10px 12px;
      border-radius:8px;
      border:1px solid #e6e9ef;
      font-size:1rem;
      width: 120px;
      box-sizing:border-box;
    }

    button{
      padding:10px 12px;
      border-radius:8px;
      border: none;
      background: linear-gradient(180deg,#0ea5a2,#089f97);
      color:white;
      cursor:pointer;
      font-weight: 600;
      font-size:0.95rem;
      min-height:44px;
    }

    button.secondary{
      background:transparent;
      border:1px solid #e6e9ef;
      color:#111827;
      font-weight:600;
    }

    .controls .wide{
      flex:1;
    }

    .status{
      padding:12px;
      border-radius:8px;
      background:#fbfdff;
      border:1px dashed #e6eef0;
      color: #0f1724;
      font-size:0.95rem;
    }

    .explain{
      background:#ffffff;
      padding:12px;
      border-radius:8px;
      border:1px solid #eef2f7;
      color: #0f1724;
      min-height:64px;
      font-size:0.95rem;
    }

    /* Right: visualization area */
    .right{
      flex:1;
      min-height:420px;
      background: var(--panel);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 6px 18px rgba(15,23,42,0.04);
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      align-items:stretch;
    }

    .canvas-wrap{
      background: linear-gradient(180deg,#ffffff,#fbfeff);
      border-radius:8px;
      padding:12px;
      border:1px solid #eef2f7;
      flex:1;
      position:relative;
      overflow:auto;
    }

    /* SVG sizing responsive */
    svg{
      width:100%;
      height: 100%;
      min-height:260px;
      display:block;
      touch-action: none;
      user-select:none;
    }

    /* Node styles */
    .node-group{
      transition: transform 600ms cubic-bezier(.2,.9,.3,1);
      transform-origin:center;
    }

    circle.node {
      r:20;
      stroke:#0f1724;
      stroke-width:1;
      transition: fill 300ms ease, stroke 300ms ease;
    }

    text.node-text{
      font-size:14px;
      font-weight:700;
      fill:white;
      pointer-events:none;
    }

    /* Highlighted items */
    .highlight circle{
      stroke-width:3;
      stroke: #2563eb;
    }

    /* Edges */
    .edge{
      stroke:#cfe9ea;
      stroke-width:2;
      fill:none;
      transition: stroke 300ms ease;
    }

    /* Color legend */
    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      font-size:0.9rem;
      color:var(--muted);
    }

    .legend .item{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .dot{
      width:16px;height:16px;border-radius:50%;
      border:1px solid rgba(0,0,0,0.06);
    }

    .red-dot{ background:#ef4444;}
    .black-dot{ background:#111827;}

    /* Footer controls */
    .play-controls{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      margin-top:8px;
    }

    .play-controls .left {
      display:flex;
      gap:8px;
      align-items:center;
    }

    /* Responsive adjustments */
    @media (max-width:980px){
      .module{flex-direction:column;}
      .left{width:100%;}
    }

    /* Accessibility focus */
    button:focus, input:focus { outline: 3px solid rgba(14,165,162,0.15); outline-offset:2px; }

  </style>
</head>
<body>
  <main>
    <header>
      <h1>Red-Black Tree — Insertion Fixup (Recoloring & Rotations)</h1>
      <div class="muted">Interactive module: see how inserting one key triggers recoloring and rotations to preserve Red-Black properties.</div>
    </header>

    <section class="layout" aria-label="Learning module layout">
      <!-- Design Plan / Documentation -->
      <div class="left" style="background:transparent;padding:0;">
        <div style="background:var(--panel);padding:16px;border-radius:12px;box-shadow:0 6px 18px rgba(15,23,42,0.04);">
          <div class="section-title">Concept Title</div>
          <div class="small">Red-Black Tree — Insertion fixup: handling red parent cases through recoloring and rotations</div>

          <hr style="margin:12px 0;border:none;border-top:1px solid #eef2f7;">

          <div class="section-title">Learning Objective</div>
          <div class="small">
            After interacting with this module you will:
            <ul style="margin:8px 0 0 16px;padding:0;font-size:0.92rem;color:var(--muted);">
              <li>Understand how a new red node is inserted into the BST structure.</li>
              <li>See how the fixup procedure uses recoloring and rotations to restore Red-Black invariants.</li>
              <li>Observe the three core cases (uncle red; uncle black with inner/outer child) and their animated effects.</li>
            </ul>
          </div>

          <hr style="margin:12px 0;border:none;border-top:1px solid #eef2f7;">

          <div class="section-title">Interaction Design</div>
          <div class="small">
            - Type an integer and click Insert. The module inserts the node as in a BST (colored red) and records the fixup steps.<br>
            - Use "Step" to advance one algorithm action at a time (highlight nodes, recolor, rotate). Each step shows an animation and a textual explanation of what's happening.<br>
            - Press "Auto" to play the recorded steps at once with animations. "Reset" clears the tree.<br>
            - Visual feedback: nodes change color (red/black), edges re-arrange on rotations with smooth transitions, and the explanation panel updates to describe the active case.
          </div>

          <hr style="margin:12px 0;border:none;border-top:1px solid #eef2f7;">

          <div class="section-title">Layout Description</div>
          <div class="small">
            - Safe area margins: 24px on all sides of the viewport (applied to body padding).<br>
            - Minimum spacing: 16px between interactive elements (CSS gap used).<br>
            - Left column (controls & textual plan): fixed width ~360px to keep controls readable and reachable.<br>
            - Right column: flexible visualization area containing an SVG canvas with nodes and edges. The action explanation is below controls for focus. The layout collapses to vertical for small screens. Controls use large tap targets and accessible labels.
          </div>
        </div>
      </div>

      <!-- Interactive Module -->
      <div class="module" role="region" aria-label="Red-Black Tree interactive module">
        <div class="left" aria-label="Controls panel">
          <div>
            <div class="section-title">Insert a value</div>
            <div class="controls" style="margin-top:8px;">
              <label for="value" class="visually-hidden" style="position:absolute;left:-9999px;">Value</label>
              <input id="value" type="number" aria-label="Value to insert" placeholder="Enter integer" />
              <button id="insertBtn" title="Insert value (plays and records steps)">Insert</button>
              <button id="stepBtn" class="secondary" title="Step through the next recorded action">Step</button>
              <button id="autoBtn" class="secondary" title="Auto-play remaining actions">Auto</button>
            </div>
          </div>

          <div>
            <div class="section-title">Playback</div>
            <div class="play-controls" style="margin-top:8px;">
              <div style="display:flex;gap:8px;align-items:center;">
                <button id="prevBtn" class="secondary" title="Go to previous step">◀ Prev</button>
                <button id="nextBtn" class="secondary" title="Go to next step">Next ▶</button>
                <button id="resetBtn" class="secondary" title="Reset the entire tree and clear steps">Reset</button>
              </div>
              <div class="legend" aria-hidden="true" style="font-size:0.9rem;">
                <div class="item"><div class="dot red-dot"></div> Red node</div>
                <div class="item"><div class="dot black-dot"></div> Black node</div>
              </div>
            </div>
          </div>

          <div>
            <div class="section-title" style="margin-top:4px;">Current step</div>
            <div id="explain" class="explain" aria-live="polite">No actions yet. Insert a value to begin.</div>
          </div>

          <div>
            <div class="section-title" style="margin-top:4px;">Status</div>
            <div id="status" class="status">Tree is empty.</div>
          </div>
        </div>

        <div class="right" aria-label="Visualization panel">
          <div class="canvas-wrap" id="canvasWrap" tabindex="0">
            <svg id="svgRoot" role="img" aria-label="Red Black Tree visualization"></svg>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    /**********************************************************************
     * Red-Black Tree Interactive Visualization
     * - Single concept: insertion fixup (recolor & rotations)
     * - No external libraries. All code below is vanilla JS.
     **********************************************************************/

    /* Utilities */
    function el(name, attrs) {
      const e = document.createElement(name);
      if (attrs) Object.assign(e, attrs);
      return e;
    }

    /* Node class for RB tree */
    let nextId = 1;
    function createNode(value, color='R') {
      return { id: nextId++, value: value, color: color, left: null, right: null, parent: null };
    }

    /* Tree and step recording */
    class RBTree {
      constructor() {
        this.root = null;
        this.steps = []; // {msg, highlight: {nodeIds}, snapshot: deep copy}
      }

      clear() {
        this.root = null;
        this.steps = [];
      }

      // BST insert: returns inserted node
      bstInsert(val) {
        let z = createNode(val,'R'); // new nodes are red
        let y = null;
        let x = this.root;
        while (x !== null) {
          y = x;
          if (val < x.value) x = x.left;
          else x = x.right;
        }
        z.parent = y;
        if (y === null) this.root = z;
        else if (val < y.value) y.left = z;
        else y.right = z;
        return z;
      }

      // Utility to clone the tree structure for snapshotting (shallow node clones but maintain ids)
      cloneTree() {
        const map = new Map();
        function cloneNode(n) {
          if (!n) return null;
          const c = { id: n.id, value: n.value, color: n.color, left: null, right: null, parent: null };
          map.set(n, c);
          c.left = cloneNode(n.left);
          c.right = cloneNode(n.right);
          return c;
        }
        const rootClone = cloneNode(this.root);
        // fix parent pointers
        map.forEach((cloned, orig) => {
          if (orig.parent) cloned.parent = map.get(orig.parent) || null;
        });
        return rootClone;
      }

      // Record a snapshot with message and highlights
      record(msg, highlights=[]) {
        const snap = this.cloneTree();
        this.steps.push({ msg: msg, highlights: new Set(highlights), snapshot: snap });
      }

      // Standard left rotate at x
      rotateLeft(x) {
        const y = x.right;
        if (!y) return;
        x.right = y.left;
        if (y.left) y.left.parent = x;
        y.parent = x.parent;
        if (!x.parent) this.root = y;
        else if (x === x.parent.left) x.parent.left = y;
        else x.parent.right = y;
        y.left = x;
        x.parent = y;
      }

      rotateRight(x) {
        const y = x.left;
        if (!y) return;
        x.left = y.right;
        if (y.right) y.right.parent = x;
        y.parent = x.parent;
        if (!x.parent) this.root = y;
        else if (x === x.parent.right) x.parent.right = y;
        else x.parent.left = y;
        y.right = x;
        x.parent = y;
      }

      // Insert and record steps for visualization
      insertWithSteps(val) {
        // check duplicates
        if (this.search(this.root, val)) {
          this.record(`Value ${val} already exists. Duplicate inserts are ignored.`, []);
          return;
        }

        const z = this.bstInsert(val);
        this.record(`Inserted ${val} as a red node (standard BST insert).`, [z.id]);

        // Fixup loop
        let node = z;
        while (node !== this.root && node.parent && node.parent.color === 'R') {
          const parent = node.parent;
          const grand = parent.parent;
          if (!grand) break;
          let uncle = (grand.left === parent) ? grand.right : grand.left;

          // Case: Parent is red and uncle is red -> recolor parent & uncle to black, grand to red
          if (uncle && uncle.color === 'R') {
            parent.color = 'B';
            uncle.color = 'B';
            grand.color = 'R';
            this.record(`Parent (${parent.value}) and uncle (${uncle.value}) are red: recolor parent & uncle -> black, grand -> red.`, [parent.id, uncle.id, grand.id]);
            node = grand;
            continue;
          }

          // Uncle is black (or null)
          if (parent === grand.right) {
            // parent is right child
            if (node === parent.left) {
              // Case 2: node is left child -> rotate right at parent (to convert to outer)
              this.record(`Case: parent is right child and node is left child. Rotate right at parent (${parent.value}).`, [node.id, parent.id, grand.id]);
              this.rotateRight(parent);
              this.record(`After rotation: structure changed.`, [node.id, parent.id, grand.id]);
              node = parent; // advance node to parent
            }
            // Case 3: node is right child (outer). rotate left at grand, recolor parent/grand
            parent.color = 'B';
            grand.color = 'R';
            this.record(`Rotate left at grandparent (${grand.value}) and recolor parent (${parent.value}) black, grand -> red.`, [parent.id, grand.id]);
            this.rotateLeft(grand);
            this.record(`After rotation: structure changed.`, [parent.id, grand.id]);
            break;
          } else {
            // parent is left child
            if (node === parent.right) {
              // Case 2 mirror: rotate left at parent
              this.record(`Case: parent is left child and node is right child. Rotate left at parent (${parent.value}).`, [node.id, parent.id, grand.id]);
              this.rotateLeft(parent);
              this.record(`After rotation: structure changed.`, [node.id, parent.id, grand.id]);
              node = parent;
            }
            // Case 3 mirror: rotate right at grand, recolor
            parent.color = 'B';
            grand.color = 'R';
            this.record(`Rotate right at grandparent (${grand.value}) and recolor parent (${parent.value}) black, grand -> red.`, [parent.id, grand.id]);
            this.rotateRight(grand);
            this.record(`After rotation: structure changed.`, [parent.id, grand.id]);
            break;
          }
        }

        // Ensure root is black
        if (this.root && this.root.color !== 'B') {
          this.root.color = 'B';
          this.record(`Ensure root (${this.root.value}) is black.`, [this.root.id]);
        } else {
          this.record(`Insertion fixup complete. Tree satisfies Red-Black properties.`, []);
        }
      }

      // search helper
      search(node, val) {
        if (!node) return null;
        if (val === node.value) return node;
        return val < node.value ? this.search(node.left, val) : this.search(node.right, val);
      }
    }

    /* Visualization: SVG rendering with transitions */
    const svg = document.getElementById('svgRoot');
    const explainEl = document.getElementById('explain');
    const statusEl = document.getElementById('status');

    const tree = new RBTree();

    // Rendering state
    let currentStepIndex = -1; // -1 means no steps displayed (empty)
    function renderStep(index) {
      if (index < 0 || index >= tree.steps.length) {
        // clear svg if no snapshot
        if (tree.root === null) {
          svg.innerHTML = '';
          explainEl.textContent = 'No actions yet. Insert a value to begin.';
          statusEl.textContent = 'Tree is empty.';
          currentStepIndex = -1;
        } else {
          // if index beyond range, show latest
          index = Math.max(0, tree.steps.length - 1);
        }
      }
      if (tree.steps.length === 0) return;
      const step = tree.steps[index];
      currentStepIndex = index;
      explainEl.textContent = step.msg;
      // Render snapshot tree: step.snapshot
      drawTree(step.snapshot, step.highlights);
      // Update status with tree size and root info
      const size = countNodes(step.snapshot);
      if (step.snapshot) {
        statusEl.textContent = `Nodes: ${size}. Root: ${step.snapshot.value} (${step.snapshot.color === 'R' ? 'Red' : 'Black'})`;
      } else {
        statusEl.textContent = `Nodes: ${size}.`;
      }
    }

    function countNodes(node) {
      if (!node) return 0;
      return 1 + countNodes(node.left) + countNodes(node.right);
    }

    // Compute layout: assign x positions by inorder sequence
    function layoutTree(rootClone) {
      const nodes = [];
      let x = 0;
      function dfs(n, depth) {
        if (!n) return;
        dfs(n.left, depth+1);
        nodes.push({node: n, depth: depth, order: x++});
        dfs(n.right, depth+1);
      }
      dfs(rootClone, 0);
      // Assign positions relative to svg size
      const paddingX = 40;
      const paddingY = 24;
      const width = svg.clientWidth || 800;
      const height = Math.max(svg.clientHeight, 320);
      const maxOrder = Math.max(1, x);
      const hSpacing = Math.max(60, (width - paddingX*2) / maxOrder);
      const vSpacing = 90;
      const pos = new Map();
      nodes.forEach(item => {
        const cx = paddingX + item.order * hSpacing + 30; // +30 for nicer left margin
        const cy = paddingY + item.depth * vSpacing + 30;
        pos.set(item.node, {x: cx, y: cy});
      });
      return pos;
    }

    // Helper to create unique DOM ids from node id
    function domId(nodeId) { return 'n-' + nodeId; }

    // Draw or update the svg to match snapshot
    function drawTree(rootClone, highlights=new Set()) {
      // Clear and rebuild (it's simpler to animate transforms on groups)
      // We'll create groups for edges then nodes
      svg.innerHTML = '';

      if (!rootClone) return;

      const positions = layoutTree(rootClone);

      // Create edges
      function createEdge(parent, child) {
        if (!child) return null;
        const p = positions.get(parent);
        const c = positions.get(child);
        if (!p || !c) return null;
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', `M ${p.x} ${p.y} L ${c.x} ${c.y}`);
        path.setAttribute('class','edge');
        svg.appendChild(path);
      }

      // Walk and create edges
      (function walk(n) {
        if (!n) return;
        if (n.left) createEdge(n, n.left);
        if (n.right) createEdge(n, n.right);
        walk(n.left); walk(n.right);
      })(rootClone);

      // Create node groups (so we can animate transform)
      (function walkNodes(n) {
        if (!n) return;
        const pos = positions.get(n);
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('class','node-group');
        g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);
        g.setAttribute('id', domId(n.id));
        if (highlights.has(n.id)) g.classList.add('highlight');

        // Circle
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('class','node');
        c.setAttribute('r', 20);
        c.setAttribute('cx', 0);
        c.setAttribute('cy', 0);
        c.setAttribute('fill', n.color === 'R' ? '#ef4444' : '#111827');
        c.setAttribute('aria-label', `Node ${n.value} ${n.color === 'R' ? 'red' : 'black'}`);

        // Text
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('class','node-text');
        t.setAttribute('x', 0);
        t.setAttribute('y', 5);
        t.setAttribute('text-anchor','middle');
        t.textContent = n.value;

        // Append
        g.appendChild(c);
        g.appendChild(t);
        svg.appendChild(g);

        walkNodes(n.left);
        walkNodes(n.right);
      })(rootClone);
    }

    // Playback controls
    const insertBtn = document.getElementById('insertBtn');
    const stepBtn = document.getElementById('stepBtn');
    const autoBtn = document.getElementById('autoBtn');
    const resetBtn = document.getElementById('resetBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const valueInput = document.getElementById('value');

    let autoTimer = null;

    function enableControls(enabled=true) {
      [insertBtn, stepBtn, autoBtn, resetBtn, prevBtn, nextBtn].forEach(b => b.disabled = !enabled);
    }

    insertBtn.addEventListener('click', () => {
      const v = valueInput.value.trim();
      if (v === '') {
        explainEl.textContent = 'Please enter an integer value to insert.';
        return;
      }
      const val = Number(v);
      if (!Number.isFinite(val)) {
        explainEl.textContent = 'Invalid number.';
        return;
      }
      // Run insertion and record steps
      tree.insertWithSteps(val);
      // After insertion, move to first new step beyond previous last displayed.
      currentStepIndex = tree.steps.length - 1; // will render latest
      renderStep(currentStepIndex);
      // clear input for convenience
      valueInput.value = '';
    });

    stepBtn.addEventListener('click', () => {
      if (tree.steps.length === 0) return;
      if (currentStepIndex < tree.steps.length - 1) {
        currentStepIndex++;
        renderStep(currentStepIndex);
      } else {
        // already at last — just stay
      }
    });

    nextBtn.addEventListener('click', () => {
      // go to next step if available, otherwise nothing
      if (tree.steps.length === 0) return;
      if (currentStepIndex < tree.steps.length - 1) {
        currentStepIndex++;
        renderStep(currentStepIndex);
      }
    });

    prevBtn.addEventListener('click', () => {
      if (tree.steps.length === 0) return;
      if (currentStepIndex > 0) {
        currentStepIndex--;
        renderStep(currentStepIndex);
      } else {
        // if at 0, show empty? We keep step 0 as earliest snapshot
      }
    });

    resetBtn.addEventListener('click', () => {
      // stop auto
      if (autoTimer) { clearInterval(autoTimer); autoTimer = null; autoBtn.textContent = 'Auto'; }
      tree.clear();
      currentStepIndex = -1;
      renderStep(-1);
    });

    autoBtn.addEventListener('click', () => {
      if (autoTimer) {
        clearInterval(autoTimer);
        autoTimer = null;
        autoBtn.textContent = 'Auto';
        enableControls(true);
        return;
      }
      if (tree.steps.length === 0) return;
      autoBtn.textContent = 'Stop';
      enableControls(false);
      // Play remaining steps from current (or 0)
      let idx = Math.max(0, currentStepIndex + 1);
      renderStep(idx);
      idx++;
      autoTimer = setInterval(() => {
        if (idx >= tree.steps.length) {
          clearInterval(autoTimer);
          autoTimer = null;
          autoBtn.textContent = 'Auto';
          enableControls(true);
          return;
        }
        renderStep(idx);
        idx++;
      }, 700);
    });

    // Initialize empty svg
    renderStep(-1);

    // Keyboard support: Enter to insert, Arrow keys for step
    valueInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') insertBtn.click();
    });
    document.addEventListener('keydown', (e) => {
      if (e.target === valueInput) return; // when typing ignore
      if (e.key === 'ArrowRight') nextBtn.click();
      if (e.key === 'ArrowLeft') prevBtn.click();
      if (e.key === ' ') { // space toggles auto
        e.preventDefault();
        autoBtn.click();
      }
    });

    // Make svg responsive on window resize (re-render current step)
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      if (resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        renderStep(currentStepIndex);
      }, 150);
    });

    // Initial explanatory hint
    explainEl.textContent = 'Insert a value to see the insertion and fixup steps. Use Step or Auto to advance through recoloring and rotations.';
  </script>
</body>
</html>