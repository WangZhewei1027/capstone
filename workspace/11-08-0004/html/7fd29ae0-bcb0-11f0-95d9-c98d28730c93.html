<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Union-Find (Disjoint Set) — Interactive Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --gap: 16px;              /* minimum spacing */
      --safe: 24px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #7dd3fc;
      --muted: #9aa7b2;
      --ok: #34d399;
      --danger: #fb7185;
      --glass: rgba(255,255,255,0.03);
      --shadow: 0 6px 18px rgba(2,6,23,0.6);
      --radius: 10px;
    }
    html,body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg,#071022 0%, #041829 100%);
      color: #e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      box-sizing: border-box;
    }
    .app {
      padding: var(--safe);
      box-sizing: border-box;
      min-height: calc(100vh - calc(var(--safe) * 2));
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: 24px;
    }

    /* Left panel (instructions + controls) */
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow);
      min-width: 300px;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      border: 1px solid rgba(255,255,255,0.03);
    }

    h1 {
      margin: 0 0 6px 0;
      font-size: 20px;
      letter-spacing: -0.2px;
    }
    .muted {
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 8px;
    }

    .section-title {
      font-weight: 600;
      font-size: 13px;
      margin-top: 6px;
      color: #cfe9f8;
    }

    /* controls */
    .controls {
      display: grid;
      gap: 12px;
    }

    label {
      font-size: 13px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    input[type="range"] {
      width: 100%;
    }
    .row {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .btn {
      background: linear-gradient(180deg,#0ea5e9 0%, #0284c7 100%);
      color: white;
      border: none;
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      min-width: 90px;
      box-shadow: 0 6px 14px rgba(2,6,23,0.5);
    }
    .btn.secondary {
      background: linear-gradient(180deg,#1f2937 0%, #111827 100%);
      border: 1px solid rgba(255,255,255,0.04);
      box-shadow: none;
    }
    .btn.warn {
      background: linear-gradient(180deg,#fb7185 0%, #ef4444 100%);
    }
    .small {
      font-size: 13px;
      padding: 8px 10px;
      border-radius: 8px;
    }

    select, input[type="checkbox"] {
      font-size: 13px;
    }

    .status {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .pill {
      background: var(--glass);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 13px;
      color: var(--muted);
      border: 1px solid rgba(255,255,255,0.02);
    }

    .legend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    .legend .item {
      display: flex;
      gap: 8px;
      align-items: center;
      color: var(--muted);
      font-size: 13px;
    }
    .dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    /* Right: Visualization area */
    .canvas-panel {
      background: linear-gradient(180deg,#071426 0%, #041022 100%);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,0.03);
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 480px;
      position: relative;
    }
    .canvas-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    .canvas-top .info {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .canvas-area {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008));
      flex: 1;
      border-radius: 10px;
      position: relative;
      overflow: hidden;
    }

    /* SVG takes full area */
    svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Node styles */
    .node {
      fill: #07283a;
      stroke: #2dd4bf;
      stroke-width: 2px;
      transition: transform 160ms ease, fill 200ms ease, stroke 200ms ease;
      cursor: pointer;
    }
    .node-label {
      fill: #dff6ff;
      font-size: 13px;
      font-weight: 700;
      pointer-events: none;
    }
    .node-sub {
      fill: #9fcad7;
      font-size: 10px;
      pointer-events: none;
    }

    /* Highlighted states */
    .highlight {
      stroke: #7dd3fc !important;
      stroke-width: 3.5px;
      filter: drop-shadow(0 6px 12px rgba(45,212,191,0.06));
    }
    .visited {
      fill: #153b47 !important;
      stroke: #a78bfa !important;
    }
    .root-node {
      fill: linear-gradient(180deg,#0ea5e9,#0284c7);
    }

    /* Arrow lines */
    .link {
      stroke: rgba(255,255,255,0.12);
      stroke-width: 2px;
      fill: none;
      transition: stroke 180ms ease;
      marker-end: url(#arrow);
    }
    .link.highlighted {
      stroke: #7dd3fc;
      stroke-width: 3px;
    }

    /* Tooltip / legend in canvas */
    .overlay {
      position: absolute;
      right: 18px;
      top: 18px;
      background: rgba(0,0,0,0.28);
      border-radius: 10px;
      padding: 10px;
      font-size: 13px;
      color: var(--muted);
      border: 1px solid rgba(255,255,255,0.03);
    }

    /* Responsive adjustments */
    @media (max-width: 980px) {
      .app {
        grid-template-columns: 1fr;
      }
      .panel { order: 2; }
      .canvas-panel { order: 1; min-height: 520px; }
    }

    /* Accessible focus styles */
    button:focus, input:focus, select:focus {
      outline: 3px solid rgba(125,211,252,0.18);
      outline-offset: 2px;
    }

    /* Small helper text area */
    .explain {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.45;
    }

    /* Footer hint */
    .hint {
      font-size: 12px;
      color: var(--muted);
      text-align: center;
      padding-top: 6px;
    }
  </style>
</head>
<body>
  <div class="app" role="main">
    <div class="panel" aria-labelledby="concept-title">
      <div>
        <h1 id="concept-title">Union-Find (Disjoint Set) — Interactive Forest</h1>
        <div class="muted">Visualize union and find (with path compression and union by rank/size).</div>
      </div>

      <div class="section-title">Learning Objective</div>
      <div class="explain" id="learning-objective">
        After interacting you should be able to:
        <ul style="margin:8px 0 0 18px; padding:0; color:var(--muted);">
          <li>Understand parent-pointer representation of disjoint sets.</li>
          <li>Perform union operations and see how tree height can change.</li>
          <li>See how path compression flattens trees during find operations.</li>
          <li>Compare union by size vs union by rank vs naive union.</li>
        </ul>
      </div>

      <div class="section-title">Interaction Design</div>
      <div class="explain">
        Click or drag nodes to select them. Use the controls below to:
        <ul style="margin:8px 0 0 18px; padding:0; color:var(--muted);">
          <li>Create a set of nodes (1..N) and reset layout.</li>
          <li>Select two nodes then press Union to merge their sets (choose strategy).</li>
          <li>Click Find on a single node to trace its path to the root; enable Path Compression to compress the path.</li>
          <li>Drag nodes to rearrange the visualization. Animated highlights show traversal and pointer updates.</li>
        </ul>
      </div>

      <div class="section-title">Controls</div>
      <div class="controls" role="region" aria-label="Union-Find controls">
        <div>
          <label for="node-count">Nodes: <span id="node-count-label">8</span></label>
          <input id="node-count" type="range" min="2" max="20" value="8" />
        </div>

        <div class="row">
          <button id="reset-btn" class="btn small">Reset</button>
          <button id="random-btn" class="btn secondary small">Random Unions</button>
          <button id="auto-btn" class="btn small" title="Run a demo sequence">Demo</button>
        </div>

        <div>
          <label for="strategy">Union Strategy</label>
          <select id="strategy" aria-label="Choose union strategy">
            <option value="size">Union by Size</option>
            <option value="rank">Union by Rank</option>
            <option value="naive">Naive (attach second to first)</option>
          </select>
        </div>

        <div class="row" style="align-items:center;">
          <input id="compress" type="checkbox" checked />
          <label for="compress" style="margin:0;">Enable Path Compression on Find</label>
        </div>

        <div class="row">
          <button id="select-clear" class="btn secondary small">Clear Selection</button>
          <button id="union-btn" class="btn small" style="min-width:120px;">Union Selected</button>
          <button id="find-btn" class="btn secondary small">Find</button>
        </div>

        <div class="section-title">Status</div>
        <div class="status">
          <div class="pill" id="components-pill">Components: 0</div>
          <div class="pill" id="last-action">Last: —</div>
        </div>

        <div class="section-title">Legend</div>
        <div class="legend" aria-hidden="true">
          <div class="item"><div class="dot" style="background:#2dd4bf"></div> Node</div>
          <div class="item"><div class="dot" style="background:#7dd3fc;border-radius:4px;width:26px;"></div> Traversal</div>
          <div class="item"><div class="dot" style="background:#a78bfa"></div> Visited</div>
          <div class="item"><div class="dot" style="background:#fb7185"></div> Selected</div>
        </div>

        <div class="section-title">Interaction Tips</div>
        <div class="explain">
          - Click a node to select it (up to 2 selections).<br>
          - Drag nodes to reposition. The layout preserves parent arrows.<br>
          - Use "Random Unions" to quickly see large components.
        </div>
      </div>

      <div class="hint">Accessible, responsive, and self-contained (vanilla JS).</div>
    </div>

    <div class="canvas-panel" aria-label="Union-Find visualization">
      <div class="canvas-top">
        <div class="info">
          <div style="font-weight:700;font-size:15px;">Forest View</div>
          <div style="color:var(--muted); font-size:13px;">Click nodes → Union / Find</div>
        </div>
        <div style="display:flex;gap:12px;align-items:center;">
          <div class="pill" id="selected-pill">Selected: —</div>
          <div class="pill" id="height-pill">Max Height: 0</div>
        </div>
      </div>

      <div class="canvas-area" id="canvas-area" role="region" aria-label="Graph area" tabindex="0">
        <svg id="svg" viewBox="0 0 1000 600" preserveAspectRatio="xMidYMid meet" aria-hidden="false">
          <defs>
            <marker id="arrow" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L8,4 L0,8 L2,4 z" fill="#a7f3d0"></path>
            </marker>
          </defs>
          <!-- Dynamic content inserted here -->
        </svg>

        <div class="overlay" aria-hidden="true" id="overlay">
          <div><strong id="overlay-title">Instructions</strong></div>
          <div style="margin-top:6px; color:var(--muted); font-size:13px;">
            Drag nodes, select two to union, or click one to find its root.<br>
            Animated traversal shows path compression when enabled.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /*
      Union-Find Interactive Module
      - Self-contained vanilla JS
      - Supports: union by size/rank/naive, path compression (optional), animated find
      - SVG visualization, draggable nodes, selection/union controls
    */

    (function () {
      // --- Configuration & state ---
      const svg = document.getElementById('svg');
      const canvasArea = document.getElementById('canvas-area');
      const nodeCountInput = document.getElementById('node-count');
      const nodeCountLabel = document.getElementById('node-count-label');
      const resetBtn = document.getElementById('reset-btn');
      const randomBtn = document.getElementById('random-btn');
      const autoBtn = document.getElementById('auto-btn');
      const unionBtn = document.getElementById('union-btn');
      const findBtn = document.getElementById('find-btn');
      const selectClearBtn = document.getElementById('select-clear');
      const strategySelect = document.getElementById('strategy');
      const compressCheckbox = document.getElementById('compress');

      const componentsPill = document.getElementById('components-pill');
      const lastAction = document.getElementById('last-action');
      const selectedPill = document.getElementById('selected-pill');
      const heightPill = document.getElementById('height-pill');

      let N = parseInt(nodeCountInput.value, 10);

      // Arrays representing the disjoint set data
      let parent = [];
      let size = [];
      let rank = [];

      // Node visual positions and elements
      let nodes = []; // {id, x, y, elGroup, circleEl, labelEl}
      let links = []; // svg line elements (index by node id for link to parent)
      let selected = []; // selected node ids (max 2)
      let runningAnimation = false;
      let dragging = { active: false, id: null, offsetX: 0, offsetY: 0 };

      // Initialize
      function init() {
        attachEventListeners();
        createNodes(N);
      }

      // --- Utility: create nodes with positions in a circle ---
      function createNodes(count) {
        N = count;
        nodeCountLabel.textContent = N;
        // reset data
        parent = new Array(N);
        size = new Array(N);
        rank = new Array(N);
        nodes = new Array(N);
        links = new Array(N);
        selected = [];

        for (let i = 0; i < N; i++) {
          parent[i] = i;
          size[i] = 1;
          rank[i] = 0;
        }
        // Clear SVG children except defs
        while (svg.lastChild && svg.lastChild.tagName !== 'defs') {
          svg.removeChild(svg.lastChild);
        }

        // Layout nodes around a circle in the visible viewBox (1000x600)
        const cx = 500, cy = 300;
        const radius = Math.min(420, 260 + Math.min(N * 6, 160));
        for (let i = 0; i < N; i++) {
          const angle = (i / N) * Math.PI * 2 - Math.PI / 2;
          const x = cx + Math.cos(angle) * radius * (0.85 + Math.random() * 0.2);
          const y = cy + Math.sin(angle) * radius * (0.85 + Math.random() * 0.15);
          nodes[i] = createNodeVisual(i, x, y);
        }
        // draw initial links (self-parent -> no link)
        updateAllLinks();
        updateStatus();
      }

      function createNodeVisual(id, x, y) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('class', 'node-group');
        g.setAttribute('data-id', id);
        g.style.cursor = 'pointer';

        // Circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('r', 22);
        circle.setAttribute('class', 'node');
        circle.setAttribute('stroke-linejoin', 'round');
        circle.setAttribute('aria-label', 'node-' + id);
        g.appendChild(circle);

        // Label (main id)
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', x);
        label.setAttribute('y', y + 5);
        label.setAttribute('text-anchor', 'middle');
        label.setAttribute('class', 'node-label');
        label.textContent = id;
        g.appendChild(label);

        // Sub label (parent id)
        const sub = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        sub.setAttribute('x', x);
        sub.setAttribute('y', y + 28);
        sub.setAttribute('text-anchor', 'middle');
        sub.setAttribute('class', 'node-sub');
        sub.textContent = 'p:' + parent[id];
        g.appendChild(sub);

        // Make group draggable/clickable
        g.addEventListener('mousedown', onNodeMouseDown);
        g.addEventListener('touchstart', onNodeTouchStart, {passive: false});
        g.addEventListener('click', onNodeClick);

        svg.appendChild(g);

        return {
          id, x, y, elGroup: g, circleEl: circle, labelEl: label, subEl: sub
        };
      }

      // --- Link drawing: draw line from node to its parent (if not self) ---
      function updateAllLinks() {
        // Remove existing link elements
        // Keep only nodes in DOM (we appended nodes groups last), so clear any <path> or <line> that were before them.
        // Simpler: remove all non-defs and re-add nodes & links in order.
        // But we keep nodes in place; instead manage links array of <path> elements, remove/create as needed.
        // First remove all existing link elements
        Array.from(svg.querySelectorAll('.link')).forEach(el => el.remove());
        links = new Array(N);

        for (let i = 0; i < N; i++) {
          drawLink(i);
        }
      }

      function drawLink(i) {
        const p = parent[i];
        if (p === i) {
          links[i] = null;
          updateNodeSub(i);
          return;
        }
        const from = nodes[i];
        const to = nodes[p];
        if (!from || !to) return;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('class', 'link');
        const d = cubicPath(from.x, from.y, to.x, to.y);
        path.setAttribute('d', d);
        path.setAttribute('data-from', i);
        path.setAttribute('data-to', p);

        // Insert path before nodes so links are under nodes
        const defs = svg.querySelector('defs');
        svg.insertBefore(path, defs.nextSibling);

        links[i] = path;
        updateNodeSub(i);
      }

      function updateNodeSub(i) {
        const n = nodes[i];
        if (!n) return;
        n.subEl.textContent = 'p:' + parent[i];
        // mark root visually
        if (parent[i] === i) {
          n.circleEl.style.stroke = '#86efac';
        } else {
          n.circleEl.style.stroke = '#2dd4bf';
        }
      }

      // generate a curved path between two points
      function cubicPath(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const cx1 = x1 + dx * 0.25;
        const cy1 = y1 + dy * 0.02;
        const cx2 = x1 + dx * 0.75;
        const cy2 = y1 + dy * 0.98;
        return `M ${x1} ${y1} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${x2} ${y2}`;
      }

      // --- Event handlers: selection, dragging, controls ---
      function onNodeClick(e) {
        if (runningAnimation) return;
        // prevent click that follows drag
        if (dragging.active) {
          return;
        }
        const g = e.currentTarget;
        const id = +g.getAttribute('data-id');
        toggleSelect(id);
      }

      function toggleSelect(id) {
        // allow up to 2 selections
        const idx = selected.indexOf(id);
        if (idx >= 0) {
          selected.splice(idx, 1);
        } else {
          if (selected.length < 2) {
            selected.push(id);
          } else {
            // replace the first selected
            selected.shift();
            selected.push(id);
          }
        }
        updateSelectionVisuals();
      }

      function updateSelectionVisuals() {
        // update node circle border color for selected nodes
        nodes.forEach(n => {
          if (!n) return;
          n.circleEl.classList.remove('highlight');
          n.circleEl.classList.remove('visited');
          n.circleEl.style.stroke = (parent[n.id] === n.id) ? '#86efac' : '#2dd4bf';
        });
        selected.forEach(id => {
          const n = nodes[id];
          if (n) {
            n.circleEl.style.stroke = '#fb7185';
            n.circleEl.style.strokeWidth = '3px';
          }
        });
        selectedPill.textContent = 'Selected: ' + (selected.length ? selected.join(',') : '—');
      }

      function onNodeMouseDown(e) {
        if (runningAnimation) return;
        const g = e.currentTarget;
        const id = +g.getAttribute('data-id');
        // start drag
        dragging.active = true;
        dragging.id = id;

        const pt = svg.createSVGPoint();
        pt.x = e.clientX; pt.y = e.clientY;
        const ctm = svg.getScreenCTM().inverse();
        const loc = pt.matrixTransform(ctm);

        dragging.offsetX = nodes[id].x - loc.x;
        dragging.offsetY = nodes[id].y - loc.y;

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
      }

      function onNodeTouchStart(e) {
        if (runningAnimation) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const g = e.currentTarget;
        const id = +g.getAttribute('data-id');
        dragging.active = true;
        dragging.id = id;
        const pt = svg.createSVGPoint();
        pt.x = touch.clientX; pt.y = touch.clientY;
        const ctm = svg.getScreenCTM().inverse();
        const loc = pt.matrixTransform(ctm);
        dragging.offsetX = nodes[id].x - loc.x;
        dragging.offsetY = nodes[id].y - loc.y;
        window.addEventListener('touchmove', onTouchMove, {passive: false});
        window.addEventListener('touchend', onTouchEnd);
      }

      function onMouseMove(e) {
        if (!dragging.active) return;
        const pt = svg.createSVGPoint();
        pt.x = e.clientX; pt.y = e.clientY;
        const ctm = svg.getScreenCTM().inverse();
        const loc = pt.matrixTransform(ctm);
        moveNodeTo(dragging.id, loc.x + dragging.offsetX, loc.y + dragging.offsetY);
      }

      function onTouchMove(e) {
        if (!dragging.active) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const pt = svg.createSVGPoint();
        pt.x = touch.clientX; pt.y = touch.clientY;
        const ctm = svg.getScreenCTM().inverse();
        const loc = pt.matrixTransform(ctm);
        moveNodeTo(dragging.id, loc.x + dragging.offsetX, loc.y + dragging.offsetY);
      }

      function onMouseUp(e) {
        if (!dragging.active) return;
        dragging.active = false;
        dragging.id = null;
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
      }

      function onTouchEnd(e) {
        if (!dragging.active) return;
        dragging.active = false;
        dragging.id = null;
        window.removeEventListener('touchmove', onTouchMove);
        window.removeEventListener('touchend', onTouchEnd);
      }

      function moveNodeTo(id, x, y) {
        const n = nodes[id];
        if (!n) return;
        n.x = x;
        n.y = y;
        n.circleEl.setAttribute('cx', x);
        n.circleEl.setAttribute('cy', y);
        n.labelEl.setAttribute('x', x);
        n.labelEl.setAttribute('y', y + 5);
        n.subEl.setAttribute('x', x);
        n.subEl.setAttribute('y', y + 28);
        // update links that involve this node (both as from or to)
        for (let i = 0; i < N; i++) {
          const ln = links[i];
          if (!ln) continue;
          const from = +ln.getAttribute('data-from');
          const to = +ln.getAttribute('data-to');
          if (from === id || to === id) {
            const f = nodes[from];
            const t = nodes[to];
            if (f && t) {
              ln.setAttribute('d', cubicPath(f.x, f.y, t.x, t.y));
            }
          }
        }
      }

      // --- Control handlers ---
      function attachEventListeners() {
        nodeCountInput.addEventListener('input', (e) => {
          nodeCountLabel.textContent = e.target.value;
        });
        nodeCountInput.addEventListener('change', (e) => {
          const v = +e.target.value;
          createNodes(v);
        });

        resetBtn.addEventListener('click', () => {
          createNodes(+nodeCountInput.value);
        });

        selectClearBtn.addEventListener('click', () => {
          selected = [];
          updateSelectionVisuals();
        });

        unionBtn.addEventListener('click', async () => {
          if (runningAnimation) return;
          if (selected.length !== 2) {
            flashLastAction('Select two nodes to union', true);
            return;
          }
          await doUnion(selected[0], selected[1]);
          selected = [];
          updateSelectionVisuals();
        });

        findBtn.addEventListener('click', async () => {
          if (runningAnimation) return;
          if (selected.length !== 1) {
            flashLastAction('Select one node to find', true);
            return;
          }
          await doFind(selected[0], compressCheckbox.checked);
          selected = [];
          updateSelectionVisuals();
        });

        randomBtn.addEventListener('click', () => {
          randomUnions(Math.max(1, Math.floor(N / 2)));
        });

        autoBtn.addEventListener('click', async () => {
          if (runningAnimation) return;
          await demoSequence();
        });
      }

      // --- Disjoint Set operations (data + animation triggers) ---
      function findRootNoAnim(a) {
        while (parent[a] !== a) a = parent[a];
        return a;
      }

      async function doFind(start, doCompress) {
        runningAnimation = true;
        flashLastAction(`Find(${start})`, false);
        // animate traversal
        const path = [];
        let cur = start;
        while (true) {
          path.push(cur);
          highlightNode(cur, 'visited');
          await sleep(320);
          if (parent[cur] === cur) break;
          cur = parent[cur];
        }
        // mark root
        highlightNode(cur, 'highlight');
        await sleep(360);

        if (doCompress) {
          // compress path: update parents of intermediate nodes to root
          const root = cur;
          for (const v of path) {
            if (parent[v] !== root) {
              parent[v] = root;
              size[v] = 1; // not meaningful, but keep values
              // animate pointer change: create/refresh link
              drawLink(v);
              await sleep(140);
            }
          }
          // refresh visuals
          updateAllLinks();
          await sleep(120);
        }

        // cleanup highlights
        nodes.forEach(n => {
          if (n) {
            n.circleEl.classList.remove('visited');
            n.circleEl.classList.remove('highlight');
            n.circleEl.style.strokeWidth = '2px';
            updateNodeSub(n.id);
          }
        });
        updateStatus();
        runningAnimation = false;
      }

      async function doUnion(a, b) {
        runningAnimation = true;
        flashLastAction(`Union(${a}, ${b})`, false);
        // find roots with visualization but without compression
        const rootA = await traceFind(a);
        const rootB = await traceFind(b);

        if (rootA === rootB) {
          flashLastAction(`Already connected (root ${rootA})`, true);
          runningAnimation = false;
          return;
        }

        // Choose strategy
        const strat = strategySelect.value;
        let newParent, child;
        if (strat === 'size') {
          if (size[rootA] >= size[rootB]) {
            newParent = rootA; child = rootB;
          } else {
            newParent = rootB; child = rootA;
          }
        } else if (strat === 'rank') {
          if (rank[rootA] > rank[rootB]) {
            newParent = rootA; child = rootB;
          } else if (rank[rootB] > rank[rootA]) {
            newParent = rootB; child = rootA;
          } else {
            newParent = rootA; child = rootB;
            rank[rootA] += 1;
          }
        } else { // naive: attach second's root to first's root
          newParent = rootA; child = rootB;
        }

        // animate change: highlight roots
        highlightNode(newParent, 'highlight');
        highlightNode(child, 'visited');
        await sleep(360);

        // set parent of child root to newParent
        parent[child] = newParent;
        size[newParent] += size[child];
        // redraw link for child
        drawLink(child);

        await sleep(360);

        // refresh visuals
        updateAllLinks();
        updateStatus();

        // cleanup highlights
        nodes.forEach(n => {
          if (n) {
            n.circleEl.classList.remove('visited');
            n.circleEl.classList.remove('highlight');
            n.circleEl.style.strokeWidth = '2px';
            updateNodeSub(n.id);
          }
        });

        runningAnimation = false;
      }

      async function traceFind(start) {
        // animate simple traversal and return root (no compression)
        let cur = start;
        highlightNode(cur, 'visited');
        await sleep(260);
        while (parent[cur] !== cur) {
          const next = parent[cur];
          highlightLink(cur, next);
          await sleep(240);
          cur = next;
          highlightNode(cur, 'visited');
          await sleep(180);
        }
        // final highlight
        highlightNode(cur, 'highlight');
        await sleep(220);
        return cur;
      }

      // --- Visual helpers ---
      function highlightNode(id, cls) {
        const n = nodes[id];
        if (!n) return;
        if (cls === 'visited') {
          n.circleEl.classList.add('visited');
        } else if (cls === 'highlight') {
          n.circleEl.classList.add('highlight');
        }
      }

      function highlightLink(from, to) {
        const ln = links[from];
        if (!ln) return;
        ln.classList.add('highlighted');
        setTimeout(() => ln.classList.remove('highlighted'), 700);
      }

      // --- Utilities: random unifications, demo ---
      function randomUnions(k) {
        // perform k random unions quickly without animation
        for (let i = 0; i < k; i++) {
          const a = Math.floor(Math.random() * N);
          const b = Math.floor(Math.random() * N);
          if (a === b) continue;
          const ra = findRootNoAnim(a);
          const rb = findRootNoAnim(b);
          if (ra === rb) continue;
          const strat = strategySelect.value;
          let newParent, child;
          if (strat === 'size') {
            if (size[ra] >= size[rb]) { newParent = ra; child = rb; }
            else { newParent = rb; child = ra; }
          } else if (strat === 'rank') {
            if (rank[ra] > rank[rb]) { newParent = ra; child = rb; }
            else if (rank[rb] > rank[ra]) { newParent = rb; child = ra; }
            else { newParent = ra; child = rb; rank[ra] += 1; }
          } else {
            newParent = ra; child = rb;
          }
          parent[child] = newParent;
          size[newParent] += size[child];
        }
        updateAllLinks();
        updateStatus();
        flashLastAction('Random unions applied', false);
      }

      async function demoSequence() {
        runningAnimation = true;
        flashLastAction('Demo sequence started', false);
        // simple demo: union pairs, find compress
        const pairs = [];
        for (let i = 0; i < Math.min(6, N - 1); i++) {
          pairs.push([i, i + 1]);
        }
        for (const [a, b] of pairs) {
          await doUnion(a, b);
          await sleep(180);
        }
        await sleep(400);
        // pick a leaf and find with compression
        const leaf = Math.min(N - 1, 5);
        selected = [leaf];
        updateSelectionVisuals();
        await doFind(leaf, true);
        flashLastAction('Demo complete', false);
        runningAnimation = false;
      }

      // --- Status calculations ---
      function updateStatus() {
        // compute number of components
        const roots = new Set();
        let maxHeight = 0;
        for (let i = 0; i < N; i++) {
          const r = findRootNoAnim(i);
          roots.add(r);
          // height from node to root
          let h = 0;
          let cur = i;
          while (parent[cur] !== cur) {
            h++; cur = parent[cur];
            if (h > N) break;
          }
          if (h > maxHeight) maxHeight = h;
        }
        componentsPill.textContent = 'Components: ' + roots.size;
        heightPill.textContent = 'Max Height: ' + maxHeight;
      }

      // --- small UI helpers ---
      function flashLastAction(msg, isError) {
        lastAction.textContent = 'Last: ' + msg;
        lastAction.style.background = isError ? 'linear-gradient(180deg,#fb7185,#ef4444)' : 'transparent';
        lastAction.style.color = isError ? 'white' : 'var(--muted)';
        setTimeout(() => {
          lastAction.style.background = 'transparent';
          lastAction.style.color = 'var(--muted)';
        }, 1500);
      }

      function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      // initial run
      init();

    })();
  </script>
</body>
</html>