<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fibonacci Sequence — Interactive Module</title>
  <style>
    /* Safe area margins */
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --primary: #0b6cff;
      --accentA: #ff8a65; /* previous-1 */
      --accentB: #ffd54f; /* previous-2 */
      --newColor: #66bb6a;
      --bg: #fbfdff;
      --card: #ffffff;
      --muted: #6b7280;
      --max-terms: 16;
    }

    html,body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #0f1724;
    }

    .page {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100%;
    }

    /* Layout */
    .header {
      display: flex;
      align-items: baseline;
      gap: var(--gap);
      margin-bottom: calc(var(--gap) + 4px);
      flex-wrap: wrap;
    }
    .title {
      font-size: 1.25rem;
      font-weight: 700;
    }
    .subtitle {
      color: var(--muted);
      font-size: 0.95rem;
    }

    .main {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: var(--gap);
    }

    /* Responsive: stack columns below 800px */
    @media (max-width: 800px) {
      .main {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: var(--card);
      border-radius: 12px;
      padding: var(--gap);
      box-shadow: 0 6px 18px rgba(7,15,29,0.04);
      box-sizing: border-box;
    }

    /* Controls */
    .controls {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .row {
      display: flex;
      gap: var(--gap);
      align-items: center;
    }

    label {
      display: block;
      font-size: 0.9rem;
      color: #0f1724;
    }

    input[type="number"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #e6e9ef;
      font-size: 0.95rem;
    }

    .small {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .sliderRow {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    input[type="range"] {
      flex: 1;
    }

    /* Buttons */
    .btnRow {
      display: flex;
      gap: var(--gap);
      flex-wrap: wrap;
    }

    button {
      padding: 10px 14px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      background: var(--card);
      box-shadow: 0 1px 0 rgba(255,255,255,0.6) inset;
    }

    button:focus {
      outline: 3px solid rgba(11,108,255,0.15);
      outline-offset: 2px;
    }

    .primary {
      background: linear-gradient(180deg,var(--primary), #0a57d6);
      color: white;
      box-shadow: 0 6px 14px rgba(11,108,255,0.14);
    }

    .mutedBtn {
      background: #f1f5f9;
      color: #0f1724;
    }

    .secondary {
      background: #e6eefc;
      color: #0b4fcf;
    }

    /* Sequence list */
    .seqList {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }

    .term {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 8px;
      background: #fbfcff;
      border: 1px solid #eef2ff;
      cursor: pointer;
      user-select: none;
      min-width: 64px;
      justify-content: center;
      font-weight: 600;
    }

    .term[aria-selected="true"] {
      box-shadow: 0 4px 10px rgba(6, 95, 255, 0.12);
      background: linear-gradient(180deg, rgba(11,108,255,0.05), #fff);
    }

    .legendDot {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      flex: 0 0 12px;
    }

    /* Visual panel */
    .visual {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      min-height: 360px;
    }

    .canvasCard {
      flex: 1;
      border-radius: 12px;
      background: linear-gradient(180deg, #fff, #fbfdff);
      border: 1px solid #eaeef6;
      padding: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    canvas {
      max-width: 100%;
      height: auto;
      display: block;
      border-radius: 8px;
      background: transparent;
    }

    .formulaBar {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: linear-gradient(180deg,#fff,#f8fbff);
      border-radius: 8px;
      border: 1px solid #eef3ff;
    }

    .formula {
      font-weight: 700;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .valueBox {
      padding: 6px 8px;
      border-radius: 6px;
      font-weight: 700;
      min-width: 48px;
      text-align: center;
      background: rgba(0,0,0,0.03);
    }

    .status {
      color: var(--muted);
      font-size: 0.9rem;
    }

    /* Color tokens for previous two and new */
    .cA { background: linear-gradient(180deg,var(--accentA), #ff7043); color: #fff; }
    .cB { background: linear-gradient(180deg,var(--accentB), #ffb900); color: #1f1f1f; }
    .cNew { background: linear-gradient(180deg,var(--newColor), #43a047); color: #fff; }

    /* Tile legend small */
    .legend {
      display: flex;
      gap: 12px;
      align-items: center;
      color: var(--muted);
      font-size: 0.9rem;
    }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      * {
        transition: none !important;
        animation: none !important;
      }
    }
  </style>
</head>
<body>
  <div class="page" role="main">
    <div class="header">
      <div class="title">Fibonacci Sequence — Step & Visualize</div>
      <div class="subtitle">See how each term is the sum of the previous two and watch growth via animated squares and a spiral arc.</div>
    </div>

    <div class="main" aria-live="polite">
      <!-- Left: Controls -->
      <section class="panel controls" aria-labelledby="controlsHeading">
        <h2 id="controlsHeading" style="margin:0 0 4px 0;font-size:1rem;">Controls</h2>

        <div>
          <label for="seedA">Seed A (a1)</label>
          <input id="seedA" type="number" step="1" value="0" min="-999999" aria-label="Seed A" />
        </div>

        <div>
          <label for="seedB">Seed B (a2)</label>
          <input id="seedB" type="number" step="1" value="1" min="-999999" aria-label="Seed B" />
        </div>

        <div class="row">
          <button id="applySeeds" class="mutedBtn" aria-label="Apply seed values">Apply seeds</button>
          <div class="small">Use different seeds to explore generalized Fibonacci-like sequences.</div>
        </div>

        <div>
          <label for="termRange">Number of terms</label>
          <div class="sliderRow">
            <input id="termRange" type="range" min="1" max="16" step="1" value="8" aria-label="Number of terms slider" />
            <div id="termCount" class="small" style="min-width:44px;text-align:right;">8</div>
          </div>
        </div>

        <div class="btnRow" role="toolbar" aria-label="Play controls">
          <button id="stepBtn" class="primary" aria-label="Step to next term">Step</button>
          <button id="playBtn" class="secondary" aria-pressed="false" aria-label="Play or pause animation">Play</button>
          <button id="resetBtn" class="mutedBtn" aria-label="Reset visualization">Reset</button>
        </div>

        <div style="border-top: 1px dashed #eef3ff; padding-top: 12px;">
          <div style="font-weight:700; margin-bottom:8px;">Sequence (click to highlight)</div>
          <div id="sequenceList" class="seqList" role="list" aria-label="Sequence list"></div>
        </div>
      </section>

      <!-- Right: Visual -->
      <section class="panel visual" aria-labelledby="visualHeading">
        <h2 id="visualHeading" style="margin:0 0 6px 0;font-size:1rem;">Visualization</h2>

        <div class="canvasCard" id="canvasCard" aria-hidden="false" role="img" aria-label="Fibonacci squares and spiral visualization">
          <canvas id="vizCanvas" width="900" height="600" tabindex="0"></canvas>
        </div>

        <div class="formulaBar" role="status" aria-live="polite">
          <div class="formula" aria-hidden="false">
            <div style="color:var(--muted)">a_n =</div>
            <div class="valueBox cA" id="valA">0</div>
            <div style="font-weight:700;">+</div>
            <div class="valueBox cB" id="valB">1</div>
            <div style="font-weight:700;">=</div>
            <div class="valueBox cNew" id="valNew">1</div>
            <div style="color:var(--muted);font-weight:600;margin-left:8px;">(next)</div>
          </div>
          <div class="legend">
            <div class="legendDot" style="background: linear-gradient(180deg,var(--accentA), #ff7043)"></div><div class="small">a_{n-1}</div>
            <div class="legendDot" style="background: linear-gradient(180deg,var(--accentB), #ffb900)"></div><div class="small">a_{n-2}</div>
            <div class="legendDot" style="background: linear-gradient(180deg,var(--newColor), #43a047)"></div><div class="small">a_n</div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>
    // Interactive Fibonacci visualization
    (function () {
      // Elements
      const seedAInput = document.getElementById('seedA');
      const seedBInput = document.getElementById('seedB');
      const applySeedsBtn = document.getElementById('applySeeds');
      const rangeInput = document.getElementById('termRange');
      const termCountLabel = document.getElementById('termCount');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const resetBtn = document.getElementById('resetBtn');
      const sequenceList = document.getElementById('sequenceList');
      const canvas = document.getElementById('vizCanvas');
      const ctx = canvas.getContext('2d');
      const valAEl = document.getElementById('valA');
      const valBEl = document.getElementById('valB');
      const valNewEl = document.getElementById('valNew');
      const maxTerms = 16;

      // State
      let seq = []; // numeric sequence
      let maxDisplayTerms = parseInt(rangeInput.value, 10) || 8;
      let playing = false;
      let playInterval = null;
      let prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // Canvas sizing & scale
      function resizeCanvas() {
        // Fill the visual card while keeping aspect ratio
        const card = canvas.parentElement;
        const style = getComputedStyle(card);
        const w = card.clientWidth - 24;
        const h = Math.max(240, card.clientHeight - 24);
        canvas.width = Math.floor(w * window.devicePixelRatio);
        canvas.height = Math.floor(h * window.devicePixelRatio);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
        drawAll();
      }
      window.addEventListener('resize', debounce(resizeCanvas, 120));
      // Initial resize
      resizeCanvas();

      // Initialize default sequence
      function initSequence(a = 0, b = 1) {
        seq = [];
        seq.push(Number(a));
        seq.push(Number(b));
        updateUI();
        drawAll();
      }

      // Apply seeds
      applySeedsBtn.addEventListener('click', () => {
        stopPlay();
        const a = Number(seedAInput.value) || 0;
        const b = Number(seedBInput.value) || 0;
        initSequence(a, b);
      });

      // Range slider handling
      rangeInput.addEventListener('input', (e) => {
        maxDisplayTerms = Math.max(1, Math.min(maxTerms, Number(e.target.value)));
        termCountLabel.textContent = maxDisplayTerms;
        // If current sequence already too long, leave but hide extra; if short, auto-step to fill (but not play)
        updateUI();
        drawAll();
      });

      // Step button
      stepBtn.addEventListener('click', () => {
        stepOnce();
      });

      // Play button
      playBtn.addEventListener('click', () => {
        if (playing) {
          stopPlay();
        } else {
          startPlay();
        }
      });

      // Reset
      resetBtn.addEventListener('click', () => {
        stopPlay();
        const a = Number(seedAInput.value) || 0;
        const b = Number(seedBInput.value) || 0;
        seq = [a, b];
        updateUI();
        drawAll();
      });

      // Keyboard support: space toggles play when play button focused
      playBtn.addEventListener('keydown', (e) => {
        if (e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          playBtn.click();
        }
      });

      // Sequence list click handler uses event delegation
      sequenceList.addEventListener('click', (e) => {
        const termEl = e.target.closest('.term');
        if (!termEl) return;
        const idx = Number(termEl.dataset.index);
        // Select / highlight
        document.querySelectorAll('.term').forEach(t => t.setAttribute('aria-selected', 'false'));
        termEl.setAttribute('aria-selected', 'true');
        highlightIndex(idx);
      });

      // Step logic: compute next term
      function stepOnce() {
        if (seq.length >= maxTerms) {
          // Do nothing if we've hit hard max; but allow fewer (maxDisplayTerms acts as UI cap)
        }
        // compute next
        const len = seq.length;
        const next = seq[len - 1] + seq[len - 2];
        seq.push(next);
        animateNewTerm(seq.length - 1);
        updateUI();
      }

      function startPlay() {
        if (playing) return;
        playing = true;
        playBtn.setAttribute('aria-pressed', 'true');
        playBtn.textContent = 'Pause';
        // auto step until reaching selected max term count
        const stepDelay = prefersReducedMotion ? 100 : 700;
        playInterval = setInterval(() => {
          if (seq.length >= maxDisplayTerms) {
            stopPlay();
            return;
          }
          stepOnce();
        }, stepDelay);
      }

      function stopPlay() {
        if (!playing) return;
        playing = false;
        playBtn.setAttribute('aria-pressed', 'false');
        playBtn.textContent = 'Play';
        clearInterval(playInterval);
        playInterval = null;
      }

      // Update UI lists and formula boxes
      function updateUI() {
        // clamp sequence length to at least 2
        if (seq.length < 2) seq = [0, 1];
        // Build sequence list (show up to maxDisplayTerms)
        sequenceList.innerHTML = '';
        const displayCount = Math.min(maxDisplayTerms, seq.length);
        for (let i = 0; i < displayCount; i++) {
          const el = document.createElement('button');
          el.className = 'term';
          el.type = 'button';
          el.dataset.index = i;
          el.setAttribute('role', 'listitem');
          el.textContent = `${i + 1}: ${seq[i]}`;
          // color dot
          const dot = document.createElement('span');
          dot.className = 'legendDot';
          if (i >= seq.length - 2) {
            // recent items color-coded
            if (i === seq.length - 1) {
              dot.style.background = 'linear-gradient(180deg,var(--newColor), #43a047)';
            } else {
              dot.style.background = 'linear-gradient(180deg,var(--accentA), #ff7043)';
            }
          } else {
            dot.style.background = '#eef2ff';
          }
          el.prepend(dot);
          el.setAttribute('aria-selected', 'false');
          sequenceList.appendChild(el);
        }

        // formula values: previous two (a_{n-1}, a_{n-2}) and predicted next
        const last = seq[seq.length - 1] ?? 0;
        const prev = seq[seq.length - 2] ?? 0;
        const next = last + prev;
        // Show a_{n-1} as 'A' and a_{n-2} as 'B' for the next computation
        valAEl.textContent = last;
        valBEl.textContent = prev;
        valNewEl.textContent = next;
      }

      // Highlight index in canvas representation
      function highlightIndex(i) {
        // Implemented by a short animation: drawAll with highlight index
        drawAll(i);
      }

      // Canvas drawing: draw squares and arcs
      // We'll tile squares in a spiral-like placement: place squares adjacent alternating horizontal/vertical.
      function drawAll(highlightIdx = -1) {
        // Clear
        const w = canvas.width / window.devicePixelRatio;
        const h = canvas.height / window.devicePixelRatio;
        ctx.clearRect(0, 0, w, h);

        // Draw background grid lightly
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);
        ctx.restore();

        // If seq empty, nothing
        if (seq.length === 0) return;

        // Compute sizes: to fit up to displayCount squares, scale them
        const displayCount = Math.min(maxDisplayTerms, seq.length);
        const values = seq.slice(0, displayCount);

        // Normalize scale so the largest square fits the canvas smaller dimension
        const maxVal = Math.max(...values.map(v => Math.abs(v)));
        // Handle negative or zero sizes: use absolute values and minimal size for 0
        const nonNegSizes = values.map(v => Math.max(0, Math.abs(v)));
        const maxSize = Math.max(1, ...nonNegSizes);

        // We'll compute each tile size proportional to value^(1) — area representation would use sqrt, but classic Fibonacci squares use side length proportional to value.
        // To ensure visible, treat size as value + 0.5 if zero
        const sideUnits = nonNegSizes.map(v => (v === 0 ? 0.6 : v));
        const unit = Math.min((w - 40) / (sideUnits.reduce((a, b) => a + b, 0) || 1), (h - 40) / (Math.max(...sideUnits) || 1));
        // But that naive layout may overflow; we use a spiral placement algorithm used for Fibonacci squares:
        // We'll scale side lengths so the sum along each axis is manageable.

        // For readability and robustness, map sideUnits to a relative scale where largest side fits 60% of min dimension.
        const minDim = Math.min(w, h);
        const largestSide = Math.max(...sideUnits);
        const scale = (minDim * 0.55) / Math.max(1, largestSide); // large square around half min dimension
        const sides = sideUnits.map(s => s * scale);

        // Spiral placement: start with first square centered
        const centerX = w / 2;
        const centerY = h / 2;
        const placed = []; // {x,y,w,h,value,index}

        // Directions: 0=right,1=down,2=left,3=up relative to current square
        let dir = 0;
        // Start with first two squares placed horizontally for clarity
        // We'll place first at center-left, second to its right, then proceed alternating.
        // For a general approach, place first square centered, second to the right of it, then attach subsequent squares around.
        if (sides.length >= 1) {
          const s0 = sides[0];
          placed.push({
            x: centerX - s0,
            y: centerY - s0 / 2,
            w: s0,
            h: s0,
            value: values[0],
            idx: 0
          });
        }
        if (sides.length >= 2) {
          const s1 = sides[1];
          // Place s1 to the right of s0
          const p0 = placed[0];
          placed.push({
            x: p0.x + p0.w,
            y: p0.y + p0.h - s1,
            w: s1,
            h: s1,
            value: values[1],
            idx: 1
          });
        }
        // For subsequent squares, follow a spiral: attach to the bounding rectangle in sequence right, down, left, up...
        let bounds = computeBounds(placed);
        dir = 0; // next attach to right of the bounding box
        for (let i = 2; i < sides.length; i++) {
          const s = sides[i];
          let nx, ny;
          if (dir === 0) { // right
            nx = bounds.x + bounds.w;
            // Align vertically so that the new square sits above or below to form spiral: put its top at bounds.y + bounds.h - s
            ny = bounds.y + bounds.h - s;
          } else if (dir === 1) { // down
            nx = bounds.x + bounds.w - s;
            ny = bounds.y + bounds.h;
          } else if (dir === 2) { // left
            nx = bounds.x - s;
            ny = bounds.y;
          } else { // up
            nx = bounds.x;
            ny = bounds.y - s;
          }
          placed.push({
            x: nx,
            y: ny,
            w: s,
            h: s,
            value: values[i],
            idx: i
          });
          bounds = computeBounds(placed);
          dir = (dir + 1) % 4;
        }

        // After placement, compute an offset to center the whole cluster in canvas
        const totalBounds = computeBounds(placed);
        const offsetX = centerX - (totalBounds.x + totalBounds.w / 2);
        const offsetY = centerY - (totalBounds.y + totalBounds.h / 2);
        // Draw each tile
        placed.forEach(p => {
          const drawX = p.x + offsetX;
          const drawY = p.y + offsetY;
          // Background tile
          const baseColor = getTileColor(p.idx, seq.length - 1);
          // Shadow
          ctx.save();
          ctx.beginPath();
          roundRect(ctx, drawX + 1.5, drawY + 1.5, p.w, p.h, 6);
          ctx.fillStyle = 'rgba(10,20,40,0.04)';
          ctx.fill();
          ctx.restore();

          // Tile background
          ctx.save();
          roundRect(ctx, drawX, drawY, p.w, p.h, 6);
          ctx.fillStyle = baseColor.bg;
          ctx.strokeStyle = baseColor.border;
          ctx.lineWidth = 1;
          ctx.fill();
          ctx.stroke();
          ctx.restore();

          // Value text (centered)
          ctx.save();
          ctx.fillStyle = baseColor.text;
          ctx.font = Math.max(12, Math.min(28, p.w / 6)) + 'px system-ui, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(String(p.value), drawX + p.w / 2, drawY + p.h / 2);
          ctx.restore();
        });

        // Draw spiral arcs inside squares progressively for first displayCount squares:
        placed.forEach((p, i) => {
          // Arcs drawn inside tile: quarter arcs connecting corners; we draw 90-degree arc fitting square
          const drawX = p.x + offsetX;
          const drawY = p.y + offsetY;
          const r = p.w;
          // Determine arc direction based on index to make roughly spiral pattern: 0=bottom-right,1=bottom-left,2=top-left,3=top-right cycles
          const dir = i % 4;
          let cx, cy, startAngle;
          if (dir === 0) {
            cx = drawX + p.w;
            cy = drawY + p.h;
            startAngle = Math.PI;
          } else if (dir === 1) {
            cx = drawX;
            cy = drawY + p.h;
            startAngle = -Math.PI / 2;
          } else if (dir === 2) {
            cx = drawX;
            cy = drawY;
            startAngle = 0;
          } else {
            cx = drawX + p.w;
            cy = drawY;
            startAngle = Math.PI / 2;
          }
          // Draw animated stroke: use dashed pattern to simulate growth if motion allowed, otherwise draw full immediately
          ctx.save();
          ctx.beginPath();
          ctx.lineWidth = Math.max(2, p.w / 28);
          ctx.strokeStyle = 'rgba(20,40,80,0.85)';
          ctx.setLineDash([]);
          ctx.arc(cx, cy, Math.max(4, p.w), startAngle, startAngle + Math.PI / 2);
          ctx.stroke();
          ctx.restore();

          // If highlight requested, draw border
          if (i === highlightIdx) {
            ctx.save();
            roundRect(ctx, drawX - 4, drawY - 4, p.w + 8, p.h + 8, 8);
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'rgba(11,108,255,0.18)';
            ctx.stroke();
            ctx.restore();
          }
        });
      }

      // Helper to compute bounding box
      function computeBounds(list) {
        if (!list || list.length === 0) return { x: 0, y: 0, w: 0, h: 0 };
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        list.forEach(p => {
          minX = Math.min(minX, p.x);
          minY = Math.min(minY, p.y);
          maxX = Math.max(maxX, p.x + p.w);
          maxY = Math.max(maxY, p.y + p.h);
        });
        return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
      }

      // Visual color mapping based on recency
      function getTileColor(idx, lastIdx) {
        // idx is index in placed list which corresponds to seq index 0..displayCount-1
        const seqIndex = idx;
        if (seqIndex === lastIdx) {
          return { bg: 'linear-gradient(180deg,var(--newColor), #43a047)', border: 'rgba(60,160,80,0.9)', text: '#fff' };
        }
        if (seqIndex === lastIdx - 1) {
          return { bg: 'linear-gradient(180deg,var(--accentA), #ff7043)', border: 'rgba(255,120,80,0.9)', text: '#fff' };
        }
        if (seqIndex === lastIdx - 2) {
          return { bg: 'linear-gradient(180deg,var(--accentB), #ffb900)', border: 'rgba(220,170,40,0.9)', text: '#111' };
        }
        // Default pale
        return { bg: '#fff', border: '#eef2ff', text: '#0f1724' };
      }

      // Animate adding a new term: quick visual flash in formula and drawAll
      function animateNewTerm(newIdx) {
        // Flash formula boxes
        const origA = valAEl.textContent;
        const origB = valBEl.textContent;
        updateUI();

        // Brief animation: we redraw with highlight on the new index for a moment
        drawAll(newIdx);
        if (prefersReducedMotion) {
          setTimeout(() => drawAll(), 150);
          return;
        }
        // Simple pulse on newVal
        valNewEl.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.12)' }, { transform: 'scale(1)' }], {
          duration: 420,
          easing: 'ease-out'
        });
        // After a short delay, remove highlight
        setTimeout(() => {
          drawAll();
        }, 520);
      }

      // Utility: rounded rectangle
      function roundRect(ctx, x, y, w, h, r) {
        const radius = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + w, y, x + w, y + h, radius);
        ctx.arcTo(x + w, y + h, x, y + h, radius);
        ctx.arcTo(x, y + h, x, y, radius);
        ctx.arcTo(x, y, x + w, y, radius);
        ctx.closePath();
      }

      // Helper: debounce
      function debounce(fn, wait) {
        let t;
        return function () {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, arguments), wait);
        };
      }

      // Initial state
      initSequence(0, 1);

      // Auto fill up to slider selection (but do not autoplay)
      function autorefillToRange() {
        while (seq.length < maxDisplayTerms) {
          seq.push(seq[seq.length - 1] + seq[seq.length - 2]);
        }
        updateUI();
        drawAll();
      }

      // On initial load, fill to selected count
      autorefillToRange();

      // Keep sequence trimmed in UI but full stored up to maxTerms
      // Ensure slider does not exceed allowed
      rangeInput.max = maxTerms;

      // Accessibility: tab focus styles are provided by CSS :focus outline on buttons/inputs
    })();
  </script>
</body>
</html>