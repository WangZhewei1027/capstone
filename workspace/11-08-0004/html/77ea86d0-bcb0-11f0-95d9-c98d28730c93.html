<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Binary Search Tree (BST) Explorer</title>
  <style>
    /*
      Safe area margins: 24px on all sides
      Minimum spacing between interactive elements: 16px
      Simple, accessible styling with clear visual feedback
    */
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #07102a;
      --muted: #9aa7c0;
      --accent: #60a5fa;
      --success: #4ade80;
      --danger: #fb7185;
      --node-bg: #0ea5a5;
      --node-text: #041024;
      --visited: #f59e0b;
      --found: #34d399;
      --node-radius: 20;
      --vertical-gap: 88px;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#061021 0%, #081428 60%);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .app{
      box-sizing: border-box;
      padding: var(--safe-margin);
      min-height:100%;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    header{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:var(--gap);
      flex-wrap:wrap;
    }

    .title-block{
      min-width: 220px;
    }

    h1{
      margin:0 0 6px 0;
      font-size:20px;
      line-height:1.1;
    }

    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* Layout: left info column, right interactive canvas */
    .main {
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      width:100%;
    }

    /* Left column: descriptions + controls */
    .left {
      width:320px;
      min-width:260px;
      max-width:40%;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      box-shadow: 0 6px 18px rgba(4,8,20,0.6);
      box-sizing:border-box;
    }

    .section{
      margin-bottom:16px;
    }

    .section h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:var(--accent);
    }

    .section p{
      margin:0;
      font-size:13px;
      color:var(--muted);
      line-height:1.35;
    }

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:12px;
      margin-top:8px;
    }

    .row{
      display:flex;
      gap:12px;
      align-items:center;
    }

    label{
      font-size:13px;
      color:var(--muted);
    }

    input[type="number"]{
      appearance: textfield;
      padding:8px 10px;
      font-size:14px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.02);
      color:inherit;
      flex:1;
    }

    button{
      appearance:none;
      border:0;
      padding:8px 12px;
      border-radius:8px;
      font-size:13px;
      cursor:pointer;
      color:#041024;
      background:var(--accent);
      transition:transform .12s ease, box-shadow .12s ease, opacity .12s;
    }

    button.secondary{
      background: rgba(255,255,255,0.06);
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.03);
    }

    button.warn{
      background:var(--danger);
      color:#fff;
    }

    .small{
      padding:6px 8px;
      font-size:13px;
      border-radius:8px;
    }

    button:active{ transform:translateY(1px); }
    button:disabled{ opacity:0.5; cursor:default; }

    .control-grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }

    /* Right column: canvas and status */
    .right{
      flex:1 1 auto;
      min-height:420px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:12px;
      display:flex;
      flex-direction:column;
      box-sizing:border-box;
      gap:12px;
      box-shadow: 0 6px 18px rgba(4,8,20,0.6);
    }

    .canvas-wrap{
      flex:1 1 auto;
      position:relative;
      overflow:auto;
      min-height:300px;
      background: linear-gradient(180deg, rgba(9,20,36,0.01), transparent);
      border-radius:8px;
      padding:12px;
    }

    svg{
      width:100%;
      height:100%;
      display:block;
      overflow:visible;
    }

    /* Node styles */
    .node{
      cursor:pointer;
      transform-origin:center;
      transition: transform 260ms ease, opacity 240ms ease;
    }

    .node circle{
      fill:var(--node-bg);
      stroke: rgba(255,255,255,0.06);
      stroke-width:2px;
      transition: fill 220ms ease, stroke 220ms ease;
    }

    .node text{
      fill:var(--node-text);
      font-weight:600;
      font-size:12px;
      text-anchor:middle;
      dominant-baseline:central;
      pointer-events:none;
    }

    .edge{
      stroke: rgba(255,255,255,0.06);
      stroke-width:2;
      fill:none;
      transition: stroke 180ms ease;
    }

    /* Visual feedback classes */
    .visited circle{ fill: var(--visited); transform: scale(1.05); }
    .found circle{ fill: var(--found); transform: scale(1.06); }
    .dim circle{ opacity: 0.25; }
    .edge.highlight{ stroke: var(--visited); stroke-width:3px; }
    .edge.found{ stroke: var(--found); stroke-width:3px; }

    /* controls below canvas */
    .statusbar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }

    .status{
      font-size:13px;
      color:var(--muted);
      min-height:20px;
    }

    .traversal-controls{
      display:flex;
      gap:8px;
      align-items:center;
    }

    .order-btn{
      padding:6px 10px;
      border-radius:8px;
      font-size:13px;
      background:rgba(255,255,255,0.03);
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.02);
    }

    .legend{
      display:flex;
      gap:8px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }

    .legend .swatch{
      width:12px;
      height:12px;
      border-radius:3px;
      display:inline-block;
      margin-right:6px;
    }

    /* Responsive tweaks */
    @media (max-width:900px){
      .main{ flex-direction:column; }
      .left{ width:100%; max-width:none; }
    }

    /* accessibility focus states */
    input:focus, button:focus{
      outline: 3px solid rgba(96,165,250,0.18);
      outline-offset:2px;
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-labelledby="title">
    <header>
      <div class="title-block">
        <h1 id="title">Binary Search Tree (BST) Explorer</h1>
        <p class="lead">Interactive visualization of BST insertions, searches, and traversals. Watch algorithmic decisions step-by-step.</p>
      </div>
      <div style="min-width:220px; text-align:right;">
        <p style="margin:0; color:var(--muted); font-size:13px;">Safe area padding: 24px • Controls spaced ≥ 16px • Responsive & keyboard friendly</p>
      </div>
    </header>

    <div class="main" role="main">
      <!-- LEFT: Descriptions + Controls -->
      <aside class="left" aria-label="Module controls and descriptions">
        <section class="section" aria-labelledby="concept">
          <h3 id="concept">Concept Title</h3>
          <p>Binary Search Tree (BST) — a binary tree where each node's left subtree contains smaller values and the right subtree contains larger values.</p>
        </section>

        <section class="section" aria-labelledby="objective">
          <h3 id="objective">Learning Objective</h3>
          <p>After interacting, you will understand how BST insertion and search traverse the tree, how node positions reflect order, and how different traversals visit nodes.</p>
        </section>

        <section class="section" aria-labelledby="interaction">
          <h3 id="interaction">Interaction Design</h3>
          <p>Type a value and press Insert to add a node. Visual path highlights show comparisons. Use Search to see traversal and discovery. Run traversals or step through them to learn visit order. Generate random trees and reset to explore variations.</p>
        </section>

        <section class="section" aria-labelledby="layoutdesc">
          <h3 id="layoutdesc">Layout Description</h3>
          <p>The left column contains descriptive text and controls (input, buttons). The right column is the visualization canvas (SVG) showing nodes and edges. Controls are grouped with at least 16px spacing. The canvas scales to available width; nodes are positioned by a simple balanced horizontal layout derived from in-order x-coordinates and depth-based y-coordinates.</p>
        </section>

        <section class="section">
          <h3>Controls</h3>
          <div class="controls" role="form" aria-label="BST controls">
            <div class="row">
              <label for="valueInput" style="width:64px;">Value</label>
              <input id="valueInput" type="number" inputmode="numeric" aria-label="Value to insert or search" placeholder="e.g., 42" />
            </div>

            <div class="row control-grid">
              <button id="insertBtn" class="small" aria-label="Insert value">Insert</button>
              <button id="searchBtn" class="small secondary" aria-label="Search value">Search</button>
              <button id="randomBtn" class="small secondary" aria-label="Generate random">Random</button>
              <button id="clearBtn" class="small warn" aria-label="Clear tree">Clear</button>
            </div>

            <div class="row" style="margin-top:6px;">
              <label style="width:64px;">Build</label>
              <div style="display:flex; gap:8px;">
                <button id="addSequence" class="secondary small" title="Insert a sample sequence">Sample seq</button>
                <button id="balanceBtn" class="secondary small" title="Balance visually by re-layout">Relayout</button>
              </div>
            </div>

            <div style="margin-top:6px;">
              <label style="display:block; margin-bottom:6px;">Traversals</label>
              <div style="display:flex; gap:8px;">
                <button class="order-btn" data-order="in" aria-label="In-order">In-order</button>
                <button class="order-btn" data-order="pre" aria-label="Pre-order">Pre-order</button>
                <button class="order-btn" data-order="post" aria-label="Post-order">Post-order</button>
                <button class="order-btn" data-order="bfs" aria-label="Level-order">Level-order</button>
              </div>
              <div style="display:flex; gap:8px; margin-top:8px;">
                <button id="playBtn" class="secondary small">Play</button>
                <button id="stepBtn" class="secondary small">Step</button>
                <button id="stopBtn" class="secondary small">Stop</button>
              </div>
            </div>
          </div>
        </section>

      </aside>

      <!-- RIGHT: Visualization -->
      <section class="right" aria-label="BST visualization">
        <div class="canvas-wrap" id="canvasWrap" tabindex="0">
          <svg id="svgCanvas" viewBox="0 0 1200 600" preserveAspectRatio="xMidYMin meet" role="img" aria-label="Binary search tree visualization">
            <!-- Edges and nodes are appended here by JS -->
          </svg>
        </div>

        <div class="statusbar" aria-live="polite">
          <div class="status" id="status">Empty tree. Tips: Insert a number (e.g., 50) and watch where it goes.</div>
          <div style="display:flex; gap:12px; align-items:center;">
            <div class="legend"><span class="swatch" style="background:var(--visited)"></span>Visited</div>
            <div class="legend"><span class="swatch" style="background:var(--found)"></span>Found</div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>
    /*
      Vanilla JS self-contained BST visualizer.
      Features:
       - Insert (animated path highlights)
       - Search (animated comparisons)
       - Traversals: in, pre, post, level (play/step/stop)
       - Random generation and sample sequence
       - Responsive SVG layout using inorder x-assignment
    */

    // DOM refs
    const svg = document.getElementById('svgCanvas');
    const insertBtn = document.getElementById('insertBtn');
    const searchBtn = document.getElementById('searchBtn');
    const clearBtn = document.getElementById('clearBtn');
    const randomBtn = document.getElementById('randomBtn');
    const valueInput = document.getElementById('valueInput');
    const statusEl = document.getElementById('status');
    const playBtn = document.getElementById('playBtn');
    const stepBtn = document.getElementById('stepBtn');
    const stopBtn = document.getElementById('stopBtn');
    const orderButtons = document.querySelectorAll('.order-btn');
    const canvasWrap = document.getElementById('canvasWrap');
    const addSequenceBtn = document.getElementById('addSequence');
    const balanceBtn = document.getElementById('balanceBtn');

    // Constants
    const NODE_R = 20;
    const V_GAP = 88;
    const ANIM_DELAY = 420; // ms between steps when animating insertion/search
    const TRAV_DELAY = 420;

    // BST structure
    class Node {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        // Rendering coordinates
        this.x = 0;
        this.y = 0;
        // id for DOM mapping
        this.id = 'n' + Math.random().toString(36).slice(2,9);
      }
    }

    let root = null;
    let nodesInOrder = []; // used for layout assignment
    let svgWidth = 1200;
    let svgHeight = 600;

    // Traversal state
    let traversalSequence = [];
    let traversalIndex = 0;
    let travTimer = null;
    let currentOrder = 'in';

    // Utility: update status aria-live
    function setStatus(txt, tone) {
      statusEl.textContent = txt;
      if (tone === 'error') {
        statusEl.style.color = 'var(--danger)';
      } else {
        statusEl.style.color = 'var(--muted)';
      }
    }

    // Insert value into BST (no animation)
    function bstInsertSync(val) {
      const node = new Node(val);
      if (!root) {
        root = node;
        return node;
      }
      let cur = root;
      while (true) {
        if (val === cur.value) {
          // duplicates go to right by convention (or ignore)
          if (cur.right === null) { cur.right = node; return node; }
          cur = cur.right;
        } else if (val < cur.value) {
          if (!cur.left) { cur.left = node; return node; }
          cur = cur.left;
        } else {
          if (!cur.right) { cur.right = node; return node; }
          cur = cur.right;
        }
      }
    }

    // Animated insertion: highlights comparison path then inserts
    async function insertAnimated(val) {
      if (root === null) {
        root = new Node(val);
        layoutAndRender();
        animateNodeAppear(root.id);
        setStatus('Inserted root: ' + val);
        return;
      }
      // Traverse with highlights
      let cur = root;
      let path = [];
      while (cur) {
        path.push(cur);
        if (val === cur.value) { // by design we'll insert to right subtree if equal
          cur = cur.right;
        } else if (val < cur.value) {
          cur = cur.left;
        } else {
          cur = cur.right;
        }
      }

      // Render current layout so existing nodes are present while we animate path
      layoutAndRender();

      // Animate visiting nodes in path
      for (let i = 0; i < path.length; i++) {
        const n = path[i];
        highlightNode(n.id, 'visited');
        setStatus('Comparing with ' + n.value + '...');
        await wait(ANIM_DELAY);
        // clear highlight except keep last dimmed until insertion
        if (i < path.length - 1) clearHighlights();
      }

      // Insert at correct spot (sync) and layout again
      bstInsertSync(val);
      layoutAndRender();
      // find the new node's id for appear animation (it has unique id)
      // The new node might be placed as leaf; find node with given value that has no children newly created
      // We can find the latest created node by searching for unmatched DOM element absence before insertion, but simpler:
      const newNode = findNode(root, val, true); // find a node equal to val that is a leaf (prefer the newest)
      if (newNode) {
        animateNodeAppear(newNode.id);
        highlightNode(newNode.id, 'found');
        setTimeout(() => clearHighlights(), 700);
      }
      setStatus('Inserted: ' + val);
    }

    // Search animated
    async function searchAnimated(val) {
      if (!root) { setStatus('Tree is empty', 'error'); return; }
      layoutAndRender();
      let cur = root;
      while (cur) {
        highlightNode(cur.id, 'visited');
        setStatus('Comparing with ' + cur.value + '...');
        await wait(ANIM_DELAY);
        if (val === cur.value) {
          highlightNode(cur.id, 'found');
          setStatus('Value found: ' + val);
          return;
        } else if (val < cur.value) cur = cur.left;
        else cur = cur.right;
        // clear all visited highlight for next step so user can see progression
        clearHighlights();
      }
      setStatus('Value not found: ' + val, 'error');
    }

    // Traversal generation
    function generateTraversal(order) {
      const seq = [];
      if (!root) return seq;
      if (order === 'in') {
        (function inorder(n){ if (!n) return; inorder(n.left); seq.push(n); inorder(n.right); })(root);
      } else if (order === 'pre') {
        (function preorder(n){ if (!n) return; seq.push(n); preorder(n.left); preorder(n.right); })(root);
      } else if (order === 'post') {
        (function postorder(n){ if (!n) return; postorder(n.left); postorder(n.right); seq.push(n); })(root);
      } else if (order === 'bfs') {
        const q = [root];
        while(q.length){
          const cur = q.shift();
          seq.push(cur);
          if (cur.left) q.push(cur.left);
          if (cur.right) q.push(cur.right);
        }
      }
      return seq;
    }

    // Play traversal animation
    function playTraversal(order) {
      stopTraversal();
      traversalSequence = generateTraversal(order);
      traversalIndex = 0;
      if (traversalSequence.length === 0) { setStatus('Tree empty — nothing to traverse'); return; }
      setStatus(capitalize(order) + ' traversal: playing');
      travTimer = setInterval(() => {
        if (traversalIndex >= traversalSequence.length) {
          stopTraversal();
          setStatus(capitalize(order) + ' traversal: complete');
          return;
        }
        clearHighlights();
        const n = traversalSequence[traversalIndex];
        highlightNode(n.id, 'found');
        traversalIndex++;
      }, TRAV_DELAY);
    }

    // Step traversal: run one step
    function stepTraversal(order) {
      if (!traversalSequence || traversalSequence.length === 0 || currentOrder !== order) {
        traversalSequence = generateTraversal(order);
        traversalIndex = 0;
        currentOrder = order;
      }
      if (traversalIndex >= traversalSequence.length) {
        setStatus('Traversal complete');
        return;
      }
      clearHighlights();
      const n = traversalSequence[traversalIndex];
      highlightNode(n.id, 'found');
      traversalIndex++;
      setStatus(capitalize(order) + ' traversal: step ' + traversalIndex + '/' + traversalSequence.length);
    }

    function stopTraversal() {
      if (travTimer) {
        clearInterval(travTimer);
        travTimer = null;
      }
      traversalSequence = [];
      traversalIndex = 0;
      // don't clear highlights immediately (user may want to inspect)
    }

    // SVG rendering utilities
    function layoutAndRender() {
      // Determine depth to scale height dynamically
      const depth = treeDepth(root);
      svgHeight = Math.max(300, (depth + 1) * V_GAP + 80);
      // compute inorder x positions
      nodesInOrder = [];
      (function inorder(n, d=0){
        if (!n) return;
        inorder(n.left, d+1);
        nodesInOrder.push({ node: n, depth: d });
        inorder(n.right, d+1);
      })(root);

      // Assign x positions across width based on index
      const width = Math.max(600, canvasWrap.clientWidth - 24);
      svg.setAttribute('viewBox', `0 0 ${width} ${svgHeight}`);
      svgWidth = width;

      const count = nodesInOrder.length || 1;
      nodesInOrder.forEach((entry, i) => {
        entry.node.x = (i + 1) * (svgWidth / (count + 1));
        entry.node.y = (entry.depth + 1) * V_GAP;
      });

      // For nodes not in nodesInOrder (shouldn't happen), set fallback positions
      // Now render edges and nodes
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      // Draw edges recursively
      function drawEdges(n) {
        if (!n) return;
        if (n.left) {
          drawEdge(n, n.left);
          drawEdges(n.left);
        }
        if (n.right) {
          drawEdge(n, n.right);
          drawEdges(n.right);
        }
      }

      function drawEdge(p, c) {
        const line = document.createElementNS('http://www.w3.org/2000/svg','path');
        const startX = p.x;
        const startY = p.y + NODE_R;
        const endX = c.x;
        const endY = c.y - NODE_R;
        // nice curved path (cubic bezier)
        const dx = (endX - startX) * 0.25;
        const d = `M ${startX} ${startY} C ${startX} ${startY+dx} ${endX} ${endY-dx} ${endX} ${endY}`;
        line.setAttribute('d', d);
        line.setAttribute('class', 'edge');
        line.setAttribute('data-from', p.id);
        line.setAttribute('data-to', c.id);
        svg.appendChild(line);
      }

      drawEdges(root);

      // Draw nodes (top-level to overlay edges below)
      function drawNode(n) {
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('class','node');
        g.setAttribute('transform', `translate(${n.x},${n.y})`);
        g.setAttribute('data-id', n.id);
        g.setAttribute('tabindex', '0');
        g.setAttribute('role','button');
        g.setAttribute('aria-label', 'Node ' + n.value);
        g.addEventListener('click', () => {
          // clicking a node will perform a small pulse highlight
          clearHighlights();
          pulseNode(n.id);
          setStatus('Node ' + n.value + ' selected');
        });
        g.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            g.click();
          }
        });

        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('r', NODE_R);
        circle.setAttribute('cx', 0);
        circle.setAttribute('cy', 0);
        g.appendChild(circle);

        const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
        txt.textContent = n.value;
        g.appendChild(txt);

        g.id = n.id;
        svg.appendChild(g);
      }

      // draw nodes in order of depth ascending so parent overlays children slightly
      const nodesByDepth = [];
      (function collect(n){
        if (!n) return;
        nodesByDepth.push(n);
        collect(n.left);
        collect(n.right);
      })(root);
      nodesByDepth.forEach(n => drawNode(n));
    }

    // Simple helper functions
    function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    function findNode(n, val, preferLeaf=false) {
      if (!n) return null;
      // preferLeaf: prefer a node with no children that equals val
      let res = null;
      if (n.value === val) {
        if (!preferLeaf) return n;
        if (!n.left && !n.right) return n;
        res = n; // fallback
      }
      const left = findNode(n.left, val, preferLeaf);
      if (left) return left;
      const right = findNode(n.right, val, preferLeaf);
      if (right) return right;
      return res;
    }

    function treeDepth(n) {
      if (!n) return 0;
      return 1 + Math.max(treeDepth(n.left), treeDepth(n.right));
    }

    // DOM highlight helpers
    function clearHighlights() {
      const highlighted = svg.querySelectorAll('.visited, .found, .dim, .edge.highlight, .edge.found');
      highlighted.forEach(el => {
        el.classList.remove('visited','found','dim','highlight','found');
      });
      // also remove any inline opacity
      const nodes = svg.querySelectorAll('.node');
      nodes.forEach(g => g.style.opacity = 1);
      const edges = svg.querySelectorAll('.edge');
      edges.forEach(e => e.style.opacity = 1);
    }

    function highlightNode(id, cls) {
      clearHighlights();
      const g = document.getElementById(id);
      if (!g) return;
      g.classList.add(cls);
      // dim other nodes/edges for focus
      const others = svg.querySelectorAll('.node');
      others.forEach(o => { if (o.id !== id) o.classList.add('dim'); });
      const edges = svg.querySelectorAll('.edge');
      edges.forEach(e => e.classList.add('dim'));
      // highlight connecting edge if present (find parent)
      const edgeTo = svg.querySelector('.edge[data-to="'+id+'"]');
      if (edgeTo) edgeTo.classList.add(cls === 'found' ? 'found' : 'highlight');
    }

    function pulseNode(id) {
      const g = document.getElementById(id);
      if (!g) return;
      g.style.transition = 'transform 220ms ease';
      g.style.transform = 'scale(1.12)';
      setTimeout(()=>{ g.style.transform=''; }, 240);
    }

    function animateNodeAppear(id) {
      const g = document.getElementById(id);
      if (!g) return;
      g.style.transform = 'scale(0.2)';
      g.style.opacity = '0';
      requestAnimationFrame(()=>{
        g.style.transition = 'transform 360ms cubic-bezier(.2,.9,.3,1), opacity 260ms ease';
        g.style.transform = 'scale(1)';
        g.style.opacity = '1';
      });
    }

    function capitalize(s){ return s && s[0].toUpperCase() + s.slice(1); }

    // Interactivity wiring
    insertBtn.addEventListener('click', async () => {
      const val = parseInt(valueInput.value, 10);
      if (Number.isNaN(val)) { setStatus('Please enter an integer value', 'error'); return; }
      insertBtn.disabled = true;
      await insertAnimated(val);
      insertBtn.disabled = false;
      valueInput.value = '';
      valueInput.focus();
    });

    searchBtn.addEventListener('click', async () => {
      const val = parseInt(valueInput.value, 10);
      if (Number.isNaN(val)) { setStatus('Please enter an integer value', 'error'); return; }
      searchBtn.disabled = true;
      await searchAnimated(val);
      searchBtn.disabled = false;
      valueInput.value = '';
      valueInput.focus();
    });

    clearBtn.addEventListener('click', () => {
      root = null;
      clearHighlights();
      layoutAndRender();
      setStatus('Cleared tree. Ready for new inserts.');
    });

    randomBtn.addEventListener('click', async () => {
      // generate 6 random unique values in range 1..99
      clearBtn.dispatchEvent(new Event('click'));
      const vals = new Set();
      while(vals.size < 6) vals.add(Math.floor(Math.random()*99)+1);
      const arr = Array.from(vals);
      setStatus('Inserting random values: ' + arr.join(', '));
      for (let v of arr) {
        await insertAnimated(v);
        await wait(140);
      }
    });

    addSequenceBtn.addEventListener('click', async () => {
      // sample sequence to create interesting tree
      const seq = [50, 30, 70, 20, 40, 60, 80, 35, 45];
      clearBtn.dispatchEvent(new Event('click'));
      setStatus('Inserting sample sequence...');
      for (let v of seq) {
        await insertAnimated(v);
        await wait(120);
      }
    });

    balanceBtn.addEventListener('click', () => {
      // simply re-layout visualization (we don't actually rotate)
      layoutAndRender();
      setStatus('Re-laid out tree for clarity.');
    });

    // Traversal controls
    orderButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const order = btn.getAttribute('data-order');
        clearHighlights();
        const seq = generateTraversal(order);
        if (seq.length === 0) { setStatus('Tree empty — nothing to traverse'); return; }
        // briefly animate each node in order automatically
        playTraversal(order);
      });
    });

    playBtn.addEventListener('click', () => {
      playTraversal(currentOrder || 'in');
    });

    stepBtn.addEventListener('click', () => {
      stepTraversal(currentOrder || 'in');
    });

    stopBtn.addEventListener('click', () => {
      stopTraversal();
      clearHighlights();
      setStatus('Traversal stopped.');
    });

    // keyboard: Enter in input triggers Insert by default
    valueInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        insertBtn.click();
      }
    });

    // Selection of traversal order via clicking the order buttons sets currentOrder
    document.querySelectorAll('.order-btn').forEach(b => {
      b.addEventListener('click', () => {
        currentOrder = b.getAttribute('data-order');
      });
    });

    // Helper: find node by id
    function nodeById(id) {
      // traverses tree to find node with id
      function find(n) { if (!n) return null; if (n.id === id) return n; return find(n.left) || find(n.right); }
      return find(root);
    }

    // Initialization: empty render
    layoutAndRender();
    setStatus('Empty tree. Tips: Insert a number (e.g., 50) and watch where it goes.');

    // Expose some helpers to global for debugging (optional)
    window._bst = {
      root,
      layoutAndRender,
      bstInsertSync,
      findNode
    };

  </script>
</body>
</html>