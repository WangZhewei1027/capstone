<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Two Pointers — Interactive Module</title>
  <style>
    :root{
      --safe-pad: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa7bf;
      --accent: #2dd4bf;
      --accent-2: #60a5fa;
      --success: #10b981;
      --danger: #ef4444;
      --card: #0d1726;
      --glass: rgba(255,255,255,0.03);
      --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#061026 0%, #071827 100%);
      color:#dbeafe;
      font-family:var(--font-sans);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Safe area padding 24px */
    .app{
      padding: var(--safe-pad);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      gap:var(--gap);
    }

    /* Layout: left info, right interactive module */
    .info {
      width: 360px;
      min-width: 280px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 18px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
      border:1px solid rgba(255,255,255,0.03);
    }

    .title{
      font-size:18px;
      font-weight:700;
      color:#fff;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .subtitle{
      font-size:13px;
      color:var(--muted);
    }
    .section{
      background: var(--glass);
      border-radius:10px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.02);
      font-size:13px;
      color:var(--muted);
      line-height:1.4;
    }
    .section h4{
      margin:0 0 8px 0;
      color:#e6eef8;
      font-size:13px;
    }

    /* Interactive panel */
    .panel{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      min-width:0;
    }

    .vis-card{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:16px;
      border:1px solid rgba(255,255,255,0.03);
    }

    /* Top controls row */
    .controls{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    .controls .group{
      display:flex;
      gap:12px;
      align-items:center;
    }

    label{
      font-size:13px;
      color:var(--muted);
    }
    input[type="text"], input[type="number"]{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color: #e6eef8;
      padding:8px 10px;
      border-radius:8px;
      min-width:120px;
    }
    input[type="text"]::placeholder{ color: rgba(255,255,255,0.25); }
    button{
      background: linear-gradient(90deg,var(--accent),var(--accent-2));
      color:#04212b;
      font-weight:600;
      border:0;
      padding:8px 12px;
      border-radius:10px;
      cursor:pointer;
      transition:transform .12s ease, box-shadow .12s ease;
    }
    button:active{ transform:translateY(1px) }
    .secondary{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      font-weight:600;
    }
    .muted-btn{
      background:transparent;
      border:1px dashed rgba(255,255,255,0.03);
      color:var(--muted);
    }

    /* Visualization area */
    .array-visual{
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .array-row{
      display:flex;
      gap:12px;
      align-items:flex-end;
      padding:12px;
      background: linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius:10px;
      min-height:120px;
      position:relative;
      overflow:hidden;
    }

    /* Boxes */
    .box{
      --w:60px;
      width:var(--w);
      min-width:44px;
      height:48px;
      background:rgba(255,255,255,0.03);
      border-radius:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#dbeafe;
      font-weight:700;
      position:relative;
      border:1px solid rgba(255,255,255,0.03);
      transition: transform .18s cubic-bezier(.2,.9,.2,1), background .18s, border-color .18s;
    }
    .box.small{ width:44px; height:40px; font-size:13px; }
    .box.highlight{ background: linear-gradient(90deg, rgba(45,212,191,0.12), rgba(96,165,250,0.08)); border-color: rgba(45,212,191,0.28); }
    .box.good{ box-shadow: 0 6px 20px rgba(16,185,129,0.08); border-color: rgba(16,185,129,0.3); background: linear-gradient(90deg, rgba(16,185,129,0.08), rgba(96,165,250,0.03)); }
    .box.bad{ box-shadow: 0 6px 20px rgba(239,68,68,0.06); border-color: rgba(239,68,68,0.28); background: linear-gradient(90deg, rgba(239,68,68,0.06), rgba(45,212,191,0.01)); }

    /* Pointers (floating labels) */
    .pointer{
      position:absolute;
      top:-28px;
      transform:translateX(0);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      transition:left .28s cubic-bezier(.2,.9,.2,1);
      pointer-events:auto;
      user-select:none;
    }
    .pointer .pin{
      width:44px;
      height:28px;
      border-radius:8px;
      background:rgba(255,255,255,0.03);
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--muted);
      font-weight:700;
      border:1px solid rgba(255,255,255,0.03);
    }
    .pointer.left .pin{ background: linear-gradient(90deg, rgba(45,212,191,0.12), rgba(45,212,191,0.06)); color:#0b2b26; border-color: rgba(45,212,191,0.22); }
    .pointer.right .pin{ background: linear-gradient(90deg, rgba(96,165,250,0.12), rgba(96,165,250,0.06)); color:#05243b; border-color: rgba(96,165,250,0.22); }
    .pointer .caret{
      width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:10px solid rgba(255,255,255,0.04);
    }
    .pointer.left .caret{ border-top-color: rgba(45,212,191,0.16); }
    .pointer.right .caret{ border-top-color: rgba(96,165,250,0.16); }

    /* Log and status */
    .status-row{
      display:flex;
      gap:16px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .status{
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:8px;
      align-items:center;
    }
    .status .pill{
      padding:6px 8px;
      border-radius:8px;
      font-weight:700;
      font-size:12px;
      background:rgba(255,255,255,0.02);
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.02);
    }

    .log{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      padding:10px;
      border-radius:8px;
      min-height:44px;
      font-size:13px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.02);
    }

    /* Responsive: collapse info on smaller screens */
    @media (max-width:960px){
      .app{ flex-direction:column; padding:18px; }
      .info{ width:100%; order:2; }
      .panel{ order:1; }
    }

    /* Accessibility focus */
    button:focus, input:focus{
      outline: 3px solid rgba(96,165,250,0.14);
      outline-offset:2px;
    }

    /* Small helper */
    .tiny{ font-size:12px; color:var(--muted); }
  </style>
</head>
<body>
  <div class="app" id="app">
    <!-- Info column with required sections -->
    <aside class="info" aria-labelledby="concept-title">
      <div>
        <div class="title" id="concept-title">Two Pointers — Pair Sum in Sorted Array</div>
        <div class="subtitle tiny">Visual, step-by-step exploration of how two pointers find a pair that sums to target.</div>
      </div>

      <div class="section" aria-live="polite">
        <h4>Learning Objective</h4>
        After interacting with this module you will:
        <ul style="margin:8px 0 0 18px; color:var(--muted);">
          <li>Understand the two-pointers technique for finding two numbers with a given sum in a sorted array.</li>
          <li>See how pointer decisions depend on comparisons (move left when sum is too small, move right when too large).</li>
          <li>Be able to step through or let the algorithm run and experiment by moving pointers manually.</li>
        </ul>
      </div>

      <div class="section" aria-hidden="false">
        <h4>Interaction Design</h4>
        - Type or paste numbers (comma/space-separated) into the array input and press Apply or Randomize.<br>
        - The array is automatically sorted (this technique requires a sorted array). The sorted array appears as boxes.<br>
        - Set a target sum. Use Play to auto-run, Step to move one comparison at a time, or Pause to stop.<br>
        - Drag the pointer pins above the boxes to manually explore state (left pointer cannot cross right pointer).<br>
        - Visual feedback: pointers slide smoothly, compared boxes highlight, and messages explain each decision (sum == target, < target, > target).<br>
      </div>

      <div class="section">
        <h4>Layout Description</h4>
        - Safe margins: 24px on all sides. Spacing between controls >= 16px to avoid crowded UI.<br>
        - Left column: explanatory text (this panel). Right/main column: interactive visualization and controls. Responsive: stacks vertically on narrow screens.<br>
        - Controls are grouped at top for quick access. Visual array sits mid-panel with pointer pins above. Log and status are below the array for step feedback.<br>
      </div>

      <div style="display:flex; gap:8px;">
        <button class="secondary" id="helpShort" aria-label="Short help">Quick tips</button>
        <button class="muted-btn" id="resetLayout" aria-label="Reset layout">Reset</button>
      </div>
    </aside>

    <!-- Interactive Panel -->
    <main class="panel" role="main">
      <div class="vis-card" aria-live="polite">
        <!-- Controls -->
        <div class="controls" role="region" aria-label="Controls">
          <div class="group" style="min-width:220px;">
            <label for="arrayInput" class="tiny">Array (comma / space separated)</label>
            <input id="arrayInput" type="text" placeholder="e.g. 1, 2, 3, 4, 5" aria-label="Array input" />
            <button id="applyBtn" title="Apply array">Apply</button>
            <button id="randomBtn" class="secondary" title="Randomize array">Randomize</button>
          </div>

          <div class="group">
            <label for="targetInput" class="tiny">Target</label>
            <input id="targetInput" type="number" value="7" aria-label="Target number" />
            <button id="stepBtn" class="secondary" title="Single step">Step</button>
            <button id="playBtn" title="Play / Pause">Play</button>
            <button id="backBtn" class="secondary" title="Step back">Back</button>
            <button id="resetBtn" class="muted-btn" title="Reset pointers">Reset</button>
          </div>

          <div class="group" style="margin-left:auto;">
            <label class="tiny" for="speedRange">Speed</label>
            <input id="speedRange" type="range" min="200" max="1500" value="700" step="100" aria-label="Animation speed" />
            <div style="text-align:right;">
              <div class="tiny">Status</div>
              <div id="statusPill" class="pill" style="padding:6px 10px; margin-top:6px;">Ready</div>
            </div>
          </div>
        </div>

        <!-- Visualization -->
        <div class="array-visual" role="region" aria-label="Array visualization">
          <div class="array-row" id="arrayRow">
            <!-- Boxes dynamically created here -->
            <!-- Pointer elements absolutely positioned -->
            <div id="pointerLeft" class="pointer left" role="slider" aria-label="Left pointer" tabindex="0">
              <div class="pin">L</div>
              <div class="caret"></div>
            </div>
            <div id="pointerRight" class="pointer right" role="slider" aria-label="Right pointer" tabindex="0">
              <div class="pin">R</div>
              <div class="caret"></div>
            </div>
          </div>

          <!-- Status and log -->
          <div class="status-row">
            <div class="status" id="calcStatus">
              <span class="tiny">Current sum:</span>
              <strong id="currentSum" style="color:#fff">—</strong>
            </div>
            <div class="log" id="log" aria-live="polite">Ready. Apply an array and press Step or Play.</div>
          </div>
        </div>
      </div>

      <!-- Extra small instruction footer -->
      <div style="display:flex; gap:12px; align-items:center; justify-content:space-between;">
        <div class="tiny" style="color:var(--muted)">Tip: You can drag L and R pins to any box to explore decisions manually.</div>
        <div class="tiny" style="color:var(--muted)">Requirement: array is sorted automatically for the algorithm.</div>
      </div>
    </main>
  </div>

  <script>
    /*
      Two Pointers Interactive Module
      - Implements a stepwise visualization of finding two numbers in a sorted array that sum to a target.
      - Controls: Apply array, Randomize, Step, Back, Play/Pause, Reset, Speed slider.
      - Drag pointers to explore manually (clamped so left < right).
      - Visual feedback: highlighted boxes, pointer animations, log messages, and current sum.
    */

    (function(){
      // Utility
      const $ = (s) => document.querySelector(s);
      const qs = (s) => document.querySelectorAll(s);

      // Elements
      const arrayInput = $('#arrayInput');
      const applyBtn = $('#applyBtn');
      const randomBtn = $('#randomBtn');
      const targetInput = $('#targetInput');
      const stepBtn = $('#stepBtn');
      const playBtn = $('#playBtn');
      const backBtn = $('#backBtn');
      const resetBtn = $('#resetBtn');
      const speedRange = $('#speedRange');
      const arrayRow = $('#arrayRow');
      const pointerL = $('#pointerLeft');
      const pointerR = $('#pointerRight');
      const logEl = $('#log');
      const currentSumEl = $('#currentSum');
      const statusPill = $('#statusPill');

      // Module state
      let arr = [1,2,3,4,5];      // sorted array
      let left = 0, right = arr.length - 1;
      let history = []; // each state: {left,right,desc,highlight}
      let playing = false;
      let playTimer = null;
      let found = false;
      let speed = Number(speedRange.value);
      let isDragging = null; // 'left'|'right'|null

      // Initialize
      function init(){
        arrayInput.value = arr.join(', ');
        targetInput.value = 7;
        buildArray();
        pushHistory('Initial state');
        updateUI();
        attachEvents();
      }

      // Parsing & applying array
      function parseArrayInput(text){
        if(!text || !text.trim()) return [];
        // split by comma or whitespace
        const parts = text.split(/[\s,]+/).filter(Boolean);
        const nums = parts.map(p => {
          const n = Number(p);
          return isFinite(n) ? n : NaN;
        });
        if(nums.some(isNaN)) return null;
        return nums;
      }

      function applyArrayFromInput(){
        const parsed = parseArrayInput(arrayInput.value);
        if(parsed === null){
          flashLog('Invalid input. Use numbers separated by spaces or commas.', true);
          return;
        }
        if(parsed.length < 2){
          flashLog('Enter at least two numbers.', true);
          return;
        }
        // Sort automatically (algorithm requires sorted input)
        arr = parsed.slice().sort((a,b)=>a-b);
        left = 0; right = arr.length - 1;
        found = false;
        buildArray();
        history = [];
        pushHistory('Array applied (sorted).');
        updateUI();
      }

      function randomizeArray(){
        const n = Math.floor(Math.random() * 6) + 5; // 5..10
        arr = Array.from({length:n}, () => Math.floor(Math.random()*20)+1).sort((a,b)=>a-b);
        arrayInput.value = arr.join(', ');
        left = 0; right = arr.length - 1;
        found = false;
        buildArray();
        history = [];
        pushHistory('Randomized array (sorted).');
        updateUI();
      }

      // Build array visuals
      function buildArray(){
        // clear existing boxes (keep pointer elements)
        Array.from(arrayRow.children).forEach(el=>{
          if(!el.classList || !el.classList.contains('box')) return;
          el.remove();
        });
        // create boxes
        arr.forEach((val, idx) => {
          const box = document.createElement('div');
          box.className = 'box';
          box.dataset.index = idx;
          box.textContent = String(val);
          box.setAttribute('role','button');
          box.setAttribute('tabindex','0');
          box.setAttribute('aria-label', `Index ${idx}, value ${val}`);
          box.style.transition = 'transform .18s ease, background .18s ease';
          arrayRow.appendChild(box);
          // click to focus pointer to this index
          box.addEventListener('click', ()=> {
            // default: set left pointer if left clicked area, else set right
            // but choose nearest pointer
            const midpoint = (left + right)/2;
            if(idx <= midpoint) setLeft(idx, 'manual');
            else setRight(idx, 'manual');
          });
        });

        // reposition pointers visually
        positionPointers();
      }

      // Position pointer elements above the corresponding box
      function positionPointers(){
        const boxes = arrayRow.querySelectorAll('.box');
        if(boxes.length === 0) return;
        // ensure left & right are in-range
        left = Math.max(0, Math.min(left, arr.length-1));
        right = Math.max(0, Math.min(right, arr.length-1));
        // get bounding rects relative to arrayRow
        const rowRect = arrayRow.getBoundingClientRect();
        function leftBoxRect(i){
          const b = boxes[i].getBoundingClientRect();
          return {left: b.left - rowRect.left + (b.width/2), width:b.width};
        }
        const lb = leftBoxRect(left);
        const rb = leftBoxRect(right);

        pointerL.style.left = (lb.left - 22) + 'px'; // center pin (pin width ~44)
        pointerR.style.left = (rb.left - 22) + 'px';
      }

      // Update UI: highlight, sums, log update
      function updateUI(desc){
        // update current sum display if pointers valid
        let sum = '—';
        if(arr.length >= 2 && left >= 0 && right >= 0 && left < arr.length && right < arr.length){
          sum = arr[left] + arr[right];
        }
        currentSumEl.textContent = sum;

        // clear previous box highlights
        arrayRow.querySelectorAll('.box').forEach(b => {
          b.classList.remove('highlight','good','bad');
        });

        // highlight compared boxes unless finished
        if(!found && left < right){
          const lbox = arrayRow.querySelector('.box[data-index="'+left+'"]');
          const rbox = arrayRow.querySelector('.box[data-index="'+right+'"]');
          if(lbox) lbox.classList.add('highlight');
          if(rbox) rbox.classList.add('highlight');
        } else if(found){
          // mark the found boxes good
          const lbox = arrayRow.querySelector('.box[data-index="'+left+'"]');
          const rbox = arrayRow.querySelector('.box[data-index="'+right+'"]');
          if(lbox) lbox.classList.add('good');
          if(rbox) rbox.classList.add('good');
        } else {
          // pointers crossed — no result
          // mark all boxes neutral
        }

        positionPointers();

        // update status pill
        if(found){
          statusPill.textContent = 'Found';
          statusPill.style.background = 'linear-gradient(90deg, rgba(16,185,129,0.12), rgba(96,165,250,0.06))';
          statusPill.style.color = '#dffaf1';
        } else if(left >= right){
          statusPill.textContent = 'No pair';
          statusPill.style.background = 'linear-gradient(90deg, rgba(239,68,68,0.06), rgba(255,255,255,0.01))';
          statusPill.style.color = '#ffdede';
        } else {
          statusPill.textContent = 'Running';
          statusPill.style.background = 'linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01))';
          statusPill.style.color = '#dbeafe';
        }

        if(desc) {
          flashLog(desc);
        }
      }

      function flashLog(message, isError=false){
        logEl.textContent = message;
        if(isError){
          logEl.style.borderColor = 'rgba(239,68,68,0.2)';
          logEl.style.color = '#ffdede';
          setTimeout(()=>{ logEl.style.borderColor = 'rgba(255,255,255,0.02)'; logEl.style.color = 'var(--muted)'; }, 2000);
        }
      }

      // History management
      function pushHistory(desc){
        history.push({left, right, desc, arr: arr.slice()});
        // cap history to 500 steps
        if(history.length > 500) history.shift();
      }

      function restoreHistory(idx){
        if(idx < 0 || idx >= history.length) return;
        const st = history[idx];
        left = st.left; right = st.right;
        updateUI(st.desc);
      }

      function stepForward(){
        if(found || left >= right){
          // already done
          if(left >= right) {
            pushHistory('Pointers crossed — target not found.');
            updateUI('Pointers crossed — target not found.');
          } else {
            updateUI('Target already found.');
          }
          stopPlaying();
          return;
        }
        // record before comparison
        const a = arr[left], b = arr[right];
        const sum = a + b;
        let desc = `Compare arr[${left}]=${a} and arr[${right}]=${b} → sum=${sum}. `;
        if(sum === Number(targetInput.value)){
          found = true;
          desc += 'Sum equals target. Pair found.';
          pushHistory(desc);
          updateUI(desc);
          stopPlaying();
          return;
        } else if(sum < Number(targetInput.value)){
          desc += 'Sum is less than target → move left pointer right (L++).';
          pushHistory(desc);
          left++;
          updateUI(desc);
          return;
        } else {
          desc += 'Sum is greater than target → move right pointer left (R--).';
          pushHistory(desc);
          right--;
          updateUI(desc);
          return;
        }
      }

      function stepBack(){
        // can't go past initial
        if(history.length <= 1) {
          flashLog('No previous step to go back to.');
          return;
        }
        // pop last; restore previous
        history.pop();
        const prev = history[history.length-1];
        left = prev.left; right = prev.right; found = false;
        updateUI('Stepped back: ' + (prev.desc||'state restored.'));
      }

      // Play / Pause
      function startPlaying(){
        if(playing) return;
        playing = true;
        playBtn.textContent = 'Pause';
        speed = Number(speedRange.value);
        playTimer = setInterval(()=>{
          // when playing, call step forward until finish
          stepForward();
          if(found || left >= right) stopPlaying();
        }, Math.max(120, speed));
      }
      function stopPlaying(){
        playing = false;
        playBtn.textContent = 'Play';
        if(playTimer) { clearInterval(playTimer); playTimer = null; }
      }

      // Reset pointers
      function resetPointers(){
        left = 0; right = arr.length - 1;
        found = false;
        pushHistory('Pointers reset to start/end.');
        updateUI('Pointers reset.');
        stopPlaying();
      }

      // Pointer setters (called by drag or clicks)
      function setLeft(idx, origin){
        idx = Math.max(0, Math.min(idx, arr.length-2)); // left must be < right
        if(idx >= right) idx = right - 1;
        left = idx;
        found = false;
        pushHistory('Left pointer moved ('+origin+').');
        updateUI('Left moved to index ' + left + ' (value ' + arr[left] + ').');
      }
      function setRight(idx, origin){
        idx = Math.max(1, Math.min(idx, arr.length-1));
        if(idx <= left) idx = left + 1;
        right = idx;
        found = false;
        pushHistory('Right pointer moved ('+origin+').');
        updateUI('Right moved to index ' + right + ' (value ' + arr[right] + ').');
      }

      // Attach events
      function attachEvents(){
        // Apply / Random
        applyBtn.addEventListener('click', applyArrayFromInput);
        randomBtn.addEventListener('click', randomizeArray);

        // Step / Back / Play / Reset
        stepBtn.addEventListener('click', ()=> {
          stopPlaying();
          stepForward();
        });
        backBtn.addEventListener('click', ()=> {
          stopPlaying();
          stepBack();
        });
        playBtn.addEventListener('click', ()=> {
          if(playing) stopPlaying(); else startPlaying();
        });
        resetBtn.addEventListener('click', ()=> {
          resetPointers();
        });

        // Speed change
        speedRange.addEventListener('input', ()=> {
          speed = Number(speedRange.value);
          if(playing){
            stopPlaying();
            startPlaying();
          }
        });

        // window resize reposition pointers
        window.addEventListener('resize', ()=> {
          positionPointers();
        });

        // Dragging pointers (pointer events)
        [pointerL, pointerR].forEach(pin=>{
          pin.addEventListener('pointerdown', (ev)=>{
            ev.preventDefault();
            pin.setPointerCapture(ev.pointerId);
            isDragging = pin === pointerL ? 'left' : 'right';
          });
        });

        // Listen on arrayRow for pointermove while dragging
        arrayRow.addEventListener('pointermove', (ev)=>{
          if(!isDragging) return;
          // find nearest box center
          const boxes = Array.from(arrayRow.querySelectorAll('.box'));
          if(boxes.length === 0) return;
          const rowRect = arrayRow.getBoundingClientRect();
          const x = ev.clientX - rowRect.left;
          // find box with center nearest to x
          let bestIdx = 0;
          let bestDist = Infinity;
          boxes.forEach((b, i)=>{
            const br = b.getBoundingClientRect();
            const center = br.left - rowRect.left + br.width/2;
            const d = Math.abs(center - x);
            if(d < bestDist){ bestDist = d; bestIdx = i; }
          });
          if(isDragging === 'left'){
            // clamp so left < right
            const desired = Math.min(bestIdx, right-1);
            setLeft(desired, 'drag');
          } else {
            const desired = Math.max(bestIdx, left+1);
            setRight(desired, 'drag');
          }
        });

        // pointer up on row -> stop drag
        ['pointerup','pointercancel','pointerleave'].forEach(evt=>{
          arrayRow.addEventListener(evt, ()=>{
            if(isDragging){
              isDragging = null;
              // finalize state
              pushHistory('Manual pointer placement.');
            }
          });
        });

        // Keyboard support: arrow keys to move focused pointer
        pointerL.addEventListener('keydown', (ev)=>{
          if(ev.key === 'ArrowRight'){ ev.preventDefault(); setLeft(Math.min(left+1, arr.length-2),'keyboard'); }
          if(ev.key === 'ArrowLeft'){ ev.preventDefault(); setLeft(Math.max(left-1,0),'keyboard'); }
        });
        pointerR.addEventListener('keydown', (ev)=>{
          if(ev.key === 'ArrowLeft'){ ev.preventDefault(); setRight(Math.max(right-1, left+1),'keyboard'); }
          if(ev.key === 'ArrowRight'){ ev.preventDefault(); setRight(Math.min(right+1,arr.length-1),'keyboard'); }
        });

        // Quick help / reset layout
        $('#helpShort').addEventListener('click', ()=> {
          alert('Tips:\n- Apply an array and a target.\n- Use Step to move one comparison.\n- Play runs automatically.\n- Drag L and R pins to explore.');
        });
        $('#resetLayout').addEventListener('click', ()=>{
          // simple visual reset: collapse to defaults
          arr = [1,2,3,4,5];
          arrayInput.value = arr.join(', ');
          targetInput.value = 7;
          left = 0; right = arr.length - 1;
          history = [];
          found = false;
          buildArray();
          pushHistory('Layout reset.');
          updateUI('Layout reset to defaults.');
          stopPlaying();
        });

        // initial apply if user types enter on array input
        arrayInput.addEventListener('keydown', (ev)=>{
          if(ev.key === 'Enter') applyArrayFromInput();
        });
        targetInput.addEventListener('keydown', (ev)=>{
          if(ev.key === 'Enter') { stopPlaying(); pushHistory('Target changed to ' + targetInput.value); updateUI('Target set to ' + targetInput.value); }
        });
      }

      // Initialize visuals after DOM ready
      window.addEventListener('load', ()=>{
        init();
      });

      // expose nothing globally
    })();
  </script>
</body>
</html>