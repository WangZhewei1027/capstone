<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Adjacency List — Interactive Module</title>
  <style>
    /* Safe area margins */
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #6ee7b7;
      --muted: #94a3b8;
      --card: #0b1220;
      --danger: #ff7b7b;
      --glass: rgba(255,255,255,0.03);
      --focus: 3px solid rgba(110,231,183,0.18);
      --max-width: 1200px;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071022 0%, #071827 100%);
      color: #e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }
    .container {
      width:100%;
      max-width: var(--max-width);
      display:flex;
      gap: var(--gap);
    }

    /* Left: canvas, Right: controls */
    .left {
      flex: 1 1 0;
      min-width: 320px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius: 12px;
      padding: 16px;
      box-sizing: border-box;
      min-height: 560px;
      position: relative;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .canvas-wrap {
      flex: 1 1 0;
      background: radial-gradient(ellipse at 10% 10%, rgba(110,231,183,0.02), transparent 10%),
                  radial-gradient(ellipse at 90% 90%, rgba(99,102,241,0.02), transparent 10%),
                  var(--bg);
      border-radius: 8px;
      position: relative;
      overflow: hidden;
      padding: 12px;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
      min-height: 420px;
    }
    svg#graph {
      width:100%;
      height:100%;
      display:block;
      cursor: crosshair;
      touch-action: none;
    }
    .top-bar {
      display:flex;
      gap: var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    .button {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      color: var(--accent);
      padding: 8px 12px;
      border-radius: 8px;
      cursor:pointer;
      font-weight:600;
      min-height:40px;
    }
    .button.secondary {
      color:var(--muted);
      background:transparent;
      border:1px solid rgba(255,255,255,0.02);
      font-weight:500;
    }
    .button.danger {
      color:var(--card);
      background:var(--danger);
      border:none;
    }
    .control {
      display:flex;
      gap:8px;
      align-items:center;
      color:var(--muted);
      font-size:14px;
    }
    label.switch {
      display:inline-flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      user-select:none;
      color:var(--muted);
    }
    .pill {
      display:inline-flex;
      gap:8px;
      align-items:center;
      background:var(--glass);
      padding:6px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.02);
      color:var(--muted);
      font-size:13px;
    }

    /* Right panel */
    .right {
      width:360px;
      min-width: 260px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 12px;
      border:1px solid rgba(255,255,255,0.03);
      box-sizing:border-box;
    }
    .card h3 {
      margin:0 0 8px 0;
      font-size:15px;
      color:var(--accent);
    }
    .muted {
      color:var(--muted);
      font-size:13px;
      line-height:1.3;
    }
    .controls-grid {
      display:flex;
      gap:12px;
      align-items:center;
    }
    input[type="number"], input[type="text"], select {
      background:transparent;
      color:var(--accent);
      border:1px solid rgba(255,255,255,0.03);
      padding:8px 10px;
      border-radius:8px;
      min-width:80px;
      font-weight:600;
      outline:none;
    }
    input[type="text"]::placeholder { color: rgba(230,238,246,0.25); }
    .adj-list {
      margin:0;
      padding:8px;
      list-style:none;
      background:rgba(0,0,0,0.02);
      border-radius:8px;
      max-height:240px;
      overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
      font-size:13px;
      color:#cfeee1;
    }
    .adj-list li {
      padding:6px 8px;
      border-bottom:1px dashed rgba(255,255,255,0.02);
      display:flex;
      justify-content:space-between;
      gap:8px;
    }
    .adj-list li:last-child { border-bottom:none; }
    .adj-entry {
      color:var(--muted);
      font-size:13px;
    }
    .copy-btn {
      padding:6px 8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      background:transparent;
      color:var(--muted);
      cursor:pointer;
      font-size:13px;
    }

    /* Node style */
    .node {
      fill: linear-gradient(180deg, #4ade80, #34d399);
      stroke: rgba(255,255,255,0.06);
      stroke-width: 1.5px;
      cursor:pointer;
    }
    .node circle {
      transition: r 0.12s ease, stroke 0.12s ease, filter 0.12s ease;
    }
    .node text {
      pointer-events:none;
      user-select:none;
      font-weight:700;
      fill: #071827;
      font-size:12px;
    }
    .node.selected circle {
      stroke: url(#glow);
      filter: drop-shadow(0 6px 18px rgba(110,231,183,0.12));
    }
    .edge {
      stroke: rgba(255,255,255,0.04);
      stroke-width: 2;
      fill:none;
      marker-end: url(#arrow);
      transition: stroke 0.12s ease, stroke-dashoffset 0.6s ease;
    }
    .edge.animated {
      stroke: #6ee7b7;
      stroke-dasharray: 1000;
      stroke-dashoffset: 1000;
    }
    .edge.highlight {
      stroke: #60a5fa;
      stroke-width: 3.5;
    }
    .node-label {
      font-size:12px;
      fill:#dbeafe;
      font-weight:700;
      pointer-events:none;
      text-anchor:middle;
      dominant-baseline:middle;
    }
    .tooltip {
      position:absolute;
      background:rgba(255,255,255,0.05);
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      color:var(--muted);
      pointer-events:none;
      transform:translate(-50%,-120%);
      display:none;
      border:1px solid rgba(255,255,255,0.02);
    }

    /* Module info */
    .info {
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .info .row {
      display:flex;
      gap:12px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .info .block {
      background:rgba(255,255,255,0.02);
      padding:10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
      color:var(--muted);
      font-size:13px;
      flex:1 1 200px;
    }

    /* Small screens */
    @media (max-width: 920px) {
      .container {
        flex-direction:column;
      }
      .right { width:100%; }
      .left { min-height: 520px; }
    }

    /* Focus states for accessibility */
    .button:focus, .copy-btn:focus, input:focus, select:focus, .node:focus {
      outline: none;
      box-shadow: var(--focus);
      border-radius: 8px;
    }

    /* minimum spacing rule: ensure interactive elements have margin */
    .button, .copy-btn, input, select, .pill {
      margin: 8px 0;
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-labelledby="title">
    <div class="container" style="width:100%;">
      <div class="left card" style="padding:12px;">
        <div class="top-bar" aria-hidden="false">
          <div style="display:flex; gap:12px; align-items:center;">
            <button id="mode-add-node" class="button" title="Add Node (click canvas or button)">Add Node</button>
            <button id="mode-add-edge" class="button secondary" title="Add Edge (click source then target)">Add Edge</button>
            <button id="mode-select" class="button secondary" title="Select / Move nodes">Select / Move</button>
          </div>

          <div style="flex:1"></div>

          <label class="pill" title="Toggle directed/undirected graph">
            <input id="directed" type="checkbox" style="accent-color:#6ee7b7;" />
            Directed
          </label>

          <div class="control">
            <label style="color:var(--muted); font-size:13px;">Weight</label>
            <input id="edge-weight" type="text" placeholder="optional" aria-label="edge weight" />
          </div>

          <button id="clear-btn" class="button secondary" title="Clear graph" style="margin-left:8px;">Clear</button>
        </div>

        <div class="canvas-wrap" id="canvasWrap">
          <svg id="graph" tabindex="0" aria-label="Graph canvas">
            <defs>
              <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#6ee7b7"></path>
              </marker>
              <linearGradient id="gradNode" x1="0" x2="0" y1="0" y2="1">
                <stop offset="0%" stop-color="#4ade80" />
                <stop offset="100%" stop-color="#34d399" />
              </linearGradient>
              <filter id="blurGlow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="6" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            <!-- edges and nodes will be injected here -->
          </svg>

          <div class="tooltip" id="tooltip" role="tooltip" aria-hidden="true">Tooltip</div>
        </div>

        <div style="display:flex; gap:12px; align-items:center; margin-top:8px;">
          <div style="color:var(--muted); font-size:13px;">Instructions:</div>
          <div style="color:var(--muted); font-size:13px;">
            - Click "Add Node" then click canvas to place nodes (or click the button to add at center).<br>
            - Switch to "Add Edge" and click source then target. Toggle "Directed" for directed edges. Optional weight in the Weight box.<br>
            - Use "Select / Move" to drag nodes. Click a node to highlight adjacency.
          </div>
        </div>
      </div>

      <div class="right" role="complementary" aria-label="Controls and adjacency list">
        <div class="card">
          <h3 id="title">Adjacency List — Interactive Module</h3>
          <div class="muted">
            Build a small graph visually and watch its adjacency list representation update in real time.
          </div>
        </div>

        <div class="card" aria-live="polite">
          <h3>Controls</h3>
          <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <button id="btn-add" class="button">Add Node</button>
            <button id="btn-edge" class="button secondary">Add Edge</button>
            <button id="btn-select" class="button secondary">Select / Move</button>
            <button id="btn-delete" class="button secondary" title="Delete selected node/edge">Delete</button>
            <button id="btn-export" class="button" title="Copy adjacency JSON">Copy Adjacency JSON</button>
          </div>
          <div style="height:8px;"></div>
          <div class="muted">Tip: Click a node in the adjacency list to highlight it in the canvas.</div>
        </div>

        <div class="card" aria-live="polite">
          <h3>Adjacency List</h3>
          <div class="muted" style="margin-bottom:8px;">Representation: node -> [neighbors]. For weighted graphs, weights appear in parentheses.</div>
          <ul id="adjList" class="adj-list" role="list"></ul>
          <div style="display:flex; gap:8px; margin-top:10px;">
            <button id="copyAdj" class="copy-btn">Copy as text</button>
            <button id="resetPositions" class="copy-btn">Reset Positions</button>
          </div>
        </div>

        <div class="card info" aria-hidden="false">
          <h3 style="margin:0; color:var(--accent);">Module Guide</h3>
          <div class="row">
            <div class="block">
              <strong>Concept Title</strong>
              <div class="muted" style="margin-top:6px;">Adjacency List — a common graph representation mapping each node to its neighbors.</div>
            </div>
            <div class="block">
              <strong>Learning Objective</strong>
              <div class="muted" style="margin-top:6px;">
                After interacting, you should be able to: construct small graphs visually and read their adjacency lists (including directed vs undirected and optional weights).
              </div>
            </div>
          </div>
          <div class="row" style="margin-top:6px;">
            <div class="block" style="flex-basis:100%;">
              <strong>Interaction Design</strong>
              <div class="muted" style="margin-top:6px;">
                Modes: Add Node, Add Edge, Select/Move. Click canvas to place nodes (or use Add Node button). In Add Edge mode, click a source node then a target node to create an edge; weight is optional. The adjacency list updates immediately. Selecting a node highlights its edges and neighbors. Dragging a node updates edges in real time. Animations show edge drawing and highlights to provide visual feedback.
              </div>
            </div>
          </div>
          <div class="row" style="margin-top:6px;">
            <div class="block" style="flex-basis:100%;">
              <strong>Layout Description</strong>
              <div class="muted" style="margin-top:6px;">
                Left: interactive SVG canvas (graph). Right: controls, adjacency list, and module guide. Safe margins: 24px; minimum spacing between interactive elements: 16px. Responsive layout stacks on small screens. Keyboard focus and aria labels are provided for accessibility.
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <script>
    /**************************************************************************
     * Adjacency List Interactive Module
     * - Vanilla JS, self-contained
     * - Features:
     *   * Add nodes by clicking canvas or button
     *   * Create edges in Add Edge mode (optionally weighted)
     *   * Directed toggle: controls adjacency direction
     *   * Drag nodes to reposition; edges update live
     *   * Real-time adjacency list text, copy/export
     *   * Visual feedback: edge draw animation, highlights, tooltip
     **************************************************************************/

    // DOM elements
    const svg = document.getElementById('graph');
    const canvasWrap = document.getElementById('canvasWrap');
    const tooltip = document.getElementById('tooltip');
    const adjListEl = document.getElementById('adjList');

    const btnAdd = document.getElementById('btn-add');
    const btnEdge = document.getElementById('btn-edge');
    const btnSelect = document.getElementById('btn-select');
    const btnDelete = document.getElementById('btn-delete');
    const btnExport = document.getElementById('btn-export');
    const copyAdj = document.getElementById('copyAdj');
    const resetPositions = document.getElementById('resetPositions');

    const modeAddNode = document.getElementById('mode-add-node');
    const modeAddEdge = document.getElementById('mode-add-edge');
    const modeSelect = document.getElementById('mode-select');

    const directedCheckbox = document.getElementById('directed');
    const edgeWeightInput = document.getElementById('edge-weight');
    const clearBtn = document.getElementById('clear-btn');

    // Mode state: 'add-node', 'add-edge', 'select'
    let mode = 'add-node';
    function setMode(m) {
      mode = m;
      [modeAddNode, modeAddEdge, modeSelect].forEach(btn => btn.classList.add('secondary'));
      if (m === 'add-node') modeAddNode.classList.remove('secondary');
      if (m === 'add-edge') modeAddEdge.classList.remove('secondary');
      if (m === 'select') modeSelect.classList.remove('secondary');

      [btnAdd, btnEdge, btnSelect].forEach(b=>b.classList.add('secondary'));
      if (m === 'add-node') btnAdd.classList.remove('secondary');
      if (m === 'add-edge') btnEdge.classList.remove('secondary');
      if (m === 'select') btnSelect.classList.remove('secondary');
    }
    setMode('add-node');

    modeAddNode.addEventListener('click', ()=>setMode('add-node'));
    modeAddEdge.addEventListener('click', ()=>setMode('add-edge'));
    modeSelect.addEventListener('click', ()=>setMode('select'));

    btnAdd.addEventListener('click', ()=>setMode('add-node'));
    btnEdge.addEventListener('click', ()=>setMode('add-edge'));
    btnSelect.addEventListener('click', ()=>setMode('select'));

    // Data structures
    const nodes = []; // {id, label, x, y, elemGroup}
    const edges = []; // {id, from, to, weight, lineElem}
    const adjacency = new Map(); // id -> [{to, weight}, ...]
    let nodeCounter = 0;
    let edgeCounter = 0;

    // Selection state for adding edges
    let pendingEdgeSource = null;
    let selectedNode = null;
    let selectedEdge = null;

    // Helper: SVG namespace
    const SVG_NS = 'http://www.w3.org/2000/svg';

    // Utility: get SVG point from client coords
    function svgPoint(clientX, clientY) {
      const pt = svg.createSVGPoint();
      pt.x = clientX;
      pt.y = clientY;
      const ctm = svg.getScreenCTM();
      return pt.matrixTransform(ctm.inverse());
    }

    // Create a node at SVG coordinates
    function createNodeAt(x, y, label = null) {
      const id = 'n' + (++nodeCounter);
      const nodeLabel = label || id.toUpperCase();

      // Group to hold circle and label
      const g = document.createElementNS(SVG_NS, 'g');
      g.setAttribute('class', 'node');
      g.setAttribute('role', 'button');
      g.setAttribute('tabindex', '0');
      g.dataset.id = id;

      // Circle
      const circle = document.createElementNS(SVG_NS, 'circle');
      circle.setAttribute('cx', x);
      circle.setAttribute('cy', y);
      circle.setAttribute('r', 20);
      circle.setAttribute('fill', 'url(#gradNode)');
      circle.setAttribute('stroke', 'rgba(255,255,255,0.06)');

      // Label
      const text = document.createElementNS(SVG_NS, 'text');
      text.setAttribute('x', x);
      text.setAttribute('y', y);
      text.setAttribute('class', 'node-label');
      text.textContent = nodeLabel;

      g.appendChild(circle);
      g.appendChild(text);
      svg.appendChild(g);

      // Add to data
      nodes.push({ id, label: nodeLabel, x, y, g, circle, text });
      adjacency.set(id, []);

      // Bind events
      bindNodeEvents(g);

      updateAdjList();
      return id;
    }

    // Bind pointer and keyboard events for node group
    function bindNodeEvents(g) {
      const id = g.dataset.id;
      const node = nodes.find(n => n.id === id);
      let dragging = false;
      let dragOffset = { x: 0, y: 0 };

      // Pointer down => depending on mode act
      g.addEventListener('pointerdown', (ev) => {
        ev.stopPropagation();
        g.setPointerCapture(ev.pointerId);
        if (mode === 'add-edge') {
          if (!pendingEdgeSource) {
            pendingEdgeSource = id;
            highlightNode(id, true);
            showTooltip(ev.clientX, ev.clientY, 'Source selected: ' + node.label);
          } else if (pendingEdgeSource === id) {
            // clicking same node cancels
            highlightNode(pendingEdgeSource, false);
            pendingEdgeSource = null;
            hideTooltip();
          } else {
            // create edge from pendingEdgeSource -> id
            const weight = edgeWeightInput.value.trim();
            createEdge(pendingEdgeSource, id, weight || null, directedCheckbox.checked);
            highlightNode(pendingEdgeSource, false);
            pendingEdgeSource = null;
            hideTooltip();
          }
        } else if (mode === 'select') {
          // start drag
          dragging = true;
          selectedNode = id;
          selectedEdge = null;
          markSelection();
          const pt = svgPoint(ev.clientX, ev.clientY);
          dragOffset = { x: node.x - pt.x, y: node.y - pt.y };
        } else if (mode === 'add-node') {
          // Quick add behavior: clicking node while in add-node makes a new node near it
          const newPos = { x: node.x + 60, y: node.y + 0 };
          const newId = createNodeAt(newPos.x, newPos.y);
          // small pulse animation on new node
          pulseNode(newId);
        }
      });

      // pointer move for drag
      g.addEventListener('pointermove', (ev) => {
        if (!dragging) return;
        ev.preventDefault();
        const pt = svgPoint(ev.clientX, ev.clientY);
        const nx = pt.x + dragOffset.x;
        const ny = pt.y + dragOffset.y;
        node.x = nx;
        node.y = ny;
        node.circle.setAttribute('cx', nx);
        node.circle.setAttribute('cy', ny);
        node.text.setAttribute('x', nx);
        node.text.setAttribute('y', ny);
        updateEdgesForNode(id);
      });

      // pointer up
      g.addEventListener('pointerup', (ev) => {
        if (dragging) {
          dragging = false;
          g.releasePointerCapture(ev.pointerId);
        } else {
          // click without drag: select node (show adjacency)
          selectedNode = id;
          selectedEdge = null;
          markSelection();
        }
      });

      // keyboard accessibility: Enter to select/highlight or start edge
      g.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          if (mode === 'add-edge') {
            if (!pendingEdgeSource) {
              pendingEdgeSource = id;
              highlightNode(id, true);
            } else if (pendingEdgeSource === id) {
              highlightNode(pendingEdgeSource, false);
              pendingEdgeSource = null;
            } else {
              const weight = edgeWeightInput.value.trim();
              createEdge(pendingEdgeSource, id, weight || null, directedCheckbox.checked);
              highlightNode(pendingEdgeSource, false);
              pendingEdgeSource = null;
            }
          } else {
            selectedNode = id;
            markSelection();
          }
        } else if (ev.key === 'Delete' || ev.key === 'Backspace') {
          deleteNode(id);
        }
      });

      // hover behavior for tooltip and highlights
      g.addEventListener('pointerenter', (ev) => {
        showTooltipAtNode(id, node.label);
        highlightNodeEdges(id, true);
      });
      g.addEventListener('pointerleave', (ev) => {
        hideTooltip();
        highlightNodeEdges(id, false);
      });
    }

    // Create an edge between two node ids
    function createEdge(fromId, toId, weight = null, directed = true) {
      // Prevent duplicate in same direction
      if (edges.some(e => e.from === fromId && e.to === toId && (e.weight || '') === (weight || ''))) {
        flashNode(fromId);
        flashNode(toId);
        return;
      }

      // Add to adjacency
      adjacency.get(fromId).push({ to: toId, weight });
      if (!directed) {
        adjacency.get(toId).push({ to: fromId, weight });
      }

      // Visual line
      const fromNode = nodes.find(n => n.id === fromId);
      const toNode = nodes.find(n => n.id === toId);
      const id = 'e' + (++edgeCounter);

      const line = document.createElementNS(SVG_NS, 'path');
      line.setAttribute('class', 'edge animated');
      line.setAttribute('data-id', id);
      // initial path
      updateEdgePath(line, fromNode.x, fromNode.y, toNode.x, toNode.y);

      // if undirected, no arrow; if directed, use marker-end
      if (!directed) {
        line.removeAttribute('marker-end');
      } else {
        line.setAttribute('marker-end', 'url(#arrow)');
      }

      svg.insertBefore(line, svg.firstChild); // put edges below nodes
      edges.push({ id, from: fromId, to: toId, weight, line });

      // animate stroke dashoffset -> 0 to simulate drawing
      requestAnimationFrame(() => {
        line.classList.remove('animated');
        // force reflow
        void line.getBoundingClientRect();
        line.classList.add('animated');
        // animate from offset to 0
        line.style.transition = 'stroke-dashoffset 0.6s ease';
        line.style.strokeDashoffset = '0';
      });

      // bind hover events
      line.addEventListener('pointerenter', () => {
        line.classList.add('highlight');
      });
      line.addEventListener('pointerleave', () => {
        line.classList.remove('highlight');
      });
      line.addEventListener('click', (ev) => {
        ev.stopPropagation();
        selectedEdge = id;
        selectedNode = null;
        markSelection();
      });

      updateAdjList();
    }

    // Update a path element to connect two points (curved)
    function updateEdgePath(pathElem, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const dr = Math.hypot(dx, dy) * 0.6;
      // simple quadratic bezier for a nice curve
      const mx = x1 + dx / 2;
      const my = y1 + dy / 2;
      const nx = mx - dy * 0.2;
      const ny = my + dx * 0.2;
      const d = `M ${x1} ${y1} Q ${nx} ${ny} ${x2} ${y2}`;
      pathElem.setAttribute('d', d);
    }

    // Update all edges connected to a node
    function updateEdgesForNode(nodeId) {
      edges.forEach(e => {
        if (e.from === nodeId || e.to === nodeId) {
          const fromNode = nodes.find(n => n.id === e.from);
          const toNode = nodes.find(n => n.id === e.to);
          updateEdgePath(e.line, fromNode.x, fromNode.y, toNode.x, toNode.y);
        }
      });
    }

    // Update adjacency list DOM
    function updateAdjList() {
      // Clear
      while (adjListEl.firstChild) adjListEl.removeChild(adjListEl.firstChild);

      // For deterministic order, use nodes order
      nodes.forEach(n => {
        const li = document.createElement('li');
        li.setAttribute('data-id', n.id);
        li.tabIndex = 0;
        li.setAttribute('role', 'listitem');

        const title = document.createElement('div');
        title.style.fontWeight = '700';
        title.style.color = '#e6fff0';
        title.textContent = n.label;

        const entry = document.createElement('div');
        entry.className = 'adj-entry';

        const neighbors = adjacency.get(n.id) || [];
        if (neighbors.length === 0) {
          entry.textContent = '∅';
        } else {
          entry.textContent = neighbors.map(nb => {
            return nb.weight ? `${labelFor(nb.to)}(${nb.weight})` : labelFor(nb.to);
          }).join(', ');
        }

        li.appendChild(title);
        li.appendChild(entry);

        // click focus node in SVG
        li.addEventListener('click', () => {
          selectedNode = n.id;
          selectedEdge = null;
          markSelection();
          // center spotlight
          pulseNode(n.id);
        });

        li.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter' || ev.key === ' ') {
            ev.preventDefault();
            li.click();
          }
        });

        adjListEl.appendChild(li);
      });
    }

    // Helpers
    function labelFor(id) {
      const n = nodes.find(x => x.id === id);
      return n ? n.label : id;
    }

    function showTooltip(clientX, clientY, text) {
      tooltip.style.display = 'block';
      tooltip.innerText = text;
      tooltip.style.left = (clientX - canvasWrap.getBoundingClientRect().left) + 'px';
      tooltip.style.top = (clientY - canvasWrap.getBoundingClientRect().top) + 'px';
      tooltip.setAttribute('aria-hidden', 'false');
    }
    function showTooltipAtNode(id, text) {
      const n = nodes.find(x => x.id === id);
      if (!n) return;
      const bbox = canvasWrap.getBoundingClientRect();
      const screenPt = svg.createSVGPoint();
      screenPt.x = n.x; screenPt.y = n.y;
      const ctm = svg.getScreenCTM();
      const pt = screenPt.matrixTransform(ctm);
      tooltip.style.left = (pt.x - bbox.left) + 'px';
      tooltip.style.top = (pt.y - bbox.top) + 'px';
      tooltip.innerText = text;
      tooltip.style.display = 'block';
      tooltip.setAttribute('aria-hidden', 'false');
    }
    function hideTooltip() {
      tooltip.style.display = 'none';
      tooltip.setAttribute('aria-hidden', 'true');
    }

    function highlightNode(id, bool) {
      const g = svg.querySelector(`g.node[data-id="${id}"]`);
      if (!g) return;
      if (bool) g.classList.add('selected'); else g.classList.remove('selected');
    }

    // highlight edges connected to a node
    function highlightNodeEdges(id, on) {
      edges.forEach(e => {
        if (e.from === id || e.to === id) {
          if (on) e.line.classList.add('highlight'); else e.line.classList.remove('highlight');
        }
      });
    }

    // mark selected node/edge visually
    function markSelection() {
      // clear all selections
      svg.querySelectorAll('g.node').forEach(g => g.classList.remove('selected'));
      svg.querySelectorAll('.edge').forEach(l => l.classList.remove('highlight'));

      if (selectedNode) {
        const g = svg.querySelector(`g.node[data-id="${selectedNode}"]`);
        if (g) g.classList.add('selected');
        // highlight neighbors too
        const nbrs = adjacency.get(selectedNode) || [];
        nbrs.forEach(nb => {
          const g2 = svg.querySelector(`g.node[data-id="${nb.to}"]`);
          if (g2) g2.classList.add('selected');
        });
        // highlight edges
        edges.forEach(e => {
          if (e.from === selectedNode || e.to === selectedNode) e.line.classList.add('highlight');
        });
      } else if (selectedEdge) {
        const edge = edges.find(e => e.id === selectedEdge);
        if (edge) edge.line.classList.add('highlight');
      }

      // update scroll in adjacency list: focus corresponding li
      const li = adjListEl.querySelector(`li[data-id="${selectedNode}"]`);
      if (li) {
        li.scrollIntoView({ block: 'nearest' });
      }
    }

    function pulseNode(id) {
      const g = svg.querySelector(`g.node[data-id="${id}"]`);
      if (!g) return;
      g.style.transition = 'transform 220ms ease';
      g.style.transformOrigin = 'center';
      g.style.transform = 'scale(1.12)';
      setTimeout(() => {
        g.style.transform = 'scale(1)';
      }, 220);
    }

    function flashNode(id) {
      const g = svg.querySelector(`g.node[data-id="${id}"]`);
      if (!g) return;
      g.style.transition = 'filter 160ms ease';
      g.style.filter = 'drop-shadow(0 0 12px rgba(255,127,127,0.45))';
      setTimeout(()=>g.style.filter='', 280);
    }

    // Delete node & its edges
    function deleteNode(id) {
      // remove node
      const idx = nodes.findIndex(n => n.id === id);
      if (idx === -1) return;
      const node = nodes[idx];
      svg.removeChild(node.g);
      nodes.splice(idx,1);

      // remove edges referencing node
      for (let i = edges.length - 1; i >= 0; i--) {
        const e = edges[i];
        if (e.from === id || e.to === id) {
          svg.removeChild(e.line);
          edges.splice(i,1);
        }
      }

      // remove adjacency entries
      adjacency.delete(id);
      adjacency.forEach((list, key) => {
        adjacency.set(key, list.filter(nb => nb.to !== id));
      });

      selectedNode = null;
      selectedEdge = null;
      updateAdjList();
    }

    // Delete selected edge
    function deleteEdgeById(edgeId) {
      const idx = edges.findIndex(e => e.id === edgeId);
      if (idx === -1) return;
      const e = edges[idx];
      // remove adjacency entry for the directed pair (remove only one direction)
      let list = adjacency.get(e.from) || [];
      adjacency.set(e.from, list.filter(nb => !(nb.to === e.to && (nb.weight || '') === (e.weight || ''))));

      // if undirected, also remove the reverse entry
      if (!directedCheckbox.checked) {
        let list2 = adjacency.get(e.to) || [];
        adjacency.set(e.to, list2.filter(nb => !(nb.to === e.from && (nb.weight || '') === (e.weight || ''))));
      }

      svg.removeChild(e.line);
      edges.splice(idx,1);
      selectedEdge = null;
      updateAdjList();
    }

    // Edge creation helper when clicking buttons
    function tryCreateEdgeFromSelectedNodes(a,b) {
      if (!a || !b) return;
      const weight = edgeWeightInput.value.trim();
      createEdge(a, b, weight || null, directedCheckbox.checked);
    }

    // Clear entire graph
    function clearGraph() {
      nodes.slice().forEach(n => deleteNode(n.id));
      adjacency.clear();
      // remove any lingering edges (should be none)
      edges.slice().forEach(e => {
        if (e.line && e.line.parentNode) svg.removeChild(e.line);
      });
      edges.length = 0;
      nodeCounter = 0;
      edgeCounter = 0;
      selectedNode = null;
      selectedEdge = null;
      updateAdjList();
    }

    // Export adjacency as JSON
    function adjacencyJSON() {
      const out = {};
      adjacency.forEach((list, key) => {
        out[labelFor(key)] = list.map(nb => nb.weight ? { node: labelFor(nb.to), weight: nb.weight } : labelFor(nb.to));
      });
      return out;
    }

    // Copy utilities
    function copyTextToClipboard(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(()=> {
          alert('Copied to clipboard');
        }).catch(()=> alert('Copy failed'));
      } else {
        // fallback
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        alert('Copied to clipboard');
      }
    }

    // Initialize: add a couple of nodes for starter demo
    function initDemo() {
      const w = svg.clientWidth;
      const h = svg.clientHeight;
      const ids = [];
      ids.push(createNodeAt(w * 0.25, h * 0.35, 'A'));
      ids.push(createNodeAt(w * 0.55, h * 0.25, 'B'));
      ids.push(createNodeAt(w * 0.75, h * 0.6, 'C'));
      createEdge(ids[0], ids[1], null, true);
      createEdge(ids[1], ids[2], '3', true);
      createEdge(ids[0], ids[2], null, true);
    }

    // event binding for canvas click to create node
    svg.addEventListener('pointerdown', (ev) => {
      const pt = svgPoint(ev.clientX, ev.clientY);

      // If clicking empty space
      if (mode === 'add-node') {
        // create a new node
        createNodeAt(pt.x, pt.y);
      } else if (mode === 'select') {
        // deselect any selections
        selectedNode = null;
        selectedEdge = null;
        markSelection();
      } else if (mode === 'add-edge') {
        // clicking empty space cancels pending source
        if (pendingEdgeSource) {
          const prev = pendingEdgeSource;
          pendingEdgeSource = null;
          highlightNode(prev, false);
        }
      }
    });

    // delete button
    btnDelete.addEventListener('click', () => {
      if (selectedNode) deleteNode(selectedNode);
      else if (selectedEdge) deleteEdgeById(selectedEdge);
    });

    // export adj json
    btnExport.addEventListener('click', () => {
      const json = JSON.stringify(adjacencyJSON(), null, 2);
      copyTextToClipboard(json);
    });

    copyAdj.addEventListener('click', () => {
      // plain text view
      let text = '';
      nodes.forEach(n => {
        const nbrs = adjacency.get(n.id) || [];
        const line = `${n.label} -> ${nbrs.length ? nbrs.map(nb => nb.weight ? `${labelFor(nb.to)}(${nb.weight})` : labelFor(nb.to)).join(', ') : '∅'}`;
        text += line + '\n';
      });
      copyTextToClipboard(text);
    });

    resetPositions.addEventListener('click', () => {
      // reset positions to a grid-ish layout
      const margin = 80;
      const w = svg.clientWidth - margin * 2;
      const h = svg.clientHeight - margin * 2;
      nodes.forEach((n, i) => {
        const cols = Math.ceil(Math.sqrt(nodes.length));
        const row = Math.floor(i / cols);
        const col = i % cols;
        n.x = margin + (col / Math.max(1, cols - 1)) * w;
        n.y = margin + (row / Math.max(1, Math.ceil(nodes.length / cols) - 1)) * h;
        n.circle.setAttribute('cx', n.x);
        n.circle.setAttribute('cy', n.y);
        n.text.setAttribute('x', n.x);
        n.text.setAttribute('y', n.y);
      });
      nodes.forEach(n => updateEdgesForNode(n.id));
    });

    // clear
    clearBtn.addEventListener('click', () => {
      if (confirm('Clear the graph?')) clearGraph();
    });

    // Edge weight input: allow Enter to finalize a pending edge by clicking the last node
    edgeWeightInput.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter' && pendingEdgeSource) {
        // create a self-loop target on the same node? We'll just cancel
        highlightNode(pendingEdgeSource, false);
        pendingEdgeSource = null;
      }
    });

    // Keyboard global: Delete key deletes selection
    window.addEventListener('keydown', (ev) => {
      if (ev.key === 'Delete' || ev.key === 'Backspace') {
        if (selectedNode) deleteNode(selectedNode);
        else if (selectedEdge) deleteEdgeById(selectedEdge);
      }
    });

    // Buttons to change mode (duplicated to top)
    document.getElementById('mode-add-node').addEventListener('click', ()=>setMode('add-node'));
    document.getElementById('mode-add-edge').addEventListener('click', ()=>setMode('add-edge'));
    document.getElementById('mode-select').addEventListener('click', ()=>setMode('select'));

    // Create nodes with top bar buttons
    document.getElementById('btn-add').addEventListener('click', () => {
      // add at center
      const rect = svg.getBoundingClientRect();
      const pt = svgPoint(rect.left + rect.width/2, rect.top + rect.height/2);
      createNodeAt(pt.x + Math.random()*40-20, pt.y + Math.random()*40-20);
    });

    document.getElementById('btn-edge').addEventListener('click', () => setMode('add-edge'));
    document.getElementById('btn-select').addEventListener('click', () => setMode('select'));

    // responsive: keep SVG viewbox consistent on resize
    function onResize() {
      // do nothing complex, but ensure nodes stay visible; can be extended
    }
    window.addEventListener('resize', onResize);

    // Initialize demo nodes
    initDemo();

    // Final housekeeping: ensure focus outlines and accessibility hints
    svg.setAttribute('aria-describedby', 'title');

    // End of module
  </script>
</body>
</html>