<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bubble Sort — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --control-width: 320px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa4b2;
      --accent: #06b6d4;
      --compare: #f59e0b;
      --swap: #ef4444;
      --sorted: #10b981;
      --bar-bg: linear-gradient(180deg,#60a5fa44,#bde0ff22);
      --transition: 300ms cubic-bezier(.2,.9,.2,1);
      --min-bar-width: 18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      padding:var(--safe-margin);
      font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#071124 0%,#071e2b 100%);
      color:#e6eef6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Page layout */
    .app{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      min-height:calc(100vh - (var(--safe-margin) * 2));
    }
    header{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* Main region */
    .main{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      flex:1;
    }

    /* Controls panel */
    .controls{
      width:var(--control-width);
      min-width:260px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      padding:var(--gap);
      border-radius:10px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .controls .group{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .row{
      display:flex;
      gap:12px;
      align-items:center;
    }
    label{font-size:13px;color:var(--muted)}
    input[type="text"]{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      padding:8px 10px;
      border-radius:6px;
      color:inherit;
      outline:none;
      font-size:13px;
    }
    .buttons{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }
    button{
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.06);
      color:inherit;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }
    button[aria-pressed="true"]{
      box-shadow:0 6px 18px rgba(6,182,212,0.12);
      border-color:rgba(6,182,212,0.6);
      background:linear-gradient(180deg, rgba(6,182,212,0.12), rgba(6,182,212,0.06));
    }
    button:disabled{opacity:0.5; cursor:not-allowed}
    .small{
      padding:6px 8px;
      font-size:12px;
    }
    .toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .legend{
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .legend .item{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .legend .swatch{
      width:14px;
      height:14px;
      border-radius:3px;
      border:1px solid rgba(255,255,255,0.04);
    }
    .sw-compare{background:var(--compare)}
    .sw-sorted{background:var(--sorted)}
    .sw-normal{background:#6b7280}

    /* Visualization area */
    .visual{
      position:relative;
      flex:1;
      min-height:320px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));
      border-radius:10px;
      padding:var(--gap);
      border:1px solid rgba(255,255,255,0.04);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      overflow:hidden;
    }
    .viz-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:16px;
    }
    .status{
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .counter{
      background:rgba(255,255,255,0.02);
      padding:6px 8px;
      border-radius:6px;
      min-width:72px;
      text-align:center;
    }

    .bars-wrap{
      position:relative;
      flex:1;
      min-height:220px;
      display:block;
      background:linear-gradient(180deg, rgba(0,0,0,0.02), transparent);
      border-radius:6px;
      padding:16px;
      overflow:hidden;
    }
    .bars{
      position:relative;
      height:100%;
      width:100%;
      display:block;
    }
    .bar{
      position:absolute;
      bottom:16px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      background:var(--bar-bg);
      border-radius:6px;
      color:#021124;
      font-size:12px;
      font-weight:600;
      text-align:center;
      box-shadow:0 6px 16px rgba(2,6,23,0.35);
      border:1px solid rgba(255,255,255,0.03);
      transition: left var(--transition), transform var(--transition), height var(--transition), box-shadow var(--transition);
      touch-action:none;
      user-select:none;
    }
    .bar .label{
      padding:6px 6px;
      color:#051225;
      font-weight:700;
    }
    .bar.compare{
      box-shadow:0 10px 28px rgba(245,158,11,0.12);
      border-color:rgba(245,158,11,0.9);
      background:linear-gradient(180deg,#ffd6a5,#ffedd5);
    }
    .bar.sorted{
      box-shadow:0 10px 28px rgba(16,185,129,0.12);
      border-color:rgba(16,185,129,0.9);
      background:linear-gradient(180deg,#bbf7d0,#d1fae5);
    }
    .bar.dragging{
      transform:scale(1.06) translateY(-6px);
      transition:none;
      z-index:100;
      box-shadow:0 24px 48px rgba(2,6,23,0.5);
    }

    footer{
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:12px;
      align-items:center;
    }

    /* Responsive adjustments */
    @media (max-width:900px){
      .main{flex-direction:column}
      .controls{width:100%}
    }

  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <h1>Bubble Sort — Interactive Module</h1>
      <p class="lead">Explore Bubble Sort by stepping through comparisons and swaps, dragging elements, or running the animation. Watch how elements "bubble" into place.</p>
    </header>

    <div class="main" role="main" aria-label="Bubble Sort interactive module">
      <aside class="controls" aria-label="Controls">
        <div class="group">
          <label for="array-input">Custom array (comma-separated integers)</label>
          <div style="display:flex;gap:8px;">
            <input id="array-input" type="text" aria-label="Custom array input" placeholder="e.g. 5,1,4,2,8" />
            <button id="apply" title="Apply custom array">Apply</button>
          </div>
        </div>

        <div class="group">
          <div class="buttons" role="group" aria-label="Play controls">
            <button id="shuffle">Shuffle</button>
            <button id="start" aria-pressed="false">Start</button>
            <button id="step">Step</button>
            <button id="reset">Reset</button>
          </div>
          <div style="display:flex;gap:12px;align-items:center;margin-top:8px;">
            <label for="speed" style="min-width:56px;color:var(--muted);font-size:13px;">Speed</label>
            <input id="speed" type="range" min="100" max="1500" value="600" />
            <div id="speed-value" style="min-width:48px;text-align:right;color:var(--muted);font-size:13px;">600ms</div>
          </div>
          <div style="margin-top:8px;display:flex;gap:12px;align-items:center;">
            <div class="toggle" role="group" aria-label="Sort direction">
              <label for="dir-asc" style="font-size:13px;color:var(--muted);">Direction</label>
              <button id="dir-asc" aria-pressed="true" class="small">Asc</button>
              <button id="dir-desc" aria-pressed="false" class="small">Desc</button>
            </div>
            <button id="randomize" class="small">Random (7)</button>
          </div>
        </div>

        <div class="group">
          <label style="color:var(--muted);font-size:13px;">Legend</label>
          <div class="legend">
            <div class="item"><span class="swatch sw-normal"></span><span style="color:var(--muted);font-size:13px;">Unsorted</span></div>
            <div class="item"><span class="swatch sw-compare"></span><span style="color:var(--muted);font-size:13px;">Comparing</span></div>
            <div class="item"><span class="swatch sw-sorted"></span><span style="color:var(--muted);font-size:13px;">Sorted</span></div>
          </div>
        </div>
      </aside>

      <section class="visual" aria-label="Visualization">
        <div class="viz-top">
          <div class="status" aria-hidden="false">
            <div class="counter" title="Comparisons"><strong id="comparisons">0</strong><div style="font-size:11px;color:var(--muted);">comparisons</div></div>
            <div class="counter" title="Swaps"><strong id="swaps">0</strong><div style="font-size:11px;color:var(--muted);">swaps</div></div>
            <div class="counter" title="Pass"><strong id="pass">0</strong><div style="font-size:11px;color:var(--muted);">pass</div></div>
          </div>
          <div style="color:var(--muted);font-size:13px;" id="live-status" aria-live="polite"></div>
        </div>

        <div class="bars-wrap" id="bars-wrap" aria-label="Array visualization">
          <div class="bars" id="bars" role="list" aria-live="polite"></div>
        </div>

        <footer>
          <div style="flex:1;color:var(--muted);font-size:13px;">
            Bubble Sort repeatedly compares adjacent items and swaps them if out of order. Each pass moves one item to its proper place.
          </div>
          <div style="color:var(--muted);font-size:12px;">Drag bars to reorder the array before sorting.</div>
        </footer>
      </section>
    </div>
  </div>

  <script>
    (function(){
      // Configuration and state
      const defaultArray = [5,1,4,2,8,3,7];
      let array = [];
      let initialArray = [];
      let comparisons = 0;
      let swaps = 0;
      let pass = 0;
      let i = 0; // outer pass index
      let j = 0; // inner index
      let running = false;
      let intervalId = null;
      let speed = 600;
      let direction = 'asc'; // 'asc' or 'desc'
      const barsWrap = document.getElementById('bars-wrap');
      const barsEl = document.getElementById('bars');
      const comparisonsEl = document.getElementById('comparisons');
      const swapsEl = document.getElementById('swaps');
      const passEl = document.getElementById('pass');
      const liveStatus = document.getElementById('live-status');
      const applyBtn = document.getElementById('apply');
      const arrayInput = document.getElementById('array-input');
      const shuffleBtn = document.getElementById('shuffle');
      const startBtn = document.getElementById('start');
      const stepBtn = document.getElementById('step');
      const resetBtn = document.getElementById('reset');
      const speedInput = document.getElementById('speed');
      const speedValue = document.getElementById('speed-value');
      const dirAscBtn = document.getElementById('dir-asc');
      const dirDescBtn = document.getElementById('dir-desc');
      const randomizeBtn = document.getElementById('randomize');

      // Visual options
      let barRects = [];
      let barWidth = 0;
      let barGap = 8;

      function init(arr) {
        stop();
        array = arr.slice();
        initialArray = arr.slice();
        comparisons = 0;
        swaps = 0;
        pass = 0;
        i = 0;
        j = 0;
        updateCounters();
        renderBars();
        announce('Array loaded. Ready to sort.');
      }

      function updateCounters(){
        comparisonsEl.textContent = comparisons;
        swapsEl.textContent = swaps;
        passEl.textContent = pass;
      }

      function announce(text){
        liveStatus.textContent = text;
      }

      // Build bar elements
      function renderBars(){
        barsEl.innerHTML = '';
        const n = array.length;
        // compute sizes
        const wrapRect = barsWrap.getBoundingClientRect();
        const availableWidth = Math.max(wrapRect.width - 32, 120);
        barWidth = Math.max(Math.floor((availableWidth - (n-1) * barGap) / n), parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-bar-width')) || 18);
        const maxVal = Math.max(...array.map(v=>Math.abs(v)), 1);
        for (let idx=0; idx<n; idx++){
          const val = array[idx];
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.setAttribute('role','listitem');
          bar.setAttribute('tabindex','0');
          bar.dataset.index = idx;
          bar.dataset.value = val;
          // height scaled
          const heightPct = Math.max(12, Math.round((Math.abs(val) / maxVal) * 100));
          const heightPx = Math.max(24, Math.round((wrapRect.height - 48) * (heightPct/100)));
          bar.style.height = heightPx + 'px';
          bar.style.width = barWidth + 'px';
          bar.style.left = (idx * (barWidth + barGap)) + 'px';
          bar.style.transform = 'translateY(0)';
          bar.innerHTML = '<div class="label" aria-hidden="true">' + val + '</div>';
          // drag handlers
          attachDragHandlers(bar);
          barsEl.appendChild(bar);
        }
      }

      // Drag and drop ordering
      let dragging = null;
      let dragStartX = 0;
      let dragOriginLeft = 0;
      function attachDragHandlers(bar){
        bar.addEventListener('pointerdown', ev => {
          ev.preventDefault();
          bar.setPointerCapture(ev.pointerId);
          dragging = bar;
          dragStartX = ev.clientX;
          dragOriginLeft = parseFloat(bar.style.left);
          bar.classList.add('dragging');
          // store initial positions of bars
          barRects = Array.from(barsEl.children).map(b => ({
            el: b,
            left: parseFloat(b.style.left),
            width: parseFloat(b.style.width)
          }));
        });
        bar.addEventListener('pointermove', ev => {
          if (!dragging || dragging !== bar) return;
          const dx = ev.clientX - dragStartX;
          const newLeft = dragOriginLeft + dx;
          bar.style.left = newLeft + 'px';
          // compute provisional index by center x
          const center = newLeft + parseFloat(bar.style.width) / 2;
          let newIndex = 0;
          for (let k=0;k<barRects.length;k++){
            const rect = barRects[k];
            if (rect.el === bar) continue;
            const rectCenter = rect.left + rect.width / 2;
            if (center > rectCenter) newIndex = Math.max(newIndex, k+1);
          }
          // shift others visually
          let insertPos = newIndex;
          const id = parseInt(bar.dataset.index);
          const currentOrder = Array.from(barsEl.children).map(b=>parseInt(b.dataset.index));
          const without = currentOrder.filter(x=>x!==id);
          without.splice(insertPos,0,id);
          // reposition according to new order
          without.forEach((origIdx,pos)=>{
            const barEl = Array.from(barsEl.children).find(b=>parseInt(b.dataset.index)===origIdx);
            if (barEl && barEl !== bar){
              barEl.style.left = (pos * (barWidth + barGap)) + 'px';
            }
          });
        });
        bar.addEventListener('pointerup', ev => {
          if (!dragging || dragging !== bar) return;
          bar.releasePointerCapture(ev.pointerId);
          bar.classList.remove('dragging');
          // finalize order
          const centers = Array.from(barsEl.children).map(b => ({
            el: b,
            center: parseFloat(b.style.left) + parseFloat(b.style.width)/2,
            idx: parseInt(b.dataset.index)
          }));
          centers.sort((a,b)=>a.center - b.center);
          const newOrderIdx = centers.map(c=>c.idx);
          // rebuild array according to new order
          array = newOrderIdx.map(idx => parseInt(initialArray[idx]));
          // update dataset index for each element and re-render to stable DOM
          initialArray = array.slice();
          renderBars();
          stop();
          announce('Array reordered by dragging. Algorithm reset.');
          dragging = null;
          updateCounters();
        });
        // keyboard accessibility: pressing space starts a drag-like swap with neighbor
        bar.addEventListener('keydown', ev=>{
          if (ev.key === 'ArrowLeft' || ev.key === 'ArrowRight'){
            ev.preventDefault();
            const idx = parseInt(bar.dataset.index);
            let target = ev.key === 'ArrowLeft' ? idx-1 : idx+1;
            if (target < 0 || target >= array.length) return;
            // swap positions
            swapIndices(idx, target, true);
            initialArray = array.slice();
            renderBars();
            stop();
            updateCounters();
            announce('Swapped element ' + array[target] + ' with ' + array[idx]);
          }
        });
      }

      // Utility: swap positions and optionally animate
      function swapIndices(a,b,instant=false){
        if (a===b) return;
        [array[a], array[b]] = [array[b], array[a]];
      }

      function compareAndMaybeSwap(curJ){
        const a = curJ;
        const b = curJ + 1;
        const A = array[a];
        const B = array[b];
        comparisons++;
        updateCounters();
        // highlight comparing bars
        highlightCompare(a,b);
        const needsSwap = (direction === 'asc') ? (A > B) : (A < B);
        announce('Comparing ' + A + ' and ' + B + (needsSwap ? '. Will swap.' : '. No swap.'));
        if (needsSwap){
          swaps++;
          updateCounters();
          // perform swap visually by swapping values then animating left positions
          // Find DOM bars and animate left positions by swapping dataset indices
          const barEls = Array.from(barsEl.children);
          // swap the dataset index values
          const barA = barEls.find(b => parseInt(b.dataset.index) === a);
          const barB = barEls.find(b => parseInt(b.dataset.index) === b);
          // If not found (after re-render), just swap array and re-render
          if (!barA || !barB){
            swapIndices(a,b);
            renderBars();
            return;
          }
          // Swap values in array (model)
          swapIndices(a,b);
          // Animate bars by reassigning left positions after brief delay so compare highlight is visible
          setTimeout(()=> {
            barA.dataset.index = b;
            barB.dataset.index = a;
            // swap lefts by setting new lefts on DOM based on dataset index
            barEls.forEach(bEl=>{
              const idx = parseInt(bEl.dataset.index);
              bEl.style.left = (idx * (barWidth + barGap)) + 'px';
              // update label text to match model
              const val = array[idx];
              const label = bEl.querySelector('.label');
              if (label) label.textContent = val;
              bEl.dataset.value = val;
            });
          }, 120);
        } else {
          // no swap: a small highlight then continue
        }
      }

      // Highlight compared bars briefly
      function highlightCompare(a,b){
        Array.from(barsEl.children).forEach(bar=>bar.classList.remove('compare'));
        const barEls = Array.from(barsEl.children);
        const ba = barEls.find(bel => parseInt(bel.dataset.index) === a);
        const bb = barEls.find(bel => parseInt(bel.dataset.index) === b);
        if (ba) ba.classList.add('compare');
        if (bb) bb.classList.add('compare');
      }

      // Mark sorted elements at end of pass
      function markSorted(startIndex){
        Array.from(barsEl.children).forEach(bar=>bar.classList.remove('sorted'));
        const n = array.length;
        for (let k = n - startIndex; k < n; k++){
          // last startIndex elements are sorted
        }
        // compute how many sorted at end
        const sortedCount = Math.max(0, startIndex);
        for (let k = 0; k < sortedCount; k++){
          // no-op placeholder (we mark sorted for final positions)
        }
        // Instead mark from the end: elements with index >= n - startIndex are sorted
        for (let idx = n - startIndex; idx < n; idx++){
          const bar = Array.from(barsEl.children).find(b=>parseInt(b.dataset.index) === idx);
          if (bar) bar.classList.add('sorted');
        }
      }

      // Algorithm step (single comparison)
      function step(){
        const n = array.length;
        if (n <= 1) {
          announce('Array too small to sort.');
          stop();
          return;
        }
        if (i >= n - 1){
          // finished
          announce('Sorting complete.');
          Array.from(barsEl.children).forEach(b=>b.classList.remove('compare'));
          Array.from(barsEl.children).forEach(b=>b.classList.add('sorted'));
          stop();
          return;
        }
        if (j >= n - i - 1){
          // end of pass
          pass++;
          passEl.textContent = pass;
          // mark the element at position n-i-1 as sorted
          const sortedIdx = n - i - 1;
          const sortedBar = Array.from(barsEl.children).find(b=>parseInt(b.dataset.index) === sortedIdx);
          if (sortedBar) sortedBar.classList.add('sorted');
          i++;
          j = 0;
          announce('Pass ' + pass + ' complete.');
          return;
        }
        // compare positions j and j+1
        compareAndMaybeSwap(j);
        j++;
      }

      // Start animation
      function start(){
        if (running) return;
        running = true;
        startBtn.setAttribute('aria-pressed','true');
        startBtn.textContent = 'Pause';
        announce('Sorting started.');
        intervalId = setInterval(()=>{
          step();
        }, speed);
      }

      function stop(){
        running = false;
        startBtn.setAttribute('aria-pressed','false');
        startBtn.textContent = 'Start';
        if (intervalId) clearInterval(intervalId);
        intervalId = null;
      }

      // Handlers for controls
      applyBtn.addEventListener('click', ()=>{
        const text = arrayInput.value.trim();
        if (!text) return;
        const parts = text.split(',').map(s=>s.trim()).filter(s=>s.length>0);
        const vals = parts.map(p => {
          const v = parseInt(p,10);
          return isNaN(v) ? 0 : v;
        });
        init(vals);
      });

      shuffleBtn.addEventListener('click', ()=>{
        const arr = initialArray.slice();
        for (let k = arr.length -1; k>0; k--){
          const r = Math.floor(Math.random() * (k+1));
          [arr[k], arr[r]] = [arr[r], arr[k]];
        }
        init(arr);
        announce('Shuffled array.');
      });

      randomizeBtn.addEventListener('click', ()=>{
        // generate random 7-element array
        const len = 7;
        const arr = Array.from({length:len}, ()=>Math.floor(Math.random()*20)+1);
        init(arr);
        announce('Random array generated.');
      });

      startBtn.addEventListener('click', ()=>{
        if (running) stop();
        else start();
      });

      stepBtn.addEventListener('click', ()=>{
        if (running){
          // step while running should pause then step one
          stop();
        }
        step();
      });

      resetBtn.addEventListener('click', ()=>{
        init(initialArray.slice());
      });

      speedInput.addEventListener('input', (ev)=>{
        speed = parseInt(ev.target.value,10);
        speedValue.textContent = speed + 'ms';
        if (running){
          stop();
          start();
        }
      });

      dirAscBtn.addEventListener('click', ()=>{
        direction = 'asc';
        dirAscBtn.setAttribute('aria-pressed','true');
        dirDescBtn.setAttribute('aria-pressed','false');
        announce('Direction set to ascending.');
      });
      dirDescBtn.addEventListener('click', ()=>{
        direction = 'desc';
        dirAscBtn.setAttribute('aria-pressed','false');
        dirDescBtn.setAttribute('aria-pressed','true');
        announce('Direction set to descending.');
      });

      // keyboard shortcuts for convenience
      window.addEventListener('keydown', ev=>{
        if (ev.key === ' ') { // space toggles start/pause
          ev.preventDefault();
          startBtn.click();
        } else if (ev.key === 's') {
          stepBtn.click();
        } else if (ev.key === 'r') {
          resetBtn.click();
        }
      });

      // initial load
      init(defaultArray);

      // Ensure bars re-render on resize for responsive sizing
      let resizeTimer = null;
      window.addEventListener('resize', ()=>{
        if (resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = setTimeout(()=>{ renderBars(); }, 120);
      });

      // A small accessibility note: aria-live is used for narration updates above.
    })();
  </script>
</body>
</html>