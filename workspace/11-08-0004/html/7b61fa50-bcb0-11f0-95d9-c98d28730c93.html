<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Heap Sort Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --node-size: 52px;
      --node-radius: 8px;
      --accent: #1565c0;
      --accent-2: #ff8f00;
      --bg: #ffffff;
      --muted: #6b7280;
      --success: #16a34a;
      --danger: #dc2626;
      --shadow: 0 6px 18px rgba(16,24,40,0.06);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg,#f7fbff,#ffffff 40%);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #0f172a;
    }

    .container {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100%;
      display: flex;
      gap: var(--gap);
      align-items: flex-start;
    }

    /* Layout: left = visual, right = controls/explanation
       Note: minimum spacing between interactive elements is 16px (var --gap)
    */
    .left {
      flex: 1 1 680px;
      min-width: 320px;
      background: rgba(255,255,255,0.7);
      border-radius: 12px;
      padding: 20px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .right {
      width: 360px;
      min-width: 280px;
      background: #fff;
      border-radius: 12px;
      padding: 20px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    /* Responsive: stack columns on small screens */
    @media (max-width: 980px) {
      .container {
        flex-direction: column;
      }
      .right {
        width: 100%;
      }
    }

    /* Header and meta */
    .title {
      font-size: 18px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .meta {
      color: var(--muted);
      font-size: 13px;
    }

    /* Visualization area */
    .viz {
      background: linear-gradient(180deg,#ffffff, #f8fbff);
      border-radius: 10px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 420px;
    }

    .viz-top {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .legend {
      font-size: 13px;
      color: var(--muted);
      margin-left: auto;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .legend .dot {
      width: 12px;
      height: 12px;
      border-radius: 3px;
    }

    /* Tree and array containers */
    .tree-area {
      position: relative;
      height: 240px;
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(21,101,192,0.03), rgba(21,101,192,0.01));
      overflow: visible;
      padding: 8px;
      border: 1px dashed rgba(16,24,40,0.04);
    }

    .array-area {
      position: relative;
      height: 84px;
      margin-top: 6px;
      background: linear-gradient(180deg, rgba(248,250,252,0.7), rgba(255,255,255,0.6));
      border-radius: 8px;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px dashed rgba(16,24,40,0.04);
    }

    /* Node styles for both tree and array nodes */
    .node {
      position: absolute;
      width: var(--node-size);
      height: var(--node-size);
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff;
      border-radius: var(--node-radius);
      box-shadow: 0 6px 12px rgba(2,6,23,0.06);
      border: 1px solid rgba(16,24,40,0.06);
      font-weight: 600;
      transition: left 420ms cubic-bezier(.2,.9,.2,1), top 420ms cubic-bezier(.2,.9,.2,1), background-color 220ms, transform 220ms;
      user-select: none;
    }

    .node.tree {
      width: 48px;
      height: 48px;
      font-size: 14px;
      border-radius: 9999px;
      background: linear-gradient(180deg,#ffffff,#f5f9ff);
    }

    .node.array {
      width: var(--node-size);
      height: var(--node-size);
      font-size: 14px;
      border-radius: 8px;
    }

    .node.active {
      background: linear-gradient(180deg, #fffbe6, #fff4e1);
      border-color: rgba(255,140,0,0.4);
      transform: scale(1.06);
      box-shadow: 0 10px 28px rgba(255,140,0,0.08);
    }
    .node.swap {
      background: linear-gradient(180deg,#e8f4ff,#def0ff);
      border-color: rgba(21,101,192,0.35);
      transform: scale(1.06);
      box-shadow: 0 10px 28px rgba(21,101,192,0.06);
    }

    .node.ghost {
      opacity: 0.16;
    }

    /* Lines connecting tree nodes */
    .edge {
      position: absolute;
      width: 2px;
      background: linear-gradient(180deg, rgba(16,24,40,0.12), rgba(16,24,40,0.06));
      transform-origin: top left;
      border-radius: 2px;
      transition: background-color 220ms;
    }

    .edge.active {
      background: linear-gradient(180deg, rgba(21,101,192,0.6), rgba(21,101,192,0.35));
    }

    /* Controls on right */
    .controls {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .input {
      display: flex;
      gap: 8px;
      align-items: center;
      width: 100%;
    }

    input[type="text"] {
      padding: 10px 12px;
      font-size: 14px;
      border-radius: 8px;
      border: 1px solid rgba(16,24,40,0.08);
      flex: 1 1 auto;
      outline: none;
      background: #fff;
      color: inherit;
      transition: box-shadow 180ms;
    }
    input[type="text"]:focus { box-shadow: 0 6px 18px rgba(3,105,161,0.06); }

    button {
      padding: 10px 12px;
      font-size: 14px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      background: var(--accent);
      color: white;
      transition: transform 120ms ease, box-shadow 120ms;
      box-shadow: 0 6px 12px rgba(21,101,192,0.12);
    }
    button.secondary {
      background: #fff;
      color: var(--accent);
      border: 1px solid rgba(21,101,192,0.12);
      box-shadow: none;
    }
    button.ghost {
      background: transparent;
      color: var(--muted);
      border: 1px solid rgba(16,24,40,0.04);
      box-shadow: none;
    }
    button:active { transform: translateY(1px); }

    .big {
      padding: 12px 14px;
      font-weight: 700;
    }

    .controls .hint {
      color: var(--muted);
      font-size: 13px;
    }

    .stats {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .stat {
      background: rgba(2,6,23,0.03);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 13px;
    }

    .pseudocode {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size: 13px;
      background: linear-gradient(180deg,#fbfdff,#ffffff);
      border: 1px solid rgba(16,24,40,0.04);
      padding: 10px;
      border-radius: 8px;
      color: #0f172a;
      line-height: 1.5;
      max-height: 220px;
      overflow: auto;
    }

    .explain {
      font-size: 14px;
      color: #0b1220;
      line-height: 1.45;
    }

    .controls .small {
      font-size: 13px;
      color: var(--muted);
    }

    /* Speed slider */
    input[type=range] {
      accent-color: var(--accent);
      width: 100%;
    }

    /* Footer instructions */
    .footer-hint {
      font-size: 12px;
      color: var(--muted);
    }

    /* Accessibility focus */
    button:focus, input[type="text"]:focus {
      outline: 3px solid rgba(21,101,192,0.14);
      outline-offset: 2px;
    }
  </style>
</head>
<body>
  <div class="container" role="main" aria-label="Heap sort interactive module">
    <div class="left" id="left">
      <!-- Header with Concept Title and Learning Objective -->
      <div class="title" aria-hidden="false">
        <div style="display:flex;flex-direction:column;">
          <div style="font-size:16px;font-weight:800;">Heap Sort — In-place Heap Construction & Extraction</div>
          <div class="meta">Visualize heapify (sift-down) and repeated extraction to sort an array.</div>
        </div>
      </div>

      <div style="display:flex;flex-direction:column;gap:8px;">
        <div style="font-size:13px;color:var(--muted);">
          Learning objective: After interacting with this module you will understand how the array-to-binary-heap mapping works, how "sift-down" heapify transforms an array into a max-heap, and how repeated swaps with the root produce a sorted array in-place.
        </div>
      </div>

      <!-- Visualization area -->
      <div class="viz" aria-live="polite">
        <div class="viz-top">
          <div style="font-weight:700">Heap visualization</div>
          <div class="legend" aria-hidden="true">
            <div style="display:flex;flex-direction:column;gap:6px;align-items:center;">
              <div style="font-size:12px;color:var(--muted);">Legend</div>
            </div>
            <div style="display:flex;gap:8px;align-items:center;">
              <div style="display:flex;gap:6px;align-items:center;">
                <div class="dot" style="background:linear-gradient(180deg,#fffbe6,#fff4e1);border:1px solid rgba(255,140,0,0.24);width:14px;height:14px;border-radius:3px;"></div>
                <div class="meta">Active sift</div>
              </div>
              <div style="display:flex;gap:6px;align-items:center;">
                <div class="dot" style="background:linear-gradient(180deg,#e8f4ff,#def0ff);border:1px solid rgba(21,101,192,0.24);width:14px;height:14px;border-radius:3px;"></div>
                <div class="meta">Swap</div>
              </div>
            </div>
          </div>
        </div>

        <div id="treeArea" class="tree-area" aria-label="Binary heap tree visualization">
          <!-- edges and tree nodes will be injected here -->
        </div>

        <div class="array-area" id="arrayArea" aria-label="Array representation of heap">
          <!-- array nodes will be injected here -->
        </div>

        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
          <div class="stats" aria-hidden="true">
            <div class="stat">n = <span id="nVal">0</span></div>
            <div class="stat">Comparisons = <span id="comp">0</span></div>
            <div class="stat">Swaps = <span id="swaps">0</span></div>
            <div class="stat">Step = <span id="stepCount">0</span></div>
          </div>

          <div style="display:flex;gap:8px;align-items:center;">
            <div class="small" id="statusText">Idle</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Controls and explanation -->
    <div class="right" aria-label="Controls and explanation">
      <div style="display:flex;flex-direction:column;gap:8px;">
        <div style="font-weight:700">Controls</div>
        <div class="input" role="group" aria-label="Array input">
          <input id="arrayInput" type="text" aria-label="Enter comma separated integers" placeholder="e.g. 5, 3, 8, 1, 2" />
          <button id="loadBtn" class="ghost" title="Load array from input">Load</button>
        </div>

        <div style="display:flex;gap:8px;">
          <button id="randBtn" class="secondary" title="Generate random array">Random</button>
          <button id="smallBtn" class="secondary" title="Small sample">Sample</button>
          <button id="resetBtn" class="ghost" title="Reset">Reset</button>
        </div>

        <div style="display:flex;gap:8px;">
          <button id="playBtn" class="big">Play</button>
          <button id="stepBack" class="ghost">◀ Step</button>
          <button id="stepFwd" class="ghost">Step ▶</button>
        </div>

        <div style="display:flex;flex-direction:column;gap:6px;">
          <label for="speed" class="small">Speed (ms per step)</label>
          <input id="speed" type="range" min="120" max="1200" step="20" value="420" />
        </div>
      </div>

      <div style="display:flex;flex-direction:column;gap:8px;">
        <div style="font-weight:700">How this interaction works</div>
        <div class="explain">
          - The top area shows the binary-heap structure (array indices mapped to tree positions).<br>
          - The bottom row shows the same elements as a contiguous array. Hover/step to see which elements are being compared or swapped.<br>
          - "Play" automatically steps through heap construction (sift-down from last parent) and extraction (swap root with last unsorted element, reduce heap size, sift-down).<br>
          - Use Step / ◀ to move one operation at a time and inspect intermediate arrays.
        </div>
      </div>

      <div style="display:flex;flex-direction:column;gap:8px;">
        <div style="font-weight:700">Pseudocode (high-level)</div>
        <div class="pseudocode" aria-hidden="true">
Build-Max-Heap(A):
  for i = floor(n/2)-1 downto 0
    SiftDown(A, i, n-1)

HeapSort(A):
  Build-Max-Heap(A)
  for end = n-1 downto 1
    swap A[0], A[end]
    SiftDown(A, 0, end-1)

SiftDown(A, i, last):
  while true:
    left = 2*i + 1
    right = 2*i + 2
    largest = i
    if left <= last and A[left] > A[largest]:
      largest = left
    if right <= last and A[right] > A[largest]:
      largest = right
    if largest == i: break
    swap A[i], A[largest]
    i = largest
        </div>
      </div>

      <div style="display:flex;flex-direction:column;gap:8px;">
        <div style="font-weight:700">Notes & accessibility</div>
        <div class="hint">
          Keyboard: Space = play/pause, → = step forward, ← = step back. Inputs are ARIA labeled. The visualization uses color + movement; while color is used, nodes also scale and show borders for contrast.
        </div>
        <div class="footer-hint">Tip: Use small arrays (≤12) for clearer tree layout.</div>
      </div>
    </div>
  </div>

  <script>
    /* Heap Sort Interactive Module
       - Vanilla JS, self-contained
       - Single concept: Heap Sort (build max-heap + extraction)
       - Interactions: load array, random/sample, step forward/back, play/pause, speed control
       - Visual feedback: animated node movements (left, top), color highlighting for active/swap nodes, connecting edges for tree, live stats
    */

    (function () {
      // Configuration
      const MAX_NODES = 14; // keep layout readable
      const treeArea = document.getElementById('treeArea');
      const arrayArea = document.getElementById('arrayArea');
      const nVal = document.getElementById('nVal');
      const compEl = document.getElementById('comp');
      const swapsEl = document.getElementById('swaps');
      const stepCountEl = document.getElementById('stepCount');
      const statusText = document.getElementById('statusText');

      const arrayInput = document.getElementById('arrayInput');
      const loadBtn = document.getElementById('loadBtn');
      const randBtn = document.getElementById('randBtn');
      const smallBtn = document.getElementById('smallBtn');
      const resetBtn = document.getElementById('resetBtn');
      const playBtn = document.getElementById('playBtn');
      const stepBack = document.getElementById('stepBack');
      const stepFwd = document.getElementById('stepFwd');
      const speedInput = document.getElementById('speed');

      let A = []; // current array
      let nodes = []; // DOM nodes arrays: treeNodes[], arrayNodes[]
      let edges = [];
      let history = []; // snapshots for stepping back
      let steps = []; // queued logical steps for stepping forward (type, i, j, message)
      let playing = false;
      let timer = null;
      let compCount = 0, swapCount = 0;
      let currentStepIndex = 0;
      let heapSize = 0;

      // Utility: clamp
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      // Initialize with sample
      function initSample() {
        const sample = [5, 3, 8, 1, 2, 7, 4, 6];
        loadArray(sample);
      }

      // Parse input
      function parseInput(text) {
        const parts = text.split(',').map(s => s.trim()).filter(s => s !== '');
        const nums = [];
        for (let p of parts) {
          const v = Number(p);
          if (!Number.isFinite(v)) return null;
          nums.push(Math.trunc(v));
        }
        return nums;
      }

      // Build DOM nodes for tree and array
      function buildVisuals() {
        // clear
        treeArea.innerHTML = '';
        arrayArea.innerHTML = '';
        nodes = [];
        edges = [];

        const n = A.length;
        if (n === 0) return;

        // compute positions
        const treeRect = treeArea.getBoundingClientRect();
        const W = Math.max(treeRect.width, 320);
        const levels = Math.floor(Math.log2(n)) + 1;
        const levelHeight = Math.max(36, (treeRect.height - 20) / Math.max(levels, 1));
        const topPadding = 8;

        // Create edge elements first (so they are beneath nodes)
        for (let i = 0; i < n; i++) {
          const leftIdx = 2 * i + 1;
          const rightIdx = 2 * i + 2;
          // edges: child->parent lines (we will draw a line between parent and child using absolute elem)
          if (leftIdx < n) {
            const e = document.createElement('div');
            e.className = 'edge';
            treeArea.appendChild(e);
            edges.push(e);
          } else {
            edges.push(null);
          }
          if (rightIdx < n) {
            const e = document.createElement('div');
            e.className = 'edge';
            treeArea.appendChild(e);
            edges.push(e);
          } else {
            edges.push(null);
          }
        }

        // Create nodes
        for (let i = 0; i < n; i++) {
          const tNode = document.createElement('div');
          tNode.className = 'node tree';
          tNode.setAttribute('data-index', i);
          tNode.setAttribute('aria-label', `heap node index ${i}, value ${A[i]}`);
          tNode.textContent = String(A[i]);
          treeArea.appendChild(tNode);

          const aNode = document.createElement('div');
          aNode.className = 'node array';
          aNode.setAttribute('data-index', i);
          aNode.setAttribute('aria-label', `array index ${i}, value ${A[i]}`);
          aNode.textContent = String(A[i]);
          arrayArea.appendChild(aNode);

          nodes.push({ tree: tNode, array: aNode });
        }

        // position nodes
        positionAll();
      }

      // compute tree node coordinates for index i
      function treeCoords(i) {
        const n = A.length;
        const treeRect = treeArea.getBoundingClientRect();
        const W = Math.max(treeRect.width, 320);
        const levels = Math.floor(Math.log2(n)) + 1;
        const levelHeight = Math.max(36, (treeRect.height - 20) / Math.max(levels, 1));
        const topPadding = 8;

        const level = Math.floor(Math.log2(i + 1));
        const levelStart = Math.pow(2, level) - 1;
        const posInLevel = i - levelStart;
        const slots = Math.pow(2, level);
        // pad left & right margins
        const leftMargin = 16;
        const rightMargin = 16;
        const usable = W - leftMargin - rightMargin;
        const x = leftMargin + (posInLevel + 0.5) * (usable / slots) - 24; // center subtract half node width ~24
        const y = topPadding + level * levelHeight;
        return { left: x, top: y };
      }

      // compute array node coordinates for index i
      function arrayCoords(i) {
        const rect = arrayArea.getBoundingClientRect();
        const W = Math.max(rect.width, 320);
        const n = A.length;
        const nodeW = 52;
        const gap = 12;
        const totalW = n * nodeW + Math.max(0, (n - 1) * gap);
        const startX = (W - totalW) / 2;
        const left = startX + i * (nodeW + gap);
        const top = (rect.height - nodeW) / 2;
        return { left: left, top: top };
      }

      // draw edges connecting parent i to children
      function drawEdges() {
        const n = A.length;
        for (let i = 0; i < n; i++) {
          const leftIdx = 2 * i + 1;
          const rightIdx = 2 * i + 2;

          if (leftIdx < n && edges[leftIdx]) {
            const p = treeCoords(i);
            const c = treeCoords(leftIdx);
            placeEdge(edges[leftIdx], p.left + 24, p.top + 24, c.left + 24, c.top + 24); // center coords
          }
          if (rightIdx < n && edges[rightIdx]) {
            const p = treeCoords(i);
            const c = treeCoords(rightIdx);
            placeEdge(edges[rightIdx], p.left + 24, p.top + 24, c.left + 24, c.top + 24);
          }
        }
      }

      // position a single edge between (x1,y1) parent and (x2,y2) child
      function placeEdge(el, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const len = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        el.style.width = Math.max(2, len) + 'px';
        el.style.left = x1 + 'px';
        el.style.top = y1 + 'px';
        el.style.transform = `rotate(${angle}deg)`;
      }

      // Position all nodes and edges according to current A (uses left/top transitions)
      function positionAll() {
        const n = A.length;
        // ensure nodes exist
        for (let i = 0; i < n; i++) {
          const coordsT = treeCoords(i);
          const coordsA = arrayCoords(i);
          const node = nodes[i];
          // set left/top absolutely relative to containers
          node.tree.style.left = coordsT.left + 'px';
          node.tree.style.top = coordsT.top + 'px';
          node.array.style.left = coordsA.left + 'px';
          node.array.style.top = coordsA.top + 'px';
          // update labels
          node.tree.textContent = String(A[i]);
          node.array.textContent = String(A[i]);
          node.tree.setAttribute('data-index', i);
          node.array.setAttribute('data-index', i);
        }
        // draw edges
        drawEdges();
      }

      // update stats display
      function updateStats() {
        nVal.textContent = String(A.length);
        compEl.textContent = String(compCount);
        swapsEl.textContent = String(swapCount);
        stepCountEl.textContent = String(currentStepIndex);
      }

      // clear highlights
      function clearHighlights() {
        nodes.forEach(n => {
          n.tree.classList.remove('active', 'swap', 'ghost');
          n.array.classList.remove('active', 'swap', 'ghost');
        });
        edges.forEach(e => {
          if (e) e.classList.remove('active');
        });
      }

      // Snapshot state to history (deep copy)
      function snapshot(note = '') {
        history.push({
          A: A.slice(),
          comp: compCount,
          swaps: swapCount,
          heapSize: heapSize,
          note: note
        });
      }

      // Restore snapshot (used for stepping back)
      function restoreSnapshot(idx) {
        if (idx < 0 || idx >= history.length) return;
        const s = history[idx];
        A = s.A.slice();
        compCount = s.comp;
        swapCount = s.swaps;
        heapSize = s.heapSize;
        // rebuild visuals and position
        buildVisuals();
        currentStepIndex = idx;
        updateStats();
        clearHighlights();
        statusText.textContent = s.note || 'Restored';
      }

      // Sequence steps generation for heap sort (logical operations recorded)
      // We'll build steps array describing comparisons/swaps/sift-start/sift-end and messages
      function generateSteps() {
        steps = [];
        compCount = 0;
        swapCount = 0;
        // Work on a copy so we can generate steps deterministically
        const B = A.slice();
        const n = B.length;

        // Helper to push step objects
        function push(type, i, j, message) {
          steps.push({ type, i, j, message, arr: B.slice() });
        }

        // SiftDown logic (record comparisons and swaps)
        function siftDown(arr, i, last) {
          push('sift-start', i, last, `SiftDown start at index ${i}`);
          while (true) {
            const left = 2 * i + 1;
            const right = 2 * i + 2;
            let largest = i;
            if (left <= last) {
              push('compare', left, largest, `Compare A[${left}] (${arr[left]}) with A[${largest}] (${arr[largest]})`);
              compCount++;
              if (arr[left] > arr[largest]) {
                largest = left;
              }
            }
            if (right <= last) {
              push('compare', right, largest, `Compare A[${right}] (${arr[right]}) with A[${largest}] (${arr[largest]})`);
              compCount++;
              if (arr[right] > arr[largest]) {
                largest = right;
              }
            }
            if (largest === i) {
              push('sift-end', i, last, `SiftDown end at index ${i}`);
              break;
            }
            // swap
            push('swap', i, largest, `Swap A[${i}] (${arr[i]}) and A[${largest}] (${arr[largest]})`);
            swapCount++;
            const tmp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = tmp;
            i = largest;
          }
        }

        // Build max-heap
        for (let start = Math.floor(n / 2) - 1; start >= 0; start--) {
          siftDown(B, start, n - 1);
        }

        // Extraction phase
        for (let end = n - 1; end >= 1; end--) {
          push('swap', 0, end, `Swap root A[0] (${B[0]}) with A[${end}] (${B[end]})`);
          swapCount++;
          const tmp = B[0]; B[0] = B[end]; B[end] = tmp;
          // mark new heap size for steps
          push('heap-shrink', 0, end - 1, `Heap size is now ${end}`);
          siftDown(B, 0, end - 1);
        }
        // final note
        push('done', -1, -1, 'Sorting complete');
        // Reset counters to zero before playing; we'll count during playback
        compCount = 0;
        swapCount = 0;
      }

      // Animation helpers: highlight nodes, animate swap by changing A and moving DOM nodes
      function highlightCompare(i, j) {
        clearHighlights();
        if (nodes[i]) {
          nodes[i].tree.classList.add('active');
          nodes[i].array.classList.add('active');
        }
        if (nodes[j]) {
          nodes[j].tree.classList.add('active');
          nodes[j].array.classList.add('active');
        }
        // highlight path edges (if parent-child)
        const minIdx = Math.min(i, j);
        // set any common edge active if directly connected
        // if j is left child of i or vice versa
        if (2 * i + 1 === j) setEdgeActive(j, true);
        if (2 * i + 2 === j) setEdgeActive(j, true);
        if (2 * j + 1 === i) setEdgeActive(i, true);
        if (2 * j + 2 === i) setEdgeActive(i, true);
      }

      function setEdgeActive(childIdx, on) {
        if (!edges[childIdx]) return;
        if (on) edges[childIdx].classList.add('active');
        else edges[childIdx].classList.remove('active');
      }

      function animateSwap(i, j, callback) {
        if (i === j) {
          callback && callback();
          return;
        }
        clearHighlights();
        // mark swap style
        nodes[i].tree.classList.add('swap');
        nodes[j].tree.classList.add('swap');
        nodes[i].array.classList.add('swap');
        nodes[j].array.classList.add('swap');

        // swap positions in DOM by swapping style left/top values (we animate by updating left/top)
        const coordsTi = treeCoords(i), coordsTj = treeCoords(j);
        const coordsAi = arrayCoords(i), coordsAj = arrayCoords(j);

        // apply new positions (they will transition)
        nodes[i].tree.style.left = coordsTj.left + 'px';
        nodes[i].tree.style.top = coordsTj.top + 'px';
        nodes[j].tree.style.left = coordsTi.left + 'px';
        nodes[j].tree.style.top = coordsTi.top + 'px';

        nodes[i].array.style.left = coordsAj.left + 'px';
        nodes[i].array.style.top = coordsAj.top + 'px';
        nodes[j].array.style.left = coordsAi.left + 'px';
        nodes[j].array.style.top = coordsAi.top + 'px';

        // After transition duration (match CSS transition ~420ms)
        setTimeout(() => {
          // swap node references in the nodes array so indexes map correctly
          const temp = nodes[i];
          nodes[i] = nodes[j];
          nodes[j] = temp;
          // Update their attributes and text to current A values (we assume A already updated)
          nodes[i].tree.setAttribute('data-index', i);
          nodes[i].array.setAttribute('data-index', i);
          nodes[j].tree.setAttribute('data-index', j);
          nodes[j].array.setAttribute('data-index', j);
          nodes[i].tree.textContent = String(A[i]);
          nodes[i].array.textContent = String(A[i]);
          nodes[j].tree.textContent = String(A[j]);
          nodes[j].array.textContent = String(A[j]);

          // remove swap class
          nodes[i].tree.classList.remove('swap');
          nodes[j].tree.classList.remove('swap');
          nodes[i].array.classList.remove('swap');
          nodes[j].array.classList.remove('swap');

          // reposition all edges and nodes to ensure consistent layout
          positionAll();
          callback && callback();
        }, Math.max(360, Number(speedInput.value)));
      }

      // Directly move a node to highlight sift target without swapping (used for sift start)
      function animateHighlight(i, callback) {
        clearHighlights();
        if (!nodes[i]) { callback && callback(); return; }
        nodes[i].tree.classList.add('active');
        nodes[i].array.classList.add('active');
        setTimeout(() => {
          callback && callback();
        }, Math.max(220, Number(speedInput.value) / 2));
      }

      // Execute one logical step (from steps array)
      function executeStep(stepIdx, forward = true, cb) {
        if (stepIdx < 0 || stepIdx >= steps.length) {
          cb && cb(false);
          return;
        }
        const s = steps[stepIdx];
        statusText.textContent = s.message || '';
        switch (s.type) {
          case 'sift-start':
            highlightCompare(s.i, s.j);
            snapshot(s.message);
            currentStepIndex++;
            updateStats();
            setTimeout(() => cb && cb(true), Math.max(180, Number(speedInput.value) / 2));
            break;
          case 'compare':
            compCount++;
            highlightCompare(s.i, s.j);
            snapshot(s.message);
            currentStepIndex++;
            updateStats();
            setTimeout(() => cb && cb(true), Math.max(180, Number(speedInput.value) / 2));
            break;
          case 'swap':
            // apply swap to A first
            const ii = s.i, jj = s.j;
            const tmp = A[ii]; A[ii] = A[jj]; A[jj] = tmp;
            swapCount++;
            // animate swap on DOM
            animateSwap(ii, jj, () => {
              snapshot(s.message);
              currentStepIndex++;
              updateStats();
              cb && cb(true);
            });
            break;
          case 'heap-shrink':
            heapSize = s.j + 1;
            snapshot(s.message);
            currentStepIndex++;
            updateStats();
            cb && cb(true);
            break;
          case 'sift-end':
            highlightCompare(s.i, s.j);
            snapshot(s.message);
            currentStepIndex++;
            updateStats();
            setTimeout(() => cb && cb(true), Math.max(160, Number(speedInput.value) / 2));
            break;
          case 'done':
            snapshot(s.message);
            currentStepIndex++;
            updateStats();
            clearHighlights();
            statusText.textContent = 'Done';
            cb && cb(true);
            break;
          default:
            snapshot(s.message || 'step');
            currentStepIndex++;
            updateStats();
            cb && cb(true);
            break;
        }
      }

      // Play/pause loop: execute steps sequentially
      function play() {
        if (playing) return;
        playing = true;
        playBtn.textContent = 'Pause';
        statusText.textContent = 'Playing';
        const runNext = () => {
          const idx = currentStepIndex;
          if (idx >= steps.length) {
            playing = false;
            playBtn.textContent = 'Play';
            statusText.textContent = 'Finished';
            return;
          }
          executeStep(idx, true, (done) => {
            if (!playing) return;
            // schedule next
            const delay = Number(speedInput.value);
            timer = setTimeout(() => {
              runNext();
            }, delay);
          });
        };
        runNext();
      }

      function pause() {
        playing = false;
        playBtn.textContent = 'Play';
        statusText.textContent = 'Paused';
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      }

      // Single step forward
      function stepForward() {
        pause();
        if (currentStepIndex >= steps.length) {
          statusText.textContent = 'Done';
          return;
        }
        executeStep(currentStepIndex, true, () => {});
      }

      // Step backward using history snapshots
      function stepBackward() {
        pause();
        // cannot step back before 0
        if (currentStepIndex <= 0) {
          statusText.textContent = 'Beginning';
          return;
        }
        // restore previous snapshot
        const prevIndex = currentStepIndex - 1;
        restoreSnapshot(prevIndex);
      }

      // Load array and prepare steps & visuals
      function loadArray(arr) {
        if (!Array.isArray(arr)) return;
        A = arr.slice(0, MAX_NODES);
        // rebuild visuals
        buildVisuals();
        // compute steps
        generateSteps();
        // clear history and initialize
        history = [];
        // set initial snapshot before any steps
        compCount = 0; swapCount = 0; heapSize = A.length;
        snapshot('Initial');
        currentStepIndex = 0;
        updateStats();
        statusText.textContent = 'Ready';
      }

      // Handlers
      loadBtn.addEventListener('click', () => {
        const parsed = parseInput(arrayInput.value);
        if (!parsed || parsed.length === 0) {
          alert('Please enter a comma-separated list of integers (e.g., 5,3,8,1)');
          return;
        }
        if (parsed.length > MAX_NODES) {
          if (!confirm(`Trimming to first ${MAX_NODES} elements for clarity.`)) return;
        }
        loadArray(parsed);
      });

      randBtn.addEventListener('click', () => {
        const n = Math.floor(Math.random() * 6) + 6; // random 6..11
        const arr = [];
        for (let i = 0; i < n; i++) arr.push(Math.floor(Math.random() * 99));
        arrayInput.value = arr.join(', ');
        loadArray(arr);
      });

      smallBtn.addEventListener('click', () => {
        const arr = [12, 7, 9, 3, 15, 8, 4];
        arrayInput.value = arr.join(', ');
        loadArray(arr);
      });

      resetBtn.addEventListener('click', () => {
        pause();
        history = [];
        steps = [];
        A = [];
        treeArea.innerHTML = '';
        arrayArea.innerHTML = '';
        nVal.textContent = '0';
        compEl.textContent = '0';
        swapsEl.textContent = '0';
        stepCountEl.textContent = '0';
        statusText.textContent = 'Reset';
      });

      playBtn.addEventListener('click', () => {
        if (!A || A.length === 0) { alert('Load an array first.'); return; }
        if (!playing) play(); else pause();
      });

      stepFwd.addEventListener('click', stepForward);
      stepBack.addEventListener('click', stepBackward);

      // speed control update
      speedInput.addEventListener('input', () => {
        // live update; transitions already use CSS value but we referenced speedInput in JS timers
      });

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          if (!A || A.length === 0) return;
          if (playing) pause(); else play();
        } else if (e.code === 'ArrowRight') {
          e.preventDefault();
          stepForward();
        } else if (e.code === 'ArrowLeft') {
          e.preventDefault();
          stepBackward();
        }
      });

      // On window resize, reposition nodes
      window.addEventListener('resize', () => {
        if (A && A.length) positionAll();
      });

      // Initialize with a sample
      initSample();

      // Accessibility: expose some functions for debugging (not required)
      window._heapSortModule = {
        loadArray, play, pause, stepForward, stepBackward, getState: () => ({ A, compCount, swapCount, currentStepIndex })
      };
    })();
  </script>
</body>
</html>