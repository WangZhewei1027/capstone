<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merge Sort Interactive Visualizer</title>
  <style>
    :root{
      --safe: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --good: #10b981;
      --compare: #f59e0b;
      --danger: #ef4444;
      --text: #e6eef6;
      --bar-min-width: 28px;
      --max-array: 20;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      padding:var(--safe);
      background:linear-gradient(180deg,#081226 0%, #021022 100%);
      color:var(--text);
      font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    header{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      margin-bottom:var(--gap);
      flex-wrap:wrap;
    }
    header h1{
      margin:0;
      font-size:1.25rem;
      line-height:1.1;
      color:var(--accent);
    }
    header p{margin:0;color:var(--muted);font-size:0.95rem}
    .container{
      display:grid;
      grid-template-columns: 1fr 380px;
      gap:var(--gap);
      align-items:start;
    }
    @media (max-width:900px){
      .container{grid-template-columns:1fr}
    }

    /* Left panel: visualization */
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:var(--gap);
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:var(--gap);
      align-items:center;
      margin-bottom:var(--gap);
    }
    .controls > *{min-width:0}
    .control-group{
      display:flex;
      gap:8px;
      align-items:center;
    }
    label{font-size:0.85rem;color:var(--muted)}
    input[type="range"]{accent-color:var(--accent)}
    button{
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      color:var(--text);
      border:1px solid rgba(255,255,255,0.04);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      min-height:40px;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:0.95rem;
    }
    button:focus{outline:2px solid rgba(6,182,212,0.25)}
    .small{padding:6px 8px;font-size:0.9rem;min-height:36px}
    .input-inline{display:flex;gap:8px;align-items:center}
    input[type="text"]{
      background:transparent;border:1px dashed rgba(255,255,255,0.06);
      color:var(--text);padding:8px;border-radius:8px;min-width:180px;
    }

    .viz{
      position:relative;
      height:320px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      border-radius:8px;padding:12px;
      display:flex;flex-direction:column;gap:12px;
      align-items:stretch;
      overflow:hidden;
    }
    .array-area{
      position:relative;
      flex:1;
      display:block;
      align-items:flex-end;
      width:100%;
      border-radius:6px;
      padding:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.00), rgba(255,255,255,0.00));
      overflow:hidden;
    }
    .bars{
      position:relative;
      height:100%;
      width:100%;
      display:block;
    }
    .bar{
      position:absolute;
      bottom:18px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      gap:6px;
      transform-origin:bottom left;
      transition: transform 350ms cubic-bezier(.25,.8,.25,1), background-color 200ms, height 200ms;
      cursor:grab;
      border-radius:6px;
      min-width:var(--bar-min-width);
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      user-select:none;
    }
    .bar:active{cursor:grabbing}
    .bar .label{
      transform:translateY(-100%);
      font-size:0.82rem;
      color:var(--panel);
      background:rgba(255,255,255,0.95);
      padding:2px 6px;border-radius:4px;font-weight:600;
      box-shadow:0 2px 6px rgba(0,0,0,0.2)
    }
    .bar .value{
      writing-mode:vertical-rl;
      transform:rotate(180deg);
      font-weight:700;color:var(--panel);padding:6px 8px;font-size:0.85rem;
    }
    .bar.default{background:linear-gradient(180deg,#60a5fa,#3b82f6)}
    .bar.compare{background:linear-gradient(180deg,#fbbf24,#f97316)}
    .bar.take{background:linear-gradient(180deg,#34d399,#10b981)}
    .bar.done{outline:2px solid rgba(16,185,129,0.14)}
    .legend{display:flex;gap:12px;align-items:center;color:var(--muted);font-size:0.9rem}
    .legend span{display:inline-flex;gap:6px;align-items:center}
    .swatch{width:14px;height:14px;border-radius:4px}

    /* Right panel: pseudocode & stack */
    .side{
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:var(--gap);
      min-height:320px;
    }
    .code{
      background:linear-gradient(180deg,#041425,#021022);
      border-radius:8px;padding:12px;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      color:var(--muted); font-size:0.9rem;line-height:1.35;
      margin-bottom:var(--gap); overflow:auto; max-height:240px;
    }
    .code .line{padding:4px 6px;border-radius:4px}
    .code .active{background:linear-gradient(90deg, rgba(6,182,212,0.06), rgba(6,182,212,0.03)); color:var(--text)}
    .stack{background:linear-gradient(180deg,#071428,#021022);border-radius:8px;padding:10px;color:var(--muted);font-size:0.9rem}
    .stack .frame{padding:6px;border-radius:6px;background:rgba(255,255,255,0.01);margin-bottom:8px}
    .info{margin-top:var(--gap);color:var(--muted);font-size:0.9rem}

    /* status */
    .status{display:flex;align-items:center;gap:12px;color:var(--muted);font-size:0.9rem;margin-top:8px}

    /* small helpers */
    .flex-row{display:flex;gap:12px;align-items:center}
    .muted{color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Merge Sort — Divide, Compare, Merge</h1>
      <p>Interactive, step-by-step visualizer showing recursion, comparisons, and merge placements.</p>
    </div>
  </header>

  <main class="container" id="main">
    <section class="panel" aria-labelledby="vizTitle">
      <div class="controls" role="group" aria-label="Controls">
        <div class="control-group">
          <label for="sizeRange">Size</label>
          <input id="sizeRange" type="range" min="3" max="20" value="8">
        </div>

        <div class="control-group">
          <button id="randomBtn" title="Generate random array">Randomize</button>
          <button id="resetBtn" class="small" title="Reset visualization to initial array">Reset</button>
        </div>

        <div class="control-group input-inline">
          <input id="customInput" type="text" placeholder="e.g. 5,2,9,1" aria-label="custom array">
          <button id="loadBtn" title="Load custom array">Load</button>
        </div>

        <div class="control-group" style="margin-left:auto">
          <button id="stepBack" title="Step back">◀</button>
          <button id="playPause" title="Play">Play ▶</button>
          <button id="stepForward" title="Step forward">▶</button>
        </div>

        <div class="control-group">
          <label for="speedRange">Speed</label>
          <input id="speedRange" type="range" min="100" max="1500" value="650">
        </div>
      </div>

      <div class="viz" role="region" aria-labelledby="vizTitle" tabindex="0">
        <div class="array-area" id="arrayArea">
          <div class="bars" id="bars" aria-live="polite"></div>
        </div>

        <div class="legend" aria-hidden="true">
          <span><i class="swatch" style="background:linear-gradient(180deg,#60a5fa,#3b82f6)"></i>Unprocessed</span>
          <span><i class="swatch" style="background:linear-gradient(180deg,#fbbf24,#f97316)"></i>Comparing</span>
          <span><i class="swatch" style="background:linear-gradient(180deg,#34d399,#10b981)"></i>Placed</span>
        </div>

        <div class="status" id="statusLine">Ready. Step through Merge Sort to see comparisons and merges.</div>
      </div>
    </section>

    <aside class="side" aria-labelledby="codeTitle">
      <div class="code" id="pseudocode" tabindex="0" aria-label="Pseudocode">
        <div class="line" data-line="0">mergeSort(A, l, r):</div>
        <div class="line" data-line="1">&nbsp;&nbsp;if l >= r: return</div>
        <div class="line" data-line="2">&nbsp;&nbsp;mid = (l + r) // 2</div>
        <div class="line" data-line="3">&nbsp;&nbsp;mergeSort(A, l, mid)</div>
        <div class="line" data-line="4">&nbsp;&nbsp;mergeSort(A, mid+1, r)</div>
        <div class="line" data-line="5">&nbsp;&nbsp;merge(A, l, mid, r)</div>
        <div style="height:8px"></div>
        <div class="line" data-line="6">merge(A, l, mid, r):</div>
        <div class="line" data-line="7">&nbsp;&nbsp;create temp arrays L, R</div>
        <div class="line" data-line="8">&nbsp;&nbsp;i = j = 0; k = l</div>
        <div class="line" data-line="9">&nbsp;&nbsp;while i < len(L) and j < len(R):</div>
        <div class="line" data-line="10">&nbsp;&nbsp;&nbsp;&nbsp;if L[i] <= R[j]: A[k] = L[i]; i++</div>
        <div class="line" data-line="11">&nbsp;&nbsp;&nbsp;&nbsp;else: A[k] = R[j]; j++</div>
        <div class="line" data-line="12">&nbsp;&nbsp;&nbsp;&nbsp;k++</div>
        <div class="line" data-line="13">&nbsp;&nbsp;copy remaining elements</div>
      </div>

      <div class="stack" id="stack" aria-live="polite" aria-atomic="true" style="margin-top:var(--gap)">
        <div style="font-weight:700;margin-bottom:8px;color:var(--text)">Recursion Stack</div>
        <div id="stackFrames" role="list"></div>
      </div>

      <div class="info">
        <strong>How to explore</strong>
        <ul style="margin-top:6px;color:var(--muted);padding-left:18px">
          <li>Use Play to animate steps automatically (speed slider controls delay).</li>
          <li>Step forward/back to inspect individual comparisons and placements.</li>
          <li>Click a bar to edit its value. Drag bars to reorder the initial array.</li>
        </ul>
      </div>
    </aside>
  </main>

  <script>
    // Merge Sort Visualizer (vanilla JS)
    (function(){
      // DOM refs
      const sizeRange = document.getElementById('sizeRange');
      const randomBtn = document.getElementById('randomBtn');
      const resetBtn = document.getElementById('resetBtn');
      const loadBtn = document.getElementById('loadBtn');
      const customInput = document.getElementById('customInput');
      const barsContainer = document.getElementById('bars');
      const playPauseBtn = document.getElementById('playPause');
      const stepForwardBtn = document.getElementById('stepForward');
      const stepBackBtn = document.getElementById('stepBack');
      const speedRange = document.getElementById('speedRange');
      const statusLine = document.getElementById('statusLine');
      const stackFrames = document.getElementById('stackFrames');
      const pseudocode = document.getElementById('pseudocode');
      const sizeMin = parseInt(sizeRange.min,10);
      const sizeMax = parseInt(sizeRange.max,10);

      let initialArray = [];
      let elements = []; // objects: {id, value}
      let steps = []; // recorded actions
      let currentStep = -1;
      let playing = false;
      let playTimer = null;

      // settings
      const MIN_BAR_WIDTH = 28;
      const gap = 8;

      // Generate unique ids
      let uid = 1;
      function makeId(){ return (uid++).toString(); }

      // Utilities
      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

      // Create random array
      function randArray(n){
        const arr = [];
        for(let i=0;i<n;i++){
          arr.push(Math.floor(Math.random()*90)+10);
        }
        return arr;
      }

      // Initialize
      function initArrayFromValues(vals){
        initialArray = vals.slice(0, sizeMax);
        elements = initialArray.map(v => ({id: makeId(), v: Number(v)}));
        resetVisualizer(true);
      }

      function generateRandom(){
        const n = Number(sizeRange.value);
        initArrayFromValues(randArray(n));
      }

      // Create bar DOM for each element
      function renderBars(){
        barsContainer.innerHTML = '';
        // compute widths
        const containerWidth = barsContainer.clientWidth;
        const n = elements.length || 1;
        let barWidth = Math.max(MIN_BAR_WIDTH, Math.floor((containerWidth - (n+1)*gap)/n));
        const totalWidth = n*barWidth + (n-1)*gap;
        const startLeft = Math.max(0, (containerWidth - totalWidth)/2);

        // find min/max for scale
        const values = elements.map(e=>e.v);
        const minV = Math.min(...values);
        const maxV = Math.max(...values);
        const range = Math.max(1, maxV - minV);

        elements.forEach((el, idx) => {
          const left = startLeft + idx*(barWidth + gap);
          const bar = document.createElement('div');
          bar.className = 'bar default';
          bar.setAttribute('data-id', el.id);
          bar.setAttribute('tabindex','0');
          bar.setAttribute('role','button');
          bar.setAttribute('aria-label', `Index ${idx}, value ${el.v}`);
          bar.style.width = barWidth + 'px';
          bar.style.left = left + 'px';
          bar.style.transition = 'transform 350ms cubic-bezier(.25,.8,.25,1), background-color 200ms';
          const heightPct = 12 + ((el.v - minV)/range)*78; // 12%..90% height
          bar.style.height = heightPct + '%';

          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = el.v;
          const val = document.createElement('div');
          val.className = 'value';
          val.textContent = el.v;

          // we place label above as floating text
          bar.appendChild(label);
          bar.appendChild(val);
          barsContainer.appendChild(bar);

          // events: click to edit
          bar.addEventListener('click', (e)=>{
            e.stopPropagation();
            const newVal = prompt('Edit value (integer):', String(el.v));
            if(newVal !== null){
              const parsed = Number(newVal);
              if(!Number.isNaN(parsed)){
                el.v = parsed;
                initialArray = elements.map(x=>x.v);
                renderBars();
                resetVisualizer(true);
              }
            }
          });

          // keyboard edit
          bar.addEventListener('keydown', (ev)=>{
            if(ev.key === 'Enter'){
              ev.preventDefault();
              bar.click();
            }
          });

          // drag-and-drop reordering (horizontal)
          let startX = 0, dragging=false, origLeft = 0;
          bar.addEventListener('pointerdown', (ev)=>{
            dragging = true;
            startX = ev.clientX;
            origLeft = parseFloat(bar.style.left);
            bar.setPointerCapture(ev.pointerId);
            bar.style.transition = 'none';
            bar.style.zIndex = 1000;
          });
          window.addEventListener('pointermove', (ev)=>{
            if(!dragging) return;
            const dx = ev.clientX - startX;
            bar.style.left = (origLeft + dx) + 'px';
          });
          window.addEventListener('pointerup', (ev)=>{
            if(!dragging) return;
            dragging = false;
            bar.style.transition = '';
            bar.style.zIndex = '';
            // compute nearest index by center distance
            const rects = Array.from(barsContainer.querySelectorAll('.bar')).map(b => {
              return {id: b.getAttribute('data-id'), left: parseFloat(b.style.left), el:b};
            });
            // sort by left
            rects.sort((a,b)=>a.left - b.left);
            const newOrderIds = rects.map(r => r.id);
            // reorder elements array to match ids
            elements.sort((a,b)=> newOrderIds.indexOf(a.id) - newOrderIds.indexOf(b.id));
            initialArray = elements.map(x=>x.v);
            // re-render to snap into place
            renderBars();
            resetVisualizer(true);
          });
        });
      }

      // Prepare steps by running merge sort recording actions
      function recordSteps(){
        steps = [];
        const arr = elements.map(e => ({id: e.id, v: e.v}));
        function push(action){
          steps.push(action);
        }

        function mergeSort(A, l, r){
          push({type:'enter', l, r});
          if(l >= r){
            push({type:'exit', l, r});
            return;
          }
          const m = Math.floor((l+r)/2);
          push({type:'marker', line:2, l, r, m});
          mergeSort(A, l, m);
          mergeSort(A, m+1, r);
          // perform merge with recording
          const left = A.slice(l, m+1);
          const right = A.slice(m+1, r+1);
          push({type:'mergeStart', l, m, r, left: left.map(x=>x.id), right: right.map(x=>x.id)});
          let i=0,j=0,k=l;
          while(i<left.length && j<right.length){
            push({type:'compare', leftId:left[i].id, rightId:right[j].id, l, m, r});
            if(left[i].v <= right[j].v){
              push({type:'take', fromId:left[i].id, toIndex:k});
              A[k] = left[i]; i++;
            } else {
              push({type:'take', fromId:right[j].id, toIndex:k});
              A[k] = right[j]; j++;
            }
            k++;
          }
          while(i<left.length){
            push({type:'take', fromId:left[i].id, toIndex:k});
            A[k] = left[i]; i++; k++;
          }
          while(j<right.length){
            push({type:'take', fromId:right[j].id, toIndex:k});
            A[k] = right[j]; j++; k++;
          }
          push({type:'mergeEnd', l, m, r, ids: A.slice(l, r+1).map(x=>x.id)});
          push({type:'exit', l, r});
        }

        mergeSort(arr, 0, arr.length-1);
      }

      // Helper to find DOM bar by id
      function barById(id){
        return barsContainer.querySelector('.bar[data-id="'+id+'"]');
      }

      // Update pseudocode highlight
      function highlightCodeFor(action){
        const mapping = {
          'enter':1,
          'marker':2,
          'compare':9,
          'mergeStart':7,
          'take':10,
          'mergeEnd':13,
          'exit':1
        };
        const target = mapping[action.type] || 0;
        const lines = pseudocode.querySelectorAll('.line');
        lines.forEach(l=>{
          const n = Number(l.getAttribute('data-line'));
          if(n === target) l.classList.add('active'); else l.classList.remove('active');
        });
      }

      // Update recursion stack display
      function updateStack(upToStepIndex){
        stackFrames.innerHTML = '';
        // emulate stack by tracking enter/exit up to currentStep
        const active = [];
        for(let i=0;i<=upToStepIndex && i<steps.length;i++){
          const s = steps[i];
          if(s.type === 'enter'){
            active.push({l:s.l, r:s.r});
          } else if(s.type === 'exit'){
            // pop last matching l,r
            for(let k=active.length-1;k>=0;k--){
              if(active[k].l === s.l && active[k].r === s.r){
                active.splice(k,1); break;
              }
            }
          }
        }
        // display active as frames
        for(let i=active.length-1;i>=0;i--){
          const f = document.createElement('div');
          f.className = 'frame';
          f.textContent = `mergeSort(${active[i].l}, ${active[i].r})`;
          stackFrames.appendChild(f);
        }
        if(active.length===0){
          const f = document.createElement('div');
          f.className = 'frame';
          f.textContent = '— stack empty —';
          stackFrames.appendChild(f);
        }
      }

      // Execute one step (apply to DOM)
      function applyStep(index, reverse=false){
        if(index < 0 || index >= steps.length) return;
        const action = steps[index];
        highlightCodeFor(action);
        // update status
        statusLine.textContent = `Step ${index+1}/${steps.length}: ${action.type}`;

        // clear previous compare/take classes
        barsContainer.querySelectorAll('.bar').forEach(b=>{
          b.classList.remove('compare','take');
        });

        // for reverse stepping we will rebuild DOM up to previous steps
        if(reverse){
          // rebuild order based on steps up to index-1
          rebuildToStep(index-1);
          updateStack(index-1);
          return;
        }

        switch(action.type){
          case 'enter':
            updateStack(index);
            break;
          case 'marker':
            updateStack(index);
            break;
          case 'compare':{
            const b1 = barById(action.leftId), b2 = barById(action.rightId);
            if(b1) b1.classList.add('compare');
            if(b2) b2.classList.add('compare');
            // no reordering yet
            updateStack(index);
            break;
          }
          case 'mergeStart':{
            // outline the range (visual cue): find ids in range and add outline class
            // no direct effect; but we can set a subtle outline after mergeEnd
            updateStack(index);
            break;
          }
          case 'take':{
            // animate the bar with fromId to the toIndex position, then reorder elements array
            const bar = barById(action.fromId);
            if(!bar) break;
            bar.classList.add('take');
            // compute target left based on current layout
            const idOrder = elements.map(e=>e.id);
            // find index currently of fromId (it's somewhere)
            const fromIdx = idOrder.indexOf(action.fromId);
            // remove from array and insert at target index position considering existing elements
            // But steps are describing merge into target index in full array. We'll reposition DOM to match new logical order.
            // To simulate movement: compute a new elements order by replacing the item at toIndex in a copy.
            const newOrder = elements.slice().map(e=>e);
            // remove the element with fromId from its current position
            const removed = newOrder.splice(fromIdx,1)[0];
            // insert at toIndex
            newOrder.splice(action.toIndex, 0, removed);
            elements = newOrder;
            // animate reflow by re-rendering positions without changing inner content
            animateToPositions();
            updateStack(index);
            break;
          }
          case 'mergeEnd':{
            // mark finalized segment as done
            action.ids.forEach(id=>{
              const b = barById(id); if(b) b.classList.add('done');
            });
            updateStack(index);
            break;
          }
          case 'exit':{
            updateStack(index);
            break;
          }
        }
      }

      // Rebuild elements and DOM to reflect result after given step index
      function rebuildToStep(stepIndex){
        // Start from original initialArray
        elements = initialArray.map(v => ({id: makeId(), v: Number(v)}));
        // But we must use consistent ids used in recorded steps; to simplify, when building steps we use current element ids.
        // For robust reverse stepping: instead of complex inverse operations, we will re-run steps up to stepIndex forward to reconstruct state.
        // So reinitialize elements with the starting ids saved at step recording time.
        // To do that, store starting ids snapshot when recording steps.
        // For simplicity: when stepping backwards, we will just re-render initial state and then apply actions up to stepIndex.
        // Implementation:
        // Reset elements to saved startingElements
        if(originalElementsSnapshot && originalElementsSnapshot.length){
          elements = originalElementsSnapshot.map(x=>({id:x.id, v:x.v}));
        }
        // apply all steps up to stepIndex
        for(let i=0;i<=stepIndex && i<steps.length;i++){
          const s = steps[i];
          if(s.type === 'take'){
            // move element with id to position toIndex
            const idx = elements.findIndex(e=>e.id === s.fromId);
            if(idx>=0){
              const [el] = elements.splice(idx,1);
              elements.splice(s.toIndex,0,el);
            }
          } else if(s.type === 'mergeEnd'){
            // nothing structural beyond takes
          }
        }
        renderBars();
      }

      // animate existing DOM bars to match elements[] positions (no DOM rebuild)
      function animateToPositions(){
        const containerWidth = barsContainer.clientWidth;
        const n = elements.length || 1;
        let barElems = Array.from(barsContainer.querySelectorAll('.bar'));
        // map id->bar element
        const barMap = {};
        barElems.forEach(b=>barMap[b.getAttribute('data-id')] = b);
        // compute sizes similar to renderBars
        let barWidth = Math.max(MIN_BAR_WIDTH, Math.floor((containerWidth - (n+1)*gap)/n));
        const totalWidth = n*barWidth + (n-1)*gap;
        const startLeft = Math.max(0, (containerWidth - totalWidth)/2);
        // get current heights range
        const values = elements.map(e=>e.v);
        const minV = Math.min(...values);
        const maxV = Math.max(...values);
        const range = Math.max(1, maxV - minV);

        elements.forEach((el, idx)=>{
          const left = startLeft + idx*(barWidth + gap);
          let bar = barMap[el.id];
          if(!bar){
            // create new bar if missing
            bar = document.createElement('div');
            bar.className = 'bar default';
            bar.setAttribute('data-id', el.id);
            bar.setAttribute('tabindex','0');
            bar.innerHTML = '<div class="label"></div><div class="value"></div>';
            barsContainer.appendChild(bar);
          }
          bar.style.width = barWidth + 'px';
          bar.style.left = left + 'px';
          const heightPct = 12 + ((el.v - minV)/range)*78;
          bar.style.height = heightPct + '%';
          const lbl = bar.querySelector('.label');
          const val = bar.querySelector('.value');
          if(lbl) lbl.textContent = el.v;
          if(val) val.textContent = el.v;
          bar.setAttribute('aria-label', `Index ${idx}, value ${el.v}`);
        });
      }

      // reset visualizer state: re-render and record steps
      let originalElementsSnapshot = null;
      function resetVisualizer(skipRecord=false){
        // snapshot original elements with their ids to support rebuild
        originalElementsSnapshot = elements.map(e => ({id:e.id, v:e.v}));
        renderBars();
        if(!skipRecord){
          recordSteps();
        } else {
          // record steps to reflect current element IDs
          recordSteps();
        }
        currentStep = -1;
        playing = false;
        playPauseBtn.textContent = 'Play ▶';
        updateStatus();
      }

      function updateStatus(){
        statusLine.textContent = `Ready — ${elements.length} elements. Steps recorded: ${steps.length}`;
      }

      // Step control functions
      function stepForward(){
        if(currentStep < steps.length -1){
          currentStep++;
          applyStep(currentStep, false);
        }
        if(currentStep >= steps.length-1){
          stopPlaying();
        }
      }
      function stepBack(){
        if(currentStep > -1){
          currentStep--;
          if(currentStep === -1){
            // fully reset
            rebuildToInitial();
            updateStack(-1);
            highlightCodeFor({type:'enter'});
            statusLine.textContent = 'At start';
          } else {
            rebuildToStep(currentStep);
            updateStack(currentStep);
          }
        }
      }

      function rebuildToInitial(){
        // rebuild DOM to initial snapshot
        elements = originalElementsSnapshot.map(x=>({id:x.id, v:x.v}));
        renderBars();
      }

      function play(){
        if(playing) return;
        playing = true;
        playPauseBtn.textContent = 'Pause ❚❚';
        const delay = Number(speedRange.value);
        function tick(){
          if(currentStep < steps.length -1){
            currentStep++;
            applyStep(currentStep, false);
            playTimer = setTimeout(tick, delay);
          } else {
            stopPlaying();
          }
        }
        playTimer = setTimeout(tick, 0);
      }
      function stopPlaying(){
        playing = false;
        playPauseBtn.textContent = 'Play ▶';
        if(playTimer) { clearTimeout(playTimer); playTimer = null; }
      }
      function togglePlay(){
        if(playing) stopPlaying(); else play();
      }

      // Event listeners
      randomBtn.addEventListener('click', generateRandom);
      sizeRange.addEventListener('input', ()=>{
        const n = Number(sizeRange.value);
        initArrayFromValues(randArray(n));
      });
      loadBtn.addEventListener('click', ()=>{
        const text = customInput.value.trim();
        if(!text) return;
        const parts = text.split(',').map(s=>s.trim()).filter(s=>s.length);
        const vals = parts.map(s=>Number(s)).filter(x=>!Number.isNaN(x));
        if(vals.length && vals.length <= sizeMax){
          sizeRange.value = vals.length;
          initArrayFromValues(vals);
        } else if(vals.length > sizeMax){
          alert('Max allowed elements: ' + sizeMax);
        } else {
          alert('No valid numbers found in input');
        }
      });

      resetBtn.addEventListener('click', ()=>{
        rebuildToInitial();
        currentStep = -1;
        stopPlaying();
        updateStack(-1);
        highlightCodeFor({type:'enter'});
        statusLine.textContent = 'Reset to initial array';
      });

      playPauseBtn.addEventListener('click', togglePlay);
      stepForwardBtn.addEventListener('click', ()=>{
        stopPlaying();
        stepForward();
      });
      stepBackBtn.addEventListener('click', ()=>{
        stopPlaying();
        stepBack();
      });

      // keyboard: space toggles play/pause
      window.addEventListener('keydown', (e)=>{
        if(e.code === 'Space'){
          e.preventDefault();
          togglePlay();
        }
        if(e.code === 'ArrowRight'){
          stopPlaying(); stepForward();
        }
        if(e.code === 'ArrowLeft'){
          stopPlaying(); stepBack();
        }
      });

      // responsive render on resize
      window.addEventListener('resize', ()=>{
        renderBars();
      });

      // initial load
      sizeRange.value = 8;
      initArrayFromValues(randArray(Number(sizeRange.value)));

      // record steps now that elements exist
      recordSteps();
      updateStatus();

      // expose for debugging
      window._mergeViz = {
        getSteps: ()=>steps,
        getElements: ()=>elements
      };
    })();
  </script>
</body>
</html>