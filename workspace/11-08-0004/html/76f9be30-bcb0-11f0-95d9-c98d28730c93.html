<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Insertion Sort — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --muted: #9aa7bd;
      --accent: #38bdf8;
      --accent-2: #60a5fa;
      --good: #10b981;
      --warn: #f59e0b;
      --bad: #ef4444;
      --glass: rgba(255,255,255,0.03);
      --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,var(--bg),#071025 60%);
      color: #dbeafe;
      font-family: var(--font-sans);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Safe area container */
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100%;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    /* Top info card: Title + Learning Objective + Plan sections */
    .info {
      background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 18px;
      display:flex;
      gap: var(--gap);
      align-items: flex-start;
      flex-wrap:wrap;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }

    .info .left {
      min-width: 220px;
      max-width: 640px;
    }

    .title {
      font-size: 20px;
      font-weight: 700;
      color: #e6f0ff;
      margin:0 0 6px 0;
    }

    .subtitle {
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    .meta-grid {
      display:flex;
      gap: var(--gap);
      margin-top: 12px;
      flex-wrap:wrap;
    }

    .meta {
      background: rgba(255,255,255,0.02);
      padding:10px 12px;
      border-radius:10px;
      min-width:220px;
      color:var(--muted);
      font-size:13px;
    }

    /* Main interactive area */
    .module {
      display:flex;
      gap: var(--gap);
      align-items: flex-start;
      flex-wrap:wrap;
    }

    /* Left side: controls & pseudocode */
    .controls {
      width: 360px;
      max-width: calc(100% - 380px);
      min-width: 300px;
      background: var(--card);
      border-radius:12px;
      padding: 14px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.5);
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    .row { display:flex; gap: var(--gap); align-items:center; flex-wrap:wrap; }
    label { font-size:13px; color:var(--muted); }
    input[type="text"]{
      flex:1;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      background:transparent;
      color: #e6f0ff;
      outline:none;
    }
    .small {
      padding:6px 8px;
      border-radius:8px;
      background: rgba(255,255,255,0.02);
      color:var(--muted);
      font-size:13px;
      border: none;
    }

    button {
      background: linear-gradient(180deg,var(--accent),var(--accent-2));
      color: #022;
      border:none;
      padding:8px 12px;
      border-radius:8px;
      font-weight:600;
      cursor:pointer;
      transition:transform .08s ease;
    }
    button.secondary {
      background: rgba(255,255,255,0.03);
      color: var(--muted);
      border:1px solid rgba(255,255,255,0.02);
    }
    button:active { transform: translateY(1px); }

    .controls .stats {
      display:flex;
      gap: var(--gap);
      justify-content:space-between;
    }
    .stat {
      background: rgba(255,255,255,0.02);
      padding:10px;
      border-radius:10px;
      min-width:80px;
      text-align:center;
      color:var(--muted);
    }
    .stat .v {
      font-weight:700;
      color:#e6f0ff;
      margin-top:6px;
      font-size:16px;
    }

    .pseudocode {
      background: rgba(255,255,255,0.02);
      padding:10px;
      border-radius:8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:13px;
      color:var(--muted);
      max-height:260px;
      overflow:auto;
    }
    .pseudocode .line {
      padding:6px 8px;
      border-radius:6px;
      display:flex;
      gap:8px;
      align-items:flex-start;
      white-space:pre;
    }
    .pseudocode .line.active {
      background: linear-gradient(90deg, rgba(96,165,250,0.08), rgba(56,189,248,0.04));
      color:#e6f0ff;
      box-shadow: inset 0 0 0 1px rgba(96,165,250,0.06);
    }
    .pseudocode .ln {
      color:#7aa9d9;
      width:26px;
      text-align:right;
      font-weight:600;
      margin-right:8px;
      opacity:0.9;
    }

    /* Visualization area */
    .viz {
      flex:1;
      min-width:320px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008));
      border-radius:12px;
      padding: 16px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      box-shadow: 0 6px 18px rgba(2,6,23,0.55);
    }

    .viz-top {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: var(--gap);
    }
    .legend { display:flex; gap:12px; align-items:center; color:var(--muted); font-size:13px; }
    .legend .k { width:12px; height:12px; border-radius:3px; display:inline-block; margin-right:8px; }

    /* Bar field */
    .field {
      background: linear-gradient(180deg, rgba(255,255,255,0.006), rgba(255,255,255,0.002));
      border-radius:10px;
      padding:14px;
      position:relative;
      height:320px;
      overflow:hidden;
    }
    .bars {
      position:relative;
      height:100%;
      width:100%;
    }
    .bar {
      position:absolute;
      bottom:12px;
      width:48px;
      background: linear-gradient(180deg,#60a5fa,#3b82f6);
      border-radius:8px 8px 6px 6px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:#021124;
      font-weight:700;
      transition: left 450ms cubic-bezier(.2,.9,.2,1), transform 220ms ease, height 450ms cubic-bezier(.2,.9,.2,1), background 220ms;
      box-shadow: 0 8px 18px rgba(3,7,18,0.6);
      cursor:pointer;
      user-select:none;
      outline: none;
    }
    .bar .label {
      position: absolute;
      top:8px;
      color:#e6f0ff;
      font-size:12px;
      font-weight:700;
    }
    .bar.small { width:36px; border-radius:6px; }

    .bar.key { background: linear-gradient(180deg,#fde68a,#f59e0b); color:#06121a; }
    .bar.compared { background: linear-gradient(180deg,#fca5a5,#ef4444); color:#201010; }
    .bar.sorted { background: linear-gradient(180deg,#bbf7d0,#34d399); color:#063018; }

    .controls-compact {
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }

    /* Footer notes */
    .note {
      color: var(--muted);
      font-size:13px;
    }

    /* Responsive */
    @media (max-width: 920px){
      .controls { width:100%; max-width:100%; }
      .viz { width:100%; }
      .info { flex-direction:column; }
    }

    /* Accessibility focus */
    .bar:focus {
      box-shadow: 0 0 0 3px rgba(96,165,250,0.16);
      z-index:2;
    }

  </style>
</head>
<body>
  <div class="app" role="main">
    <!-- Instruction / Plan sections (visible to learners) -->
    <div class="info" aria-labelledby="module-title">
      <div class="left">
        <h1 class="title" id="module-title">Insertion Sort — Stepwise Visualizer</h1>
        <p class="subtitle">Explore how Insertion Sort builds a sorted list one element at a time. Use step controls, autoplay, or set a custom array. Drag or click to edit the initial array before starting.</p>

        <div class="meta-grid">
          <div class="meta">
            <strong>Learning Objective</strong>
            <div style="margin-top:8px;color:var(--muted);font-size:13px;">
              After interacting you will be able to:
              <ul style="margin:8px 0 0 18px; padding:0; color:var(--muted);">
                <li>Trace comparisons and shifts while inserting the key element.</li>
                <li>See how the sorted prefix grows and elements move right to make room.</li>
                <li>Relate the algorithm steps to the pseudocode and complexity counters.</li>
              </ul>
            </div>
          </div>

          <div class="meta">
            <strong>Interaction Design</strong>
            <div style="margin-top:8px;color:var(--muted);font-size:13px;">
              Users interact by:
              <ul style="margin:6px 0 0 18px; padding:0; color:var(--muted);">
                <li>Typing or generating an array, then Start/Step/Play controls to step through algorithm actions.</li>
                <li>Click a bar to select it as the key and use ←/→ keys to reorder the initial array before starting.</li>
                <li>Watching animated shifts and a highlighted pseudocode line that syncs to each action.</li>
              </ul>
            </div>
          </div>
        </div>

      </div>

      <div style="min-width:260px;">
        <div style="background: rgba(255,255,255,0.02); padding:10px; border-radius:8px;">
          <strong style="display:block;color:#e6f0ff;">Layout Description</strong>
          <p class="subtitle" style="margin-top:8px;">
            Safe margins: 24px. Consistent spacing: 16px between controls. Left column houses controls and pseudocode, right column shows visualization with bars, legend and counters. Mobile-first responsive layout stacks columns. All interactive elements have keyboard focus and clear contrast.
          </p>
        </div>
      </div>
    </div>

    <!-- Main interactive module -->
    <div class="module" aria-live="polite">
      <!-- Controls & Pseudocode -->
      <section class="controls" aria-label="Controls and pseudocode">
        <div class="row" style="justify-content:space-between; align-items:center;">
          <div style="display:flex; gap:8px; align-items:center;">
            <label for="array-input">Array</label>
            <input id="array-input" type="text" aria-label="Array input" placeholder="e.g. 5,3,8,1,2" />
          </div>
          <div style="display:flex; gap:8px;">
            <button id="apply" title="Apply array">Apply</button>
            <button id="random" class="secondary" title="Generate random array">Random</button>
          </div>
        </div>

        <div class="row">
          <label>Size</label>
          <input id="size-range" type="range" min="3" max="12" value="8" style="flex:1" />
          <div class="small" id="size-val">8</div>
        </div>

        <div class="row controls-compact" style="justify-content:flex-start;">
          <button id="start">Start</button>
          <button id="step" class="secondary">Step</button>
          <button id="back" class="secondary">Back</button>
          <button id="reset" class="secondary">Reset</button>
          <div style="flex:1"></div>
          <label style="font-size:13px;color:var(--muted);">Speed</label>
          <input id="speed" type="range" min="0.1" max="2" step="0.1" value="1" style="width:120px" />
        </div>

        <div class="row" style="justify-content:space-between;">
          <div class="stats" style="flex:1;">
            <div class="stat">
              <div style="font-size:12px;color:var(--muted);">Comparisons</div>
              <div class="v" id="comp-count">0</div>
            </div>
            <div class="stat">
              <div style="font-size:12px;color:var(--muted);">Moves (shifts)</div>
              <div class="v" id="move-count">0</div>
            </div>
            <div class="stat">
              <div style="font-size:12px;color:var(--muted);">Step</div>
              <div class="v" id="step-counter">0/0</div>
            </div>
          </div>
        </div>

        <div>
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <strong style="color:#e6f0ff;">Pseudocode (highlighted)</strong>
            <div style="color:var(--muted);font-size:13px;">Keyboard: select bar → use ←/→ to reorder before Start</div>
          </div>
          <div class="pseudocode" id="pseudocode" aria-hidden="false">
            <!-- lines inserted by JS -->
          </div>
        </div>

        <div class="note" style="margin-top:6px;">
          Click any bar to select it pre-run; use left/right to swap. While running, bars are animated: red = comparison, yellow = key, green = sorted.
        </div>
      </section>

      <!-- Visualization -->
      <section class="viz" aria-label="Visualization">
        <div class="viz-top">
          <div class="legend">
            <div><span class="k" style="background:#34d399"></span> Sorted</div>
            <div><span class="k" style="background:#fde68a"></span> Key</div>
            <div><span class="k" style="background:#fca5a5"></span> Comparing</div>
          </div>
          <div style="display:flex; gap:12px; align-items:center;">
            <button id="play-toggle" class="secondary" title="Toggle autoplay">Play</button>
            <button id="explain" class="secondary" title="Short explanation">Explain</button>
          </div>
        </div>

        <div class="field" id="field" role="application" aria-label="Array bars field">
          <div class="bars" id="bars" tabindex="0" aria-live="polite">
            <!-- bars created by JS -->
          </div>
        </div>

        <div style="display:flex; justify-content:space-between; gap:16px; align-items:center;">
          <div class="note">Time complexity: Average/O(n^2). Best case (already sorted): O(n).</div>
          <div style="color:var(--muted); font-size:13px;">Tip: use Step for tight control and Back to revisit prior action.</div>
        </div>
      </section>
    </div>
  </div>

  <script>
    // Insertion Sort Visualizer
    (function(){
      // DOM refs
      const arrayInput = document.getElementById('array-input');
      const applyBtn = document.getElementById('apply');
      const randomBtn = document.getElementById('random');
      const sizeRange = document.getElementById('size-range');
      const sizeVal = document.getElementById('size-val');
      const startBtn = document.getElementById('start');
      const stepBtn = document.getElementById('step');
      const backBtn = document.getElementById('back');
      const resetBtn = document.getElementById('reset');
      const playToggle = document.getElementById('play-toggle');
      const explainBtn = document.getElementById('explain');
      const barsContainer = document.getElementById('bars');
      const field = document.getElementById('field');
      const compCountEl = document.getElementById('comp-count');
      const moveCountEl = document.getElementById('move-count');
      const stepCounterEl = document.getElementById('step-counter');
      const speedRange = document.getElementById('speed');
      const pseudocodeEl = document.getElementById('pseudocode');

      // Pseudocode lines
      const codeLines = [
        'for i = 1 to n-1:',
        '  key = A[i]',
        '  j = i - 1',
        '  while j >= 0 and A[j] > key:',
        '    // compare A[j] and key',
        '    A[j+1] = A[j]   // shift right',
        '    j = j - 1',
        '  A[j+1] = key     // insert key',
        '// sorted prefix grows by one'
      ];

      // Render pseudocode
      function renderPseudocode(){
        pseudocodeEl.innerHTML = '';
        codeLines.forEach((ln, idx) => {
          const line = document.createElement('div');
          line.className = 'line';
          line.dataset.ln = idx;
          line.innerHTML = '<div class="ln">'+(idx+1)+'</div><div>'+ln+'</div>';
          pseudocodeEl.appendChild(line);
        });
      }
      renderPseudocode();

      // State
      let array = [];
      let initialArray = [];
      let maxVal = 100;
      let actions = []; // sequence of recorded steps
      let stepIndex = -1; // current action index
      let playing = false;
      let autoplayTimer = null;
      let compCount = 0;
      let moveCount = 0;
      let selectedIndex = null; // for pre-run edits

      // Accessibility: allow keyboard reordering when a bar is selected
      document.addEventListener('keydown', (e) => {
        if (selectedIndex !== null && !isRunning()){
          if (e.key === 'ArrowLeft') { swapPre(selectedIndex, selectedIndex-1); e.preventDefault(); }
          if (e.key === 'ArrowRight') { swapPre(selectedIndex, selectedIndex+1); e.preventDefault(); }
        }
      });

      // Helpers
      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
      function isRunning(){ return actions.length > 0 && stepIndex >= 0 && stepIndex < actions.length && playing; }

      // Create random array
      function randomArray(n){
        const arr = [];
        for(let i=0;i<n;i++) arr.push(Math.floor(Math.random()*maxVal)+1);
        return arr;
      }

      // Apply input
      function applyInput(){
        const val = arrayInput.value.trim();
        if(val){
          const parts = val.split(',').map(s => s.trim()).filter(s=>s!=='');
          const parsed = parts.map(s => {
            const num = Number(s);
            return Number.isFinite(num) ? num : null;
          });
          if(parsed.some(x => x === null)) { alert('Please enter a comma-separated list of numbers.'); return; }
          array = parsed.slice(0, 12);
        } else {
          array = randomArray(Number(sizeRange.value));
        }
        array = array.map(x => Math.round(x));
        initialArray = array.slice();
        resetRunState();
        renderBars();
        updateInputFromArray();
      }

      function updateInputFromArray(){
        arrayInput.value = array.join(', ');
      }

      // Size handler
      sizeRange.addEventListener('input', ()=>{
        sizeVal.textContent = sizeRange.value;
      });

      // Random button
      randomBtn.addEventListener('click', ()=>{
        const n = Number(sizeRange.value)||8;
        array = randomArray(n);
        initialArray = array.slice();
        resetRunState();
        renderBars();
        updateInputFromArray();
      });

      // Apply button
      applyBtn.addEventListener('click', applyInput);

      // Start: build actions from current initialArray and move to step 0
      startBtn.addEventListener('click', ()=>{
        if(actions.length > 0 && stepIndex < actions.length - 1){ /* already ran */ }
        buildActionsFrom(initialArray.slice());
        stepIndex = -1;
        compCount = 0; moveCount = 0;
        updateCounters();
        // Move to first step automatically
        stepForward();
      });

      // Step forward
      stepBtn.addEventListener('click', ()=>{ stepForward(); });

      // Back
      backBtn.addEventListener('click', ()=>{ stepBack(); });

      // Reset
      resetBtn.addEventListener('click', ()=>{
        resetRunState();
        array = initialArray.slice();
        renderBars();
        updateCounters();
        selectedIndex = null;
      });

      // Play toggle
      playToggle.addEventListener('click', togglePlay);

      // Speed change
      speedRange.addEventListener('input', ()=>{
        if(playing){ restartAutoplay(); }
      });

      // Explain
      explainBtn.addEventListener('click', ()=>{
        alert('Insertion Sort builds the sorted portion on the left. For each index i, it takes the key and shifts larger elements right until the correct spot is found, then inserts the key. Best case O(n) (already sorted), average/worst O(n^2).');
      });

      // Build actions by simulating insertion sort and recording each micro-step
      function buildActionsFrom(arr){
        actions = [];
        const n = arr.length;
        // push initial state
        pushAction({type:'start', i:null, j:null, before:arr.slice(), after:arr.slice(), line:0});
        for(let i=1;i<n;i++){
          const key = arr[i];
          let j = i-1;
          // select key
          pushAction({type:'select', i:i, j:null, before:arr.slice(), after:arr.slice(), keyIndex:i, line:1});
          // enter while
          while(j >= 0){
            // compare A[j] > key
            pushAction({type:'compare', i:i, j:j, before:arr.slice(), after:arr.slice(), keyIndex:i, line:3});
            if(arr[j] > key){
              // shift A[j] -> A[j+1]
              const before = arr.slice();
              arr[j+1] = arr[j];
              const after = arr.slice();
              pushAction({type:'shift', i:i, j:j, before, after, keyIndex:i, line:5});
              j = j-1;
            } else {
              break;
            }
          }
          // insert key at j+1
          const beforeIns = arr.slice();
          arr[j+1] = key;
          const afterIns = arr.slice();
          pushAction({type:'insert', i:i, j:j+1, before:beforeIns, after:afterIns, keyIndex:j+1, line:6});
          // mark the current prefix as sorted up to i
          pushAction({type:'mark', i:i, j:j+1, before:arr.slice(), after:arr.slice(), keyIndex:null, line:8});
        }
        pushAction({type:'end', i:null, j:null, before:arr.slice(), after:arr.slice(), line:8});
        // Reset counters
        compCount = 0; moveCount = 0;
        updateCounters();
        stepCounterEl.textContent = `0/${actions.length-1}`;
      }

      function pushAction(act){
        // deep clone arrays to decouple
        const clone = {
          type: act.type,
          i: act.i,
          j: act.j,
          before: act.before.slice(),
          after: act.after.slice(),
          keyIndex: act.keyIndex != null ? act.keyIndex : null,
          line: act.line
        };
        actions.push(clone);
      }

      // Step forward by rendering next action
      async function stepForward(){
        if(actions.length === 0) return;
        if(stepIndex >= actions.length - 1){
          // already at end
          stepIndex = actions.length -1;
          updateStepUI();
          stopAutoplay();
          return;
        }
        stepIndex++;
        await renderAction(actions[stepIndex]);
        updateStepUI();
      }

      // Step back by rendering previous action's 'after' state (or before)
      async function stepBack(){
        if(actions.length === 0) return;
        if(stepIndex <= 0){
          stepIndex = -1;
          // render initial array
          renderArrayState(initialArray.slice());
          compCount = 0; moveCount = 0;
          updateCounters();
          stepCounterEl.textContent = `0/${actions.length-1}`;
          clearPseudocodeHighlight();
          return;
        }
        stepIndex--;
        await renderAction(actions[stepIndex]);
        updateStepUI();
      }

      // Render action object: animate changes from before -> after
      async function renderAction(action){
        // Highlight pseudocode line
        highlightPseudocode(action.line);
        // Update counters depending on action
        if(action.type === 'compare'){
          compCount++; updateCounters();
        } else if(action.type === 'shift'){
          moveCount++; updateCounters();
        } else if(action.type === 'insert'){
          // insertion is considered a move as well (placing key)
          moveCount++; updateCounters();
        }

        // Visualize before state quickly then animate to after
        // We'll render the 'after' state but use classes to mark special bars: key, compared, sorted
        // For smoothness, we set positions based on after array
        renderArrayState(action.after.slice(), action);
        // Delay for animation to be noticeable
        const speed = Number(speedRange.value) || 1;
        // longer for shift/insert to allow seeing motion
        const base = (action.type === 'shift' || action.type === 'insert') ? 600 : 420;
        await sleep(base / speed);
      }

      function renderArrayState(arrState, action){
        array = arrState.slice();
        // Compute layout
        const containerWidth = barsContainer.clientWidth;
        const maxBars = Math.max(3, array.length);
        const gap = 12;
        const totalGap = (array.length - 1) * gap;
        const barWidth = Math.max(36, Math.floor((containerWidth - totalGap) / array.length));
        const maxH = field.clientHeight - 48;
        const maxValInArray = Math.max(...array, 1);

        // Ensure bars count matches
        while(barsContainer.firstChild) barsContainer.removeChild(barsContainer.firstChild);
        array.forEach((val, idx) => {
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.setAttribute('role','button');
          bar.setAttribute('tabindex', '0');
          bar.dataset.index = idx;
          bar.style.left = (idx * (barWidth + gap)) + 'px';
          bar.style.width = barWidth + 'px';
          const h = Math.max(12, Math.round((val / maxValInArray) * maxH));
          bar.style.height = h + 'px';
          const lbl = document.createElement('div');
          lbl.className = 'label';
          lbl.textContent = val;
          bar.appendChild(lbl);

          // Set classes from action (visual cues)
          if(action){
            if(action.type === 'compare' && action.j === idx) bar.classList.add('compared');
            if(action.type === 'key' && action.keyIndex === idx) bar.classList.add('key');
            if(action.type === 'select' && action.keyIndex === idx) bar.classList.add('key');
            if(action.type === 'shift' && action.after[idx] !== action.before[idx]) {
              // if value moved into this spot
              bar.classList.add('key'); // tint to highlight mutation
            }
            if(action.type === 'insert' && action.j === idx) {
              bar.classList.add('key');
            }
            if(action.type === 'mark') {
              // mark sorted indices up to action.i
              const upto = action.i != null ? action.i : array.length - 1;
              if(idx <= upto) bar.classList.add('sorted');
            }
            if(action.type === 'end'){
              bar.classList.add('sorted');
            }
            // additionally highlight the key index if provided
            if(action.keyIndex === idx) bar.classList.add('key');
          }

          // Pre-run selection highlight
          if(stepIndex < 0 && selectedIndex === idx) {
            bar.style.boxShadow = '0 8px 20px rgba(96,165,250,0.12)';
          }

          // Click behavior for pre-run selection
          bar.addEventListener('click', (e) => {
            if(actions.length === 0 || stepIndex < 0){
              // toggle selection
              if(selectedIndex === idx) selectedIndex = null;
              else selectedIndex = idx;
              renderArrayState(array.slice());
            }
          });

          // Keyboard select
          bar.addEventListener('keydown', (e) => {
            if((e.key === 'Enter' || e.key === ' ') && (actions.length === 0 || stepIndex < 0)){
              e.preventDefault();
              selectedIndex = idx;
              renderArrayState(array.slice());
            }
            if(e.key === 'ArrowLeft' && (actions.length === 0 || stepIndex < 0)){
              e.preventDefault(); swapPre(idx, idx-1);
            }
            if(e.key === 'ArrowRight' && (actions.length === 0 || stepIndex < 0)){
              e.preventDefault(); swapPre(idx, idx+1);
            }
          });

          barsContainer.appendChild(bar);
        });

        // update input to match current actual array if we're pre-run
        if(stepIndex < 0) updateInputFromArray();
      }

      // Swap elements in pre-run initial array (also adjusts initialArray)
      function swapPre(i, j){
        if(j < 0 || j >= initialArray.length || i < 0 || i >= initialArray.length) return;
        const tmp = initialArray[i];
        initialArray[i] = initialArray[j];
        initialArray[j] = tmp;
        selectedIndex = j;
        renderBars();
        updateInputFromArray();
      }

      // Render bars from initialArray
      function renderBars(){
        renderArrayState(initialArray.slice());
      }

      // Update counters
      function updateCounters(){
        compCountEl.textContent = compCount;
        moveCountEl.textContent = moveCount;
        if(actions.length > 0){
          const total = Math.max(0, actions.length-1);
          const curr = stepIndex < 0 ? 0 : Math.min(actions.length-1, stepIndex);
          stepCounterEl.textContent = `${curr}/${total}`;
        } else {
          stepCounterEl.textContent = `0/0`;
        }
      }

      // Highlight pseudocode line
      function highlightPseudocode(lineNumber){
        // lineNumber corresponds to our mapping; if 0 or undefined, clear
        const lines = pseudocodeEl.querySelectorAll('.line');
        lines.forEach(l => l.classList.remove('active'));
        if(lineNumber == null) return;
        // clamp
        const idx = clamp(lineNumber, 0, lines.length-1);
        const node = pseudocodeEl.querySelector('.line[data-ln="'+idx+'"]');
        if(node) node.classList.add('active');
      }
      function clearPseudocodeHighlight(){ highlightPseudocode(null); }

      // Play controls
      function togglePlay(){
        if(playing){ stopAutoplay(); }
        else { startAutoplay(); }
      }

      function startAutoplay(){
        if(actions.length === 0){
          alert('No actions to play. Click Start to build the action sequence first.');
          return;
        }
        playing = true;
        playToggle.textContent = 'Pause';
        continueAutoplay();
      }

      function continueAutoplay(){
        if(!playing) return;
        if(stepIndex >= actions.length -1){
          stopAutoplay();
          return;
        }
        const speed = Number(speedRange.value) || 1;
        let delay = 500 / speed;
        // increase delay for shifts/inserts
        const next = actions[Math.min(actions.length-1, stepIndex+1)];
        if(next && (next.type === 'shift' || next.type === 'insert')) delay = 700 / speed;
        autoplayTimer = setTimeout(async () => {
          await stepForward();
          continueAutoplay();
        }, delay);
      }

      function stopAutoplay(){
        playing = false;
        playToggle.textContent = 'Play';
        if(autoplayTimer) { clearTimeout(autoplayTimer); autoplayTimer = null; }
      }

      function restartAutoplay(){
        stopAutoplay();
        startAutoplay();
      }

      // Utility sleep
      function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

      // Reset run state
      function resetRunState(){
        actions = [];
        stepIndex = -1;
        stopAutoplay();
        compCount = 0; moveCount = 0;
        clearPseudocodeHighlight();
        updateCounters();
      }

      // Update step UI (counters & highlight)
      function updateStepUI(){
        updateCounters();
        // If we're at end, ensure bars show final array
        if(stepIndex >= 0 && stepIndex < actions.length){
          const act = actions[stepIndex];
          // pseudocode highlight handled in renderAction
          if(stepIndex === actions.length -1){
            // done
            setTimeout(()=>{ clearPseudocodeHighlight(); }, 300);
          }
        }
      }

      // Initialize
      function init(){
        sizeVal.textContent = sizeRange.value;
        array = randomArray(Number(sizeRange.value));
        initialArray = array.slice();
        renderBars();
        updateInputFromArray();

        // Wire some UI conveniences
        field.addEventListener('click', ()=>{ field.focus(); });
        // Responsive re-render on resize to update positions
        window.addEventListener('resize', ()=>{ renderBars(); });

        // Start with no actions until user presses Start
      }

      init();

    })();
  </script>
</body>
</html>