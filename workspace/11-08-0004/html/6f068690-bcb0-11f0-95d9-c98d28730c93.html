<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Radix Sort — Interactive Module (LSD)</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1720;
      --panel: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --card: #071028;
      --pill-bg: #172a3b;
      --success: #10b981;
      --danger: #ef4444;
      --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    /* Layout safe area */
    html,body{
      height:100%;
      margin:0;
      padding:0;
      background: linear-gradient(180deg,#061426 0%, #071026 100%);
      color: #e6eef6;
      font-family: var(--font-sans);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }
    header {
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-start;
    }
    h1 {
      margin:0;
      font-size:1.4rem;
      letter-spacing: -0.02em;
    }
    p.lead {
      margin:0;
      color:var(--muted);
      font-size:0.95rem;
    }

    main.module {
      display:grid;
      grid-template-columns: 340px 1fr;
      gap: var(--gap);
      align-items:start;
    }

    /* Left controls panel */
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      padding:16px;
      border-radius:10px;
      border: 1px solid rgba(255,255,255,0.04);
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    }
    .panel h2 {
      margin-top:0;
      font-size:1rem;
      margin-bottom:8px;
    }
    .controls {
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }
    label { font-size:0.85rem; color:var(--muted); }
    input[type="text"], input[type="number"], select {
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:rgba(255,255,255,0.02);
      color:inherit;
      outline:none;
      box-sizing:border-box;
    }
    .row {
      display:flex;
      gap:var(--gap);
      align-items:center;
    }
    .row .flex {
      flex:1;
    }
    button {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      color:inherit;
      border:1px solid rgba(255,255,255,0.06);
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:0.95rem;
      min-width:64px;
    }
    button[aria-pressed="true"]{
      box-shadow: 0 6px 18px rgba(6,182,212,0.08);
      border-color: rgba(6,182,212,0.18);
      background: linear-gradient(180deg, rgba(6,182,212,0.06), rgba(6,182,212,0.02));
      color:var(--accent);
    }
    button:disabled {
      opacity:0.45;
      cursor:not-allowed;
    }
    .muted {
      color:var(--muted);
      font-size:0.85rem;
    }

    /* Visualization area */
    .viz {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      padding:18px;
      border-radius:10px;
      border: 1px solid rgba(255,255,255,0.04);
      min-height:360px;
      display:flex;
      flex-direction:column;
      gap:12px;
      box-sizing:border-box;
    }

    .statusbar {
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .badge {
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      color:var(--muted);
      font-size:0.85rem;
    }

    /* Input array row */
    .array-row {
      display:flex;
      gap:12px;
      align-items:center;
      padding:12px;
      border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border:1px dashed rgba(255,255,255,0.02);
      min-height:84px;
      flex-wrap:wrap;
      position:relative;
    }
    .slot {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:64px;
      height:40px;
      padding:6px 10px;
      border-radius:8px;
      background:var(--pill-bg);
      border:1px solid rgba(255,255,255,0.03);
      color:#e6eef6;
      font-weight:600;
      font-size:0.95rem;
      box-sizing:border-box;
      position:relative;
      transition: transform 420ms cubic-bezier(.2,.9,.3,1), box-shadow 220ms;
    }
    .slot:focus {
      outline: 3px solid rgba(6,182,212,0.16);
      transform: translateY(-4px);
    }
    .digit-wrap {
      display:flex;
      gap:6px;
      font-weight:500;
      color:var(--muted);
      font-size:0.78rem;
      margin-top:6px;
    }
    .digit-box {
      background: rgba(255,255,255,0.02);
      padding:4px 6px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .digit-box.current {
      background: linear-gradient(90deg, rgba(6,182,212,0.12), rgba(16,185,129,0.06));
      color:var(--accent);
      border-color: rgba(6,182,212,0.14);
      font-weight:700;
    }

    /* Buckets */
    .buckets {
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:flex-start;
      flex-wrap:wrap;
    }
    .bucket {
      width:86px;
      min-height:88px;
      padding:8px;
      border-radius:10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border:1px solid rgba(255,255,255,0.03);
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:center;
      transition:transform 240ms;
    }
    .bucket .label {
      font-size:0.85rem;
      color:var(--muted);
      font-weight:600;
    }
    .bucket .holder {
      display:flex;
      gap:8px;
      flex-direction:column;
      align-items:center;
      width:100%;
      min-height:40px;
    }
    .bucket .holder .slot {
      width:72px;
      height:32px;
      min-width:0;
      font-size:0.9rem;
      padding:4px 8px;
    }

    /* small UI pieces */
    .controls-grid {
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
    }
    .footer-note {
      color:var(--muted);
      font-size:0.85rem;
    }

    /* Responsive */
    @media (max-width:880px){
      main.module{
        grid-template-columns: 1fr;
      }
      .panel { order:2; }
      .viz { order:1; }
      .buckets { justify-content:space-between; }
    }

    /* animation helper */
    .anim {
      transition: transform 420ms cubic-bezier(.2,.9,.3,1), opacity 240ms;
    }

    /* visually hidden for accessibility */
    .sr-only {
      position:absolute;
      left:-10000px;
      top:auto;
      width:1px;
      height:1px;
      overflow:hidden;
    }

  </style>
</head>
<body>
  <div class="app" role="application" aria-labelledby="title">
    <header>
      <h1 id="title">Radix Sort — Least Significant Digit (LSD) Visualizer</h1>
      <p class="lead">Step through Radix Sort on non-negative integers. Watch digits drive bucket placement and observe stable, non-comparative sorting.</p>
    </header>

    <main class="module" aria-live="polite">
      <!-- Controls panel -->
      <section class="panel" aria-label="Controls">
        <h2>Learning Objective</h2>
        <p class="muted">After using this module you will be able to: identify how Radix Sort processes numbers digit-by-digit (LSD first), see how buckets collect and preserve order (stability), and understand when Radix Sort completes.</p>

        <h2 style="margin-top:12px;">Interaction Design</h2>
        <p class="muted">Use the inputs below to enter a sequence of non-negative integers (comma or space separated), generate random sets, then Step or Play the sort. Observe animated movements of items into numeric buckets (0–9) per digit, see digits highlighted, and watch the array reassemble. Controls are disabled during animations to avoid confusing state changes.</p>

        <div class="controls" style="margin-top:12px;">
          <div>
            <label for="numbers">Numbers (non-negative integers):</label>
            <input id="numbers" type="text" aria-describedby="numbers-help" placeholder="e.g. 170, 45, 75, 90, 802, 24, 2, 66" />
            <div id="numbers-help" class="muted" style="margin-top:8px;">Separate with commas or spaces. Max 12 items recommended for clarity.</div>
          </div>

          <div class="controls-grid">
            <div>
              <label for="maxDigits">Max digits (auto if empty):</label>
              <input id="maxDigits" type="number" min="1" placeholder="Auto" />
            </div>
            <div>
              <label for="speed">Animation speed</label>
              <input id="speed" type="range" min="50" max="1000" value="300" aria-valuemin="50" aria-valuemax="1000" />
              <div class="muted" style="margin-top:6px;">Delay per move: <span id="speed-val">300</span> ms</div>
            </div>
          </div>

          <div class="row">
            <button id="loadBtn">Load</button>
            <button id="randomBtn" title="Generate random numbers">Random</button>
            <button id="clearBtn" title="Clear">Clear</button>
          </div>

          <div class="row">
            <button id="stepBtn">Step</button>
            <button id="playBtn">Play</button>
            <button id="resetBtn">Reset</button>
          </div>

          <div>
            <div class="muted" style="margin-bottom:6px;">Status</div>
            <div class="row">
              <div class="badge" id="current-pass">Pass: 0</div>
              <div class="badge" id="total-passes">Total passes: 0</div>
              <div class="badge" id="mode">Mode: LSD</div>
            </div>
          </div>

          <div class="footer-note" style="margin-top:8px;">
            Notes: This demo focuses on LSD Radix Sort for non-negative integers. Radix (base 10) is fixed here for clarity. The algorithm is stable: items with the same digit preserve relative order.
          </div>
        </div>
      </section>

      <!-- Visualization panel -->
      <section class="viz" aria-label="Visualization">
        <div class="statusbar" aria-hidden="true">
          <div class="badge" id="item-count">Items: 0</div>
          <div class="badge" id="max-digits-badge">Max digits: 0</div>
          <div class="badge" id="next-digit-badge">Next digit (LSD=0): 0</div>
        </div>

        <div aria-live="polite">
          <div class="muted" style="margin-bottom:6px;">Input array (left-to-right order):</div>
          <div id="arrayRow" class="array-row" tabindex="0" aria-label="Input array"></div>
        </div>

        <div style="margin-top:10px;">
          <div class="muted" style="margin-bottom:6px;">Buckets (0–9): highlighted digit determines destination</div>
          <div id="buckets" class="buckets" role="list" aria-label="Buckets 0 to 9">
            <!-- 10 buckets created by script -->
          </div>
        </div>
      </section>
    </main>

    <!-- Hidden accessible instructions -->
    <div class="sr-only" aria-hidden="false">
      Controls: Load numbers into the input. Press Step to perform the next digit pass. Press Play to run automatically. Reset returns to the original array.
    </div>
  </div>

  <script>
    (function(){
      // DOM elements
      const numbersInput = document.getElementById('numbers');
      const loadBtn = document.getElementById('loadBtn');
      const randomBtn = document.getElementById('randomBtn');
      const clearBtn = document.getElementById('clearBtn');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const resetBtn = document.getElementById('resetBtn');
      const arrayRow = document.getElementById('arrayRow');
      const bucketsEl = document.getElementById('buckets');
      const speedInput = document.getElementById('speed');
      const speedVal = document.getElementById('speed-val');
      const maxDigitsInput = document.getElementById('maxDigits');

      const itemCountBadge = document.getElementById('item-count');
      const maxDigitsBadge = document.getElementById('max-digits-badge');
      const nextDigitBadge = document.getElementById('next-digit-badge');
      const currentPassBadge = document.getElementById('current-pass');
      const totalPassesBadge = document.getElementById('total-passes');

      // state
      let initialArray = []; // original numbers
      let items = []; // current order numbers
      let maxDigits = 0;
      let currentPass = 0; // 0-based index, 0 is LSD
      let running = false;
      let playTimer = null;
      let base = 10; // fixed base 10
      let animDelay = Number(speedInput.value);
      let disabledDuringAnimation = false;

      // utilities
      function parseNumbers(text) {
        if (!text) return [];
        // split on comma or whitespace
        const parts = text.split(/[\s,]+/).filter(Boolean);
        const nums = [];
        for (let p of parts) {
          if (!/^\d+$/.test(p)) {
            return {error: 'Only non-negative integers allowed.'};
          }
          const n = Number(p);
          nums.push(n);
        }
        if (nums.length > 24) {
          return {error: 'Please use 24 or fewer items for clarity.'};
        }
        return {nums};
      }

      function updateBadges() {
        itemCountBadge.textContent = 'Items: ' + items.length;
        maxDigitsBadge.textContent = 'Max digits: ' + maxDigits;
        nextDigitBadge.textContent = 'Next digit (LSD=0): ' + currentPass;
        currentPassBadge.textContent = 'Pass: ' + currentPass;
        totalPassesBadge.textContent = 'Total passes: ' + maxDigits;
      }

      function computeMaxDigits(arr) {
        if (!arr.length) return 0;
        let max = 0;
        for (let n of arr) {
          const d = String(n).length;
          if (d > max) max = d;
        }
        return max;
      }

      function createBuckets() {
        bucketsEl.innerHTML = '';
        for (let i = 0; i < base; i++) {
          const b = document.createElement('div');
          b.className = 'bucket';
          b.setAttribute('data-bucket', String(i));
          b.innerHTML = '<div class="label">Bucket ' + i + '</div><div class="holder" role="list"></div>';
          bucketsEl.appendChild(b);
        }
      }

      // create a visual slot element for a number
      function createSlotElement(value) {
        const el = document.createElement('div');
        el.className = 'slot anim';
        el.setAttribute('data-value', String(value));
        el.setAttribute('tabindex','0');
        el.setAttribute('role','listitem');
        el.textContent = String(value);
        return el;
      }

      // render arrayRow from items
      function renderArrayRow() {
        arrayRow.innerHTML = '';
        const padded = padItems(items, maxDigits);
        for (let i = 0; i < items.length; i++) {
          const val = items[i];
          const slot = createSlotElement(val);
          // add digit decomposition display (hidden visually below)
          const digits = padded[i].split('');
          const digitWrap = document.createElement('div');
          digitWrap.className = 'digit-wrap';
          digits.forEach((d, idx) => {
            const db = document.createElement('div');
            db.className = 'digit-box';
            db.textContent = d;
            // mark current digit
            const rightIndex = digits.length - 1 - currentPass;
            if (idx === rightIndex) {
              db.classList.add('current');
            }
            digitWrap.appendChild(db);
          });
          slot.appendChild(digitWrap);
          arrayRow.appendChild(slot);
        }
        updateBadges();
      }

      function padItems(arr, digits) {
        return arr.map(n => {
          let s = String(n);
          while (s.length < digits) s = '0' + s;
          return s;
        });
      }

      // get digit of number at position pos (0 = LSD)
      function digitAt(num, pos) {
        const s = String(num);
        const idx = s.length - 1 - pos;
        if (idx < 0) return 0;
        return Number(s[idx]);
      }

      // FLIP animation helper
      function animateMove(element, beforeRect, afterRect, onEnd) {
        // compute delta from before to after (in viewport coords)
        const dx = beforeRect.left - afterRect.left;
        const dy = beforeRect.top - afterRect.top;
        // temporarily apply transform to put it back at before position,
        // then remove transform to animate to natural position
        element.style.transition = 'none';
        element.style.transform = `translate(${dx}px, ${dy}px)`;
        requestAnimationFrame(() => {
          element.style.transition = 'transform 420ms cubic-bezier(.2,.9,.3,1), opacity 240ms';
          element.style.transform = 'translate(0,0)';
        });
        const cleanup = () => {
          element.style.transition = '';
          element.style.transform = '';
          element.removeEventListener('transitionend', cleanup);
          if (typeof onEnd === 'function') onEnd();
        };
        element.addEventListener('transitionend', cleanup);
      }

      // move a single visual slot from arrayRow -> bucket holder or reverse
      function moveElementToSlot(slotEl, targetHolder, stepDelay) {
        return new Promise(resolve => {
          // compute before rect
          const beforeRect = slotEl.getBoundingClientRect();
          // append to target holder (DOM change)
          targetHolder.appendChild(slotEl);
          // compute after rect
          const afterRect = slotEl.getBoundingClientRect();
          // animate using FLIP
          animateMove(slotEl, beforeRect, afterRect, () => {
            setTimeout(resolve, stepDelay); // additional delay to visualize
          });
        });
      }

      // perform one pass (single digit index)
      async function performPass(passIndex) {
        if (!items.length) return;
        disabledDuringAnimation = true;
        toggleControls(true);

        // clear all buckets holders
        const holders = [];
        for (let i = 0; i < base; i++) {
          const holder = bucketsEl.children[i].querySelector('.holder');
          holder.innerHTML = '';
          holders.push(holder);
        }

        // For visualization, we will move each slot element from arrayRow to buckets
        // sequentially, animating each move for clarity.
        const slots = Array.from(arrayRow.querySelectorAll('.slot'));
        for (let i = 0; i < slots.length; i++) {
          const slot = slots[i];
          const num = Number(slot.getAttribute('data-value'));
          const d = digitAt(num, passIndex);
          const targetHolder = holders[d];
          // compute before rect, then append and animate
          const beforeRect = slot.getBoundingClientRect();
          targetHolder.appendChild(slot);
          const afterRect = slot.getBoundingClientRect();
          animateMove(slot, beforeRect, afterRect);
          // highlight bucket briefly
          const bucketEl = bucketsEl.children[d];
          bucketEl.style.transform = 'translateY(-4px)';
          setTimeout(() => bucketEl.style.transform = '', 350);
          await wait(animDelay);
        }

        // pause before collecting
        await wait(Math.max(150, animDelay));

        // collect buckets in order 0..9, moving elements back into arrayRow in sequence,
        // building the new items order.
        const newOrder = [];
        for (let b = 0; b < base; b++) {
          const holder = holders[b];
          // move each child slot back to arrayRow
          const bucketSlots = Array.from(holder.querySelectorAll('.slot'));
          for (let s = 0; s < bucketSlots.length; s++) {
            const slot = bucketSlots[s];
            const beforeRect = slot.getBoundingClientRect();
            arrayRow.appendChild(slot);
            const afterRect = slot.getBoundingClientRect();
            animateMove(slot, beforeRect, afterRect);
            newOrder.push(Number(slot.getAttribute('data-value')));
            await wait(Math.max(80, animDelay / 2));
          }
          // small visual pause for bucket transition
          await wait(40);
        }

        // update underlying items order after collection
        items = newOrder;
        currentPass = passIndex + 1;
        renderArrayRow();
        disabledDuringAnimation = false;
        toggleControls(false);
      }

      function wait(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      function toggleControls(disable) {
        const controls = [loadBtn, randomBtn, clearBtn, stepBtn, playBtn, resetBtn, maxDigitsInput, numbersInput];
        controls.forEach(c => c.disabled = disable);
      }

      // event handlers
      loadBtn.addEventListener('click', () => {
        const parsed = parseNumbers(numbersInput.value);
        if (parsed.error) {
          alert(parsed.error);
          return;
        }
        initialArray = parsed.nums.slice();
        items = initialArray.slice();
        // compute max digits
        const userMax = Number(maxDigitsInput.value);
        maxDigits = userMax && userMax > 0 ? Math.max(1, Math.floor(userMax)) : computeMaxDigits(items);
        if (maxDigits === 0) maxDigits = 1;
        currentPass = 0;
        createBuckets();
        renderArrayRow();
      });

      randomBtn.addEventListener('click', () => {
        // generate 8 random numbers 0..999
        const count = 8;
        const arr = [];
        for (let i = 0; i < count; i++) arr.push(Math.floor(Math.random() * 1000));
        numbersInput.value = arr.join(', ');
        loadBtn.click();
      });

      clearBtn.addEventListener('click', () => {
        numbersInput.value = '';
        initialArray = [];
        items = [];
        maxDigits = 0;
        currentPass = 0;
        createBuckets();
        renderArrayRow();
      });

      resetBtn.addEventListener('click', () => {
        // return to initial array
        if (!initialArray.length) return;
        items = initialArray.slice();
        currentPass = 0;
        maxDigits = Number(maxDigitsInput.value) || computeMaxDigits(items) || 1;
        createBuckets();
        renderArrayRow();
      });

      stepBtn.addEventListener('click', async () => {
        if (!items.length) return;
        if (currentPass >= maxDigits) {
          // nothing to do
          alert('All passes completed. Press Reset to run again, or change inputs.');
          return;
        }
        await performPass(currentPass);
        updateBadges();
      });

      playBtn.addEventListener('click', async () => {
        if (running) {
          running = false;
          playBtn.setAttribute('aria-pressed','false');
          playBtn.textContent = 'Play';
          if (playTimer) clearInterval(playTimer);
          return;
        }
        if (!items.length) return;
        running = true;
        playBtn.setAttribute('aria-pressed','true');
        playBtn.textContent = 'Pause';
        // auto-run passes until complete or paused
        while (running && currentPass < maxDigits) {
          await performPass(currentPass);
          if (!running) break;
          await wait(220);
        }
        running = false;
        playBtn.setAttribute('aria-pressed','false');
        playBtn.textContent = 'Play';
      });

      speedInput.addEventListener('input', () => {
        animDelay = Number(speedInput.value);
        speedVal.textContent = String(animDelay);
      });

      // initialization
      (function init(){
        createBuckets();
        renderArrayRow();
        speedVal.textContent = speedInput.value;
        // create basic ARIA attributes
        playBtn.setAttribute('aria-pressed','false');

        // keyboard support: Enter on numbers input loads
        numbersInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            loadBtn.click();
          }
        });

        // prevent accidental text selection dragging issues
        document.addEventListener('dragstart', e => e.preventDefault());
      })();

      // Expose minimal helpful info to screen readers when passes happen:
      const liveAnnouncer = document.createElement('div');
      liveAnnouncer.className = 'sr-only';
      liveAnnouncer.setAttribute('aria-live','polite');
      document.body.appendChild(liveAnnouncer);

      // update badges periodically (some state changes may not call render)
      setInterval(updateBadges, 500);

      // Ensure controls are accessible with spacing requirements:
      // (This is design; implemented via CSS layout and gap variables.)

    })();
  </script>
</body>
</html>