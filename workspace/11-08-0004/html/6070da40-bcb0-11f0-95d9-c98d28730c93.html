<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Queue — Interactive Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-padding: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --success: #16a34a;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.02);
      --node-bg: linear-gradient(180deg,#082634,#0b3946);
      --node-size: 72px;
      --node-gap: 12px;
    }

    html,body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg,#071021 0%, #021423 100%);
      color: #e6eef6;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .app {
      padding: var(--safe-padding);
      box-sizing: border-box;
      min-height: 100%;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    header {
      display:flex;
      flex-direction: column;
      gap: 8px;
    }

    h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: -0.2px;
      color: #eaf6fb;
    }

    .meta {
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 14px;
    }

    main {
      display: flex;
      gap: var(--gap);
      align-items: stretch;
      flex: 1 1 auto;
    }

    /* Left column: controls & description */
    .left {
      width: 360px;
      max-width: 100%;
      display:flex;
      flex-direction: column;
      gap: var(--gap);
    }

    /* Right column: visualizer */
    .right {
      flex: 1 1 auto;
      min-width: 260px;
      display:flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      padding: 16px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(2,6,23,0.6);
    }

    .small {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.4;
    }

    /* Controls layout */
    .controls {
      display:flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .input-row {
      display:flex;
      gap: var(--gap);
      align-items: center;
    }

    input[type="text"], input[type="number"] {
      flex: 1 1 auto;
      padding: 10px 12px;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.04);
      color: #e6eef6;
      border-radius: 8px;
      outline: none;
      font-size: 14px;
    }

    input[type="text"]:focus, input[type="number"]:focus { box-shadow: 0 0 0 3px rgba(6,182,212,0.08); border-color: var(--accent); }

    .btn {
      background: linear-gradient(180deg,var(--accent), #04a0b0);
      color: #042024;
      padding: 10px 12px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      min-width: 88px;
      text-align: center;
    }

    .btn.secondary {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.06);
      color: #cfeef6;
      font-weight: 600;
    }

    .btn.danger {
      background: linear-gradient(180deg,#ef4444,#dc2626);
      color: white;
    }

    .btn:active { transform: translateY(1px); }

    .row {
      display:flex;
      gap: var(--gap);
      align-items: center;
      flex-wrap: wrap;
    }

    label {
      font-size: 13px;
      color: var(--muted);
    }

    .status {
      display:flex;
      gap: 12px;
      align-items:center;
      flex-wrap:wrap;
    }

    .badge {
      background: rgba(255,255,255,0.03);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 13px;
      color: var(--muted);
      border: 1px solid rgba(255,255,255,0.02);
    }

    .visual {
      display:flex;
      flex-direction: column;
      gap: var(--gap);
      align-items: stretch;
    }

    .queue-area {
      min-height: calc(var(--node-size) + 48px);
      display:flex;
      align-items:center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    /* Queue container */
    .queue {
      display:flex;
      gap: var(--node-gap);
      align-items:center;
      padding: 12px;
      min-height: var(--node-size);
      max-width: 100%;
      transition: height 240ms ease;
    }

    .node {
      width: var(--node-size);
      height: var(--node-size);
      min-width: var(--node-size);
      border-radius: 10px;
      background: var(--node-bg);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 700;
      color: #dff8fb;
      font-size: 18px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      position: relative;
      transition: transform 360ms cubic-bezier(.2,.9,.2,1), opacity 300ms ease;
      will-change: transform, opacity;
      border: 1px solid rgba(255,255,255,0.04);
    }

    .node.small {
      width: 56px;
      height: 56px;
      font-size: 15px;
    }

    .label {
      position: absolute;
      top: -22px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.45);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .marker {
      font-size: 12px;
      color: #9ee8f0;
      position: absolute;
      bottom: -22px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(6,182,212,0.06);
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(6,182,212,0.06);
      color: var(--accent);
    }

    /* Animations for enqueue/dequeue */
    .incoming {
      transform: translateX(50px) scale(0.95);
      opacity: 0;
    }

    .arrived {
      transform: translateX(0) scale(1);
      opacity: 1;
      transition: transform 360ms cubic-bezier(.2,.9,.2,1), opacity 240ms ease;
    }

    .depart {
      transform: translateY(-40px) scale(0.9);
      opacity: 0;
      transition: transform 380ms cubic-bezier(.2,.9,.2,1), opacity 260ms ease;
    }

    /* Indicators for head/tail text */
    .info-row {
      display:flex;
      gap: var(--gap);
      align-items:center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .legend {
      display:flex;
      gap: 12px;
      align-items:center;
    }

    .legend .swatch {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      background: var(--accent);
      box-shadow: 0 2px 6px rgba(6,182,212,0.12);
    }

    /* Footer / explanations */
    .explain {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.5;
    }

    /* Responsive stack */
    @media (max-width: 880px) {
      main { flex-direction: column; }
      .left { width: 100%; order: 2; }
      .right { order: 1; }
    }

    /* Accessibility focus */
    .btn:focus, input:focus {
      outline: 3px solid rgba(6,182,212,0.12);
      outline-offset: 2px;
    }

    /* spacing rule: ensure at least 16px between interactive controls (enforced via gap) */
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Queue interactive module">
    <header>
      <h1>Queue — FIFO Data Structure (Interactive)</h1>
      <div class="meta">
        <div class="small"><strong>Concept Title:</strong> Queue (First-In, First-Out)</div>
        <div class="small"><strong>Learning Objective:</strong> Understand enqueue, dequeue, peek, and capacity behavior through direct manipulation and animations that reveal FIFO ordering.</div>
      </div>
    </header>

    <main>
      <!-- Left column: Controls & instructional text -->
      <section class="left">
        <div class="panel controls" aria-labelledby="controls-heading">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <h2 id="controls-heading" style="margin:0;font-size:16px;">Controls</h2>
            <div class="status" aria-hidden="true">
              <div class="badge" id="sizeBadge">Size: 0</div>
              <div class="badge" id="capBadge">Capacity: ∞</div>
            </div>
          </div>

          <div class="input-row" style="gap: var(--gap);">
            <input id="valueInput" type="text" inputmode="text" placeholder="Value to enqueue" aria-label="Value to enqueue" />
            <button id="enqueueBtn" class="btn" aria-label="Enqueue">Enqueue</button>
            <button id="dequeueBtn" class="btn secondary" aria-label="Dequeue">Dequeue</button>
          </div>

          <div class="row">
            <button id="peekBtn" class="btn secondary" aria-label="Peek head">Peek</button>
            <button id="clearBtn" class="btn secondary" aria-label="Clear queue">Clear</button>
            <button id="fillDemoBtn" class="btn" aria-label="Fill demo">Demo Fill</button>
          </div>

          <div class="row" style="align-items:center;">
            <label for="capacityInput">Max capacity (0 = ∞)</label>
            <input id="capacityInput" type="number" min="0" step="1" value="0" aria-label="Set capacity" style="width: 120px;" />
            <label for="speedRange" style="margin-left:8px;">Animation speed</label>
            <input id="speedRange" type="range" min="0.5" max="2" step="0.1" value="1" style="width:140px" aria-label="Animation speed" />
          </div>

          <div class="small" style="margin-top:4px;">
            Keyboard: Type value and press Enter to enqueue. Buttons are reachable by tab. Screen-reader announcements appear for major actions.
          </div>
        </div>

        <div class="panel" aria-labelledby="learning-heading">
          <h3 id="learning-heading" style="margin:0 0 8px 0;font-size:15px;">Interaction Design</h3>
          <div class="small">
            - Enqueue: Enter a value and click "Enqueue" (or press Enter). A new node appears at the rear and slides into place — visually reinforcing that new items join at the tail.<br><br>
            - Dequeue: Click "Dequeue" to remove the element at the front. The head node lifts and fades out, showing FIFO removal.<br><br>
            - Peek: Highlights the head without removing it, emphasizing "front" visibility.<br><br>
            - Capacity: Set a positive integer capacity to explore bounded-queue (overflow prevents enqueue). A capacity of 0 means unlimited.<br><br>
            Animations (slide in / lift out) and live announcements reinforce ordering and state changes.
          </div>
        </div>

        <div class="panel" aria-labelledby="layout-heading">
          <h3 id="layout-heading" style="margin:0 0 8px 0;font-size:15px;">Layout Description</h3>
          <div class="small">
            - Safe area: 24px padding around the app for consistent margins.<br>
            - Controls column left (360px) with inputs and actions; visualization on the right fills remaining width.<br>
            - Minimum spacing (gap) set to 16px between interactive elements to improve clarity and touch targets.<br>
            - Visual queue centered horizontally with nodes laid out left-to-right (front at left). Accessible roles and an ARIA live region announce operations.
          </div>
        </div>
      </section>

      <!-- Right column: Visualizer -->
      <section class="right">
        <div class="panel visual" aria-live="polite" aria-atomic="true">
          <div class="info-row" style="align-items:center;">
            <div style="display:flex;flex-direction:column;">
              <div style="font-weight:700;font-size:15px;">Queue Visualizer</div>
              <div style="font-size:13px;color:var(--muted);">Front (head) is on the left — Rear (tail) on the right</div>
            </div>
            <div style="display:flex;gap:12px;align-items:center;">
              <div class="badge" id="emptyBadge">Empty</div>
              <div class="legend" aria-hidden="true">
                <div class="swatch"></div><div style="color:var(--muted);font-size:13px;">Recent action</div>
              </div>
            </div>
          </div>

          <div class="queue-area" aria-hidden="false">
            <!-- The queue crowd -->
            <div id="queueContainer" class="queue" role="list" aria-label="Queue elements"></div>
          </div>

          <div style="display:flex;gap:var(--gap);align-items:center;justify-content:space-between;">
            <div style="font-size:13px;color:var(--muted);">Peek result: <span id="peekResult" style="color:#dff8fb;font-weight:700">—</span></div>
            <div style="font-size:13px;color:var(--muted);">Operations are animated for clarity.</div>
          </div>
        </div>

        <div class="panel explain" aria-hidden="false">
          <strong>What you will learn</strong>
          <ul style="margin-top:8px;color:var(--muted);">
            <li>How elements join at the rear (enqueue) and leave from the front (dequeue).</li>
            <li>How peek reads the front element without removal.</li>
            <li>How capacity constraints cause enqueue to fail (overflow).</li>
            <li>Visual mapping between abstract FIFO rules and node movement through animation.</li>
          </ul>
        </div>
      </section>
    </main>

    <!-- Live region for screen readers -->
    <div id="srLive" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;" aria-live="polite" aria-atomic="true"></div>

    <footer style="color:var(--muted);font-size:13px;padding-top:8px;">
      Tip: Try different capacities and speeds to see how a bounded queue behaves under overflow.
    </footer>
  </div>

  <script>
    // Queue interactive implementation (vanilla JS)
    (function () {
      // DOM references
      const valueInput = document.getElementById('valueInput');
      const enqueueBtn = document.getElementById('enqueueBtn');
      const dequeueBtn = document.getElementById('dequeueBtn');
      const peekBtn = document.getElementById('peekBtn');
      const clearBtn = document.getElementById('clearBtn');
      const fillDemoBtn = document.getElementById('fillDemoBtn');
      const capacityInput = document.getElementById('capacityInput');
      const speedRange = document.getElementById('speedRange');

      const queueContainer = document.getElementById('queueContainer');
      const sizeBadge = document.getElementById('sizeBadge');
      const capBadge = document.getElementById('capBadge');
      const emptyBadge = document.getElementById('emptyBadge');
      const peekResult = document.getElementById('peekResult');
      const srLive = document.getElementById('srLive');

      // Internal queue array
      let queue = [];
      // Optionally track DOM nodes separately to maintain reference to elements
      const domNodes = [];

      // Animation timing factor (multiplies CSS durations)
      let speedFactor = 1.0;

      // Helper: announce to screen-reader live region
      function announce(message) {
        srLive.textContent = '';
        // Slight delay to ensure repeated messages read
        setTimeout(() => { srLive.textContent = message; }, 50);
      }

      // Update UI badges
      function updateBadges() {
        sizeBadge.textContent = 'Size: ' + queue.length;
        const cap = parseInt(capacityInput.value, 10) || 0;
        capBadge.textContent = 'Capacity: ' + (cap > 0 ? cap : '∞');
        emptyBadge.textContent = queue.length === 0 ? 'Empty' : 'Has items';
      }

      // Create a visual node (DOM element)
      function createNode(value) {
        const el = document.createElement('div');
        el.className = 'node incoming';
        el.setAttribute('role', 'listitem');
        el.setAttribute('tabindex', '-1');
        el.textContent = value;
        return el;
      }

      // Render markers (front/rear labels) — maintain small labels on head/tail
      function updateMarkers() {
        // Remove existing markers
        domNodes.forEach(n => {
          const existingLabel = n.el.querySelector('.marker');
          if (existingLabel) existingLabel.remove();
        });

        if (domNodes.length === 0) return;
        const headNode = domNodes[0].el;
        const tailNode = domNodes[domNodes.length - 1].el;

        const headMarker = document.createElement('div');
        headMarker.className = 'marker';
        headMarker.textContent = 'HEAD';
        headNode.appendChild(headMarker);

        const tailMarker = document.createElement('div');
        tailMarker.className = 'marker';
        tailMarker.textContent = 'TAIL';
        tailNode.appendChild(tailMarker);
      }

      // Enqueue operation with animation
      function enqueue(value) {
        const cap = parseInt(capacityInput.value, 10) || 0;
        if (cap > 0 && queue.length >= cap) {
          announce('Cannot enqueue. Queue is at capacity.');
          flashCapacityError();
          return false;
        }
        // Logical update
        queue.push(value);

        // Visual node creation
        const nodeEl = createNode(value);
        const nodeObj = { value, el: nodeEl };
        domNodes.push(nodeObj);

        // Append node element off to the side (incoming)
        queueContainer.appendChild(nodeEl);

        // Trigger animation to "arrive"
        // CSS: .incoming -> initial transform/opacity; then add .arrived to animate to place
        // Use requestAnimationFrame for reliable transition start
        requestAnimationFrame(() => {
          // slight timing adjustment by speed factor
          const delay = 20;
          setTimeout(() => {
            nodeEl.classList.remove('incoming');
            nodeEl.classList.add('arrived');
          }, delay);
        });

        // After animation finishes, ensure markers and badges updated
        const animDuration = 360 * speedFactor + 80;
        setTimeout(() => {
          updateMarkers();
          updateBadges();
          announce('Enqueued ' + value + '. Size is now ' + queue.length + '.');
          // clear peek display
          peekResult.textContent = '—';
        }, animDuration);
        return true;
      }

      // Dequeue operation with animation
      function dequeue() {
        if (queue.length === 0) {
          announce('Cannot dequeue. Queue is empty.');
          return null;
        }

        // Logical: remove head
        const value = queue.shift();

        // Visual: animate DOM of head
        const nodeObj = domNodes.shift();
        const el = nodeObj.el;

        // Add depart animation class
        el.classList.add('depart');

        // After animation remove element and update markers
        const animDuration = 380 * speedFactor + 80;
        setTimeout(() => {
          if (el && el.parentNode) el.parentNode.removeChild(el);
          updateMarkers();
          updateBadges();
          announce('Dequeued ' + value + '. Size is now ' + queue.length + '.');
          peekResult.textContent = '—';
        }, animDuration);

        return value;
      }

      // Peek operation (no modification)
      function peek() {
        if (queue.length === 0) {
          announce('Peek: queue is empty.');
          peekResult.textContent = '—';
          return null;
        }
        const head = queue[0];
        peekResult.textContent = head;
        // Visual hint: pulse the head node briefly
        if (domNodes.length > 0) {
          const el = domNodes[0].el;
          el.animate([
            { boxShadow: '0 6px 18px rgba(6,182,212,0.0)' },
            { boxShadow: '0 12px 30px rgba(6,182,212,0.18)' },
            { boxShadow: '0 6px 18px rgba(6,182,212,0.0)' }
          ], { duration: 500 * speedFactor, easing: 'ease' });
        }
        announce('Peeked at head: ' + head);
        return head;
      }

      // Clear queue completely (no animation for simplicity)
      function clearQueue() {
        queue = [];
        // remove all dom nodes
        while (domNodes.length) {
          const n = domNodes.shift();
          if (n.el && n.el.parentNode) n.el.parentNode.removeChild(n.el);
        }
        updateBadges();
        updateMarkers();
        peekResult.textContent = '—';
        announce('Queue cleared.');
      }

      // Capacity error flash
      function flashCapacityError() {
        const original = capBadge.style.background;
        capBadge.style.color = '#fff';
        capBadge.style.background = 'linear-gradient(180deg,#ef4444,#dc2626)';
        setTimeout(() => {
          capBadge.style.background = '';
          capBadge.style.color = '';
        }, 600);
      }

      // Demo fill: enqueue a sequence
      function demoFill() {
        const items = ['A', 'B', 'C', 'D', 'E'];
        let i = 0;
        function step() {
          if (i >= items.length) {
            announce('Demo fill complete.');
            return;
          }
          const ok = enqueue(items[i]);
          i++;
          if (!ok) return;
          setTimeout(step, 500 * speedFactor);
        }
        step();
      }

      // Event listeners
      enqueueBtn.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (v === '') {
          // allow empty string? we'll disallow empty to keep clarity
          announce('Please enter a value to enqueue.');
          valueInput.focus();
          return;
        }
        const ok = enqueue(v);
        if (ok) valueInput.value = '';
        valueInput.focus();
      });

      dequeueBtn.addEventListener('click', () => {
        const removed = dequeue();
        if (removed === null) {
          // nothing
        }
      });

      peekBtn.addEventListener('click', () => peek());

      clearBtn.addEventListener('click', () => {
        clearQueue();
      });

      fillDemoBtn.addEventListener('click', () => {
        demoFill();
      });

      capacityInput.addEventListener('change', () => {
        updateBadges();
        announce('Capacity set to ' + (parseInt(capacityInput.value,10) || 0 ? capacityInput.value : 'infinite') + '.');
      });

      speedRange.addEventListener('input', (e) => {
        speedFactor = parseFloat(e.target.value) || 1.0;
        announce('Animation speed set to ' + speedFactor + 'x.');
      });

      // Keyboard: Enter to enqueue
      valueInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          enqueueBtn.click();
        }
      });

      // Accessibility: announce initial instructions
      announce('Interactive queue loaded. Type a value and press Enqueue. Dequeue removes the head.');

      // Initialize badges
      updateBadges();

      // Expose for console debugging (not necessary)
      window._queueModule = {
        enqueue, dequeue, peek, clear: clearQueue, get queue() { return queue.slice(); }
      };
    })();
  </script>
</body>
</html>