<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quick Sort Interactive Module</title>
  <style>
    /* Safe area margin: 24px all sides */
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --ui-width: 360px;
      --accent: #0b74de;
      --muted: #64748b;
      --bg: #0f1724;
      --card: #0b1220;
      --success: #059669;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.03);
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071022 0%, #071226 60%);
      color:#e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Container with required safe margins */
    .page {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      gap:var(--gap);
      align-items:stretch;
      flex-wrap:wrap;
    }

    /* Left column: Controls & description */
    .sidebar {
      width: min(var(--ui-width), 100%);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:18px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      min-width:260px;
      flex-shrink:0;
    }

    h1,h2,h3{ margin:0; line-height:1.15; }
    .title {
      font-size:18px;
      font-weight:600;
      color:#eaf2ff;
    }
    .muted { color:var(--muted); font-size:13px; }

    .panel {
      background: var(--glass);
      border-radius:10px;
      padding:12px;
      box-sizing:border-box;
      font-size:13px;
      color:#dbeafe;
    }

    .controls {
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    /* Row of small controls */
    .row { display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap; }
    .btn {
      background:transparent;
      color:#dbeafe;
      border:1px solid rgba(255,255,255,0.06);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      transition:all 160ms ease;
      min-width:60px;
    }
    .btn:active { transform:translateY(1px); }
    .btn.primary {
      background:linear-gradient(90deg,var(--accent),#3db4ff);
      color:#042028;
      border: none;
      box-shadow: 0 6px 18px rgba(11,116,222,0.18);
    }
    .btn.ghost {
      background:transparent;
      border:1px dashed rgba(255,255,255,0.04);
    }

    .small {
      font-size:13px;
      padding:6px 8px;
      border-radius:8px;
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.02);
      color:#dbeafe;
    }

    select, input[type="range"] {
      -webkit-appearance:none;
      appearance:none;
      background:transparent;
      color:#e6eef8;
      border:1px solid rgba(255,255,255,0.04);
      padding:8px;
      border-radius:8px;
    }
    label { font-size:13px; color:#dbeafe; display:flex; gap:8px; align-items:center; }

    /* Main visual area */
    .main {
      flex:1;
      min-width:320px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .visual-card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:18px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:16px;
      min-height:420px;
    }

    .canvas {
      position:relative;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:10px;
      padding:12px;
      min-height:260px;
      display:flex;
      align-items:flex-end;
      overflow:hidden;
    }

    /* Bars container: uses relative positioning for FLIP animation */
    .bars {
      display:flex;
      gap:12px;
      align-items:flex-end;
      width:100%;
      height:100%;
      position:relative;
      padding:8px;
      box-sizing:border-box;
    }

    .bar {
      user-select:none;
      -webkit-user-select:none;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      gap:6px;
      background:linear-gradient(180deg,#0ea5ff22,#0ea5ff11);
      color:#e6eef8;
      border-radius:6px 6px 4px 4px;
      padding:6px 6px;
      min-width:28px;
      box-sizing:border-box;
      font-size:12px;
      position:relative;
      transition: transform 360ms cubic-bezier(.22,.9,.2,1), background 200ms;
      cursor:pointer;
      border:1px solid rgba(255,255,255,0.03);
    }
    .bar .value {
      writing-mode:vertical-rl;
      transform:rotate(180deg);
      font-weight:700;
      color:#e6f8ff;
      font-size:12px;
    }
    .bar.pivot { background:linear-gradient(180deg,#ffd16633,#ffb70322); box-shadow:0 6px 16px rgba(255,177,3,0.06); }
    .bar.compare { background:linear-gradient(180deg,#7dd3fc22,#38bdf829); box-shadow:0 6px 16px rgba(59,130,246,0.06); }
    .bar.swap { background:linear-gradient(180deg,#fb718522,#fb718521); box-shadow:0 6px 20px rgba(251,113,133,0.06); }
    .bar.sorted { background:linear-gradient(180deg,#34d39933,#10b98122); box-shadow:0 6px 20px rgba(16,185,129,0.06); }

    /* Pseudocode / state area */
    .info {
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .code {
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:12px;
      border-radius:8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size:13px;
      color:#cde9ff;
      line-height:1.5;
      min-width:220px;
      flex:1;
    }
    .code .line { padding:2px 6px; display:block; border-radius:6px; }
    .code .active { background:rgba(11,116,222,0.12); color:#dff3ff; }

    .stack {
      width:180px;
      min-width:160px;
      background:rgba(255,255,255,0.02);
      padding:10px;
      border-radius:8px;
      font-size:13px;
      color:#dbeafe;
    }
    .stack .frame {
      background:rgba(255,255,255,0.01);
      padding:8px;
      border-radius:8px;
      margin-bottom:8px;
      border:1px solid rgba(255,255,255,0.02);
      font-weight:600;
    }

    /* Footer tiny hints */
    .hint { font-size:12px; color:var(--muted); }

    /* Responsive */
    @media (max-width:980px){
      .page { padding:18px; }
      .sidebar { width:100%; order:2; }
      .main { order:1; }
    }
  </style>
</head>
<body>
  <div class="page" role="main">
    <!-- Sidebar: Concept Title / Learning Objectives / Controls -->
    <aside class="sidebar" aria-label="Quick Sort controls and description">
      <div class="title">Quick Sort — Interactive Module</div>
      <div class="muted">An in-depth, stepwise exploration of Quick Sort partitioning and recursion.</div>

      <div class="panel" aria-hidden="false">
        <h3 style="margin-bottom:6px;">Learning Objective</h3>
        <div style="font-size:13px; color:#dbeafe;">
          After interacting you should:
          <ul style="margin:8px 0 0 18px; padding:0; color:#dbeafe; font-size:13px;">
            <li>Understand how partitioning rearranges elements around a pivot.</li>
            <li>Visualize comparisons, swaps, and recursive subproblems.</li>
            <li>Be able to run and step through Quick Sort with different pivot strategies.</li>
          </ul>
        </div>
      </div>

      <div class="panel">
        <h3 style="margin-bottom:6px;">Interaction Design</h3>
        <div style="font-size:13px; color:#dbeafe;">
          - Click bars to edit a value. Drag not required — editing is keyboard-friendly.<br>
          - Use Play to animate, Step to advance one algorithm action (compare/swap/partition).<br>
          - Change pivot strategy (first, last, middle, random, median-of-three).<br>
          - Adjust speed and array size. Shuffle to randomize the input.<br>
          - Visual feedback: color highlights for pivot/compare/swap, animated swaps (FLIP), and a stack view showing recursion frames.
        </div>
      </div>

      <div class="controls">
        <div class="row" role="group" aria-label="Execution controls">
          <button id="playBtn" class="btn primary" aria-pressed="false" title="Play / Pause (Space)">Play</button>
          <button id="stepBtn" class="btn" title="Step forward (Right Arrow)">Step</button>
          <button id="resetBtn" class="btn ghost" title="Reset to initial array">Reset</button>
          <button id="shuffleBtn" class="btn" title="Shuffle array">Shuffle</button>
        </div>

        <div class="row" style="align-items:center;">
          <label style="flex:1;">
            Pivot:
            <select id="pivotSelect" class="small" aria-label="Choose pivot strategy">
              <option value="last">Last element</option>
              <option value="first">First element</option>
              <option value="middle">Middle element</option>
              <option value="random">Random element</option>
              <option value="median3">Median of three</option>
            </select>
          </label>
        </div>

        <div class="row" style="align-items:center;">
          <label style="flex:1;">
            Array size:
            <input id="sizeRange" type="range" min="4" max="18" value="10" />
          </label>
          <div id="sizeLabel" class="small" aria-live="polite">10</div>
        </div>

        <div class="row" style="align-items:center;">
          <label style="flex:1;">
            Speed:
            <input id="speedRange" type="range" min="0.1" max="2.5" step="0.1" value="1" />
          </label>
          <div id="speedLabel" class="small">1.0x</div>
        </div>

        <div class="hint">Keyboard: Space = Play/Pause, → = Step</div>
      </div>

      <div class="panel" style="font-size:13px;">
        <h3 style="margin-bottom:6px;">Layout Description</h3>
        <div style="color:#dbeafe;">
          - Safe area margins: 24px on all sides. Min spacing 16px between interactive elements.<br>
          - Left column holds controls & description; right (main) column is the visual demonstration.<br>
          - Top of visual area: animated bars representing array elements. Bottom/right: pseudocode and recursion stack.<br>
          - Accessibility: ARIA labels, keyboard shortcuts, visible focus through controls, and scalable layout for small screens.
        </div>
      </div>
    </aside>

    <!-- Main visual and info -->
    <main class="main" aria-label="Quick Sort visualization">
      <section class="visual-card" aria-live="polite">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="display:flex; gap:12px; align-items:center;">
            <h2 style="font-size:16px; margin:0;">Quick Sort Visualizer</h2>
            <div id="status" class="muted" style="font-size:13px;">Idle</div>
          </div>
          <div class="muted" style="font-size:13px;">Click a bar to edit its value (Enter to confirm)</div>
        </div>

        <div class="canvas" id="canvas" tabindex="0" aria-label="Array visualization area">
          <div class="bars" id="bars" role="list" aria-live="polite"></div>
        </div>

        <div class="info">
          <div class="code" id="pseudocode" aria-hidden="false">
            <div class="line" data-line="1">function quicksort(A, lo, hi)</div>
            <div class="line" data-line="2">  if lo &lt; hi then</div>
            <div class="line" data-line="3">    p ← partition(A, lo, hi)</div>
            <div class="line" data-line="4">    quicksort(A, lo, p - 1)</div>
            <div class="line" data-line="5">    quicksort(A, p + 1, hi)</div>
            <hr style="opacity:.06" />
            <div class="line" data-line="10">function partition(A, lo, hi)</div>
            <div class="line" data-line="11">  choose pivot and swap into A[hi]</div>
            <div class="line" data-line="12">  i ← lo</div>
            <div class="line" data-line="13">  for j from lo to hi-1</div>
            <div class="line" data-line="14">    if A[j] &lt;= pivot then swap A[i],A[j]; i++</div>
            <div class="line" data-line="15">  swap A[i],A[hi]</div>
            <div class="line" data-line="16">  return i</div>
          </div>

          <div class="stack" id="stack" aria-label="Recursion stack">
            <div style="font-weight:700; margin-bottom:8px;">Recursion Stack</div>
            <div id="stackFrames"></div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script>
    /**********************************************************************
     * Quick Sort Interactive Module (vanilla HTML/CSS/JS)
     * - Implements a step-by-step Quick Sort visualization with animations.
     * - No external libraries. Uses FLIP-style animation for swaps.
     **********************************************************************/

    /* ---------- Utility & state ---------- */
    const playBtn = document.getElementById('playBtn');
    const stepBtn = document.getElementById('stepBtn');
    const resetBtn = document.getElementById('resetBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const pivotSelect = document.getElementById('pivotSelect');
    const sizeRange = document.getElementById('sizeRange');
    const sizeLabel = document.getElementById('sizeLabel');
    const speedRange = document.getElementById('speedRange');
    const speedLabel = document.getElementById('speedLabel');
    const barsEl = document.getElementById('bars');
    const statusEl = document.getElementById('status');
    const pseudocode = document.getElementById('pseudocode');
    const stackFrames = document.getElementById('stackFrames');

    let array = [];
    let initialArray = [];
    let actions = []; // queued actions from generator
    let running = false;
    let animating = false;
    let actionGenerator = null;
    let speed = 1.0;
    let arraySize = parseInt(sizeRange.value,10) || 10;

    // For accessibility: keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        togglePlay();
      } else if (e.code === 'ArrowRight') {
        e.preventDefault();
        stepOnce();
      }
    });

    /* ---------- Initialization ---------- */
    function init() {
      arraySize = parseInt(sizeRange.value,10);
      speed = parseFloat(speedRange.value);
      sizeLabel.textContent = arraySize;
      speedLabel.textContent = speed.toFixed(1) + 'x';
      array = randomArray(arraySize);
      initialArray = array.slice();
      renderArray();
      resetAlgorithmState();
    }

    function randomArray(n){
      const arr = [];
      for (let i=0;i<n;i++){
        arr.push(Math.floor(Math.random()*90)+10);
      }
      return arr;
    }

    sizeRange.addEventListener('input', () => {
      arraySize = parseInt(sizeRange.value,10);
      sizeLabel.textContent = arraySize;
      array = randomArray(arraySize);
      initialArray = array.slice();
      resetAlgorithmState();
      renderArray(true);
    });

    speedRange.addEventListener('input', () => {
      speed = parseFloat(speedRange.value);
      speedLabel.textContent = speed.toFixed(1) + 'x';
    });

    shuffleBtn.addEventListener('click', () => {
      array = randomArray(arraySize);
      initialArray = array.slice();
      resetAlgorithmState();
      renderArray(true);
    });

    resetBtn.addEventListener('click', () => {
      array = initialArray.slice();
      resetAlgorithmState();
      renderArray(true);
    });

    playBtn.addEventListener('click', togglePlay);
    stepBtn.addEventListener('click', stepOnce);

    function togglePlay() {
      running = !running;
      playBtn.textContent = running ? 'Pause' : 'Play';
      playBtn.setAttribute('aria-pressed', running.toString());
      if (running) {
        runLoop();
      }
    }

    function resetAlgorithmState(){
      actionGenerator = quickSortActions(array.slice());
      actions = [];
      updateStatus('Idle');
      clearHighlights();
      populateStack([]);
      highlightPseudocode(null);
      running = false;
      playBtn.textContent = 'Play';
      playBtn.setAttribute('aria-pressed','false');
    }

    /* ---------- Rendering Bars & FLIP swap animation ---------- */

    // Render bars according to current array
    function renderArray(skipTransition=false) {
      // Clear and recreate bars
      barsEl.innerHTML = '';
      const max = Math.max(...array);
      const min = Math.min(...array);
      for (let i=0;i<array.length;i++){
        const val = array[i];
        const b = document.createElement('div');
        b.className = 'bar';
        b.setAttribute('role','listitem');
        b.setAttribute('data-index', i);
        b.setAttribute('tabindex', 0);
        b.innerHTML = `<div class="value" aria-hidden="false">${val}</div>`;
        const heightPercent = 20 + Math.round(80 * (val - min) / (max - min + 1));
        b.style.height = heightPercent + '%';
        // Allow clicking to edit
        b.addEventListener('click', () => editBarValue(i));
        b.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') editBarValue(i);
        });
        barsEl.appendChild(b);
      }
    }

    // Edit a bar's value via prompt (keeps it simple & accessible)
    function editBarValue(index) {
      const newVal = prompt('Edit value (integer):', String(array[index]));
      if (newVal === null) return;
      const v = parseInt(newVal,10);
      if (!Number.isFinite(v)) return alert('Please enter a valid integer.');
      array[index] = v;
      initialArray = array.slice();
      renderArray(true);
      resetAlgorithmState();
    }

    // FLIP animation utility to swap two indices in the DOM and array with animation
    async function animateSwap(i, j, visualMark='swap') {
      if (animating) await wait(20);
      animating = true;
      const bars = Array.from(barsEl.children);
      const aEl = bars.find(el => Number(el.dataset.index) === i);
      const bEl = bars.find(el => Number(el.dataset.index) === j);
      if (!aEl || !bEl) { animating = false; return; }

      // Get first positions
      const rects1 = barsEl.getBoundingClientRect();
      const aRect = aEl.getBoundingClientRect();
      const bRect = bEl.getBoundingClientRect();

      // Apply visual class
      aEl.classList.add(visualMark);
      bEl.classList.add(visualMark);

      // Prepare for FLIP:
      // swap array first so that DOM order will represent new state after reflow
      // But we need to compute deltas for animation using the inverse order, so
      // clone positions:
      const clones = bars.map(el => el.cloneNode(true));
      // place clones overlayed
      const overlay = document.createElement('div');
      overlay.style.position = 'absolute';
      overlay.style.left = '0';
      overlay.style.top = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.pointerEvents = 'none';
      overlay.style.zIndex = '1000';
      // map original positions
      bars.forEach((el, idx) => {
        const r = el.getBoundingClientRect();
        const c = clones[idx];
        c.style.position = 'absolute';
        c.style.left = (r.left - rects1.left) + 'px';
        c.style.top = (r.top - rects1.top) + 'px';
        c.style.width = r.width + 'px';
        c.style.height = r.height + 'px';
        c.style.margin = '0';
        c.style.boxSizing = 'border-box';
        overlay.appendChild(c);
      });
      barsEl.appendChild(overlay);

      // Perform swap in model
      const tmp = array[i]; array[i] = array[j]; array[j] = tmp;

      // Re-render bars DOM to reflect new order (quick and stable)
      renderArray(true);

      // Now compute second positions and animate clones to their new rects
      const newBars = Array.from(barsEl.children).filter(n => n !== overlay);
      const rects2 = newBars.map(el => el.getBoundingClientRect());

      // Animate clones to new positions
      clones.forEach((c, idx) => {
        const start = c.getBoundingClientRect();
        const target = rects2[idx];
        const dx = (target.left - rects1.left) - (start.left - rects1.left);
        const dy = (target.top - rects1.top) - (start.top - rects1.top);
        c.style.transition = `transform ${300 / speed}ms cubic-bezier(.22,.9,.2,1), opacity ${200 / speed}ms`;
        c.style.transform = `translate(${dx}px, ${dy}px)`;
      });

      await wait(320 / speed);
      // cleanup overlay
      overlay.remove();

      // animate highlight fade
      const updatedBars = Array.from(barsEl.children);
      updatedBars.forEach(el => el.classList.remove('swap', 'compare'));
      // mark final indices for a moment
      const newA = updatedBars.find(el => Number(el.dataset.index) === i);
      const newB = updatedBars.find(el => Number(el.dataset.index) === j);
      if (newA) newA.classList.add('swap');
      if (newB) newB.classList.add('swap');
      await wait(150 / speed);
      if (newA) newA.classList.remove('swap');
      if (newB) newB.classList.remove('swap');

      animating = false;
    }

    function highlightCompare(i, j) {
      clearHighlights();
      const bars = Array.from(barsEl.children);
      const a = bars.find(el => Number(el.dataset.index) === i);
      const b = bars.find(el => Number(el.dataset.index) === j);
      if (a) a.classList.add('compare');
      if (b) b.classList.add('compare');
    }
    function highlightPivot(i) {
      const bars = Array.from(barsEl.children);
      bars.forEach(el => el.classList.remove('pivot'));
      const p = bars.find(el => Number(el.dataset.index) === i);
      if (p) p.classList.add('pivot');
    }
    function markSortedRange(lo, hi) {
      const bars = Array.from(barsEl.children);
      bars.forEach(el => {
        const idx = Number(el.dataset.index);
        if (idx >= lo && idx <= hi) el.classList.add('sorted');
      });
    }
    function clearHighlights(){
      const bars = Array.from(barsEl.children);
      bars.forEach(el => el.classList.remove('pivot','compare','swap','sorted'));
    }

    /* ---------- QuickSort action generator ---------- */
    // Produces a sequence of actions: {type, payload}
    // Types: 'setPivot', 'compare', 'swap', 'partitionDone', 'markSorted', 'stack'
    function* quickSortActions(arr) {
      const A = arr;
      const n = A.length;
      // We'll operate on indices 0..n-1
      // Use explicit stack to generate frame updates
      const stack = [{lo:0, hi:n-1, state:'visit'}];

      while (stack.length > 0) {
        yield {type:'stack', stack: stack.slice()};
        const frame = stack.pop();
        const lo = frame.lo, hi = frame.hi;
        if (lo >= hi) {
          // single element or empty -> mark sorted range
          if (lo === hi) yield {type: 'markSorted', lo, hi};
          continue;
        }
        // Partition step: choose pivot index based on strategy callback (external)
        const pivotChoice = choosePivot(A, lo, hi);
        // swap pivot into A[hi] if needed
        if (pivotChoice !== hi) {
          yield {type:'setPivot', index: pivotChoice};
          yield {type:'swap', i: pivotChoice, j: hi};
        } else {
          yield {type:'setPivot', index: pivotChoice};
        }
        const pivotVal = A[hi];

        let i = lo;
        yield {type:'partitionBegin', lo, hi, pivotIndex: hi};
        for (let j = lo; j <= hi -1; j++) {
          yield {type:'compare', i: j, j: hi};
          if (A[j] <= pivotVal) {
            // swap A[i] and A[j]
            if (i !== j) {
              yield {type:'swap', i, j};
            }
            i++;
          }
        }
        // place pivot at position i
        if (i !== hi) yield {type:'swap', i, j: hi};
        // pivot is at i
        yield {type:'partitionDone', p: i, lo, hi};
        // push recursive calls onto stack (right then left so left is processed next)
        // As this is just for visualization, we push right then left to keep recursion order intuitive
        stack.push({lo: i+1, hi: hi, state:'visit'});
        stack.push({lo: lo, hi: i-1, state:'visit'});
      }
      // final pass: mark all sorted
      yield {type:'done'};
    }

    // choosePivot is controlled by UI; we store strategy here and make it available
    function choosePivot(A, lo, hi) {
      const strat = pivotSelect.value;
      if (strat === 'first') return lo;
      if (strat === 'last') return hi;
      if (strat === 'middle') return lo + Math.floor((hi - lo)/2);
      if (strat === 'random') return Math.floor(Math.random() * (hi - lo + 1)) + lo;
      if (strat === 'median3') {
        const a = A[lo], b = A[hi], c = A[lo + Math.floor((hi-lo)/2)];
        const trio = [{v:a,i:lo},{v:b,i:hi},{v:c,i:lo+Math.floor((hi-lo)/2)}];
        trio.sort((x,y)=>x.v-y.v);
        return trio[1].i;
      }
      return hi;
    }

    /* ---------- Driver: running / stepping through actions ---------- */

    async function runLoop() {
      if (!actionGenerator) actionGenerator = quickSortActions(array.slice());
      // If already animating, wait
      while (running) {
        const next = actionGenerator.next();
        if (next.done) {
          updateStatus('Finished');
          running = false;
          playBtn.textContent = 'Play';
          playBtn.setAttribute('aria-pressed','false');
          break;
        }
        const act = next.value;
        await handleAction(act);
        // Pause slightly between actions depending on speed
        await wait(120 / speed);
        if (!running) break;
      }
    }

    async function stepOnce() {
      if (!actionGenerator) actionGenerator = quickSortActions(array.slice());
      const next = actionGenerator.next();
      if (next.done) {
        updateStatus('Finished');
        return;
      }
      const act = next.value;
      await handleAction(act);
    }

    async function handleAction(act) {
      switch(act.type) {
        case 'stack':
          populateStack(act.stack);
          break;
        case 'setPivot':
          highlightPivot(act.index);
          highlightPseudocode(11);
          updateStatus('Selected pivot at index ' + act.index);
          break;
        case 'partitionBegin':
          highlightPseudocode(12);
          updateStatus(`Partitioning range [${act.lo}, ${act.hi}]`);
          populateStack([{lo:act.lo,hi:act.hi}]); // emphasize current
          break;
        case 'compare':
          highlightCompare(act.i, act.j);
          highlightPseudocode(14);
          updateStatus(`Compare index ${act.i} with pivot`);
          break;
        case 'swap':
          highlightPseudocode(14);
          updateStatus(`Swapping index ${act.i} and ${act.j}`);
          await animateSwap(act.i, act.j, 'swap');
          renderArray();
          break;
        case 'partitionDone':
          highlightPseudocode(15);
          markSortedRange(act.p, act.p);
          updateStatus(`Partition complete. Pivot placed at ${act.p}`);
          // small pause
          await wait(220 / speed);
          break;
        case 'markSorted':
          markSortedRange(act.lo, act.hi);
          updateStatus(`Element at ${act.lo} is sorted`);
          break;
        case 'done':
          updateStatus('Array sorted');
          // mark all sorted
          markSortedRange(0, array.length-1);
          highlightPseudocode(null);
          break;
        default:
          // unknown
          break;
      }
    }

    function updateStatus(text) {
      statusEl.textContent = text;
    }

    function populateStack(s) {
      stackFrames.innerHTML = '';
      const stackCopy = s.slice().reverse();
      if (stackCopy.length === 0) {
        const e = document.createElement('div');
        e.className = 'muted';
        e.style.opacity = '0.6';
        e.textContent = 'No pending frames';
        stackFrames.appendChild(e);
        return;
      }
      stackCopy.forEach(frame => {
        const f = document.createElement('div');
        f.className = 'frame';
        f.textContent = `[${frame.lo}, ${frame.hi}]`;
        stackFrames.appendChild(f);
      });
    }

    function highlightPseudocode(lineNumber) {
      const lines = Array.from(pseudocode.querySelectorAll('.line'));
      lines.forEach(l => {
        const ln = Number(l.dataset.line);
        if (ln === lineNumber) l.classList.add('active');
        else l.classList.remove('active');
      });
    }

    /* ---------- Helpers ---------- */
    function wait(ms) {
      return new Promise(res => setTimeout(res, ms));
    }

    // On load
    init();

    // initial render
    renderArray();

  </script>
</body>
</html>