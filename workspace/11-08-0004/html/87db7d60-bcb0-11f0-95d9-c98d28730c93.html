<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive: Longest Common Subsequence (LCS)</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1721;
      --panel: #0b1220;
      --card: #0f1728;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --success: #10b981;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.03);
      --radius: 10px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Segoe UI Mono", monospace;
      color-scheme: dark;
    }

    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#07111a 0%, #071217 60%);
      color: #e6eef6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Safe area margins */
    .page{
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:var(--gap);
    }

    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }

    .subtitle{
      color:var(--muted);
      font-size:13px;
      margin-top:6px;
    }

    main{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
    }

    /* Left: Design Plan */
    .plan{
      width:360px;
      min-width:260px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015));
      border-radius: var(--radius);
      padding:18px;
      box-sizing:border-box;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
      line-height:1.45;
    }

    .plan h2{
      font-size:16px;
      margin:0 0 10px 0;
    }

    .plan section{
      margin-bottom:14px;
    }

    .plan .label{
      font-weight:600;
      color:var(--accent);
      font-size:13px;
      margin-bottom:6px;
    }

    .plan p{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* Right: Interactive module */
    .module{
      flex:1;
      min-width:0;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding:18px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      box-shadow: 0 6px 24px rgba(2,6,23,0.7);
    }

    .controls{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }

    .input-group{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width:200px;
    }

    label{
      font-size:13px;
      color:var(--muted);
    }

    input[type="text"]{
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background: rgba(255,255,255,0.02);
      color:inherit;
      font-size:14px;
      outline:none;
    }

    .btn{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      color:var(--accent);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
    }
    .btn:active{ transform:translateY(1px); }

    .btn.ghost{
      color:var(--muted);
      background:transparent;
      border:1px dashed rgba(255,255,255,0.03);
    }

    .btn.primary{
      background: linear-gradient(90deg, rgba(6,182,212,0.12), rgba(16,185,129,0.06));
      color: #dffeff;
      border: 1px solid rgba(6,182,212,0.12);
    }

    .small{
      padding:6px 8px;
      font-size:13px;
      border-radius:8px;
    }

    .panel{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      flex-wrap:wrap;
    }

    .matrix-wrap{
      background:var(--glass);
      border-radius:8px;
      padding:12px;
      overflow:auto;
      max-width:100%;
      min-height:180px;
      flex:1;
      border:1px solid rgba(255,255,255,0.02);
    }

    /* DP grid */
    .grid{
      display:inline-grid;
      gap:4px;
      background:transparent;
      padding:8px;
    }

    .cell{
      width:44px;
      height:44px;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,0.02);
      border-radius:8px;
      font-size:14px;
      color:#cfeff6;
      position:relative;
      transition: transform 180ms ease, background-color 180ms linear, box-shadow 180ms linear;
      box-sizing:border-box;
      border:1px solid rgba(255,255,255,0.02);
    }

    .cell.header{
      background: rgba(255,255,255,0.02);
      color:var(--muted);
      font-weight:700;
    }

    .cell.char{
      font-weight:700;
      color:var(--muted);
      font-size:13px;
    }

    .cell.value{
      font-family: var(--mono);
      font-size:14px;
    }

    .cell.match{
      background: linear-gradient(90deg, rgba(6,182,212,0.12), rgba(16,185,129,0.03));
      box-shadow: 0 6px 18px rgba(6,182,212,0.06);
      color:#ffffff;
    }

    .cell.current{
      transform: translateY(-6px) scale(1.02);
      box-shadow: 0 10px 30px rgba(0,0,0,0.6), 0 6px 22px rgba(6,182,212,0.06);
      z-index:5;
    }

    .cell.arrow{
      font-size:12px;
      color:var(--muted);
    }

    .cell.path{
      background: linear-gradient(90deg, rgba(16,185,129,0.14), rgba(6,182,212,0.08));
      color:#fff;
      font-weight:700;
    }

    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }

    .legend .box{
      width:12px;
      height:12px;
      border-radius:3px;
      display:inline-block;
      vertical-align:middle;
      margin-right:8px;
    }

    .controls-row{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }

    .play-controls{
      display:flex;
      gap:8px;
      align-items:center;
    }

    .status{
      color:var(--muted);
      font-size:13px;
      margin-left:auto;
    }

    .result{
      background: rgba(255,255,255,0.01);
      border-radius:8px;
      padding:10px;
      border: 1px solid rgba(255,255,255,0.02);
      min-height:54px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }

    .lcs-out{
      font-family: var(--mono);
      font-size:15px;
      color:#dffeff;
      font-weight:700;
      letter-spacing:0.6px;
    }

    .explain{
      color:var(--muted);
      font-size:13px;
    }

    /* Responsive */
    @media (max-width:980px){
      main{flex-direction:column;}
      .plan{ width:100%; }
      .module{ width:100%; }
      .matrix-wrap{ max-height:360px; }
    }

    /* Accessibility focus */
    button:focus, input:focus{
      outline: 2px solid rgba(6,182,212,0.18);
      outline-offset: 2px;
    }

    /* tiny arrow indicators inside cell */
    .pointer{
      position:absolute;
      left:6px;
      top:6px;
      font-size:11px;
      color:var(--muted);
    }

    .seq-high{
      background:linear-gradient(90deg, rgba(16,185,129,0.14), rgba(6,182,212,0.06));
      border-radius:6px;
      padding:4px 8px;
      color:#eaffff;
      font-weight:700;
      display:inline-block;
    }

    /* small slider */
    .slider{
      -webkit-appearance: none;
      width:120px;
      height:6px;
      background: rgba(255,255,255,0.04);
      border-radius:10px;
      outline:none;
    }
    .slider::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:14px;height:14px;border-radius:50%;
      background:var(--accent);
      box-shadow:0 4px 10px rgba(6,182,212,0.2);
      cursor:pointer;
      border: none;
    }

    /* small note */
    .note{
      color:var(--muted);
      font-size:12px;
    }

  </style>
</head>
<body>
  <div class="page" role="main">
    <header>
      <div>
        <h1>Longest Common Subsequence — Interactive Module</h1>
        <div class="subtitle">Step through the dynamic programming matrix, visualize choices and backtrack the LCS.</div>
      </div>
      <div class="status" aria-live="polite" id="statusBar">Ready</div>
    </header>

    <main>
      <!-- Design Plan -->
      <aside class="plan" aria-labelledby="planTitle">
        <h2 id="planTitle">Design Plan</h2>

        <section>
          <div class="label">Concept Title</div>
          <p>Longest Common Subsequence (LCS): visualize DP filling and backtracking to extract the longest subsequence common to two strings.</p>
        </section>

        <section>
          <div class="label">Learning Objective</div>
          <p>After interacting, users will understand how the DP table for LCS is built, how values and choices (match vs. max of neighbors) determine the score, and how backtracking yields the actual subsequence.</p>
        </section>

        <section>
          <div class="label">Interaction Design</div>
          <p>
            Users type or choose two strings. They can step through the DP table cell-by-cell (Next/Prev), auto-play the filling animation, or instantly compute. Each computed cell animates into view, displays its value and a small arrow showing which neighbor it derived from (↖ match, ↑ from above, ← from left). After filling, a "Trace LCS" animation follows the backtrack path highlighting cells and corresponding characters in the original strings. Clicking any cell shows an explanation of why its value was chosen. Keyboard-accessible controls and an adjustable speed slider provide control over pacing.
          </p>
        </section>

        <section>
          <div class="label">Layout Description</div>
          <p>
            Two-column responsive layout: left column holds this design plan (fixed width); right column is the interactive module. Safe area margins are 24px; spacing between interactive controls is at least 16px. The interactive panel contains input controls at the top, the DP matrix in the center (scrollable), and playback + result summary below. Visual focus is maintained by highlighting the active cell and path, and by keeping controls grouped for quick access.
          </p>
        </section>

        <div class="note" style="margin-top:8px;">Accessibility: controls are keyboard-focusable; status updates use aria-live; color contrast optimized for dark themes.</div>
      </aside>

      <!-- Interactive Module -->
      <section class="module" aria-labelledby="moduleTitle">
        <div id="moduleTitle" style="display:none;">LCS Interactive Module</div>

        <div class="controls" role="region" aria-label="Controls">
          <div class="input-group">
            <label for="strA">String A</label>
            <input id="strA" type="text" maxlength="20" value="AGGTAB" aria-describedby="strAHelp" />
            <div id="strAHelp" class="note">Up to 20 chars. Letters/digits allowed.</div>
          </div>

          <div class="input-group">
            <label for="strB">String B</label>
            <input id="strB" type="text" maxlength="20" value="GXTXAYB" />
          </div>

          <div style="display:flex;flex-direction:column;gap:8px;">
            <div style="display:flex;gap:8px;">
              <button id="computeBtn" class="btn primary small" aria-label="Compute DP table">Compute</button>
              <button id="animateBtn" class="btn small" aria-label="Animate filling">Animate</button>
              <button id="resetBtn" class="btn ghost small" aria-label="Reset">Reset</button>
            </div>
            <div style="display:flex;gap:8px;align-items:center;">
              <select id="examples" class="small" aria-label="Examples">
                <option value="">Examples...</option>
                <option value="AGGTAB|GXTXAYB">AGGTAB / GXTXAYB</option>
                <option value="ABCBDAB|BDCABA">ABCBDAB / BDCABA</option>
                <option value="XMJYAUZ|MZJAWXU">XMJYAUZ / MZJAWXU</option>
                <option value="ABCDEF|FBDAMN">ABCDEF / FBDAMN</option>
                <option value="ABC|DEF">ABC / DEF</option>
              </select>
              <button id="randBtn" class="btn small" aria-label="Randomize short strings">Random</button>
              <div class="note" style="margin-left:6px;">(Max 16 chars recommended)</div>
            </div>
          </div>
        </div>

        <div class="panel" style="align-items:flex-start;">
          <div class="matrix-wrap" role="region" aria-label="DP matrix">
            <div id="matrixContainer" style="min-width:240px; overflow:auto;"></div>
          </div>

          <div style="width:260px; display:flex;flex-direction:column; gap:12px;">
            <div class="legend" aria-hidden="true">
              <div><span class="box" style="background:linear-gradient(90deg, rgba(6,182,212,0.12), rgba(16,185,129,0.03));"></span>match</div>
              <div><span class="box" style="background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02);"></span>regular</div>
              <div><span class="box" style="background:linear-gradient(90deg, rgba(16,185,129,0.14), rgba(6,182,212,0.06));"></span>backtrack path</div>
            </div>

            <div style="background:var(--glass); padding:12px; border-radius:8px;">
              <div class="controls-row" style="margin-bottom:8px;">
                <div class="play-controls">
                  <button id="prevBtn" class="btn small" aria-label="Previous step">◀ Prev</button>
                  <button id="nextBtn" class="btn small" aria-label="Next step">Next ▶</button>
                  <button id="playBtn" class="btn small" aria-label="Play">Play ►</button>
                  <button id="traceBtn" class="btn small" aria-label="Trace LCS">Trace LCS</button>
                </div>
              </div>

              <div style="display:flex;align-items:center;gap:8px;">
                <label for="speed" class="note">Speed</label>
                <input id="speed" type="range" min="100" max="1500" value="400" class="slider" />
                <div id="speedVal" class="note" style="min-width:54px;text-align:right;">400 ms</div>
              </div>
            </div>

            <div class="result" aria-live="polite">
              <div>
                <div class="explain">Longest Common Subsequence:</div>
                <div id="lcsText" class="lcs-out">—</div>
              </div>
              <div style="width:1px;background:rgba(255,255,255,0.02);height:48px;"></div>
              <div style="text-align:right;">
                <div class="explain">Cells filled</div>
                <div id="filledCount" class="note">0</div>
              </div>
            </div>

            <div style="font-size:13px;color:var(--muted);">
              <div style="margin-bottom:6px;">Interaction tips:</div>
              <ul style="margin:0 0 0 18px; padding:0; color:var(--muted);">
                <li>Click a cell to get an explanation of its value.</li>
                <li>Use Play to auto-step; Trace to animate backtracking.</li>
                <li>Try mismatched strings to see zero LCS.</li>
              </ul>
            </div>

          </div>
        </div>

      </section>
    </main>

    <footer style="color:var(--muted); font-size:13px;">
      Implemented with vanilla HTML, CSS and JavaScript. No external libraries.
    </footer>
  </div>

  <script>
    (function(){
      // Utilities and DOM
      const el = id => document.getElementById(id);
      const strA = el('strA');
      const strB = el('strB');
      const computeBtn = el('computeBtn');
      const animateBtn = el('animateBtn');
      const resetBtn = el('resetBtn');
      const randBtn = el('randBtn');
      const examples = el('examples');
      const matrixContainer = el('matrixContainer');
      const prevBtn = el('prevBtn');
      const nextBtn = el('nextBtn');
      const playBtn = el('playBtn');
      const traceBtn = el('traceBtn');
      const speed = el('speed');
      const speedVal = el('speedVal');
      const lcsText = el('lcsText');
      const filledCount = el('filledCount');
      const statusBar = el('statusBar');

      // State
      let A = '', B = '';
      let n=0,m=0;
      let dp = []; // (n+1)x(m+1)
      let parent = []; // store direction: 'diag','up','left'
      let steps = []; // array of {i,j,val,from,match}
      let stepIndex = -1;
      let playTimer = null;
      let isPlaying = false;
      let matrixEl = null;
      let maxLenDisplay = 16; // recommendation cap for neatness

      function setStatus(s){ statusBar.textContent = s; }

      // Build matrix UI
      function buildEmptyMatrix(){
        matrixContainer.innerHTML = '';
        const a = A.split('');
        const b = B.split('');
        n = a.length; m = b.length;
        const rows = n + 2; // header row plus dp rows
        const cols = m + 2;

        // Create grid wrapper
        const grid = document.createElement('div');
        grid.className = 'grid';
        grid.style.gridTemplateColumns = `repeat(${cols}, auto)`;
        grid.style.gridAutoRows = 'min-content';
        // Add top-left empty cell
        // First row: empty, header for B chars (with leading blank)
        // Row 0, col 0:
        const topLeft = createCell('', 'header');
        grid.appendChild(topLeft);

        // Row 0, col 1..m: header blank for 0 column
        const topHeaderBlank = createCell('', 'header'); // for alignment (represents dp[0][0])
        grid.appendChild(topHeaderBlank);

        // Now B chars header
        for(let j=0;j<m;j++){
          const c = createCell(b[j], 'char header');
          grid.appendChild(c);
        }

        // Now rows for A (each row begins with header char or blank for 0)
        for(let i=0;i<n+1;i++){
          // Leftmost header: for dp row 0 we add blank; otherwise character
          if(i===0){
            const header0 = createCell('', 'header');
            grid.appendChild(header0);
          } else {
            const header = createCell(a[i-1], 'char header');
            grid.appendChild(header);
          }

          // Now dp cells for columns 0..m-1 but we include dp[0..m] -> m+1 cells
          for(let j=0;j<m+1;j++){
            const cell = createCell('', 'cell value');
            cell.dataset.i = i; cell.dataset.j = j;
            cell.tabIndex = 0;
            cell.setAttribute('role','button');
            cell.setAttribute('aria-label', `Cell ${i},${j}`);
            cell.addEventListener('click', ()=>onCellClick(i,j));
            cell.addEventListener('keydown', (ev) => {
              if(ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); onCellClick(i,j); }
            });
            grid.appendChild(cell);
          }
        }

        matrixContainer.appendChild(grid);
        matrixEl = grid;
        // set small hint
        setStatus('Matrix built. Press Compute or Animate.');
      }

      function createCell(text, cls='cell'){
        const d = document.createElement('div');
        d.className = cls ? ('cell '+cls) : 'cell';
        d.innerHTML = text || '';
        return d;
      }

      // Prepare DP arrays and steps
      function prepareDP(){
        const a = A.split(''), b = B.split('');
        n = a.length; m = b.length;
        dp = Array.from({length:n+1}, ()=>Array(m+1).fill(0));
        parent = Array.from({length:n+1}, ()=>Array(m+1).fill(''));
        steps = [];
        let count = 0;
        for(let i=1;i<=n;i++){
          for(let j=1;j<=m;j++){
            const cell = {i,j,match:false,from:'',val:0};
            if(a[i-1] === b[j-1]){
              dp[i][j] = dp[i-1][j-1] + 1;
              parent[i][j] = 'diag';
              cell.match = true;
              cell.from = 'diag';
              cell.val = dp[i][j];
            } else {
              if(dp[i-1][j] >= dp[i][j-1]){
                dp[i][j] = dp[i-1][j];
                parent[i][j] = 'up';
                cell.from = 'up';
                cell.val = dp[i][j];
              } else {
                dp[i][j] = dp[i][j-1];
                parent[i][j] = 'left';
                cell.from = 'left';
                cell.val = dp[i][j];
              }
            }
            steps.push(cell);
            count++;
          }
        }
        // Also push final step mark
        stepIndex = -1;
        setStatus(`Prepared ${steps.length} steps. Ready to animate or compute instantly.`);
        filledCount.textContent = '0';
        lcsText.textContent = '—';
      }

      // Update a single cell UI (i,j) with dp value and arrow
      function updateCellUI(i,j,val,from,match,highlight=false){
        // Find the corresponding cell element in grid.
        // Grid layout: first row is header cells (1 + 1 + m) => we appended top-left, topHeaderBlank, then B chars
        // For rows: for each of n+1 rows (i from 0..n) we added a left header plus m+1 dp cells.
        // So index in grid children:
        // index = (top header row had (m+2) elements) + (rowIndex)*(m+2) + (1 + j)
        const cols = m + 2;
        const topRowCount = cols;
        const rowIndex = i + 1; // because top header row is rowIndex 0
        const idx = topRowCount + (rowIndex -1)*cols + (1 + j);
        const cell = matrixEl.children[idx];
        if(!cell) return;
        cell.innerHTML = ''; // clear
        const valEl = document.createElement('div');
        valEl.className = 'cell.value';
        valEl.textContent = val;
        cell.appendChild(valEl);

        // arrow
        const arrow = document.createElement('div');
        arrow.className = 'pointer';
        arrow.textContent = from === 'diag' ? '↖' : (from === 'up' ? '↑' : (from === 'left' ? '←' : ''));
        cell.appendChild(arrow);
        // update classes
        cell.classList.remove('match','current','path');
        if(match) cell.classList.add('match');
        if(highlight) cell.classList.add('current');
      }

      // Reset UI cells to blank values
      function clearMatrixValues(){
        // iterate dp cells and clear
        if(!matrixEl) return;
        const cols = m + 2;
        const topRowCount = cols;
        for(let i=0;i<=n;i++){
          for(let j=0;j<=m;j++){
            const rowIndex = i + 1;
            const idx = topRowCount + (rowIndex -1)*cols + (1 + j);
            const cell = matrixEl.children[idx];
            if(cell){
              cell.innerHTML = '';
              cell.classList.remove('match','current','path');
              cell.classList.add('value');
            }
          }
        }
      }

      // Build full table instantly
      function computeInstant(){
        if(n>maxLenDisplay || m>maxLenDisplay){
          if(!confirm('Large strings may produce a wide table. Continue?')) return;
        }
        prepareDP();
        // render all dp values
        for(const s of steps){
          updateCellUI(s.i, s.j, s.val, s.from, s.match, false);
        }
        filledCount.textContent = String(steps.length);
        lcsText.textContent = backtrackString();
        setStatus('Computed instantly. Click Trace LCS to animate backtracking.');
      }

      // Step animation controls
      function animateStart(){
        if(steps.length===0) prepareDP();
        if(n>maxLenDisplay || m>maxLenDisplay){
          if(!confirm('Large strings may produce a wide table. Continue?')) return;
        }
        clearMatrixValues();
        stepIndex = -1;
        filledCount.textContent = '0';
        isPlaying = true;
        playBtn.textContent = 'Pause ❚❚';
        play();
      }

      function play(){
        if(!isPlaying) return;
        const delay = parseInt(speed.value,10);
        playTimer = setTimeout(()=>{
          if(stepIndex < steps.length -1){
            stepForward();
            play();
          } else {
            isPlaying = false;
            playBtn.textContent = 'Play ►';
            setStatus('Animation complete.');
            lcsText.textContent = backtrackString();
          }
        }, delay);
      }

      function stepForward(){
        if(steps.length===0) prepareDP();
        if(stepIndex < steps.length -1){
          stepIndex++;
          const s = steps[stepIndex];
          updateCellUI(s.i, s.j, s.val, s.from, s.match, true);
          // un-highlight previous
          if(stepIndex>0){
            const prev = steps[stepIndex-1];
            updateCellUI(prev.i, prev.j, prev.val, prev.from, prev.match, false);
          }
          filledCount.textContent = String(stepIndex+1);
          setStatus(`Filled cell (${s.i},${s.j}) = ${s.val} ${s.match ? '(match)' : ''}`);
        }
      }

      function stepBackward(){
        if(steps.length===0) return;
        if(stepIndex >= 0){
          const s = steps[stepIndex];
          // clear current cell
          updateCellUI(s.i, s.j, '', '', false, false);
          stepIndex--;
          filledCount.textContent = String(Math.max(0, stepIndex+1));
          setStatus('Stepped back.');
        }
      }

      function animateStop(){
        isPlaying = false;
        if(playTimer) { clearTimeout(playTimer); playTimer = null; }
        playBtn.textContent = 'Play ►';
      }

      // On cell click: show explanation
      function onCellClick(i,j){
        if(i<0 || j<0) return;
        if(i===0 || j===0){
          setStatus(`Cell (${i},${j}): boundary cell = 0.`);
          return;
        }
        if(dp && dp[i] && typeof dp[i][j] !== 'undefined'){
          const val = dp[i][j];
          const why = parent[i][j] === 'diag' ? `characters match: A[${i-1}] == B[${j-1}]` : `taken max of neighbors: up ${dp[i-1][j]} vs left ${dp[i][j-1]}`;
          setStatus(`Cell (${i},${j}) = ${val}. Reason: ${why}.`);
          // briefly highlight
          highlightCell(i,j,'current',600);
        } else {
          setStatus(`Cell (${i},${j}) not yet computed.`);
        }
      }

      function highlightCell(i,j,cls,ms=400){
        // find and add class then remove
        const cols = m + 2;
        const topRowCount = cols;
        const rowIndex = i + 1;
        const idx = topRowCount + (rowIndex -1)*cols + (1 + j);
        const cell = matrixEl.children[idx];
        if(!cell) return;
        cell.classList.add(cls);
        setTimeout(()=>cell.classList.remove(cls), ms);
      }

      // Backtracking animation
      function traceBackAnimate(){
        if(!parent || parent.length===0){ setStatus('Compute the DP table first.'); return; }
        // Start from (n,m)
        let i = n, j = m;
        const path = [];
        while(i>0 && j>0){
          path.push({i,j});
          const p = parent[i][j];
          if(p === 'diag'){
            i--; j--;
          } else if(p === 'up'){
            i--;
          } else {
            j--;
          }
        }
        // Animate path highlighting and highlight sequence chars as chosen
        let idx = 0;
        const delay = parseInt(speed.value,10);
        function step(){
          if(idx >= path.length){
            // finished
            setStatus('Backtracking complete. LCS highlighted.');
            lcsText.textContent = backtrackString();
            return;
          }
          const cell = path[idx];
          const ci = cell.i, cj = cell.j;
          // find and mark cell as path
          markCellPath(ci,cj,true);
          // If this cell is a diag and chars match, highlight corresponding characters in sequences in header
          if(parent[ci][cj] === 'diag'){
            highlightSeqChar(ci-1, cj-1);
          }
          idx++;
          setTimeout(step, delay);
        }
        // clear existing path highlights
        clearPathHighlights();
        step();
      }

      function backtrackString(){
        if(!parent || parent.length===0) return '—';
        let i=n, j=m;
        const a = A.split(''), b = B.split('');
        const res = [];
        while(i>0 && j>0){
          if(parent[i][j] === 'diag'){
            res.push(a[i-1]);
            i--; j--;
          } else if(parent[i][j] === 'up'){
            i--;
          } else {
            j--;
          }
        }
        return res.reverse().join('') || '—';
      }

      function markCellPath(i,j,add){
        const cols = m + 2;
        const topRowCount = cols;
        const rowIndex = i + 1;
        const idx = topRowCount + (rowIndex -1)*cols + (1 + j);
        const cell = matrixEl.children[idx];
        if(cell){
          if(add) cell.classList.add('path');
          else cell.classList.remove('path');
        }
      }

      function clearPathHighlights(){
        if(!matrixEl) return;
        const nodes = matrixEl.querySelectorAll('.path');
        nodes.forEach(n => n.classList.remove('path'));
        // also clear seq highlights
        const seqEls = matrixContainer.querySelectorAll('.seq-high');
        seqEls.forEach(e => e.classList.remove('seq-high'));
      }

      // Highlight matching characters in headers by wrapping header cells with highlight (we can locate header cells)
      function highlightSeqChar(ai, bj){
        // Find top B header cell for bj: that's in first row (row 0) after two header cells: index = 2 + bj
        // But we created top-left, topHeaderBlank, then B chars: grid children indexes 0..(m+1)
        const topBIndex = 2 + bj; // 0-based within matrixEl.children
        const topCell = matrixEl.children[topBIndex];
        if(topCell){
          topCell.classList.add('seq-high');
          setTimeout(()=>topCell.classList.remove('seq-high'), parseInt(speed.value,10));
        }
        // For left A header: each row begins at index: topRowCount + rowIndex*cols
        const cols = m + 2;
        const rowIndex = ai + 1; // because header row 0
        const leftHeaderIdx = (m + 2) + (rowIndex -1)*cols; // first element of that row
        const leftCell = matrixEl.children[leftHeaderIdx];
        if(leftCell){
          leftCell.classList.add('seq-high');
          setTimeout(()=>leftCell.classList.remove('seq-high'), parseInt(speed.value,10));
        }
      }

      // Random short strings
      function randomStrings(){
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const lenA = Math.floor(Math.random()*6) + 3;
        const lenB = Math.floor(Math.random()*6) + 3;
        let a='', b='';
        for(let i=0;i<lenA;i++) a += chars.charAt(Math.floor(Math.random()*chars.length));
        for(let j=0;j<lenB;j++) b += chars.charAt(Math.floor(Math.random()*chars.length));
        strA.value = a;
        strB.value = b;
        loadStrings();
      }

      // Example select
      examples.addEventListener('change', ()=>{
        const val = examples.value;
        if(!val) return;
        const parts = val.split('|');
        strA.value = parts[0] || '';
        strB.value = parts[1] || '';
        loadStrings();
      });

      randBtn.addEventListener('click', randomStrings);

      // Load strings and build matrix
      function loadStrings(){
        A = (strA.value || '').trim();
        B = (strB.value || '').trim();
        if(!A && !B){
          alert('Please enter at least one string.');
          return;
        }
        if(A.length>60 || B.length>60){
          if(!confirm('Very long strings may be slow. Continue?')) return;
        }
        buildEmptyMatrix();
        // Prepare arrays but do not compute until user asks
        dp = []; parent = []; steps = [];
        stepIndex = -1;
        lcsText.textContent = '—';
        filledCount.textContent = '0';
      }

      // Hook up controls
      computeBtn.addEventListener('click', ()=>{
        loadStrings();
        computeInstant();
      });

      animateBtn.addEventListener('click', ()=>{
        loadStrings();
        animateStart();
      });

      resetBtn.addEventListener('click', ()=>{
        loadStrings();
      });

      // Step / Play controls
      nextBtn.addEventListener('click', ()=>{
        if(isPlaying){ animateStop(); }
        if(steps.length===0) prepareDP();
        stepForward();
      });

      prevBtn.addEventListener('click', ()=>{
        if(isPlaying){ animateStop(); }
        stepBackward();
      });

      playBtn.addEventListener('click', ()=>{
        if(isPlaying){
          animateStop();
        } else {
          if(steps.length===0) prepareDP();
          isPlaying = true;
          playBtn.textContent = 'Pause ❚❚';
          play();
        }
      });

      traceBtn.addEventListener('click', ()=>{
        if(isPlaying) animateStop();
        if(steps.length===0) prepareDP();
        // If not all steps filled yet, we should fill them so parent is available, for realism we compute dp completely now
        computeInstant(); // this also populates parent
        // small delay to allow rendering
        setTimeout(()=>{ traceBackAnimate(); }, 140);
      });

      speed.addEventListener('input', ()=>{
        speedVal.textContent = `${speed.value} ms`;
      });

      // Click compute when pressing Enter in inputs
      [strA,strB].forEach(inp=>{
        inp.addEventListener('keydown', (ev)=>{
          if(ev.key === 'Enter'){
            computeBtn.click();
          }
        });
      });

      // On load set default
      (function init(){
        loadStrings();
        setStatus('Ready');
      })();

      // Expose some functions for debugging in console (optional)
      window.__lcs = {
        prepareDP, computeInstant, animateStart, traceBackAnimate, backtrackString
      };
    })();
  </script>
</body>
</html>