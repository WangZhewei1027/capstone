<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Binary Tree Traversal Explorer</title>
  <style>
    :root{
      --safe-pad:24px;
      --gap:16px;
      --bg:#0f1724;
      --panel:#0b1220;
      --muted:#94a3b8;
      --accent:#60a5fa;
      --accent-2:#7dd3fc;
      --node-fill:#071032;
      --node-border:#90a4ff;
      --visit:#f97316;
      --stack-bg:#071133;
      --good:#10b981;
      --danger:#ef4444;
    }
    html,body{
      height:100%;
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      background: linear-gradient(180deg,var(--bg),#071025 80%);
      color: #e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .root{
      padding:var(--safe-pad);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    header{
      display:flex;
      gap:var(--gap);
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .title h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* Toolbar */
    .toolbar{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }
    .controls-row{
      display:flex;
      gap:12px;
      align-items:center;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      padding:10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
    }
    button, .radio-group label{
      background:transparent;
      color:inherit;
      border:1px solid rgba(255,255,255,0.06);
      padding:8px 10px;
      border-radius:6px;
      cursor:pointer;
      font-size:13px;
    }
    button:hover{ border-color:rgba(255,255,255,0.12); transform:translateY(-1px); }
    button:active{ transform:translateY(0); }
    button[aria-pressed="true"]{
      border-color:var(--accent);
      box-shadow:0 6px 20px rgba(96,165,250,0.08);
      background:linear-gradient(180deg, rgba(96,165,250,0.08), rgba(125,211,252,0.02));
    }
    .radio-group{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .radio-group input[type="radio"]{ display:none; }
    .radio-group label{
      border-color:rgba(255,255,255,0.04);
    }
    .radio-group input[type="radio"]:checked + label{
      border-color:var(--accent);
      background:linear-gradient(180deg, rgba(96,165,250,0.06), transparent);
    }

    /* Layout main area */
    .main{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      flex:1 1 auto;
      min-height:400px;
    }
    .canvas-panel{
      flex:1 1 60%;
      min-width:280px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      border-radius:10px;
      padding:16px;
      border:1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:420px;
    }
    .canvas-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .canvas-wrap{
      flex:1 1 auto;
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:320px;
      overflow:auto;
      padding:8px;
      border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
    }
    svg.tree{
      width:100%;
      height:100%;
      min-height:320px;
      overflow:visible;
      touch-action:none;
    }

    /* Node visuals */
    .node {
      cursor:pointer;
      transition:transform 240ms ease, fill 180ms ease;
    }
    .node circle{
      fill:var(--node-fill);
      stroke:var(--node-border);
      stroke-width:1.6px;
      transition:fill 160ms linear, stroke 160ms linear, r 120ms;
    }
    .node text{
      fill:#e6eef8;
      font-size:12px;
      pointer-events:none;
      dominant-baseline:middle;
      text-anchor:middle;
    }
    .node.visit circle{
      fill:var(--visit);
      stroke:var(--visit);
      transform-origin:center center;
      animation:pulse 650ms ease;
    }
    @keyframes pulse{
      0%{ transform:scale(1); filter:drop-shadow(0 0 0 rgba(249,115,22,0.0)); }
      50%{ transform:scale(1.08); filter:drop-shadow(0 6px 18px rgba(249,115,22,0.12)); }
      100%{ transform:scale(1); filter:drop-shadow(0 0 0 rgba(249,115,22,0.0)); }
    }
    .edge{
      stroke:#213152;
      stroke-width:2;
      fill:none;
      transition:stroke 180ms;
      stroke-linecap:round;
    }
    .edge.active{
      stroke:var(--accent-2);
      stroke-width:2.6;
    }

    /* Small plus placeholder for adding children */
    .plus{
      fill:rgba(255,255,255,0.03);
      stroke:rgba(255,255,255,0.12);
      stroke-width:1;
      cursor:pointer;
    }

    /* Right panels: stack & visited */
    .side{
      width:320px;
      min-width:220px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .panel{
      background:linear-gradient(180deg,var(--panel), rgba(0,0,0,0.02));
      border-radius:10px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.03);
      min-height:120px;
      max-height:420px;
      overflow:auto;
      box-sizing:border-box;
    }
    .panel h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:var(--muted);
    }
    .stack{
      display:flex;
      flex-direction:column-reverse;
      gap:8px;
      align-items:flex-end;
    }
    .stack .item{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--accent-2);
      min-width:60%;
      text-align:center;
      transform-origin:center;
      transition:transform 200ms ease, opacity 200ms ease;
    }
    .visited-list{
      display:flex;
      flex-direction:row;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .visited-list .badge{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      padding:6px 8px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--good);
      font-size:13px;
    }

    /* small contextual edit toolbar */
    .node-toolbar{
      position: absolute;
      min-width:140px;
      background:linear-gradient(180deg, rgba(0,0,0,0.35), rgba(0,0,0,0.15));
      border-radius:8px;
      padding:8px;
      border:1px solid rgba(255,255,255,0.04);
      display:flex;
      gap:8px;
      align-items:center;
      z-index:20;
    }
    .node-toolbar input[type="text"]{
      padding:6px 8px;
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      border-radius:6px;
      color:inherit;
      width:64px;
    }
    .hint{
      color:var(--muted);
      font-size:12px;
    }

    /* responsive */
    @media (max-width:900px){
      .main{ flex-direction:column; }
      .side{ width:100%; }
      .canvas-panel{ width:100%; min-height:360px; }
    }

    /* reduced motion */
    @media (prefers-reduced-motion:reduce){
      .node.visit circle{ animation:none; transform:none; }
      .node{ transition:none; }
      .edge{ transition:none; }
    }
  </style>
</head>
<body>
  <div class="root" role="application" aria-label="Binary Tree Traversal Explorer">
    <header>
      <div class="title">
        <h1>Binary Tree Traversal Explorer</h1>
        <p class="subtitle">Interactively explore preorder, inorder and postorder traversals with a simulated call stack.</p>
      </div>

      <div class="toolbar" role="toolbar" aria-label="Controls">
        <div class="controls-row" role="group" aria-label="Tree operations">
          <button id="randomBtn" title="Generate a random tree">Random Tree</button>
          <button id="resetBtn" title="Reset to small demo tree">Reset</button>
          <button id="clearBtn" title="Clear tree">Clear</button>
          <button id="toggleEdit" aria-pressed="false" title="Toggle edit mode">Edit Mode</button>
        </div>

        <div class="controls-row" role="group" aria-label="Traversal controls">
          <div class="radio-group" role="radiogroup" aria-label="Traversal type">
            <input type="radio" id="pre" name="traversal" value="preorder" checked>
            <label for="pre">Preorder</label>
            <input type="radio" id="in" name="traversal" value="inorder">
            <label for="in">Inorder</label>
            <input type="radio" id="post" name="traversal" value="postorder">
            <label for="post">Postorder</label>
          </div>
          <button id="playPause" title="Play / Pause">Play</button>
          <button id="stepBtn" title="Step">Step</button>
          <label style="display:flex;align-items:center;gap:8px;">
            <span class="hint" style="font-size:12px;color:var(--muted)">Speed</span>
            <input id="speed" type="range" min="200" max="1400" value="600" step="50" aria-label="Playback speed" />
          </label>
        </div>
      </div>
    </header>

    <main class="main">
      <section class="canvas-panel" aria-label="Canvas panel">
        <div class="canvas-header">
          <div class="hint">Click "+" to add children in Edit Mode. Click a node to edit value or remove it.</div>
          <div class="hint">Keyboard: Space toggles play/pause. → step forward. ← step back.</div>
        </div>
        <div class="canvas-wrap" id="canvasWrap">
          <svg class="tree" id="treeSvg" viewBox="0 0 800 420" preserveAspectRatio="xMidYMin meet" aria-hidden="false" role="img"></svg>
          <!-- node toolbar dynamically placed -->
          <div id="nodeToolbar" class="node-toolbar" style="display:none;" aria-hidden="true">
            <input id="nodeValueInput" type="text" maxlength="6" aria-label="Edit node value"/>
            <button id="applyNode">Apply</button>
            <button id="removeNode" title="Remove node">Remove</button>
          </div>
        </div>
      </section>

      <aside class="side" aria-label="Panels">
        <div class="panel" aria-live="polite">
          <h3>Call Stack (top = current)</h3>
          <div id="stack" class="stack" aria-label="Call stack"></div>
        </div>

        <div class="panel" aria-live="polite">
          <h3>Visited Order</h3>
          <div id="visited" class="visited-list" aria-label="Visited nodes"></div>
        </div>
      </aside>
    </main>
  </div>

  <script>
    (function(){
      // Utilities
      const svg = document.getElementById('treeSvg');
      const canvasWrap = document.getElementById('canvasWrap');
      const stackEl = document.getElementById('stack');
      const visitedEl = document.getElementById('visited');
      const randomBtn = document.getElementById('randomBtn');
      const resetBtn = document.getElementById('resetBtn');
      const clearBtn = document.getElementById('clearBtn');
      const toggleEditBtn = document.getElementById('toggleEdit');
      const playPauseBtn = document.getElementById('playPause');
      const stepBtn = document.getElementById('stepBtn');
      const speedRange = document.getElementById('speed');
      const nodeToolbar = document.getElementById('nodeToolbar');
      const nodeValueInput = document.getElementById('nodeValueInput');
      const applyNodeBtn = document.getElementById('applyNode');
      const removeNodeBtn = document.getElementById('removeNode');

      let editMode = false;
      let traversalType = 'preorder';
      let playing = false;
      let playTimer = null;
      let speed = Number(speedRange.value);
      let eventIndex = 0;
      let events = [];
      let visitedCount = 0;
      let currentNodeId = null;
      let nodesById = new Map();

      // Tree data structure
      let nextId = 1;
      let root = null;

      // Basic node factory
      function newNode(value){
        const id = String(nextId++);
        const node = { id, value: String(value), left:null, right:null, _x:0, _y:0 };
        nodesById.set(id,node);
        return node;
      }

      // Sample small balanced tree
      function sampleTree(){
        nodesById.clear();
        nextId = 1;
        const n1 = newNode('A');
        const n2 = newNode('B');
        const n3 = newNode('C');
        const n4 = newNode('D');
        const n5 = newNode('E');
        const n6 = newNode('F');
        n1.left = n2.id;
        n1.right = n3.id;
        n2.left = n4.id;
        n2.right = n5.id;
        n3.right = n6.id;
        root = n1.id;
      }

      // Random small tree
      function randomTree(maxNodes = 9){
        nodesById.clear();
        nextId = 1;
        const count = Math.max(1, Math.floor(Math.random()*(maxNodes-1))+1);
        root = null;
        // insert nodes level-order ensuring binary tree shape
        let created = [];
        for(let i=0;i<count;i++){
          const n = newNode(String.fromCharCode(65 + (i % 26)));
          created.push(n);
          if(i===0){ root = n.id; continue; }
          // find parent with free slot
          for(let p of created){
            if(p.left === null){ p.left = n.id; break; }
            if(p.right === null){ p.right = n.id; break; }
          }
        }
      }

      // Clear tree
      function clearTree(){
        nodesById.clear();
        nextId = 1;
        root = null;
      }

      // Layout: compute positions using inorder indexing
      function layoutTree(){
        if(!root) return;
        const gapX = 60;
        const gapY = 90;
        let index = 0;
        function dfs(nid, depth){
          const node = nodesById.get(nid);
          if(!node) return;
          if(node.left) dfs(node.left, depth+1);
          node._x = (++index) * gapX;
          node._y = depth * gapY + 40;
          if(node.right) dfs(node.right, depth+1);
        }
        dfs(root,0);
        // adjust viewbox width
        const width = Math.max(800, (index+2) * gapX);
        const height = Math.max(320, getMaxDepth()*gapY + 120);
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      }
      function getMaxDepth(){
        let max = 0;
        function dfs(nid, d){
          if(!nid) return;
          max = Math.max(max, d);
          const n = nodesById.get(nid);
          if(n.left) dfs(n.left, d+1);
          if(n.right) dfs(n.right, d+1);
        }
        if(root) dfs(root, 0);
        return max;
      }

      // Render the tree into the SVG
      function render(){
        // clear
        while(svg.firstChild) svg.removeChild(svg.firstChild);
        nodesById.forEach(n => { n._el = null; n._edgeLeft = null; n._edgeRight = null; });

        layoutTree();
        if(!root) return;

        // draw edges
        function drawEdges(nid){
          const n = nodesById.get(nid);
          if(!n) return;
          if(n.left){
            const child = nodesById.get(n.left);
            const path = document.createElementNS('http://www.w3.org/2000/svg','path');
            path.setAttribute('class','edge');
            const x1 = n._x, y1 = n._y;
            const x2 = child._x, y2 = child._y;
            const midY = (y1+y2)/2;
            const d = `M ${x1} ${y1+12} C ${x1} ${midY} ${x2} ${midY} ${x2} ${y2-12}`;
            path.setAttribute('d', d);
            path.dataset.from = n.id;
            path.dataset.to = child.id;
            svg.appendChild(path);
            n._edgeLeft = path;
            drawEdges(n.left);
          }
          if(n.right){
            const child = nodesById.get(n.right);
            const path = document.createElementNS('http://www.w3.org/2000/svg','path');
            path.setAttribute('class','edge');
            const x1 = n._x, y1 = n._y;
            const x2 = child._x, y2 = child._y;
            const midY = (y1+y2)/2;
            const d = `M ${x1} ${y1+12} C ${x1} ${midY} ${x2} ${midY} ${x2} ${y2-12}`;
            path.setAttribute('d', d);
            path.dataset.from = n.id;
            path.dataset.to = child.id;
            svg.appendChild(path);
            n._edgeRight = path;
            drawEdges(n.right);
          }
        }
        drawEdges(root);

        // draw nodes (after edges)
        nodesById.forEach(n=>{
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('class','node');
          g.setAttribute('data-id', n.id);
          g.setAttribute('transform', `translate(${n._x},${n._y})`);
          g.setAttribute('tabindex','0');
          g.setAttribute('role','button');
          g.setAttribute('aria-label', `Node ${n.value}`);
          // circle
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('r', 18);
          g.appendChild(c);
          // text
          const t = document.createElementNS('http://www.w3.org/2000/svg','text');
          t.textContent = n.value;
          g.appendChild(t);

          // placeholders for add child in edit mode
          const px = 28, py = 32;
          if(!n.left){
            const plusL = document.createElementNS('http://www.w3.org/2000/svg','g');
            plusL.setAttribute('class','plus placeholder-left');
            plusL.setAttribute('transform', `translate(${-px},${py})`);
            plusL.setAttribute('data-action','add-left');
            plusL.innerHTML = '<rect x="-14" y="-10" width="28" height="20" rx="6" fill="transparent"></rect>';
            const pl = document.createElementNS('http://www.w3.org/2000/svg','circle');
            pl.setAttribute('r',10);
            pl.setAttribute('fill','rgba(255,255,255,0.02)');
            pl.setAttribute('stroke','rgba(255,255,255,0.06)');
            pl.setAttribute('stroke-width','1');
            plusL.appendChild(pl);
            const ptxt = document.createElementNS('http://www.w3.org/2000/svg','text');
            ptxt.setAttribute('y',1);
            ptxt.setAttribute('font-size','12');
            ptxt.setAttribute('fill','var(--muted)');
            ptxt.textContent = '+';
            plusL.appendChild(ptxt);
            g.appendChild(plusL);
          }
          if(!n.right){
            const plusR = document.createElementNS('http://www.w3.org/2000/svg','g');
            plusR.setAttribute('class','plus placeholder-right');
            plusR.setAttribute('transform', `translate(${px},${py})`);
            plusR.setAttribute('data-action','add-right');
            plusR.innerHTML = '<rect x="-14" y="-10" width="28" height="20" rx="6" fill="transparent"></rect>';
            const pr = document.createElementNS('http://www.w3.org/2000/svg','circle');
            pr.setAttribute('r',10);
            pr.setAttribute('fill','rgba(255,255,255,0.02)');
            pr.setAttribute('stroke','rgba(255,255,255,0.06)');
            pr.setAttribute('stroke-width','1');
            plusR.appendChild(pr);
            const ptxt = document.createElementNS('http://www.w3.org/2000/svg','text');
            ptxt.setAttribute('y',1);
            ptxt.setAttribute('font-size','12');
            ptxt.setAttribute('fill','var(--muted)');
            ptxt.textContent = '+';
            plusR.appendChild(ptxt);
            g.appendChild(plusR);
          }
          svg.appendChild(g);
          n._el = g;
        });

        // attach listeners
        svg.querySelectorAll('.node').forEach(g=>{
          g.addEventListener('click', onNodeClick);
          g.addEventListener('keydown', e=>{
            if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onNodeClick(e); }
          });
        });
        svg.querySelectorAll('.placeholder-left, .placeholder-right').forEach(p=>{
          p.style.cursor = editMode ? 'pointer' : 'default';
          p.addEventListener('click', onPlaceholderClick);
        });

        // hide toolbar
        hideNodeToolbar();
      }

      // Event handlers
      function onPlaceholderClick(e){
        e.stopPropagation();
        if(!editMode) return;
        const action = this.getAttribute('data-action');
        // parent node
        const parentG = this.closest('.node');
        const pid = parentG.getAttribute('data-id');
        const parent = nodesById.get(pid);
        if(!parent) return;
        const newVal = prompt('Value for new node:', String.fromCharCode(65 + (Math.floor(Math.random()*26))));
        if(newVal === null) return;
        const n = newNode(newVal || '?');
        if(action === 'add-left') parent.left = n.id;
        else parent.right = n.id;
        render();
      }

      function onNodeClick(e){
        e.stopPropagation();
        const g = this;
        const id = g.getAttribute('data-id');
        if(editMode){
          showNodeToolbar(id, g);
        } else {
          // in play mode, clicking a node will jump to that node's next event (if any)
          // For simplicity: highlight node briefly and scroll it into view
          const n = nodesById.get(id);
          if(n){
            // temporary pulse
            g.classList.add('visit');
            setTimeout(()=>g.classList.remove('visit'), 700);
            scrollToNode(n);
          }
        }
      }

      // Toolbar
      let toolbarTargetId = null;
      function showNodeToolbar(id, svgNode){
        toolbarTargetId = id;
        const pt = svgNode.getCTM();
        const x = svgNode._prevX || svgNode.getBoundingClientRect().left;
        // place toolbar near clicked node (absolute coordinates)
        const canvasRect = canvasWrap.getBoundingClientRect();
        const nodeRect = svgNode.getBoundingClientRect();
        nodeToolbar.style.display = 'flex';
        nodeToolbar.style.top = (nodeRect.top - canvasRect.top + nodeRect.height + 8) + 'px';
        nodeToolbar.style.left = Math.min(canvasRect.width - 160, nodeRect.left - canvasRect.left) + 'px';
        nodeValueInput.value = nodesById.get(id).value;
      }
      function hideNodeToolbar(){
        toolbarTargetId = null;
        nodeToolbar.style.display = 'none';
      }
      applyNodeBtn.addEventListener('click', ()=>{
        if(!toolbarTargetId) return;
        const n = nodesById.get(toolbarTargetId);
        if(!n) return;
        n.value = nodeValueInput.value || n.value;
        render();
      });
      removeNodeBtn.addEventListener('click', ()=>{
        if(!toolbarTargetId) return;
        // remove node and its subtree by unlinking from parent
        const id = toolbarTargetId;
        // find parent
        let parent = null, parentSide = null;
        nodesById.forEach(n=>{
          if(n.left === id){ parent = n; parentSide = 'left'; }
          if(n.right === id){ parent = n; parentSide = 'right'; }
        });
        // delete subtree
        function deleteSub(id){
          const n = nodesById.get(id);
          if(!n) return;
          if(n.left) deleteSub(n.left);
          if(n.right) deleteSub(n.right);
          nodesById.delete(id);
        }
        deleteSub(id);
        if(parent){
          parent[parentSide] = null;
        } else {
          // deleting root
          root = null;
        }
        hideNodeToolbar();
        render();
      });

      // traversal logger: produce events array of {type:'push'|'visit'|'pop', id}
      function generateEvents(type){
        const ev = [];
        if(!root) return ev;
        function preorder(nid){
          if(!nid) return;
          ev.push({type:'push', id:nid});
          ev.push({type:'visit', id:nid});
          if(nodesById.get(nid).left) preorder(nodesById.get(nid).left);
          if(nodesById.get(nid).right) preorder(nodesById.get(nid).right);
          ev.push({type:'pop', id:nid});
        }
        function inorder(nid){
          if(!nid) return;
          ev.push({type:'push', id:nid});
          if(nodesById.get(nid).left) inorder(nodesById.get(nid).left);
          ev.push({type:'visit', id:nid});
          if(nodesById.get(nid).right) inorder(nodesById.get(nid).right);
          ev.push({type:'pop', id:nid});
        }
        function postorder(nid){
          if(!nid) return;
          ev.push({type:'push', id:nid});
          if(nodesById.get(nid).left) postorder(nodesById.get(nid).left);
          if(nodesById.get(nid).right) postorder(nodesById.get(nid).right);
          ev.push({type:'visit', id:nid});
          ev.push({type:'pop', id:nid});
        }
        if(type === 'preorder') preorder(root);
        else if(type === 'inorder') inorder(root);
        else postorder(root);
        return ev;
      }

      // Playback and animation
      function resetSimulation(){
        if(playTimer){ clearInterval(playTimer); playTimer = null; }
        playing = false;
        playPauseBtn.textContent = 'Play';
        eventIndex = 0;
        events = generateEvents(traversalType);
        visitedEl.innerHTML = '';
        stackEl.innerHTML = '';
        visitedCount = 0;
        clearAllHighlights();
      }
      function clearAllHighlights(){
        svg.querySelectorAll('.node').forEach(g=>g.classList.remove('visit'));
        svg.querySelectorAll('.edge').forEach(e=>e.classList.remove('active'));
      }
      function play(){
        if(events.length === 0) return;
        playing = true;
        playPauseBtn.textContent = 'Pause';
        if(playTimer) clearInterval(playTimer);
        playTimer = setInterval(()=> {
          if(eventIndex >= events.length){ pause(); return; }
          stepForward();
        }, speed);
      }
      function pause(){
        playing = false;
        playPauseBtn.textContent = 'Play';
        if(playTimer){ clearInterval(playTimer); playTimer = null; }
      }
      function stepForward(){
        if(eventIndex >= events.length) return;
        const ev = events[eventIndex++];
        handleEvent(ev);
      }
      function stepBackward(){
        if(eventIndex <= 0) return;
        // rebuild and replay up to eventIndex-1 to get previous state
        eventIndex = Math.max(0, eventIndex - 1);
        rebuildToIndex(eventIndex);
      }
      function rebuildToIndex(idx){
        // reset visuals and then replay events up to idx (exclusive)
        svg.querySelectorAll('.edge').forEach(e=>e.classList.remove('active'));
        svg.querySelectorAll('.node').forEach(g=>g.classList.remove('visit'));
        stackEl.innerHTML = '';
        visitedEl.innerHTML = '';
        visitedCount = 0;
        for(let i=0;i<idx;i++){
          simulateEventNoAnimation(events[i]);
        }
      }
      function simulateEventNoAnimation(ev){
        const node = nodesById.get(ev.id);
        if(!node) return;
        if(ev.type === 'push'){
          addStackItem(node);
        } else if(ev.type === 'visit'){
          addVisited(node);
        } else if(ev.type === 'pop'){
          popStackItem(node);
        }
      }
      function handleEvent(ev){
        const node = nodesById.get(ev.id);
        if(!node) { return; }
        if(ev.type === 'push'){
          addStackItem(node, true);
        } else if(ev.type === 'visit'){
          // highlight node
          const g = node._el;
          if(g){
            g.classList.add('visit');
            // find edge from parent to this node and briefly activate it
            const parentEdge = findParentEdge(ev.id);
            if(parentEdge){
              parentEdge.classList.add('active');
              setTimeout(()=> parentEdge.classList.remove('active'), Math.max(300, speed/3));
            }
            // remove class after animation duration
            setTimeout(()=> g.classList.remove('visit'), 700);
          }
          addVisited(node, true);
        } else if(ev.type === 'pop'){
          popStackItem(node, true);
        }
      }
      function findParentEdge(childId){
        // find edge connecting to child
        const edges = svg.querySelectorAll('.edge');
        for(const e of edges){
          if(e.dataset.to === childId) return e;
        }
        return null;
      }

      // Stack UI manipulations
      function addStackItem(node, animate=false){
        const div = document.createElement('div');
        div.className = 'item';
        div.textContent = node.value;
        div.dataset.id = node.id;
        if(animate){
          div.style.transform = 'translateY(10px)';
          div.style.opacity = '0';
          stackEl.appendChild(div);
          requestAnimationFrame(()=> {
            div.style.transform = '';
            div.style.opacity = '';
          });
        } else {
          stackEl.appendChild(div);
        }
      }
      function popStackItem(node, animate=false){
        // remove top-most item matching node.id
        const items = Array.from(stackEl.children);
        for(let i=items.length-1;i>=0;i--){
          const it = items[i];
          if(it.dataset.id === node.id){
            if(animate){
              it.style.transform = 'translateY(10px)';
              it.style.opacity = '0';
              setTimeout(()=> {
                if(it.parentNode) it.parentNode.removeChild(it);
              }, 220);
            } else {
              it.parentNode.removeChild(it);
            }
            return;
          }
        }
      }

      // Visited list
      function addVisited(node, animate=false){
        visitedCount++;
        const b = document.createElement('div');
        b.className = 'badge';
        b.textContent = `${visitedCount}: ${node.value}`;
        visitedEl.appendChild(b);
      }

      // Controls wiring
      randomBtn.addEventListener('click', ()=>{
        randomTree();
        resetSimulation();
        render();
      });
      resetBtn.addEventListener('click', ()=>{
        sampleTree();
        resetSimulation();
        render();
      });
      clearBtn.addEventListener('click', ()=>{
        clearTree();
        resetSimulation();
        render();
      });
      toggleEditBtn.addEventListener('click', ()=>{
        editMode = !editMode;
        toggleEditBtn.setAttribute('aria-pressed', String(editMode));
        toggleEditBtn.textContent = editMode ? 'Edit Mode (on)' : 'Edit Mode';
        render();
      });

      document.querySelectorAll('input[name="traversal"]').forEach(r=>{
        r.addEventListener('change', ()=>{
          traversalType = document.querySelector('input[name="traversal"]:checked').value;
          resetSimulation();
        });
      });

      playPauseBtn.addEventListener('click', ()=>{
        if(playing) pause();
        else play();
      });
      stepBtn.addEventListener('click', ()=>{
        if(playing) { pause(); }
        stepForward();
      });
      speedRange.addEventListener('input', ()=>{
        speed = Number(speedRange.value);
        if(playing){
          pause();
          play();
        }
      });

      // keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
        if(e.code === 'Space'){ e.preventDefault(); if(playing) pause(); else play(); }
        if(e.code === 'ArrowRight'){ e.preventDefault(); if(playing) pause(); stepForward(); else stepForward(); }
        if(e.code === 'ArrowLeft'){ e.preventDefault(); stepBackward(); }
      });

      // click on canvas to hide any toolbar
      document.addEventListener('click', (e)=>{
        if(!nodeToolbar.contains(e.target)) hideNodeToolbar();
      });

      // scroll node into view
      function scrollToNode(node){
        const el = node._el;
        if(!el) return;
        const r = el.getBoundingClientRect();
        const canvasRect = canvasWrap.getBoundingClientRect();
        // compute scroll offsets to center node
        canvasWrap.scrollLeft += (r.left + r.width/2) - (canvasRect.left + canvasRect.width/2);
        canvasWrap.scrollTop += (r.top + r.height/2) - (canvasRect.top + canvasRect.height/2);
      }

      // Initial demo
      sampleTree();
      resetSimulation();
      render();

      // expose some debugging on window for convenience
      window._bt = {
        nodesById, render, sampleTree, randomTree, resetSimulation
      };

      // Accessibility: announce event index updates
      const liveAnnouncer = document.createElement('div');
      liveAnnouncer.setAttribute('aria-live','polite');
      liveAnnouncer.style.position='absolute';
      liveAnnouncer.style.left='-9999px';
      document.body.appendChild(liveAnnouncer);

      // hook to update announcer on each event
      const origHandleEvent = handleEvent;
      handleEvent = function(ev){
        origHandleEvent(ev);
        const node = nodesById.get(ev.id);
        if(node){
          const msg = ev.type === 'push' ? `Enter ${node.value}` : ev.type === 'visit' ? `Visit ${node.value}` : `Return from ${node.value}`;
          liveAnnouncer.textContent = msg;
        }
      };
    })();
  </script>
</body>
</html>