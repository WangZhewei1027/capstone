<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Insertion Sort — Interactive Module</title>
  <style>
    :root{
      --safe-pad: 24px;               /* safe area margin */
      --gap: 16px;                   /* minimum spacing between interactive elements */
      --bg: #0f1720;
      --card: #0b1220;
      --muted: #9aa7b2;
      --accent: #38bdf8;
      --success: #34d399;
      --danger: #fb7185;
      --focus: #fef08a;
      --bar-bg: #e6eef6;
      --bar-height-max: 220px;
    }

    /* Global layout and safety margins */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071125 0%, #071722 40%);
      color: #e6eef6;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .app {
      padding: var(--safe-pad);
      box-sizing: border-box;
      max-width: 1200px;
      margin: 0 auto;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    h1 {
      margin:0;
      font-size: 1.5rem;
      letter-spacing: -0.02em;
    }

    .subtitle {
      margin:0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    main {
      display: grid;
      grid-template-columns: 1fr 340px;
      gap: var(--gap);
      align-items: start;
    }

    /* Responsive: stack controls under main on small screens */
    @media (max-width: 880px) {
      main {
        grid-template-columns: 1fr;
      }
    }

    /* Visualization card */
    .viz-card{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.05));
      border: 1px solid rgba(255,255,255,0.04);
      padding: 16px;
      border-radius: 12px;
      box-shadow: 0 6px 24px rgba(2,6,23,0.6);
      min-height: 420px;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    .viz-top {
      display:flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap:wrap;
    }

    .small {
      color: var(--muted);
      font-size: 0.9rem;
    }

    .array-container {
      position: relative;
      height: calc(var(--bar-height-max) + 80px);
      border-radius:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.03));
      padding: 18px;
      overflow: hidden;
      display:flex;
      align-items:flex-end;
      justify-content:center;
    }

    /* Each bar is absolutely positioned inside .bars-stage */
    .bars-stage{
      position: relative;
      width: 100%;
      max-width: 1000px;
      height: 100%;
      min-height: var(--bar-height-max);
    }

    .bar {
      position: absolute;
      bottom: 44px; /* leave room for labels below bars */
      width: 56px;
      background: linear-gradient(180deg,#f1f6fb,#cfeaf8);
      border-radius: 8px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color: #08303b;
      font-weight:700;
      box-shadow: 0 6px 16px rgba(2,8,20,0.45);
      transition: transform 400ms cubic-bezier(.2,.9,.2,1), box-shadow 200ms, background 200ms;
      user-select: none;
      cursor: default;
    }

    .bar .label {
      margin-bottom: 6px;
      font-size: 0.9rem;
      background: rgba(255,255,255,0.85);
      padding: 4px 8px;
      border-radius: 8px;
      transform: translateY(6px);
    }

    .bar .idx {
      position:absolute;
      bottom:-32px;
      font-size: 0.78rem;
      color: var(--muted);
      left:50%;
      transform: translateX(-50%);
    }

    /* colors for roles */
    .bar.sorted {
      background: linear-gradient(180deg,#dffcf0,#b7f1da);
      box-shadow: 0 8px 26px rgba(12,64,46,0.35);
    }

    .bar.key {
      background: linear-gradient(180deg,#ffd9b3,#ffc58a);
      box-shadow: 0 10px 30px rgba(95,42,5,0.35);
      z-index: 40;
      transform: translateY(-18px) scale(1.03);
    }

    .bar.compare {
      outline: 3px solid rgba(251,113,133,0.14);
      box-shadow: 0 10px 30px rgba(203,35,63,0.14);
      z-index: 39;
    }

    /* controls panel */
    .controls{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03));
      border-radius: 12px;
      padding: 16px;
      border: 1px solid rgba(255,255,255,0.04);
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      min-height: 420px;
    }

    .group {
      display:flex;
      gap: 12px;
      align-items:center;
      flex-wrap:wrap;
    }

    .btn {
      background: linear-gradient(180deg,#0f1724,#071224);
      color: var(--accent);
      border: 1px solid rgba(56,189,248,0.12);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      min-width: 48px;
      font-weight:600;
      transition: transform 120ms, box-shadow 120ms;
    }

    .btn:hover { transform: translateY(-3px); }
    .btn:active { transform: translateY(0); }

    .btn.primary {
      background: linear-gradient(180deg,#06b6d4,#0ea5b7);
      color: #032023;
      border: none;
      box-shadow: 0 8px 20px rgba(6,182,212,0.15);
    }

    .control-row {
      display:flex;
      gap: 12px;
      align-items:center;
      flex-wrap:wrap;
    }

    input[type="range"] {
      appearance: none;
      height: 6px;
      background: rgba(255,255,255,0.06);
      border-radius: 999px;
      outline: none;
    }

    .small-input {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.04);
      background: transparent;
      color: inherit;
      min-width: 120px;
    }

    .array-input {
      width:100%;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background: rgba(255,255,255,0.02);
      color: inherit;
    }

    .log {
      font-size: 0.95rem;
      color: var(--muted);
      background: rgba(255,255,255,0.02);
      border-radius:8px;
      padding:10px;
      min-height:56px;
    }

    footer.note {
      font-size:0.9rem;
      color:var(--muted);
    }

    /* code-like display for pseudocode */
    pre.pseudocode {
      background: rgba(0,0,0,0.25);
      padding: 12px;
      border-radius: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Helvetica Neue", monospace;
      color: #dbeafe;
      font-size: 0.9rem;
      white-space: pre-wrap;
      margin:0;
    }

    /* accessibility focus */
    .btn:focus, .small-input:focus, .array-input:focus {
      box-shadow: 0 0 0 4px rgba(254,224,102,0.12);
      outline: none;
    }

    /* Status badges */
    .status {
      display:inline-flex;
      gap:8px;
      align-items:center;
      background: rgba(255,255,255,0.02);
      padding: 6px 10px;
      border-radius: 999px;
      font-weight:600;
      color:var(--muted);
      font-size:0.9rem;
    }

    .status .dot {
      width:10px;height:10px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 6px 18px rgba(56,189,248,0.12);
    }

    /* ensure minimum spacing between interactive elements */
    .controls > * { margin-bottom: 0 !important; }
    .controls .group > * { margin-bottom: 0 !important; }

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Insertion Sort interactive module">
    <header>
      <h1>Insertion Sort — Step-by-step Interactive Explorer</h1>
      <p class="subtitle">Visualize how insertion sort builds a sorted region by inserting one element at a time.</p>
    </header>

    <main>
      <!-- VISUALIZATION -->
      <section class="viz-card" aria-labelledby="viz-title">
        <div class="viz-top">
          <div>
            <div id="viz-title" class="small" style="font-weight:700">Array visualization</div>
            <div class="small" id="viz-sub">Bars represent values; numbers below indicate indices.</div>
          </div>
          <div class="status" aria-live="polite">
            <div class="dot" id="status-dot" style="background: var(--accent)"></div>
            <div id="status-text">Ready</div>
          </div>
        </div>

        <div class="array-container" id="array-container" aria-hidden="false">
          <div class="bars-stage" id="bars-stage" role="list" aria-label="Array elements">
            <!-- Bars injected by JS -->
          </div>
        </div>

        <div style="display:flex;gap:var(--gap);flex-wrap:wrap;align-items:center;justify-content:space-between;">
          <div class="small" id="explain-text">Tip: Click "Step" to advance one algorithm action. Use Play to animate.</div>
          <div style="display:flex;gap:12px;align-items:center">
            <div class="small" id="pseudocode-label" style="color:var(--muted)">Pseudocode</div>
            <pre class="pseudocode" id="pseudocode">
for i = 1 to n-1
  key = A[i]
  j = i - 1
  while j >= 0 and A[j] > key
    A[j+1] = A[j]    // shift right
    j = j - 1
  A[j+1] = key      // insert key
            </pre>
          </div>
        </div>
      </section>

      <!-- CONTROLS -->
      <aside class="controls" aria-label="Controls">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div style="font-weight:700">Controls</div>
          <div class="small" style="color:var(--muted)">Accessible · Responsive · Animated</div>
        </div>

        <div class="group" role="group" aria-label="Initial array controls" style="gap:var(--gap);">
          <button class="btn" id="btn-randomize" title="Create a random array">Randomize</button>
          <button class="btn" id="btn-shuffle" title="Shuffle current array">Shuffle</button>
          <label style="display:flex;align-items:center;gap:8px">
            <span class="small" style="color:var(--muted)">Size</span>
            <input type="range" id="size-range" min="5" max="12" value="8" aria-label="Array size">
          </label>
        </div>

        <div style="display:flex;flex-direction:column;gap:8px;">
          <input id="array-input" class="array-input" placeholder="Enter comma-separated numbers (e.g. 5,3,8,1)" aria-label="Array input text"/>
          <div style="display:flex;gap:12px;">
            <button class="btn primary" id="btn-apply">Apply Array</button>
            <button class="btn" id="btn-reset">Reset</button>
          </div>
        </div>

        <div style="display:flex;flex-direction:column;gap:8px;">
          <div style="display:flex;gap:12px;align-items:center;">
            <button class="btn" id="btn-stepback" title="Step backward (previous snapshot)">⟵ Step</button>
            <button class="btn primary" id="btn-step" title="Step forward">Step ⟶</button>
            <button class="btn" id="btn-play" title="Play / Pause">Play ▶</button>
            <button class="btn" id="btn-fast" title="Fast-forward to end">Fast ▶▶</button>
            <button class="btn" id="btn-stop" title="Stop and reset">Stop ⟲</button>
          </div>

          <div style="display:flex;gap:12px;align-items:center;">
            <label class="small" style="min-width:48px;color:var(--muted)">Speed</label>
            <input type="range" id="speed-range" min="0.25" max="2.5" step="0.05" value="1" aria-label="Playback speed">
            <div class="small" id="speed-label" style="color:var(--muted)">1.0x</div>
          </div>
        </div>

        <div>
          <div style="font-weight:700">Step log</div>
          <div class="log" id="log" aria-live="polite"></div>
        </div>

        <div>
          <div style="font-weight:700">Interaction Design</div>
          <div class="small" style="color:var(--muted);margin-top:6px">
            - Click "Step" to execute one algorithm action (select, compare, shift, insert).<br>
            - Click "Play" to animate steps automatically. Use "Speed" to adjust tempo.<br>
            - Type a custom array or use Randomize / Shuffle. "Apply" locks the array for sorting.<br>
            - Use Step Back to review prior state (history snapshots are stored).<br>
            - Bars lift and slide to show the key being moved and other elements shifting — visualizing the algorithm.
          </div>
        </div>

        <div>
          <div style="font-weight:700">Learning Objective</div>
          <div class="small" style="color:var(--muted);margin-top:6px">
            After interacting, you should understand how insertion sort gradually grows a sorted prefix by taking a key element and shifting larger elements right until the proper slot is found.
          </div>
        </div>

      </aside>
    </main>

    <section style="display:flex;gap:var(--gap);flex-direction:column;">
      <div style="font-weight:700">Layout Description</div>
      <div class="small" style="color:var(--muted);max-width:1000px">
        Spatial organization: The page uses a two-column layout (visualization left, controls right). Safe area margins are 24px on all sides and at least 16px gap between controls. The visualization occupies the left column and presents the array as horizontally aligned bars with numeric labels below; controls are grouped to the right with clear buttons, sliders and a log. The design is responsive: on narrow screens the controls stack under the visualization. Focus states and adequate contrasts ensure accessibility.
      </div>
    </section>

    <footer class="note" aria-hidden="false">
      Tip: You can paste repeated or unsorted numbers. The system uses animated bar shifts to make the key's insertion visually explicit.
    </footer>
  </div>

  <script>
    /********************************************************************
     * Insertion Sort Interactive Module (Vanilla JS)
     *
     * Features:
     * - Visualizes array as movable bars with animated transforms
     * - Insertion sort generator yields fine-grained steps (select, compare/shift, insert)
     * - Controls: Randomize, Shuffle, Size, Apply custom array, Step, Play/Pause, Speed, Fast-forward, Reset
     * - Step-back using stored history snapshots
     * - Accessible labels and responsive layout
     *
     * Implementation notes:
     * - Each bar is an object {id, value}. The current array order is an array of these items.
     * - Sorting generator mutates a copy of the items; every yielded state contains a deep copy snapshot
     *   so the UI can step forward/back through history.
     ********************************************************************/

    (function(){
      // DOM elements
      const barsStage = document.getElementById('bars-stage');
      const arrayInput = document.getElementById('array-input');
      const sizeRange = document.getElementById('size-range');
      const btnRandom = document.getElementById('btn-randomize');
      const btnShuffle = document.getElementById('btn-shuffle');
      const btnApply = document.getElementById('btn-apply');
      const btnReset = document.getElementById('btn-reset');
      const btnStep = document.getElementById('btn-step');
      const btnStepBack = document.getElementById('btn-stepback');
      const btnPlay = document.getElementById('btn-play');
      const btnFast = document.getElementById('btn-fast');
      const btnStop = document.getElementById('btn-stop');
      const speedRange = document.getElementById('speed-range');
      const speedLabel = document.getElementById('speed-label');
      const logBox = document.getElementById('log');
      const statusText = document.getElementById('status-text');
      const statusDot = document.getElementById('status-dot');

      // State
      let items = []; // array of {id,value}
      let nextId = 1;
      let snapshots = []; // history of states
      let snapIndex = 0; // current displayed snapshot index
      let gen = null; // generator for insertion sort
      let playing = false;
      let playTimer = null;

      // Visual layout variables
      const gap = 12; // visual gap between bars in pixels (not CSS var)
      let barWidth = 56; // initial width, will be recalculated

      // Initialize with a random array
      function initRandom(size=8){
        const arr = [];
        for (let i=0;i<size;i++){
          arr.push(randInt(1, 99));
        }
        applyNewArray(arr);
      }

      function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

      function applyNewArray(values){
        // Reset generator and history
        nextId = 1;
        items = values.map(v => ({ id: nextId++, value: Number(v) }));
        buildInitialSnapshot();
        renderSnapshot(0);
        updateStatus('Ready');
      }

      function buildInitialSnapshot(){
        snapshots = [];
        const snap = makeSnapshot('init', {arr: cloneItems(items), i:null, j:null, keyId:null, desc:'Initial array'});
        snapshots.push(snap);
        snapIndex = 0;
        gen = null;
        playing = false;
        clearPlayTimer();
        updatePlayButton();
      }

      function cloneItems(arr){
        return arr.map(it => ({ id: it.id, value: it.value }));
      }

      function makeSnapshot(type, data){
        return {
          type: type,
          arr: cloneItems(data.arr),
          i: data.i,
          j: data.j,
          keyId: data.keyId,
          desc: data.desc || ''
        };
      }

      // Insertion sort generator yields snapshots describing steps
      function* insertionSortGen(initialItems){
        // Work on a copy of the item array (objects with id & value)
        let arr = cloneItems(initialItems);
        const n = arr.length;
        for (let i=1;i<n;i++){
          const key = arr[i];
          let j = i - 1;
          // Selected key
          yield makeSnapshot('select', { arr, i, j, keyId:key.id, desc:`Select key ${key.value} at index ${i}` });

          // Compare and shift
          while (j >= 0 && arr[j].value > key.value){
            // Shift arr[j] right to arr[j+1]
            arr[j+1] = arr[j];
            yield makeSnapshot('shift', { arr, i, j, keyId:key.id, desc:`Shift ${arr[j+1].value} right from index ${j} to ${j+1}` });
            j = j - 1;
            yield makeSnapshot('compare', { arr, i, j, keyId:key.id, desc: (j >= 0) ? `Compare key ${key.value} with ${arr[j].value} at index ${j}` : `Reached start of array` });
          }

          arr[j+1] = key;
          yield makeSnapshot('insert', { arr, i, j: j+1, keyId:key.id, desc:`Insert key ${key.value} at index ${j+1}` });
        }
        yield makeSnapshot('done', { arr, i:null, j:null, keyId:null, desc: 'Sorting complete' });
      }

      // Render a snapshot at index k from snapshots
      function renderSnapshot(k){
        if (k < 0) k = 0;
        if (k >= snapshots.length) k = snapshots.length - 1;
        snapIndex = k;
        const snap = snapshots[snapIndex];
        renderArray(snap.arr, snap);
        writeLog(snap.desc || '');
        updateStatusFromSnapshot(snap);
      }

      // Render items as bars; compute positions based on current order
      function renderArray(arr, snap=null){
        // Ensure bars exist for each item id; create as needed
        // We'll reuse DOM elements per item.id for smoother animations
        const existing = {};
        const children = Array.from(barsStage.children);
        children.forEach(ch => {
          existing[ch.dataset.id] = ch;
        });

        // Ensure barWidth computed from container
        computeBarWidth(arr.length);

        // Create any missing bars
        arr.forEach(it => {
          if (!existing[it.id]){
            const el = document.createElement('div');
            el.className = 'bar';
            el.setAttribute('role','listitem');
            el.setAttribute('aria-label',`Value ${it.value}`);
            el.dataset.id = it.id;
            el.innerHTML = `<div class="label">${it.value}</div><div class="idx">—</div>`;
            barsStage.appendChild(el);
            existing[it.id] = el;
            // set initial style
            el.style.width = barWidth + 'px';
            el.style.transform = 'translateX(0) translateY(0)';
            el.style.bottom = '44px';
          } else {
            // update label text
            const el = existing[it.id];
            el.querySelector('.label').textContent = it.value;
            el.style.width = barWidth + 'px';
          }
        });

        // Remove DOM elements not in current array
        Object.keys(existing).forEach(id => {
          if (!arr.some(it => String(it.id) === String(id))){
            const el = existing[id];
            if (el && el.parentNode) el.parentNode.removeChild(el);
            delete existing[id];
          }
        });

        // Position items based on index and animate transforms
        const containerRect = barsStage.getBoundingClientRect();
        const totalWidth = (arr.length * barWidth) + ((arr.length - 1) * gap);
        const startX = Math.max((containerRect.width - totalWidth) / 2, 8);

        arr.forEach((it, idx) => {
          const el = existing[it.id];
          const x = startX + idx * (barWidth + gap);
          el.style.left = x + 'px';
          // compute height relative to value; map values to 40..maxHeight
          const maxVal = Math.max(...arr.map(a => a.value), 1);
          const minVal = Math.min(...arr.map(a => a.value), 0);
          const scale = (it.value - minVal) / Math.max(1, (maxVal - minVal));
          const minH = 36;
          const maxH = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar-height-max')) || 220;
          const h = Math.round(minH + scale * (maxH - minH));
          el.style.height = h + 'px';
          // update numeric label and index label
          el.querySelector('.label').textContent = it.value;
          el.querySelector('.idx').textContent = idx;

          // reset classes
          el.classList.remove('sorted','key','compare');
        });

        // Apply role-based classes based on snapshot (sorted region, key, compare)
        if (snap){
          const type = snap.type;
          const sArr = snap.arr;
          // sorted region: indexes 0..i-1 are sorted (when i exists)
          if (Number.isInteger(snap.i) && snap.i > 0){
            for (let idx = 0; idx < snap.i; idx++){
              const it = sArr[idx];
              const el = barsStage.querySelector(`[data-id="${it.id}"]`);
              if (el) el.classList.add('sorted');
            }
          } else if (type === 'done'){
            // all sorted
            sArr.forEach(it => {
              const el = barsStage.querySelector(`[data-id="${it.id}"]`);
              if (el) el.classList.add('sorted');
            });
          }

          // key bar highlight
          if (snap.keyId != null){
            const keyEl = barsStage.querySelector(`[data-id="${snap.keyId}"]`);
            if (keyEl) keyEl.classList.add('key');
          }

          // compare: if j index provided and valid, highlight
          if (snap.j != null && snap.j >= 0 && snap.j < sArr.length){
            const cmpIt = sArr[snap.j];
            const cmpEl = barsStage.querySelector(`[data-id="${cmpIt.id}"]`);
            if (cmpEl) cmpEl.classList.add('compare');
          }
        }
      }

      function computeBarWidth(n){
        const containerWidth = barsStage.getBoundingClientRect().width || barsStage.clientWidth || 800;
        // desired gap 12; ensure min bar width 36 and max 72
        const totalGaps = (n - 1) * gap;
        const avail = Math.max(containerWidth - totalGaps - 20, n * 36);
        const w = Math.min(72, Math.floor(avail / n));
        barWidth = Math.max(36, w);
        // Update existing bars width
        Array.from(barsStage.children).forEach(ch => ch.style.width = barWidth + 'px');
      }

      // Logging and status updates
      function writeLog(text){
        logBox.textContent = text || '';
      }

      function updateStatus(text){
        statusText.textContent = text;
      }

      function updateStatusFromSnapshot(snap){
        if (!snap) { updateStatus('Ready'); return; }
        switch (snap.type){
          case 'init': updateStatus('Ready'); statusDot.style.background = getComputedStyle(document.documentElement).getPropertyValue('--accent'); break;
          case 'select': updateStatus('Selecting key'); statusDot.style.background = '#f59e0b'; break;
          case 'compare': updateStatus('Comparing'); statusDot.style.background = '#fb7185'; break;
          case 'shift': updateStatus('Shifting elements'); statusDot.style.background = '#fb7185'; break;
          case 'insert': updateStatus('Inserting key'); statusDot.style.background = getComputedStyle(document.documentElement).getPropertyValue('--success'); break;
          case 'done': updateStatus('Sorted'); statusDot.style.background = getComputedStyle(document.documentElement).getPropertyValue('--success'); break;
          default: updateStatus('Ready'); statusDot.style.background = getComputedStyle(document.documentElement).getPropertyValue('--accent'); break;
        }
      }

      // Step control logic
      function ensureGenerator(){
        if (!gen){
          gen = insertionSortGen(items);
        }
      }

      function stepForward(){
        // If we are not at the end of snapshots, just advance snapshot index
        if (snapIndex < snapshots.length - 1){
          renderSnapshot(snapIndex + 1);
          return;
        }
        // Otherwise, pull next from generator and append snapshot
        ensureGenerator();
        const result = gen.next();
        if (result.done){
          // nothing left
          return;
        } else {
          const snap = result.value;
          snapshots.push(snap);
          renderSnapshot(snapshots.length - 1);
        }
      }

      function stepBack(){
        if (snapIndex > 0){
          renderSnapshot(snapIndex - 1);
        }
      }

      function playToggle(){
        if (playing){
          stopPlaying();
        } else {
          startPlaying();
        }
      }

      function startPlaying(){
        ensureGenerator();
        playing = true;
        updatePlayButton();
        scheduleNextStep();
      }

      function scheduleNextStep(){
        clearPlayTimer();
        const speed = Number(speedRange.value) || 1;
        const baseDelay = 600; // ms per step at 1.0x
        const delay = Math.max(80, baseDelay / speed);
        playTimer = setTimeout(() => {
          // Advance one step
          const prevLength = snapshots.length;
          stepForward();
          // If new snapshot appended or advanced in history, schedule another
          if (snapIndex < snapshots.length - 1 || prevLength !== snapshots.length){
            scheduleNextStep();
          } else {
            // generator may be done; check if more available
            // try to peek generator
            if (gen){
              const res = gen.next();
              if (!res.done){
                snapshots.push(res.value);
                renderSnapshot(snapshots.length - 1);
                scheduleNextStep();
              } else {
                stopPlaying();
              }
            } else {
              stopPlaying();
            }
          }
        }, delay);
      }

      function stopPlaying(){
        playing = false;
        updatePlayButton();
        clearPlayTimer();
      }

      function clearPlayTimer(){
        if (playTimer){
          clearTimeout(playTimer);
          playTimer = null;
        }
      }

      function updatePlayButton(){
        btnPlay.textContent = playing ? 'Pause ❚❚' : 'Play ▶';
      }

      function fastForward(){
        ensureGenerator();
        // Exhaust generator quickly, appending snapshots
        let res;
        do {
          res = gen.next();
          if (!res.done){
            snapshots.push(res.value);
          }
        } while (!res.done);
        renderSnapshot(snapshots.length - 1);
        stopPlaying();
      }

      function resetToInitial(){
        clearPlayTimer();
        playing = false;
        gen = null;
        // Reduce snapshots to initial only (index 0)
        if (snapshots.length > 0){
          snapshots = [snapshots[0]];
        } else {
          buildInitialSnapshot();
        }
        renderSnapshot(0);
        updatePlayButton();
        updateStatus('Ready');
      }

      // Buttons and input handlers
      btnRandom.addEventListener('click', () => {
        const n = Number(sizeRange.value) || 8;
        const arr = [];
        for (let i=0;i<n;i++) arr.push(randInt(1,99));
        applyNewArray(arr);
      });

      btnShuffle.addEventListener('click', () => {
        // shuffle items array then reset snapshots
        for (let i = items.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [items[i], items[j]] = [items[j], items[i]];
        }
        buildInitialSnapshot();
        renderSnapshot(0);
      });

      btnApply.addEventListener('click', () => {
        const text = arrayInput.value.trim();
        if (!text) return;
        const parts = text.split(',').map(s => s.trim()).filter(s => s !== '');
        const nums = [];
        for (const p of parts){
          const num = Number(p);
          if (Number.isNaN(num)){
            alert('Please enter only numbers separated by commas.');
            return;
          }
          nums.push(num);
        }
        if (nums.length === 0) return;
        applyNewArray(nums);
      });

      btnReset.addEventListener('click', () => {
        initRandom(Number(sizeRange.value));
      });

      btnStep.addEventListener('click', () => {
        stopPlaying();
        stepForward();
      });

      btnStepBack.addEventListener('click', () => {
        stopPlaying();
        stepBack();
      });

      btnPlay.addEventListener('click', () => {
        playToggle();
      });

      btnFast.addEventListener('click', () => {
        stopPlaying();
        fastForward();
      });

      btnStop.addEventListener('click', () => {
        resetToInitial();
      });

      speedRange.addEventListener('input', () => {
        speedLabel.textContent = Number(speedRange.value).toFixed(2) + 'x';
      });

      sizeRange.addEventListener('input', () => {
        // Visual hint only. Do not auto-apply.
      });

      // Allow click on bars to edit value (small interactive feature)
      barsStage.addEventListener('click', (e) => {
        const bar = e.target.closest('.bar');
        if (!bar) return;
        const id = Number(bar.dataset.id);
        const item = items.find(it => it.id === id);
        if (!item) return;
        const newVal = prompt('Edit value for this element:', String(item.value));
        if (newVal === null) return;
        const num = Number(newVal);
        if (Number.isNaN(num)){
          alert('Please enter a number.');
          return;
        }
        item.value = num;
        buildInitialSnapshot();
        renderSnapshot(0);
      });

      // window resize: recompute positions
      window.addEventListener('resize', () => {
        renderSnapshot(snapIndex);
      });

      // Setup initial array
      initRandom(Number(sizeRange.value));

      // Accessibility: keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.key === ' ' && document.activeElement.tagName !== 'INPUT') {
          e.preventDefault();
          playToggle();
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          stepForward();
        } else if (e.key === 'ArrowLeft') {
          e.preventDefault();
          stepBack();
        }
      });

      // Expose nothing globally
    })();
  </script>
</body>
</html>