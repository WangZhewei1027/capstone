<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dijkstra's Algorithm — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --good: #10b981;
      --warn: #f59e0b;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#071023 0%, #07122a 60%);
      color:#e6eef8;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:var(--safe-margin);
      box-sizing:border-box;
    }
    *{box-sizing:inherit}
    a{color:var(--accent)}
    header{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-bottom:var(--gap);
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    .subtitle{
      color:var(--muted);
      font-size:13px;
      margin:0;
    }
    main{
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:var(--gap);
      align-items:start;
    }
    @media (max-width:980px){
      main{grid-template-columns:1fr}
    }

    /* left column contains description + canvas card */
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      min-height:120px;
    }
    .info{
      display:flex;
      flex-direction:column;
      gap:12px;
      margin-bottom:12px;
    }
    .row{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
    }

    /* Graph area */
    .canvas-wrap{
      position:relative;
      min-height:520px;
      border-radius:10px;
      overflow:hidden;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border:1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
    }
    svg{
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
      background-image:
        radial-gradient(rgba(255,255,255,0.01) 1px, transparent 1px);
      background-size:120px 120px;
    }
    .toolbar{
      display:flex;
      gap:12px;
      padding:12px;
      align-items:center;
      border-bottom:1px solid rgba(255,255,255,0.02);
      flex-wrap:wrap;
    }
    button, input[type=range], select{
      background:var(--glass);
      color:inherit;
      border:1px solid rgba(255,255,255,0.04);
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      cursor:pointer;
      min-height:40px;
    }
    button[aria-pressed="true"]{
      outline: 2px solid rgba(6,182,212,0.14);
      box-shadow:0 6px 18px rgba(6,182,212,0.06);
      border-color:rgba(6,182,212,0.22);
    }
    .small{
      padding:6px 8px;
      min-height:34px;
      font-size:13px;
    }
    .controls{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .panel{
      display:flex;
      flex-direction:column;
      gap:12px;
      margin-top:12px;
    }

    /* state panel on the right */
    .right{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .state-card{
      padding:12px;
      border-radius:10px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
    }
    .state-title{
      font-size:13px;
      margin:0 0 6px 0;
      color:var(--muted);
    }
    .dist-list{
      display:grid;
      gap:8px;
      max-height:220px;
      overflow:auto;
    }
    .dist-item{
      display:flex;
      justify-content:space-between;
      gap:12px;
      background:rgba(255,255,255,0.01);
      padding:8px;
      border-radius:8px;
      font-size:13px;
    }
    .queue{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .log{
      font-size:13px;
      color:var(--muted);
      max-height:180px;
      overflow:auto;
      padding:8px;
      border-radius:8px;
      background:rgba(255,255,255,0.01);
      border:1px dashed rgba(255,255,255,0.02);
    }

    /* Node & Edge styles (SVG classes) */
    .edge{
      stroke:#9fb3c8;
      stroke-width:3;
      opacity:0.85;
      transition:stroke 260ms, stroke-width 260ms, opacity 260ms;
      stroke-linecap:round;
    }
    .edge.highlight{
      stroke:var(--accent);
      stroke-width:5;
      opacity:1;
      filter:drop-shadow(0 6px 10px rgba(6,182,212,0.12));
    }
    .edge.improve{
      stroke:var(--good);
      stroke-width:5;
      filter:drop-shadow(0 6px 8px rgba(16,185,129,0.12));
    }
    .node{
      cursor:grab;
      transition:transform 140ms;
    }
    .node circle{
      fill:linear-gradient(#07142a,#0d2537);
      stroke:rgba(255,255,255,0.06);
      stroke-width:1.5px;
      transition:fill 180ms, stroke 180ms, r 180ms;
    }
    .node .label{
      font-size:12px;
      fill:#e6eef8;
      pointer-events:none;
    }
    .node .dist-badge{
      font-size:11px;
      fill:#071426;
      pointer-events:none;
    }
    .node.selected circle{
      stroke:rgba(6,182,212,0.9);
      stroke-width:2.6px;
      filter:drop-shadow(0 6px 14px rgba(6,182,212,0.12));
    }
    .node.visiting circle{
      stroke:var(--warn);
      stroke-width:2.4px;
      filter:drop-shadow(0 10px 26px rgba(245,158,11,0.12));
    }
    .node.visited circle{
      stroke:var(--good);
      stroke-width:2.8px;
      filter:drop-shadow(0 12px 26px rgba(16,185,129,0.12));
    }

    /* small helper styles */
    .muted-block{
      color:var(--muted);
      font-size:13px;
      background:rgba(255,255,255,0.01);
      padding:8px;
      border-radius:8px;
    }
    .hint{
      color:var(--muted);
      font-size:12px;
    }
    input[type=number]{
      width:80px;
      padding:6px 8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background:var(--glass);
      color:inherit;
    }

    footer{
      margin-top:var(--gap);
      color:var(--muted);
      font-size:13px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Interactive: Dijkstra's Algorithm</h1>
    <p class="subtitle">Explore shortest paths step-by-step with an editable weighted graph and animated relaxations.</p>
  </header>

  <main>
    <section>
      <div class="card info" aria-hidden="false">
        <div>
          <strong>Concept Title</strong>
          <div class="muted">Single-source shortest paths on non-negative weighted graphs (Dijkstra)</div>
        </div>
        <div>
          <strong>Learning Objective</strong>
          <div class="muted">After interacting with this module, you will be able to: build a small weighted graph, run Dijkstra's algorithm from a chosen source, observe the priority selection and edge relaxations, and trace the final shortest-path tree to any target node.</div>
        </div>
        <div>
          <strong>Interaction Design</strong>
          <div class="muted">
            Click "Add Node" then tap the canvas to place nodes. Use "Add Edge" then click two nodes to connect them with a positive weight (editable). Drag nodes to reposition. Set a source and target node using the dedicated buttons. Run the algorithm automatically or step through: the currently extracted node is highlighted, edges considered pulse, successful relaxations show distance updates and green highlights, and the priority queue is shown in real time. Controls include Play, Step, Pause, Reset, Clear, and Random Graph. Animations reinforce the algorithm's greedy choice and relaxation process.
          </div>
        </div>
        <div>
          <strong>Layout Description</strong>
          <div class="muted">
            Safe margin of 24px surrounds the viewport. The page uses a two-column responsive layout: the left column holds the interactive canvas and controls; the right column shows algorithm state (distance table, priority queue, log). Interactive elements have at least 16px spacing, clearly grouped controls at the top of the canvas, and accessible labels. The SVG canvas scales to the available area for responsive use on mobile and desktop.
          </div>
        </div>
      </div>

      <div class="card canvas-wrap" style="margin-top:var(--gap);">
        <div class="toolbar" role="toolbar" aria-label="Graph controls">
          <div class="controls">
            <button id="mode-add-node" aria-pressed="false" class="small">Add Node</button>
            <button id="mode-add-edge" aria-pressed="false" class="small">Add Edge</button>
            <button id="mode-move" aria-pressed="true" class="small">Move</button>
            <button id="set-source" class="small">Set Source</button>
            <button id="set-target" class="small">Set Target</button>
            <button id="delete-selected" class="small">Delete</button>
            <button id="random-graph" class="small">Random Graph</button>
          </div>
          <div style="flex:1"></div>
          <div class="controls">
            <button id="run" class="">Run</button>
            <button id="step" class="">Step</button>
            <button id="pause" class="">Pause</button>
            <button id="reset" class="">Reset</button>
          </div>
        </div>

        <svg id="svgCanvas" tabindex="0" aria-label="Graph canvas">
          <!-- SVG contents inserted by JS -->
        </svg>

        <div style="padding:12px; display:flex; gap:12px; align-items:center; border-top:1px solid rgba(255,255,255,0.02);">
          <label class="hint" style="min-width:90px">Animation speed</label>
          <input id="speed" type="range" min="0.1" max="2.5" step="0.1" value="1" aria-label="Animation speed">
          <div class="muted hint" id="speedVal">1.0x</div>
          <div style="flex:1"></div>
          <label class="hint">Weight:</label>
          <input id="defaultWeight" type="number" min="1" step="1" value="5" aria-label="Default weight for new edges">
          <div class="hint">Double-click an edge to edit its weight. Click a node then "Set Source/Target".</div>
        </div>
      </div>
    </section>

    <aside class="right" aria-live="polite">
      <div class="state-card">
        <h3 class="state-title">Distances (from source)</h3>
        <div id="distList" class="dist-list" role="list" aria-live="polite">
          <!-- populated by JS -->
        </div>
      </div>

      <div class="state-card">
        <h3 class="state-title">Priority queue</h3>
        <div id="queueView" class="queue" aria-live="polite">
          <!-- queue -->
        </div>
      </div>

      <div class="state-card">
        <h3 class="state-title">Algorithm log</h3>
        <div id="log" class="log" role="log" aria-live="polite"></div>
      </div>

      <div class="state-card">
        <h3 class="state-title">Controls / Tips</h3>
        <div class="muted-block">
          - Add nodes, then add edges (undirected).<br>
          - Edge weights must be positive.<br>
          - Use Step to progress one extraction (or neighbor relax).<br>
          - After Run completes, click any node and press "Set Target" then click "Show shortest path" in the log actions to visualize the path.
        </div>
      </div>
    </aside>
  </main>

  <footer>
    Tip: This module runs completely in your browser with no external libraries.
  </footer>

  <script>
    // Dijkstra Interactive Module (Vanilla JS)
    // Author: Interactive pedagogical module
    (function(){
      // Layout constraints
      const SAFE_MARGIN = 24;
      const MIN_GAP = 16;

      // DOM elements
      const svg = document.getElementById('svgCanvas');
      const modeAddNodeBtn = document.getElementById('mode-add-node');
      const modeAddEdgeBtn = document.getElementById('mode-add-edge');
      const modeMoveBtn = document.getElementById('mode-move');
      const setSourceBtn = document.getElementById('set-source');
      const setTargetBtn = document.getElementById('set-target');
      const deleteBtn = document.getElementById('delete-selected');
      const randomGraphBtn = document.getElementById('random-graph');

      const runBtn = document.getElementById('run');
      const stepBtn = document.getElementById('step');
      const pauseBtn = document.getElementById('pause');
      const resetBtn = document.getElementById('reset');

      const defaultWeightInput = document.getElementById('defaultWeight');
      const speedRange = document.getElementById('speed');
      const speedVal = document.getElementById('speedVal');

      const distList = document.getElementById('distList');
      const queueView = document.getElementById('queueView');
      const logEl = document.getElementById('log');

      // State
      let nodes = []; // {id, x, y}
      let edges = []; // {id, a, b, weight}
      let nodeCounter = 0;
      let edgeCounter = 0;
      let selected = { type: null, id: null }; // type: "node"|"edge"
      let mode = 'move'; // 'add-node'|'add-edge'|'move'
      let addEdgeFrom = null;

      // Algorithm state
      let sourceId = null;
      let targetId = null;
      let dists = {};   // id -> numeric (Infinity)
      let prev = {};    // id -> prevId
      let visited = new Set();
      let pq = []; // array of {id, dist}
      let algorithmRunning = false;
      let algorithmPaused = false;
      let algorithmStepMode = false;
      let algorithmTimer = null;
      let animationSpeed = 1.0;

      // SVG groups
      const gEdges = document.createElementNS('http://www.w3.org/2000/svg','g');
      const gNodes = document.createElementNS('http://www.w3.org/2000/svg','g');
      svg.appendChild(gEdges);
      svg.appendChild(gNodes);

      // Utility helpers
      function $(id){return document.getElementById(id);}
      function createSVG(tag, attrs={}){
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for(const [k,v] of Object.entries(attrs)){
          el.setAttribute(k,v);
        }
        return el;
      }
      function log(msg){
        const time = new Date().toLocaleTimeString();
        logEl.innerHTML = `<div style="margin-bottom:6px"><strong>[${time}]</strong> ${escapeHTML(msg)}</div>` + logEl.innerHTML;
      }
      function escapeHTML(s){ return (s+'').replace(/[&<>"']/g, c=>'&#'+c.charCodeAt(0)+';'); }

      // Mode buttons
      function setMode(m){
        mode = m;
        modeAddNodeBtn.setAttribute('aria-pressed', m==='add-node');
        modeAddEdgeBtn.setAttribute('aria-pressed', m==='add-edge');
        modeMoveBtn.setAttribute('aria-pressed', m==='move');
        svg.style.cursor = (m==='move') ? 'grab' : 'crosshair';
        addEdgeFrom = null;
        clearSelection();
      }

      modeAddNodeBtn.addEventListener('click', ()=> setMode('add-node'));
      modeAddEdgeBtn.addEventListener('click', ()=> setMode('add-edge'));
      modeMoveBtn.addEventListener('click', ()=> setMode('move'));

      // Node creation
      svg.addEventListener('pointerdown', (e)=>{
        const pt = svgPoint(e.clientX, e.clientY);
        if(mode === 'add-node'){
          addNode(pt.x, pt.y);
        }
      });

      // Add Node / Edge / Move interaction
      function addNode(x,y){
        const id = 'n'+(++nodeCounter);
        nodes.push({id, x, y});
        dists[id] = Infinity;
        prev[id] = null;
        render();
        log(`Added node ${id}`);
      }

      function addEdge(a,b,weight){
        if(a===b) return;
        // ensure no duplicate
        if(edges.some(e=> (e.a===a&&e.b===b) || (e.a===b&&e.b===a) )) {
          log('Edge already exists between '+a+' and '+b);
          return;
        }
        const id = 'e'+(++edgeCounter);
        edges.push({id,a,b,weight:Math.max(1,Number(weight)||1)});
        render();
        log(`Added edge ${id} ${a}<->${b} weight=${weight}`);
      }

      // Node and edge rendering
      function render(){
        // Clear groups
        while(gEdges.firstChild) gEdges.removeChild(gEdges.firstChild);
        while(gNodes.firstChild) gNodes.removeChild(gNodes.firstChild);

        // Draw edges first
        edges.forEach(e=>{
          const na = nodes.find(n=>n.id===e.a);
          const nb = nodes.find(n=>n.id===e.b);
          if(!na || !nb) return;
          const line = createSVG('line',{
            x1: na.x, y1: na.y, x2: nb.x, y2: nb.y,
            class: 'edge',
            'data-id': e.id,
            'stroke-linecap':'round'
          });
          // add dblclick to edit weight
          line.addEventListener('dblclick', (ev)=>{
            ev.stopPropagation();
            const val = prompt('Edge weight (positive number):', e.weight);
            if(val !== null){
              const num = Number(val);
              if(!isFinite(num) || num<=0){ alert('Please enter positive number'); }
              else { e.weight = num; render(); log(`Edge ${e.id} weight set to ${num}`); }
            }
          });
          // click selects edge
          line.addEventListener('click', (ev)=>{
            ev.stopPropagation();
            selectEdge(e.id);
          });

          // weight label
          const mx = (na.x+nb.x)/2;
          const my = (na.y+nb.y)/2;
          const labelBg = createSVG('rect',{
            x: mx-16, y: my-14, width:32, height:20, rx:8, ry:8,
            fill: 'rgba(7,20,36,0.9)',
            'pointer-events':'none'
          });
          const label = createSVG('text',{
            x: mx, y: my, 'text-anchor':'middle', 'alignment-baseline':'middle',
            class:'edge-label', 'pointer-events':'none', 'fill':'#e6eef8', 'font-size':12
          });
          label.textContent = e.weight;

          gEdges.appendChild(line);
          gEdges.appendChild(labelBg);
          gEdges.appendChild(label);
        });

        // Draw nodes on top
        nodes.forEach(n=>{
          const g = createSVG('g', {class:'node', 'data-id':n.id, tabindex:0});
          g.setAttribute('transform', `translate(${n.x},${n.y})`);
          // circle
          const circle = createSVG('circle', {r:18, cx:0, cy:0});
          // id label
          const label = createSVG('text', {x:0, y:-2, 'text-anchor':'middle', class:'label'});
          label.textContent = n.id;
          // distance badge
          const badge = createSVG('text', {x:0, y:28, 'text-anchor':'middle', class:'dist-badge'});
          const distText = (dists[n.id]===Infinity) ? '\u221E' : dists[n.id];
          badge.textContent = distText;

          g.appendChild(circle);
          g.appendChild(label);
          g.appendChild(badge);

          // events
          g.addEventListener('pointerdown', (ev)=>{
            ev.stopPropagation();
            selectNode(n.id);
            if(mode === 'add-edge'){
              if(!addEdgeFrom) { addEdgeFrom = n.id; g.classList.add('selected'); }
              else {
                const weight = Number(defaultWeightInput.value) || 1;
                addEdge(addEdgeFrom, n.id, weight);
                clearSelection();
                addEdgeFrom = null;
              }
            } else if(mode==='move'){
              startDragNode(n.id, ev);
            }
          });

          // keyboard support: Enter selects
          g.addEventListener('keydown', (ev)=>{
            if(ev.key==='Enter'){
              selectNode(n.id);
            }
          });

          // Visual classes based on algorithm state and selection
          g.classList.toggle('selected', selected.type==='node' && selected.id===n.id);
          g.classList.toggle('visiting', visited.has(n.id)===false && dists[n.id]===Infinity ? false : false);
          g.classList.toggle('visited', visited.has(n.id));
          gNodes.appendChild(g);
        });

        updateStateViews();
      }

      // Selection helpers
      function clearSelection(){
        selected = {type:null, id:null};
        document.querySelectorAll('.node').forEach(el=>el.classList.remove('selected'));
        document.querySelectorAll('.edge').forEach(el=>el.classList.remove('selected'));
      }
      function selectNode(id){
        selected = {type:'node', id};
        document.querySelectorAll('.node').forEach(el => el.classList.toggle('selected', el.getAttribute('data-id')===id));
        document.querySelectorAll('line.edge').forEach(el=>el.classList.remove('selected'));
      }
      function selectEdge(id){
        selected = {type:'edge', id};
        document.querySelectorAll('line.edge').forEach(el => el.classList.toggle('selected', el.getAttribute('data-id')===id));
        document.querySelectorAll('.node').forEach(el=>el.classList.remove('selected'));
      }

      // Node dragging
      let dragging = null;
      function startDragNode(id, ev){
        dragging = {id, startX:ev.clientX, startY:ev.clientY};
        svg.setPointerCapture(ev.pointerId);
        const onmove = (e)=> {
          if(!dragging) return;
          const dx = e.clientX - dragging.startX;
          const dy = e.clientY - dragging.startY;
          dragging.startX = e.clientX;
          dragging.startY = e.clientY;
          const node = nodes.find(n=>n.id===dragging.id);
          if(node){
            node.x += dx;
            node.y += dy;
            // clamp to inner area (respect margin)
            const rect = svg.getBoundingClientRect();
            const pad = 24;
            node.x = Math.max(pad, Math.min(rect.width-pad, node.x));
            node.y = Math.max(pad, Math.min(rect.height-pad, node.y));
            render();
          }
        };
        const onup = (e)=>{
          svg.releasePointerCapture(ev.pointerId);
          svg.removeEventListener('pointermove', onmove);
          svg.removeEventListener('pointerup', onup);
          dragging = null;
        };
        svg.addEventListener('pointermove', onmove);
        svg.addEventListener('pointerup', onup);
      }

      // Delete selected
      deleteBtn.addEventListener('click', ()=>{
        if(!selected.type) return;
        if(selected.type==='node'){
          // remove node and incident edges
          nodes = nodes.filter(n=>n.id!==selected.id);
          edges = edges.filter(e=> e.a!==selected.id && e.b!==selected.id);
          // cleanup algorithm state
          delete dists[selected.id];
          delete prev[selected.id];
          visited.delete(selected.id);
          if(sourceId===selected.id) sourceId=null;
          if(targetId===selected.id) targetId=null;
          log(`Deleted node ${selected.id}`);
          clearSelection();
          render();
        } else if(selected.type==='edge'){
          edges = edges.filter(e=>e.id!==selected.id);
          log(`Deleted edge ${selected.id}`);
          clearSelection();
          render();
        }
      });

      // Set source / target
      setSourceBtn.addEventListener('click', ()=>{
        if(selected.type!=='node') { alert('Select a node first.'); return; }
        sourceId = selected.id;
        resetAlgorithmState();
        log(`Source set to ${sourceId}`);
        render();
      });
      setTargetBtn.addEventListener('click', ()=>{
        if(selected.type!=='node') { alert('Select a node first.'); return; }
        targetId = selected.id;
        log(`Target set to ${targetId}`);
        render();
      });

      // Random graph
      randomGraphBtn.addEventListener('click', ()=>{
        // clear and create random nodes and edges
        clearAll();
        const w = svg.clientWidth, h = svg.clientHeight;
        const count = Math.max(4, Math.floor(Math.random()*4)+5);
        for(let i=0;i<count;i++){
          addNode(60 + Math.random()*(w-120), 60 + Math.random()*(h-120));
        }
        // connect with some edges
        const nodeIds = nodes.map(n=>n.id);
        for(let i=0;i<nodeIds.length;i++){
          for(let j=i+1;j<nodeIds.length;j++){
            if(Math.random()<0.28){
              addEdge(nodeIds[i], nodeIds[j], Math.floor(Math.random()*9)+1);
            }
          }
        }
        if(nodes.length>0){
          sourceId = nodes[0].id;
          log('Generated random graph. Source set to '+sourceId);
        }
        render();
      });

      // Clear / reset
      function clearAll(){
        nodes = []; edges = []; nodeCounter=0; edgeCounter=0;
        sourceId = null; targetId = null;
        dists = {}; prev={}; visited.clear();
        pq = []; selected={type:null,id:null};
        stopAlgorithm();
        render();
      }
      resetBtn.addEventListener('click', ()=>{
        resetAlgorithmState();
        log('Algorithm state reset (distances cleared)');
        render();
      });

      function resetAlgorithmState(){
        // reset dists and visited and prev but keep nodes & edges
        nodes.forEach(n=>{ dists[n.id]=Infinity; prev[n.id]=null; });
        visited = new Set();
        pq = [];
        algorithmRunning = false;
        algorithmPaused = false;
        stopAlgorithm();
      }

      // Algorithm controls
      runBtn.addEventListener('click', ()=>{
        if(algorithmRunning && !algorithmPaused) return;
        if(!sourceId){ alert('Set a source node first.'); return; }
        algorithmPaused = false;
        algorithmStepMode = false;
        startDijkstra();
      });
      stepBtn.addEventListener('click', ()=>{
        if(!sourceId){ alert('Set a source node first.'); return; }
        if(!algorithmRunning){
          // initialize then step one
          algorithmStepMode = true;
          startDijkstra();
        } else {
          algorithmPaused = true;
          performOneStep();
        }
      });
      pauseBtn.addEventListener('click', ()=>{
        algorithmPaused = true;
        log('Paused');
      });

      function startDijkstra(){
        if(algorithmRunning) { algorithmPaused = false; return; }
        algorithmRunning = true;
        algorithmPaused = false;
        // initialize distances
        nodes.forEach(n=>{ dists[n.id]=Infinity; prev[n.id]=null; });
        visited.clear();
        pq = [];
        dists[sourceId]=0;
        pushPQ(sourceId,0);
        log('Dijkstra started from '+sourceId);
        render();

        scheduleNext();
      }

      function stopAlgorithm(){
        algorithmRunning = false;
        algorithmPaused = false;
        if(algorithmTimer) { clearTimeout(algorithmTimer); algorithmTimer=null; }
      }

      function scheduleNext(delayFactor=1){
        if(algorithmPaused) return;
        const delay = 600 / animationSpeed * delayFactor;
        algorithmTimer = setTimeout(()=> {
          performOneStep();
        }, delay);
      }

      // Priority queue helpers (simple array)
      function pushPQ(id,dist){
        pq.push({id,dist});
        // keep pq sorted ascending
        pq.sort((a,b)=>a.dist-b.dist || a.id.localeCompare(b.id));
      }
      function popPQ(){
        if(pq.length===0) return null;
        return pq.shift();
      }

      function updateStateViews(){
        // distances
        distList.innerHTML = '';
        nodes.forEach(n=>{
          const di = dists[n.id];
          const div = document.createElement('div');
          div.className = 'dist-item';
          const left = document.createElement('div');
          left.textContent = n.id;
          left.style.fontWeight = (n.id===sourceId)? '700':'500';
          if(n.id===sourceId) left.style.color = 'var(--accent)';
          const right = document.createElement('div');
          right.textContent = (di===Infinity)? '∞' : di;
          if(visited.has(n.id)) right.style.color = 'var(--good)';
          div.appendChild(left); div.appendChild(right);
          distList.appendChild(div);
        });
        // PQ view
        queueView.innerHTML = '';
        pq.forEach(item=>{
          const d = document.createElement('div');
          d.className = 'muted';
          d.textContent = `${item.id} : ${item.dist}`;
          queueView.appendChild(d);
        });
      }

      // Main step: extract min and relax neighbors
      let currentProcessing = null; // {id, neighborsQueue}
      function performOneStep(){
        if(!algorithmRunning) return;
        if(algorithmPaused) return;
        if(!currentProcessing){
          // extract min
          while(pq.length>0 && visited.has(pq[0].id)) pq.shift();
          const top = popPQ();
          if(!top){
            // done
            algorithmRunning = false;
            log('Dijkstra complete');
            highlightFinalTree();
            return;
          }
          const u = top.id;
          if(visited.has(u)) {
            scheduleNext();
            return;
          }
          // mark visiting
          highlightNodeVisiting(u);
          log(`Extracted ${u} with dist=${top.dist}`);
          visited.add(u);
          // gather neighbors
          const neighbors = edges.filter(e=> e.a===u || e.b===u).map(e=>{
            const v = (e.a===u)? e.b : e.a;
            const w = e.weight;
            return {v,w,edgeId:e.id};
          });
          currentProcessing = {id:u, neighbors, idx:0};
          // schedule first neighbor processing quickly
          if(algorithmStepMode){ /* step mode: process only one neighbor and pause */ }
          scheduleNext(0.7);
          return;
        } else {
          // we have a current node being processed
          const proc = currentProcessing;
          if(proc.idx >= proc.neighbors.length){
            // finished neighbors, finalize node color
            finalizeNode(proc.id);
            currentProcessing = null;
            scheduleNext();
            return;
          }
          const nb = proc.neighbors[proc.idx++];
          // animate edge highlight and relaxation
          highlightEdge(nb.edgeId);
          const old = dists[nb.v];
          const alt = dists[proc.id] + nb.w;
          log(`Considering edge ${proc.id} -> ${nb.v} (w=${nb.w}), alt=${alt}`);
          if(alt < old){
            dists[nb.v] = alt;
            prev[nb.v] = proc.id;
            pushPQ(nb.v, alt);
            animateImprovement(nb.edgeId, nb.v, alt);
            log(`Relaxed ${nb.v}: updated dist ${alt} via ${proc.id}`);
          } else {
            // show failed relaxation
            animateNoImprove(nb.edgeId);
            log(`No improvement for ${nb.v} (current ${old})`);
          }
          updateStateViews();

          if(algorithmStepMode){
            algorithmPaused = true; // pause after one neighbor step
            return;
          }
          // continue processing neighbors after small delay
          scheduleNext();
          return;
        }
      }

      // Visual helpers for algorithm
      function highlightNodeVisiting(id){
        // add visiting class briefly
        document.querySelectorAll('.node').forEach(el=>{
          el.classList.toggle('visiting', el.getAttribute('data-id')===id);
        });
      }
      function finalizeNode(id){
        document.querySelectorAll('.node').forEach(el=>{
          el.classList.toggle('visiting', false);
          el.classList.toggle('visited', el.getAttribute('data-id')===id ? true : el.classList.contains('visited'));
        });
        // ensure visited set is reflected
        document.querySelectorAll('.node').forEach(el=>{
          el.classList.toggle('visited', visited.has(el.getAttribute('data-id')));
        });
      }
      function highlightEdge(edgeId){
        const line = gEdges.querySelector(`line[data-id="${edgeId}"]`);
        if(!line) return;
        line.classList.add('highlight');
        setTimeout(()=> line.classList.remove('highlight'), 700 / animationSpeed);
      }
      function animateImprovement(edgeId, nodeId, newDist){
        const line = gEdges.querySelector(`line[data-id="${edgeId}"]`);
        if(line) {
          line.classList.add('improve');
          setTimeout(()=> line.classList.remove('improve'), 900 / animationSpeed);
        }
        // update node badge flash
        const nodeEl = [...gNodes.children].find(g=>g.getAttribute('data-id')===nodeId);
        if(nodeEl){
          const badge = nodeEl.querySelector('.dist-badge');
          if(badge){
            const original = badge.textContent;
            badge.textContent = newDist;
            badge.style.transition = 'transform 220ms';
            badge.style.transform = 'scale(1.18)';
            setTimeout(()=>{ badge.style.transform='scale(1)'; }, 220);
          }
        }
      }
      function animateNoImprove(edgeId){
        const line = gEdges.querySelector(`line[data-id="${edgeId}"]`);
        if(line){
          line.style.opacity = 0.45;
          setTimeout(()=> line.style.opacity = 0.85, 450 / animationSpeed);
        }
      }

      function highlightFinalTree(){
        // color edges that are in prev[] tree
        edges.forEach(e=>{
          const child = (prev[e.a]===e.b) ? e.a : (prev[e.b]===e.a) ? e.b : null;
          const line = gEdges.querySelector(`line[data-id="${e.id}"]`);
          if(child && line){
            line.classList.add('improve');
            line.style.opacity = 1;
          }
        });
      }

      // Utility: convert client coords to svg coords
      function svgPoint(clientX, clientY){
        const rect = svg.getBoundingClientRect();
        return { x: clientX - rect.left, y: clientY - rect.top };
      }

      // Speed control
      speedRange.addEventListener('input', ()=>{
        animationSpeed = Number(speedRange.value) || 1;
        speedVal.textContent = animationSpeed.toFixed(1) + 'x';
      });

      // Clicking empty area clears selection and edge add preview
      svg.addEventListener('click', (ev)=>{
        if(mode === 'add-edge' && addEdgeFrom){
          // click on empty -> cancel
          addEdgeFrom = null;
          clearSelection();
          log('Edge creation canceled');
        } else {
          clearSelection();
        }
      });

      // On page load, create a small example
      function seedExample(){
        clearAll();
        const w = svg.clientWidth, h = svg.clientHeight;
        addNode(140,120);
        addNode(360,110);
        addNode(240,260);
        addNode(480,260);
        addEdge('n1','n2',4);
        addEdge('n1','n3',2);
        addEdge('n3','n2',1);
        addEdge('n2','n4',5);
        addEdge('n3','n4',8);
        sourceId = 'n1';
        render();
        log('Seed graph created. Source set to n1');
      }

      // Initialize
      setMode('move');
      speedVal.textContent = animationSpeed.toFixed(1) +'x';
      seedExample();

      // Expose a simple UI action: show shortest path from source to target via prev[]
      // Add an on-click action on log to show "Show shortest path" when target exists and finished
      log('Ready — build a graph, set source & target, then Run or Step.');
      // Provide context menu in log: clicking last "Dijkstra complete" will add link
      const observer = new MutationObserver(()=>{
        // if algorithm complete and target set, add quick path button
        if(!algorithmRunning && targetId && prev[targetId]){
          const p = document.createElement('div');
          p.innerHTML = `<button id="show-path" class="small">Show shortest path to ${targetId}</button>`;
          // insert at top of log container
          logEl.prepend(p);
          const btn = document.getElementById('show-path');
          if(btn){
            btn.addEventListener('click', ()=>{
              highlightPath(targetId);
            });
          }
        }
      });
      observer.observe(logEl, {childList:true});

      function highlightPath(destId){
        // clear previous highlights
        document.querySelectorAll('line.edge').forEach(l=> l.classList.remove('improve'));
        // trace back
        const path = [];
        let cur = destId;
        while(cur && prev[cur]){
          const p = prev[cur];
          const edge = edges.find(e=> (e.a===cur && e.b===p) || (e.b===cur && e.a===p));
          if(edge) path.push(edge.id);
          cur = p;
        }
        path.forEach(id=>{
          const line = gEdges.querySelector(`line[data-id="${id}"]`);
          if(line) line.classList.add('improve');
        });
        log('Highlighted shortest path to '+destId);
      }

      // Make sure the UI remains responsive on resize
      window.addEventListener('resize', ()=>{
        // keep nodes inside svg
        const rect = svg.getBoundingClientRect();
        nodes.forEach(n=>{
          n.x = Math.max(24, Math.min(rect.width-24, n.x));
          n.y = Math.max(24, Math.min(rect.height-24, n.y));
        });
        render();
      });

    })();
  </script>
</body>
</html>