<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Counting Sort — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1720;
      --card: #0b1220;
      --muted: #98a1b3;
      --accent: #4fd1c5;
      --accent-2: #7c5cff;
      --danger: #ff7b7b;
      --cell-w: 64px;
      --cell-h: 64px;
      --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071126 0%, #051827 100%);
      color: #e6eef6;
      font-family: var(--font-sans);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .app{
      padding: var(--safe-margin);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    header{
      display:flex;
      align-items:flex-start;
      gap:var(--gap);
      flex-wrap:wrap;
    }

    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }

    .subtitle{
      color:var(--muted);
      font-size:13px;
      margin-top:6px;
    }

    .top-row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      width:100%;
      justify-content:space-between;
    }

    main{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
      width:100%;
      flex-wrap:wrap;
    }

    /* Left: Controls */
    .controls{
      width:320px;
      min-width:240px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border:1px solid rgba(255,255,255,0.04);
      padding:16px;
      border-radius:8px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .controls h2{
      margin:0;
      font-size:14px;
      color:var(--accent);
    }

    .row{
      display:flex;
      gap:var(--gap);
      align-items:center;
    }

    label{
      font-size:13px;
      color:var(--muted);
    }

    input[type="text"], input[type="number"], select{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:inherit;
      padding:8px;
      border-radius:6px;
      outline:none;
      min-width:0;
    }

    input[type="number"]{
      width:84px;
    }

    button{
      background:linear-gradient(180deg,var(--accent), #32b4a8);
      color:#022;
      border:none;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
    }

    button.ghost{
      background:transparent;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      font-weight:600;
    }

    .controls .group{
      display:flex;
      gap:var(--gap);
      flex-direction:column;
    }

    .small{
      font-size:13px;
      color:var(--muted);
    }

    .control-row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }

    .btn-row{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
    }

    /* Right: Visual area */
    .visual{
      flex:1;
      min-width:320px;
      background:linear-gradient(180deg,#081123 0%, rgba(255,255,255,0.01) 100%);
      padding:16px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .arrays{
      display:flex;
      gap:var(--gap);
      flex-direction:column;
      align-items:stretch;
    }

    .array-row{
      display:flex;
      align-items:center;
      gap:12px;
    }

    .array-label{
      width:92px;
      color:var(--muted);
      font-size:13px;
    }

    .strip{
      display:flex;
      gap:12px;
      align-items:center;
      padding:8px;
      min-height:84px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      border-radius:8px;
      flex-wrap:wrap;
      position:relative;
      overflow:visible;
    }

    .cell{
      width:var(--cell-w);
      height:var(--cell-h);
      background:linear-gradient(180deg,#072033, #04202b);
      border:1px solid rgba(255,255,255,0.04);
      border-radius:8px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      color:var(--muted);
      font-weight:700;
      font-size:14px;
      position:relative;
      box-sizing:border-box;
      transition:transform 260ms ease, box-shadow 200ms ease;
      min-width:var(--cell-w);
    }

    .cell .label{
      position:absolute;
      top:6px;
      left:8px;
      font-size:11px;
      color:var(--muted);
      font-weight:600;
    }

    .cell.value{
      font-size:18px;
      color: #f2fbff;
    }

    .cell.highlight{
      box-shadow:0 8px 30px rgba(124,92,255,0.16);
      transform:translateY(-6px);
    }

    .cell.count{
      background:linear-gradient(180deg,#06262e,#06333c);
      color:var(--accent);
    }

    .cell.output{
      background:linear-gradient(180deg,#062022,#053037);
      color:#dff7f3;
    }

    .bar{
      height:6px;
      background:var(--accent);
      border-radius:6px;
      width:20%;
      transition:width 360ms ease;
      margin-top:6px;
    }

    .controls .note{
      font-size:13px;
      color:var(--muted);
    }

    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      font-size:13px;
      color:var(--muted);
      flex-wrap:wrap;
    }

    .legend .key{
      display:flex;
      gap:8px;
      align-items:center;
    }

    .chip{
      width:14px;
      height:14px;
      border-radius:3px;
      background:var(--accent-2);
      box-shadow:0 2px 8px rgba(124,92,255,0.14);
    }

    /* Floating clone for animation */
    .float-clone{
      position:fixed;
      z-index: 9999;
      pointer-events:none;
      transition: transform 420ms cubic-bezier(.21,.97,.28,1), opacity 250ms ease;
      will-change:transform, opacity;
    }

    /* Footer info sections */
    .info{
      display:flex;
      gap:var(--gap);
      flex-direction:column;
      color:var(--muted);
      font-size:13px;
    }

    pre{
      margin:0;
      background:rgba(255,255,255,0.02);
      padding:12px;
      border-radius:6px;
      overflow:auto;
      color:#bfe;
      font-size:12px;
    }

    footer{
      color:var(--muted);
      font-size:12px;
      margin-top:8px;
    }

    .controls .toggle{
      display:flex;
      gap:8px;
      align-items:center;
    }

    @media (max-width:920px){
      .controls{width:100%;}
      .visual{width:100%;}
      main{flex-direction:column;}
    }

    /* Accessibility focus */
    button:focus, input:focus{
      outline: 3px solid rgba(127, 90, 255, 0.18);
      outline-offset:2px;
    }

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Counting sort interactive module">
    <header>
      <div style="flex:1">
        <h1>Counting Sort — Stable, Linear-Time Sort for Small Integers</h1>
        <div class="subtitle">Visual, step-by-step exploration of counting sort (stable variant).</div>
      </div>
      <div style="display:flex;gap:12px;align-items:center;">
        <div class="legend" aria-hidden="true">
          <div class="key"><div class="chip" style="background:linear-gradient(180deg,#7c5cff,#4fd1c5)"></div> Items (value + original index)</div>
          <div class="key"><div class="chip" style="background:var(--accent)"></div> Counts / frequencies</div>
        </div>
      </div>
    </header>

    <main>
      <section class="controls" aria-labelledby="controls-title">
        <h2 id="controls-title">Controls & Inputs</h2>

        <div class="group">
          <label class="small">Array values (comma-separated)</label>
          <input id="arrayInput" type="text" aria-label="Array values" value="4,1,3,4,2,1,3">
          <div class="small">You can edit values and press Update. Values must be non-negative integers.</div>
        </div>

        <div class="control-row">
          <div style="display:flex;gap:8px;align-items:center;">
            <label class="small" for="maxValue">Max value (k)</label>
            <input id="maxValue" type="number" min="0" value="5" aria-label="Maximum value for counts">
          </div>
          <div style="display:flex;gap:8px;align-items:center;">
            <button id="updateBtn">Update</button>
            <button id="randomBtn" class="ghost">Random</button>
          </div>
        </div>

        <div class="control-row">
          <label class="small" for="stableToggle">Stable placement</label>
          <div class="toggle" style="margin-left:auto">
            <input id="stableToggle" type="checkbox" checked aria-label="Toggle stability">
            <label for="stableToggle" class="small" style="margin:0">Stable (right→left)</label>
          </div>
        </div>

        <div class="group">
          <label class="small">Execution</label>
          <div class="btn-row">
            <button id="backBtn" class="ghost" title="Step back (not all steps reversible)">Back</button>
            <button id="stepBtn">Step</button>
            <button id="playBtn" class="ghost">Play</button>
            <button id="resetBtn" class="ghost">Reset</button>
          </div>
          <div class="control-row">
            <label class="small">Speed</label>
            <input id="speed" type="range" min="100" max="1200" value="600" step="50" aria-label="Animation speed">
            <div class="small" id="speedLabel">600 ms</div>
          </div>
        </div>

        <div class="group">
          <label class="small">Quick add (value)</label>
          <div style="display:flex;gap:8px">
            <input id="quickVal" type="number" min="0" value="2" aria-label="Quick add value">
            <button id="addBtn" class="ghost">Add</button>
          </div>
        </div>

        <div class="info">
          <div><strong>Learning objective:</strong> After interacting you should understand how counting sort builds a frequency array, transforms it into cumulative counts, and places items into the output (stable when placing right-to-left).</div>
          <div class="small">Shortcuts: Space = Step, Enter = Play/Pause.</div>
        </div>
      </section>

      <section class="visual" aria-live="polite">
        <div class="arrays">

          <div class="array-row" aria-hidden="false">
            <div class="array-label">Input</div>
            <div id="inputStrip" class="strip" aria-label="Input array"></div>
          </div>

          <div class="array-row">
            <div class="array-label">Counts</div>
            <div id="countsStrip" class="strip" aria-label="Counts array"></div>
          </div>

          <div class="array-row">
            <div class="array-label">Cumulative</div>
            <div id="cumStrip" class="strip" aria-label="Cumulative counts"></div>
          </div>

          <div class="array-row">
            <div class="array-label">Output</div>
            <div id="outputStrip" class="strip" aria-label="Output array"></div>
          </div>

        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;gap:var(--gap);margin-top:8px;">
          <div class="small">Step: <span id="stepCounter">0</span></div>
          <div class="small">Current phase: <span id="phaseLabel">idle</span></div>
        </div>

        <div style="margin-top:12px;">
          <h3 style="margin:0;font-size:14px;color:var(--accent);">How it works (live)</h3>
          <div class="small" style="margin-top:8px;color:var(--muted);line-height:1.5">
            1) Count frequencies of each integer (counts array).<br>
            2) Transform counts into cumulative counts (prefix sums).<br>
            3) Place elements into output using cumulative counts (stable if traversed right-to-left).
          </div>
        </div>
      </section>
    </main>

    <section style="display:flex;gap:var(--gap);flex-direction:column;">
      <div style="display:flex;gap:var(--gap);flex-wrap:wrap;">
        <div style="flex:1;min-width:320px;background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;">
          <strong>Interaction Design</strong>
          <div class="small" style="margin-top:8px;color:var(--muted)">
            - Edit the input array or add values with Quick add. Press Update to reload.<br>
            - Click Step to advance one atomic operation (count increment, cumulative update, or placement).<br>
            - Play animates steps automatically; speed slider controls animation delay.<br>
            - Toggle Stable to switch placement order (stable = right-to-left traversal).<br>
            - Visual feedback: cells highlight when accessed, counts animate width to reflect frequency, and items fly into output slots to show placement.
          </div>
        </div>

        <div style="flex:1;min-width:320px;background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;">
          <strong>Layout Description</strong>
          <div class="small" style="margin-top:8px;color:var(--muted)">
            - Safe margins: 24px on all sides. Controls column (left) is fixed-width; visual area expands.<br>
            - Minimum spacing between interactive elements is 16px. Arrays are stacked vertically for clear flow: Input → Counts → Cumulative → Output.<br>
            - Accessibility: controls and strips are keyboard-focusable; colors have sufficient contrast; aria-live provides updates.
          </div>
        </div>
      </div>
      <footer>Self-contained demo • Vanilla HTML/CSS/JS • No external libraries</footer>
    </section>
  </div>

  <script>
    // Counting Sort Interactive Module
    (function(){
      // Elements
      const arrayInput = document.getElementById('arrayInput');
      const maxValueInput = document.getElementById('maxValue');
      const updateBtn = document.getElementById('updateBtn');
      const randomBtn = document.getElementById('randomBtn');
      const inputStrip = document.getElementById('inputStrip');
      const countsStrip = document.getElementById('countsStrip');
      const cumStrip = document.getElementById('cumStrip');
      const outputStrip = document.getElementById('outputStrip');
      const stepBtn = document.getElementById('stepBtn');
      const playBtn = document.getElementById('playBtn');
      const resetBtn = document.getElementById('resetBtn');
      const backBtn = document.getElementById('backBtn');
      const speedRange = document.getElementById('speed');
      const speedLabel = document.getElementById('speedLabel');
      const addBtn = document.getElementById('addBtn');
      const quickVal = document.getElementById('quickVal');
      const stableToggle = document.getElementById('stableToggle');
      const stepCounter = document.getElementById('stepCounter');
      const phaseLabel = document.getElementById('phaseLabel');

      // State
      let items = []; // {value, id}
      let counts = [];
      let cumulative = [];
      let output = [];
      let k = 5;
      let playing = false;
      let timer = null;
      let speed = parseInt(speedRange.value,10);
      let stepIndex = 0;
      let phase = 'idle'; // 'count','cumulative','place','done'
      let history = []; // snapshots for back (simple restore)
      let stable = true;

      // Util
      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
      function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
      function uid(){ return Math.random().toString(36).slice(2,9); }

      // Render helpers
      function clearStrip(strip){
        while(strip.firstChild) strip.removeChild(strip.firstChild);
      }

      function createItemCell(item){
        const div = document.createElement('div');
        div.className = 'cell';
        div.tabIndex = 0;
        div.setAttribute('role','group');
        div.setAttribute('aria-label', `value ${item.value}, original index ${item.id}`);
        const lbl = document.createElement('div');
        lbl.className = 'label';
        lbl.textContent = `#${item.id}`;
        const val = document.createElement('div');
        val.className = 'value';
        val.textContent = item.value;
        div.appendChild(lbl);
        div.appendChild(val);
        return div;
      }

      function createCountCell(index, cnt){
        const div = document.createElement('div');
        div.className = 'cell count';
        div.setAttribute('data-index', index);
        const lbl = document.createElement('div');
        lbl.className = 'label';
        lbl.textContent = index;
        const val = document.createElement('div');
        val.className = 'value';
        val.textContent = cnt;
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.width = (Math.min(cnt,10)/Math.max(1,10))*100 + '%';
        div.appendChild(lbl);
        div.appendChild(val);
        div.appendChild(bar);
        return div;
      }

      function createOutputCell(slot){
        const div = document.createElement('div');
        div.className = 'cell output';
        div.setAttribute('data-slot', slot);
        const lbl = document.createElement('div');
        lbl.className = 'label';
        lbl.textContent = slot;
        const val = document.createElement('div');
        val.className = 'value';
        val.textContent = '';
        div.appendChild(lbl);
        div.appendChild(val);
        return div;
      }

      function renderAll(){
        clearStrip(inputStrip);
        clearStrip(countsStrip);
        clearStrip(cumStrip);
        clearStrip(outputStrip);

        // Input
        items.forEach(it=>{
          const node = createItemCell(it);
          inputStrip.appendChild(node);
        });

        // Counts
        counts.forEach((c,i)=>{
          const node = createCountCell(i,c);
          countsStrip.appendChild(node);
        });

        // Cumulative
        cumulative.forEach((c,i)=>{
          const div = document.createElement('div');
          div.className = 'cell';
          div.setAttribute('data-index', i);
          const lbl = document.createElement('div');
          lbl.className = 'label';
          lbl.textContent = i;
          const val = document.createElement('div');
          val.className = 'value';
          val.textContent = c;
          div.appendChild(lbl);
          div.appendChild(val);
          cumStrip.appendChild(div);
        });

        // Output grid
        for(let i=0;i<items.length;i++){
          const cell = createOutputCell(i);
          const val = cell.querySelector('.value');
          if(output[i]){
            val.textContent = output[i].value + ' #' + output[i].id;
          }
          outputStrip.appendChild(cell);
        }

        stepCounter.textContent = stepIndex;
        phaseLabel.textContent = phase;
      }

      // Parse input text into items
      function parseInputText(txt){
        const parts = txt.split(',').map(s=>s.trim()).filter(s=>s.length>0);
        const vals = [];
        for(const p of parts){
          const v = Number(p);
          if(Number.isFinite(v) && Number.isInteger(v) && v>=0){
            vals.push(v);
          } else {
            // ignore invalid
          }
        }
        return vals;
      }

      // Initialize state
      function initFromInput(){
        const vals = parseInputText(arrayInput.value);
        k = clamp(parseInt(maxValueInput.value||'0',10), 0, 100);
        // Ensure k is at least max value in array
        const maxInVals = vals.length ? Math.max(...vals) : 0;
        if(maxInVals > k){
          k = maxInVals;
          maxValueInput.value = k;
        }
        items = vals.map((v,i)=>({value:v, id:i}));
        counts = new Array(k+1).fill(0);
        cumulative = new Array(k+1).fill(0);
        output = new Array(items.length).fill(null);
        stepIndex = 0;
        phase = 'count';
        history = [];
        saveSnapshot();
        renderAll();
      }

      // Save snapshot for approximate back (restores arrays)
      function saveSnapshot(){
        history.push({
          items: JSON.parse(JSON.stringify(items)),
          counts: counts.slice(),
          cumulative: cumulative.slice(),
          output: output.map(x=> x ? JSON.parse(JSON.stringify(x)) : null),
          stepIndex,
          phase
        });
        if(history.length>200) history.shift();
      }

      // Random generator
      function randomize(){
        const n = clamp(randInt(4,12),4,20);
        const maxv = clamp(parseInt(maxValueInput.value||'5',10), 0, 30);
        const vals = [];
        for(let i=0;i<n;i++) vals.push(randInt(0, Math.max(1,maxv)));
        arrayInput.value = vals.join(',');
        initFromInput();
      }

      // Animations
      function highlightCell(strip, idx, ms=500){
        const node = strip.children[idx];
        if(!node) return;
        node.classList.add('highlight');
        setTimeout(()=>node.classList.remove('highlight'), ms);
      }

      // Floating clone animation (from element -> target element)
      function animateMove(fromEl, toEl, onEnd){
        const rectFrom = fromEl.getBoundingClientRect();
        const rectTo = toEl.getBoundingClientRect();
        const clone = fromEl.cloneNode(true);
        clone.classList.add('float-clone');
        clone.style.left = rectFrom.left + 'px';
        clone.style.top = rectFrom.top + 'px';
        clone.style.width = rectFrom.width + 'px';
        clone.style.height = rectFrom.height + 'px';
        clone.style.opacity = '1';
        clone.style.transform = 'translate(0px,0px)';
        document.body.appendChild(clone);
        // Force reflow
        getComputedStyle(clone).transform;
        const dx = rectTo.left - rectFrom.left;
        const dy = rectTo.top - rectFrom.top;
        // apply transform
        clone.style.transform = `translate(${dx}px, ${dy}px) scale(1)`;
        clone.style.transitionDuration = Math.max(200, speed) + 'ms';
        clone.style.opacity = '1';
        setTimeout(()=>{
          clone.style.opacity = '0';
        }, Math.max(180, speed - 100));
        setTimeout(()=>{
          if(clone && clone.parentNode) clone.parentNode.removeChild(clone);
          if(typeof onEnd === 'function') onEnd();
        }, Math.max(220, speed+50));
      }

      // Phases and step engine
      function stepOnce(){
        saveSnapshot();
        if(phase === 'count'){
          // Find first input not counted yet by comparing sum(counts) and items processed
          const processed = counts.reduce((a,b)=>a+b,0);
          if(processed < items.length){
            const i = processed; // process input index i
            const itm = items[i];
            // highlight input
            highlightCell(inputStrip, i, speed);
            // increment count
            counts[itm.value] = (counts[itm.value]||0) + 1;
            // update UI
            renderAll();
            stepIndex++;
            return;
          } else {
            // move to cumulative
            phase = 'cumulative';
            stepIndex++;
            renderAll();
            return;
          }
        } else if(phase === 'cumulative'){
          // compute prefix sums one by one
          // find first index where cumulative not set or not equal
          let idx = cumulative.findIndex((v,i)=> v !== (i===0 ? counts[0] : cumulative[i-1] + counts[i]));
          if(idx === -1){
            // all computed
            phase = 'place';
            stepIndex++;
            renderAll();
            return;
          } else {
            // compute upto idx
            if(idx === 0){
              cumulative[0] = counts[0];
            } else {
              cumulative[idx] = cumulative[idx-1] + counts[idx];
            }
            // animate counts->cum cell
            const from = countsStrip.children[idx];
            const to = cumStrip.children[idx];
            if(from && to){
              highlightCell(countsStrip, idx, speed);
              highlightCell(cumStrip, idx, speed);
            }
            renderAll();
            stepIndex++;
            return;
          }
        } else if(phase === 'place'){
          // place items into output based on cumulative (stable: traverse right->left)
          const n = items.length;
          // Find next input index to place:
          let i;
          if(stable){
            // place from right to left: first unplaced highest index
            // We can track number placed by sum(output non-null)
            const placed = output.filter(Boolean).length;
            if(placed >= n){
              phase = 'done';
              stepIndex++;
              renderAll();
              return;
            }
            // find next input index to process: the largest index that isn't placed yet
            // We'll process input index = lastUnplacedIndex
            for(i = n-1; i >=0; i--){
              // we decide placement based on whether this item already appears in output by id
              const already = output.some(o => o && o.id === items[i].id);
              if(!already) break;
            }
            if(i<0){
              phase = 'done';
              stepIndex++;
              renderAll();
              return;
            }
          } else {
            // unstable: left-to-right
            for(i = 0; i < n; i++){
              const already = output.some(o => o && o.id === items[i].id);
              if(!already) break;
            }
            if(i>=n){
              phase = 'done';
              stepIndex++;
              renderAll();
              return;
            }
          }

          const itm = items[i];
          const val = itm.value;
          // Determine target index: cumulative[val] - 1 (then decrement)
          const targetIndex = (cumulative[val] !== undefined ? cumulative[val] - 1 : counts[val]-1);
          // Visuals: highlight input cell and counts cell
          highlightCell(inputStrip, i, speed);
          const cidx = val;
          highlightCell(countsStrip, cidx, speed);
          // animate move
          const inputNode = inputStrip.children[i];
          const outputNode = outputStrip.children[targetIndex];
          // decrement cumulative and counts accordingly
          cumulative[val] = (cumulative[val] || 0) - 1;
          counts[val] = Math.max(0, (counts[val] || 0) - 1);
          // animate move and then store item
          animateMove(inputNode, outputNode, ()=>{
            output[targetIndex] = itm;
            renderAll();
          });
          stepIndex++;
          return;
        } else {
          // done or idle
          phase = 'done';
          renderAll();
          return;
        }
      }

      function startPlaying(){
        playing = true;
        playBtn.textContent = 'Pause';
        function loop(){
          if(!playing) return;
          stepOnce();
          if(phase === 'done'){ playing=false; playBtn.textContent='Play'; return; }
          timer = setTimeout(loop, speed + 80);
        }
        loop();
      }

      function stopPlaying(){
        playing = false;
        playBtn.textContent = 'Play';
        if(timer){ clearTimeout(timer); timer = null; }
      }

      // Event handlers
      updateBtn.addEventListener('click', ()=>{
        initFromInput();
      });

      randomBtn.addEventListener('click', ()=>{
        randomize();
      });

      stepBtn.addEventListener('click', ()=>{
        if(playing){ stopPlaying(); }
        stepOnce();
      });

      playBtn.addEventListener('click', ()=>{
        stable = stableToggle.checked;
        if(playing){ stopPlaying(); }
        else startPlaying();
      });

      resetBtn.addEventListener('click', ()=>{
        stopPlaying();
        initFromInput();
      });

      backBtn.addEventListener('click', ()=>{
        if(history.length>1){
          // pop current
          history.pop();
          const snap = history.pop();
          if(snap){
            items = snap.items;
            counts = snap.counts;
            cumulative = snap.cumulative;
            output = snap.output;
            stepIndex = snap.stepIndex;
            phase = snap.phase;
            renderAll();
            saveSnapshot();
          }
        }
      });

      speedRange.addEventListener('input', ()=>{
        speed = parseInt(speedRange.value,10);
        speedLabel.textContent = speed + ' ms';
      });

      addBtn.addEventListener('click', ()=>{
        const v = clamp(parseInt(quickVal.value||'0',10),0,1000);
        // append to array and re-init preserving existing placed items (simple approach: just reinit)
        const arr = parseInputText(arrayInput.value);
        arr.push(v);
        arrayInput.value = arr.join(',');
        initFromInput();
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if(e.code === 'Space'){
          e.preventDefault();
          stepBtn.click();
        } else if(e.key === 'Enter'){
          playBtn.click();
        }
      });

      // Initial setup
      initFromInput();
      // expose stable toggle effect immediately
      stableToggle.addEventListener('change', ev=>{
        stable = ev.target.checked;
      });

      // ensure responsive cell width based on container size
      function adjustCellWidth(){
        const cells = document.querySelectorAll('.cell');
        // keep consistent cell size via CSS variable or default
      }
      window.addEventListener('resize', adjustCellWidth);

    })();
  </script>
</body>
</html>