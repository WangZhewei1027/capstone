<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Singly Linked List — Interactive Module</title>
  <style>
    /* Safe area margin */
    :root {
      --safe-padding: 24px;
      --gap: 16px;
      --node-w: 120px;
      --node-h: 64px;
      --accent: #0b73ff;
      --muted: #6b7280;
    }
    html,body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: #f7fafc;
      color: #111827;
    }
    .app {
      box-sizing: border-box;
      padding: var(--safe-padding);
      min-height: 100%;
      display: grid;
      grid-template-columns: 360px 1fr;
      grid-gap: var(--gap);
    }

    /* Responsive stack */
    @media (max-width: 900px) {
      .app {
        grid-template-columns: 1fr;
      }
    }

    /* Left controls */
    .panel {
      background: white;
      border-radius: 10px;
      padding: 18px;
      box-shadow: 0 6px 18px rgba(11, 12, 16, 0.06);
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      min-width: 0;
    }
    .title {
      font-size: 18px;
      font-weight: 700;
      display: flex;
      align-items: baseline;
      gap: 8px;
    }
    .subtitle {
      color: var(--muted);
      font-size: 13px;
    }

    .controls-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    label {
      display: block;
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="text"], input[type="number"], select {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #e6e9ef;
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
    }
    .row {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    button {
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      background: var(--accent);
      color: white;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(11, 115, 255, 0.12);
    }
    button.ghost {
      background: #eef2ff;
      color: var(--accent);
      box-shadow: none;
    }
    button.warn {
      background: #ef4444;
      box-shadow: 0 2px 8px rgba(239,68,68,0.12);
    }
    .small {
      padding: 6px 8px;
      font-size: 13px;
      border-radius: 6px;
    }

    /* Right visualization */
    .viewer {
      background: linear-gradient(180deg, #ffffff 0%, #fbfdff 100%);
      border-radius: 10px;
      padding: 18px;
      position: relative;
      min-height: 420px;
      box-shadow: 0 6px 18px rgba(11, 12, 16, 0.04);
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }
    .canvas {
      position: relative;
      background: linear-gradient(90deg, rgba(11,115,255,0.02), rgba(11,115,255,0.0));
      border-radius: 8px;
      padding: 18px;
      min-height: 260px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: auto;
    }
    .nodes-row {
      display: flex;
      align-items: center;
      gap: var(--gap);
      padding: 12px;
      transition: height 0.2s ease;
    }

    /* Node style */
    .node {
      width: var(--node-w);
      min-width: var(--node-w);
      height: var(--node-h);
      background: linear-gradient(180deg, #ffffff, #fbfdff);
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      box-shadow: 0 6px 14px rgba(14, 16, 20, 0.04);
      display: flex;
      font-size: 13px;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      box-sizing: border-box;
      position: relative;
      transition: transform 320ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease;
      cursor: grab;
    }
    .node:active { cursor: grabbing; }
    .node .value {
      font-weight: 700;
      color: #0f172a;
      display:block;
      width: 56%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .node .next-handle {
      width: 34%;
      text-align: center;
      color: var(--muted);
      font-size: 12px;
      user-select: none;
    }
    .node.current {
      outline: 3px solid rgba(11,115,255,0.12);
      transform: translateY(-8px) scale(1.02);
    }
    .node.inserted {
      animation: popIn 340ms ease;
    }
    @keyframes popIn {
      from { transform: scale(.85); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    .node.deleted {
      animation: fadeOut 260ms forwards;
    }
    @keyframes fadeOut {
      to { opacity: 0; transform: scale(.9); }
    }

    /* HEAD label */
    .head-badge {
      position: absolute;
      top: 12px;
      left: 26px;
      background: linear-gradient(180deg,#0b73ff,#0a62d4);
      color: white;
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 6px 18px rgba(11,115,255,0.12);
    }

    /* Animated pointer */
    .pointer {
      position: absolute;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: linear-gradient(180deg,#34d399,#10b981);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 700;
      font-size: 12px;
      transform: translate(-50%,-50%);
      transition: transform 480ms cubic-bezier(.2,.9,.2,1);
      box-shadow: 0 8px 20px rgba(16,185,129,0.14);
      pointer-events: none;
    }

    /* svg overlay for arrows */
    .svg-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: visible;
    }
    .arrow {
      stroke: #9ca3af;
      stroke-width: 2.5;
      fill: none;
      marker-end: url(#arrowhead);
      transition: stroke 200ms ease;
    }

    /* small helper text */
    .hint {
      color: var(--muted);
      font-size: 13px;
    }

    /* footer status */
    .status {
      font-size: 13px;
      color: var(--muted);
    }

    /* small layout for traversal controls */
    .controls-row {
      display:flex;
      gap: 8px;
      align-items:center;
    }
    input[type="range"] { width: 150px; }

    /* accessibility focus */
    button:focus, input:focus {
      outline: 3px solid rgba(11,115,255,0.12);
      outline-offset: 2px;
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Singly Linked List interactive module">
    <!-- Controls -->
    <section class="panel" aria-label="Controls">
      <div>
        <div class="title">Singly Linked List</div>
        <div class="subtitle">Visualize nodes, pointers, insertion, deletion, reordering, and traversal.</div>
      </div>

      <div class="controls-group" aria-live="polite">
        <!-- Add Node -->
        <div>
          <label for="valueInput">Value</label>
          <div class="row">
            <input type="text" id="valueInput" placeholder="e.g., 42" aria-label="Node value" />
            <button id="addHeadBtn" class="small" title="Add to head">Add Head</button>
            <button id="addTailBtn" class="small ghost" title="Add to tail">Add Tail</button>
          </div>
          <div class="hint" style="margin-top:8px;">Tip: Use Add Head/Tail to build the list. Drag nodes to reorder.</div>
        </div>

        <!-- Insert after index -->
        <div>
          <label>Insert after index (0-based)</label>
          <div class="row">
            <input type="number" id="insertIndex" min="0" value="0" aria-label="Insert index" />
            <input type="text" id="insertValue" placeholder="value" aria-label="Insert value" />
            <button id="insertAfterBtn" class="small">Insert After</button>
          </div>
        </div>

        <!-- Delete -->
        <div>
          <label>Delete by index (0-based)</label>
          <div class="row">
            <input type="number" id="deleteIndex" min="0" value="0" aria-label="Delete index" />
            <button id="deleteBtn" class="small warn">Delete</button>
            <button id="clearBtn" class="small ghost">Clear</button>
          </div>
        </div>

        <!-- Traversal -->
        <div>
          <label>Traversal</label>
          <div class="controls-row">
            <button id="playBtn" title="Play traversal">Play</button>
            <button id="stepBtn" class="ghost" title="Step one node">Step</button>
            <button id="pauseBtn" class="ghost" title="Pause">Pause</button>
            <div style="display:flex;align-items:center;gap:8px;margin-left:8px;">
              <label for="speed" class="hint">Speed</label>
              <input type="range" id="speed" min="0.2" max="1.8" step="0.1" value="1">
            </div>
          </div>
          <div class="hint" style="margin-top:6px;">Pointer animates along nodes. Use Step to go one-by-one.</div>
        </div>
      </div>

      <div style="margin-top:8px;">
        <div class="status" id="status">List is empty</div>
      </div>
    </section>

    <!-- Visualization -->
    <section class="viewer" aria-label="Linked list visualization">
      <div class="head-badge" id="headBadge" style="display:none;">HEAD</div>

      <div class="canvas" id="canvas" tabindex="0" aria-label="Linked list canvas">
        <svg class="svg-overlay" id="svgOverlay" aria-hidden="true"></svg>
        <div class="nodes-row" id="nodesRow" aria-live="polite"></div>
        <div class="pointer" id="pointer" style="display:none;">P</div>
      </div>

      <div class="hint" id="explain">Nodes show Value and a Next area. Arrows indicate next pointers.</div>
    </section>
  </div>

  <script>
    // Linked List Interactive Module (Singly linked list visualization)
    (function(){
      // Model: simple array represents node sequence; 'next pointer' is implied by array order.
      let nodes = []; // each: {id: number, value: string}
      let idCounter = 1;

      // traversal state
      let currentIndex = -1;
      let traversalTimer = null;
      let traversalSpeed = 1.0; // multiplier

      // drag state
      let dragIndex = null;

      // DOM refs
      const nodesRow = document.getElementById('nodesRow');
      const svgOverlay = document.getElementById('svgOverlay');
      const headBadge = document.getElementById('headBadge');
      const pointerEl = document.getElementById('pointer');
      const statusEl = document.getElementById('status');

      // Controls
      const valueInput = document.getElementById('valueInput');
      const addHeadBtn = document.getElementById('addHeadBtn');
      const addTailBtn = document.getElementById('addTailBtn');
      const insertIndexInput = document.getElementById('insertIndex');
      const insertValueInput = document.getElementById('insertValue');
      const insertAfterBtn = document.getElementById('insertAfterBtn');
      const deleteIndexInput = document.getElementById('deleteIndex');
      const deleteBtn = document.getElementById('deleteBtn');
      const clearBtn = document.getElementById('clearBtn');
      const playBtn = document.getElementById('playBtn');
      const stepBtn = document.getElementById('stepBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const speedInput = document.getElementById('speed');

      // helper: update status text
      function updateStatus() {
        if (nodes.length === 0) {
          statusEl.textContent = 'List is empty';
        } else {
          statusEl.textContent = 'Size: ' + nodes.length + '  — Head value: ' + nodes[0].value;
        }
      }

      // Render nodes and arrows
      function render(animate = true) {
        // Clear existing children
        nodesRow.innerHTML = '';
        // Reset svg overlay size
        svgOverlay.innerHTML = '';

        // Create nodes DOM
        nodes.forEach((node, idx) => {
          const d = document.createElement('div');
          d.className = 'node';
          d.draggable = true;
          d.dataset.index = idx;
          d.dataset.id = node.id;
          d.setAttribute('role','article');
          d.setAttribute('aria-label', 'Node ' + idx + ' value ' + node.value);
          // content
          d.innerHTML = '<div class="value" title="' + escapeHtml(String(node.value)) + '">' + escapeHtml(String(node.value)) + '</div>'
                      + '<div class="next-handle">next</div>';

          // event: drag
          d.addEventListener('dragstart', (e) => {
            dragIndex = Number(d.dataset.index);
            e.dataTransfer.effectAllowed = 'move';
            // small drag image for clarity (invisible)
            const crt = d.cloneNode(true);
            crt.style.position = 'absolute';
            crt.style.top = '-9999px';
            document.body.appendChild(crt);
            e.dataTransfer.setDragImage(crt, 10, 10);
            setTimeout(()=>document.body.removeChild(crt), 0);
          });
          d.addEventListener('dragend', () => {
            dragIndex = null;
          });

          // Allow keyboard focus and actions
          d.tabIndex = 0;
          d.addEventListener('keydown', (e) => {
            // Enter key to step to this node
            if (e.key === 'Enter') {
              stopTraversal();
              highlightNode(idx);
              movePointerToNode(idx);
            }
          });

          // allow drop on each node to insert before
          d.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            d.style.outline = '2px dashed rgba(11,115,255,0.18)';
          });
          d.addEventListener('dragleave', () => {
            d.style.outline = '';
          });
          d.addEventListener('drop', (e) => {
            e.preventDefault();
            d.style.outline = '';
            const targetIndex = Number(d.dataset.index);
            if (dragIndex === null || dragIndex === targetIndex) return;
            // reorder: move dragged to before targetIndex
            const item = nodes.splice(dragIndex, 1)[0];
            const insertAt = (dragIndex < targetIndex) ? targetIndex : targetIndex;
            nodes.splice(insertAt, 0, item);
            render();
            stopTraversal();
          });

          // Append
          nodesRow.appendChild(d);
        });

        // Head badge show/hide
        if (nodes.length > 0) {
          headBadge.style.display = 'inline-flex';
          // position head badge relative to canvas left
          const rowRect = nodesRow.getBoundingClientRect();
          const canvasRect = document.getElementById('canvas').getBoundingClientRect();
          // place near the first node's left
          const first = nodesRow.children[0];
          if (first) {
            const firstRect = first.getBoundingClientRect();
            headBadge.style.top = (firstRect.top - canvasRect.top - 36) + 'px';
            headBadge.style.left = (firstRect.left - canvasRect.left + 6) + 'px';
          } else {
            headBadge.style.display = 'none';
          }
        } else {
          headBadge.style.display = 'none';
          pointerEl.style.display = 'none';
          currentIndex = -1;
        }

        // Animate and then draw arrows (use requestAnimationFrame to let layout settle)
        requestAnimationFrame(() => drawArrows());

        updateStatus();
      }

      // Draw arrows between consecutive nodes using SVG cubic curves
      function drawArrows() {
        const canvas = document.getElementById('canvas');
        const rect = canvas.getBoundingClientRect();
        svgOverlay.innerHTML = '';
        if (nodesRow.children.length <= 1) return;

        // ensure marker definition
        const defs = createSVGElement('defs');
        const marker = createSVGElement('marker');
        marker.setAttribute('id','arrowhead');
        marker.setAttribute('markerWidth','10');
        marker.setAttribute('markerHeight','10');
        marker.setAttribute('refX','8');
        marker.setAttribute('refY','3');
        marker.setAttribute('orient','auto');
        const path = createSVGElement('path');
        path.setAttribute('d','M0,0 L6,3 L0,6 z');
        path.setAttribute('fill','#9ca3af');
        marker.appendChild(path);
        defs.appendChild(marker);
        svgOverlay.appendChild(defs);

        // For each pair i -> i+1 draw path
        for (let i = 0; i < nodesRow.children.length - 1; i++) {
          const left = nodesRow.children[i];
          const right = nodesRow.children[i+1];
          const leftRect = left.getBoundingClientRect();
          const rightRect = right.getBoundingClientRect();
          const startX = leftRect.right - rect.left - 8;
          const startY = leftRect.top + leftRect.height/2 - rect.top;
          const endX = rightRect.left - rect.left + 8;
          const endY = rightRect.top + rightRect.height/2 - rect.top;

          // create smooth curved path
          const midX = (startX + endX) / 2;
          const pathStr = `M ${startX} ${startY} C ${midX} ${startY} ${midX} ${endY} ${endX} ${endY}`;
          const p = createSVGElement('path');
          p.setAttribute('d', pathStr);
          p.classList.add('arrow');
          p.setAttribute('marker-end','url(#arrowhead)');
          svgOverlay.appendChild(p);
        }
      }

      function createSVGElement(tag) {
        return document.createElementNS('http://www.w3.org/2000/svg', tag);
      }

      // Helper to move animated pointer to node at index
      function movePointerToNode(index) {
        if (index < 0 || index >= nodesRow.children.length) {
          pointerEl.style.display = 'none';
          return;
        }
        const nodeEl = nodesRow.children[index];
        const canvasRect = document.getElementById('canvas').getBoundingClientRect();
        const nodeRect = nodeEl.getBoundingClientRect();
        const cx = nodeRect.left + nodeRect.width/2 - canvasRect.left;
        const cy = nodeRect.top + nodeRect.height/2 - canvasRect.top - 20; // slightly above
        pointerEl.style.display = 'flex';
        pointerEl.style.transform = `translate(${cx}px, ${cy}px) translate(-50%,-50%)`;
        // update aria
        pointerEl.setAttribute('aria-hidden','false');
      }

      // highlight node: add class current
      function highlightNode(index) {
        Array.from(nodesRow.children).forEach((child, idx) => {
          if (idx === index) child.classList.add('current');
          else child.classList.remove('current');
        });
      }

      // traversal control
      function startTraversal() {
        if (nodes.length === 0) return;
        stopTraversal();
        if (currentIndex < 0) currentIndex = 0;
        highlightNode(currentIndex);
        movePointerToNode(currentIndex);
        traversalTimer = setInterval(() => {
          currentIndex++;
          if (currentIndex >= nodes.length) {
            stopTraversal();
            return;
          }
          highlightNode(currentIndex);
          movePointerToNode(currentIndex);
        }, 700 / traversalSpeed);
      }
      function stopTraversal() {
        if (traversalTimer) {
          clearInterval(traversalTimer);
          traversalTimer = null;
        }
      }
      function stepTraversal() {
        if (nodes.length === 0) return;
        stopTraversal();
        if (currentIndex < nodes.length - 1) {
          currentIndex++;
        } else {
          currentIndex = 0;
        }
        highlightNode(currentIndex);
        movePointerToNode(currentIndex);
      }

      // CRUD operations
      function addNodeAtHead(value) {
        if (!value) return;
        nodes.unshift({ id: idCounter++, value: value });
        currentIndex = 0;
        render();
        // mark inserted
        markInserted(0);
      }
      function addNodeAtTail(value) {
        if (!value) return;
        nodes.push({ id: idCounter++, value: value });
        render();
        markInserted(nodes.length - 1);
      }
      function insertAfter(index, value) {
        if (!value) return;
        if (index < 0 || index >= nodes.length) {
          alert('Invalid index to insert after.');
          return;
        }
        nodes.splice(index+1, 0, { id: idCounter++, value: value });
        render();
        markInserted(index+1);
      }
      function deleteAt(index) {
        if (nodes.length === 0) return;
        if (index < 0 || index >= nodes.length) {
          alert('Invalid index to delete.');
          return;
        }
        // animate deletion
        const nodeEl = nodesRow.children[index];
        if (nodeEl) {
          nodeEl.classList.add('deleted');
        }
        setTimeout(() => {
          nodes.splice(index, 1);
          if (currentIndex >= nodes.length) currentIndex = nodes.length - 1;
          render();
        }, 260);
      }
      function clearAll() {
        nodes = [];
        currentIndex = -1;
        render();
      }

      // minor helpers
      function markInserted(index) {
        const el = nodesRow.children[index];
        if (!el) return;
        el.classList.add('inserted');
        setTimeout(()=> el.classList.remove('inserted'), 600);
      }
      function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
      }

      // Wire up controls
      addHeadBtn.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (!v) { valueInput.focus(); return; }
        addNodeAtHead(v);
        valueInput.value = '';
        stopTraversal();
      });
      addTailBtn.addEventListener('click', () => {
        const v = valueInput.value.trim();
        if (!v) { valueInput.focus(); return; }
        addNodeAtTail(v);
        valueInput.value = '';
        stopTraversal();
      });
      insertAfterBtn.addEventListener('click', () => {
        const v = insertValueInput.value.trim();
        const idx = parseInt(insertIndexInput.value, 10);
        if (isNaN(idx)) { insertIndexInput.focus(); return; }
        insertAfter(idx, v);
        insertValueInput.value = '';
        stopTraversal();
      });
      deleteBtn.addEventListener('click', () => {
        const idx = parseInt(deleteIndexInput.value, 10);
        if (isNaN(idx)) { deleteIndexInput.focus(); return; }
        deleteAt(idx);
        stopTraversal();
      });
      clearBtn.addEventListener('click', () => {
        if (!confirm('Clear the entire list?')) return;
        clearAll();
        stopTraversal();
      });

      playBtn.addEventListener('click', () => {
        startTraversal();
      });
      pauseBtn.addEventListener('click', () => {
        stopTraversal();
      });
      stepBtn.addEventListener('click', () => {
        stepTraversal();
      });
      speedInput.addEventListener('input', (e) => {
        traversalSpeed = Number(e.target.value) || 1;
        // if running, restart with new speed
        if (traversalTimer) {
          startTraversal();
        }
      });

      // canvas resize/scroll handling: update arrows & head/pointer positions
      const canvas = document.getElementById('canvas');
      let resizeObserver = new ResizeObserver(() => {
        render();
      });
      resizeObserver.observe(canvas);
      window.addEventListener('scroll', () => {
        drawArrows();
        if (currentIndex >= 0) movePointerToNode(currentIndex);
      }, {passive:true});
      window.addEventListener('resize', () => {
        drawArrows();
        if (currentIndex >= 0) movePointerToNode(currentIndex);
      });

      // initial demo nodes
      function seedDemo() {
        nodes = [
          { id: idCounter++, value: 'A' },
          { id: idCounter++, value: 'B' },
          { id: idCounter++, value: 'C' }
        ];
        currentIndex = -1;
        render();
      }

      seedDemo();

      // Expose for console experimentation (optional)
      window._linkedListModule = {
        get nodes() { return nodes; },
        addHead: addNodeAtHead,
        addTail: addNodeAtTail,
        insertAfter: insertAfter,
        deleteAt: deleteAt,
        clear: clearAll,
        render: render
      };

    })();
  </script>
</body>
</html>