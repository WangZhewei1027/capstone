<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Heap Sort — Interactive Module</title>
  <style>
    /* ===== Safe area and basic layout ===== */
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --accent: #0b6efd;
      --accent-2: #0b9d6f;
      --bg: #fbfbfd;
      --muted: #667085;
      --danger: #ef4444;
      --success: #10b981;
      --node-size: 44px;
    }

    html,body{
      height:100%;
      margin:0;
      padding:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#ffffff 0%, #fbfbff 100%);
      color:#0f172a;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height:100%;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
    }

    /* Header */
    header {
      display:flex;
      gap: var(--gap);
      align-items: center;
      justify-content: space-between;
      flex-wrap:wrap;
    }

    .title-block {
      min-width:0;
    }

    h1 {
      margin:0;
      font-size:20px;
      font-weight:600;
      letter-spacing:-0.2px;
    }
    p.lead {
      margin:4px 0 0 0;
      color:var(--muted);
      font-size:13px;
    }

    /* Main area layout: controls + visualization + notes */
    .main {
      display:flex;
      gap: var(--gap);
      align-items:flex-start;
      width:100%;
    }

    /* Left column: controls and meta */
    .controls {
      width:320px;
      min-width:240px;
      background:linear-gradient(180deg,#ffffff,#fbfdff);
      border:1px solid #eef2ff;
      border-radius:10px;
      padding:16px;
      box-sizing:border-box;
      flex-shrink:0;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .controls h2 {
      margin:0;
      font-size:14px;
    }

    label {
      font-size:13px;
      color:var(--muted);
      display:block;
      margin-bottom:6px;
    }

    .row {
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }

    input[type="text"], .array-input {
      width:100%;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid #e6eef9;
      background:#fff;
      outline:none;
      box-sizing:border-box;
      font-size:13px;
      color:#0f172a;
    }

    .small {
      font-size:13px;
      color:#0f172a;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid #e6eef9;
      background:#fff;
    }

    .controls .buttons {
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
    }

    button {
      padding:8px 12px;
      border-radius:8px;
      border:1px solid rgba(2,6,23,0.08);
      background:#fff;
      color:#0f172a;
      cursor:pointer;
      font-size:13px;
      min-height:40px;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    button.primary {
      background:linear-gradient(180deg,var(--accent),#0a58d1);
      color:#fff;
      border:none;
      box-shadow: 0 4px 10px rgba(11,110,253,0.12);
    }
    button.ghost {
      background:transparent;
      border:1px dashed #dde8ff;
    }
    button:disabled {
      opacity:0.5;
      cursor:not-allowed;
    }

    .control-row {
      display:flex;
      gap:12px;
      align-items:center;
    }

    .note {
      font-size:13px;
      color:var(--muted);
    }

    /* Visualization area */
    .viz {
      background:linear-gradient(180deg,#ffffff,#fbfdff);
      flex:1;
      padding:16px;
      border-radius:10px;
      border:1px solid #eef2ff;
      min-height:480px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .viz-top {
      display:flex;
      gap:16px;
      align-items:center;
      justify-content:space-between;
    }

    .view-toggle {
      display:flex;
      gap:8px;
      align-items:center;
    }

    .view-toggle button {
      padding:8px 10px;
      font-size:13px;
    }

    .canvas {
      position:relative;
      flex:1;
      min-height:360px;
      border-radius:8px;
      background:linear-gradient(180deg,#ffffff,#fbfeff);
      border:1px solid #eef7ff;
      padding:12px;
      box-sizing:border-box;
    }

    /* Array bars */
    .array-row {
      display:flex;
      gap:8px;
      align-items:flex-end;
      justify-content:center;
      height:120px;
      margin-top:12px;
      width:100%;
    }
    .bar {
      width:28px;
      background:linear-gradient(180deg,#dbeafe,#bfdbfe);
      border-radius:6px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:#0b1220;
      font-weight:600;
      transition:transform 400ms cubic-bezier(.2,.9,.2,1), background 200ms;
      box-shadow: 0 2px 6px rgba(11,37,91,0.06);
      position:relative;
      height:48px;
    }
    .bar .val {
      font-size:13px;
      padding:6px 6px 8px 6px;
      color:#073163;
    }
    .bar.comparing {
      background:linear-gradient(180deg,#fff7cc,#ffe6a3);
      transform:translateY(-12px) scale(1.05);
    }
    .bar.swapping {
      background:linear-gradient(180deg,#ffdcdc,#ffb3b3);
      transform:translateY(-18px) scale(1.06);
    }
    .bar.sorted {
      background:linear-gradient(180deg,#dcfce7,#bbf7d0);
      color:#065f46;
    }

    /* Heap nodes - absolute positioned */
    .heap-layer {
      position:absolute;
      left:0; right:0; top:8px;
      height:220px;
      pointer-events:none;
    }
    .node {
      width:var(--node-size);
      height:var(--node-size);
      border-radius:50%;
      background:linear-gradient(180deg,#f0f9ff,#dbeefe);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:600;
      color:#06316a;
      position:absolute;
      transform:translate(-50%,-50%);
      transition:transform 400ms cubic-bezier(.2,.9,.2,1), background 250ms;
      box-shadow: 0 6px 14px rgba(9,30,66,0.06);
      pointer-events:auto;
    }
    .node.index {
      font-size:12px;
      opacity:0.7;
      position:absolute;
      bottom:-16px;
      left:50%;
      transform:translateX(-50%);
      width:max-content;
    }
    .node.comparing {
      background:linear-gradient(180deg,#fff7cc,#ffe6a3);
      transform:translate(-50%,-50%) scale(1.06);
    }
    .node.swapping {
      background:linear-gradient(180deg,#ffdcdc,#ffb3b3);
      transform:translate(-50%,-50%) scale(1.08);
    }
    svg.connectors {
      position:absolute;
      left:0; top:0;
      width:100%;
      height:100%;
      pointer-events:none;
      overflow:visible;
    }

    /* Right column: step/log */
    .steps {
      width:300px;
      min-width:220px;
      max-width:360px;
      background:linear-gradient(180deg,#ffffff,#fbfdff);
      border:1px solid #eef2ff;
      border-radius:10px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .steps h3 {
      margin:0;
      font-size:14px;
    }
    .log {
      max-height:420px;
      overflow:auto;
      font-size:13px;
      color:var(--muted);
      padding-right:6px;
    }
    .log .entry {
      padding:8px;
      border-radius:8px;
      margin-bottom:8px;
      background:#fff;
      border:1px solid #eef6ff;
      font-size:13px;
    }
    .footer-note {
      font-size:12px;
      color:var(--muted);
    }

    /* Responsive */
    @media (max-width:1000px){
      .main { flex-direction:column; }
      .controls, .steps { width:100%; }
      .viz { order:2; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Heap Sort interactive module">
    <header>
      <div class="title-block">
        <h1>Heap Sort — Build & Extract (Max-Heap)</h1>
        <p class="lead">Visual, step-by-step exploration of Heap Sort (max-heap). See heap as array or tree, animate comparisons and swaps.</p>
      </div>
      <div style="min-width:260px; text-align:right;">
        <div style="font-size:13px; color:var(--muted)">Safe area: 24px margin • Spacing >= 16px • Vanilla HTML/CSS/JS</div>
      </div>
    </header>

    <main class="main">
      <!-- Controls / Inputs -->
      <section class="controls" aria-labelledby="controls-title">
        <h2 id="controls-title">Interaction & Controls</h2>

        <div>
          <label for="sizeRange">Array size (5–15)</label>
          <input id="sizeRange" type="range" min="5" max="15" value="9" class="small" />
        </div>

        <div>
          <label for="arrayInput">Custom array (comma separated)</label>
          <input id="arrayInput" class="array-input" type="text" placeholder="e.g. 6,3,9,1,4" aria-label="Custom array input" />
          <div style="display:flex; gap:12px; margin-top:8px;">
            <button id="applyArray">Apply</button>
            <button id="randomize" class="ghost">Random</button>
          </div>
        </div>

        <div>
          <label>Controls</label>
          <div class="buttons">
            <button id="stepBack" aria-label="Step backward">⟲ Step Back</button>
            <button id="stepForward" aria-label="Step forward">Step ⟳</button>
            <button id="playPause" class="primary" aria-pressed="false">Play ▶</button>
            <button id="reset">Reset</button>
          </div>
        </div>

        <div>
          <label>Actions</label>
          <div class="row">
            <button id="buildHeap">Build Max-Heap</button>
            <button id="runSort" class="primary">Run Heap Sort</button>
          </div>
        </div>

        <div>
          <label for="speed">Animation speed</label>
          <input id="speed" type="range" min="0.4" max="2.0" step="0.1" value="1" class="small" />
          <div class="note">Lower = faster. Speed affects animations and auto-play interval.</div>
        </div>

        <div>
          <label>View</label>
          <div class="view-toggle" role="tablist" aria-label="View toggle">
            <button id="viewArray" class="small" aria-pressed="true">Array</button>
            <button id="viewTree" class="small" aria-pressed="false">Tree</button>
            <label style="margin-left:auto; font-size:13px; color:var(--muted);">
              <input type="checkbox" id="showIndices" checked /> show indices
            </label>
          </div>
        </div>

        <div>
          <label>Notes</label>
          <div class="note">
            This module demonstrates:
            <ul style="margin:6px 0 0 18px;">
              <li>Building the max-heap (sift-down from last parent).</li>
              <li>Repeatedly swapping root with end and re-heapifying.</li>
            </ul>
          </div>
        </div>

      </section>

      <!-- Visualization -->
      <section class="viz" aria-labelledby="viz-title">
        <div class="viz-top">
          <div>
            <strong id="viz-title">Visualization</strong>
            <div style="font-size:13px; color:var(--muted); margin-top:4px;">Toggle between array bars and heap tree. Hover nodes to inspect.</div>
          </div>
          <div style="display:flex; gap:12px; align-items:center;">
            <div class="note">Action:</div>
            <div id="currentAction" class="note">idle</div>
          </div>
        </div>

        <div class="canvas" id="canvas" role="region" aria-label="Heap visualization">
          <!-- SVG connectors -->
          <svg class="connectors" id="connectors" aria-hidden="true"></svg>

          <!-- Heap layer (absolute positioned nodes) -->
          <div class="heap-layer" id="heapLayer" aria-hidden="false"></div>

          <!-- Array bars (flex) -->
          <div class="array-row" id="arrayRow" aria-hidden="false"></div>

          <!-- Legend / small help -->
          <div style="position:absolute; right:12px; bottom:12px; background:#fff; border-radius:8px; padding:8px; border:1px solid #eef6ff; font-size:12px;">
            <div style="display:flex; gap:8px; align-items:center;">
              <div style="width:12px; height:12px; background:#fff7cc; border-radius:3px; border:1px solid #ffe6a3"></div> comparing
            </div>
            <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
              <div style="width:12px; height:12px; background:#ffdcdc; border-radius:3px; border:1px solid #ffb3b3"></div> swapping
            </div>
          </div>
        </div>
      </section>

      <!-- Steps / Log -->
      <aside class="steps" aria-labelledby="steps-title">
        <h3 id="steps-title">Action Log & Steps</h3>
        <div class="log" id="log" aria-live="polite"></div>
        <div class="footer-note">You can step forward/back to see each compare/swap. Play animates through complete Heap Sort.</div>
      </aside>
    </main>
  </div>

  <script>
    /*
      Heap Sort Interactive Module
      - Single-concept module: Demonstrate Heap Sort using max-heap.
      - Features:
        * Array <-> Tree views
        * Step-by-step actions (compare, swap, heapify start/end)
        * Play/Pause, Step Forward/Back, Build Heap, Run Sort
        * Animations for swaps and comparisons
        * Self-contained vanilla HTML/CSS/JS
    */

    // ---------- Utility helpers ----------
    const el = id => document.getElementById(id);

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function sleep(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }

    // ---------- State ----------
    let array = [];                // current numeric array
    let initialArray = [];         // original snapshot for reset/replay
    let actions = [];              // recorded actions from algorithm
    let actionIndex = 0;           // next action to apply (we will apply up to actionIndex)
    let playing = false;
    let playTimer = null;

    // DOM refs
    const sizeRange = el('sizeRange');
    const arrayInput = el('arrayInput');
    const applyArray = el('applyArray');
    const randomize = el('randomize');
    const buildHeapBtn = el('buildHeap');
    const runSortBtn = el('runSort');
    const stepForwardBtn = el('stepForward');
    const stepBackBtn = el('stepBack');
    const playPauseBtn = el('playPause');
    const resetBtn = el('reset');
    const speedRange = el('speed');
    const viewArrayBtn = el('viewArray');
    const viewTreeBtn = el('viewTree');
    const showIndicesCheck = el('showIndices');
    const arrayRow = el('arrayRow');
    const heapLayer = el('heapLayer');
    const connectors = el('connectors');
    const logEl = el('log');
    const currentActionEl = el('currentAction');
    const canvas = el('canvas');

    // Layout constants
    const MAX_VALUE = 99;

    // ---------- Interaction Design (implemented) ----------
    // - User generates a random array or inputs one.
    // - "Build Max-Heap" runs the heapify sequence and records compare/swap actions (but does not sort).
    // - "Run Heap Sort" records the full series of actions to sort using heap sort.
    // - Step Forward / Back step through actions. Play animates with chosen speed.
    // - Toggle Array/Tree to see alternative representations. Both highlight compared/swapped elements.
    // - Visual feedback:
    //    * "Comparing" elements briefly lift and change color.
    //    * "Swapping" animates position swap for both array bars and heap nodes; values update after animation.
    // - For stepping back, we re-apply actions from the initial array up to the requested index (simple deterministic rollback).
    // - Log shows textual representation of each action for reflection.

    // ---------- Algorithm instrumentation ----------
    // Action types: {type:'compare',i,j}, {type:'swap',i,j}, {type:'heapifyStart',i,n}, {type:'heapifyEnd',i,n}, {type:'done'}
    function recordHeapSort(arr) {
      actions = [];
      const a = arr.slice();
      const n = a.length;

      // helper: record compare
      function cmp(i,j){
        actions.push({type:'compare', i, j});
        return a[i] - a[j];
      }
      // helper: record swap
      function sw(i,j){
        actions.push({type:'swap', i, j});
        const t = a[i]; a[i] = a[j]; a[j] = t;
      }
      function siftDown(start, end){
        actions.push({type:'heapifyStart', start, end});
        let root = start;
        while(true){
          let child = 2*root + 1;
          if (child > end) break;
          let swapIndex = root;
          // compare root and child
          actions.push({type:'compare', i:swapIndex, j:child});
          if (a[swapIndex] < a[child]) swapIndex = child;
          if (child+1 <= end){
            actions.push({type:'compare', i:swapIndex, j:child+1});
            if (a[swapIndex] < a[child+1]) swapIndex = child+1;
          }
          if (swapIndex === root) break;
          sw(root, swapIndex);
          root = swapIndex;
        }
        actions.push({type:'heapifyEnd', start, end});
      }

      // build max heap
      for (let i = Math.floor((n-2)/2); i >= 0; i--){
        siftDown(i, n-1);
      }

      // extraction sort
      for (let end = n-1; end > 0; end--){
        sw(0, end);
        siftDown(0, end-1);
      }

      actions.push({type:'done'});
      return actions;
    }

    // A separate record for build-only (heapify)
    function recordBuildHeap(arr){
      actions = [];
      const a = arr.slice();
      function cmp(i,j){ actions.push({type:'compare',i,j}); return a[i] - a[j];}
      function sw(i,j){ actions.push({type:'swap',i,j}); const t=a[i]; a[i]=a[j]; a[j]=t; }
      function siftDown(start,end){
        actions.push({type:'heapifyStart', start, end});
        let root = start;
        while(true){
          let child = 2*root + 1;
          if (child > end) break;
          let swapIndex = root;
          actions.push({type:'compare', i:swapIndex, j:child});
          if (a[swapIndex] < a[child]) swapIndex = child;
          if (child+1 <= end){
            actions.push({type:'compare', i:swapIndex, j:child+1});
            if (a[swapIndex] < a[child+1]) swapIndex = child+1;
          }
          if (swapIndex === root) break;
          sw(root, swapIndex);
          root = swapIndex;
        }
        actions.push({type:'heapifyEnd', start, end});
      }
      const n = a.length;
      for (let i = Math.floor((n-2)/2); i >= 0; i--){
        siftDown(i, n-1);
      }
      actions.push({type:'done'});
      return actions;
    }

    // ---------- Visualization helpers ----------
    function renderArrayView(values, highlight = {}) {
      arrayRow.innerHTML = '';
      const max = Math.max(...values, 1);
      const minVal = Math.min(...values);
      values.forEach((v, i) => {
        const div = document.createElement('div');
        div.className = 'bar';
        div.dataset.index = i;
        if (highlight.comparing && highlight.comparing.includes(i)) div.classList.add('comparing');
        if (highlight.swapping && highlight.swapping.includes(i)) div.classList.add('swapping');
        if (highlight.sorted && highlight.sorted.includes(i)) div.classList.add('sorted');
        const inner = document.createElement('div');
        inner.className = 'val';
        inner.textContent = String(v);
        div.appendChild(inner);
        arrayRow.appendChild(div);
      });
    }

    // Compute node positions for tree layout
    function computeNodePositions(n, width) {
      const levels = Math.floor(Math.log2(n)) + 1;
      const positions = [];
      const layerHeight = 40 + 64; // vertical spacing
      const topOffset = 24;
      for (let i = 0; i < n; i++){
        const level = Math.floor(Math.log2(i+1));
        const indexInLevel = i - (2**level - 1);
        const nodesInLevel = 2**level;
        const rowY = topOffset + level * layerHeight + 16;
        const padding = 24;
        // compute x position based on fraction across width
        const frac = (indexInLevel + 0.5) / nodesInLevel;
        const x = padding + frac * (width - padding*2);
        positions.push({x, y: rowY});
      }
      return positions;
    }

    function renderTree(values, highlight = {}) {
      heapLayer.innerHTML = '';
      connectors.innerHTML = '';
      const rect = canvas.getBoundingClientRect();
      const width = Math.max(rect.width, 320);
      const positions = computeNodePositions(values.length, width);

      // Draw connectors (lines) first
      const ns = values.length;
      for (let i = 0; i < ns; i++){
        const left = positions[i];
        const leftX = left.x;
        const leftY = left.y;
        const leftCenterY = leftY; // nodes are center positioned
        const leftCenterX = leftX;
        const leftIdx = i;
        const lchild = 2*i + 1;
        if (lchild < ns){
          const right = positions[lchild];
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', leftCenterX);
          line.setAttribute('y1', leftCenterY+18);
          line.setAttribute('x2', right.x);
          line.setAttribute('y2', right.y-18);
          line.setAttribute('stroke','#e6f0ff');
          line.setAttribute('stroke-width','2');
          connectors.appendChild(line);
        }
        const rchild = 2*i + 2;
        if (rchild < ns){
          const right = positions[rchild];
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', leftCenterX);
          line.setAttribute('y1', leftCenterY+18);
          line.setAttribute('x2', right.x);
          line.setAttribute('y2', right.y-18);
          line.setAttribute('stroke','#e6f0ff');
          line.setAttribute('stroke-width','2');
          connectors.appendChild(line);
        }
      }

      // Draw nodes
      values.forEach((v,i) => {
        const pos = positions[i];
        const node = document.createElement('div');
        node.className = 'node';
        node.dataset.index = i;
        const span = document.createElement('div');
        span.textContent = String(v);
        node.appendChild(span);
        if (showIndicesCheck.checked){
          const idx = document.createElement('div');
          idx.className = 'index';
          idx.textContent = i;
          node.appendChild(idx);
        }
        // apply highlighting classes
        if (highlight.comparing && highlight.comparing.includes(i)) node.classList.add('comparing');
        if (highlight.swapping && highlight.swapping.includes(i)) node.classList.add('swapping');
        if (highlight.sorted && highlight.sorted.includes(i)) node.classList.add('sorted');

        node.style.left = pos.x + 'px';
        node.style.top = pos.y + 'px';
        heapLayer.appendChild(node);
      });
    }

    // Render both views depending on toggle
    function renderAll(highlight = {}) {
      if (viewArrayBtn.getAttribute('aria-pressed') === 'true'){
        arrayRow.style.display = 'flex';
        heapLayer.style.display = 'none';
        connectors.style.display = 'none';
      } else {
        arrayRow.style.display = 'none';
        heapLayer.style.display = 'block';
        connectors.style.display = 'block';
      }
      renderArrayView(array, highlight);
      renderTree(array, highlight);
    }

    function logAction(action, idx) {
      const e = document.createElement('div');
      e.className = 'entry';
      e.textContent = `${idx}: ${describeAction(action)}`;
      logEl.appendChild(e);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function describeAction(act){
      if (!act) return '—';
      switch(act.type){
        case 'compare': return `compare indices ${act.i} ↔ ${act.j}`;
        case 'swap': return `swap indices ${act.i} ↔ ${act.j}`;
        case 'heapifyStart': return `heapify start at ${act.start} (end ${act.end})`;
        case 'heapifyEnd': return `heapify end at ${act.start} (end ${act.end})`;
        case 'done': return `done`;
        default: return JSON.stringify(act);
      }
    }

    // ---------- Action application (visualization) ----------
    // Apply action by index (replay from initial array)
    async function applyActionsUpTo(k) {
      // Rebuild from initial and apply first k actions
      array = initialArray.slice();
      // reset log and visuals
      clearHighlights();
      renderAll();

      for (let i = 0; i < k && i < actions.length; i++){
        const act = actions[i];
        currentActionEl.textContent = describeAction(act);
        await performActionVisual(act, /*animate*/ true);
      }
      actionIndex = k;
      updateButtons();
    }

    function clearHighlights(){
      currentActionEl.textContent = 'idle';
      // remove classes from nodes and bars
      document.querySelectorAll('.bar, .node').forEach(elm => {
        elm.classList.remove('comparing','swapping','sorted');
      });
    }

    // Perform a single action visually. Returns a Promise that resolves when animation finishes.
    async function performActionVisual(act, animated=true){
      if (!act) return;
      // default animation duration scaled by speed
      const baseMs = 520;
      const speedFactor = parseFloat(speedRange.value) || 1;
      const animMs = Math.round(baseMs / speedFactor);

      switch(act.type){
        case 'compare': {
          highlightCompare([act.i, act.j]);
          // short pause
          await sleep(Math.round(animMs * 0.45));
          break;
        }
        case 'swap': {
          highlightSwap([act.i, act.j]);
          // animate swap positions in both array and tree
          await animateSwap(act.i, act.j, animMs);
          break;
        }
        case 'heapifyStart': {
          // show subtle notice
          const nodes = [act.start];
          highlightCompare(nodes);
          await sleep(Math.round(animMs * 0.25));
          break;
        }
        case 'heapifyEnd': {
          // clear highlights
          await sleep(Math.round(animMs * 0.1));
          break;
        }
        case 'done': {
          // mark all sorted
          highlightSorted();
          await sleep(300);
          break;
        }
      }
      // After action applied, update visuals (array values may have changed)
      renderAll();
    }

    function highlightCompare(indices){
      clearHighlights();
      indices.forEach(idx => {
        const bar = arrayRow.querySelector(`.bar[data-index="${idx}"]`);
        if (bar) bar.classList.add('comparing');
        const node = heapLayer.querySelector(`.node[data-index="${idx}"]`);
        if (node) node.classList.add('comparing');
      });
    }

    function highlightSwap(indices){
      clearHighlights();
      indices.forEach(idx => {
        const bar = arrayRow.querySelector(`.bar[data-index="${idx}"]`);
        if (bar) bar.classList.add('swapping');
        const node = heapLayer.querySelector(`.node[data-index="${idx}"]`);
        if (node) node.classList.add('swapping');
      });
    }

    function highlightSorted(){
      clearHighlights();
      for (let i = 0; i < array.length; i++){
        const bar = arrayRow.querySelector(`.bar[data-index="${i}"]`);
        if (bar) bar.classList.add('sorted');
        const node = heapLayer.querySelector(`.node[data-index="${i}"]`);
        if (node) node.classList.add('sorted');
      }
    }

    // Animate swapping visuals and update underlying array values.
    async function animateSwap(i,j,ms){
      // get elements
      const barI = arrayRow.querySelector(`.bar[data-index="${i}"]`);
      const barJ = arrayRow.querySelector(`.bar[data-index="${j}"]`);
      const nodeI = heapLayer.querySelector(`.node[data-index="${i}"]`);
      const nodeJ = heapLayer.querySelector(`.node[data-index="${j}"]`);

      // For smooth animation, we will animate CSS transforms based on computed positions
      // Snapshot current positions
      const snapshot = (el) => {
        if (!el) return null;
        const r = el.getBoundingClientRect();
        return {el, left: r.left + r.width/2, top: r.top + r.height/2};
      };
      // only animate the nodes/ bars if they exist
      const sBarI = snapshot(barI), sBarJ = snapshot(barJ);
      const sNodeI = snapshot(nodeI), sNodeJ = snapshot(nodeJ);

      // Swap values in array model first for subsequent layout
      const tmp = array[i]; array[i] = array[j]; array[j] = tmp;

      // Re-render to compute new places
      renderAll(); // this will update DOM positions for target state
      await sleep(20); // allow DOM to update

      // compute destination positions
      const dBarI = arrayRow.querySelector(`.bar[data-index="${i}"]`);
      const dBarJ = arrayRow.querySelector(`.bar[data-index="${j}"]`);
      const dNodeI = heapLayer.querySelector(`.node[data-index="${i}"]`);
      const dNodeJ = heapLayer.querySelector(`.node[data-index="${j}"]`);
      const dSBarI = snapshot(dBarI), dSBarJ = snapshot(dBarJ);
      const dSNodeI = snapshot(dNodeI), dSNodeJ = snapshot(dNodeJ);

      // Function to animate a pair: set transform on source to move to destination, then clear.
      function animateElementPair(snapFrom, snapTo){
        return new Promise(resolve => {
          if (!snapFrom || !snapTo) {
            return resolve();
          }
          const deltaX = snapTo.left - snapFrom.left;
          const deltaY = snapTo.top - snapFrom.top;
          // apply a temporary translate to the element that moves it from its old screen position to its new one
          // compute current transform and set transition
          const elm = snapFrom.el;
          elm.style.transition = `transform ${ms}ms cubic-bezier(.2,.9,.2,1)`;
          // move it back visually by reversing the delta
          // set transform to translate by (-deltaX, -deltaY) so it appears at old position,
          // then force reflow and set transform to none to animate to new position.
          elm.style.transform = `translate(${ -deltaX }px, ${ -deltaY }px)`;
          // Force reflow
          void elm.offsetWidth;
          // Clear transform to animate to new position
          elm.style.transform = '';
          setTimeout(() => {
            elm.style.transition = '';
            elm.style.transform = '';
            resolve();
          }, ms + 20);
        });
      }

      // To visualize swapping nicely, we animate both bars and nodes (if present)
      const promises = [];
      if (sBarI && dSBarI) promises.push(animateElementPair(sBarI, dSBarI));
      if (sBarJ && dSBarJ) promises.push(animateElementPair(sBarJ, dSBarJ));
      if (sNodeI && dSNodeI) promises.push(animateElementPair(sNodeI, dSNodeI));
      if (sNodeJ && dSNodeJ) promises.push(animateElementPair(sNodeJ, dSNodeJ));

      // wait all animations complete
      await Promise.all(promises);
    }

    // ---------- Controls and main flow ----------
    function updateButtons(){
      stepBackBtn.disabled = actionIndex <= 0;
      stepForwardBtn.disabled = actionIndex >= actions.length;
      buildHeapBtn.disabled = playing;
      runSortBtn.disabled = playing;
      applyArray.disabled = playing;
      randomize.disabled = playing;
      resetBtn.disabled = playing && actionIndex === 0;
      playPauseBtn.disabled = actions.length === 0;
    }

    // Step forward by one action
    async function stepForward(){
      if (actionIndex >= actions.length) return;
      // apply action (we can apply the single action by replaying one more)
      await applyActionsUpTo(actionIndex + 1);
      appendLog(actionIndex-1); // last applied action logged
    }

    // Step back by one action
    async function stepBack(){
      if (actionIndex <= 0) return;
      await applyActionsUpTo(actionIndex - 1);
    }

    // Append an action entry to log
    function appendLog(appliedIndex){
      if (appliedIndex < 0 || appliedIndex >= actions.length) return;
      logAction(actions[appliedIndex], appliedIndex);
    }

    // Play / Pause
    function togglePlay(){
      if (playing) {
        playing = false;
        playPauseBtn.textContent = 'Play ▶';
        playPauseBtn.classList.remove('secondary');
        playPauseBtn.setAttribute('aria-pressed','false');
        if (playTimer) clearInterval(playTimer);
      } else {
        playing = true;
        playPauseBtn.textContent = 'Pause ❚❚';
        playPauseBtn.setAttribute('aria-pressed','true');
        const speedFactor = parseFloat(speedRange.value) || 1;
        const interval = Math.max(80, Math.round(600 / speedFactor));
        playTimer = setInterval(async () => {
          if (actionIndex >= actions.length) {
            togglePlay(); // auto-stop
            return;
          }
          await stepForward();
        }, interval);
      }
      updateButtons();
    }

    // Reset to initial state
    function resetToInitial(){
      actions = [];
      actionIndex = 0;
      array = initialArray.slice();
      renderAll();
      logEl.innerHTML = '';
      currentActionEl.textContent = 'idle';
      updateButtons();
    }

    // Generate random array
    function generateRandom(n){
      const arr = [];
      for (let i = 0; i < n; i++){
        arr.push(Math.floor(Math.random() * MAX_VALUE) + 1);
      }
      return arr;
    }

    // Build buttons' event listeners
    sizeRange.addEventListener('input', () => {
      const n = parseInt(sizeRange.value, 10);
      array = generateRandom(n);
      initialArray = array.slice();
      arrayInput.value = array.join(',');
      actions = [];
      actionIndex = 0;
      renderAll();
      logEl.innerHTML = '';
      updateButtons();
    });

    randomize.addEventListener('click', () => {
      const n = parseInt(sizeRange.value, 10);
      array = generateRandom(n);
      initialArray = array.slice();
      arrayInput.value = array.join(',');
      actions = [];
      actionIndex = 0;
      renderAll();
      logEl.innerHTML = '';
      updateButtons();
    });

    applyArray.addEventListener('click', () => {
      const text = arrayInput.value.trim();
      if (!text) return;
      const parts = text.split(',').map(s => parseInt(s.trim(),10)).filter(x => !Number.isNaN(x));
      if (parts.length < 2) {
        alert('Please enter at least two numbers separated by commas.');
        return;
      }
      const n = clamp(parts.length, 2, 15);
      sizeRange.value = n;
      array = parts.slice(0,n);
      initialArray = array.slice();
      actions = [];
      actionIndex = 0;
      renderAll();
      logEl.innerHTML = '';
      updateButtons();
    });

    buildHeapBtn.addEventListener('click', async () => {
      // record heapify actions from initial
      initialArray = array.slice();
      actions = recordBuildHeap(initialArray);
      actionIndex = 0;
      logEl.innerHTML = '';
      renderAll();
      // prepare to step through build
      updateButtons();
    });

    runSortBtn.addEventListener('click', async () => {
      initialArray = array.slice();
      actions = recordHeapSort(initialArray);
      actionIndex = 0;
      logEl.innerHTML = '';
      renderAll();
      updateButtons();
    });

    stepForwardBtn.addEventListener('click', async () => {
      await stepForward();
    });

    stepBackBtn.addEventListener('click', async () => {
      await stepBack();
    });

    playPauseBtn.addEventListener('click', () => {
      // If no actions recorded, record full sort from current array
      if (actions.length === 0) {
        initialArray = array.slice();
        actions = recordHeapSort(initialArray);
        actionIndex = 0;
        logEl.innerHTML = '';
      }
      togglePlay();
    });

    resetBtn.addEventListener('click', () => {
      // reset array to initial snapshot
      array = initialArray.slice();
      actionIndex = 0;
      actions = [];
      logEl.innerHTML = '';
      renderAll();
      updateButtons();
    });

    speedRange.addEventListener('input', () => {
      // affects next animations (play uses speed interval)
    });

    viewArrayBtn.addEventListener('click', () => {
      viewArrayBtn.setAttribute('aria-pressed','true');
      viewTreeBtn.setAttribute('aria-pressed','false');
      renderAll();
    });

    viewTreeBtn.addEventListener('click', () => {
      viewTreeBtn.setAttribute('aria-pressed','true');
      viewArrayBtn.setAttribute('aria-pressed','false');
      renderAll();
    });

    showIndicesCheck.addEventListener('change', () => {
      renderAll();
    });

    // Initialize with a random array
    (function init(){
      const n = parseInt(sizeRange.value, 10);
      array = generateRandom(n);
      initialArray = array.slice();
      arrayInput.value = array.join(',');
      actions = [];
      actionIndex = 0;
      renderAll();
      updateButtons();
    })();

    // When the window resizes, re-render tree positions to keep connectors correct
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => renderAll(), 120);
    });

    // For accessibility: keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.key === ' ') { e.preventDefault(); playPauseBtn.click(); }
      if (e.key === 'ArrowRight') { stepForwardBtn.click(); }
      if (e.key === 'ArrowLeft') { stepBackBtn.click(); }
    });

    // Expose some description content in the page as well (Learning Objective and Layout Description)
    // We'll append this textual plan for clarity (meets the "Interactive Design Plan" requirement)
    (function appendDesignPlan() {
      const container = document.createElement('div');
      container.style.marginTop = '8px';
      container.style.fontSize = '13px';
      container.style.color = 'var(--muted)';
      container.innerHTML = `
        <strong>Concept Title:</strong> Heap Sort — Build a Max-Heap and Repeatedly Extract the Maximum<br/>
        <strong>Learning Objective:</strong> After interacting, you should understand how a max-heap is constructed (sift-down heapify), how the root is repeatedly swapped with the end to produce a sorted array, and be able to trace individual compare/swap operations.<br/>
        <strong>Interaction Design:</strong> Use the controls to create or input an array. Click "Build Max-Heap" to record the heapify actions, or "Run Heap Sort" to record the full sort. Step Forward/Back walks the action sequence; Play animates automatically. Visual feedback includes: highlighted comparisons, animated swaps (nodes/bars move to new positions), and final sorted marking. The array and heap-tree representations are synchronized and can be toggled to reinforce the index-&gt;tree mapping. Logs describe each action so you can reflect on the algorithm steps.<br/>
        <strong>Layout Description:</strong> The module uses a three-column responsive layout (Controls | Visualization | Steps/Log). Safe area margins are 24 px on all sides; interactive elements have at least 16 px spacing. Controls are on the left (stacked), visualization in the center (array bars and heap tree with connectors), and action log on the right. The design remains clear on narrow screens by stacking columns vertically. Interactive elements use accessible labels and keyboard shortcuts (Space=Play/Pause, ←/→ step). 
      `;
      document.querySelector('.controls').appendChild(container);
    })();

  </script>
</body>
</html>