<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Linear Search — Interactive Visualization</title>
  <style>
    /* Safe area margin */
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --cell-size: 64px;
      --cell-gap: 12px;
      --accent: #ffb020;
      --match: #28a745;
      --current: #ffd27a;
      --visited: #e9ecef;
      --bg: #0f1720;
      --panel-bg: #0b1220;
      --text: #e6eef8;
      --muted: #98a0b2;
      --danger: #e55353;
    }

    html,body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg,#071425 0%, #07192a 100%);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      padding: var(--safe-margin);
      box-sizing: border-box;
    }

    /* Layout */
    .container {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: var(--gap);
      min-height: calc(100vh - 2 * var(--safe-margin));
    }

    header {
      grid-column: 1 / -1;
      margin-bottom: 4px;
    }

    h1 {
      margin: 0 0 6px 0;
      font-size: 20px;
      letter-spacing: -0.2px;
    }

    p.lead {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
    }

    /* Panels */
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      padding: 16px;
      border-radius: 12px;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    label {
      display: block;
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    input[type="range"] {
      width: 100%;
    }

    .small {
      font-size: 13px;
      color: var(--muted);
    }

    .btn {
      background: #102034;
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.04);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      min-height: 38px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }

    .btn:active { transform: translateY(1px); }
    .btn[aria-pressed="true"] { outline: 2px solid rgba(255,178,32,0.18); }

    .controls .btn-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .input {
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.03);
      padding: 8px 10px;
      border-radius: 8px;
      color: var(--text);
      min-height: 38px;
      width: 100%;
      font-size: 14px;
    }

    .visual {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      align-items: center;
      justify-content: center;
    }

    /* Array visualization */
    .array-wrap {
      width: 100%;
      min-height: 220px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow-x: auto;
      padding: 12px;
    }

    .array {
      display: flex;
      gap: var(--cell-gap);
      align-items: center;
      padding: 12px;
      background: linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.03);
      min-height: calc(var(--cell-size) + 60px);
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      min-width: var(--cell-size);
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.02);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.03);
      color: var(--text);
      font-weight: 600;
      position: relative;
      transition: background 250ms ease, transform 200ms cubic-bezier(.2,.8,.2,1);
      box-shadow: 0 4px 10px rgba(2,6,23,0.35);
      cursor: pointer;
    }

    .cell:focus {
      outline: 3px solid rgba(255,178,32,0.14);
      transform: translateY(-4px);
    }

    .cell.small {
      font-weight: 500;
      font-size: 13px;
    }

    .cell .idx {
      position: absolute;
      bottom: -22px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: var(--muted);
    }

    .cell.current {
      background: linear-gradient(180deg, var(--current), #fff2d2);
      color: #102020;
      animation: pulse 900ms infinite alternate;
      z-index: 4;
    }

    .cell.visited {
      background: var(--visited);
      color: #213044;
      opacity: 0.9;
    }

    .cell.match {
      background: linear-gradient(180deg,#7ce08a,#28a745);
      color: white;
      transform: scale(1.06);
      box-shadow: 0 8px 24px rgba(40,167,69,0.2);
      z-index: 5;
    }

    @keyframes pulse {
      from { box-shadow: 0 6px 16px rgba(255,178,32,0.10); transform: translateY(-2px); }
      to { box-shadow: 0 14px 30px rgba(255,178,32,0.18); transform: translateY(-6px); }
    }

    /* Magnifier */
    .magnifier {
      position: absolute;
      width: calc(var(--cell-size) + 18px);
      height: calc(var(--cell-size) + 18px);
      pointer-events: none;
      transition: transform 450ms cubic-bezier(.2,.9,.2,1), opacity 200ms;
      transform-origin: center;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3;
      filter: drop-shadow(0 10px 30px rgba(2,6,23,0.6));
    }

    .magnifier svg {
      width: 100%;
      height: 100%;
      opacity: 0.95;
    }

    /* Status & explanation */
    .status-bar {
      grid-column: 1 / -1;
      margin-top: 8px;
      display: flex;
      gap: var(--gap);
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .status {
      display: flex;
      gap: 12px;
      align-items: center;
      color: var(--muted);
    }

    .badge {
      background: rgba(255,255,255,0.02);
      padding: 8px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.03);
      font-weight: 600;
      color: var(--text);
    }

    .explanation {
      font-size: 14px;
      color: var(--muted);
      background: rgba(255,255,255,0.02);
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.02);
    }

    /* Footer controls */
    .actions {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: flex-end;
    }

    /* Responsive */
    @media (max-width: 920px) {
      .container { grid-template-columns: 1fr; }
      .controls { order: 1; }
      .visual { order: 2; }
      .status-bar { flex-direction: column; align-items: stretch; gap: 12px; }
    }

    /* Accessibility focus for keyboard users */
    .cell[tabindex]:focus { outline-offset: 2px; }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Linear Search interactive module">
    <header>
      <h1>Linear Search — Visual Explorer</h1>
      <p class="lead">See how the algorithm checks elements one-by-one. Edit values, pick a target, and step through the comparisons.</p>
    </header>

    <aside class="panel controls" aria-label="Controls">
      <div>
        <label for="size">Array size: <span id="sizeLabel" class="small">8</span></label>
        <input id="size" type="range" min="2" max="20" value="8" />
      </div>

      <div>
        <label>Values</label>
        <div class="row btn-row" role="group" aria-label="Array actions">
          <button id="fillRandom" class="btn" title="Fill with random integers">Fill random</button>
          <button id="shuffle" class="btn" title="Shuffle current values">Shuffle</button>
          <button id="reset" class="btn" title="Reset default sequence">Reset</button>
        </div>
      </div>

      <div>
        <label for="target">Target (search key)</label>
        <input id="target" class="input" type="text" placeholder="Type value to search (e.g., 7)" aria-label="Target value" />
      </div>

      <div>
        <label>Mode & Speed</label>
        <div class="row">
          <button id="stepBtn" class="btn" title="Advance one comparison">Step</button>
          <button id="playBtn" class="btn" aria-pressed="false" title="Play / pause automatic stepping">Play</button>
          <div style="width:100%;">
            <label class="small" for="speed">Speed</label>
            <input id="speed" type="range" min="200" max="1600" value="800" />
          </div>
        </div>
      </div>

      <div>
        <label>Controls Info</label>
        <div class="explanation" id="explainShort" aria-live="polite">
          Double-click a cell to edit its value. Use Step to move one comparison, or Play to auto-run. The magnifier shows the current comparison.
        </div>
      </div>

      <div>
        <label>Legend</label>
        <div style="display:flex; gap:12px; flex-wrap:wrap;">
          <div class="badge" style="background:#fff2d2; color:#102020">Current</div>
          <div class="badge" style="background:var(--visited); color:#213044">Visited</div>
          <div class="badge" style="background:linear-gradient(180deg,#7ce08a,#28a745); color:white">Match</div>
        </div>
      </div>
    </aside>

    <main class="panel visual" aria-live="polite" aria-atomic="true">
      <div class="array-wrap" id="arrayWrap">
        <div class="array" id="array" role="list" aria-label="Array elements">
          <!-- cells dynamically generated here -->
        </div>

        <div id="magnifier" class="magnifier" style="opacity:0;">
          <!-- simple magnifier SVG -->
          <svg viewBox="0 0 100 100" aria-hidden="true" focusable="false">
            <defs>
              <linearGradient id="g" x1="0" x2="1">
                <stop offset="0" stop-color="#fff" stop-opacity="0.95" />
                <stop offset="1" stop-color="#ffffff" stop-opacity="0.85" />
              </linearGradient>
            </defs>
            <circle cx="44" cy="44" r="30" fill="url(#g)" stroke="rgba(0,0,0,0.06)" stroke-width="2"/>
            <circle cx="44" cy="44" r="26" fill="none" stroke="rgba(0,0,0,0.06)" stroke-width="1.5"/>
            <rect x="66" y="66" width="10" height="24" rx="4" transform="rotate(45 70 78)" fill="#fff2d2" opacity="0.9" />
          </svg>
        </div>
      </div>

      <div id="stepExplanation" class="explanation" style="width:100%;" aria-live="polite">
        Ready. Build an array, enter a target, then Step or Play.
      </div>
    </main>

    <div class="status-bar">
      <div class="status" aria-hidden="false">
        <div class="badge" id="count">Comparisons: 0</div>
        <div class="badge" id="currentIdx">Current index: —</div>
        <div class="badge" id="result">Status: idle</div>
      </div>

      <div class="actions" role="toolbar">
        <button id="stepBtnBottom" class="btn">Step</button>
        <button id="playBtnBottom" class="btn" aria-pressed="false">Play</button>
        <button id="resetBtnBottom" class="btn">Reset</button>
      </div>
    </div>
  </div>

  <script>
    // Linear Search Interactive — vanilla JS
    (function () {
      // DOM elements
      const sizeInput = document.getElementById('size');
      const sizeLabel = document.getElementById('sizeLabel');
      const arrayEl = document.getElementById('array');
      const arrayWrap = document.getElementById('arrayWrap');
      const fillRandomBtn = document.getElementById('fillRandom');
      const shuffleBtn = document.getElementById('shuffle');
      const resetBtn = document.getElementById('reset');
      const resetBtnBottom = document.getElementById('resetBtnBottom');
      const targetInput = document.getElementById('target');
      const stepBtn = document.getElementById('stepBtn');
      const stepBtnBottom = document.getElementById('stepBtnBottom');
      const playBtn = document.getElementById('playBtn');
      const playBtnBottom = document.getElementById('playBtnBottom');
      const speedInput = document.getElementById('speed');
      const magnifier = document.getElementById('magnifier');
      const explainShort = document.getElementById('explainShort');
      const stepExplanation = document.getElementById('stepExplanation');
      const countBadge = document.getElementById('count');
      const idxBadge = document.getElementById('currentIdx');
      const resultBadge = document.getElementById('result');

      // State
      let arr = [];
      let currentIndex = -1;
      let comparisons = 0;
      let running = false;
      let intervalId = null;
      let target = null;

      // Initialize
      function init(size = parseInt(sizeInput.value, 10)) {
        sizeInput.value = size;
        sizeLabel.textContent = size;
        arr = new Array(size).fill(0).map((_, i) => i + 1);
        currentIndex = -1;
        comparisons = 0;
        running = false;
        stopAuto();
        updateBadges();
        renderArray();
        setExplanation('Ready. Build an array, enter a target, then Step or Play.');
      }

      // Render array cells
      function renderArray() {
        arrayEl.innerHTML = '';
        arr.forEach((val, i) => {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.setAttribute('role', 'listitem');
          cell.setAttribute('tabindex', '0');
          cell.dataset.index = i;
          cell.innerHTML = `<span class="value">${escapeHtml(String(val))}</span><span class="idx">A[${i}]</span>`;
          // Double-click to edit
          cell.addEventListener('dblclick', () => editCell(i));
          cell.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              editCell(i);
            }
          });
          arrayEl.appendChild(cell);
        });

        // Reset magnifier invisibility
        magnifier.style.opacity = 0;
      }

      // Escape HTML for safety in cell content
      function escapeHtml(text) {
        return text.replace(/[&<>"']/g, function (m) {
          return ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[m];
        });
      }

      // Edit a cell's value
      function editCell(index) {
        const newVal = prompt('Edit value for A[' + index + ']:', String(arr[index]));
        if (newVal !== null) {
          arr[index] = newVal;
          renderArray();
          setExplanation('Edited A[' + index + '] to "' + newVal + '".');
        }
      }

      // Step one comparison
      function step() {
        if (currentIndex === -2) {
          // already finished
          return;
        }

        if (target === null || target === '') {
          setExplanation('Please enter a target value to search for.', true);
          return;
        }

        // Prepare target as string trimming whitespace for consistent comparison
        const targetStr = String(target).trim();

        // Advance index
        currentIndex++;
        comparisons++;
        updateBadges();

        // Update visuals
        updateCells();

        // Show magnifier and move it
        moveMagnifierTo(currentIndex);

        // Compare
        const cellVal = String(arr[currentIndex]).trim();
        setExplanation(`Comparing target "${targetStr}" with A[${currentIndex}] = "${cellVal}"`);

        // Visual delay for animation completeness — we decide match after a short timeout
        // But the processing logic should evaluate immediately to allow stopping.
        const isMatch = (cellVal === targetStr);
        if (isMatch) {
          markMatch(currentIndex);
          setResult('found', currentIndex);
          stopAuto();
          currentIndex = -2; // finished state
        } else {
          markVisited(currentIndex);
          // If last element reached and not found
          if (currentIndex >= arr.length - 1) {
            setResult('not-found');
            stopAuto();
            currentIndex = -2; // finished
          }
        }
      }

      // Mark visited cell visually
      function markVisited(i) {
        const cell = arrayEl.querySelector(`.cell[data-index="${i}"]`);
        if (!cell) return;
        cell.classList.remove('current');
        cell.classList.add('visited');
      }

      // Mark match visually
      function markMatch(i) {
        const cell = arrayEl.querySelector(`.cell[data-index="${i}"]`);
        if (!cell) return;
        cell.classList.remove('current');
        cell.classList.remove('visited');
        cell.classList.add('match');
      }

      // Update cell classes to reflect current index, visited, etc.
      function updateCells() {
        arrayEl.querySelectorAll('.cell').forEach((cell) => {
          const idx = Number(cell.dataset.index);
          cell.classList.remove('current');
          if (idx < currentIndex) {
            cell.classList.add('visited');
          } else if (idx === currentIndex) {
            cell.classList.add('current');
            cell.classList.remove('visited');
            cell.classList.remove('match');
          } else {
            cell.classList.remove('visited', 'match', 'current');
          }
        });
      }

      // Move magnifier overlay to target cell (animated)
      function moveMagnifierTo(i) {
        const cell = arrayEl.querySelector(`.cell[data-index="${i}"]`);
        if (!cell) {
          magnifier.style.opacity = 0;
          return;
        }
        const wrapRect = arrayWrap.getBoundingClientRect();
        const rect = cell.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const wrapCenterX = wrapRect.left;
        const wrapCenterY = wrapRect.top;

        const offsetX = centerX - wrapRect.left - (magnifier.offsetWidth / 2);
        const offsetY = centerY - wrapRect.top - (magnifier.offsetHeight / 2);

        magnifier.style.opacity = 1;
        magnifier.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1)`;
      }

      // Auto-run functions
      function startAuto() {
        if (running) return;
        running = true;
        playBtn.setAttribute('aria-pressed', 'true');
        playBtnBottom.setAttribute('aria-pressed', 'true');
        const speed = Number(speedInput.value);
        intervalId = setInterval(() => {
          // if finished, stop
          if (currentIndex === -2) {
            stopAuto();
            return;
          }
          // when starting from initial state (-1) but no target or out-of-range
          if (currentIndex >= arr.length - 1) {
            // if already at end and we haven't indicated not-found, step will show not-found
            if (currentIndex === arr.length - 1) {
              step();
            } else {
              stopAuto();
            }
            return;
          }
          step();
        }, speed);
      }

      function stopAuto() {
        running = false;
        playBtn.setAttribute('aria-pressed', 'false');
        playBtnBottom.setAttribute('aria-pressed', 'false');
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = null;
        }
      }

      // Shuffle array values
      function shuffleArray() {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        renderArray();
        setExplanation('Array shuffled.');
      }

      // Fill with random integers
      function fillRandom() {
        const max = Math.max(10, arr.length * 5);
        arr = arr.map(() => String(Math.floor(Math.random() * max) + 1));
        renderArray();
        setExplanation('Array filled with random values.');
      }

      // Update badges
      function updateBadges() {
        countBadge.textContent = 'Comparisons: ' + comparisons;
        idxBadge.textContent = currentIndex >= 0 && currentIndex < arr.length ? 'Current index: ' + currentIndex : 'Current index: —';
        resultBadge.textContent = 'Status: ' + (currentIndex === -2 ? 'finished' : (running ? 'running' : 'idle'));
      }

      // Set explanation text (short and detailed)
      function setExplanation(text, warn = false) {
        stepExplanation.textContent = text;
        explainShort.textContent = warn ? text : explainShort.textContent;
        // ARIA live will announce changes
      }

      // Mark final result
      function setResult(status, index) {
        if (status === 'found') {
          resultBadge.textContent = 'Status: found at index ' + index;
          setExplanation('Success: target found at A[' + index + ']. Comparisons: ' + comparisons);
        } else if (status === 'not-found') {
          resultBadge.textContent = 'Status: not found';
          setExplanation('Target not found in array after ' + comparisons + ' comparisons.', true);
        }
        updateBadges();
      }

      // Reset to initial state but keep array values (or accept flag to regenerate)
      function reset(full = false) {
        stopAuto();
        currentIndex = -1;
        comparisons = 0;
        if (full) {
          // reset values to sequence 1..n
          arr = new Array(Number(sizeInput.value)).fill(0).map((_, i) => i + 1);
        }
        renderArray();
        updateBadges();
        setExplanation('Reset. Ready to search.');
      }

      // Event wiring
      sizeInput.addEventListener('input', () => {
        const sz = Number(sizeInput.value);
        sizeLabel.textContent = sz;
      });
      sizeInput.addEventListener('change', () => {
        const sz = Number(sizeInput.value);
        init(sz);
      });

      fillRandomBtn.addEventListener('click', fillRandom);
      shuffleBtn.addEventListener('click', () => {
        shuffleArray();
        setExplanation('Shuffled array.');
      });

      resetBtn.addEventListener('click', () => {
        reset(true);
      });
      resetBtnBottom.addEventListener('click', () => {
        reset(true);
      });

      targetInput.addEventListener('input', (e) => {
        target = e.target.value;
      });

      stepBtn.addEventListener('click', () => {
        // if we are in finished state, do nothing
        if (currentIndex === -2) {
          setExplanation('Search is finished. Reset to try again.');
          return;
        }
        // If we haven't started yet, currentIndex will be -1 and step() will set it to 0
        step();
        updateBadges();
      });

      stepBtnBottom.addEventListener('click', () => {
        stepBtn.click();
      });

      playBtn.addEventListener('click', () => {
        if (running) stopAuto();
        else startAuto();
        updateBadges();
      });
      playBtnBottom.addEventListener('click', () => {
        playBtn.click();
      });

      speedInput.addEventListener('change', () => {
        if (running) {
          stopAuto();
          startAuto(); // restart with new speed
        }
      });

      // Buttons to set accessible states
      document.addEventListener('keydown', (e) => {
        // Space to step, Enter to toggle play (unless focused in input)
        const active = document.activeElement;
        const typingNow = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable);
        if (typingNow) return;
        if (e.key === ' ') {
          e.preventDefault();
          stepBtn.click();
        } else if (e.key === 'Enter') {
          e.preventDefault();
          playBtn.click();
        }
      });

      // Initialize default array
      init( Number(sizeInput.value) );

      // Make sure magnifier moves on window resize
      window.addEventListener('resize', () => {
        if (currentIndex >= 0 && currentIndex < arr.length) {
          moveMagnifierTo(currentIndex);
        }
      });

      // Accessibility: announce state changes using ARIA live attributes are already on stepExplanation and main panel

      // Helper: initial randomization on first run for a varied demo
      fillRandom();

    })();
  </script>
</body>
</html>