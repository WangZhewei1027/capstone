<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>K-Nearest Neighbors — Interactive Module</title>
  <style>
    /* Safe area margins */
    :root {
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1720;
      --panel: #0b1220;
      --muted: #9aa3b2;
      --accent: #2ca6ff;
      --success: #28c76f;
      --danger: #ff6b6b;
      --glass: rgba(255,255,255,0.03);
    }

    html,body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg,#071021 0%, #071827 50%, #071021 100%);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #e6eef8;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Container with safe margins */
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100%;
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: var(--gap);
      align-items: start;
    }

    /* Left panel: explanations & controls */
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      min-height: 360px;
    }

    h1 {
      margin: 0 0 8px 0;
      font-size: 20px;
      line-height: 1.1;
    }

    .muted {
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 12px;
    }

    .section {
      margin-top: 14px;
    }

    label {
      display: block;
      font-size: 13px;
      margin-bottom: 6px;
      color: #dbe9ff;
    }

    .control-row {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    input[type="range"] {
      width: 100%;
    }

    .btn {
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.04);
      padding: 8px 10px;
      border-radius: 8px;
      color: inherit;
      cursor: pointer;
      font-size: 13px;
      min-width: 0;
    }

    .btn:focus { outline: 2px solid rgba(44,166,255,0.25); }

    .btn.primary {
      background: linear-gradient(180deg, rgba(44,166,255,0.14), rgba(44,166,255,0.06));
      border-color: rgba(44,166,255,0.28);
      color: #dff4ff;
    }

    .small {
      font-size: 12px;
      color: var(--muted);
    }

    .legend {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .legend .item {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 13px;
      color: #e6eef8;
    }

    .color-swatch {
      width: 18px;
      height: 18px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(2,6,23,0.6);
      border: 1px solid rgba(255,255,255,0.04);
    }

    /* Right: canvas area */
    .canvas-panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      min-height: 360px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .canvas-area {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius: 8px;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 300px;
      position: relative;
      overflow: hidden;
      padding: 12px;
    }

    /* Canvas itself scales responsively */
    canvas {
      border-radius: 8px;
      background: linear-gradient(180deg,#06121a, #081421);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
      max-width: 100%;
      max-height: 100%;
      width: 100%;
      height: 100%;
      display: block;
    }

    .hint {
      font-size: 13px;
      color: var(--muted);
    }

    /* Accessibility / mobile: stack layout */
    @media (max-width: 980px) {
      .app {
        grid-template-columns: 1fr;
      }
    }

    /* Controls layout specifics for spacing requirements */
    .control-block {
      margin-bottom: 12px;
    }

    .radio-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .tiny {
      font-size: 12px;
    }

    .status {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 13px;
    }

    .value-box {
      background: rgba(255,255,255,0.02);
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.03);
      min-width: 88px;
      text-align: center;
    }

    /* Ensure minimum spacing between interactive elements */
    .panel > * + * { margin-top: var(--gap); }
    .canvas-panel > * + * { margin-top: var(--gap); }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="K-Nearest Neighbors interactive module">
    <!-- Left explanatory and controls panel -->
    <aside class="panel" aria-labelledby="title">
      <h1 id="title">K-Nearest Neighbors (KNN): Visual, Interactive</h1>
      <div class="muted">Explore how the choice of K and distance affects classification decisions.</div>

      <!-- Learning objective -->
      <div class="section" aria-labelledby="objective">
        <label id="objective"><strong>Learning objective</strong></label>
        <div class="small">
          After exploring this module you will be able to:
          <ul style="margin:8px 0 0 18px; padding:0;">
            <li>See how K and distance metric affect predicted class of a query point.</li>
            <li>Understand neighbor voting vs distance-weighted voting.</li>
            <li>Experiment by adding, moving, and removing data points to observe local effects.</li>
          </ul>
        </div>
      </div>

      <!-- Interaction design description -->
      <div class="section" aria-labelledby="interaction">
        <label id="interaction"><strong>Interaction design (how to use)</strong></label>
        <div class="small">
          - Click on the canvas to add a data point with the selected class. <br>
          - Drag points to reposition them. <br>
          - Drag the green query point to test different locations. <br>
          - Use controls below to change K, distance metric, and toggle weighted voting. <br>
          - Background colors update instantly to show the predicted class region. <br>
          - Distances to the K nearest neighbors are drawn and animated.
        </div>
      </div>

      <!-- Layout description -->
      <div class="section" aria-labelledby="layout">
        <label id="layout"><strong>Layout description</strong></label>
        <div class="small">
          The module uses a two-column layout: explanatory controls on the left and an interactive canvas on the right.
          Safe margins of 24px are applied and at least 16px spacing between controls to keep touch targets comfortable.
          The canvas area scales responsively and all controls are keyboard-focusable for accessibility.
        </div>
      </div>

      <!-- Controls -->
      <div class="section" aria-labelledby="controls">
        <label id="controls"><strong>Controls</strong></label>

        <div class="control-block">
          <label for="kRange">K (number of neighbors): <span id="kValue" class="value-box">5</span></label>
          <input id="kRange" type="range" min="1" max="25" value="5" aria-label="Select K">
        </div>

        <div class="control-row" style="align-items:center;">
          <div style="flex:1;">
            <label for="metric">Distance metric</label>
            <select id="metric" class="btn" aria-label="Distance metric">
              <option value="euclidean">Euclidean (L2)</option>
              <option value="manhattan">Manhattan (L1)</option>
              <option value="chebyshev">Chebyshev (L∞)</option>
            </select>
          </div>

          <div style="min-width: 140px;">
            <label style="margin-bottom:6px;">Voting</label>
            <div class="radio-row" role="radiogroup" aria-label="Voting method">
              <label class="btn" style="display:flex; align-items:center; gap:8px;">
                <input type="radio" name="voting" value="majority" checked style="accent-color: var(--accent);" aria-label="Majority voting"> Majority
              </label>
              <label class="btn" style="display:flex; align-items:center; gap:8px;">
                <input type="radio" name="voting" value="weighted" style="accent-color: var(--accent);" aria-label="Weighted voting"> Weighted
              </label>
            </div>
          </div>
        </div>

        <div class="control-row" style="align-items:center;">
          <div style="flex:1;">
            <label for="classSelect">Point class to add</label>
            <select id="classSelect" class="btn" aria-label="Class to add">
              <option value="0">Blue class</option>
              <option value="1">Pink class</option>
              <option value="2">Yellow class</option>
            </select>
          </div>

          <div style="display:flex; gap:8px;">
            <button id="randomBtn" class="btn" title="Add random points">Add random</button>
            <button id="clearBtn" class="btn" title="Clear all points">Clear</button>
            <button id="resetBtn" class="btn primary" title="Reset example">Reset example</button>
          </div>
        </div>

        <div class="status" aria-live="polite">
          <div class="small">Query prediction:</div>
          <div id="prediction" class="value-box">—</div>
        </div>

        <div class="legend" aria-hidden="false">
          <div class="item"><div class="color-swatch" style="background: #4aa3ff"></div> Class 0 (blue)</div>
          <div class="item"><div class="color-swatch" style="background: #ff73c5"></div> Class 1 (pink)</div>
          <div class="item"><div class="color-swatch" style="background: #ffd56a"></div> Class 2 (yellow)</div>
          <div class="item" style="margin-left:auto;"><div class="color-swatch" style="background: #40d47e"></div> Query point</div>
        </div>

      </div>
    </aside>

    <!-- Right interactive canvas + small helper row -->
    <main class="canvas-panel" aria-labelledby="canvasTitle">
      <div id="canvasTitle" class="muted">Interactive plot (click to add). Drag points or the green query point.</div>

      <div class="canvas-area" id="canvasArea">
        <canvas id="plot" width="900" height="640" role="img" aria-label="KNN plot"></canvas>
      </div>

      <div style="display:flex; gap:12px; align-items:center; justify-content:space-between;">
        <div class="hint">Tip: Press <kbd style="background:#071827;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.03)">R</kbd> to reset. Use keyboard to focus controls.</div>
        <div style="display:flex; gap:8px;">
          <button id="toggleBoundary" class="btn" aria-pressed="true">Show regions</button>
          <button id="toggleLines" class="btn" aria-pressed="true">Show neighbor lines</button>
        </div>
      </div>
    </main>
  </div>

  <script>
  /* KNN Interactive Module — Vanilla JS
     Features:
     - 2D canvas with draggable data points (multiple classes)
     - Movable query point (green) to see predicted class
     - Adjustable K, distance metric, and weighted voting
     - Background region rendering approximated by sampling grid
     - Animated lines to the K nearest neighbors and pulsing neighbor circles
  */

  (function () {
    // Canvas and layout
    const canvas = document.getElementById('plot');
    const ctx = canvas.getContext('2d', { alpha: false });

    const container = document.getElementById('canvasArea');

    // Controls
    const kRange = document.getElementById('kRange');
    const kValue = document.getElementById('kValue');
    const metricSelect = document.getElementById('metric');
    const votingRadios = document.getElementsByName('voting');
    const classSelect = document.getElementById('classSelect');
    const randomBtn = document.getElementById('randomBtn');
    const clearBtn = document.getElementById('clearBtn');
    const resetBtn = document.getElementById('resetBtn');
    const predictionBox = document.getElementById('prediction');
    const toggleBoundaryBtn = document.getElementById('toggleBoundary');
    const toggleLinesBtn = document.getElementById('toggleLines');

    // Colors for classes
    const CLASS_COLORS = ['#4aa3ff', '#ff73c5', '#ffd56a'];
    const QUERY_COLOR = '#40d47e';
    const BG_COLORS = CLASS_COLORS.map(hexToRgb); // arrays of [r,g,b]

    // State
    let state = {
      points: [], // {x: 0..1, y:0..1, cls: 0..n-1}
      query: { x: 0.5, y: 0.5 },
      dragging: null, // {type:'point'|'query', index}
      showRegions: true,
      showLines: true,
      animateTick: 0,
    };

    // Canvas rendering settings
    let DPR = Math.max(1, window.devicePixelRatio || 1);

    // Ensure spacing and responsive canvas sizing
    function resizeCanvasToDisplaySize() {
      const style = getComputedStyle(canvas);
      const width = Math.floor(canvas.clientWidth * DPR);
      const height = Math.floor(canvas.clientHeight * DPR);
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
    }

    // Utility: hex to RGB array
    function hexToRgb(hex) {
      const h = hex.replace('#','');
      const bigint = parseInt(h,16);
      return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
    }

    function lerp(a,b,t) { return a + (b-a) * t; }

    // Convert normalized coordinates to pixel coordinates on canvas
    function toPixel(pos) {
      return {
        x: Math.round(pos.x * canvas.width),
        y: Math.round(pos.y * canvas.height),
      };
    }

    function toNormalized(px, py) {
      return { x: px / canvas.width, y: py / canvas.height };
    }

    // Default example points initializer
    function seedExample() {
      state.points = [
        {x: 0.18, y: 0.22, cls: 0},
        {x: 0.14, y: 0.68, cls: 0},
        {x: 0.28, y: 0.45, cls: 0},
        {x: 0.6, y: 0.28, cls: 1},
        {x: 0.68, y: 0.25, cls: 1},
        {x: 0.72, y: 0.48, cls: 1},
        {x: 0.6, y: 0.72, cls: 2},
        {x: 0.84, y: 0.74, cls: 2},
        {x: 0.48, y: 0.86, cls: 2},
      ];
      state.query = { x: 0.46, y: 0.46 };
    }

    // K and controls initialization
    function getK() { return Math.max(1, parseInt(kRange.value,10)); }
    function getMetric() { return metricSelect.value; }
    function getWeighted() { return Array.from(votingRadios).find(r=>r.checked).value === 'weighted'; }

    kRange.addEventListener('input', () => {
      kValue.textContent = kRange.value;
      requestRender();
    });

    metricSelect.addEventListener('change', () => requestRender());
    votingRadios.forEach(r => r.addEventListener('change', () => requestRender()));
    classSelect.addEventListener('change', () => { /* no-op */ });

    randomBtn.addEventListener('click', () => {
      // Add 6 random points across classes
      for (let i=0;i<6;i++) {
        state.points.push({
          x: Math.random() * 0.9 + 0.05,
          y: Math.random() * 0.9 + 0.05,
          cls: i % CLASS_COLORS.length
        });
      }
      requestRender();
    });

    clearBtn.addEventListener('click', () => {
      state.points = [];
      requestRender();
    });

    resetBtn.addEventListener('click', () => {
      seedExample();
      requestRender();
    });

    toggleBoundaryBtn.addEventListener('click', () => {
      state.showRegions = !state.showRegions;
      toggleBoundaryBtn.setAttribute('aria-pressed', String(state.showRegions));
      toggleBoundaryBtn.classList.toggle('primary', state.showRegions);
      requestRender();
    });

    toggleLinesBtn.addEventListener('click', () => {
      state.showLines = !state.showLines;
      toggleLinesBtn.setAttribute('aria-pressed', String(state.showLines));
      toggleLinesBtn.classList.toggle('primary', state.showLines);
      requestRender();
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') {
        seedExample();
        requestRender();
      }
    });

    // Canvas interactions: add points, drag
    let pointerDown = false;

    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      const clientX = (evt.clientX !== undefined) ? evt.clientX : (evt.touches && evt.touches[0].clientX);
      const clientY = (evt.clientY !== undefined) ? evt.clientY : (evt.touches && evt.touches[0].clientY);
      const px = (clientX - rect.left) * DPR;
      const py = (clientY - rect.top) * DPR;
      return toNormalized(px, py);
    }

    function findNearbyPoint(normPos, radius = 0.03) {
      let best = -1, bestDist = Infinity;
      for (let i=0;i<state.points.length;i++) {
        const p = state.points[i];
        const dx = p.x - normPos.x;
        const dy = p.y - normPos.y;
        const d = Math.hypot(dx, dy);
        if (d < radius && d < bestDist) { best = i; bestDist = d; }
      }
      // Check query point separately (slightly larger)
      const qdx = state.query.x - normPos.x;
      const qdy = state.query.y - normPos.y;
      const qd = Math.hypot(qdx, qdy);
      if (qd < radius * 1.3) {
        return { type: 'query' };
      }
      return best >= 0 ? { type: 'point', index: best } : null;
    }

    canvas.addEventListener('pointerdown', (e) => {
      pointerDown = true;
      canvas.setPointerCapture(e.pointerId);
      const pos = getMousePos(e);
      const hit = findNearbyPoint(pos);
      if (hit) {
        if (hit.type === 'query') {
          state.dragging = { type: 'query' };
        } else {
          state.dragging = { type: 'point', index: hit.index };
        }
      } else {
        // Add new point of selected class
        const cls = parseInt(classSelect.value,10) || 0;
        state.points.push({ x: pos.x, y: pos.y, cls });
      }
      requestRender();
    });

    canvas.addEventListener('pointermove', (e) => {
      if (!pointerDown) return;
      const pos = getMousePos(e);
      if (state.dragging) {
        if (state.dragging.type === 'query') {
          state.query.x = Math.min(0.995, Math.max(0.005, pos.x));
          state.query.y = Math.min(0.995, Math.max(0.005, pos.y));
        } else if (state.dragging.type === 'point') {
          const idx = state.dragging.index;
          if (state.points[idx]) {
            state.points[idx].x = Math.min(0.995, Math.max(0.005, pos.x));
            state.points[idx].y = Math.min(0.995, Math.max(0.005, pos.y));
          }
        }
        requestRender();
      }
    });

    canvas.addEventListener('pointerup', (e) => {
      pointerDown = false;
      state.dragging = null;
      canvas.releasePointerCapture(e.pointerId);
    });

    // Double click to remove a point
    canvas.addEventListener('dblclick', (e) => {
      const pos = getMousePos(e);
      const hit = findNearbyPoint(pos, 0.03);
      if (hit && hit.type === 'point') {
        state.points.splice(hit.index, 1);
        requestRender();
      }
    });

    // Distance functions
    function distance(a, b, metric) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      if (metric === 'euclidean') return Math.hypot(dx, dy);
      if (metric === 'manhattan') return Math.abs(dx) + Math.abs(dy);
      if (metric === 'chebyshev') return Math.max(Math.abs(dx), Math.abs(dy));
      return Math.hypot(dx, dy);
    }

    // KNN predict: return {label, probs, neighbors:[{index,dist}]}
    function knnPredict(query, points, K, metric, weighted) {
      if (points.length === 0) return { label: null, probs: [], neighbors: [] };
      // Compute distances
      const arr = points.map((p,i) => ({ index: i, dist: distance(query, p, metric), cls: p.cls }));
      arr.sort((a,b) => a.dist - b.dist);
      const neighbors = arr.slice(0, Math.min(K, arr.length));
      // Voting
      const counts = new Map();
      neighbors.forEach(n => {
        const cls = n.cls;
        const w = (weighted ? (n.dist === 0 ? 1e6 : 1 / (n.dist + 1e-6)) : 1);
        counts.set(cls, (counts.get(cls) || 0) + w);
      });
      // Normalize to probabilities
      const total = Array.from(counts.values()).reduce((s,v) => s+v, 0) || 1;
      const probs = [];
      for (let i=0;i<CLASS_COLORS.length;i++) {
        probs[i] = (counts.get(i) || 0) / total;
      }
      // Choose the highest
      let bestCls = null, bestVal = -Infinity;
      for (const [cls, val] of counts) {
        if (val > bestVal) { bestVal = val; bestCls = cls; }
      }
      return { label: bestCls, probs, neighbors };
    }

    // Background region rendering using sampling grid
    function renderBackground() {
      if (!state.showRegions) return;
      const step = Math.max(6, Math.round(canvas.width / 140)); // adapt sample density with size
      // For each sample cell paint small rectangle
      for (let y = 0; y < canvas.height; y += step) {
        for (let x = 0; x < canvas.width; x += step) {
          const norm = toNormalized(x + 0.5, y + 0.5);
          const res = knnPredict(norm, state.points, getK(), getMetric(), getWeighted());
          const cls = res.label;
          if (cls === null) {
            ctx.fillStyle = 'rgba(4,8,12,0.05)';
          } else {
            const rgb = BG_COLORS[cls];
            // color intensity based on probability
            const prob = res.probs[cls] || 0;
            const alpha = 0.12 + 0.6 * Math.min(1, prob);
            ctx.fillStyle = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${alpha})`;
          }
          ctx.fillRect(x, y, step, step);
        }
      }
    }

    // Draw data points and query
    function renderPoints() {
      for (let i=0;i<state.points.length;i++) {
        const p = state.points[i];
        const pos = toPixel(p);
        // Pulsing animation for neighbors (if included)
        ctx.beginPath();
        ctx.fillStyle = CLASS_COLORS[p.cls];
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1 * DPR;
        ctx.arc(pos.x + 0.5, pos.y + 0.5, 8 * DPR, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();

        // Inner dot
        ctx.beginPath();
        ctx.fillStyle = '#071827';
        ctx.arc(pos.x + 0.5, pos.y + 0.5, 4 * DPR, 0, Math.PI*2);
        ctx.fill();
      }

      // Query point
      const qpos = toPixel(state.query);
      ctx.beginPath();
      ctx.fillStyle = QUERY_COLOR;
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 1 * DPR;
      ctx.arc(qpos.x + 0.5, qpos.y + 0.5, 10 * DPR, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // Small white center
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.arc(qpos.x + 0.5, qpos.y + 0.5, 3 * DPR, 0, Math.PI*2);
      ctx.fill();
    }

    // Draw lines to K neighbors and highlight neighbor circles
    function renderNeighborLines(predict) {
      if (!state.showLines) return;
      const neighbors = predict.neighbors || [];
      const qpix = toPixel(state.query);
      // Animate alpha and pulsing using tick
      const t = (state.animateTick % 1000) / 1000;
      neighbors.forEach((n,i) => {
        const p = state.points[n.index];
        const pp = toPixel(p);
        // line
        ctx.beginPath();
        ctx.moveTo(qpix.x + 0.5, qpix.y + 0.5);
        ctx.lineTo(pp.x + 0.5, pp.y + 0.5);
        const baseAlpha = 0.9 * (1 - i / Math.max(1, neighbors.length));
        ctx.strokeStyle = `rgba(255,255,255,${(0.12 + 0.5*baseAlpha)})`;
        ctx.lineWidth = Math.max(1, (3 - i * 0.2) * DPR);
        ctx.stroke();

        // pulsing neighbor circle overlay
        const pulse = 1 + 0.25 * Math.sin((state.animateTick / 320) + i);
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 2 * DPR;
        ctx.arc(pp.x + 0.5, pp.y + 0.5, (10 * DPR) * pulse, 0, Math.PI*2);
        ctx.stroke();

        // small inner highlight
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.arc(pp.x + 0.5, pp.y + 0.5, 5 * DPR, 0, Math.PI*2);
        ctx.fill();
      });
    }

    // Overlay info: text prediction and probabilities
    function renderPredictionInfo(predict) {
      // Text in top-left corner
      const margin = 12 * DPR;
      const lineH = 18 * DPR;
      ctx.font = `${14 * DPR}px system-ui, -apple-system, 'Segoe UI', Roboto`;
      ctx.textBaseline = 'top';
      // Background box
      ctx.fillStyle = 'rgba(2,6,12,0.36)';
      ctx.fillRect(margin - 6, margin - 6, 220 * DPR, 72 * DPR);
      // Title
      ctx.fillStyle = '#dff4ff';
      const label = (predict.label === null) ? 'No data' : `Predicted: Class ${predict.label}`;
      ctx.fillText(label, margin, margin);
      // Probabilities bars
      const barsX = margin;
      let y = margin + 20 * DPR;
      for (let i=0;i<CLASS_COLORS.length;i++) {
        const prob = (predict.probs && predict.probs[i]) ? predict.probs[i] : 0;
        // small swatch
        ctx.fillStyle = CLASS_COLORS[i];
        ctx.fillRect(barsX, y, 10 * DPR, 10 * DPR);
        // bar background
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.fillRect(barsX + 16 * DPR, y, 160 * DPR, 10 * DPR);
        // bar foreground
        ctx.fillStyle = CLASS_COLORS[i];
        ctx.fillRect(barsX + 16 * DPR, y, Math.max(2, prob * 160) * DPR, 10 * DPR);
        // percent text
        ctx.fillStyle = '#e6eef8';
        ctx.font = `${12 * DPR}px system-ui`;
        ctx.fillText(`${Math.round(prob * 100)}%`, barsX + 182 * DPR, y);
        y += 16 * DPR;
      }
    }

    // Main render pass
    function render() {
      resizeCanvasToDisplaySize();
      state.animateTick += 16;
      // Clear with background color
      ctx.fillStyle = '#06121a';
      ctx.fillRect(0,0,canvas.width, canvas.height);

      // Background regions
      renderBackground();

      // Prediction
      const predict = knnPredict(state.query, state.points, getK(), getMetric(), getWeighted());

      // Lines to neighbors
      renderNeighborLines(predict);

      // Points and query
      renderPoints();

      // Prediction info overlay
      renderPredictionInfo(predict);

      // Update textual prediction box for screen-reader friendly content
      if (predict.label === null) {
        predictionBox.textContent = 'No points';
      } else {
        const topProb = predict.probs[predict.label] || 0;
        predictionBox.textContent = `Class ${predict.label} — ${Math.round(topProb*100)}%`;
      }
    }

    // Throttled rendering
    let scheduled = false;
    function requestRender() {
      if (!scheduled) {
        scheduled = true;
        requestAnimationFrame(() => {
          render();
          scheduled = false;
        });
      }
    }

    // Animation loop for subtle updates (pulsing, lines)
    function animateLoop() {
      state.animateTick += 16;
      requestRender();
      requestAnimationFrame(animateLoop);
    }

    // Initial setup
    function init() {
      DPR = Math.max(1, window.devicePixelRatio || 1);
      // Size canvas responsively to container
      function fit() {
        // Set canvas CSS size to container area
        const rect = container.getBoundingClientRect();
        // Reserve padding: canvas should fill the area
        canvas.style.width = (rect.width - 24) + 'px';
        canvas.style.height = (rect.height - 24) + 'px';
        resizeCanvasToDisplaySize();
        requestRender();
      }
      window.addEventListener('resize', fit);
      fit();

      // seed
      seedExample();
      kValue.textContent = kRange.value;

      requestRender();
      requestAnimationFrame(animateLoop);
    }

    init();

  })();
  </script>
</body>
</html>