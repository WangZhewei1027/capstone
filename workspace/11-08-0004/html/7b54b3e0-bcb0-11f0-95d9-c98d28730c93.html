<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dijkstra’s Algorithm — Interactive Module</title>
  <style>
    :root{
      --bg:#f6f8fb;
      --panel:#ffffff;
      --accent:#2463ff;
      --muted:#6b7280;
      --success:#16a34a;
      --danger:#ef4444;
      --shadow: 0 6px 18px rgba(20,24,40,0.08);
      --safe-margin:24px;
      --gap:16px;
      --node-radius:20;
    }

    /* Safe area margins */
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#f6f8fb 0%, #eef3ff 100%);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:#0f1724;
    }

    .app {
      box-sizing:border-box;
      padding:var(--safe-margin);
      min-height:100vh;
      display:flex;
      gap:var(--gap);
    }

    /* Layout: left panel (text+controls), right panel (canvas) */
    .panel {
      background:var(--panel);
      border-radius:12px;
      padding:18px;
      box-shadow:var(--shadow);
    }

    .left {
      width:360px;
      max-width:40%;
      min-width:300px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    .right {
      flex:1;
      min-width:320px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      align-items:stretch;
    }

    h1{
      font-size:20px;
      margin:0 0 6px 0;
      line-height:1.2;
    }

    .muted {
      color:var(--muted);
      font-size:13px;
      margin:0 0 8px 0;
    }

    .section{
      border-radius:8px;
      padding:12px;
      background:linear-gradient(180deg, rgba(36,99,255,0.04), rgba(36,99,255,0.01));
      border:1px solid rgba(36,99,255,0.08);
    }

    .controls {
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .row {
      display:flex;
      gap:12px;
      align-items:center;
    }

    button {
      background:var(--panel);
      border:1px solid rgba(15,23,36,0.06);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      color:#08203a;
      transition:all .12s ease;
    }
    button:hover{ transform:translateY(-1px); box-shadow:0 6px 20px rgba(16,24,40,0.06); }
    .primary{
      background:var(--accent);
      color:white;
      border:none;
    }
    .danger{
      background:var(--danger);
      color:white;
      border:none;
    }
    .ghost{
      background:transparent;
      border:1px dashed rgba(15,23,36,0.06);
    }

    .small {
      padding:6px 8px;
      font-size:13px;
      border-radius:6px;
    }

    label{ font-size:13px; color:var(--muted); }

    /* Canvas container */
    .canvas-wrap{
      position:relative;
      flex:1;
      min-height:420px;
      border-radius:12px;
      overflow:hidden;
      background:linear-gradient(180deg,#fff 0%, #fbfdff 100%);
      border:1px solid rgba(2,6,23,0.04);
      display:flex;
      flex-direction:column;
    }

    /* toolbar above canvas */
    .toolbar{
      display:flex;
      gap:12px;
      align-items:center;
      padding:12px;
      border-bottom:1px solid rgba(2,6,23,0.03);
      background:transparent;
    }

    .toolbar .info{
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:8px;
      align-items:center;
    }

    /* svg full area */
    svg {
      width:100%;
      height:100%;
      touch-action:none;
      user-select:none;
      background:transparent;
      display:block;
    }

    /* Nodes & edges styling */
    .edge {
      stroke:#cbd5e1;
      stroke-width:3;
      fill:none;
      transition:stroke 0.2s, stroke-width 0.15s;
    }

    .edge.highlight {
      stroke:var(--accent);
      stroke-width:4.5;
      filter:drop-shadow(0 6px 14px rgba(36,99,255,0.14));
    }

    .edge.traversing {
      stroke:linear-gradient(#2463ff,#60a5fa);
    }

    .node {
      cursor:pointer;
      transition:transform .12s, stroke .12s, fill .12s;
    }

    .node circle {
      fill:#ffffff;
      stroke:#0f1724;
      stroke-opacity:0.06;
      stroke-width:1.5;
      transition:fill .12s, stroke 0.12s;
      r:var(--node-radius);
    }

    .node .label {
      font-size:12px;
      text-anchor:middle;
      dominant-baseline:middle;
      pointer-events:none;
      fill:#0f1724;
    }

    .node .dist {
      font-size:11px;
      text-anchor:middle;
      fill:var(--muted);
      dominant-baseline:text-after-edge;
      pointer-events:none;
    }

    .node.source circle{
      fill:linear-gradient(180deg,#e7f0ff,#f1f6ff);
      stroke:var(--accent);
      stroke-width:2.5;
      filter:drop-shadow(0 10px 18px rgba(36,99,255,0.08));
    }

    .node.target circle{
      stroke:var(--danger);
      stroke-width:2.2;
      filter:drop-shadow(0 8px 18px rgba(239,68,68,0.06));
    }

    .node.visited circle{
      fill:#f8fafc;
      stroke:rgba(16,185,129,0.9);
      stroke-width:2;
      filter:drop-shadow(0 8px 18px rgba(16,185,129,0.06));
    }

    .node.pulse circle{
      animation:nodePulse 0.9s ease;
    }

    @keyframes nodePulse {
      from{ transform:scale(1); }
      50%{ transform:scale(1.08); }
      to{ transform:scale(1); }
    }

    .edge-weight {
      font-size:11px;
      fill:#0f1724;
      background:white;
    }

    .pq {
      font-family:monospace;
      font-size:13px;
      color:var(--muted);
      padding:10px;
      background:rgba(2,6,23,0.03);
      border-radius:8px;
      display:flex;
      gap:6px;
      flex-wrap:wrap;
    }

    .status {
      font-size:13px;
      color:var(--muted);
    }

    /* modal for edge weight */
    .modal {
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background:var(--panel);
      padding:12px;
      border-radius:10px;
      box-shadow:var(--shadow);
      z-index:30;
      min-width:240px;
    }

    input[type="number"], input[type="text"]{
      padding:8px;
      border-radius:8px;
      border:1px solid rgba(2,6,23,0.06);
      width:100%;
      box-sizing:border-box;
    }

    /* responsive */
    @media (max-width:920px){
      .app { padding:16px; flex-direction:column; }
      .left { width:auto; max-width:100%; min-width:auto; }
    }

    /* spacing constraints for accessibility */
    .left .panel, .right .panel{
      margin-bottom:var(--gap);
    }

    /* small helper */
    .muted-note { font-size:12px; color:var(--muted); }

    /* highlight shortest path */
    .edge.path {
      stroke:#10b981;
      stroke-width:5;
      filter:drop-shadow(0 8px 20px rgba(16,185,129,0.09));
    }

  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Dijkstra interactive module">
    <!-- LEFT: description + controls -->
    <div class="panel left" style="display:flex; flex-direction:column;">
      <div>
        <h1>Interactive: Dijkstra’s Algorithm</h1>
        <p class="muted">Explore shortest paths on a weighted graph with step-by-step animation.</p>
      </div>

      <div class="section" aria-labelledby="objective-heading">
        <strong id="objective-heading">Learning Objective</strong>
        <p class="muted-note" style="margin-top:8px;">
          After interacting you'll understand how Dijkstra selects the next node,
          relaxes edges, updates tentative distances, and constructs the shortest-path tree.
        </p>
      </div>

      <div class="section">
        <strong>Interaction Design</strong>
        <ol style="margin:8px 0 0 18px; color:var(--muted); font-size:13px;">
          <li>Click "Sample Graph" to load a ready example or add nodes by clicking the canvas.</li>
          <li>Use "Add Edge" then click two nodes to create a weighted edge (positive weights only).</li>
          <li>Set a source (start) and optionally a target node to see the final path highlighted.</li>
          <li>Use "Step" to advance one relaxation/visit step, or "Play" to animate automatically.</li>
          <li>Watch node fills, edge highlights, and the priority queue update to build intuition.</li>
        </ol>
      </div>

      <div class="section controls" aria-label="Controls">
        <div class="row">
          <button id="sampleBtn" class="small">Sample Graph</button>
          <button id="addNodeBtn" class="small">Add Node</button>
          <button id="addEdgeBtn" class="small">Add Edge</button>
        </div>

        <div class="row">
          <button id="setSourceBtn" class="small">Set Source</button>
          <button id="setTargetBtn" class="small">Set Target</button>
          <button id="clearBtn" class="small ghost">Clear</button>
        </div>

        <div class="row" style="align-items:center;">
          <button id="stepBtn" class="primary small" aria-label="Step">Step</button>
          <button id="playBtn" class="small" aria-pressed="false" title="Play / Pause">Play</button>
          <button id="resetBtn" class="small">Reset</button>
          <label style="margin-left:auto; font-size:13px;" for="speed">Speed</label>
          <input id="speed" type="range" min="0.25" max="2" step="0.25" value="1" style="width:110px;">
        </div>

        <div class="row" style="align-items:center;">
          <div style="flex:1;">
            <div style="font-size:13px; margin-bottom:6px;">Algorithm Status</div>
            <div id="statusText" class="status">Idle. Load a graph and choose a source.</div>
          </div>
        </div>

        <div style="display:flex; gap:8px; align-items:center;">
          <div style="font-size:13px;">Priority Queue</div>
          <div id="pqView" class="pq" aria-live="polite" style="flex:1;"></div>
        </div>

        <div style="font-size:12px; color:var(--muted); margin-top:6px;">
          Tips: click a node to select it. Drag nodes to reposition. Press Space to toggle play/pause.
        </div>
      </div>

      <div class="section" aria-hidden="false">
        <strong>Layout Description</strong>
        <p class="muted-note" style="margin-top:8px;">
          Left panel: title, objectives, controls (fixed width, vertical). Right panel: interactive SVG canvas and canvas toolbar.
          Safe area margins are 24px; minimum spacing between interactive elements is 16px. The canvas is responsive and accessible.
        </p>
      </div>

    </div>

    <!-- RIGHT: canvas -->
    <div class="panel right" style="padding:0; display:flex; flex-direction:column;">
      <div class="toolbar" role="toolbar" aria-label="Canvas toolbar">
        <div class="info">
          <svg width="18" height="18" viewBox="0 0 24 24" style="opacity:0.9;">
            <circle cx="12" cy="12" r="10" fill="#eaf2ff" />
            <path d="M7 16L11 10L17 14" fill="none" stroke="#2463ff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          <div style="font-size:14px; font-weight:600;">Graph Canvas</div>
        </div>
        <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
          <div class="muted" id="modeIndicator">Mode: <span id="modeText">Idle</span></div>
        </div>
      </div>

      <div class="canvas-wrap" id="canvasWrap" style="position:relative;">
        <!-- modal for edge weight -->
        <div id="modal" class="modal" style="display:none;" role="dialog" aria-modal="true">
          <div style="font-weight:700; margin-bottom:8px;">Edge Weight</div>
          <input id="weightInput" type="number" min="0.1" step="0.1" value="1" aria-label="Edge weight">
          <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">
            <button id="modalCancel" class="small">Cancel</button>
            <button id="modalOk" class="small primary">OK</button>
          </div>
        </div>

        <!-- SVG -->
        <svg id="svgCanvas" tabindex="0" aria-label="Graph canvas" focusable="true">
          <defs>
            <marker id="arrow" viewBox="0 0 10 10" refX="7" refY="5"
                    markerWidth="6" markerHeight="6" orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#cbd5e1"/>
            </marker>
          </defs>
        </svg>

      </div>
    </div>
  </div>

  <script>
    /*****************************************************************
     * Dijkstra Interactive Module (vanilla JS)
     * - Single-page self-contained implementation
     * - Create nodes by clicking 'Add Node' then click canvas; or load sample
     * - Add edges by 'Add Edge' then click two nodes; set weight in modal
     * - Set source and target nodes; Step or Play to execute algorithm
     *****************************************************************/

    (function(){
      // Utility helpers
      const $ = (id)=>document.getElementById(id);
      const svg = $('svgCanvas');
      const canvasWrap = $('canvasWrap');
      const modeText = $('modeText');
      const statusText = $('statusText');
      const pqView = $('pqView');
      const modal = $('modal');
      const weightInput = $('weightInput');

      // State
      let nodes = []; // {id, x, y, label, dist, prev, visited}
      let edges = []; // {id, a, b, weight, lineElem, textElem}
      let nodeIdCounter = 0;
      let edgeIdCounter = 0;

      let mode = 'idle'; // 'idle','addNode','addEdge','setSource','setTarget','dragging'
      let addEdgeState = {first:null};
      let selectedNode = null;
      let sourceNode = null;
      let targetNode = null;

      // Algorithm runtime state
      let running = false;
      let autoTimer = null;
      let speed = 1; // multiplier: lower is faster
      let pq = []; // array of node ids, used as priority queue by dist
      let actionsQueue = []; // for step-by-step: queue of actions generated by algorithm

      // DOM elements for controls
      const sampleBtn = $('sampleBtn');
      const addNodeBtn = $('addNodeBtn');
      const addEdgeBtn = $('addEdgeBtn');
      const setSourceBtn = $('setSourceBtn');
      const setTargetBtn = $('setTargetBtn');
      const clearBtn = $('clearBtn');
      const stepBtn = $('stepBtn');
      const playBtn = $('playBtn');
      const resetBtn = $('resetBtn');
      const speedInput = $('speed');

      // Initialize
      function init(){
        svg.addEventListener('mousedown', onSvgMouseDown);
        svg.addEventListener('mousemove', onSvgMouseMove);
        svg.addEventListener('mouseup', onSvgMouseUp);
        svg.addEventListener('click', onSvgClick);
        svg.addEventListener('keydown', onSvgKeyDown);
        window.addEventListener('resize', redraw);

        sampleBtn.addEventListener('click', loadSampleGraph);
        addNodeBtn.addEventListener('click', ()=>setMode('addNode'));
        addEdgeBtn.addEventListener('click', ()=>setMode('addEdge'));
        setSourceBtn.addEventListener('click', ()=>setMode('setSource'));
        setTargetBtn.addEventListener('click', ()=>setMode('setTarget'));
        clearBtn.addEventListener('click', clearAll);
        stepBtn.addEventListener('click', step);
        playBtn.addEventListener('click', togglePlay);
        resetBtn.addEventListener('click', resetAlgorithm);
        speedInput.addEventListener('input', ()=> speed = 1 / parseFloat(speedInput.value)); // invert so slider 2 is slower

        $('modalOk').addEventListener('click', onModalOk);
        $('modalCancel').addEventListener('click', ()=>hideModal());

        // keyboard play/pause
        document.addEventListener('keydown', (e)=>{
          if(e.code === 'Space'){
            e.preventDefault();
            togglePlay();
          }
        });

        // initial sample
        loadSampleGraph();
        updateModeDisplay();
      }

      /* ---------- Rendering ---------- */

      function redraw(){
        // clear svg elements and rebuild
        while (svg.lastChild) svg.removeChild(svg.lastChild);

        // re-add defs
        const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
        defs.innerHTML = '<marker id="arrow" viewBox="0 0 10 10" refX="7" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#cbd5e1"/></marker>';
        svg.appendChild(defs);

        // edges below nodes
        edges.forEach(e=>{
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', e.ax);
          line.setAttribute('y1', e.ay);
          line.setAttribute('x2', e.bx);
          line.setAttribute('y2', e.by);
          line.setAttribute('class','edge');
          line.setAttribute('stroke-linecap','round');
          line.setAttribute('data-id', e.id);
          line.setAttribute('marker-end','url(#arrow)');
          svg.appendChild(line);
          e.lineElem = line;

          // weight label (midpoint)
          const tx = (e.ax + e.bx) / 2;
          const ty = (e.ay + e.by) / 2;
          const text = document.createElementNS('http://www.w3.org/2000/svg','text');
          text.setAttribute('x', tx);
          text.setAttribute('y', ty - 8);
          text.setAttribute('class','edge-weight');
          text.setAttribute('text-anchor','middle');
          text.textContent = e.weight;
          svg.appendChild(text);
          e.textElem = text;

          // bring text above line
        });

        // nodes
        nodes.forEach(n=>{
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('class','node');
          g.setAttribute('transform',`translate(${n.x},${n.y})`);
          g.setAttribute('data-id', n.id);
          g.setAttribute('tabindex','0');
          g.setAttribute('role','button');
          g.addEventListener('mousedown', onNodeMouseDown);
          g.addEventListener('click', onNodeClick);
          g.addEventListener('dblclick', onNodeDblClick);
          g.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter') onNodeClick(ev); });

          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circle.setAttribute('r', parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-radius')) || 20);
          g.appendChild(circle);

          const label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('class','label');
          label.setAttribute('y', -2);
          label.textContent = n.label || n.id;
          g.appendChild(label);

          const dist = document.createElementNS('http://www.w3.org/2000/svg','text');
          dist.setAttribute('class','dist');
          dist.setAttribute('y', 18);
          dist.textContent = n.dist==Infinity ? '∞' : n.dist.toFixed(1);
          g.appendChild(dist);

          svg.appendChild(g);
          n.g = g;
          n.circle = circle;
          n.distText = dist;

          refreshNodeAppearance(n);
        });
      }

      function refreshEdgeAppearance(e){
        // classes: highlight, path
        if(!e.lineElem) return;
        e.lineElem.classList.toggle('highlight', !!e.highlight);
        e.lineElem.classList.toggle('path', !!e.path);
      }

      function refreshNodeAppearance(n){
        if(!n.g) return;
        const g = n.g;
        g.classList.toggle('source', n.id === sourceNode?.id);
        g.classList.toggle('target', n.id === targetNode?.id);
        g.classList.toggle('visited', !!n.visited);
        g.classList.toggle('pulse', !!n.pulsing);
        // update distance text
        n.distText.textContent = n.dist==Infinity ? '∞' : n.dist.toFixed(1);
      }

      function setMode(m){
        mode = m;
        addEdgeState.first = null;
        selectedNode = null;
        updateModeDisplay();
      }

      function updateModeDisplay(){
        modeText.textContent = mode;
        // visual hints
        const btns = [addNodeBtn, addEdgeBtn, setSourceBtn, setTargetBtn];
        btns.forEach(b => b.classList.remove('primary'));
        if(mode === 'addNode') addNodeBtn.classList.add('primary');
        if(mode === 'addEdge') addEdgeBtn.classList.add('primary');
        if(mode === 'setSource') setSourceBtn.classList.add('primary');
        if(mode === 'setTarget') setTargetBtn.classList.add('primary');
      }

      /* ---------- Interactions ---------- */

      function onSvgClick(e){
        const pt = clientToSvg(e.clientX, e.clientY);
        if(mode === 'addNode'){
          addNode(pt.x, pt.y);
          setMode('idle');
        }
      }

      function onSvgMouseDown(e){
        // for dragging nodes: handled in node mousedown
      }

      function onSvgMouseMove(e){
        // dragging node?
        if(mode === 'dragging' && selectedNode){
          const pt = clientToSvg(e.clientX, e.clientY);
          selectedNode.x = pt.x;
          selectedNode.y = pt.y;
          selectedNode.g.setAttribute('transform',`translate(${selectedNode.x},${selectedNode.y})`);
          // update connected edges positions
          edges.forEach(ed=>{
            if(ed.a === selectedNode.id || ed.b === selectedNode.id){
              updateEdgeCoords(ed);
            }
          });
        }
      }

      function onSvgMouseUp(e){
        if(mode === 'dragging'){
          setMode('idle');
        }
      }

      function onSvgKeyDown(e){
        // placeholder
      }

      function onNodeMouseDown(e){
        e.stopPropagation();
        const id = parseInt(this.getAttribute('data-id'));
        const node = findNode(id);
        // start dragging
        selectedNode = node;
        setMode('dragging');
      }

      function onNodeClick(e){
        e.stopPropagation();
        const id = parseInt(this.getAttribute('data-id'));
        const node = findNode(id);

        if(mode === 'addEdge'){
          if(!addEdgeState.first){
            addEdgeState.first = node;
            statusText.textContent = `Pick second node to connect from "${node.label}".`;
          } else if(addEdgeState.first && addEdgeState.first.id === node.id){
            statusText.textContent = 'Cannot connect node to itself. Choose another node.';
          } else {
            // show modal to input weight
            showModal('Create edge', (value)=>{
              const w = parseFloat(value);
              if(isNaN(w) || w <= 0){
                statusText.textContent = 'Weight must be positive.';
                return false;
              }
              createEdge(addEdgeState.first, node, w);
              addEdgeState.first = null;
              setMode('idle');
              statusText.textContent = 'Edge created.';
              return true;
            });
          }
        } else if(mode === 'setSource'){
          sourceNode = node;
          resetAlgorithm(true);
          statusText.textContent = `Source set to "${node.label}".`;
          setMode('idle');
        } else if(mode === 'setTarget'){
          targetNode = node;
          resetAlgorithm(true);
          statusText.textContent = `Target set to "${node.label}".`;
          setMode('idle');
        } else {
          // plain click: select for info
          statusText.textContent = `Node ${node.label}. Dist: ${node.dist==Infinity ? '∞' : node.dist.toFixed(1)}.`;
        }
      }

      function onNodeDblClick(e){
        e.stopPropagation();
        const id = parseInt(this.getAttribute('data-id'));
        const node = findNode(id);
        const newLabel = prompt('Label for node', node.label || ('N' + node.id));
        if(newLabel !== null){
          node.label = newLabel;
          redraw();
        }
      }

      /* ---------- Node / Edge management ---------- */

      function addNode(x,y,label){
        const id = ++nodeIdCounter;
        const n = {
          id, x, y, label: label || String.fromCharCode(64 + (id % 26 || 26)),
          dist: Infinity, prev: null, visited:false, pulsing:false
        };
        nodes.push(n);
        redraw();
        statusText.textContent = `Added node "${n.label}".`;
      }

      function createEdge(n1,n2,w){
        // store coordinates copies for fast redraw
        const e = {
          id: ++edgeIdCounter,
          a: n1.id,
          b: n2.id,
          weight: +w,
          ax: n1.x, ay: n1.y, bx: n2.x, by: n2.y,
          highlight:false, path:false
        };
        edges.push(e);
        redraw();
      }

      function updateEdgeCoords(e){
        const nA = findNode(e.a);
        const nB = findNode(e.b);
        e.ax = nA.x; e.ay = nA.y; e.bx = nB.x; e.by = nB.y;
        if(e.lineElem){
          e.lineElem.setAttribute('x1', e.ax);
          e.lineElem.setAttribute('y1', e.ay);
          e.lineElem.setAttribute('x2', e.bx);
          e.lineElem.setAttribute('y2', e.by);
        }
        if(e.textElem){
          const tx = (e.ax + e.bx) / 2;
          const ty = (e.ay + e.by) / 2;
          e.textElem.setAttribute('x', tx);
          e.textElem.setAttribute('y', ty - 8);
        }
      }

      function findNode(id){ return nodes.find(n=>n.id===id); }
      function findEdge(a,b){ return edges.find(e=> (e.a===a && e.b===b) || (e.a===b && e.b===a)); }

      function clearAll(){
        nodes = []; edges = []; nodeIdCounter = 0; edgeIdCounter = 0;
        sourceNode = null; targetNode = null;
        addEdgeState.first = null;
        resetAlgorithm(true);
        redraw();
        statusText.textContent = 'Cleared graph.';
      }

      /* ---------- Modal ---------- */

      let modalCallback = null;
      function showModal(title, callback){
        modal.style.display = 'block';
        weightInput.value = '1';
        weightInput.focus();
        modalCallback = callback;
      }
      function hideModal(){
        modal.style.display = 'none';
        modalCallback = null;
      }
      function onModalOk(){
        const val = weightInput.value;
        if(modalCallback) {
          const ok = modalCallback(val);
          if(ok) hideModal();
        } else hideModal();
      }

      /* ---------- Sample Graph ---------- */

      function loadSampleGraph(){
        clearAll();
        // place nodes in a hex layout
        const W = svg.clientWidth || canvasWrap.clientWidth || 800;
        const H = Math.max(420, svg.clientHeight || 480);
        const cx = W/2, cy = H/2;
        const positions = [
          {x:cx-160,y:cy-40},
          {x:cx-80,y:cy-110},
          {x:cx+10,y:cy-40},
          {x:cx+120,y:cy-10},
          {x:cx+10,y:cy+80},
          {x:cx-120,y:cy+70}
        ];
        positions.forEach((p, i)=> addNode(p.x,p.y, String.fromCharCode(65+i)));
        // create edges with weights
        const lookup = (label)=> nodes.find(n=>n.label===label);
        createEdge(lookup('A'), lookup('B'), 7);
        createEdge(lookup('A'), lookup('C'), 9);
        createEdge(lookup('A'), lookup('F'), 14);
        createEdge(lookup('B'), lookup('C'), 10);
        createEdge(lookup('B'), lookup('D'), 15);
        createEdge(lookup('C'), lookup('D'), 11);
        createEdge(lookup('C'), lookup('F'), 2);
        createEdge(lookup('D'), lookup('E'), 6);
        createEdge(lookup('E'), lookup('F'), 9);

        // set default source
        sourceNode = nodes[0];
        targetNode = nodes[3];
        resetAlgorithm(true);
        statusText.textContent = 'Sample graph loaded. Source A, target D.';
        redraw();
      }

      /* ---------- Dijkstra Algorithm (step-by-step) ---------- */

      function resetAlgorithm(skipVisualReset){
        // reset runtime state: dist, prev, visited
        nodes.forEach(n=>{
          n.dist = Infinity;
          n.prev = null;
          n.visited = false;
          n.pulsing = false;
        });
        edges.forEach(e=>{
          e.highlight = false;
          e.path = false;
        });
        pq = [];
        actionsQueue = [];
        running = false;
        if(autoTimer) { clearInterval(autoTimer); autoTimer = null; playBtn.textContent = 'Play'; playBtn.setAttribute('aria-pressed','false'); }

        if(sourceNode){
          sourceNode.dist = 0;
          pqPush(sourceNode);
        }
        if(!skipVisualReset) redraw();
        updatePriorityQueueView();
      }

      // minimal PQ helpers (not optimized, fine for demo)
      function pqPush(node){
        if(!pq.includes(node)){
          pq.push(node);
        }
      }

      function pqPop(){
        // pop node with min dist and not visited
        let minIdx = -1;
        let minVal = Infinity;
        for(let i=0;i<pq.length;i++){
          if(pq[i].dist < minVal && !pq[i].visited){
            minVal = pq[i].dist;
            minIdx = i;
          }
        }
        if(minIdx === -1) return null;
        const node = pq.splice(minIdx,1)[0];
        return node;
      }

      function updatePriorityQueueView(){
        pqView.innerHTML = '';
        const list = pq.slice().sort((a,b)=>a.dist - b.dist);
        list.forEach(n=>{
          const el = document.createElement('div');
          el.textContent = `${n.label}:${n.dist==Infinity ? '∞' : n.dist.toFixed(1)}`;
          pqView.appendChild(el);
        });
      }

      function step(){
        // If actionsQueue has pending actions (edge relax animations), consume them first
        if(actionsQueue.length > 0){
          const act = actionsQueue.shift();
          performAction(act);
          return;
        }

        // otherwise, pick next node from pq
        const u = pqPop();
        if(!u){
          statusText.textContent = 'Algorithm finished.';
          running = false;
          if(autoTimer) { clearInterval(autoTimer); autoTimer = null; playBtn.textContent='Play'; playBtn.setAttribute('aria-pressed','false'); }
          highlightFinalPath();
          return;
        }

        // visit u
        u.visited = true;
        u.pulsing = true;
        refreshNodeAppearance(u);
        statusText.textContent = `Visiting ${u.label} (dist=${u.dist==Infinity ? '∞' : u.dist.toFixed(1)})`;
        // add action to stop pulsation after short time
        actionsQueue.push({type:'stopPulse', nodeId:u.id});

        // for each neighbor, relax edges
        const neighbors = edges.filter(e=>e.a===u.id || e.b===u.id).map(e=>{
          const vid = e.a===u.id ? e.b : e.a;
          return {edge:e, neighbor: findNode(vid)};
        });

        neighbors.forEach(pair=>{
          actionsQueue.push({type:'relax', edgeId:pair.edge.id, fromId:u.id, toId:pair.neighbor.id});
        });

        updatePriorityQueueView();
      }

      function performAction(act){
        if(act.type==='stopPulse'){
          const n = findNode(act.nodeId);
          if(n){ n.pulsing = false; refreshNodeAppearance(n); }
          return;
        }
        if(act.type==='relax'){
          const edge = edges.find(e=>e.id===act.edgeId);
          const a = findNode(act.fromId);
          const b = findNode(act.toId);
          // highlight edge traveling
          edge.highlight = true;
          refreshEdgeAppearance(edge);
          // animate line stroke by temporarily increasing stroke width and color
          if(edge.lineElem){
            edge.lineElem.classList.add('highlight');
            // after short timeout, perform relax logic
            setTimeout(()=>{
              // compute alt
              const alt = a.dist + edge.weight;
              if(alt < b.dist){
                b.dist = alt;
                b.prev = a.id;
                pqPush(b);
                // visually mark update: pulse neighbor
                b.pulsing = true;
                refreshNodeAppearance(b);
                // schedule stop pulse after timeout
                setTimeout(()=>{ b.pulsing = false; refreshNodeAppearance(b); }, 700);
                statusText.textContent = `Relax: improved ${b.label} to ${b.dist.toFixed(1)} via ${a.label}`;
              } else {
                statusText.textContent = `Relax: no improvement for ${b.label} (alt=${alt.toFixed(1)})`;
              }
              // un-highlight edge after animation
              edge.highlight = false;
              refreshEdgeAppearance(edge);
              updatePriorityQueueView();
            }, 360 * (1 / speed));
          }
          return;
        }
      }

      function togglePlay(){
        if(running){
          running = false;
          if(autoTimer){ clearInterval(autoTimer); autoTimer = null; }
          playBtn.textContent = 'Play';
          playBtn.setAttribute('aria-pressed','false');
          statusText.textContent = 'Paused.';
        } else {
          running = true;
          playBtn.textContent = 'Pause';
          playBtn.setAttribute('aria-pressed','true');
          statusText.textContent = 'Running...';
          autoTimer = setInterval(()=>{
            // each tick advance one step
            step();
          }, 600 * (1 / speed));
        }
      }

      function highlightFinalPath(){
        // from target back to source, mark edges as path
        edges.forEach(e=>{ e.path = false; refreshEdgeAppearance(e); });
        if(!sourceNode || !targetNode) return;
        let cur = targetNode;
        if(cur.prev === null){
          statusText.textContent += ' (no path to target)';
          return;
        }
        let pathNodes = [];
        while(cur && cur.prev !== null){
          pathNodes.push(cur);
          const prev = findNode(cur.prev);
          const e = findEdge(cur.id, prev.id);
          if(e){ e.path = true; refreshEdgeAppearance(e); }
          cur = prev;
        }
        if(cur) pathNodes.push(cur);
        statusText.textContent += ' Final path highlighted.';
      }

      /* ---------- Utility ---------- */

      function clientToSvg(clientX, clientY){
        const pt = svg.createSVGPoint();
        pt.x = clientX; pt.y = clientY;
        const ctm = svg.getScreenCTM().inverse();
        const sp = pt.matrixTransform(ctm);
        return {x:sp.x, y:sp.y};
      }

      // expose for debugging
      window._dbg = { nodes, edges, redraw };

      // start
      init();
    })();
  </script>
</body>
</html>