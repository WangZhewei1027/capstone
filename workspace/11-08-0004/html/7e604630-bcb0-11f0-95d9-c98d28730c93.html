<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Counting Sort — Interactive Module</title>
  <style>
    /*
      Safe area 24px on all sides, min spacing 16px between interactive elements.
      Responsive, accessible, no external assets.
    */

    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --success: #10b981;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.03);
      --max-width: 1200px;
      --control-height: 40px;
      --radius: 10px;
      --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071028 0%, #021121 100%);
      color: #e6eef8;
      font-family: var(--font-sans);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .app{
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100%;
      display:flex;
      justify-content:center;
    }

    .container{
      width:100%;
      max-width: var(--max-width);
      display:grid;
      grid-template-columns: 380px 1fr;
      grid-gap: var(--gap);
      align-items:start;
    }

    /* Left panel: textual explanation and controls */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.6);
      min-height: 320px;
    }

    .title{
      font-size: 18px;
      font-weight:700;
      margin:0 0 8px 0;
      color: #dff9ff;
    }

    .sub{
      font-size:13px;
      color: var(--muted);
      margin:0 0 14px 0;
      line-height:1.4;
    }

    .section{
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom:1px solid rgba(255,255,255,0.03);
    }

    .section h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:#bfefff;
      font-weight:600;
    }

    .section p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:12px;
      margin-top:12px;
    }

    .row{
      display:flex;
      gap:var(--gap);
      align-items:center;
    }

    label{
      font-size:13px;
      color:var(--muted);
    }

    input[type="text"], .slider, select{
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.04);
      color: #e6eef8;
      padding:8px 10px;
      border-radius:8px;
      height: var(--control-height);
      font-size:13px;
      outline:none;
    }

    input[type="text"]:focus, select:focus{
      box-shadow:0 4px 18px rgba(6,182,212,0.06);
      border-color: var(--accent);
    }

    .button{
      background: linear-gradient(90deg, rgba(6,182,212,0.12), rgba(16,185,129,0.06));
      color: var(--accent);
      border:1px solid rgba(6,182,212,0.06);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      height: var(--control-height);
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }

    .button.ghost{
      background:transparent;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.03);
    }

    .button:disabled{
      opacity:0.45;
      cursor:not-allowed;
    }

    .control-row{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }

    .small{
      font-size:12px;
      color:var(--muted);
    }

    /* Right panel: interactive visualization */
    .viz{
      min-height: 520px;
      background: linear-gradient(180deg, rgba(255,255,255,0.015), transparent);
      border-radius: var(--radius);
      padding:20px;
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:16px;
      overflow:hidden;
    }

    .viz-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }

    .viz-title{
      font-size:15px;
      font-weight:700;
      color:#dcfaff;
    }

    .viz-sub{
      font-size:13px;
      color:var(--muted);
    }

    .canvas{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:18px;
      padding:8px;
    }

    /* Rows: Input, Counts, Output */
    .row-area{
      background: rgba(255,255,255,0.02);
      border-radius:10px;
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:80px;
    }

    .row-label{
      font-size:13px;
      color:var(--muted);
      margin-bottom:6px;
    }

    .bars{
      display:flex;
      gap:12px;
      align-items:end;
      min-height:72px;
      padding:4px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }

    /* bar item */
    .bar{
      position:relative;
      width:44px;
      min-width:44px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      transition: transform 360ms cubic-bezier(.22,.9,.4,1), opacity 240ms;
      cursor:default;
    }

    .bar .rect{
      width:100%;
      border-radius:8px 8px 4px 4px;
      background: linear-gradient(180deg,#07a1b3 0%, #064f67 100%);
      display:flex;
      align-items:flex-end;
      justify-content:center;
      color:#e7fbff;
      font-weight:700;
      font-size:12px;
      padding-bottom:6px;
      box-shadow: 0 6px 16px rgba(2,10,22,0.5);
      transition: transform 240ms, box-shadow 240ms;
    }

    .bar[data-role="count"] .rect{
      background: linear-gradient(180deg,#334155 0%, #0b1220 100%);
      color: #cfe7f3;
      font-weight:700;
      font-size:13px;
      padding:6px 4px;
      box-shadow:none;
      border:1px solid rgba(255,255,255,0.02);
      min-height:34px;
    }

    .bar.highlight .rect{
      transform: translateY(-8px) scale(1.03);
      box-shadow: 0 12px 30px rgba(6,182,212,0.12);
    }

    .bar.muted{
      opacity:0.36;
    }

    .bar .value{
      pointer-events:none;
      user-select:none;
      font-size:12px;
    }

    .count-index{
      position:absolute;
      top:-18px;
      font-size:12px;
      color:var(--muted);
      left:50%;
      transform:translateX(-50%);
    }

    /* Output cells (placeholder positions) */
    .output-cells{
      display:flex;
      gap:12px;
      align-items:center;
      padding:4px;
      overflow:auto;
    }

    .cell{
      width:44px;
      min-width:44px;
      height:54px;
      border-radius:8px;
      background: rgba(255,255,255,0.02);
      border:1px dashed rgba(255,255,255,0.03);
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--muted);
      font-size:13px;
    }

    .cell.filled{
      border-style:solid;
      background: linear-gradient(180deg,#042b37, #023140);
      color:#dcfcff;
      font-weight:700;
    }

    /* playback controls */
    .playback{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:flex-end;
      margin-top:4px;
    }

    .speed{
      width:160px;
    }

    .legend{
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }

    /* small animations for bucket increments */
    @keyframes pulse {
      0% { transform: scale(1); background-color: rgba(255,255,255,0.02); }
      50% { transform: scale(1.08); background-color: rgba(6,182,212,0.08); }
      100% { transform: scale(1); background-color: rgba(255,255,255,0.02); }
    }

    .bucket-pulse .rect{
      animation: pulse 420ms ease;
    }

    /* responsive */
    @media (max-width:980px){
      .container{ grid-template-columns: 1fr; }
      .panel{ order:2; }
      .viz{ order:1; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Counting Sort interactive module">
    <div class="container" role="region" aria-label="Main content">
      <!-- Left panel: textual sections + controls -->
      <div class="panel" aria-labelledby="panel-title">
        <h1 class="title" id="panel-title">Counting Sort — Interactive Module</h1>
        <p class="sub">Visual, step-by-step exploration of Counting Sort. Edit the input, set the range, then step through or autoplay the algorithm to watch items counted, buckets formed, cumulative counts computed, and elements placed into the sorted output (stable).</p>

        <div class="section" aria-label="Learning objective">
          <h3>Learning Objective</h3>
          <p>After interacting with this module you will: (1) understand how Counting Sort counts occurrences into buckets, (2) see how cumulative counts determine output indices, and (3) observe how the algorithm places elements to produce a stable, sorted array.</p>
        </div>

        <div class="section" aria-label="Interaction design">
          <h3>Interaction Design</h3>
          <p>Controls let you edit the input array (comma-separated integers), randomize values, and adjust the maximum key/range. Use Step to advance the algorithm one micro-step (counting each element, updating cumulative buckets, placing items); Play to animate automatically. Speed slider adjusts animation pace. Visual feedback includes animated bucket increments, highlighted bars during counting and placement, and smooth movement of bars into output slots for clear cause-and-effect mapping.</p>
        </div>

        <div class="section" aria-label="Layout description">
          <h3>Layout Description</h3>
          <p>The left column contains textual explanations and controls. The right column displays the interactive visualization: three stacked rows labeled Input → Count Buckets → Output. All interactive elements use at least 16px spacing; the page keeps 24px safe margins. Visual elements scale to available width for accessibility and mobile responsiveness. Buttons and inputs include high-contrast focus styles for keyboard navigation.</p>
        </div>

        <div class="section" aria-label="Controls">
          <h3>Controls</h3>

          <div class="controls" role="form" aria-label="Controls for configuring counting sort">
            <div style="display:flex;gap:12px;align-items:center;">
              <label for="input-array" class="small" style="min-width:70px;">Array</label>
              <input id="input-array" type="text" aria-label="Comma separated input array" value="4,2,2,8,3,3,1" />
            </div>

            <div style="display:flex;gap:12px;align-items:center;">
              <label for="max-value" class="small" style="min-width:70px;">Max value</label>
              <input id="max-value" type="number" min="0" value="8" style="width:110px;" aria-label="Maximum key value for buckets" />
              <div style="flex:1;"></div>
              <button id="apply" class="button" aria-label="Apply array and range">Apply</button>
            </div>

            <div class="control-row">
              <button id="randomize" class="button ghost" aria-label="Randomize array">Randomize</button>
              <button id="shuffle" class="button ghost" aria-label="Shuffle array">Shuffle</button>
              <button id="reset" class="button ghost" aria-label="Reset to initial">Reset</button>
            </div>

            <div style="display:flex;gap:12px;align-items:center;">
              <label class="small" for="speed">Speed</label>
              <input id="speed" type="range" min="200" max="1500" value="700" class="speed" aria-label="Animation speed" />
              <span class="small" id="speed-label">700 ms</span>
            </div>

            <div style="display:flex;gap:8px;align-items:center;">
              <button id="step" class="button" aria-label="Step one operation">Step</button>
              <button id="play" class="button" aria-label="Play or pause auto run">Play</button>
              <button id="fast-reset" class="button ghost" aria-label="Reset visualization">Reset Visual</button>
              <div style="flex:1"></div>
              <div class="small legend" aria-hidden="true">
                <span style="display:inline-flex;align-items:center;gap:8px;"><span style="width:12px;height:12px;background:#07a1b3;border-radius:3px;display:inline-block;"></span> Input bars</span>
                <span style="display:inline-flex;align-items:center;gap:8px;"><span style="width:12px;height:12px;background:#334155;border-radius:3px;display:inline-block;"></span> Buckets</span>
                <span style="display:inline-flex;align-items:center;gap:8px;"><span style="width:12px;height:12px;background:#042b37;border-radius:3px;display:inline-block;"></span> Output</span>
              </div>
            </div>
          </div>
        </div>

      </div>

      <!-- Right panel: visualization -->
      <div class="viz" aria-live="polite">
        <div class="viz-header">
          <div>
            <div class="viz-title">Counting Sort Visualization</div>
            <div class="viz-sub">Watch how counts → cumulative counts → placements produce a stable sorted array.</div>
          </div>

          <div style="display:flex;gap:12px;align-items:center;">
            <div class="small" id="status">Status: Idle</div>
          </div>
        </div>

        <div class="canvas" role="region" aria-label="Visualization area">
          <!-- Input row -->
          <div class="row-area" aria-label="Input array">
            <div class="row-label">Input array (left → right)</div>
            <div id="input-bars" class="bars" tabindex="0" aria-label="Input bars region"></div>
          </div>

          <!-- Count buckets row -->
          <div class="row-area" aria-label="Count buckets">
            <div class="row-label">Count buckets (index labeled above)</div>
            <div id="buckets" class="bars" tabindex="0" aria-label="Buckets region"></div>
          </div>

          <!-- Output row -->
          <div class="row-area" aria-label="Output array">
            <div class="row-label">Output array (filled left → right)</div>
            <div id="output-cells" class="output-cells" tabindex="0" aria-label="Output cells"></div>
          </div>

        </div>

      </div>

    </div>
  </div>

  <script>
    /*
      Counting Sort Interactive Module
      - No external libraries
      - Step-mode micro-operations: count, cumulative, place
      - Animations:
          * bucket increment pulse
          * bar highlight
          * animate movement of bars into output via cloned element and transform
    */

    (function(){
      // DOM references
      const inputField = document.getElementById('input-array');
      const maxValueInput = document.getElementById('max-value');
      const applyBtn = document.getElementById('apply');
      const randomBtn = document.getElementById('randomize');
      const shuffleBtn = document.getElementById('shuffle');
      const resetBtn = document.getElementById('reset');
      const stepBtn = document.getElementById('step');
      const playBtn = document.getElementById('play');
      const fastResetBtn = document.getElementById('fast-reset');
      const speedInput = document.getElementById('speed');
      const speedLabel = document.getElementById('speed-label');
      const status = document.getElementById('status');

      const inputBars = document.getElementById('input-bars');
      const bucketsEl = document.getElementById('buckets');
      const outputCells = document.getElementById('output-cells');

      // State
      let originalArray = parseInput(inputField.value);
      let arr = originalArray.slice();
      let maxValue = clampNumber(parseInt(maxValueInput.value,10) || 0, 0, 1000);
      let counts = [];
      let cumulative = [];
      let steps = []; // list of operations
      let stepIndex = 0;
      let playing = false;
      let timer = null;
      let animSpeed = parseInt(speedInput.value,10);
      let outputArr = [];

      // Accessibility: announce status changes
      function setStatus(text){
        status.textContent = 'Status: ' + text;
      }

      // Utility functions
      function clampNumber(n,min,max){
        if(isNaN(n)) return min;
        return Math.max(min, Math.min(max, n));
      }

      function parseInput(text){
        let parts = text.split(',').map(s=>s.trim()).filter(s=>s.length>0);
        let values = parts.map(s=>{
          let n = parseInt(s,10);
          return isNaN(n)?0:n;
        });
        return values.slice(0,60); // limit to reasonable length
      }

      function clearChildren(el){
        while(el.firstChild) el.removeChild(el.firstChild);
      }

      function createBar(value, opts={}){
        // opts: role: 'input'|'count'|'output', index: number
        const bar = document.createElement('div');
        bar.className = 'bar';
        if(opts.role==='count') bar.dataset.role='count';
        if(opts.role) bar.setAttribute('data-role', opts.role);
        bar.setAttribute('data-value', String(value));
        if(typeof opts.index !== 'undefined') bar.setAttribute('data-index', String(opts.index));
        const indexLabel = document.createElement('div');
        indexLabel.className='count-index';
        if(typeof opts.index !== 'undefined') indexLabel.textContent = opts.index;
        else indexLabel.textContent = '';
        const rect = document.createElement('div');
        rect.className = 'rect';
        const valEl = document.createElement('div');
        valEl.className='value';
        valEl.textContent = String(value);
        rect.appendChild(valEl);
        bar.appendChild(rect);
        if(opts.showIndex) bar.appendChild(indexLabel);
        return bar;
      }

      function renderAll(){
        // input bars
        clearChildren(inputBars);
        arr.forEach((v,i)=>{
          const b = createBar(v, {role:'input', index:i, showIndex:false});
          b.tabIndex = 0;
          b.setAttribute('aria-label', 'Input element index ' + i + ' value ' + v);
          inputBars.appendChild(b);
        });

        // buckets
        clearChildren(bucketsEl);
        for(let i=0;i<=maxValue;i++){
          const c = createBar(0, {role:'count', index:i, showIndex:true});
          c.querySelector('.value').textContent = '0';
          c.setAttribute('aria-label', 'Bucket ' + i + ' count 0');
          bucketsEl.appendChild(c);
        }

        // output cells placeholders
        clearChildren(outputCells);
        for(let i=0;i<arr.length;i++){
          const cell = document.createElement('div');
          cell.className='cell';
          cell.setAttribute('data-index', String(i));
          cell.setAttribute('aria-label','Output cell ' + i + ' empty');
          cell.textContent = '';
          outputCells.appendChild(cell);
        }

        setStatus('Ready');
      }

      // Build steps for counting sort: micro-operations
      function buildSteps(){
        steps = [];
        counts = new Array(maxValue+1).fill(0);

        // Counting phase: for each element in arr left->right create an op
        for(let i=0;i<arr.length;i++){
          steps.push({type:'count', index:i, value:arr[i]});
        }

        // Cumulative phase: we'll animate updating cumulative counts left to right
        // Build steps to set cumulative array progressively
        // After counting we'll have counts[]; but we want to show intermediate cumulative updates
        steps.push({type:'calc-cumulative-start'});

        // Placement phase: to be computed after we have counts, we will add operations for placing elements
        // We'll add a placeholder op that will be handled after counting and cumulative computed
        steps.push({type:'place-start'});
      }

      // Apply array and range
      function applyConfig(){
        const parsed = parseInput(inputField.value);
        originalArray = parsed.slice();
        arr = originalArray.slice();
        maxValue = clampNumber(parseInt(maxValueInput.value,10) || 0, 0, 1000);
        if(maxValue < 0) maxValue = 0;
        if(maxValue < Math.max(...arr,0)) {
          // expand range so that max value accommodates elements
          maxValue = Math.max(...arr);
          maxValueInput.value = String(maxValue);
        }
        buildSteps();
        stepIndex = 0;
        outputArr = new Array(arr.length).fill(null);
        renderAll();
      }

      // Randomize
      function randomizeArray(){
        const len = Math.max(4, Math.min(20, Math.floor(Math.random()*8)+5));
        const maxCandidate = Math.max(5, Math.floor(Math.random()*12)+3);
        arr = [];
        for(let i=0;i<len;i++){
          arr.push(Math.floor(Math.random()*(maxCandidate+1)));
        }
        inputField.value = arr.join(',');
        maxValueInput.value = String(Math.max(...arr, maxCandidate));
        applyConfig();
      }

      // Shuffle
      function shuffleArray(){
        for(let i=arr.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [arr[i],arr[j]]=[arr[j],arr[i]];
        }
        inputField.value = arr.join(',');
        applyConfig();
      }

      // Reset to original
      function resetToOriginal(){
        arr = originalArray.slice();
        inputField.value = arr.join(',');
        applyConfig();
      }

      // Visual helpers: update bucket count display
      function updateBucketDisplay(index, value){
        const bucket = bucketsEl.querySelector('.bar[data-index="'+index+'"]');
        if(!bucket) return;
        bucket.querySelector('.value').textContent = String(value);
        bucket.setAttribute('aria-label','Bucket ' + index + ' count ' + value);
      }

      // Pulse bucket (visual feedback)
      function pulseBucket(index){
        const bucket = bucketsEl.querySelector('.bar[data-index="'+index+'"]');
        if(!bucket) return;
        bucket.classList.add('bucket-pulse');
        setTimeout(()=>bucket.classList.remove('bucket-pulse'), 420);
      }

      // Highlight input bar
      function highlightInputBar(i, on=true){
        const bar = inputBars.querySelector('.bar:nth-child(' + (i+1) + ')');
        if(!bar) return;
        if(on) bar.classList.add('highlight');
        else bar.classList.remove('highlight');
      }

      // Mute other bars
      function setMutedAll(muted){
        const bars = inputBars.querySelectorAll('.bar');
        bars.forEach(b=> {
          if(muted) b.classList.add('muted');
          else b.classList.remove('muted');
        });
      }

      // Animate placing element from input index to output cell targetIndex
      function animatePlace(inputIndex, value, targetIndex){
        return new Promise(resolve=>{
          const fromBar = inputBars.querySelector('.bar:nth-child(' + (inputIndex+1) + ')');
          if(!fromBar){
            // fallback: create a temporary visual element
            const temp = createBar(value, {role:'input'});
            document.body.appendChild(temp);
            temp.style.position='fixed';
            temp.style.left='10px';
            temp.style.top='10px';
            setTimeout(()=>{ temp.remove(); resolve(); }, animSpeed);
            return;
          }

          // create a clone to animate
          const rect = fromBar.getBoundingClientRect();
          const targetCell = outputCells.querySelector('.cell[data-index="'+targetIndex+'"]');
          const targetRect = targetCell.getBoundingClientRect();

          const clone = fromBar.cloneNode(true);
          clone.style.position = 'fixed';
          clone.style.left = rect.left + 'px';
          clone.style.top = rect.top + 'px';
          clone.style.width = rect.width + 'px';
          clone.style.margin = '0';
          clone.style.zIndex = 9999;
          clone.style.pointerEvents = 'none';
          clone.querySelector('.rect').style.boxShadow = '0 18px 36px rgba(2,8,22,0.6)';
          document.body.appendChild(clone);

          // Hide original visually for duration
          fromBar.style.visibility = 'hidden';

          // compute translate
          const dx = (targetRect.left + (targetRect.width/2)) - (rect.left + (rect.width/2));
          const dy = (targetRect.top + (targetRect.height/2)) - (rect.top + (rect.height/2));

          clone.style.transition = 'transform ' + (animSpeed) + 'ms cubic-bezier(.22,.9,.4,1), opacity 200ms';
          clone.style.transformOrigin = 'center';
          // trigger
          requestAnimationFrame(()=>{
            clone.style.transform = 'translate3d(' + dx + 'px,' + dy + 'px,0) scale(0.96)';
            clone.style.opacity = '0.98';
          });

          // after animation ends
          setTimeout(()=>{
            // remove clone
            clone.remove();
            // reveal original removed and update output cell
            fromBar.style.visibility = '';
            // add element to output cell visually
            fillOutputCell(targetIndex, value);
            resolve();
          }, animSpeed + 30);
        });
      }

      function fillOutputCell(index, value){
        const cell = outputCells.querySelector('.cell[data-index="'+index+'"]');
        if(!cell) return;
        cell.classList.add('filled');
        cell.textContent = String(value);
        cell.setAttribute('aria-label', 'Output cell ' + index + ' value ' + value);
      }

      // Execute a single step operation
      async function doStep(){
        if(stepIndex >= steps.length){
          setStatus('Finished');
          return;
        }

        const op = steps[stepIndex];
        switch(op.type){
          case 'count':
            setStatus('Counting element at index ' + op.index + ' (value ' + op.value + ')');
            highlightInputBar(op.index,true);
            // increment bucket
            counts[op.value] = (counts[op.value] || 0) + 1;
            updateBucketDisplay(op.value, counts[op.value]);
            pulseBucket(op.value);
            await delay(animSpeed * 0.6);
            highlightInputBar(op.index,false);
            stepIndex++;
            break;

          case 'calc-cumulative-start':
            setStatus('Computing cumulative counts');
            // compute cumulative from counts
            cumulative = new Array(counts.length).fill(0);
            let running = 0;
            // We'll create micro-ops to show sequential updates
            const cumOps = [];
            for(let i=0;i<counts.length;i++){
              running += (counts[i]||0);
              cumOps.push({type:'cumulative', index:i, value:running});
            }
            // inject cumOps into steps, replacing current op
            steps.splice(stepIndex, 1, ...cumOps);
            // do not increment stepIndex here
            break;

          case 'cumulative':
            setStatus('Cumulative update bucket ' + op.index + ' = ' + op.value);
            cumulative[op.index] = op.value;
            // display cumulative value in bucket visually (overwrite)
            updateBucketDisplay(op.index, op.value);
            // animate a small highlight
            pulseBucket(op.index);
            await delay(animSpeed * 0.45);
            stepIndex++;
            break;

          case 'place-start':
            // After cumulative computed, we must prepare placement operations
            setStatus('Preparing placements (stable)');
            // Copy cumulative to compute target positions. We will place from right to left (stable)
            const tempCum = cumulative.slice();
            // Since in classic counting sort we decrement to find position, we'll compute positions for each arr element iterating right->left
            const placeOps = [];
            for(let i=arr.length-1;i>=0;i--){
              const v = arr[i];
              tempCum[v] = tempCum[v] - 1;
              const targetIndex = tempCum[v];
              placeOps.push({type:'place', index:i, value:v, target:targetIndex});
            }
            // insert into steps in place of current op
            steps.splice(stepIndex, 1, ...placeOps);
            break;

          case 'place':
            setStatus('Placing element index ' + op.index + ' value ' + op.value + ' → output[' + op.target + ']');
            // visually highlight input bar
            highlightInputBar(op.index,true);
            await animatePlace(op.index, op.value, op.target);
            highlightInputBar(op.index,false);
            // mark counts updated visually (decrement)
            // We'll update the bucket display for the value to show how many remain (optional)
            counts[op.value] = Math.max(0, (counts[op.value]||0) - 1);
            updateBucketDisplay(op.value, counts[op.value]);
            pulseBucket(op.value);
            await delay(80);
            stepIndex++;
            break;

          default:
            stepIndex++;
            break;
        }
      }

      function delay(ms){ return new Promise(res=>setTimeout(res, ms)); }

      // Play/pause logic
      function startPlaying(){
        if(playing) return;
        playing = true;
        playBtn.textContent = 'Pause';
        setStatus('Playing');
        const loop = async ()=>{
          if(!playing) return;
          if(stepIndex >= steps.length){
            stopPlaying();
            setStatus('Finished');
            return;
          }
          await doStep();
          // schedule next loop
          if(playing){
            timer = setTimeout(loop, 80);
          }
        };
        loop();
      }

      function stopPlaying(){
        playing = false;
        playBtn.textContent = 'Play';
        clearTimeout(timer);
      }

      function resetVisualOnly(){
        // reset visual to initial state but keep configuration same
        arr = originalArray.slice();
        buildSteps();
        stepIndex = 0;
        outputArr = new Array(arr.length).fill(null);
        renderAll();
        setStatus('Reset visual');
      }

      // Wiring controls
      applyBtn.addEventListener('click', ()=>{
        applyConfig();
      });

      randomBtn.addEventListener('click', ()=>{
        randomizeArray();
      });

      shuffleBtn.addEventListener('click', ()=>{
        shuffleArray();
      });

      resetBtn.addEventListener('click', ()=>{
        resetToOriginal();
      });

      fastResetBtn.addEventListener('click', ()=>{
        resetVisualOnly();
      });

      stepBtn.addEventListener('click', async ()=>{
        if(playing){
          stopPlaying();
        }
        // ensure steps exist
        if(steps.length===0){
          buildSteps();
        }
        await doStep();
      });

      playBtn.addEventListener('click', ()=>{
        if(playing) stopPlaying();
        else startPlaying();
      });

      speedInput.addEventListener('input', ()=>{
        animSpeed = parseInt(speedInput.value,10);
        speedLabel.textContent = animSpeed + ' ms';
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e)=>{
        if(e.key === ' ') { // toggle play/pause
          e.preventDefault();
          if(playing) stopPlaying(); else startPlaying();
        } else if(e.key === 'ArrowRight'){
          e.preventDefault();
          stepBtn.click();
        } else if(e.key === 'r' && (e.ctrlKey || e.metaKey)){
          e.preventDefault();
          resetToOriginal();
        }
      });

      // Initialize
      animSpeed = parseInt(speedInput.value,10);
      speedLabel.textContent = animSpeed + ' ms';
      applyConfig();

      // Expose some debug to console for learning
      window.countingSortViz = {
        getState: ()=>({arr, counts, cumulative, steps, stepIndex}),
        step: ()=>stepBtn.click(),
        play: ()=>playBtn.click(),
        reset: ()=>resetBtn.click()
      };

      // Provide an initial gentle instruction (aria)
      setStatus('Ready — edit array or click Play / Step to begin');
    })();
  </script>
</body>
</html>