<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kruskal’s Algorithm — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #38bdf8;
      --muted: #94a3b8;
      --success: #10b981;
      --danger: #ef4444;
      --highlight: #f59e0b;
      --glass: rgba(255,255,255,0.04);
      --radius: 10px;
    }

    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#021026 0%, #071226 100%);
      color:#e6eef6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Safe area */
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    header{
      display:flex;
      align-items: start;
      justify-content: space-between;
      gap: var(--gap);
      flex-wrap:wrap;
    }

    .title {
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
      color: #e6f0ff;
    }

    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* Main content layout */
    .main {
      display: flex;
      gap: var(--gap);
      align-items: stretch;
    }

    /* Left column: description + controls */
    .left {
      width: 360px;
      min-width: 280px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding: var(--gap);
      box-sizing: border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      border: 1px solid rgba(255,255,255,0.04);
    }

    .section-title {
      font-weight:600;
      font-size:13px;
      color:#dbeafe;
      margin-bottom:4px;
    }

    .card {
      background: rgba(255,255,255,0.01);
      padding:12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.02);
      color:var(--muted);
      font-size:13px;
      line-height:1.3;
    }

    .controls {
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .row {
      display:flex;
      gap:12px;
      align-items:center;
    }

    button {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      color:var(--accent);
      border:1px solid rgba(255,255,255,0.04);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
      transition:transform .12s ease, box-shadow .12s ease;
    }

    button:hover { transform: translateY(-2px); }
    button:active { transform: translateY(0); }

    .btn-primary {
      background: linear-gradient(180deg,#075985,#0ea5e9);
      color:white;
      border: none;
    }

    .btn-ghost {
      background: transparent;
      color: var(--muted);
      border: 1px dashed rgba(255,255,255,0.03);
    }

    .small {
      padding:6px 8px;
      font-size:12px;
      border-radius:6px;
    }

    label {
      font-size:12px;
      color:var(--muted);
    }

    .status {
      background: linear-gradient(180deg,#061829,#071226);
      border-radius:8px;
      padding:10px;
      font-size:13px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.02);
    }

    .legend {
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:13px;
    }

    .dot {
      width:12px;height:12px;border-radius:3px;
      display:inline-block;margin-right:8px;
    }

    /* Right column: interactive canvas */
    .right {
      flex:1;
      min-height:640px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding: var(--gap);
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      border: 1px solid rgba(255,255,255,0.04);
    }

    .canvas-wrap {
      position:relative;
      flex:1;
      display:flex;
      gap:var(--gap);
      min-height:320px;
      border-radius:8px;
      overflow:hidden;
      background: linear-gradient(180deg, rgba(8,18,30,0.6), rgba(2,6,23,0.6));
      border:1px solid rgba(255,255,255,0.02);
    }

    svg {
      width:100%;
      height:100%;
      display:block;
      touch-action: none;
    }

    .toolbar {
      display:flex;
      gap:12px;
      align-items:center;
      justify-content: space-between;
    }

    .info {
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }

    /* Node and edge styles */
    .node {
      cursor:grab;
      transition:transform .08s linear;
    }
    .node:active { cursor:grabbing; }

    .node circle {
      fill: #0ea5e9; /* default node color */
      stroke: rgba(255,255,255,0.06);
      stroke-width:2px;
      transition: r .12s ease, transform .12s ease;
    }

    .node text {
      font-size:12px;
      fill:white;
      pointer-events:none;
      font-weight:600;
    }

    .edge {
      stroke: rgba(255,255,255,0.12);
      stroke-width:3;
      transition: stroke .3s ease, stroke-width .3s ease, opacity .3s ease;
      stroke-linecap:round;
    }

    .edge.accepted {
      stroke: var(--success);
      stroke-width:5;
    }
    .edge.rejected {
      stroke: var(--danger);
      stroke-dasharray: 6 4;
      stroke-width:3;
    }
    .edge.inspect {
      stroke: var(--highlight);
      stroke-width:6;
    }
    .weight-label {
      font-size:12px;
      fill: #e6eef6;
      font-weight:600;
      pointer-events:none;
      background:transparent;
    }

    /* simple animations for accepted edges */
    @keyframes glow {
      0% { filter: drop-shadow(0 0 0 rgba(0,0,0,0)); }
      50% { filter: drop-shadow(0 0 8px rgba(16,185,129,0.45)); }
      100% { filter: drop-shadow(0 0 0 rgba(0,0,0,0)); }
    }

    .edge.accepted { animation: glow 1s ease; }

    /* responsive */
    @media (max-width: 980px){
      .main { flex-direction: column; }
      .left { width:100%; min-width:unset; order:2; }
      .right { order:1; min-height:420px; }
      header { align-items: center; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Kruskal's algorithm interactive module">
    <header>
      <div class="title" aria-hidden="false">
        <h1>Kruskal’s Algorithm — Build Minimum Spanning Tree (MST)</h1>
        <p class="lead">Step through Kruskal’s greedy process: sort edges by weight, pick edges that don't create cycles, and form an MST.</p>
      </div>
      <div style="display:flex;flex-direction:column;gap:8px;align-items:flex-end;">
        <div style="color:var(--muted);font-size:13px">Interactive module • Vanilla HTML/CSS/JS</div>
        <div style="color:var(--muted);font-size:13px">Safe area: 24px; spacing: 16px</div>
      </div>
    </header>

    <div class="main" role="main">
      <!-- LEFT: Descriptions and Controls -->
      <aside class="left" aria-labelledby="conceptTitle">
        <div>
          <div class="section-title" id="conceptTitle">Concept Title</div>
          <div class="card"><strong>Kruskal's Algorithm (Minimum Spanning Tree)</strong> — Selects edges in ascending weight order and adds an edge if it connects two different components (using Union-Find) until all vertices are connected.</div>
        </div>

        <div>
          <div class="section-title">Learning Objective</div>
          <div class="card">
            After interacting with this module you will be able to:
            <ul>
              <li>See how sorting edges by weight drives greedy choice.</li>
              <li>Observe how Union-Find prevents cycles by tracking components.</li>
              <li>Experiment by creating and moving nodes/edges to understand algorithm stability.</li>
            </ul>
          </div>
        </div>

        <div>
          <div class="section-title">Interaction Design</div>
          <div class="card">
            Click controls to create nodes or edges, drag nodes to reposition them, and use "Step" or "Play" to run Kruskal. Visual feedback includes:
            <ul>
              <li>Currently inspected edge highlighted in amber.</li>
              <li>Accepted edges animate in green and become part of the MST.</li>
              <li>Rejected edges flash red and show as dashed.</li>
              <li>Union-Find component colors update to reflect merges.</li>
            </ul>
            Modes:
            <ul>
              <li>Add Node: click on canvas to place nodes.</li>
              <li>Add Edge: click two nodes to create an edge (enter weight when prompted).</li>
              <li>Drag nodes to rearrange and observe dynamic layout.</li>
            </ul>
          </div>
        </div>

        <div>
          <div class="section-title">Layout Description</div>
          <div class="card">
            Spatial arrangement:
            <ul>
              <li>Left column: textual explanations and control panel (width 360px). Keeps focus on actions and settings.</li>
              <li>Right column: interactive SVG canvas with graph visualization and live status (fills remaining width).</li>
              <li>Canvas toolbar placed above the svg; status bar below shows MST weight and Union-Find sets.</li>
            </ul>
            Accessibility & responsive notes:
            <ul>
              <li>All interactive controls have labels, large touch targets, and 16px minimum spacing.</li>
              <li>Canvas is responsive and stacks on small screens.</li>
            </ul>
          </div>
        </div>

        <!-- Controls -->
        <div>
          <div class="section-title">Controls</div>
          <div class="controls" role="region" aria-label="Controls">
            <div class="row">
              <button id="btn-add-node" class="small" aria-pressed="false">Add Node</button>
              <button id="btn-add-edge" class="small" aria-pressed="false">Add Edge</button>
              <button id="btn-delete" class="small btn-ghost">Delete Item</button>
            </div>
            <div class="row">
              <button id="btn-step" class="btn-primary">Step</button>
              <button id="btn-play" class="small">Play</button>
              <button id="btn-reset" class="small btn-ghost">Reset</button>
            </div>
            <div class="row">
              <button id="btn-sample1" class="small">Sample: Triangle</button>
              <button id="btn-sample2" class="small">Sample: Square</button>
              <button id="btn-random" class="small">Random (7 nodes)</button>
            </div>
            <div class="row">
              <button id="btn-shuffle" class="small">Shuffle Weights</button>
              <button id="btn-toggle-weights" class="small">Toggle Weights</button>
            </div>
          </div>
        </div>

        <div>
          <div class="section-title">Status / Legend</div>
          <div class="status" id="statusArea" aria-live="polite">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div style="font-weight:700;color:#e6eef6">MST weight: <span id="mstWeight">0</span></div>
              <div style="font-size:12px;color:var(--muted)">Edges: <span id="edgeCount">0</span></div>
            </div>
            <div style="margin-top:8px" class="legend" aria-hidden="false">
              <div style="display:flex;align-items:center;">
                <span class="dot" style="background:var(--highlight)"></span> Inspecting
              </div>
              <div style="display:flex;align-items:center;">
                <span class="dot" style="background:var(--success)"></span> Accepted
              </div>
              <div style="display:flex;align-items:center;">
                <span class="dot" style="background:var(--danger)"></span> Rejected
              </div>
            </div>
            <div style="margin-top:10px;font-size:13px;color:var(--muted)">
              Unions: <span id="unionSets">—</span>
            </div>
          </div>
        </div>

      </aside>

      <!-- RIGHT: Interactive canvas -->
      <section class="right" aria-label="Interactive graph canvas">
        <div class="toolbar">
          <div style="display:flex;gap:12px;align-items:center">
            <div class="info">
              <label style="font-size:12px;color:var(--muted)">Mode:</label>
              <div id="modeLabel" style="font-weight:700;color:#e6eef6">Browse</div>
            </div>
            <div class="info">
              <label style="font-size:12px;color:var(--muted)">Step index:</label>
              <div id="stepIndex" style="font-weight:700;color:#e6eef6">0</div>
            </div>
          </div>

          <div style="display:flex;gap:12px;align-items:center">
            <div class="info" style="font-size:13px;color:var(--muted)">Tip: Drag nodes. Use "Add Edge" then click two nodes.</div>
          </div>
        </div>

        <div class="canvas-wrap" id="canvasWrap">
          <svg id="svgCanvas" tabindex="0" role="img" aria-label="Graph drawing area">
            <defs>
              <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="0" dy="2" stdDeviation="4" flood-color="#000" flood-opacity="0.5"/>
              </filter>
            </defs>
            <!-- Edges and nodes will be inserted here -->
          </svg>
        </div>

        <div style="display:flex;gap:16px;align-items:center;justify-content:space-between;">
          <div style="font-size:13px;color:var(--muted)">Edge order (by weight): <span id="orderList">—</span></div>
          <div style="font-size:13px;color:var(--muted)">Accepted edges: <span id="acceptedList">—</span></div>
        </div>

      </section>
    </div>
  </div>

  <script>
    /**********************************************************************
     * Kruskal's Algorithm Interactive Module
     * - Vanilla JS, self-contained
     * - Users can add nodes, add edges (with weights), drag nodes
     * - Step through Kruskal: edges inspected, accepted, or rejected with animation
     **********************************************************************/

    (function(){
      // Utility
      function $(id){ return document.getElementById(id); }
      function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

      // State
      const state = {
        nodes: [], // {id,x,y}
        edges: [], // {id,a,b,w,accepted,rejected}
        nodeIdCounter: 0,
        edgeIdCounter: 0,
        mode: 'browse', // browse | add-node | add-edge | delete
        selection: null, // for add-edge: first node id
        kruskal: {
          sortedEdgeIds: [],
          index: 0,
          playing: false,
          acceptedEdgeIds: new Set(),
          rejectedEdgeIds: new Set(),
          unionFind: null
        },
        showWeights: true
      };

      // DOM refs
      const svg = $('svgCanvas');
      const modeLabel = $('modeLabel');
      const stepIndex = $('stepIndex');
      const mstWeightLabel = $('mstWeight');
      const edgeCountLabel = $('edgeCount');
      const orderList = $('orderList');
      const acceptedList = $('acceptedList');
      const unionSetsLabel = $('unionSets');
      const statusArea = $('statusArea');

      // Buttons
      const btnAddNode = $('btn-add-node');
      const btnAddEdge = $('btn-add-edge');
      const btnDelete = $('btn-delete');
      const btnStep = $('btn-step');
      const btnPlay = $('btn-play');
      const btnReset = $('btn-reset');
      const btnSample1 = $('btn-sample1');
      const btnSample2 = $('btn-sample2');
      const btnRandom = $('btn-random');
      const btnShuffle = $('btn-shuffle');
      const btnToggleWeights = $('btn-toggle-weights');

      // Interaction constraints
      const safeMargin = 24;
      const minGap = 16;

      /* -------------------------
         Rendering utilities (SVG)
         ------------------------- */
      function clearSVG(){
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        // re-add defs (shadow)
        const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
        defs.innerHTML = '<filter id="shadow" x="-50%" y="-50%" width="200%" height="200%"><feDropShadow dx="0" dy="2" stdDeviation="4" flood-color="#000" flood-opacity="0.5"/></filter>';
        svg.appendChild(defs);
      }

      function render(){
        clearSVG();
        // Draw edges below nodes
        const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
        edgeGroup.setAttribute('id','edgeGroup');
        svg.appendChild(edgeGroup);

        state.edges.forEach(e => {
          const a = getNodeById(e.a);
          const b = getNodeById(e.b);
          if(!a || !b) return;

          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', a.x);
          line.setAttribute('y1', a.y);
          line.setAttribute('x2', b.x);
          line.setAttribute('y2', b.y);
          line.classList.add('edge');
          line.setAttribute('data-edge-id', e.id);

          if (state.kruskal.acceptedEdgeIds.has(e.id)){
            line.classList.add('accepted');
          } else if (state.kruskal.rejectedEdgeIds.has(e.id)){
            line.classList.add('rejected');
          }

          edgeGroup.appendChild(line);

          // weight label midpoint
          if (state.showWeights){
            const midx = (a.x+b.x)/2;
            const midy = (a.y+b.y)/2;
            const weightText = document.createElementNS('http://www.w3.org/2000/svg','text');
            weightText.setAttribute('x', midx + 6);
            weightText.setAttribute('y', midy - 6);
            weightText.setAttribute('class','weight-label');
            weightText.textContent = e.w;
            edgeGroup.appendChild(weightText);
          }

          // clickable: bring to front on hover for visibility
          line.addEventListener('mouseenter', ()=>{
            line.style.opacity = 0.9;
          });
          line.addEventListener('mouseleave', ()=>{
            line.style.opacity = 1;
          });

          // For delete mode, click to delete an edge
          line.addEventListener('click', (ev)=>{
            ev.stopPropagation();
            if (state.mode === 'delete'){
              removeEdgeById(e.id);
              commitRender();
            }
          });
        });

        // Nodes (top)
        const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
        nodeGroup.setAttribute('id','nodeGroup');
        svg.appendChild(nodeGroup);

        state.nodes.forEach(n => {
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('class','node');
          g.setAttribute('data-node-id', n.id);
          g.setAttribute('transform', `translate(${n.x},${n.y})`);
          g.setAttribute('tabindex', 0);
          // circle
          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circle.setAttribute('r', 18);
          circle.setAttribute('cx', 0);
          circle.setAttribute('cy', 0);
          circle.setAttribute('fill', '#0ea5e9');
          circle.setAttribute('filter','url(#shadow)');
          g.appendChild(circle);
          // label
          const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
          txt.setAttribute('x', 0);
          txt.setAttribute('y', 4);
          txt.setAttribute('text-anchor','middle');
          txt.textContent = String(n.id);
          g.appendChild(txt);

          nodeGroup.appendChild(g);

          // Dragging
          let dragging = false;
          let start = null;
          const onPointerDown = (ev)=>{
            ev.preventDefault();
            if (state.mode === 'add-edge'){
              // clicking a node selects it for edge creation
              handleNodeClickForAddEdge(n.id);
              return;
            }
            if (state.mode === 'delete'){
              // delete node
              removeNodeById(n.id);
              commitRender();
              return;
            }
            // otherwise allow dragging
            dragging = true;
            start = {x: ev.clientX, y: ev.clientY, nodeX: n.x, nodeY: n.y};
            g.setPointerCapture(ev.pointerId);
          };
          const onPointerMove = (ev)=>{
            if (!dragging) return;
            const dx = ev.clientX - start.x;
            const dy = ev.clientY - start.y;
            n.x = start.nodeX + dx;
            n.y = start.nodeY + dy;
            g.setAttribute('transform', `translate(${n.x},${n.y})`);
            // update edges positions live
            updateEdgesPositions();
          };
          const onPointerUp = (ev)=>{
            dragging = false;
            g.releasePointerCapture(ev.pointerId);
            commitRender();
          };
          g.addEventListener('pointerdown', onPointerDown);
          g.addEventListener('pointermove', onPointerMove);
          g.addEventListener('pointerup', onPointerUp);

          // keyboard accessibility: pressing Enter triggers same as clicking
          g.addEventListener('keydown', (ev)=>{
            if (ev.key === 'Enter' || ev.key === ' '){
              ev.preventDefault();
              if (state.mode === 'add-edge'){
                handleNodeClickForAddEdge(n.id);
              } else if (state.mode === 'delete'){
                removeNodeById(n.id);
                commitRender();
              }
            }
          });
        });

        updateStatus();
      }

      function updateEdgesPositions(){
        // update line endpoints live during drag
        const edgeLines = svg.querySelectorAll('line.edge');
        edgeLines.forEach(line => {
          const id = line.getAttribute('data-edge-id');
          const e = getEdgeById(parseInt(id));
          if (!e) return;
          const a = getNodeById(e.a);
          const b = getNodeById(e.b);
          line.setAttribute('x1', a.x);
          line.setAttribute('y1', a.y);
          line.setAttribute('x2', b.x);
          line.setAttribute('y2', b.y);
          // update weight label (if visible)
          // weight labels are the following text nodes in the edgeGroup; to keep simple, re-render commitRender on pointerup
        });
      }

      /* -------------------------
         Graph manipulation helpers
         ------------------------- */
      function addNodeAt(x,y){
        const id = ++state.nodeIdCounter;
        state.nodes.push({id, x, y});
        return id;
      }
      function getNodeById(id){ return state.nodes.find(n=>n.id===id); }
      function removeNodeById(id){
        // remove edges attached
        state.edges = state.edges.filter(e=> e.a !== id && e.b !== id);
        state.nodes = state.nodes.filter(n=> n.id !== id);
      }
      function addEdge(a,b,w){
        // avoid duplicates (unordered)
        if (a === b) return null;
        const exists = state.edges.some(e=> (e.a===a&&e.b===b) || (e.a===b&&e.b===a));
        if (exists) return null;
        const id = ++state.edgeIdCounter;
        state.edges.push({id, a, b, w: w, accepted:false, rejected:false});
        return id;
      }
      function removeEdgeById(id){
        state.edges = state.edges.filter(e=> e.id!==id);
      }
      function getEdgeById(id){ return state.edges.find(e=>e.id===id); }

      /* -------------------------
         Kruskal process logic
         ------------------------- */
      function prepareKruskal(){
        // sort edges by weight (ascending)
        const sorted = [...state.edges].sort((p,q)=> p.w - q.w).map(e=>e.id);
        state.kruskal.sortedEdgeIds = sorted;
        state.kruskal.index = 0;
        state.kruskal.acceptedEdgeIds = new Set();
        state.kruskal.rejectedEdgeIds = new Set();
        // union-find init
        state.kruskal.unionFind = new UnionFind(state.nodes.map(n=>n.id));
        // clear visual flags
        state.edges.forEach(e => { e.accepted=false; e.rejected=false; });
        updateOrderDisplay();
        updateAcceptedDisplay();
        stepIndex.textContent = '0';
      }

      function stepKruskalOnce(){
        const idx = state.kruskal.index;
        if (idx >= state.kruskal.sortedEdgeIds.length){
          // finished
          state.kruskal.playing = false;
          btnPlay.textContent = 'Play';
          return;
        }
        const eid = state.kruskal.sortedEdgeIds[idx];
        const e = getEdgeById(eid);
        highlightInspectEdge(eid);
        // inspect after small timeout for animation clarity
        setTimeout(()=>{
          const a = e.a, b = e.b;
          const uf = state.kruskal.unionFind;
          const ra = uf.find(a), rb = uf.find(b);
          if (ra !== rb){
            // accept
            uf.union(a,b);
            state.kruskal.acceptedEdgeIds.add(eid);
            e.accepted = true;
            animateAcceptEdge(eid);
          } else {
            // reject
            state.kruskal.rejectedEdgeIds.add(eid);
            e.rejected = true;
            animateRejectEdge(eid);
          }
          state.kruskal.index++;
          updateOrderDisplay();
          updateAcceptedDisplay();
          updateUnionDisplay();
          stepIndex.textContent = String(state.kruskal.index);
          updateMSTWeight();
          // if autoplayer, continue
          if (state.kruskal.playing){
            if (state.kruskal.index < state.kruskal.sortedEdgeIds.length){
              setTimeout(stepKruskalOnce, 700);
            } else {
              state.kruskal.playing = false;
              btnPlay.textContent = 'Play';
            }
          }
        }, 400);
      }

      function playToggle(){
        if (state.kruskal.playing){
          state.kruskal.playing = false;
          btnPlay.textContent = 'Play';
        } else {
          prepareKruskalIfNeeded();
          state.kruskal.playing = true;
          btnPlay.textContent = 'Pause';
          stepKruskalOnce();
        }
      }

      function prepareKruskalIfNeeded(){
        if (!state.kruskal.sortedEdgeIds || state.kruskal.sortedEdgeIds.length === 0){
          prepareKruskal();
        } else {
          // if something changed (edges added/removed), recompute
          // simple approach: re-prepare always
          prepareKruskal();
        }
      }

      function resetKruskal(){
        state.kruskal.playing = false;
        btnPlay.textContent = 'Play';
        state.kruskal.sortedEdgeIds = [];
        state.kruskal.index = 0;
        state.kruskal.acceptedEdgeIds = new Set();
        state.kruskal.rejectedEdgeIds = new Set();
        state.kruskal.unionFind = null;
        // clear flags
        state.edges.forEach(e => { e.accepted=false; e.rejected=false; });
        updateOrderDisplay();
        updateAcceptedDisplay();
        updateUnionDisplay();
        updateMSTWeight();
        stepIndex.textContent = '0';
        commitRender();
      }

      function updateOrderDisplay(){
        const list = state.kruskal.sortedEdgeIds.map(id=> {
          const e = getEdgeById(id);
          return e ? `${id}(w=${e.w})` : id;
        });
        orderList.textContent = list.join(', ') || '—';
        edgeCountLabel.textContent = String(state.edges.length);
      }

      function updateAcceptedDisplay(){
        const list = Array.from(state.kruskal.acceptedEdgeIds).map(id=> {
          const e = getEdgeById(id);
          return e ? `${id}` : id;
        });
        acceptedList.textContent = list.join(', ') || '—';
      }

      function updateUnionDisplay(){
        if (!state.kruskal.unionFind) { unionSetsLabel.textContent = '—'; return; }
        const groups = state.kruskal.unionFind.groups();
        const repr = groups.map(g=> '['+g.join(',')+']').join(' ');
        unionSetsLabel.textContent = repr || '—';
      }

      function updateMSTWeight(){
        let sum = 0;
        state.kruskal.acceptedEdgeIds.forEach(id => {
          const e = getEdgeById(id);
          if (e) sum += e.w;
        });
        mstWeightLabel.textContent = String(sum);
      }

      /* -------------------------
         Visual animations & helpers
         ------------------------- */
      function highlightInspectEdge(id){
        // clear previous 'inspect' class
        svg.querySelectorAll('line.edge.inspect').forEach(l=> l.classList.remove('inspect'));
        const line = svg.querySelector(`line.edge[data-edge-id="${id}"]`);
        if (line) line.classList.add('inspect');
      }
      function animateAcceptEdge(id){
        const line = svg.querySelector(`line.edge[data-edge-id="${id}"]`);
        if (!line) return;
        line.classList.remove('inspect');
        line.classList.remove('rejected');
        line.classList.add('accepted');
        // also update node colors of components (simple: color nodes in same component)
        colorNodesByComponents();
        setTimeout(commitRender, 300);
      }
      function animateRejectEdge(id){
        const line = svg.querySelector(`line.edge[data-edge-id="${id}"]`);
        if (!line) return;
        line.classList.remove('inspect');
        line.classList.add('rejected');
        setTimeout(() => {
          // keep rejected visible as dashed; commit render
          commitRender();
        }, 300);
      }

      function colorNodesByComponents(){
        const uf = state.kruskal.unionFind;
        if (!uf) return;
        const groups = uf.groups();
        const palette = ['#60a5fa','#f472b6','#34d399','#f59e0b','#fb923c','#a78bfa','#f97316'];
        const nodeColorMap = {};
        groups.forEach((g,i)=>{
          g.forEach(id=> nodeColorMap[id] = palette[i % palette.length]);
        });
        // apply colors to SVG nodes
        svg.querySelectorAll('g.node').forEach(gn=>{
          const id = parseInt(gn.getAttribute('data-node-id'));
          const circle = gn.querySelector('circle');
          if (nodeColorMap[id]) circle.setAttribute('fill', nodeColorMap[id]);
          else circle.setAttribute('fill','#0ea5e9');
        });
      }

      /* -------------------------
         Union-Find implementation
         ------------------------- */
      function UnionFind(elements){
        this.parent = {};
        this.rank = {};
        elements.forEach(e=> {
          this.parent[e] = e;
          this.rank[e] = 0;
        });
      }
      UnionFind.prototype.find = function(x){
        if (this.parent[x] !== x){
          this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
      };
      UnionFind.prototype.union = function(a,b){
        const ra = this.find(a);
        const rb = this.find(b);
        if (ra === rb) return false;
        if (this.rank[ra] < this.rank[rb]) this.parent[ra] = rb;
        else if (this.rank[ra] > this.rank[rb]) this.parent[rb] = ra;
        else { this.parent[rb] = ra; this.rank[ra]++; }
        return true;
      };
      UnionFind.prototype.groups = function(){
        const map = {};
        for (const k in this.parent){
          const r = this.find(k);
          if (!map[r]) map[r] = [];
          map[r].push(parseInt(k));
        }
        // sort each group for consistent display
        return Object.values(map).map(arr=>arr.sort((a,b)=>a-b));
      };

      /* -------------------------
         Interaction handlers
         ------------------------- */
      function setMode(m){
        state.mode = m;
        modeLabel.textContent = m === 'browse' ? 'Browse' : (m === 'add-node' ? 'Add Node' : (m === 'add-edge' ? 'Add Edge' : 'Delete'));
        // toggle button pressed states
        btnAddNode.setAttribute('aria-pressed', m==='add-node');
        btnAddEdge.setAttribute('aria-pressed', m==='add-edge');
        btnDelete.setAttribute('aria-pressed', m==='delete');
      }

      btnAddNode.addEventListener('click', ()=>{
        setMode(state.mode === 'add-node' ? 'browse' : 'add-node');
      });
      btnAddEdge.addEventListener('click', ()=>{
        setMode(state.mode === 'add-edge' ? 'browse' : 'add-edge');
        state.selection = null;
      });
      btnDelete.addEventListener('click', ()=>{
        setMode(state.mode === 'delete' ? 'browse' : 'delete');
      });

      // Canvas click: add node if in add-node mode
      svg.addEventListener('click', (ev)=>{
        const pt = svg.createSVGPoint();
        pt.x = ev.clientX;
        pt.y = ev.clientY;
        const ctm = svg.getScreenCTM().inverse();
        const loc = pt.matrixTransform(ctm);
        if (state.mode === 'add-node'){
          // ensure inside canvas area and keep margin
          addNodeAt(loc.x, loc.y);
          commitRender();
        }
      });

      function handleNodeClickForAddEdge(nodeId){
        if (state.mode !== 'add-edge') return;
        if (!state.selection){
          state.selection = nodeId;
          statusArea.querySelector('.legend').scrollIntoView({behavior:'smooth',block:'end'});
        } else {
          if (state.selection === nodeId){
            // cannot connect to same
            state.selection = null;
            return;
          }
          // ask for weight
          let weight = prompt('Enter edge weight (positive integer):', String(randInt(1,20)));
          if (weight === null) { state.selection = null; return; }
          weight = parseInt(weight);
          if (isNaN(weight) || weight <= 0) weight = randInt(1,20);
          addEdge(state.selection, nodeId, weight);
          state.selection = null;
          commitRender();
        }
      }

      // Step & Play
      btnStep.addEventListener('click', ()=>{
        prepareKruskalIfNeeded();
        stepKruskalOnce();
      });
      btnPlay.addEventListener('click', playToggle);
      btnReset.addEventListener('click', ()=>{
        resetKruskal();
      });

      btnSample1.addEventListener('click', ()=>{
        loadSampleTriangle();
      });
      btnSample2.addEventListener('click', ()=>{
        loadSampleSquare();
      });
      btnRandom.addEventListener('click', ()=>{
        loadRandomGraph(7);
      });

      btnShuffle.addEventListener('click', ()=>{
        state.edges.forEach(e=> e.w = randInt(1,20));
        resetKruskal();
        commitRender();
      });

      btnToggleWeights.addEventListener('click', ()=>{
        state.showWeights = !state.showWeights;
        commitRender();
      });

      /* -------------------------
         Sample graphs
         ------------------------- */
      function loadSampleTriangle(){
        // reset nodes and edges
        state.nodes = [];
        state.edges = [];
        state.nodeIdCounter = 0;
        state.edgeIdCounter = 0;
        addNodeAt(160,120); // id1
        addNodeAt(320,120); // id2
        addNodeAt(240,240); // id3
        addEdge(1,2,4);
        addEdge(2,3,2);
        addEdge(1,3,5);
        resetKruskal();
        commitRender();
      }
      function loadSampleSquare(){
        state.nodes = [];
        state.edges = [];
        state.nodeIdCounter = 0;
        state.edgeIdCounter = 0;
        addNodeAt(160,120); //1
        addNodeAt(320,120); //2
        addNodeAt(320,280); //3
        addNodeAt(160,280); //4
        addEdge(1,2,3); addEdge(2,3,4); addEdge(3,4,2); addEdge(4,1,7);
        addEdge(1,3,5);
        resetKruskal();
        commitRender();
      }
      function loadRandomGraph(n){
        state.nodes = [];
        state.edges = [];
        state.nodeIdCounter = 0;
        state.edgeIdCounter = 0;
        const margin = 80;
        const w = svg.clientWidth || 800;
        const h = svg.clientHeight || 500;
        for (let i=0;i<n;i++){
          addNodeAt(randInt(margin, w-margin), randInt(margin, h-margin));
        }
        // random edges - ensure connectivity by making a random spanning tree then add extras
        const ids = state.nodes.map(n=>n.id);
        const shuffled = ids.slice().sort(()=>Math.random()-0.5);
        for (let i=1;i<shuffled.length;i++){
          const a = shuffled[i-1];
          const b = shuffled[i];
          addEdge(a,b, randInt(1,20));
        }
        // add some random extra edges
        for (let i=0;i<Math.max(1, n); i++){
          const a = ids[randInt(0,ids.length-1)];
          const b = ids[randInt(0,ids.length-1)];
          if (a!==b) addEdge(a,b, randInt(1,20));
        }
        resetKruskal();
        commitRender();
      }

      /* -------------------------
         Misc helpers
         ------------------------- */
      function commitRender(){
        // render nodes/edges based on current state
        render();
      }

      // Initialize with a sample
      loadSampleSquare();

      /* -------------------------
         Keyboard shortcuts (optional)
         ------------------------- */
      window.addEventListener('keydown', (ev)=>{
        if (ev.key === 'n') { setMode('add-node'); }
        if (ev.key === 'e') { setMode('add-edge'); }
        if (ev.key === 'd') { setMode('delete'); }
        if (ev.key === 'Escape') { setMode('browse'); state.selection=null; }
        if (ev.key === ' ') { ev.preventDefault(); playToggle(); }
      });

      /* -------------------------
         Utility: update UI elements for status
         ------------------------- */
      function updateStatus(){
        edgeCountLabel.textContent = String(state.edges.length);
      }

      // initial status update
      updateStatus();

      /**********************************************************************
       * End of module
       **********************************************************************/
    })();
  </script>
</body>
</html>