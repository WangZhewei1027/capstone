<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Priority Queue Interactive Module</title>
  <style>
    /* Safe area margins: 24px */
    html,body {
      height: 100%;
      margin: 0;
      padding: 24px;
      box-sizing: border-box;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: #f7f9fc;
      color: #0b1220;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Layout */
    .container {
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 24px;
      height: calc(100% - 48px);
    }

    /* Single column on narrow screens */
    @media (max-width: 880px) {
      .container {
        grid-template-columns: 1fr;
        grid-auto-rows: min-content;
        height: auto;
      }
    }

    /* Panel styling */
    .panel {
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(6, 24, 64, 0.08);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px; /* Minimum spacing 16px between interactive elements */
      min-height: 140px;
    }

    h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: -0.2px;
    }
    .muted {
      color: #475569;
      font-size: 13px;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    label {
      font-size: 13px;
      color: #0b1220;
    }

    input[type="text"], input[type="number"], select {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #e6eef8;
      background: #fbfdff;
      width: 100%;
      font-size: 14px;
    }

    button {
      padding: 10px 12px;
      border-radius: 8px;
      border: none;
      background: #0b63ff;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: transform .08s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    button:active { transform: scale(.99); }
    button.secondary {
      background: #eef2ff;
      color: #27334b;
      border: 1px solid #dbeafe;
    }
    button.ghost {
      background: transparent;
      color: #0b1220;
      border: 1px solid #e6eef8;
    }
    .controls .small {
      font-size: 13px;
      padding: 8px 10px;
    }

    /* Interactive canvas */
    .canvas {
      position: relative;
      min-height: 420px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .top-controls {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
    }

    .heap-area {
      position: relative;
      flex: 1;
      min-height: 300px;
      border-radius: 12px;
      background: linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);
      border: 1px dashed #e6eef8;
      overflow: hidden;
      padding: 12px;
    }

    /* Node styling */
    .node {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 10px;
      background: linear-gradient(180deg,#0b63ff 0%, #0057d1 100%);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      box-shadow: 0 8px 18px rgba(11,99,255,0.18);
      transition: left 350ms ease, top 350ms ease, transform 180ms ease;
      will-change: left, top, transform;
      z-index: 1;
    }

    .node.small {
      width: 52px;
      height: 52px;
      font-size: 13px;
      border-radius: 9px;
    }

    .node .prio {
      font-size: 12px;
      opacity: .92;
      font-weight: 700;
    }
    .node .val {
      font-size: 11px;
      opacity: .9;
      font-weight: 600;
      background: rgba(255,255,255,0.12);
      padding: 2px 6px;
      border-radius: 6px;
      margin-top: 4px;
    }

    .node.highlight {
      box-shadow: 0 12px 30px rgba(11,99,255,0.28), 0 2px 6px rgba(0,0,0,0.06);
      transform: translateY(-6px) scale(1.03);
      z-index: 3;
    }

    .edge {
      position: absolute;
      width: 2px;
      background: linear-gradient(180deg, rgba(6,24,64,0.12), rgba(6,24,64,0.03));
      transform-origin: top left;
      border-radius: 2px;
      z-index: 0;
      transition: opacity 280ms ease;
    }

    /* Queue (sorted view) */
    .queue {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 6px;
      overflow-x: auto;
    }

    .chip {
      min-width: 70px;
      padding: 8px 10px;
      border-radius: 12px;
      background: #f1f5f9;
      border: 1px solid #e6eef8;
      color: #0b1220;
      font-weight: 600;
      display:flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .chip .cprio { font-size:12px; color:#334155; }
    .chip .cval { font-size:11px; color:#475569; }

    /* Log */
    .log {
      background: #0b1220;
      color: #e6f2ff;
      padding: 12px;
      border-radius: 8px;
      font-size: 13px;
      max-height: 140px;
      overflow: auto;
    }

    .muted-box {
      background: #fff;
      border-radius: 8px;
      padding: 12px;
      border: 1px solid #eef2ff;
      color: #334155;
      font-size: 13px;
    }

    footer.note {
      font-size: 13px;
      color: #475569;
      margin-top: 6px;
    }
  </style>
</head>
<body>
  <div class="container" role="main">
    <!-- Left: Explanatory panel -->
    <aside class="panel" aria-label="Module description">
      <div>
        <h1>Priority Queue — Interactive Exploration</h1>
        <div class="muted">A hands-on demonstration of enqueue, peek, and dequeue with animated heap operations.</div>
      </div>

      <div>
        <strong>Learning Objective</strong>
        <div class="muted-box" id="learning-objective">
          After using this module you will be able to:
          <ul>
            <li>Understand how a priority queue orders elements by priority (min- or max-first).</li>
            <li>See how insertion and removal map to bubble-up and bubble-down operations in a binary heap.</li>
            <li>Step through each compare-and-swap to observe how the heap maintains its invariants.</li>
          </ul>
        </div>
      </div>

      <div>
        <strong>Interaction Design</strong>
        <div class="muted">
          Use the controls to insert items (value + numeric priority), toggle between min- and max-priority, and remove items.
          Each operation is animated in the heap view:
          <ul>
            <li>Insert: new node appears at the bottom and bubbles up while highlighted.</li>
            <li>Dequeue (pop): root is removed, last node replaces it and bubbles down while swapping with children.</li>
            <li>Toggle "Step mode" to advance swap-by-swap using Next Step — ideal for study and debugging.</li>
          </ul>
          Visual feedback includes color highlights, movement animations, and a live operation log.
        </div>
      </div>

      <div>
        <strong>Layout Description</strong>
        <div class="muted">
          The page uses a two-column layout (controls left, interactive canvas right). Safe area margins are 24px and interactive elements are spaced at least 16px.
          The right panel contains:
          <ul>
            <li>Top controls (mode, speed, step) and input form.</li>
            <li>Heap visualization (absolute-positioned nodes and edges).</li>
            <li>Sorted queue view and operation log below the heap.</li>
          </ul>
          The design is responsive: columns stack on narrow screens. Controls are keyboard-accessible and labeled for screen readers.
        </div>
      </div>

      <footer class="note">Only one concept is covered: the behavior of a priority queue implemented by a binary heap (min/max).</footer>
    </aside>

    <!-- Right: Interactive canvas -->
    <section class="panel" aria-label="Interactive priority queue">
      <div class="top-controls">
        <div style="display:flex; gap:12px; align-items:center;">
          <div>
            <label for="mode-select">Mode</label><br/>
            <select id="mode-select" aria-label="Select heap mode">
              <option value="min">Min-heap (lowest priority first)</option>
              <option value="max">Max-heap (highest priority first)</option>
            </select>
          </div>

          <div>
            <label for="speed-range">Animation speed</label><br/>
            <input id="speed-range" type="range" min="100" max="1200" value="350" aria-label="Animation speed in ms" />
          </div>

          <div style="display:flex; align-items:center; gap:8px;">
            <label for="step-mode" style="font-size:13px;">Step mode</label>
            <input id="step-mode" type="checkbox" aria-label="Enable step mode" />
            <button id="next-step" class="secondary small" disabled aria-label="Next step">Next step</button>
          </div>
        </div>

        <div style="display:flex; gap:12px;">
          <button id="clear-btn" class="ghost" aria-label="Clear queue">Clear</button>
          <button id="peek-btn" class="secondary" aria-label="Peek root">Peek</button>
          <button id="dequeue-btn" aria-label="Dequeue (pop root)">Dequeue</button>
        </div>
      </div>

      <div class="controls" style="margin-top:2px;">
        <div class="row">
          <div style="flex:1;">
            <label for="val-input">Value (label)</label>
            <input id="val-input" type="text" placeholder="e.g. Task A" aria-label="Item value" />
          </div>
          <div style="width:140px;">
            <label for="prio-input">Priority (number)</label>
            <input id="prio-input" type="number" value="10" aria-label="Item priority" />
          </div>
          <div style="width:120px; display:flex; align-items:flex-end;">
            <button id="insert-btn" aria-label="Insert item">Insert</button>
          </div>
        </div>
      </div>

      <div class="canvas" id="canvas" aria-live="polite">
        <div class="heap-area" id="heap-area" role="img" aria-label="Heap visualization">
          <!-- edges and nodes rendered here -->
        </div>

        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div style="flex:1;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <strong>Queue (sorted view)</strong>
              <div class="muted">Ordered by priority →</div>
            </div>
            <div class="queue" id="queue-view" tabindex="0" aria-label="Sorted queue view"></div>
          </div>

          <div style="width:320px;">
            <strong>Operation Log</strong>
            <div class="log" id="log" aria-live="polite"></div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    // Priority Queue (binary heap) interactive module
    (function () {
      // DOM elements
      const modeSelect = document.getElementById('mode-select');
      const speedRange = document.getElementById('speed-range');
      const stepModeCheckbox = document.getElementById('step-mode');
      const nextStepBtn = document.getElementById('next-step');
      const clearBtn = document.getElementById('clear-btn');
      const peekBtn = document.getElementById('peek-btn');
      const dequeueBtn = document.getElementById('dequeue-btn');
      const insertBtn = document.getElementById('insert-btn');
      const valInput = document.getElementById('val-input');
      const prioInput = document.getElementById('prio-input');
      const heapArea = document.getElementById('heap-area');
      const queueView = document.getElementById('queue-view');
      const logEl = document.getElementById('log');

      // Internal state
      let heap = []; // array of nodes: {id, value, priority}
      let nextId = 1;
      let isMin = true;
      let animDuration = Number(speedRange.value); // ms
      let stepMode = false;
      let pendingActions = []; // actions queue for stepping
      let running = false;

      // Visual state caches
      const nodesDom = new Map(); // id => element
      const edgesDom = new Map(); // key "parentId-childId" => element

      // Accessibility helper
      function announce(msg) {
        const p = document.createElement('div');
        p.textContent = msg;
        p.style.position = 'absolute';
        p.style.left = '-9999px';
        p.style.height = '1px';
        p.style.width = '1px';
        p.style.overflow = 'hidden';
        document.body.appendChild(p);
        setTimeout(() => document.body.removeChild(p), 2000);
      }

      // Logging
      function log(msg) {
        const time = new Date().toLocaleTimeString();
        const line = document.createElement('div');
        line.textContent = `[${time}] ${msg}`;
        logEl.prepend(line);
      }

      // Helper comparator
      function compare(a, b) {
        if (a.priority === b.priority) return 0;
        return (a.priority < b.priority) ? -1 : 1;
      }
      function isHigherPriority(a, b) {
        const cmp = compare(a, b);
        return isMin ? (cmp < 0) : (cmp > 0);
      }

      // Render functions
      function renderQueueView() {
        // Sorted array by priority (stable-ish)
        const sorted = heap.slice().sort((x, y) => {
          const c = compare(x, y);
          return isMin ? c : -c;
        });
        queueView.innerHTML = '';
        if (sorted.length === 0) {
          const tip = document.createElement('div');
          tip.className = 'chip';
          tip.style.opacity = '.6';
          tip.textContent = 'Empty';
          queueView.appendChild(tip);
          return;
        }
        for (const item of sorted) {
          const chip = document.createElement('div');
          chip.className = 'chip';
          chip.title = `Value: ${item.value} — Priority: ${item.priority}`;
          const pr = document.createElement('div');
          pr.className = 'cprio';
          pr.textContent = `p: ${item.priority}`;
          const va = document.createElement('div');
          va.className = 'cval';
          va.textContent = item.value;
          chip.appendChild(pr);
          chip.appendChild(va);
          queueView.appendChild(chip);
        }
      }

      // Compute positions for heap nodes (binary tree layout)
      function computePositions() {
        const container = heapArea;
        const rect = container.getBoundingClientRect();
        const width = Math.max(280, rect.width - 24);
        const levelHeight = 90; // px per level
        const positions = new Map();
        const n = heap.length;
        for (let i = 0; i < n; i++) {
          const depth = Math.floor(Math.log2(i + 1));
          const levelStart = Math.pow(2, depth) - 1;
          const posInLevel = i - levelStart;
          const nodesInLevel = Math.pow(2, depth);
          const horizontalGap = width / (nodesInLevel + 1);
          const left = Math.round(horizontalGap * (posInLevel + 1)) - 30 + 12; // center node width 60, plus padding
          const top = depth * levelHeight + 14;
          positions.set(heap[i].id, {left, top});
        }
        return positions;
      }

      function renderHeapImmediate() {
        // ensure DOM nodes for each heap item exist
        for (const item of heap) {
          if (!nodesDom.has(item.id)) {
            const el = document.createElement('div');
            el.className = 'node';
            el.setAttribute('data-id', item.id);
            el.setAttribute('role', 'img');
            el.setAttribute('aria-label', `Item ${item.value} with priority ${item.priority}`);
            el.innerHTML = `<div class="prio">${item.priority}</div><div class="val">${escapeHtml(item.value)}</div>`;
            heapArea.appendChild(el);
            nodesDom.set(item.id, el);
          } else {
            const el = nodesDom.get(item.id);
            el.querySelector('.prio').textContent = item.priority;
            el.querySelector('.val').textContent = item.value;
          }
        }
        // remove DOM nodes that are no longer in heap
        for (const [id, el] of nodesDom.entries()) {
          if (!heap.some(h => h.id === id)) {
            // remove edges connected to this id
            for (const key of Array.from(edgesDom.keys())) {
              if (key.includes(String(id))) {
                const e = edgesDom.get(key);
                if (e && e.parentNode) e.parentNode.removeChild(e);
                edgesDom.delete(key);
              }
            }
            if (el.parentNode) el.parentNode.removeChild(el);
            nodesDom.delete(id);
          }
        }

        // compute positions and set left/top for nodes, draw edges
        const positions = computePositions();

        // create/update edges
        for (let i = 0; i < heap.length; i++) {
          const parent = heap[i];
          const leftChildIdx = 2 * i + 1;
          const rightChildIdx = 2 * i + 2;
          if (leftChildIdx < heap.length) drawEdgeBetween(parent.id, heap[leftChildIdx].id, positions);
          if (rightChildIdx < heap.length) drawEdgeBetween(parent.id, heap[rightChildIdx].id, positions);
        }

        // position nodes
        for (const item of heap) {
          const el = nodesDom.get(item.id);
          const pos = positions.get(item.id);
          if (!pos) continue;
          el.style.left = `${pos.left}px`;
          el.style.top = `${pos.top}px`;
        }
      }

      function drawEdgeBetween(parentId, childId, positions) {
        const key = `${parentId}-${childId}`;
        let el = edgesDom.get(key);
        const p = positions.get(parentId);
        const c = positions.get(childId);
        if (!p || !c) return;
        const startX = p.left + 30; // center of parent node
        const startY = p.top + 48;
        const endX = c.left + 30;
        const endY = c.top + 8;
        const dx = endX - startX;
        const dy = endY - startY;
        const length = Math.hypot(dx, dy);
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        if (!el) {
          el = document.createElement('div');
          el.className = 'edge';
          el.style.height = `${length}px`;
          el.style.left = `${startX}px`;
          el.style.top = `${startY}px`;
          el.style.transform = `rotate(${angle}deg)`;
          heapArea.appendChild(el);
          edgesDom.set(key, el);
        } else {
          el.style.height = `${length}px`;
          el.style.left = `${startX}px`;
          el.style.top = `${startY}px`;
          el.style.transform = `rotate(${angle}deg)`;
        }
      }

      // Utility: escape HTML for values
      function escapeHtml(s) {
        if (!s && s !== 0) return '';
        return String(s)
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#039;');
      }

      // Animate a sequence of swaps (actions). Each action: {type:'swap', aIdx, bIdx} or {type:'insert', id} or {type:'remove', id}
      function scheduleActions(actions) {
        if (stepMode) {
          pendingActions.push(...actions);
          nextStepBtn.disabled = pendingActions.length === 0;
          updateLogForPending();
          return Promise.resolve();
        } else {
          return runActionsSequentially(actions);
        }
      }

      async function runActionsSequentially(actions) {
        for (const act of actions) {
          if (act.type === 'highlight') {
            const el = nodesDom.get(act.id);
            if (el) {
              el.classList.add('highlight');
              await sleep(Math.max(120, animDuration / 3));
              el.classList.remove('highlight');
            }
          } else if (act.type === 'swap') {
            await animateSwap(act.aIdx, act.bIdx);
          } else if (act.type === 'insert') {
            // a brief pop-in
            const el = nodesDom.get(act.id);
            if (el) {
              el.style.transform = 'scale(0.85)';
              await sleep(60);
              el.style.transform = 'scale(1)';
              await sleep(Math.max(60, animDuration / 6));
            }
          } else if (act.type === 'remove') {
            const el = nodesDom.get(act.id);
            if (el) {
              el.style.transition = `transform ${Math.round(animDuration/2)}ms ease, opacity ${Math.round(animDuration/2)}ms ease`;
              el.style.transform = 'translateY(-10px) scale(.8)';
              el.style.opacity = '0';
              await sleep(Math.round(animDuration/2));
            }
          }
          renderHeapImmediate();
          renderQueueView();
        }
      }

      function sleep(ms) {
        return new Promise(res => setTimeout(res, ms));
      }

      // Animate swapping two indices in the heap array
      function animateSwap(aIdx, bIdx) {
        return new Promise(async (resolve) => {
          const a = heap[aIdx];
          const b = heap[bIdx];
          if (!a || !b) return resolve();
          const elA = nodesDom.get(a.id);
          const elB = nodesDom.get(b.id);
          if (!elA || !elB) return resolve();

          // highlight both
          elA.classList.add('highlight');
          elB.classList.add('highlight');

          // swap in heap array
          [heap[aIdx], heap[bIdx]] = [heap[bIdx], heap[aIdx]];

          // re-render positions; CSS transitions will animate top/left
          renderHeapImmediate();

          // wait for animation duration
          await sleep(animDuration);

          // remove highlights
          elA.classList.remove('highlight');
          elB.classList.remove('highlight');

          resolve();
        });
      }

      // Heap operations with action recording
      function heapInsert(item) {
        const actions = [];
        heap.push(item);
        actions.push({type: 'insert', id: item.id});
        let idx = heap.length - 1;
        while (idx > 0) {
          const parentIdx = Math.floor((idx - 1) / 2);
          if (isHigherPriority(heap[idx], heap[parentIdx])) {
            actions.push({type: 'swap', aIdx: idx, bIdx: parentIdx});
            // swap in logical heap for future steps
            [heap[idx], heap[parentIdx]] = [heap[parentIdx], heap[idx]];
            idx = parentIdx;
          } else break;
        }
        // Because we mutated logical heap during building actions, re-build from initial insertion:
        // Simpler: re-create heap by removing item and reinserting while building actions.
        // For clarity: we'll implement a version that simulates without double-swapping by computing swaps first.
        // But here we've already swapped; so to apply actions visually in sequence, we need to reverse-engineer.
        // To keep code correct, we will rebuild heap by removing item and using a pure algorithm that records swaps.

        // Rebuild: remove the item, then re-run pure insert to generate actions
        const insertedId = item.id;
        // remove any inserted copies
        heap = heap.filter(h => h.id !== insertedId);
        // insert all previous state (we need the previous state before insertion). Instead, to keep consistent:
        // We'll maintain a separate logicalHeap for computations. Simpler approach: implement insert that records swaps without mutating heap until executing.
      }

      // We'll implement "computeInsertActions" and "computeRemoveActions" that operate on a copy of heap and return actions.
      function computeInsertActions(currentHeap, newItem) {
        const copy = currentHeap.slice();
        const actions = [];
        copy.push(newItem);
        actions.push({type:'insert', id:newItem.id});
        let idx = copy.length - 1;
        while (idx > 0) {
          const parentIdx = Math.floor((idx - 1) / 2);
          if (isHigherPriority(copy[idx], copy[parentIdx])) {
            actions.push({type:'swap', aIdx: idx, bIdx: parentIdx});
            [copy[idx], copy[parentIdx]] = [copy[parentIdx], copy[idx]];
            idx = parentIdx;
          } else break;
        }
        return actions;
      }
      function computeRemoveActions(currentHeap) {
        // remove root: if empty, no actions. We'll record remove of root id and subsequent swaps.
        const copy = currentHeap.slice();
        const actions = [];
        if (copy.length === 0) return actions;
        const rootId = copy[0].id;
        actions.push({type:'remove', id: rootId});
        if (copy.length === 1) {
          // just remove
          return actions;
        }
        // replace root with last
        copy[0] = copy.pop();
        let idx = 0;
        while (true) {
          const left = 2 * idx + 1;
          const right = 2 * idx + 2;
          let candidate = idx;
          if (left < copy.length && isHigherPriority(copy[left], copy[candidate])) candidate = left;
          if (right < copy.length && isHigherPriority(copy[right], copy[candidate])) candidate = right;
          if (candidate !== idx) {
            actions.push({type:'swap', aIdx: idx, bIdx: candidate});
            [copy[idx], copy[candidate]] = [copy[candidate], copy[idx]];
            idx = candidate;
          } else break;
        }
        return actions;
      }

      // Apply actions physically to the real heap state, sequentially (used during auto mode)
      async function executeActionsAndApply(actions) {
        // We'll replay actions while mutating the real heap in the same way as compute functions assumed.
        for (const act of actions) {
          if (act.type === 'insert') {
            // actual push: find item by id among nodesDom or temporary store
            // We kept new items in nodesDom already, but we need item data stored elsewhere: map from id->item
            // To avoid complications, we'll store pendingItems when inserting.
            const pending = pendingItemsMap.get(act.id);
            if (pending) {
              heap.push(pending);
              pendingItemsMap.delete(act.id);
            }
            renderHeapImmediate();
            await runActionsSequentially([act]); // small pop-in
          } else if (act.type === 'remove') {
            const root = heap[0];
            if (root) {
              // remove root from heap logically
              if (heap.length === 1) {
                heap.pop();
              } else {
                heap[0] = heap.pop();
              }
            }
            renderHeapImmediate();
            await runActionsSequentially([act]);
          } else if (act.type === 'swap') {
            // perform swap in heap and animate
            await runActionsSequentially([act]);
          } else if (act.type === 'highlight') {
            await runActionsSequentially([act]);
          }
        }
      }

      // We will maintain a small map for items freshly created awaiting insertion application
      const pendingItemsMap = new Map();

      // Public operations bound to buttons
      insertBtn.addEventListener('click', async () => {
        const val = valInput.value.trim() || `Item${nextId}`;
        const pr = Number(prioInput.value);
        const id = nextId++;
        const item = {id, value: val, priority: pr};
        // Keep item in pending map for later apply
        pendingItemsMap.set(id, item);
        // create DOM node right away
        createNodeDom(item);
        // compute actions based on current logical heap (without the new item)
        const actions = computeInsertActions(heap, item);
        log(`Insert "${item.value}" (priority ${item.priority}) scheduled.`);
        renderHeapImmediate();
        renderQueueView();
        if (stepMode) {
          pendingActions.push(...actions);
          nextStepBtn.disabled = pendingActions.length === 0;
          updateLogForPending();
          announce(`Insert scheduled. ${pendingActions.length} step(s) pending.`);
        } else {
          // apply actions to logical heap and animate
          await executeActionsAndApply(actions);
          // ensure final heap matches expected final state (rebuild heap)
          applyInsertToHeap(item);
          log(`Inserted "${item.value}" (priority ${item.priority}).`);
          renderHeapImmediate();
          renderQueueView();
        }
      });

      function createNodeDom(item) {
        if (nodesDom.has(item.id)) return;
        const el = document.createElement('div');
        el.className = 'node';
        el.setAttribute('data-id', item.id);
        el.setAttribute('role', 'img');
        el.setAttribute('aria-label', `Item ${item.value} with priority ${item.priority}`);
        el.innerHTML = `<div class="prio">${item.priority}</div><div class="val">${escapeHtml(item.value)}</div>`;
        // start off invisible / near bottom
        el.style.opacity = '0';
        el.style.transform = 'scale(.95)';
        heapArea.appendChild(el);
        nodesDom.set(item.id, el);
        // fade in
        setTimeout(() => { el.style.opacity = '1'; el.style.transform = 'scale(1)'; }, 20);
        // ensure positions after creation
        renderHeapImmediate();
      }

      function applyInsertToHeap(item) {
        // Mutate the logical heap to final correct state by inserting and performing bubble-up
        heap.push(item);
        let idx = heap.length - 1;
        while (idx > 0) {
          const parentIdx = Math.floor((idx - 1) / 2);
          if (isHigherPriority(heap[idx], heap[parentIdx])) {
            [heap[idx], heap[parentIdx]] = [heap[parentIdx], heap[idx]];
            idx = parentIdx;
          } else break;
        }
      }

      // Dequeue
      dequeueBtn.addEventListener('click', async () => {
        if (heap.length === 0) {
          log('Dequeue requested on empty queue.');
          return;
        }
        const actions = computeRemoveActions(heap);
        log('Dequeue scheduled.');
        renderHeapImmediate();
        renderQueueView();
        if (stepMode) {
          pendingActions.push(...actions);
          nextStepBtn.disabled = pendingActions.length === 0;
          updateLogForPending();
          announce(`Dequeue scheduled. ${pendingActions.length} step(s) pending.`);
          return;
        } else {
          // execute actions and apply final logical changes
          await executeActionsAndApply(actions);
          const removed = applyRemoveFromHeap();
          log(`Dequeued "${removed.value}" (priority ${removed.priority}).`);
          renderHeapImmediate();
          renderQueueView();
        }
      });

      function applyRemoveFromHeap() {
        if (heap.length === 0) return null;
        const root = heap[0];
        if (heap.length === 1) {
          heap.pop();
          // remove DOM node
          const el = nodesDom.get(root.id);
          if (el) {
            el.style.opacity = '0';
            setTimeout(() => { if (el && el.parentNode) el.parentNode.removeChild(el); }, animDuration);
            nodesDom.delete(root.id);
          }
          return root;
        }
        // replace root with last, then bubble down
        heap[0] = heap.pop();
        let idx = 0;
        while (true) {
          const left = 2 * idx + 1;
          const right = 2 * idx + 2;
          let candidate = idx;
          if (left < heap.length && isHigherPriority(heap[left], heap[candidate])) candidate = left;
          if (right < heap.length && isHigherPriority(heap[right], heap[candidate])) candidate = right;
          if (candidate !== idx) {
            [heap[idx], heap[candidate]] = [heap[candidate], heap[idx]];
            idx = candidate;
          } else break;
        }
        return root;
      }

      peekBtn.addEventListener('click', () => {
        if (heap.length === 0) {
          log('Peek: queue empty.');
          announce('Queue is empty.');
        } else {
          const root = heap[0];
          log(`Peek: "${root.value}" (priority ${root.priority}).`);
          // highlight root node briefly
          const el = nodesDom.get(root.id);
          if (el) {
            el.classList.add('highlight');
            setTimeout(() => el.classList.remove('highlight'), 500);
          }
          announce(`Peek: ${root.value} with priority ${root.priority}`);
        }
      });

      clearBtn.addEventListener('click', () => {
        heap = [];
        // clear DOM
        for (const el of nodesDom.values()) {
          if (el.parentNode) el.parentNode.removeChild(el);
        }
        nodesDom.clear();
        for (const e of edgesDom.values()) {
          if (e.parentNode) e.parentNode.removeChild(e);
        }
        edgesDom.clear();
        pendingActions = [];
        pendingItemsMap.clear();
        nextStepBtn.disabled = true;
        log('Queue cleared.');
        renderQueueView();
      });

      // Step mode controls
      stepModeCheckbox.addEventListener('change', (e) => {
        stepMode = e.target.checked;
        nextStepBtn.disabled = !stepMode || pendingActions.length === 0;
        log(`Step mode ${stepMode ? 'enabled' : 'disabled'}.`);
      });

      nextStepBtn.addEventListener('click', async () => {
        if (pendingActions.length === 0) return;
        const action = pendingActions.shift();
        nextStepBtn.disabled = pendingActions.length === 0;
        updateLogForPending();
        log(`Executing step: ${action.type}${action.type==='swap' ? ` (${action.aIdx}<->${action.bIdx})` : ''}`);
        // Apply single action
        if (action.type === 'insert') {
          // apply insert: pop from pendingItemsMap and push to heap
          const pending = pendingItemsMap.get(action.id);
          if (pending) {
            heap.push(pending);
            pendingItemsMap.delete(action.id);
          }
          renderHeapImmediate();
          await runActionsSequentially([action]);
        } else if (action.type === 'remove') {
          // logical remove root
          if (heap.length === 1) {
            const root = heap.pop();
            renderHeapImmediate();
            await runActionsSequentially([action]);
            // remove DOM node
            const el = nodesDom.get(root.id);
            if (el) {
              el.style.opacity = '0';
              setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); nodesDom.delete(root.id); }, animDuration);
            }
          } else if (heap.length > 1) {
            // replace root with last
            heap[0] = heap.pop();
            renderHeapImmediate();
            await runActionsSequentially([action]);
          }
        } else if (action.type === 'swap') {
          // perform swap in heap and animate
          const aIdx = action.aIdx;
          const bIdx = action.bIdx;
          // swap
          [heap[aIdx], heap[bIdx]] = [heap[bIdx], heap[aIdx]];
          await runActionsSequentially([action]);
        } else if (action.type === 'highlight') {
          await runActionsSequentially([action]);
        }
        renderHeapImmediate();
        renderQueueView();
      });

      // Speed control
      speedRange.addEventListener('input', (e) => {
        animDuration = Number(e.target.value);
      });

      // Mode change
      modeSelect.addEventListener('change', (e) => {
        isMin = e.target.value === 'min';
        log(`Mode changed to ${isMin ? 'Min-heap' : 'Max-heap'}.`);
        // reheapify current heap to conform to new mode
        heapifyWhole();
        renderHeapImmediate();
        renderQueueView();
      });

      function heapifyWhole() {
        // Build heap from existing items using desired comparator
        // We'll do a standard heapify: from parent nodes downwards
        for (let i = Math.floor(heap.length / 2) - 1; i >= 0; i--) {
          siftDown(i, heap.length);
        }
      }
      function siftDown(i, n) {
        while (true) {
          let candidate = i;
          const left = 2 * i + 1;
          const right = 2 * i + 2;
          if (left < n && isHigherPriority(heap[left], heap[candidate])) candidate = left;
          if (right < n && isHigherPriority(heap[right], heap[candidate])) candidate = right;
          if (candidate === i) break;
          [heap[i], heap[candidate]] = [heap[candidate], heap[i]];
          i = candidate;
        }
      }

      // Utility to show pending actions in log
      function updateLogForPending() {
        // top-of-log message about pending actions
        if (pendingActions.length > 0) {
          log(`Pending steps: ${pendingActions.length}`);
        }
      }

      // Initialize with some demo items
      function seedDemo() {
        const demo = [
          {value: 'Task A', priority: 20},
          {value: 'Task B', priority: 5},
          {value: 'Task C', priority: 14},
          {value: 'Task D', priority: 9}
        ];
        for (const d of demo) {
          const id = nextId++;
          const item = {id, value: d.value, priority: d.priority};
          heap.push(item);
          createNodeDom(item);
        }
        heapifyWhole();
        renderHeapImmediate();
        renderQueueView();
        log('Demo items seeded.');
      }

      // initial render
      renderQueueView();
      renderHeapImmediate();
      seedDemo();

      // helper: ensure correct resize handling
      let resizeTimer;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => { renderHeapImmediate(); }, 80);
      });

      // Expose some debug globals (optional, safe)
      window._pq = {
        heap, nodesDom, edgesDom, renderHeapImmediate, renderQueueView
      };
    })();
  </script>
</body>
</html>