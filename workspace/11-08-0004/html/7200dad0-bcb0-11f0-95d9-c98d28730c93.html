<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Merge Sort Module</title>
  <style>
    /* Safe area padding 24px on all sides */
    :root{
      --safe-pad: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #94a3b8;
      --accent: #38bdf8;
      --accent-2: #7c3aed;
      --ok: #10b981;
      --danger: #fb7185;
      --bar-bg: linear-gradient(180deg,#2563eb 0%, #60a5fa 100%);
    }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#06111a 0%, #071428 100%);
      color:#e6eef8;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .wrap{
      padding: var(--safe-pad);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    header{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
      color:var(--accent);
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    main{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
    }

    /* Two-column layout that becomes stacked on narrow screens */
    .left, .right{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:16px;
      box-sizing:border-box;
    }
    .left{
      width:360px;
      min-width:260px;
      max-width:40%;
      flex-shrink:0;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .right{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      min-width:260px;
      overflow:hidden;
    }

    /* Responsive: stack columns */
    @media (max-width:920px){
      main{flex-direction:column;}
      .left{width:100%;}
    }

    /* Info panel styling for Concept Title, Learning Objective, Interaction Design, Layout Description */
    .info-block{
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.03);
      padding:12px;
      border-radius:8px;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }
    .info-block strong{color:#fff;}

    /* Controls */
    .controls{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .row{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    input[type="text"]{
      flex:1;
      min-width:0;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:transparent;
      color:inherit;
      font-size:14px;
      outline:none;
    }
    button{
      padding:8px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      color:inherit;
      font-size:14px;
      cursor:pointer;
    }
    button.primary{
      background: linear-gradient(180deg, var(--accent), #1fa8da);
      border: none;
      color: #041225;
      font-weight:600;
    }
    .small{
      font-size:13px;
      padding:6px 8px;
    }
    .muted{
      color:var(--muted);
      font-size:13px;
    }

    label{
      font-size:13px;
      color:var(--muted);
    }

    /* Visual area: array bars and recursion list */
    .visual-top{
      display:flex;
      gap:var(--gap);
      align-items:flex-start;
    }
    .array-panel{
      flex:1;
      min-height:220px;
      padding:12px;
      border-radius:8px;
      display:flex;
      flex-direction:column;
      gap:12px;
      border:1px solid rgba(255,255,255,0.03);
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
    }
    .array-line{
      display:flex;
      align-items:end;
      gap:12px;
      padding:8px;
      min-height:140px;
      overflow:hidden;
      justify-content:flex-start;
    }

    .bar{
      --w:36px;
      width:var(--w);
      min-width:28px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      transition: transform 300ms ease, background-color 200ms ease, opacity 180ms ease;
      cursor:pointer;
      user-select:none;
    }
    .bar .rect{
      width:100%;
      background:var(--bar-bg);
      border-radius:8px;
      transition: height 300ms ease, transform 300ms ease, background-color 200ms ease;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      box-shadow: 0 4px 10px rgba(2,6,23,0.6), inset 0 -6px 8px rgba(255,255,255,0.03);
    }
    .bar .label{
      font-size:12px;
      color:var(--muted);
      width:100%;
      text-align:center;
    }

    .bar.highlight .rect{ box-shadow: 0 6px 18px rgba(59,130,246,0.18), inset 0 -6px 8px rgba(255,255,255,0.03); transform:translateY(-6px); }
    .bar.compare .rect{ background: linear-gradient(180deg,#f97316,#fb923c); }
    .bar.overwrite .rect{ background: linear-gradient(180deg,#16a34a,#34d399); }
    .bar.sorted .rect{ background: linear-gradient(180deg,#7c3aed,#a78bfa); }

    .controls-bottom{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }

    /* Recursion list */
    .recursion{
      width:220px;
      min-width:180px;
      max-width:36%;
      border-radius:8px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.03);
      display:flex;
      flex-direction:column;
      gap:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.008), rgba(255,255,255,0.004));
    }
    .stack-item{
      padding:6px 8px;
      border-radius:8px;
      background:rgba(255,255,255,0.012);
      color:var(--muted);
      font-size:13px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      transition: background-color 200ms ease, transform 200ms;
    }
    .stack-item.active{ background: rgba(56,189,248,0.07); color:var(--accent); transform:translateX(6px); }
    .stack-item .range{ font-weight:600; color:#fff; }

    /* Footer stats */
    .stats{
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }

    /* Accessibility focus */
    button:focus, input:focus{
      outline: 3px solid rgba(56,189,248,0.14);
      outline-offset:2px;
    }
  </style>
</head>
<body>
  <div class="wrap" role="main">
    <header>
      <h1>Merge Sort — Interactive Module</h1>
      <p class="subtitle">Visualize divide-and-conquer merging, step through comparisons and overwrites, and experiment with arrays.</p>
    </header>

    <main>
      <section class="left" aria-labelledby="concept-title">
        <div class="info-block" id="concept-title">
          <strong>Concept Title:</strong>
          <div>Merge Sort — stable, divide-and-conquer sorting by recursive splitting and merging.</div>
        </div>

        <div class="info-block">
          <strong>Learning Objective:</strong>
          <div>
            After using this module you will be able to:
            <ul style="margin:8px 0 0 18px; padding:0; color:var(--muted)">
              <li>Understand how an array is split recursively into subarrays.</li>
              <li>See how comparisons and overwrites happen during merging.</li>
              <li>Relate the merge steps to the reconstructed sorted array.</li>
            </ul>
          </div>
        </div>

        <div class="info-block">
          <strong>Interaction Design:</strong>
          <div class="muted">
            - Input an array (comma-separated) or randomize. Use "Play" to animate the full sort, or use "Step" controls to move forward/backward one action at a time. <br>
            - Clicking a bar will allow editing the value. <br>
            - Visual feedback: splitting highlights active subranges in the recursion stack; comparing elements pulse in orange; overwrites animate to green and change height; when a subrange is fully merged it turns purple. <br>
            - Speed slider adjusts animation durations. Keyboard: Space toggles Play/Pause; ← and → step back/forward.
          </div>
        </div>

        <div class="info-block">
          <strong>Layout Description:</strong>
          <div class="muted">
            - Safe area margins: 24px; minimum spacing between controls: 16px. <br>
            - Left column holds descriptive text, controls, and the recursion stack; right column contains the array visualization and controls. <br>
            - Responsive: the two columns stack on narrow screens. All controls are keyboard-focusable and have a minimum hit area. Colors and contrast are chosen for accessibility.
          </div>
        </div>

        <div class="controls" aria-label="controls">
          <div class="row">
            <input id="array-input" type="text" aria-label="Array input" placeholder="e.g. 5,3,8,1,2" />
            <button id="set-array" class="small" title="Set array">Set</button>
          </div>

          <div class="row">
            <button id="randomize" class="primary">Randomize</button>
            <label class="muted" for="size-range">Size</label>
            <input id="size-range" type="range" min="3" max="20" value="8" />
            <label class="muted" for="speed-range">Speed</label>
            <input id="speed-range" type="range" min="0.3" max="2.2" step="0.1" value="1" />
          </div>

          <div class="row controls-bottom">
            <button id="play" class="primary" aria-pressed="false">Play</button>
            <button id="step-back" title="Step backward" class="small">◀</button>
            <button id="step-forward" title="Step forward" class="small">▶</button>
            <button id="reset" class="small">Reset</button>
            <div style="flex:1"></div>
            <div class="muted" id="step-counter">Step: 0 / 0</div>
          </div>

          <div style="display:flex;gap:12px;align-items:center;">
            <div class="muted">Comparisons: <strong id="comp-count">0</strong></div>
            <div class="muted">Writes: <strong id="write-count">0</strong></div>
          </div>
        </div>

        <div class="recursion" aria-live="polite" aria-atomic="true">
          <div style="color:var(--muted); font-size:13px; font-weight:600;">Recursion Stack (active splits)</div>
          <div id="rec-stack" style="display:flex;flex-direction:column;gap:8px;"></div>
        </div>

      </section>

      <section class="right" aria-labelledby="visual-title">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <div style="font-weight:700; font-size:15px;">Array Visualization</div>
            <div class="muted" style="font-size:13px;">Bars represent elements; height proportional to value. Click a bar to edit.</div>
          </div>
          <div class="stats" role="status" aria-live="polite">
            <div class="muted">Speed:</div>
            <div id="speed-display" style="color:var(--accent);font-weight:700;">1x</div>
          </div>
        </div>

        <div class="visual-top">
          <div class="array-panel" aria-label="array-panel">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div class="muted">Array</div>
              <div class="muted" id="array-state">[]</div>
            </div>
            <div class="array-line" id="array-line" role="list" aria-label="array elements"></div>
          </div>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div class="muted">Controls are keyboard accessible. Space: Play/Pause. Arrow keys: step.</div>
          <div class="muted">Click a bar to edit value (numbers only).</div>
        </div>
      </section>
    </main>
  </div>

  <script>
    /*
      Interactive Merge Sort Module
      - Self-contained vanilla JS
      - Records actions: split, compare, overwrite, done
      - Allows play/pause and step forward/back
    */

    (function(){
      // DOM refs
      const arrayInput = document.getElementById('array-input');
      const setArrayBtn = document.getElementById('set-array');
      const randomizeBtn = document.getElementById('randomize');
      const sizeRange = document.getElementById('size-range');
      const speedRange = document.getElementById('speed-range');
      const playBtn = document.getElementById('play');
      const stepFwdBtn = document.getElementById('step-forward');
      const stepBackBtn = document.getElementById('step-back');
      const resetBtn = document.getElementById('reset');
      const arrayLine = document.getElementById('array-line');
      const recStack = document.getElementById('rec-stack');
      const stepCounter = document.getElementById('step-counter');
      const compCountEl = document.getElementById('comp-count');
      const writeCountEl = document.getElementById('write-count');
      const arrayStateEl = document.getElementById('array-state');
      const speedDisplay = document.getElementById('speed-display');

      // State
      let baseArray = [];
      let workingArray = [];
      let bars = [];
      let actions = []; // recorded actions
      let stepIndex = 0; // next action index to apply when stepping forward
      let playing = false;
      let timer = null;
      let compCount = 0, writeCount = 0;
      const MAX_SIZE = 20;

      // Animation timing
      const BASE_STEP_MS = 550; // base ms per action; speed slider scales inverse
      function getStepDuration() {
        const s = parseFloat(speedRange.value);
        return BASE_STEP_MS / s;
      }
      function updateSpeedDisplay(){
        speedDisplay.textContent = speedRange.value + 'x';
      }
      updateSpeedDisplay();

      // Utilities
      function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

      function parseArrayInput(text) {
        const parts = text.split(',').map(p=>p.trim()).filter(p=>p!=='');
        const nums = [];
        for(const p of parts){
          const n = Number(p);
          if(!Number.isFinite(n)) return null;
          nums.push(n);
        }
        return nums;
      }

      function randomArray(n){
        const a = [];
        for(let i=0;i<n;i++){
          a.push(Math.floor(Math.random()*90)+1);
        }
        return a;
      }

      function clampSize(n){ return clamp(n, 3, MAX_SIZE); }

      // Rendering
      function renderArray(arr){
        arrayLine.innerHTML = '';
        bars = [];
        workingArray = arr.slice();
        arrayStateEl.textContent = '[' + arr.join(', ') + ']';
        const maxVal = Math.max(1, ...arr.map(x=>Math.abs(x)));
        const barWidth = Math.max(28, Math.floor((arrayLine.clientWidth - 12) / arr.length) - 12);
        for(let i=0;i<arr.length;i++){
          const v = arr[i];
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.setAttribute('role','listitem');
          bar.setAttribute('tabindex','0');
          bar.dataset.index = i;
          bar.innerHTML = '<div class="rect" style="height: ' + Math.max(18, Math.round((v/maxVal) * 120)) + 'px"></div>' +
                          '<div class="label">' + v + '</div>';
          // click to edit
          bar.addEventListener('click', ()=> promptEditBar(i));
          bar.addEventListener('keydown', (e)=> {
            if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); promptEditBar(i); }
          });
          arrayLine.appendChild(bar);
          bars.push(bar);
        }
      }

      function updateBarHeight(i, value){
        const maxVal = Math.max(1, ...workingArray.map(x=>Math.abs(x)));
        const rect = bars[i].querySelector('.rect');
        const label = bars[i].querySelector('.label');
        rect.style.height = Math.max(18, Math.round((value/maxVal) * 120)) + 'px';
        label.textContent = value;
      }

      // Editing bar value
      function promptEditBar(i){
        const current = workingArray[i];
        const input = prompt('Edit value at index ' + i + ':', String(current));
        if(input === null) return;
        const n = Number(input.trim());
        if(!Number.isFinite(n)) {
          alert('Please enter a valid number.');
          return;
        }
        workingArray[i] = n;
        baseArray[i] = n;
        updateBarHeight(i,n);
        arrayStateEl.textContent = '[' + workingArray.join(', ') + ']';
        resetActions(); // new array -> reset recorded actions
      }

      // Recursion stack UI
      function pushRec(rangeStr){
        const el = document.createElement('div');
        el.className = 'stack-item active';
        el.dataset.range = rangeStr;
        el.innerHTML = '<div class="range">' + rangeStr + '</div><div class="muted">splitting</div>';
        recStack.prepend(el);
      }
      function popRec(rangeStr){
        // remove the first element matching the range from top
        const children = Array.from(recStack.children);
        for(const ch of children){
          if(ch.dataset.range === rangeStr){
            ch.classList.remove('active');
            ch.style.background = 'rgba(0,0,0,0.02)';
            ch.querySelector('.muted').textContent = 'done';
            // remove visually after short delay
            setTimeout(()=>{ if(ch && ch.parentNode) ch.parentNode.removeChild(ch); }, 360);
            break;
          }
        }
      }

      // Action recording for merge sort
      function recordActionsForMergeSort(arr){
        actions = [];
        compCount = 0; writeCount = 0;

        function mergeSort(a, l, r){
          if(l >= r) return;
          actions.push({type:'split', range:[l,r]});
          const mid = Math.floor((l + r) / 2);
          mergeSort(a, l, mid);
          mergeSort(a, mid+1, r);
          // merge step - operate on a copy for indexes
          const temp = [];
          let i = l, j = mid+1;
          while(i <= mid && j <= r){
            actions.push({type:'compare', indices:[i,j]});
            compCount++;
            if(a[i] <= a[j]){
              // overwrite position
              actions.push({type:'overwrite', index: (l + temp.length), newValue: a[i], oldValue: a[l + temp.length]});
              temp.push(a[i]);
              i++;
              writeCount++;
            } else {
              actions.push({type:'overwrite', index: (l + temp.length), newValue: a[j], oldValue: a[l + temp.length]});
              temp.push(a[j]);
              j++;
              writeCount++;
            }
          }
          while(i <= mid){
            actions.push({type:'overwrite', index: (l + temp.length), newValue: a[i], oldValue: a[l + temp.length]});
            temp.push(a[i]); i++; writeCount++;
          }
          while(j <= r){
            actions.push({type:'overwrite', index: (l + temp.length), newValue: a[j], oldValue: a[l + temp.length]});
            temp.push(a[j]); j++; writeCount++;
          }
          // write back into array 'a' for consistent subsequent actions: also push action marking 'done' for range
          for(let k=0;k<temp.length;k++){
            a[l+k] = temp[k];
          }
          actions.push({type:'done', range:[l,r]});
        }

        const copy = arr.slice();
        mergeSort(copy, 0, copy.length - 1);
        // set counters
        compCountEl.textContent = '0';
        writeCountEl.textContent = '0';
        stepIndex = 0;
        updateStepCounter();
      }

      function updateStepCounter(){
        stepCounter.textContent = 'Step: ' + stepIndex + ' / ' + actions.length;
      }

      function resetActions(){
        // reset visual states and re-generate actions for current baseArray
        stopPlaying();
        recordActionsForMergeSort(baseArray.slice());
        // reset UI
        compCount = 0; writeCount = 0;
        compCountEl.textContent = compCount;
        writeCountEl.textContent = writeCount;
        // reset working array to base
        workingArray = baseArray.slice();
        renderArray(workingArray);
        // clear recursion stack
        recStack.innerHTML = '';
        updateStepCounter();
      }

      // Apply and revert actions
      function applyAction(action, forward=true){
        switch(action.type){
          case 'split':
            {
              const [l,r] = action.range;
              if(forward){
                pushRec('['+l+'..'+r+']');
              } else {
                popRec('['+l+'..'+r+']');
              }
            }
            break;
          case 'compare':
            {
              const [a,b] = action.indices;
              const barA = bars[a];
              const barB = bars[b];
              if(forward){
                barA.classList.add('compare');
                barB.classList.add('compare');
                compCount++;
                compCountEl.textContent = compCount;
                // remove compare highlight after short duration
                setTimeout(()=>{ barA.classList.remove('compare'); barB.classList.remove('compare'); }, getStepDuration() * 0.9);
              } else {
                // when reverting a compare we simply decrement counter and ensure classes removed
                compCount = Math.max(0, compCount - 1);
                compCountEl.textContent = compCount;
                barA.classList.remove('compare');
                barB.classList.remove('compare');
              }
            }
            break;
          case 'overwrite':
            {
              const idx = action.index;
              if(forward){
                // store the oldValue (already stored in action.oldValue)
                const oldVal = workingArray[idx];
                action._appliedOld = oldVal; // store for robust revert
                workingArray[idx] = action.newValue;
                writeCount++;
                writeCountEl.textContent = writeCount;
                // animate bar
                const b = bars[idx];
                b.classList.add('overwrite');
                updateBarHeight(idx, action.newValue);
                arrayStateEl.textContent = '[' + workingArray.join(', ') + ']';
                setTimeout(()=>{ b.classList.remove('overwrite'); }, getStepDuration() * 0.9);
              } else {
                // revert to previous value
                const old = (typeof action._appliedOld !== 'undefined') ? action._appliedOld : action.oldValue;
                workingArray[idx] = old;
                writeCount = Math.max(0, writeCount - 1);
                writeCountEl.textContent = writeCount;
                const b = bars[idx];
                b.classList.add('overwrite');
                updateBarHeight(idx, old);
                arrayStateEl.textContent = '[' + workingArray.join(', ') + ']';
                setTimeout(()=>{ b.classList.remove('overwrite'); }, getStepDuration() * 0.7);
              }
            }
            break;
          case 'done':
            {
              const [l,r] = action.range;
              if(forward){
                for(let i=l;i<=r;i++){
                  bars[i].classList.add('sorted');
                }
                // also pop split visual if present
                popRec('['+l+'..'+r+']');
              } else {
                for(let i=l;i<=r;i++){
                  bars[i].classList.remove('sorted');
                }
                // nothing else
              }
            }
            break;
        }
        updateStepCounter();
      }

      // Step forward
      function stepForward(){
        if(stepIndex >= actions.length) { stopPlaying(); return; }
        const action = actions[stepIndex];
        applyAction(action, true);
        stepIndex++;
        updateStepCounter();
      }
      // Step back (revert previous action)
      function stepBack(){
        if(stepIndex <= 0) return;
        stepIndex--;
        const action = actions[stepIndex];
        applyAction(action, false);
        updateStepCounter();
      }

      // Play controls
      function startPlaying(){
        if(playing) return;
        playing = true;
        playBtn.textContent = 'Pause';
        playBtn.setAttribute('aria-pressed', 'true');
        runPlayLoop();
      }
      function stopPlaying(){
        playing = false;
        playBtn.textContent = 'Play';
        playBtn.setAttribute('aria-pressed', 'false');
        if(timer) { clearTimeout(timer); timer = null; }
      }
      function runPlayLoop(){
        if(!playing) return;
        if(stepIndex >= actions.length){
          stopPlaying();
          return;
        }
        stepForward();
        timer = setTimeout(()=> {
          runPlayLoop();
        }, getStepDuration());
      }

      // Initialize with random array
      function initialize(){
        const size = clampSize(Number(sizeRange.value));
        baseArray = randomArray(size);
        arrayInput.value = baseArray.join(', ');
        renderArray(baseArray);
        recordActionsForMergeSort(baseArray.slice());
      }

      // Event bindings
      setArrayBtn.addEventListener('click', ()=>{
        const parsed = parseArrayInput(arrayInput.value);
        if(!parsed || parsed.length === 0){
          alert('Enter a comma-separated list of numbers (3..20 items).');
          return;
        }
        if(parsed.length > MAX_SIZE){
          alert('Max size is ' + MAX_SIZE + '.');
          return;
        }
        baseArray = parsed.slice();
        sizeRange.value = clampSize(parsed.length);
        renderArray(baseArray);
        resetActions();
      });

      randomizeBtn.addEventListener('click', ()=>{
        const n = clampSize(Number(sizeRange.value));
        baseArray = randomArray(n);
        arrayInput.value = baseArray.join(', ');
        renderArray(baseArray);
        resetActions();
      });

      sizeRange.addEventListener('input', ()=>{
        const n = clampSize(Number(sizeRange.value));
        baseArray = randomArray(n);
        arrayInput.value = baseArray.join(', ');
        renderArray(baseArray);
        resetActions();
      });

      speedRange.addEventListener('input', ()=>{
        updateSpeedDisplay();
      });

      playBtn.addEventListener('click', ()=>{
        if(playing) stopPlaying();
        else startPlaying();
      });

      stepFwdBtn.addEventListener('click', ()=>{
        stopPlaying();
        stepForward();
      });

      stepBackBtn.addEventListener('click', ()=>{
        stopPlaying();
        stepBack();
      });

      resetBtn.addEventListener('click', ()=>{
        stopPlaying();
        // revert everything to baseArray
        workingArray = baseArray.slice();
        renderArray(workingArray);
        recStack.innerHTML = '';
        compCount = 0; writeCount = 0;
        compCountEl.textContent = compCount;
        writeCountEl.textContent = writeCount;
        recordActionsForMergeSort(baseArray.slice());
      });

      // keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
        if(e.key === ' '){
          e.preventDefault();
          if(playing) stopPlaying(); else startPlaying();
        } else if(e.key === 'ArrowRight'){
          e.preventDefault();
          stopPlaying();
          stepForward();
        } else if(e.key === 'ArrowLeft'){
          e.preventDefault();
          stopPlaying();
          stepBack();
        }
      });

      // Resize: re-render heights for responsive
      window.addEventListener('resize', ()=>{
        renderArray(workingArray);
      });

      // Initialize module
      initialize();

    })();
  </script>
</body>
</html>