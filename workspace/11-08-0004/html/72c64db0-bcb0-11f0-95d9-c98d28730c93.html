<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Priority Queue (Min-Heap) — Learning Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #94a3b8;
      --accent: #06b6d4;
      --accent-2: #7c3aed;
      --card: #0b1220;
      --text: #e6eef6;
      --success: #10b981;
      --danger: #ef4444;
      --node-size: 56px;
      --transition: 400ms;
    }

    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071027 0%, #041022 100%);
      color:var(--text);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Safe area margins */
    .app {
      padding:var(--safe-margin);
      box-sizing:border-box;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }

    header {
      display:flex;
      flex-direction:column;
      gap:8px;
      max-width:1200px;
      margin:0 auto;
    }

    h1{
      margin:0;
      font-size:20px;
      letter-spacing:-0.3px;
    }

    .meta {
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }

    .module {
      display:flex;
      gap:var(--gap);
      max-width:1200px;
      margin:0 auto;
      align-items:flex-start;
    }

    /* Left column: explanation & controls */
    .left {
      flex:0 1 360px;
      min-width:260px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.03);
      border-radius:12px;
      padding:18px;
      box-sizing:border-box;
    }

    .section {
      margin-bottom:16px;
    }
    .section h2 {
      margin:0 0 8px 0;
      font-size:15px;
    }
    .section p {
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    label {
      display:block;
      font-size:13px;
      color:var(--muted);
      margin-bottom:8px;
    }

    .controls {
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
      align-items:center;
      margin-top:8px;
    }

    input[type="number"]{
      width:120px;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.06);
      background:transparent;
      color:var(--text);
      outline:none;
      box-sizing:border-box;
    }
    input[type="number"]::placeholder{ color: rgba(255,255,255,0.22); }

    .btn {
      padding:8px 12px;
      border-radius:8px;
      border:0;
      cursor:pointer;
      background:linear-gradient(180deg,var(--accent), #06b0c9);
      color:#042029;
      font-weight:600;
      box-shadow:0 6px 18px rgba(6,182,212,0.08);
      min-width:86px;
    }
    .btn.secondary {
      background:transparent;
      border:1px solid rgba(255,255,255,0.04);
      color:var(--text);
      font-weight:600;
      min-width:86px;
      padding:8px 10px;
    }
    .btn.warn {
      background:linear-gradient(180deg,#ef4444,#dc2626);
      color:white;
    }

    .small {
      font-size:13px;
      color:var(--muted);
    }

    /* Right column: visualization */
    .right {
      flex:1 1 0;
      min-width:320px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.03);
      padding:18px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      align-items:stretch;
      justify-content:flex-start;
    }

    .viz-stage {
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:8px;
      padding:12px;
      min-height:260px;
      position:relative;
      overflow:visible;
    }

    /* Node common */
    .node {
      position:absolute;
      width:var(--node-size);
      height:var(--node-size);
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      background:linear-gradient(180deg,#0ea5a4,#02848a);
      color:#012026;
      font-weight:700;
      box-shadow:0 8px 22px rgba(2,132,138,0.14);
      transform:translate(-50%, -50%);
      transition: transform var(--transition) cubic-bezier(.2,.9,.2,1), box-shadow var(--transition), background var(--transition);
      z-index:10;
    }

    .node.max {
      background:linear-gradient(180deg,#8b5cf6,#6d28d9);
      color:#fff;
    }

    .node .priority {
      font-size:14px;
    }

    .node.compare {
      box-shadow:0 14px 30px rgba(7,89,100,0.28);
      transform:translate(-50%, -50%) scale(1.08);
    }

    .node.removed {
      opacity:0.06;
      transform:translate(-50%, -50%) scale(0.9);
    }

    /* lines between parent-child */
    .line {
      position:absolute;
      height:2px;
      background:linear-gradient(90deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      transform-origin:left center;
      z-index:5;
      transition:opacity var(--transition);
    }

    /* array representation */
    .array-row {
      display:flex;
      gap:12px;
      align-items:center;
      padding:8px;
      flex-wrap:wrap;
    }

    .array-cell {
      min-width:48px;
      height:48px;
      border-radius:8px;
      border:1px dashed rgba(255,255,255,0.04);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      background:rgba(255,255,255,0.02);
      color:var(--muted);
    }

    .array-cell.present {
      border-style:solid;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      color:var(--text);
    }

    .log {
      min-height:56px;
      max-height:140px;
      overflow:auto;
      padding:8px;
      border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border:1px solid rgba(255,255,255,0.02);
      font-size:13px;
      color:var(--muted);
    }

    .controls-row {
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }

    .speed {
      display:flex;
      align-items:center;
      gap:8px;
      color:var(--muted);
      font-size:13px;
    }

    input[type="range"]{
      -webkit-appearance:none;
      appearance:none;
      height:6px;
      background:linear-gradient(90deg, #06b6d4, #7c3aed);
      border-radius:6px;
      outline:none;
      width:160px;
    }

    footer {
      max-width:1200px;
      margin:0 auto;
      color:var(--muted);
      font-size:13px;
    }

    /* responsiveness */
    @media (max-width:880px){
      .module { flex-direction:column; }
      .left, .right { width:100%; }
    }

    /* focus outlines for accessibility */
    button:focus, input:focus {
      outline:3px solid rgba(6,182,212,0.16);
      outline-offset:2px;
    }

  </style>
</head>
<body>
  <div class="app" role="main">
    <header>
      <h1>Concept Title: Priority Queue (Min-Heap implementation)</h1>
      <div class="meta">
        <div>Interactive module demonstrating how a priority queue operates using a binary min-heap.</div>
        <div aria-hidden="true">•</div>
        <div>Safe margins: 24px · Spacing: ≥16px · Accessible & responsive</div>
      </div>
    </header>

    <div class="module" role="region" aria-label="Priority queue interactive module">
      <!-- Left column -->
      <aside class="left" role="complementary" aria-label="Controls and explanation">
        <div class="section">
          <h2>Learning Objective</h2>
          <p>
            After interacting with this module you will understand how a min-priority queue maintains the smallest-priority element at the root by using a binary heap.
            You will see the array layout, node comparisons, and the sequence of swaps (sift-up on insert, sift-down on remove).
          </p>
        </div>

        <div class="section" aria-live="polite">
          <h2>Interaction Design</h2>
          <p class="small">
            Use the controls below to insert numbers (priorities), extract the minimum, or auto-generate values.
            Animations show comparisons and swaps; a step mode lets you step through each individual comparison.
          </p>
        </div>

        <div class="section">
          <h2>Controls</h2>
          <label for="valueInput">Insert a priority (integer)</label>
          <div class="controls" role="form" aria-label="Insert controls">
            <input id="valueInput" type="number" placeholder="e.g., 42" aria-label="Priority value input" />
            <button id="insertBtn" class="btn" aria-label="Insert into priority queue">Insert</button>
            <button id="randBtn" class="btn secondary" aria-label="Insert random number">Random</button>
            <button id="extractBtn" class="btn warn" aria-label="Extract minimum">Extract Min</button>
          </div>
        </div>

        <div class="section">
          <div class="controls-row">
            <div class="speed" title="Control animation speed">
              <label for="speedRange" class="small">Animation speed</label>
              <input id="speedRange" type="range" min="0.3" max="2.0" step="0.1" value="1" aria-label="Animation speed" />
              <div id="speedLabel" class="small">1.0×</div>
            </div>

            <div style="display:flex; gap:12px; align-items:center;">
              <label class="small" style="margin-right:6px;">Step mode</label>
              <button id="stepToggle" class="btn secondary" aria-pressed="false" aria-label="Toggle step mode">Off</button>
              <button id="stepBtn" class="btn secondary" disabled aria-label="Next step">Step</button>
            </div>
          </div>
        </div>

        <div class="section">
          <h2>Layout Description</h2>
          <p class="small">
            Left column contains explanatory text and controls. The right column shows a visual heap (tree) at top, array representation below,
            and an operation log at the bottom. Elements are spaced with at least 16px and margins of 24px are preserved.
          </p>
        </div>

        <div class="section">
          <div class="controls">
            <button id="clearBtn" class="btn secondary" aria-label="Clear the priority queue">Clear</button>
            <button id="populateBtn" class="btn" aria-label="Populate with sample values">Sample Build</button>
          </div>
        </div>

      </aside>

      <!-- Right column -->
      <section class="right" role="main" aria-label="Visualization and state">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div>
            <strong>Visualization</strong>
            <div class="small" style="color:var(--muted); margin-top:6px;">Nodes move smoothly to show comparisons and swaps.</div>
          </div>
          <div class="small" id="countDisplay" aria-live="polite">Size: 0</div>
        </div>

        <div class="viz-stage" id="vizStage" aria-hidden="false" title="Heap tree visualization">
          <!-- SVG lines and node elements will be managed by JS -->
        </div>

        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div>
            <strong>Array representation</strong>
            <div class="small" style="color:var(--muted);">Heap stored in an array (index 0 is root).</div>
          </div>
          <div class="small" id="rootValue">Root: —</div>
        </div>

        <div class="array-row" id="arrayRow" role="list" aria-live="polite" aria-label="Heap array representation">
          <!-- Cells -->
        </div>

        <div>
          <strong>Operation log</strong>
          <div class="log" id="log" aria-live="polite" role="log"></div>
        </div>
      </section>
    </div>

    <footer>
      Tip: Try inserting values in different orders and extracting repeatedly to watch how the heap reorganizes to keep the minimum at the root.
    </footer>
  </div>

  <script>
    // Priority Queue (Min-Heap) Interactive Module
    // Self-contained, vanilla JS. Accessible controls, animations, step mode.

    // DOM references
    const vizStage = document.getElementById('vizStage');
    const arrayRow = document.getElementById('arrayRow');
    const logEl = document.getElementById('log');
    const countDisplay = document.getElementById('countDisplay');
    const rootValue = document.getElementById('rootValue');

    const valueInput = document.getElementById('valueInput');
    const insertBtn = document.getElementById('insertBtn');
    const randBtn = document.getElementById('randBtn');
    const extractBtn = document.getElementById('extractBtn');
    const clearBtn = document.getElementById('clearBtn');
    const populateBtn = document.getElementById('populateBtn');

    const speedRange = document.getElementById('speedRange');
    const speedLabel = document.getElementById('speedLabel');
    const stepToggle = document.getElementById('stepToggle');
    const stepBtn = document.getElementById('stepBtn');

    // state
    let heap = []; // array of numbers
    let nodeElements = []; // element per index
    let lines = []; // connecting divs
    let animQueue = []; // queued animation steps
    let isAnimating = false;
    let stepMode = false;
    let pendingStepResolve = null;
    let speedMultiplier = 1.0;

    // config
    const NODE_SIZE = 56;
    const H_GAP = 22;
    const BASE_ANIM_DURATION = 400; // ms (multiplied by speedMultiplier)
    const MIN_GAP = 16;

    // utility logging
    function log(text, type='') {
      const time = new Date().toLocaleTimeString();
      const p = document.createElement('div');
      p.textContent = `[${time}] ${text}`;
      logEl.prepend(p);
    }

    function updateCount() {
      countDisplay.textContent = `Size: ${heap.length}`;
      rootValue.textContent = `Root: ${heap.length ? heap[0] : '—'}`;
    }

    // create or update visuals
    function rebuildVisuals() {
      // Clear existing nodes and lines
      vizStage.innerHTML = '';
      nodeElements = [];
      lines = [];

      const width = vizStage.clientWidth;
      const maxLevel = Math.floor(Math.log2(Math.max(1, heap.length))) + 1;
      const centerX = width / 2;

      // compute positions by level and order
      const positions = [];
      for (let i = 0; i < heap.length; i++) {
        const level = Math.floor(Math.log2(i + 1));
        const indexInLevel = i - (Math.pow(2, level) - 1);
        const itemsInLevel = Math.pow(2, level);
        const verticalSpacing = Math.max(64, 100 - (maxLevel - 1) * 6);
        const y = 28 + level * verticalSpacing;
        const totalWidth = Math.min(width - 80, itemsInLevel * (NODE_SIZE + H_GAP));
        const startX = centerX - totalWidth / 2 + NODE_SIZE / 2;
        const x = startX + indexInLevel * (totalWidth / itemsInLevel);
        positions.push({ x, y });
      }

      // create lines first (so they appear under nodes)
      for (let i = 0; i < heap.length; i++) {
        const parentIndex = i;
        const leftChild = 2 * i + 1;
        const rightChild = 2 * i + 2;
        [leftChild, rightChild].forEach(child => {
          if (child < heap.length) {
            const line = document.createElement('div');
            line.className = 'line';
            line.style.left = positions[parentIndex].x + 'px';
            line.style.top = positions[parentIndex].y + 'px';
            // set rotation and length to child
            const dx = positions[child].x - positions[parentIndex].x;
            const dy = positions[child].y - positions[parentIndex].y;
            const length = Math.sqrt(dx*dx + dy*dy);
            const angle = Math.atan2(dy, dx) * (180 / Math.PI);
            line.style.width = length + 'px';
            line.style.transform = `translate(-0%, -50%) rotate(${angle}deg)`;
            line.style.opacity = '1';
            vizStage.appendChild(line);
            lines.push(line);
          }
        });
      }

      // create node elements
      for (let i = 0; i < heap.length; i++) {
        const pos = positions[i];
        const node = document.createElement('div');
        node.className = 'node';
        node.setAttribute('data-index', i);
        node.setAttribute('role', 'listitem');
        node.setAttribute('aria-label', `Node index ${i} value ${heap[i]}`);
        node.tabIndex = 0;
        node.style.left = pos.x + 'px';
        node.style.top = pos.y + 'px';
        const span = document.createElement('div');
        span.className = 'priority';
        span.textContent = heap[i];
        node.appendChild(span);
        vizStage.appendChild(node);
        nodeElements.push(node);
      }

      // update array representation
      renderArray();
      updateCount();
    }

    function renderArray(highlightIndices = []) {
      arrayRow.innerHTML = '';
      for (let i = 0; i < heap.length; i++) {
        const cell = document.createElement('div');
        cell.className = 'array-cell present';
        cell.textContent = heap[i];
        cell.title = `Index ${i}`;
        if (i === 0) {
          cell.style.boxShadow = 'inset 0 0 0 2px rgba(6,182,212,0.06)';
        }
        if (highlightIndices.includes(i)) {
          cell.style.background = 'linear-gradient(180deg, rgba(6,182,212,0.12), rgba(124,58,237,0.06))';
        }
        arrayRow.appendChild(cell);
      }
      if (heap.length === 0) {
        const placeholder = document.createElement('div');
        placeholder.className = 'array-cell';
        placeholder.style.opacity = 0.6;
        placeholder.textContent = '—';
        arrayRow.appendChild(placeholder);
      }
    }

    // helper to wait for animations or step resolution
    function waitForAnimation(duration) {
      return new Promise(resolve => {
        if (stepMode) {
          // Wait until step button pressed
          pendingStepResolve = resolve;
          stepBtn.disabled = false;
        } else {
          setTimeout(resolve, duration);
        }
      });
    }

    // perform swap animation between indices i and j
    async function animateSwap(i, j) {
      if (!nodeElements[i] || !nodeElements[j]) {
        // fallback: rebuild visuals and return
        rebuildVisuals();
        await waitForAnimation(BASE_ANIM_DURATION * speedMultiplier);
        return;
      }
      const nodeI = nodeElements[i];
      const nodeJ = nodeElements[j];

      // highlight
      nodeI.classList.add('compare');
      nodeJ.classList.add('compare');
      renderArray([i,j]);

      // swap positions in DOM visually by swapping transform positions
      // read current positions (left/top)
      const rectI = nodeI.getBoundingClientRect();
      const rectJ = nodeJ.getBoundingClientRect();
      const parentRect = vizStage.getBoundingClientRect();
      const xi = rectI.left + rectI.width/2 - parentRect.left;
      const yi = rectI.top + rectI.height/2 - parentRect.top;
      const xj = rectJ.left + rectJ.width/2 - parentRect.left;
      const yj = rectJ.top + rectJ.height/2 - parentRect.top;

      // set immediate transform to current absolute coordinates (to enable smooth transition)
      nodeI.style.transition = `transform ${BASE_ANIM_DURATION * speedMultiplier}ms cubic-bezier(.2,.9,.2,1)`;
      nodeJ.style.transition = `transform ${BASE_ANIM_DURATION * speedMultiplier}ms cubic-bezier(.2,.9,.2,1)`;
      nodeI.style.transform = `translate(${xj - xi}px, ${yj - yi}px) translate(-50%, -50%) scale(1.08)`;
      nodeJ.style.transform = `translate(${xi - xj}px, ${yi - yj}px) translate(-50%, -50%) scale(1.08)`;

      // wait for animation
      await waitForAnimation(BASE_ANIM_DURATION * speedMultiplier);

      // clear transform and rebuild visuals to reflect new array indexes
      nodeI.style.transition = '';
      nodeJ.style.transition = '';
      nodeI.classList.remove('compare');
      nodeJ.classList.remove('compare');

      rebuildVisuals();
    }

    // swap helper (array-level)
    function arraySwap(i, j) {
      const tmp = heap[i];
      heap[i] = heap[j];
      heap[j] = tmp;
    }

    // Sift-up (bubble-up) with step recording
    async function siftUp(index) {
      let i = index;
      while (i > 0) {
        const parent = Math.floor((i - 1) / 2);
        log(`Compare node ${i} (${heap[i]}) with parent ${parent} (${heap[parent]})`);
        if (heap[i] < heap[parent]) {
          log(`Swap: ${heap[i]} < ${heap[parent]} → swapping indices ${i} and ${parent}`);
          arraySwap(i, parent);
          await animateSwap(i, parent);
          i = parent;
        } else {
          // indicate comparison but no swap
          await indicateNoSwap(i, parent);
          break;
        }
      }
    }

    // Sift-down (after extracting root)
    async function siftDown(index=0) {
      let i = index;
      const n = heap.length;
      while (true) {
        const left = 2 * i + 1;
        const right = 2 * i + 2;
        let smallest = i;
        if (left < n && heap[left] < heap[smallest]) smallest = left;
        if (right < n && heap[right] < heap[smallest]) smallest = right;

        if (smallest !== i) {
          log(`Compare node ${i} (${heap[i]}) with child ${smallest} (${heap[smallest]}) → swap`);
          arraySwap(i, smallest);
          await animateSwap(i, smallest);
          i = smallest;
        } else {
          // show a comparison highlight then stop
          if (left < n) {
            await indicateNoSwap(i, left);
          }
          break;
        }
      }
    }

    async function indicateNoSwap(i, j) {
      // highlight comparison briefly without swapping
      const ni = nodeElements[i];
      const nj = nodeElements[j];
      if (ni) ni.classList.add('compare');
      if (nj) nj.classList.add('compare');
      renderArray([i,j]);
      await waitForAnimation((BASE_ANIM_DURATION/1.6) * speedMultiplier);
      if (ni) ni.classList.remove('compare');
      if (nj) nj.classList.remove('compare');
      renderArray();
    }

    // Public operations
    async function insertValue(value) {
      heap.push(value);
      rebuildVisuals();
      log(`Insert ${value} → add at index ${heap.length - 1}`);
      // animate sift-up
      await siftUp(heap.length - 1);
      updateCount();
    }

    async function extractMin() {
      if (heap.length === 0) {
        log('Extract attempted on empty queue');
        return;
      }
      const min = heap[0];
      log(`Extract min → ${min}`);
      if (heap.length === 1) {
        heap.pop();
        rebuildVisuals();
        await waitForAnimation((BASE_ANIM_DURATION/2) * speedMultiplier);
        updateCount();
        return min;
      }
      // move last into root
      heap[0] = heap.pop();
      // animate root swap (root with last index visually)
      // We will simulate a swap between indices 0 and heap.length (old last)
      rebuildVisuals(); // ensure elements exist
      await siftDown(0);
      updateCount();
      return min;
    }

    // Event handlers
    insertBtn.addEventListener('click', async () => {
      const val = valueInput.value.trim();
      if (val === '') {
        valueInput.focus();
        return;
      }
      const num = Number(val);
      if (!Number.isFinite(num)) {
        log('Invalid number');
        return;
      }
      // disable controls during animation
      disableControls(true);
      await insertValue(num);
      disableControls(false);
    });

    randBtn.addEventListener('click', async () => {
      const num = Math.floor(Math.random() * 99) + 1;
      valueInput.value = num;
      insertBtn.click();
    });

    extractBtn.addEventListener('click', async () => {
      disableControls(true);
      await extractMin();
      disableControls(false);
    });

    clearBtn.addEventListener('click', () => {
      heap = [];
      rebuildVisuals();
      log('Cleared heap');
      updateCount();
    });

    populateBtn.addEventListener('click', async () => {
      disableControls(true);
      const sample = [30, 20, 15, 5, 10, 12, 6];
      // Build step-by-step (inserts)
      for (let v of sample) {
        await insertValue(v);
      }
      disableControls(false);
      log('Sample build completed');
    });

    // speed control
    speedRange.addEventListener('input', () => {
      speedMultiplier = Number(speedRange.value);
      speedLabel.textContent = speedMultiplier.toFixed(1) + '×';
    });

    // step mode
    stepToggle.addEventListener('click', () => {
      stepMode = !stepMode;
      stepToggle.textContent = stepMode ? 'On' : 'Off';
      stepToggle.setAttribute('aria-pressed', '' + stepMode);
      stepBtn.disabled = !stepMode;
      log(`Step mode ${stepMode ? 'enabled' : 'disabled'}`);
    });

    stepBtn.addEventListener('click', () => {
      if (pendingStepResolve) {
        pendingStepResolve();
        pendingStepResolve = null;
        stepBtn.disabled = true;
      }
    });

    function disableControls(disabled) {
      insertBtn.disabled = disabled;
      randBtn.disabled = disabled;
      extractBtn.disabled = disabled;
      clearBtn.disabled = disabled;
      populateBtn.disabled = disabled;
      valueInput.disabled = disabled;
      stepToggle.disabled = disabled;
      speedRange.disabled = disabled;
      if (disabled) {
        document.activeElement && document.activeElement.blur();
      }
    }

    // handle window resize: rebuild visualization positions
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        rebuildVisuals();
      }, 120);
    });

    // initialize
    rebuildVisuals();
    updateCount();
    log('Module ready — insert values to begin');

    // Keyboard accessibility: Enter to insert when input focused
    valueInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        insertBtn.click();
      }
    });

    // Some helpful aria/live messages for operations
    const observer = new MutationObserver(() => {
      // whenever log changes, keep it scrolled to top (newest first)
      // we show newest at top by prepending, so nothing needed.
    });
    observer.observe(logEl, { childList: true });

    // Basic demo: small seed (optional)
    // (commented out; user can click Sample Build)
    // sample insert
    // (No auto-run to respect user control)

  </script>
</body>
</html>