<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Two Pointers — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa4b2;
      --accent: #2dd4bf;
      --accent-2: #60a5fa;
      --danger: #fb7185;
      --box-bg: #071028;
      --box-border: #183049;
      --success: #34d399;
      --text: #e6eef6;
      --glass: rgba(255,255,255,0.03);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      font-size: 16px;
    }
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,var(--bg), #07102a 60%);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    /* Safe area */
    .app {
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }
    header{
      display:flex;
      flex-direction: column;
      gap:8px;
    }
    h1{
      margin:0;
      font-size:1.25rem;
      letter-spacing: -0.02em;
    }
    p.lead {
      margin:0;
      color:var(--muted);
      font-size:0.95rem;
    }

    /* Layout columns */
    .main {
      display: grid;
      gap: var(--gap);
      grid-template-columns: 320px 1fr;
      align-items:start;
    }
    /* Responsive */
    @media (max-width: 880px){
      .main {
        grid-template-columns: 1fr;
      }
    }

    /* Controls panel */
    .controls {
      background: linear-gradient(180deg,var(--panel), rgba(255,255,255,0.02));
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
      min-width: 240px;
    }
    .controls .group {
      display:flex;
      flex-direction:column;
      gap:12px;
      margin-bottom:12px;
    }
    label {
      font-size:0.9rem;
      color:var(--muted);
    }
    input[type="text"], input[type="number"], textarea {
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.04);
      color:var(--text);
      padding:8px 10px;
      border-radius:8px;
      font-size:0.95rem;
      outline:none;
    }
    .small-row { display:flex; gap:12px; align-items:center; }
    button {
      background:linear-gradient(180deg,var(--accent), #0fb2a2);
      color:#012;
      border:0;
      padding:10px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      transition: transform 120ms ease, box-shadow 120ms;
    }
    button.secondary {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      color:var(--text);
      border:1px solid rgba(255,255,255,0.04);
      font-weight:600;
    }
    button:active{ transform: translateY(1px) }
    .btn-row{ display:flex; gap:12px; flex-wrap:wrap; }

    .controls .hint { font-size:0.85rem; color:var(--muted); }

    /* Visual panel */
    .visual {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
      border-radius:12px;
      padding:18px;
      min-height: 360px;
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    /* Array display */
    .array-area {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));
      padding: 18px;
      border-radius:12px;
      position:relative;
      overflow:visible;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
    }
    .array-container {
      display:flex;
      gap:12px;
      align-items:flex-end;
      justify-content:center;
      width:100%;
      min-height: 80px;
      flex-wrap:wrap;
      padding:6px;
    }
    .box {
      min-width: 48px;
      height: 48px;
      background: var(--box-bg);
      border: 1px solid var(--box-border);
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:8px;
      color:var(--text);
      font-weight:600;
      transition: transform 300ms cubic-bezier(.2,.8,.2,1), background 180ms;
      position:relative;
    }
    .box.highlight {
      box-shadow: 0 6px 20px rgba(2,210,180,0.12);
      transform: translateY(-6px) scale(1.03);
      background: linear-gradient(180deg, rgba(45,212,191,0.12), rgba(45,212,191,0.04));
    }
    .box.pulse {
      animation: pulse 900ms ease;
    }
    @keyframes pulse {
      0% { transform: translateY(-2px) scale(1); box-shadow: none; }
      50% { transform: translateY(-8px) scale(1.04); box-shadow: 0 12px 30px rgba(45,212,191,0.12); }
      100% { transform: translateY(-6px) scale(1.02); box-shadow: none; }
    }

    /* Pointers */
    .pointer {
      position:absolute;
      top:calc(100% - 38px);
      width:64px;
      height:32px;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:8px;
      font-weight:700;
      color:#052022;
      transform: translateX(-50%);
      pointer-events:none;
      transition: left 420ms cubic-bezier(.2,.9,.3,1), transform 180ms;
    }
    .pointer.l {
      background: linear-gradient(180deg,var(--accent-2), #2a6fda);
      left: 0;
    }
    .pointer.r {
      background: linear-gradient(180deg,var(--accent), #0fa18f);
      left: 100%;
    }
    .arrow {
      position:absolute;
      top:-12px;
      width:0;height:0;
      border-left:8px solid transparent;
      border-right:8px solid transparent;
      border-bottom:12px solid rgba(255,255,255,0.06);
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.4));
    }
    .pointer .label { font-size:0.9rem; }

    /* Result panel */
    .result {
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      padding:12px;
      background: rgba(255,255,255,0.01);
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .result .big {
      font-size:1rem;
      color:var(--text);
      font-weight:700;
    }
    .result .explain { color:var(--muted); font-size:0.95rem; }

    .log {
      margin-top:6px;
      max-height:160px;
      overflow:auto;
      padding:10px;
      background: rgba(255,255,255,0.015);
      border-radius:8px;
      font-size:0.9rem;
      color:var(--muted);
      border:1px dashed rgba(255,255,255,0.02);
    }
    .log-entry {
      padding:6px 0;
      border-bottom:1px solid rgba(255,255,255,0.02);
    }
    .log-entry strong { color:var(--text); font-weight:700; margin-right:6px; }

    .status {
      display:flex;
      gap:12px;
      align-items:center;
      color:var(--muted);
      font-size:0.9rem;
    }
    .chip {
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.02);
      font-weight:600;
      color:var(--text);
    }

    /* Accessibility focus */
    input:focus, button:focus, textarea:focus {
      box-shadow: 0 6px 20px rgba(96,165,250,0.08);
      outline: 2px solid rgba(96,165,250,0.18);
    }

    /* small helper */
    .muted { color:var(--muted); font-size:0.92rem; }
    .flex { display:flex; gap:10px; align-items:center; }
    .grow { flex:1; }

    /* footer */
    footer { color:var(--muted); font-size:0.88rem; padding-top:6px; }

    /* ensure at least 16px between buttons in a group */
    .btn-row > * { min-width: 84px; }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Two pointers interactive module">
    <header>
      <h1>Two Pointers — Pair Sum in a Sorted Array</h1>
      <p class="lead">Use two indices from both ends to find whether two numbers sum to a target. Step through the algorithm, run it automatically, and experiment with different arrays and targets.</p>
    </header>

    <main class="main" id="main-grid">
      <!-- Controls -->
      <section class="controls" aria-label="Controls">
        <div class="group">
          <label for="arrayInput">Sorted array (comma separated)</label>
          <input id="arrayInput" type="text" aria-describedby="arrayHint" value="1,2,3,4,5,6,7,8,9" />
          <div id="arrayHint" class="hint">Enter integers sorted in non-decreasing order. Example: 1,2,3,5,8</div>
        </div>

        <div class="group">
          <div class="small-row">
            <label for="sizeRange">Generate random sorted array</label>
            <div class="grow" style="text-align:right;">
              <input id="sizeRange" type="range" min="2" max="14" value="9" aria-label="Array size" />
            </div>
          </div>
          <div class="btn-row">
            <button id="generateBtn" class="secondary" type="button">Generate</button>
            <button id="shuffleBtn" class="secondary" type="button">Shuffle & Sort</button>
          </div>
        </div>

        <div class="group">
          <label for="targetInput">Target sum</label>
          <input id="targetInput" type="number" value="10" />
        </div>

        <div class="group">
          <label for="speedRange">Animation speed (ms per step)</label>
          <input id="speedRange" type="range" min="150" max="1200" value="500" />
        </div>

        <div class="group">
          <div class="btn-row" role="group" aria-label="Algorithm controls">
            <button id="stepBtn" type="button">Step (Space)</button>
            <button id="runBtn" type="button">Run (Enter)</button>
            <button id="autoBtn" type="button">Auto</button>
            <button id="resetBtn" class="secondary" type="button">Reset</button>
          </div>
          <div class="hint">Keyboard: Space = Step, Enter = Run, A = Toggle Auto</div>
        </div>
      </section>

      <!-- Visuals -->
      <section class="visual" aria-live="polite" aria-label="Visual algorithm area">
        <div class="array-area" id="arrayArea" role="region" aria-label="Array visualization">
          <div class="array-container" id="arrayContainer" aria-hidden="false"></div>

          <!-- pointers are absolutely positioned inside array-area -->
          <div class="pointer l" id="leftPointer" role="img" aria-label="Left pointer">
            <div class="arrow" aria-hidden="true"></div>
            <div class="label">L</div>
          </div>
          <div class="pointer r" id="rightPointer" role="img" aria-label="Right pointer">
            <div class="arrow" aria-hidden="true"></div>
            <div class="label">R</div>
          </div>
        </div>

        <div class="result" role="status" aria-live="polite" id="resultPanel">
          <div>
            <div class="big" id="sumDisplay">Sum: —</div>
            <div class="explain" id="explain">Press Step to begin.</div>
          </div>
          <div class="status">
            <div class="chip" id="indicesChip">L: - • R: -</div>
            <div class="chip" id="stepChip">Step: 0</div>
          </div>
        </div>

        <div class="log" id="log" aria-live="polite" aria-atomic="true">
          <div class="log-entry">Ready. Enter an array and target, then Step or Run.</div>
        </div>
      </section>
    </main>

    <footer>
      Note: This demonstration assumes a sorted array. Two pointers exploits ordering to decide pointer movement without nested loops.
    </footer>
  </div>

  <script>
    // Two Pointers Interactive Module
    (function(){
      // DOM references
      const arrayInput = document.getElementById('arrayInput');
      const generateBtn = document.getElementById('generateBtn');
      const shuffleBtn = document.getElementById('shuffleBtn');
      const sizeRange = document.getElementById('sizeRange');
      const arrayContainer = document.getElementById('arrayContainer');
      const leftPointer = document.getElementById('leftPointer');
      const rightPointer = document.getElementById('rightPointer');
      const stepBtn = document.getElementById('stepBtn');
      const runBtn = document.getElementById('runBtn');
      const autoBtn = document.getElementById('autoBtn');
      const resetBtn = document.getElementById('resetBtn');
      const targetInput = document.getElementById('targetInput');
      const speedRange = document.getElementById('speedRange');
      const sumDisplay = document.getElementById('sumDisplay');
      const explain = document.getElementById('explain');
      const log = document.getElementById('log');
      const indicesChip = document.getElementById('indicesChip');
      const stepChip = document.getElementById('stepChip');
      const arrayArea = document.getElementById('arrayArea');

      // State
      let arr = [];
      let left = 0, right = 0;
      let stepCount = 0;
      let running = false;
      let autoplay = false;
      let autoplayTimer = null;
      let found = null;

      // Utility: parse array input
      function parseArrayInput(str){
        const parts = str.split(',').map(s => s.trim()).filter(Boolean);
        const nums = parts.map(p => {
          const n = Number(p);
          return Number.isFinite(n) ? n : NaN;
        });
        return nums;
      }

      function showLog(message, important=false){
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        if(important) entry.innerHTML = '<strong>' + message + '</strong>';
        else entry.textContent = message;
        log.prepend(entry);
        // Keep log length manageable
        while (log.children.length > 200) log.removeChild(log.lastChild);
      }

      // Render array boxes
      function renderArray(){
        arrayContainer.innerHTML = '';
        arr.forEach((v, idx) => {
          const b = document.createElement('div');
          b.className = 'box';
          b.dataset.index = idx;
          b.textContent = v;
          b.setAttribute('role','img');
          b.setAttribute('aria-label', 'Value ' + v + ' at index ' + idx);
          arrayContainer.appendChild(b);
        });
        // set pointers to initial positions after DOM updated
        requestAnimationFrame(()=>updatePointers(true));
      }

      // Update pointer positions based on left/right indices
      function updatePointers(immediate=false){
        const boxes = Array.from(arrayContainer.children);
        const total = boxes.length;
        if (total === 0) {
          leftPointer.style.display = 'none';
          rightPointer.style.display = 'none';
          return;
        } else {
          leftPointer.style.display = '';
          rightPointer.style.display = '';
        }
        // clamp indices
        left = Math.max(0, Math.min(left, Math.max(0,total-1)));
        right = Math.max(0, Math.min(right, Math.max(0,total-1)));
        // compute center positions using bounding rect of container and box
        const containerRect = arrayContainer.getBoundingClientRect();
        const leftBox = boxes[left];
        const rightBox = boxes[right];
        if (!leftBox || !rightBox) return;
        const lb = leftBox.getBoundingClientRect();
        const rb = rightBox.getBoundingClientRect();
        // left: center of box relative to arrayArea
        const areaRect = arrayArea.getBoundingClientRect();
        const leftCenter = (lb.left + lb.right) / 2 - areaRect.left;
        const rightCenter = (rb.left + rb.right) / 2 - areaRect.left;
        // position pointers (set left px)
        leftPointer.style.left = leftCenter + 'px';
        rightPointer.style.left = rightCenter + 'px';
        // update chips
        indicesChip.textContent = 'L: ' + left + ' • R: ' + right;
        stepChip.textContent = 'Step: ' + stepCount;
        // highlight current boxes
        boxes.forEach(b => b.classList.remove('highlight','pulse'));
        if (left <= right) {
          leftBox.classList.add('highlight','pulse');
          rightBox.classList.add('highlight','pulse');
        }
        // update sum display
        if (left < right) {
          const sum = arr[left] + arr[right];
          sumDisplay.textContent = 'Sum: ' + arr[left] + ' + ' + arr[right] + ' = ' + sum;
        } else {
          sumDisplay.textContent = 'Sum: —';
        }
      }

      // Validate array is sorted (non-decreasing)
      function isSorted(a){
        for (let i=1;i<a.length;i++){
          if (a[i] < a[i-1]) return false;
        }
        return true;
      }

      // Reset algorithm state
      function resetState(){
        left = 0;
        right = Math.max(0, arr.length - 1);
        stepCount = 0;
        found = null;
        running = false;
        if (autoplayTimer) { clearTimeout(autoplayTimer); autoplayTimer=null; }
        updatePointers(true);
        explain.textContent = 'Ready. Press Step to begin.';
      }

      // Single algorithm step
      function step(){
        if (found !== null) {
          showLog('Algorithm already finished. Reset to run again.', false);
          return;
        }
        if (arr.length < 2) {
          explain.textContent = 'Need at least 2 elements.';
          showLog('Array too small for two pointers.', true);
          return;
        }
        if (left >= right) {
          explain.textContent = 'No pair found (pointers crossed).';
          showLog('Finished: no pair sums to target ' + targetInput.value, true);
          found = false;
          updatePointers();
          return;
        }
        stepCount++;
        const a = arr[left], b = arr[right];
        const sum = a + b;
        const target = Number(targetInput.value);
        // highlight current comparison
        updatePointers();
        // small delay to make highlight visible before moving pointers during auto/run
        // but in step() we'll perform logic immediately and animate pointer change
        let reason;
        if (sum === target) {
          explain.textContent = 'Found! ' + a + ' + ' + b + ' = ' + target;
          showLog('Step ' + stepCount + ': arr['+left+']='+a+' + arr['+right+']='+b+' = ' + sum + ' → FOUND', true);
          found = {left, right};
          // accent the boxes
          const leftBox = arrayContainer.querySelector('.box[data-index="'+left+'"]');
          const rightBox = arrayContainer.querySelector('.box[data-index="'+right+'"]');
          if (leftBox) leftBox.style.background = 'linear-gradient(180deg, rgba(52,211,153,0.16), rgba(34,197,94,0.04))';
          if (rightBox) rightBox.style.background = 'linear-gradient(180deg, rgba(52,211,153,0.12), rgba(34,197,94,0.03))';
          updatePointers();
          return;
        } else if (sum < target) {
          reason = 'sum < target → move left pointer right (L++)';
          showLog('Step ' + stepCount + ': ' + a + ' + ' + b + ' = ' + sum + ' < ' + target + ' → L++');
          left++;
        } else {
          reason = 'sum > target → move right pointer left (R--)';
          showLog('Step ' + stepCount + ': ' + a + ' + ' + b + ' = ' + sum + ' > ' + target + ' → R--');
          right--;
        }
        explain.textContent = reason + '.';
        updatePointers();
        // if pointers crossed as a result
        if (left >= right && found === null) {
          showLog('Pointers crossed. No pair found for target ' + target + '.', true);
          explain.textContent = 'Pointers crossed. No pair found.';
          found = false;
        }
      }

      // Run to completion (animated)
      function runAnimated(){
        if (found !== null) {
          showLog('Algorithm already finished. Reset to run again.', false);
          return;
        }
        running = true;
        const stepDelay = Number(speedRange.value);

        function loop(){
          if (found !== null) { running=false; return; }
          // perform one step
          step();
          if (found === null && left < right) {
            autoplayTimer = setTimeout(loop, stepDelay);
          } else {
            running = false;
          }
        }
        loop();
      }

      // Autoplay toggle
      function toggleAuto(){
        autoplay = !autoplay;
        autoBtn.textContent = autoplay ? 'Stop Auto' : 'Auto';
        if (autoplay) {
          // keep running steps until finished or toggled off
          const loop = () => {
            if (!autoplay || found !== null) { autoplay=false; autoBtn.textContent='Auto'; return; }
            step();
            if (found === null && left < right) {
              autoplayTimer = setTimeout(loop, Math.max(120, Number(speedRange.value)));
            } else {
              autoplay=false;
              autoBtn.textContent='Auto';
            }
          };
          loop();
        } else {
          if (autoplayTimer) { clearTimeout(autoplayTimer); autoplayTimer=null; }
        }
      }

      // Generate random sorted array
      function generateRandomArray(n){
        const res = [];
        let cur = Math.floor(Math.random()*3);
        for (let i=0;i<n;i++){
          cur += Math.floor(Math.random()*5) + 1;
          res.push(cur);
        }
        return res;
      }

      // Shuffle current array and sort
      function shuffleAndSort(){
        const shuffled = arr.slice().sort(() => Math.random()-0.5);
        arr = shuffled.sort((a,b)=>a-b);
        arrayInput.value = arr.join(',');
        renderArray();
        resetState();
        showLog('Shuffled and sorted the current array.');
      }

      // Attach events
      generateBtn.addEventListener('click', ()=>{
        const n = Math.max(2, Math.min(14, Number(sizeRange.value) || 9));
        arr = generateRandomArray(n);
        arrayInput.value = arr.join(',');
        renderArray();
        resetState();
        showLog('Generated random sorted array of size ' + n + '.');
      });

      shuffleBtn.addEventListener('click', ()=>{
        const parsed = parseArrayInput(arrayInput.value);
        if (parsed.length < 2) { showLog('Provide an array first to shuffle & sort.'); return; }
        arr = parsed.slice().sort((a,b)=>a-b);
        arrayInput.value = arr.join(',');
        renderArray();
        resetState();
        showLog('Sorted the provided array.');
      });

      // On array input change
      arrayInput.addEventListener('change', ()=>{
        const parsed = parseArrayInput(arrayInput.value);
        if (parsed.some(Number.isNaN)) {
          showLog('Invalid numbers in array input. Please enter integers separated by commas.', true);
          return;
        }
        arr = parsed;
        if (!isSorted(arr)) {
          showLog('Warning: array is not sorted. Two-pointer guarantees require a sorted array.', true);
        } else {
          showLog('Array updated.');
        }
        renderArray();
        resetState();
      });

      // On target change, reset algorithm
      targetInput.addEventListener('change', ()=>{
        resetState();
        showLog('Target set to ' + targetInput.value + '.');
      });

      // Buttons
      stepBtn.addEventListener('click', ()=>{ step(); });
      runBtn.addEventListener('click', ()=>{ runAnimated(); });
      resetBtn.addEventListener('click', ()=>{ resetState(); showLog('Reset algorithm.'); });
      autoBtn.addEventListener('click', ()=>{ toggleAuto(); });

      speedRange.addEventListener('input', ()=>{ /* speed update instant */ });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.key === ' ' && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          step();
        } else if (e.key === 'Enter' && !e.shiftKey) {
          if (document.activeElement.tagName === 'TEXTAREA') return;
          e.preventDefault();
          runAnimated();
        } else if (e.key.toLowerCase() === 'a') {
          toggleAuto();
        }
      });

      // Window resize reposition pointers (responsive)
      window.addEventListener('resize', ()=> updatePointers(true));

      // Initialize default array from input
      (function init(){
        const parsed = parseArrayInput(arrayInput.value);
        if (parsed.some(Number.isNaN) || parsed.length ===0) {
          arr = [1,2,3,4,5,6,7,8,9];
          arrayInput.value = arr.join(',');
        } else arr = parsed;
        renderArray();
        resetState();
      })();

      // Accessible announcements when state changes: we'll use showLog which is in ARIA-live region (log div)
      // Focus management: when clicking Step or Run, ensure visual area is obvious.
      [stepBtn, runBtn, autoBtn, resetBtn, generateBtn, shuffleBtn].forEach(btn=>{
        btn.addEventListener('click', ()=>{ arrayArea.scrollIntoView({behavior:'smooth', block:'center'}); });
      });

      // Prevent text selection from dragging (polish)
      document.addEventListener('dragstart', e => e.preventDefault());
    })();
  </script>
</body>
</html>