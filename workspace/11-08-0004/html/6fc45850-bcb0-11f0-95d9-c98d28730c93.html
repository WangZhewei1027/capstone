<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Union‑Find (Disjoint Set) — Interactive Module</title>
  <style>
    :root{
      --safe-margin: 24px;
      --gap: 16px;
      --bg: #0f1720;
      --card: #0b1220;
      --accent: #39a0ff;
      --muted: #9aa6b2;
      --success: #16a34a;
      --danger: #ef4444;
      --glass: rgba(255,255,255,0.03);
      --radius: 12px;
      --node-size: 44px;
    }

    /* Page safe area and layout */
    html,body{
      height:100%;
      margin:0;
      background: linear-gradient(180deg,#071025 0%, #071322 100%);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:#e6eef6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .container{
      padding: var(--safe-margin);
      box-sizing: border-box;
      min-height:100%;
      display:flex;
      gap:var(--gap);
      align-items:stretch;
      justify-content:center;
    }

    /* Layout: left panel controls, right canvas */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding:20px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
      min-width:280px;
      max-width:420px;
      flex:0 0 380px;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      box-sizing:border-box;
    }

    .canvas-wrap{
      flex:1;
      min-width:250px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
      border-radius: var(--radius);
      padding:16px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:var(--gap);
      align-items:stretch;
    }

    h1{
      margin:0;
      font-size:18px;
      color:#eaf4ff;
      letter-spacing:0.2px;
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }

    .section{
      background:var(--glass);
      padding:12px;
      border-radius:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .controls{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
    }

    button, input[type="number"], select {
      background:transparent;
      color:inherit;
      border:1px solid rgba(255,255,255,0.06);
      padding:8px 12px;
      border-radius:10px;
      cursor:pointer;
      min-height:40px;
      transition:all .18s ease;
      outline:none;
    }
    button:hover { transform: translateY(-2px); border-color: rgba(57,160,255,0.9); }
    button:active { transform: translateY(0); }
    .primary{
      background: linear-gradient(90deg,var(--accent),#4fe0ff20);
      border:1px solid rgba(57,160,255,0.12);
      color:#071322;
      font-weight:600;
    }
    .danger{
      background: linear-gradient(90deg,#ef6b6b22,#ef444430);
      border-color: rgba(239,68,68,0.12);
      color:#ffecec;
    }
    label { font-size:13px; color:var(--muted); }

    .row{
      display:flex;
      gap:var(--gap);
      align-items:center;
      flex-wrap:wrap;
    }

    .stat {
      background:rgba(255,255,255,0.02);
      padding:10px;
      border-radius:8px;
      min-width:120px;
    }
    .stat b{ display:block; font-size:14px; color:#e6f7ff; }
    .stat small{ color:var(--muted); font-size:12px; }

    /* Canvas area */
    #canvas{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius:10px;
      flex:1;
      position:relative;
      overflow:hidden;
      min-height:420px;
      display:flex;
      gap:var(--gap);
    }

    /* SVG will fill area */
    svg{
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
    }

    /* Node styles */
    .node {
      cursor:pointer;
      transition: transform .18s ease, filter .18s ease;
      filter: drop-shadow(0 3px 8px rgba(3,10,18,0.6));
    }
    .node circle {
      transition: fill .15s ease, r .12s ease;
      fill: #071322;
      stroke: rgba(255,255,255,0.06);
      stroke-width:2.6;
    }
    .node .label {
      fill: #dff2ff;
      font-size:13px;
      pointer-events:none;
    }
    .node.selected circle { stroke: var(--accent); stroke-width:3.5; transform-origin:center; }
    .node.root circle { fill: rgba(57,160,255,0.12); }
    .node.highlight circle { fill: #ffeaa3; }
    .node.found circle { fill: rgba(22,163,74,0.14); stroke: rgba(22,163,74,0.8); }

    /* Arrow styles */
    .link {
      stroke: rgba(255,255,255,0.08);
      stroke-width: 2.2;
      fill:none;
      marker-end: url(#arrowhead);
      transition: stroke .14s ease;
    }
    .link.highlight { stroke: #ffeaa3; stroke-width:3.2; }
    .link.compressed { stroke: rgba(57,160,255,0.9); stroke-width:3.2; }

    /* Panel for arrays and logs */
    .arrays{
      display:flex;
      gap:var(--gap);
      flex-wrap:wrap;
    }
    .array-box{
      background:rgba(255,255,255,0.02);
      border-radius:10px;
      padding:8px;
      min-width:120px;
    }
    .arr-row{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:flex-start;
      flex-wrap:wrap;
    }
    .chip{
      padding:6px 8px;
      border-radius:8px;
      background:rgba(255,255,255,0.03);
      font-size:13px;
      color:#dff2ff;
      border:1px solid rgba(255,255,255,0.02);
      min-width:36px;
      text-align:center;
    }

    /* Log */
    .log{
      max-height:140px;
      overflow:auto;
      padding:8px;
      background:rgba(0,0,0,0.05);
      border-radius:8px;
      font-size:13px;
      color:var(--muted);
    }
    .log .entry{ margin-bottom:8px; }
    .small-muted{ color:var(--muted); font-size:13px; }

    /* Responsive layout adjustments */
    @media (max-width:980px){
      .container{ flex-direction:column; padding:16px; }
      .panel{ max-width:100%; width:100%; flex:0 0 auto; }
      .canvas-wrap{ width:100%; flex:1 1 auto; }
      #canvas{ min-height:360px; }
    }

    /* Accessibility focus styles */
    button:focus, input:focus, select:focus, .node:focus{ box-shadow:0 6px 24px rgba(57,160,255,0.12); outline:none; }
  </style>
</head>
<body>
  <div class="container" role="main" aria-label="Union Find interactive module">
    <!-- Left Panel: explanation and controls -->
    <aside class="panel" aria-hidden="false">
      <header>
        <h1>Union‑Find (Disjoint Set)</h1>
        <p class="lead">Interactive explainer of union and find operations (with path compression and union by size).</p>
      </header>

      <div class="section" aria-labelledby="objective-title">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <label id="objective-title" class="small-muted">Learning Objective</label>
            <div style="font-weight:600;color:#eaf4ff;">Understand how union, find, and path compression work</div>
          </div>
          <div class="stat" aria-hidden="true" style="text-align:right;">
            <small>Current nodes</small>
            <b id="nodeCount">0</b>
          </div>
        </div>
        <p class="small-muted" style="margin:0;">
          After interacting you'll be able to perform unions and finds, see representative roots, and watch path compression flatten trees for faster future lookups.
        </p>
      </div>

      <div class="section" aria-labelledby="interaction-title">
        <label id="interaction-title" class="small-muted">Interaction Design</label>
        <p class="small-muted" style="margin:0;">
          - Click a node to select it. Click two nodes then press "Union" to merge sets. <br>
          - Click one node and press "Find" to trace its path to the root (animated). <br>
          - Enable "Path compression" to automatically reattach nodes directly to the root during Find. <br>
          - Toggle "Union by size" to see different tree shapes. <br>
          - Drag nodes to rearrange the visualization.
        </p>
      </div>

      <div class="section" aria-labelledby="controls">
        <label id="controls" class="small-muted">Controls</label>

        <div class="row controls" role="group" aria-label="Add and reset">
          <button id="addNodeBtn" title="Add node">Add Node</button>
          <button id="resetBtn" class="danger" title="Reset to initial state">Reset</button>
          <button id="randomBtn" title="Create 6 random nodes">Auto (6 nodes)</button>
        </div>

        <div class="row" style="align-items:center;">
          <div style="flex:1;">
            <label class="small-muted">Union / Find</label>
            <div class="row" style="margin-top:8px;">
              <button id="unionBtn" class="primary" disabled>Union</button>
              <button id="findBtn" title="Find root of selected node" disabled>Find</button>
            </div>
          </div>

          <div style="width:1px;background:rgba(255,255,255,0.02);height:64px;margin-left:12px;"></div>

          <div style="min-width:140px;">
            <label class="small-muted">Options</label>
            <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px;">
              <label style="display:flex;gap:8px;align-items:center;">
                <input id="pathCompression" type="checkbox" checked aria-checked="true">
                <span class="small-muted">Path compression</span>
              </label>

              <label style="display:flex;gap:8px;align-items:center;">
                <input id="unionBySize" type="checkbox" checked aria-checked="true">
                <span class="small-muted">Union by size</span>
              </label>
            </div>
          </div>
        </div>
      </div>

      <div class="section" aria-labelledby="arrays">
        <label id="arrays" class="small-muted">Internal State (live)</label>
        <div class="arrays" aria-live="polite">
          <div class="array-box" style="flex:1;">
            <small class="small-muted">parent[]</small>
            <div id="parentArray" class="arr-row" aria-hidden="false" style="margin-top:8px;"></div>
          </div>
          <div class="array-box" style="flex:1;">
            <small class="small-muted">size[]</small>
            <div id="sizeArray" class="arr-row" style="margin-top:8px;"></div>
          </div>
        </div>
        <div style="margin-top:8px;">
          <small class="small-muted">Operation log</small>
          <div id="log" class="log" aria-live="polite"></div>
        </div>
      </div>

      <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
        <small class="small-muted">Tip: drag nodes or arrange to see different layouts</small>
        <div style="display:flex;gap:8px;">
          <button id="demoStepBtn" title="Run a simple demo step">Demo Step</button>
        </div>
      </div>

    </aside>

    <!-- Right: Canvas and visualization -->
    <section class="canvas-wrap" aria-label="Visualization area">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <label class="small-muted">Visualization</label>
        <div style="display:flex;gap:12px;align-items:center;">
          <div class="small-muted">Select nodes by clicking. Two selected -> union.</div>
        </div>
      </div>

      <div id="canvas" role="region" aria-label="Union-Find visual canvas">
        <svg id="svg" xmlns="http://www.w3.org/2000/svg" focusable="false" aria-hidden="false">
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="10" refY="4" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L8,4 L0,8 z" fill="rgba(255,255,255,0.12)"></path>
            </marker>
          </defs>
          <g id="links"></g>
          <g id="nodes"></g>
        </svg>
      </div>

    </section>
  </div>

  <script>
    // Union-Find interactive module (vanilla JS)
    // Layout constraints: 24px safe margin and 16px min spacing are enforced in CSS.
    (function () {
      // Utility helpers
      const el = id => document.getElementById(id);
      const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

      // DOM references
      const svg = el('svg');
      const nodesGroup = el('nodes');
      const linksGroup = el('links');
      const addNodeBtn = el('addNodeBtn');
      const resetBtn = el('resetBtn');
      const randomBtn = el('randomBtn');
      const unionBtn = el('unionBtn');
      const findBtn = el('findBtn');
      const demoStepBtn = el('demoStepBtn');
      const nodeCountEl = el('nodeCount');
      const parentArrayEl = el('parentArray');
      const sizeArrayEl = el('sizeArray');
      const logEl = el('log');
      const pathCompressionCheckbox = el('pathCompression');
      const unionBySizeCheckbox = el('unionBySize');

      // State for union-find
      let parent = [];
      let size = [];
      let nodes = []; // visual nodes list
      let links = []; // visual links list
      let selected = []; // selected node ids
      let nodeIdCounter = 0;

      // Visual layout parameters
      const W = () => svg.clientWidth;
      const H = () => svg.clientHeight;

      // For dragging
      let dragState = null;

      // Initialize with no nodes
      function resetAll() {
        parent = [];
        size = [];
        nodes = [];
        links = [];
        selected = [];
        nodeIdCounter = 0;
        nodesGroup.innerHTML = '';
        linksGroup.innerHTML = '';
        log('Reset to empty state.');
        updateArrays();
        updateButtons();
      }

      function autoCreate(n = 6) {
        resetAll();
        // place nodes in a ring
        const cx = W()/2, cy = H()/2, r = Math.min(W(),H())*0.28;
        for (let i=0;i<n;i++){
          const angle = (i / n) * Math.PI * 2;
          const x = cx + r * Math.cos(angle);
          const y = cy + r * Math.sin(angle);
          createNodeAt(x,y);
        }
        updateArrays();
        log('Auto-created ' + n + ' nodes.');
      }

      // Create a new union-find node and its SVG
      function createNodeAt(x,y) {
        const id = nodeIdCounter++;
        parent[id] = id;
        size[id] = 1;
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('class','node');
        g.setAttribute('tabindex','0');
        g.dataset.id = id;
        // circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('r', parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--node-size'))/2 || 22);
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        // label
        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.setAttribute('x', x);
        text.setAttribute('y', y+4);
        text.setAttribute('class','label');
        text.setAttribute('text-anchor','middle');
        text.textContent = id;
        g.appendChild(circle);
        g.appendChild(text);
        // position stored as attributes (center)
        g.dataset.x = x;
        g.dataset.y = y;

        // event handlers
        g.addEventListener('pointerdown', onPointerDownNode);
        g.addEventListener('click', onClickNode);
        g.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter' || ev.key===' ') { onClickNode({currentTarget: g}); ev.preventDefault(); } });

        nodesGroup.appendChild(g);
        nodes.push(g);
        nodeCountEl.textContent = nodes.length;
        updateArrays();
        updateLinks();
      }

      // Log
      function log(msg) {
        const d = new Date();
        const time = d.toLocaleTimeString();
        const entry = document.createElement('div');
        entry.className = 'entry';
        entry.textContent = `[${time}] ${msg}`;
        logEl.prepend(entry);
      }

      // Toggle selection of a node
      function setSelectedById(id, add=false) {
        if (!add) selected = []; // if not multi-select, clear
        if (selected.includes(id)) {
          selected = selected.filter(v=>v!==id);
        } else {
          selected.push(id);
          // limit to two selected for union
          if (selected.length>2) selected = selected.slice(-2);
        }
        updateSelectionVisuals();
        updateButtons();
      }

      function updateSelectionVisuals() {
        nodes.forEach(g=>{
          const id = Number(g.dataset.id);
          g.classList.toggle('selected', selected.includes(id));
        });
      }

      function updateButtons() {
        unionBtn.disabled = selected.length !== 2;
        findBtn.disabled = selected.length !== 1;
      }

      // Event: clicking a node
      function onClickNode(e) {
        const g = e.currentTarget;
        const id = Number(g.dataset.id);
        const addKey = (e.shiftKey || e.ctrlKey || e.metaKey);
        setSelectedById(id, addKey);
      }

      // Pointer down for drag
      function onPointerDownNode(e) {
        const g = e.currentTarget;
        const id = Number(g.dataset.id);
        // initiate capture
        dragState = {
          id,
          node: g,
          startX: e.clientX,
          startY: e.clientY,
          origX: Number(g.dataset.x),
          origY: Number(g.dataset.y)
        };
        g.setPointerCapture(e.pointerId);
        const move = (ev)=>onPointerMove(ev);
        const up = (ev)=>onPointerUp(ev);
        window.addEventListener('pointermove', move);
        window.addEventListener('pointerup', up);
        function onPointerMove(ev) {
          if (!dragState) return;
          const dx = ev.clientX - dragState.startX;
          const dy = ev.clientY - dragState.startY;
          const nx = clamp(dragState.origX + dx, 40, W()-40);
          const ny = clamp(dragState.origY + dy, 40, H()-40);
          dragState.node.dataset.x = nx;
          dragState.node.dataset.y = ny;
          const circle = dragState.node.querySelector('circle');
          const text = dragState.node.querySelector('text');
          circle.setAttribute('cx', nx);
          circle.setAttribute('cy', ny);
          text.setAttribute('x', nx);
          text.setAttribute('y', ny+4);
          updateLinks(); // update edge positions live
        }
        function onPointerUp(ev) {
          if (!dragState) return;
          try { dragState.node.releasePointerCapture(ev.pointerId); } catch(_) {}
          window.removeEventListener('pointermove', move);
          window.removeEventListener('pointerup', up);
          dragState = null;
        }
      }

      // Edge drawing based on parent array
      function updateLinks() {
        linksGroup.innerHTML = '';
        links = [];
        for (let i=0;i<parent.length;i++){
          if (parent[i] === undefined) continue;
          const pid = parent[i];
          if (pid === i) continue; // root has no outgoing parent arrow
          // draw arrow from node i to parent pid
          const gFrom = nodes.find(n=>Number(n.dataset.id)===i);
          const gTo = nodes.find(n=>Number(n.dataset.id)===pid);
          if (!gFrom || !gTo) continue;
          const x1 = Number(gFrom.dataset.x);
          const y1 = Number(gFrom.dataset.y);
          const x2 = Number(gTo.dataset.x);
          const y2 = Number(gTo.dataset.y);
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          path.setAttribute('class','link');
          // compute a curved path for clarity
          const dx = x2 - x1, dy = y2 - y1;
          const mx = x1 + dx*0.5, my = y1 + dy*0.5;
          const nx = mx - dy*0.18, ny = my + dx*0.18;
          const d = `M ${x1} ${y1} Q ${nx} ${ny} ${x2} ${y2}`;
          path.setAttribute('d', d);
          linksGroup.appendChild(path);
          links.push({from:i,to:pid,el:path});
        }
      }

      // Update parent/size arrays UI
      function updateArrays() {
        parentArrayEl.innerHTML = '';
        sizeArrayEl.innerHTML = '';
        for (let i=0;i<parent.length;i++){
          const pChip = document.createElement('div');
          pChip.className = 'chip';
          pChip.textContent = parent[i] !== undefined ? parent[i] : '-';
          parentArrayEl.appendChild(pChip);

          const sChip = document.createElement('div');
          sChip.className = 'chip';
          sChip.textContent = size[i] !== undefined ? size[i] : '-';
          sizeArrayEl.appendChild(sChip);
        }
        nodeCountEl.textContent = nodes.length;
      }

      // Visual helpers: highlight a path (array of node ids)
      function animatePath(pathIds, options = {}) {
        return new Promise(resolve=>{
          if (!pathIds.length) return resolve();
          // highlight each link/node sequentially
          let i = 0;
          function step(){
            // clear previous highlights
            nodes.forEach(n=>n.classList.remove('highlight','found'));
            links.forEach(l=>l.el.classList.remove('highlight','compressed'));
            if (i >= pathIds.length) return resolve();
            const nid = pathIds[i];
            const ng = nodes.find(n=>Number(n.dataset.id)===nid);
            if (ng) ng.classList.add('highlight');
            // highlight link to next (if exists)
            if (i < pathIds.length-1) {
              const next = pathIds[i+1];
              const linkObj = links.find(l=>l.from===nid && l.to===next);
              if (linkObj) linkObj.el.classList.add('highlight');
            }
            i++;
            setTimeout(step, options.step || 450);
          }
          step();
        });
      }

      // Find with optional path compression (animated)
      async function findWithTrace(x, doCompress) {
        let path = [];
        let cur = x;
        // gather path to root
        while (true) {
          path.push(cur);
          if (parent[cur] === cur) break;
          cur = parent[cur];
          // guard
          if (path.length > parent.length + 5) break;
        }
        const root = cur;
        log(`Find(${x}) -> root ${root} (path: ${path.join(' → ')})`);
        // animate highlighting of path (from node to root)
        await animatePath(path.slice());
        // mark the root visually
        nodes.forEach(n=>{
          const id = Number(n.dataset.id);
          n.classList.toggle('root', id === root);
        });
        if (doCompress && path.length > 1) {
          // animate compression: reattach each node directly to root
          for (let i=0;i<path.length-1;i++){
            const nodeId = path[i];
            parent[nodeId] = root;
            // animate link change: find the link element for nodeId and mark as 'compressed'
            const linkObj = links.find(l=>l.from===nodeId);
            if (linkObj) {
              linkObj.el.classList.add('compressed');
            }
            updateArrays();
            updateLinks(); // redraw links progressively
            // small pause to emphasize each reconnection
            await new Promise(r=>setTimeout(r, 260));
          }
          log(`Path compression applied: nodes now point directly to ${root}`);
        }
        // mark found node
        nodes.forEach(n=>{
          const id = Number(n.dataset.id);
          n.classList.toggle('found', path.includes(id));
          n.classList.remove('highlight');
        });
        // short highlight permanence
        await new Promise(r=>setTimeout(r, 600));
        // clear temporary markers
        nodes.forEach(n=>{ n.classList.remove('root','highlight','found'); });
        links.forEach(l=>l.el.classList.remove('highlight','compressed'));
        updateArrays();
        updateLinks();
        return root;
      }

      // Union operation
      function union(a,b) {
        a = findRepresentative(a);
        b = findRepresentative(b);
        if (a === b) {
          log(`Union(${a}, ${b}) -> already same set.`);
          return;
        }
        const bySize = unionBySizeCheckbox.checked;
        if (bySize) {
          // attach smaller to larger
          if (size[a] < size[b]) {
            parent[a] = b;
            size[b] += size[a];
            log(`Union by size: attached ${a} -> ${b}. size[${b}] = ${size[b]}`);
          } else {
            parent[b] = a;
            size[a] += size[b];
            log(`Union by size: attached ${b} -> ${a}. size[${a}] = ${size[a]}`);
          }
        } else {
          // naive: attach b to a
          parent[b] = a;
          size[a] += size[b];
          log(`Union: attached ${b} -> ${a}.`);
        }
        updateArrays();
        updateLinks();
        // animate a flash for roots changed
        const changed = [a,b];
        nodes.forEach(n=>{
          const id = Number(n.dataset.id);
          if (changed.includes(id)) {
            n.classList.add('highlight');
            setTimeout(()=>n.classList.remove('highlight'), 500);
          }
        });
      }

      // Helper: find representative w/o compression (internal)
      function findRepresentative(x) {
        let cur = x;
        while (parent[cur] !== cur) cur = parent[cur];
        return cur;
      }

      // Demo step: a simple scripted union/find to demonstrate behavior
      function demoStep() {
        // pick two random nodes if >=2 exist, union them; then pick one random to find
        if (nodes.length < 2) { log('Add at least 2 nodes for demo steps.'); return; }
        const a = Math.floor(Math.random()*nodes.length);
        let b = Math.floor(Math.random()*nodes.length);
        while (b===a) b = Math.floor(Math.random()*nodes.length);
        selected = [a,b];
        updateSelectionVisuals();
        union(a,b);
        // after union, perform a find on a random node
        const f = Math.floor(Math.random()*nodes.length);
        selected = [f];
        updateSelectionVisuals();
        setTimeout(()=>{ findBtn.dispatchEvent(new Event('click')); }, 400);
      }

      // Event handlers for UI buttons
      addNodeBtn.addEventListener('click', ()=>{
        // place new node near center with small random offset
        const x = clamp(W()/2 + (Math.random()-0.5)*180, 60, W()-60);
        const y = clamp(H()/2 + (Math.random()-0.5)*140, 60, H()-60);
        createNodeAt(x,y);
        log('Added node ' + (nodeIdCounter-1));
      });

      resetBtn.addEventListener('click', ()=>{ resetAll(); });

      randomBtn.addEventListener('click', ()=>{ autoCreate(6); });

      unionBtn.addEventListener('click', ()=>{
        if (selected.length !== 2) return;
        const a = selected[0], b = selected[1];
        union(a,b);
        selected = [];
        updateSelectionVisuals();
        updateButtons();
      });

      findBtn.addEventListener('click', async ()=>{
        if (selected.length !== 1) return;
        const x = selected[0];
        const doCompress = pathCompressionCheckbox.checked;
        await findWithTrace(x, doCompress);
        selected = [];
        updateSelectionVisuals();
        updateButtons();
      });

      demoStepBtn.addEventListener('click', demoStep);

      // Resize responsiveness: adjust svg viewBox or recalc links positions
      let resizeTimeout = null;
      window.addEventListener('resize', ()=> {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(()=> updateLinks(), 120);
      });

      // Accessibility keyboard: allow adding with keyboard shortcuts
      window.addEventListener('keydown',(e)=>{
        if (e.key === 'n' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          addNodeBtn.click();
        }
      });

      // Initial state
      resetAll();
      // Provide an initial set of nodes for immediate exploration
      autoCreate(6);

      // Expose small API for debugging (in dev console)
      window.__UF = {
        parent, size, nodes, createNodeAt, union, findWithTrace, resetAll, autoCreate
      };
    })();
  </script>
</body>
</html>