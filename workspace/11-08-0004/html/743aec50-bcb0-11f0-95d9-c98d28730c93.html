<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Heap Sort — Interactive Module</title>
  <style>
    /* Safe area margins: 24px on all sides */
    :root {
      --safe-pad: 24px;
      --gap: 16px;
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #06b6d4;
      --muted: #94a3b8;
      --success: #10b981;
      --danger: #ef4444;
      --duration: 600ms; /* default animation duration; will be updated inline by JS */
      --bar-min-width: 24px;
      --bar-max-width: 80px;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(180deg, #071024 0%, #081427 100%);
      color: #e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing: antialiased;
    }

    body {
      padding: var(--safe-pad);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    /* Module container */
    .module {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: var(--gap);
      align-items: start;
      min-height: 60vh;
    }

    /* Responsive: stack on small screens */
    @media (max-width: 900px) {
      .module {
        grid-template-columns: 1fr;
      }
    }

    /* Sidebar card with descriptions */
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
      min-width: 0;
    }

    .title {
      font-size: 20px;
      font-weight: 600;
      color: #e6f6fb;
      margin: 0 0 8px 0;
    }

    .subtitle {
      font-size: 13px;
      color: var(--muted);
      margin: 0 0 12px 0;
    }

    .section {
      margin-bottom: 16px;
    }

    .section h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #cfeff6;
    }

    .section p {
      margin: 0;
      font-size: 13px;
      color: #d7eaf2;
      line-height: 1.4;
    }

    /* Visualization area */
    .visual {
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    .controls {
      display: flex;
      gap: var(--gap);
      align-items: center;
      flex-wrap: wrap;
      background: rgba(255,255,255,0.02);
      padding: 12px;
      border-radius: 10px;
    }

    .controls > * {
      margin: 0;
    }

    .btn {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      color: #e6f6fb;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      min-height: 40px;
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }
    .btn:active { transform: translateY(1px); }
    .btn.primary {
      background: linear-gradient(180deg, rgba(6,182,212,0.12), rgba(6,182,212,0.06));
      border-color: rgba(6,182,212,0.24);
      color: var(--accent);
      font-weight: 600;
    }
    .btn.warn {
      border-color: rgba(255,193,7,0.18);
      color: #ffd166;
    }

    .control-group {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    label {
      font-size: 13px;
      color: var(--muted);
      display: inline-block;
      min-width: 64px;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: rgba(255,255,255,0.04);
      border-radius: 999px;
      outline: none;
      width: 180px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid rgba(255,255,255,0.12);
    }

    /* Visual canvas */
    .canvas {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      border-radius: 12px;
      padding: 18px;
      min-height: 420px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: stretch;
    }

    .panel {
      display: flex;
      gap: var(--gap);
      align-items: center;
      justify-content: space-between;
    }

    .status {
      font-size: 13px;
      color: var(--muted);
    }

    /* bars area */
    .bars-wrap {
      background: rgba(255,255,255,0.01);
      border-radius: 10px;
      padding: 12px;
      position: relative;
      overflow: hidden;
      min-height: 140px;
      display: flex;
      align-items: flex-end;
      gap: 8px;
    }

    .bars {
      position: relative;
      height: 220px;
      width: 100%;
    }

    .bar {
      position: absolute;
      bottom: 0;
      width: 48px;
      border-radius: 6px 6px 4px 4px;
      background: linear-gradient(180deg, rgba(6,182,212,0.14), rgba(6,182,212,0.06));
      border: 1px solid rgba(6,182,212,0.18);
      color: #062026;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      padding-bottom: 6px;
      box-sizing: border-box;
      user-select: none;
      transition: transform var(--duration) cubic-bezier(.2,.9,.2,1), background-color 180ms, border-color 180ms;
      will-change: transform;
    }

    .bar .label {
      color: #04262a;
      text-shadow: 0 1px 0 rgba(255,255,255,0.12);
    }

    .bar.compare {
      background: linear-gradient(180deg, rgba(255,236,179,0.9), rgba(255,220,120,0.85));
      border-color: rgba(255,200,50,0.6);
      z-index: 5;
    }
    .bar.swap {
      background: linear-gradient(180deg, rgba(255,167,167,0.92), rgba(255,110,110,0.86));
      border-color: rgba(255,90,90,0.7);
      z-index: 6;
    }
    .bar.sorted {
      background: linear-gradient(180deg, rgba(16,185,129,0.9), rgba(16,185,129,0.8));
      border-color: rgba(16,185,129,0.7);
      color: #042620;
      z-index: 3;
    }

    /* Tree area */
    .tree {
      background: rgba(255,255,255,0.01);
      border-radius: 10px;
      padding: 12px;
      position: relative;
      min-height: 180px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: visible;
    }

    .tree-canvas {
      position: relative;
      width: 100%;
      height: 200px;
    }

    .node {
      position: absolute;
      width: 44px;
      height: 44px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 2px solid rgba(255,255,255,0.04);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      color: #dff6fb;
      transition: transform var(--duration) cubic-bezier(.2,.9,.2,1), background-color 180ms, border-color 180ms;
      will-change: transform;
      box-shadow: 0 6px 14px rgba(2,6,23,0.6);
    }
    .node.compare {
      background: linear-gradient(180deg, rgba(255,236,179,1), rgba(255,220,120,0.95));
      border-color: rgba(255,200,50,0.8);
      color: #2b1700;
    }
    .node.swap {
      background: linear-gradient(180deg, rgba(255,167,167,1), rgba(255,110,110,0.96));
      border-color: rgba(255,90,90,0.9);
      color: #2b0000;
    }
    .node.sorted {
      background: linear-gradient(180deg, rgba(16,185,129,1), rgba(16,185,129,0.9));
      border-color: rgba(16,185,129,0.9);
      color: #042620;
    }

    svg.connectors {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: visible;
    }

    .legend {
      display: flex;
      gap: 12px;
      align-items: center;
      font-size: 13px;
      color: var(--muted);
      flex-wrap: wrap;
    }
    .legend-item {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 6px 8px;
      background: rgba(255,255,255,0.01);
      border-radius: 8px;
    }
    .swatch {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      background: var(--accent);
      border: 1px solid rgba(255,255,255,0.06);
    }

    /* small footnote */
    .keys {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }

  </style>
</head>
<body>
  <div class="module" role="application" aria-label="Heap Sort interactive module">
    <!-- Left sidebar: Concept, objectives, interaction design, layout description -->
    <aside class="card" aria-labelledby="concept-title">
      <h1 id="concept-title" class="title">Heap Sort — Visual & Interactive</h1>
      <p class="subtitle">A focused, step-driven exploration of heap sort (max-heap → extract-max).</p>

      <div class="section" aria-labelledby="objective-title">
        <h3 id="objective-title">Learning Objective</h3>
        <p>Understand how Heap Sort constructs a max-heap and repeatedly extracts the maximum to sort an array. Interact step-by-step to see heapify (sift-down), swaps, and the sorted region emerge.</p>
      </div>

      <div class="section" aria-labelledby="interaction-title">
        <h3 id="interaction-title">Interaction Design</h3>
        <p>Controls allow you to:
          generate custom or random arrays, step through each heapify or swap, auto-play with adjustable speed, and toggle actions with keyboard shortcuts.
          Visual feedback includes animated bar and tree node movements, color highlights for compare/swap/sorted states, and textual status updates.</p>
      </div>

      <div class="section" aria-labelledby="layout-title">
        <h3 id="layout-title">Layout Description</h3>
        <p>The module uses a two-column layout (sidebar + visualization). The visual area contains a top control row, a bars view (array), and a binary-tree view (heap). Spacing respects a 24px safe margin and 16px minimum gaps. The design is responsive and accessible (keyboard shortcuts: Space = Play/Pause, N = Next Step, R = Randomize).</p>
    </aside>

    <!-- Right: Visual interactive area -->
    <main class="visual" aria-live="polite">
      <div class="controls card" role="toolbar" aria-label="Controls">
        <div class="control-group">
          <button id="btn-random" class="btn" title="Generate random array (R)">Random</button>
          <button id="btn-reset" class="btn" title="Reset to original">Reset</button>
          <button id="btn-play" class="btn primary" title="Play / Pause (Space)">Play</button>
          <button id="btn-step" class="btn" title="Next step (N)">Step</button>
        </div>

        <div class="control-group" style="margin-left:auto;">
          <label for="size">Size</label>
          <input id="size" type="range" min="6" max="14" value="9" aria-label="Array size" />
        </div>

        <div class="control-group">
          <label for="speed">Speed</label>
          <input id="speed" type="range" min="100" max="1200" value="600" aria-label="Animation speed in ms" />
        </div>

        <div class="control-group">
          <label for="input-arr">Array</label>
          <input id="input-arr" type="text" placeholder="e.g. 7,3,9,1" aria-label="Custom array values" style="padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:#dff6fb;" />
          <button id="btn-apply" class="btn">Apply</button>
        </div>
      </div>

      <div class="canvas card" role="region" aria-label="Visualization">
        <div class="panel">
          <div class="status" id="status">Idle — ready</div>
          <div class="legend" aria-hidden="true">
            <div class="legend-item"><span class="swatch" style="background: linear-gradient(180deg, rgba(255,236,179,1), rgba(255,220,120,0.95)); border-color: rgba(255,200,50,0.8);"></span>Compare</div>
            <div class="legend-item"><span class="swatch" style="background: linear-gradient(180deg, rgba(255,167,167,1), rgba(255,110,110,0.96)); border-color: rgba(255,90,90,0.9);"></span>Swap</div>
            <div class="legend-item"><span class="swatch" style="background: linear-gradient(180deg, rgba(16,185,129,1), rgba(16,185,129,0.9)); border-color: rgba(16,185,129,0.9);"></span>Sorted</div>
          </div>
        </div>

        <div class="bars-wrap" aria-hidden="false">
          <div id="bars" class="bars" aria-label="Array bars container"></div>
        </div>

        <div class="tree" aria-hidden="false">
          <div id="tree-canvas" class="tree-canvas" aria-label="Binary heap tree">
            <svg id="connectors" class="connectors" viewBox="0 0 1000 200" preserveAspectRatio="none"></svg>
            <div id="nodes"></div>
          </div>
        </div>

        <div class="keys">
          Shortcuts: Space = Play/Pause &nbsp; • &nbsp; N = Next Step &nbsp; • &nbsp; R = Randomize
        </div>
      </div>
    </main>
  </div>

  <script>
    /*
      Heap Sort Interactive Module
      - Single concept: Heap Sort (max-heap -> extract)
      - No external libraries. All animations use CSS transitions on transform.
      - Controls: Random, Reset, Play/Pause, Step, Size, Speed, Custom array input.
      - Keyboard shortcuts: Space (Play/Pause), N (Next), R (Randomize).
    */

    (function () {
      // DOM references
      const btnRandom = document.getElementById('btn-random');
      const btnReset = document.getElementById('btn-reset');
      const btnPlay = document.getElementById('btn-play');
      const btnStep = document.getElementById('btn-step');
      const inputSize = document.getElementById('size');
      const inputSpeed = document.getElementById('speed');
      const inputArr = document.getElementById('input-arr');
      const btnApply = document.getElementById('btn-apply');

      const barsContainer = document.getElementById('bars');
      const nodesContainer = document.getElementById('nodes');
      const connectorsSvg = document.getElementById('connectors');
      const statusEl = document.getElementById('status');

      // State
      let initialArray = [];
      let array = [];
      let n = parseInt(inputSize.value, 10);
      let animator = null;
      let gen = null;
      let autoPlay = false;
      let speedMs = parseInt(inputSpeed.value, 10);

      // configuration
      const safePad = 24;
      const gap = 8; // visual gap between bars
      let barWidth = 48; // will recalc on layout
      const maxBarHeight = 200;

      // Utility: create random array
      function randomArray(len) {
        const arr = [];
        for (let i = 0; i < len; i++) {
          arr.push(Math.floor(Math.random() * 90) + 10);
        }
        return arr;
      }

      // Initialize
      function init(seed) {
        n = parseInt(inputSize.value, 10) || 9;
        speedMs = parseInt(inputSpeed.value, 10) || 600;
        document.documentElement.style.setProperty('--duration', speedMs + 'ms');
        if (seed && Array.isArray(seed)) {
          initialArray = seed.slice();
        } else {
          initialArray = randomArray(n);
        }
        array = initialArray.slice();
        renderAll();
        resetAlgorithmState();
        updateStatus('Ready. Array loaded.');
      }

      // Render bars and tree
      function renderAll() {
        // Clear containers
        barsContainer.innerHTML = '';
        nodesContainer.innerHTML = '';
        connectorsSvg.innerHTML = '';

        // Recompute sizing
        const containerWidth = barsContainer.clientWidth || barsContainer.offsetWidth || 800;
        // dynamic bar width based on n and available space
        const available = containerWidth - (n - 1) * gap;
        barWidth = Math.max(24, Math.min(80, Math.floor(available / n)));
        // set bar width CSS for creation

        // Create bars
        for (let i = 0; i < array.length; i++) {
          const b = document.createElement('div');
          b.className = 'bar';
          b.setAttribute('data-index', i);
          b.setAttribute('role', 'button');
          b.setAttribute('aria-label', 'Value ' + array[i] + ' at index ' + i);
          b.tabIndex = 0;
          b.innerHTML = '<div class="label">' + array[i] + '</div>';
          // set height relative to max value
          const maxVal = Math.max(...array, 100);
          const h = Math.round((array[i] / maxVal) * maxBarHeight);
          b.style.height = (Math.max(24, h)) + 'px';
          b.style.width = barWidth + 'px';
          barsContainer.appendChild(b);

          // click to edit value
          b.addEventListener('click', () => {
            const val = prompt('Edit value at index ' + i, String(array[i]));
            if (val !== null) {
              const v = parseInt(val.trim(), 10);
              if (!Number.isNaN(v)) {
                array[i] = v;
                initialArray = array.slice();
                renderAll();
                resetAlgorithmState();
                updateStatus('Custom array updated.');
              }
            }
          });
          b.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') b.click();
          });
        }

        // Layout bars (absolute)
        layoutBars();

        // Create tree nodes (positions calculated below)
        for (let i = 0; i < array.length; i++) {
          const node = document.createElement('div');
          node.className = 'node';
          node.id = 'node-' + i;
          node.textContent = array[i];
          nodesContainer.appendChild(node);
        }

        layoutTree();
      }

      function layoutBars() {
        const wrapRect = barsContainer.getBoundingClientRect();
        const totalWidth = wrapRect.width;
        const localGap = gap;
        const usedWidth = n * barWidth + (n - 1) * localGap;
        const startX = Math.max(12, (totalWidth - usedWidth) / 2);

        const barEls = barsContainer.querySelectorAll('.bar');
        barEls.forEach((el, index) => {
          const i = parseInt(el.getAttribute('data-index'), 10);
          const x = startX + i * (barWidth + localGap);
          el.style.transform = `translate3d(${x}px, 0, 0)`;
        });
      }

      function layoutTree() {
        // We'll position nodes in levels across the width of the tree canvas.
        const treeRect = document.getElementById('tree-canvas').getBoundingClientRect();
        const width = treeRect.width || 1000;
        const height = treeRect.height || 200;

        const nodes = Array.from(nodesContainer.children);
        nodes.forEach((nEl, i) => {
          // compute level and position in level
          const level = Math.floor(Math.log2(i + 1));
          const indexInLevel = i - (2 ** level - 1);
          const nodesInLevel = 2 ** level;
          const levelY = 20 + level * 56;
          const marginX = 16;
          const usableWidth = Math.max(200, width - marginX * 2);
          const gapX = usableWidth / (nodesInLevel + 1);
          const x = marginX + gapX * (indexInLevel + 1) - (nEl.offsetWidth / 2);
          const y = levelY - (nEl.offsetHeight / 2);
          nEl.style.transform = `translate3d(${x}px, ${y}px, 0)`;
        });

        // Draw connectors lines
        connectorsSvg.innerHTML = '';
        const svgNS = "http://www.w3.org/2000/svg";
        nodes.forEach((nEl, i) => {
          const left = nEl.getBoundingClientRect().left;
          const top = nEl.getBoundingClientRect().top;
          // connector to left child
          const leftChildIndex = 2 * i + 1;
          const rightChildIndex = 2 * i + 2;
          if (leftChildIndex < nodes.length) {
            const child = nodes[leftChildIndex];
            drawLineBetween(nEl, child);
          }
          if (rightChildIndex < nodes.length) {
            const child = nodes[rightChildIndex];
            drawLineBetween(nEl, child);
          }
        });
      }

      function drawLineBetween(aEl, bEl) {
        // Coordinates relative to the svg container
        const svgRect = connectorsSvg.getBoundingClientRect();
        const aRect = aEl.getBoundingClientRect();
        const bRect = bEl.getBoundingClientRect();
        const ax = aRect.left + aRect.width / 2 - svgRect.left;
        const ay = aRect.top + aRect.height / 2 - svgRect.top;
        const bx = bRect.left + bRect.width / 2 - svgRect.left;
        const by = bRect.top + bRect.height / 2 - svgRect.top;

        const ns = "http://www.w3.org/2000/svg";
        const line = document.createElementNS(ns, 'line');
        line.setAttribute('x1', ax);
        line.setAttribute('y1', ay);
        line.setAttribute('x2', bx);
        line.setAttribute('y2', by);
        line.setAttribute('stroke', 'rgba(255,255,255,0.06)');
        line.setAttribute('stroke-width', '2');
        line.setAttribute('stroke-linecap', 'round');
        connectorsSvg.appendChild(line);
      }

      // Algorithm generator functions
      function* siftDownGen(arr, start, end) {
        // start: index to sift down; end: exclusive bound
        let root = start;
        while (true) {
          let child = 2 * root + 1;
          if (child >= end) break;
          let swapIdx = root;
          // compare with left child
          if (arr[swapIdx] < arr[child]) {
            swapIdx = child;
          }
          // compare with right child
          if (child + 1 < end && arr[swapIdx] < arr[child + 1]) {
            swapIdx = child + 1;
          }
          if (swapIdx === root) break;
          yield { type: 'compare', i: root, j: swapIdx };
          yield { type: 'swap', i: root, j: swapIdx };
          // perform swap in array prototype used by generator
          const tmp = arr[root];
          arr[root] = arr[swapIdx];
          arr[swapIdx] = tmp;
          root = swapIdx;
        }
      }

      function* heapSortGenerator(arr) {
        const nLocal = arr.length;
        // build heap
        for (let start = Math.floor((nLocal - 2) / 2); start >= 0; start--) {
          yield* siftDownGen(arr, start, nLocal);
        }
        // extract elements
        for (let end = nLocal - 1; end > 0; end--) {
          yield { type: 'swap', i: 0, j: end };
          const tmp = arr[0];
          arr[0] = arr[end];
          arr[end] = tmp;
          yield { type: 'markSorted', index: end };
          yield* siftDownGen(arr, 0, end);
        }
        yield { type: 'markSorted', index: 0 };
        yield { type: 'done' };
      }

      // Algorithm control
      function resetAlgorithmState() {
        stopAutoPlay();
        gen = null;
        animator = null;
        // clear highlights
        document.querySelectorAll('.bar').forEach(b => {
          b.classList.remove('compare', 'swap', 'sorted');
        });
        document.querySelectorAll('.node').forEach(n => {
          n.classList.remove('compare', 'swap', 'sorted');
          n.textContent = array[parseInt(n.id.split('-')[1], 10)];
        });
      }

      function startGenerator() {
        // create a new generator over a copy so we can show actions and mutate visual array separately.
        // But to keep visual in sync we will operate on the main array and update DOM on each step.
        gen = heapSortGenerator(array);
      }

      function stepOnce() {
        if (!gen) startGenerator();
        const res = gen.next();
        if (res.done) {
          updateStatus('Done: array is sorted.');
          autoPlay = false;
          btnPlay.textContent = 'Play';
          return;
        }
        const action = res.value;
        handleAction(action);
      }

      // Handle generator action: provide animations and state updates
      function handleAction(action) {
        if (!action) return;
        if (action.type === 'compare') {
          clearHighlights();
          highlightPair(action.i, action.j, 'compare');
          updateStatus(`Comparing index ${action.i} (value ${array[action.i]}) and ${action.j} (value ${array[action.j]})`);
        } else if (action.type === 'swap') {
          clearHighlights();
          highlightPair(action.i, action.j, 'swap');
          updateStatus(`Swapping index ${action.i} and ${action.j}`);
          performSwapVisualization(action.i, action.j);
        } else if (action.type === 'markSorted') {
          markSorted(action.index);
          updateStatus(`Index ${action.index} placed into sorted region.`);
        } else if (action.type === 'done') {
          clearHighlights();
          updateStatus('Heap sort complete.');
          document.querySelectorAll('.bar').forEach(b => b.classList.add('sorted'));
          document.querySelectorAll('.node').forEach(n => n.classList.add('sorted'));
          autoPlay = false;
          btnPlay.textContent = 'Play';
        }
      }

      function clearHighlights() {
        document.querySelectorAll('.bar').forEach(b => {
          b.classList.remove('compare', 'swap');
        });
        document.querySelectorAll('.node').forEach(n => {
          n.classList.remove('compare', 'swap');
        });
      }

      function highlightPair(i, j, cls) {
        const barI = barsContainer.querySelector('.bar[data-index="' + i + '"]');
        const barJ = barsContainer.querySelector('.bar[data-index="' + j + '"]');
        if (barI) barI.classList.add(cls);
        if (barJ) barJ.classList.add(cls);

        const nodeI = document.getElementById('node-' + i);
        const nodeJ = document.getElementById('node-' + j);
        if (nodeI) nodeI.classList.add(cls);
        if (nodeJ) nodeJ.classList.add(cls);
      }

      function markSorted(index) {
        const bar = barsContainer.querySelector('.bar[data-index="' + index + '"]');
        if (bar) {
          bar.classList.remove('compare', 'swap');
          bar.classList.add('sorted');
        }
        const node = document.getElementById('node-' + index);
        if (node) {
          node.classList.remove('compare', 'swap');
          node.classList.add('sorted');
        }
      }

      // When swapping, animate bars moving left/right; we rely on updating data-index attributes
      // and then re-laying out positions so CSS transitions animate the transforms.
      function performSwapVisualization(i, j) {
        // swap underlying array is already performed in generator before yielding swap action
        // but in our implementation the generator swaps the array immediately after yielding 'swap'.
        // The action here assumes the array is already updated. To avoid mismatch, we will update
        // DOM by swapping the data-index attributes to reflect new positions.
        // Find bar elements currently at indices i and j
        const barI = barsContainer.querySelector('.bar[data-index="' + i + '"]');
        const barJ = barsContainer.querySelector('.bar[data-index="' + j + '"]');

        if (!barI || !barJ) {
          // fallback: re-render all and return
          renderAll();
          return;
        }

        // Swap data-index attributes and label texts to match the array
        barI.setAttribute('data-index', '__tmp__');
        barJ.setAttribute('data-index', i);
        barI.setAttribute('data-index', j);

        // Update labels to new array values
        const biLabel = barI.querySelector('.label');
        const bjLabel = barJ.querySelector('.label');
        const idxBi = parseInt(barI.getAttribute('data-index'), 10);
        const idxBj = parseInt(barJ.getAttribute('data-index'), 10);
        if (biLabel) biLabel.textContent = array[idxBi];
        if (bjLabel) bjLabel.textContent = array[idxBj];

        // Swap node contents (values) as well to reflect heap array mapping
        const nodeI = document.getElementById('node-' + i);
        const nodeJ = document.getElementById('node-' + j);
        if (nodeI) nodeI.textContent = array[i];
        if (nodeJ) nodeJ.textContent = array[j];

        // Reassign temporary id fix
        const tmpBar = barsContainer.querySelector('.bar[data-index="__tmp__"]');
        if (tmpBar) tmpBar.setAttribute('data-index', j);

        // After attribute swap, relayout bars and tree; CSS transitions animate transforms
        layoutBars();
        layoutTree();

        // Wait for animation to finish before proceeding to next step if autoplay
        const wait = Math.max(200, speedMs);
        // After the swap animation, clear swap class (but keep sorted if applicable)
        setTimeout(() => {
          clearHighlights();
          // Update nodes' text to current array values
          nodesContainer.querySelectorAll('.node').forEach((nEl, idx) => {
            nEl.textContent = array[idx];
          });
          // Continue autoplay if active
          if (autoPlay) scheduleNextStep();
        }, wait + 20);
      }

      // Step scheduling
      function scheduleNextStep() {
        if (!autoPlay) return;
        if (!gen) startGenerator();
        // Wait slightly less than animation to keep pace with transitions
        setTimeout(() => {
          if (!autoPlay) return;
          stepOnce();
        }, Math.max(50, speedMs));
      }

      function startAutoPlay() {
        if (autoPlay) return;
        autoPlay = true;
        btnPlay.textContent = 'Pause';
        if (!gen) startGenerator();
        scheduleNextStep();
      }

      function stopAutoPlay() {
        autoPlay = false;
        btnPlay.textContent = 'Play';
      }

      // Swap two items in array and update DOM; used for manual reset/sync
      function swapInArray(i, j) {
        const tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
      }

      // UI interactions
      btnRandom.addEventListener('click', () => {
        init();
      });
      btnRandom.addEventListener('keydown', (e) => { if (e.key === 'Enter') btnRandom.click(); });

      btnReset.addEventListener('click', () => {
        array = initialArray.slice();
        renderAll();
        resetAlgorithmState();
        updateStatus('Reset to initial array.');
      });

      btnPlay.addEventListener('click', () => {
        if (autoPlay) {
          stopAutoPlay();
          updateStatus('Paused.');
        } else {
          startAutoPlay();
          updateStatus('Playing...');
        }
      });

      btnStep.addEventListener('click', () => {
        if (autoPlay) {
          stopAutoPlay();
        }
        stepOnce();
      });

      inputSize.addEventListener('input', () => {
        // regenerate random array of new size but don't start algorithm automatically
        const newSize = parseInt(inputSize.value, 10);
        init(randomArray(newSize));
      });

      inputSpeed.addEventListener('input', () => {
        speedMs = parseInt(inputSpeed.value, 10);
        document.documentElement.style.setProperty('--duration', speedMs + 'ms');
      });

      btnApply.addEventListener('click', () => {
        const raw = inputArr.value.trim();
        if (!raw) return;
        const parts = raw.split(',').map(s => s.trim()).filter(Boolean);
        const vals = parts.map(p => parseInt(p, 10)).filter(v => !Number.isNaN(v));
        if (!vals.length) {
          alert('Please enter comma-separated integers, e.g. 7,3,9,1');
          return;
        }
        inputSize.value = Math.max(6, Math.min(14, vals.length));
        init(vals);
      });

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.key === ' ' || e.code === 'Space') {
          e.preventDefault();
          btnPlay.click();
        } else if (e.key.toLowerCase() === 'n') {
          btnStep.click();
        } else if (e.key.toLowerCase() === 'r') {
          btnRandom.click();
        }
      });

      // Status update
      function updateStatus(msg) {
        statusEl.textContent = msg;
      }

      // Responsive: relayout on resize
      let resizeTimer;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          layoutBars();
          layoutTree();
        }, 80);
      });

      // Initialize first load
      init();

      // Accessibility: announce initial instructions
      statusEl.setAttribute('role', 'status');

    })();
  </script>
</body>
</html>