import { test, expect } from '@playwright/test';

//
// 72500c40-bcb0-11f0-95d9-c98d28730c93.spec.js
//
// Playwright E2E test suite for "K-Means Interactive Explorer"
//
// NOTES:
// - Tests are written defensively because the HTML snippet is partial. The tests
//   locate elements by visible text (buttons) and by generic labels (Iter, Inertia, Points).
// - The AppPage helper centralizes interactions (page-object pattern).
// - Each test validates FSM behaviors described in the specification:
//   uninitialized -> initialized -> stepping -> running -> converged and pointer drag behaviors.
// - Keyboard shortcuts are tested: Space (toggle run), ArrowRight (step), 'r' (reset).
//

class AppPage {
  constructor(page) {
    this.page = page;
  }

  // navigate to the app
  async goto() {
    await this.page.goto('http://127.0.0.1:5500/workspace/11-08-0004/html/72500c40-bcb0-11f0-95d9-c98d28730c93.html', { waitUntil: 'networkidle' });
    // Wait a short while for any initial JS initialization
    await this.page.waitForTimeout(300);
  }

  // Helpers to find widely-used control buttons by label variants
  async _getButtonByNames(names = []) {
    for (const name of names) {
      const btn = this.page.getByRole('button', { name, exact: false });
      if (await btn.count() > 0) return btn.first();
    }
    // fallback: try text locator
    for (const name of names) {
      const loc = this.page.locator(`text=${name}`);
      if (await loc.count() > 0) return loc.first();
    }
    return null;
  }

  async getInitButton() {
    return await this._getButtonByNames(['Init', 'Initialize', 'Random init', 'Init centroids']);
  }
  async getStepButton() {
    return await this._getButtonByNames(['Step', 'STEP', 'Next']);
  }
  async getRunButton() {
    return await this._getButtonByNames(['Run', 'Start', 'Stop']);
  }
  async getResetButton() {
    return await this._getButtonByNames(['Reset', 'Reset (r)', 'Restart']);
  }
  async getAddRandomButton() {
    return await this._getButtonByNames(['Add random', 'Add Random', 'Random']);
  }
  async getClearButton() {
    return await this._getButtonByNames(['Clear', 'Clear points']);
  }
  async getKInput() {
    // K usually displayed as a number input or range labeled 'K'
    const byLabel = this.page.getByLabel(/k/i);
    if (await byLabel.count() > 0) return byLabel.first();
    const byText = this.page.locator('text=K');
    if (await byText.count() > 0) return byText.first();
    return null;
  }
  async getSpeedInput() {
    const byLabel1 = this.page.getByLabel(/speed/i);
    if (await byLabel.count() > 0) return byLabel.first();
    return null;
  }
  async getToggleLines() {
    return await this._getButtonByNames(['Lines', 'Toggle lines', 'Show lines']);
  }
  async getToggleTrails() {
    return await this._getButtonByNames(['Trails', 'Toggle trails', 'Show trails']);
  }

  // Canvas helpers
  async canvasLocator() {
    const canvases = this.page.locator('canvas');
    if (await canvases.count() > 0) return canvases.first();
    // fallback to any element with role img or a container named 'plot'
    const svg = this.page.locator('svg');
    if (await svg.count() > 0) return svg.first();
    return null;
  }

  async canvasBoundingBox() {
    const canv = await this.canvasLocator();
    if (!canv) return null;
    return await canv.boundingBox();
  }

  async clickCanvasAt(relativeX = 0.5, relativeY = 0.5) {
    // relativeX/Y are ratios into the canvas area
    const box = await this.canvasBoundingBox();
    if (!box) throw new Error('Canvas not found');
    const x = box.x + box.width * relativeX;
    const y = box.y + box.height * relativeY;
    await this.page.mouse.click(x, y);
    // small wait for click handlers to run
    await this.page.waitForTimeout(100);
  }

  async dragOnCanvas(fromRelX, fromRelY, toRelX, toRelY, steps = 6) {
    const box1 = await this.canvasBoundingBox();
    if (!box) throw new Error('Canvas not found');
    const startX = box.x + box.width * fromRelX;
    const startY = box.y + box.height * fromRelY;
    const endX = box.x + box.width * toRelX;
    const endY = box.y + box.height * toRelY;
    await this.page.mouse.move(startX, startY);
    await this.page.mouse.down();
    // incremental moves to simulate pointermove events
    for (let i = 1; i <= steps; i++) {
      const nx = startX + ((endX - startX) * i) / steps;
      const ny = startY + ((endY - startY) * i) / steps;
      await this.page.mouse.move(nx, ny);
      await this.page.waitForTimeout(30);
    }
    await this.page.mouse.up();
    await this.page.waitForTimeout(150);
  }

  // Controls interactions
  async clickInit() {
    const btn1 = await this.getInitButton();
    if (!btn) throw new Error('Init button not found');
    await btn.click();
    await this.page.waitForTimeout(200);
  }
  async clickStep() {
    const btn2 = await this.getStepButton();
    if (!btn) throw new Error('Step button not found');
    await btn.click();
  }
  async clickRun() {
    const btn3 = await this.getRunButton();
    if (!btn) throw new Error('Run button not found');
    await btn.click();
    await this.page.waitForTimeout(120);
  }
  async clickReset() {
    const btn4 = await this.getResetButton();
    if (!btn) throw new Error('Reset button not found');
    await btn.click();
    // wait a bit for reset handlers
    await this.page.waitForTimeout(200);
  }
  async clickAddRandom() {
    const btn5 = await this.getAddRandomButton();
    if (!btn) throw new Error('Add Random button not found');
    await btn.click();
    await this.page.waitForTimeout(150);
  }
  async clickClear() {
    const btn6 = await this.getClearButton();
    if (!btn) throw new Error('Clear button not found');
    await btn.click();
    await this.page.waitForTimeout(150);
  }

  // Keyboard helpers
  async pressSpace() {
    await this.page.keyboard.press(' ');
    await this.page.waitForTimeout(120);
  }
  async pressArrowRight() {
    await this.page.keyboard.press('ArrowRight');
    await this.page.waitForTimeout(120);
  }
  async pressR() {
    // 'r' to reset per FSM
    await this.page.keyboard.press('r');
    await this.page.waitForTimeout(200);
  }

  // Utility: parse textual stats from the page body.
  async _pageText() {
    return await this.page.locator('body').innerText();
  }

  // Attempt to extract iteration count (iter)
  async getIteration() {
    const body = await this._pageText();
    // common patterns: Iter: 0, Iteration: 0, Iterations 0
    const iterMatch = body.match(/(?:Iter(?:ation)?s?|Iters?)[:\s]*([0-9]+)/i);
    if (iterMatch) return parseInt(iterMatch[1], 10);
    // Another heuristic: "iter=0" style
    const iterMatch2 = body.match(/iter\s*[:=]\s*([0-9]+)/i);
    if (iterMatch2) return parseInt(iterMatch2[1], 10);
    // If not found, return null to let tests decide
    return null;
  }

  // Attempt to extract inertia value (float)
  async getInertia() {
    const body1 = await this._pageText();
    const match = body.match(/Inertia[:\s]*([0-9]+(?:\.[0-9]+)?)/i);
    if (match) return parseFloat(match[1]);
    return null;
  }

  // Check for "Converged" textual indicator
  async isConvergedTextPresent() {
    const loc1 = this.page.locator('text=Converged', { exact: false });
    return (await loc.count()) > 0;
  }

  // Read Run button visible text
  async getRunButtonText() {
    const btn7 = await this.getRunButton();
    if (!btn) return null;
    return (await btn.innerText()).trim();
  }
}

test.describe('K-Means Interactive Explorer â€” FSM behavior', () => {
  let app;

  test.beforeEach(async ({ page }) => {
    app = new AppPage(page);
    await app.goto();
  });

  test.afterEach(async ({ page }) => {
    // try to reset app to initial state after each test, using keyboard 'r' or Reset button if present
    try {
      const rb = await app.getResetButton();
      if (rb) await rb.click();
      else await app.pressR();
    } catch (e) {
      // ignore
    }
    await page.waitForTimeout(150);
  });

  test.describe('Uninitialized state and basic UI controls', () => {
    test('has main control buttons and starts in uninitialized-like state', async () => {
      // Validate presence of primary controls: Init, Step, Run, Reset, Add random, Clear
      const initBtn = await app.getInitButton();
      const stepBtn = await app.getStepButton();
      const runBtn = await app.getRunButton();
      const resetBtn = await app.getResetButton();
      const addRandomBtn = await app.getAddRandomButton();
      const clearBtn = await app.getClearButton();

      expect(initBtn).not.toBeNull();
      expect(stepBtn).not.toBeNull();
      expect(runBtn).not.toBeNull();
      expect(resetBtn).not.toBeNull();
      expect(addRandomBtn).not.toBeNull();
      expect(clearBtn).not.toBeNull();

      // Check that iteration is zero or not present (uninitialized should have iter 0)
      const iter = await app.getIteration();
      if (iter !== null) {
        expect(iter).toBeGreaterThanOrEqual(0);
      }
    });

    test('Reset keyboard shortcut (r) returns to uninitialized state', async ({ page }) => {
      // Click Init first to change state
      const initBtn1 = await app.getInitButton();
      if (!initBtn) test.skip('Init button not found, skipping keyboard test');
      await initBtn.click();
      await page.waitForTimeout(200);

      // Press 'r' to reset according to FSM -> should go to uninitialized
      await app.pressR();

      // After reset, iteration should be 0 or missing
      const iter1 = await app.getIteration();
      if (iter !== null) {
        expect(iter).toBe(0);
      }
      // Reset should clear points/centroids: try add random then reset and verify UI text changes
      const addRandomBtn1 = await app.getAddRandomButton();
      if (addRandomBtn) {
        await addRandomBtn.click();
        await page.waitForTimeout(120);
        await app.pressR();
        await page.waitForTimeout(120);
        // No explicit assertion possible beyond not throwing
      }
    });
  });

  test.describe('Initialization and stepping behavior', () => {
    test('Init sets up centroids and permits stepping', async ({ page }) => {
      // Click Init to move from uninitialized -> initialized
      await app.clickInit();

      // Step button should be available and able to perform one step
      const beforeIter = await app.getIteration();

      // Trigger a single stepping action by clicking Step or pressing ArrowRight
      await app.clickStep().catch(() => {}); // if Step not found, rely on keyboard
      if ((await app.getStepButton()) === null) {
        await app.pressArrowRight();
      }

      // wait a bit for step to complete (animation, async)
      await page.waitForTimeout(800);

      const afterIter = await app.getIteration();

      // If iteration counter is present it should increase by at least 1
      if (beforeIter !== null && afterIter !== null) {
        expect(afterIter).toBeGreaterThanOrEqual(beforeIter + 1);
      } else {
        // if counter not found, at least ensure Run button is present still
        const rbText = await app.getRunButtonText();
        expect(rbText).not.toBeNull();
      }
    });

    test('STEP emits converged or changed outcome and UI updates accordingly', async ({ page }) => {
      await app.clickInit();

      // We'll attempt repeated Step clicks until we either detect "Converged" text
      // or we have performed a small number of steps. This validates both STEP_SUCCESS_* paths.
      let converged = false;
      for (let i = 0; i < 6; i++) {
        await app.clickStep();
        // wait for async animations/draws to settle
        await page.waitForTimeout(600);
        if (await app.isConvergedTextPresent()) {
          converged = true;
          break;
        }
      }
      // Either converged was reached or at least we completed a few steps without error
      expect(converged || true).toBeTruthy();
    });

    test('Changing K and re-initializing updates centroids (K_CHANGE -> INIT_CLICK)', async ({ page }) => {
      const kInput = await app.getKInput();
      if (!kInput) test.skip('K input not found; skipping K_CHANGE test');

      // set K to 3 if possible
      try {
        await kInput.fill('3');
        await kInput.press('Enter').catch(() => {});
      } catch (e) {
        // some inputs may be sliders; attempt to click then type
        try {
          await kInput.click();
          await kInput.type('3');
        } catch (err) {
          // ignore
        }
      }

      // Click Init to re-initialize centroids
      await app.clickInit();

      // After initializing, ensure we can Step without error
      await app.clickStep();
      await page.waitForTimeout(500);

      // No explicit numeric assertion since DOM shape unknown, but flow should complete
      expect(true).toBeTruthy();
    });

    test('Speed change affects run loop timing (SPEED_CHANGE observable via faster run)', async ({ page }) => {
      const speedInput = await app.getSpeedInput();
      if (!speedInput) test.skip('Speed control not found; skipping SPEED_CHANGE test');

      // Set to maximum speed if possible
      try {
        await speedInput.fill('10');
        await speedInput.press('Enter').catch(() => {});
      } catch (e) {
        try {
          await speedInput.click();
          await speedInput.type('10');
        } catch (err) {
          // ignore
        }
      }

      // Init then Run briefly; faster speed should not error and should toggle Run button
      await app.clickInit();
      const beforeRunText = await app.getRunButtonText();
      await app.clickRun();
      await page.waitForTimeout(200);
      const duringRunText = await app.getRunButtonText();

      // Run button text should toggle to something indicating running (Stop)
      expect(duringRunText).not.toEqual(beforeRunText);

      // Stop run
      await app.clickRun();
      await page.waitForTimeout(200);
      const afterRunText = await app.getRunButtonText();
      // After stopping it should return to original label or similar
      expect(afterRunText).not.toBeNull();
    });
  });

  test.describe('Run loop and convergence (running state)', () => {
    test('Run starts and toggles Run button text; stopping returns to initialized state', async ({ page }) => {
      await app.clickInit();

      const runBtn1 = await app.getRunButton();
      if (!runBtn) test.skip('Run button not found, skipping run loop test');

      const beforeText = await runBtn.innerText();
      await runBtn.click();
      await page.waitForTimeout(200);

      const duringText = await runBtn.innerText();
      // When running, the UI should indicate 'Stop' or similar; must be different
      expect(duringText.trim().toLowerCase()).not.toEqual(beforeText.trim().toLowerCase());

      // Click again to stop
      await runBtn.click();
      await page.waitForTimeout(200);
      const afterText = await runBtn.innerText();
      expect(afterText).not.toBeNull();
    });

    test('Run completes to converged: RUN_COMPLETE transitions to converged state', async ({ page }) => {
      await app.clickInit();

      // Start run
      const runBtn2 = await app.getRunButton();
      if (!runBtn) test.skip('Run button not found, skipping run-to-converged test');

      await runBtn.click();

      // Wait for up to 10s for convergence text or for Run button to revert to 'Run'
      const maxWait = 10000;
      const start = Date.now();
      let converged1 = false;
      while (Date.now() - start < maxWait) {
        if (await app.isConvergedTextPresent()) {
          converged = true;
          break;
        }
        const currentText = await app.getRunButtonText();
        if (currentText && /run/i.test(currentText) && Date.now() - start > 800) {
          // assume run loop stopped (Run button reverted)
          break;
        }
        await page.waitForTimeout(300);
      }

      // If converged, ensure UI indicates convergence
      if (converged) {
        expect(await app.isConvergedTextPresent()).toBeTruthy();
      } else {
        // Otherwise, at least the run loop stopped gracefully (Run button exists)
        expect(await app.getRunButtonText()).not.toBeNull();
      }
    });
  });

  test.describe('Pointer interactions: add, drag points and centroids', () => {
    test('Clicking on canvas adds a point (CLICK_CANVAS_ADD_POINT -> initialized/converged)', async ({ page }) => {
      const canvas = await app.canvasLocator();
      if (!canvas) test.skip('Canvas not found; skipping canvas-add-point test');

      // Read body text before adding
      const beforeText1 = await app._pageText();

      // Click center of canvas to add point
      await app.clickCanvasAt(0.45, 0.45);

      // Wait for point add handler
      await page.waitForTimeout(200);

      const afterText1 = await app._pageText();

      // Heuristic: look for Points count change or new textual indicator; fallback to mere absence of error
      const beforePointsMatch = beforeText.match(/Points?[:\s]*([0-9]+)/i);
      const afterPointsMatch = afterText.match(/Points?[:\s]*([0-9]+)/i);

      if (beforePointsMatch && afterPointsMatch) {
        const beforeCount = parseInt(beforePointsMatch[1], 10);
        const afterCount = parseInt(afterPointsMatch[1], 10);
        expect(afterCount).toBeGreaterThanOrEqual(beforeCount + 1);
      } else {
        // If explicit points label not present, at least ensure the inner text changed
        expect(afterText).not.toEqual(beforeText);
      }
    });

    test('Dragging a point updates assignments/inertia live (dragging_point state)', async ({ page }) => {
      const canvas1 = await app.canvasLocator();
      if (!canvas) test.skip('Canvas not found; skipping point drag');

      // Add a point to be draggable
      await app.clickCanvasAt(0.3, 0.3);
      await page.waitForTimeout(200);

      // Capture inertia before drag if present
      const inertiaBefore = await app.getInertia();

      // Perform small drag on canvas region where point was added; assume that moves a point
      await app.dragOnCanvas(0.3, 0.3, 0.7, 0.7);
      await page.waitForTimeout(300);

      const inertiaAfter = await app.getInertia();

      // If inertia values are visible, they should generally change due to moving point
      if (inertiaBefore !== null && inertiaAfter !== null) {
        expect(inertiaAfter).not.toEqual(inertiaBefore);
      } else {
        // If inertia not shown, at minimum ensure no JS error and page still responds
        expect(await app._pageText()).not.toBeNull();
      }
    });

    test('Dragging a centroid updates drawing immediately (dragging_centroid state)', async ({ page }) => {
      // Initialize centroids
      await app.clickInit();
      await page.waitForTimeout(200);

      const canvas2 = await app.canvasLocator();
      if (!canvas) test.skip('Canvas not found; skipping centroid drag');

      // Try to approximate a centroid position by clicking near center then dragging
      // We cannot detect centroid DOM element; simulate pointerdown then drag as if on centroid
      await app.dragOnCanvas(0.5, 0.5, 0.6, 0.6);

      // If no error and script executed, this validates startCentroidDrag/endCentroidDrag handlers fired
      expect(true).toBeTruthy();
    });
  });

  test.describe('UI toggles and edge cases', () => {
    test('Toggle lines and trails update UI (TOGGLE_LINES / TOGGLE_TRAILS)', async ({ page }) => {
      const linesToggle = await app.getToggleLines();
      const trailsToggle = await app.getToggleTrails();

      if (!linesToggle && !trailsToggle) test.skip('Toggles not present; skipping toggles test');

      if (linesToggle) {
        await linesToggle.click();
        await page.waitForTimeout(120);
        await linesToggle.click();
        await page.waitForTimeout(120);
      }
      if (trailsToggle) {
        await trailsToggle.click();
        await page.waitForTimeout(120);
        await trailsToggle.click();
        await page.waitForTimeout(120);
      }

      expect(true).toBeTruthy();
    });

    test('Add random and Clear do not crash and change UI state (ADD_RANDOM, CLEAR_CLICK)', async ({ page }) {
      const addRandomBtn2 = await app.getAddRandomButton();
      const clearBtn1 = await app.getClearButton();

      if (!addRandomBtn || !clearBtn) test.skip('Add random or Clear button missing; skipping');

      // Add some random points
      await addRandomBtn.click();
      await page.waitForTimeout(200);
      await addRandomBtn.click();
      await page.waitForTimeout(200);

      // Clear them
      await clearBtn.click();
      await page.waitForTimeout(200);

      // Page should still respond
      expect(await app._pageText()).not.toBeNull();
    });

    test('Window resize triggers UI update (WINDOW_RESIZE event)', async ({ page }) => {
      // Resize viewport to simulate window resize
      await page.setViewportSize({ width: 800, height: 600 });
      await page.waitForTimeout(120);
      await page.setViewportSize({ width: 1200, height: 900 });
      await page.waitForTimeout(120);

      // No explicit UI indicator expected; just ensure no crash
      expect(true).toBeTruthy();
    });
  });

  test.describe('Keyboard shortcut coverage', () => {
    test('Space toggles run state (KEY_SPACE mapped to RUN_CLICK)', async ({ page }) => {
      await app.clickInit();
      const before = await app.getRunButtonText();
      await app.pressSpace();
      await page.waitForTimeout(200);
      const during = await app.getRunButtonText();
      // Text should change (Run -> Stop)
      expect(during).not.toEqual(before);

      // Stop again using space
      await app.pressSpace();
      await page.waitForTimeout(200);
      const after = await app.getRunButtonText();
      expect(after).not.toBeNull();
    });

    test('Right arrow triggers single step (KEY_RIGHT -> STEP_CLICK)', async ({ page }) => {
      await app.clickInit();
      const itBefore = await app.getIteration();
      await app.pressArrowRight();
      await page.waitForTimeout(600);
      const itAfter = await app.getIteration();

      if (itBefore !== null && itAfter !== null) {
        expect(itAfter).toBeGreaterThanOrEqual((itBefore ?? 0) + 1);
      } else {
        // pass if no iteration counter but action did not crash
        expect(true).toBeTruthy();
      }
    });

    test('r resets the visualization (KEY_R -> RESET_CLICK)', async ({ page }) {
      // Ensure some state then reset
      await app.clickInit();
      await app.clickAddRandom().catch(() => {});
      await page.waitForTimeout(120);
      await app.pressR();
      await page.waitForTimeout(200);
      // iter should be zero if reported
      const it = await app.getIteration();
      if (it !== null) expect(it).toBe(0);
    });
  });
});