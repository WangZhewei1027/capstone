{
  "topic": "Two Pointers â€” Pair Sum Visualizer",
  "description": "Models the interactive UI and algorithm animation states for a two-pointers pair-sum visualizer (loading/sorting arrays, stepping/comparing, autoplay, found/finished outcomes).",
  "states": [
    {
      "name": "idle",
      "onEnter": "INIT_SETUP",
      "onExit": "CLEAR_UI",
      "on": {
        "LOAD_SORT_CLICK": "ready",
        "RANDOM_CLICK": "ready",
        "STEP_CLICK": "comparing",
        "PLAY_CLICK": "playing",
        "SORT_ONLY_CLICK": "visual_sorted",
        "RESET_CLICK": "idle",
        "EXPLAIN_TOGGLE_CLICK": "idle",
        "WINDOW_RESIZE": "idle"
      }
    },
    {
      "name": "visual_sorted",
      "onEnter": "SORT_ONLY_ACTION",
      "onExit": "CLEAR_HIGHLIGHTS",
      "on": {
        "LOAD_SORT_CLICK": "ready",
        "RANDOM_CLICK": "ready",
        "RESET_CLICK": "idle",
        "STEP_CLICK": "comparing",
        "PLAY_CLICK": "playing",
        "SORT_ONLY_CLICK": "visual_sorted"
      }
    },
    {
      "name": "ready",
      "onEnter": "LOAD_READY_UI",
      "onExit": "PRE_STEP_PREP",
      "on": {
        "STEP_CLICK": "comparing",
        "PLAY_CLICK": "playing",
        "LOAD_SORT_CLICK": "ready",
        "RANDOM_CLICK": "ready",
        "RESET_CLICK": "idle",
        "SORT_ONLY_CLICK": "visual_sorted",
        "EXPLAIN_TOGGLE_CLICK": "ready",
        "WINDOW_RESIZE": "ready"
      }
    },
    {
      "name": "playing",
      "onEnter": "START_PLAY",
      "onExit": "STOP_PLAY",
      "on": {
        "TIMER_TICK": "comparing",
        "PLAY_CLICK": "ready",
        "STEP_CLICK": "comparing_after_stop",
        "SPEED_CHANGE": "playing",
        "RESET_CLICK": "idle",
        "WINDOW_RESIZE": "playing"
      }
    },
    {
      "name": "comparing",
      "onEnter": "STEP_ONCE",
      "onExit": "CLEAR_COMPARISON_TIMER",
      "on": {
        "COMPARISON_EQUAL": "found",
        "COMPARISON_LESS": "post_move",
        "COMPARISON_GREATER": "post_move",
        "POINTERS_CROSSED": "finished",
        "RESET_CLICK": "idle"
      }
    },
    {
      "name": "comparing_after_stop",
      "onEnter": "STOP_PLAY_AND_STEP",
      "onExit": "CLEAR_COMPARISON_TIMER",
      "on": {
        "COMPARISON_EQUAL": "found",
        "COMPARISON_LESS": "ready",
        "COMPARISON_GREATER": "ready",
        "POINTERS_CROSSED": "finished",
        "RESET_CLICK": "idle"
      }
    },
    {
      "name": "post_move",
      "onEnter": "APPLY_POINTER_MOVE",
      "onExit": "CLEAR_MOVE_ANIM",
      "on": {
        "CONTINUE_PLAYING": "playing",
        "CONTINUE_PAUSED": "ready",
        "POINTERS_CROSSED": "finished",
        "RESET_CLICK": "idle"
      }
    },
    {
      "name": "found",
      "onEnter": "ON_FOUND_ACTION",
      "onExit": "CLEAR_HIGHLIGHTS",
      "on": {
        "RESET_CLICK": "idle",
        "LOAD_SORT_CLICK": "ready",
        "PLAY_CLICK": "playing",
        "RANDOM_CLICK": "ready",
        "SORT_ONLY_CLICK": "visual_sorted"
      }
    },
    {
      "name": "finished",
      "onEnter": "ON_FINISHED_ACTION",
      "onExit": "CLEAR_HIGHLIGHTS",
      "on": {
        "RESET_CLICK": "idle",
        "LOAD_SORT_CLICK": "ready",
        "PLAY_CLICK": "playing",
        "RANDOM_CLICK": "ready",
        "SORT_ONLY_CLICK": "visual_sorted"
      }
    }
  ],
  "events": [
    "LOAD_SORT_CLICK",
    "RANDOM_CLICK",
    "RESET_CLICK",
    "STEP_CLICK",
    "PLAY_CLICK",
    "TIMER_TICK",
    "SPEED_CHANGE",
    "SORT_ONLY_CLICK",
    "EXPLAIN_TOGGLE_CLICK",
    "WINDOW_RESIZE",
    "COMPARISON_EQUAL",
    "COMPARISON_LESS",
    "COMPARISON_GREATER",
    "POINTERS_CROSSED",
    "CONTINUE_PLAYING",
    "CONTINUE_PAUSED"
  ],
  "notes": "State actions map to functions in the implementation:\n- INIT_SETUP: createCells(initial), placePointers(), setActiveCode(1)\n- LOAD_AND_SORT / LOAD_READY_UI: parseArrayInput(), arr = nums, arr.sort(), createCells(arr), L=0,R=n-1, placePointers(), setActiveCode(1), update sum banner, log\n- RANDOM_CLICK: generate random sorted array, set arrayInput and target, then LOAD_AND_SORT\n- SORT_ONLY_ACTION: parseArrayInput(), sort values, createCells(sorted), L/R set for visual only, placePointers(), log (does not set internal arr variable in code)\n- STEP_ONCE: the stepOnce() routine: check empty or L>=R; setActiveCode lines, compute a+b, update banner, highlight active; after timeout decide equality/less/greater and perform pointer move or found; emit COMPARISON_* or POINTERS_CROSSED accordingly\n- START_PLAY / STOP_PLAY: start/clear interval timer and set playing flag and UI button text\n- STOP_PLAY_AND_STEP: stopPlaying() then perform single STEP_ONCE (code path used when Step is clicked while playing)\n- APPLY_POINTER_MOVE: update L or R, placePointers(), log; then if playing continue (CONTINUE_PLAYING) else go to ready (CONTINUE_PAUSED). The code implicitly continues or stops depending on playing flag.\n- ON_FOUND_ACTION / ON_FINISHED_ACTION: highlight found/crossed state, setActiveCode(4 or 7), update banner, log, stopPlaying()\n\nKeyboard shortcuts: Space triggers PLAY_CLICK (with load if arr empty), ArrowRight triggers STEP_CLICK, ArrowLeft triggers RESET_CLICK. Window resize triggers PLACE_POINTERS (handled as WINDOW_RESIZE event). Internal timing and animation delays are modeled by TIMER_TICK and the comparing state's internal timers that yield COMPARISON_* events. The FSM folds transient animation intervals into 'comparing' and 'post_move' states and exposes internal outcome events for clarity."
}