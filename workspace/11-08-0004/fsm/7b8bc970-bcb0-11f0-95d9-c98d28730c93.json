{
  "topic": "Topological Sort Interactive Application",
  "description": "Finite state machine modeling the interactive behaviours of the Topological Sort (Kahn's algorithm) educational module: edit modes, node/edge interactions, and running/stepping/auto-running the algorithm with visual feedback and completion/cycle detection.",
  "states": [
    {
      "name": "mode:move",
      "onEnter": "setMode('move')",
      "onExit": "clearTempEdge()",
      "on": {
        "CLICK_MODE_ADD": "mode:add",
        "CLICK_MODE_EDGE": "mode:edge",
        "CLICK_MODE_DELETE": "mode:delete",
        "CLICK_MODE_MOVE": "mode:move",
        "DOUBLE_CLICK_STAGE": "ACTION_ADD_NODE",
        "MOUSEDOWN_NODE": "interaction:select_or_drag_start",
        "MOUSEDOWN_STAGE_EMPTY": "DESELECT_NODE"
      }
    },
    {
      "name": "mode:add",
      "onEnter": "setMode('add')",
      "onExit": "clearTempEdge()",
      "on": {
        "CLICK_MODE_MOVE": "mode:move",
        "CLICK_MODE_EDGE": "mode:edge",
        "CLICK_MODE_DELETE": "mode:delete",
        "CLICK_MODE_ADD": "mode:add",
        "DOUBLE_CLICK_STAGE": "ACTION_ADD_NODE",
        "MOUSEDOWN_STAGE_EMPTY": "ACTION_ADD_NODE",
        "MOUSEDOWN_NODE": "interaction:select_node"
      }
    },
    {
      "name": "mode:edge",
      "onEnter": "setMode('edge')",
      "onExit": "clearTempEdge()",
      "on": {
        "CLICK_MODE_MOVE": "mode:move",
        "CLICK_MODE_ADD": "mode:add",
        "CLICK_MODE_DELETE": "mode:delete",
        "CLICK_MODE_EDGE": "mode:edge",
        "MOUSEDOWN_NODE": "mode:edge:temp",
        "CANCEL_TEMP_EDGE": "mode:edge"
      }
    },
    {
      "name": "mode:edge:temp",
      "onEnter": "beginTempEdge(fromNodeId)",
      "onExit": "clearTempEdge()",
      "on": {
        "MOUSEMOVE": "TEMP_EDGE_UPDATE",
        "MOUSEUP_OVER_NODE": "ACTION_ADD_EDGE",
        "MOUSEUP_NOT_OVER_NODE": "CANCEL_TEMP_EDGE",
        "CLICK_MODE_MOVE": "mode:move",
        "CLICK_MODE_ADD": "mode:add",
        "CLICK_MODE_DELETE": "mode:delete"
      }
    },
    {
      "name": "mode:delete",
      "onEnter": "setMode('delete')",
      "onExit": "clearTempEdge()",
      "on": {
        "CLICK_MODE_MOVE": "mode:move",
        "CLICK_MODE_ADD": "mode:add",
        "CLICK_MODE_EDGE": "mode:edge",
        "CLICK_MODE_DELETE": "mode:delete",
        "MOUSEDOWN_NODE": "ACTION_REMOVE_NODE",
        "KEY_DELETE": "ACTION_REMOVE_SELECTED_NODE",
        "MOUSEDOWN_STAGE_EMPTY": "DESELECT_NODE"
      }
    },
    {
      "name": "interaction:select_or_drag_start",
      "onEnter": "selectNode(nodeId); if(mode==='move') startDrag(nodeId, event)",
      "onExit": "stopDrag()",
      "on": {
        "MOUSEMOVE": "interaction:dragging",
        "MOUSEUP": "interaction:drag_end",
        "KEY_DELETE": "ACTION_REMOVE_SELECTED_NODE",
        "CLICK_STAGE_EMPTY": "DESELECT_NODE"
      }
    },
    {
      "name": "interaction:dragging",
      "onEnter": "startDrag(nodeId, event)",
      "onExit": "stopDrag()",
      "on": {
        "MOUSEMOVE": "interaction:dragging",
        "MOUSEUP": "interaction:drag_end"
      }
    },
    {
      "name": "interaction:drag_end",
      "onEnter": "stopDrag()",
      "on": {
        "NO_OP": "mode:move"
      }
    },
    {
      "name": "kahn:idle",
      "onEnter": "resetRun()",
      "onExit": "",
      "on": {
        "COMPUTE_INIT": "kahn:initialized",
        "LOAD_SAMPLE": "kahn:idle",
        "LOAD_RANDOM": "kahn:idle",
        "CLEAR_GRAPH": "kahn:idle",
        "RESET_RUN": "kahn:idle",
        "AUTO_TOGGLE": "kahn:idle"
      }
    },
    {
      "name": "kahn:initialized",
      "onEnter": "initKahn()",
      "onExit": "",
      "on": {
        "STEP": "kahn:stepping",
        "AUTO_START": "kahn:auto_running",
        "RESET_RUN": "kahn:idle",
        "COMPUTE_INIT": "kahn:initialized"
      }
    },
    {
      "name": "kahn:stepping",
      "onEnter": "stepKahn()",
      "onExit": "",
      "on": {
        "STEP_COMPLETE_NOT_FINISHED": "kahn:initialized",
        "STEP_COMPLETE_FINISHED": "kahn:complete",
        "STEP_DETECTED_CYCLE": "kahn:cycle_detected",
        "RESET_RUN": "kahn:idle"
      }
    },
    {
      "name": "kahn:auto_running",
      "onEnter": "startAutoRun(interval)",
      "onExit": "stopAutoRun()",
      "on": {
        "AUTO_TICK": "kahn:stepping",
        "AUTO_STOP": "kahn:initialized",
        "AUTO_FINISHED": "kahn:complete",
        "RESET_RUN": "kahn:idle"
      }
    },
    {
      "name": "kahn:cycle_detected",
      "onEnter": "highlightRemainingAsCycle(); statusText='Cycle detected'",
      "onExit": "clear cycle highlights (on next reset)",
      "on": {
        "RESET_RUN": "kahn:idle",
        "COMPUTE_INIT": "kahn:initialized"
      }
    },
    {
      "name": "kahn:complete",
      "onEnter": "finishRun(); showToast('Topological order complete.')",
      "onExit": "",
      "on": {
        "RESET_RUN": "kahn:idle",
        "COMPUTE_INIT": "kahn:initialized"
      }
    },
    {
      "name": "graph:manipulation",
      "onEnter": "",
      "onExit": "",
      "on": {
        "ACTION_ADD_NODE": "graph:manipulation",
        "ACTION_ADD_EDGE": "graph:manipulation",
        "ACTION_REMOVE_NODE": "graph:manipulation",
        "LOAD_SAMPLE": "graph:manipulation",
        "LOAD_RANDOM": "graph:manipulation",
        "CLEAR_GRAPH": "graph:manipulation"
      }
    }
  ],
  "events": [
    "CLICK_MODE_MOVE",
    "CLICK_MODE_ADD",
    "CLICK_MODE_EDGE",
    "CLICK_MODE_DELETE",
    "DOUBLE_CLICK_STAGE",
    "MOUSEDOWN_NODE",
    "MOUSEDOWN_STAGE_EMPTY",
    "MOUSEMOVE",
    "MOUSEUP",
    "MOUSEUP_OVER_NODE",
    "MOUSEUP_NOT_OVER_NODE",
    "TEMP_EDGE_UPDATE",
    "BEGIN_TEMP_EDGE",
    "CANCEL_TEMP_EDGE",
    "ACTION_ADD_EDGE",
    "ACTION_ADD_NODE",
    "ACTION_REMOVE_NODE",
    "ACTION_REMOVE_SELECTED_NODE",
    "DESELECT_NODE",
    "SELECT_NODE",
    "KEY_DELETE",
    "LOAD_SAMPLE",
    "LOAD_RANDOM",
    "CLEAR_GRAPH",
    "COMPUTE_INIT",
    "STEP",
    "STEP_COMPLETE_NOT_FINISHED",
    "STEP_COMPLETE_FINISHED",
    "STEP_DETECTED_CYCLE",
    "AUTO_START",
    "AUTO_STOP",
    "AUTO_TICK",
    "AUTO_FINISHED",
    "AUTO_TOGGLE",
    "RESET_RUN",
    "NO_OP"
  ],
  "notes": "This FSM models two orthogonal concerns in the application: (1) editor interaction modes (move, add, edge, delete) and transient interactions (dragging, temporary edge creation) and (2) Kahn's algorithm run states (idle, initialized, stepping, auto-running, cycle detected, complete). In the real implementation these domains operate concurrently: mode switching and graph manipulations are independent from the algorithm FSM (although the UI disables/enables algorithm buttons and highlights nodes based on kahnState). 'onEnter' and 'onExit' actions reference the JavaScript functions used in the app (e.g., setMode(...), beginTempEdge(...), clearTempEdge(), initKahn(), stepKahn(), startAutoRun(), stopAutoRun(), finishRun(), resetRun(), highlightRemainingAsCycle(), animateNodeToOutput()). Transitions for stepping and auto-run are modeled as step/auto tick events; stepKahn() is synchronous in the code but may produce three outcomes: continue (STEP_COMPLETE_NOT_FINISHED), finish (STEP_COMPLETE_FINISHED) or detect cycle (STEP_DETECTED_CYCLE). Visual states applied to nodes (node-zero, node-selected, node-output, node-detect) are side effects of the Kahn and selection actions and are represented implicitly by the algorithm and selection transitions.",
  "version": "1.0"
}