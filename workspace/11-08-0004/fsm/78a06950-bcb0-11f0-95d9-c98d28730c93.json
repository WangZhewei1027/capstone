{
  "topic": "Topological Sort Visualizer (Kahn's Algorithm)",
  "description": "Models UI modes and algorithm progression for an interactive Kahn's algorithm topological-sort visualizer: graph editing modes (add/create-edge/delete/drag), algorithm lifecycle (prepare, step, animate, autoplay), and terminal states (complete or cycle detected).",
  "states": [
    {
      "name": "idle_editing",
      "onEnter": "updateUIIdle",
      "onExit": "clearTransientHighlights",
      "on": {
        "CLICK_ADD_NODE": "idle_editing",
        "DOUBLE_CLICK_ADD_NODE": "idle_editing",
        "TOGGLE_CREATE_EDGE": "create_edge_idle",
        "TOGGLE_DELETE_MODE": "delete_mode",
        "CLICK_RANDOM_DAG": "idle_editing",
        "CLICK_RESET_GRAPH": "idle_editing",
        "PREPARE_ALGORITHM": "algo_ready",
        "NODE_DRAG_START": "dragging"
      }
    },
    {
      "name": "create_edge_idle",
      "onEnter": "enterCreateEdgeMode",
      "onExit": "exitCreateEdgeMode",
      "on": {
        "SELECT_EDGE_SOURCE": "create_edge_pending",
        "TOGGLE_CREATE_EDGE": "idle_editing",
        "CLICK_BACKGROUND_CANCEL": "idle_editing",
        "NODE_DRAG_START": "dragging",
        "CLICK_RANDOM_DAG": "create_edge_idle",
        "CLICK_RESET_GRAPH": "idle_editing"
      }
    },
    {
      "name": "create_edge_pending",
      "onEnter": "highlightPendingSource",
      "onExit": "clearPendingSource",
      "on": {
        "SELECT_EDGE_TARGET": "create_edge_idle",
        "CANCEL_CREATE_EDGE": "create_edge_idle",
        "TOGGLE_CREATE_EDGE": "idle_editing",
        "CLICK_BACKGROUND_CANCEL": "create_edge_idle",
        "NODE_DRAG_START": "dragging"
      }
    },
    {
      "name": "delete_mode",
      "onEnter": "enterDeleteMode",
      "onExit": "exitDeleteMode",
      "on": {
        "CLICK_DELETE_NODE": "delete_mode",
        "CLICK_DELETE_EDGE": "delete_mode",
        "TOGGLE_DELETE_MODE": "idle_editing",
        "NODE_DRAG_START": "dragging",
        "CLICK_RESET_GRAPH": "idle_editing",
        "CLICK_RANDOM_DAG": "delete_mode"
      }
    },
    {
      "name": "dragging",
      "onEnter": "startDraggingNode",
      "onExit": "stopDraggingNode",
      "on": {
        "NODE_DRAG_END": "idle_editing",
        "NODE_DRAG_CANCEL": "idle_editing",
        "NODE_DRAG_MOVE": "dragging"
      }
    },
    {
      "name": "algo_ready",
      "onEnter": "prepareAlgorithm",
      "onExit": "persistAlgorithmState",
      "on": {
        "CLICK_STEP": "algo_processing",
        "START_AUTOPLAY": "autoplay_playing",
        "CLICK_RESTART": "algo_ready",
        "PREPARE_ALGORITHM": "algo_ready",
        "CLICK_RESET_GRAPH": "idle_editing",
        "CLICK_RANDOM_DAG": "algo_ready",
        "NODE_DRAG_START": "dragging"
      }
    },
    {
      "name": "algo_processing",
      "onEnter": "animateRemoveNode",
      "onExit": "finalizeStep",
      "on": {
        "ANIMATION_COMPLETE": "algo_ready",
        "ALGORITHM_COMPLETE": "algo_complete",
        "CYCLE_DETECTED": "cycle_detected",
        "START_AUTOPLAY": "autoplay_playing"
      }
    },
    {
      "name": "autoplay_playing",
      "onEnter": "startAutoplayTimer",
      "onExit": "stopAutoplayTimer",
      "on": {
        "TIMER_TICK": "algo_processing",
        "STOP_AUTOPLAY": "algo_ready",
        "ANIMATION_COMPLETE": "autoplay_playing",
        "ALGORITHM_COMPLETE": "algo_complete",
        "CYCLE_DETECTED": "cycle_detected",
        "CLICK_RESET_GRAPH": "idle_editing"
      }
    },
    {
      "name": "algo_complete",
      "onEnter": "displayCompletionStatus",
      "onExit": "clearCompletionHighlights",
      "on": {
        "PREPARE_ALGORITHM": "algo_ready",
        "CLICK_RESTART": "algo_ready",
        "CLICK_RESET_GRAPH": "idle_editing",
        "START_AUTOPLAY": "autoplay_playing",
        "NODE_DRAG_START": "dragging"
      }
    },
    {
      "name": "cycle_detected",
      "onEnter": "displayCycleStatus",
      "onExit": "clearCycleHighlights",
      "on": {
        "PREPARE_ALGORITHM": "algo_ready",
        "CLICK_RESTART": "algo_ready",
        "CLICK_RESET_GRAPH": "idle_editing",
        "NODE_DRAG_START": "dragging"
      }
    }
  ],
  "events": [
    "CLICK_ADD_NODE",
    "DOUBLE_CLICK_ADD_NODE",
    "TOGGLE_CREATE_EDGE",
    "SELECT_EDGE_SOURCE",
    "SELECT_EDGE_TARGET",
    "CANCEL_CREATE_EDGE",
    "CLICK_BACKGROUND_CANCEL",
    "TOGGLE_DELETE_MODE",
    "CLICK_DELETE_NODE",
    "CLICK_DELETE_EDGE",
    "CLICK_RANDOM_DAG",
    "CLICK_RESET_GRAPH",
    "PREPARE_ALGORITHM",
    "CLICK_STEP",
    "CLICK_RESTART",
    "START_AUTOPLAY",
    "STOP_AUTOPLAY",
    "TIMER_TICK",
    "ANIMATION_COMPLETE",
    "ALGORITHM_COMPLETE",
    "CYCLE_DETECTED",
    "NODE_DRAG_START",
    "NODE_DRAG_MOVE",
    "NODE_DRAG_END",
    "NODE_DRAG_CANCEL",
    "SPEED_CHANGE"
  ],
  "notes": "High-level FSM capturing UI modes and algorithm lifecycle. Important behaviors: create-edge and delete modes are mutually exclusive; create-edge has a substate when a source node is selected (pending). Dragging is modeled as a transient state. 'prepareAlgorithm' computes indegrees/adjacency, populates zero in-degree queue and sets algorithmRunning. 'algo_processing' represents a single Step invocation that animates node/edge removal and then, on ANIMATION_COMPLETE, finalizes indegree updates and returns to algo_ready or transitions to algo_complete/cycle_detected. Autoplay schedules repeated TIMER_TICK events that transition into algo_processing. Many UI actions (add node, random DAG, reset) affect graph data synchronously and typically keep the FSM in an editing or algorithm-ready state. This model abstracts some implementation details (timers, sorting queue by label, DOM class updates) as onEnter/onExit actions."
}