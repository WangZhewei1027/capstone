{
  "topic": "Divide-and-Conquer Interactive Visualization",
  "description": "Models the interactive states and transitions for a merge-style divide-and-conquer visualization (array bars, recursion tree, action log, and animation controls). States capture playback, single-step/rewind behavior, merge animations, and UI-driven array setup actions.",
  "states": [
    {
      "name": "idle",
      "onEnter": "setMode('Idle'); initializeFromOriginal() (render bars/tree, clear actions & timers)",
      "onExit": "none",
      "on": {
        "PLAY": "playing",
        "STEP": "stepping",
        "BACK": "rewinding",
        "RANDOMIZE": "idle",
        "APPLY_CUSTOM": "idle",
        "RESET": "idle",
        "SIZE_CHANGE": "idle",
        "NODE_CLICK": "idle"
      }
    },
    {
      "name": "playing",
      "onEnter": "startPlaying() (prepareActions() if needed; set playing=true; setMode('Playing'); playActions())",
      "onExit": "clearAnimTimer() (stop scheduled timeouts)",
      "on": {
        "PAUSE": "paused",
        "STEP": "stepping",
        "BACK": "rewinding",
        "RESET": "idle",
        "RANDOMIZE": "idle",
        "APPLY_CUSTOM": "idle",
        "ANIMATION_STARTED": "animating",
        "FINISH": "finished"
      }
    },
    {
      "name": "paused",
      "onEnter": "pausePlayback() (set playing=false; setMode('Paused'); clearAnimTimer())",
      "onExit": "none",
      "on": {
        "PLAY": "playing",
        "STEP": "stepping",
        "BACK": "rewinding",
        "RESET": "idle",
        "RANDOMIZE": "idle",
        "APPLY_CUSTOM": "idle"
      }
    },
    {
      "name": "animating",
      "onEnter": "startMergeAnimation() (executeAction merge with internal timed steps; set animTimer)",
      "onExit": "clearAnimTimer()",
      "on": {
        "ANIMATION_DONE_KEEP_PLAYING": "playing",
        "ANIMATION_DONE_STOP": "idle",
        "PAUSE": "paused",
        "RESET": "idle",
        "BACK": "rewinding"
      }
    },
    {
      "name": "stepping",
      "onEnter": "performStep() (prepareActions() if needed; set playing=false; stepForward(); execute current action synchronously or begin merge animation)",
      "onExit": "clearAnimTimer() (if a merge animation was started by the step)",
      "on": {
        "MERGE_ANIMATION_STARTED": "animating",
        "STEP_COMPLETE": "idle",
        "FINISH": "finished",
        "RESET": "idle"
      }
    },
    {
      "name": "rewinding",
      "onEnter": "performBack() (clear timers; stepBackward() -> replay state up to actionIndex-1)",
      "onExit": "none",
      "on": {
        "BACK_COMPLETE": "idle",
        "RESET": "idle"
      }
    },
    {
      "name": "finished",
      "onEnter": "setMode('Finished')",
      "onExit": "none",
      "on": {
        "RESET": "idle",
        "PLAY": "playing",
        "RANDOMIZE": "idle",
        "APPLY_CUSTOM": "idle"
      }
    }
  ],
  "events": [
    "PLAY",
    "PAUSE",
    "STEP",
    "BACK",
    "RESET",
    "RANDOMIZE",
    "APPLY_CUSTOM",
    "SIZE_CHANGE",
    "NODE_CLICK",
    "ANIMATION_STARTED",
    "ANIMATION_DONE_KEEP_PLAYING",
    "ANIMATION_DONE_STOP",
    "MERGE_ANIMATION_STARTED",
    "STEP_COMPLETE",
    "BACK_COMPLETE",
    "ACTIONS_PREPARED",
    "FINISH"
  ],
  "notes": "This FSM maps the UI controls and internal animation sequencing of the merge-style divide-and-conquer demo. Key behaviors captured: Play begins automated stepping through the recorded actions (prepareActions -> recordActionsForMergeSort), Pause stops automatic progression (clears animTimer), Step advances a single action (may start a merge animation), Back rewinds one action by re-rendering and replaying up to actionIndex-1. 'animating' represents an internal timed merge sequence driven by animTimer; its completion leads either back into continuous playing (ANIMATION_DONE_KEEP_PLAYING) or stops to idle/paused (ANIMATION_DONE_STOP) depending on whether the user requested continuous playback. Node clicks (NODE_CLICK) focus subarray UI but do not change global playback state. Keyboard shortcuts (Space, ArrowRight, ArrowLeft) dispatch PLAY/PAUSE, STEP, BACK respectively. The mapping simplifies some conditional logic present in the code (e.g., whether to re-prepare actions when empty) into explicit prepare/start actions called on state entry."
}