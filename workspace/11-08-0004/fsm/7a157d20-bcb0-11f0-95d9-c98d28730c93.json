{
  "topic": "Bellman-Ford Interactive Explorer",
  "description": "Models the user interactions, algorithm execution, and visual-feedback states of the Bellman-Ford interactive SVG application (node/edge creation, stepping/playback of relaxations, and negative-cycle detection).",
  "states": [
    {
      "name": "idle",
      "onEnter": "render",
      "on": {
        "CLICK_CANVAS": "adding_node",
        "NODE_CLICK": "creating_edge",
        "NODE_CTRL_CLICK": "source_selected",
        "START_DRAG": "dragging",
        "CLICK_PRESET1": "preset_loaded",
        "CLICK_PRESET2": "preset_loaded",
        "CLICK_CLEAR": "cleared",
        "CLICK_RESET": "reset_state",
        "CLICK_HELP": "show_help",
        "RUN_STEP": "prepared_steps",
        "PLAY_TOGGLE": "playing",
        "DETECT_NEGATIVE": "detecting_negative"
      }
    },
    {
      "name": "adding_node",
      "onEnter": "createNode",
      "onExit": "render",
      "on": {
        "DONE": "idle",
        "CLICK_CANVAS": "adding_node"
      }
    },
    {
      "name": "creating_edge",
      "onEnter": "startEdgeCreation (set creatingEdgeFrom + updateSelectionVisual)",
      "onExit": "updateSelectionVisual",
      "on": {
        "NODE_CLICK_TARGET": "edge_created",
        "NODE_CLICK_SAME": "idle",
        "CANCEL_EDGE_CREATION": "idle",
        "START_DRAG": "dragging",
        "CLICK_CANVAS": "adding_node"
      }
    },
    {
      "name": "edge_created",
      "onEnter": "addEdge (and add reverse if undirected) + render + status='Edge created'",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "dragging",
      "onEnter": "startDrag (capture node, set drag offsets)",
      "onExit": "endDrag + render",
      "on": {
        "DRAG_MOVE": "dragging",
        "END_DRAG": "idle",
        "DRAG_CANCEL": "idle"
      }
    },
    {
      "name": "source_selected",
      "onEnter": "setSource (sourceNodeId=...) + sourceLabel update + resetAlgorithmState + render",
      "on": {
        "DONE": "idle",
        "RUN_STEP": "prepared_steps",
        "PLAY_TOGGLE": "playing",
        "DETECT_NEGATIVE": "detecting_negative"
      }
    },
    {
      "name": "prepared_steps",
      "onEnter": "prepareSteps (compute steps[], reset distances/preds for replay, update displays)",
      "on": {
        "RUN_STEP": "stepping",
        "PLAY_TOGGLE": "playing",
        "DETECT_NEGATIVE": "detecting_negative",
        "RESET_ALGORITHM": "reset_state"
      }
    },
    {
      "name": "stepping",
      "onEnter": "applyStep (apply current step: highlightEdge, update distances/preds, render, flashNode, updateTable, increment currentStepIndex)",
      "onExit": "updateTable",
      "on": {
        "STEP_APPLIED_MORE": "prepared_steps",
        "STEP_APPLIED_COMPLETE": "completed",
        "PLAY_TOGGLE": "playing",
        "DETECT_NEGATIVE": "detecting_negative"
      }
    },
    {
      "name": "playing",
      "onEnter": "play (start interval timer; btnPlay text -> 'Pause'; status -> 'Playing')",
      "onExit": "stopPlay (clear interval; btnPlay text -> 'Play')",
      "on": {
        "TIMER_TICK": "playing",
        "PLAY_TOGGLE": "paused",
        "AUTO_COMPLETE": "completed",
        "DETECT_NEGATIVE": "detecting_negative"
      }
    },
    {
      "name": "paused",
      "onEnter": "stopPlay",
      "on": {
        "PLAY_TOGGLE": "playing",
        "RUN_STEP": "stepping",
        "DETECT_NEGATIVE": "detecting_negative",
        "RESET_ALGORITHM": "reset_state"
      }
    },
    {
      "name": "detecting_negative",
      "onEnter": "detectNegativeCycle (ensure final distances by applying remaining steps if needed; then scan edges for du + w < dv; highlight neg edges + flash nodes)",
      "onExit": "updateEdgeStyles",
      "on": {
        "NEGATIVE_FOUND": "negative_detected",
        "NO_NEGATIVE_FOUND": "no_negative_detected",
        "DONE": "idle"
      }
    },
    {
      "name": "negative_detected",
      "onEnter": "highlightNegativeEdges + flashInvolvedNodes + status='Negative cycle detected â€” highlighted in red'",
      "on": {
        "ACK": "idle",
        "RESET_ALGORITHM": "reset_state"
      }
    },
    {
      "name": "no_negative_detected",
      "onEnter": "status='No negative cycle detected.'",
      "on": {
        "ACK": "idle",
        "RESET_ALGORITHM": "reset_state"
      }
    },
    {
      "name": "completed",
      "onEnter": "status='Completed V-1 iterations' (or 'Finished' from play); update displays",
      "on": {
        "DETECT_NEGATIVE": "detecting_negative",
        "RUN_STEP": "prepared_steps",
        "PLAY_TOGGLE": "playing",
        "RESET_ALGORITHM": "reset_state"
      }
    },
    {
      "name": "cleared",
      "onEnter": "clearGraph (nodes=[], edges=[], resetAlgorithmState, render, status='Ready')",
      "on": {
        "DONE": "idle",
        "CLICK_PRESET1": "preset_loaded",
        "CLICK_PRESET2": "preset_loaded"
      }
    },
    {
      "name": "preset_loaded",
      "onEnter": "loadPreset (create nodes, addEdge calls, render) + status updated to preset hint",
      "on": {
        "DONE": "idle",
        "SELECT_SOURCE": "source_selected"
      }
    },
    {
      "name": "reset_state",
      "onEnter": "resetAlgorithmState + render",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "show_help",
      "onEnter": "showHelp (alert with keyboard & interaction tips)",
      "on": {
        "DONE": "idle"
      }
    }
  ],
  "events": [
    "CLICK_CANVAS",
    "NODE_CLICK",
    "NODE_CLICK_TARGET",
    "NODE_CLICK_SAME",
    "NODE_CTRL_CLICK",
    "SELECT_SOURCE",
    "START_DRAG",
    "DRAG_MOVE",
    "END_DRAG",
    "DRAG_CANCEL",
    "CLICK_PRESET1",
    "CLICK_PRESET2",
    "CLICK_CLEAR",
    "CLICK_RESET",
    "CLICK_HELP",
    "RUN_STEP",
    "PREPARE_STEPS",
    "STEPS_PREPARED",
    "STEP_APPLIED_MORE",
    "STEP_APPLIED_COMPLETE",
    "PLAY_TOGGLE",
    "PLAY",
    "PAUSE",
    "TIMER_TICK",
    "AUTO_COMPLETE",
    "DETECT_NEGATIVE",
    "NEGATIVE_FOUND",
    "NO_NEGATIVE_FOUND",
    "CLEAR_GRAPH",
    "RESET_ALGORITHM",
    "LOAD_PRESET1",
    "LOAD_PRESET2",
    "HELP",
    "ACK",
    "DONE"
  ],
  "notes": "This FSM models user interaction and algorithm execution flows in the application at a high level. Actions referenced in onEnter/onExit correspond to concrete functions in the source (render, createNode, addEdge, startEdgeCreation/updateSelectionVisual, startDrag/endDrag, prepareSteps, applyStep, play/stopPlay, detectNegativeCycle, clearGraph, resetAlgorithmState, showHelp). Some UI behaviors are transient (e.g., applying a single step or adding a node) and are represented here as brief states (adding_node, edge_created, stepping) to capture the side-effecting onEnter actions and the subsequent return to the idle/ready states. Keyboard shortcuts (space to toggle play, 'r' to reset) are modeled via PLAY_TOGGLE and RESET_ALGORITHM events. Visual-feedback transitions include highlighting edges (current/success/failed/neg) and flashing nodes as part of applyStep and detectNegativeCycle actions."
}