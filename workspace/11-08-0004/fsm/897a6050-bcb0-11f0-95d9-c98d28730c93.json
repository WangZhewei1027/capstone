{
  "topic": "Linear Search Interactive Module",
  "description": "Models the interactive states and transitions of a step-by-step linear search visualization (controls: Step, Play/Pause, Reset, Shuffle, Pick target, edit cells, change size/speed, apply custom array).",
  "states": [
    {
      "name": "idle",
      "onEnter": "initializeArray(resetState=true) / renderArray / updateStatus",
      "onExit": "none",
      "on": {
        "TARGET_SET": "ready",
        "CLICK_STEP": "idle",
        "CLICK_PLAY": "idle",
        "RESET_CLICK": "idle",
        "SHUFFLE_CLICK": "idle",
        "APPLY_ARRAY": "idle",
        "SIZE_CHANGE": "idle",
        "SPEED_CHANGE": "idle",
        "PICK_TOGGLE": "pick_mode",
        "DOUBLE_CLICK_CELL": "editing"
      }
    },
    {
      "name": "ready",
      "onEnter": "update UI to reflect target set (targetInput shown) / updatePseudocode(-1)",
      "onExit": "none",
      "on": {
        "CLICK_STEP": "comparing",
        "CLICK_PLAY": "playing",
        "PICK_TOGGLE": "pick_mode",
        "CELL_CLICK": "ready",
        "DOUBLE_CLICK_CELL": "editing",
        "RESET_CLICK": "idle",
        "SHUFFLE_CLICK": "idle",
        "APPLY_ARRAY": "idle",
        "SIZE_CHANGE": "idle"
      }
    },
    {
      "name": "playing",
      "onEnter": "togglePlay(true) -> set playing=true / update Play button label to 'Pause' / schedule timer to call stepOnce after short delay",
      "onExit": "clear scheduled timer (if any) / togglePlay(false) effects (update Play button label)",
      "on": {
        "TIMER_TRIGGER": "comparing",
        "CLICK_PLAY": "paused",
        "CLICK_STEP": "comparing",
        "TARGET_SET": "playing",
        "PICK_TOGGLE": "pick_mode",
        "RESET_CLICK": "idle",
        "SHUFFLE_CLICK": "idle",
        "APPLY_ARRAY": "idle",
        "DOUBLE_CLICK_CELL": "editing"
      }
    },
    {
      "name": "paused",
      "onEnter": "set playing=false / update Play button label to 'Play' / clear timer",
      "onExit": "none",
      "on": {
        "CLICK_STEP": "comparing",
        "CLICK_PLAY": "playing",
        "TARGET_SET": "paused",
        "PICK_TOGGLE": "pick_mode",
        "RESET_CLICK": "idle",
        "SHUFFLE_CLICK": "idle",
        "APPLY_ARRAY": "idle",
        "DOUBLE_CLICK_CELL": "editing"
      }
    },
    {
      "name": "comparing",
      "onEnter": "stepOnce pre-evaluation: increment comparisons / updateStatus / clearCellStates / add 'comparing' class to current cell / updatePointerPosition(currentIndex) / updatePseudocode(2) / announce('Comparing index ...') / schedule evaluation timeout (short delay)",
      "onExit": "clear 'comparing' visuals (clearCellStates)",
      "on": {
        "COMPARISON_EQUAL": "found",
        "COMPARISON_NOT_EQUAL": "post_compare"
      }
    },
    {
      "name": "post_compare",
      "onEnter": "Handle result of a non-equal comparison: mark cell as 'checked' / updatePseudocode(4 and 5) / increment currentIndex and updateStatus / if currentIndex >= length -> transition to notFound (this is a guard handled externally)",
      "onExit": "none",
      "on": {
        "IF_PLAYING_CONTINUE": "playing",
        "IF_NOT_PLAYING_STAY": "paused",
        "IF_EXHAUSTED": "notFound",
        "PICK_TOGGLE": "pick_mode",
        "RESET_CLICK": "idle",
        "SHUFFLE_CLICK": "idle"
      }
    },
    {
      "name": "found",
      "onEnter": "clear any timers / set playing=false / mark found cell with 'found' class / updatePseudocode(3) / resultText = 'Found' / announce(found message)",
      "onExit": "clear found visuals",
      "on": {
        "RESET_CLICK": "idle",
        "SHUFFLE_CLICK": "idle",
        "APPLY_ARRAY": "idle",
        "PICK_TOGGLE": "pick_mode",
        "DOUBLE_CLICK_CELL": "editing"
      }
    },
    {
      "name": "notFound",
      "onEnter": "clear timers / set playing=false / updatePseudocode(7) / resultText = 'Not found' / announce(not found message)",
      "onExit": "none",
      "on": {
        "RESET_CLICK": "idle",
        "SHUFFLE_CLICK": "idle",
        "APPLY_ARRAY": "idle",
        "PICK_TOGGLE": "pick_mode",
        "DOUBLE_CLICK_CELL": "editing"
      }
    },
    {
      "name": "pick_mode",
      "onEnter": "set pickMode=true / highlight Pick button as active / announce('Pick mode active')",
      "onExit": "set pickMode=false / remove Pick button active state",
      "on": {
        "PICK_CELL_FROM_PLAYING": "playing",
        "PICK_CELL_FROM_IDLE": "ready",
        "PICK_CELL_FROM_PAUSED": "paused",
        "PICK_TOGGLE": "idle",
        "RESET_CLICK": "idle",
        "SHUFFLE_CLICK": "idle"
      }
    },
    {
      "name": "editing",
      "onEnter": "prompt user to edit value (synchronous prompt) / if valid integer update arr[index] and re-render cell / announce('Value updated')",
      "onExit": "none",
      "on": {
        "EDIT_DONE": "idle",
        "EDIT_DONE_WITH_TARGET": "ready",
        "CANCEL_EDIT": "idle"
      }
    }
  ],
  "events": [
    "CLICK_STEP",
    "CLICK_PLAY",
    "CLICK_PAUSE",
    "TIMER_TRIGGER",
    "COMPARISON_EQUAL",
    "COMPARISON_NOT_EQUAL",
    "RESET_CLICK",
    "SHUFFLE_CLICK",
    "SIZE_CHANGE",
    "SIZE_COMMIT",
    "SPEED_CHANGE",
    "TARGET_SET",
    "PICK_TOGGLE",
    "PICK_CELL_FROM_PLAYING",
    "PICK_CELL_FROM_IDLE",
    "PICK_CELL_FROM_PAUSED",
    "CELL_CLICK",
    "APPLY_ARRAY",
    "DOUBLE_CLICK_CELL",
    "EDIT_DONE",
    "EDIT_DONE_WITH_TARGET",
    "CANCEL_EDIT",
    "KEY_SPACE",
    "KEY_ENTER",
    "WINDOW_RESIZE",
    "IF_PLAYING_CONTINUE",
    "IF_NOT_PLAYING_STAY",
    "IF_EXHAUSTED"
  ],
  "notes": "Guards and conditional behavior (explained):\n- Many transitions depend on runtime guards (target present, currentIndex value, playing flag). Those guards are represented here as conditional events (IF_PLAYING_CONTINUE, IF_NOT_PLAYING_STAY, IF_EXHAUSTED and separate PICK_CELL_* events). Implementers should evaluate: if a comparison finishes and arr[currentIndex] === target -> dispatch COMPARISON_EQUAL; else dispatch COMPARISON_NOT_EQUAL. After COMPARISON_NOT_EQUAL, the module increments currentIndex; if currentIndex >= arr.length then dispatch IF_EXHAUSTED -> notFound; else if playing is true dispatch IF_PLAYING_CONTINUE -> playing (automatically schedule next compare), otherwise dispatch IF_NOT_PLAYING_STAY -> paused (user must step next).\n- noTarget handling: Step or Play when no numeric target is set results in an announcement and no state change (modeled as CLICK_STEP/CLICK_PLAY staying in idle with an announcement). In this model, TARGET_SET moves the machine into ready/active flows.\n- pick_mode is modeled as an overlay state that can be entered from any primary state; after selecting a cell the app returns to a primary state based on context (playing vs started vs not started). Those return targets are represented with PICK_CELL_FROM_* events.\n- comparing state models the animation and short timeout used to show 'comparing' styling; onEnter performs increment comparisons, pointer movement, pseudocode highlight, and schedules evaluation. On completion the comparing state's scheduled callback dispatches either COMPARISON_EQUAL or COMPARISON_NOT_EQUAL.\n- playing state onEnter starts a short scheduling delay then triggers the first step; onExit clears timers. The Step button while playing pauses (toggle) and performs a single step in the code; this is modeled by the CLICK_STEP transition into comparing while also clearing playing (onExit actions).\n- editing is synchronous via prompt(); after editing, the machine returns to an appropriate state (idle/ready) depending on whether the edit affected the target or search progress.\n- apply array, shuffle and reset: Reset (RESET_CLICK) explicitly reinitializes array and resets search state (currentIndex=-1, comparisons=0, playing=false). Shuffle reorders array; the implementation calls initializeArray with resetState=false so existing search progress may be preserved; for this FSM we conservatively model these events as returning to idle or preserving state depending on context â€” implementers should apply the exact reset semantics in code.\n- Accessibility announcements occur as side-effects on many transitions (announce(...) used liberally). These are captured as onEnter actions in relevant states (e.g., comparing, found, notFound, pick_mode, idle announcements)."
}