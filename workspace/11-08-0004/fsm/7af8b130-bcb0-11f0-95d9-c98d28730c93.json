{
  "topic": "Interactive Linked List Module",
  "description": "Models the user-visible interactive states of a small linked-list visualization: selection, insertion, deletion, traversal animation, reset, and demo seeding, including validation and animation lifecycle.",
  "states": [
    {
      "name": "idle",
      "onEnter": "renderList; refreshInfo; setStatus('Ready')",
      "onExit": "none",
      "on": {
        "NODE_CLICK": "nodeSelected",
        "CLICK_INSERT_HEAD": "inserting_head",
        "CLICK_INSERT_TAIL": "inserting_tail",
        "CLICK_INSERT_AFTER": "inserting_after",
        "CLICK_DELETE": "deleting",
        "CLICK_TRAVERSE": "traversing",
        "CLICK_RESET": "resetting",
        "KEY_ENTER_INPUT": "inserting_head",
        "INIT_DEMO": "seeding"
      }
    },
    {
      "name": "nodeSelected",
      "onEnter": "set selectedId; add .selected class to node el; announce('Selected node X')",
      "onExit": "clear selectedId visual (.selected removed)",
      "on": {
        "NODE_CLICK": "idle",
        "CLICK_INSERT_HEAD": "inserting_head",
        "CLICK_INSERT_TAIL": "inserting_tail",
        "CLICK_INSERT_AFTER": "inserting_after",
        "CLICK_DELETE": "deleting",
        "CLICK_TRAVERSE": "traversing",
        "CLICK_RESET": "resetting",
        "KEY_ENTER_INPUT": "inserting_head"
      }
    },
    {
      "name": "inserting_head",
      "onEnter": "validate_value; if invalid => emit NO_VALUE_ENTERED; else create node object; createNodeElement; nodes.unshift(node); animateInsert(node, index=0); announce('Inserted <value> at head'); clearSelection(); scrollIntoView(node.el)",
      "onExit": "refreshArrows; refreshInfo",
      "on": {
        "ANIMATION_DONE": "idle",
        "NO_VALUE_ENTERED": "idle"
      }
    },
    {
      "name": "inserting_tail",
      "onEnter": "validate_value; if invalid => emit NO_VALUE_ENTERED; else create node object; createNodeElement; nodes.push(node); animateInsert(node, position=nodes.length-1); announce('Inserted <value> at tail'); clearSelection(); scrollIntoView(node.el)",
      "onExit": "refreshArrows; refreshInfo",
      "on": {
        "ANIMATION_DONE": "idle",
        "NO_VALUE_ENTERED": "idle"
      }
    },
    {
      "name": "inserting_after",
      "onEnter": "validate_value; if invalid => emit NO_VALUE_ENTERED; else validate_selected; if no selection => emit NO_SELECTION; else create node object; createNodeElement; splice node after selected index; animateInsert(node, idx+1); announce('Inserted <value> after node <selected>'); clearSelection(); scrollIntoView(node.el)",
      "onExit": "refreshArrows; refreshInfo",
      "on": {
        "ANIMATION_DONE": "idle",
        "NO_VALUE_ENTERED": "idle",
        "NO_SELECTION": "idle"
      }
    },
    {
      "name": "deleting",
      "onEnter": "validate_selected; if no selection => emit NO_SELECTION; else remove node from nodes array; animateDelete(node); announce('Deleted node <value>'); selectedId = null",
      "onExit": "refreshArrows; refreshInfo; clearSelection",
      "on": {
        "ANIMATION_DONE": "idle",
        "NO_SELECTION": "idle"
      }
    },
    {
      "name": "traversing",
      "onEnter": "if nodes.length === 0 => emit LIST_EMPTY; else set traversing=true; announce('Starting traversal'); pointer.show; disable selection; set traverseStep to 0; start async traversal loop: for each node => highlight node; positionPointerAt(node); announce('Visiting node <value>'); pulse node; advance step; after visiting all => emit TRAVERSE_COMPLETE",
      "onExit": "pointer.hide; enable selection; set traversing=false; traverseStep='Traversal: complete'; announce('Traversal complete')",
      "on": {
        "TRAVERSE_COMPLETE": "idle",
        "LIST_EMPTY": "idle",
        "NODE_CLICK": "traversing"
      }
    },
    {
      "name": "resetting",
      "onEnter": "if nodes.length === 0 => announce('List already empty') and emit RESET_DONE; else animate all nodes removal; after animation timeout clear nodes; reset idCounter; clear listArea and arrowSvg defs; refreshInfo; announce('List reset')",
      "onExit": "refreshArrows; refreshInfo",
      "on": {
        "RESET_DONE": "idle",
        "ANIMATION_DONE": "idle"
      }
    },
    {
      "name": "seeding",
      "onEnter": "seedDemo sequence: insertTail('A') then insertTail('B') then insertTail('C') with small delays; announce('Demo list created: A -> B -> C')",
      "onExit": "refreshArrows; refreshInfo",
      "on": {
        "ANIMATION_DONE": "idle",
        "SEED_COMPLETE": "idle"
      }
    }
  ],
  "events": [
    "NODE_CLICK",
    "CLICK_INSERT_HEAD",
    "CLICK_INSERT_TAIL",
    "CLICK_INSERT_AFTER",
    "CLICK_DELETE",
    "CLICK_TRAVERSE",
    "CLICK_RESET",
    "KEY_ENTER_INPUT",
    "ANIMATION_DONE",
    "TRAVERSE_COMPLETE",
    "NO_VALUE_ENTERED",
    "NO_SELECTION",
    "LIST_EMPTY",
    "RESET_DONE",
    "INIT_DEMO",
    "SEED_COMPLETE"
  ],
  "notes": "High-level FSM: selection is modeled as a separate state (nodeSelected). Insert/Delete/Reset/Traverse are transient states that perform validation, trigger DOM animations, announce status, and return to idle when their animations/async work complete. During traversing the UI disables selection (clicks are ignored). Validation failures (no value, no selected node, empty list for traversal) cause announcements and return to idle without mutation. The code issues timeouts/promises for animations; those map to ANIMATION_DONE / TRAVERSE_COMPLETE / RESET_DONE events that return the machine to idle. The seedDemo process runs at init and behaves like a sequence of inserting_tail operations that finishes back to idle."
}