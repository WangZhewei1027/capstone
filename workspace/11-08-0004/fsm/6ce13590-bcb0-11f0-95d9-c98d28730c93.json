{
  "topic": "Arrays â€” Ordered Indexed Collections Interactive Module",
  "description": "Finite state machine modeling the interactive array visualization: user-driven array mutations (push/pop/shift/unshift/insert/remove), element access highlights, drag-to-reorder, animations, preset loading, and brief walkthrough.",
  "states": [
    {
      "name": "idle",
      "onEnter": "updateView",
      "on": {
        "PUSH": "inserting",
        "PUSH_INVALID": "invalidInput",
        "POP": "removing",
        "POP_EMPTY": "idle",
        "UNSHIFT": "inserting",
        "UNSHIFT_INVALID": "invalidInput",
        "SHIFT": "removing",
        "SHIFT_EMPTY": "idle",
        "INSERT": "inserting",
        "INSERT_INVALID": "invalidInput",
        "REMOVE": "removing",
        "REMOVE_INVALID": "idle",
        "ACCESS": "accessing",
        "ACCESS_INVALID": "idle",
        "CLEAR": "mutatingInstant",
        "LOAD_PRESET": "loadingPreset",
        "SHOW_WALKTHROUGH": "showingWalkthrough",
        "START_DRAG": "dragging",
        "KEYBOARD_SHORTCUT_PUSH": "inserting",
        "KEYBOARD_SHORTCUT_POP": "removing",
        "ENTER_CELL": "accessing"
      }
    },
    {
      "name": "inserting",
      "onEnter": "doInsertOperation (push/unshift/insert) -> pushHistory -> updateView",
      "onExit": null,
      "on": {
        "ANIMATION_INSERT_START": "animatingInsert",
        "ANIMATION_INSERT_DONE": "idle",
        "NO_ANIMATION": "idle"
      }
    },
    {
      "name": "removing",
      "onEnter": "doRemoveOperation (pop/shift/remove) -> pushHistory -> updateView",
      "onExit": null,
      "on": {
        "ANIMATION_REMOVE_START": "animatingRemove",
        "ANIMATION_REMOVE_DONE": "idle",
        "NO_ANIMATION": "idle"
      }
    },
    {
      "name": "mutatingInstant",
      "onEnter": "clearArray -> pushHistory -> updateView",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "loadingPreset",
      "onEnter": "loadPreset -> pushHistory -> updateView",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "showingWalkthrough",
      "onEnter": "showWalkthroughAlert",
      "on": {
        "WALKTHROUGH_CLOSED": "idle"
      }
    },
    {
      "name": "dragging",
      "onEnter": "beginDrag (set dragging class, create placeholder, capture pointer)",
      "onExit": "endDrag (remove dragging class, remove placeholder, release pointer)",
      "on": {
        "MOVE_DRAG": "dragging",
        "DROP": "dropHandling"
      }
    },
    {
      "name": "dropHandling",
      "onEnter": "computeOldAndNewIndex; if moved -> reorderArr -> pushHistory -> updateView -> animatePulseAt(newIndex); else -> updateView",
      "on": {
        "REORDERED": "animatingPulse",
        "NO_CHANGE": "idle"
      }
    },
    {
      "name": "accessing",
      "onEnter": "doAccess -> pushHistory -> animatePulseAt(index)",
      "on": {
        "ANIMATION_PULSE_DONE": "idle",
        "NO_ANIMATION": "idle"
      }
    },
    {
      "name": "animatingInsert",
      "onEnter": "animateInsertAt(pos) (visual pop) -> schedule ANIMATION_INSERT_DONE",
      "on": {
        "ANIMATION_INSERT_DONE": "idle"
      }
    },
    {
      "name": "animatingRemove",
      "onEnter": "animateRemove(removedElement) (fade/slide) -> schedule ANIMATION_REMOVE_DONE",
      "on": {
        "ANIMATION_REMOVE_DONE": "idle"
      }
    },
    {
      "name": "animatingPulse",
      "onEnter": "animatePulseAt(pos) (accessed highlight) -> schedule ANIMATION_PULSE_DONE",
      "on": {
        "ANIMATION_PULSE_DONE": "idle"
      }
    },
    {
      "name": "invalidInput",
      "onEnter": "flashInput (visual feedback) -> pushHistory('invalid input' or 'invalid index')",
      "on": {
        "FLASH_DONE": "idle"
      }
    }
  ],
  "events": [
    "PUSH",
    "PUSH_INVALID",
    "POP",
    "POP_EMPTY",
    "UNSHIFT",
    "UNSHIFT_INVALID",
    "SHIFT",
    "SHIFT_EMPTY",
    "INSERT",
    "INSERT_INVALID",
    "REMOVE",
    "REMOVE_INVALID",
    "ACCESS",
    "ACCESS_INVALID",
    "CLEAR",
    "LOAD_PRESET",
    "SHOW_WALKTHROUGH",
    "START_DRAG",
    "MOVE_DRAG",
    "DROP",
    "REORDERED",
    "NO_CHANGE",
    "ANIMATION_INSERT_START",
    "ANIMATION_INSERT_DONE",
    "ANIMATION_REMOVE_START",
    "ANIMATION_REMOVE_DONE",
    "ANIMATION_PULSE_DONE",
    "NO_ANIMATION",
    "FLASH_DONE",
    "WALKTHROUGH_CLOSED",
    "KEYBOARD_SHORTCUT_PUSH",
    "KEYBOARD_SHORTCUT_POP",
    "ENTER_CELL"
  ],
  "notes": "Implementation notes and mapping to code:\n- updateView: renders DOM to match the array, updates length and code view, creates/removes .cell elements.\n- doInsertOperation covers doPush, doUnshift, and doInsert: they mutate arr, pushHistory, call updateView and schedule animateInsertAt.\n- doRemoveOperation covers doPop, doShift, and doRemove: they mutate arr, pushHistory, call updateView and removed DOM nodes are animated via animateRemove.\n- Accessing highlights a cell via animatePulseAt; Enter on a focused .cell triggers ACCESS event (Enter -> doAccess).\n- Dragging flow: pointerdown -> START_DRAG (dragging state creates placeholder and fixed positioning), pointermove -> MOVE_DRAG (repositions placeholder), pointerup -> DROP (dropHandling state computes indices). If indices changed it reorders arr and triggers animatingPulse; otherwise simply calls updateView.\n- Animations are time-based (setTimeout) and implicitly cause transitions to ANIMATION_*_DONE after durations used in code (insert ~260ms, remove ~220ms, pulse ~700ms).\n- invalidInput is used when value is missing or index out of range; flashInput provides temporary visual feedback and then returns to idle.\n- Walkthrough uses alert() (synchronous); modeled as showingWalkthrough state with WALKTHROUGH_CLOSED event on dismiss.\n- Keyboard shortcuts (Ctrl+P, Ctrl+O) map to KEYBOARD_SHORTCUT_PUSH and KEYBOARD_SHORTCUT_POP which trigger the corresponding operations.\n- History updates (pushHistory) occur on all mutating operations and certain invalid attempts; history is capped at 80 entries.\n- There is no terminal 'done' state: primary steady state is idle; all interactions are transient and return to idle after work/animations complete."
}