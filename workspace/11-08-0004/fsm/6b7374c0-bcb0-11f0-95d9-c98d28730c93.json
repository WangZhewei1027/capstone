{
  "topic": "Radix Sort Interactive Module",
  "description": "Models the UI and algorithmic interaction states for an LSD Radix Sort visualizer (loading input, step/play execution of atomic moves: placing into buckets and collecting back) including animation and completion behavior.",
  "states": [
    {
      "name": "idle",
      "onEnter": "resetAll",
      "on": {
        "CLICK_GENERATE": "idle",
        "CLICK_LOAD": "ready",
        "CLICK_RESET": "idle",
        "INPUT_CHANGE": "idle"
      }
    },
    {
      "name": "ready",
      "onEnter": "loadFromInput_or_prepareQueue (creates cards, createBuckets, renderCards, buildEntireMoveQueue if applicable; sets phase='placing')",
      "onExit": "updateStatus",
      "on": {
        "CLICK_STEP": "animating",
        "CLICK_PLAY": "playing",
        "CLICK_RESET": "idle",
        "CLICK_LOAD": "ready",
        "SPEED_CHANGE": "ready",
        "KEY_SPACE": "animating",
        "KEY_ENTER": "playing"
      }
    },
    {
      "name": "playing",
      "onEnter": "autoPlay (start consuming moveQueue sequentially; btnPlay UI updated)",
      "onExit": "pauseAuto (set auto=false; update play button UI)",
      "on": {
        "CLICK_PAUSE": "ready",
        "CLICK_RESET": "idle",
        "MOVE_COMPLETE": "playing",
        "MOVE_QUEUE_EMPTY": "done",
        "CLICK_LOAD": "ready",
        "SPEED_CHANGE": "playing"
      }
    },
    {
      "name": "animating",
      "onEnter": "executeMoveFromQueue (stepOnce / move() invoked; runs one Promise-returning atomic animation function such as moveCardToBucket or collectBuckets)",
      "onExit": "updateStatus",
      "on": {
        "MOVE_COMPLETE": "playing_or_ready",
        "MOVE_QUEUE_EMPTY": "done",
        "CLICK_RESET": "idle"
      }
    },
    {
      "name": "done",
      "onEnter": "markDone (phase='done'; updateStatus; pulse/visual hint)",
      "on": {
        "CLICK_RESET": "idle",
        "CLICK_LOAD": "ready",
        "CLICK_PLAY": "playing",
        "CLICK_GENERATE": "done",
        "SPEED_CHANGE": "done"
      }
    }
  ],
  "events": [
    "CLICK_GENERATE",
    "CLICK_LOAD",
    "CLICK_RESET",
    "CLICK_PLAY",
    "CLICK_PAUSE",
    "CLICK_STEP",
    "KEY_SPACE",
    "KEY_ENTER",
    "SPEED_CHANGE",
    "MOVE_COMPLETE",
    "MOVE_QUEUE_EMPTY"
  ],
  "notes": "This FSM abstracts the JS control flow. Key implementation actions referenced above map to functions in the script: resetAll (clears state and DOM), generateRandom (fills input field), loadFromInput (parse input, create cards, set pass and maxDigits, createBuckets, renderCards, buildEntireMoveQueue and set phase 'placing'), buildEntireMoveQueue/buildMovesForPass (enqueue atomic move functions into moveQueue), stepOnce/executeMoveFromQueue (pop one move and execute Promise-returning animation), autoPlay (loop consuming moveQueue while auto=true), moveCardToBucket (animate placing), collectBuckets (animate collection back to input), and markDone (set phase='done' and update UI). The 'animating' state is transient while an atomic animation Promise is pending. Transitions from 'animating' on MOVE_COMPLETE branch back to 'playing' if auto is active or to 'ready' if paused; when moveQueue is empty a MOVE_QUEUE_EMPTY event transitions to 'done'. The model intentionally keeps 'placing' and 'collecting' as conceptual sub-operations expressed by the contents of the moveQueue rather than separate top-level orthogonal states."
}