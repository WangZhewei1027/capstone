{
  "topic": "0/1 Knapsack Interactive Module",
  "description": "Models the interactive states and transitions of the knapsack UI: adding/removing items, drag/drop interactions, greedy and DP solver animations, capacity changes and UI feedback.",
  "states": [
    {
      "name": "idle",
      "onEnter": "updateAll / renderItems / renderKnapsackItems (implicit steady state)",
      "on": {
        "CLICK_ADD_ITEM": "adding_item",
        "CLICK_RANDOM_EX": "loading_random_example",
        "CLICK_TOGGLE_ITEM": "toggling_item",
        "CLICK_DELETE_ITEM": "deleting_item",
        "DRAG_START": "dragging",
        "CLICK_SOLVE_GREEDY": "greedy_solving",
        "CLICK_SOLVE_DP": "dp_solving",
        "CLICK_RESET": "resetting",
        "CLICK_CLEAR_KNAP": "clearing_knapsack",
        "CAPACITY_INPUT_CHANGE": "idle",
        "KEY_DELETE_ON_DROPZONE": "clearing_knapsack"
      }
    },
    {
      "name": "adding_item",
      "onEnter": "validateAndCreateItem / renderItems / log('Added item')",
      "on": {
        "ADD_ITEM_DONE": "idle",
        "ADD_ITEM_ERROR": "idle"
      }
    },
    {
      "name": "loading_random_example",
      "onEnter": "seedRandomExample / renderItems / renderKnapsackItems / updateAll / log('Random example loaded')",
      "on": {
        "RANDOM_LOADED": "idle"
      }
    },
    {
      "name": "toggling_item",
      "onEnter": "checkIfInKnapsack; if removing -> removeFromKnapsack; if adding -> capacityCheck",
      "on": {
        "TOGGLE_REMOVED": "idle",
        "TOGGLE_ADD_ALLOWED": "adding_to_knapsack",
        "TOGGLE_ADD_DENIED": "overcap_flash"
      }
    },
    {
      "name": "adding_to_knapsack",
      "onEnter": "inKnapsack.add(id) / renderItems / renderKnapsackItems / updateAll / animateAddToKnapsack (start)",
      "on": {
        "ADD_ANIMATION_END": "idle"
      },
      "onExit": "ensure updateAll"
    },
    {
      "name": "removing_from_knapsack",
      "onEnter": "inKnapsack.delete(id) / renderItems / renderKnapsackItems / updateAll / log('Removed item from knapsack')",
      "on": {
        "REMOVE_DONE": "idle"
      }
    },
    {
      "name": "dragging",
      "onEnter": "drag context established (dragstart sets dataTransfer)",
      "on": {
        "DRAG_OVER": "dragover",
        "DROP": "drop_attempt",
        "DRAG_END": "idle",
        "DRAG_LEAVE": "dragging"
      }
    },
    {
      "name": "dragover",
      "onEnter": "dropzone.classList.add('dragover')",
      "onExit": "dropzone.classList.remove('dragover')",
      "on": {
        "DRAG_LEAVE": "dragging",
        "DROP": "drop_attempt",
        "DRAG_END": "idle"
      }
    },
    {
      "name": "drop_attempt",
      "onEnter": "attemptAddFromDrop (read id from dataTransfer); if fits -> inKnapsack.add + render + animateAddToKnapsack; if not -> log reject + flashOvercap",
      "on": {
        "DROP_ADD_STARTED": "animating_add",
        "DROP_ADD_REJECTED": "overcap_flash"
      }
    },
    {
      "name": "animating_add",
      "onEnter": "animateAddToKnapsack (token animation ~700ms) / log('Added or dropped into knapsack')",
      "on": {
        "ADD_ANIMATION_END": "idle"
      },
      "onExit": "renderKnapsackItems / updateAll"
    },
    {
      "name": "overcap_flash",
      "onEnter": "flashOvercap() / log('Over capacity attempt')",
      "on": {
        "FLASH_DONE": "idle"
      }
    },
    {
      "name": "greedy_solving",
      "onEnter": "startGreedy: clear inKnapsack / render / updateAll / log('Greedy solver started') / begin animated picks",
      "on": {
        "GREEDY_PICK_STEP": "greedy_solving",
        "GREEDY_SKIP_STEP": "greedy_solving",
        "GREEDY_FINISHED": "idle",
        "USER_INTERRUPT": "idle"
      },
      "onExit": "applyGreedyResult (inKnapsack = selection) / renderKnapsackItems / updateAll / log('Greedy finished')"
    },
    {
      "name": "dp_solving",
      "onEnter": "startDP: capacity check (if >60 -> DP_TOO_LARGE), log('DP solver started') / build DP table and animate computation row/cell",
      "on": {
        "DP_TOO_LARGE": "idle",
        "DP_PROCESS_ROW": "dp_solving",
        "DP_PROCESS_CELL": "dp_solving",
        "DP_BUILD_COMPLETE": "dp_backtracking",
        "USER_INTERRUPT": "idle"
      }
    },
    {
      "name": "dp_backtracking",
      "onEnter": "backtrack DP table to determine chosen items / markChosen (highlight cells and pulse items) / set inKnapsack to chosen / render / updateAll / log('DP finished')",
      "on": {
        "DP_FINISHED": "idle"
      },
      "onExit": "ensure dp table marked and items updated"
    },
    {
      "name": "resetting",
      "onEnter": "confirm reset -> if confirmed seedExample / inKnapsack.clear / render / dpContainer.clear / logEl.clear",
      "on": {
        "RESET_CONFIRMED": "idle",
        "RESET_CANCELLED": "idle"
      }
    },
    {
      "name": "clearing_knapsack",
      "onEnter": "clearKnapsack() / renderKnapsackItems / updateAll / log('Cleared knapsack')",
      "on": {
        "CLEAR_DONE": "idle"
      }
    },
    {
      "name": "deleting_item",
      "onEnter": "confirm delete -> removeItem(id) / render / updateAll / log('Removed item')",
      "on": {
        "DELETE_CONFIRMED": "idle",
        "DELETE_CANCELLED": "idle"
      }
    }
  ],
  "events": [
    "CLICK_ADD_ITEM",
    "ADD_ITEM_DONE",
    "ADD_ITEM_ERROR",
    "CLICK_RANDOM_EX",
    "RANDOM_LOADED",
    "CLICK_TOGGLE_ITEM",
    "TOGGLE_REMOVED",
    "TOGGLE_ADD_ALLOWED",
    "TOGGLE_ADD_DENIED",
    "CLICK_DELETE_ITEM",
    "DELETE_CONFIRMED",
    "DELETE_CANCELLED",
    "DRAG_START",
    "DRAG_OVER",
    "DRAG_LEAVE",
    "DROP",
    "DROP_ADD_STARTED",
    "DROP_ADD_REJECTED",
    "DRAG_END",
    "ADD_ANIMATION_END",
    "FLASH_DONE",
    "CLICK_SOLVE_GREEDY",
    "GREEDY_PICK_STEP",
    "GREEDY_SKIP_STEP",
    "GREEDY_FINISHED",
    "CLICK_SOLVE_DP",
    "DP_TOO_LARGE",
    "DP_PROCESS_ROW",
    "DP_PROCESS_CELL",
    "DP_BUILD_COMPLETE",
    "DP_FINISHED",
    "CLICK_RESET",
    "RESET_CONFIRMED",
    "RESET_CANCELLED",
    "CLICK_CLEAR_KNAP",
    "CLEAR_DONE",
    "KEY_DELETE_ON_DROPZONE",
    "CAPACITY_INPUT_CHANGE",
    "USER_INTERRUPT"
  ],
  "notes": "This FSM abstracts the application's primary interactive flows. Many actions are implemented as asynchronous animations or timeouts in the code (e.g., animateAddToKnapsack, greedy step timeouts, DP cell processing). Those are modeled as transient states (animating_add, greedy_solving, dp_solving) with explicit completion events (ADD_ANIMATION_END, GREEDY_FINISHED, DP_FINISHED / DP_BUILD_COMPLETE). Capacity >60 blocks DP rendering (DP_TOO_LARGE). Visual feedback actions include flashOvercap, highlightItemCard and markChosen; rendering/updating is represented by renderItems / renderKnapsackItems / updateAll invoked on state transitions and onExit where appropriate."
}