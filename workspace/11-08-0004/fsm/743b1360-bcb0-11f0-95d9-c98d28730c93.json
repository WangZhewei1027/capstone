{
  "topic": "Hash Map Visualizer (Separate Chaining)",
  "description": "FSM modeling the interactive behaviors of the Hash Map visualizer UI: inserting, searching, deleting keys, animating tokens and nodes, table size changes, copy hash calculation, and basic UI feedback.",
  "states": [
    {
      "name": "idle",
      "onEnter": "updateStats; setReadyMessage",
      "onExit": "",
      "on": {
        "CLICK_INSERT": "insert_animating",
        "CLICK_SEARCH": "searching",
        "CLICK_DELETE": "searching_for_delete",
        "CLICK_RESET": "awaiting_confirm_reset",
        "SIZE_RANGE_INPUT": "idle",
        "SIZE_RANGE_CHANGE": "awaiting_confirm_size_change",
        "CLICK_COPY": "copying_hash",
        "FORM_ENTER": "insert_animating",
        "KEY_INPUT": "idle",
        "TABLE_FOCUS": "idle"
      }
    },
    {
      "name": "insert_animating",
      "onEnter": "showHashCalc; computeHashDetail; animateToken(from=InsertButton,to=bucket)",
      "onExit": "",
      "on": {
        "ANIMATION_END": "inserting",
        "ANIMATION_TIMEOUT": "inserting"
      }
    },
    {
      "name": "inserting",
      "onEnter": "checkDuplicateOrCollision; updateModel_appendNode; appendNode_DOM_with_fadeIn; collisions++ if applicable; totalItems++; updateStats; setMessage",
      "onExit": "",
      "on": {
        "DOM_INSERT_ANIMATION_END": "idle",
        "INSERT_COMPLETE": "idle"
      }
    },
    {
      "name": "searching",
      "onEnter": "showHashCalc; computeHashDetail; bucket.hilite = true; sequentially_highlight_nodes (add highlight class per node) ; increment comparisons; update lastComparisons",
      "onExit": "bucket.hilite = false; clear_highlights; reset lastComparisons after delay",
      "on": {
        "SEARCH_STEP": "searching",
        "SEARCH_FOUND": "found_view",
        "SEARCH_NOT_FOUND": "idle",
        "SEARCH_COMPLETE": "idle"
      }
    },
    {
      "name": "searching_for_delete",
      "onEnter": "showHashCalc; computeHashDetail; bucket.hilite = true; sequentially_highlight_nodes; increment comparisons; update lastComparisons",
      "onExit": "bucket.hilite = false; clear_highlights; reset lastComparisons after delay",
      "on": {
        "SEARCH_STEP": "searching_for_delete",
        "SEARCH_FOUND": "removing_node",
        "SEARCH_NOT_FOUND": "idle",
        "SEARCH_COMPLETE": "idle"
      }
    },
    {
      "name": "found_view",
      "onEnter": "mark_node_found (add 'found' class); setMessage('Found...')",
      "onExit": "remove_found_mark",
      "on": {
        "FOUND_DISPLAY_TIMEOUT": "idle",
        "FOUND_DISMISS": "idle"
      }
    },
    {
      "name": "removing_node",
      "onEnter": "mark_node_found; delay; mark_node_removing (add 'removing' class); updateModel_removeKey; totalItems--; adjust collisions; schedule_DOM_removal; updateStats; setMessage",
      "onExit": "",
      "on": {
        "NODE_REMOVAL_DONE": "idle",
        "REMOVAL_TIMEOUT": "idle"
      }
    },
    {
      "name": "awaiting_confirm_reset",
      "onEnter": "show_browser_confirm('Reset table?')",
      "onExit": "",
      "on": {
        "CONFIRM_RESET": "resetting",
        "CANCEL_RESET": "idle"
      }
    },
    {
      "name": "awaiting_confirm_size_change",
      "onEnter": "show_browser_confirm('Changing table size will reset the table. Continue?')",
      "onExit": "",
      "on": {
        "CONFIRM_SIZE_CHANGE": "resetting_with_new_size",
        "CANCEL_SIZE_CHANGE": "idle"
      }
    },
    {
      "name": "resetting",
      "onEnter": "initTable(current_tableSize); setMessage('New table created. Ready.')",
      "onExit": "",
      "on": {
        "RESET_COMPLETE": "idle",
        "RESET_DONE": "idle"
      }
    },
    {
      "name": "resetting_with_new_size",
      "onEnter": "initTable(new_tableSize_from_range); setMessage('New table created. Ready.')",
      "onExit": "",
      "on": {
        "RESET_COMPLETE": "idle",
        "RESET_DONE": "idle"
      }
    },
    {
      "name": "copying_hash",
      "onEnter": "attempt_clipboard_write(hashCalc.text); setMessage(success_or_error)",
      "onExit": "",
      "on": {
        "COPY_SUCCESS": "idle",
        "COPY_FAILURE": "idle",
        "COPY_DONE": "idle"
      }
    }
  ],
  "events": [
    "CLICK_INSERT",
    "CLICK_SEARCH",
    "CLICK_DELETE",
    "CLICK_RESET",
    "CONFIRM_RESET",
    "CANCEL_RESET",
    "SIZE_RANGE_INPUT",
    "SIZE_RANGE_CHANGE",
    "CONFIRM_SIZE_CHANGE",
    "CANCEL_SIZE_CHANGE",
    "CLICK_COPY",
    "FORM_ENTER",
    "KEY_INPUT",
    "TABLE_FOCUS",
    "ANIMATION_END",
    "ANIMATION_TIMEOUT",
    "DOM_INSERT_ANIMATION_END",
    "INSERT_COMPLETE",
    "SEARCH_STEP",
    "SEARCH_FOUND",
    "SEARCH_NOT_FOUND",
    "SEARCH_COMPLETE",
    "FOUND_DISPLAY_TIMEOUT",
    "FOUND_DISMISS",
    "NODE_REMOVAL_DONE",
    "REMOVAL_TIMEOUT",
    "RESET_COMPLETE",
    "RESET_DONE",
    "COPY_SUCCESS",
    "COPY_FAILURE",
    "COPY_DONE"
  ],
  "notes": "This FSM models the primary UI flows: insert (with floating token animation and DOM append), search (sequential node highlighting with comparison counting), delete (search that transitions to node removal), reset (with browser confirm), size changes (input live preview and change-confirm leading to reset), and copy of the hash calculation. The real implementation uses asynchronous animations (animateToken returns a Promise, timeouts for highlighting and removal) and blocking browser confirm() calls â€” those confirm dialogs are modeled as 'awaiting_confirm_*' states and map to CONFIRM_* or CANCEL_* events. Some low-level timing events (ANIMATION_END, DOM_INSERT_ANIMATION_END, NODE_REMOVAL_DONE) are used to represent Promise/timeout completions. The FSM intentionally treats the 'searching' and 'searching_for_delete' flows separately to reflect that delete continues into removal when a node is found. Accessibility events such as TABLE_FOCUS and live KEY_INPUT update the displayed hash calculation but do not change the main state except generating UI side-effects. Collisions and duplicate detection are recorded as onEnter actions during insertion. Clipboard write is asynchronous and reported back via COPY_SUCCESS or COPY_FAILURE."
}