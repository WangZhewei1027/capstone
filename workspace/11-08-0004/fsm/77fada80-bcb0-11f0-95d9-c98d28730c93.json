{
  "topic": "Sliding Window Interactive Module",
  "description": "Models the interactive states and transitions of a sliding-window visualization: array input, window size and aggregation selection, manual stepping, autoplay, dragging the overlay to snap, and internal recompute/incremental update behaviors.",
  "states": [
    {
      "name": "no_data",
      "onEnter": "renderArray/updateUI (hide overlay)",
      "onExit": "none",
      "on": {
        "APPLY_ARRAY": "computing",
        "CHANGE_WINDOW_SIZE": "computing",
        "CHANGE_AGG": "computing"
      }
    },
    {
      "name": "computing",
      "onEnter": "computeInitial or recomputeWindow (depending on context) -> emits COMPUTE_DONE_*",
      "onExit": "updateUI",
      "on": {
        "COMPUTE_DONE_POSITIONS_GT_ZERO": "ready",
        "COMPUTE_DONE_NO_POSITIONS": "no_data"
      }
    },
    {
      "name": "ready",
      "onEnter": "updateUI (display current window, indices, op counts, labels)",
      "onExit": "none",
      "on": {
        "CLICK_PLAY": "playing",
        "KEY_SPACE": "playing",
        "CLICK_NEXT": "sliding",
        "KEY_RIGHT": "sliding",
        "CLICK_PREV": "sliding",
        "KEY_LEFT": "sliding",
        "CLICK_RESET": "computing",
        "APPLY_ARRAY": "computing",
        "CHANGE_WINDOW_SIZE": "computing",
        "CHANGE_AGG": "computing",
        "POINTER_DOWN": "dragging",
        "SPEED_CHANGE": "ready"
      }
    },
    {
      "name": "playing",
      "onEnter": "startPlay (start timer/interval using current speed)",
      "onExit": "stopPlay (clear timer)",
      "on": {
        "TIMER_TICK": "sliding",
        "CLICK_PLAY": "ready",
        "KEY_SPACE": "ready",
        "CLICK_NEXT": "sliding",
        "CLICK_PREV": "sliding",
        "KEY_RIGHT": "sliding",
        "KEY_LEFT": "sliding",
        "SPEED_CHANGE": "playing"
      }
    },
    {
      "name": "dragging",
      "onEnter": "startDrag (stopPlay, capture pointer, track overlay start position)",
      "onExit": "endDrag (release pointer capture)",
      "on": {
        "POINTER_MOVE": "dragging",
        "POINTER_UP_ADJACENT": "sliding",
        "POINTER_UP_JUMP": "computing",
        "CLICK_RESET": "computing",
        "APPLY_ARRAY": "computing"
      }
    },
    {
      "name": "sliding",
      "onEnter": "slideStep(direction) (determine leaving/entering indices; do incremental update when possible; otherwise recomputeWindow). Note: handlers/starter functions may call stopPlay before entering sliding if needed.",
      "onExit": "updateUI (apply entering/leaving highlights, update result, op counts and narration)",
      "on": {
        "SLIDE_DONE": "ready",
        "SLIDE_DONE_AT_END": "ready"
      }
    }
  ],
  "events": [
    "APPLY_ARRAY",
    "CHANGE_WINDOW_SIZE",
    "CHANGE_AGG",
    "CLICK_PLAY",
    "CLICK_NEXT",
    "CLICK_PREV",
    "CLICK_RESET",
    "KEY_RIGHT",
    "KEY_LEFT",
    "KEY_SPACE",
    "SPEED_CHANGE",
    "TIMER_TICK",
    "POINTER_DOWN",
    "POINTER_MOVE",
    "POINTER_UP_ADJACENT",
    "POINTER_UP_JUMP",
    "COMPUTE_DONE_POSITIONS_GT_ZERO",
    "COMPUTE_DONE_NO_POSITIONS",
    "SLIDE_DONE",
    "SLIDE_DONE_AT_END"
  ],
  "notes": "Mapping of UI actions to FSM transitions: - APPLY_ARRAY/CHANGE_WINDOW_SIZE/CHANGE_AGG trigger the computing state which runs computeInitial (initial window) or recomputeWindow (when snapping with a jump) and then emits a COMPUTE_DONE_* event to transition to ready or no_data. - ready is the idle/paused state; user NEXT/PREV/arrow keys or play will cause sliding transitions. - playing starts a timer (startPlay). Each TIMER_TICK triggers a sliding step; if the end is reached the timer is cleared and the state returns to ready. - dragging begins on pointer down on overlay (dragging stops playback). On pointer up the overlay snaps: if the snap is to an adjacent index the FSM goes to sliding (incremental update); if it's a jump (>1) or incremental context is not available, it goes to computing (recomputeWindow). - sliding encapsulates a single step: onEnter runs slideStep which performs either O(1) incremental updates (for sum/avg usually) or a recompute for max/min when required; onExit updates the UI highlighting and narration and then emits SLIDE_DONE to return to ready. - No_data handles states where there are no valid windows (arr empty or k > arr.length). - Actions referenced in onEnter/onExit correspond to functions in the code: renderArray, computeInitial, recomputeWindow, startPlay, stopPlay, slideStep, updateUI, startDrag, endDrag."
}