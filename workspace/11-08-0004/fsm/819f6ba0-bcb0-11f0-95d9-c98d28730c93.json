{
  "topic": "Bellman-Ford Interactive Module",
  "description": "Finite State Machine modelling the interactive UI and algorithm execution flow for the Bellman-Ford step-by-step module (modes: Add Node / Add Edge / Drag; graph editing; preparing and stepping through algorithm snapshots; auto-play; reset/clear).",
  "states": [
    {
      "name": "mode_drag",
      "onEnter": "setMode('drag')",
      "onExit": "",
      "on": {
        "CLICK_ADD_NODE": "mode_addNode",
        "CLICK_ADD_EDGE": "mode_addEdge",
        "CLICK_DRAG": "mode_drag",
        "NODE_MOUSEDOWN": "dragging",
        "NODE_CLICK": "mode_drag",
        "CANVAS_CLICK": "mode_drag",
        "RESET_GRAPH": "mode_drag",
        "INIT_DEMO": "mode_drag"
      }
    },
    {
      "name": "mode_addNode",
      "onEnter": "setMode('addNode')",
      "onExit": "",
      "on": {
        "CANVAS_CLICK": "mode_addNode",
        "CLICK_ADD_EDGE": "mode_addEdge",
        "CLICK_DRAG": "mode_drag",
        "CLICK_ADD_NODE": "mode_addNode",
        "RESET_GRAPH": "mode_addNode",
        "NODE_CLICK": "mode_addNode"
      }
    },
    {
      "name": "mode_addEdge",
      "onEnter": "setMode('addEdge')",
      "onExit": "clear addEdgeFrom (if any)",
      "on": {
        "NODE_CLICK": "addEdge_pending",
        "CLICK_ADD_NODE": "mode_addNode",
        "CLICK_DRAG": "mode_drag",
        "CANVAS_CLICK": "mode_addEdge",
        "RESET_GRAPH": "mode_addEdge"
      }
    },
    {
      "name": "addEdge_pending",
      "onEnter": "set addEdgeFrom (selected source node) and status('Select target node...')",
      "onExit": "clear addEdgeFrom",
      "on": {
        "NODE_CLICK": "mode_addEdge",
        "ADD_EDGE_CANCEL": "mode_addEdge",
        "CLICK_DRAG": "mode_drag",
        "RESET_GRAPH": "mode_addEdge"
      }
    },
    {
      "name": "dragging",
      "onEnter": "start tracking draggingNode; add mouse/touch move and end listeners",
      "onExit": "stop tracking draggingNode; remove move/end listeners",
      "on": {
        "MOUSE_MOVE": "dragging",
        "TOUCH_MOVE": "dragging",
        "MOUSE_UP": "mode_drag",
        "TOUCH_END": "mode_drag",
        "RESET_GRAPH": "mode_drag"
      }
    },
    {
      "name": "algo_idle",
      "onEnter": "snapshots=[], steps=[], currentSnapshotIndex=0; stopAuto(); refreshDisplaySnapshot()",
      "onExit": "",
      "on": {
        "PREPARE_RUN": "algo_preparing",
        "CLEAR_STEPS": "algo_idle",
        "RESET_GRAPH": "algo_idle"
      }
    },
    {
      "name": "algo_preparing",
      "onEnter": "prepareBellmanFord() (build snapshots and steps, set currentSnapshotIndex=0, enable step buttons if success)",
      "onExit": "",
      "on": {
        "PREPARE_SUCCESS": "algo_viewing",
        "PREPARE_FAIL": "algo_idle",
        "RESET_GRAPH": "algo_idle"
      }
    },
    {
      "name": "algo_viewing",
      "onEnter": "refreshDisplaySnapshot() (render current snapshot, highlight edge/node as needed)",
      "onExit": "",
      "on": {
        "NEXT_STEP": "algo_viewing",
        "PREV_STEP": "algo_viewing",
        "AUTO_TOGGLE": "algo_auto",
        "AUTO_START": "algo_auto",
        "AUTO_STOP": "algo_viewing",
        "CLEAR_STEPS": "algo_idle",
        "RESET_GRAPH": "algo_idle"
      }
    },
    {
      "name": "algo_auto",
      "onEnter": "startAuto() (set autoTimer, change auto button text, set interval to call stepNext())",
      "onExit": "stopAuto() (clear interval, reset auto button text)",
      "on": {
        "AUTO_TOGGLE": "algo_viewing",
        "AUTO_STOP": "algo_viewing",
        "NEXT_STEP_REACHED_END": "algo_viewing",
        "RESET_GRAPH": "algo_idle",
        "CLEAR_STEPS": "algo_idle"
      }
    },
    {
      "name": "algo_done",
      "onEnter": "refreshDisplaySnapshot(); log final summary; if snapshots final.negCycleDetected then status('Negative cycle detected')",
      "onExit": "",
      "on": {
        "RESET_GRAPH": "algo_idle",
        "CLEAR_STEPS": "algo_idle",
        "PREPARE_RUN": "algo_preparing"
      }
    }
  ],
  "events": [
    "CLICK_ADD_NODE",
    "CLICK_ADD_EDGE",
    "CLICK_DRAG",
    "CANVAS_CLICK",
    "NODE_CLICK",
    "NODE_MOUSEDOWN",
    "MOUSE_MOVE",
    "TOUCH_MOVE",
    "MOUSE_UP",
    "TOUCH_END",
    "ADD_EDGE_CANCEL",
    "EDGE_WEIGHT_ENTERED",
    "EDGE_CREATED",
    "EDGE_CLICK",
    "PREPARE_RUN",
    "PREPARE_SUCCESS",
    "PREPARE_FAIL",
    "NEXT_STEP",
    "PREV_STEP",
    "AUTO_TOGGLE",
    "AUTO_START",
    "AUTO_STOP",
    "NEXT_STEP_REACHED_END",
    "CLEAR_STEPS",
    "RESET_GRAPH",
    "RESIZE",
    "KEY_NEXT",
    "KEY_PREV",
    "INIT_DEMO",
    "SELECT_SOURCE"
  ],
  "notes": "This FSM models two orthogonal interaction domains of the application: (1) UI 'modes' for editing/interacting with the graph (drag / add node / add edge / dragging / add-edge pending) and (2) algorithm execution states for Bellman-Ford (idle / preparing / viewing snapshots / auto-playing / done). Key implementation behaviors not expressible as pure state transitions are described below:\n\n- Add Node flow: In mode_addNode, CANVAS_CLICK triggers addNode(x,y) (creates node, calls render(), updateSourceOptions()). The mode remains mode_addNode until user toggles mode.\n- Add Edge flow: In mode_addEdge: first NODE_CLICK sets addEdgeFrom and transitions to addEdge_pending (onEnter stores source). The next NODE_CLICK (target) triggers a prompt for weight; on confirmation EDGE_CREATED occurs (edges.push and render). If the prompt is cancelled ADD_EDGE_CANCEL occurs. Clicking empty canvas while in addEdge clears addEdgeFrom.\n- Drag flow: NODE_MOUSEDOWN in mode_drag transitions to dragging (onEnter attaches move/up listeners). MOUSE_MOVE / TOUCH_MOVE update node position and call render(); MOUSE_UP / TOUCH_END transitions back to mode_drag and removes listeners.\n- Prepare run: PREPARE_RUN invokes prepareBellmanFord(). If no source selected or no nodes, prepareBellmanFord sets status and remains in algo_idle (PREPARE_FAIL). On success PREPARE_SUCCESS is emitted and snapshots/steps are populated; next/prev buttons enabled and currentSnapshotIndex set to 0.\n- Snapshot stepping: NEXT_STEP and PREV_STEP update currentSnapshotIndex and call refreshDisplaySnapshot(). When currentSnapshotIndex reaches the final snapshot, NEXT_STEP produces status 'Reached last snapshot.' and, if auto is running, triggers NEXT_STEP_REACHED_END causing algo_auto to exit to algo_viewing. refreshDisplaySnapshot updates node SVG dist/pred labels, highlights the current edge (highlightEdge) and logs step messages.\n- Auto-play: AUTO_TOGGLE toggles auto play. Entering algo_auto runs startAuto() which sets autoTimer (interval 700ms) and repeatedly issues NEXT_STEP until final snapshot. Exiting algo_auto runs stopAuto().\n- Reset/Clear Steps: RESET_GRAPH calls clearGraph() (clears nodes, edges, steps, snapshots, stops auto) and transitions algorithm state to algo_idle; CLEAR_STEPS calls resetStepsOnly() (clears snapshots/steps and stops auto) and transitions to algo_idle.\n- Negative cycle: During prepareBellmanFord a final pass sets a negCycleDetected flag in the final snapshot; that flag is surfaced when algorithm reaches the final summary snapshot and the algo_done behavior/log notes the negative cycle. The code does not create a separate running state for detection; the FSM exposes algo_done to represent viewing final summary (optionally with negCycle detected).\n\nInitial conditions used by the UI: on load initDemo() runs which sets mode_drag and pre-populates a sample graph; algorithm starts in algo_idle (no snapshots) until PREPARE_RUN is invoked. Keyboard shortcuts map to NEXT_STEP / PREV_STEP / and mode toggles (space, ArrowRight, ArrowLeft, 'a', 'e', 'd'). Events like RESIZE update internal svg bounds but do not change high-level states.",
  "implementation_notes": "Actions referenced in onEnter/onExit correspond to concrete functions in the code: setMode(...), addNode(x,y), highlightEdge(i), highlightNode(id), prepareBellmanFord(), startAuto(), stopAuto(), refreshDisplaySnapshot(), render(), clearGraph(), resetStepsOnly(), and log(msg). The FSM representation above intentionally separates editing modes from algorithm states; in the real app they run concurrently (i.e. mode_* and algo_* are orthogonal). For clarity here they are modeled as separate named states; transitions that cross concerns (e.g. RESET_GRAPH, CLEAR_STEPS) are mapped to algorithm states as appropriate."
}