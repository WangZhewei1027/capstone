{
  "topic": "Interactive Application",
  "description": "Finite state machine for the Counting Sort interactive walkthrough UI (controls, autoplay/step, animations, and algorithmic stages). Models modes (ready/playing/paused/stepping), algorithmic stages (init, counting, prefix sums, placing, done), and user interactions that drive transitions.",
  "states": [
    {
      "name": "ready",
      "onEnter": "initialize",
      "onExit": null,
      "on": {
        "PLAY": "playing",
        "STEP": "stepping",
        "NEXT": "stepping",
        "PREV": "stepping_backward",
        "RESET": "initializing",
        "RANDOMIZE": "initializing",
        "EXAMPLE_LOAD": "initializing",
        "INPUT_CHANGE": "initializing",
        "MAX_CHANGE": "initializing",
        "TOGGLE_STABLE": "ready",
        "SPEED_CHANGE": "ready"
      }
    },
    {
      "name": "initializing",
      "onEnter": "initialize (parse input, set k, zero counts, buildSteps, render arrays, highlight pseudocode line 1, setStatus Ready)",
      "onExit": null,
      "on": {
        "INIT_COMPLETE": "ready",
        "ERROR": "error"
      }
    },
    {
      "name": "stepping",
      "onEnter": "executeStep (single step from steps[stepIndex])",
      "onExit": null,
      "on": {
        "STEP_COMPLETE": "ready",
        "DONE": "done",
        "ERROR": "error"
      }
    },
    {
      "name": "stepping_backward",
      "onEnter": "stepBackward (pause, reinitialize, replay up to target stepIndex)",
      "onExit": null,
      "on": {
        "STEP_BACK_COMPLETE": "ready",
        "ERROR": "error"
      }
    },
    {
      "name": "playing",
      "onEnter": "play (set playing=true, update UI 'Pause', start loop executing steps sequentially)",
      "onExit": "pause (set playing=false, update UI 'Play')",
      "on": {
        "PAUSE": "paused",
        "STOP": "ready",
        "FINISH": "done",
        "ERROR": "error"
      }
    },
    {
      "name": "paused",
      "onEnter": "pause (set playing=false, update mode-label 'Paused')",
      "onExit": null,
      "on": {
        "PLAY": "playing",
        "STEP": "stepping",
        "NEXT": "stepping",
        "PREV": "stepping_backward",
        "RESET": "initializing",
        "ERROR": "error"
      }
    },
    {
      "name": "done",
      "onEnter": "highlightFinalOutput; setStatus('Done â€” output ready')",
      "onExit": null,
      "on": {
        "RESET": "initializing",
        "PLAY": "playing",
        "STEP": "stepping",
        "ERROR": "error"
      }
    },
    {
      "name": "error",
      "onEnter": "showError (alert) and setStatus('Error')",
      "onExit": null,
      "on": {
        "RESET": "initializing",
        "INPUT_CHANGE": "initializing"
      }
    },
    {
      "name": "algorithm:init_counts",
      "onEnter": "highlightPseudocode(1); setStatus('Initializing counts'); updateCountDisplay(all indices, no highlight)",
      "onExit": null,
      "on": {
        "INIT_COUNTS_COMPLETE": "ready"
      }
    },
    {
      "name": "algorithm:counting",
      "onEnter": "highlightPseudocode(2); for each input item: highlight input cell, increment state.counts[value], updateCountDisplay(value)",
      "onExit": null,
      "on": {
        "COUNT_STEP": "algorithm:counting",
        "COUNT_COMPLETE": "algorithm:prefix_start",
        "ERROR": "error"
      }
    },
    {
      "name": "algorithm:prefix_start",
      "onEnter": "highlightPseudocode(3); setStatus('Computing prefix sums')",
      "onExit": null,
      "on": {
        "PREFIX_STEP": "algorithm:prefix",
        "PREFIX_COMPLETE": "algorithm:place_start",
        "ERROR": "error"
      }
    },
    {
      "name": "algorithm:prefix",
      "onEnter": "for i: highlight counts[i-1] and counts[i], compute counts[i]+=counts[i-1], updateCountDisplay(i)",
      "onExit": null,
      "on": {
        "PREFIX_STEP_COMPLETE": "algorithm:prefix",
        "PREFIX_COMPLETE": "algorithm:place_start",
        "ERROR": "error"
      }
    },
    {
      "name": "algorithm:place_start",
      "onEnter": "highlightPseudocode(4); setStatus('Placing elements into output array')",
      "onExit": null,
      "on": {
        "PLACE_STEP": "algorithm:place",
        "PLACE_COMPLETE": "done",
        "ERROR": "error"
      }
    },
    {
      "name": "algorithm:place",
      "onEnter": "highlightPseudocode(5); identify source and target, animateMove(source,target), set output[target]=value, counts[value]--, renderOutput, updateCountDisplay(value)",
      "onExit": null,
      "on": {
        "ANIMATION_COMPLETE": "algorithm:place",
        "PLACE_STEP_COMPLETE": "algorithm:place",
        "PLACE_COMPLETE": "done",
        "ERROR": "error"
      }
    }
  ],
  "events": [
    "INIT",
    "INIT_COMPLETE",
    "RANDOMIZE",
    "EXAMPLE_LOAD",
    "RESET",
    "INPUT_CHANGE",
    "MAX_CHANGE",
    "TOGGLE_STABLE",
    "SPEED_CHANGE",
    "PLAY",
    "PAUSE",
    "STOP",
    "STEP",
    "NEXT",
    "PREV",
    "COUNT_STEP",
    "COUNT_COMPLETE",
    "PREFIX_STEP",
    "PREFIX_COMPLETE",
    "PREFIX_STEP_COMPLETE",
    "PLACE_STEP",
    "PLACE_STEP_COMPLETE",
    "PLACE_COMPLETE",
    "ANIMATION_COMPLETE",
    "STEP_COMPLETE",
    "STEP_BACK_COMPLETE",
    "FINISH",
    "ERROR"
  ],
  "notes": "High-level notes and mapping to implementation details:\n- The application maintains a single linear step list (state.steps). Steps include types: 'init_counts', 'count', 'prefix_start', 'prefix', 'place_start', 'place', 'done'. The FSM represents both UI mode states (ready, playing, paused, stepping) and algorithmic sub-states (algorithm:counting, algorithm:prefix, algorithm:place, etc.).\n- initialize() parses input, sets k and arrays, builds steps via buildSteps(), renders original/count/output and highlights pseudocode line 1. It is used by many transitions (INPUT_CHANGE, RANDOMIZE, EXAMPLE_LOAD, RESET).\n- play() sets state.playing=true and loops executing steps until paused or steps exhausted. onEnter playing => action 'play', onExit playing => action 'pause'. When play runs to the last step, done state is entered (highlightFinalOutput).\n- stepping executes exactly one step via executeStep; the step implementation performs animations (animateMove) and UI updates (highlightPseudocode, setStatus, updateCountDisplay, renderOutput). After a step finishes a STEP_COMPLETE is emitted; if that step was the final 'done' step, DONE is emitted.\n- stepping backward is implemented by reinitializing and replaying steps up to the previous target index (see stepBackward), which is represented by stepping_backward state and its onEnter action 'stepBackward'.\n- Stable toggle (TOGGLE_STABLE) updates state.stable and rebuilds steps (buildSteps) without forcing a full reinitialize; the UI shows status 'Stable set to ON/OFF'.\n- Speed adjustments (SPEED_CHANGE) set state.speed and affect durations (ANIM_TIME_BASE / speedFactor) used by animations and waits.\n- Error handling (invalid input) triggers an alert and transitions to error state; user must correct input or press reset to recover.\n- This FSM is intentionally descriptive: onEnter/onExit actions map to JS functions used in the code (initialize, play, pause, executeStep, stepBackward, highlightFinalOutput, etc.). Transitions that occur implicitly inside play/executeStep are exposed as events (e.g., ANIMATION_COMPLETE, STEP_COMPLETE, DONE) to show the step progression and animation boundaries."
}