{
  "topic": "Huffman Coding — Interactive Module",
  "description": "Models the interactive UI states for building a Huffman prefix tree: text analysis → priority queue interactions (select/merge/hint/auto) → animated merges → final tree → encode/decode and visual highlights.",
  "states": [
    {
      "name": "idle",
      "onEnter": "clearState",
      "on": {
        "ANALYZE": "awaiting_selection",
        "RESET": "idle"
      }
    },
    {
      "name": "awaiting_selection",
      "onEnter": "analyzeText (if reached via ANALYZE) / renderQueue (if arrived from merging)",
      "onExit": "updateMetrics",
      "on": {
        "SELECT_NODE": "one_selected",
        "TOGGLE_SELECT": "one_selected",
        "HINT": "awaiting_selection",
        "AUTO_STEP": "merging",
        "AUTO_FINISH_START": "auto_finishing",
        "ENCODE": "encoding",
        "DECODE": "decoding",
        "RESET": "idle"
      }
    },
    {
      "name": "one_selected",
      "onEnter": "updateSelectionVisuals",
      "onExit": "updateSelectionVisuals",
      "on": {
        "SELECT_NODE": "two_selected",
        "TOGGLE_SELECT": "two_selected",
        "DESELECT_NODE": "awaiting_selection",
        "ESCAPE_CLEAR_SELECTION": "awaiting_selection",
        "AUTO_STEP": "merging",
        "AUTO_FINISH_START": "auto_finishing",
        "HINT": "one_selected",
        "RESET": "idle"
      }
    },
    {
      "name": "two_selected",
      "onEnter": "updateSelectionVisuals",
      "onExit": "updateSelectionVisuals",
      "on": {
        "MERGE_SELECTED": "merging (if CAN_MERGE) / error_invalid_merge (else)",
        "TOGGLE_SELECT": "one_selected",
        "DESELECT_NODE": "one_selected",
        "ESCAPE_CLEAR_SELECTION": "awaiting_selection",
        "AUTO_STEP": "merging",
        "AUTO_FINISH_START": "auto_finishing",
        "HINT": "two_selected",
        "RESET": "idle"
      }
    },
    {
      "name": "merging",
      "onEnter": "animateMerge (fade out children, insert parent) ; (implicit) on animation end run: remove children, push parent, sortQueue, selected.clear(), renderQueue, renderTree, updateMetrics, setStatus",
      "onExit": "clear transient animation styles (transform/opacity) ; updateSelectionVisuals",
      "on": {
        "MERGE_ANIMATION_COMPLETE": "awaiting_selection (if nodes.length > 1) / tree_complete (if nodes.length === 1)",
        "RESET": "idle"
      }
    },
    {
      "name": "error_invalid_merge",
      "onEnter": "flash(queue,'shake') ; status: 'Huffman greedy rule...'; highlightSmallest(900)",
      "onExit": "clear transient shake/highlight",
      "on": {
        "ACK_ERROR": "two_selected",
        "DESELECT_NODE": "one_selected",
        "RESET": "idle"
      }
    },
    {
      "name": "hint_highlighting",
      "onEnter": "highlightSmallest(duration)",
      "onExit": "remove hint highlight",
      "on": {
        "HINT_DONE": "awaiting_selection",
        "RESET": "idle"
      }
    },
    {
      "name": "auto_finishing",
      "onEnter": "autoFinish (loop: autoStep + await animation until nodes.length <= 1 or autoFinishAbort)",
      "onExit": "abortAutoFinish (if aborted) ; set Auto-Finish button text back",
      "on": {
        "AUTO_FINISH_STEP_COMPLETE": "auto_finishing (loop)",
        "AUTO_FINISH_COMPLETE": "tree_complete",
        "AUTO_FINISH_ABORT": "awaiting_selection",
        "RESET": "idle"
      }
    },
    {
      "name": "tree_complete",
      "onEnter": "renderTree ; computeCodesAndRender ; updateMetrics ; set finalRoot",
      "onExit": "clear highlights",
      "on": {
        "ENCODE": "encoding",
        "DECODE": "decoding",
        "HOVER_CODE": "hover_code",
        "HOVER_NODE": "hover_node",
        "RESET": "idle",
        "ANALYZE": "awaiting_selection"
      }
    },
    {
      "name": "encoding",
      "onEnter": "encodeText (compute codes, build bitstring, update encoded text and metrics, setStatus)",
      "onExit": "none",
      "on": {
        "ENCODE_COMPLETE": "tree_complete",
        "RESET": "idle"
      }
    },
    {
      "name": "decoding",
      "onEnter": "decodeBits (start step-by-step traversal animation; highlightTraversalStep on each bit)",
      "onExit": "clearTraversalHighlights",
      "on": {
        "DECODE_STEP": "decoding",
        "DECODE_COMPLETE": "tree_complete",
        "DECODE_ERROR": "tree_complete",
        "RESET": "idle"
      }
    },
    {
      "name": "hover_code",
      "onEnter": "highlightPathForSymbol(sym,true)",
      "onExit": "highlightPathForSymbol(sym,false)",
      "on": {
        "LEAVE_CODE": "tree_complete",
        "RESET": "idle"
      }
    },
    {
      "name": "hover_node",
      "onEnter": "highlightNodeInSvg(nodeId,true)",
      "onExit": "highlightNodeInSvg(nodeId,false)",
      "on": {
        "LEAVE_NODE": "tree_complete",
        "RESET": "idle"
      }
    }
  ],
  "events": [
    "ANALYZE",
    "ANALYZE_COMPLETE",
    "RESET",
    "SELECT_NODE",
    "TOGGLE_SELECT",
    "DESELECT_NODE",
    "ESCAPE_CLEAR_SELECTION",
    "MERGE_SELECTED",
    "MERGE_ANIMATION_COMPLETE",
    "ACK_ERROR",
    "HINT",
    "HINT_DONE",
    "AUTO_STEP",
    "AUTO_FINISH_START",
    "AUTO_FINISH_STEP_COMPLETE",
    "AUTO_FINISH_COMPLETE",
    "AUTO_FINISH_ABORT",
    "ENCODE",
    "ENCODE_COMPLETE",
    "DECODE",
    "DECODE_STEP",
    "DECODE_COMPLETE",
    "DECODE_ERROR",
    "HOVER_CODE",
    "LEAVE_CODE",
    "HOVER_NODE",
    "LEAVE_NODE"
  ],
  "notes": "Guards and side-effect details: \n- SELECT/TOGGLE_SELECT/DESELECT_NODE are parameterized by node id; the FSM uses selection count to move between awaiting_selection / one_selected / two_selected. \n- MERGE_SELECTED only performs a merge (moves to merging) if canMerge(selectedIds) (i.e., the two selected are the two smallest by weight and createdAt). If the guard fails the FSM transitions to error_invalid_merge and stays in the selection context. \n- merging.onEnter triggers animateMerge(left,right,parent) which performs the visual fade-out/insert; when the animation callback completes the app removes children, pushes the parent node, sorts the queue, clears selection, re-renders queue and tree, updates metrics and then emits MERGE_ANIMATION_COMPLETE. That event leads to awaiting_selection or tree_complete depending on whether nodes.length > 1. \n- auto_finishing runs autoFinish which loops autoStep + waiting for animations until nodes.length === 1 or AUTO_FINISH_ABORT is invoked. On normal completion it emits AUTO_FINISH_COMPLETE → tree_complete. On abort it emits AUTO_FINISH_ABORT → awaiting_selection. \n- encoding is synchronous in the UI: encodeText constructs the bitstring and updates metrics and encoded display; encoding transitions back to tree_complete (ENCODE_COMPLETE). \n- decoding runs asynchronously step-by-step with timeouts; each step highlights traversal. When finished DECODE_COMPLETE returns to tree_complete and writes decoded text into the sample input. \n- HOVER_CODE/HOVER_NODE invoke highlight logic (highlightPathForSymbol / highlightNodeInSvg) and are transient hover states returning to tree_complete on LEAVE events. \n- The UI exposes additional transient UI actions (flash/shake, highlightSmallest, renderTree, renderQueue, updateSelectionVisuals) which are represented as onEnter/onExit actions in relevant states rather than separate states for every short animation. \n- The FSM abstracts many DOM details: events like MERGE_ANIMATION_COMPLETE, AUTO_FINISH_STEP_COMPLETE, DECODE_STEP/DECODE_COMPLETE are logical events that the implementation triggers implicitly after animations/timeouts complete (they correspond to animateMerge callback, autoFinish loop delays and decode setTimeout loops respectively)."
}