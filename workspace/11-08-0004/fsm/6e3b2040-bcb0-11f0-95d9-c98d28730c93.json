{
  "topic": "Stack (LIFO) Interactive Module",
  "description": "Finite state machine modeling the interactive stack UI: push/pop/peek, drag & drop, capacity changes, and visual/ARIA feedback including animation lifecycles, overflow/underflow flashes, and clearing.",
  "states": [
    {
      "name": "idle",
      "onEnter": "updateIndicators / renderStack",
      "on": {
        "CLICK_PUSH_VALID": "pushing",
        "INPUT_ENTER_VALID": "pushing",
        "DROP_ON_STACK_VALID": "pushing",
        "CLICK_PUSH_EMPTY": "idle",
        "INPUT_ENTER_EMPTY": "idle",
        "DROP_ON_STACK_FULL": "overflow",
        "CLICK_PUSH_FULL": "overflow",
        "CLICK_POP_VALID": "popping",
        "CLICK_POP_EMPTY": "underflow",
        "CLICK_NODE_TOP": "popping",
        "CLICK_NODE_NON_TOP": "announce_only",
        "CLICK_PEEK_VALID": "peeking",
        "CLICK_PEEK_EMPTY": "underflow",
        "CLICK_CLEAR_NONEMPTY": "clearing",
        "CLICK_CLEAR_EMPTY": "idle",
        "CAPACITY_CHANGED_OK": "idle",
        "CAPACITY_CHANGED_CAUSES_WARNING": "capacity_warning",
        "DRAG_START": "dragging",
        "WINDOW_RESIZE": "idle"
      }
    },
    {
      "name": "pushing",
      "onEnter": "animatePush(value) // creates floating node, schedules logical push and render on animation completion, announce('Pushed ...')",
      "onExit": "updateIndicators / renderStack",
      "on": {
        "PUSH_ANIM_COMPLETE": "idle",
        "PUSH_ANIM_CANCEL": "idle",
        "CLICK_PUSH_FULL": "overflow"
      }
    },
    {
      "name": "popping",
      "onEnter": "animatePop() // clones top node, removes logical top immediately, animates floating removal, announce('Popped ...')",
      "onExit": "updateIndicators / renderStack",
      "on": {
        "POP_ANIM_COMPLETE": "idle",
        "POP_ANIM_CANCEL": "idle"
      }
    },
    {
      "name": "peeking",
      "onEnter": "peek() // pointer pulse animation and announce('Peek: top is ...')",
      "onExit": "updateIndicators",
      "on": {
        "PEEK_ANIM_COMPLETE": "idle"
      }
    },
    {
      "name": "dragging",
      "onEnter": "set draggedValue (from dragstart); e.dataTransfer prepared",
      "onExit": "clear draggedValue",
      "on": {
        "DRAG_OVER": "drag_over",
        "DRAG_END": "idle",
        "DROP_ON_STACK_VALID": "pushing",
        "DROP_ON_STACK_FULL": "overflow"
      }
    },
    {
      "name": "drag_over",
      "onEnter": "stackFrame.style.borderColor = 'rgba(6,182,212,0.18)' // visual highlight",
      "onExit": "stackFrame.style.borderColor = 'rgba(255,255,255,0.04)' // restore",
      "on": {
        "DROP_ON_STACK_VALID": "pushing",
        "DROP_ON_STACK_FULL": "overflow",
        "DRAG_LEAVE": "dragging",
        "DRAG_END": "idle"
      }
    },
    {
      "name": "overflow",
      "onEnter": "flashOverflow() // add flash class; announce('Overflow: stack is full. Cannot push.')",
      "onExit": "remove overflow visual (class removed after timeout)",
      "on": {
        "OVERFLOW_DONE": "idle",
        "CLICK_CLEAR_NONEMPTY": "clearing",
        "CAPACITY_CHANGED_OK": "idle"
      }
    },
    {
      "name": "underflow",
      "onEnter": "flashUnderflow() // add flash class; announce('Underflow: stack is empty. Cannot pop.')",
      "onExit": "remove underflow visual (class removed after timeout)",
      "on": {
        "UNDERFLOW_DONE": "idle",
        "CLICK_CLEAR_EMPTY": "idle"
      }
    },
    {
      "name": "clearing",
      "onEnter": "stack = []; renderStack(); announce('Cleared stack.')",
      "onExit": "updateIndicators",
      "on": {
        "CLEAR_DONE": "idle"
      }
    },
    {
      "name": "capacity_warning",
      "onEnter": "capacity = newValue; updateIndicators(); flashOverflow(); announce('Warning: current size exceeds new capacity.')",
      "onExit": "updateIndicators",
      "on": {
        "CAP_WARNING_DONE": "idle",
        "CLICK_CLEAR_NONEMPTY": "clearing"
      }
    },
    {
      "name": "announce_only",
      "onEnter": "announce('Only the top element can be popped (LIFO).')",
      "on": {
        "ANNOUNCE_DONE": "idle"
      }
    }
  ],
  "events": [
    "CLICK_PUSH_VALID",
    "CLICK_PUSH_EMPTY",
    "CLICK_PUSH_FULL",
    "INPUT_ENTER_VALID",
    "INPUT_ENTER_EMPTY",
    "DROP_ON_STACK_VALID",
    "DROP_ON_STACK_FULL",
    "PUSH_ANIM_COMPLETE",
    "PUSH_ANIM_CANCEL",
    "CLICK_POP_VALID",
    "CLICK_POP_EMPTY",
    "POP_ANIM_COMPLETE",
    "POP_ANIM_CANCEL",
    "CLICK_NODE_TOP",
    "CLICK_NODE_NON_TOP",
    "CLICK_PEEK_VALID",
    "CLICK_PEEK_EMPTY",
    "PEEK_ANIM_COMPLETE",
    "CLICK_CLEAR_NONEMPTY",
    "CLICK_CLEAR_EMPTY",
    "CLEAR_DONE",
    "CAPACITY_CHANGED_OK",
    "CAPACITY_CHANGED_CAUSES_WARNING",
    "CAP_WARNING_DONE",
    "DRAG_START",
    "DRAG_OVER",
    "DRAG_LEAVE",
    "DRAG_END",
    "DROP",
    "WINDOW_RESIZE",
    "ANNOUNCE_DONE",
    "OVERFLOW_DONE",
    "UNDERFLOW_DONE"
  ],
  "notes": "Guards and payloads: many events are conditional (e.g., CLICK_PUSH_* variants depend on whether a value was entered or capacity reached). The FSM models animation lifecycles as explicit COMPLETE events (PUSH_ANIM_COMPLETE / POP_ANIM_COMPLETE / PEEK_ANIM_COMPLETE) which are produced by setTimeout/animation end in the implementation. Key onEnter actions map to actual functions in the code: animatePush(value), animatePop(), peek(), flashOverflow(), flashUnderflow(), renderStack(), updateIndicators(), announce(...). Drag & Drop: DRAG_START sets draggedValue; DRAG_OVER toggles visual border; DROP triggers either DROP_ON_STACK_VALID or DROP_ON_STACK_FULL depending on capacity. Capacity change may immediately produce 'capacity_warning' if current size > new capacity (flash and announce). ANNOUNCE_DONE, OVERFLOW_DONE, UNDERFLOW_DONE, CLEAR_DONE and CAP_WARNING_DONE represent transient timers or callbacks that return the UI to idle after visual feedback completes."
}