{
  "topic": "Dijkstra Interactive Module",
  "description": "Models the interactive UI modes, algorithm runtime (step/play), modal flow, node/edge creation, dragging and visual animation steps for the Dijkstra interactive application.",
  "states": [
    {
      "name": "idle",
      "onEnter": "updateModeDisplay",
      "onExit": "clearTransientSelection",
      "on": {
        "CLICK_SAMPLE": "idle",
        "CLICK_ADD_NODE": "addNode",
        "CLICK_ADD_EDGE": "addEdge",
        "CLICK_SET_SOURCE": "setSource",
        "CLICK_SET_TARGET": "setTarget",
        "CLICK_CLEAR": "idle",
        "CLICK_RESET": "idle",
        "CLICK_STEP": "stepping",
        "CLICK_PLAY": "running",
        "NODE_MOUSE_DOWN": "dragging",
        "NODE_CLICK": "idle",
        "SVG_CLICK": "idle"
      }
    },
    {
      "name": "addNode",
      "onEnter": "setMode_addNode",
      "onExit": "updateModeDisplay",
      "on": {
        "SVG_CLICK": "idle",
        "CLICK_ADD_NODE": "addNode",
        "CLICK_CLEAR": "idle",
        "CLICK_SAMPLE": "idle",
        "KEY_ESC": "idle"
      }
    },
    {
      "name": "addEdge",
      "onEnter": "setMode_addEdge; addEdgeState.first = null",
      "onExit": "updateModeDisplay",
      "on": {
        "NODE_CLICK": "addEdge_firstSelected",
        "CLICK_CLEAR": "idle",
        "CLICK_ADD_EDGE": "addEdge",
        "CLICK_SAMPLE": "idle",
        "KEY_ESC": "idle"
      }
    },
    {
      "name": "addEdge_firstSelected",
      "onEnter": "recordFirstNodeForEdge; showStatus_pickSecond",
      "onExit": "clearFirstEdgeSelection",
      "on": {
        "NODE_CLICK_SAME": "addEdge_firstSelected",
        "NODE_CLICK_DIFFERENT": "modal_open",
        "CLICK_CLEAR": "idle",
        "KEY_ESC": "addEdge"
      }
    },
    {
      "name": "modal_open",
      "onEnter": "showModal",
      "onExit": "hideModal",
      "on": {
        "MODAL_OK_VALID": "idle",
        "MODAL_OK_INVALID": "modal_open",
        "MODAL_CANCEL": "addEdge_firstSelected"
      }
    },
    {
      "name": "setSource",
      "onEnter": "setMode_setSource",
      "onExit": "updateModeDisplay",
      "on": {
        "NODE_CLICK": "idle",
        "CLICK_CLEAR": "idle",
        "KEY_ESC": "idle"
      }
    },
    {
      "name": "setTarget",
      "onEnter": "setMode_setTarget",
      "onExit": "updateModeDisplay",
      "on": {
        "NODE_CLICK": "idle",
        "CLICK_CLEAR": "idle",
        "KEY_ESC": "idle"
      }
    },
    {
      "name": "dragging",
      "onEnter": "captureSelectedNode_for_drag",
      "onExit": "releaseDrag; updateConnectedEdges",
      "on": {
        "MOUSE_MOVE": "dragging",
        "MOUSE_UP": "idle",
        "CLICK_CLEAR": "idle"
      }
    },
    {
      "name": "running",
      "onEnter": "startAutoTimer; setRunningTrue; playButtonToPause",
      "onExit": "stopAutoTimer; setRunningFalse; playButtonToPlay",
      "on": {
        "TIMER_TICK": "stepping",
        "CLICK_PLAY": "paused",
        "CLICK_STEP": "stepping",
        "ALGORITHM_FINISHED": "finished",
        "CLICK_CLEAR": "idle",
        "CLICK_RESET": "idle"
      }
    },
    {
      "name": "paused",
      "onEnter": "setRunningFalse; playButtonToPlay",
      "onExit": "setRunningTrue; playButtonToPause",
      "on": {
        "CLICK_PLAY": "running",
        "CLICK_STEP": "stepping",
        "CLICK_CLEAR": "idle",
        "CLICK_RESET": "idle",
        "ALGORITHM_FINISHED": "finished"
      }
    },
    {
      "name": "stepping",
      "onEnter": "performOneStep",
      "onExit": "updatePriorityQueueView",
      "on": {
        "ACTION_STOP_PULSE": "stepping",
        "ACTION_RELAX_ANIMATION": "animating_relax",
        "NO_NEXT_NODE": "finished",
        "CLICK_PLAY": "running",
        "CLICK_CLEAR": "idle"
      }
    },
    {
      "name": "animating_relax",
      "onEnter": "startEdgeHighlightAnimation",
      "onExit": "endEdgeHighlightAnimation; applyRelaxOutcome",
      "on": {
        "ANIMATION_COMPLETE": "stepping",
        "CLICK_CLEAR": "idle",
        "CLICK_PLAY": "running"
      }
    },
    {
      "name": "finished",
      "onEnter": "highlightFinalPath; stopAllTimers; setRunningFalse",
      "onExit": "clearPathHighlight?",
      "on": {
        "CLICK_RESET": "idle",
        "CLICK_CLEAR": "idle",
        "CLICK_SAMPLE": "idle",
        "CLICK_PLAY": "idle",
        "CLICK_STEP": "idle"
      }
    }
  ],
  "events": [
    "CLICK_SAMPLE",
    "CLICK_ADD_NODE",
    "CLICK_ADD_EDGE",
    "CLICK_SET_SOURCE",
    "CLICK_SET_TARGET",
    "CLICK_CLEAR",
    "CLICK_STEP",
    "CLICK_PLAY",
    "CLICK_RESET",
    "SPEED_CHANGE",
    "MODAL_OK_VALID",
    "MODAL_OK_INVALID",
    "MODAL_CANCEL",
    "NODE_CLICK",
    "NODE_CLICK_SAME",
    "NODE_CLICK_DIFFERENT",
    "NODE_MOUSE_DOWN",
    "NODE_DOUBLE_CLICK",
    "SVG_CLICK",
    "MOUSE_MOVE",
    "MOUSE_UP",
    "KEY_SPACE",
    "KEY_ESC",
    "TIMER_TICK",
    "ACTION_STOP_PULSE",
    "ACTION_RELAX_ANIMATION",
    "ANIMATION_COMPLETE",
    "ALGORITHM_FINISHED",
    "NO_NEXT_NODE"
  ],
  "notes": "State names approximate the UI 'mode' variable and the algorithm runtime (running/paused/stepping/animating). onEnter/onExit are high-level actions that map to the JS functions: setMode_*, updateModeDisplay(), loadSampleGraph(), clearAll(), resetAlgorithm(), startAutoTimer()/stopAutoTimer(), performOneStep() (which enqueues stopPulse and relax actions), startEdgeHighlightAnimation()/endEdgeHighlightAnimation() (the setTimeout relax animation), showModal()/hideModal(), addNode(), createEdge(), highlightFinalPath(), updatePriorityQueueView(), and dragging helpers. 'addEdge_firstSelected' represents the intermediate state after selecting the first node to connect. The modal can be opened from that state and returns either to addEdge_firstSelected (on cancel) or to idle (after creating the edge). 'stepping' represents a single-step invocation; it either performs an immediate action (stop pulse) or initiates an animation (animating_relax). When the priority queue is empty/algorithm completes, ALGORITHM_FINISHED / NO_NEXT_NODE transitions to 'finished', which highlights the path and halts auto-play. Some implementation details (exact timing, internal queued actionsQueue consumption and nested setTimeout callbacks) are represented as abstract events (ANIMATION_COMPLETE, ACTION_RELAX_ANIMATION) in the FSM."
}