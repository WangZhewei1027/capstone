{
  "topic": "Deque Explorer Interactive Module",
  "description": "Models the interactive behaviors of a double-ended queue (deque) visualization: push/pop at both ends, peek, clear, capacity handling, animations, keyboard shortcuts and accessibility announcements.",
  "states": [
    {
      "name": "idle",
      "onEnter": "updateMeta",
      "on": {
        "PUSH_FRONT": "inserting_front",
        "PUSH_BACK": "inserting_back",
        "POP_FRONT": "removing_front",
        "POP_BACK": "removing_back",
        "PEEK_FRONT": "peeking_front",
        "PEEK_BACK": "peeking_back",
        "CLEAR": "clearing",
        "INSERT_RANDOM": "inserting_random",
        "CAPACITY_CHANGE": "capacity_changing",
        "KEY_PRESS_F": "inserting_front",
        "KEY_PRESS_B": "inserting_back",
        "KEY_PRESS_1": "removing_front",
        "KEY_PRESS_2": "removing_back",
        "KEY_PRESS_ESCAPE": "idle"
      }
    },
    {
      "name": "inserting_front",
      "onEnter": "attemptPushFront",
      "onExit": "updateMeta",
      "on": {
        "INSERTION_BLOCKED": "insertion_blocked",
        "INSERTION_SUCCESS": "animating_in_front",
        "ANIMATION_END": "idle",
        "TIMEOUT_END": "idle"
      }
    },
    {
      "name": "inserting_back",
      "onEnter": "attemptPushBack",
      "onExit": "updateMeta",
      "on": {
        "INSERTION_BLOCKED": "insertion_blocked",
        "INSERTION_SUCCESS": "animating_in_back",
        "ANIMATION_END": "idle",
        "TIMEOUT_END": "idle"
      }
    },
    {
      "name": "inserting_random",
      "onEnter": "chooseRandomEndAndAttemptInsert",
      "onExit": "updateMeta",
      "on": {
        "TO_FRONT": "inserting_front",
        "TO_BACK": "inserting_back",
        "INSERTION_BLOCKED": "insertion_blocked"
      }
    },
    {
      "name": "insertion_blocked",
      "onEnter": "shakeBeltAndAnnounceBlocked",
      "onExit": "clearShake",
      "on": {
        "SHAKE_END": "idle",
        "TIMEOUT_END": "idle"
      }
    },
    {
      "name": "animating_in_front",
      "onEnter": "startIncomingAnimationFront",
      "onExit": "focusNewNode",
      "on": {
        "ANIMATION_END": "idle",
        "TIMEOUT_END": "idle"
      }
    },
    {
      "name": "animating_in_back",
      "onEnter": "startIncomingAnimationBack",
      "onExit": "focusNewNode",
      "on": {
        "ANIMATION_END": "idle",
        "TIMEOUT_END": "idle"
      }
    },
    {
      "name": "removing_front",
      "onEnter": "attemptPopFront",
      "onExit": "updateMeta",
      "on": {
        "EMPTY": "empty_error",
        "REMOVAL_ANIMATION_END": "idle",
        "ANIMATION_END": "idle",
        "TIMEOUT_END": "idle"
      }
    },
    {
      "name": "removing_back",
      "onEnter": "attemptPopBack",
      "onExit": "updateMeta",
      "on": {
        "EMPTY": "empty_error",
        "REMOVAL_ANIMATION_END": "idle",
        "ANIMATION_END": "idle",
        "TIMEOUT_END": "idle"
      }
    },
    {
      "name": "peeking_front",
      "onEnter": "flashFrontElementAndAnnounce",
      "onExit": "clearFlash",
      "on": {
        "TIMEOUT_END": "idle",
        "ANIMATION_END": "idle"
      }
    },
    {
      "name": "peeking_back",
      "onEnter": "flashBackElementAndAnnounce",
      "onExit": "clearFlash",
      "on": {
        "TIMEOUT_END": "idle",
        "ANIMATION_END": "idle"
      }
    },
    {
      "name": "clearing",
      "onEnter": "clearAllWithAnimations",
      "onExit": "updateMeta",
      "on": {
        "ANIMATION_END_ALL": "idle",
        "TIMEOUT_END": "idle"
      }
    },
    {
      "name": "capacity_changing",
      "onEnter": "setCapacityAndAnnounce",
      "onExit": "updateMeta",
      "on": {
        "CAPACITY_EXCEEDED": "capacity_exceeded",
        "CAPACITY_OK": "idle",
        "TIMEOUT_END": "idle"
      }
    },
    {
      "name": "capacity_exceeded",
      "onEnter": "announceCapacityExceededAndShake",
      "onExit": "clearShake",
      "on": {
        "SHAKE_END": "idle",
        "TIMEOUT_END": "idle"
      }
    },
    {
      "name": "empty_error",
      "onEnter": "announceEmptyOperation",
      "on": {
        "TIMEOUT_END": "idle"
      }
    }
  ],
  "events": [
    "PUSH_FRONT",
    "PUSH_BACK",
    "POP_FRONT",
    "POP_BACK",
    "PEEK_FRONT",
    "PEEK_BACK",
    "CLEAR",
    "INSERT_RANDOM",
    "CAPACITY_CHANGE",
    "KEY_PRESS_F",
    "KEY_PRESS_B",
    "KEY_PRESS_1",
    "KEY_PRESS_2",
    "KEY_PRESS_ESCAPE",
    "INSERTION_SUCCESS",
    "INSERTION_BLOCKED",
    "ANIMATION_END",
    "REMOVAL_ANIMATION_END",
    "ANIMATION_END_ALL",
    "SHAKE_END",
    "TIMEOUT_END",
    "TO_FRONT",
    "TO_BACK",
    "EMPTY",
    "CAPACITY_EXCEEDED",
    "CAPACITY_OK"
  ],
  "notes": "This FSM models the user-visible interactive states and transitions of the Deque Explorer. Actions named in onEnter/onExit correspond to the JavaScript functions or combined behaviors in the script: attemptPushFront/attemptPushBack (check capacity, update array, create DOM cell, announce, updateMeta), shakeBeltAndAnnounce/announceCapacityExceededAndShake (add 'shake' class and announce, cleared after ~420ms), startIncomingAnimationFront/Back (add 'incoming-*' and 'flash' classes; animation ~900ms), attemptPopFront/Back (shift/pop the array, add 'outgoing-*' animation and remove element on animationend), flashFrontElementAndAnnounce/flashBackElementAndAnnounce (add 'flash' class for ~700ms), clearAllWithAnimations (set deque length to 0, assign outgoing classes to all children and remove on animationend). Keyboard shortcuts map to the same logical events. Timing-based transitions (timeouts and animationend events) are modeled with TIMEOUT_END/ANIMATION_END events. The FSM distinguishes blocked-insert and capacity-exceeded flows; in practice these are transient states that return to idle after showing a shake animation and announcement. The mutation observer that focuses new nodes is represented by the focusNewNode onExit for insertion animations."
}