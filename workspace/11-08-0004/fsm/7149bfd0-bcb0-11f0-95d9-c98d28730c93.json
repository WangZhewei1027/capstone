{
  "topic": "Heap Visualizer UI",
  "description": "Models the interactive states and transitions of the Heap (Min/Max) visualizer: mode toggles, insert / extract operations with percolate animations, heapify preparation and playback (step/play/pause), array utilities, and element focus/highlight behavior.",
  "states": [
    {
      "name": "idle",
      "onEnter": "render (initial randomize performed once at app start)",
      "onExit": "",
      "on": {
        "CLICK_MIN": "idle",
        "CLICK_MAX": "idle",
        "CLICK_INSERT": "percolatingUp",
        "CLICK_EXTRACT": "percolatingDown",
        "CLICK_RANDOMIZE": "idle",
        "CLICK_PREPARE_HEAPIFY": "heapifyPrepared",
        "CLICK_RESET_HEAPIFY": "idle",
        "CLICK_CLEAR": "idle",
        "CLICK_STEP": "stepping",
        "CLICK_PLAY": "playing",
        "CLICK_PAUSE": "idle",
        "CLICK_ARRAY_BOX": "focused"
      }
    },
    {
      "name": "percolatingUp",
      "onEnter": "insertValue -> render -> percolateUp(start asynchronous steps)",
      "onExit": "stop any percolate-up timeouts (implicit by completion)",
      "on": {
        "COMPARE_NODES": "comparing",
        "NEED_SWAP": "swapping",
        "PERCOLATE_UP_COMPLETE": "idle",
        "CLICK_MIN": "percolatingUp",
        "CLICK_MAX": "percolatingUp",
        "CLICK_CLEAR": "idle",
        "CLICK_RANDOMIZE": "idle"
      }
    },
    {
      "name": "percolatingDown",
      "onEnter": "extractRoot -> render -> percolateDown(start asynchronous steps) (entered when extracting)",
      "onExit": "stop any percolate-down timeouts (implicit by completion)",
      "on": {
        "COMPARE_NODES": "comparing",
        "NEED_SWAP": "swapping",
        "PERCOLATE_DOWN_COMPLETE": "idle",
        "CLICK_MIN": "percolatingDown",
        "CLICK_MAX": "percolatingDown",
        "CLICK_CLEAR": "idle",
        "CLICK_RANDOMIZE": "idle"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlightCompare (visual compare animation for two indices)",
      "onExit": "",
      "on": {
        "COMPARE_ANIMATION_DONE": "previousActivityResume"
      }
    },
    {
      "name": "swapping",
      "onEnter": "animateSwap (swap data, update DOM, visual focus then remove focus after delay)",
      "onExit": "",
      "on": {
        "SWAP_ANIMATION_DONE": "previousActivityResume"
      }
    },
    {
      "name": "heapifyPrepared",
      "onEnter": "prepareHeapify (generate actions[], set actionIndex=0, playing=false)",
      "onExit": "",
      "on": {
        "CLICK_PLAY": "playing",
        "CLICK_STEP": "stepping",
        "CLICK_RESET_HEAPIFY": "idle",
        "CLICK_CLEAR": "idle",
        "CLICK_RANDOMIZE": "idle",
        "CLICK_PREPARE_HEAPIFY": "heapifyPrepared"
      }
    },
    {
      "name": "stepping",
      "onEnter": "doStepAction (if no actions prepareHeapify then execute single action); increments actionIndex",
      "onExit": "",
      "on": {
        "ACTION_WAS_COMPARE": "comparing",
        "ACTION_WAS_SWAP": "swapping",
        "ACTION_WAS_DONE": "heapifyDone",
        "ACTION_STEP_COMPLETE": "heapifyPrepared",
        "CLICK_PLAY": "playing",
        "CLICK_RESET_HEAPIFY": "idle"
      }
    },
    {
      "name": "playing",
      "onEnter": "playActions (if actions empty prepareHeapify; start playInterval that repeatedly calls doStepAction)",
      "onExit": "clearInterval(playInterval) (stop playback)",
      "on": {
        "PLAYBACK_TICK": "stepping",
        "PLAYBACK_FINISHED": "idle",
        "CLICK_PAUSE": "paused",
        "CLICK_STEP": "stepping",
        "CLICK_RESET_HEAPIFY": "idle",
        "CLICK_CLEAR": "idle",
        "CLICK_RANDOMIZE": "idle"
      }
    },
    {
      "name": "paused",
      "onEnter": "pauseActions (clearInterval & set playing=false)",
      "onExit": "",
      "on": {
        "CLICK_PLAY": "playing",
        "CLICK_STEP": "stepping",
        "CLICK_RESET_HEAPIFY": "idle",
        "CLICK_CLEAR": "idle",
        "CLICK_RANDOMIZE": "idle"
      }
    },
    {
      "name": "heapifyDone",
      "onEnter": "log 'Heapify complete.' (actions array ended)",
      "onExit": "",
      "on": {
        "CLICK_PREPARE_HEAPIFY": "heapifyPrepared",
        "CLICK_RESET_HEAPIFY": "idle",
        "CLICK_CLEAR": "idle",
        "CLICK_RANDOMIZE": "idle"
      }
    },
    {
      "name": "focused",
      "onEnter": "focusIndex (highlight node and array box, update actionLog)",
      "onExit": "clear/replace focus (when index disappears or new focus set)",
      "on": {
        "CLICK_ARRAY_BOX": "focused",
        "CLICK_MIN": "focused",
        "CLICK_MAX": "focused",
        "CLICK_INSERT": "percolatingUp",
        "CLICK_EXTRACT": "percolatingDown",
        "CLICK_RANDOMIZE": "idle",
        "CLICK_CLEAR": "idle",
        "CLICK_RESET_HEAPIFY": "idle",
        "CLICK_PREPARE_HEAPIFY": "heapifyPrepared"
      }
    }
  ],
  "events": [
    "CLICK_MIN",
    "CLICK_MAX",
    "CLICK_INSERT",
    "CLICK_EXTRACT",
    "CLICK_RANDOMIZE",
    "CLICK_PREPARE_HEAPIFY",
    "CLICK_RESET_HEAPIFY",
    "CLICK_CLEAR",
    "CLICK_STEP",
    "CLICK_PLAY",
    "CLICK_PAUSE",
    "CLICK_ARRAY_BOX",
    "COMPARE_NODES",
    "COMPARE_ANIMATION_DONE",
    "NEED_SWAP",
    "SWAP_ANIMATION_DONE",
    "PERCOLATE_UP_COMPLETE",
    "PERCOLATE_DOWN_COMPLETE",
    "ACTION_WAS_COMPARE",
    "ACTION_WAS_SWAP",
    "ACTION_WAS_DONE",
    "ACTION_STEP_COMPLETE",
    "PLAYBACK_TICK",
    "PLAYBACK_FINISHED"
  ],
  "notes": "This FSM abstracts the UI imperative behavior into states that reflect the user's primary interactions and the major animated processes. 'previousActivityResume' in comparing/swapping means control returns to the activity that initiated the compare/swap (percolatingUp, percolatingDown, stepping, or playing). Mode toggles (min/max) are modeled as self-transitions that trigger set-mode + render. The actual code implements asynchronous animations and timeouts rather than an explicit event bus; those timeouts correspond to the COMPARE_ANIMATION_DONE / SWAP_ANIMATION_DONE / PLAYBACK_TICK events above. Focus is modeled as a transient/orthogonal state; many operations keep or clear focus depending on whether the focused index remains present after the operation. Initial application start runs a randomizeArray() then render() (modeled as idle onEnter)."
}