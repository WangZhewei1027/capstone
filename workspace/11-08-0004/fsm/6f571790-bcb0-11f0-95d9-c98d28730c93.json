{
  "topic": "KNN Interactive Module",
  "description": "Finite state machine modeling the interactive behaviors of a K-Nearest Neighbors visualization: canvas interactions (add/drag/remove points and query), controls (K, metric, voting), toggles (regions/lines), rendering/animation loop and UI updates.",
  "states": [
    {
      "name": "running",
      "onEnter": "init/startAnimationLoop/requestRender",
      "onExit": "",
      "on": {
        "POINTER_DOWN_ON_POINT": "dragging_point",
        "POINTER_DOWN_ON_QUERY": "dragging_query",
        "POINTER_DOWN_ON_EMPTY": "adding_point",
        "DOUBLE_CLICK_ON_POINT": "running",
        "POINTER_MOVE": "running",
        "POINTER_UP": "running",
        "K_CHANGE": "running",
        "METRIC_CHANGE": "running",
        "VOTING_CHANGE": "running",
        "CLASS_SELECT_CHANGE": "running",
        "ADD_RANDOM": "running",
        "CLEAR": "running",
        "RESET_BUTTON": "running",
        "KEY_RESET_R": "running",
        "TOGGLE_REGIONS": "running",
        "TOGGLE_LINES": "running",
        "RESIZE": "running",
        "REQUEST_RENDER": "running",
        "ANIMATION_TICK": "running"
      }
    },
    {
      "name": "adding_point",
      "onEnter": "addPointAtPointer (use selected class); set pointerDown = true; requestRender",
      "onExit": "",
      "on": {
        "POINTER_MOVE": "adding_point",
        "POINTER_UP": "running",
        "REQUEST_RENDER": "adding_point",
        "ANIMATION_TICK": "adding_point"
      }
    },
    {
      "name": "dragging_point",
      "onEnter": "set dragging = {type:'point', index}; set pointerDown = true; setPointerCapture",
      "onExit": "clear dragging; releasePointerCapture",
      "on": {
        "POINTER_MOVE": "dragging_point",
        "POINTER_UP": "running",
        "DOUBLE_CLICK_ON_POINT": "dragging_point",
        "REQUEST_RENDER": "dragging_point",
        "ANIMATION_TICK": "dragging_point",
        "RESIZE": "dragging_point"
      }
    },
    {
      "name": "dragging_query",
      "onEnter": "set dragging = {type:'query'}; set pointerDown = true; setPointerCapture",
      "onExit": "clear dragging; releasePointerCapture",
      "on": {
        "POINTER_MOVE": "dragging_query",
        "POINTER_UP": "running",
        "REQUEST_RENDER": "dragging_query",
        "ANIMATION_TICK": "dragging_query",
        "RESIZE": "dragging_query"
      }
    }
  ],
  "events": [
    "POINTER_DOWN_ON_POINT",
    "POINTER_DOWN_ON_QUERY",
    "POINTER_DOWN_ON_EMPTY",
    "POINTER_MOVE",
    "POINTER_UP",
    "DOUBLE_CLICK_ON_POINT",
    "K_CHANGE",
    "METRIC_CHANGE",
    "VOTING_CHANGE",
    "CLASS_SELECT_CHANGE",
    "ADD_RANDOM",
    "CLEAR",
    "RESET_BUTTON",
    "KEY_RESET_R",
    "TOGGLE_REGIONS",
    "TOGGLE_LINES",
    "RESIZE",
    "REQUEST_RENDER",
    "ANIMATION_TICK"
  ],
  "notes": "Interpretation and mapping notes:\n- 'running' is the main active state: animation loop is running (animateLoop) and the app is responsive. On app initialization the FSM enters 'running' and starts animation and an initial render.\n- Pointer down semantics are disambiguated into three event types depending on hit testing (implemented in code by findNearbyPoint):\n  - POINTER_DOWN_ON_POINT: pointerdown hit an existing data point -> transition to dragging_point.\n  - POINTER_DOWN_ON_QUERY: pointerdown hit the green query point -> transition to dragging_query.\n  - POINTER_DOWN_ON_EMPTY: pointerdown did not hit anything -> add a new data point (action addPointAtPointer) and remain effectively in running (modeled as a short-lived adding_point state that returns to running on pointer up).\n- Dragging states (dragging_point, dragging_query) update positions on POINTER_MOVE and end on POINTER_UP. OnEnter/OnExit correspond to setting/clearing state.dragging and pointer capture/release as in the code.\n- DOUBLE_CLICK_ON_POINT removes the point immediately (action removePoint) and stays/returns to running.\n- Control changes (K_CHANGE, METRIC_CHANGE, VOTING_CHANGE, CLASS_SELECT_CHANGE, ADD_RANDOM, CLEAR, RESET_BUTTON, KEY_RESET_R, TOGGLE_REGIONS, TOGGLE_LINES) perform their respective actions (update state.k, update metric, toggle voting, add random points, clear points, seed example, toggle showRegions/showLines) and always trigger requestRender. These do not change the primary interaction state (remain in running or dragging if currently dragging).\n- REQUEST_RENDER is the internal scheduling call that causes a requestAnimationFrame; the actual draw cycle synchronously computes knnPredict and updates UI during render. ANIMATION_TICK represents periodic animation increments used for pulsing lines and neighbor effects; the animation loop drives REQUEST_RENDER continuously.\n- RESIZE triggers canvas fit/rescale and requests render; it does not change interaction state.\n- The knnPredict computation is synchronous and occurs inside the render pass; it's modeled as part of REQUEST_RENDER / render actions rather than a separate FSM state.\n- Accessibility/UI updates: toggles update aria-pressed and button styling (action toggleButtonState). Prediction text box is updated as part of render (action updatePredictionBox).\n- The FSM intentionally treats animation as part of the 'running' state so interactive transitions (dragging, adding) can occur while animation is running."
}