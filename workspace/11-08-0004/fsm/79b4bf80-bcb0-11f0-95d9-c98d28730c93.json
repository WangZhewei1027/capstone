{
  "topic": "Bubble Sort Interactive Module",
  "description": "Models the interactive behavior of the Bubble Sort step-through UI: array creation, stepping through recorded snapshots (compare/swap/pass), playback (auto-advance), and controls that change playback or recompute the snapshot sequence.",
  "states": [
    {
      "name": "snapshot_display",
      "onEnter": "applySnapshot(currentSnapshot); highlightOperation(currentSnapshot); updateStatsUI(); setPassInfo(currentSnapshot.pass); scheduleAutoIfPlaying()",
      "onExit": "clearCodeHighlight()",
      "on": {
        "STEP_FORWARD": "advance",
        "STEP_BACK": "retreat",
        "AUTO_STEP": "advance",
        "PLAY": "start_play",
        "PAUSE": "stop_play",
        "TOGGLE_PLAY": "toggle_play",
        "SET_ARRAY": "recompute",
        "RANDOMIZE": "recompute",
        "RESET": "reset_to_start",
        "OPTIMIZED_TOGGLE": "recompute",
        "SPEED_CHANGE": "update_speed",
        "SIZE_CHANGE": "update_size",
        "RESIZE": "rerender",
        "KEY_LEFT": "retreat",
        "KEY_RIGHT": "advance",
        "KEY_SPACE": "toggle_play"
      }
    },
    {
      "name": "advance",
      "onEnter": "clearAutoIfNeeded(); if(currentSnapshotIndex < snapshots.length - 1) { currentSnapshotIndex++; recomputeCountsUpTo(currentSnapshotIndex); }",
      "onExit": "",
      "on": {
        "UPDATED": "snapshot_display",
        "AT_END": "completed"
      }
    },
    {
      "name": "retreat",
      "onEnter": "clearAutoIfNeeded(); if(currentSnapshotIndex > 0) { currentSnapshotIndex--; recomputeCountsUpTo(currentSnapshotIndex); }",
      "onExit": "",
      "on": {
        "UPDATED": "snapshot_display"
      }
    },
    {
      "name": "start_play",
      "onEnter": "playing = true; updatePlayButtonUI(); startAutoPlayTimer()",
      "onExit": "",
      "on": {
        "TIMER_TICK": "advance",
        "PAUSE": "stop_play",
        "TOGGLE_PLAY": "stop_play",
        "STOP": "stop_play"
      }
    },
    {
      "name": "stop_play",
      "onEnter": "playing = false; updatePlayButtonUI(); clearAutoPlayTimer()",
      "onExit": "",
      "on": {
        "PLAY": "start_play",
        "TOGGLE_PLAY": "start_play"
      }
    },
    {
      "name": "toggle_play",
      "onEnter": "if(playing) { dispatch PAUSE } else { dispatch PLAY }",
      "onExit": "",
      "on": {
        "PLAY": "start_play",
        "PAUSE": "stop_play"
      }
    },
    {
      "name": "recompute",
      "onEnter": "computeAllSnapshots(); // rebuild snapshots from initialArray with current optimized flag; set currentSnapshotIndex=0; recomputeCountsUpTo(0)",
      "onExit": "",
      "on": {
        "DONE": "snapshot_display"
      }
    },
    {
      "name": "reset_to_start",
      "onEnter": "pausePlayback(); currentSnapshotIndex = 0; recomputeCountsUpTo(0);",
      "onExit": "",
      "on": {
        "DONE": "snapshot_display"
      }
    },
    {
      "name": "update_speed",
      "onEnter": "speed = newSpeedValue; updateSpeedUI(); if(playing) rescheduleAutoPlayWithNewSpeed()",
      "onExit": "",
      "on": {
        "DONE": "snapshot_display"
      }
    },
    {
      "name": "update_size",
      "onEnter": "size = newSizeValue; updateSizeUI(); // no automatic snapshot rebuild until user requests randomize or set",
      "onExit": "",
      "on": {
        "DONE": "snapshot_display"
      }
    },
    {
      "name": "rerender",
      "onEnter": "applySnapshot(currentSnapshot) // recompute bar widths/positions for new container size",
      "onExit": "",
      "on": {
        "DONE": "snapshot_display"
      }
    },
    {
      "name": "completed",
      "onEnter": "clearAutoPlayTimer(); playing = false; updatePlayButtonUI(); statusText('Completed.')",
      "onExit": "",
      "on": {
        "RESET": "reset_to_start",
        "STEP_BACK": "retreat",
        "SET_ARRAY": "recompute",
        "RANDOMIZE": "recompute",
        "PLAY": "start_play",
        "TOGGLE_PLAY": "toggle_play"
      }
    }
  ],
  "events": [
    "STEP_FORWARD",
    "STEP_BACK",
    "AUTO_STEP",
    "TIMER_TICK",
    "PLAY",
    "PAUSE",
    "TOGGLE_PLAY",
    "SET_ARRAY",
    "RANDOMIZE",
    "RESET",
    "OPTIMIZED_TOGGLE",
    "SPEED_CHANGE",
    "SIZE_CHANGE",
    "RESIZE",
    "KEY_LEFT",
    "KEY_RIGHT",
    "KEY_SPACE",
    "UPDATED",
    "DONE",
    "AT_END",
    "STOP"
  ],
  "notes": "This FSM models two orthogonal concerns: the playback/control state (playing/paused) and the currently displayed snapshot type (start/compare/swap/pass). For simplicity the FSM uses a single generic display state (snapshot_display) and transient action states (advance/retreat/recompute/...) that perform index changes and recompute stats, then return to snapshot_display. Key onEnter actions used throughout: applySnapshot(currentSnapshot) — updates DOM positions/heights/labels; highlightOperation(currentSnapshot) — adds compare/swap/pass highlights and pseudocode highlights; updateStatsUI() — updates comparisons/swaps/pass displays; computeAllSnapshots() — simulates Bubble Sort and builds the snapshots array; startAutoPlayTimer()/clearAutoPlayTimer() — manage the recurring timer that emits TIMER_TICK/AUTO_STEP; recomputeCountsUpTo(i) — computes comparisons/swaps/pass count up to snapshot i. Transitions triggered by keyboard map to STEP_FORWARD/STEP_BACK/TOGGLE_PLAY. Reaching the last snapshot triggers transition to completed, which stops playback and sets the UI to 'Completed.'"
}