{
  "topic": "Two Pointers — Interactive Module",
  "description": "Finite state machine modeling the interactive two-pointers visualization: array input, pointer manipulation (manual drag/keyboard/click), step-by-step comparisons, auto-play, history, and result states (found / no pair).",
  "states": [
    {
      "name": "idle",
      "onEnter": "updateUI (display status, position pointers, highlight compared boxes)",
      "onExit": "none",
      "on": {
        "APPLY_ARRAY": "applying_array",
        "APPLY_INVALID": "idle",
        "RANDOMIZE": "randomizing",
        "STEP": "stepping",
        "BACK": "history_back",
        "PLAY": "playing",
        "RESET_POINTERS": "reset_pointers",
        "RESET_LAYOUT": "reset_layout",
        "START_DRAG_LEFT": "dragging_left",
        "START_DRAG_RIGHT": "dragging_right",
        "BOX_CLICK": "manual_move",
        "EDIT_ARRAY": "editing_array",
        "EDIT_TARGET": "editing_target",
        "HELP": "help_open"
      }
    },
    {
      "name": "applying_array",
      "onEnter": "applyArrayFromInput (parseArrayInput, sort array, buildArray, pushHistory('Array applied'))",
      "onExit": "updateUI",
      "on": {
        "APPLY_SUCCESS": "idle",
        "APPLY_INVALID": "invalid_input",
        "ERROR": "idle"
      }
    },
    {
      "name": "invalid_input",
      "onEnter": "flashLog (show invalid input message)",
      "onExit": "none",
      "on": {
        "APPLY_ARRAY": "applying_array",
        "EDIT_ARRAY": "editing_array",
        "CANCEL": "idle"
      }
    },
    {
      "name": "randomizing",
      "onEnter": "randomizeArray (generate sorted array, buildArray, pushHistory('Randomized array'))",
      "onExit": "updateUI",
      "on": {
        "RANDOMIZE_DONE": "idle",
        "ERROR": "idle"
      }
    },
    {
      "name": "stepping",
      "onEnter": "stepForward (compare arr[left] + arr[right] to target, pushHistory, updateUI)",
      "onExit": "none",
      "on": {
        "FOUND_PAIR": "found",
        "POINTERS_CROSSED": "no_pair",
        "STEP_ADVANCED": "idle",
        "ERROR": "idle"
      }
    },
    {
      "name": "playing",
      "onEnter": "startPlaying (set playing=true, setInterval calling stepForward at speed)",
      "onExit": "stopPlaying (clear interval, set playing=false)",
      "on": {
        "PAUSE": "idle",
        "FOUND_PAIR": "found",
        "POINTERS_CROSSED": "no_pair",
        "SPEED_CHANGE": "playing",
        "STOP_PLAY": "idle",
        "ERROR": "idle"
      }
    },
    {
      "name": "found",
      "onEnter": "updateUI('Pair found'), pushHistory('Pair found'), stopPlaying",
      "onExit": "none",
      "on": {
        "RESET_POINTERS": "reset_pointers",
        "APPLY_ARRAY": "applying_array",
        "RANDOMIZE": "randomizing",
        "PLAY": "playing",
        "EDIT_ARRAY": "editing_array"
      }
    },
    {
      "name": "no_pair",
      "onEnter": "updateUI('Pointers crossed — no pair'), pushHistory('Pointers crossed — target not found'), stopPlaying",
      "onExit": "none",
      "on": {
        "RESET_POINTERS": "reset_pointers",
        "APPLY_ARRAY": "applying_array",
        "RANDOMIZE": "randomizing",
        "EDIT_ARRAY": "editing_array"
      }
    },
    {
      "name": "dragging_left",
      "onEnter": "set isDragging='left' (pointerdown capture), on pointermove call setLeft(desired,'drag')",
      "onExit": "clear isDragging, pushHistory('Manual pointer placement.'), updateUI",
      "on": {
        "DRAG_MOVE": "dragging_left",
        "END_DRAG": "idle",
        "CANCEL_DRAG": "idle"
      }
    },
    {
      "name": "dragging_right",
      "onEnter": "set isDragging='right' (pointerdown capture), on pointermove call setRight(desired,'drag')",
      "onExit": "clear isDragging, pushHistory('Manual pointer placement.'), updateUI",
      "on": {
        "DRAG_MOVE": "dragging_right",
        "END_DRAG": "idle",
        "CANCEL_DRAG": "idle"
      }
    },
    {
      "name": "manual_move",
      "onEnter": "setLeft or setRight (depending on nearest pointer) with origin 'manual', pushHistory, updateUI",
      "onExit": "none",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "history_back",
      "onEnter": "stepBack (pop history, restore previous left/right, found=false, updateUI)",
      "onExit": "none",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "reset_pointers",
      "onEnter": "resetPointers (left=0,right=end,found=false,pushHistory('Pointers reset')), stopPlaying",
      "onExit": "updateUI",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "reset_layout",
      "onEnter": "reset layout defaults (arr=[1..5], arrayInput, targetInput, left/right reset, history cleared, buildArray, pushHistory('Layout reset'))",
      "onExit": "updateUI",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "editing_array",
      "onEnter": "focus array input (user typing)",
      "onExit": "none",
      "on": {
        "INPUT_ENTER": "applying_array",
        "APPLY_ARRAY": "applying_array",
        "CANCEL": "idle"
      }
    },
    {
      "name": "editing_target",
      "onEnter": "focus target input (user typing)",
      "onExit": "none",
      "on": {
        "TARGET_SET": "idle",
        "CANCEL": "idle"
      }
    },
    {
      "name": "help_open",
      "onEnter": "alert(help text) (user sees quick tips)",
      "onExit": "none",
      "on": {
        "DONE": "idle"
      }
    }
  ],
  "events": [
    "APPLY_ARRAY",
    "APPLY_SUCCESS",
    "APPLY_INVALID",
    "RANDOMIZE",
    "RANDOMIZE_DONE",
    "STEP",
    "STEP_ADVANCED",
    "FOUND_PAIR",
    "POINTERS_CROSSED",
    "PLAY",
    "PAUSE",
    "STOP_PLAY",
    "BACK",
    "HISTORY_RESTORED",
    "RESET_POINTERS",
    "RESET_LAYOUT",
    "START_DRAG_LEFT",
    "START_DRAG_RIGHT",
    "DRAG_MOVE",
    "END_DRAG",
    "CANCEL_DRAG",
    "BOX_CLICK",
    "EDIT_ARRAY",
    "INPUT_ENTER",
    "INPUT_ENTER_ARRAY",
    "INPUT_ENTER_TARGET",
    "TARGET_SET",
    "EDIT_TARGET",
    "SPEED_CHANGE",
    "HELP",
    "ERROR",
    "DONE"
  ],
  "notes": "State actions reference functions and behaviors implemented in the code: parseArrayInput/applyArrayFromInput, randomizeArray, buildArray, positionPointers, updateUI, flashLog, pushHistory, stepForward, stepBack, startPlaying, stopPlaying, resetPointers, setLeft, setRight. The FSM models both user-driven transitions (clicks, drags, keyboard) and automatic transitions emitted by the stepping logic (FOUND_PAIR, POINTERS_CROSSED, STEP_ADVANCED). Dragging and manual pointer movements are modeled as separate dragging states and a manual_move transient state. 'playing' repeatedly triggers stepForward and responds to the same completion events as single stepping. Help uses a transient alert and does not persist application state. Error/invalid input paths are represented by INVALID_INPUT which shows a flash log and returns to editing/idle."
}