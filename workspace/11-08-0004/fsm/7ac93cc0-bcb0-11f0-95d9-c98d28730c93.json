{
  "topic": "Interactive Application",
  "description": "Finite state machine modeling the interactive BFS SVG application: node/edge creation modes, drag interactions, BFS run/step/pause lifecycle, visual feedback (queue/edge/node animations), resets and clearing.",
  "states": [
    {
      "name": "idle",
      "onEnter": "ensureDefaultUI (mode=null, no temporary listeners)",
      "on": {
        "CLICK_ADD_NODE_BUTTON": "awaiting_canvas_click_add_node",
        "DOUBLE_CLICK_SVG": "idle",
        "CLICK_ADD_EDGE_BUTTON": "add_edge_waiting_source",
        "CLICK_SET_START_BUTTON": "set_start_waiting",
        "CLICK_SET_TARGET_BUTTON": "set_target_waiting",
        "NODE_DRAG_START": "dragging_node",
        "CLICK_RUN_BUTTON": "bfs_running",
        "CLICK_STEP_BUTTON": "bfs_paused",
        "CLICK_RESET_BUTTON": "idle",
        "CLICK_CLEAR_BUTTON": "idle",
        "SPACE_KEY": "bfs_running"
      }
    },
    {
      "name": "awaiting_canvas_click_add_node",
      "onEnter": "attachCanvasClickListener (temporary listener that will add node on next canvas click and remove itself)",
      "onExit": "removeCanvasClickListener",
      "on": {
        "CANVAS_CLICK": "idle",
        "DOUBLE_CLICK_SVG": "idle",
        "CLICK_ADD_NODE_BUTTON": "awaiting_canvas_click_add_node",
        "NODE_DRAG_START": "dragging_node",
        "CLICK_CLEAR_BUTTON": "idle",
        "CLICK_RESET_BUTTON": "idle"
      }
    },
    {
      "name": "add_edge_waiting_source",
      "onEnter": "setMode('addEdge') (toggle UI, pendingEdgeSource=null)",
      "onExit": "setMode(null)",
      "on": {
        "CLICK_ADD_EDGE_BUTTON": "idle",
        "NODE_CLICK": "add_edge_waiting_target",
        "NODE_DRAG_START": "dragging_node",
        "CLICK_CLEAR_BUTTON": "idle",
        "CLICK_RESET_BUTTON": "idle"
      }
    },
    {
      "name": "add_edge_waiting_target",
      "onEnter": "highlightNode(pendingEdgeSource,true)",
      "onExit": "highlightNode(pendingEdgeSource,false)",
      "on": {
        "NODE_CLICK": "add_edge_waiting_source",
        "CLICK_ADD_EDGE_BUTTON": "idle",
        "NODE_DRAG_START": "dragging_node",
        "CLICK_CLEAR_BUTTON": "idle",
        "CLICK_RESET_BUTTON": "idle"
      }
    },
    {
      "name": "set_start_waiting",
      "onEnter": "setMode('setStart') (toggle UI, awaiting node click)",
      "onExit": "setMode(null)",
      "on": {
        "NODE_CLICK": "idle",
        "CLICK_SET_START_BUTTON": "idle",
        "NODE_DRAG_START": "dragging_node",
        "CLICK_CLEAR_BUTTON": "idle",
        "CLICK_RESET_BUTTON": "idle"
      }
    },
    {
      "name": "set_target_waiting",
      "onEnter": "setMode('setTarget') (toggle UI, awaiting node click)",
      "onExit": "setMode(null)",
      "on": {
        "NODE_CLICK": "idle",
        "CLICK_SET_TARGET_BUTTON": "idle",
        "NODE_DRAG_START": "dragging_node",
        "CLICK_CLEAR_BUTTON": "idle",
        "CLICK_RESET_BUTTON": "idle"
      }
    },
    {
      "name": "dragging_node",
      "onEnter": "startDrag (attach mousemove/mouseup listeners, compute offsets)",
      "onExit": "endDrag (remove listeners)",
      "on": {
        "NODE_DRAG_MOVE": "dragging_node",
        "NODE_DRAG_END": "RETURN_PREVIOUS"
      }
    },
    {
      "name": "bfs_running",
      "onEnter": "runBFS (create BFS state, set running=true, resetVisualState then scheduleNextStep)",
      "onExit": "stopRun (clear timers, running=false)",
      "on": {
        "BFS_STEP_COMPLETE": "bfs_running",
        "BFS_FOUND_TARGET": "bfs_done_path",
        "BFS_COMPLETE_NO_TARGET": "bfs_done_notfound",
        "SPACE_KEY": "bfs_paused",
        "CLICK_RESET_BUTTON": "idle",
        "CLICK_CLEAR_BUTTON": "idle",
        "NODE_DRAG_START": "dragging_node"
      }
    },
    {
      "name": "bfs_paused",
      "onEnter": "pauseBFS (running=false, keep bfsState for stepping)",
      "onExit": "resumeBFS (if resuming via run, scheduleNextStep)",
      "on": {
        "CLICK_STEP_BUTTON": "bfs_paused",
        "CLICK_RUN_BUTTON": "bfs_running",
        "SPACE_KEY": "bfs_running",
        "CLICK_RESET_BUTTON": "idle",
        "CLICK_CLEAR_BUTTON": "idle",
        "NODE_DRAG_START": "dragging_node"
      }
    },
    {
      "name": "bfs_done_path",
      "onEnter": "reconstructPath & highlight (visualize node-path & highlight edges), stopRun",
      "on": {
        "CLICK_RESET_BUTTON": "idle",
        "CLICK_CLEAR_BUTTON": "idle",
        "CLICK_RUN_BUTTON": "bfs_running",
        "CLICK_STEP_BUTTON": "bfs_paused",
        "NODE_DRAG_START": "dragging_node"
      }
    },
    {
      "name": "bfs_done_notfound",
      "onEnter": "finalizeNoPath (log not found, stopRun)",
      "on": {
        "CLICK_RESET_BUTTON": "idle",
        "CLICK_CLEAR_BUTTON": "idle",
        "CLICK_RUN_BUTTON": "bfs_running",
        "CLICK_STEP_BUTTON": "bfs_paused",
        "NODE_DRAG_START": "dragging_node"
      }
    }
  ],
  "events": [
    "CLICK_ADD_NODE_BUTTON",
    "CANVAS_CLICK",
    "DOUBLE_CLICK_SVG",
    "CLICK_ADD_EDGE_BUTTON",
    "CLICK_SET_START_BUTTON",
    "CLICK_SET_TARGET_BUTTON",
    "NODE_CLICK",
    "NODE_DRAG_START",
    "NODE_DRAG_MOVE",
    "NODE_DRAG_END",
    "CLICK_RUN_BUTTON",
    "CLICK_STEP_BUTTON",
    "CLICK_RESET_BUTTON",
    "CLICK_CLEAR_BUTTON",
    "SPACE_KEY",
    "SPEED_CHANGED",
    "BFS_STEP_COMPLETE",
    "BFS_FOUND_TARGET",
    "BFS_COMPLETE_NO_TARGET",
    "EDGE_CREATED"
  ],
  "notes": "Guards and implementation details: \n- CLICK_RUN_BUTTON requires a start node to be set (the code alerts if none). In this FSM the transition to bfs_running assumes that precondition is satisfied. \n- NODE_CLICK carries a payload (node id). In add_edge mode the first NODE_CLICK selects pendingEdgeSource and transitions to add_edge_waiting_target; the second NODE_CLICK either cancels selection (if same node) or creates an undirected edge and returns to add_edge_waiting_source while remaining in addEdge mode. \n- Add-node via CLICK_ADD_NODE_BUTTON attaches a one-time canvas click listener; that is modeled as awaiting_canvas_click_add_node and returns to idle after node creation. DOUBLE_CLICK_SVG immediately adds a node and stays in the current mode (mode unchanged). \n- Dragging is modeled as an orthogonal/transient state (dragging_node). In the real implementation drag does not clear the active mode; on DRAG_END the UI returns to the prior mode. The special 'RETURN_PREVIOUS' outcome above indicates returning to whatever interactive mode was active before drag started. \n- BFS lifecycle: runBFS creates bfsState and uses a timer loop (scheduleNextStep) to repeatedly fire performBFSStep. Each perform step emits visual actions: animateDequeue, animateEnqueue, pulseEdge, highlight node classes. When the queue empties or target found the BFS finishes (bfs_done_notfound or bfs_done_path). \n- Step mode (CLICK_STEP_BUTTON) creates bfsState if absent and executes a single performBFSStep; the app then remains paused (bfs_paused) with bfsState retained for subsequent steps. \n- CLICK_RESET_BUTTON calls stopRun and resetVisualState (clears bfsState and animations) and returns to idle. CLICK_CLEAR_BUTTON removes all nodes/edges and resets start/target; modeled as returning to idle. \n- SPEED_CHANGED affects timing between BFS steps but does not change FSM state. \n- The FSM intentionally abstracts animation-specific micro-states (individual enqueue/dequeue animation frames) into their parent BFS states; animateEnqueue/animateDequeue/pulseEdge are listed as onEnter/onExit actions where relevant (described in state onEnter handlers)."
}