{
  "topic": "Bellman–Ford Interactive Module",
  "description": "Finite state machine modeling UI interaction modes and algorithm execution states for the Bellman–Ford interactive tutorial (node/edge editing, mode toggles, single-step / auto-run algorithm execution, animations and negative-cycle detection).",
  "states": [
    {
      "name": "idle",
      "onEnter": "setModeIdle / updateUI",
      "onExit": "none",
      "on": {
        "TOGGLE_ADD_NODE": "addNode",
        "TOGGLE_ADD_EDGE": "addEdge",
        "TOGGLE_SET_SOURCE": "setSource",
        "NODE_MOUSEDOWN": "dragging",
        "STEP_CLICK": "stepping",
        "AUTO_TOGGLE": "auto_running",
        "PRESET_LOAD": "idle",
        "CLEAR": "idle",
        "FAST_TOGGLE": "idle",
        "EDGE_CLICK_EDIT": "idle"
      }
    },
    {
      "name": "addNode",
      "onEnter": "setModeAddNode / overlay.pointerEvents = 'auto' / updateUI",
      "onExit": "overlay.pointerEvents = 'none' / updateUI",
      "on": {
        "TOGGLE_ADD_NODE": "idle",
        "SVG_CLICK": "addNode",
        "NODE_MOUSEDOWN": "dragging",
        "TOGGLE_ADD_EDGE": "addEdge",
        "TOGGLE_SET_SOURCE": "setSource",
        "STEP_CLICK": "stepping",
        "AUTO_TOGGLE": "auto_running",
        "PRESET_LOAD": "idle",
        "CLEAR": "idle",
        "FAST_TOGGLE": "addNode"
      }
    },
    {
      "name": "addEdge",
      "onEnter": "setModeAddEdge / selectedForEdge = null / updateUI",
      "onExit": "selectedForEdge = null / updateUI",
      "on": {
        "TOGGLE_ADD_EDGE": "idle",
        "NODE_CLICK": "addEdgeSourceSelected",
        "STEP_CLICK": "stepping",
        "AUTO_TOGGLE": "auto_running",
        "PRESET_LOAD": "idle",
        "CLEAR": "idle",
        "FAST_TOGGLE": "addEdge"
      }
    },
    {
      "name": "addEdgeSourceSelected",
      "onEnter": "markSelectedSource (selectedForEdge set) / message('Selected source: ...')",
      "onExit": "clearSelectedForEdge",
      "on": {
        "NODE_CLICK": "addEdge",
        "TOGGLE_ADD_EDGE": "idle",
        "STEP_CLICK": "stepping",
        "AUTO_TOGGLE": "auto_running",
        "CLEAR": "idle"
      }
    },
    {
      "name": "setSource",
      "onEnter": "setModeSetSource / updateUI",
      "onExit": "updateUI",
      "on": {
        "TOGGLE_SET_SOURCE": "idle",
        "NODE_CLICK": "setSource",
        "STEP_CLICK": "stepping",
        "AUTO_TOGGLE": "auto_running",
        "PRESET_LOAD": "idle",
        "CLEAR": "idle",
        "FAST_TOGGLE": "setSource"
      }
    },
    {
      "name": "dragging",
      "onEnter": "startDrag (attach mousemove/mouseup listeners) / updateUI",
      "onExit": "stopDrag (remove listeners) / resetAlgorithmState / updateUI",
      "on": {
        "NODE_MOUSEMOVE": "dragging",
        "NODE_MOUSEUP": "idle",
        "NODE_MOUSEDOWN": "dragging"
      }
    },
    {
      "name": "stepping",
      "onEnter": "performStep (relaxEdgeAt(edgeIndex, detectionMode=false)) / animateEdgeFlash('relax')",
      "onExit": "updateUI / renderDistanceTable",
      "on": {
        "RELAX_IMPROVED": "idle",
        "RELAX_NOCHANGE": "idle",
        "RELAX_COMPLETE": "idle",
        "NEG_CYCLE_DETECTED": "detecting"
      }
    },
    {
      "name": "detecting",
      "onEnter": "performStep (relaxEdgeAt(edgeIndex, detectionMode=true)) / animateEdgeFlash('detect')",
      "onExit": "updateUI",
      "on": {
        "NEG_CYCLE_DETECTED": "detecting",
        "RELAX_COMPLETE": "idle",
        "RELAX_NOCHANGE": "idle"
      }
    },
    {
      "name": "auto_running",
      "onEnter": "startAuto (sets autoTimer, autoBtn text='Stop')",
      "onExit": "stopAuto (clearInterval, autoTimer=null, autoBtn text='Auto')",
      "on": {
        "AUTO_TOGGLE": "idle",
        "AUTO_FINISHED": "finished",
        "STEP_CLICK": "stepping",
        "PRESET_LOAD": "idle",
        "CLEAR": "idle",
        "FAST_TOGGLE": "auto_running",
        "NEG_CYCLE_DETECTED": "detecting"
      }
    },
    {
      "name": "finished",
      "onEnter": "message('Algorithm finished.') / set finished UI state",
      "onExit": "resetAlgorithmState",
      "on": {
        "RESET": "idle",
        "PRESET_LOAD": "idle",
        "CLEAR": "idle",
        "TOGGLE_ADD_NODE": "addNode",
        "TOGGLE_ADD_EDGE": "addEdge",
        "TOGGLE_SET_SOURCE": "setSource"
      }
    },
    {
      "name": "addNode (action)",
      "onEnter": "addNodeAtPoint(x,y) / resetAlgorithmState / renderDistanceTable / message('Added node')",
      "onExit": "updateUI",
      "on": {
        "DONE": "addNode"
      }
    },
    {
      "name": "addEdge (action)",
      "onEnter": "createEdge(from,to,weight) / resetAlgorithmState / renderDistanceTable / message('Added edge')",
      "onExit": "updateUI",
      "on": {
        "DONE": "addEdge"
      }
    },
    {
      "name": "edgeEdit",
      "onEnter": "promptEditEdgeWeight / updateEdgeWeight / resetAlgorithmState / renderDistanceTable",
      "onExit": "updateUI",
      "on": {
        "DONE": "idle"
      }
    }
  ],
  "events": [
    "TOGGLE_ADD_NODE",
    "TOGGLE_ADD_EDGE",
    "TOGGLE_SET_SOURCE",
    "SVG_CLICK",
    "NODE_MOUSEDOWN",
    "NODE_MOUSEMOVE",
    "NODE_MOUSEUP",
    "NODE_CLICK",
    "STEP_CLICK",
    "AUTO_TOGGLE",
    "AUTO_STARTED",
    "AUTO_FINISHED",
    "PRESET_LOAD",
    "CLEAR",
    "FAST_TOGGLE",
    "EDGE_CLICK_EDIT",
    "RELAX_IMPROVED",
    "RELAX_NOCHANGE",
    "RELAX_COMPLETE",
    "NEG_CYCLE_DETECTED",
    "RESET",
    "DRAG_START",
    "DRAG_END",
    "DONE"
  ],
  "notes": "This FSM separates the interactive UI modes (idle, add-node, add-edge, set-source, dragging) from the algorithm execution behaviors (single-step relaxation, detection pass, auto-run). Several actions in the real implementation are asynchronous (edge relaxation animation, flashing, and distance-row highlight). 'stepping' and 'detecting' represent transient algorithm-execution states entered when the user requests a step or the auto-run triggers a step; after the individual relaxation completes the FSM returns to the prior UI mode (represented here as transitions back to 'idle' for simplicity). startAuto/stopAuto manage a repeating timer; auto_running repeatedly triggers step actions until completion. Many user actions (adding/removing nodes or edges, loading presets, dragging nodes) call resetAlgorithmState() which stops auto-run, resets distances/preds/iteration counters and clears visual edge highlight states. Edge-weight edits, new nodes/edges and node movement both invoke resetAlgorithmState and update the distance table. Negative-cycle detection is modeled by the 'detecting' state and by NEG_CYCLE_DETECTED events which cause edges to be highlighted in red and a message to be shown."
}