{
  "topic": "Sliding Window Interactive Module",
  "description": "Models the interactive behavior of a sliding-window visualization: editing the array, changing window size, stepping/playing the animation, dragging the window, and toggling computation modes and math display.",
  "states": [
    {
      "name": "idle",
      "onEnter": "renderUI",
      "onExit": "clearTransientUI",
      "on": {
        "STEP_FORWARD": "stepping",
        "STEP_BACK": "steppingBack",
        "PLAY_TOGGLE_TRUE": "playing",
        "PLAY_TOGGLE_FALSE": "idle",
        "CLICK_CELL": "updatingStart",
        "APPLY_ARRAY": "applying",
        "RANDOMIZE_ARRAY": "randomizing",
        "CHANGE_K": "recomputing",
        "RESET": "recomputing",
        "MODE_TOGGLE": "idle",
        "SHOW_MATH_TOGGLE": "idle",
        "DRAG_START": "dragging",
        "RESIZE": "idle"
      }
    },
    {
      "name": "playing",
      "onEnter": "startPlayTimer",
      "onExit": "stopPlayTimer",
      "on": {
        "TICK": "stepping",
        "PLAY_TOGGLE_FALSE": "idle",
        "DRAG_START": "dragging",
        "RESET": "recomputing",
        "APPLY_ARRAY": "applying",
        "RANDOMIZE_ARRAY": "randomizing",
        "CHANGE_K": "recomputing"
      }
    },
    {
      "name": "stepping",
      "onEnter": "doStepForward",
      "onExit": "finishStepAnimation",
      "on": {
        "ANIMATION_COMPLETE": "idle",
        "REACH_END": "atEnd",
        "PLAYING_CONTINUE": "playing"
      }
    },
    {
      "name": "steppingBack",
      "onEnter": "doStepBack",
      "onExit": "finishStepAnimation",
      "on": {
        "ANIMATION_COMPLETE": "idle"
      }
    },
    {
      "name": "dragging",
      "onEnter": "prepareDrag",
      "onExit": "finalizeDrag",
      "on": {
        "DRAG_MOVE": "dragging",
        "DRAG_END": "idle",
        "PLAY_TOGGLE_FALSE": "idle",
        "PLAY_TOGGLE_TRUE": "playing"
      }
    },
    {
      "name": "updatingStart",
      "onEnter": "updateStartAndRecompute",
      "onExit": "finishUpdate",
      "on": {
        "UPDATE_COMPLETE": "idle"
      }
    },
    {
      "name": "applying",
      "onEnter": "applyArrayInput",
      "onExit": "finishApply",
      "on": {
        "APPLY_COMPLETE": "recomputing"
      }
    },
    {
      "name": "randomizing",
      "onEnter": "generateRandomArray",
      "onExit": "finishRandomize",
      "on": {
        "RANDOMIZE_COMPLETE": "recomputing"
      }
    },
    {
      "name": "recomputing",
      "onEnter": "computeInitialWindowSum",
      "onExit": "updateUI",
      "on": {
        "RECOMPUTE_COMPLETE": "idle"
      }
    },
    {
      "name": "atEnd",
      "onEnter": "handleReachedEnd",
      "onExit": "clearEndFlag",
      "on": {
        "PLAY_TOGGLE_FALSE": "idle",
        "RESET": "recomputing",
        "STEP_BACK": "steppingBack",
        "CLICK_CELL": "updatingStart",
        "APPLY_ARRAY": "applying"
      }
    }
  ],
  "events": [
    "STEP_FORWARD",
    "STEP_BACK",
    "PLAY_TOGGLE_TRUE",
    "PLAY_TOGGLE_FALSE",
    "TICK",
    "CLICK_CELL",
    "APPLY_ARRAY",
    "RANDOMIZE_ARRAY",
    "CHANGE_K",
    "RESET",
    "MODE_TOGGLE",
    "SHOW_MATH_TOGGLE",
    "DRAG_START",
    "DRAG_MOVE",
    "DRAG_END",
    "RESIZE",
    "ANIMATION_COMPLETE",
    "REACH_END",
    "APPLY_COMPLETE",
    "RANDOMIZE_COMPLETE",
    "RECOMPUTE_COMPLETE",
    "UPDATE_COMPLETE",
    "KEY_LEFT",
    "KEY_RIGHT"
  ],
  "notes": "State/actions mapping captures the app's user-driven transitions and side effects.\n- idle: default interactive state. renderUI performs renderArray/syncWindowRect and updates UI cards.\n- playing: onEnter startPlayTimer sets interval (800ms) to emit TICK. onExit clears the timer.\n- stepping: performs stepForward computation (chooses sliding update or naive recompute depending on mode), updates currentSum, best, animates numbers/highlights, and then signals ANIMATION_COMPLETE. If step reached the last possible window position, stepping emits REACH_END which transitions to atEnd and stops play.\n- steppingBack: performs stepBack which recomputes the sum and animates; returns to idle when complete.\n- dragging: onEnter disables smooth transition for the window overlay (windowRect.style.transition='none') and captures pointer/touch. DRAG_MOVE updates start visually. DRAG_END triggers recompute of the window sum and updateUI. Note: in implementation dragging does not automatically stop the play state; the app retains the playing flag. The FSM maps DRAG_END to idle for a simple normalized flow; in reality the next state should be idle or playing depending on the playing flagâ€”this conditional behavior is handled by the implementation.\n- applying/randomizing/recomputing/updatingStart: atomic transitions that parse/set array, set k and start, recompute initial sums (computeInitial/recomputeWindowSum) and then update UI. These states perform input validation and then emit completion events (APPLY_COMPLETE, RANDOMIZE_COMPLETE, RECOMPUTE_COMPLETE, UPDATE_COMPLETE) which transition back to idle (or recomputing in the case of APPLY -> RECOMPUTE).\n- atEnd: represents the UI when the window is at the final valid start position. Step forward from atEnd is a no-op; playing is stopped when REACH_END is reached.\n- Events KEY_LEFT/KEY_RIGHT map to STEP_BACK and STEP_FORWARD respectively (keyboard shortcuts in code).\n- The FSM intentionally treats small animations (animateNumber, animateHighlightChange) as internal actions associated with states like stepping; they are represented by ANIMATION_COMPLETE which returns to idle.\n- Conditional transitions (e.g., DRAG_END returning to playing vs idle, stepping finishing and returning to playing when the play flag is still set) are noted here: the real code uses runtime flags (playing) to decide whether to resume/continue playback. In this FSM those conditions are indicated by events PLAYING_CONTINUE or by mapping DRAG_END to either idle or playing depending on the playing flag.\n- Accessibility and resize events trigger UI synchronization (RESIZE -> idle path mapped to renderUI)."
}