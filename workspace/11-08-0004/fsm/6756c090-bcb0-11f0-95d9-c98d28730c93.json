{
  "topic": "Binary Tree Interactive Module",
  "description": "Models the interactive states and transitions for a browser-based Binary Search Tree explorer: inserting/deleting nodes, random fill, traversal animations, rendering/layout, and UI interactions.",
  "states": [
    {
      "name": "empty",
      "onEnter": "render(true); updateStats(); announce('Empty tree. Insert nodes to begin.')",
      "on": {
        "CLICK_INSERT": "inserting",
        "VALUE_ENTER": "inserting",
        "CLICK_RANDOM_FILL": "randomFilling",
        "CLICK_CLEAR": "empty",
        "CLICK_TRAVERSE": "empty",
        "CLICK_AUTO_LAYOUT": "rendering",
        "CLICK_EXPORT": "exporting",
        "RESIZE": "rendering"
      }
    },
    {
      "name": "ready",
      "onEnter": "render(true); updateStats(); announce('Tree ready.')",
      "on": {
        "CLICK_INSERT": "inserting",
        "VALUE_ENTER": "inserting",
        "CLICK_DELETE": "deleting",
        "CLICK_CLEAR": "empty",
        "CLICK_RANDOM_FILL": "randomFilling",
        "CLICK_TRAVERSE": "traversing",
        "CLICK_AUTO_LAYOUT": "rendering",
        "CLICK_EXPORT": "exporting",
        "NODE_CLICK": "selecting_node",
        "NODE_HOVER_ENTER": "hovering",
        "NODE_HOVER_LEAVE": "ready",
        "SPEED_CHANGE": "ready",
        "RESIZE": "rendering"
      }
    },
    {
      "name": "inserting",
      "onEnter": "insertValue(parseInt(valueInput.value,10))  // starts async insertion and animateInsertionPath when necessary",
      "onExit": "updateStats(); render(true)",
      "on": {
        "INSERT_SUCCESS": "ready",
        "INSERT_DUPLICATE": "ready",
        "CLICK_CLEAR": "empty",
        "CLICK_RANDOM_FILL": "randomFilling",
        "CLICK_TRAVERSE": "traversing",
        "RESIZE": "rendering"
      }
    },
    {
      "name": "deleting",
      "onEnter": "deleteValue(parseInt(valueInput.value,10))  // performs BST delete, rebuilds map, render(true), announce",
      "onExit": "updateStats(); render(true)",
      "on": {
        "DELETE_SUCCESS": "ready",
        "DELETE_RESULT_EMPTY": "empty",
        "DELETE_NOT_FOUND": "ready",
        "CLICK_CLEAR": "empty",
        "RESIZE": "rendering"
      }
    },
    {
      "name": "randomFilling",
      "onEnter": "fillRandom(parseInt(randomCount.value,10)||6)  // starts async sequence of insertions",
      "onExit": "updateStats(); render(true)",
      "on": {
        "RANDOM_FILL_STEP": "randomFilling",
        "RANDOM_FILL_COMPLETE": "ready",
        "CLICK_CLEAR": "empty",
        "RESIZE": "rendering"
      }
    },
    {
      "name": "traversing",
      "onEnter": "runTraversal(traversalSelect.value)  // animates traversal; marks nodes current/visited, announces steps",
      "onExit": "clearMarkers(); updateStats(); render(true)",
      "on": {
        "TRAVERSAL_STEP": "traversing",
        "TRAVERSAL_COMPLETE": "ready",
        "CLICK_CLEAR": "empty",
        "CLICK_INSERT": "inserting",
        "RESIZE": "rendering"
      }
    },
    {
      "name": "rendering",
      "onEnter": "render(true)  // computeLayout, drawEdges, drawNodes and adjust svg size",
      "onExit": "announce('Auto layout performed.')",
      "on": {
        "RENDER_DONE": "ready",
        "CLICK_EXPORT": "exporting",
        "RESIZE": "rendering"
      }
    },
    {
      "name": "exporting",
      "onEnter": "copySVG(); announce('SVG copied to clipboard (if supported).')",
      "onExit": "announce('Export complete.')",
      "on": {
        "EXPORT_DONE": "ready",
        "CLICK_CLEAR": "empty",
        "RESIZE": "rendering"
      }
    },
    {
      "name": "selecting_node",
      "onEnter": "flashNode(nodeId) // sets valueInput.value = node.val; announce('Selected X')",
      "onExit": "clearMarkers()",
      "on": {
        "SELECTED_DONE": "ready",
        "NODE_HOVER_ENTER": "hovering",
        "CLICK_DELETE": "deleting",
        "CLICK_INSERT": "inserting"
      }
    },
    {
      "name": "hovering",
      "onEnter": "highlightNode(nodeId)  // adds hover visual feedback",
      "onExit": "unhighlightNode(nodeId)",
      "on": {
        "NODE_HOVER_LEAVE": "ready",
        "NODE_CLICK": "selecting_node",
        "CLICK_CLEAR": "empty"
      }
    }
  ],
  "events": [
    "CLICK_INSERT",
    "VALUE_ENTER",
    "INSERT_SUCCESS",
    "INSERT_DUPLICATE",
    "CLICK_DELETE",
    "DELETE_SUCCESS",
    "DELETE_NOT_FOUND",
    "DELETE_RESULT_EMPTY",
    "CLICK_CLEAR",
    "CLICK_RANDOM_FILL",
    "RANDOM_FILL_STEP",
    "RANDOM_FILL_COMPLETE",
    "CLICK_TRAVERSE",
    "TRAVERSAL_STARTED",
    "TRAVERSAL_STEP",
    "TRAVERSAL_COMPLETE",
    "CLICK_AUTO_LAYOUT",
    "AUTO_LAYOUT_DONE",
    "CLICK_EXPORT",
    "EXPORT_DONE",
    "NODE_CLICK",
    "NODE_HOVER_ENTER",
    "NODE_HOVER_LEAVE",
    "SPEED_CHANGE",
    "RESIZE",
    "RENDER_REQUEST",
    "RENDER_DONE",
    "SELECTED_DONE",
    "ANNOUNCE"
  ],
  "notes": "States map to UI modes in the original code. Many actions are asynchronous (insertValue, fillRandom, runTraversal) and produce internal step events (e.g., TRAVERSAL_STEP, RANDOM_FILL_STEP). Rendering/layout is performed by render(true) which computes layout and updates SVG; it is modeled as a transient 'rendering' state that returns to 'ready'. Hovering and node selection are modeled as short-lived sub-states that produce visual highlight/flash actions. The real implementation does not strictly block other button presses during animations; the FSM models preferred transitions and completion events (e.g., INSERT_SUCCESS, TRAVERSAL_COMPLETE) that the async functions implicitly produce when finished."
}