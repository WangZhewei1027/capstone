{
  "topic": "Quick Sort Interactive Module",
  "description": "Finite state machine modelling the interactive Quick Sort visualizer: user controls, algorithm action stream, animations, editing and configuration changes.",
  "states": [
    {
      "name": "idle",
      "onEnter": "updateStatus('Idle'); clearHighlights(); highlightPseudocode(null)",
      "onExit": "",
      "on": {
        "PLAY": "running",
        "STEP": "actionHandling",
        "RESET": "idle_reset",
        "SHUFFLE": "idle_shuffle",
        "SIZE_CHANGE": "idle_resize",
        "PIVOT_CHANGE": "idle_config",
        "SPEED_CHANGE": "idle_config",
        "EDIT_START": "editing",
        "KEY_SPACE": "running",
        "KEY_RIGHT": "actionHandling"
      }
    },
    {
      "name": "idle_reset",
      "onEnter": "resetAlgorithmState(); renderArray(true)",
      "onExit": "",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "idle_shuffle",
      "onEnter": "array = randomArray(arraySize); initialArray = array.slice(); resetAlgorithmState(); renderArray(true)",
      "onExit": "",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "idle_resize",
      "onEnter": "arraySize = parseInt(sizeRange.value,10); sizeLabel.textContent = arraySize; array = randomArray(arraySize); initialArray = array.slice(); resetAlgorithmState(); renderArray(true)",
      "onExit": "",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "idle_config",
      "onEnter": "applyConfigChanges()",
      "onExit": "",
      "on": {
        "DONE": "idle"
      }
    },
    {
      "name": "running",
      "onEnter": "running=true; playBtn.textContent='Pause'; playBtn.setAttribute('aria-pressed','true'); runLoop()",
      "onExit": "running=false; playBtn.textContent='Play'; playBtn.setAttribute('aria-pressed','false')",
      "on": {
        "PAUSE": "idle",
        "STEP": "actionHandling",
        "RESET": "idle_reset",
        "SHUFFLE": "idle_shuffle",
        "SIZE_CHANGE": "idle_resize",
        "PIVOT_CHANGE": "idle_config",
        "SPEED_CHANGE": "idle_config",
        "ACTION_STACK": "stackUpdate",
        "ACTION_SET_PIVOT": "pivotSelected",
        "ACTION_PARTITION_BEGIN": "partitioning",
        "ACTION_COMPARE": "comparing",
        "ACTION_SWAP": "swapping",
        "ACTION_PARTITION_DONE": "partitionDone",
        "ACTION_MARK_SORTED": "markingSorted",
        "ACTION_DONE": "done",
        "KEY_SPACE": "idle",
        "KEY_RIGHT": "actionHandling"
      }
    },
    {
      "name": "actionHandling",
      "onEnter": "consumeNextGeneratorAction()  // synchronous call to actionGenerator.next() leading to an ACTION_* event",
      "onExit": "",
      "on": {
        "ACTION_STACK": "stackUpdate",
        "ACTION_SET_PIVOT": "pivotSelected",
        "ACTION_PARTITION_BEGIN": "partitioning",
        "ACTION_COMPARE": "comparing",
        "ACTION_SWAP": "swapping",
        "ACTION_PARTITION_DONE": "partitionDone",
        "ACTION_MARK_SORTED": "markingSorted",
        "ACTION_DONE": "done",
        "NO_ACTION": "idle"
      }
    },
    {
      "name": "stackUpdate",
      "onEnter": "populateStack(payload.stack)",
      "onExit": "",
      "on": {
        "CONTINUE": "running",
        "PAUSE_AFTER_STEP": "idle"
      }
    },
    {
      "name": "pivotSelected",
      "onEnter": "highlightPivot(payload.index); highlightPseudocode(11); updateStatus('Selected pivot at index ' + payload.index)",
      "onExit": "",
      "on": {
        "CONTINUE": "running",
        "PAUSE_AFTER_STEP": "idle"
      }
    },
    {
      "name": "partitioning",
      "onEnter": "highlightPseudocode(12); updateStatus(`Partitioning range [${payload.lo}, ${payload.hi}]`); populateStack([{lo:payload.lo,hi:payload.hi}])",
      "onExit": "",
      "on": {
        "CONTINUE": "running",
        "PAUSE_AFTER_STEP": "idle"
      }
    },
    {
      "name": "comparing",
      "onEnter": "highlightCompare(payload.i, payload.j); highlightPseudocode(14); updateStatus('Compare index ' + payload.i + ' with pivot')",
      "onExit": "clearHighlights()",
      "on": {
        "CONTINUE": "running",
        "PAUSE_AFTER_STEP": "idle"
      }
    },
    {
      "name": "swapping",
      "onEnter": "highlightPseudocode(14); updateStatus('Swapping index ' + payload.i + ' and ' + payload.j); animating=true; animateSwap(payload.i, payload.j, 'swap')",
      "onExit": "animating=false; renderArray(); clearHighlights()",
      "on": {
        "ANIMATION_END": "postSwap"
      }
    },
    {
      "name": "postSwap",
      "onEnter": "/// post-swap cleanup already done in onExit of swapping",
      "onExit": "",
      "on": {
        "CONTINUE": "running",
        "PAUSE_AFTER_STEP": "idle"
      }
    },
    {
      "name": "partitionDone",
      "onEnter": "highlightPseudocode(15); markSortedRange(payload.p, payload.p); updateStatus('Partition complete. Pivot placed at ' + payload.p); wait(220 / speed)",
      "onExit": "",
      "on": {
        "CONTINUE": "running",
        "PAUSE_AFTER_STEP": "idle"
      }
    },
    {
      "name": "markingSorted",
      "onEnter": "markSortedRange(payload.lo, payload.hi); updateStatus('Element(s) ['+payload.lo+','+payload.hi+'] marked sorted')",
      "onExit": "",
      "on": {
        "CONTINUE": "running",
        "PAUSE_AFTER_STEP": "idle"
      }
    },
    {
      "name": "done",
      "onEnter": "updateStatus('Array sorted'); markSortedRange(0, array.length-1); highlightPseudocode(null); running=false; playBtn.textContent='Play'; playBtn.setAttribute('aria-pressed','false')",
      "onExit": "",
      "on": {
        "RESET": "idle_reset",
        "SHUFFLE": "idle_shuffle",
        "SIZE_CHANGE": "idle_resize"
      }
    },
    {
      "name": "editing",
      "onEnter": "promptEdit()  // triggers prompt; on confirm -> EDIT_CONFIRM, on cancel -> EDIT_CANCEL",
      "onExit": "renderArray(true); resetAlgorithmState()",
      "on": {
        "EDIT_CONFIRM": "idle",
        "EDIT_CANCEL": "idle"
      }
    }
  ],
  "events": [
    "PLAY",
    "PAUSE",
    "STEP",
    "RESET",
    "SHUFFLE",
    "SIZE_CHANGE",
    "SPEED_CHANGE",
    "PIVOT_CHANGE",
    "EDIT_START",
    "EDIT_CONFIRM",
    "EDIT_CANCEL",
    "KEY_SPACE",
    "KEY_RIGHT",
    "ACTION_STACK",
    "ACTION_SET_PIVOT",
    "ACTION_PARTITION_BEGIN",
    "ACTION_COMPARE",
    "ACTION_SWAP",
    "ACTION_PARTITION_DONE",
    "ACTION_MARK_SORTED",
    "ACTION_DONE",
    "ANIMATION_END",
    "CONTINUE",
    "PAUSE_AFTER_STEP",
    "NO_ACTION"
  ],
  "notes": "This FSM models both user-driven states (idle, running, editing, config changes) and algorithm-driven action states produced by the quickSortActions generator (stack, setPivot, partitionBegin, compare, swap, partitionDone, markSorted, done). 'running' starts the asynchronous runLoop which repeatedly consumes generator actions; each ACTION_* event maps to an algorithm substate that performs visual updates (highlightPseudocode, highlightPivot, highlightCompare, animateSwap, markSortedRange, populateStack). Swaps use a FLIP-style animation (animateSwap) and set 'animating' during the transition; the FSM represents this as the 'swapping' (animating) state and expects an ANIMATION_END event on completion. Step (STEP or KEY_RIGHT) consumes exactly one generator action (actionHandling -> corresponding action state) and then returns to idle (PAUSE_AFTER_STEP) unless running is active, in which case CONTINUE returns to 'running'. Configuration changes (size/speed/pivot) and shuffle/reset reinitialize the generator and array (resetAlgorithmState) and render the array. The mapping from the generator's next() to ACTION_* events is runtime-driven (consumeNextGeneratorAction())."
}