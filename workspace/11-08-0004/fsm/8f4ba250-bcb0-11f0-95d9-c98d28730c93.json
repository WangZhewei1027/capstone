{
  "topic": "Topological Sort Interactive Application (Kahn's Algorithm)",
  "description": "Models the interactive UI states for building a directed graph and stepping/autoplaying Kahn's topological sort. Captures editing gestures (adding/removing nodes/edges, dragging), the add-edge flow, algorithm initialization, single-step processing (with animation substeps), autoplay, cycle detection and completion.",
  "states": [
    {
      "name": "idle",
      "onEnter": "enableEditing",
      "onExit": "clearTransientHighlights",
      "on": {
        "ADD_NODE_CLICK": "idle",
        "ADD_NODE_DBLCLICK": "idle",
        "ADD_EDGE_TOGGLE": "adding_edge",
        "STEP_CLICK": "algo_processing_step",
        "AUTO_TOGGLE_START": "autoplay_running",
        "RESET_ALGO_CLICK": "idle",
        "CLEAR_CLICK_CONFIRMED": "idle",
        "CLEAR_CLICK_CANCELLED": "idle",
        "EDGE_CLICK_REMOVE": "idle",
        "NODE_DELETE": "idle",
        "GRAPH_MODIFIED": "idle",
        "NODE_POINTER_DOWN": "dragging"
      }
    },
    {
      "name": "adding_edge",
      "onEnter": "toggleAddEdgeMode(true)",
      "onExit": "toggleAddEdgeMode(false)",
      "on": {
        "NODE_CLICK": "edge_selected",
        "NODE_CLICK_WHEN_SOURCE_SET": "idle",
        "GRAPH_CLICK_CANCEL_ADD_EDGE": "idle",
        "ADD_EDGE_TOGGLE": "idle",
        "RESET_ALGO_CLICK": "adding_edge",
        "CLEAR_CLICK_CONFIRMED": "idle",
        "EDGE_CLICK_REMOVE": "adding_edge"
      }
    },
    {
      "name": "edge_selected",
      "onEnter": "markEdgeSource",
      "onExit": "clearEdgeSourceMark",
      "on": {
        "NODE_CLICK": "idle",
        "NODE_CLICK_SAME_AS_SOURCE": "idle",
        "GRAPH_CLICK_CANCEL_ADD_EDGE": "idle",
        "ADD_EDGE_TOGGLE": "idle",
        "CLEAR_CLICK_CONFIRMED": "idle"
      }
    },
    {
      "name": "dragging",
      "onEnter": "startDrag",
      "onExit": "endDrag_and_updateEdges",
      "on": {
        "POINTER_MOVE": "dragging",
        "POINTER_UP": "idle",
        "NODE_DELETE": "idle",
        "CLEAR_CLICK_CONFIRMED": "idle"
      }
    },
    {
      "name": "algo_processing_step",
      "onEnter": "initAlgoIfNeeded; performStep (highlight pseudo-lines, pop queue, animate move, process outgoing edges, update badges)",
      "onExit": "renderQueue; updateIndegreeBadges; finalizeStepState",
      "on": {
        "ALGO_STEP_COMPLETE": "algo_ready",
        "ALGO_FINISHED": "algo_finished",
        "CYCLE_DETECTED": "cycle_detected",
        "RESET_ALGO_CLICK": "idle",
        "CLEAR_CLICK_CONFIRMED": "idle"
      }
    },
    {
      "name": "algo_ready",
      "onEnter": "initAlgoStateIfNeeded; renderQueue",
      "onExit": "clearPseudoHighlights",
      "on": {
        "STEP_CLICK": "algo_processing_step",
        "AUTO_TOGGLE_START": "autoplay_running",
        "RESET_ALGO_CLICK": "idle",
        "GRAPH_MODIFIED": "algo_ready",
        "EDGE_CLICK_REMOVE": "algo_ready",
        "NODE_DELETE": "algo_ready",
        "CLEAR_CLICK_CONFIRMED": "idle"
      }
    },
    {
      "name": "autoplay_running",
      "onEnter": "initAlgoIfNeeded; startAutoplayTimer",
      "onExit": "stopAutoplayTimer",
      "on": {
        "AUTO_TOGGLE_STOP": "algo_ready",
        "ALGO_STEP_COMPLETE": "autoplay_running",
        "ALGO_FINISHED": "algo_finished",
        "CYCLE_DETECTED": "algo_ready",
        "RESET_ALGO_CLICK": "idle",
        "CLEAR_CLICK_CONFIRMED": "idle",
        "GRAPH_MODIFIED": "autoplay_running"
      }
    },
    {
      "name": "cycle_detected",
      "onEnter": "showCycleBanner",
      "onExit": "hideCycleBanner",
      "on": {
        "RESET_ALGO_CLICK": "idle",
        "GRAPH_MODIFIED": "cycle_detected",
        "STEP_CLICK": "cycle_detected",
        "AUTO_TOGGLE_START": "autoplay_running",
        "CLEAR_CLICK_CONFIRMED": "idle",
        "EDGE_CLICK_REMOVE": "cycle_detected",
        "NODE_DELETE": "cycle_detected"
      }
    },
    {
      "name": "algo_finished",
      "onEnter": "finalizeAlgorithm; stopAutoplayIfRunning; clearPseudoHighlights",
      "onExit": "prepareForEditing",
      "on": {
        "RESET_ALGO_CLICK": "idle",
        "GRAPH_MODIFIED": "idle",
        "CLEAR_CLICK_CONFIRMED": "idle",
        "ADD_EDGE_TOGGLE": "adding_edge"
      }
    }
  ],
  "events": [
    "ADD_NODE_CLICK",
    "ADD_NODE_DBLCLICK",
    "ADD_EDGE_TOGGLE",
    "NODE_CLICK",
    "NODE_CLICK_WHEN_SOURCE_SET",
    "NODE_CLICK_SAME_AS_SOURCE",
    "GRAPH_CLICK_CANCEL_ADD_EDGE",
    "EDGE_CLICK_REMOVE",
    "NODE_POINTER_DOWN",
    "POINTER_MOVE",
    "POINTER_UP",
    "NODE_DELETE",
    "STEP_CLICK",
    "AUTO_TOGGLE_START",
    "AUTO_TOGGLE_STOP",
    "RESET_ALGO_CLICK",
    "CLEAR_CLICK_CONFIRMED",
    "CLEAR_CLICK_CANCELLED",
    "CLEAR_CLICK",
    "GRAPH_MODIFIED",
    "ALGO_STEP_COMPLETE",
    "ALGO_FINISHED",
    "CYCLE_DETECTED"
  ],
  "notes": "State actions correspond to the concrete functions in the code. Key mappings: enableEditing = normal editing mode (addingEdge false); toggleAddEdgeMode(true/false) = UI enter/exit add-edge flow; markEdgeSource/clearEdgeSourceMark = edgeFromNode bookkeeping and highlight; startDrag/endDrag_and_updateEdges = pointer capture and updating node positions and edge geometry; initAlgoIfNeeded / initAlgoStateIfNeeded = computeIndegree(), build initial queue and render it; performStep = the sequence in stepAlgo (highlight pseudo-lines 3..7, pop queue, animateMoveToOutput, decrement indegrees, remove edges, push newly zero nodes); startAutoplayTimer/stopAutoplayTimer = setInterval handling used by Autoplay button; showCycleBanner/hideCycleBanner = display cycle detected banner; finalizeAlgorithm = finishing when removed.size === nodes.length. The FSM models user-driven transitions (button clicks, node/edge interactions) and algorithm-driven transitions (step completion, cycle detection, algorithm finish). The implementation uses synchronous confirm() for Clear; for FSM events this is modeled as CLEAR_CLICK_CONFIRMED / CLEAR_CLICK_CANCELLED depending on user response. Some transitions are conditional (e.g., NODE_CLICK in adding_edge leads to either edge_selected or back to idle after creating an edge); these are represented by distinct event names to indicate the different outcomes."
}