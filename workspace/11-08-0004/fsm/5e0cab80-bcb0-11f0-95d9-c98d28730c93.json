{
  "topic": "Queue — FIFO Interactive Module",
  "description": "Models the interactive states of a visual FIFO queue application (enqueue, dequeue, peek, capacity changes, animations, and error/log feedback).",
  "states": [
    {
      "name": "idle",
      "onEnter": "updateControls;renderSlots (ensure UI matches current queue/capacity)",
      "on": {
        "ENQUEUE": "enqueueing",
        "ENQUEUE_INVALID": "error",
        "DEQUEUE": "dequeuing",
        "DEQUEUE_INVALID": "error",
        "PEEK": "peeking",
        "PEEK_INVALID": "error",
        "CLEAR": "clearing",
        "CAPACITY_CHANGE": "adjusting_capacity",
        "INIT": "idle"
      }
    },
    {
      "name": "enqueueing",
      "onEnter": "enqueue (validate value -> push to queue; setLog); animateEnqueue (create bubble and move to rear); disable/adjust controls during anim",
      "onExit": "refreshSlotValues;updateControls",
      "on": {
        "ENQUEUE_ANIMATION_END": "idle",
        "ENQUEUE_CANCEL": "idle"
      }
    },
    {
      "name": "dequeuing",
      "onEnter": "dequeue (shift from queue; setLog); animateDequeue (animate front leaving); disable/adjust controls during anim",
      "onExit": "refreshSlotValues;updateControls",
      "on": {
        "DEQUEUE_ANIMATION_END": "idle",
        "DEQUEUE_CANCEL": "idle"
      }
    },
    {
      "name": "peeking",
      "onEnter": "peek (setLog); pulseFrontPointer (visual pulse animation)",
      "onExit": "updateControls",
      "on": {
        "PEEK_ANIMATION_END": "idle"
      }
    },
    {
      "name": "clearing",
      "onEnter": "clearQueue (empty queue; setLog); animateDequeue for each existing item; disable controls during anim",
      "onExit": "refreshSlotValues;updateControls",
      "on": {
        "CLEAR_ANIMATION_END": "idle"
      }
    },
    {
      "name": "adjusting_capacity",
      "onEnter": "setCapacity (update capacity variable and label); if queue.length > capacity -> trimRear (splice) and setLog; renderSlots",
      "onExit": "updateControls",
      "on": {
        "CAPACITY_TRIM_COMPLETE": "idle",
        "CAPACITY_RENDER_COMPLETE": "idle"
      }
    },
    {
      "name": "error",
      "onEnter": "setLog (error tone) — examples: empty input, dequeue/peek on empty, enqueue when full, invalid capacity change messaging",
      "onExit": "updateControls",
      "on": {
        "AUTO_RESOLVE": "idle",
        "DISMISS_ERROR": "idle"
      }
    }
  ],
  "events": [
    "INIT",
    "ENQUEUE",
    "ENQUEUE_INVALID",
    "ENQUEUE_ANIMATION_END",
    "ENQUEUE_CANCEL",
    "DEQUEUE",
    "DEQUEUE_INVALID",
    "DEQUEUE_ANIMATION_END",
    "DEQUEUE_CANCEL",
    "PEEK",
    "PEEK_INVALID",
    "PEEK_ANIMATION_END",
    "CLEAR",
    "CLEAR_ANIMATION_END",
    "CAPACITY_CHANGE",
    "CAPACITY_TRIM_COMPLETE",
    "CAPACITY_RENDER_COMPLETE",
    "AUTO_RESOLVE",
    "DISMISS_ERROR",
    "INPUT_ENTER",
    "KEY_D",
    "KEY_P"
  ],
  "notes": "Guards and behavior details: - ENQUEUE is only taken when the input value is non-empty and queue.length < capacity; otherwise the code logs an error and remains in idle (modeled as ENQUEUE_INVALID -> error -> idle). - DEQUEUE and PEEK are only taken when queue.length > 0; otherwise they generate DEQUEUE_INVALID/PEEK_INVALID to transition to error (transient). - Animations are implemented with DOM transitions; when an animation finishes the code updates the DOM and controls. Those completion points map to *_ANIMATION_END events that return the FSM to idle. - CAPACITY_CHANGE immediately updates capacity; if capacity < current size the implementation trims the rear (splice) and logs the removal; renderSlots is then called. - The error state is transient in the app: it sets a log with an error tone and control state but effectively returns to idle immediately; modeled here as AUTO_RESOLVE/DISMISS_ERROR returning to idle. - Keyboard shortcuts map to ENQUEUE (Enter/INPUT_ENTER), DEQUEUE (D/KEY_D) and PEEK (P/KEY_P) and follow the same validation rules as button-driven events. - Controls are enabled/disabled based on queue length vs capacity; those visual/interactive changes are performed on entering/exiting relevant states via updateControls."
}