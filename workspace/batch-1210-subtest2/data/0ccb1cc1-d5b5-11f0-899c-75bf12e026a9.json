{
  "id": "0ccb1cc1-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:46:14.814Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Binary Tree",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Binary Tree Visualization and Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  h1 {\n    text-align: center;\n  }\n  #treeCanvas {\n    border: 1px solid #ccc;\n    display: block;\n    margin: 20px auto;\n    background: #fafafa;\n  }\n  #controls {\n    max-width: 600px;\n    margin: 0 auto 40px auto;\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n    justify-content: center;\n  }\n  #nodeValue {\n    width: 80px;\n    padding: 6px 8px;\n    font-size: 16px;\n  }\n  button {\n    padding: 8px 15px;\n    font-size: 16px;\n    cursor: pointer;\n  }\n  #output {\n    max-width: 600px;\n    margin: 0 auto;\n    font-family: monospace;\n    background: #eee;\n    padding: 15px;\n    border-radius: 8px;\n    white-space: pre-wrap;\n    min-height: 80px;\n  }\n  .section-title {\n    text-align: center;\n    margin-top: 40px;\n    margin-bottom: 10px;\n  }\n</style>\n</head>\n<body>\n<h1>Binary Tree Demo and Visualization</h1>\n<div id=\"controls\">\n  <input type=\"number\" id=\"nodeValue\" placeholder=\"Node value\" />\n  <button id=\"insertBtn\">Insert</button>\n  <button id=\"clearBtn\">Clear Tree</button>\n  <button id=\"inorderBtn\">In-order Traversal</button>\n  <button id=\"preorderBtn\">Pre-order Traversal</button>\n  <button id=\"postorderBtn\">Post-order Traversal</button>\n  <button id=\"levelorderBtn\">Level-order Traversal</button>\n</div>\n\n<canvas id=\"treeCanvas\" width=\"800\" height=\"400\"></canvas>\n\n<h3 class=\"section-title\">Traversal Output:</h3>\n<div id=\"output\">(Press traversal buttons to see output here)</div>\n\n<script>\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n      // Positions for drawing\n      this.x = 0;\n      this.y = 0;\n    }\n  }\n\n  class BinaryTree {\n    constructor() {\n      this.root = null;\n    }\n\n    insert(value) {\n      if (this.root === null) {\n        this.root = new Node(value);\n        return true;\n      }\n      return this._insertNode(this.root, value);\n    }\n\n    _insertNode(current, value) {\n      if (value === current.value) {\n        // Do not allow duplicates\n        return false;\n      } else if (value < current.value) {\n        if (current.left === null) {\n          current.left = new Node(value);\n          return true;\n        }\n        return this._insertNode(current.left, value);\n      } else {\n        if (current.right === null) {\n          current.right = new Node(value);\n          return true;\n        }\n        return this._insertNode(current.right, value);\n      }\n    }\n\n    clear() {\n      this.root = null;\n    }\n\n    inorder() {\n      const result = [];\n      function traverse(node) {\n        if (!node) return;\n        traverse(node.left);\n        result.push(node.value);\n        traverse(node.right);\n      }\n      traverse(this.root);\n      return result;\n    }\n\n    preorder() {\n      const result = [];\n      function traverse(node) {\n        if (!node) return;\n        result.push(node.value);\n        traverse(node.left);\n        traverse(node.right);\n      }\n      traverse(this.root);\n      return result;\n    }\n\n    postorder() {\n      const result = [];\n      function traverse(node) {\n        if (!node) return;\n        traverse(node.left);\n        traverse(node.right);\n        result.push(node.value);\n      }\n      traverse(this.root);\n      return result;\n    }\n\n    levelorder() {\n      const result = [];\n      const queue = [];\n      if (this.root !== null) queue.push(this.root);\n      while (queue.length > 0) {\n        let node = queue.shift();\n        result.push(node.value);\n        if (node.left) queue.push(node.left);\n        if (node.right) queue.push(node.right);\n      }\n      return result;\n    }\n  }\n\n  const canvas = document.getElementById('treeCanvas');\n  const ctx = canvas.getContext('2d');\n\n  // Settings for drawing\n  const nodeRadius = 20;\n  const verticalSpacing = 70;\n  const horizontalSpacing = 40;\n\n  // Calculate positions for nodes before drawing\n  function calculateNodePositions(root, width) {\n    const levels = [];\n\n    // First, do an inorder traversal to get horizontal order of nodes\n    const nodesInOrder = [];\n    function inorderPosition(node, depth) {\n      if (!node) return;\n      if (levels[depth] === undefined) levels[depth] = [];\n      inorderPosition(node.left, depth + 1);\n      levels[depth].push(node);\n      nodesInOrder.push(node);\n      inorderPosition(node.right, depth + 1);\n    }\n    inorderPosition(root, 0);\n\n    // Assign x positions in inorder indexing for each node\n    // We'll assign x indexes as increasing numbers from left to right\n    // then translate to pixel positions\n\n    // We can assign x by inorder index:\n    // Let's build a map from node to its inorder index\n\n    const inorderIndices = new Map();\n    nodesInOrder.forEach((node, idx) => {\n      inorderIndices.set(node, idx);\n    });\n\n    // Determine canvas width limits for x based on number of nodes\n    // Spread nodes evenly across width with padding\n    const totalNodes = nodesInOrder.length;\n    let xStep = (width - 2 * nodeRadius) / (totalNodes - 1 || 1);\n\n    // Assign positions\n    nodesInOrder.forEach(node => {\n      node.x = nodeRadius + inorderIndices.get(node) * xStep;\n    });\n\n    // Assign y position based on depth\n    function assignY(node, depth) {\n      if (!node) return;\n      node.y = nodeRadius + depth * verticalSpacing;\n      assignY(node.left, depth + 1);\n      assignY(node.right, depth + 1);\n    }\n    assignY(root, 0);\n  }\n\n  function drawTree(tree) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    if (!tree.root) return;\n\n    calculateNodePositions(tree.root, canvas.width);\n\n    // Draw edges (lines between nodes)\n    function drawEdges(node) {\n      if (!node) return;\n      if (node.left) {\n        drawLine(node.x, node.y, node.left.x, node.left.y);\n        drawEdges(node.left);\n      }\n      if (node.right) {\n        drawLine(node.x, node.y, node.right.x, node.right.y);\n        drawEdges(node.right);\n      }\n    }\n    function drawLine(x1, y1, x2, y2) {\n      ctx.strokeStyle = '#555';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n    }\n\n    drawEdges(tree.root);\n\n    // Draw nodes (circles with values)\n    function drawNode(node) {\n      if (!node) return;\n      // Draw circle\n      ctx.fillStyle = '#1976d2';\n      ctx.strokeStyle = '#0d47a1';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // Draw text\n      ctx.fillStyle = \"white\";\n      ctx.font = \"bold 16px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(node.value, node.x, node.y);\n\n      drawNode(node.left);\n      drawNode(node.right);\n    }\n\n    drawNode(tree.root);\n  }\n\n  // Main program logic\n  const tree = new BinaryTree();\n  const nodeValueInput = document.getElementById('nodeValue');\n  const insertBtn = document.getElementById('insertBtn');\n  const clearBtn = document.getElementById('clearBtn');\n  const inorderBtn = document.getElementById('inorderBtn');\n  const preorderBtn = document.getElementById('preorderBtn');\n  const postorderBtn = document.getElementById('postorderBtn');\n  const levelorderBtn = document.getElementById('levelorderBtn');\n  const outputDiv = document.getElementById('output');\n\n  insertBtn.addEventListener('click', () => {\n    const val = parseInt(nodeValueInput.value, 10);\n    if (isNaN(val)) {\n      alert('Please enter a valid number.');\n      return;\n    }\n    const inserted = tree.insert(val);\n    if (!inserted) {\n      alert('Duplicate values are not allowed.');\n    } else {\n      drawTree(tree);\n      outputDiv.textContent = `Inserted value: ${val}`;\n    }\n    nodeValueInput.value = '';\n    nodeValueInput.focus();\n  });\n\n  clearBtn.addEventListener('click', () => {\n    tree.clear();\n    drawTree(tree);\n    outputDiv.textContent = 'Tree cleared.';\n    nodeValueInput.focus();\n  });\n\n  inorderBtn.addEventListener('click', () => {\n    const traversal = tree.inorder();\n    outputDiv.textContent = 'In-order: ' + (traversal.length ? traversal.join(', ') : '(empty)');\n  });\n\n  preorderBtn.addEventListener('click', () => {\n    const traversal = tree.preorder();\n    outputDiv.textContent = 'Pre-order: ' + (traversal.length ? traversal.join(', ') : '(empty)');\n  });\n\n  postorderBtn.addEventListener('click', () => {\n    const traversal = tree.postorder();\n    outputDiv.textContent = 'Post-order: ' + (traversal.length ? traversal.join(', ') : '(empty)');\n  });\n\n  levelorderBtn.addEventListener('click', () => {\n    const traversal = tree.levelorder();\n    outputDiv.textContent = 'Level-order: ' + (traversal.length ? traversal.join(', ') : '(empty)');\n  });\n\n  // Initial draw: empty\n  drawTree(tree);\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Binary Tree"
    }
  ],
  "topic": "Binary Tree",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}