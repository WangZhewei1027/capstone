{
  "id": "0ccd66b0-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:45:34.147Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "K-Nearest Neighbors (KNN)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>K-Nearest Neighbors (KNN) Demonstration</title>\n<style>\n  body {\n    font-family: \"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;\n    margin: 20px;\n    background: #f0f0f0;\n  }\n  h1 {\n    text-align: center;\n  }\n  #canvasContainer {\n    display: flex;\n    justify-content: center;\n    margin-bottom: 20px;\n  }\n  canvas {\n    background: white;\n    border: 1px solid #ccc;\n    cursor: crosshair;\n  }\n  #controls {\n    max-width: 600px;\n    margin: 0 auto 20px;\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n    justify-content: center;\n  }\n  label {\n    font-weight: 600;\n  }\n  select, input[type=number] {\n    padding: 5px;\n    font-size: 1rem;\n    width: 60px;\n  }\n  button {\n    padding: 8px 16px;\n    font-size: 1rem;\n    cursor: pointer;\n    border: none;\n    background-color: #0078d7;\n    color: white;\n    border-radius: 4px;\n    transition: background-color 0.2s;\n  }\n  button:hover:not(:disabled) {\n    background-color: #005ea1;\n  }\n  button:disabled {\n    background-color: #aaa;\n    cursor: not-allowed;\n  }\n  #description {\n    max-width: 600px;\n    margin: 0 auto 30px;\n    line-height: 1.5;\n  }\n  #info {\n    max-width: 600px;\n    margin: 0 auto;\n    font-weight: bold;\n    text-align: center;\n  }\n  .legend {\n    max-width: 600px;\n    margin: 10px auto 30px;\n    display: flex;\n    justify-content: center;\n    gap: 20px;\n  }\n  .legend-item {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n  }\n  .color-box {\n    width: 20px;\n    height: 20px;\n    border-radius: 4px;\n    border: 1px solid #555;\n  }\n  .color-A {\n    background-color: #de425b;\n  }\n  .color-B {\n    background-color: #2c94d2;\n  }\n  .color-unknown {\n    background-color: #999999;\n  }\n</style>\n</head>\n<body>\n<h1>K-Nearest Neighbors (KNN) Demo</h1>\n\n<div id=\"description\">\n  <p>\n    This interactive demo illustrates the K-Nearest Neighbors (KNN) classification algorithm.\n    You can add training data points to two classes (Class A and Class B) by selecting the class and clicking on the canvas.\n    Then add an <em>unknown</em> (unlabeled) point by selecting the <strong>Unknown</strong> class and clicking on the canvas.\n    The demo will classify the unknown point based on the majority class of its K nearest neighbors\n    and display its predicted label and the neighbors used.\n  </p>\n  <p>\n    Adjust the number of neighbors (K) using the input next to the <strong>Class</strong> selector,\n    then click \"Classify Unknown\" to see the classification result.\n  </p>\n  <p>\n    You can clear the points and start over at any time.\n  </p>\n</div>\n\n<div id=\"controls\">\n  <label for=\"classSelect\">Select Class:</label>\n  <select id=\"classSelect\" title=\"Choose point type to add\">\n    <option value=\"A\">Class A (Red)</option>\n    <option value=\"B\">Class B (Blue)</option>\n    <option value=\"unknown\">Unknown (Gray)</option>\n  </select>\n\n  <label for=\"kInput\">K (neighbors):</label>\n  <input id=\"kInput\" type=\"number\" min=\"1\" max=\"15\" value=\"3\" title=\"Number of neighbors for classification\" />\n\n  <button id=\"classifyBtn\" title=\"Classify the unknown points\">Classify Unknown</button>\n  <button id=\"clearBtn\" title=\"Clear all points from the canvas\">Clear All</button>\n</div>\n\n<div id=\"info\">Add training points! Then add unknown points and classify.</div>\n\n<div class=\"legend\">\n  <div class=\"legend-item\"><div class=\"color-box color-A\"></div>Class A</div>\n  <div class=\"legend-item\"><div class=\"color-box color-B\"></div>Class B</div>\n  <div class=\"legend-item\"><div class=\"color-box color-unknown\"></div>Unknown</div>\n  <div class=\"legend-item\" style=\"border-left: 2px solid #555; padding-left: 6px; margin-left: 20px;\">Neighbors for classification are connected by lines</div>\n</div>\n\n<div id=\"canvasContainer\">\n  <canvas id=\"knnCanvas\" width=\"600\" height=\"400\" aria-label=\"KNN scatter plot\"></canvas>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById(\"knnCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const classSelect = document.getElementById(\"classSelect\");\n  const kInput = document.getElementById(\"kInput\");\n  const classifyBtn = document.getElementById(\"classifyBtn\");\n  const clearBtn = document.getElementById(\"clearBtn\");\n  const info = document.getElementById(\"info\");\n\n  const POINT_RADIUS = 7;\n\n  // Colors for classes\n  const COLORS = {\n    A: \"#de425b\",\n    B: \"#2c94d2\",\n    unknown: \"#999999\",\n    neighborLine: \"#4a4a4a\",\n    correct: \"#27ae60\",\n    incorrect: \"#c0392b\",\n  };\n\n  // Data points storage: {x, y, cls, predicted?}\n  let points = [];\n\n  // To keep track of neighbors for unknown points after classification\n  let classificationResults = [];\n\n  // Utility: Draw a circle with text inside\n  function drawPoint(point, options = {}) {\n    const {x, y, cls, predicted=false, isNeighbor=false} = point;\n    ctx.beginPath();\n    ctx.lineWidth = isNeighbor ? 3 : 1.5;\n    ctx.strokeStyle = isNeighbor ? \"#555\" : \"#333\";\n    ctx.fillStyle = COLORS[cls] || \"#777\";\n\n    ctx.shadowColor = \"rgba(0,0,0,0.15)\";\n    ctx.shadowBlur = 3;\n    ctx.shadowOffsetX = 1;\n    ctx.shadowOffsetY = 1;\n\n    ctx.arc(x, y, POINT_RADIUS, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.shadowBlur = 0;\n    ctx.shadowOffsetX = 0;\n    ctx.shadowOffsetY = 0;\n    ctx.stroke();\n\n    // Draw predicted label highlight circle if available\n    if (predicted) {\n      ctx.beginPath();\n      ctx.lineWidth = 3;\n      ctx.strokeStyle = COLORS.correct;\n      ctx.arc(x, y, POINT_RADIUS + 4, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n  }\n\n  // Clear canvas\n  function clearCanvas() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  // Draw all points and connections for neighbors\n  function draw() {\n    clearCanvas();\n\n    // If classification done, draw connections for neighbors\n    classificationResults.forEach(({unknownPoint, neighbors}) => {\n      neighbors.forEach(neighbor => {\n        ctx.strokeStyle = COLORS.neighborLine;\n        ctx.lineWidth = 1.5;\n        ctx.beginPath();\n        ctx.moveTo(unknownPoint.x, unknownPoint.y);\n        ctx.lineTo(neighbor.x, neighbor.y);\n        ctx.stroke();\n      });\n    });\n\n    // Draw training points first\n    points.forEach(p => {\n      if (p.cls !== \"unknown\") {\n        drawPoint(p);\n      }\n    });\n\n    // Draw unknown points with classification highlight if predicted\n    points.forEach(p => {\n      if (p.cls === \"unknown\") {\n        const result = classificationResults.find(r => r.unknownPoint === p);\n        drawPoint(p, {predicted: !!result});\n      }\n    });\n  }\n\n  // Euclidean distance between two points\n  function dist(p1, p2) {\n    return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  }\n\n  // Find K nearest neighbors of unknown point among training points\n  function findKNearest(unknownPoint, k) {\n    const trainingPoints = points.filter(p => p.cls === \"A\" || p.cls === \"B\");\n\n    // Compute distances\n    const distances = trainingPoints.map(tp => ({\n      point: tp,\n      d: dist(tp, unknownPoint)\n    }));\n\n    distances.sort((a, b) => a.d - b.d);\n\n    return distances.slice(0, k).map(d => d.point);\n  }\n\n  // Majority vote function\n  function majorityVote(neighbors) {\n    const counts = {};\n    neighbors.forEach(n => {\n      counts[n.cls] = (counts[n.cls] || 0) + 1;\n    });\n    // Find max count\n    let maxCount = 0;\n    let winner = null;\n    for (const cls in counts) {\n      if (counts[cls] > maxCount) {\n        maxCount = counts[cls];\n        winner = cls;\n      }\n    }\n\n    // Check tie - if tie occurs, choose randomly among tied classes\n    const topClasses = Object.entries(counts)\n      .filter(([, count]) => count === maxCount)\n      .map(([cls]) => cls);\n\n    if (topClasses.length > 1) {\n      // Random tie breaker for demonstration\n      winner = topClasses[Math.floor(Math.random() * topClasses.length)];\n    }\n\n    return winner;\n  }\n\n  // Handle canvas click to add points\n  function onCanvasClick(evt) {\n    const rect = canvas.getBoundingClientRect();\n    const x = evt.clientX - rect.left;\n    const y = evt.clientY - rect.top;\n    const cls = classSelect.value;\n\n    // Only add point inside bounds\n    if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) return;\n\n    points.push({x, y, cls});\n    classificationResults = []; // Reset any previous classification\n    info.textContent = `Added point of class: ${cls === 'unknown' ? 'Unknown' : cls}`;\n    draw();\n  }\n\n  // Handle classification\n  function classifyUnknown() {\n    const k = parseInt(kInput.value);\n    if (k < 1) {\n      alert(\"K must be at least 1.\");\n      return;\n    }\n    // Check training and unknown points presence\n    const unknownPoints = points.filter(p => p.cls === \"unknown\");\n    const trainingPoints = points.filter(p => p.cls === \"A\" || p.cls === \"B\");\n\n    if (trainingPoints.length === 0) {\n      alert(\"Please add training points (Class A and Class B) before classification.\");\n      return;\n    }\n    if (unknownPoints.length === 0) {\n      alert(\"Please add at least one unknown point to classify.\");\n      return;\n    }\n    if (k > trainingPoints.length) {\n      alert(`K cannot be larger than the number of training points (${trainingPoints.length}).`);\n      return;\n    }\n\n    classificationResults = [];\n\n    // Classify each unknown point\n    unknownPoints.forEach(up => {\n      const neighbors = findKNearest(up, k);\n      const pred = majorityVote(neighbors);\n      up.predictedClass = pred;\n      classificationResults.push({unknownPoint: up, neighbors});\n    });\n\n    // Display results summary\n    let summary = \"Classification Results:\\n\";\n    classificationResults.forEach(({unknownPoint, neighbors}, i) => {\n      const pred = unknownPoint.predictedClass;\n      summary += `Unknown Point #${i + 1}: Predicted class = ${pred.toUpperCase()} (neighbors: ${neighbors.length})\\n`;\n    });\n\n    info.textContent = summary.replace(/\\n/g, \"  |  \");\n    draw();\n  }\n\n  // Clear all points\n  function clearAll() {\n    points = [];\n    classificationResults = [];\n    info.textContent = \"Cleared all points. Add new points to start.\";\n    draw();\n  }\n\n  // Initial draw\n  draw();\n\n  canvas.addEventListener(\"click\", onCanvasClick);\n  classifyBtn.addEventListener(\"click\", classifyUnknown);\n  clearBtn.addEventListener(\"click\", clearAll);\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Nearest Neighbors (KNN)"
    }
  ],
  "topic": "K-Nearest Neighbors (KNN)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}