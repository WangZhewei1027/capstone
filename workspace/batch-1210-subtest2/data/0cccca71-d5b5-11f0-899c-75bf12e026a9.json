{
  "id": "0cccca71-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:46:29.819Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Prim’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Prim's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    padding: 0;\n    background: #fafafa;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n  h1 {\n    margin-top: 20px;\n  }\n  #container {\n    display: flex;\n    margin: 20px;\n    max-width: 1000px;\n    width: 95vw;\n  }\n  #graphCanvas {\n    border: 1px solid #ccc;\n    background: #fff;\n    flex-grow: 1;\n    border-radius: 6px;\n  }\n  #controls {\n    margin-left: 20px;\n    max-width: 300px;\n  }\n  #log {\n    margin-top: 15px;\n    height: 250px;\n    overflow-y: auto;\n    background: #111;\n    color: #eee;\n    font-family: monospace;\n    font-size: 14px;\n    padding: 10px;\n    border-radius: 6px;\n    white-space: pre-wrap;\n  }\n  button, select {\n    padding: 8px 14px;\n    margin-top: 10px;\n    width: 100%;\n    font-size: 14px;\n    border: 1px solid #777;\n    border-radius: 4px;\n    background: #f0f0f0;\n    cursor: pointer;\n  }\n  button:disabled {\n    background: #ddd;\n    cursor: not-allowed;\n  }\n  label {\n    display: block;\n    margin-top: 15px;\n    font-weight: bold;\n  }\n  input[type=\"number\"] {\n    width: 100%;\n    padding: 6px 10px;\n    font-size: 14px;\n    border-radius: 4px;\n    border: 1px solid #777;\n    box-sizing: border-box;\n  }\n  #graphInputArea {\n    width: 100%;\n    height: 100px;\n    margin-top: 8px;\n    font-family: monospace;\n    font-size: 13px;\n    padding: 8px;\n    border-radius: 6px;\n    border: 1px solid #aaa;\n    resize: vertical;\n  }\n  #exampleGraph {\n    font-size: 14px;\n    margin-top: 8px;\n  }\n  small {\n    color: #666;\n  }\n</style>\n</head>\n<body>\n<h1>Prim's Algorithm Visualization</h1>\n<div id=\"container\">\n  <canvas id=\"graphCanvas\" width=\"700\" height=\"500\" title=\"Graph Visualization\"></canvas>\n  <div id=\"controls\">\n    <label for=\"exampleGraphs\">Load Example Graph:</label>\n    <select id=\"exampleGraphs\">\n      <option value=\"\">-- Select an example --</option>\n      <option value=\"graph1\">Graph 1 (7 nodes)</option>\n      <option value=\"graph2\">Graph 2 (6 nodes)</option>\n      <option value=\"graph3\">Graph 3 (8 nodes)</option>\n    </select>\n\n    <label for=\"graphInputArea\">Or input your graph edges:</label>\n    <small>Format: one edge per line, <br />u v weight (space separated). Nodes numbered from 0.</small>\n    <textarea id=\"graphInputArea\" placeholder=\"Example:\\n0 1 7\\n0 3 5\\n1 2 8\\n...\" ></textarea>\n\n    <label for=\"startNodeInput\">Start node:</label>\n    <input type=\"number\" id=\"startNodeInput\" min=\"0\" value=\"0\"/>\n\n    <button id=\"loadGraphBtn\">Load Graph</button>\n    <button id=\"startBtn\" disabled>Start Prim's Algorithm</button>\n    <button id=\"stepBtn\" disabled>Step</button>\n    <button id=\"resetBtn\" disabled>Reset</button>\n\n    <div id=\"log\"></div>\n  </div>\n</div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('graphCanvas');\n  const ctx = canvas.getContext('2d');\n\n  const exampleGraphsSelect = document.getElementById('exampleGraphs');\n  const graphInputArea = document.getElementById('graphInputArea');\n  const loadGraphBtn = document.getElementById('loadGraphBtn');\n  const startBtn = document.getElementById('startBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const resetBtn = document.getElementById('resetBtn');\n  const startNodeInput = document.getElementById('startNodeInput');\n  const logDiv = document.getElementById('log');\n\n  // Graph data structures\n  // Nodes will be objects: {id, x, y}\n  // Edges: {u, v, weight}\n\n  let nodes = [];\n  let edges = [];\n  let adjacencyList = [];\n\n  // Prim's Algorithm state\n  let primState = null;\n\n  // Visualization parameters\n  const NODE_RADIUS = 20;\n  const COLORS = {\n    nodeDefault: '#3498db',\n    nodeSelected: '#e74c3c',\n    nodeInMST: '#2ecc71',\n    edgeDefault: '#aaa',\n    edgeSelected: '#e74c3c',\n    edgeInMST: '#2ecc71',\n    edgeCandidate: '#f39c12',\n    textColor: '#222'\n  };\n\n  // Utility for logging messages\n  function log(msg) {\n    logDiv.textContent += msg + '\\n';\n    logDiv.scrollTop = logDiv.scrollHeight;\n  }\n\n  // Clear the log\n  function clearLog() {\n    logDiv.textContent = '';\n  }\n\n  // Example Graphs\n  // Each example: {nodesCount, edges array}\n  // edges: [ {u,v,weight}, ...]\n  const exampleGraphs = {\n    graph1: {\n      nodesCount: 7,\n      edges: [\n        {u:0,v:1,weight:7},{u:0,v:3,weight:5},\n        {u:1,v:2,weight:8},{u:1,v:3,weight:9},{u:1,v:4,weight:7},\n        {u:2,v:4,weight:5},\n        {u:3,v:4,weight:15},{u:3,v:5,weight:6},\n        {u:4,v:5,weight:8},{u:4,v:6,weight:9},\n        {u:5,v:6,weight:11}\n      ]\n    },\n    graph2: {\n      nodesCount: 6,\n      edges: [\n        {u:0,v:1,weight:3},{u:0,v:3,weight:1},\n        {u:1,v:2,weight:1},{u:1,v:3,weight:3},{u:1,v:4,weight:6},\n        {u:2,v:4,weight:5},\n        {u:3,v:4,weight:5},{u:3,v:5,weight:4},\n        {u:4,v:5,weight:2}\n      ]\n    },\n    graph3: {\n      nodesCount: 8,\n      edges: [\n        {u:0,v:1,weight:2},{u:0,v:3,weight:6},{u:1,v:2,weight:3},\n        {u:1,v:3,weight:8},{u:1,v:4,weight:5},{u:2,v:4,weight:7},\n        {u:3,v:4,weight:9},{u:3,v:5,weight:4},{u:4,v:5,weight:2},\n        {u:4,v:6,weight:6},{u:5,v:6,weight:1},{u:6,v:7,weight:7},\n        {u:5,v:7,weight:8}\n      ]\n    }\n  };\n\n  // Generate node positions arranged in circle for visualization\n  function positionNodesCircle(numNodes) {\n    const centerX = canvas.width/2;\n    const centerY = canvas.height/2;\n    const radius = Math.min(canvas.width, canvas.height)/2 - 80;\n    let coords = [];\n    for(let i=0; i<numNodes; i++) {\n      const angle = (2*Math.PI*i)/numNodes - Math.PI/2;\n      coords.push({\n        id: i,\n        x: centerX + radius * Math.cos(angle),\n        y: centerY + radius * Math.sin(angle)\n      });\n    }\n    return coords;\n  }\n\n  // Build adjacency list from edges\n  function buildAdjacencyList(numNodes, edges) {\n    let adj = new Array(numNodes);\n    for(let i=0; i<numNodes; i++) adj[i] = [];\n    edges.forEach(({u,v,weight}) => {\n      adj[u].push({to:v,weight});\n      adj[v].push({to:u,weight});\n    });\n    return adj;\n  }\n\n  // Draw graph nodes and edges\n  // primState holds the current MST and candidate edges info\n  // Colors:\n  // - MST edges: green\n  // - candidate edges (frontier): orange\n  // - selected edge in current step: red\n  function drawGraph() {\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n\n    // Draw edges first\n    edges.forEach(({u,v,weight}) => {\n      const n1 = nodes[u];\n      const n2 = nodes[v];\n      let color = COLORS.edgeDefault;\n      let lineWidth = 1;\n\n      if (primState) {\n        // Is edge in MST?\n        if (primState.mstEdges.some(e => (e.u===u && e.v===v) || (e.u===v && e.v===u))) {\n          color = COLORS.edgeInMST;\n          lineWidth = 3;\n        } else if (primState.currentEdge && (\n            (primState.currentEdge.u === u && primState.currentEdge.v === v) ||\n            (primState.currentEdge.u === v && primState.currentEdge.v === u)\n          )) {\n          // Edge currently selected in this step\n          color = COLORS.edgeSelected;\n          lineWidth = 3;\n        } else if (primState.candidateEdges.some(e => (e.u===u && e.v===v) || (e.u===v && e.v===u))) {\n          color = COLORS.edgeCandidate;\n          lineWidth = 2;\n        }\n      }\n\n      ctx.strokeStyle = color;\n      ctx.lineWidth = lineWidth;\n      ctx.beginPath();\n      ctx.moveTo(n1.x, n1.y);\n      ctx.lineTo(n2.x, n2.y);\n      ctx.stroke();\n\n      // Draw weight label near midpoint\n      const midX = (n1.x + n2.x)/2;\n      const midY = (n1.y + n2.y)/2;\n      ctx.fillStyle = COLORS.textColor;\n      ctx.font = '12px Arial';\n      ctx.fillText(weight, midX + 5, midY - 5);\n    });\n\n    // Draw nodes\n    nodes.forEach(node => {\n      let fillColor = COLORS.nodeDefault;\n      let strokeColor = '#555';\n\n      if (primState) {\n        if (primState.mstNodes.has(node.id)) {\n          fillColor = COLORS.nodeInMST;\n          strokeColor = '#27ae60';\n        }\n        if (primState.currentNode === node.id) {\n          fillColor = COLORS.nodeSelected;\n          strokeColor = '#c0392b';\n        }\n      }\n\n      ctx.fillStyle = fillColor;\n      ctx.strokeStyle = strokeColor;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2*Math.PI);\n      ctx.fill();\n      ctx.stroke();\n\n      ctx.fillStyle = '#fff';\n      ctx.font = '16px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(node.id, node.x, node.y);\n    });\n  }\n\n  // Priority queue implementation (min-heap) by weight for edges\n  class MinHeap {\n    constructor() {\n      this.heap = [];\n    }\n    parent(i) {return Math.floor((i-1)/2);}\n    left(i) {return 2*i+1;}\n    right(i) {return 2*i+2;}\n    swap(i,j) {\n      const tmp = this.heap[i];\n      this.heap[i] = this.heap[j];\n      this.heap[j] = tmp;\n    }\n    push(obj) {\n      this.heap.push(obj);\n      this.heapifyUp(this.heap.length-1);\n    }\n    heapifyUp(i) {\n      let current = i;\n      while(current>0 && this.heap[current].weight < this.heap[this.parent(current)].weight) {\n        this.swap(current, this.parent(current));\n        current = this.parent(current);\n      }\n    }\n    heapifyDown(i) {\n      let smallest = i;\n      let left = this.left(i);\n      let right = this.right(i);\n\n      if(left < this.heap.length && this.heap[left].weight < this.heap[smallest].weight) smallest = left;\n      if(right < this.heap.length && this.heap[right].weight < this.heap[smallest].weight) smallest = right;\n\n      if(smallest !== i) {\n        this.swap(i, smallest);\n        this.heapifyDown(smallest);\n      }\n    }\n    pop() {\n      if(this.heap.length === 0) return null;\n      const root = this.heap[0];\n      const last = this.heap.pop();\n      if(this.heap.length > 0) {\n        this.heap[0] = last;\n        this.heapifyDown(0);\n      }\n      return root;\n    }\n    isEmpty() {\n      return this.heap.length === 0;\n    }\n    toArray() {\n      return [...this.heap];\n    }\n  }\n\n  // Prim's Algorithm state and step function\n  function PrimAlgorithm(adjList, startNode){\n    return {\n      mstNodes: new Set(),\n      mstEdges: [],\n      candidateEdges: [],\n      visited: new Array(adjList.length).fill(false),\n      edgePQ: new MinHeap(),\n      currentNode: null,\n      currentEdge: null,\n      started: false,\n\n      init() {\n        this.mstNodes.clear();\n        this.mstEdges = [];\n        this.candidateEdges = [];\n        this.visited.fill(false);\n        this.edgePQ = new MinHeap();\n        this.currentNode = startNode;\n        this.currentEdge = null;\n        this.started = true;\n\n        this.visited[startNode] = true;\n        this.mstNodes.add(startNode);\n\n        for(let e of adjList[startNode]) {\n          this.edgePQ.push({u: startNode, v: e.to, weight: e.weight});\n        }\n        this.updateCandidates();\n      },\n\n      updateCandidates() {\n        // Extract candidate edges from priority queue as array for visualization\n        this.candidateEdges = this.edgePQ.toArray();\n      },\n\n      step() {\n        if(!this.started) {\n          this.init();\n          return {continue:true};\n        }\n        if(this.edgePQ.isEmpty()){\n          // MST complete\n          this.currentEdge = null;\n          this.currentNode = null;\n          return {continue:false};\n        }\n\n        // Pop min edge from pq\n        let edge = this.edgePQ.pop();\n        // Mark currentEdge for visualization\n        this.currentEdge = edge;\n\n        // Check if it connects to a new node\n        if(this.visited[edge.v]) {\n          // Already visited, skip edge and step again recursively\n          this.updateCandidates();\n          return this.step();\n        }\n\n        // Accept this edge\n        this.mstEdges.push(edge);\n        this.currentNode = edge.v;\n        this.mstNodes.add(edge.v);\n        this.visited[edge.v] = true;\n\n        // Add edges from newly added node to pq\n        for(let e of adjList[edge.v]) {\n          if(!this.visited[e.to]) {\n            this.edgePQ.push({u: edge.v, v: e.to, weight: e.weight});\n          }\n        }\n        this.updateCandidates();\n        return {continue:true};\n      }\n    };\n  }\n\n  // Parse input graph from textarea\n  // Returns {nodesCount, edges} or null on error\n  function parseGraphInput(text) {\n    // Input format: lines of \"u v w\"\n    const lines = text.trim().split('\\n');\n    let edgeList = [];\n    let maxNode = -1;\n    for(let i=0; i<lines.length; i++){\n      const line = lines[i].trim();\n      if(line === '') continue;\n      const parts = line.split(/ +/);\n      if(parts.length !== 3){\n        alert(`Invalid edge format at line ${i+1}. Expected: u v weight`);\n        return null;\n      }\n      let u = parseInt(parts[0],10);\n      let v = parseInt(parts[1],10);\n      let w = parseFloat(parts[2]);\n      if(isNaN(u) || isNaN(v) || isNaN(w) || w <= 0){\n        alert(`Invalid numbers at line ${i+1}.`);\n        return null;\n      }\n      edgeList.push({u,v,weight:w});\n      maxNode = Math.max(maxNode, u, v);\n    }\n    return {nodesCount: maxNode+1, edges: edgeList};\n  }\n\n  // Load a graph (nodes + edges)\n  function loadGraph(graphData, startNode) {\n    if (!graphData) return;\n    const {nodesCount, edges: inputEdges} = graphData;\n\n    if(startNode<0 || startNode>=nodesCount){\n      alert(`Start node must be between 0 and ${nodesCount-1}`);\n      return false;\n    }\n\n    nodes = positionNodesCircle(nodesCount);\n    edges = inputEdges;\n\n    adjacencyList = buildAdjacencyList(nodesCount, edges);\n\n    primState = null;\n\n    clearLog();\n    log(`Graph loaded with ${nodesCount} nodes and ${edges.length} edges.`);\n    log(`Start node set to ${startNode}.`);\n\n    startBtn.disabled = false;\n    stepBtn.disabled = true;\n    resetBtn.disabled = true;\n\n    drawGraph();\n    return true;\n  }\n\n  // Event handlers\n  loadGraphBtn.onclick = () => {\n    let graphData = null;\n    const inputText = graphInputArea.value.trim();\n    const startNode = parseInt(startNodeInput.value,10);\n    if(inputText){\n      graphData = parseGraphInput(inputText);\n      if(!graphData) return;\n    } else if(exampleGraphsSelect.value){\n      graphData = exampleGraphs[exampleGraphsSelect.value];\n    } else {\n      alert('Please select an example graph or input your graph edges.');\n      return;\n    }\n    if(loadGraph(graphData, startNode)) {\n      log('Click \"Start Prim\\'s Algorithm\" to begin.');\n    }\n  };\n\n  startBtn.onclick = () => {\n    const startNode = parseInt(startNodeInput.value,10);\n    primState = PrimAlgorithm(adjacencyList, startNode);\n    primState.init();\n\n    startBtn.disabled = true;\n    stepBtn.disabled = false;\n    resetBtn.disabled = false;\n    loadGraphBtn.disabled = true;\n    exampleGraphsSelect.disabled = true;\n    graphInputArea.disabled = true;\n    startNodeInput.disabled = true;\n\n    clearLog();\n    log(`Starting Prim's Algorithm from node ${startNode}.\\n`);\n    log(`Added start node ${startNode} to MST.`);\n    drawGraph();\n  };\n\n  stepBtn.onclick = () => {\n    if(!primState) return;\n    const res = primState.step();\n\n    // Logging each step\n    if(primState.currentEdge) {\n      log(`Considering edge (${primState.currentEdge.u} — ${primState.currentEdge.v}) with weight ${primState.currentEdge.weight}`);\n    }\n\n    if(primState.currentNode !== null) {\n      log(`Added node ${primState.currentNode} to MST.`);\n    }\n    drawGraph();\n\n    if(!res.continue){\n      log('\\nPrim\\'s MST construction complete.');\n      stepBtn.disabled = true;\n    }\n  };\n\n  resetBtn.onclick = () => {\n    primState = null;\n    startBtn.disabled = false;\n    stepBtn.disabled = true;\n    resetBtn.disabled = true;\n    loadGraphBtn.disabled = false;\n    exampleGraphsSelect.disabled = false;\n    graphInputArea.disabled = false;\n    startNodeInput.disabled = false;\n    clearLog();\n    drawGraph();\n  };\n\n  exampleGraphsSelect.onchange = () => {\n    if(exampleGraphsSelect.value) {\n      const graphData = exampleGraphs[exampleGraphsSelect.value];\n      // Auto fill example into textarea for user reference\n      let text = graphData.edges.map(e => `${e.u} ${e.v} ${e.weight}`).join('\\n');\n      graphInputArea.value = text;\n      startNodeInput.value = 0;\n    } else {\n      graphInputArea.value = '';\n    }\n  };\n\n  // Initial call to draw empty canvas\n  drawGraph();\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Prim’s Algorithm"
    }
  ],
  "topic": "Prim’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}