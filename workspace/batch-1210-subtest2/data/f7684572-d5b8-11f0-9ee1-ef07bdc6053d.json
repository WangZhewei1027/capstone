{
  "id": "f7684572-d5b8-11f0-9ee1-ef07bdc6053d",
  "timestamp": "2025-12-10T11:13:16.535Z",
  "model": "gpt-4o-mini",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Topological Sort Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 20px;\n        }\n        canvas {\n            border: 1px solid #ccc;\n            background-color: #f9f9f9;\n        }\n        .button {\n            margin: 10px 0;\n            padding: 10px 20px;\n            font-size: 16px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n\n<h1>Topological Sort Visualization</h1>\n<canvas id=\"canvas\" width=\"800\" height=\"400\"></canvas>\n<br>\n<button class=\"button\" id=\"sortButton\">Perform Topological Sort</button>\n<div id=\"result\"></div>\n\n<script>\n    // Create a directed graph using an adjacency list\n    const graph = {\n        A: ['C', 'D'],\n        B: ['D'],\n        C: ['E'],\n        D: ['F'],\n        E: ['F'],\n        F: []\n    };\n\n    function topologicalSort(graph) {\n        const inDegree = {};\n        const sortedList = [];\n        const zeroInDegreeQueue = [];\n\n        // Calculate in-degrees of all nodes\n        for (const node in graph) {\n            if (!inDegree[node]) inDegree[node] = 0;\n            for (const neighbor of graph[node]) {\n                inDegree[neighbor] = (inDegree[neighbor] || 0) + 1;\n            }\n        }\n\n        // Collect all nodes with zero in-degree\n        for (const node in inDegree) {\n            if (inDegree[node] === 0) zeroInDegreeQueue.push(node);\n        }\n\n        while (zeroInDegreeQueue.length > 0) {\n            const node = zeroInDegreeQueue.shift();\n            sortedList.push(node);\n\n            // Decrease the in-degree of neighboring nodes\n            for (const neighbor of graph[node]) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] === 0) {\n                    zeroInDegreeQueue.push(neighbor);\n                }\n            }\n        }\n\n        // Check for cycles (if sortedList length doesn't match graph size)\n        if (sortedList.length !== Object.keys(graph).length) {\n            throw new Error(\"Graph has at least one cycle.\");\n        }\n\n        return sortedList;\n    }\n\n    function drawGraph() {\n        const canvas = document.getElementById(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        const nodes = Object.keys(graph);\n        const nodeCoordinates = {};\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \n        nodes.forEach((node, index) => {\n            const x = (index + 1) * 100;\n            const y = 200;\n            nodeCoordinates[node] = { x, y };\n            ctx.fillStyle = \"#00f\";\n            ctx.beginPath();\n            ctx.arc(x, y, 20, 0, Math.PI * 2);\n            ctx.fill();\n            ctx.fillStyle = \"#fff\";\n            ctx.fillText(node, x - 6, y + 6);\n        });\n\n        ctx.strokeStyle = '#000';\n        for (const node in graph) {\n            for (const neighbor of graph[node]) {\n                ctx.beginPath();\n                ctx.moveTo(nodeCoordinates[node].x, nodeCoordinates[node].y);\n                ctx.lineTo(nodeCoordinates[neighbor].x, nodeCoordinates[neighbor].y);\n                ctx.stroke();\n            }\n        }\n    }\n\n    document.getElementById(\"sortButton\").addEventListener(\"click\", () => {\n        try {\n            const sorted = topologicalSort(graph);\n            document.getElementById(\"result\").innerText = \"Topological Sort Result: \" + sorted.join(\" -> \");\n            drawGraph();\n        } catch (error) {\n            alert(error.message);\n        }\n    });\n\n    // Initial drawing of the graph\n    drawGraph();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}