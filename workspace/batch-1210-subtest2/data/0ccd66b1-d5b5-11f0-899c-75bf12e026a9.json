{
  "id": "0ccd66b1-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:45:49.883Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "K-Means Clustering",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>K-Means Clustering Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0; padding: 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background: #f9f9f9;\n  }\n  h1 {\n    margin: 1rem;\n    color: #333;\n  }\n  #canvas-container {\n    position: relative;\n    margin: 1rem;\n    border: 2px solid #ccc;\n    background: #fff;\n  }\n  canvas {\n    display: block;\n    background: #fafafa;\n    cursor: crosshair;\n  }\n  #controls {\n    margin: 1rem;\n    display: flex;\n    gap: 1rem;\n    flex-wrap: wrap;\n    align-items: center;\n    justify-content: center;\n  }\n  label {\n    font-weight: 600;\n    color: #555;\n  }\n  input[type=number] {\n    width: 60px;\n    padding: 0.2rem;\n    font-size: 1rem;\n  }\n  button {\n    padding: 0.5rem 1rem;\n    font-size: 1rem;\n    cursor: pointer;\n    border: none;\n    border-radius: 4px;\n    color: white;\n    background-color: #0078d7;\n    transition: background-color 0.3s;\n  }\n  button:hover:not(:disabled) {\n    background-color: #005fa3;\n  }\n  button:disabled {\n    background-color: #999;\n    cursor: not-allowed;\n  }\n  #info {\n    max-width: 600px;\n    margin: 1rem;\n    color: #444;\n    text-align: center;\n    font-size: 0.9rem;\n  }\n  #resetBtn {\n    background-color: #cc4b37;\n  }\n  #resetBtn:hover {\n    background-color: #9f3527;\n  }\n</style>\n</head>\n<body>\n  <h1>K-Means Clustering Interactive Demo</h1>\n\n  <div id=\"canvas-container\">\n    <canvas id=\"canvas\" width=\"700\" height=\"500\" tabindex=\"0\" aria-label=\"Canvas for K-Means clustering visualization\"></canvas>\n  </div>\n\n  <div id=\"controls\">\n    <label for=\"kInput\">Number of Clusters (k):</label>\n    <input type=\"number\" id=\"kInput\" min=\"1\" max=\"10\" value=\"3\" />\n    <button id=\"startBtn\" title=\"Start K-Means Clustering\">Start Clustering</button>\n    <button id=\"stepBtn\" title=\"Perform one iteration of K-Means\" disabled>Step</button>\n    <button id=\"runBtn\" title=\"Run full K-Means to convergence\" disabled>Run</button>\n    <button id=\"resetBtn\" title=\"Clear all points and start over\">Reset</button>\n  </div>\n\n  <div id=\"info\">\n    <p>\n      Click inside the canvas to add 2D points (data). Set the number of clusters <em>k</em>, then start the clustering process. You can step through iterations or run to convergence.\n    </p>\n  </div>\n\n<script>\n(() => {\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n\n  const kInput = document.getElementById('kInput');\n  const startBtn = document.getElementById('startBtn');\n  const stepBtn = document.getElementById('stepBtn');\n  const runBtn = document.getElementById('runBtn');\n  const resetBtn = document.getElementById('resetBtn');\n\n  const width = canvas.width;\n  const height = canvas.height;\n  const pointRadius = 5;\n  const centroidRadius = 10;\n\n  let points = [];  // {x, y, cluster}\n  let centroids = []; // {x, y}\n  let k = 3;\n\n  let state = 'input'; // 'input', 'clustering', 'finished'\n  let converged = false;\n\n  // Colors for clusters - repeat if k > colors.length\n  const colors = [\n    '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',\n    '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',\n  ];\n\n  // Utility functions\n  function distanceSquared(p1, p2) {\n    const dx = p1.x - p2.x;\n    const dy = p1.y - p2.y;\n    return dx*dx + dy*dy;\n  }\n\n  function drawPoint(p) {\n    ctx.beginPath();\n    ctx.arc(p.x, p.y, pointRadius, 0, 2*Math.PI);\n    if (p.cluster === null || p.cluster === undefined) {\n      ctx.fillStyle = '#888'; // unclustered points gray\n    } else {\n      ctx.fillStyle = colors[p.cluster % colors.length];\n      ctx.globalAlpha = 0.7;\n    }\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    // Draw black outline\n    ctx.strokeStyle = '#222';\n    ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  function drawCentroid(c, idx) {\n    ctx.beginPath();\n    ctx.arc(c.x, c.y, centroidRadius, 0, 2*Math.PI);\n    ctx.fillStyle = colors[idx % colors.length];\n    ctx.fill();\n    ctx.strokeStyle = '#000';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // Draw label (cluster number)\n    ctx.fillStyle = '#fff';\n    ctx.font = 'bold 14px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(idx + 1, c.x, c.y);\n  }\n\n  function clearCanvas() {\n    ctx.clearRect(0, 0, width, height);\n  }\n\n  // Draw all points and centroids\n  function draw() {\n    clearCanvas();\n\n    // Draw points first\n    for (const p of points) {\n      drawPoint(p);\n    }\n\n    // Draw centroids if any\n    if(state !== 'input') {\n      for (let i=0; i<centroids.length; i++) {\n        drawCentroid(centroids[i], i);\n      }\n    }\n  }\n\n  // Assign each point to the nearest centroid\n  // Returns true if any point changed its cluster assignment\n  function assignClusters() {\n    let changed = false;\n    for (const p of points) {\n      let minDist = Infinity;\n      let bestCluster = null;\n      for (let i = 0; i < centroids.length; i++) {\n        const dist = distanceSquared(p, centroids[i]);\n        if (dist < minDist) {\n          minDist = dist;\n          bestCluster = i;\n        }\n      }\n      if (p.cluster !== bestCluster) {\n        changed = true;\n        p.cluster = bestCluster;\n      }\n    }\n    return changed;\n  }\n\n  // Move centroids to mean of assigned points\n  // Returns true if any centroid changed position significantly\n  function updateCentroids() {\n    let moved = false;\n    for (let i = 0; i < centroids.length; i++) {\n      const clusterPoints = points.filter(p => p.cluster === i);\n      if (clusterPoints.length === 0) continue; // no points assigned\n      const meanX = clusterPoints.reduce((sum,p) => sum + p.x, 0) / clusterPoints.length;\n      const meanY = clusterPoints.reduce((sum,p) => sum + p.y, 0) / clusterPoints.length;\n      const old = centroids[i];\n      const distMoved = Math.sqrt(distanceSquared(old, {x: meanX, y: meanY}));\n      if(distMoved > 1e-3) {\n        moved = true;\n        centroids[i] = {x: meanX, y: meanY};\n      }\n    }\n    return moved;\n  }\n\n  // Initialize centroids randomly from existing points\n  // If fewer points than k, pick random locations inside canvas\n  function initializeCentroids() {\n    centroids = [];\n    if(points.length >= k){\n      // Random unique indices from points\n      const chosenIndices = new Set();\n      while (chosenIndices.size < k) {\n        const idx = Math.floor(Math.random()*points.length);\n        chosenIndices.add(idx);\n      }\n      for (const idx of chosenIndices) {\n        const p = points[idx];\n        centroids.push({x: p.x, y: p.y});\n      }\n    } else {\n      // Less points than k, random places on canvas\n      for (let i=0; i<k; i++) {\n        centroids.push({x: Math.random()*width, y: Math.random()*height});\n      }\n    }\n  }\n\n  // Perform one iteration: assign clusters, update centroids\n  // Returns true if converged this iteration\n  function iterate() {\n    const clusterChanged = assignClusters();\n    const centroidsMoved = updateCentroids();\n    draw();\n    converged = !(clusterChanged || centroidsMoved);\n    if(converged) {\n      state = 'finished';\n      stepBtn.disabled = true;\n      runBtn.disabled = true;\n      startBtn.disabled = false;\n      kInput.disabled = false;\n    }\n    return converged;\n  }\n\n  // Run until convergence with small delay for animation\n  async function runToConvergence() {\n    startBtn.disabled = true;\n    stepBtn.disabled = true;\n    runBtn.disabled = true;\n    kInput.disabled = true;\n    resetBtn.disabled = true;\n\n    while(!converged) {\n      iterate();\n      await new Promise(r => setTimeout(r, 300));\n    }\n\n    resetBtn.disabled = false;\n  }\n\n  // Add point at mouse location\n  function handleCanvasClick(e) {\n    if(state !== 'input') return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    points.push({x, y, cluster: null});\n    draw();\n  }\n\n  // Reset everything\n  function reset() {\n    points = [];\n    centroids = [];\n    state = 'input';\n    converged = false;\n    kInput.disabled = false;\n    startBtn.disabled = false;\n    stepBtn.disabled = true;\n    runBtn.disabled = true;\n    draw();\n  }\n\n  // When start button clicked\n  function startClustering() {\n    k = parseInt(kInput.value);\n    if (isNaN(k) || k < 1) {\n      alert('Please enter a valid number of clusters (k >= 1).');\n      return;\n    }\n    if(points.length === 0) {\n      alert('Please add some points by clicking on the canvas before starting clustering.');\n      return;\n    }\n    if(points.length < k) {\n      alert('Number of clusters k should be less or equal to number of points.');\n      return;\n    }\n\n    state = 'clustering';\n    converged = false;\n    kInput.disabled = true;\n    startBtn.disabled = true;\n    stepBtn.disabled = false;\n    runBtn.disabled = false;\n\n    // Clear cluster assignments before new start\n    for(const p of points){\n      p.cluster = null;\n    }\n\n    initializeCentroids();\n\n    draw();\n  }\n\n  // Event listeners\n  canvas.addEventListener('click', handleCanvasClick);\n  startBtn.addEventListener('click', startClustering);\n  stepBtn.addEventListener('click', () => {\n    if(state === 'clustering' && !converged){\n      iterate();\n    }\n  });\n  runBtn.addEventListener('click', () => {\n    if(state === 'clustering' && !converged){\n      runToConvergence();\n    }\n  });\n  resetBtn.addEventListener('click', reset);\n\n  // Initial draw\n  draw();\n\n  // Accessibility: enable keyboard enter key to add point\n  canvas.addEventListener('keydown', e => {\n    if(e.key === 'Enter'){\n      // Add point at center of canvas\n      const x = width/2;\n      const y = height/2;\n      if(state === 'input'){\n        points.push({x, y, cluster:null});\n        draw();\n      }\n    }\n  });\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "K-Means Clustering"
    }
  ],
  "topic": "K-Means Clustering",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}