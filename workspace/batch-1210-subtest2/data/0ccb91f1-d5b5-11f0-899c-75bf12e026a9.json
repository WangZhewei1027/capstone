{
  "id": "0ccb91f1-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:45:42.330Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Weighted Graph",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Weighted Graph Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    text-align: center;\n  }\n  #graph-container {\n    margin: 20px auto;\n    width: 600px;\n    height: 600px;\n    border: 1px solid #ccc;\n    position: relative;\n    background: #f9f9f9;\n  }\n  svg {\n    width: 100%;\n    height: 100%;\n  }\n  .node circle {\n    fill: #4a90e2;\n    stroke: #2c70b8;\n    stroke-width: 2px;\n    cursor: pointer;\n    transition: fill 0.3s;\n  }\n  .node text {\n    pointer-events: none;\n    fill: #fff;\n    font-weight: bold;\n    font-size: 14px;\n  }\n  .edge path {\n    stroke: #666;\n    stroke-width: 2px;\n    fill: none;\n  }\n  .edge text {\n    fill: #333;\n    font-size: 12px;\n    font-weight: bold;\n    user-select: none;\n  }\n  .info {\n    margin-top: 15px;\n    font-size: 16px;\n  }\n  #shortest-path-btn {\n    margin-top: 15px;\n    padding: 10px 20px;\n    font-size: 15px;\n    cursor: pointer;\n  }\n  #instructions {\n    margin-bottom: 10px;\n  }\n</style>\n</head>\n<body>\n<h1>Weighted Graph Visualization & Shortest Path</h1>\n<div id=\"instructions\">\n  <strong>Instructions:</strong> Click two nodes (start and end) to find the shortest path using Dijkstra's algorithm.\n</div>\n<div id=\"graph-container\">\n  <svg id=\"graph-svg\" viewBox=\"0 0 600 600\" preserveAspectRatio=\"xMidYMid meet\"></svg>\n</div>\n<div class=\"info\" id=\"info\">Click a node to select the start point.</div>\n<button id=\"reset-selection\" style=\"margin-top:10px;\">Reset Selection</button>\n\n<script>\n  // Weighted graph data\n  // Nodes with id, label and (x,y) coordinates for visualization\n  const nodes = [\n    {id: 'A', label: 'A', x: 100, y: 100},\n    {id: 'B', label: 'B', x: 300, y: 80},\n    {id: 'C', label: 'C', x: 480, y: 130},\n    {id: 'D', label: 'D', x: 150, y: 300},\n    {id: 'E', label: 'E', x: 350, y: 280},\n    {id: 'F', label: 'F', x: 470, y: 350},\n    {id: 'G', label: 'G', x: 270, y: 450},\n    {id: 'H', label: 'H', x: 430, y: 520},\n  ];\n\n  // Edges as pairs with weights\n  // Undirected edges\n  const edges = [\n    {from: 'A', to: 'B', weight: 4},\n    {from: 'A', to: 'D', weight: 7},\n    {from: 'B', to: 'C', weight: 6},\n    {from: 'B', to: 'E', weight: 5},\n    {from: 'C', to: 'F', weight: 2},\n    {from: 'D', to: 'E', weight: 3},\n    {from: 'D', to: 'G', weight: 8},\n    {from: 'E', to: 'F', weight: 1},\n    {from: 'E', to: 'G', weight: 4},\n    {from: 'F', to: 'H', weight: 7},\n    {from: 'G', to: 'H', weight: 3}\n  ];\n\n  // Setup SVG and draw nodes/edges\n  const svg = document.getElementById('graph-svg');\n\n  // Create groups for edges and nodes\n  const edgesGroup = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  edgesGroup.setAttribute('id', 'edges');\n  svg.appendChild(edgesGroup);\n\n  const nodesGroup = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  nodesGroup.setAttribute('id', 'nodes');\n  svg.appendChild(nodesGroup);\n\n  // Helper: get node by id\n  function getNode(id) {\n    return nodes.find(n => n.id === id);\n  }\n\n  // Draw edges with weight labels\n  edges.forEach(({from, to, weight}) => {\n    const fromNode = getNode(from);\n    const toNode = getNode(to);\n\n    // Draw line as a path (straight line)\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    path.classList.add('edge');\n    path.setAttribute('d', `M ${fromNode.x} ${fromNode.y} L ${toNode.x} ${toNode.y}`);\n    path.setAttribute('stroke', '#666');\n    path.setAttribute('stroke-width', 2);\n    path.setAttribute('fill', 'none');\n    path.setAttribute('pointer-events', 'none'); // so clicks go to nodes\n\n    edgesGroup.appendChild(path);\n\n    // Calculate midpoint for weight label\n    const mx = (fromNode.x + toNode.x) / 2;\n    const my = (fromNode.y + toNode.y) / 2;\n\n    // Slight offset the label perpendicular to the edge for clarity\n    const dx = toNode.x - fromNode.x;\n    const dy = toNode.y - fromNode.y;\n    const length = Math.sqrt(dx*dx + dy*dy);\n    const offsetX = -dy / length * 15;\n    const offsetY = dx / length * 15;\n\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    text.classList.add('edge');\n    text.setAttribute('x', mx + offsetX);\n    text.setAttribute('y', my + offsetY);\n    text.textContent = weight;\n    text.style.userSelect = 'none';\n    text.setAttribute('pointer-events', 'none');\n\n    edgesGroup.appendChild(text);\n  });\n\n  // Draw nodes\n  nodes.forEach(({id, label, x, y}) => {\n    const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    g.classList.add('node');\n    g.setAttribute('transform', `translate(${x},${y})`);\n    g.dataset.id = id;\n\n    const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    circle.setAttribute('r', 20);\n\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    text.setAttribute('text-anchor', 'middle');\n    text.setAttribute('dy', '0.35em');\n    text.textContent = label;\n\n    g.appendChild(circle);\n    g.appendChild(text);\n\n    nodesGroup.appendChild(g);\n  });\n\n  // Selection for shortest path start and end\n  let selectedNodes = [];\n  const info = document.getElementById('info');\n  const resetBtn = document.getElementById('reset-selection');\n\n  function resetSelection() {\n    selectedNodes = [];\n    info.textContent = 'Click a node to select the start point.';\n    clearHighlights();\n  }\n  resetBtn.addEventListener('click', resetSelection);\n\n  // Highlight utilities\n  function clearHighlights() {\n    // Reset edges and nodes styles\n    svg.querySelectorAll('.node circle').forEach(c => {\n      c.style.fill = '#4a90e2';\n      c.style.stroke = '#2c70b8';\n    });\n    svg.querySelectorAll('.edge path').forEach(p => {\n      p.style.stroke = '#666';\n      p.style.strokeWidth = 2;\n    });\n  }\n\n  function highlightPath(path) {\n    clearHighlights();\n    if (!path || path.length < 2) return;\n\n    // Highlight nodes\n    path.forEach(id => {\n      const g = svg.querySelector(`.node[data-id='${id}']`);\n      if (g) {\n        const circle = g.querySelector('circle');\n        circle.style.fill = '#e94e77'; // red highlight\n        circle.style.stroke = '#b9325c';\n      }\n    });\n\n    // Highlight edges connecting path nodes\n    for (let i=0; i<path.length-1; i++) {\n      const from = path[i];\n      const to = path[i+1];\n      edgesGroup.querySelectorAll('path').forEach(pathEl => {\n        // get d attribute and check if it matches edge from->to or to->from\n        // d = \"M x1 y1 L x2 y2\"\n        const d = pathEl.getAttribute('d');\n        const fromNode = getNode(from);\n        const toNode = getNode(to);\n        const candidates = [\n          `M ${fromNode.x} ${fromNode.y} L ${toNode.x} ${toNode.y}`,\n          `M ${toNode.x} ${toNode.y} L ${fromNode.x} ${fromNode.y}`,\n        ];\n        if (candidates.includes(d)) {\n          pathEl.style.stroke = '#e94e77';\n          pathEl.style.strokeWidth = 4;\n        }\n      });\n    }\n  }\n\n  function dijkstra(startId, endId) {\n    // Build adjacency list\n    const adjacency = {};\n    nodes.forEach(n => adjacency[n.id] = []);\n    edges.forEach(({from, to, weight}) => {\n      adjacency[from].push({node: to, weight});\n      adjacency[to].push({node: from, weight});\n    });\n\n    const distances = {};\n    const prev = {};\n    const visited = new Set();\n\n    nodes.forEach(n => distances[n.id] = Infinity);\n    distances[startId] = 0;\n\n    const pq = new Map(); // simple priority queue with Map: nodeId->distance\n    pq.set(startId, 0);\n\n    while(pq.size > 0) {\n      // Get node with min distance in pq\n      let currentNode = null;\n      let currentDist = Infinity;\n      for (const [nodeId, dist] of pq.entries()) {\n        if (dist < currentDist) {\n          currentDist = dist;\n          currentNode = nodeId;\n        }\n      }\n      pq.delete(currentNode);\n\n      if (currentNode === endId) {\n        break; // shortest path found\n      }\n      visited.add(currentNode);\n\n      adjacency[currentNode].forEach(({node: neighbor, weight}) => {\n        if (visited.has(neighbor)) return;\n        const alt = distances[currentNode] + weight;\n        if (alt < distances[neighbor]) {\n          distances[neighbor] = alt;\n          prev[neighbor] = currentNode;\n          pq.set(neighbor, alt);\n        }\n      });\n    }\n\n    // Reconstruct path\n    const path = [];\n    let u = endId;\n    if (prev[u] !== undefined || u === startId) {\n      while(u) {\n        path.unshift(u);\n        if (u === startId) break;\n        u = prev[u];\n      }\n    }\n    if (path[0] !== startId) return null; // no path\n    return {path, distance: distances[endId]};\n  }\n\n  // Handle node clicks\n  nodesGroup.querySelectorAll('.node').forEach(g => {\n    g.addEventListener('click', e => {\n      const nodeId = g.dataset.id;\n      if (selectedNodes.length === 0) {\n        selectedNodes.push(nodeId);\n        info.textContent = `Start node selected: ${nodeId}. Now select the end node.`;\n        highlightPath([nodeId]);\n      } else if (selectedNodes.length === 1) {\n        if (nodeId === selectedNodes[0]) {\n          info.textContent = `End node cannot be the same as start node. Select a different node.`;\n          return;\n        }\n        selectedNodes.push(nodeId);\n        info.textContent = `End node selected: ${nodeId}. Calculating shortest path...`;\n\n        // Compute shortest path\n        const result = dijkstra(selectedNodes[0], selectedNodes[1]);\n        if (!result) {\n          info.textContent = `No path found between ${selectedNodes[0]} and ${selectedNodes[1]}.`;\n          highlightPath(null);\n        } else {\n          info.textContent = `Shortest path from ${selectedNodes[0]} to ${selectedNodes[1]}: ${result.path.join(' â†’ ')} (Distance: ${result.distance})`;\n          highlightPath(result.path);\n        }\n      } else {\n        info.textContent = `Please reset selection to start again.`;\n      }\n    });\n  });\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Weighted Graph"
    }
  ],
  "topic": "Weighted Graph",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}