{
  "id": "0ccca362-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:46:15.154Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Floyd-Warshall Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>Floyd-Warshall Algorithm Visualization</title>\n  <style>\n    body {\n      font-family: Arial, sans-serif;\n      margin: 20px;\n      background: #f5f5f5;\n    }\n    h1 {\n      text-align: center;\n    }\n    #inputArea {\n      margin-bottom: 20px;\n      max-width: 600px;\n      margin-left: auto;\n      margin-right: auto;\n      background: white;\n      padding: 15px 20px;\n      border-radius: 8px;\n      box-shadow: 0 0 10px #ccc;\n    }\n    label {\n      display: block;\n      margin-top: 10px;\n      font-weight: bold;\n    }\n    textarea, input[type=number] {\n      width: 100%;\n      font-family: monospace;\n      font-size: 1rem;\n      margin-top: 5px;\n      padding: 8px;\n      box-sizing: border-box;\n      border-radius: 4px;\n      border: 1px solid #ccc;\n      resize: vertical;\n    }\n    button {\n      margin-top: 15px;\n      padding: 10px 15px;\n      font-size: 1rem;\n      border: none;\n      background-color: #007bff;\n      color: white;\n      border-radius: 5px;\n      cursor: pointer;\n      width: 100%;\n    }\n    button:hover {\n      background-color: #0056b3;\n    }\n    #outputArea {\n      max-width: 800px;\n      margin: 20px auto 40px auto;\n      background: white;\n      padding: 20px;\n      border-radius: 8px;\n      box-shadow: 0 0 10px #ccc;\n      overflow-x: auto;\n    }\n    table {\n      border-collapse: collapse;\n      margin-top: 10px;\n      width: 100%;\n      max-width: 100%;\n    }\n    th, td {\n      border: 1px solid #ddd;\n      text-align: center;\n      padding: 8px;\n      min-width: 40px;\n    }\n    th {\n      background-color: #007bff;\n      color: white;\n      position: sticky;\n      top: 0;\n      z-index: 2;\n    }\n    td.infinity {\n      color: #d9534f;\n      font-weight: bold;\n    }\n    #stepControls {\n      max-width: 800px;\n      margin: 10px auto 0 auto;\n      display: flex;\n      justify-content: center;\n      gap: 10px;\n    }\n    #stepControls button {\n      width: auto;\n      padding: 10px 20px;\n    }\n\n    #description {\n      max-width: 800px;\n      margin: 0 auto 30px auto;\n      background: white;\n      padding: 15px 20px;\n      border-radius: 8px;\n      box-shadow: 0 0 10px #ccc;\n      line-height: 1.5;\n    }\n    .highlight {\n      background-color: #fff3cd;\n    }\n    #status {\n      max-width: 800px;\n      margin: 10px auto;\n      text-align: center;\n      font-weight: bold;\n      font-size: 1.1rem;\n    }\n    small {\n      color: #777;\n    }\n    @media (max-width: 600px) {\n      #stepControls {\n        flex-direction: column;\n        gap: 8px;\n      }\n      button {\n        font-size: 0.9rem;\n      }\n    }\n  </style>\n</head>\n<body>\n  <h1>Floyd-Warshall Algorithm Visualization</h1>\n  <div id=\"description\">\n    <p>The Floyd-Warshall algorithm finds the shortest paths between all pairs of vertices in a weighted graph (with positive or negative edge weights but no negative cycles).</p>\n    <p>Input the adjacency matrix of your graph below, where each row represents the edges from the corresponding vertex. Use <code>INF</code> or <code>Infinity</code> for no direct edge. For instance, with 4 vertices, input a 4x4 matrix like this:</p>\n    <pre>[\n[0, 3, INF, 7],\n[8, 0, 2, INF],\n[5, INF, 0, 1],\n[2, INF, INF, 0]\n]</pre>\n    <p>Press \"Run Algorithm\" to see step-by-step how shortest paths between all pairs get updated.</p>\n    <small>Note: Vertices are zero-indexed (0 to n-1).</small>\n  </div>\n  <div id=\"inputArea\">\n    <label for=\"matrixInput\">Adjacency Matrix (JSON Array of Arrays):</label>\n    <textarea id=\"matrixInput\" rows=\"8\" spellcheck=\"false\">\n[\n[0, 3, Infinity, 7],\n[8, 0, 2, Infinity],\n[5, Infinity, 0, 1],\n[2, Infinity, Infinity, 0]\n]\n    </textarea>\n    <button id=\"runButton\">Run Algorithm</button>\n  </div>\n  <div id=\"status\"></div>\n  <div id=\"outputArea\"></div>\n  <div id=\"stepControls\" style=\"display:none;\">\n    <button id=\"prevStep\" disabled>Previous Step</button>\n    <button id=\"nextStep\" disabled>Next Step</button>\n    <button id=\"autoPlay\">Auto Play</button>\n    <button id=\"resetSteps\">Reset</button>\n  </div>\n\n  <script>\n    (() => {\n      const matrixInput = document.getElementById(\"matrixInput\");\n      const runButton = document.getElementById(\"runButton\");\n      const outputArea = document.getElementById(\"outputArea\");\n      const status = document.getElementById(\"status\");\n      const stepControls = document.getElementById(\"stepControls\");\n      const prevStepBtn = document.getElementById(\"prevStep\");\n      const nextStepBtn = document.getElementById(\"nextStep\");\n      const autoPlayBtn = document.getElementById(\"autoPlay\");\n      const resetStepsBtn = document.getElementById(\"resetSteps\");\n\n      let steps = [];\n      let currentStep = 0;\n      let autoPlayInterval = null;\n\n      /**\n       * Parse input text as adjacency matrix\n       * - Accepts Infinity or INF (case insensitive) as Infinity\n       * - Validates square matrix with zero diagonal\n       */\n      function parseMatrix(input) {\n        let matrix;\n        try {\n          // Use Function to parse JSON so we can have Infinity as valid token\n          matrix = (new Function('return ' + input.trim() + ';'))();\n        } catch (e) {\n          throw new Error(\"Invalid input: Please enter a valid JSON array of arrays.\");\n        }\n\n        // Validate\n        if (!Array.isArray(matrix) || matrix.length === 0) {\n          throw new Error(\"Input must be a non-empty 2D array.\");\n        }\n        const n = matrix.length;\n        for (let i = 0; i < n; i++) {\n          if (!Array.isArray(matrix[i]) || matrix[i].length !== n) {\n            throw new Error(\"Matrix must be square (all rows must have same number of elements as columns).\");\n          }\n          for (let j = 0; j < n; j++) {\n            // Replace strings \"INF\",\"Infinity\"(case-insensitive) with Infinity\n            let val = matrix[i][j];\n            if (typeof val === \"string\") {\n              if (/^inf(inity)?$/i.test(val.trim())) {\n                matrix[i][j] = Infinity;\n              } else {\n                let num = Number(val);\n                if (isNaN(num)) {\n                  throw new Error(`Invalid matrix element at [${i}][${j}]: must be a number or \"INF\"/\"Infinity\".`);\n                }\n                matrix[i][j] = num;\n              }\n            } else if (typeof val !== \"number\") {\n              throw new Error(`Matrix element at [${i}][${j}] must be a number.`);\n            }\n          }\n          if (typeof matrix[i][i] !== \"number\" || matrix[i][i] !== 0) {\n            throw new Error(\"Diagonal elements must be zero.\");\n          }\n        }\n        return matrix;\n      }\n\n      // Deep copy matrix\n      function copyMatrix(m) {\n        return m.map(row => row.slice());\n      }\n\n      /**\n       * Build a HTML table to display the matrix with optional highlight cells\n       * @param {number[][]} matrix \n       * @param {{i?: number, j?: number, k?: number, updatedCell?: [number, number]}=} highlight \n       *      highlight.k - current intermediate vertex\n       *      highlight.i, highlight.j - current cell in iteration\n       *      highlight.updatedCell - cell where update happened\n       */\n      function buildMatrixTable(matrix, highlight = {}) {\n        const n = matrix.length;\n        const table = document.createElement(\"table\");\n        // Header row\n        const thead = document.createElement(\"thead\");\n        const topRow = document.createElement(\"tr\");\n        topRow.appendChild(document.createElement(\"th\")); // empty top-left corner\n        for (let col = 0; col < n; col++) {\n          const th = document.createElement(\"th\");\n          th.textContent = col;\n          topRow.appendChild(th);\n        }\n        thead.appendChild(topRow);\n        table.appendChild(thead);\n\n        const tbody = document.createElement(\"tbody\");\n        for (let i = 0; i < n; i++) {\n          const tr = document.createElement(\"tr\");\n          const rowHeader = document.createElement(\"th\");\n          rowHeader.textContent = i;\n          tr.appendChild(rowHeader);\n          for (let j = 0; j < n; j++) {\n            const td = document.createElement(\"td\");\n            let val = matrix[i][j];\n            if (val === Infinity) {\n              td.textContent = \"∞\";\n              td.classList.add(\"infinity\");\n            } else {\n              td.textContent = val.toFixed(2).replace(/\\.00$/, \"\");\n            }\n            // Highlighting logic:\n            if (highlight.updatedCell && highlight.updatedCell[0] === i && highlight.updatedCell[1] === j) {\n              td.classList.add(\"highlight\");\n              td.title = \"Updated in this step\";\n            } else if (highlight.i === i && highlight.j === j) {\n              td.style.backgroundColor = \"#d1ecf1\"; // light blue\n              td.title = \"Currently considering\";\n            }\n            tr.appendChild(td);\n          }\n          tbody.appendChild(tr);\n        }\n        table.appendChild(tbody);\n        return table;\n      }\n\n      /**\n       * Floyd-Warshall Algorithm with step-by-step recording\n       * Steps contain:\n       *  - k: intermediate vertex considered\n       *  - i: row vertex\n       *  - j: column vertex\n       *  - beforeMatrix: matrix before update at this cell\n       *  - afterMatrix: matrix after update at this cell (only updated if improved)\n       *  - updated: boolean, true if the entry got updated in this inner iteration\n       */\n      function floydWarshallWithSteps(graph) {\n        const n = graph.length;\n        let dist = copyMatrix(graph);\n        const allSteps = [];\n\n        for (let k = 0; k < n; k++) {\n          for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n              const beforeMatrix = copyMatrix(dist);\n              let updated = false;\n              if (dist[i][k] !== Infinity && dist[k][j] !== Infinity) {\n                const newDist = dist[i][k] + dist[k][j];\n                if (newDist < dist[i][j]) {\n                  dist[i][j] = newDist;\n                  updated = true;\n                }\n              }\n              const afterMatrix = copyMatrix(dist);\n              allSteps.push({\n                k, i, j, beforeMatrix, afterMatrix, updated\n              });\n            }\n          }\n        }\n        return {finalMatrix: dist, steps: allSteps};\n      }\n\n      // Render a step in outputArea\n      function renderStep(step) {\n        outputArea.innerHTML = \"\";\n        const { k, i, j, beforeMatrix, afterMatrix, updated } = step;\n        const n = beforeMatrix.length;\n\n        const infoDiv = document.createElement(\"div\");\n        infoDiv.style.marginBottom = \"10px\";\n\n        // Describe the step\n        let msg = `Considering if vertex <strong>${k}</strong> acts as an intermediate between <strong>${i}</strong> and <strong>${j}</strong>:<br>`;\n        let dist_ik = beforeMatrix[i][k];\n        let dist_kj = beforeMatrix[k][j];\n        let dist_ij = beforeMatrix[i][j];\n        let newDist = (dist_ik === Infinity || dist_kj === Infinity) ? Infinity : dist_ik + dist_kj;\n\n        function fmt(v) { return v === Infinity ? \"∞\" : v.toFixed(2).replace(/\\.00$/, \"\"); }\n\n        msg += `d[${i}][${k}] = ${fmt(dist_ik)}, d[${k}][${j}] = ${fmt(dist_kj)} → `;\n        msg += `sum = ${fmt(newDist)} vs current d[${i}][${j}] = ${fmt(dist_ij)}.<br>`;\n\n        if (newDist < dist_ij) {\n          msg += `<span style=\"color: green; font-weight: bold;\">Update: d[${i}][${j}] will be updated to ${fmt(newDist)}.</span>`;\n        } else {\n          msg += `No update performed.`;\n        }\n        infoDiv.innerHTML = msg;\n        outputArea.appendChild(infoDiv);\n\n        // Show before matrix and after matrix side by side, highlight current cell and updated cell\n        const container = document.createElement(\"div\");\n        container.style.display = \"flex\";\n        container.style.justifyContent = \"space-around\";\n        container.style.flexWrap = \"wrap\";\n        container.style.gap = \"20px\";\n\n        const beforeDiv = document.createElement(\"div\");\n        beforeDiv.style.flex = \"1 1 300px\";\n        beforeDiv.innerHTML = `<strong>Before Update</strong>`;\n        beforeDiv.appendChild(buildMatrixTable(beforeMatrix, {i, j, k}));\n        \n        const afterDiv = document.createElement(\"div\");\n        afterDiv.style.flex = \"1 1 300px\";\n        afterDiv.innerHTML = `<strong>After Update</strong>`;\n        afterDiv.appendChild(buildMatrixTable(afterMatrix, {updatedCell: updated ? [i,j] : null}));\n\n        container.appendChild(beforeDiv);\n        container.appendChild(afterDiv);\n        outputArea.appendChild(container);\n      }\n\n      // Render final result matrix\n      function renderFinalMatrix(matrix) {\n        const finalDiv = document.createElement(\"div\");\n        finalDiv.style.maxWidth = \"600px\";\n        finalDiv.style.margin = \"30px auto 10px auto\";\n        finalDiv.innerHTML = `<h2>Final Shortest Path Distance Matrix</h2>`;\n        finalDiv.appendChild(buildMatrixTable(matrix));\n        outputArea.appendChild(finalDiv);\n      }\n\n      function disableStepControls(disabled) {\n        prevStepBtn.disabled = disabled || currentStep === 0;\n        nextStepBtn.disabled = disabled || currentStep >= steps.length - 1;\n      }\n\n      function stopAutoPlay() {\n        if (autoPlayInterval) {\n          clearInterval(autoPlayInterval);\n          autoPlayInterval = null;\n          autoPlayBtn.textContent = \"Auto Play\";\n        }\n      }\n\n      runButton.addEventListener(\"click\", () => {\n        stopAutoPlay();\n        outputArea.innerHTML = \"\";\n        status.textContent = \"\";\n        stepControls.style.display = \"none\";\n        currentStep = 0;\n        steps = [];\n\n        let matrix;\n        try {\n          matrix = parseMatrix(matrixInput.value);\n        } catch (err) {\n          status.style.color = \"red\";\n          status.textContent = err.message;\n          return;\n        }\n\n        status.style.color = \"black\";\n        status.textContent = \"Running Floyd-Warshall algorithm...\";\n\n        // Run algorithm with steps\n        setTimeout(() => { // timeout so UI updates\n          const result = floydWarshallWithSteps(matrix);\n          steps = result.steps;\n          status.textContent = `Algorithm completed: ${steps.length} steps. Use navigation buttons below to see each step.`;\n          stepControls.style.display = \"flex\";\n\n          renderStep(steps[currentStep]);\n          disableStepControls(false);\n          renderFinalMatrix(result.finalMatrix);\n        }, 50);\n      });\n\n      prevStepBtn.addEventListener(\"click\", () => {\n        if (currentStep > 0) {\n          currentStep--;\n          renderStep(steps[currentStep]);\n          disableStepControls(false);\n          stopAutoPlay();\n        }\n      });\n\n      nextStepBtn.addEventListener(\"click\", () => {\n        if (currentStep < steps.length - 1) {\n          currentStep++;\n          renderStep(steps[currentStep]);\n          disableStepControls(false);\n          stopAutoPlay();\n        }\n      });\n\n      autoPlayBtn.addEventListener(\"click\", () => {\n        if (autoPlayInterval) {\n          // Stop auto play\n          stopAutoPlay();\n        } else {\n          // Start auto play\n          if (currentStep >= steps.length - 1) {\n            currentStep = 0; // restart from beginning\n          }\n          autoPlayBtn.textContent = \"Pause\";\n          autoPlayInterval = setInterval(() => {\n            renderStep(steps[currentStep]);\n            disableStepControls(false);\n            if (currentStep < steps.length - 1) {\n              currentStep++;\n            } else {\n              stopAutoPlay();\n            }\n          }, 700);\n        }\n      });\n\n      resetStepsBtn.addEventListener(\"click\", () => {\n        stopAutoPlay();\n        if (steps.length > 0) {\n          currentStep = 0;\n          renderStep(steps[currentStep]);\n          disableStepControls(false);\n        }\n      });\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Floyd-Warshall Algorithm"
    }
  ],
  "topic": "Floyd-Warshall Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}