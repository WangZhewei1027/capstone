{
  "id": "0ccc2e30-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:46:06.011Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Heap Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Heap Sort Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f5f7fa;\n    color: #333;\n  }\n  h1 {\n    text-align: center;\n  }\n  #inputSection {\n    text-align: center;\n    margin-bottom: 20px;\n  }\n  #arrayInput {\n    width: 300px;\n    font-size: 1rem;\n    padding: 8px;\n  }\n  button {\n    padding: 8px 15px;\n    font-size: 1rem;\n    margin-left: 10px;\n    cursor: pointer;\n    border: none;\n    background-color: #2c7be5;\n    color: white;\n    border-radius: 4px;\n  }\n  button:disabled {\n    background-color: #a0a9b8;\n    cursor: not-allowed;\n  }\n  #arrayContainer {\n    max-width: 90vw;\n    margin: 20px auto;\n    display: flex;\n    justify-content: center;\n    flex-wrap: wrap;\n    gap: 8px;\n  }\n  .array-bar {\n    display: flex;\n    flex-direction: column;\n    justify-content: flex-end;\n    align-items: center;\n    width: 30px;\n    background-color: #a0c4ff;\n    margin: 0 2px;\n    border-radius: 3px;\n    transition: background-color 0.3s ease;\n  }\n  .array-bar.highlight {\n    background-color: #ff595e;\n  }\n  .array-bar.sorted {\n    background-color: #1982c4;\n  }\n  .bar-value {\n    margin-top: 5px;\n    font-size: 0.85rem;\n    user-select: none;\n  }\n  #log {\n    max-width: 900px;\n    margin: 30px auto;\n    padding: 15px;\n    background-color: #e9efff;\n    border-radius: 8px;\n    height: 150px;\n    overflow-y: auto;\n    font-family: monospace;\n    font-size: 0.9rem;\n    white-space: pre-wrap;\n  }\n  #speedControl {\n    margin-top: 15px;\n    text-align: center;\n  }\n  label {\n    font-weight: bold;\n  }\n  input[type=\"range\"] {\n    width: 200px;\n    vertical-align: middle;\n    margin-left: 10px;\n  }\n  #footer {\n    text-align: center;\n    margin-top: 30px;\n    font-size: 0.9rem;\n    color: #666;\n  }\n  @media (max-width: 500px) {\n    .array-bar {\n      width: 20px;\n    }\n    #arrayInput {\n      width: 90vw;\n    }\n  }\n</style>\n</head>\n<body>\n<h1>Heap Sort Visualizer</h1>\n\n<div id=\"inputSection\">\n  <input id=\"arrayInput\" type=\"text\" placeholder=\"Enter numbers separated by commas\" />\n  <button id=\"startBtn\">Start Sorting</button>\n  <div id=\"speedControl\">\n    <label for=\"speedRange\">Animation Speed:</label>\n    <input type=\"range\" id=\"speedRange\" min=\"50\" max=\"1000\" value=\"500\" />\n    <span id=\"speedValue\">500 ms</span>\n  </div>\n</div>\n\n<div id=\"arrayContainer\"></div>\n\n<div id=\"log\"></div>\n\n<div id=\"footer\">\n  Enter a list of integers separated by commas (e.g. 12, 3, 5, 7, 19).<br />\n  The algorithm will visualize heap sort step by step.\n</div>\n\n<script>\n(() => {\n  const arrayInput = document.getElementById('arrayInput');\n  const startBtn = document.getElementById('startBtn');\n  const arrayContainer = document.getElementById('arrayContainer');\n  const logArea = document.getElementById('log');\n  const speedRange = document.getElementById('speedRange');\n  const speedValue = document.getElementById('speedValue');\n\n  let array = [];\n  let bars = [];\n  let animationSpeed = 500; // milliseconds\n\n  function log(message) {\n    logArea.textContent += message + \"\\n\";\n    logArea.scrollTop = logArea.scrollHeight;\n  }\n\n  function clearLog() {\n    logArea.textContent = \"\";\n  }\n\n  function createBars(arr) {\n    arrayContainer.innerHTML = \"\";\n    bars = [];\n    const max = Math.max(...arr.map(n => Math.abs(n)) );\n    for (let i = 0; i < arr.length; i++) {\n      const bar = document.createElement('div');\n      bar.classList.add('array-bar');\n      // Height proportional to value\n      // If negative values exist, handle their height differently: bar will still grow positive upward\n      const heightPercent = max === 0 ? 100 : (Math.abs(arr[i]) / max) * 100;\n      bar.style.height = `${heightPercent + 20}px`; // add 20px for minimum visibility\n      const label = document.createElement('div');\n      label.textContent = arr[i];\n      label.classList.add('bar-value');\n      bar.appendChild(label);\n      arrayContainer.appendChild(bar);\n      bars.push(bar);\n    }\n  }\n\n  function swap(arr, i, j) {\n    const temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  // sleep function returns a promise that resolves after ms milliseconds\n  function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Heapify subtree rooted at index i for heap size n\n  async function heapify(arr, n, i) {\n    let largest = i;\n    const left = 2 * i + 1;\n    const right = 2 * i + 2;\n\n    // Highlight current node\n    highlightBars([i], 'highlight');\n    log(`Heapify called on index ${i} (value: ${arr[i]})`);\n\n    if (left < n) {\n      highlightBars([left], 'highlight');\n      log(`Compare left child index ${left} (value: ${arr[left]}) with current largest index ${largest} (value: ${arr[largest]})`);\n      await sleep(animationSpeed);\n      if (arr[left] > arr[largest]) {\n        largest = left;\n        log(`Left child is larger, update largest to index ${largest}`);\n      }\n      unhighlightBars([left]);\n    }\n    if (right < n) {\n      highlightBars([right], 'highlight');\n      log(`Compare right child index ${right} (value: ${arr[right]}) with current largest index ${largest} (value: ${arr[largest]})`);\n      await sleep(animationSpeed);\n      if (arr[right] > arr[largest]) {\n        largest = right;\n        log(`Right child is larger, update largest to index ${largest}`);\n      }\n      unhighlightBars([right]);\n    }\n\n    if (largest !== i) {\n      log(`Swapping index ${i} (value: ${arr[i]}) and largest index ${largest} (value: ${arr[largest]})`);\n      await swapVisual(arr, i, largest);\n      await heapify(arr, n, largest);\n    } else {\n      log(`No swap needed, node at index ${i} is largest.`);\n    }\n    unhighlightBars([i]);\n  }\n\n  // Swaps elements in array and updates visualization bars with animations\n  async function swapVisual(arr, i, j) {\n    highlightBars([i, j], 'highlight');\n    await sleep(animationSpeed / 2);\n\n    // swap in array\n    swap(arr, i, j);\n\n    // update bar heights and labels\n    updateBar(bars[i], arr[i]);\n    updateBar(bars[j], arr[j]);\n\n    await sleep(animationSpeed / 2);\n    unhighlightBars([i, j]);\n  }\n\n  function updateBar(bar, value) {\n    const max = Math.max(...array.map(n => Math.abs(n))) || 1;\n    const heightPercent = (Math.abs(value)/max) * 100;\n    bar.style.height = `${heightPercent + 20}px`; // +20 for min visual height\n    bar.firstChild.textContent = value;\n  }\n\n  function highlightBars(indices, className) {\n    indices.forEach(i => bars[i]?.classList.add(className));\n  }\n\n  function unhighlightBars(indices, className = 'highlight') {\n    indices.forEach(i => bars[i]?.classList.remove(className));\n  }\n\n  function markSorted(index) {\n    if(bars[index]) bars[index].classList.add('sorted');\n  }\n\n  async function heapSort(arr) {\n    clearLog();\n    log(\"Starting Heap Sort...\");\n\n    const n = arr.length;\n\n    // Build max heap\n    log(\"Building max heap...\");\n    for (let i = Math.floor(n / 2) -1; i >= 0; i--) {\n      await heapify(arr, n, i);\n    }\n    log(\"Max heap constructed.\");\n\n    // One by one extract elements\n    for (let i = n - 1; i > 0; i--) {\n      log(`Swapping root (index 0, value: ${arr[0]}) with index ${i} (value: ${arr[i]})`);\n      // Move current root to end\n      await swapVisual(arr, 0, i);\n\n      // Mark the sorted element\n      markSorted(i);\n\n      // call max heapify on the reduced heap\n      log(`Heapifying root after removing index ${i} from heap`);\n      await heapify(arr, i, 0);\n    }\n    markSorted(0);\n    log(\"Heap Sort Completed!\");\n  }\n\n  function parseInput(input) {\n    return input\n      .split(',')\n      .map(e => e.trim())\n      .filter(e => e !== '')\n      .map(Number);\n  }\n\n  function validateInput(arr) {\n    if (arr.length === 0) return 'Input cannot be empty.';\n    if (arr.some(isNaN)) return 'Input contains non-numeric values.';\n    if(arr.length > 60) return 'Please enter 60 or fewer numbers for visualization.';\n    return null;\n  }\n\n  async function startSorting() {\n    startBtn.disabled = true;\n    arrayInput.disabled = true;\n    speedRange.disabled = true;\n\n    await heapSort(array);\n\n    startBtn.disabled = false;\n    arrayInput.disabled = false;\n    speedRange.disabled = false;\n  }\n\n  speedRange.addEventListener('input', () => {\n    animationSpeed = +speedRange.value;\n    speedValue.textContent = `${animationSpeed} ms`;\n  });\n\n  startBtn.addEventListener('click', () => {\n    const input = arrayInput.value;\n    const parsedArray = parseInput(input);\n    const error = validateInput(parsedArray);\n    if (error) {\n      alert(error);\n      return;\n    }\n    array = parsedArray;\n    createBars(array);\n    startSorting();\n  });\n\n  // Initial setup - example array\n  arrayInput.value = '12, 3, 19, 5, 7, 15, 2, 1';\n  array = parseInput(arrayInput.value);\n  createBars(array);\n\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap Sort"
    }
  ],
  "topic": "Heap Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}