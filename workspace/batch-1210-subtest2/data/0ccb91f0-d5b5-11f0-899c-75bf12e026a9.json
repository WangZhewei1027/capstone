{
  "id": "0ccb91f0-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:46:23.096Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Graph (Directed/Undirected)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Graph Visualization (Directed / Undirected)</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  #controls {\n    margin-bottom: 15px;\n  }\n  button {\n    margin-right: 10px;\n    padding: 8px 12px;\n    font-size: 16px;\n  }\n  canvas {\n    border: 1px solid #ccc;\n    background: #fafafa;\n    cursor: grab;\n  }\n  canvas:active {\n    cursor: grabbing;\n  }\n  #info {\n    margin-top: 10px;\n    font-size: 14px;\n    color: #555;\n  }\n</style>\n</head>\n<body>\n<h1>Graph Visualization: Directed / Undirected</h1>\n\n<div id=\"controls\">\n  <button id=\"toggleMode\">Switch to Undirected</button>\n  <button id=\"resetGraph\">Reset Graph</button>\n  <span>Instructions: Click on canvas to add nodes. Drag from one node to another to add edge. In Directed mode, edges have arrows.</span>\n</div>\n\n<canvas id=\"graphCanvas\" width=\"800\" height=\"600\"></canvas>\n<div id=\"info\"></div>\n\n<script>\n(() => {\n  const canvas = document.getElementById(\"graphCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const toggleBtn = document.getElementById(\"toggleMode\");\n  const resetBtn = document.getElementById(\"resetGraph\");\n  const infoDiv = document.getElementById(\"info\");\n\n  const NODE_RADIUS = 20;\n  const ARROW_HEAD_LENGTH = 12;\n  const ARROW_HEAD_ANGLE = Math.PI / 7;\n\n  let mode = \"directed\"; // or \"undirected\"\n  toggleBtn.textContent = \"Switch to Undirected\";\n\n  // Graph structure\n  const nodes = [];\n  const edges = []; // edges: {from: nodeId, to: nodeId}\n\n  let nodeIdCounter = 0;\n\n  // Interaction state\n  let draggingNode = null;\n  let draggingEdge = null; // {fromNode, toX, toY}\n  let dragOffsetX = 0;\n  let dragOffsetY = 0;\n\n  // Helper: distance between two points\n  function dist(x1, y1, x2, y2) {\n    return Math.hypot(x1 - x2, y1 - y2);\n  }\n\n  // Find node under given coordinates\n  function findNodeAt(x, y) {\n    return nodes.find((n) => dist(n.x, n.y, x, y) <= NODE_RADIUS);\n  }\n\n  // Draw arrow head at point (x,y) with direction angle\n  function drawArrowHead(x, y, angle) {\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x - ARROW_HEAD_LENGTH * Math.cos(angle - ARROW_HEAD_ANGLE), y - ARROW_HEAD_LENGTH * Math.sin(angle - ARROW_HEAD_ANGLE));\n    ctx.lineTo(x - ARROW_HEAD_LENGTH * Math.cos(angle + ARROW_HEAD_ANGLE), y - ARROW_HEAD_LENGTH * Math.sin(angle + ARROW_HEAD_ANGLE));\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Draw a node\n  function drawNode(node) {\n    ctx.beginPath();\n    ctx.fillStyle = \"#4a90e2\";\n    ctx.strokeStyle = \"#1c3d73\";\n    ctx.lineWidth = 2;\n    ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.fillStyle = \"white\";\n    ctx.font = \"bold 16px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(node.id, node.x, node.y);\n  }\n\n  // Draw edge\n  function drawEdge(edge) {\n    const fromNode = nodes.find((n) => n.id === edge.from);\n    const toNode = nodes.find((n) => n.id === edge.to);\n    if (!fromNode || !toNode) return;\n\n    const dx = toNode.x - fromNode.x;\n    const dy = toNode.y - fromNode.y;\n    const angle = Math.atan2(dy, dx);\n\n    // Start and end positions adjusted to node perimeter\n    const startX = fromNode.x + NODE_RADIUS * Math.cos(angle);\n    const startY = fromNode.y + NODE_RADIUS * Math.sin(angle);\n    let endX = toNode.x - NODE_RADIUS * Math.cos(angle);\n    let endY = toNode.y - NODE_RADIUS * Math.sin(angle);\n\n    // For undirected graphs with edges both ways: offset edges so they don't overlap exactly\n    let offsetX = 0,\n      offsetY = 0;\n    if (mode === \"undirected\") {\n      // Check if opposite edge exists\n      const oppositeEdge = edges.find(\n        (e) => e.from === edge.to && e.to === edge.from\n      );\n      if (oppositeEdge && edge.from < edge.to) {\n        // Offset edges by 8 px perpendicular to the line\n        const perpAngle = angle + Math.PI / 2;\n        offsetX = 8 * Math.cos(perpAngle);\n        offsetY = 8 * Math.sin(perpAngle);\n      } else if (oppositeEdge && edge.from > edge.to) {\n        const perpAngle = angle + Math.PI / 2;\n        offsetX = -8 * Math.cos(perpAngle);\n        offsetY = -8 * Math.sin(perpAngle);\n      }\n    }\n\n    ctx.strokeStyle = \"#333\";\n    ctx.fillStyle = \"#333\";\n    ctx.lineWidth = 2;\n\n    ctx.beginPath();\n    ctx.moveTo(startX + offsetX, startY + offsetY);\n    ctx.lineTo(endX + offsetX, endY + offsetY);\n    ctx.stroke();\n\n    if (mode === \"directed\") {\n      // Draw arrow head\n      drawArrowHead(endX + offsetX, endY + offsetY, angle);\n    }\n  }\n\n  // Redraw entire graph\n  function drawGraph() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw edges first\n    edges.forEach(drawEdge);\n\n    // Draw nodes on top\n    nodes.forEach(drawNode);\n\n    // Draw current dragging edge if any\n    if (draggingEdge) {\n      const fromNode = draggingEdge.fromNode;\n      const fromX = fromNode.x;\n      const fromY = fromNode.y;\n      const toX = draggingEdge.toX;\n      const toY = draggingEdge.toY;\n\n      const dx = toX - fromX;\n      const dy = toY - fromY;\n      const angle = Math.atan2(dy, dx);\n\n      const startX = fromX + NODE_RADIUS * Math.cos(angle);\n      const startY = fromY + NODE_RADIUS * Math.sin(angle);\n      const endX = toX;\n      const endY = toY;\n\n      ctx.strokeStyle = \"rgba(0,0,0,0.6)\";\n      ctx.fillStyle = \"rgba(0,0,0,0.6)\";\n      ctx.lineWidth = 2;\n\n      ctx.beginPath();\n      ctx.moveTo(startX, startY);\n      ctx.lineTo(endX, endY);\n      ctx.stroke();\n\n      if (mode === \"directed\") {\n        drawArrowHead(endX, endY, angle);\n      }\n    }\n  }\n\n  // Add a node at given position\n  function addNode(x, y) {\n    const node = { id: ++nodeIdCounter, x, y };\n    nodes.push(node);\n    drawGraph();\n    updateInfo();\n  }\n\n  // Add an edge from fromNode to toNode, prevents duplicates\n  function addEdge(fromId, toId) {\n    if (fromId === toId) return; // Prevent self-loops for simplicity\n\n    // Check if edge exists already\n    const exists = edges.some(\n      (e) =>\n        e.from === fromId &&\n        e.to === toId\n    );\n    if (!exists) {\n      edges.push({ from: fromId, to: toId });\n      drawGraph();\n      updateInfo();\n    }\n  }\n\n  // Remove all and reset\n  function resetGraph() {\n    nodes.length = 0;\n    edges.length = 0;\n    nodeIdCounter = 0;\n    drawGraph();\n    updateInfo();\n  }\n\n  // Update info display about graph\n  function updateInfo() {\n    infoDiv.textContent = `Mode: ${mode.toUpperCase()} | Nodes: ${nodes.length} | Edges: ${edges.length}`;\n  }\n\n  // Mouse events\n  let isDragging = false;\n\n  canvas.addEventListener(\"mousedown\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    const node = findNodeAt(x, y);\n    if (node) {\n      // Start dragging node\n      draggingNode = node;\n      dragOffsetX = x - node.x;\n      dragOffsetY = y - node.y;\n      isDragging = true;\n    } else {\n      // Start edge dragging mode? We'll allow click & drag from node to another to create edge.\n      draggingNode = null;\n      isDragging = false;\n    }\n  });\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    if (draggingNode && isDragging) {\n      // Drag to move node\n      draggingNode.x = x - dragOffsetX;\n      draggingNode.y = y - dragOffsetY;\n      drawGraph();\n    } else if (draggingEdge) {\n      // Update end position of edge line\n      draggingEdge.toX = x;\n      draggingEdge.toY = y;\n      drawGraph();\n    }\n  });\n\n  canvas.addEventListener(\"mouseup\", (e) => {\n    if (draggingNode && isDragging) {\n      // Finished dragging node\n      draggingNode = null;\n      isDragging = false;\n    } else if (draggingEdge) {\n      // Finish creating edge if releasing on node\n      const rect = canvas.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n      const toNode = findNodeAt(x, y);\n      if (toNode && toNode.id !== draggingEdge.fromNode.id) {\n        addEdge(draggingEdge.fromNode.id, toNode.id);\n      }\n      draggingEdge = null;\n      drawGraph();\n    }\n  });\n\n  // To create edges: On mousedown on a node + shift key pressed, start dragging edge line\n  // Alternatively: Right click to start edge create dragging\n  // To keep it simple: Ctrl + click and drag from node to node creates edge.\n  canvas.addEventListener(\"mousedown\", (e) => {\n    if (e.ctrlKey) {\n      const rect = canvas.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n      const node = findNodeAt(x, y);\n      if (node) {\n        draggingEdge = { fromNode: node, toX: x, toY: y };\n        drawGraph();\n        e.preventDefault();\n      }\n    }\n  });\n\n  // Add node on canvas click if not clicked on existing node or edge drag started\n  canvas.addEventListener(\"click\", (e) => {\n    if (draggingEdge || isDragging) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    if (!findNodeAt(x, y)) {\n      addNode(x, y);\n    }\n  });\n\n  // Switch mode button click\n  toggleBtn.addEventListener(\"click\", () => {\n    mode = mode === \"directed\" ? \"undirected\" : \"directed\";\n    toggleBtn.textContent =\n      mode === \"directed\" ? \"Switch to Undirected\" : \"Switch to Directed\";\n    drawGraph();\n    updateInfo();\n  });\n\n  // Reset button\n  resetBtn.addEventListener(\"click\", () => {\n    resetGraph();\n  });\n\n  // Initial state\n  drawGraph();\n  updateInfo();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Graph (Directed/Undirected)"
    }
  ],
  "topic": "Graph (Directed/Undirected)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}