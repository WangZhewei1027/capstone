{
  "id": "f767f752-d5b8-11f0-9ee1-ef07bdc6053d",
  "timestamp": "2025-12-10T11:12:58.458Z",
  "model": "gpt-4o-mini",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Dijkstra's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            background-color: #f4f4f4;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            height: 100vh;\n            margin: 0;\n        }\n        canvas {\n            border: 1px solid black;\n            margin-bottom: 20px;\n        }\n        #controls {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"canvas\" width=\"600\" height=\"400\"></canvas>\n    <div id=\"controls\">\n        <button onclick=\"runDijkstra()\">Run Dijkstra's Algorithm</button>\n        <button onclick=\"resetGraph()\">Reset Graph</button>\n    </div>\n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n\n        const nodes = [];\n        const edges = [];\n        let startNode = null;\n        let endNode = null;\n\n        class Node {\n            constructor(id, x, y) {\n                this.id = id;\n                this.x = x;\n                this.y = y;\n                this.edges = [];\n                this.distance = Infinity;\n                this.previous = null;\n                this.visited = false;\n            }\n\n            draw() {\n                ctx.fillStyle = this.visited ? 'lightgreen' : 'lightblue';\n                ctx.beginPath();\n                ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = 'black';\n                ctx.fillText(this.id, this.x - 5, this.y + 5);\n            }\n        }\n\n        class Edge {\n            constructor(fromNode, toNode, weight) {\n                this.fromNode = fromNode;\n                this.toNode = toNode;\n                this.weight = weight;\n                fromNode.edges.push(this);\n            }\n\n            draw() {\n                ctx.beginPath();\n                ctx.moveTo(this.fromNode.x, this.fromNode.y);\n                ctx.lineTo(this.toNode.x, this.toNode.y);\n                ctx.stroke();\n                ctx.fillStyle = 'red';\n                ctx.fillText(this.weight, (this.fromNode.x + this.toNode.x) / 2, (this.fromNode.y + this.toNode.y) / 2);\n            }\n        }\n\n        // Initialize nodes and edges\n        function initGraph() {\n            nodes.push(new Node('A', 100, 100));\n            nodes.push(new Node('B', 200, 50));\n            nodes.push(new Node('C', 300, 150));\n            nodes.push(new Node('D', 200, 200));\n            nodes.push(new Node('E', 400, 100));\n\n            new Edge(nodes[0], nodes[1], 1);\n            new Edge(nodes[1], nodes[2], 2);\n            new Edge(nodes[1], nodes[3], 1);\n            new Edge(nodes[2], nodes[4], 5);\n            new Edge(nodes[0], nodes[3], 4);\n            new Edge(nodes[3], nodes[4], 2);\n        }\n\n        function drawGraph() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            edges.forEach(edge => edge.draw());\n            nodes.forEach(node => node.draw());\n        }\n\n        async function runDijkstra() {\n            startNode = nodes[0]; // Starting from node A\n            endNode = nodes[nodes.length - 1]; // Ending at node E\n            startNode.distance = 0;\n\n            let unvisited = [...nodes];\n\n            while (unvisited.length > 0) {\n                // Get the node with the smallest distance\n                let currentNode = unvisited.reduce((minNode, node) => (node.distance < minNode.distance ? node : minNode), unvisited[0]);\n                if (currentNode.distance === Infinity) break;\n\n                currentNode.visited = true;\n                unvisited = unvisited.filter(node => node !== currentNode);\n                drawGraph();\n\n                for (const edge of currentNode.edges) {\n                    const neighbor = edge.toNode;\n                    if (!neighbor.visited) {\n                        const newDistance = currentNode.distance + edge.weight;\n                        if (newDistance < neighbor.distance) {\n                            neighbor.distance = newDistance;\n                            neighbor.previous = currentNode;\n                        }\n                    }\n                }\n\n                await new Promise(resolve => setTimeout(resolve, 500)); // Delay for visualization\n            }\n\n            highlightPath();\n        }\n\n        function highlightPath() {\n            let node = endNode;\n            while (node) {\n                node.visited = true; // Highlight the path\n                node = node.previous;\n            }\n            drawGraph();\n        }\n\n        function resetGraph() {\n            nodes.length = 0;\n            edges.length = 0;\n            initGraph();\n            drawGraph();\n        }\n\n        initGraph();\n        drawGraph();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}