{
  "id": "0cccca72-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:45:17.239Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Topological Sort",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Topological Sort Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f0f2f5;\n  }\n  h1 {\n    text-align: center;\n  }\n  #graphInput {\n    width: 100%;\n    height: 120px;\n    font-family: monospace;\n    font-size: 14px;\n  }\n  #runBtn {\n    margin-top: 10px;\n    padding: 8px 16px;\n    font-size: 16px;\n  }\n  #output {\n    margin-top: 20px;\n    background: white;\n    padding: 15px;\n    border-radius: 6px;\n    box-shadow: 0 0 10px rgba(0,0,0,0.1);\n    min-height: 60px;\n    font-size: 18px;\n    white-space: pre-wrap;\n  }\n  #error {\n    color: red;\n    margin-top: 10px;\n    font-weight: bold;\n  }\n  label {\n    font-weight: bold;\n  }\n  #explanation {\n    margin-top: 20px;\n    background: #fff8dc;\n    border-left: 5px solid #ffd700;\n    padding: 15px;\n    border-radius: 6px;\n    font-size: 14px;\n    line-height: 1.5;\n  }\n</style>\n</head>\n<body>\n<h1>Topological Sort Demo</h1>\n\n<label for=\"graphInput\">Enter graph edges (one per line): <br />\n<small>Format: <code>node -> node1,node2,...</code> or <code>node</code> for isolated nodes. Nodes can be strings without spaces.</small></label>\n<textarea id=\"graphInput\" spellcheck=\"false\">5 -> 0,2\n4 -> 0,1\n2 -> 3\n3 -> 1\n0\n1\n</textarea>\n<br />\n<button id=\"runBtn\">Run Topological Sort</button>\n\n<div id=\"error\"></div>\n\n<div id=\"output\"></div>\n\n<div id=\"explanation\">\n<strong>What is Topological Sort?</strong><br />\nTopological sort is an ordering of the vertices in a directed acyclic graph (DAG) such that for every directed edge <code>U → V</code>, vertex <code>U</code> comes before <code>V</code> in the ordering.<br />\n<br />\nIf the graph contains a cycle, a topological ordering is not possible.<br />\n<br />\nThis demo uses Depth-First Search (DFS) to perform topological sorting and detects cycles.<br />\n</div>\n\n<script>\n(function() {\n  // Utility to parse input edges to adjacency list\n  function parseInput(text) {\n    // Each line: node -> node1,node2,...\n    // or just node (isolated)\n    const lines = text.trim().split('\\n');\n    const graph = Object.create(null); // adjacency list\n\n    for (const line of lines) {\n      const trimmed = line.trim();\n      if (!trimmed) continue;\n      let [node, neighbors] = trimmed.split('->').map(s => s.trim());\n      if (!node) continue;\n      if (!graph[node]) graph[node] = [];\n      if (neighbors) {\n        const neighList = neighbors.split(',').map(n => n.trim()).filter(n => n.length);\n        graph[node].push(...neighList);\n        // Ensure all neighbors exist in graph even if no outgoing edges\n        for (const n of neighList) {\n          if (!(n in graph)) graph[n] = [];\n        }\n      } else {\n        // ensure node is in graph even if isolated\n        if (!(node in graph)) graph[node] = [];\n      }\n    }\n    return graph;\n  }\n\n  // Topological sort using DFS\n  // Returns an object - { order: [...], cycle: boolean, cycleNodes: [...] }\n  function topologicalSort(graph) {\n    const visited = new Set();\n    const visiting = new Set();\n    const stack = [];\n    let cycleFound = false;\n    let cyclePath = [];\n\n    // We keep track of parents to reconstruct cycle if found\n    const parents = {};\n\n    function dfs(node) {\n      if (cycleFound) return;\n      visiting.add(node);\n\n      for (const n of graph[node]) {\n        if (!visited.has(n)) {\n          if (visiting.has(n)) {\n            // Cycle detected\n            cycleFound = true;\n            // reconstruct cycle path from n to node\n            cyclePath = [n];\n            let cur = node;\n            while (cur !== n && cur !== undefined) {\n              cyclePath.push(cur);\n              cur = parents[cur];\n            }\n            cyclePath.push(n);\n            cyclePath.reverse();\n            return;\n          }\n          parents[n] = node;\n          dfs(n);\n          if (cycleFound) return;\n        }\n      }\n\n      visiting.delete(node);\n      visited.add(node);\n      stack.push(node);\n    }\n\n    for (const node of Object.keys(graph)) {\n      if (!visited.has(node)) {\n        dfs(node);\n        if (cycleFound) break;\n      }\n    }\n\n    if (cycleFound) {\n      return { order: [], cycle: true, cycleNodes: cyclePath };\n    } else {\n      return { order: stack.reverse(), cycle: false };\n    }\n  }\n\n  function displayGraph(graph) {\n    const lines = [];\n    for (const node in graph) {\n      if (graph[node].length) {\n        lines.push(`${node} → ${graph[node].join(', ')}`);\n      } else {\n        lines.push(`${node} (no outgoing edges)`);\n      }\n    }\n    return lines.join('\\n');\n  }\n\n  // UI elements\n  const input = document.getElementById('graphInput');\n  const runBtn = document.getElementById('runBtn');\n  const outputDiv = document.getElementById('output');\n  const errorDiv = document.getElementById('error');\n\n  runBtn.onclick = () => {\n    errorDiv.textContent = '';\n    outputDiv.textContent = '';\n\n    let graph;\n    try {\n      graph = parseInput(input.value);\n      if (Object.keys(graph).length === 0) {\n        errorDiv.textContent = 'Graph is empty or invalid format.';\n        return;\n      }\n    } catch(e) {\n      errorDiv.textContent = 'Error parsing graph input.';\n      return;\n    }\n\n    const result = topologicalSort(graph);\n\n    if (result.cycle) {\n      errorDiv.textContent = 'Cycle detected! Topological sort not possible.';\n      outputDiv.innerHTML = `<strong>Cycle path:</strong> ${result.cycleNodes.join(' → ')}`;\n    } else {\n      outputDiv.innerHTML = `<strong>Topological Order:</strong> ${result.order.join(' → ')}`;\n    }\n  };\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Topological Sort"
    }
  ],
  "topic": "Topological Sort",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}