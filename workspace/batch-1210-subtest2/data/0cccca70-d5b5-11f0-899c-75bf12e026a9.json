{
  "id": "0cccca70-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:46:56.501Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Kruskal’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <title>Kruskal's Algorithm Visualization</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 0;\n            display: flex;\n            flex-direction: column;\n            height: 100vh;\n            overflow: hidden;\n        }\n        header {\n            background: #3f51b5;\n            color: white;\n            padding: 1rem;\n            text-align: center;\n        }\n        main {\n            flex: 1;\n            display: flex;\n            flex-direction: row;\n            overflow: hidden;\n        }\n        #graph-container {\n            flex: 1;\n            position: relative;\n            background: #f0f0f0;\n            border-right: 1px solid #ccc;\n        }\n        canvas {\n            width: 100%;\n            height: 100%;\n            display: block;\n            background: #fafafa;\n        }\n        #info-panel {\n            width: 350px;\n            padding: 10px 20px;\n            box-sizing: border-box;\n            overflow-y: auto;\n            background: #ffffff;\n            border-left: 1px solid #ccc;\n        }\n        h2 {\n            margin-top: 0;\n        }\n        .step-highlight {\n            background: #fffbcc;\n            border-left: 4px solid #ffca28;\n            padding-left: 6px;\n            margin: 6px 0;\n        }\n        #controls {\n            margin-bottom: 15px;\n        }\n        button {\n            background-color: #3f51b5;\n            border: none;\n            color: white;\n            padding: 10px 15px;\n            margin-right: 10px;\n            cursor: pointer;\n            font-size: 1rem;\n            border-radius: 3px;\n            transition: background-color 0.3s ease;\n        }\n        button:disabled {\n            background-color: #9fa8da;\n            cursor: default;\n        }\n        #edge-list {\n            font-family: monospace;\n            max-height: 150px;\n            overflow-y: auto;\n            background: #eeeeee;\n            padding: 10px;\n            border-radius: 4px;\n        }\n        #mst-list {\n            font-family: monospace;\n            max-height: 150px;\n            overflow-y: auto;\n            background: #e8f5e9;\n            padding: 10px;\n            border-radius: 4px;\n        }\n        #legend {\n            margin-top: 15px;\n            font-size: 0.9rem;\n        }\n        #legend span {\n            display: inline-flex;\n            align-items: center;\n            margin-right: 15px;\n        }\n        #legend .box {\n            width: 16px;\n            height: 16px;\n            margin-right: 5px;\n            display: inline-block;\n            border-radius: 3px;\n        }\n        #legend .edge {\n            border-bottom: 2px solid;\n            display: inline-block;\n            width: 20px;\n            margin-right: 5px;\n        }\n        a {\n            color: #3f51b5;\n            text-decoration: none;\n        }\n        a:hover {\n            text-decoration: underline;\n        }\n        #note {\n            font-size: 0.85rem;\n            color: #555;\n            margin-top: 10px;\n        }\n        /* Scrollbar styling for lists */\n        #edge-list::-webkit-scrollbar,\n        #mst-list::-webkit-scrollbar {\n            width: 8px;\n        }\n        #edge-list::-webkit-scrollbar-track,\n        #mst-list::-webkit-scrollbar-track {\n            background: #f1f1f1;\n        }\n        #edge-list::-webkit-scrollbar-thumb,\n        #mst-list::-webkit-scrollbar-thumb {\n            background: #888;\n            border-radius: 4px;\n        }\n        #edge-list::-webkit-scrollbar-thumb:hover,\n        #mst-list::-webkit-scrollbar-thumb:hover {\n            background: #555;\n        }\n    </style>\n</head>\n<body>\n    <header>\n        <h1>Kruskal's Algorithm Visualization</h1>\n        <div>Minimum Spanning Tree (MST) construction step-by-step</div>\n    </header>\n    <main>\n        <div id=\"graph-container\">\n            <canvas id=\"graph-canvas\"></canvas>\n        </div>\n        <aside id=\"info-panel\">\n            <div id=\"controls\">\n                <button id=\"prev-step\" disabled>Previous Step</button>\n                <button id=\"next-step\">Next Step</button>\n                <button id=\"reset-btn\">Reset</button>\n            </div>\n            <h2>Edges (sorted by weight):</h2>\n            <div id=\"edge-list\"></div>\n\n            <h2>Current MST Edges:</h2>\n            <div id=\"mst-list\"></div>\n\n            <h2>Algorithm Explanation:</h2>\n            <div id=\"explanation\"></div>\n\n            <div id=\"legend\">\n                <strong>Legend:</strong><br />\n                <span><span class=\"box\" style=\"background:#bbb;\"></span>Node</span>\n                <span><span class=\"edge\" style=\"border-color:#bbb;\"></span>Unchecked edge</span><br/>\n                <span><span class=\"edge\" style=\"border-color:#4caf50;\"></span>Selected (MST) edge</span>\n                <span><span class=\"edge\" style=\"border-color:#f44336; opacity:0.6;\"></span>Rejected edge (creates cycle)</span>\n            </div>\n            <div id=\"note\">\n                Note: Nodes can be dragged to reposition for better visibility.<br/>\n                Source code of <a href=\"https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\" target=\"_blank\" rel=\"noopener noreferrer\">Kruskal's Algorithm (Wikipedia)</a>.\n            </div>\n        </aside>\n    </main>\n    <script>\n        (() => {\n            // Graph data - undirected weighted graph\n            // Nodes: id, x, y (canvas coordinates)\n            // Edges: u, v, weight\n            // We'll define nodes placed in a circle for clarity but allow dragging the nodes.\n            const canvas = document.getElementById('graph-canvas');\n            const ctx = canvas.getContext('2d');\n            let width, height;\n\n            function resize() {\n                width = canvas.clientWidth;\n                height = canvas.clientHeight;\n                const dpr = window.devicePixelRatio || 1;\n                canvas.width = width * dpr;\n                canvas.height = height * dpr;\n                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n            }\n            resize();\n            window.addEventListener('resize', () => {\n                resize();\n                drawGraph();\n            });\n\n            // Node radius for drawing\n            const NODE_RADIUS = 16;\n\n            // Graph Example Setup\n            // Use a small graph for clarity\n            // Nodes on a circle centered in the canvas\n            const NODE_POSITIONS = [];\n            const NODE_COUNT = 7;\n            const CENTER = {x: 0, y: 0};\n            const RADIUS = 150;\n\n            // initialize positions after knowing canvas size\n            function initNodePositions() {\n                CENTER.x = width / 2;\n                CENTER.y = height / 2;\n                NODE_POSITIONS.length = 0;\n                for (let i = 0; i < NODE_COUNT; i++) {\n                    const angle = (2 * Math.PI * i) / NODE_COUNT - Math.PI / 2;\n                    let x = CENTER.x + RADIUS * Math.cos(angle);\n                    let y = CENTER.y + RADIUS * Math.sin(angle);\n                    NODE_POSITIONS.push({id: i, x, y});\n                }\n            }\n            initNodePositions();\n\n            // Graph edges (u, v, weight) - undirected\n            // Ensure it's connected enough for meaningful MST\n            // Weights are chosen arbitrarily but reasonably spread\n            let EDGES = [\n                {u:0, v:1, w:7},\n                {u:0, v:3, w:5},\n                {u:1, v:2, w:8},\n                {u:1, v:3, w:9},\n                {u:1, v:4, w:7},\n                {u:2, v:4, w:5},\n                {u:3, v:4, w:15},\n                {u:3, v:5, w:6},\n                {u:4, v:5, w:8},\n                {u:4, v:6, w:9},\n                {u:5, v:6, w:11},\n            ];\n\n            // Sort edges by weight ascending for Kruskal\n            // We'll keep a separate sorted copy so we can highlight them in order\n            const sortedEdges = [...EDGES].sort((a,b) => a.w - b.w);\n\n            // Disjoint Set Union (Union-Find) for cycle detection\n            class DSU {\n                constructor(n) {\n                    this.parent = new Array(n);\n                    this.rank = new Array(n);\n                    for(let i = 0; i < n; i++) {\n                        this.parent[i] = i;\n                        this.rank[i] = 0;\n                    }\n                }\n                find(x) {\n                    if(this.parent[x] !== x) {\n                        this.parent[x] = this.find(this.parent[x]);\n                    }\n                    return this.parent[x];\n                }\n                union(a,b) {\n                    a = this.find(a);\n                    b = this.find(b);\n                    if(a === b) return false;\n                    if(this.rank[a] < this.rank[b]) {\n                        this.parent[a] = b;\n                    } else if(this.rank[b] < this.rank[a]) {\n                        this.parent[b] = a;\n                    } else {\n                        this.parent[b] = a;\n                        this.rank[a]++;\n                    }\n                    return true;\n                }\n            }\n\n            // Visual State:\n            // - For each edge: status = \"unchecked\", \"accepted\", \"rejected\"\n            // We'll simulate the algorithm step by step.\n            // Each step considers one edge.\n            // On accepting edge: union sets.\n            // On rejecting edge: no union.\n\n            let currentStep = -1; // before first edge considered\n            const edgeStatuses = new Map(); // edge index -> status\n\n            function resetState() {\n                currentStep = -1;\n                edgeStatuses.clear();\n                updateUI();\n                drawGraph();\n            }\n\n            // Step forward\n            function nextStep() {\n                if(currentStep >= sortedEdges.length - 1) return;\n                currentStep++;\n                const edge = sortedEdges[currentStep];\n                // Check if adding this edge creates a cycle\n                const dsu = new DSU(NODE_COUNT);\n                for(let i = 0; i < currentStep; i++) {\n                    if(edgeStatuses.get(i) === 'accepted') {\n                        dsu.union(sortedEdges[i].u, sortedEdges[i].v);\n                    }\n                }\n                if(dsu.union(edge.u, edge.v)) {\n                    // accepted\n                    edgeStatuses.set(currentStep, 'accepted');\n                } else {\n                    // rejected (would create cycle)\n                    edgeStatuses.set(currentStep, 'rejected');\n                }\n                updateUI();\n                drawGraph();\n            }\n\n            // Step backward\n            function prevStep() {\n                if(currentStep < 0) return;\n                edgeStatuses.delete(currentStep);\n                currentStep--;\n                updateUI();\n                drawGraph();\n            }\n\n            // Canvas Drawing Helpers\n\n            // Clear canvas\n            function clearCanvas() {\n                ctx.clearRect(0, 0, width, height);\n            }\n\n            // Draw nodes as circles with labels\n            // Drag capability implemented below\n            function drawNodes() {\n                for(let node of NODE_POSITIONS) {\n                    // Node circle\n                    ctx.beginPath();\n                    ctx.fillStyle = '#bbb';\n                    ctx.strokeStyle = '#666';\n                    ctx.lineWidth = 2;\n                    ctx.shadowColor = 'rgba(0,0,0,0.1)';\n                    ctx.shadowBlur = 4;\n                    ctx.shadowOffsetX = 1;\n                    ctx.shadowOffsetY = 1;\n                    ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI*2);\n                    ctx.fill();\n                    ctx.shadowColor = 'transparent';\n                    ctx.stroke();\n\n                    // Node label\n                    ctx.fillStyle = '#222';\n                    ctx.font = 'bold 14px Arial';\n                    ctx.textAlign = 'center';\n                    ctx.textBaseline = 'middle';\n                    ctx.fillText(node.id.toString(), node.x, node.y);\n                }\n            }\n\n            // Draw edges with different styles depending on status\n            function drawEdges() {\n                for(let i=0; i<sortedEdges.length; i++) {\n                    const edge = sortedEdges[i];\n                    const n1 = NODE_POSITIONS[edge.u];\n                    const n2 = NODE_POSITIONS[edge.v];\n                    const status = edgeStatuses.get(i) || 'unchecked';\n                    ctx.beginPath();\n                    ctx.lineWidth = 3;\n                    // edge color and style based on status\n                    if(status === 'accepted') {\n                        ctx.strokeStyle = '#4caf50'; // green\n                        ctx.shadowColor = 'rgba(76, 175, 80, 0.5)';\n                        ctx.shadowBlur = 8;\n                        ctx.setLineDash([]);\n                    } else if(status === 'rejected') {\n                        ctx.strokeStyle = 'rgba(244, 67, 54, 0.5)'; // red transparent\n                        ctx.shadowColor = 'transparent';\n                        ctx.setLineDash([10,6]);\n                    } else {\n                        ctx.strokeStyle = '#bbb';\n                        ctx.shadowColor = 'transparent';\n                        ctx.setLineDash([]);\n                    }\n                    ctx.moveTo(n1.x, n1.y);\n                    ctx.lineTo(n2.x, n2.y);\n                    ctx.stroke();\n                    ctx.shadowColor = 'transparent';\n                    ctx.setLineDash([]);\n\n                    // Draw weight label in middle of edge\n                    const midX = (n1.x + n2.x)/2;\n                    const midY = (n1.y + n2.y)/2;\n                    ctx.fillStyle = '#444';\n                    ctx.font = 'normal 12px Arial';\n                    ctx.textAlign = 'center';\n                    ctx.textBaseline = 'middle';\n                    // Draw weight background circle for readability\n                    ctx.beginPath();\n                    ctx.fillStyle = 'white';\n                    ctx.arc(midX, midY, 12, 0, Math.PI*2);\n                    ctx.fill();\n                    ctx.fillStyle = '#444';\n                    ctx.fillText(edge.w.toString(), midX, midY);\n                }\n            }\n\n            function drawGraph() {\n                clearCanvas();\n                drawEdges();\n                drawNodes();\n            }\n\n            // UI Elements\n            const prevBtn = document.getElementById('prev-step');\n            const nextBtn = document.getElementById('next-step');\n            const resetBtn = document.getElementById('reset-btn');\n            const edgeListDiv = document.getElementById('edge-list');\n            const mstListDiv = document.getElementById('mst-list');\n            const explanationDiv = document.getElementById('explanation');\n\n            // Explanation texts for each step\n            function getExplanation(step) {\n                if(step < 0) {\n                    return 'Algorithm not started yet. Click \"Next Step\" to begin considering edges.';\n                }\n                if(step >= sortedEdges.length) {\n                    return 'All edges considered. MST construction complete!';\n                }\n                const edge = sortedEdges[step];\n                const status = edgeStatuses.get(step);\n                let text = `Considering edge <strong>${edge.u} - ${edge.v}</strong> with weight <strong>${edge.w}</strong>. `;\n                if(status === 'accepted') {\n                    text += 'Adding this edge does NOT create a cycle, so it is <span style=\"color:#4caf50;\">accepted</span> into the MST.';\n                } else if(status === 'rejected') {\n                    text += 'Adding this edge would create a cycle, so it is <span style=\"color:#f44336;\">rejected</span>.';\n                } else {\n                    text += 'Deciding this edge status...';\n                }\n                return text;\n            }\n\n            // Update edge list display, MST list display and buttons\n            function updateUI() {\n                // Update edges display with statuses\n                // Show edges with their index and status, highlight current edge being considered\n                let edgeHTML = '';\n                for(let i=0; i<sortedEdges.length; i++) {\n                    const e = sortedEdges[i];\n                    const status = edgeStatuses.get(i) || 'unchecked';\n                    let color, weightColor;\n                    switch(status) {\n                        case 'accepted': color = '#4caf50'; break;\n                        case 'rejected': color = '#f44336'; break;\n                        default: color = '#555'; break;\n                    }\n                    const highlight = (i === currentStep) ? 'step-highlight' : '';\n                    edgeHTML += `<div class=\"${highlight}\" style=\"color:${color};\">\n                        [${i}] Edge ${e.u} - ${e.v}, weight: <strong>${e.w}</strong>\n                    </div>`;\n                }\n                edgeListDiv.innerHTML = edgeHTML;\n\n                // MST edges\n                let mstHTML = '';\n                for(let i=0; i<=currentStep; i++) {\n                    if(edgeStatuses.get(i) === 'accepted') {\n                        const e = sortedEdges[i];\n                        mstHTML += `Edge ${e.u} - ${e.v} (wt: ${e.w})<br/>`;\n                    }\n                }\n                if(!mstHTML) mstHTML = '<i>No edges selected yet.</i>';\n                mstListDiv.innerHTML = mstHTML;\n\n                // Explanation text\n                explanationDiv.innerHTML = getExplanation(currentStep);\n\n                // Buttons enable/disable\n                prevBtn.disabled = currentStep < 0;\n                nextBtn.disabled = currentStep >= sortedEdges.length - 1;\n            }\n\n            // Node Dragging to reposition nodes\n            let draggingNode = null;\n            let dragOffsetX = 0;\n            let dragOffsetY = 0;\n\n            canvas.addEventListener('mousedown', (e) => {\n                const rect = canvas.getBoundingClientRect();\n                const mouseX = (e.clientX - rect.left);\n                const mouseY = (e.clientY - rect.top);\n                // Check if mouse is inside any node\n                for(let node of NODE_POSITIONS) {\n                    const dx = mouseX - node.x;\n                    const dy = mouseY - node.y;\n                    if(dx*dx + dy*dy <= NODE_RADIUS*NODE_RADIUS) {\n                        draggingNode = node;\n                        dragOffsetX = dx;\n                        dragOffsetY = dy;\n                        break;\n                    }\n                }\n            });\n            window.addEventListener('mouseup', () => {\n                draggingNode = null;\n            });\n            window.addEventListener('mousemove', e => {\n                if(draggingNode) {\n                    const rect = canvas.getBoundingClientRect();\n                    let x = (e.clientX - rect.left) - dragOffsetX;\n                    let y = (e.clientY - rect.top) - dragOffsetY;\n                    // Clamp inside canvas\n                    x = Math.min(width - NODE_RADIUS, Math.max(NODE_RADIUS, x));\n                    y = Math.min(height - NODE_RADIUS, Math.max(NODE_RADIUS, y));\n                    draggingNode.x = x;\n                    draggingNode.y = y;\n                    drawGraph();\n                }\n            });\n\n            // Button event listeners\n            prevBtn.addEventListener('click', () => {\n                prevStep();\n            });\n            nextBtn.addEventListener('click', () => {\n                nextStep();\n            });\n            resetBtn.addEventListener('click', () => {\n                resetState();\n            });\n\n            // Initialize UI and graph drawing\n            resetState();\n        })();\n    </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Kruskal’s Algorithm"
    }
  ],
  "topic": "Kruskal’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}