{
  "id": "0ccca360-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:48:01.412Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Dijkstra’s Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Dijkstra's Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 0;\n    display: flex;\n    height: 100vh;\n    overflow: hidden;\n  }\n  #controls {\n    width: 320px;\n    background: #f4f4f4;\n    border-right: 1px solid #ccc;\n    padding: 20px;\n    box-sizing: border-box;\n    overflow-y: auto;\n  }\n  #graph-container {\n    flex-grow: 1;\n    background: #222;\n    position: relative;\n  }\n  h2 {\n    margin-top: 0;\n  }\n  label {\n    display: block;\n    margin-top: 10px;\n    font-weight: bold;\n  }\n  input[type=\"number\"], select {\n    width: 100%;\n    padding: 5px;\n    font-size: 14px;\n    margin-top: 4px;\n    box-sizing: border-box;\n  }\n  button {\n    margin-top: 15px;\n    width: 100%;\n    padding: 10px;\n    font-size: 16px;\n    cursor: pointer;\n    background: #007bff;\n    color: white;\n    border: none;\n    border-radius: 3px;\n  }\n  button:disabled {\n    background: #999;\n    cursor: default;\n  }\n  #log {\n    margin-top: 15px;\n    height: 120px;\n    overflow-y: auto;\n    background: #fff;\n    border: 1px solid #ccc;\n    padding: 10px;\n    font-size: 13px;\n    white-space: pre-wrap;\n  }\n  svg {\n    width: 100%;\n    height: 100%;\n    display: block;\n  }\n  .node {\n    cursor: pointer;\n    transition: fill 0.3s, stroke 0.3s;\n  }\n  .node circle {\n    fill: #3498db;\n    stroke: #2980b9;\n    stroke-width: 3px;\n    transition: fill 0.3s, stroke 0.3s;\n  }\n  .node text {\n    fill: #fff;\n    font-weight: bold;\n    pointer-events: none;\n    user-select: none;\n  }\n  .edge {\n    stroke: #aaa;\n    stroke-width: 2px;\n    marker-end: url(#arrow);\n    transition: stroke 0.3s, stroke-width 0.3s;\n  }\n  .edge.highlighted {\n    stroke: #e74c3c;\n    stroke-width: 4px;\n  }\n  .node.visited circle {\n    fill: #2ecc71;\n    stroke: #27ae60;\n  }\n  .node.current circle {\n    fill: #e67e22;\n    stroke: #d35400;\n  }\n  .node.start circle {\n    fill: #f1c40f;\n    stroke: #f39c12;\n  }\n  .node.end circle {\n    fill: #e74c3c;\n    stroke: #c0392b;\n  }\n  #instructions {\n    font-size: 13px;\n    color: #555;\n    margin-top: 10px;\n  }\n  #edges-list {\n    max-height: 120px;\n    overflow-y: auto;\n    border: 1px solid #ddd;\n    background: #fff;\n    padding: 10px;\n    font-size: 13px;\n    margin-top: 5px;\n  }\n  #edges-list div {\n    margin-bottom: 4px;\n  }\n  #add-edge-btn {\n    margin-top: 10px;\n    background: #28a745;\n  }\n  #reset-graph-btn {\n    background: #dc3545;\n    margin-top: 15px;\n  }\n  #speed-label {\n    margin-top: 15px;\n    font-weight: bold;\n  }\n  #speed-range {\n    width: 100%;\n  }\n  #footer {\n    font-size: 12px;\n    color: #666;\n    margin-top: 10px;\n    text-align: center;\n  }\n</style>\n</head>\n<body>\n  <div id=\"controls\">\n    <h2>Dijkstra's Algorithm</h2>\n\n    <label for=\"vertex-count\">Number of vertices (2-12):</label>\n    <input type=\"number\" id=\"vertex-count\" min=\"2\" max=\"12\" value=\"6\" />\n\n    <button id=\"create-graph-btn\">Create Graph</button>\n    \n    <div id=\"graph-setup\" style=\"display:none; margin-top:15px;\">\n      <h3>Edges (Add / Remove)</h3>\n      <label for=\"edge-from\">From:</label>\n      <select id=\"edge-from\"></select>\n      <label for=\"edge-to\">To:</label>\n      <select id=\"edge-to\"></select>\n      <label for=\"edge-weight\">Weight (1-50):</label>\n      <input type=\"number\" id=\"edge-weight\" min=\"1\" max=\"50\" value=\"1\" />\n      <button id=\"add-edge-btn\">Add / Update Edge</button>\n\n      <h4>Current Edges:</h4>\n      <div id=\"edges-list\"></div>\n\n      <button id=\"reset-graph-btn\" style=\"background:#dc3545;\">Reset Edges</button>\n    </div>\n\n    <div id=\"algorithm-controls\" style=\"display:none; margin-top:20px;\">\n      <label for=\"start-node\">Start Node:</label>\n      <select id=\"start-node\"></select>\n\n      <label for=\"end-node\">End Node (optional):</label>\n      <select id=\"end-node\">\n        <option value=\"\">(None)</option>\n      </select>\n\n      <button id=\"run-btn\">Run Dijkstra</button>\n      <button id=\"step-btn\" disabled>Step</button>\n      <button id=\"reset-btn\" disabled>Reset</button>\n\n      <label id=\"speed-label\" for=\"speed-range\">Animation speed (ms delay):</label>\n      <input type=\"range\" id=\"speed-range\" min=\"50\" max=\"2000\" step=\"50\" value=\"600\" />\n      \n      <div id=\"instructions\">\n        <strong>Instructions:</strong><br />\n        • Create graph by selecting the number of vertices and clicking \"Create Graph\".<br />\n        • Add and update edges with weights.<br />\n        • Select start node and optionally end node.<br />\n        • Run the algorithm to see shortest paths.<br />\n        • Use Step to run it manually step-by-step.<br />\n      </div>\n\n      <h4>Log / Status:</h4>\n      <div id=\"log\"></div>\n    </div>\n\n    <div id=\"footer\">\n      &copy; 2024 Dijkstra's Algorithm Visualizer\n    </div>\n  </div>\n  <div id=\"graph-container\">\n    <svg id=\"svg-graph\" xmlns=\"http://www.w3.org/2000/svg\">\n      <defs>\n        <marker id=\"arrow\" markerWidth=\"10\" markerHeight=\"7\" refX=\"10\" refY=\"3.5\" orient=\"auto\" markerUnits=\"strokeWidth\">\n          <path d=\"M0,0 L10,3.5 L0,7 Z\" fill=\"#aaa\" />\n        </marker>\n      </defs>\n    </svg>\n  </div>\n\n<script>\n(() => {\n  const MAX_VERTICES = 12;\n  const MIN_VERTICES = 2;\n\n  let vertexCount = 6;\n  let vertices = [];\n  let edges = new Map(); // key: \"u-v\", value: weight\n  let adjacencyList = [];\n  let animationDelay = 600;\n\n  const controls = {\n    vertexCountInput: document.getElementById('vertex-count'),\n    createGraphBtn: document.getElementById('create-graph-btn'),\n    graphSetup: document.getElementById('graph-setup'),\n    edgeFromSelect: document.getElementById('edge-from'),\n    edgeToSelect: document.getElementById('edge-to'),\n    edgeWeightInput: document.getElementById('edge-weight'),\n    addEdgeBtn: document.getElementById('add-edge-btn'),\n    edgesList: document.getElementById('edges-list'),\n    resetGraphBtn: document.getElementById('reset-graph-btn'),\n\n    algorithmControls: document.getElementById('algorithm-controls'),\n    startNodeSelect: document.getElementById('start-node'),\n    endNodeSelect: document.getElementById('end-node'),\n    runBtn: document.getElementById('run-btn'),\n    stepBtn: document.getElementById('step-btn'),\n    resetBtn: document.getElementById('reset-btn'),\n    speedRange: document.getElementById('speed-range'),\n    logDiv: document.getElementById('log'),\n  };\n\n  const svg = document.getElementById('svg-graph');\n  const WIDTH = svg.clientWidth;\n  const HEIGHT = svg.clientHeight;\n\n  // Nodes positions stored here for rendering edges\n  let nodePositions = [];\n\n  // State variables for the Dijkstra animation\n  let dijkstraState = null;\n  // Controls animation steps and intervals\n  let animationTimer = null;\n\n  // Utility to create vertex labels A, B, C...\n  function vertexLabel(i) {\n    return String.fromCharCode(65 + i);\n  }\n\n  // Clear SVG elements\n  function clearSVG() {\n    while (svg.lastChild && svg.lastChild.tagName !== 'defs') {\n      svg.removeChild(svg.lastChild);\n    }\n  }\n\n  // Build adjacency list from edges map\n  function buildAdjacencyList() {\n    adjacencyList = [];\n    for (let i = 0; i < vertexCount; i++) {\n      adjacencyList[i] = [];\n    }\n    edges.forEach((weight, key) => {\n      // Edge key is \"u-v\"\n      const [uStr, vStr] = key.split('-');\n      const u = parseInt(uStr, 10);\n      const v = parseInt(vStr, 10);\n      adjacencyList[u].push({ to: v, weight });\n      adjacencyList[v].push({ to: u, weight }); // undirected graph\n    });\n  }\n\n  // Initialize graph visualization\n  function drawGraph() {\n    clearSVG();\n    nodePositions = [];\n    const centerX = svg.clientWidth/2;\n    const centerY = svg.clientHeight/2;\n    const radius = Math.min(centerX, centerY) - 80;\n\n    // Position nodes evenly on a circle\n    for (let i = 0; i < vertexCount; i++) {\n      const angle = (2 * Math.PI * i) / vertexCount - Math.PI / 2;\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n      nodePositions.push({ x, y });\n    }\n\n    // Draw edges first\n    edges.forEach((weight, key) => {\n      const [uStr, vStr] = key.split('-');\n      const u = parseInt(uStr, 10);\n      const v = parseInt(vStr, 10);\n      drawEdge(u, v, weight);\n    });\n\n    // Draw nodes\n    for (let i = 0; i < vertexCount; i++) {\n      drawNode(i);\n    }\n  }\n\n  function drawEdge(u, v, weight) {\n    const posU = nodePositions[u];\n    const posV = nodePositions[v];\n    // Create line\n    const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    line.setAttribute(\"x1\", posU.x);\n    line.setAttribute(\"y1\", posU.y);\n    line.setAttribute(\"x2\", posV.x);\n    line.setAttribute(\"y2\", posV.y);\n    line.setAttribute(\"class\", \"edge\");\n    line.setAttribute(\"data-from\", u);\n    line.setAttribute(\"data-to\", v);\n    svg.appendChild(line);\n\n    // Weight Label - place near middle with slight offset\n    const midX = (posU.x + posV.x)/2;\n    const midY = (posU.y + posV.y)/2;\n    const label = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    label.setAttribute(\"x\", midX);\n    label.setAttribute(\"y\", midY - 10);\n    label.setAttribute(\"fill\", \"#eee\");\n    label.setAttribute(\"font-size\", \"14px\");\n    label.setAttribute(\"font-weight\", \"bold\");\n    label.setAttribute(\"pointer-events\", \"none\");\n    label.textContent = weight;\n    svg.appendChild(label);\n  }\n\n  function drawNode(i) {\n    const pos = nodePositions[i];\n    const group = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    group.classList.add(\"node\");\n    group.setAttribute(\"data-node\", i);\n    group.style.userSelect = 'none';\n\n    // Circle\n    const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    circle.setAttribute(\"cx\", pos.x);\n    circle.setAttribute(\"cy\", pos.y);\n    circle.setAttribute(\"r\", 22);\n    group.appendChild(circle);\n\n    // Label text\n    const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    text.setAttribute(\"x\", pos.x);\n    text.setAttribute(\"y\", pos.y + 6);\n    text.setAttribute(\"text-anchor\", \"middle\");\n    text.setAttribute(\"font-size\", \"20\");\n    text.textContent = vertexLabel(i);\n    group.appendChild(text);\n\n    svg.appendChild(group);\n  }\n\n  // Update nodes colors based on Dijkstra's state\n  function updateNodeColors() {\n    const nodes = svg.querySelectorAll('g.node');\n    for (const nodeEl of nodes) {\n      const idx = parseInt(nodeEl.getAttribute('data-node'), 10);\n      nodeEl.classList.remove('visited', 'current', 'start', 'end');\n      if (!dijkstraState) continue;\n      if (idx === dijkstraState.start) {\n        nodeEl.classList.add('start');\n      }\n      if (dijkstraState.end !== null && idx === dijkstraState.end) {\n        nodeEl.classList.add('end');\n      }\n      if (dijkstraState.processed.has(idx)) {\n        nodeEl.classList.add('visited');\n      }\n      if (dijkstraState.current === idx) {\n        nodeEl.classList.add('current');\n      }\n    }\n  }\n\n  // Highlight edges in the current shortest path\n  function highlightPath(path) {\n    const allEdges = svg.querySelectorAll('line.edge');\n    allEdges.forEach(e => e.classList.remove('highlighted'));\n\n    if (!path || path.length < 2) return;\n    for (let i = 0; i < path.length - 1; i++) {\n      const u = path[i];\n      const v = path[i+1];\n      // Highlight edge both ways since undirected\n      for (const edgeEl of allEdges) {\n        const from = parseInt(edgeEl.getAttribute('data-from'), 10);\n        const to = parseInt(edgeEl.getAttribute('data-to'), 10);\n        if ((from === u && to === v) || (from === v && to === u)) {\n          edgeEl.classList.add('highlighted');\n        }\n      }\n    }\n  }\n\n  // Display log message\n  function log(text, append=true) {\n    if (append) {\n      controls.logDiv.textContent += text + \"\\n\";\n      controls.logDiv.scrollTop = controls.logDiv.scrollHeight;\n    } else {\n      controls.logDiv.textContent = text + \"\\n\";\n    }\n  }\n\n  // Update the select elements for vertices\n  function updateVertexSelects() {\n    const selects = [controls.edgeFromSelect, controls.edgeToSelect, controls.startNodeSelect, controls.endNodeSelect];\n    selects.forEach(select => {\n      // Save current values\n      const val = select.value;\n      // Clear options\n      select.innerHTML = '';\n      // For end-node allow empty option\n      if (select === controls.endNodeSelect) {\n        const optNone = document.createElement('option');\n        optNone.value = '';\n        optNone.textContent = '(None)';\n        select.appendChild(optNone);\n      }\n      for (let i = 0; i < vertexCount; i++) {\n        const opt = document.createElement('option');\n        opt.value = i;\n        opt.textContent = vertexLabel(i);\n        select.appendChild(opt);\n      }\n      // Restore if possible\n      if ([...select.options].some(o => o.value === val)) {\n        select.value = val;\n      } else {\n        select.selectedIndex = 0;\n      }\n    });\n  }\n\n  // Renders edges list in controls with remove buttons\n  function renderEdgesList() {\n    controls.edgesList.innerHTML = '';\n    if (edges.size === 0) {\n      controls.edgesList.textContent = '(No edges added)';\n      return;\n    }\n    const fragment = document.createDocumentFragment();\n    const sortedEdges = [...edges.entries()].sort((a,b) => {\n      const [au,av] = a[0].split('-').map(Number);\n      const [bu,bv] = b[0].split('-').map(Number);\n      if (au !== bu) return au - bu;\n      return av - bv;\n    });\n    sortedEdges.forEach(([key, weight]) => {\n      const div = document.createElement('div');\n      const [u,v] = key.split('-').map(Number);\n      div.textContent = `${vertexLabel(u)} ↔ ${vertexLabel(v)} : ${weight}`;\n      const rmBtn = document.createElement('button');\n      rmBtn.textContent = 'Remove';\n      rmBtn.style.marginLeft = '10px';\n      rmBtn.style.cursor = 'pointer';\n      rmBtn.style.fontSize = '12px';\n      rmBtn.style.padding = '2px 6px';\n      rmBtn.style.background = '#dc3545';\n      rmBtn.style.color = 'white';\n      rmBtn.style.border = 'none';\n      rmBtn.style.borderRadius = '3px';\n      rmBtn.addEventListener('click', () => {\n        edges.delete(key);\n        buildAdjacencyList();\n        drawGraph();\n        renderEdgesList();\n      });\n      div.appendChild(rmBtn);\n      fragment.appendChild(div);\n    });\n    controls.edgesList.appendChild(fragment);\n  }\n\n  // Add or update edge in edges Map\n  function addOrUpdateEdge(u, v, weight) {\n    if (u === v) {\n      alert('Cannot create edge to the same vertex.');\n      return false;\n    }\n    if (weight < 1 || weight > 50) {\n      alert('Weight must be between 1 and 50.');\n      return false;\n    }\n    // Store with smaller index first for consistent key\n    const a = Math.min(u, v);\n    const b = Math.max(u, v);\n    edges.set(`${a}-${b}`, weight);\n    return true;\n  }\n\n  // --- DIJKSTRA ALGORITHM STEPS IMPLEMENTATION --- //\n  // State contains:\n  // start, end\n  // distances[], prev[]\n  // processed: Set\n  // pq: priority queue (array, smallest dist at front)\n  // current: current node being processed\n  // finished: boolean\n\n  // Priority queue implementation (min-heap) for Dijkstra, but for simplicity use array sorted\n  function pqPush(pq, item) {\n    pq.push(item);\n    pq.sort((a,b) => a.dist - b.dist);\n  }\n  function pqPop(pq) {\n    return pq.shift();\n  }\n\n  // Initialize Dijkstra state\n  function dijkstraInit(start, end=null) {\n    const dist = new Array(vertexCount).fill(Infinity);\n    const prev = new Array(vertexCount).fill(null);\n    dist[start] = 0;\n    const processed = new Set();\n    const pq = [];\n    pqPush(pq, { node: start, dist: 0 });\n    const state = {\n      start,\n      end,\n      distances: dist,\n      previous: prev,\n      processed,\n      pq,\n      current: null,\n      finished: false,\n    };\n    return state;\n  }\n\n  // One step of Dijkstra's algorithm\n  // Returns a status object with info about changes\n  function dijkstraStep(state) {\n    if (state.finished) return { done: true };\n    if (state.pq.length === 0) {\n      state.finished = true;\n      return { done: true };\n    }\n    const { node, dist } = pqPop(state.pq);\n    if (state.processed.has(node)) {\n      // Skip already processed nodes\n      return { done: false };\n    }\n    state.current = node;\n    state.processed.add(node);\n    // Relax edges\n    let relaxedAny = false;\n    const neighbors = adjacencyList[node];\n    for (const { to, weight } of neighbors) {\n      if (state.processed.has(to)) continue;\n      const newDist = state.distances[node] + weight;\n      if (newDist < state.distances[to]) {\n        state.distances[to] = newDist;\n        state.previous[to] = node;\n        pqPush(state.pq, { node: to, dist: newDist });\n        relaxedAny = true;\n      }\n    }\n    if (state.end !== null && node === state.end) {\n      state.finished = true;\n      return { done: true, reachedEnd: true };\n    }\n    if (state.pq.length === 0) {\n      state.finished = true;\n      return { done: true };\n    }\n    return { done: false };\n  }\n\n  // Compute the shortest path from start to end (or to all nodes if end=null)\n  // Returns array of node indices representing path or null if end not reachable\n  function reconstructPath(state) {\n    if (state.end === null) return null;\n    const path = [];\n    let u = state.end;\n    if (state.distances[u] === Infinity) return null;\n    while (u !== null) {\n      path.push(u);\n      u = state.previous[u];\n    }\n    return path.reverse();\n  }\n\n  // Highlight shortest path edges after algorithm finishes\n  function highlightShortestPath(state) {\n    const path = reconstructPath(state);\n    highlightPath(path);\n  }\n\n  // Update nodes with distance labels\n  function updateDistanceLabels() {\n    const nodes = svg.querySelectorAll('g.node');\n    nodes.forEach(nodeEl => {\n      // Remove existing dist labels first\n      const oldDistLabel = nodeEl.querySelector('.dist-label');\n      if (oldDistLabel) nodeEl.removeChild(oldDistLabel);\n    });\n    nodes.forEach(nodeEl => {\n      const idx = +nodeEl.getAttribute('data-node');\n      const distVal = dijkstraState ? dijkstraState.distances[idx] : Infinity;\n      const label = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      const pos = nodePositions[idx];\n      label.setAttribute(\"x\", pos.x);\n      label.setAttribute(\"y\", pos.y + 38);\n      label.setAttribute(\"text-anchor\", \"middle\");\n      label.setAttribute(\"font-size\", \"13\");\n      label.setAttribute(\"fill\", \"#f39c12\");\n      label.setAttribute(\"class\", \"dist-label\");\n      label.style.userSelect = 'none';\n      label.textContent = distVal === Infinity ? '∞' : distVal;\n      svg.appendChild(label);\n    });\n  }\n\n  // Run full Dijkstra with animation or step by step\n  function runDijkstraAuto() {\n    if (!dijkstraState) return;\n    controls.runBtn.disabled = true;\n    controls.stepBtn.disabled = true;\n    controls.resetBtn.disabled = false;\n\n    function step() {\n      const res = dijkstraStep(dijkstraState);\n      updateNodeColors();\n      updateDistanceLabels();\n\n      if (res.done) {\n        if (dijkstraState.end !== null) {\n          highlightShortestPath(dijkstraState);\n          if (res.reachedEnd) {\n            log(`Reached end node ${vertexLabel(dijkstraState.end)} with distance ${dijkstraState.distances[dijkstraState.end]}.`);\n          } else {\n            log(`No path to node ${vertexLabel(dijkstraState.end)} found.`);\n          }\n        } else {\n          log('Algorithm finished. Shortest distances from start node shown.');\n        }\n        controls.runBtn.disabled = true;\n        controls.stepBtn.disabled = true;\n        controls.resetBtn.disabled = false;\n        animationTimer = null;\n        return;\n      }\n      logStep();\n      animationTimer = setTimeout(step, animationDelay);\n    }\n    step();\n  }\n\n  // Log current step information\n  function logStep() {\n    if (!dijkstraState) return;\n    const curr = dijkstraState.current;\n    const dist = dijkstraState.distances[curr];\n    log(`Processing node ${vertexLabel(curr)}, current distance: ${dist}`, false);\n  }\n\n  // Initialize page with default graph setup\n  function initializeDefaultGraph() {\n    vertexCount = Number(controls.vertexCountInput.value);\n    if (isNaN(vertexCount) || vertexCount < MIN_VERTICES || vertexCount > MAX_VERTICES) {\n      alert(`Number of vertices must be between ${MIN_VERTICES} and ${MAX_VERTICES}.`);\n      return false;\n    }\n    vertices = [];\n    for (let i = 0; i < vertexCount; i++) {\n      vertices.push(vertexLabel(i));\n    }\n    edges.clear();\n    // Prepopulate edges with a simple connected graph (ring)\n    for (let i = 0; i < vertexCount; i++) {\n      const next = (i + 1) % vertexCount;\n      edges.set(`${Math.min(i, next)}-${Math.max(i, next)}`, 1 + Math.floor(Math.random() * 10));\n    }\n    buildAdjacencyList();\n    updateVertexSelects();\n    renderEdgesList();\n    drawGraph();\n    controls.graphSetup.style.display = 'block';\n    controls.algorithmControls.style.display = 'block';\n    controls.logDiv.textContent = '';\n    controls.runBtn.disabled = false;\n    controls.stepBtn.disabled = true;\n    controls.resetBtn.disabled = true;\n    dijkstraState = null;\n    animationDelay = Number(controls.speedRange.value);\n    return true;\n  }\n\n  // Reset edges only (clear all edges)\n  function resetEdges() {\n    edges.clear();\n    buildAdjacencyList();\n    renderEdgesList();\n    drawGraph();\n    dijkstraState = null;\n    controls.runBtn.disabled = false;\n    controls.stepBtn.disabled = true;\n    controls.resetBtn.disabled = true;\n    controls.logDiv.textContent = '';\n    highlightPath(null);\n    updateNodeColors();\n    updateDistanceLabels();\n  }\n\n  // Reset algorithm state only (allow editing graph while preserving vertex count)\n  function resetAlgorithm() {\n    if (animationTimer) {\n      clearTimeout(animationTimer);\n      animationTimer = null;\n    }\n    dijkstraState = null;\n    updateNodeColors();\n    highlightPath(null);\n    updateDistanceLabels();\n    controls.logDiv.textContent = '';\n    controls.runBtn.disabled = false;\n    controls.stepBtn.disabled = true;\n    controls.resetBtn.disabled = true;\n  }\n\n  // Event Listeners\n  controls.createGraphBtn.addEventListener('click', () => {\n    if (animationTimer) {\n      clearTimeout(animationTimer);\n      animationTimer = null;\n    }\n    if (!initializeDefaultGraph()) return;\n  });\n\n  controls.addEdgeBtn.addEventListener('click', () => {\n    const u = Number(controls.edgeFromSelect.value);\n    const v = Number(controls.edgeToSelect.value);\n    const w = Number(controls.edgeWeightInput.value);\n    if (addOrUpdateEdge(u, v, w)) {\n      buildAdjacencyList();\n      drawGraph();\n      renderEdgesList();\n      resetAlgorithm();\n    }\n  });\n\n  controls.resetGraphBtn.addEventListener('click', () => {\n    if (confirm('Clear all edges?')) {\n      resetEdges();\n    }\n  });\n\n  controls.runBtn.addEventListener('click', () => {\n    // Initialize and run\n    const start = Number(controls.startNodeSelect.value);\n    let end = controls.endNodeSelect.value;\n    end = end === '' ? null : Number(end);\n\n    if (start === end) {\n      alert('Start and end node must be different or leave end empty.');\n      return;\n    }\n    buildAdjacencyList();\n    dijkstraState = dijkstraInit(start, end);\n    controls.runBtn.disabled = true;\n    controls.stepBtn.disabled = false;\n    controls.resetBtn.disabled = false;\n    controls.logDiv.textContent = '';\n    highlightPath(null);\n    updateDistanceLabels();\n    updateNodeColors();\n    if (animationTimer) {\n      clearTimeout(animationTimer);\n      animationTimer = null;\n    }\n    animationDelay = Number(controls.speedRange.value);\n\n    runDijkstraAuto();\n  });\n\n  controls.stepBtn.addEventListener('click', () => {\n    if (!dijkstraState) return;\n    if (dijkstraState.finished) return;\n    const res = dijkstraStep(dijkstraState);\n    updateNodeColors();\n    updateDistanceLabels();\n    logStep();\n    if (res.done) {\n      if (dijkstraState.end !== null) {\n        highlightShortestPath(dijkstraState);\n        if (res.reachedEnd) {\n          log(`Reached end node ${vertexLabel(dijkstraState.end)} with distance ${dijkstraState.distances[dijkstraState.end]}.`);\n        } else {\n          log(`No path to node ${vertexLabel(dijkstraState.end)} found.`);\n        }\n      } else {\n        log('Algorithm finished. Shortest distances from start node shown.');\n      }\n      controls.stepBtn.disabled = true;\n      controls.runBtn.disabled = true;\n    }\n  });\n\n  controls.resetBtn.addEventListener('click', () => {\n    resetAlgorithm();\n  });\n\n  controls.speedRange.addEventListener('input', () => {\n    animationDelay = Number(controls.speedRange.value);\n  });\n\n  // Initialize default graph on page load\n  initializeDefaultGraph();\n})();\n</script>\n\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Dijkstra’s Algorithm"
    }
  ],
  "topic": "Dijkstra’s Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}