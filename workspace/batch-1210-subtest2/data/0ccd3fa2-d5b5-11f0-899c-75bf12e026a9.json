{
  "id": "0ccd3fa2-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:45:38.190Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Linear Regression",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>Linear Regression Demo</title>\n  <style>\n    body {\n      font-family: Arial, sans-serif;\n      margin: 20px;\n      background: #f9f9f9;\n    }\n    h1 {\n      text-align: center;\n    }\n    #container {\n      max-width: 800px;\n      margin: 0 auto;\n      background: white;\n      padding: 20px;\n      border-radius: 8px;\n      box-shadow: 0 0 10px rgba(0,0,0,0.1);\n    }\n    #canvasContainer {\n      text-align: center;\n      margin-top: 20px;\n      position: relative;\n    }\n    canvas {\n      border: 1px solid #ccc;\n      background: #fff;\n      cursor: crosshair;\n    }\n    #instructions {\n      text-align: center;\n      margin-bottom: 10px;\n      color: #555;\n    }\n    #rmse {\n      margin-top: 15px;\n      font-weight: bold;\n      text-align: center;\n    }\n    button {\n      display: block;\n      margin: 10px auto 0 auto;\n      padding: 8px 16px;\n      font-size: 16px;\n      cursor: pointer;\n      border: none;\n      background: #007BFF;\n      color: white;\n      border-radius: 4px;\n      transition: background-color 0.3s;\n    }\n    button:hover {\n      background: #0056b3;\n    }\n    #clearBtn {\n      background: #dc3545;\n    }\n    #clearBtn:hover {\n      background: #a71d2a;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"container\">\n    <h1>Linear Regression Interactive Demo</h1>\n    <div id=\"instructions\">Click on the canvas to add data points. The linear regression line updates automatically.</div>\n    <div id=\"canvasContainer\">\n      <canvas id=\"plot\" width=\"700\" height=\"400\"></canvas>\n    </div>\n    <div id=\"rmse\"></div>\n    <button id=\"clearBtn\">Clear Points</button>\n  </div>\n\n  <script>\n    (() => {\n      const canvas = document.getElementById('plot');\n      const ctx = canvas.getContext('2d');\n      const width = canvas.width;\n      const height = canvas.height;\n\n      // Margin for axis labels and ticks\n      const margin = { top: 30, bottom: 50, left: 60, right: 30 };\n\n      // Data to store points as objects {x, y} in data coordinate space\n      let points = [];\n\n      // Coordinate system ranges - we will scale dynamically based on points\n      let xMin = 0, xMax = 10;\n      let yMin = 0, yMax = 10;\n\n      // Convert data coordinates to canvas coordinates\n      function dataToCanvasX(x) {\n        return margin.left + ((x - xMin) / (xMax - xMin)) * (width - margin.left - margin.right);\n      }\n      function dataToCanvasY(y) {\n        return height - margin.bottom - ((y - yMin) / (yMax - yMin)) * (height - margin.top - margin.bottom);\n      }\n\n      // Convert canvas coordinates to data coordinates\n      function canvasToDataX(cx) {\n        return xMin + ((cx - margin.left) / (width - margin.left - margin.right)) * (xMax - xMin);\n      }\n      function canvasToDataY(cy) {\n        return yMin + ((height - margin.bottom - cy) / (height - margin.top - margin.bottom)) * (yMax - yMin);\n      }\n\n      // Draw axes with ticks and labels\n      function drawAxes() {\n        ctx.strokeStyle = '#000';\n        ctx.lineWidth = 1;\n        ctx.font = '12px Arial';\n        ctx.fillStyle = '#000';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n\n        // Draw x axis\n        ctx.beginPath();\n        ctx.moveTo(margin.left, height - margin.bottom);\n        ctx.lineTo(width - margin.right, height - margin.bottom);\n        ctx.stroke();\n\n        // Draw y axis\n        ctx.beginPath();\n        ctx.moveTo(margin.left, margin.top);\n        ctx.lineTo(margin.left, height - margin.bottom);\n        ctx.stroke();\n\n        // Ticks and labels - 6 ticks each axis\n        let xTicks = 6;\n        let yTicks = 6;\n\n        // X axis ticks & labels\n        for(let i = 0; i <= xTicks; i++) {\n          const x = margin.left + i * (width - margin.left - margin.right) / xTicks;\n          const val = xMin + i * (xMax - xMin) / xTicks;\n          ctx.beginPath();\n          ctx.moveTo(x, height - margin.bottom);\n          ctx.lineTo(x, height - margin.bottom + 6);\n          ctx.stroke();\n          ctx.fillText(val.toFixed(1), x, height - margin.bottom + 18);\n        }\n\n        // Y axis ticks & labels\n        ctx.textAlign = 'right';\n        for(let i = 0; i <= yTicks; i++) {\n          const y = height - margin.bottom - i * (height - margin.top - margin.bottom) / yTicks;\n          const val = yMin + i * (yMax - yMin) / yTicks;\n          ctx.beginPath();\n          ctx.moveTo(margin.left, y);\n          ctx.lineTo(margin.left - 6, y);\n          ctx.stroke();\n          ctx.fillText(val.toFixed(1), margin.left - 10, y);\n        }\n\n        // Axis labels\n        ctx.textAlign = 'center';\n        ctx.fillText('X', width/2, height - 10);\n        ctx.save();\n        ctx.translate(15, height/2);\n        ctx.rotate(-Math.PI/2);\n        ctx.fillText('Y', 0, 0);\n        ctx.restore();\n      }\n\n      // Draw the data points\n      function drawPoints() {\n        ctx.fillStyle = 'blue';\n        points.forEach(({x,y}) => {\n          const cx = dataToCanvasX(x);\n          const cy = dataToCanvasY(y);\n          ctx.beginPath();\n          ctx.arc(cx, cy, 5, 0, 2 * Math.PI);\n          ctx.fill();\n        });\n      }\n\n      // Calculate linear regression parameters: slope (m) and intercept (b)\n      // y = m*x + b\n      function linearRegression(dataPoints) {\n        if(dataPoints.length < 2) return null;\n\n        const n = dataPoints.length;\n        let sumX=0, sumY=0, sumXY=0, sumX2=0;\n        for(const p of dataPoints) {\n          sumX += p.x;\n          sumY += p.y;\n          sumXY += p.x * p.y;\n          sumX2 += p.x * p.x;\n        }\n        const denominator = n*sumX2 - sumX*sumX;\n        if(denominator === 0) return null; // vertical line or all x the same\n\n        const m = (n*sumXY - sumX*sumY) / denominator;\n        const b = (sumY - m*sumX) / n;\n        return {m, b};\n      }\n\n      // Draw linear regression line\n      function drawRegressionLine(line) {\n        if(!line) return;\n        ctx.strokeStyle = 'red';\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        // Find two points on the x-range\n        const x1 = xMin;\n        const y1 = line.m*x1 + line.b;\n        const x2 = xMax;\n        const y2 = line.m*x2 + line.b;\n        // Clip line to y boundaries\n        let pointsToDraw = [];\n\n        function clipPoint(x, y) {\n          if(y < yMin) {\n            y = yMin;\n            x = (y - line.b)/line.m;\n          } else if(y > yMax) {\n            y = yMax;\n            x = (y - line.b)/line.m;\n          }\n          return {x,y};\n        }\n\n        let p1 = clipPoint(x1,y1);\n        let p2 = clipPoint(x2,y2);\n\n        ctx.moveTo(dataToCanvasX(p1.x), dataToCanvasY(p1.y));\n        ctx.lineTo(dataToCanvasX(p2.x), dataToCanvasY(p2.y));\n        ctx.stroke();\n      }\n\n      // Calculate Root Mean Squared Error (RMSE) for the regression line\n      function calculateRMSE(line, dataPoints) {\n        if(!line) return null;\n        let sumSqError = 0;\n        dataPoints.forEach(p => {\n          const pred = line.m*p.x + line.b;\n          const error = p.y - pred;\n          sumSqError += error * error;\n        });\n        return Math.sqrt(sumSqError / dataPoints.length);\n      }\n\n      // Update data coordinate ranges to fit points nicely with some margin\n      function updateRanges() {\n        if(points.length === 0) {\n          xMin = 0; xMax = 10;\n          yMin = 0; yMax = 10;\n          return;\n        }\n        // Determine min and max of points with padding\n        const paddingFactor = 0.1;\n        let xs = points.map(p => p.x);\n        let ys = points.map(p => p.y);\n        let minX = Math.min(...xs);\n        let maxX = Math.max(...xs);\n        let minY = Math.min(...ys);\n        let maxY = Math.max(...ys);\n\n        // Avoid zero ranges\n        if(maxX - minX < 1) {\n          minX -= 1;\n          maxX += 1;\n        }\n        if(maxY - minY < 1) {\n          minY -= 1;\n          maxY += 1;\n        }\n\n        let xRange = maxX - minX;\n        let yRange = maxY - minY;\n\n        xMin = minX - xRange * paddingFactor;\n        xMax = maxX + xRange * paddingFactor;\n        yMin = minY - yRange * paddingFactor;\n        yMax = maxY + yRange * paddingFactor;\n\n        // Floor and ceil for nicer axis ticks\n        xMin = Math.floor(xMin);\n        xMax = Math.ceil(xMax);\n        yMin = Math.floor(yMin);\n        yMax = Math.ceil(yMax);\n      }\n\n      // Redraw entire plot\n      function redraw() {\n        ctx.clearRect(0, 0, width, height);\n        updateRanges();\n        drawAxes();\n        drawPoints();\n        const line = linearRegression(points);\n        drawRegressionLine(line);\n        const rmse = calculateRMSE(line, points);\n        const rmseDiv = document.getElementById('rmse');\n        if(rmse !== null) {\n          rmseDiv.textContent = 'Root Mean Squared Error (RMSE): ' + rmse.toFixed(3);\n        } else {\n          rmseDiv.textContent = '';\n        }\n      }\n\n      // Event: user clicks on canvas to add a point\n      canvas.addEventListener('click', function(e) {\n        const rect = canvas.getBoundingClientRect();\n        const cx = e.clientX - rect.left;\n        const cy = e.clientY - rect.top;\n\n        if(cx < margin.left || cx > width - margin.right ||\n           cy < margin.top || cy > height - margin.bottom) {\n          // Outside plotting area - ignore\n          return;\n        }\n\n        const x = canvasToDataX(cx);\n        const y = canvasToDataY(cy);\n\n        points.push({x,y});\n        redraw();\n      });\n\n      // Clear button to reset points\n      document.getElementById('clearBtn').addEventListener('click', () => {\n        points = [];\n        redraw();\n      });\n\n      // Initial draw\n      redraw();\n    })();\n  </script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Linear Regression"
    }
  ],
  "topic": "Linear Regression",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}