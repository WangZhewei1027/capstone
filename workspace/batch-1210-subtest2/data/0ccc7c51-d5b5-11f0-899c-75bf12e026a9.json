{
  "id": "0ccc7c51-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:46:15.027Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Breadth-First Search (BFS)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Breadth-First Search (BFS) Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f0f0f0;\n  }\n  h1 { text-align: center; }\n  #graph-container {\n    display: flex;\n    justify-content: center;\n    margin-top: 20px;\n  }\n  svg {\n    background: white;\n    border: 1px solid #ccc;\n    border-radius: 8px;\n  }\n  circle.node {\n    fill: #eee;\n    stroke: #666;\n    stroke-width: 2px;\n    cursor: pointer;\n    transition: fill 0.3s;\n  }\n  circle.node.visited {\n    fill: #76c7c0;\n  }\n  circle.node.current {\n    fill: #ff6f61;\n  }\n  text.node-label {\n    font-size: 14px;\n    pointer-events: none;\n    user-select: none;\n  }\n  line.edge {\n    stroke: #999;\n    stroke-width: 2px;\n  }\n  line.edge.highlighted {\n    stroke: #ff6f61;\n    stroke-width: 3px;\n  }\n  #controls {\n    max-width: 600px;\n    margin: 0 auto 30px;\n    text-align: center;\n  }\n  #log {\n    max-width: 600px;\n    margin: 0 auto;\n    background: white;\n    border: 1px solid #ccc;\n    height: 150px;\n    overflow-y: auto;\n    padding: 10px;\n    font-family: monospace;\n    font-size: 14px;\n    border-radius: 6px;\n  }\n  button {\n    background: #76c7c0;\n    border: none;\n    padding: 10px 16px;\n    border-radius: 6px;\n    color: white;\n    font-weight: bold;\n    cursor: pointer;\n    margin-left: 10px;\n  }\n  button:disabled {\n    background: #ccc;\n    cursor: not-allowed;\n  }\n  #startNodeLabel {\n    width: 40px;\n    font-weight: bold;\n    text-align: center;\n    font-size: 16px;\n    margin-left: 10px;\n  }\n  #desc {\n    max-width: 600px;\n    margin: 0 auto 20px;\n    background: #fff8dc;\n    border: 1px solid #e2d27d;\n    border-radius: 6px;\n    padding: 15px;\n  }\n  a {\n    color: #76c7c0;\n  }\n</style>\n</head>\n<body>\n<h1>Breadth-First Search (BFS) Visualization</h1>\n<div id=\"desc\">\n  <p>\n    This is an interactive demonstration of <strong>Breadth-First Search (BFS)</strong> on a graph.\n    BFS explores the graph layer by layer, starting from a selected start node, visiting all neighbors at the current depth before moving deeper.\n  </p>\n  <p>\n    Click on a node below to select the BFS start node, then press <em>Start BFS</em>.<br/>\n    Nodes turn <span style=\"color:#ff6f61; font-weight:bold;\">red</span> when currently visiting,<br/>\n    and <span style=\"color:#76c7c0; font-weight:bold;\">teal</span> when visited.<br/>\n    Explored edges also highlight in red as BFS progresses.\n  </p>\n  <p>\n    Learn more about BFS: <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\" target=\"_blank\" rel=\"noopener\">Wikipedia BFS</a> \n  </p>\n</div>\n<div id=\"controls\">\n  Start Node: \n  <input type=\"text\" id=\"startNodeLabel\" maxlength=\"2\" readonly />\n  <button id=\"startBFS\" disabled>Start BFS</button>\n  <button id=\"resetGraph\">Reset</button>\n</div>\n<div id=\"graph-container\">\n  <svg id=\"graph\" width=\"600\" height=\"450\" aria-label=\"Graph visualization of nodes and edges\">\n    <!-- Nodes and edges will be added here by JS -->\n  </svg>\n</div>\n<h2 style=\"text-align:center;\">BFS Visit Log</h2>\n<div id=\"log\" role=\"log\" aria-live=\"polite\" aria-atomic=\"true\"></div>\n\n<script>\n(() => {\n  const svg = document.getElementById('graph');\n  const logEl = document.getElementById('log');\n  const startInput = document.getElementById('startNodeLabel');\n  const startBtn = document.getElementById('startBFS');\n  const resetBtn = document.getElementById('resetGraph');\n\n  // Graph data - adjacency list and node positions\n  /*\n    Graph layout:\n      A --- B --- E\n      |    /      |\n      C -- D -----F\n      |\n      G\n  */\n  const nodes = [\n    { id: 'A', x: 100, y: 100 },\n    { id: 'B', x: 220, y: 80 },\n    { id: 'C', x: 100, y: 220 },\n    { id: 'D', x: 220, y: 200 },\n    { id: 'E', x: 350, y: 80 },\n    { id: 'F', x: 350, y: 200 },\n    { id: 'G', x: 50,  y: 320 },\n  ];\n\n  const edges = [\n    ['A','B'],\n    ['A','C'],\n    ['B','C'],\n    ['B','E'],\n    ['C','D'],\n    ['D','E'],\n    ['D','F'],\n    ['E','F'],\n    ['C','G']\n  ];\n\n  // Build adjacency list map\n  const adjacency = {};\n  nodes.forEach(({id}) => adjacency[id] = []);\n  edges.forEach(([u,v]) => {\n    adjacency[u].push(v);\n    adjacency[v].push(u);\n  });\n\n  // Helpers for SVG element creation\n  function createSVGElement(name, attrs) {\n    const el = document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n    for (const attr in attrs) {\n      el.setAttribute(attr, attrs[attr]);\n    }\n    return el;\n  }\n\n  // State vars\n  let selectedStartNode = null;\n  let bfsRunning = false;\n  let visitedNodes = new Set();\n  let visitedEdges = new Set();\n  let bfsQueue = [];\n  let bfsTimeout = null;\n\n  // Store references to created DOM objects for nodes and edges:\n  const nodeElements = {};\n  const edgeElements = {};\n\n  // Draw edges\n  edges.forEach(([u,v]) => {\n    const from = nodes.find(n => n.id === u);\n    const to = nodes.find(n => n.id === v);\n    // Edges are undirected, draw a line from center of u to center of v\n    const line = createSVGElement('line', {\n      class: 'edge',\n      x1: from.x,\n      y1: from.y,\n      x2: to.x,\n      y2: to.y,\n      'data-edge': `${u}-${v}`\n    });\n    svg.appendChild(line);\n    // Store edge element for easy access both ways\n    edgeElements[`${u}-${v}`] = line;\n    edgeElements[`${v}-${u}`] = line;\n  });\n\n  // Draw nodes\n  nodes.forEach(({id, x, y}) => {\n    const group = createSVGElement('g', { class: 'node-group', 'aria-label': `Node ${id}`, role: 'button', tabindex: 0 });\n    const circle = createSVGElement('circle', {\n      class: 'node',\n      cx: x,\n      cy: y,\n      r: 22,\n      fill: '#eee',\n      stroke: '#666',\n      'stroke-width': 2,\n      cursor: 'pointer',\n      'data-node': id\n    });\n    const text = createSVGElement('text', {\n      class: 'node-label',\n      x: x,\n      y: y + 5,\n      'text-anchor': 'middle',\n      'pointer-events': 'none',\n      fill: '#333',\n      'font-weight': 'bold',\n      'font-size': '16px',\n      'user-select': 'none'\n    });\n    text.textContent = id;\n\n    group.appendChild(circle);\n    group.appendChild(text);\n    svg.appendChild(group);\n\n    nodeElements[id] = {\n      group,\n      circle,\n      text\n    };\n\n    // Node click/select handlers\n    group.addEventListener('click', () => {\n      if (bfsRunning) return;\n      selectStartNode(id);\n    });\n    group.addEventListener('keydown', e => {\n      if ((e.key === 'Enter' || e.key === ' ') && !bfsRunning) {\n        e.preventDefault();\n        selectStartNode(id);\n      }\n    });\n  });\n\n  // Select start node logic\n  function selectStartNode(id) {\n    if (selectedStartNode === id) return;\n    if (bfsRunning) return;\n\n    if (selectedStartNode) {\n      // reset old\n      nodeElements[selectedStartNode].circle.setAttribute('stroke', '#666');\n      nodeElements[selectedStartNode].circle.setAttribute('stroke-width', 2);\n    }\n    selectedStartNode = id;\n    nodeElements[id].circle.setAttribute('stroke', '#ff6f61');\n    nodeElements[id].circle.setAttribute('stroke-width', 4);\n    startInput.value = id;\n    startBtn.disabled = false;\n    appendLog(`Selected start node: ${id}`);\n  }\n\n  // Reset graph states (colors and program vars)\n  function resetGraph() {\n    if (bfsTimeout) {\n      clearTimeout(bfsTimeout);\n      bfsTimeout = null;\n    }\n    bfsRunning = false;\n    visitedNodes.clear();\n    visitedEdges.clear();\n    bfsQueue = [];\n    startBtn.disabled = !selectedStartNode;\n    startInput.value = selectedStartNode || '';\n\n    // Reset nodes styles\n    for (const id in nodeElements) {\n      const circle = nodeElements[id].circle;\n      circle.classList.remove('visited', 'current');\n      circle.setAttribute('fill', '#eee');\n      if (id === selectedStartNode) {\n        circle.setAttribute('stroke', '#ff6f61');\n        circle.setAttribute('stroke-width', 4);\n      } else {\n        circle.setAttribute('stroke', '#666');\n        circle.setAttribute('stroke-width', 2);\n      }\n    }\n    // Reset edges\n    for (const key in edgeElements) {\n      edgeElements[key].classList.remove('highlighted');\n    }\n    clearLog();\n    appendLog('Graph reset.');\n  }\n\n  // Append message to log with auto scroll\n  function appendLog(msg) {\n    const timestamp = new Date().toLocaleTimeString();\n    logEl.textContent += `[${timestamp}] ${msg}\\n`;\n    logEl.scrollTop = logEl.scrollHeight;\n  }\n  function clearLog() {\n    logEl.textContent = '';\n  }\n\n  // BFS Algorithm with visual step-by-step and delays\n  function startBFS() {\n    if (!selectedStartNode || bfsRunning) return;\n\n    bfsRunning = true;\n    startBtn.disabled = true;\n    resetBtn.disabled = true;\n\n    visitedNodes.clear();\n    visitedEdges.clear();\n    bfsQueue = [selectedStartNode];\n    appendLog(`Starting BFS from node ${selectedStartNode}...`);\n\n    stepBFS();\n  }\n\n  function stepBFS() {\n    if (bfsQueue.length === 0) {\n      appendLog('BFS Complete!');\n      bfsRunning = false;\n      resetBtn.disabled = false;\n      return;\n    }\n\n    const current = bfsQueue.shift();\n\n    // Mark current node\n    if (visitedNodes.has(current)) {\n      // Already visited, do next step immediately\n      stepBFS();\n      return;\n    }\n\n    // Visual steps\n    // 1) Mark node current red (current visiting)\n    // 2) After delay, mark node visited teal\n    // 3) Enqueue all unvisited neighbors\n\n    // 1) Highlight current node \n    const currentCircle = nodeElements[current].circle;\n    currentCircle.classList.add('current');\n    currentCircle.setAttribute('fill', '#ff6f61');\n    appendLog(`Visiting node ${current}`);\n\n    // After 800ms, mark visited and enqueue neighbors\n    bfsTimeout = setTimeout(() => {\n      // Mark visited\n      currentCircle.classList.remove('current');\n      currentCircle.classList.add('visited');\n      currentCircle.setAttribute('fill', '#76c7c0');\n      visitedNodes.add(current);\n\n      // Enqueue neighbors\n      const neighbors = adjacency[current];\n      let newlyQueued = [];\n      neighbors.forEach(nbr => {\n        if (!visitedNodes.has(nbr) && !bfsQueue.includes(nbr)) {\n          bfsQueue.push(nbr);\n          newlyQueued.push(nbr);\n        }\n\n        // Highlight edge between current and neighbor if neighbor just queued or visited\n        if (visitedNodes.has(nbr) || bfsQueue.includes(nbr)) {\n          // To avoid double highlight, check visitedEdges Set with a sorted key\n          const edgeKey = [current, nbr].sort().join('-');\n          if (!visitedEdges.has(edgeKey)) {\n            visitedEdges.add(edgeKey);\n            const edgeEl = edgeElements[`${current}-${nbr}`];\n            if (edgeEl) {\n              edgeEl.classList.add('highlighted');\n            }\n          }\n        }\n      });\n\n      if (newlyQueued.length > 0) {\n        appendLog(`Enqueued neighbors of ${current}: ${newlyQueued.join(', ')}`);\n      } else {\n        appendLog(`No unvisited neighbors to enqueue from ${current}.`);\n      }\n\n      // Proceed to next step after 700ms\n      bfsTimeout = setTimeout(stepBFS, 700);\n    }, 800);\n  }\n\n  startBtn.addEventListener('click', () => {\n    if (!selectedStartNode) return;\n    clearLog();\n    startBFS();\n  });\n\n  resetBtn.addEventListener('click', () => {\n    resetGraph();\n  });\n\n  // Initialize states\n  resetGraph();\n\n  // Accessibility instructions in console:\n  console.info('BFS Visualization: Select a node by clicking or tab+Enter. Press Start BFS to run.');\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Breadth-First Search (BFS)"
    }
  ],
  "topic": "Breadth-First Search (BFS)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}