{
  "id": "0ccca361-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:46:04.533Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Bellman-Ford Algorithm",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Bellman-Ford Algorithm Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f4f6f8;\n  }\n  h1 {\n    text-align: center;\n  }\n  #graph-input {\n    margin-bottom: 15px;\n  }\n  #output {\n    white-space: pre-wrap;\n    background: #fff;\n    border: 1px solid #ccc;\n    padding: 15px;\n    height: 200px;\n    overflow-y: scroll;\n    font-family: monospace;\n  }\n  label, input, button {\n    font-size: 1rem;\n  }\n  #graph-input > div {\n    margin-bottom: 10px;\n  }\n  table {\n    border-collapse: collapse;\n    margin-top: 10px;\n  }\n  table, th, td {\n    border: 1px solid #666;\n    padding: 6px 10px;\n    text-align: center;\n  }\n  #visualization {\n    margin-top: 20px;\n    display: flex;\n    justify-content: center;\n  }\n  svg {\n    background: white;\n    border: 1px solid #ccc;\n    border-radius: 5px;\n  }\n  .node circle {\n    fill: #4a90e2;\n    stroke: #333;\n    stroke-width: 2px;\n  }\n  .node text {\n    fill: white;\n    font-weight: bold;\n    user-select: none;\n  }\n  .edge path {\n    stroke: #999;\n    stroke-width: 2px;\n    fill: none;\n    marker-end: url(#arrowhead);\n  }\n  .edge text {\n    font-size: 12px;\n    fill: #555;\n    user-select: none;\n  }\n  .highlight {\n    stroke: #e94e77 !important;\n    stroke-width: 3px !important;\n    fill: #e94e77 !important;\n  }\n  #steps {\n    margin-top: 20px;\n    max-height: 300px;\n    overflow-y: auto;\n    background: white;\n    border: 1px solid #ccc;\n    padding: 10px;\n    font-family: monospace;\n  }\n  #instructions {\n    max-width: 600px;\n    margin: 0 auto 20px auto;\n    background: #eef5fb;\n    border: 1px solid #a0c4ff;\n    padding: 15px;\n    border-radius: 5px;\n    font-size: 0.9rem;\n  }\n</style>\n</head>\n<body>\n<h1>Bellman-Ford Algorithm Visualization</h1>\n<div id=\"instructions\">\n  <p>Enter the directed graph edges and their weights below. Use the following format:<br>\n  <code>source target weight</code><br>\n  For example, to add an edge from node 0 to node 1 with weight -2, enter:<br>\n  <code>0 1 -2</code></p>\n  <p>Separate edges by new lines. Node IDs should be integers starting from 0.</p>\n  <p>After entering edges, specify the source vertex (start node) and click <strong>Run Bellman-Ford</strong> to see shortest paths and detect negative weight cycles.</p>\n</div>\n<div id=\"graph-input\">\n  <div>\n    <label for=\"edges\">Graph Edges (one per line):</label><br>\n    <textarea id=\"edges\" rows=\"10\" cols=\"45\" placeholder=\"0 1 5&#10;1 2 3&#10;0 2 10&#10;2 1 -2\"></textarea>\n  </div>\n  <div>\n    <label for=\"source\">Source Vertex:</label>\n    <input type=\"number\" id=\"source\" min=\"0\" value=\"0\" />\n  </div>\n  <div>\n    <button id=\"runBtn\">Run Bellman-Ford</button>\n  </div>\n</div>\n\n<div id=\"output-container\">\n  <h3>Algorithm Output:</h3>\n  <div id=\"output\">Enter graph edges and source, then click \"Run Bellman-Ford\".</div>\n</div>\n\n<div id=\"visualization\">\n  <svg id=\"svgGraph\" width=\"700\" height=\"400\" aria-label=\"Graph visualization\"></svg>\n</div>\n\n<div id=\"steps-container\">\n  <h3>Relaxation Steps:</h3>\n  <div id=\"steps\">Steps will appear here after running the algorithm.</div>\n</div>\n\n<script>\n(() => {\n  const svg = document.getElementById('svgGraph');\n  const edgesInput = document.getElementById('edges');\n  const sourceInput = document.getElementById('source');\n  const runBtn = document.getElementById('runBtn');\n  const output = document.getElementById('output');\n  const stepsDiv = document.getElementById('steps');\n\n  // Constants for visualization layout\n  const NODE_RADIUS = 20;\n  const SVG_WIDTH = svg.clientWidth || 700;\n  const SVG_HEIGHT = svg.clientHeight || 400;\n\n  // Clear SVG content\n  function clearSvg() {\n    while (svg.firstChild) svg.removeChild(svg.firstChild);\n  }\n\n  // Draw arrowhead marker\n  function addArrowheadMarker() {\n    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');\n    marker.setAttribute('id', 'arrowhead');\n    marker.setAttribute('markerWidth', '10');\n    marker.setAttribute('markerHeight', '7');\n    marker.setAttribute('refX', '10');\n    marker.setAttribute('refY', '3.5');\n    marker.setAttribute('orient', 'auto');\n    marker.setAttribute('fill', '#999');\n\n    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n    polygon.setAttribute('points', '0 0, 10 3.5, 0 7');\n    marker.appendChild(polygon);\n    defs.appendChild(marker);\n    svg.appendChild(defs);\n  }\n\n  // Parse input edges to structured graph form\n  // Returns {edges: [{source, target, weight}], nodes: Set(nodeIds)}\n  function parseEdges(text) {\n    const lines = text.trim().split('\\n');\n    const edges = [];\n    const nodes = new Set();\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].trim();\n      if (!line) continue;\n      const parts = line.split(/\\s+/);\n      if (parts.length !== 3) {\n        throw new Error(`Line ${i + 1}: Expected 3 values per line (source target weight)`);\n      }\n      const source = parseInt(parts[0], 10);\n      const target = parseInt(parts[1], 10);\n      const weight = parseFloat(parts[2]);\n      if (isNaN(source) || isNaN(target) || isNaN(weight)) {\n        throw new Error(`Line ${i + 1}: Invalid number format`);\n      }\n      edges.push({ source, target, weight });\n      nodes.add(source);\n      nodes.add(target);\n    }\n    return { edges, nodes };\n  }\n\n  // Calculate positions for nodes in a circle for visualization\n  // Returns Map nodeId => {x, y}\n  function calculateNodePositions(nodes) {\n    const nodeArray = Array.from(nodes).sort((a,b) => a-b);\n    const count = nodeArray.length;\n    const centerX = SVG_WIDTH / 2;\n    const centerY = SVG_HEIGHT / 2;\n    const radius = Math.min(SVG_WIDTH, SVG_HEIGHT) / 2 - 60;\n\n    const positions = new Map();\n    nodeArray.forEach((nodeId, i) => {\n      const angle = (2 * Math.PI * i) / count - Math.PI / 2;\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n      positions.set(nodeId, { x, y });\n    });\n    return positions;\n  }\n\n  // Create SVG elements for the graph\n  function drawGraph(edges, nodes, positions, highlightEdges = [], distances = {}) {\n    clearSvg();\n    addArrowheadMarker();\n\n    // Draw edges first\n    for (const { source, target, weight } of edges) {\n      const start = positions.get(source);\n      const end = positions.get(target);\n      if (!start || !end) continue;\n\n      // Calculate line start/end adjusted to node radius\n      const dx = end.x - start.x;\n      const dy = end.y - start.y;\n      const len = Math.sqrt(dx*dx + dy*dy);\n      const offsetX = (dx / len) * NODE_RADIUS;\n      const offsetY = (dy / len) * NODE_RADIUS;\n      const lineStartX = start.x + offsetX;\n      const lineStartY = start.y + offsetY;\n      const lineEndX = end.x - offsetX;\n      const lineEndY = end.y - offsetY;\n\n      // Create path for edge\n      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n      path.setAttribute('d', `M${lineStartX},${lineStartY} L${lineEndX},${lineEndY}`);\n      path.setAttribute('class', 'edge');\n      path.setAttribute('stroke', '#999');\n      path.setAttribute('stroke-width', '2');\n      path.setAttribute('fill', 'none');\n      path.setAttribute('marker-end', 'url(#arrowhead)');\n\n      // Highlight if in highlightEdges\n      if (highlightEdges.some(e => e.source === source && e.target === target && e.weight === weight)) {\n        path.classList.add('highlight');\n        path.setAttribute('stroke', '#e94e77');\n        path.setAttribute('stroke-width', '3');\n      }\n\n      svg.appendChild(path);\n\n      // Weight label midpoint with a slight offset\n      const labelX = (lineStartX + lineEndX) / 2 + (-dy / len) * 12;\n      const labelY = (lineStartY + lineEndY) / 2 + (dx / len) * 12;\n      const weightText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      weightText.setAttribute('x', labelX);\n      weightText.setAttribute('y', labelY);\n      weightText.setAttribute('text-anchor', 'middle');\n      weightText.setAttribute('dominant-baseline', 'middle');\n      weightText.setAttribute('class', 'edge-text');\n      weightText.setAttribute('fill', highlightEdges.some(e => e.source === source && e.target === target && e.weight === weight) ? '#e94e77' : '#555');\n      weightText.textContent = weight;\n      svg.appendChild(weightText);\n    }\n\n    // Draw nodes on top\n    for (const nodeId of nodes) {\n      const pos = positions.get(nodeId);\n      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      g.setAttribute('class', 'node');\n      g.setAttribute('tabindex', 0);\n      g.setAttribute('role', 'button');\n      g.setAttribute('aria-label', 'Node ' + nodeId);\n      g.setAttribute('transform', `translate(${pos.x},${pos.y})`);\n\n      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n      circle.setAttribute('r', NODE_RADIUS);\n      circle.setAttribute('stroke', '#333');\n      circle.setAttribute('stroke-width', '2');\n      circle.setAttribute('fill', '#4a90e2');\n\n      // Highlight source node in a different color\n      if (distances.source === nodeId) {\n        circle.setAttribute('fill', '#f39c12');\n        circle.setAttribute('stroke', '#b36b00');\n      }\n\n      // If distance is Infinity we show '∞', else the distance\n      const distVal = (distances.dist && typeof distances.dist[nodeId] !== 'undefined') \n        ? (distances.dist[nodeId] === Infinity ? '∞' : distances.dist[nodeId]) \n        : '';\n\n      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      text.setAttribute('fill', 'white');\n      text.setAttribute('font-weight', 'bold');\n      text.setAttribute('text-anchor', 'middle');\n      text.setAttribute('dominant-baseline', 'middle');\n      text.textContent = nodeId;\n\n      const distText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      distText.setAttribute('fill', '#ffeb3b');\n      distText.setAttribute('font-size', '12px');\n      distText.setAttribute('text-anchor', 'middle');\n      distText.setAttribute('dominant-baseline', 'hanging');\n      distText.textContent = distVal;\n\n      g.appendChild(circle);\n      g.appendChild(text);\n      g.appendChild(distText);\n      svg.appendChild(g);\n    }\n  }\n\n  // Bellman-Ford Algorithm Implementation\n  /*\n   * graph: { edges: [{source, target, weight}], nodes: Set }\n   * source: integer nodeId\n   *\n   * Returns:\n   *  - {dist: map nodeId->distance,\n   *     predecessor: map nodeId->predecessor or null,\n   *     negativeCycle: boolean,\n   *     steps: array of step descriptions}\n   */\n  function bellmanFord(graph, source) {\n    const dist = {};\n    const predecessor = {};\n    const steps = [];\n\n    // Initialization\n    graph.nodes.forEach((node) => {\n      dist[node] = Infinity;\n      predecessor[node] = null;\n    });\n    dist[source] = 0;\n\n    steps.push(`Initialization: set distance[${source}] = 0, all others to Infinity.\\n`);\n\n    const edges = graph.edges;\n\n    const nodeCount = graph.nodes.size;\n\n    for (let i = 1; i <= nodeCount - 1; i++) {\n      steps.push(`Iteration ${i}:\\n`);\n      let anyUpdate = false;\n      for (const { source: u, target: v, weight: w } of edges) {\n        const prevDist = dist[v];\n        if (dist[u] !== Infinity && dist[u] + w < dist[v]) {\n          dist[v] = dist[u] + w;\n          predecessor[v] = u;\n          anyUpdate = true;\n          steps.push(`  Relax edge (${u} -> ${v}) with weight ${w}: updated dist[${v}] from ${prevDist === Infinity ? '∞' : prevDist} to ${dist[v]}.\\n`);\n        } else {\n          steps.push(`  Check edge (${u} -> ${v}) with weight ${w}: no update needed.\\n`);\n        }\n      }\n      if (!anyUpdate) {\n        steps.push(`No updates in this iteration. Early stop.\\n`);\n        break;\n      }\n    }\n\n    // Check for negative-weight cycles\n    let negativeCycle = false;\n    steps.push(`Checking for negative weight cycles:\\n`);\n    for (const { source: u, target: v, weight: w } of edges) {\n      if (dist[u] !== Infinity && dist[u] + w < dist[v]) {\n        negativeCycle = true;\n        steps.push(`  Negative cycle detected via edge (${u} -> ${v}) with weight ${w}.\\n`);\n        break;\n      }\n    }\n    if (!negativeCycle) {\n      steps.push(`  No negative weight cycles detected.\\n`);\n    }\n\n    return { dist, predecessor, negativeCycle, steps, source };\n  }\n\n  // Reconstruct path from source to a target node using predecessor map\n  function reconstructPath(predecessor, source, target) {\n    let path = [];\n    let current = target;\n    while (current !== null && current !== undefined) {\n      path.push(current);\n      if (current === source) break;\n      current = predecessor[current];\n    }\n    if (path[path.length - 1] !== source) return null; // no path\n    return path.reverse();\n  }\n\n  // Format output text with distances and paths\n  function formatOutput(data) {\n    if (data.negativeCycle) {\n      return 'Negative weight cycle detected. Shortest paths not reliable.';\n    }\n    let text = `Shortest distances from source vertex ${data.source}:\\n`;\n    for (const node of Array.from(Object.keys(data.dist)).sort((a,b) => a - b)) {\n      const distVal = data.dist[node];\n      if (distVal === Infinity) {\n        text += `  Node ${node}: unreachable\\n`;\n      } else {\n        const path = reconstructPath(data.predecessor, data.source, Number(node));\n        const pathStr = path ? path.join(' → ') : 'unreachable';\n        text += `  Node ${node}: distance = ${distVal}, path = ${pathStr}\\n`;\n      }\n    }\n    return text;\n  }\n\n  // Highlight edges that were relaxed in the last iteration where an update happened\n  // We will parse the steps logs to collect the last updated edges for visual highlight\n  function extractLastRelaxedEdgesFromSteps(steps) {\n    // Steps have lines like:\n    // \"  Relax edge (u -> v) with weight w: updated dist[v] from ... to ...\"\n    // We want to find the edges updated in the last iteration that had any update.\n\n    // Reverse iterate to find last iteration with updates and collect edges updated there.\n    const updatesPerIteration = [];\n    let currentIterationUpdates = [];\n    let iterationStarted = false;\n    for (const line of steps) {\n      const iterMatch = line.match(/^Iteration (\\d+):/);\n      if (iterMatch) {\n        if (iterationStarted) {\n          updatesPerIteration.push(currentIterationUpdates);\n          currentIterationUpdates = [];\n        }\n        iterationStarted = true;\n      } else if (/Relax edge \\((\\d+) -> (\\d+)\\) with weight (-?\\d+\\.?\\d*): updated/.test(line)) {\n        const m = line.match(/Relax edge \\((\\d+) -> (\\d+)\\) with weight (-?\\d+\\.?\\d*): updated/);\n        currentIterationUpdates.push({\n          source: Number(m[1]),\n          target: Number(m[2]),\n          weight: Number(m[3])\n        });\n      }\n    }\n    if (iterationStarted) updatesPerIteration.push(currentIterationUpdates);\n\n    // Find last iteration with updates (non-empty array) from end\n    for (let i = updatesPerIteration.length - 1; i >= 0; i--) {\n      if (updatesPerIteration[i].length > 0) return updatesPerIteration[i];\n    }\n    return [];\n  }\n\n  runBtn.addEventListener('click', () => {\n    const edgesText = edgesInput.value.trim();\n    const sourceNode = Number(sourceInput.value);\n\n    output.textContent = '';\n    stepsDiv.textContent = '';\n\n    if (isNaN(sourceNode)) {\n      output.textContent = 'Invalid source vertex.';\n      return;\n    }\n    if (!edgesText) {\n      output.textContent = 'Please enter edges.';\n      return;\n    }\n\n    let graph;\n    try {\n      graph = parseEdges(edgesText);\n    } catch (e) {\n      output.textContent = 'Error parsing edges: ' + e.message;\n      return;\n    }\n\n    if (!graph.nodes.has(sourceNode)) {\n      output.textContent = `Source vertex ${sourceNode} does not exist in the graph nodes.`;\n      return;\n    }\n\n    // Run Bellman-Ford\n    const result = bellmanFord(graph, sourceNode);\n\n    // Show output text\n    output.textContent = formatOutput(result);\n\n    // Show steps:\n    stepsDiv.textContent = result.steps.join('');\n\n    // Calculate node positions & draw graph with highlights on edges relaxed in last update iteration\n    const positions = calculateNodePositions(graph.nodes);\n    const highlightEdges = extractLastRelaxedEdgesFromSteps(result.steps);\n    drawGraph(graph.edges, graph.nodes, positions, highlightEdges, { dist: result.dist, source: sourceNode });\n  });\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Bellman-Ford Algorithm"
    }
  ],
  "topic": "Bellman-Ford Algorithm",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}