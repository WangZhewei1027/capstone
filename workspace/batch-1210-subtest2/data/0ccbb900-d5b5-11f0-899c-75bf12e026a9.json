{
  "id": "0ccbb900-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:46:03.365Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Adjacency Matrix",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Adjacency Matrix Visualization</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n  }\n  h1 {\n    text-align: center;\n  }\n  #graphInputs {\n    margin-bottom: 20px;\n  }\n  label {\n    display: block;\n    margin-top: 10px;\n  }\n  input[type=\"number\"], input[type=\"text\"] {\n    width: 50px;\n    text-align: center;\n  }\n  textarea {\n    width: 300px;\n    height: 80px;\n    font-family: monospace;\n  }\n  table {\n    border-collapse: collapse;\n    margin-top: 20px;\n  }\n  table, th, td {\n    border: 1px solid #444;\n  }\n  th, td {\n    padding: 5px 10px;\n    text-align: center;\n  }\n  #matrixContainer {\n    overflow-x: auto;\n  }\n  #graphDisplay {\n    margin-top: 30px;\n    display: flex;\n    justify-content: center;\n  }\n  svg {\n    border: 1px solid #ddd;\n    background-color: #fafafa;\n  }\n</style>\n</head>\n<body>\n<h1>Adjacency Matrix Demonstration</h1>\n\n<div id=\"graphInputs\">\n  <label>\n    Number of vertices (max 10):\n    <input type=\"number\" id=\"numVertices\" min=\"1\" max=\"10\" value=\"4\" />\n  </label>\n  <label>\n    Directed graph?\n    <input type=\"checkbox\" id=\"directed\" />\n  </label>\n  <label>\n    Weighted edges?\n    <input type=\"checkbox\" id=\"weighted\" />\n  </label>\n  <label>\n    Enter edges (one per line):\n    <br />\n    Format:\n    <ul>\n      <li>Unweighted: <code>src dest</code> (e.g. <code>0 2</code>)</li>\n      <li>Weighted: <code>src dest weight</code> (e.g. <code>0 2 5</code>)</li>\n      <li>Vertices indexed from 0 to n-1</li>\n    </ul>\n    <textarea id=\"edgesInput\">0 1\n0 2\n1 2\n2 3</textarea>\n  </label>\n  <br />\n  <button id=\"generateMatrixBtn\">Generate Adjacency Matrix</button>\n</div>\n\n<div id=\"matrixContainer\">\n  <h2>Adjacency Matrix</h2>\n  <div id=\"matrixOutput\"></div>\n</div>\n\n<div id=\"graphDisplay\">\n  <svg id=\"graphSVG\" width=\"500\" height=\"400\"></svg>\n</div>\n\n<script>\n(() => {\n  const numVerticesInput = document.getElementById('numVertices');\n  const directedInput = document.getElementById('directed');\n  const weightedInput = document.getElementById('weighted');\n  const edgesInput = document.getElementById('edgesInput');\n  const generateBtn = document.getElementById('generateMatrixBtn');\n  const matrixOutput = document.getElementById('matrixOutput');\n  const graphSVG = document.getElementById('graphSVG');\n\n  // Clear SVG content\n  function clearSVG() {\n    while (graphSVG.firstChild) {\n      graphSVG.removeChild(graphSVG.firstChild);\n    }\n  }\n\n  // Create adjacency matrix\n  function createAdjacencyMatrix(n, edges, directed, weighted) {\n    const matrix = Array(n)\n      .fill(null)\n      .map(() => Array(n).fill(weighted ? 0 : 0)); // 0 for no edge\n\n    edges.forEach(edge => {\n      const [src, dest, w] = edge;\n      if (weighted) {\n        matrix[src][dest] = w;\n        if (!directed) matrix[dest][src] = w;\n      } else {\n        matrix[src][dest] = 1;\n        if (!directed) matrix[dest][src] = 1;\n      }\n    });\n    return matrix;\n  }\n\n  // Render matrix as HTML table\n  function renderMatrix(matrix, weighted) {\n    const n = matrix.length;\n    const table = document.createElement('table');\n    const thead = document.createElement('thead');\n    const headerRow = document.createElement('tr');\n\n    // Top-left empty corner cell\n    const cornerCell = document.createElement('th');\n    cornerCell.textContent = '';\n    headerRow.appendChild(cornerCell);\n\n    // Header columns: vertex indices\n    for (let j = 0; j < n; j++) {\n      const th = document.createElement('th');\n      th.textContent = j;\n      headerRow.appendChild(th);\n    }\n    thead.appendChild(headerRow);\n    table.appendChild(thead);\n\n    const tbody = document.createElement('tbody');\n    for (let i = 0; i < n; i++) {\n      const row = document.createElement('tr');\n      const rowHeader = document.createElement('th');\n      rowHeader.textContent = i;\n      row.appendChild(rowHeader);\n\n      for (let j = 0; j < n; j++) {\n        const td = document.createElement('td');\n        let val = matrix[i][j];\n        if (weighted) {\n          // Show 0 as empty for clarity\n          td.textContent = val === 0 ? '' : val;\n        } else {\n          td.textContent = val;\n        }\n        row.appendChild(td);\n      }\n      tbody.appendChild(row);\n    }\n    table.appendChild(tbody);\n    return table;\n  }\n\n  // Draw the graph on SVG\n  function drawGraph(matrix, directed, weighted) {\n    clearSVG();\n    const n = matrix.length;\n    const width = graphSVG.clientWidth;\n    const height = graphSVG.clientHeight;\n    const radius = Math.min(width, height) / 2 - 50; // leave margin\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Calculate vertex positions on a circle\n    const positions = [];\n    for (let i = 0; i < n; i++) {\n      const angle = (2 * Math.PI * i) / n - Math.PI / 2; // start from top\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n      positions.push({ x, y });\n    }\n\n    // Draw edges (lines/arrows)\n    // To avoid overlapping, if multiple edges between same nodes, shift slightly\n    const existingEdges = new Set();\n\n    function createArrowMarker() {\n      const marker = document.createElementNS(\"http://www.w3.org/2000/svg\", \"marker\");\n      marker.setAttribute(\"id\", \"arrowhead\");\n      marker.setAttribute(\"markerWidth\", \"10\");\n      marker.setAttribute(\"markerHeight\", \"7\");\n      marker.setAttribute(\"refX\", \"10\");\n      marker.setAttribute(\"refY\", \"3.5\");\n      marker.setAttribute(\"orient\", \"auto\");\n      marker.setAttribute(\"fill\", \"#333\");\n      const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n      path.setAttribute(\"d\", \"M0,0 L10,3.5 L0,7 Z\");\n      marker.appendChild(path);\n      return marker;\n    }\n\n    // Add defs for arrow markers once\n    let defs = graphSVG.querySelector('defs');\n    if (!defs) {\n      defs = document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n      graphSVG.appendChild(defs);\n      defs.appendChild(createArrowMarker());\n    }\n\n    // Helper to shorten line ends so arrows don't overlap nodes\n    function shortenLine(x1, y1, x2, y2, shorten) {\n      // shorten: length to shorten from end\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n      const length = Math.sqrt(dx * dx + dy * dy);\n      if (length === 0) return [x1, y1, x2, y2];\n      const ratio = (length - shorten) / length;\n      const newX2 = x1 + dx * ratio;\n      const newY2 = y1 + dy * ratio;\n      return [x1, y1, newX2, newY2];\n    }\n\n    // Draw edges\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        let val = matrix[i][j];\n        if ((weighted && val !== 0) || (!weighted && val === 1)) {\n          // Check duplicate edge in undirected graph\n          if (!directed && i > j) continue; // draw only once\n\n          // Calculate line start/end points slightly outside vertex circles\n          const { x: x1, y: y1 } = positions[i];\n          const { x: x2, y: y2 } = positions[j];\n          const nodeRadius = 15;\n          const [startX, startY, endX, endY] = shortenLine(\n            x1,\n            y1,\n            x2,\n            y2,\n            nodeRadius\n          );\n\n          // For directed graphs, add arrow marker\n          const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n          line.setAttribute(\"x1\", startX);\n          line.setAttribute(\"y1\", startY);\n          line.setAttribute(\"x2\", endX);\n          line.setAttribute(\"y2\", endY);\n          line.setAttribute(\"stroke\", \"#333\");\n          line.setAttribute(\"stroke-width\", \"2\");\n\n          if (directed) {\n            line.setAttribute(\"marker-end\", \"url(#arrowhead)\");\n          }\n\n          // For self loop, draw a small circle near the node\n          if (i === j) {\n            // Remove the line, draw loop as a circle near node\n            // Draw a circle offset right/down of the node position\n            const loopRadius = 12;\n            const loop = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n            loop.setAttribute(\"cx\", x1 + nodeRadius + loopRadius);\n            loop.setAttribute(\"cy\", y1 - loopRadius);\n            loop.setAttribute(\"r\", loopRadius);\n            loop.setAttribute(\"fill\", \"none\");\n            loop.setAttribute(\"stroke\", \"#333\");\n            loop.setAttribute(\"stroke-width\", \"2\");\n            graphSVG.appendChild(loop);\n\n            if (weighted) {\n              const txt = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n              txt.setAttribute(\"x\", x1 + nodeRadius + loopRadius);\n              txt.setAttribute(\"y\", y1 - loopRadius);\n              txt.setAttribute(\"font-size\", \"12\");\n              txt.setAttribute(\"fill\", \"#333\");\n              txt.setAttribute(\"text-anchor\", \"middle\");\n              txt.setAttribute(\"dominant-baseline\", \"middle\");\n              txt.textContent = val;\n              graphSVG.appendChild(txt);\n            }\n            continue;\n          }\n\n          graphSVG.appendChild(line);\n\n          // Add weight label for weighted edges\n          if (weighted) {\n            // Position text near midpoint offset a bit\n            const midX = (startX + endX) / 2;\n            const midY = (startY + endY) / 2;\n\n            // Offset perpendicular direction for clarity\n            const dx = endX - startX;\n            const dy = endY - startY;\n            const offset = 12;\n            const length = Math.sqrt(dx * dx + dy * dy);\n            const offsetX = -(dy / length) * offset;\n            const offsetY = (dx / length) * offset;\n\n            const txt = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n            txt.setAttribute(\"x\", midX + offsetX);\n            txt.setAttribute(\"y\", midY + offsetY);\n            txt.setAttribute(\"font-size\", \"12\");\n            txt.setAttribute(\"fill\", \"#d22\");\n            txt.setAttribute(\"font-weight\", \"bold\");\n            txt.setAttribute(\"text-anchor\", \"middle\");\n            txt.setAttribute(\"dominant-baseline\", \"middle\");\n            txt.textContent = val;\n            graphSVG.appendChild(txt);\n          }\n        }\n      }\n    }\n\n    // Draw vertices as circles with labels\n    for (let i = 0; i < n; i++) {\n      const { x, y } = positions[i];\n      // Circle\n      const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      circle.setAttribute(\"cx\", x);\n      circle.setAttribute(\"cy\", y);\n      circle.setAttribute(\"r\", 15);\n      circle.setAttribute(\"fill\", \"#3a87ad\");\n      circle.setAttribute(\"stroke\", \"#222\");\n      circle.setAttribute(\"stroke-width\", \"2\");\n      graphSVG.appendChild(circle);\n\n      // Label\n      const text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      text.setAttribute(\"x\", x);\n      text.setAttribute(\"y\", y + 1); // adjust vertical center\n      text.setAttribute(\"font-size\", \"14\");\n      text.setAttribute(\"fill\", \"#fff\");\n      text.setAttribute(\"font-weight\", \"bold\");\n      text.setAttribute(\"text-anchor\", \"middle\");\n      text.setAttribute(\"dominant-baseline\", \"middle\");\n      text.textContent = i;\n      graphSVG.appendChild(text);\n    }\n  }\n\n  function parseEdges(inputText, weighted, n) {\n    const lines = inputText.trim().split('\\n');\n    const edges = [];\n    for (let idx = 0; idx < lines.length; idx++) {\n      const line = lines[idx].trim();\n      if (!line) continue;\n      const parts = line.split(/\\s+/);\n      if (weighted) {\n        if (parts.length < 3) {\n          alert(`Invalid edge format in line ${idx + 1}, expected: src dest weight`);\n          return null;\n        }\n        const [srcStr, destStr, weightStr] = parts;\n        const src = parseInt(srcStr, 10);\n        const dest = parseInt(destStr, 10);\n        const weight = Number(weightStr);\n        if (\n          Number.isNaN(src) ||\n          Number.isNaN(dest) ||\n          Number.isNaN(weight) ||\n          src < 0 ||\n          src >= n ||\n          dest < 0 ||\n          dest >= n\n        ) {\n          alert(`Invalid values in line ${idx + 1}`);\n          return null;\n        }\n        edges.push([src, dest, weight]);\n      } else {\n        if (parts.length < 2) {\n          alert(`Invalid edge format in line ${idx + 1}, expected: src dest`);\n          return null;\n        }\n        const [srcStr, destStr] = parts;\n        const src = parseInt(srcStr, 10);\n        const dest = parseInt(destStr, 10);\n        if (\n          Number.isNaN(src) ||\n          Number.isNaN(dest) ||\n          src < 0 ||\n          src >= n ||\n          dest < 0 ||\n          dest >= n\n        ) {\n          alert(`Invalid values in line ${idx + 1}`);\n          return null;\n        }\n        edges.push([src, dest]);\n      }\n    }\n    return edges;\n  }\n\n  generateBtn.addEventListener('click', () => {\n    const n = parseInt(numVerticesInput.value, 10);\n    if (!(n >= 1 && n <= 10)) {\n      alert('Number of vertices must be between 1 and 10');\n      return;\n    }\n    const directed = directedInput.checked;\n    const weighted = weightedInput.checked;\n\n    const edges = parseEdges(edgesInput.value, weighted, n);\n    if (edges === null) return;\n\n    const matrix = createAdjacencyMatrix(n, edges, directed, weighted);\n\n    // Show matrix\n    matrixOutput.innerHTML = '';\n    const table = renderMatrix(matrix, weighted);\n    matrixOutput.appendChild(table);\n\n    // Draw graph\n    drawGraph(matrix, directed, weighted);\n  });\n\n  // Initial generate run for default inputs\n  generateBtn.click();\n})();\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Adjacency Matrix"
    }
  ],
  "topic": "Adjacency Matrix",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}