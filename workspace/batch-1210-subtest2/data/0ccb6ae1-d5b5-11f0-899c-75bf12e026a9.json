{
  "id": "0ccb6ae1-d5b5-11f0-899c-75bf12e026a9",
  "timestamp": "2025-12-10T10:46:07.159Z",
  "model": "gpt-3.5-turbo",
  "status": "success",
  "question": "Heap (Min/Max)",
  "answer": {
    "role": "assistant",
    "content": "<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Heap (Min/Max) Visualization and Demo</title>\n<style>\n  body {\n    font-family: Arial, sans-serif;\n    margin: 20px;\n    background: #f0f4f8;\n  }\n  h1 {\n    text-align: center;\n  }\n  #container {\n    display: flex;\n    justify-content: center;\n    gap: 40px;\n    flex-wrap: wrap;\n  }\n  .heap-container {\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 8px rgb(0 0 0 / 0.1);\n    padding: 20px;\n    width: 450px;\n  }\n  .heap-container h2 {\n    text-align: center;\n    margin-bottom: 15px;\n  }\n  .controls {\n    display: flex;\n    justify-content: center;\n    gap: 10px;\n    margin-bottom: 10px;\n  }\n  input[type=number] {\n    width: 80px;\n    padding: 6px;\n    font-size: 16px;\n  }\n  button {\n    padding: 7px 12px;\n    font-size: 16px;\n    cursor: pointer;\n    border: none;\n    background: #0288d1;\n    color: white;\n    border-radius: 4px;\n    transition: background-color 0.2s ease;\n  }\n  button:hover:not(:disabled) {\n    background: #0277bd;\n  }\n  button:disabled {\n    background: #bbb;\n    cursor: default;\n  }\n  #output {\n    font-family: monospace;\n    background: #eef4f9;\n    border-radius: 5px;\n    padding: 10px;\n    height: 150px;\n    overflow-y: auto;\n    white-space: pre-wrap;\n    border: 1px solid #ccc;\n  }\n  .tree {\n    display: flex;\n    justify-content: center;\n    flex-wrap: wrap;\n    margin-top: 15px;\n    user-select: none;\n  }\n  .node {\n    background: #0288d1;\n    color: white;\n    padding: 6px 12px;\n    margin: 5px;\n    border-radius: 4px;\n    min-width: 32px;\n    text-align: center;\n    position: relative;\n  }\n  .node.min {\n    background: #0288d1;\n  }\n  .node.max {\n    background: #d13212;\n  }\n  .level {\n    display: flex;\n    justify-content: center;\n    gap: 10px;\n  }\n  .connections {\n    position: relative;\n    height: 25px;\n  }\n  /* Lines connecting parent to children */\n  .line {\n    position: absolute;\n    border-left: 2px solid #444;\n    border-bottom: 2px solid #444;\n  }\n</style>\n</head>\n<body>\n<h1>Heap (Min/Max) Demo & Visualization</h1>\n<div id=\"container\">\n  <div class=\"heap-container\" id=\"minHeapContainer\">\n    <h2>Min Heap</h2>\n    <div class=\"controls\">\n      <input type=\"number\" id=\"minHeapInput\" placeholder=\"Enter number\" />\n      <button id=\"minHeapInsertBtn\">Insert</button>\n      <button id=\"minHeapExtractBtn\" disabled>Extract Min</button>\n      <button id=\"minHeapClearBtn\">Clear</button>\n    </div>\n    <div id=\"minHeapOutput\" class=\"output\" style=\"min-height: 170px; background: #e1f5fe; border-radius:5px; padding:8px; font-family: monospace; overflow-y:auto;\"></div>\n    <div id=\"minHeapTree\" class=\"tree\" aria-label=\"Min Heap Tree Visualization\"></div>\n  </div>\n\n  <div class=\"heap-container\" id=\"maxHeapContainer\">\n    <h2>Max Heap</h2>\n    <div class=\"controls\">\n      <input type=\"number\" id=\"maxHeapInput\" placeholder=\"Enter number\" />\n      <button id=\"maxHeapInsertBtn\">Insert</button>\n      <button id=\"maxHeapExtractBtn\" disabled>Extract Max</button>\n      <button id=\"maxHeapClearBtn\">Clear</button>\n    </div>\n    <div id=\"maxHeapOutput\" class=\"output\" style=\"min-height: 170px; background: #ffebee; border-radius:5px; padding:8px; font-family: monospace; overflow-y:auto;\"></div>\n    <div id=\"maxHeapTree\" class=\"tree\" aria-label=\"Max Heap Tree Visualization\"></div>\n  </div>\n</div>\n\n<script>\n  // Heap class with comparator\n  class Heap {\n    constructor(comparator) {\n      this.data = [];\n      this.comparator = comparator || ((a, b) => a - b);\n    }\n\n    size() {\n      return this.data.length;\n    }\n\n    peek() {\n      return this.data.length > 0 ? this.data[0] : null;\n    }\n\n    insert(value) {\n      this.data.push(value);\n      this.bubbleUp(this.data.length - 1);\n    }\n\n    extract() {\n      if (this.data.length === 0) return null;\n      const top = this.data[0];\n      const last = this.data.pop();\n      if (this.data.length > 0) {\n        this.data[0] = last;\n        this.bubbleDown(0);\n      }\n      return top;\n    }\n\n    bubbleUp(index) {\n      while (index > 0) {\n        const parent = Math.floor((index - 1) / 2);\n        if (this.comparator(this.data[index], this.data[parent]) < 0) {\n          [this.data[index], this.data[parent]] = [this.data[parent], this.data[index]];\n          index = parent;\n        } else {\n          break;\n        }\n      }\n    }\n\n    bubbleDown(index) {\n      const length = this.data.length;\n      while (true) {\n        const left = index * 2 + 1;\n        const right = index * 2 + 2;\n        let smallest = index;\n\n        if (left < length && this.comparator(this.data[left], this.data[smallest]) < 0) {\n          smallest = left;\n        }\n        if (right < length && this.comparator(this.data[right], this.data[smallest]) < 0) {\n          smallest = right;\n        }\n        if (smallest === index) break;\n\n        [this.data[index], this.data[smallest]] = [this.data[smallest], this.data[index]];\n        index = smallest;\n      }\n    }\n\n    clear() {\n      this.data = [];\n    }\n\n    toArray() {\n      return [...this.data];\n    }\n  }\n\n  // Utilities for tree visualization\n  function buildLevels(array) {\n    // Takes the array representing heap and returns an array of levels\n    const levels = [];\n    let level = 0;\n    let count = 1;\n    let i = 0;\n    while (i < array.length) {\n      const levelArr = array.slice(i, i + count);\n      levels.push(levelArr);\n      i += count;\n      count *= 2;\n      level++;\n    }\n    return levels;\n  }\n\n  function createNodeElement(value, type) {\n    const div = document.createElement('div');\n    div.classList.add('node');\n    div.classList.add(type === 'min' ? 'min' : 'max');\n    div.textContent = value;\n    return div;\n  }\n\n  function createConnections(container, startIdx, levelNodesCount, level) {\n    // Draw connecting lines between nodes for visualization\n\n    // We do this by creating absolutely positioned divs connecting parents with children\n    // The container must be position: relative or absolute.\n\n    const lineThickness = 2;\n\n    // Dimensions approximate based on CSS\n    // Each node ~44px width + margin, height ~30px\n\n    // To simplify drawing, we won't do precise lines but simple corner lines under nodes.\n\n    // Container offset top to position lines\n    const offsetTop = 0;\n    const offsetLeft = 0;\n\n    const nodes = container.querySelectorAll(`.level:nth-child(${level + 1}) .node`);\n    if (!nodes.length) return;\n    const nextLevel = container.querySelectorAll(`.level:nth-child(${level + 2}) .node`);\n    if (!nextLevel.length) return;\n\n    // Position lines between parents and children\n    // For each parent node, draw lines to two children if they exist.\n\n    const parentCount = nodes.length;\n\n    // Clear existing lines container\n    let connectionsContainer = container.querySelector(`.connections.level-${level}`);\n    if (connectionsContainer) {\n      connectionsContainer.remove();\n    }\n\n    const connections = document.createElement('div');\n    connections.classList.add('connections', `level-${level}`);\n    connections.style.position = 'relative';\n    connections.style.height = '40px';\n    connections.style.marginTop = '-20px';\n    container.appendChild(connections);\n\n    for (let i = 0; i < parentCount; i++) {\n      const parentNode = nodes[i];\n      const childLeftIndex = i * 2;\n      const childRightIndex = i * 2 + 1;\n\n      const parentRect = parentNode.getBoundingClientRect();\n      const parentCenterX = parentNode.offsetLeft + parentNode.offsetWidth / 2;\n\n      if (childLeftIndex < nextLevel.length) {\n        const leftChild = nextLevel[childLeftIndex];\n        const leftRect = leftChild.getBoundingClientRect();\n        const leftCenterX = leftChild.offsetLeft + leftChild.offsetWidth / 2;\n        // Create line from parent center to left child center\n        const line = document.createElement('div');\n        line.classList.add('line');\n        // We create an \"L\" shaped line: vertical down then horizontal to child\n        // Position line absolutely relative to connections container\n        const startX = parentCenterX;\n        const startY = 0;\n        const endX = leftCenterX;\n        const endY = 40;\n\n        // Vertical line from parentCenterX, 0 to parentCenterX, 20\n        const verticalLine = document.createElement('div');\n        verticalLine.style.position = 'absolute';\n        verticalLine.style.left = startX + 'px';\n        verticalLine.style.top = startY + 'px';\n        verticalLine.style.width = lineThickness + 'px';\n        verticalLine.style.height = '20px';\n        verticalLine.style.backgroundColor = '#444';\n        connections.appendChild(verticalLine);\n\n        // Horizontal line from min(startX, endX) to max(startX, endX), at top 20px\n        const horizontalLine = document.createElement('div');\n        horizontalLine.style.position = 'absolute';\n        horizontalLine.style.top = '20px';\n        horizontalLine.style.left = Math.min(startX, endX) + 'px';\n        horizontalLine.style.width = Math.abs(endX - startX) + 'px';\n        horizontalLine.style.height = lineThickness + 'px';\n        horizontalLine.style.backgroundColor = '#444';\n        connections.appendChild(horizontalLine);\n\n        // Vertical line down to child center horizontally at endX, from 20 to 40\n        const verticalLineDown = document.createElement('div');\n        verticalLineDown.style.position = 'absolute';\n        verticalLineDown.style.left = endX + 'px';\n        verticalLineDown.style.top = '20px';\n        verticalLineDown.style.width = lineThickness + 'px';\n        verticalLineDown.style.height = '20px';\n        verticalLineDown.style.backgroundColor = '#444';\n        connections.appendChild(verticalLineDown);\n      }\n\n      if (childRightIndex < nextLevel.length) {\n        const rightChild = nextLevel[childRightIndex];\n        const rightRect = rightChild.getBoundingClientRect();\n        const rightCenterX = rightChild.offsetLeft + rightChild.offsetWidth / 2;\n        // Create line from parent center to right child center\n        const line = document.createElement('div');\n\n        const startX = parentCenterX;\n        const startY = 0;\n        const endX = rightCenterX;\n        const endY = 40;\n\n        // Vertical line from parentCenterX, 0 to parentCenterX, 20\n        const verticalLine = document.createElement('div');\n        verticalLine.style.position = 'absolute';\n        verticalLine.style.left = startX + 'px';\n        verticalLine.style.top = startY + 'px';\n        verticalLine.style.width = lineThickness + 'px';\n        verticalLine.style.height = '20px';\n        verticalLine.style.backgroundColor = '#444';\n        connections.appendChild(verticalLine);\n\n        // Horizontal line from min(startX, endX) to max(startX, endX), at top 20px\n        const horizontalLine = document.createElement('div');\n        horizontalLine.style.position = 'absolute';\n        horizontalLine.style.top = '20px';\n        horizontalLine.style.left = Math.min(startX, endX) + 'px';\n        horizontalLine.style.width = Math.abs(endX - startX) + 'px';\n        horizontalLine.style.height = lineThickness + 'px';\n        horizontalLine.style.backgroundColor = '#444';\n        connections.appendChild(horizontalLine);\n\n        // Vertical line down to child center horizontally at endX, from 20 to 40\n        const verticalLineDown = document.createElement('div');\n        verticalLineDown.style.position = 'absolute';\n        verticalLineDown.style.left = endX + 'px';\n        verticalLineDown.style.top = '20px';\n        verticalLineDown.style.width = lineThickness + 'px';\n        verticalLineDown.style.height = '20px';\n        verticalLineDown.style.backgroundColor = '#444';\n        connections.appendChild(verticalLineDown);\n      }\n    }\n  }\n\n  function visualizeHeap(container, heapArray, type) {\n    container.innerHTML = '';\n    if (heapArray.length === 0){\n      container.textContent = '(empty)';\n      return;\n    }\n    const levels = buildLevels(heapArray);\n    levels.forEach((levelArr, i) => {\n      const levelDiv = document.createElement('div');\n      levelDiv.classList.add('level');\n      levelDiv.style.display = 'flex';\n      levelDiv.style.justifyContent = 'center';\n      levelDiv.style.gap = '20px';\n\n      levelArr.forEach(value => {\n        const node = createNodeElement(value, type);\n        levelDiv.appendChild(node);\n      });\n\n      container.appendChild(levelDiv);\n    });\n\n    // After rendering, draw connections\n    // Use a timeout to wait for DOM paint for accurate offsets\n    setTimeout(() => {\n      for(let i = 0; i < levels.length - 1; i++){\n        createConnections(container, 0, levels[i].length, i);\n      }\n    }, 50);\n  }\n\n  // Output log helper\n  function log(outputElement, text) {\n    outputElement.textContent += text + '\\n';\n    outputElement.scrollTop = outputElement.scrollHeight;\n  }\n\n  // MIN HEAP SETUP\n  const minHeap = new Heap((a, b) => a - b);\n  const minHeapInput = document.getElementById('minHeapInput');\n  const minHeapInsertBtn = document.getElementById('minHeapInsertBtn');\n  const minHeapExtractBtn = document.getElementById('minHeapExtractBtn');\n  const minHeapClearBtn = document.getElementById('minHeapClearBtn');\n  const minHeapOutput = document.getElementById('minHeapOutput');\n  const minHeapTree = document.getElementById('minHeapTree');\n\n  minHeapInsertBtn.addEventListener('click', () => {\n    const val = Number(minHeapInput.value);\n    if (isNaN(val)) {\n      alert('Please enter a valid number.');\n      return;\n    }\n    minHeap.insert(val);\n    log(minHeapOutput, `Inserted ${val} into Min Heap.`);\n    visualizeHeap(minHeapTree, minHeap.toArray(), 'min');\n    minHeapExtractBtn.disabled = minHeap.size() === 0;\n    minHeapInput.value = '';\n    minHeapInput.focus();\n  });\n\n  minHeapExtractBtn.addEventListener('click', () => {\n    if (minHeap.size() === 0) return;\n    const extracted = minHeap.extract();\n    log(minHeapOutput, `Extracted min value: ${extracted}`);\n    visualizeHeap(minHeapTree, minHeap.toArray(), 'min');\n    minHeapExtractBtn.disabled = minHeap.size() === 0;\n  });\n\n  minHeapClearBtn.addEventListener('click', () => {\n    minHeap.clear();\n    log(minHeapOutput, 'Cleared Min Heap.');\n    visualizeHeap(minHeapTree, [], 'min');\n    minHeapExtractBtn.disabled = true;\n  });\n\n  // MAX HEAP SETUP\n  const maxHeap = new Heap((a, b) => b - a);\n  const maxHeapInput = document.getElementById('maxHeapInput');\n  const maxHeapInsertBtn = document.getElementById('maxHeapInsertBtn');\n  const maxHeapExtractBtn = document.getElementById('maxHeapExtractBtn');\n  const maxHeapClearBtn = document.getElementById('maxHeapClearBtn');\n  const maxHeapOutput = document.getElementById('maxHeapOutput');\n  const maxHeapTree = document.getElementById('maxHeapTree');\n\n  maxHeapInsertBtn.addEventListener('click', () => {\n    const val = Number(maxHeapInput.value);\n    if (isNaN(val)) {\n      alert('Please enter a valid number.');\n      return;\n    }\n    maxHeap.insert(val);\n    log(maxHeapOutput, `Inserted ${val} into Max Heap.`);\n    visualizeHeap(maxHeapTree, maxHeap.toArray(), 'max');\n    maxHeapExtractBtn.disabled = maxHeap.size() === 0;\n    maxHeapInput.value = '';\n    maxHeapInput.focus();\n  });\n\n  maxHeapExtractBtn.addEventListener('click', () => {\n    if (maxHeap.size() === 0) return;\n    const extracted = maxHeap.extract();\n    log(maxHeapOutput, `Extracted max value: ${extracted}`);\n    visualizeHeap(maxHeapTree, maxHeap.toArray(), 'max');\n    maxHeapExtractBtn.disabled = maxHeap.size() === 0;\n  });\n\n  maxHeapClearBtn.addEventListener('click', () => {\n    maxHeap.clear();\n    log(maxHeapOutput, 'Cleared Max Heap.');\n    visualizeHeap(maxHeapTree, [], 'max');\n    maxHeapExtractBtn.disabled = true;\n  });\n\n  // Initialize empty visualizations & disable buttons\n  visualizeHeap(minHeapTree, [], 'min');\n  visualizeHeap(maxHeapTree, [], 'max');\n  minHeapExtractBtn.disabled = true;\n  maxHeapExtractBtn.disabled = true;\n</script>\n</body>\n</html>"
  },
  "messages": [
    {
      "role": "system",
      "content": "Generate a single HTML file with JavaScript demonstrating the user-given concept. Only respond in a single HTML file."
    },
    {
      "role": "user",
      "content": "Heap (Min/Max)"
    }
  ],
  "topic": "Heap (Min/Max)",
  "hasFSM": true,
  "hasTest": true,
  "evaluation": {
    "score": null,
    "notes": ""
  }
}