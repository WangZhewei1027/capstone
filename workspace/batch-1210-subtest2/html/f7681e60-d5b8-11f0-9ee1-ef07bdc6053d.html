<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bellman-Ford Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #graph {
            display: flex;
            flex-direction: column;
            margin-top: 20px;
        }
        .edge {
            margin: 5px 0;
        }
        #output {
            margin-top: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>

<h1>Bellman-Ford Algorithm Visualization</h1>
<p>Enter the edges of the graph in the format:</p>
<p><em>source target weight</em></p>
<p>For example, to add an edge from vertex 0 to vertex 1 with weight 4, enter: 0 1 4</p>
<input type="text" id="edgeInput" placeholder="Enter edge (src tgt weight)">
<button onclick="addEdge()">Add Edge</button>
<button onclick="runBellmanFord()">Run Bellman-Ford</button>

<div id="graph"></div>

<div id="output"></div>

<script>
    let edges = [];
    let vertices = new Set();

    function addEdge() {
        const input = document.getElementById('edgeInput').value;
        const [src, tgt, weight] = input.split(' ').map(Number);
        
        if (!isNaN(src) && !isNaN(tgt) && !isNaN(weight)) {
            edges.push({ src, tgt, weight });
            vertices.add(src);
            vertices.add(tgt);
            updateGraphDisplay();
            document.getElementById('edgeInput').value = '';
        } else {
            alert("Invalid input! Please enter in 'source target weight' format.");
        }
    }

    function updateGraphDisplay() {
        const graphDiv = document.getElementById('graph');
        graphDiv.innerHTML = '';
        edges.forEach(edge => {
            const div = document.createElement('div');
            div.className = 'edge';
            div.textContent = `Edge: ${edge.src} -> ${edge.tgt} with weight ${edge.weight}`;
            graphDiv.appendChild(div);
        });
    }

    function runBellmanFord() {
        const source = prompt("Enter the source vertex:");
        const distances = {};
        const predecessors = {};

        // Initialize distances
        for (let vertex of vertices) {
            distances[vertex] = Infinity;
            predecessors[vertex] = null;
        }
        distances[source] = 0;

        // Relax edges |V| - 1 times
        for (let i = 0; i < vertices.size - 1; i++) {
            for (let edge of edges) {
                if (distances[edge.src] !== Infinity && distances[edge.src] + edge.weight < distances[edge.tgt]) {
                    distances[edge.tgt] = distances[edge.src] + edge.weight;
                    predecessors[edge.tgt] = edge.src;
                }
            }
        }

        // Check for negative-weight cycles
        for (let edge of edges) {
            if (distances[edge.src] !== Infinity && distances[edge.src] + edge.weight < distances[edge.tgt]) {
                console.log("Negative weight cycle detected!");
                return;
            }
        }

        displayResults(distances);
    }

    function displayResults(distances) {
        const outputDiv = document.getElementById('output');
        outputDiv.innerHTML = "Shortest distances from the source vertex:<br/>";
        for (const vertex in distances) {
            outputDiv.innerHTML += `Vertex ${vertex}: ${distances[vertex]}<br/>`;
        }
    }
</script>

</body>
</html>