<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Heap (Min/Max) Visualization and Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f0f4f8;
  }
  h1 {
    text-align: center;
  }
  #container {
    display: flex;
    justify-content: center;
    gap: 40px;
    flex-wrap: wrap;
  }
  .heap-container {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgb(0 0 0 / 0.1);
    padding: 20px;
    width: 450px;
  }
  .heap-container h2 {
    text-align: center;
    margin-bottom: 15px;
  }
  .controls {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 10px;
  }
  input[type=number] {
    width: 80px;
    padding: 6px;
    font-size: 16px;
  }
  button {
    padding: 7px 12px;
    font-size: 16px;
    cursor: pointer;
    border: none;
    background: #0288d1;
    color: white;
    border-radius: 4px;
    transition: background-color 0.2s ease;
  }
  button:hover:not(:disabled) {
    background: #0277bd;
  }
  button:disabled {
    background: #bbb;
    cursor: default;
  }
  #output {
    font-family: monospace;
    background: #eef4f9;
    border-radius: 5px;
    padding: 10px;
    height: 150px;
    overflow-y: auto;
    white-space: pre-wrap;
    border: 1px solid #ccc;
  }
  .tree {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    margin-top: 15px;
    user-select: none;
  }
  .node {
    background: #0288d1;
    color: white;
    padding: 6px 12px;
    margin: 5px;
    border-radius: 4px;
    min-width: 32px;
    text-align: center;
    position: relative;
  }
  .node.min {
    background: #0288d1;
  }
  .node.max {
    background: #d13212;
  }
  .level {
    display: flex;
    justify-content: center;
    gap: 10px;
  }
  .connections {
    position: relative;
    height: 25px;
  }
  /* Lines connecting parent to children */
  .line {
    position: absolute;
    border-left: 2px solid #444;
    border-bottom: 2px solid #444;
  }
</style>
</head>
<body>
<h1>Heap (Min/Max) Demo & Visualization</h1>
<div id="container">
  <div class="heap-container" id="minHeapContainer">
    <h2>Min Heap</h2>
    <div class="controls">
      <input type="number" id="minHeapInput" placeholder="Enter number" />
      <button id="minHeapInsertBtn">Insert</button>
      <button id="minHeapExtractBtn" disabled>Extract Min</button>
      <button id="minHeapClearBtn">Clear</button>
    </div>
    <div id="minHeapOutput" class="output" style="min-height: 170px; background: #e1f5fe; border-radius:5px; padding:8px; font-family: monospace; overflow-y:auto;"></div>
    <div id="minHeapTree" class="tree" aria-label="Min Heap Tree Visualization"></div>
  </div>

  <div class="heap-container" id="maxHeapContainer">
    <h2>Max Heap</h2>
    <div class="controls">
      <input type="number" id="maxHeapInput" placeholder="Enter number" />
      <button id="maxHeapInsertBtn">Insert</button>
      <button id="maxHeapExtractBtn" disabled>Extract Max</button>
      <button id="maxHeapClearBtn">Clear</button>
    </div>
    <div id="maxHeapOutput" class="output" style="min-height: 170px; background: #ffebee; border-radius:5px; padding:8px; font-family: monospace; overflow-y:auto;"></div>
    <div id="maxHeapTree" class="tree" aria-label="Max Heap Tree Visualization"></div>
  </div>
</div>

<script>
  // Heap class with comparator
  class Heap {
    constructor(comparator) {
      this.data = [];
      this.comparator = comparator || ((a, b) => a - b);
    }

    size() {
      return this.data.length;
    }

    peek() {
      return this.data.length > 0 ? this.data[0] : null;
    }

    insert(value) {
      this.data.push(value);
      this.bubbleUp(this.data.length - 1);
    }

    extract() {
      if (this.data.length === 0) return null;
      const top = this.data[0];
      const last = this.data.pop();
      if (this.data.length > 0) {
        this.data[0] = last;
        this.bubbleDown(0);
      }
      return top;
    }

    bubbleUp(index) {
      while (index > 0) {
        const parent = Math.floor((index - 1) / 2);
        if (this.comparator(this.data[index], this.data[parent]) < 0) {
          [this.data[index], this.data[parent]] = [this.data[parent], this.data[index]];
          index = parent;
        } else {
          break;
        }
      }
    }

    bubbleDown(index) {
      const length = this.data.length;
      while (true) {
        const left = index * 2 + 1;
        const right = index * 2 + 2;
        let smallest = index;

        if (left < length && this.comparator(this.data[left], this.data[smallest]) < 0) {
          smallest = left;
        }
        if (right < length && this.comparator(this.data[right], this.data[smallest]) < 0) {
          smallest = right;
        }
        if (smallest === index) break;

        [this.data[index], this.data[smallest]] = [this.data[smallest], this.data[index]];
        index = smallest;
      }
    }

    clear() {
      this.data = [];
    }

    toArray() {
      return [...this.data];
    }
  }

  // Utilities for tree visualization
  function buildLevels(array) {
    // Takes the array representing heap and returns an array of levels
    const levels = [];
    let level = 0;
    let count = 1;
    let i = 0;
    while (i < array.length) {
      const levelArr = array.slice(i, i + count);
      levels.push(levelArr);
      i += count;
      count *= 2;
      level++;
    }
    return levels;
  }

  function createNodeElement(value, type) {
    const div = document.createElement('div');
    div.classList.add('node');
    div.classList.add(type === 'min' ? 'min' : 'max');
    div.textContent = value;
    return div;
  }

  function createConnections(container, startIdx, levelNodesCount, level) {
    // Draw connecting lines between nodes for visualization

    // We do this by creating absolutely positioned divs connecting parents with children
    // The container must be position: relative or absolute.

    const lineThickness = 2;

    // Dimensions approximate based on CSS
    // Each node ~44px width + margin, height ~30px

    // To simplify drawing, we won't do precise lines but simple corner lines under nodes.

    // Container offset top to position lines
    const offsetTop = 0;
    const offsetLeft = 0;

    const nodes = container.querySelectorAll(`.level:nth-child(${level + 1}) .node`);
    if (!nodes.length) return;
    const nextLevel = container.querySelectorAll(`.level:nth-child(${level + 2}) .node`);
    if (!nextLevel.length) return;

    // Position lines between parents and children
    // For each parent node, draw lines to two children if they exist.

    const parentCount = nodes.length;

    // Clear existing lines container
    let connectionsContainer = container.querySelector(`.connections.level-${level}`);
    if (connectionsContainer) {
      connectionsContainer.remove();
    }

    const connections = document.createElement('div');
    connections.classList.add('connections', `level-${level}`);
    connections.style.position = 'relative';
    connections.style.height = '40px';
    connections.style.marginTop = '-20px';
    container.appendChild(connections);

    for (let i = 0; i < parentCount; i++) {
      const parentNode = nodes[i];
      const childLeftIndex = i * 2;
      const childRightIndex = i * 2 + 1;

      const parentRect = parentNode.getBoundingClientRect();
      const parentCenterX = parentNode.offsetLeft + parentNode.offsetWidth / 2;

      if (childLeftIndex < nextLevel.length) {
        const leftChild = nextLevel[childLeftIndex];
        const leftRect = leftChild.getBoundingClientRect();
        const leftCenterX = leftChild.offsetLeft + leftChild.offsetWidth / 2;
        // Create line from parent center to left child center
        const line = document.createElement('div');
        line.classList.add('line');
        // We create an "L" shaped line: vertical down then horizontal to child
        // Position line absolutely relative to connections container
        const startX = parentCenterX;
        const startY = 0;
        const endX = leftCenterX;
        const endY = 40;

        // Vertical line from parentCenterX, 0 to parentCenterX, 20
        const verticalLine = document.createElement('div');
        verticalLine.style.position = 'absolute';
        verticalLine.style.left = startX + 'px';
        verticalLine.style.top = startY + 'px';
        verticalLine.style.width = lineThickness + 'px';
        verticalLine.style.height = '20px';
        verticalLine.style.backgroundColor = '#444';
        connections.appendChild(verticalLine);

        // Horizontal line from min(startX, endX) to max(startX, endX), at top 20px
        const horizontalLine = document.createElement('div');
        horizontalLine.style.position = 'absolute';
        horizontalLine.style.top = '20px';
        horizontalLine.style.left = Math.min(startX, endX) + 'px';
        horizontalLine.style.width = Math.abs(endX - startX) + 'px';
        horizontalLine.style.height = lineThickness + 'px';
        horizontalLine.style.backgroundColor = '#444';
        connections.appendChild(horizontalLine);

        // Vertical line down to child center horizontally at endX, from 20 to 40
        const verticalLineDown = document.createElement('div');
        verticalLineDown.style.position = 'absolute';
        verticalLineDown.style.left = endX + 'px';
        verticalLineDown.style.top = '20px';
        verticalLineDown.style.width = lineThickness + 'px';
        verticalLineDown.style.height = '20px';
        verticalLineDown.style.backgroundColor = '#444';
        connections.appendChild(verticalLineDown);
      }

      if (childRightIndex < nextLevel.length) {
        const rightChild = nextLevel[childRightIndex];
        const rightRect = rightChild.getBoundingClientRect();
        const rightCenterX = rightChild.offsetLeft + rightChild.offsetWidth / 2;
        // Create line from parent center to right child center
        const line = document.createElement('div');

        const startX = parentCenterX;
        const startY = 0;
        const endX = rightCenterX;
        const endY = 40;

        // Vertical line from parentCenterX, 0 to parentCenterX, 20
        const verticalLine = document.createElement('div');
        verticalLine.style.position = 'absolute';
        verticalLine.style.left = startX + 'px';
        verticalLine.style.top = startY + 'px';
        verticalLine.style.width = lineThickness + 'px';
        verticalLine.style.height = '20px';
        verticalLine.style.backgroundColor = '#444';
        connections.appendChild(verticalLine);

        // Horizontal line from min(startX, endX) to max(startX, endX), at top 20px
        const horizontalLine = document.createElement('div');
        horizontalLine.style.position = 'absolute';
        horizontalLine.style.top = '20px';
        horizontalLine.style.left = Math.min(startX, endX) + 'px';
        horizontalLine.style.width = Math.abs(endX - startX) + 'px';
        horizontalLine.style.height = lineThickness + 'px';
        horizontalLine.style.backgroundColor = '#444';
        connections.appendChild(horizontalLine);

        // Vertical line down to child center horizontally at endX, from 20 to 40
        const verticalLineDown = document.createElement('div');
        verticalLineDown.style.position = 'absolute';
        verticalLineDown.style.left = endX + 'px';
        verticalLineDown.style.top = '20px';
        verticalLineDown.style.width = lineThickness + 'px';
        verticalLineDown.style.height = '20px';
        verticalLineDown.style.backgroundColor = '#444';
        connections.appendChild(verticalLineDown);
      }
    }
  }

  function visualizeHeap(container, heapArray, type) {
    container.innerHTML = '';
    if (heapArray.length === 0){
      container.textContent = '(empty)';
      return;
    }
    const levels = buildLevels(heapArray);
    levels.forEach((levelArr, i) => {
      const levelDiv = document.createElement('div');
      levelDiv.classList.add('level');
      levelDiv.style.display = 'flex';
      levelDiv.style.justifyContent = 'center';
      levelDiv.style.gap = '20px';

      levelArr.forEach(value => {
        const node = createNodeElement(value, type);
        levelDiv.appendChild(node);
      });

      container.appendChild(levelDiv);
    });

    // After rendering, draw connections
    // Use a timeout to wait for DOM paint for accurate offsets
    setTimeout(() => {
      for(let i = 0; i < levels.length - 1; i++){
        createConnections(container, 0, levels[i].length, i);
      }
    }, 50);
  }

  // Output log helper
  function log(outputElement, text) {
    outputElement.textContent += text + '\n';
    outputElement.scrollTop = outputElement.scrollHeight;
  }

  // MIN HEAP SETUP
  const minHeap = new Heap((a, b) => a - b);
  const minHeapInput = document.getElementById('minHeapInput');
  const minHeapInsertBtn = document.getElementById('minHeapInsertBtn');
  const minHeapExtractBtn = document.getElementById('minHeapExtractBtn');
  const minHeapClearBtn = document.getElementById('minHeapClearBtn');
  const minHeapOutput = document.getElementById('minHeapOutput');
  const minHeapTree = document.getElementById('minHeapTree');

  minHeapInsertBtn.addEventListener('click', () => {
    const val = Number(minHeapInput.value);
    if (isNaN(val)) {
      alert('Please enter a valid number.');
      return;
    }
    minHeap.insert(val);
    log(minHeapOutput, `Inserted ${val} into Min Heap.`);
    visualizeHeap(minHeapTree, minHeap.toArray(), 'min');
    minHeapExtractBtn.disabled = minHeap.size() === 0;
    minHeapInput.value = '';
    minHeapInput.focus();
  });

  minHeapExtractBtn.addEventListener('click', () => {
    if (minHeap.size() === 0) return;
    const extracted = minHeap.extract();
    log(minHeapOutput, `Extracted min value: ${extracted}`);
    visualizeHeap(minHeapTree, minHeap.toArray(), 'min');
    minHeapExtractBtn.disabled = minHeap.size() === 0;
  });

  minHeapClearBtn.addEventListener('click', () => {
    minHeap.clear();
    log(minHeapOutput, 'Cleared Min Heap.');
    visualizeHeap(minHeapTree, [], 'min');
    minHeapExtractBtn.disabled = true;
  });

  // MAX HEAP SETUP
  const maxHeap = new Heap((a, b) => b - a);
  const maxHeapInput = document.getElementById('maxHeapInput');
  const maxHeapInsertBtn = document.getElementById('maxHeapInsertBtn');
  const maxHeapExtractBtn = document.getElementById('maxHeapExtractBtn');
  const maxHeapClearBtn = document.getElementById('maxHeapClearBtn');
  const maxHeapOutput = document.getElementById('maxHeapOutput');
  const maxHeapTree = document.getElementById('maxHeapTree');

  maxHeapInsertBtn.addEventListener('click', () => {
    const val = Number(maxHeapInput.value);
    if (isNaN(val)) {
      alert('Please enter a valid number.');
      return;
    }
    maxHeap.insert(val);
    log(maxHeapOutput, `Inserted ${val} into Max Heap.`);
    visualizeHeap(maxHeapTree, maxHeap.toArray(), 'max');
    maxHeapExtractBtn.disabled = maxHeap.size() === 0;
    maxHeapInput.value = '';
    maxHeapInput.focus();
  });

  maxHeapExtractBtn.addEventListener('click', () => {
    if (maxHeap.size() === 0) return;
    const extracted = maxHeap.extract();
    log(maxHeapOutput, `Extracted max value: ${extracted}`);
    visualizeHeap(maxHeapTree, maxHeap.toArray(), 'max');
    maxHeapExtractBtn.disabled = maxHeap.size() === 0;
  });

  maxHeapClearBtn.addEventListener('click', () => {
    maxHeap.clear();
    log(maxHeapOutput, 'Cleared Max Heap.');
    visualizeHeap(maxHeapTree, [], 'max');
    maxHeapExtractBtn.disabled = true;
  });

  // Initialize empty visualizations & disable buttons
  visualizeHeap(minHeapTree, [], 'min');
  visualizeHeap(maxHeapTree, [], 'max');
  minHeapExtractBtn.disabled = true;
  maxHeapExtractBtn.disabled = true;
</script>
</body>
</html>