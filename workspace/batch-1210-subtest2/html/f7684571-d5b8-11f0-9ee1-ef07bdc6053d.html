<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prim's Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #graph {
            margin: 20px;
            width: 400px;
            height: 400px;
            border: 1px solid black;
            position: relative;
        }
        .edge {
            stroke: black;
            stroke-width: 2;
        }
        .node {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: blue;
            position: absolute;
            cursor: pointer;
        }
        .selected {
            background: green;
        }
        #output {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Prim's Algorithm Visualization</h1>
    <div id="graph"></div>
    <button onclick="runPrims()">Run Prim's Algorithm</button>
    <div id="output"></div>

    <script>
        const graph = {
            // Define nodes and edges with weights
            'A': { 'B': 4, 'H': 8 },
            'B': { 'A': 4, 'C': 8, 'H': 11 },
            'C': { 'B': 8, 'D': 7, 'F': 4, 'I': 2 },
            'D': { 'C': 7, 'E': 9, 'F': 14 },
            'E': { 'D': 9, 'F': 10 },
            'F': { 'C': 4, 'D': 14, 'E': 10, 'G': 2 },
            'G': { 'F': 2, 'I': 6, 'H': 1 },
            'H': { 'A': 8, 'B': 11, 'G': 1, 'I': 7 },
            'I': { 'C': 2, 'G': 6, 'H': 7 }
        };

        const nodePositions = {
            'A': { x: 50, y: 50 },
            'B': { x: 150, y: 50 },
            'C': { x: 250, y: 100 },
            'D': { x: 300, y: 250 },
            'E': { x: 150, y: 250 },
            'F': { x: 100, y: 150 },
            'G': { x: 200, y: 200 },
            'H': { x: 100, y: 50 },
            'I': { x: 250, y: 200 }
        };

        const edges = [];

        function drawGraph() {
            const graphElem = document.getElementById('graph');
            graphElem.innerHTML = ''; // Clear previous drawing

            for (const node in nodePositions) {
                const pos = nodePositions[node];
                const nodeDiv = document.createElement('div');
                nodeDiv.className = 'node';
                nodeDiv.style.left = pos.x + 'px';
                nodeDiv.style.top = pos.y + 'px';
                nodeDiv.setAttribute('data-node', node);
                nodeDiv.addEventListener('click', () => toggleNode(nodeDiv));
                graphElem.appendChild(nodeDiv);
            }

            for (const source in graph) {
                const posA = nodePositions[source];
                for (const target in graph[source]) {
                    const posB = nodePositions[target];
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('class', 'edge');
                    line.setAttribute('x1', posA.x + 10);
                    line.setAttribute('y1', posA.y + 10);
                    line.setAttribute('x2', posB.x + 10);
                    line.setAttribute('y2', posB.y + 10);
                    graphElem.appendChild(line);
                    edges.push({ source, target, weight: graph[source][target], line });
                }
            }
        }

        function toggleNode(nodeDiv) {
            nodeDiv.classList.toggle('selected');
        }

        function runPrims() {
            const selectedNodes = Array.from(document.querySelectorAll('.node.selected')).map(node => node.dataset.node);
            if (selectedNodes.length === 0) {
                alert('Please select at least one node to start Prim\'s Algorithm.');
                return;
            }

            const mstEdges = [];
            const visited = new Set(selectedNodes);
            const edgeList = [];

            selectedNodes.forEach(node => {
                for (const [neighbor, weight] of Object.entries(graph[node])) {
                    edgeList.push({ source: node, target: neighbor, weight });
                }
            });

            while (edgeList.length > 0) {
                edgeList.sort((a, b) => a.weight - b.weight);
                const { source, target, weight } = edgeList.shift();

                if (!visited.has(target)) {
                    visited.add(target);
                    mstEdges.push({ source, target, weight });

                    for (const [neighbor, edgeWeight] of Object.entries(graph[target])) {
                        edgeList.push({ source: target, target: neighbor, weight: edgeWeight });
                    }
                }
            }

            displayResult(mstEdges);
        }

        function displayResult(mstEdges) {
            const output = document.getElementById('output');
            output.innerHTML = '<h2>Minimum Spanning Tree (MST)</h2>';
            mstEdges.forEach(edge => {
                output.innerHTML += `<p>${edge.source} - ${edge.target} (Weight: ${edge.weight})</p>`;
            });
        }

        drawGraph();
    </script>
</body>
</html>