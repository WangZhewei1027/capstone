<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Priority Queue Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 1rem;
    max-width: 600px;
  }
  h1 {
    text-align: center;
  }
  .input-section {
    margin-bottom: 1rem;
  }
  label {
    display: inline-block;
    width: 70px;
  }
  input[type="text"], input[type="number"] {
    width: 200px;
    padding: 5px;
    margin-right: 1rem;
  }
  button {
    padding: 6px 12px;
    margin-right: 10px;
    cursor: pointer;
  }
  #queueVisual {
    margin-top: 1rem;
    padding: 10px;
    border: 1px solid #ddd;
    background: #fafafa;
    min-height: 80px;
    font-family: monospace;
    white-space: pre-wrap;
  }
  .item {
    display: inline-block;
    margin: 0 5px 5px 0;
    padding: 6px 10px;
    border-radius: 4px;
    background: #007bff;
    color: white;
    font-weight: bold;
    user-select: none;
  }
  .item .prio {
    font-weight: normal;
    font-size: 0.85em;
    color: #cce5ff;
    margin-left: 4px;
  }
  .message {
    margin-top: 0.5rem;
    font-size: 0.9rem;
    color: #555;
  }
  #dequeuedItem {
    margin-top: 0.5rem;
    font-weight: bold;
  }
</style>
</head>
<body>
<h1>Priority Queue Demo</h1>

<div class="input-section">
  <label for="itemInput">Item:</label>
  <input type="text" id="itemInput" placeholder="Enter value" />
  <label for="priorityInput">Priority:</label>
  <input type="number" id="priorityInput" placeholder="Priority (number)" />
  <button id="enqueueBtn">Enqueue</button>
  <button id="dequeueBtn">Dequeue</button>
  <button id="peekBtn">Peek</button>
</div>

<div>
  <strong>Queue (highest priority first):</strong>
  <div id="queueVisual"></div>
</div>

<div id="dequeuedItem"></div>
<div class="message" id="message"></div>

<script>
  /*
    Priority Queue Implementation (Min-Heap based on priority):
    Lower numeric priority value = higher priority.
    Items with same priority: first-enqueued served first (stability).
  */

  class PriorityQueue {
    constructor() {
      this.heap = [];
      this.counter = 0; // To keep insertion order for stability
    }

    // Helper methods for heap operations
    parentIndex(idx) {
      return Math.floor((idx - 1) / 2);
    }
    leftChildIndex(idx) {
      return idx * 2 + 1;
    }
    rightChildIndex(idx) {
      return idx * 2 + 2;
    }

    swap(i, j) {
      [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
    }

    compare(a, b) {
      // Compare by priority first
      if (a.priority < b.priority) return -1;
      if (a.priority > b.priority) return 1;
      // If same priority, compare insertion order (lower first)
      return a.count - b.count;
    }

    enqueue(item, priority) {
      if (item === '' || item == null) return false;
      if (typeof priority !== 'number' || isNaN(priority)) return false;

      const node = { item, priority, count: this.counter++ };
      this.heap.push(node);
      this.bubbleUp(this.heap.length - 1);
      return true;
    }

    bubbleUp(idx) {
      while (idx > 0) {
        const parent = this.parentIndex(idx);
        if (this.compare(this.heap[idx], this.heap[parent]) < 0) {
          this.swap(idx, parent);
          idx = parent;
        } else {
          break;
        }
      }
    }

    dequeue() {
      if (this.isEmpty()) return null;
      const root = this.heap[0];
      const last = this.heap.pop();
      if (this.heap.length > 0) {
        this.heap[0] = last;
        this.bubbleDown(0);
      }
      return root.item;
    }

    bubbleDown(idx) {
      const length = this.heap.length;
      while (true) {
        let left = this.leftChildIndex(idx);
        let right = this.rightChildIndex(idx);
        let smallest = idx;

        if (left < length && this.compare(this.heap[left], this.heap[smallest]) < 0) {
          smallest = left;
        }
        if (right < length && this.compare(this.heap[right], this.heap[smallest]) < 0) {
          smallest = right;
        }
        if (smallest !== idx) {
          this.swap(idx, smallest);
          idx = smallest;
        } else {
          break;
        }
      }
    }

    peek() {
      if (this.isEmpty()) return null;
      return this.heap[0].item;
    }

    isEmpty() {
      return this.heap.length === 0;
    }

    toArray() {
      // Return a shallow copy of array sorted as priority (not changing heap)
      // For visualization: sort by priority and insertion count ascending
      return [...this.heap].sort((a,b) => this.compare(a,b));
    }
  }

  const pq = new PriorityQueue();

  const itemInput = document.getElementById('itemInput');
  const priorityInput = document.getElementById('priorityInput');
  const enqueueBtn = document.getElementById('enqueueBtn');
  const dequeueBtn = document.getElementById('dequeueBtn');
  const peekBtn = document.getElementById('peekBtn');
  const queueVisual = document.getElementById('queueVisual');
  const message = document.getElementById('message');
  const dequeuedItem = document.getElementById('dequeuedItem');

  function updateVisual() {
    const arr = pq.toArray();
    if (arr.length === 0) {
      queueVisual.textContent = '(empty)';
      return;
    }
    queueVisual.innerHTML = '';
    arr.forEach(node => {
      const div = document.createElement('div');
      div.className = 'item';
      div.textContent = node.item;
      const spanPrio = document.createElement('span');
      spanPrio.className = 'prio';
      spanPrio.textContent = `(p:${node.priority})`;
      div.appendChild(spanPrio);
      queueVisual.appendChild(div);
    });
  }

  enqueueBtn.addEventListener('click', () => {
    message.textContent = '';
    dequeuedItem.textContent = '';
    const val = itemInput.value.trim();
    const prioRaw = priorityInput.value.trim();
    if (val === '') {
      message.textContent = 'Please enter an item value.';
      return;
    }
    const prioNum = Number(prioRaw);
    if (prioRaw === '' || isNaN(prioNum)) {
      message.textContent = 'Please enter a valid numeric priority.';
      return;
    }
    if (pq.enqueue(val, prioNum)) {
      message.textContent = `Enqueued "${val}" with priority ${prioNum}.`;
      itemInput.value = '';
      priorityInput.value = '';
      updateVisual();
      itemInput.focus();
    } else {
      message.textContent = 'Failed to enqueue. Check input.';
    }
  });

  dequeueBtn.addEventListener('click', () => {
    message.textContent = '';
    const removed = pq.dequeue();
    if (removed === null) {
      dequeuedItem.textContent = '';
      message.textContent = 'Queue is empty, nothing to dequeue.';
    } else {
      dequeuedItem.textContent = `Dequeued item: "${removed}"`;
      updateVisual();
    }
  });

  peekBtn.addEventListener('click', () => {
    message.textContent = '';
    dequeuedItem.textContent = '';
    const next = pq.peek();
    if (next === null) {
      message.textContent = 'Queue is empty.';
    } else {
      message.textContent = `Next to dequeue (peek): "${next}"`;
    }
  });

  // Initial visualization
  updateVisual();
</script>

</body>
</html>