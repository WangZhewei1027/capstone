<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Nearest Neighbors (KNN) Visualization</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        #canvas { border: 1px solid black; margin: 20px auto; display: block; }
        #controls { margin: 20px; }
        .data-point { cursor: pointer; }
    </style>
</head>
<body>

    <h1>K-Nearest Neighbors (KNN) Visualization</h1>
    <canvas id="canvas" width="500" height="500"></canvas>

    <div id="controls">
        <label for="k-value">Enter K value:</label>
        <input type="number" id="k-value" value="3" min="1" max="10">
        <button id="add-data">Add Data Point</button>
        <button id="compute-knn">Compute KNN</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let points = [];
        let k = 3;  // Default K value
        const colors = ['red', 'blue']; // Example colors for classes

        // Drawing function for points
        function drawPoints() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            points.forEach((point, index) => {
                ctx.fillStyle = colors[point.class];
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            });
        }

        // Function to calculate distance
        function distance(point1, point2) {
            return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
        }

        // Function to compute KNN
        function computeKNN(targetPoint) {
            const distances = points.map(point => ({
                point,
                distance: distance(point, targetPoint)
            }));

            distances.sort((a, b) => a.distance - b.distance);
            const nearestNeighbors = distances.slice(0, k);

            // Count votes
            const votes = {};
            nearestNeighbors.forEach(({ point }) => {
                votes[point.class] = (votes[point.class] || 0) + 1;
            });

            // Majority vote
            let predictedClass = Object.keys(votes).reduce((a, b) => votes[a] > votes[b] ? a : b);
            return predictedClass;
        }

        // Add event listener for canvas
        canvas.addEventListener('click', event => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            let newPoint = { x: x, y: y, class: points.length % 2 }; // Alternating classes for demonstration
            points.push(newPoint);
            drawPoints();
        });

        // Add event listener for compute KNN button
        document.getElementById('compute-knn').addEventListener('click', () => {
            k = parseInt(document.getElementById('k-value').value);
            const targetPoint = { x: Math.random() * canvas.width, y: Math.random() * canvas.height, class: 'unknown' };

            const predictedClass = computeKNN(targetPoint);
            ctx.fillStyle = colors[predictedClass];
            ctx.beginPath();
            ctx.arc(targetPoint.x, targetPoint.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();

            console.log(`Predicted class for ${targetPoint.x}, ${targetPoint.y}: Class ${predictedClass}`);
        });

        // Add event listener for adding data point button
        document.getElementById('add-data').addEventListener('click', () => {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            let newPoint = { x: x, y: y, class: points.length % 2 }; // Alternating classes for demonstration
            points.push(newPoint);
            drawPoints();
        });
    </script>
</body>
</html>