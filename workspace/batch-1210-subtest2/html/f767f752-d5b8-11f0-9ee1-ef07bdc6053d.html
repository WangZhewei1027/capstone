<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }
        canvas {
            border: 1px solid black;
            margin-bottom: 20px;
        }
        #controls {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <div id="controls">
        <button onclick="runDijkstra()">Run Dijkstra's Algorithm</button>
        <button onclick="resetGraph()">Reset Graph</button>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const nodes = [];
        const edges = [];
        let startNode = null;
        let endNode = null;

        class Node {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.edges = [];
                this.distance = Infinity;
                this.previous = null;
                this.visited = false;
            }

            draw() {
                ctx.fillStyle = this.visited ? 'lightgreen' : 'lightblue';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = 'black';
                ctx.fillText(this.id, this.x - 5, this.y + 5);
            }
        }

        class Edge {
            constructor(fromNode, toNode, weight) {
                this.fromNode = fromNode;
                this.toNode = toNode;
                this.weight = weight;
                fromNode.edges.push(this);
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.fromNode.x, this.fromNode.y);
                ctx.lineTo(this.toNode.x, this.toNode.y);
                ctx.stroke();
                ctx.fillStyle = 'red';
                ctx.fillText(this.weight, (this.fromNode.x + this.toNode.x) / 2, (this.fromNode.y + this.toNode.y) / 2);
            }
        }

        // Initialize nodes and edges
        function initGraph() {
            nodes.push(new Node('A', 100, 100));
            nodes.push(new Node('B', 200, 50));
            nodes.push(new Node('C', 300, 150));
            nodes.push(new Node('D', 200, 200));
            nodes.push(new Node('E', 400, 100));

            new Edge(nodes[0], nodes[1], 1);
            new Edge(nodes[1], nodes[2], 2);
            new Edge(nodes[1], nodes[3], 1);
            new Edge(nodes[2], nodes[4], 5);
            new Edge(nodes[0], nodes[3], 4);
            new Edge(nodes[3], nodes[4], 2);
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            edges.forEach(edge => edge.draw());
            nodes.forEach(node => node.draw());
        }

        async function runDijkstra() {
            startNode = nodes[0]; // Starting from node A
            endNode = nodes[nodes.length - 1]; // Ending at node E
            startNode.distance = 0;

            let unvisited = [...nodes];

            while (unvisited.length > 0) {
                // Get the node with the smallest distance
                let currentNode = unvisited.reduce((minNode, node) => (node.distance < minNode.distance ? node : minNode), unvisited[0]);
                if (currentNode.distance === Infinity) break;

                currentNode.visited = true;
                unvisited = unvisited.filter(node => node !== currentNode);
                drawGraph();

                for (const edge of currentNode.edges) {
                    const neighbor = edge.toNode;
                    if (!neighbor.visited) {
                        const newDistance = currentNode.distance + edge.weight;
                        if (newDistance < neighbor.distance) {
                            neighbor.distance = newDistance;
                            neighbor.previous = currentNode;
                        }
                    }
                }

                await new Promise(resolve => setTimeout(resolve, 500)); // Delay for visualization
            }

            highlightPath();
        }

        function highlightPath() {
            let node = endNode;
            while (node) {
                node.visited = true; // Highlight the path
                node = node.previous;
            }
            drawGraph();
        }

        function resetGraph() {
            nodes.length = 0;
            edges.length = 0;
            initGraph();
            drawGraph();
        }

        initGraph();
        drawGraph();
    </script>
</body>
</html>