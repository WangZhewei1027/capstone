<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Sort Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        canvas {
            border: 1px solid #ccc;
            background-color: #f9f9f9;
        }
        .button {
            margin: 10px 0;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>

<h1>Topological Sort Visualization</h1>
<canvas id="canvas" width="800" height="400"></canvas>
<br>
<button class="button" id="sortButton">Perform Topological Sort</button>
<div id="result"></div>

<script>
    // Create a directed graph using an adjacency list
    const graph = {
        A: ['C', 'D'],
        B: ['D'],
        C: ['E'],
        D: ['F'],
        E: ['F'],
        F: []
    };

    function topologicalSort(graph) {
        const inDegree = {};
        const sortedList = [];
        const zeroInDegreeQueue = [];

        // Calculate in-degrees of all nodes
        for (const node in graph) {
            if (!inDegree[node]) inDegree[node] = 0;
            for (const neighbor of graph[node]) {
                inDegree[neighbor] = (inDegree[neighbor] || 0) + 1;
            }
        }

        // Collect all nodes with zero in-degree
        for (const node in inDegree) {
            if (inDegree[node] === 0) zeroInDegreeQueue.push(node);
        }

        while (zeroInDegreeQueue.length > 0) {
            const node = zeroInDegreeQueue.shift();
            sortedList.push(node);

            // Decrease the in-degree of neighboring nodes
            for (const neighbor of graph[node]) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] === 0) {
                    zeroInDegreeQueue.push(neighbor);
                }
            }
        }

        // Check for cycles (if sortedList length doesn't match graph size)
        if (sortedList.length !== Object.keys(graph).length) {
            throw new Error("Graph has at least one cycle.");
        }

        return sortedList;
    }

    function drawGraph() {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const nodes = Object.keys(graph);
        const nodeCoordinates = {};

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        nodes.forEach((node, index) => {
            const x = (index + 1) * 100;
            const y = 200;
            nodeCoordinates[node] = { x, y };
            ctx.fillStyle = "#00f";
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#fff";
            ctx.fillText(node, x - 6, y + 6);
        });

        ctx.strokeStyle = '#000';
        for (const node in graph) {
            for (const neighbor of graph[node]) {
                ctx.beginPath();
                ctx.moveTo(nodeCoordinates[node].x, nodeCoordinates[node].y);
                ctx.lineTo(nodeCoordinates[neighbor].x, nodeCoordinates[neighbor].y);
                ctx.stroke();
            }
        }
    }

    document.getElementById("sortButton").addEventListener("click", () => {
        try {
            const sorted = topologicalSort(graph);
            document.getElementById("result").innerText = "Topological Sort Result: " + sorted.join(" -> ");
            drawGraph();
        } catch (error) {
            alert(error.message);
        }
    });

    // Initial drawing of the graph
    drawGraph();
</script>

</body>
</html>