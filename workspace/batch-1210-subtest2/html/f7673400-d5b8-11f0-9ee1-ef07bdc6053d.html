<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adjacency Matrix Demonstration</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        table {
            border-collapse: collapse;
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid #000;
            padding: 10px;
            text-align: center;
        }
        th {
            background-color: #f2f2f2;
        }
        #addEdgeBtn {
            margin-top: 10px;
        }
    </style>
</head>
<body>

<h2>Adjacency Matrix Demonstration</h2>
<p>This demonstration allows you to visualize an adjacency matrix for a simple graph. Add edges to create connections between vertices.</p>

<h3>Vertices</h3>
<input type="text" id="vertexA" placeholder="Vertex A (0-indexed)" />
<input type="text" id="vertexB" placeholder="Vertex B (0-indexed)" />
<button id="addEdgeBtn">Add Edge</button>

<h3>Adjacency Matrix</h3>
<table id="adjacencyMatrix">
    <thead>
        <tr id="matrixHeader">
            <th></th>
        </tr>
    </thead>
    <tbody id="matrixBody">
    </tbody>
</table>

<script>
    const adjacencyMatrix = [];
    const vertices = [];

    function updateMatrix() {
        const matrixBody = document.getElementById('matrixBody');
        const matrixHeader = document.getElementById('matrixHeader');

        // Clear existing matrix
        matrixBody.innerHTML = '';
        matrixHeader.innerHTML = '<th></th>'; // Reset header

        // Update the header
        for (let i = 0; i < vertices.length; i++) {
            matrixHeader.innerHTML += `<th>${i}</th>`;
        }

        // Create new matrix rows
        for (let i = 0; i < vertices.length; i++) {
            let row = '<tr><th>' + i + '</th>';
            for (let j = 0; j < vertices.length; j++) {
                row += `<td>${adjacencyMatrix[i] ? adjacencyMatrix[i][j] : 0}</td>`;
            }
            row += '</tr>';
            matrixBody.innerHTML += row;
        }
    }

    document.getElementById('addEdgeBtn').addEventListener('click', () => {
        const vertexA = parseInt(document.getElementById('vertexA').value);
        const vertexB = parseInt(document.getElementById('vertexB').value);

        // Check for valid indices
        if (isNaN(vertexA) || isNaN(vertexB) || vertexA < 0 || vertexB < 0) {
            alert('Please enter valid vertex indices.');
            return;
        }

        // Ensure the adjacency matrix is large enough
        const maxVertex = Math.max(vertexA, vertexB);
        while (maxVertex >= adjacencyMatrix.length) {
            adjacencyMatrix.push(Array(adjacencyMatrix.length + 1).fill(0));
            for (let i = 0; i < adjacencyMatrix.length; i++) {
                adjacencyMatrix[i].push(0);
            }
        }

        // Add the edge
        adjacencyMatrix[vertexA][vertexB] = 1;
        adjacencyMatrix[vertexB][vertexA] = 1; // For undirected graph

        // Update the matrix display
        updateMatrix();
    });

    // Initial empty matrix setup
    updateMatrix();
</script>

</body>
</html>