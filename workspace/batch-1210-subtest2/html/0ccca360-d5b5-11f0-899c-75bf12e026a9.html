<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dijkstra's Algorithm Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    display: flex;
    height: 100vh;
    overflow: hidden;
  }
  #controls {
    width: 320px;
    background: #f4f4f4;
    border-right: 1px solid #ccc;
    padding: 20px;
    box-sizing: border-box;
    overflow-y: auto;
  }
  #graph-container {
    flex-grow: 1;
    background: #222;
    position: relative;
  }
  h2 {
    margin-top: 0;
  }
  label {
    display: block;
    margin-top: 10px;
    font-weight: bold;
  }
  input[type="number"], select {
    width: 100%;
    padding: 5px;
    font-size: 14px;
    margin-top: 4px;
    box-sizing: border-box;
  }
  button {
    margin-top: 15px;
    width: 100%;
    padding: 10px;
    font-size: 16px;
    cursor: pointer;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 3px;
  }
  button:disabled {
    background: #999;
    cursor: default;
  }
  #log {
    margin-top: 15px;
    height: 120px;
    overflow-y: auto;
    background: #fff;
    border: 1px solid #ccc;
    padding: 10px;
    font-size: 13px;
    white-space: pre-wrap;
  }
  svg {
    width: 100%;
    height: 100%;
    display: block;
  }
  .node {
    cursor: pointer;
    transition: fill 0.3s, stroke 0.3s;
  }
  .node circle {
    fill: #3498db;
    stroke: #2980b9;
    stroke-width: 3px;
    transition: fill 0.3s, stroke 0.3s;
  }
  .node text {
    fill: #fff;
    font-weight: bold;
    pointer-events: none;
    user-select: none;
  }
  .edge {
    stroke: #aaa;
    stroke-width: 2px;
    marker-end: url(#arrow);
    transition: stroke 0.3s, stroke-width 0.3s;
  }
  .edge.highlighted {
    stroke: #e74c3c;
    stroke-width: 4px;
  }
  .node.visited circle {
    fill: #2ecc71;
    stroke: #27ae60;
  }
  .node.current circle {
    fill: #e67e22;
    stroke: #d35400;
  }
  .node.start circle {
    fill: #f1c40f;
    stroke: #f39c12;
  }
  .node.end circle {
    fill: #e74c3c;
    stroke: #c0392b;
  }
  #instructions {
    font-size: 13px;
    color: #555;
    margin-top: 10px;
  }
  #edges-list {
    max-height: 120px;
    overflow-y: auto;
    border: 1px solid #ddd;
    background: #fff;
    padding: 10px;
    font-size: 13px;
    margin-top: 5px;
  }
  #edges-list div {
    margin-bottom: 4px;
  }
  #add-edge-btn {
    margin-top: 10px;
    background: #28a745;
  }
  #reset-graph-btn {
    background: #dc3545;
    margin-top: 15px;
  }
  #speed-label {
    margin-top: 15px;
    font-weight: bold;
  }
  #speed-range {
    width: 100%;
  }
  #footer {
    font-size: 12px;
    color: #666;
    margin-top: 10px;
    text-align: center;
  }
</style>
</head>
<body>
  <div id="controls">
    <h2>Dijkstra's Algorithm</h2>

    <label for="vertex-count">Number of vertices (2-12):</label>
    <input type="number" id="vertex-count" min="2" max="12" value="6" />

    <button id="create-graph-btn">Create Graph</button>
    
    <div id="graph-setup" style="display:none; margin-top:15px;">
      <h3>Edges (Add / Remove)</h3>
      <label for="edge-from">From:</label>
      <select id="edge-from"></select>
      <label for="edge-to">To:</label>
      <select id="edge-to"></select>
      <label for="edge-weight">Weight (1-50):</label>
      <input type="number" id="edge-weight" min="1" max="50" value="1" />
      <button id="add-edge-btn">Add / Update Edge</button>

      <h4>Current Edges:</h4>
      <div id="edges-list"></div>

      <button id="reset-graph-btn" style="background:#dc3545;">Reset Edges</button>
    </div>

    <div id="algorithm-controls" style="display:none; margin-top:20px;">
      <label for="start-node">Start Node:</label>
      <select id="start-node"></select>

      <label for="end-node">End Node (optional):</label>
      <select id="end-node">
        <option value="">(None)</option>
      </select>

      <button id="run-btn">Run Dijkstra</button>
      <button id="step-btn" disabled>Step</button>
      <button id="reset-btn" disabled>Reset</button>

      <label id="speed-label" for="speed-range">Animation speed (ms delay):</label>
      <input type="range" id="speed-range" min="50" max="2000" step="50" value="600" />
      
      <div id="instructions">
        <strong>Instructions:</strong><br />
        • Create graph by selecting the number of vertices and clicking "Create Graph".<br />
        • Add and update edges with weights.<br />
        • Select start node and optionally end node.<br />
        • Run the algorithm to see shortest paths.<br />
        • Use Step to run it manually step-by-step.<br />
      </div>

      <h4>Log / Status:</h4>
      <div id="log"></div>
    </div>

    <div id="footer">
      &copy; 2024 Dijkstra's Algorithm Visualizer
    </div>
  </div>
  <div id="graph-container">
    <svg id="svg-graph" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <marker id="arrow" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L10,3.5 L0,7 Z" fill="#aaa" />
        </marker>
      </defs>
    </svg>
  </div>

<script>
(() => {
  const MAX_VERTICES = 12;
  const MIN_VERTICES = 2;

  let vertexCount = 6;
  let vertices = [];
  let edges = new Map(); // key: "u-v", value: weight
  let adjacencyList = [];
  let animationDelay = 600;

  const controls = {
    vertexCountInput: document.getElementById('vertex-count'),
    createGraphBtn: document.getElementById('create-graph-btn'),
    graphSetup: document.getElementById('graph-setup'),
    edgeFromSelect: document.getElementById('edge-from'),
    edgeToSelect: document.getElementById('edge-to'),
    edgeWeightInput: document.getElementById('edge-weight'),
    addEdgeBtn: document.getElementById('add-edge-btn'),
    edgesList: document.getElementById('edges-list'),
    resetGraphBtn: document.getElementById('reset-graph-btn'),

    algorithmControls: document.getElementById('algorithm-controls'),
    startNodeSelect: document.getElementById('start-node'),
    endNodeSelect: document.getElementById('end-node'),
    runBtn: document.getElementById('run-btn'),
    stepBtn: document.getElementById('step-btn'),
    resetBtn: document.getElementById('reset-btn'),
    speedRange: document.getElementById('speed-range'),
    logDiv: document.getElementById('log'),
  };

  const svg = document.getElementById('svg-graph');
  const WIDTH = svg.clientWidth;
  const HEIGHT = svg.clientHeight;

  // Nodes positions stored here for rendering edges
  let nodePositions = [];

  // State variables for the Dijkstra animation
  let dijkstraState = null;
  // Controls animation steps and intervals
  let animationTimer = null;

  // Utility to create vertex labels A, B, C...
  function vertexLabel(i) {
    return String.fromCharCode(65 + i);
  }

  // Clear SVG elements
  function clearSVG() {
    while (svg.lastChild && svg.lastChild.tagName !== 'defs') {
      svg.removeChild(svg.lastChild);
    }
  }

  // Build adjacency list from edges map
  function buildAdjacencyList() {
    adjacencyList = [];
    for (let i = 0; i < vertexCount; i++) {
      adjacencyList[i] = [];
    }
    edges.forEach((weight, key) => {
      // Edge key is "u-v"
      const [uStr, vStr] = key.split('-');
      const u = parseInt(uStr, 10);
      const v = parseInt(vStr, 10);
      adjacencyList[u].push({ to: v, weight });
      adjacencyList[v].push({ to: u, weight }); // undirected graph
    });
  }

  // Initialize graph visualization
  function drawGraph() {
    clearSVG();
    nodePositions = [];
    const centerX = svg.clientWidth/2;
    const centerY = svg.clientHeight/2;
    const radius = Math.min(centerX, centerY) - 80;

    // Position nodes evenly on a circle
    for (let i = 0; i < vertexCount; i++) {
      const angle = (2 * Math.PI * i) / vertexCount - Math.PI / 2;
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      nodePositions.push({ x, y });
    }

    // Draw edges first
    edges.forEach((weight, key) => {
      const [uStr, vStr] = key.split('-');
      const u = parseInt(uStr, 10);
      const v = parseInt(vStr, 10);
      drawEdge(u, v, weight);
    });

    // Draw nodes
    for (let i = 0; i < vertexCount; i++) {
      drawNode(i);
    }
  }

  function drawEdge(u, v, weight) {
    const posU = nodePositions[u];
    const posV = nodePositions[v];
    // Create line
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", posU.x);
    line.setAttribute("y1", posU.y);
    line.setAttribute("x2", posV.x);
    line.setAttribute("y2", posV.y);
    line.setAttribute("class", "edge");
    line.setAttribute("data-from", u);
    line.setAttribute("data-to", v);
    svg.appendChild(line);

    // Weight Label - place near middle with slight offset
    const midX = (posU.x + posV.x)/2;
    const midY = (posU.y + posV.y)/2;
    const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
    label.setAttribute("x", midX);
    label.setAttribute("y", midY - 10);
    label.setAttribute("fill", "#eee");
    label.setAttribute("font-size", "14px");
    label.setAttribute("font-weight", "bold");
    label.setAttribute("pointer-events", "none");
    label.textContent = weight;
    svg.appendChild(label);
  }

  function drawNode(i) {
    const pos = nodePositions[i];
    const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
    group.classList.add("node");
    group.setAttribute("data-node", i);
    group.style.userSelect = 'none';

    // Circle
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", pos.x);
    circle.setAttribute("cy", pos.y);
    circle.setAttribute("r", 22);
    group.appendChild(circle);

    // Label text
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", pos.x);
    text.setAttribute("y", pos.y + 6);
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("font-size", "20");
    text.textContent = vertexLabel(i);
    group.appendChild(text);

    svg.appendChild(group);
  }

  // Update nodes colors based on Dijkstra's state
  function updateNodeColors() {
    const nodes = svg.querySelectorAll('g.node');
    for (const nodeEl of nodes) {
      const idx = parseInt(nodeEl.getAttribute('data-node'), 10);
      nodeEl.classList.remove('visited', 'current', 'start', 'end');
      if (!dijkstraState) continue;
      if (idx === dijkstraState.start) {
        nodeEl.classList.add('start');
      }
      if (dijkstraState.end !== null && idx === dijkstraState.end) {
        nodeEl.classList.add('end');
      }
      if (dijkstraState.processed.has(idx)) {
        nodeEl.classList.add('visited');
      }
      if (dijkstraState.current === idx) {
        nodeEl.classList.add('current');
      }
    }
  }

  // Highlight edges in the current shortest path
  function highlightPath(path) {
    const allEdges = svg.querySelectorAll('line.edge');
    allEdges.forEach(e => e.classList.remove('highlighted'));

    if (!path || path.length < 2) return;
    for (let i = 0; i < path.length - 1; i++) {
      const u = path[i];
      const v = path[i+1];
      // Highlight edge both ways since undirected
      for (const edgeEl of allEdges) {
        const from = parseInt(edgeEl.getAttribute('data-from'), 10);
        const to = parseInt(edgeEl.getAttribute('data-to'), 10);
        if ((from === u && to === v) || (from === v && to === u)) {
          edgeEl.classList.add('highlighted');
        }
      }
    }
  }

  // Display log message
  function log(text, append=true) {
    if (append) {
      controls.logDiv.textContent += text + "\n";
      controls.logDiv.scrollTop = controls.logDiv.scrollHeight;
    } else {
      controls.logDiv.textContent = text + "\n";
    }
  }

  // Update the select elements for vertices
  function updateVertexSelects() {
    const selects = [controls.edgeFromSelect, controls.edgeToSelect, controls.startNodeSelect, controls.endNodeSelect];
    selects.forEach(select => {
      // Save current values
      const val = select.value;
      // Clear options
      select.innerHTML = '';
      // For end-node allow empty option
      if (select === controls.endNodeSelect) {
        const optNone = document.createElement('option');
        optNone.value = '';
        optNone.textContent = '(None)';
        select.appendChild(optNone);
      }
      for (let i = 0; i < vertexCount; i++) {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = vertexLabel(i);
        select.appendChild(opt);
      }
      // Restore if possible
      if ([...select.options].some(o => o.value === val)) {
        select.value = val;
      } else {
        select.selectedIndex = 0;
      }
    });
  }

  // Renders edges list in controls with remove buttons
  function renderEdgesList() {
    controls.edgesList.innerHTML = '';
    if (edges.size === 0) {
      controls.edgesList.textContent = '(No edges added)';
      return;
    }
    const fragment = document.createDocumentFragment();
    const sortedEdges = [...edges.entries()].sort((a,b) => {
      const [au,av] = a[0].split('-').map(Number);
      const [bu,bv] = b[0].split('-').map(Number);
      if (au !== bu) return au - bu;
      return av - bv;
    });
    sortedEdges.forEach(([key, weight]) => {
      const div = document.createElement('div');
      const [u,v] = key.split('-').map(Number);
      div.textContent = `${vertexLabel(u)} ↔ ${vertexLabel(v)} : ${weight}`;
      const rmBtn = document.createElement('button');
      rmBtn.textContent = 'Remove';
      rmBtn.style.marginLeft = '10px';
      rmBtn.style.cursor = 'pointer';
      rmBtn.style.fontSize = '12px';
      rmBtn.style.padding = '2px 6px';
      rmBtn.style.background = '#dc3545';
      rmBtn.style.color = 'white';
      rmBtn.style.border = 'none';
      rmBtn.style.borderRadius = '3px';
      rmBtn.addEventListener('click', () => {
        edges.delete(key);
        buildAdjacencyList();
        drawGraph();
        renderEdgesList();
      });
      div.appendChild(rmBtn);
      fragment.appendChild(div);
    });
    controls.edgesList.appendChild(fragment);
  }

  // Add or update edge in edges Map
  function addOrUpdateEdge(u, v, weight) {
    if (u === v) {
      alert('Cannot create edge to the same vertex.');
      return false;
    }
    if (weight < 1 || weight > 50) {
      alert('Weight must be between 1 and 50.');
      return false;
    }
    // Store with smaller index first for consistent key
    const a = Math.min(u, v);
    const b = Math.max(u, v);
    edges.set(`${a}-${b}`, weight);
    return true;
  }

  // --- DIJKSTRA ALGORITHM STEPS IMPLEMENTATION --- //
  // State contains:
  // start, end
  // distances[], prev[]
  // processed: Set
  // pq: priority queue (array, smallest dist at front)
  // current: current node being processed
  // finished: boolean

  // Priority queue implementation (min-heap) for Dijkstra, but for simplicity use array sorted
  function pqPush(pq, item) {
    pq.push(item);
    pq.sort((a,b) => a.dist - b.dist);
  }
  function pqPop(pq) {
    return pq.shift();
  }

  // Initialize Dijkstra state
  function dijkstraInit(start, end=null) {
    const dist = new Array(vertexCount).fill(Infinity);
    const prev = new Array(vertexCount).fill(null);
    dist[start] = 0;
    const processed = new Set();
    const pq = [];
    pqPush(pq, { node: start, dist: 0 });
    const state = {
      start,
      end,
      distances: dist,
      previous: prev,
      processed,
      pq,
      current: null,
      finished: false,
    };
    return state;
  }

  // One step of Dijkstra's algorithm
  // Returns a status object with info about changes
  function dijkstraStep(state) {
    if (state.finished) return { done: true };
    if (state.pq.length === 0) {
      state.finished = true;
      return { done: true };
    }
    const { node, dist } = pqPop(state.pq);
    if (state.processed.has(node)) {
      // Skip already processed nodes
      return { done: false };
    }
    state.current = node;
    state.processed.add(node);
    // Relax edges
    let relaxedAny = false;
    const neighbors = adjacencyList[node];
    for (const { to, weight } of neighbors) {
      if (state.processed.has(to)) continue;
      const newDist = state.distances[node] + weight;
      if (newDist < state.distances[to]) {
        state.distances[to] = newDist;
        state.previous[to] = node;
        pqPush(state.pq, { node: to, dist: newDist });
        relaxedAny = true;
      }
    }
    if (state.end !== null && node === state.end) {
      state.finished = true;
      return { done: true, reachedEnd: true };
    }
    if (state.pq.length === 0) {
      state.finished = true;
      return { done: true };
    }
    return { done: false };
  }

  // Compute the shortest path from start to end (or to all nodes if end=null)
  // Returns array of node indices representing path or null if end not reachable
  function reconstructPath(state) {
    if (state.end === null) return null;
    const path = [];
    let u = state.end;
    if (state.distances[u] === Infinity) return null;
    while (u !== null) {
      path.push(u);
      u = state.previous[u];
    }
    return path.reverse();
  }

  // Highlight shortest path edges after algorithm finishes
  function highlightShortestPath(state) {
    const path = reconstructPath(state);
    highlightPath(path);
  }

  // Update nodes with distance labels
  function updateDistanceLabels() {
    const nodes = svg.querySelectorAll('g.node');
    nodes.forEach(nodeEl => {
      // Remove existing dist labels first
      const oldDistLabel = nodeEl.querySelector('.dist-label');
      if (oldDistLabel) nodeEl.removeChild(oldDistLabel);
    });
    nodes.forEach(nodeEl => {
      const idx = +nodeEl.getAttribute('data-node');
      const distVal = dijkstraState ? dijkstraState.distances[idx] : Infinity;
      const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
      const pos = nodePositions[idx];
      label.setAttribute("x", pos.x);
      label.setAttribute("y", pos.y + 38);
      label.setAttribute("text-anchor", "middle");
      label.setAttribute("font-size", "13");
      label.setAttribute("fill", "#f39c12");
      label.setAttribute("class", "dist-label");
      label.style.userSelect = 'none';
      label.textContent = distVal === Infinity ? '∞' : distVal;
      svg.appendChild(label);
    });
  }

  // Run full Dijkstra with animation or step by step
  function runDijkstraAuto() {
    if (!dijkstraState) return;
    controls.runBtn.disabled = true;
    controls.stepBtn.disabled = true;
    controls.resetBtn.disabled = false;

    function step() {
      const res = dijkstraStep(dijkstraState);
      updateNodeColors();
      updateDistanceLabels();

      if (res.done) {
        if (dijkstraState.end !== null) {
          highlightShortestPath(dijkstraState);
          if (res.reachedEnd) {
            log(`Reached end node ${vertexLabel(dijkstraState.end)} with distance ${dijkstraState.distances[dijkstraState.end]}.`);
          } else {
            log(`No path to node ${vertexLabel(dijkstraState.end)} found.`);
          }
        } else {
          log('Algorithm finished. Shortest distances from start node shown.');
        }
        controls.runBtn.disabled = true;
        controls.stepBtn.disabled = true;
        controls.resetBtn.disabled = false;
        animationTimer = null;
        return;
      }
      logStep();
      animationTimer = setTimeout(step, animationDelay);
    }
    step();
  }

  // Log current step information
  function logStep() {
    if (!dijkstraState) return;
    const curr = dijkstraState.current;
    const dist = dijkstraState.distances[curr];
    log(`Processing node ${vertexLabel(curr)}, current distance: ${dist}`, false);
  }

  // Initialize page with default graph setup
  function initializeDefaultGraph() {
    vertexCount = Number(controls.vertexCountInput.value);
    if (isNaN(vertexCount) || vertexCount < MIN_VERTICES || vertexCount > MAX_VERTICES) {
      alert(`Number of vertices must be between ${MIN_VERTICES} and ${MAX_VERTICES}.`);
      return false;
    }
    vertices = [];
    for (let i = 0; i < vertexCount; i++) {
      vertices.push(vertexLabel(i));
    }
    edges.clear();
    // Prepopulate edges with a simple connected graph (ring)
    for (let i = 0; i < vertexCount; i++) {
      const next = (i + 1) % vertexCount;
      edges.set(`${Math.min(i, next)}-${Math.max(i, next)}`, 1 + Math.floor(Math.random() * 10));
    }
    buildAdjacencyList();
    updateVertexSelects();
    renderEdgesList();
    drawGraph();
    controls.graphSetup.style.display = 'block';
    controls.algorithmControls.style.display = 'block';
    controls.logDiv.textContent = '';
    controls.runBtn.disabled = false;
    controls.stepBtn.disabled = true;
    controls.resetBtn.disabled = true;
    dijkstraState = null;
    animationDelay = Number(controls.speedRange.value);
    return true;
  }

  // Reset edges only (clear all edges)
  function resetEdges() {
    edges.clear();
    buildAdjacencyList();
    renderEdgesList();
    drawGraph();
    dijkstraState = null;
    controls.runBtn.disabled = false;
    controls.stepBtn.disabled = true;
    controls.resetBtn.disabled = true;
    controls.logDiv.textContent = '';
    highlightPath(null);
    updateNodeColors();
    updateDistanceLabels();
  }

  // Reset algorithm state only (allow editing graph while preserving vertex count)
  function resetAlgorithm() {
    if (animationTimer) {
      clearTimeout(animationTimer);
      animationTimer = null;
    }
    dijkstraState = null;
    updateNodeColors();
    highlightPath(null);
    updateDistanceLabels();
    controls.logDiv.textContent = '';
    controls.runBtn.disabled = false;
    controls.stepBtn.disabled = true;
    controls.resetBtn.disabled = true;
  }

  // Event Listeners
  controls.createGraphBtn.addEventListener('click', () => {
    if (animationTimer) {
      clearTimeout(animationTimer);
      animationTimer = null;
    }
    if (!initializeDefaultGraph()) return;
  });

  controls.addEdgeBtn.addEventListener('click', () => {
    const u = Number(controls.edgeFromSelect.value);
    const v = Number(controls.edgeToSelect.value);
    const w = Number(controls.edgeWeightInput.value);
    if (addOrUpdateEdge(u, v, w)) {
      buildAdjacencyList();
      drawGraph();
      renderEdgesList();
      resetAlgorithm();
    }
  });

  controls.resetGraphBtn.addEventListener('click', () => {
    if (confirm('Clear all edges?')) {
      resetEdges();
    }
  });

  controls.runBtn.addEventListener('click', () => {
    // Initialize and run
    const start = Number(controls.startNodeSelect.value);
    let end = controls.endNodeSelect.value;
    end = end === '' ? null : Number(end);

    if (start === end) {
      alert('Start and end node must be different or leave end empty.');
      return;
    }
    buildAdjacencyList();
    dijkstraState = dijkstraInit(start, end);
    controls.runBtn.disabled = true;
    controls.stepBtn.disabled = false;
    controls.resetBtn.disabled = false;
    controls.logDiv.textContent = '';
    highlightPath(null);
    updateDistanceLabels();
    updateNodeColors();
    if (animationTimer) {
      clearTimeout(animationTimer);
      animationTimer = null;
    }
    animationDelay = Number(controls.speedRange.value);

    runDijkstraAuto();
  });

  controls.stepBtn.addEventListener('click', () => {
    if (!dijkstraState) return;
    if (dijkstraState.finished) return;
    const res = dijkstraStep(dijkstraState);
    updateNodeColors();
    updateDistanceLabels();
    logStep();
    if (res.done) {
      if (dijkstraState.end !== null) {
        highlightShortestPath(dijkstraState);
        if (res.reachedEnd) {
          log(`Reached end node ${vertexLabel(dijkstraState.end)} with distance ${dijkstraState.distances[dijkstraState.end]}.`);
        } else {
          log(`No path to node ${vertexLabel(dijkstraState.end)} found.`);
        }
      } else {
        log('Algorithm finished. Shortest distances from start node shown.');
      }
      controls.stepBtn.disabled = true;
      controls.runBtn.disabled = true;
    }
  });

  controls.resetBtn.addEventListener('click', () => {
    resetAlgorithm();
  });

  controls.speedRange.addEventListener('input', () => {
    animationDelay = Number(controls.speedRange.value);
  });

  // Initialize default graph on page load
  initializeDefaultGraph();
})();
</script>

</body>
</html>