<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Binary Tree Visualization and Demo</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  h1 {
    text-align: center;
  }
  #treeCanvas {
    border: 1px solid #ccc;
    display: block;
    margin: 20px auto;
    background: #fafafa;
  }
  #controls {
    max-width: 600px;
    margin: 0 auto 40px auto;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
  }
  #nodeValue {
    width: 80px;
    padding: 6px 8px;
    font-size: 16px;
  }
  button {
    padding: 8px 15px;
    font-size: 16px;
    cursor: pointer;
  }
  #output {
    max-width: 600px;
    margin: 0 auto;
    font-family: monospace;
    background: #eee;
    padding: 15px;
    border-radius: 8px;
    white-space: pre-wrap;
    min-height: 80px;
  }
  .section-title {
    text-align: center;
    margin-top: 40px;
    margin-bottom: 10px;
  }
</style>
</head>
<body>
<h1>Binary Tree Demo and Visualization</h1>
<div id="controls">
  <input type="number" id="nodeValue" placeholder="Node value" />
  <button id="insertBtn">Insert</button>
  <button id="clearBtn">Clear Tree</button>
  <button id="inorderBtn">In-order Traversal</button>
  <button id="preorderBtn">Pre-order Traversal</button>
  <button id="postorderBtn">Post-order Traversal</button>
  <button id="levelorderBtn">Level-order Traversal</button>
</div>

<canvas id="treeCanvas" width="800" height="400"></canvas>

<h3 class="section-title">Traversal Output:</h3>
<div id="output">(Press traversal buttons to see output here)</div>

<script>
  class Node {
    constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
      // Positions for drawing
      this.x = 0;
      this.y = 0;
    }
  }

  class BinaryTree {
    constructor() {
      this.root = null;
    }

    insert(value) {
      if (this.root === null) {
        this.root = new Node(value);
        return true;
      }
      return this._insertNode(this.root, value);
    }

    _insertNode(current, value) {
      if (value === current.value) {
        // Do not allow duplicates
        return false;
      } else if (value < current.value) {
        if (current.left === null) {
          current.left = new Node(value);
          return true;
        }
        return this._insertNode(current.left, value);
      } else {
        if (current.right === null) {
          current.right = new Node(value);
          return true;
        }
        return this._insertNode(current.right, value);
      }
    }

    clear() {
      this.root = null;
    }

    inorder() {
      const result = [];
      function traverse(node) {
        if (!node) return;
        traverse(node.left);
        result.push(node.value);
        traverse(node.right);
      }
      traverse(this.root);
      return result;
    }

    preorder() {
      const result = [];
      function traverse(node) {
        if (!node) return;
        result.push(node.value);
        traverse(node.left);
        traverse(node.right);
      }
      traverse(this.root);
      return result;
    }

    postorder() {
      const result = [];
      function traverse(node) {
        if (!node) return;
        traverse(node.left);
        traverse(node.right);
        result.push(node.value);
      }
      traverse(this.root);
      return result;
    }

    levelorder() {
      const result = [];
      const queue = [];
      if (this.root !== null) queue.push(this.root);
      while (queue.length > 0) {
        let node = queue.shift();
        result.push(node.value);
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
      }
      return result;
    }
  }

  const canvas = document.getElementById('treeCanvas');
  const ctx = canvas.getContext('2d');

  // Settings for drawing
  const nodeRadius = 20;
  const verticalSpacing = 70;
  const horizontalSpacing = 40;

  // Calculate positions for nodes before drawing
  function calculateNodePositions(root, width) {
    const levels = [];

    // First, do an inorder traversal to get horizontal order of nodes
    const nodesInOrder = [];
    function inorderPosition(node, depth) {
      if (!node) return;
      if (levels[depth] === undefined) levels[depth] = [];
      inorderPosition(node.left, depth + 1);
      levels[depth].push(node);
      nodesInOrder.push(node);
      inorderPosition(node.right, depth + 1);
    }
    inorderPosition(root, 0);

    // Assign x positions in inorder indexing for each node
    // We'll assign x indexes as increasing numbers from left to right
    // then translate to pixel positions

    // We can assign x by inorder index:
    // Let's build a map from node to its inorder index

    const inorderIndices = new Map();
    nodesInOrder.forEach((node, idx) => {
      inorderIndices.set(node, idx);
    });

    // Determine canvas width limits for x based on number of nodes
    // Spread nodes evenly across width with padding
    const totalNodes = nodesInOrder.length;
    let xStep = (width - 2 * nodeRadius) / (totalNodes - 1 || 1);

    // Assign positions
    nodesInOrder.forEach(node => {
      node.x = nodeRadius + inorderIndices.get(node) * xStep;
    });

    // Assign y position based on depth
    function assignY(node, depth) {
      if (!node) return;
      node.y = nodeRadius + depth * verticalSpacing;
      assignY(node.left, depth + 1);
      assignY(node.right, depth + 1);
    }
    assignY(root, 0);
  }

  function drawTree(tree) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!tree.root) return;

    calculateNodePositions(tree.root, canvas.width);

    // Draw edges (lines between nodes)
    function drawEdges(node) {
      if (!node) return;
      if (node.left) {
        drawLine(node.x, node.y, node.left.x, node.left.y);
        drawEdges(node.left);
      }
      if (node.right) {
        drawLine(node.x, node.y, node.right.x, node.right.y);
        drawEdges(node.right);
      }
    }
    function drawLine(x1, y1, x2, y2) {
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    drawEdges(tree.root);

    // Draw nodes (circles with values)
    function drawNode(node) {
      if (!node) return;
      // Draw circle
      ctx.fillStyle = '#1976d2';
      ctx.strokeStyle = '#0d47a1';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Draw text
      ctx.fillStyle = "white";
      ctx.font = "bold 16px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(node.value, node.x, node.y);

      drawNode(node.left);
      drawNode(node.right);
    }

    drawNode(tree.root);
  }

  // Main program logic
  const tree = new BinaryTree();
  const nodeValueInput = document.getElementById('nodeValue');
  const insertBtn = document.getElementById('insertBtn');
  const clearBtn = document.getElementById('clearBtn');
  const inorderBtn = document.getElementById('inorderBtn');
  const preorderBtn = document.getElementById('preorderBtn');
  const postorderBtn = document.getElementById('postorderBtn');
  const levelorderBtn = document.getElementById('levelorderBtn');
  const outputDiv = document.getElementById('output');

  insertBtn.addEventListener('click', () => {
    const val = parseInt(nodeValueInput.value, 10);
    if (isNaN(val)) {
      alert('Please enter a valid number.');
      return;
    }
    const inserted = tree.insert(val);
    if (!inserted) {
      alert('Duplicate values are not allowed.');
    } else {
      drawTree(tree);
      outputDiv.textContent = `Inserted value: ${val}`;
    }
    nodeValueInput.value = '';
    nodeValueInput.focus();
  });

  clearBtn.addEventListener('click', () => {
    tree.clear();
    drawTree(tree);
    outputDiv.textContent = 'Tree cleared.';
    nodeValueInput.focus();
  });

  inorderBtn.addEventListener('click', () => {
    const traversal = tree.inorder();
    outputDiv.textContent = 'In-order: ' + (traversal.length ? traversal.join(', ') : '(empty)');
  });

  preorderBtn.addEventListener('click', () => {
    const traversal = tree.preorder();
    outputDiv.textContent = 'Pre-order: ' + (traversal.length ? traversal.join(', ') : '(empty)');
  });

  postorderBtn.addEventListener('click', () => {
    const traversal = tree.postorder();
    outputDiv.textContent = 'Post-order: ' + (traversal.length ? traversal.join(', ') : '(empty)');
  });

  levelorderBtn.addEventListener('click', () => {
    const traversal = tree.levelorder();
    outputDiv.textContent = 'Level-order: ' + (traversal.length ? traversal.join(', ') : '(empty)');
  });

  // Initial draw: empty
  drawTree(tree);
</script>
</body>
</html>